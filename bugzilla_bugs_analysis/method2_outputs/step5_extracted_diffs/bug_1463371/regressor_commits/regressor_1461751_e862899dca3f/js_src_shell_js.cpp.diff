# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/shell/js.cpp
# Commit: e862899dca3f
# Full Hash: e862899dca3f252a8fe3c7be10d83d79dad328c5
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2018-05-16 18:32:17
# Regressor Bug: 1461751
# File Overlap Count: 2
# Description:
#   Bug 1461751 - Simplify module resolve hook to be a function pointer r=luke r=baku
# ==============================================================================

diff -r 1076e77e7b5c -r e862899dca3f js/src/shell/js.cpp
--- a/js/src/shell/js.cpp	Tue Apr 24 16:19:51 2018 +0200
+++ b/js/src/shell/js.cpp	Wed May 16 11:59:09 2018 +0100
@@ -610,7 +610,8 @@
     readLineBufPos(0),
     errFilePtr(nullptr),
     outFilePtr(nullptr),
-    offThreadMonitor(mutexid::ShellOffThreadState)
+    offThreadMonitor(mutexid::ShellOffThreadState),
+    moduleResolveHook(cx)
 {}
 
 ShellContext::~ShellContext()
@@ -868,6 +869,7 @@
 static bool
 InitModuleLoader(JSContext* cx)
 {
+
     // Decompress and evaluate the embedded module loader source to initialize
     // the module loader for the current compartment.
 
@@ -4280,13 +4282,34 @@
         return false;
     }
 
-    RootedFunction hook(cx, &args[0].toObject().as<JSFunction>());
-    Rooted<GlobalObject*> global(cx, cx->global());
-    global->setModuleResolveHook(hook);
+    ShellContext* sc = GetShellContext(cx);
+    sc->moduleResolveHook = &args[0].toObject().as<JSFunction>();
+
     args.rval().setUndefined();
     return true;
 }
 
+static JSObject*
+CallModuleResolveHook(JSContext* cx, HandleObject module, HandleString specifier)
+{
+    ShellContext* sc = GetShellContext(cx);
+
+    JS::AutoValueArray<2> args(cx);
+    args[0].setObject(*module);
+    args[1].setString(specifier);
+
+    RootedValue result(cx);
+    if (!JS_CallFunction(cx, nullptr, sc->moduleResolveHook, args, &result))
+        return nullptr;
+
+    if (!result.isObject() || !result.toObject().is<ModuleObject>()) {
+         JS_ReportErrorASCII(cx, "Module resolve hook did not return Module object");
+         return nullptr;
+    }
+
+    return &result.toObject();
+}
+
 static bool
 GetModuleLoadPath(JSContext* cx, unsigned argc, Value* vp)
 {
@@ -9298,6 +9321,8 @@
 
     js::SetPreserveWrapperCallback(cx, DummyPreserveWrapperCallback);
 
+    JS::SetModuleResolveHook(cx->runtime(), CallModuleResolveHook);
+
     result = Shell(cx, &op, envp);
 
 #ifdef DEBUG