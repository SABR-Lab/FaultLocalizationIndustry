# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/src/XPCConvert.cpp
# Commit: b3c093b141e2
# Full Hash: b3c093b141e2381efef699124f8a629d0711c8c6
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2018-08-07 15:42:55
# Regressor Bug: 1478359
# File Overlap Count: 2
# Description:
#   Bug 1478359 - Store a global object in nsXPCWrappedJS and use it for realm-entering. r=mccr8
#   
#   The problem we're solving here: getting/entering the realm/global of a cross-compartment wrapper doesn't make sense once there are multiple realms in a compartment and the CCW will be shared by all of them. Because nsXPCWrappedJS can store a CCW, we will no longer be able to use this JSObject to enter the target realm.
#   
#   What this patch does: we pass a JSContext* to nsXPCWrappedJS::GetNewOrUsed and we use this to store a global object in nsXPCWrappedJS (with the invariant that the object and global stored in nsXPCWrappedJS are same-compartment). Then when we want to enter the nsXPCWrappedJS's target realm, we use this global object instead of the maybe-CCW object. Because we currently still have one realm per compartment and the objects are same-compartment, this is guaranteed to preserve behavior for now.
# ==============================================================================

diff -r bf6961db9405 -r b3c093b141e2 js/xpconnect/src/XPCConvert.cpp
--- a/js/xpconnect/src/XPCConvert.cpp	Tue Aug 07 12:41:15 2018 +0300
+++ b/js/xpconnect/src/XPCConvert.cpp	Tue Aug 07 11:57:41 2018 +0200
@@ -440,7 +440,8 @@
 
 // static
 bool
-XPCConvert::JSData2Native(void* d, HandleValue s,
+XPCConvert::JSData2Native(JSContext* cx,
+                          void* d, HandleValue s,
                           const nsXPTType& type,
                           const nsID* iid,
                           uint32_t arrlen,
@@ -448,7 +449,8 @@
 {
     MOZ_ASSERT(d, "bad param");
 
-    AutoJSContext cx;
+    js::AssertSameCompartment(cx, s);
+
     if (pErr)
         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
 
@@ -796,7 +798,7 @@
         }
 
         RootedObject src(cx, &s.toObject());
-        return JSObject2NativeInterface((void**)d, src, iid, nullptr, pErr);
+        return JSObject2NativeInterface(cx, (void**)d, src, iid, nullptr, pErr);
     }
 
     case nsXPTType::T_DOMOBJECT:
@@ -1034,7 +1036,8 @@
 
 // static
 bool
-XPCConvert::JSObject2NativeInterface(void** dest, HandleObject src,
+XPCConvert::JSObject2NativeInterface(JSContext* cx,
+                                     void** dest, HandleObject src,
                                      const nsID* iid,
                                      nsISupports* aOuter,
                                      nsresult* pErr)
@@ -1043,6 +1046,8 @@
     MOZ_ASSERT(src, "bad param");
     MOZ_ASSERT(iid, "bad param");
 
+    js::AssertSameCompartment(cx, src);
+
     *dest = nullptr;
      if (pErr)
         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
@@ -1116,7 +1121,7 @@
     }
 
     RefPtr<nsXPCWrappedJS> wrapper;
-    nsresult rv = nsXPCWrappedJS::GetNewOrUsed(src, *iid, getter_AddRefs(wrapper));
+    nsresult rv = nsXPCWrappedJS::GetNewOrUsed(cx, src, *iid, getter_AddRefs(wrapper));
     if (pErr)
         *pErr = rv;
 
@@ -1534,7 +1539,7 @@
     RootedValue current(cx);
     for (uint32_t i = 0; i < length; ++i) {
         if (!JS_GetElement(cx, jsarray, i, &current) ||
-            !JSData2Native(aEltType.ElementPtr(buf, i), current,
+            !JSData2Native(cx, aEltType.ElementPtr(buf, i), current,
                            aEltType, aIID, 0, pErr)) {
             // Array element conversion failed. Clean up all elements converted
             // before the error. Caller handles freeing 'buf'.