# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/src/XPCWrappedJS.cpp
# Commit: b3c093b141e2
# Full Hash: b3c093b141e2381efef699124f8a629d0711c8c6
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2018-08-07 15:42:55
# Regressor Bug: 1478359
# File Overlap Count: 2
# Description:
#   Bug 1478359 - Store a global object in nsXPCWrappedJS and use it for realm-entering. r=mccr8
#   
#   The problem we're solving here: getting/entering the realm/global of a cross-compartment wrapper doesn't make sense once there are multiple realms in a compartment and the CCW will be shared by all of them. Because nsXPCWrappedJS can store a CCW, we will no longer be able to use this JSObject to enter the target realm.
#   
#   What this patch does: we pass a JSContext* to nsXPCWrappedJS::GetNewOrUsed and we use this to store a global object in nsXPCWrappedJS (with the invariant that the object and global stored in nsXPCWrappedJS are same-compartment). Then when we want to enter the nsXPCWrappedJS's target realm, we use this global object instead of the maybe-CCW object. Because we currently still have one realm per compartment and the objects are same-compartment, this is guaranteed to preserve behavior for now.
# ==============================================================================

diff -r bf6961db9405 -r b3c093b141e2 js/xpconnect/src/XPCWrappedJS.cpp
--- a/js/xpconnect/src/XPCWrappedJS.cpp	Tue Aug 07 12:41:15 2018 +0300
+++ b/js/xpconnect/src/XPCWrappedJS.cpp	Tue Aug 07 11:57:41 2018 +0200
@@ -301,6 +301,7 @@
 {
     MOZ_ASSERT(mRefCnt >= 2 && IsValid(), "must be strongly referenced");
     JS::TraceEdge(trc, &mJSObj, "nsXPCWrappedJS::mJSObj");
+    JS::TraceEdge(trc, &mJSObjGlobal, "nsXPCWrappedJS::mJSObjGlobal");
 }
 
 NS_IMETHODIMP
@@ -318,9 +319,16 @@
     return mJSObj;
 }
 
+JSObject*
+nsXPCWrappedJS::GetJSObjectGlobal()
+{
+    return mJSObjGlobal;
+}
+
 // static
 nsresult
-nsXPCWrappedJS::GetNewOrUsed(JS::HandleObject jsObj,
+nsXPCWrappedJS::GetNewOrUsed(JSContext* cx,
+                             JS::HandleObject jsObj,
                              REFNSIID aIID,
                              nsXPCWrappedJS** wrapperResult)
 {
@@ -328,7 +336,7 @@
     MOZ_RELEASE_ASSERT(NS_IsMainThread(),
                        "nsXPCWrappedJS::GetNewOrUsed called off main thread");
 
-    AutoJSContext cx;
+    MOZ_RELEASE_ASSERT(js::GetContextCompartment(cx) == js::GetObjectCompartment(jsObj));
 
     bool allowNonScriptable = mozilla::jsipc::IsWrappedCPOW(jsObj);
     RefPtr<nsXPCWrappedJSClass> clasp = nsXPCWrappedJSClass::GetNewOrUsed(cx, aIID,
@@ -369,13 +377,17 @@
         if (!rootClasp)
             return NS_ERROR_FAILURE;
 
-        root = new nsXPCWrappedJS(cx, rootJSObj, rootClasp, nullptr, &rv);
+        // Note: rootJSObj is never a CCW because GetRootJSObject unwraps. We
+        // also rely on this in nsXPCWrappedJS::UpdateObjectPointerAfterGC.
+        RootedObject global(cx, JS::GetNonCCWObjectGlobal(rootJSObj));
+        root = new nsXPCWrappedJS(cx, rootJSObj, global, rootClasp, nullptr, &rv);
         if (NS_FAILED(rv)) {
             return rv;
         }
     }
 
-    RefPtr<nsXPCWrappedJS> wrapper = new nsXPCWrappedJS(cx, jsObj, clasp, root, &rv);
+    RootedObject global(cx, JS::CurrentGlobalOrNull(cx));
+    RefPtr<nsXPCWrappedJS> wrapper = new nsXPCWrappedJS(cx, jsObj, global, clasp, root, &rv);
     if (NS_FAILED(rv)) {
         return rv;
     }
@@ -385,14 +397,20 @@
 
 nsXPCWrappedJS::nsXPCWrappedJS(JSContext* cx,
                                JSObject* aJSObj,
+                               JSObject* aJSObjGlobal,
                                nsXPCWrappedJSClass* aClass,
                                nsXPCWrappedJS* root,
                                nsresult* rv)
     : mJSObj(aJSObj),
+      mJSObjGlobal(aJSObjGlobal),
       mClass(aClass),
       mRoot(root ? root : this),
       mNext(nullptr)
 {
+    MOZ_ASSERT(JS_IsGlobalObject(aJSObjGlobal));
+    MOZ_RELEASE_ASSERT(js::GetObjectCompartment(aJSObj) ==
+                       js::GetObjectCompartment(aJSObjGlobal));
+
     *rv = InitStub(GetClass()->GetIID());
     // Continue even in the failure case, so that our refcounting/Destroy
     // behavior works correctly.
@@ -503,6 +521,7 @@
         }
 
         mJSObj = nullptr;
+        mJSObjGlobal = nullptr;
     }
 
     if (IsRootWrapper()) {
@@ -640,6 +659,7 @@
     // if we are not currently running an incremental GC.
     MOZ_ASSERT(!IsIncrementalGCInProgress(xpc_GetSafeJSContext()));
     *mJSObj.unsafeGet() = nullptr;
+    *mJSObjGlobal.unsafeGet() = nullptr;
 
     // Notify other wrappers in the chain.
     if (mNext)
@@ -675,7 +695,8 @@
     if (!ccx.IsValid())
         return NS_ERROR_UNEXPECTED;
 
-    return nsXPCWrappedJSClass::BuildPropertyEnumerator(ccx, GetJSObject(),
+    RootedObject scope(cx, GetJSObjectGlobal());
+    return nsXPCWrappedJSClass::BuildPropertyEnumerator(ccx, GetJSObject(), scope,
                                                         aEnumerate);
 }
 
@@ -687,8 +708,9 @@
     if (!ccx.IsValid())
         return NS_ERROR_UNEXPECTED;
 
+    RootedObject scope(cx, GetJSObjectGlobal());
     return nsXPCWrappedJSClass::
-        GetNamedPropertyAsVariant(ccx, GetJSObject(), name, _retval);
+        GetNamedPropertyAsVariant(ccx, GetJSObject(), scope, name, _retval);
 }
 
 /***************************************************************************/