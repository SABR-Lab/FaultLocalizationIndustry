# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/src/XPCWrappedJSClass.cpp
# Commit: b3c093b141e2
# Full Hash: b3c093b141e2381efef699124f8a629d0711c8c6
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2018-08-07 15:42:55
# Regressor Bug: 1478359
# File Overlap Count: 2
# Description:
#   Bug 1478359 - Store a global object in nsXPCWrappedJS and use it for realm-entering. r=mccr8
#   
#   The problem we're solving here: getting/entering the realm/global of a cross-compartment wrapper doesn't make sense once there are multiple realms in a compartment and the CCW will be shared by all of them. Because nsXPCWrappedJS can store a CCW, we will no longer be able to use this JSObject to enter the target realm.
#   
#   What this patch does: we pass a JSContext* to nsXPCWrappedJS::GetNewOrUsed and we use this to store a global object in nsXPCWrappedJS (with the invariant that the object and global stored in nsXPCWrappedJS are same-compartment). Then when we want to enter the nsXPCWrappedJS's target realm, we use this global object instead of the maybe-CCW object. Because we currently still have one realm per compartment and the objects are same-compartment, this is guaranteed to preserve behavior for now.
# ==============================================================================

diff -r bf6961db9405 -r b3c093b141e2 js/xpconnect/src/XPCWrappedJSClass.cpp
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp	Tue Aug 07 12:41:15 2018 +0300
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp	Tue Aug 07 11:57:41 2018 +0200
@@ -181,8 +181,11 @@
 JSObject*
 nsXPCWrappedJSClass::CallQueryInterfaceOnJSObject(JSContext* cx,
                                                   JSObject* jsobjArg,
+                                                  HandleObject scope,
                                                   REFNSIID aIID)
 {
+    js::AssertSameCompartment(scope, jsobjArg);
+
     RootedObject jsobj(cx, jsobjArg);
     JSObject* id;
     RootedValue retval(cx);
@@ -208,7 +211,7 @@
 
     // XXX we should install an error reporter that will send reports to
     // the JS error console service.
-    if (!scriptEval.StartEvaluating(jsobj))
+    if (!scriptEval.StartEvaluating(scope))
         return nullptr;
 
     // check upfront for the existence of the function property
@@ -240,10 +243,6 @@
         return nullptr;
     }
 
-    // AutoScriptEvaluate entered jsobj's realm.
-    js::AssertSameCompartment(cx, jsobj);
-    RootedObject scope(cx, JS::CurrentGlobalOrNull(cx));
-
     if ((id = xpc_NewIDObject(cx, scope, aIID))) {
         // Throwing NS_NOINTERFACE is the prescribed way to fail QI from JS. It
         // is not an exception that is ever worth reporting, but we don't want
@@ -307,7 +306,7 @@
     RootedValue val(ccx);
 
     return JS_GetPropertyById(ccx, aJSObj, aName, &val) &&
-           XPCConvert::JSData2Native(aResult, val, type,
+           XPCConvert::JSData2Native(ccx, aResult, val, type,
                                      &NS_GET_IID(nsIVariant), 0, pErr);
 }
 
@@ -315,6 +314,7 @@
 nsresult
 nsXPCWrappedJSClass::GetNamedPropertyAsVariant(XPCCallContext& ccx,
                                                JSObject* aJSObjArg,
+                                               HandleObject scope,
                                                const nsAString& aName,
                                                nsIVariant** aResult)
 {
@@ -322,7 +322,7 @@
     RootedObject aJSObj(cx, aJSObjArg);
 
     AutoScriptEvaluate scriptEval(cx);
-    if (!scriptEval.StartEvaluating(aJSObj))
+    if (!scriptEval.StartEvaluating(scope))
         return NS_ERROR_FAILURE;
 
     // Wrap the string in a Value after the AutoScriptEvaluate, so that the
@@ -351,6 +351,7 @@
 nsresult
 nsXPCWrappedJSClass::BuildPropertyEnumerator(XPCCallContext& ccx,
                                              JSObject* aJSObjArg,
+                                             HandleObject scope,
                                              nsISimpleEnumerator** aEnumerate)
 {
     JSContext* cx = ccx.GetJSContext();
@@ -497,7 +498,7 @@
     nsCString displayName("anonymous");
     if (funName) {
         RootedValue funNameVal(cx, StringValue(funName));
-        if (!XPCConvert::JSData2Native(&displayName, funNameVal,
+        if (!XPCConvert::JSData2Native(cx, &displayName, funNameVal,
                                        { nsXPTType::T_UTF8STRING },
                                        nullptr, 0, nullptr))
         {
@@ -565,20 +566,20 @@
     }
 
     // We passed the unwrapped object's global to AutoEntryScript so we now need
-    // to enter the (maybe wrapper) object's realm. We will have to revisit this
-    // later because CCWs are not associated with a single realm so this
-    // doesn't make much sense. See bug 1478359.
-    JSAutoRealmAllowCCW ar(aes.cx(), obj);
+    // to enter the realm corresponding with the (maybe wrapper) object.
+    RootedObject objScope(RootingCx(), self->GetJSObjectGlobal());
+    JSAutoRealm ar(aes.cx(), objScope);
 
     // We support nsISupportsWeakReference iff the root wrapped JSObject
     // claims to support it in its QueryInterface implementation.
     if (aIID.Equals(NS_GET_IID(nsISupportsWeakReference))) {
         // We only want to expose one implementation from our aggregate.
         nsXPCWrappedJS* root = self->GetRootWrapper();
+        RootedObject rootScope(ccx, root->GetJSObjectGlobal());
 
         // Fail if JSObject doesn't claim support for nsISupportsWeakReference
         if (!root->IsValid() ||
-            !CallQueryInterfaceOnJSObject(ccx, root->GetJSObject(), aIID)) {
+            !CallQueryInterfaceOnJSObject(ccx, root->GetJSObject(), rootScope, aIID)) {
             *aInstancePtr = nullptr;
             return NS_NOINTERFACE;
         }
@@ -604,7 +605,7 @@
     const nsXPTInterfaceInfo* info = nsXPTInterfaceInfo::ByIID(aIID);
     if (info && info->IsFunction()) {
         RefPtr<nsXPCWrappedJS> wrapper;
-        nsresult rv = nsXPCWrappedJS::GetNewOrUsed(obj, aIID, getter_AddRefs(wrapper));
+        nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, obj, aIID, getter_AddRefs(wrapper));
 
         // Do the same thing we do for the "check for any existing wrapper" case above.
         if (NS_SUCCEEDED(rv) && wrapper) {
@@ -616,7 +617,7 @@
     // else we do the more expensive stuff...
 
     // check if the JSObject claims to implement this interface
-    RootedObject jsobj(ccx, CallQueryInterfaceOnJSObject(ccx, obj, aIID));
+    RootedObject jsobj(ccx, CallQueryInterfaceOnJSObject(ccx, obj, objScope, aIID));
     if (jsobj) {
         // We can't use XPConvert::JSObject2NativeInterface() here
         // since that can find a XPCWrappedNative directly on the
@@ -630,7 +631,8 @@
         // XPConvert::JSObject2NativeInterface() here to make sure we
         // get a new (or used) nsXPCWrappedJS.
         RefPtr<nsXPCWrappedJS> wrapper;
-        nsresult rv = nsXPCWrappedJS::GetNewOrUsed(jsobj, aIID, getter_AddRefs(wrapper));
+        nsresult rv =
+            nsXPCWrappedJS::GetNewOrUsed(ccx, jsobj, aIID, getter_AddRefs(wrapper));
         if (NS_SUCCEEDED(rv) && wrapper) {
             // We need to go through the QueryInterface logic to make
             // this return the right thing for the various 'special'
@@ -659,14 +661,12 @@
 nsXPCWrappedJSClass::GetRootJSObject(JSContext* cx, JSObject* aJSObjArg)
 {
     RootedObject aJSObj(cx, aJSObjArg);
-    JSObject* result = CallQueryInterfaceOnJSObject(cx, aJSObj,
+    RootedObject global(cx, JS::CurrentGlobalOrNull(cx));
+    JSObject* result = CallQueryInterfaceOnJSObject(cx, aJSObj, global,
                                                     NS_GET_IID(nsISupports));
     if (!result)
         result = aJSObj;
-    JSObject* inner = js::UncheckedUnwrap(result);
-    if (inner)
-        return inner;
-    return result;
+    return js::UncheckedUnwrap(result);
 }
 
 bool
@@ -963,10 +963,9 @@
         return NS_ERROR_FAILURE;
 
     // We passed the unwrapped object's global to AutoEntryScript so we now need
-    // to enter the (maybe wrapper) object's realm. We will have to revisit this
-    // later because CCWs are not associated with a single realm so this
-    // doesn't make much sense. See bug 1478359.
-    JSAutoRealmAllowCCW ar(cx, obj);
+    // to enter the realm corresponding with the (maybe wrapper) object.
+    RootedObject scope(cx, wrapper->GetJSObjectGlobal());
+    JSAutoRealm ar(cx, scope);
 
     // [optional_argc] has a different calling convention, which we don't
     // support for JS-implemented components.
@@ -995,7 +994,7 @@
         argc -= 1;
     }
 
-    if (!scriptEval.StartEvaluating(obj))
+    if (!scriptEval.StartEvaluating(scope))
         goto pre_call_clean_up;
 
     xpccx->SetPendingException(nullptr);
@@ -1203,7 +1202,7 @@
         }
 
         MOZ_ASSERT(param.IsIndirect(), "outparams are always indirect");
-        if (!XPCConvert::JSData2Native(nativeParams[i].val.p, val, type,
+        if (!XPCConvert::JSData2Native(cx, nativeParams[i].val.p, val, type,
                                        &param_iid, 0, nullptr))
             break;
     }
@@ -1239,7 +1238,7 @@
                 break;
 
             MOZ_ASSERT(param.IsIndirect(), "outparams are always indirect");
-            if (!XPCConvert::JSData2Native(nativeParams[i].val.p, val, type,
+            if (!XPCConvert::JSData2Native(cx, nativeParams[i].val.p, val, type,
                                            &param_iid, array_count, nullptr))
                 break;
         }