# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderBridgeParent.h
# Commit: 1d3fca2f0721
# Full Hash: 1d3fca2f0721c26585e70fa9aabb9069c99052ec
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-04-05 21:47:45
# Description:
#   Bug 1538572 - Replace mApis nsTArray with RenderRootArray r=sotaro
#   
#   This will allow us to simply do null checks when trying to get
#   an API, which will prevent problems with concurrently accessing
#   an nsTArray.
# ==============================================================================

diff -r dd68a6245f61 -r 1d3fca2f0721 gfx/layers/wr/WebRenderBridgeParent.h
--- a/gfx/layers/wr/WebRenderBridgeParent.h	Fri Apr 05 15:38:13 2019 +0000
+++ b/gfx/layers/wr/WebRenderBridgeParent.h	Fri Apr 05 15:42:50 2019 +0000
@@ -71,11 +71,13 @@
 
   bool CloneWebRenderAPIs(nsTArray<RefPtr<wr::WebRenderAPI>>& aOutAPIs) {
     for (auto& api : mApis) {
-      RefPtr<wr::WebRenderAPI> clone = api->Clone();
-      if (!clone) {
-        return false;
+      if (api) {
+        RefPtr<wr::WebRenderAPI> clone = api->Clone();
+        if (!clone) {
+          return false;
+        }
+        aOutAPIs.AppendElement(clone);
       }
-      aOutAPIs.AppendElement(clone);
     }
     return true;
   }
@@ -83,10 +85,10 @@
       const ScreenPoint& aPoint);
   already_AddRefed<wr::WebRenderAPI> GetWebRenderAPI(
       wr::RenderRoot aRenderRoot) {
-    if ((size_t)aRenderRoot >= mApis.Length()) {
+    if (aRenderRoot > wr::kHighestRenderRoot) {
       return nullptr;
     }
-    return do_AddRef(mApis[(int)aRenderRoot]);
+    return do_AddRef(mApis[aRenderRoot]);
   }
   AsyncImagePipelineManager* AsyncImageManager() { return mAsyncImageManager; }
   CompositorVsyncScheduler* CompositorScheduler() {
@@ -273,10 +275,10 @@
 
   wr::WebRenderAPI* Api(wr::RenderRoot aRenderRoot) {
     if (IsRootWebRenderBridgeParent()) {
-      return mApis[(size_t)aRenderRoot];
+      return mApis[aRenderRoot];
     } else {
       MOZ_ASSERT(aRenderRoot == wr::RenderRoot::Default);
-      return mApis[(size_t)mRenderRoot];
+      return mApis[mRenderRoot];
     }
   }
 
@@ -435,7 +437,14 @@
   CompositorBridgeParentBase* MOZ_NON_OWNING_REF mCompositorBridge;
   wr::PipelineId mPipelineId;
   RefPtr<widget::CompositorWidget> mWidget;
-  nsTArray<RefPtr<wr::WebRenderAPI>> mApis;
+  // The RenderRootArray means there will always be a fixed number of apis,
+  // one for each RenderRoot, even if renderroot splitting isn't enabled.
+  // In this case, the unused apis will be nullptrs. Also, if this is not
+  // the root WebRenderBridgeParent, there should only be one api in this
+  // list. We avoid using a dynamically sized array for this because we
+  // need to be able to null these out in a thread-safe way from
+  // ClearResources, and there's no way to do that with an nsTArray.
+  wr::RenderRootArray<RefPtr<wr::WebRenderAPI>> mApis;
   RefPtr<AsyncImagePipelineManager> mAsyncImageManager;
   RefPtr<CompositorVsyncScheduler> mCompositorScheduler;
   RefPtr<CompositorAnimationStorage> mAnimStorage;
