# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/AsyncImagePipelineManager.cpp
# Commit: 96da9d241051
# Full Hash: 96da9d241051d222bdd693bdb519d058a013b59c
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-23 09:46:24
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 8cefa694f811 -r 96da9d241051 gfx/layers/wr/AsyncImagePipelineManager.cpp
--- a/gfx/layers/wr/AsyncImagePipelineManager.cpp	Fri Mar 22 18:28:31 2019 +0000
+++ b/gfx/layers/wr/AsyncImagePipelineManager.cpp	Fri Mar 22 18:28:42 2019 +0000
@@ -27,6 +27,7 @@
 
 AsyncImagePipelineManager::AsyncImagePipeline::AsyncImagePipeline()
     : mInitialised(false),
+      mRenderRoot(wr::RenderRoot::Default),
       mIsChanged(false),
       mUseExternalImage(false),
       mFilter(wr::ImageRendering::Auto),
@@ -40,13 +41,13 @@
       mRendered(aRendered) {}
 
 AsyncImagePipelineManager::AsyncImagePipelineManager(
-    already_AddRefed<wr::WebRenderAPI>&& aApi)
-    : mApi(aApi),
-      mIdNamespace(mApi->GetNamespace()),
-      mUseTripleBuffering(mApi->GetUseTripleBuffering()),
+    nsTArray<RefPtr<wr::WebRenderAPI>>&& aApis)
+    : mApis(aApis),
+      mIdNamespace(mApis[0]->GetNamespace()),
+      mUseTripleBuffering(mApis[0]->GetUseTripleBuffering()),
       mResourceId(0),
       mAsyncImageEpoch{0},
-      mWillGenerateFrame(false),
+      mWillGenerateFrame{},
       mDestroyed(false),
       mUpdatesLock("UpdatesLock"),
       mUpdatesCount(0) {
@@ -59,22 +60,30 @@
 
 void AsyncImagePipelineManager::Destroy() {
   MOZ_ASSERT(!mDestroyed);
-  mApi = nullptr;
+  mApis.Clear();
   mPipelineTexturesHolders.Clear();
   mDestroyed = true;
 }
 
-void AsyncImagePipelineManager::SetWillGenerateFrame() {
-  MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());
-
-  mWillGenerateFrame = true;
+void AsyncImagePipelineManager::SetWillGenerateFrameAllRenderRoots() {
+  for (auto renderRoot : wr::kRenderRoots) {
+    SetWillGenerateFrame(renderRoot);
+  }
 }
 
-bool AsyncImagePipelineManager::GetAndResetWillGenerateFrame() {
+void AsyncImagePipelineManager::SetWillGenerateFrame(
+    wr::RenderRoot aRenderRoot) {
   MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());
 
-  bool ret = mWillGenerateFrame;
-  mWillGenerateFrame = false;
+  mWillGenerateFrame[aRenderRoot] = true;
+}
+
+bool AsyncImagePipelineManager::GetAndResetWillGenerateFrame(
+    wr::RenderRoot aRenderRoot) {
+  MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());
+
+  bool ret = mWillGenerateFrame[aRenderRoot];
+  mWillGenerateFrame[aRenderRoot] = false;
   return ret;
 }
 
@@ -145,7 +154,8 @@
 }
 
 void AsyncImagePipelineManager::AddAsyncImagePipeline(
-    const wr::PipelineId& aPipelineId, WebRenderImageHost* aImageHost) {
+    const wr::PipelineId& aPipelineId, WebRenderImageHost* aImageHost,
+    wr::RenderRoot aRenderRoot) {
   if (mDestroyed) {
     return;
   }
@@ -154,6 +164,7 @@
 
   MOZ_ASSERT(!mAsyncImagePipelines.Get(id));
   AsyncImagePipeline* holder = new AsyncImagePipeline();
+  holder->mRenderRoot = aRenderRoot;
   holder->mImageHost = aImageHost;
   mAsyncImagePipelines.Put(id, holder);
   AddPipeline(aPipelineId, /* aWrBridge */ nullptr);
@@ -286,7 +297,7 @@
     aPipeline->mWrTextureWrapper->UpdateWebRenderTextureHost(aMaybeFastTxn,
                                                              wrTexture);
     // Ensure frame generation.
-    SetWillGenerateFrame();
+    SetWillGenerateFrame(aPipeline->mRenderRoot);
   } else {
     if (useWrTextureWrapper) {
       aPipeline->mWrTextureWrapper = new WebRenderTextureHostWrapper(this);
@@ -347,8 +358,8 @@
 }
 
 void AsyncImagePipelineManager::ApplyAsyncImagesOfImageBridge(
-    wr::TransactionBuilder& aSceneBuilderTxn,
-    wr::TransactionBuilder& aFastTxn) {
+    wr::RenderRootArray<Maybe<wr::TransactionBuilder>>& aSceneBuilderTxns,
+    wr::RenderRootArray<Maybe<wr::TransactionBuilder>>& aFastTxns) {
   if (mDestroyed || mAsyncImagePipelines.Count() == 0) {
     return;
   }
@@ -364,8 +375,9 @@
     if (!pipeline->mImageHost->GetAsyncRef()) {
       continue;
     }
-    ApplyAsyncImageForPipeline(epoch, pipelineId, pipeline, aSceneBuilderTxn,
-                               aFastTxn);
+    ApplyAsyncImageForPipeline(epoch, pipelineId, pipeline,
+                               *aSceneBuilderTxns[pipeline->mRenderRoot],
+                               *aFastTxns[pipeline->mRenderRoot]);
   }
 }
 
@@ -456,14 +468,15 @@
 
 void AsyncImagePipelineManager::ApplyAsyncImageForPipeline(
     const wr::PipelineId& aPipelineId, wr::TransactionBuilder& aTxn,
-    wr::TransactionBuilder& aTxnForImageBridge) {
+    wr::TransactionBuilder& aTxnForImageBridge, wr::RenderRoot aRenderRoot) {
   AsyncImagePipeline* pipeline =
       mAsyncImagePipelines.Get(wr::AsUint64(aPipelineId));
   if (!pipeline) {
     return;
   }
+  wr::WebRenderAPI* api = mApis[(size_t)pipeline->mRenderRoot];
   wr::TransactionBuilder fastTxn(/* aUseSceneBuilderThread */ false);
-  wr::AutoTransactionSender sender(mApi, &fastTxn);
+  wr::AutoTransactionSender sender(api, &fastTxn);
 
   // Transaction for async image pipeline that uses ImageBridge always need to
   // be non low priority.
@@ -670,11 +683,12 @@
 }
 
 void AsyncImagePipelineManager::ProcessPipelineRemoved(
-    const wr::PipelineId& aPipelineId, const uint64_t aUpdatesCount) {
+    const wr::RemovedPipeline& aRemovedPipeline, const uint64_t aUpdatesCount) {
   if (mDestroyed) {
     return;
   }
-  if (auto entry = mPipelineTexturesHolders.Lookup(wr::AsUint64(aPipelineId))) {
+  if (auto entry = mPipelineTexturesHolders.Lookup(
+          wr::AsUint64(aRemovedPipeline.pipeline_id))) {
     PipelineTexturesHolder* holder = entry.Data();
     if (holder->mDestroyedEpoch.isSome()) {
       while (!holder->mTextureHosts.empty()) {