# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderBridgeParent.cpp
# Commit: 96da9d241051
# Full Hash: 96da9d241051d222bdd693bdb519d058a013b59c
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-23 09:46:24
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 8cefa694f811 -r 96da9d241051 gfx/layers/wr/WebRenderBridgeParent.cpp
--- a/gfx/layers/wr/WebRenderBridgeParent.cpp	Fri Mar 22 18:28:31 2019 +0000
+++ b/gfx/layers/wr/WebRenderBridgeParent.cpp	Fri Mar 22 18:28:42 2019 +0000
@@ -296,13 +296,14 @@
 WebRenderBridgeParent::WebRenderBridgeParent(
     CompositorBridgeParentBase* aCompositorBridge,
     const wr::PipelineId& aPipelineId, widget::CompositorWidget* aWidget,
-    CompositorVsyncScheduler* aScheduler, RefPtr<wr::WebRenderAPI>&& aApi,
+    CompositorVsyncScheduler* aScheduler,
+    nsTArray<RefPtr<wr::WebRenderAPI>>&& aApis,
     RefPtr<AsyncImagePipelineManager>&& aImageMgr,
     RefPtr<CompositorAnimationStorage>&& aAnimStorage, TimeDuration aVsyncRate)
     : mCompositorBridge(aCompositorBridge),
       mPipelineId(aPipelineId),
       mWidget(aWidget),
-      mApi(aApi),
+      mApis(aApis),
       mAsyncImageManager(aImageMgr),
       mCompositorScheduler(aScheduler),
       mAnimStorage(aAnimStorage),
@@ -310,7 +311,9 @@
       mChildLayersObserverEpoch{0},
       mParentLayersObserverEpoch{0},
       mWrEpoch{0},
-      mIdNamespace(aApi->GetNamespace()),
+      mIdNamespace(aApis[0]->GetNamespace()),
+      mRenderRootRectMutex("WebRenderBridgeParent::mRenderRootRectMutex"),
+      mRenderRoot(wr::RenderRoot::Default),
       mPaused(false),
       mDestroyed(false),
       mReceivedDisplayList(false),
@@ -323,6 +326,10 @@
     MOZ_ASSERT(!mCompositorScheduler);
     mCompositorScheduler = new CompositorVsyncScheduler(this, mWidget);
   }
+
+  if (!IsRootWebRenderBridgeParent() && gfxPrefs::WebRenderSplitRenderRoots()) {
+    mRenderRoot = wr::RenderRoot::Content;
+  }
 }
 
 WebRenderBridgeParent::WebRenderBridgeParent(const wr::PipelineId& aPipelineId)
@@ -332,6 +339,8 @@
       mParentLayersObserverEpoch{0},
       mWrEpoch{0},
       mIdNamespace{0},
+      mRenderRootRectMutex("WebRenderBridgeParent::mRenderRootRectMutex"),
+      mRenderRoot(wr::RenderRoot::Default),
       mPaused(false),
       mDestroyed(true),
       mReceivedDisplayList(false),
@@ -726,13 +735,15 @@
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvUpdateResources(
     nsTArray<OpUpdateResource>&& aResourceUpdates,
     nsTArray<RefCountedShmem>&& aSmallShmems,
-    nsTArray<ipc::Shmem>&& aLargeShmems) {
+    nsTArray<ipc::Shmem>&& aLargeShmems, const wr::RenderRoot& aRenderRoot) {
   if (mDestroyed) {
     wr::IpcResourceUpdateQueue::ReleaseShmems(this, aSmallShmems);
     wr::IpcResourceUpdateQueue::ReleaseShmems(this, aLargeShmems);
     return IPC_OK();
   }
 
+  MOZ_RELEASE_ASSERT((size_t)aRenderRoot < mApis.Length());
+
   wr::TransactionBuilder txn;
   txn.SetLowPriority(!IsRootWebRenderBridgeParent());
 
@@ -745,7 +756,7 @@
     return IPC_FAIL(this, "Invalid WebRender resource data shmem or address.");
   }
 
-  mApi->SendTransaction(txn);
+  Api(aRenderRoot)->SendTransaction(txn);
 
   return IPC_OK();
 }
@@ -828,33 +839,40 @@
   }
   LayersId rootLayersId = cbp->RootLayerTreeId();
   if (RefPtr<APZUpdater> apz = cbp->GetAPZUpdater()) {
-    apz->UpdateFocusState(rootLayersId, GetLayersId(), aFocus);
+    apz->UpdateFocusState(rootLayersId, WRRootId(GetLayersId(), mRenderRoot),
+                          aFocus);
   }
 }
 
 void WebRenderBridgeParent::UpdateAPZScrollData(const wr::Epoch& aEpoch,
-                                                WebRenderScrollData&& aData) {
+                                                WebRenderScrollData&& aData,
+                                                wr::RenderRoot aRenderRoot) {
   CompositorBridgeParent* cbp = GetRootCompositorBridgeParent();
   if (!cbp) {
     return;
   }
   LayersId rootLayersId = cbp->RootLayerTreeId();
   if (RefPtr<APZUpdater> apz = cbp->GetAPZUpdater()) {
-    apz->UpdateScrollDataAndTreeState(rootLayersId, GetLayersId(), aEpoch,
-                                      std::move(aData));
+    apz->UpdateScrollDataAndTreeState(
+        WRRootId(rootLayersId, wr::RenderRoot::Default),
+        WRRootId(GetLayersId(), RenderRootForExternal(aRenderRoot)), aEpoch,
+        std::move(aData));
   }
 }
 
 void WebRenderBridgeParent::UpdateAPZScrollOffsets(
-    ScrollUpdatesMap&& aUpdates, uint32_t aPaintSequenceNumber) {
+    ScrollUpdatesMap&& aUpdates, uint32_t aPaintSequenceNumber,
+    wr::RenderRoot aRenderRoot) {
   CompositorBridgeParent* cbp = GetRootCompositorBridgeParent();
   if (!cbp) {
     return;
   }
   LayersId rootLayersId = cbp->RootLayerTreeId();
   if (RefPtr<APZUpdater> apz = cbp->GetAPZUpdater()) {
-    apz->UpdateScrollOffsets(rootLayersId, GetLayersId(), std::move(aUpdates),
-                             aPaintSequenceNumber);
+    apz->UpdateScrollOffsets(
+        WRRootId(rootLayersId, wr::RenderRoot::Default),
+        WRRootId(GetLayersId(), RenderRootForExternal(aRenderRoot)),
+        std::move(aUpdates), aPaintSequenceNumber);
   }
 }
 
@@ -876,16 +894,79 @@
   }
 }
 
+bool WebRenderBridgeParent::SetDisplayList(
+    wr::RenderRoot aRenderRoot, const gfx::IntRect& aRect,
+    const nsTArray<WebRenderParentCommand>& aCommands,
+    const wr::LayoutSize& aContentSize, ipc::ByteBuf&& aDL,
+    const wr::BuiltDisplayListDescriptor& aDLDesc,
+    const nsTArray<OpUpdateResource>& aResourceUpdates,
+    const nsTArray<RefCountedShmem>& aSmallShmems,
+    const nsTArray<ipc::Shmem>& aLargeShmems, const TimeStamp& aTxnStartTime,
+    wr::TransactionBuilder& aTxn, Maybe<wr::AutoTransactionSender>& aTxnSender,
+    wr::Epoch aWrEpoch, bool aValidTransaction, bool aObserveLayersUpdate) {
+  wr::WebRenderAPI* api = Api(aRenderRoot);
+  aTxn.SetLowPriority(!IsRootWebRenderBridgeParent());
+  if (aValidTransaction) {
+    aTxnSender.emplace(api, &aTxn);
+  }
+
+  if (NS_WARN_IF(
+          !ProcessWebRenderParentCommands(aCommands, aTxn, aRenderRoot))) {
+    return false;
+  }
+
+  if (NS_WARN_IF(!UpdateResources(aResourceUpdates, aSmallShmems, aLargeShmems,
+                                  aTxn))) {
+    return false;
+  }
+
+  wr::Vec<uint8_t> dlData(std::move(aDL));
+
+  if (aValidTransaction) {
+    if (IsRootWebRenderBridgeParent()) {
+      if (aRenderRoot != wr::RenderRoot::Default) {
+        MutexAutoLock lock(mRenderRootRectMutex);
+        mRenderRootRects[aRenderRoot] = aRect;
+      }
+      LayoutDeviceIntSize widgetSize = mWidget->GetClientSize();
+      LayoutDeviceIntRect rect = LayoutDeviceIntRect::FromUnknownRect(aRect);
+      rect.SetWidth(
+          std::max(0, std::min(widgetSize.width - rect.X(), rect.Width())));
+      rect.SetHeight(
+          std::max(0, std::min(widgetSize.height - rect.Y(), rect.Height())));
+      aTxn.SetDocumentView(rect, widgetSize);
+    }
+    gfx::Color clearColor(0.f, 0.f, 0.f, 0.f);
+    aTxn.SetDisplayList(clearColor, aWrEpoch,
+                        LayerSize(aRect.width, aRect.height), mPipelineId,
+                        aContentSize, aDLDesc, dlData);
+
+    if (aObserveLayersUpdate) {
+      aTxn.Notify(wr::Checkpoint::SceneBuilt,
+                  MakeUnique<ScheduleObserveLayersUpdate>(
+                      mCompositorBridge, GetLayersId(),
+                      mChildLayersObserverEpoch, true));
+    }
+
+    if (!IsRootWebRenderBridgeParent()) {
+      aTxn.Notify(
+          wr::Checkpoint::SceneBuilt,
+          MakeUnique<SceneBuiltNotification>(this, aWrEpoch, aTxnStartTime));
+    }
+
+    api->SendTransaction(aTxn);
+
+    // We will schedule generating a frame after the scene
+    // build is done, so we don't need to do it here.
+  }
+
+  return true;
+}
+
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvSetDisplayList(
-    const gfx::IntSize& aSize,
-    InfallibleTArray<WebRenderParentCommand>&& aCommands,
+    nsTArray<RenderRootDisplayListData>&& aDisplayLists,
     InfallibleTArray<OpDestroy>&& aToDestroy, const uint64_t& aFwdTransactionId,
-    const TransactionId& aTransactionId, const wr::LayoutSize& aContentSize,
-    ipc::ByteBuf&& dl, const wr::BuiltDisplayListDescriptor& dlDesc,
-    const WebRenderScrollData& aScrollData,
-    nsTArray<OpUpdateResource>&& aResourceUpdates,
-    nsTArray<RefCountedShmem>&& aSmallShmems,
-    nsTArray<ipc::Shmem>&& aLargeShmems, const wr::IdNamespace& aIdNamespace,
+    const TransactionId& aTransactionId, const wr::IdNamespace& aIdNamespace,
     const bool& aContainsSVGGroup, const VsyncId& aVsyncId,
     const TimeStamp& aVsyncStartTime, const TimeStamp& aRefreshStartTime,
     const TimeStamp& aTxnStartTime, const nsCString& aTxnURL,
@@ -897,6 +978,15 @@
     return IPC_OK();
   }
 
+  // Guard against malicious content processes
+  MOZ_RELEASE_ASSERT(aDisplayLists.Length() > 0);
+  for (auto& displayList : aDisplayLists) {
+    // mApis.Length() should be the lowest possible length of things that we
+    // will be indexing via a RenderRoot, so it should be sufficient to check
+    // just that.
+    MOZ_RELEASE_ASSERT((size_t)displayList.mRenderRoot < mApis.Length());
+  }
+
   if (!IsRootWebRenderBridgeParent()) {
     CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::URL, aTxnURL);
   }
@@ -913,29 +1003,19 @@
 
   mAsyncImageManager->SetCompositionTime(TimeStamp::Now());
 
-  // If id namespaces do not match, it means the command is obsolete, probably
-  // because the tab just moved to a new window.
-  // In that case do not send the commands to webrender.
-  bool validTransaction = aIdNamespace == mIdNamespace;
-  wr::TransactionBuilder txn;
-  txn.SetLowPriority(!IsRootWebRenderBridgeParent());
-  Maybe<wr::AutoTransactionSender> sender;
-  if (validTransaction) {
-    sender.emplace(mApi, &txn);
-  }
+  mReceivedDisplayList = true;
+  bool observeLayersUpdate = ShouldParentObserveEpoch();
 
-  if (!ProcessWebRenderParentCommands(aCommands, txn)) {
-    return IPC_FAIL(this, "Invalid parent command found");
+  // The IsFirstPaint() flag should be the same for all the scrolldata across
+  // all the renderroot display lists in a given transaction. We assert this
+  // below. So we can read the flag from any one of them.
+  if (aDisplayLists[0].mScrollData.IsFirstPaint()) {
+    mIsFirstPaint = true;
   }
-
-  if (!UpdateResources(aResourceUpdates, aSmallShmems, aLargeShmems, txn)) {
-    return IPC_FAIL(this, "Failed to deserialize resource updates");
-  }
-
-  mReceivedDisplayList = true;
-
-  if (aScrollData.IsFirstPaint()) {
-    mIsFirstPaint = true;
+  for (size_t i = 1; i < aDisplayLists.Length(); i++) {
+    // Ensure the flag is the same on all of them.
+    MOZ_RELEASE_ASSERT(aDisplayLists[i].mScrollData.IsFirstPaint() ==
+                       aDisplayLists[0].mScrollData.IsFirstPaint());
   }
 
   // aScrollData is moved into this function but that is not reflected by the
@@ -945,41 +1025,30 @@
   // Also note that this needs to happen before the display list transaction is
   // sent to WebRender, so that the UpdateHitTestingTree call is guaranteed to
   // be in the updater queue at the time that the scene swap completes.
-  UpdateAPZScrollData(wrEpoch,
-                      std::move(const_cast<WebRenderScrollData&>(aScrollData)));
-
-  wr::Vec<uint8_t> dlData(std::move(dl));
-
-  bool observeLayersUpdate = ShouldParentObserveEpoch();
+  for (auto& displayList : aDisplayLists) {
+    UpdateAPZScrollData(wrEpoch, std::move(displayList.mScrollData),
+                        displayList.mRenderRoot);
+  }
 
-  if (validTransaction) {
-    if (IsRootWebRenderBridgeParent()) {
-      LayoutDeviceIntSize widgetSize = mWidget->GetClientSize();
-      LayoutDeviceIntRect docRect(LayoutDeviceIntPoint(), widgetSize);
-      txn.SetDocumentView(docRect);
-    }
-    gfx::Color clearColor(0.f, 0.f, 0.f, 0.f);
-    txn.SetDisplayList(clearColor, wrEpoch,
-                       LayerSize(aSize.width, aSize.height), mPipelineId,
-                       aContentSize, dlDesc, dlData);
+  bool validTransaction = aIdNamespace == mIdNamespace;
 
-    if (observeLayersUpdate) {
-      txn.Notify(wr::Checkpoint::SceneBuilt,
-                 MakeUnique<ScheduleObserveLayersUpdate>(
-                     mCompositorBridge, GetLayersId(),
-                     mChildLayersObserverEpoch, true));
+  wr::RenderRootArray<wr::TransactionBuilder> txns;
+  wr::RenderRootArray<Maybe<wr::AutoTransactionSender>> senders;
+  for (auto& displayList : aDisplayLists) {
+    MOZ_ASSERT(displayList.mRenderRoot == wr::RenderRoot::Default ||
+               IsRootWebRenderBridgeParent());
+    if (!SetDisplayList(
+            displayList.mRenderRoot, displayList.mRect, displayList.mCommands,
+            displayList.mContentSize, std::move(displayList.mDL),
+            displayList.mDLDesc, displayList.mResourceUpdates,
+            displayList.mSmallShmems, displayList.mLargeShmems, aTxnStartTime,
+            txns[displayList.mRenderRoot], senders[displayList.mRenderRoot],
+            wrEpoch, validTransaction, observeLayersUpdate)) {
+      return IPC_FAIL(this, "Failed call to SetDisplayList");
     }
+  }
 
-    if (!IsRootWebRenderBridgeParent()) {
-      txn.Notify(wr::Checkpoint::SceneBuilt, MakeUnique<SceneBuiltNotification>(
-                                                 this, wrEpoch, aTxnStartTime));
-    }
-
-    mApi->SendTransaction(txn);
-
-    // We will schedule generating a frame after the scene
-    // build is done, so we don't need to do it here.
-  } else if (observeLayersUpdate) {
+  if (!validTransaction && observeLayersUpdate) {
     mCompositorBridge->ObserveLayersUpdate(GetLayersId(),
                                            mChildLayersObserverEpoch, true);
   }
@@ -999,20 +1068,19 @@
     }
   }
 
-  wr::IpcResourceUpdateQueue::ReleaseShmems(this, aSmallShmems);
-  wr::IpcResourceUpdateQueue::ReleaseShmems(this, aLargeShmems);
+  for (auto& displayList : aDisplayLists) {
+    wr::IpcResourceUpdateQueue::ReleaseShmems(this, displayList.mSmallShmems);
+    wr::IpcResourceUpdateQueue::ReleaseShmems(this, displayList.mLargeShmems);
+  }
+
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvEmptyTransaction(
-    const FocusTarget& aFocusTarget, const ScrollUpdatesMap& aUpdates,
-    const uint32_t& aPaintSequenceNumber,
-    InfallibleTArray<WebRenderParentCommand>&& aCommands,
+    const FocusTarget& aFocusTarget, const uint32_t& aPaintSequenceNumber,
+    nsTArray<RenderRootUpdates>&& aRenderRootUpdates,
     InfallibleTArray<OpDestroy>&& aToDestroy, const uint64_t& aFwdTransactionId,
-    const TransactionId& aTransactionId,
-    nsTArray<OpUpdateResource>&& aResourceUpdates,
-    nsTArray<RefCountedShmem>&& aSmallShmems,
-    nsTArray<ipc::Shmem>&& aLargeShmems, const wr::IdNamespace& aIdNamespace,
+    const TransactionId& aTransactionId, const wr::IdNamespace& aIdNamespace,
     const VsyncId& aVsyncId, const TimeStamp& aVsyncStartTime,
     const TimeStamp& aRefreshStartTime, const TimeStamp& aTxnStartTime,
     const nsCString& aTxnURL, const TimeStamp& aFwdTime) {
@@ -1023,6 +1091,14 @@
     return IPC_OK();
   }
 
+  // Guard against malicious content processes
+  for (auto& update : aRenderRootUpdates) {
+    // mApis.Length() should be the lowest possible length of things that we
+    // will be indexing via a RenderRoot, so it should be sufficient to check
+    // just that.
+    MOZ_RELEASE_ASSERT((size_t)update.mRenderRoot < mApis.Length());
+  }
+
   if (!IsRootWebRenderBridgeParent()) {
     CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::URL, aTxnURL);
   }
@@ -1035,89 +1111,117 @@
   AutoWebRenderBridgeParentAsyncMessageSender autoAsyncMessageSender(
       this, &aToDestroy);
 
-  bool scheduleComposite = false;
+  wr::RenderRootArray<bool> scheduleComposite(false);
 
   UpdateAPZFocusState(aFocusTarget);
-  if (!aUpdates.empty()) {
-    // aUpdates is moved into this function but that is not reflected by the
-    // function signature due to the way the IPDL generator works. We remove the
-    // const so that we can move this structure all the way to the desired
-    // destination.
-    UpdateAPZScrollOffsets(std::move(const_cast<ScrollUpdatesMap&>(aUpdates)),
-                           aPaintSequenceNumber);
+
+  wr::RenderRootArray<Maybe<wr::TransactionBuilder>> txns;
+  for (auto& update : aRenderRootUpdates) {
+    MOZ_ASSERT(update.mRenderRoot == wr::RenderRoot::Default ||
+               IsRootWebRenderBridgeParent());
+
+    if (!update.mScrollUpdates.empty()) {
+      UpdateAPZScrollOffsets(std::move(update.mScrollUpdates),
+                             aPaintSequenceNumber, update.mRenderRoot);
+    }
+
+    txns[update.mRenderRoot].emplace();
+    txns[update.mRenderRoot]->SetLowPriority(!IsRootWebRenderBridgeParent());
   }
 
-  wr::TransactionBuilder txn;
-  txn.SetLowPriority(!IsRootWebRenderBridgeParent());
-
   // Update WrEpoch for UpdateResources() and ProcessWebRenderParentCommands().
   // WrEpoch is used to manage ExternalImages lifetimes in
   // AsyncImagePipelineManager.
   Unused << GetNextWrEpoch();
 
-  if (!UpdateResources(aResourceUpdates, aSmallShmems, aLargeShmems, txn)) {
-    return IPC_FAIL(this, "Failed to deserialize resource updates");
-  }
-
-  if (!aCommands.IsEmpty()) {
-    mAsyncImageManager->SetCompositionTime(TimeStamp::Now());
-    if (!ProcessWebRenderParentCommands(aCommands, txn)) {
-      return IPC_FAIL(this, "Invalid parent command found");
+  for (auto& update : aRenderRootUpdates) {
+    if (!UpdateResources(update.mResourceUpdates, update.mSmallShmems,
+                         update.mLargeShmems, *txns[update.mRenderRoot])) {
+      return IPC_FAIL(this, "Failed to deserialize resource updates");
     }
   }
 
-  if (ShouldParentObserveEpoch()) {
-    txn.Notify(
-        wr::Checkpoint::SceneBuilt,
-        MakeUnique<ScheduleObserveLayersUpdate>(
-            mCompositorBridge, GetLayersId(), mChildLayersObserverEpoch, true));
+  bool compositionTimeSet = false;
+  for (auto& update : aRenderRootUpdates) {
+    if (!update.mCommands.IsEmpty()) {
+      if (!compositionTimeSet) {
+        mAsyncImageManager->SetCompositionTime(TimeStamp::Now());
+        compositionTimeSet = true;
+      }
+      if (!ProcessWebRenderParentCommands(update.mCommands,
+                                          *txns[update.mRenderRoot],
+                                          update.mRenderRoot)) {
+        return IPC_FAIL(this, "Invalid parent command found");
+      }
+    }
+
+    if (ShouldParentObserveEpoch()) {
+      txns[update.mRenderRoot]->Notify(wr::Checkpoint::SceneBuilt,
+                                       MakeUnique<ScheduleObserveLayersUpdate>(
+                                           mCompositorBridge, GetLayersId(),
+                                           mChildLayersObserverEpoch, true));
+    }
   }
 
-  // Even when txn.IsResourceUpdatesEmpty() is true, there could be resource
-  // updates. It is handled by WebRenderTextureHostWrapper. In this case
-  // txn.IsRenderedFrameInvalidated() becomes true.
-  if (txn.IsResourceUpdatesEmpty() && !txn.IsRenderedFrameInvalidated()) {
+  bool rollbackEpoch = true;
+  for (auto& update : aRenderRootUpdates) {
+    auto& txn = *txns[update.mRenderRoot];
+
+    // Even when txn.IsResourceUpdatesEmpty() is true, there could be resource
+    // updates. It is handled by WebRenderTextureHostWrapper. In this case
+    // txn.IsRenderedFrameInvalidated() becomes true.
+    if (!txn.IsResourceUpdatesEmpty() || txn.IsRenderedFrameInvalidated()) {
+      // There are resource updates, then we update Epoch of transaction.
+      txn.UpdateEpoch(mPipelineId, mWrEpoch);
+      scheduleComposite[update.mRenderRoot] = true;
+      rollbackEpoch = false;
+    }
+  }
+  if (rollbackEpoch) {
     // If TransactionBuilder does not have resource updates nor display list,
     // ScheduleGenerateFrame is not triggered via SceneBuilder and there is no
     // need to update WrEpoch.
     // Then we want to rollback WrEpoch. See Bug 1490117.
     RollbackWrEpoch();
-  } else {
-    // There are resource updates, then we update Epoch of transaction.
-    txn.UpdateEpoch(mPipelineId, mWrEpoch);
-    scheduleComposite = true;
-  }
-
-  if (!txn.IsEmpty()) {
-    mApi->SendTransaction(txn);
   }
 
-  bool sendDidComposite = true;
-  if (scheduleComposite || !mPendingTransactionIds.empty()) {
-    // If we are going to kick off a new composite as a result of this
-    // transaction, or if there are already composite-triggering pending
-    // transactions inflight, then set sendDidComposite to false because we will
-    // send the DidComposite message after the composite occurs.
-    // If there are no pending transactions and we're not going to do a
-    // composite, then we leave sendDidComposite as true so we just send
-    // the DidComposite notification now.
-    sendDidComposite = false;
+  bool scheduleAnyComposite = false;
+
+  for (auto renderRoot : wr::kRenderRoots) {
+    if (txns[renderRoot] && !txns[renderRoot]->IsEmpty()) {
+      Api(renderRoot)->SendTransaction(*txns[renderRoot]);
+    }
+    if (scheduleComposite[renderRoot]) {
+      scheduleAnyComposite = true;
+    }
   }
 
+  // If we are going to kick off a new composite as a result of this
+  // transaction, or if there are already composite-triggering pending
+  // transactions inflight, then set sendDidComposite to false because we will
+  // send the DidComposite message after the composite occurs.
+  // If there are no pending transactions and we're not going to do a
+  // composite, then we leave sendDidComposite as true so we just send
+  // the DidComposite notification now.
+  bool sendDidComposite =
+      !scheduleAnyComposite && mPendingTransactionIds.empty();
+
   // Only register a value for CONTENT_FRAME_TIME telemetry if we actually drew
   // something. It is for consistency with disabling WebRender.
   HoldPendingTransactionId(mWrEpoch, aTransactionId, false, aVsyncId,
                            aVsyncStartTime, aRefreshStartTime, aTxnStartTime,
                            aTxnURL, aFwdTime,
                            /* aIsFirstPaint */ false,
-                           /* aUseForTelemetry */ scheduleComposite);
+                           /* aUseForTelemetry */ scheduleAnyComposite);
 
-  if (scheduleComposite) {
-    // This is actually not necessary, since ScheduleGenerateFrame() is
-    // triggered via SceneBuilder thread. But if we remove it, it causes talos
-    // regression. The SceneBuilder thread seems not trigger next vsync right
-    // away. For now, we call ScheduleGenerateFrame() here.
-    ScheduleGenerateFrame();
+  for (auto renderRoot : wr::kRenderRoots) {
+    if (scheduleComposite[renderRoot]) {
+      mAsyncImageManager->SetWillGenerateFrame(renderRoot);
+    }
+  }
+
+  if (scheduleAnyComposite) {
+    ScheduleGenerateFrame(Nothing());
   } else if (sendDidComposite) {
     // The only thing in the pending transaction id queue should be the entry
     // we just added, and now we're going to pretend we rendered it
@@ -1129,8 +1233,10 @@
     }
   }
 
-  wr::IpcResourceUpdateQueue::ReleaseShmems(this, aSmallShmems);
-  wr::IpcResourceUpdateQueue::ReleaseShmems(this, aLargeShmems);
+  for (auto& update : aRenderRootUpdates) {
+    wr::IpcResourceUpdateQueue::ReleaseShmems(this, update.mSmallShmems);
+    wr::IpcResourceUpdateQueue::ReleaseShmems(this, update.mLargeShmems);
+  }
   return IPC_OK();
 }
 
@@ -1141,26 +1247,28 @@
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvParentCommands(
-    nsTArray<WebRenderParentCommand>&& aCommands) {
+    nsTArray<WebRenderParentCommand>&& aCommands,
+    const wr::RenderRoot& aRenderRoot) {
   if (mDestroyed) {
     return IPC_OK();
   }
   wr::TransactionBuilder txn;
   txn.SetLowPriority(!IsRootWebRenderBridgeParent());
-  if (!ProcessWebRenderParentCommands(aCommands, txn)) {
+  if (!ProcessWebRenderParentCommands(aCommands, txn, aRenderRoot)) {
     return IPC_FAIL(this, "Invalid parent command found");
   }
-  mApi->SendTransaction(txn);
+
+  Api(aRenderRoot)->SendTransaction(txn);
   return IPC_OK();
 }
 
 bool WebRenderBridgeParent::ProcessWebRenderParentCommands(
     const InfallibleTArray<WebRenderParentCommand>& aCommands,
-    wr::TransactionBuilder& aTxn) {
+    wr::TransactionBuilder& aTxn, wr::RenderRoot aRenderRoot) {
   // Transaction for async image pipeline that uses ImageBridge always need to
   // be non low priority.
   wr::TransactionBuilder txnForImageBridge;
-  wr::AutoTransactionSender sender(mApi, &txnForImageBridge);
+  wr::AutoTransactionSender sender(Api(aRenderRoot), &txnForImageBridge);
 
   for (InfallibleTArray<WebRenderParentCommand>::index_type i = 0;
        i < aCommands.Length(); ++i) {
@@ -1170,13 +1278,13 @@
         const OpAddPipelineIdForCompositable& op =
             cmd.get_OpAddPipelineIdForCompositable();
         AddPipelineIdForCompositable(op.pipelineId(), op.handle(), op.isAsync(),
-                                     aTxn, txnForImageBridge);
+                                     aTxn, txnForImageBridge, aRenderRoot);
         break;
       }
       case WebRenderParentCommand::TOpRemovePipelineIdForCompositable: {
         const OpRemovePipelineIdForCompositable& op =
             cmd.get_OpRemovePipelineIdForCompositable();
-        RemovePipelineIdForCompositable(op.pipelineId(), aTxn);
+        RemovePipelineIdForCompositable(op.pipelineId(), aTxn, aRenderRoot);
         break;
       }
       case WebRenderParentCommand::TOpReleaseTextureOfImage: {
@@ -1190,15 +1298,17 @@
         mAsyncImageManager->UpdateAsyncImagePipeline(
             op.pipelineId(), op.scBounds(), op.scTransform(), op.scaleToSize(),
             op.filter(), op.mixBlendMode());
-        mAsyncImageManager->ApplyAsyncImageForPipeline(op.pipelineId(), aTxn,
-                                                       txnForImageBridge);
+        mAsyncImageManager->ApplyAsyncImageForPipeline(
+            op.pipelineId(), aTxn, txnForImageBridge,
+            RenderRootForExternal(aRenderRoot));
         break;
       }
       case WebRenderParentCommand::TOpUpdatedAsyncImagePipeline: {
         const OpUpdatedAsyncImagePipeline& op =
             cmd.get_OpUpdatedAsyncImagePipeline();
-        mAsyncImageManager->ApplyAsyncImageForPipeline(op.pipelineId(), aTxn,
-                                                       txnForImageBridge);
+        mAsyncImageManager->ApplyAsyncImageForPipeline(
+            op.pipelineId(), aTxn, txnForImageBridge,
+            RenderRootForExternal(aRenderRoot));
         break;
       }
       case WebRenderParentCommand::TCompositableOperation: {
@@ -1218,7 +1328,8 @@
           return false;
         }
         if (data.animations().Length()) {
-          mAnimStorage->SetAnimations(data.id(), data.animations());
+          mAnimStorage->SetAnimations(data.id(), data.animations(),
+                                      RenderRootForExternal(aRenderRoot));
           const auto activeAnim = mActiveAnimations.find(data.id());
           if (activeAnim == mActiveAnimations.end()) {
             mActiveAnimations.emplace(data.id(), mWrEpoch);
@@ -1245,7 +1356,7 @@
   // to block until all the inflight transactions have been processed. This
   // flush message blocks until all previously sent scenes have been built
   // and received by the render backend thread.
-  mApi->FlushSceneBuilder();
+  Api(wr::RenderRoot::Default)->FlushSceneBuilder();
   // The post-swap hook for async-scene-building calls the
   // ScheduleRenderOnCompositorThread function from the scene builder thread,
   // which then triggers a call to ScheduleGenerateFrame() on the compositor
@@ -1259,7 +1370,7 @@
   // shouldn't be calling this function all that much in production so this
   // is probably fine. If it becomes an issue we can add more state tracking
   // machinery to optimize it away.
-  ScheduleGenerateFrame();
+  ScheduleGenerateFrameAllRenderRoots();
 }
 
 void WebRenderBridgeParent::FlushFrameGeneration() {
@@ -1285,7 +1396,7 @@
   // this effectively blocks on the render backend and renderer threads,
   // following the same codepath that WebRender takes to render and composite
   // a frame.
-  mApi->WaitFlushed();
+  Api(wr::RenderRoot::Default)->WaitFlushed();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvGetSnapshot(
@@ -1338,7 +1449,8 @@
 
   FlushSceneBuilds();
   FlushFrameGeneration();
-  mApi->Readback(start, size, Range<uint8_t>(buffer, buffer_size));
+  Api(wr::RenderRoot::Default)
+      ->Readback(start, size, Range<uint8_t>(buffer, buffer_size));
 
   return IPC_OK();
 }
@@ -1346,13 +1458,16 @@
 void WebRenderBridgeParent::AddPipelineIdForCompositable(
     const wr::PipelineId& aPipelineId, const CompositableHandle& aHandle,
     const bool& aAsync, wr::TransactionBuilder& aTxn,
-    wr::TransactionBuilder& aTxnForImageBridge) {
+    wr::TransactionBuilder& aTxnForImageBridge,
+    const wr::RenderRoot& aRenderRoot) {
   if (mDestroyed) {
     return;
   }
 
-  MOZ_ASSERT(mAsyncCompositables.find(wr::AsUint64(aPipelineId)) ==
-             mAsyncCompositables.end());
+  auto& asyncCompositables = mAsyncCompositables[aRenderRoot];
+
+  MOZ_ASSERT(asyncCompositables.find(wr::AsUint64(aPipelineId)) ==
+             asyncCompositables.end());
 
   RefPtr<CompositableHost> host;
   if (aAsync) {
@@ -1381,8 +1496,9 @@
   }
 
   wrHost->SetWrBridge(this);
-  mAsyncCompositables.emplace(wr::AsUint64(aPipelineId), wrHost);
-  mAsyncImageManager->AddAsyncImagePipeline(aPipelineId, wrHost);
+  asyncCompositables.emplace(wr::AsUint64(aPipelineId), wrHost);
+  mAsyncImageManager->AddAsyncImagePipeline(aPipelineId, wrHost,
+                                            RenderRootForExternal(aRenderRoot));
 
   // If this is being called from WebRenderBridgeParent::RecvSetDisplayList,
   // then aTxn might contain a display list that references pipelines that
@@ -1397,13 +1513,16 @@
 }
 
 void WebRenderBridgeParent::RemovePipelineIdForCompositable(
-    const wr::PipelineId& aPipelineId, wr::TransactionBuilder& aTxn) {
+    const wr::PipelineId& aPipelineId, wr::TransactionBuilder& aTxn,
+    wr::RenderRoot aRenderRoot) {
   if (mDestroyed) {
     return;
   }
 
-  auto it = mAsyncCompositables.find(wr::AsUint64(aPipelineId));
-  if (it == mAsyncCompositables.end()) {
+  auto& asyncCompositables = mAsyncCompositables[aRenderRoot];
+
+  auto it = asyncCompositables.find(wr::AsUint64(aPipelineId));
+  if (it == asyncCompositables.end()) {
     return;
   }
   RefPtr<WebRenderImageHost>& wrHost = it->second;
@@ -1411,7 +1530,7 @@
   wrHost->ClearWrBridge(this);
   mAsyncImageManager->RemoveAsyncImagePipeline(aPipelineId, aTxn);
   aTxn.RemovePipeline(aPipelineId);
-  mAsyncCompositables.erase(wr::AsUint64(aPipelineId));
+  asyncCompositables.erase(wr::AsUint64(aPipelineId));
   return;
 }
 
@@ -1463,18 +1582,26 @@
     return IPC_OK();
   }
 
-  // Clear resources
-  wr::TransactionBuilder txn;
-  txn.SetLowPriority(true);
-  txn.ClearDisplayList(GetNextWrEpoch(), mPipelineId);
-  txn.Notify(
-      wr::Checkpoint::SceneBuilt,
-      MakeUnique<ScheduleObserveLayersUpdate>(
-          mCompositorBridge, GetLayersId(), mChildLayersObserverEpoch, false));
+  for (auto renderRoot : wr::kRenderRoots) {
+    if (renderRoot == wr::RenderRoot::Default ||
+        (IsRootWebRenderBridgeParent() &&
+         gfxPrefs::WebRenderSplitRenderRoots())) {
+      // Clear resources
+      wr::TransactionBuilder txn;
+      txn.SetLowPriority(true);
+      txn.ClearDisplayList(GetNextWrEpoch(), mPipelineId);
+      txn.Notify(wr::Checkpoint::SceneBuilt,
+                 MakeUnique<ScheduleObserveLayersUpdate>(
+                     mCompositorBridge, GetLayersId(),
+                     mChildLayersObserverEpoch, false));
 
-  mApi->SendTransaction(txn);
+      Api(renderRoot)->SendTransaction(txn);
+    }
+  }
   // Schedule generate frame to clean up Pipeline
-  ScheduleGenerateFrame();
+
+  ScheduleGenerateFrameAllRenderRoots();
+
   // Remove animations.
   for (const auto& id : mActiveAnimations) {
     mAnimStorage->ClearById(id.first);
@@ -1486,13 +1613,14 @@
 }
 
 wr::Epoch WebRenderBridgeParent::UpdateWebRender(
-    CompositorVsyncScheduler* aScheduler, wr::WebRenderAPI* aApi,
+    CompositorVsyncScheduler* aScheduler,
+    nsTArray<RefPtr<wr::WebRenderAPI>>&& aApis,
     AsyncImagePipelineManager* aImageMgr,
     CompositorAnimationStorage* aAnimStorage,
     const TextureFactoryIdentifier& aTextureFactoryIdentifier) {
   MOZ_ASSERT(!IsRootWebRenderBridgeParent());
   MOZ_ASSERT(aScheduler);
-  MOZ_ASSERT(aApi);
+  MOZ_ASSERT(!aApis.IsEmpty());
   MOZ_ASSERT(aImageMgr);
   MOZ_ASSERT(aAnimStorage);
 
@@ -1502,7 +1630,7 @@
 
   // Update id name space to identify obsoleted keys.
   // Since usage of invalid keys could cause crash in webrender.
-  mIdNamespace = aApi->GetNamespace();
+  mIdNamespace = aApis[0]->GetNamespace();
   // XXX Remove it when webrender supports sharing/moving Keys between different
   // webrender instances.
   // XXX It requests client to update/reallocate webrender related resources,
@@ -1520,7 +1648,7 @@
   ClearResources();
   mCompositorBridge = cBridge;
   mCompositorScheduler = aScheduler;
-  mApi = aApi;
+  mApis = aApis;
   mAsyncImageManager = aImageMgr;
   mAnimStorage = aAnimStorage;
 
@@ -1531,7 +1659,7 @@
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvScheduleComposite() {
-  ScheduleGenerateFrame();
+  ScheduleGenerateFrameAllRenderRoots();
   return IPC_OK();
 }
 
@@ -1540,16 +1668,22 @@
     return;
   }
 
-  wr::TransactionBuilder fastTxn(/* aUseSceneBuilderThread */ false);
-  fastTxn.InvalidateRenderedFrame();
-  mApi->SendTransaction(fastTxn);
+  for (auto renderRoot : wr::kRenderRoots) {
+    if (renderRoot == wr::RenderRoot::Default ||
+        (IsRootWebRenderBridgeParent() &&
+         gfxPrefs::WebRenderSplitRenderRoots())) {
+      wr::TransactionBuilder fastTxn(/* aUseSceneBuilderThread */ false);
+      fastTxn.InvalidateRenderedFrame();
+      Api(renderRoot)->SendTransaction(fastTxn);
+    }
+  }
 
-  ScheduleGenerateFrame();
+  ScheduleGenerateFrameAllRenderRoots();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvCapture() {
   if (!mDestroyed) {
-    mApi->Capture();
+    Api(wr::RenderRoot::Default)->Capture();
   }
   return IPC_OK();
 }
@@ -1570,16 +1704,25 @@
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvSetConfirmedTargetAPZC(
-    const uint64_t& aBlockId, nsTArray<ScrollableLayerGuid>&& aTargets) {
+    const uint64_t& aBlockId, nsTArray<SLGuidAndRenderRoot>&& aTargets) {
   for (size_t i = 0; i < aTargets.Length(); i++) {
-    if (aTargets[i].mLayersId != GetLayersId()) {
-      // Guard against bad data from hijacked child processes
+    // Guard against bad data from hijacked child processes
+    if (aTargets[i].mRenderRoot > wr::kHighestRenderRoot ||
+        (!gfxPrefs::WebRenderSplitRenderRoots() &&
+         aTargets[i].mRenderRoot != wr::RenderRoot::Default)) {
+      NS_ERROR(
+          "Unexpected render root in RecvSetConfirmedTargetAPZC; dropping "
+          "message...");
+      return IPC_FAIL(this, "Bad render root");
+    }
+    if (aTargets[i].mScrollableLayerGuid.mLayersId != GetLayersId()) {
       NS_ERROR(
           "Unexpected layers id in RecvSetConfirmedTargetAPZC; dropping "
           "message...");
       return IPC_FAIL(this, "Bad layers id");
     }
   }
+
   if (mDestroyed) {
     return IPC_OK();
   }
@@ -1623,8 +1766,8 @@
   if (mDestroyed) {
     return IPC_OK();
   }
-  mCompositorBridge->SetTestAsyncScrollOffset(GetLayersId(), aScrollId,
-                                              CSSPoint(aX, aY));
+  mCompositorBridge->SetTestAsyncScrollOffset(
+      WRRootId(GetLayersId(), mRenderRoot), aScrollId, CSSPoint(aX, aY));
   return IPC_OK();
 }
 
@@ -1633,7 +1776,8 @@
   if (mDestroyed) {
     return IPC_OK();
   }
-  mCompositorBridge->SetTestAsyncZoom(GetLayersId(), aScrollId,
+  mCompositorBridge->SetTestAsyncZoom(WRRootId(GetLayersId(), mRenderRoot),
+                                      aScrollId,
                                       LayerToParentLayerScale(aZoom));
   return IPC_OK();
 }
@@ -1642,13 +1786,14 @@
   if (mDestroyed) {
     return IPC_OK();
   }
-  mCompositorBridge->FlushApzRepaints(GetLayersId());
+  mCompositorBridge->FlushApzRepaints(WRRootId(GetLayersId(), mRenderRoot));
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvGetAPZTestData(
     APZTestData* aOutData) {
-  mCompositorBridge->GetAPZTestData(GetLayersId(), aOutData);
+  mCompositorBridge->GetAPZTestData(WRRootId(GetLayersId(), mRenderRoot),
+                                    aOutData);
   return IPC_OK();
 }
 
@@ -1681,8 +1826,8 @@
 }
 
 bool WebRenderBridgeParent::SampleAnimations(
-    nsTArray<wr::WrOpacityProperty>& aOpacityArray,
-    nsTArray<wr::WrTransformProperty>& aTransformArray) {
+    wr::RenderRootArray<nsTArray<wr::WrOpacityProperty>>& aOpacityArrays,
+    wr::RenderRootArray<nsTArray<wr::WrTransformProperty>>& aTransformArrays) {
   const bool isAnimating = AdvanceAnimations();
 
   // return the animated data if has
@@ -1690,11 +1835,14 @@
     for (auto iter = mAnimStorage->ConstAnimatedValueTableIter(); !iter.Done();
          iter.Next()) {
       AnimatedValue* value = iter.UserData();
+      wr::RenderRoot renderRoot = mAnimStorage->AnimationRenderRoot(iter.Key());
+      auto& transformArray = aTransformArrays[renderRoot];
+      auto& opacityArray = aOpacityArrays[renderRoot];
       if (value->mType == AnimatedValue::TRANSFORM) {
-        aTransformArray.AppendElement(wr::ToWrTransformProperty(
+        transformArray.AppendElement(wr::ToWrTransformProperty(
             iter.Key(), value->mTransform.mTransformInDevSpace));
       } else if (value->mType == AnimatedValue::OPACITY) {
-        aOpacityArray.AppendElement(
+        opacityArray.AppendElement(
             wr::ToWrOpacityProperty(iter.Key(), value->mOpacity));
       }
     }
@@ -1727,8 +1875,8 @@
     return;
   }
 
-  if (mSkippedComposite ||
-      wr::RenderThread::Get()->TooManyPendingFrames(mApi->GetId())) {
+  if (mSkippedComposite || wr::RenderThread::Get()->TooManyPendingFrames(
+                               Api(wr::RenderRoot::Default)->GetId())) {
     // Render thread is busy, try next time.
     mSkippedComposite = true;
     mSkippedCompositeId = aId;
@@ -1763,20 +1911,24 @@
   TimeStamp start = TimeStamp::Now();
   mAsyncImageManager->SetCompositionTime(start);
 
-  // Ensure GenerateFrame is handled on the render backend thread rather
-  // than going through the scene builder thread. That way we continue
-  // generating frames with the old scene even during slow scene builds.
-  bool useSceneBuilderThread = false;
-  wr::TransactionBuilder fastTxn(useSceneBuilderThread);
-
+  wr::RenderRootArray<Maybe<wr::TransactionBuilder>> fastTxns;
   // Handle transaction that is related to DisplayList.
-  wr::TransactionBuilder sceneBuilderTxn;
-  wr::AutoTransactionSender sender(mApi, &sceneBuilderTxn);
+  wr::RenderRootArray<Maybe<wr::TransactionBuilder>> sceneBuilderTxns;
+  wr::RenderRootArray<Maybe<wr::AutoTransactionSender>> senders;
+  for (auto& api : mApis) {
+    auto renderRoot = api->GetRenderRoot();
+    // Ensure GenerateFrame is handled on the render backend thread rather
+    // than going through the scene builder thread. That way we continue
+    // generating frames with the old scene even during slow scene builds.
+    fastTxns[renderRoot].emplace(false /* useSceneBuilderThread */);
+    sceneBuilderTxns[renderRoot].emplace();
+    senders[renderRoot].emplace(api, sceneBuilderTxns[renderRoot].ptr());
+  }
 
   // Adding and updating wr::ImageKeys of ImageHosts that uses ImageBridge are
   // done without using transaction of scene builder thread. With it, updating
   // of video frame becomes faster.
-  mAsyncImageManager->ApplyAsyncImagesOfImageBridge(sceneBuilderTxn, fastTxn);
+  mAsyncImageManager->ApplyAsyncImagesOfImageBridge(sceneBuilderTxns, fastTxns);
 
   if (!mAsyncImageManager->GetCompositeUntilTime().IsNull()) {
     // Trigger another CompositeToTarget() call because there might be another
@@ -1785,35 +1937,58 @@
     mCompositorScheduler->ScheduleComposition();
   }
 
-  if (!mAsyncImageManager->GetAndResetWillGenerateFrame() &&
-      fastTxn.IsEmpty() && !aForceGenerateFrame) {
+  uint8_t framesGenerated = 0;
+  wr::RenderRootArray<bool> generateFrame;
+  for (auto& api : mApis) {
+    auto renderRoot = api->GetRenderRoot();
+    generateFrame[renderRoot] =
+        mAsyncImageManager->GetAndResetWillGenerateFrame(renderRoot) ||
+        !fastTxns[renderRoot]->IsEmpty() || aForceGenerateFrame;
+    if (generateFrame[renderRoot]) {
+      framesGenerated++;
+    }
+  }
+
+  if (framesGenerated == 0) {
     // Could skip generating frame now.
     mPreviousFrameTimeStamp = TimeStamp();
     return;
   }
 
-  nsTArray<wr::WrOpacityProperty> opacityArray;
-  nsTArray<wr::WrTransformProperty> transformArray;
+  wr::RenderRootArray<nsTArray<wr::WrOpacityProperty>> opacityArrays;
+  wr::RenderRootArray<nsTArray<wr::WrTransformProperty>> transformArrays;
 
-  if (SampleAnimations(opacityArray, transformArray)) {
-    ScheduleGenerateFrame();
+  if (SampleAnimations(opacityArrays, transformArrays)) {
+    // TODO we should have a better way of assessing whether we need a content
+    // or a chrome frame generation.
+    ScheduleGenerateFrameAllRenderRoots();
   }
   // We do this even if the arrays are empty, because it will clear out any
   // previous properties store on the WR side, which is desirable.
-  fastTxn.UpdateDynamicProperties(opacityArray, transformArray);
+  for (auto& api : mApis) {
+    auto renderRoot = api->GetRenderRoot();
+    fastTxns[renderRoot]->UpdateDynamicProperties(opacityArrays[renderRoot],
+                                                  transformArrays[renderRoot]);
+  }
 
   SetAPZSampleTime();
 
-  wr::RenderThread::Get()->IncPendingFrameCount(mApi->GetId(), aId, start);
+  wr::RenderThread::Get()->IncPendingFrameCount(
+      Api(wr::RenderRoot::Default)->GetId(), aId, start, framesGenerated);
 
 #if defined(ENABLE_FRAME_LATENCY_LOG)
   auto startTime = TimeStamp::Now();
-  mApi->SetFrameStartTime(startTime);
+  Api(wr::RenderRoot::Default)->SetFrameStartTime(startTime);
 #endif
 
-  fastTxn.GenerateFrame();
-
-  mApi->SendTransaction(fastTxn);
+  MOZ_ASSERT(framesGenerated > 0);
+  for (auto& api : mApis) {
+    auto renderRoot = api->GetRenderRoot();
+    if (generateFrame[renderRoot]) {
+      fastTxns[renderRoot]->GenerateFrame();
+      mApis[(size_t)renderRoot]->SendTransaction(*fastTxns[renderRoot]);
+    }
+  }
   mMostRecentComposite = TimeStamp::Now();
 }
 
@@ -1831,6 +2006,17 @@
       aUseForTelemetry));
 }
 
+already_AddRefed<wr::WebRenderAPI>
+WebRenderBridgeParent::GetWebRenderAPIAtPoint(const gfx::IntPoint& aPoint) {
+  MutexAutoLock lock(mRenderRootRectMutex);
+  for (auto renderRoot : wr::kNonDefaultRenderRoots) {
+    if (mRenderRootRects[renderRoot].Contains(aPoint)) {
+      return do_AddRef(Api(renderRoot));
+    }
+  }
+  return do_AddRef(Api(wr::RenderRoot::Default));
+}
+
 TransactionId WebRenderBridgeParent::LastPendingTransactionId() {
   TransactionId id{0};
   if (!mPendingTransactionIds.empty()) {
@@ -1850,13 +2036,13 @@
 }
 
 void WebRenderBridgeParent::NotifyDidSceneBuild(
-    RefPtr<wr::WebRenderPipelineInfo> aInfo) {
+    wr::RenderRoot aRenderRoot, RefPtr<wr::WebRenderPipelineInfo> aInfo) {
   MOZ_ASSERT(IsRootWebRenderBridgeParent());
   if (!mCompositorScheduler) {
     return;
   }
 
-  mAsyncImageManager->SetWillGenerateFrame();
+  mAsyncImageManager->SetWillGenerateFrame(aRenderRoot);
 
   // If the scheduler has a composite more recent than our last composite (which
   // we missed), and we're within the threshold ms of the last vsync, then
@@ -1932,7 +2118,8 @@
             transactionId.mFwdTime, transactionId.mSceneBuiltTime,
             transactionId.mSkippedComposites, transactionId.mTxnURL));
 
-        wr::RenderThread::Get()->NotifySlowFrame(mApi->GetId());
+        wr::RenderThread::Get()->NotifySlowFrame(
+            Api(wr::RenderRoot::Default)->GetId());
       }
     }
 
@@ -1969,9 +2156,19 @@
   return wr::AsLayersId(mPipelineId);
 }
 
-void WebRenderBridgeParent::ScheduleGenerateFrame() {
+void WebRenderBridgeParent::ScheduleGenerateFrameAllRenderRoots() {
   if (mCompositorScheduler) {
-    mAsyncImageManager->SetWillGenerateFrame();
+    mAsyncImageManager->SetWillGenerateFrameAllRenderRoots();
+    mCompositorScheduler->ScheduleComposition();
+  }
+}
+
+void WebRenderBridgeParent::ScheduleGenerateFrame(
+    const Maybe<wr::RenderRoot>& aRenderRoot) {
+  if (mCompositorScheduler) {
+    if (aRenderRoot.isSome()) {
+      mAsyncImageManager->SetWillGenerateFrame(*aRenderRoot);
+    }
     mCompositorScheduler->ScheduleComposition();
   }
 }
@@ -1996,7 +2193,8 @@
   if (!IsRootWebRenderBridgeParent() || mDestroyed) {
     return;
   }
-  mApi->Pause();
+
+  Api(wr::RenderRoot::Default)->Pause();
 #endif
   mPaused = true;
 }
@@ -2008,7 +2206,7 @@
     return false;
   }
 
-  if (!mApi->Resume()) {
+  if (!Api(wr::RenderRoot::Default)->Resume()) {
     return false;
   }
 #endif
@@ -2017,19 +2215,15 @@
 }
 
 void WebRenderBridgeParent::ClearResources() {
-  if (!mApi) {
+  if (mApis.IsEmpty()) {
     return;
   }
 
   wr::Epoch wrEpoch = GetNextWrEpoch();
+  mReceivedDisplayList = false;
+  // Schedule generate frame to clean up Pipeline
+  ScheduleGenerateFrameAllRenderRoots();
 
-  wr::TransactionBuilder txn;
-  txn.SetLowPriority(true);
-  txn.ClearDisplayList(wrEpoch, mPipelineId);
-  mReceivedDisplayList = false;
-
-  // Schedule generate frame to clean up Pipeline
-  ScheduleGenerateFrame();
   // WrFontKeys and WrImageKeys are deleted during WebRenderAPI destruction.
   for (const auto& entry : mTextureHosts) {
     WebRenderTextureHost* wrTexture = entry.second->AsWebRenderTextureHost();
@@ -2039,23 +2233,31 @@
     }
   }
   mTextureHosts.clear();
-  for (const auto& entry : mAsyncCompositables) {
-    wr::PipelineId pipelineId = wr::AsPipelineId(entry.first);
-    RefPtr<WebRenderImageHost> host = entry.second;
-    host->ClearWrBridge(this);
-    mAsyncImageManager->RemoveAsyncImagePipeline(pipelineId, txn);
-    txn.RemovePipeline(pipelineId);
-  }
-  mAsyncCompositables.clear();
+
   for (const auto& entry : mSharedSurfaceIds) {
     mAsyncImageManager->HoldExternalImage(mPipelineId, mWrEpoch, entry.second);
   }
   mSharedSurfaceIds.clear();
 
   mAsyncImageManager->RemovePipeline(mPipelineId, wrEpoch);
-  txn.RemovePipeline(mPipelineId);
+
+  for (auto& api : mApis) {
+    wr::TransactionBuilder txn;
+    txn.SetLowPriority(true);
+    txn.ClearDisplayList(wrEpoch, mPipelineId);
 
-  mApi->SendTransaction(txn);
+    auto renderRoot = api->GetRenderRoot();
+    for (const auto& entry : mAsyncCompositables[renderRoot]) {
+      wr::PipelineId pipelineId = wr::AsPipelineId(entry.first);
+      RefPtr<WebRenderImageHost> host = entry.second;
+      host->ClearWrBridge(this);
+      mAsyncImageManager->RemoveAsyncImagePipeline(pipelineId, txn);
+      txn.RemovePipeline(pipelineId);
+    }
+    mAsyncCompositables[renderRoot].clear();
+    txn.RemovePipeline(mPipelineId);
+    api->SendTransaction(txn);
+  }
 
   for (const auto& id : mActiveAnimations) {
     mAnimStorage->ClearById(id.first);
@@ -2071,7 +2273,7 @@
   mAnimStorage = nullptr;
   mCompositorScheduler = nullptr;
   mAsyncImageManager = nullptr;
-  mApi = nullptr;
+  mApis.Clear();
   mCompositorBridge = nullptr;
 }
 
@@ -2133,12 +2335,14 @@
 }
 
 TextureFactoryIdentifier WebRenderBridgeParent::GetTextureFactoryIdentifier() {
-  MOZ_ASSERT(mApi);
+  MOZ_ASSERT(!mApis.IsEmpty());
 
   return TextureFactoryIdentifier(
-      LayersBackend::LAYERS_WR, XRE_GetProcessType(), mApi->GetMaxTextureSize(),
-      false, mApi->GetUseANGLE(), mApi->GetUseDComp(), false, false, false,
-      mApi->GetSyncHandle());
+      LayersBackend::LAYERS_WR, XRE_GetProcessType(),
+      Api(wr::RenderRoot::Default)->GetMaxTextureSize(), false,
+      Api(wr::RenderRoot::Default)->GetUseANGLE(),
+      Api(wr::RenderRoot::Default)->GetUseDComp(), false, false, false,
+      Api(wr::RenderRoot::Default)->GetSyncHandle());
 }
 
 wr::Epoch WebRenderBridgeParent::GetNextWrEpoch() {