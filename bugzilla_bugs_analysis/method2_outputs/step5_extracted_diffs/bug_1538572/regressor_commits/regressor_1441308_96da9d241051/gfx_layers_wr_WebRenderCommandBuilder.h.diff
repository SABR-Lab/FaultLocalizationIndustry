# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderCommandBuilder.h
# Commit: 96da9d241051
# Full Hash: 96da9d241051d222bdd693bdb519d058a013b59c
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-23 09:46:24
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 8cefa694f811 -r 96da9d241051 gfx/layers/wr/WebRenderCommandBuilder.h
--- a/gfx/layers/wr/WebRenderCommandBuilder.h	Fri Mar 22 18:28:31 2019 +0000
+++ b/gfx/layers/wr/WebRenderCommandBuilder.h	Fri Mar 22 18:28:42 2019 +0000
@@ -9,6 +9,7 @@
 
 #include "mozilla/webrender/WebRenderAPI.h"
 #include "mozilla/layers/ClipManager.h"
+#include "mozilla/layers/RenderRootBoundary.h"
 #include "mozilla/layers/WebRenderMessages.h"
 #include "mozilla/layers/WebRenderScrollData.h"
 #include "mozilla/layers/WebRenderUserData.h"
@@ -30,6 +31,51 @@
 class WebRenderParentCommand;
 class WebRenderUserData;
 
+class WebRenderScrollDataCollection {
+ public:
+  WebRenderScrollDataCollection() : mSeenRenderRoot{} {}
+
+  std::vector<WebRenderLayerScrollData>& operator[](
+      wr::RenderRoot aRenderRoot) {
+    return mInternalScrollDatas[aRenderRoot];
+  }
+
+  bool IsEmpty() const {
+    for (auto renderRoot : wr::kRenderRoots) {
+      if (!mInternalScrollDatas[renderRoot].empty()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  void AppendRoot(Maybe<ScrollMetadata>& aRootMetadata,
+                  wr::RenderRootArray<WebRenderScrollData>& aScrollDatas);
+
+  void AppendWrapper(const RenderRootBoundary& aBoundary,
+                     size_t aLayerCountBeforeRecursing);
+
+  void AppendScrollData(const wr::DisplayListBuilder& aBuilder,
+                        WebRenderLayerManager* aManager, nsDisplayItem* aItem,
+                        size_t aLayerCountBeforeRecursing,
+                        const ActiveScrolledRoot* aStopAtAsr,
+                        const Maybe<gfx::Matrix4x4>& aAncestorTransform);
+
+  size_t GetLayerCount(wr::RenderRoot aRenderRoot) const;
+
+  void Clear() {
+    for (auto renderRoot : wr::kRenderRoots) {
+      mInternalScrollDatas[renderRoot].clear();
+      mSeenRenderRoot[renderRoot] = false;
+    }
+  }
+
+ private:
+  wr::RenderRootArray<std::vector<WebRenderLayerScrollData>>
+      mInternalScrollDatas;
+  wr::RenderRootArray<bool> mSeenRenderRoot;
+};
+
 class WebRenderCommandBuilder {
   typedef nsTHashtable<nsRefPtrHashKey<WebRenderUserData>>
       WebRenderUserDataRefTable;
@@ -38,6 +84,8 @@
  public:
   explicit WebRenderCommandBuilder(WebRenderLayerManager* aManager)
       : mManager(aManager),
+        mRootStackingContexts(nullptr),
+        mCurrentClipManager(nullptr),
         mLastAsr(nullptr),
         mBuilderDumpIndex(0),
         mDumpIndent(0),
@@ -51,13 +99,12 @@
 
   bool NeedsEmptyTransaction();
 
-  void BuildWebRenderCommands(wr::DisplayListBuilder& aBuilder,
-                              wr::IpcResourceUpdateQueue& aResourceUpdates,
-                              nsDisplayList* aDisplayList,
-                              nsDisplayListBuilder* aDisplayListBuilder,
-                              WebRenderScrollData& aScrollData,
-                              wr::LayoutSize& aContentSize,
-                              WrFiltersHolder&& aFilters);
+  void BuildWebRenderCommands(
+      wr::DisplayListBuilder& aBuilder,
+      wr::IpcResourceUpdateQueue& aResourceUpdates, nsDisplayList* aDisplayList,
+      nsDisplayListBuilder* aDisplayListBuilder,
+      wr::RenderRootArray<WebRenderScrollData>& aScrollDatas,
+      WrFiltersHolder&& aFilters);
 
   void PushOverrideForASR(const ActiveScrolledRoot* aASR,
                           const wr::WrSpatialId& aSpatialId);
@@ -118,13 +165,19 @@
 
   bool GetContainsSVGGroup() { return mContainsSVGGroup; }
 
+  const StackingContextHelper& GetRootStackingContextHelper(
+      wr::RenderRoot aRenderRoot) const {
+    return *(*mRootStackingContexts)[aRenderRoot];
+  }
+
   // Those are data that we kept between transactions. We used to cache some
   // data in the layer. But in layers free mode, we don't have layer which
   // means we need some other place to cached the data between transaction.
   // We store the data in frame's property.
   template <class T>
   already_AddRefed<T> CreateOrRecycleWebRenderUserData(
-      nsDisplayItem* aItem, bool* aOutIsRecycled = nullptr) {
+      nsDisplayItem* aItem, wr::RenderRoot aRenderRoot,
+      bool* aOutIsRecycled = nullptr) {
     MOZ_ASSERT(aItem);
     nsIFrame* frame = aItem->Frame();
     if (aOutIsRecycled) {
@@ -142,7 +195,7 @@
     RefPtr<WebRenderUserData>& data = userDataTable->GetOrInsert(
         WebRenderUserDataKey(aItem->GetPerFrameKey(), T::Type()));
     if (!data) {
-      data = new T(GetRenderRootStateManager(), aItem);
+      data = new T(GetRenderRootStateManager(aRenderRoot), aItem);
       mWebRenderUserDatas.PutEntry(data);
       if (aOutIsRecycled) {
         *aOutIsRecycled = false;
@@ -165,14 +218,29 @@
 
   WebRenderLayerManager* mManager;
 
+  class MOZ_RAII ScrollDataBoundaryWrapper {
+   public:
+    ScrollDataBoundaryWrapper(WebRenderCommandBuilder& aBuilder,
+                              RenderRootBoundary& aBoundary);
+    ~ScrollDataBoundaryWrapper();
+
+   private:
+    WebRenderCommandBuilder& mBuilder;
+    RenderRootBoundary mBoundary;
+    size_t mLayerCountBeforeRecursing;
+  };
+  friend class ScrollDataBoundaryWrapper;
+
  private:
-  RenderRootStateManager* GetRenderRootStateManager();
+  RenderRootStateManager* GetRenderRootStateManager(wr::RenderRoot aRenderRoot);
 
-  ClipManager mClipManager;
+  wr::RenderRootArray<Maybe<StackingContextHelper>>* mRootStackingContexts;
+  wr::RenderRootArray<ClipManager> mClipManagers;
+  ClipManager* mCurrentClipManager;
 
   // We use this as a temporary data structure while building the mScrollData
   // inside a layers-free transaction.
-  std::vector<WebRenderLayerScrollData> mLayerScrollData;
+  WebRenderScrollDataCollection mLayerScrollDatas;
   // We use this as a temporary data structure to track the current display
   // item's ASR as we recurse in CreateWebRenderCommandsFromDisplayList. We
   // need this so that WebRenderLayerScrollData items that deeper in the