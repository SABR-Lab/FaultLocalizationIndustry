# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxFontMissingGlyphs.cpp
# Commit: 96da9d241051
# Full Hash: 96da9d241051d222bdd693bdb519d058a013b59c
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-23 09:46:24
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 8cefa694f811 -r 96da9d241051 gfx/thebes/gfxFontMissingGlyphs.cpp
--- a/gfx/thebes/gfxFontMissingGlyphs.cpp	Fri Mar 22 18:28:31 2019 +0000
+++ b/gfx/thebes/gfxFontMissingGlyphs.cpp	Fri Mar 22 18:28:42 2019 +0000
@@ -164,7 +164,12 @@
   static UserDataKey sWRUserDataKey;
 };
 
-static RefPtr<SourceSurface> gWRGlyphAtlas[8];
+// If we add more render roots, this will need to be updated to accomodate
+// more than two render roots, at which point simply adding a bit to an
+// array index is probably not how we want to do things.
+static const int CONTENT_RECT_GLYPH_ATLAS = 8;
+
+static RefPtr<SourceSurface> gWRGlyphAtlas[16];
 static LinkedList<WRUserData> gWRUsers;
 UserDataKey WRUserData::sWRUserDataKey;
 
@@ -218,13 +223,17 @@
   // from the layer manager.
   for (WRUserData* user : gWRUsers) {
     auto* manager = user->mManager;
-    for (size_t i = 0; i < 8; i++) {
+    for (size_t i = 0; i < 16; i++) {
       if (gWRGlyphAtlas[i]) {
         uint32_t handle = (uint32_t)(uintptr_t)gWRGlyphAtlas[i]->GetUserData(
             reinterpret_cast<UserDataKey*>(manager));
         if (handle) {
-          manager->GetRenderRootStateManager()->AddImageKeyForDiscard(
-              wr::ImageKey{manager->WrBridge()->GetNamespace(), handle});
+          wr::RenderRoot renderRoot = (i & CONTENT_RECT_GLYPH_ATLAS)
+                                          ? wr::RenderRoot::Content
+                                          : wr::RenderRoot::Default;
+          manager->GetRenderRootStateManager(renderRoot)
+              ->AddImageKeyForDiscard(
+                  wr::ImageKey{manager->WrBridge()->GetNamespace(), handle});
         }
       }
     }
@@ -235,7 +244,7 @@
     gWRUsers.popFirst()->Remove();
   }
   // Finally, clear out the atlases.
-  for (size_t i = 0; i < 8; i++) {
+  for (size_t i = 0; i < 16; i++) {
     gWRGlyphAtlas[i] = nullptr;
   }
 }
@@ -249,7 +258,7 @@
   // When the layer manager is destroyed, we need go through each
   // atlas and remove any assigned image keys.
   if (isInList()) {
-    for (size_t i = 0; i < 8; i++) {
+    for (size_t i = 0; i < 16; i++) {
       if (gWRGlyphAtlas[i]) {
         gWRGlyphAtlas[i]->RemoveUserData(
             reinterpret_cast<UserDataKey*>(mManager));
@@ -269,15 +278,20 @@
       key |= (aMat->_11 < 0 ? 1 : 0) | (aMat->_22 < 0 ? 2 : 0);
     }
   }
+  // The atlas may exist, but an image key may not be assigned for it to
+  // the given layer manager.
+  auto* tdt = static_cast<layout::TextDrawTarget*>(&aDrawTarget);
+  if (tdt->GetRenderRoot() == wr::RenderRoot::Content) {
+    key |= CONTENT_RECT_GLYPH_ATLAS;
+  }
+
   // Check if an atlas was already created, or create one if necessary.
   RefPtr<SourceSurface> atlas = gWRGlyphAtlas[key];
   if (!atlas) {
     atlas = MakeWRGlyphAtlas(aMat);
     gWRGlyphAtlas[key] = atlas;
   }
-  // The atlas may exist, but an image key may not be assigned for it to
-  // the given layer manager.
-  auto* tdt = static_cast<layout::TextDrawTarget*>(&aDrawTarget);
+
   auto* manager = tdt->WrLayerManager();
   if (!atlas->GetUserData(reinterpret_cast<UserDataKey*>(manager))) {
     // No image key, so we need to map the atlas' data for transfer to WR.