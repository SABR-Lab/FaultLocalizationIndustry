# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/APZCTreeManagerParent.cpp
# Commit: c09a51622e98
# Full Hash: c09a51622e988e81077c75e3aaa5a49df66284b3
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-22 16:44:08
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 737807563dd5 -r c09a51622e98 gfx/layers/ipc/APZCTreeManagerParent.cpp
--- a/gfx/layers/ipc/APZCTreeManagerParent.cpp	Thu Mar 21 23:14:26 2019 +0000
+++ b/gfx/layers/ipc/APZCTreeManagerParent.cpp	Fri Mar 22 03:15:14 2019 +0000
@@ -14,9 +14,9 @@
 namespace layers {
 
 APZCTreeManagerParent::APZCTreeManagerParent(
-    LayersId aLayersId, RefPtr<APZCTreeManager> aAPZCTreeManager,
+    WRRootId aWrRootId, RefPtr<APZCTreeManager> aAPZCTreeManager,
     RefPtr<APZUpdater> aAPZUpdater)
-    : mLayersId(aLayersId),
+    : mWrRootId(aWrRootId),
       mTreeManager(std::move(aAPZCTreeManager)),
       mUpdater(std::move(aAPZUpdater)) {
   MOZ_ASSERT(mTreeManager != nullptr);
@@ -38,54 +38,54 @@
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvSetKeyboardMap(
     const KeyboardMap& aKeyboardMap) {
   mUpdater->RunOnControllerThread(
-      mLayersId, NewRunnableMethod<KeyboardMap>(
-                     "layers::IAPZCTreeManager::SetKeyboardMap", mTreeManager,
-                     &IAPZCTreeManager::SetKeyboardMap, aKeyboardMap));
+      UpdaterQueueSelector(mWrRootId),
+      NewRunnableMethod<KeyboardMap>(
+          "layers::IAPZCTreeManager::SetKeyboardMap", mTreeManager,
+          &IAPZCTreeManager::SetKeyboardMap, aKeyboardMap));
 
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvZoomToRect(
-    const ScrollableLayerGuid& aGuid, const CSSRect& aRect,
+    const SLGuidAndRenderRoot& aGuid, const CSSRect& aRect,
     const uint32_t& aFlags) {
-  if (aGuid.mLayersId != mLayersId) {
-    // Guard against bad data from hijacked child processes
-    NS_ERROR("Unexpected layers id in RecvZoomToRect; dropping message...");
+  if (!IsGuidValid(aGuid)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
   mUpdater->RunOnControllerThread(
-      mLayersId, NewRunnableMethod<ScrollableLayerGuid, CSSRect, uint32_t>(
-                     "layers::IAPZCTreeManager::ZoomToRect", mTreeManager,
-                     &IAPZCTreeManager::ZoomToRect, aGuid, aRect, aFlags));
+      UpdaterQueueSelector(aGuid.GetWRRootId()),
+      NewRunnableMethod<SLGuidAndRenderRoot, CSSRect, uint32_t>(
+          "layers::IAPZCTreeManager::ZoomToRect", mTreeManager,
+          &IAPZCTreeManager::ZoomToRect, aGuid, aRect, aFlags));
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvContentReceivedInputBlock(
     const uint64_t& aInputBlockId, const bool& aPreventDefault) {
   mUpdater->RunOnControllerThread(
-      mLayersId, NewRunnableMethod<uint64_t, bool>(
-                     "layers::IAPZCTreeManager::ContentReceivedInputBlock",
-                     mTreeManager, &IAPZCTreeManager::ContentReceivedInputBlock,
-                     aInputBlockId, aPreventDefault));
+      UpdaterQueueSelector(mWrRootId),
+      NewRunnableMethod<uint64_t, bool>(
+          "layers::IAPZCTreeManager::ContentReceivedInputBlock", mTreeManager,
+          &IAPZCTreeManager::ContentReceivedInputBlock, aInputBlockId,
+          aPreventDefault));
 
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvSetTargetAPZC(
-    const uint64_t& aInputBlockId, nsTArray<ScrollableLayerGuid>&& aTargets) {
+    const uint64_t& aInputBlockId, nsTArray<SLGuidAndRenderRoot>&& aTargets) {
+  UpdaterQueueSelector selector(mWrRootId.mLayersId);
   for (size_t i = 0; i < aTargets.Length(); i++) {
-    if (aTargets[i].mLayersId != mLayersId) {
-      // Guard against bad data from hijacked child processes
-      NS_ERROR(
-          "Unexpected layers id in RecvSetTargetAPZC; dropping message...");
+    if (!IsGuidValid(aTargets[i])) {
       return IPC_FAIL_NO_REASON(this);
     }
+    selector.mRenderRoots += aTargets[i].mRenderRoot;
   }
   mUpdater->RunOnControllerThread(
-      mLayersId,
+      selector,
       NewRunnableMethod<uint64_t,
-                        StoreCopyPassByRRef<nsTArray<ScrollableLayerGuid>>>(
+                        StoreCopyPassByRRef<nsTArray<SLGuidAndRenderRoot>>>(
           "layers::IAPZCTreeManager::SetTargetAPZC", mTreeManager,
           &IAPZCTreeManager::SetTargetAPZC, aInputBlockId, aTargets));
 
@@ -93,13 +93,9 @@
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvUpdateZoomConstraints(
-    const ScrollableLayerGuid& aGuid,
+    const SLGuidAndRenderRoot& aGuid,
     const MaybeZoomConstraints& aConstraints) {
-  if (aGuid.mLayersId != mLayersId) {
-    // Guard against bad data from hijacked child processes
-    NS_ERROR(
-        "Unexpected layers id in RecvUpdateZoomConstraints; dropping "
-        "message...");
+  if (!IsGuidValid(aGuid)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
@@ -110,7 +106,7 @@
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvSetDPI(
     const float& aDpiValue) {
   mUpdater->RunOnControllerThread(
-      mLayersId,
+      UpdaterQueueSelector(mWrRootId),
       NewRunnableMethod<float>("layers::IAPZCTreeManager::SetDPI", mTreeManager,
                                &IAPZCTreeManager::SetDPI, aDpiValue));
   return IPC_OK();
@@ -119,7 +115,7 @@
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvSetAllowedTouchBehavior(
     const uint64_t& aInputBlockId, nsTArray<TouchBehaviorFlags>&& aValues) {
   mUpdater->RunOnControllerThread(
-      mLayersId,
+      UpdaterQueueSelector(mWrRootId),
       NewRunnableMethod<uint64_t,
                         StoreCopyPassByRRef<nsTArray<TouchBehaviorFlags>>>(
           "layers::IAPZCTreeManager::SetAllowedTouchBehavior", mTreeManager,
@@ -130,17 +126,14 @@
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvStartScrollbarDrag(
-    const ScrollableLayerGuid& aGuid, const AsyncDragMetrics& aDragMetrics) {
-  if (aGuid.mLayersId != mLayersId) {
-    // Guard against bad data from hijacked child processes
-    NS_ERROR(
-        "Unexpected layers id in RecvStartScrollbarDrag; dropping message...");
+    const SLGuidAndRenderRoot& aGuid, const AsyncDragMetrics& aDragMetrics) {
+  if (!IsGuidValid(aGuid)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
   mUpdater->RunOnControllerThread(
-      mLayersId,
-      NewRunnableMethod<ScrollableLayerGuid, AsyncDragMetrics>(
+      UpdaterQueueSelector(aGuid.GetWRRootId()),
+      NewRunnableMethod<SLGuidAndRenderRoot, AsyncDragMetrics>(
           "layers::IAPZCTreeManager::StartScrollbarDrag", mTreeManager,
           &IAPZCTreeManager::StartScrollbarDrag, aGuid, aDragMetrics));
 
@@ -148,17 +141,17 @@
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvStartAutoscroll(
-    const ScrollableLayerGuid& aGuid, const ScreenPoint& aAnchorLocation) {
+    const SLGuidAndRenderRoot& aGuid, const ScreenPoint& aAnchorLocation) {
   // Unlike RecvStartScrollbarDrag(), this message comes from the parent
   // process (via nsBaseWidget::mAPZC) rather than from the child process
   // (via TabChild::mApzcTreeManager), so there is no need to check the
-  // layers id against mLayersId (and in any case, it wouldn't match, because
-  // mLayersId stores the parent process's layers id, while nsBaseWidget is
+  // layers id against mWrRootId (and in any case, it wouldn't match, because
+  // mWrRootId stores the parent process's layers id, while nsBaseWidget is
   // sending the child process's layers id).
 
   mUpdater->RunOnControllerThread(
-      mLayersId,
-      NewRunnableMethod<ScrollableLayerGuid, ScreenPoint>(
+      UpdaterQueueSelector(mWrRootId),
+      NewRunnableMethod<SLGuidAndRenderRoot, ScreenPoint>(
           "layers::IAPZCTreeManager::StartAutoscroll", mTreeManager,
           &IAPZCTreeManager::StartAutoscroll, aGuid, aAnchorLocation));
 
@@ -166,13 +159,14 @@
 }
 
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvStopAutoscroll(
-    const ScrollableLayerGuid& aGuid) {
+    const SLGuidAndRenderRoot& aGuid) {
   // See RecvStartAutoscroll() for why we don't check the layers id.
 
   mUpdater->RunOnControllerThread(
-      mLayersId, NewRunnableMethod<ScrollableLayerGuid>(
-                     "layers::IAPZCTreeManager::StopAutoscroll", mTreeManager,
-                     &IAPZCTreeManager::StopAutoscroll, aGuid));
+      UpdaterQueueSelector(mWrRootId),
+      NewRunnableMethod<SLGuidAndRenderRoot>(
+          "layers::IAPZCTreeManager::StopAutoscroll", mTreeManager,
+          &IAPZCTreeManager::StopAutoscroll, aGuid));
 
   return IPC_OK();
 }
@@ -180,7 +174,7 @@
 mozilla::ipc::IPCResult APZCTreeManagerParent::RecvSetLongTapEnabled(
     const bool& aLongTapEnabled) {
   mUpdater->RunOnControllerThread(
-      mLayersId,
+      UpdaterQueueSelector(mWrRootId),
       NewRunnableMethod<bool>(
           "layers::IAPZCTreeManager::SetLongTapEnabled", mTreeManager,
           &IAPZCTreeManager::SetLongTapEnabled, aLongTapEnabled));
@@ -188,5 +182,22 @@
   return IPC_OK();
 }
 
+bool APZCTreeManagerParent::IsGuidValid(const SLGuidAndRenderRoot& aGuid) {
+  if (aGuid.mScrollableLayerGuid.mLayersId != mWrRootId.mLayersId) {
+    NS_ERROR("Unexpected layers id");
+    return false;
+  }
+  if (mWrRootId.mRenderRoot == wr::RenderRoot::Content) {
+    // If this APZCTreeManagerParent is for a content process IPDL bridge, then
+    // all the render root references that come over the bridge must be for
+    // the content render root.
+    if (aGuid.mRenderRoot != wr::RenderRoot::Content) {
+      NS_ERROR("Unexpected render root");
+      return false;
+    }
+  }
+  return true;
+}
+
 }  // namespace layers
 }  // namespace mozilla