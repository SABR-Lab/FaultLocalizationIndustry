# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderCommandBuilder.cpp
# Commit: c09a51622e98
# Full Hash: c09a51622e988e81077c75e3aaa5a49df66284b3
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-22 16:44:08
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 737807563dd5 -r c09a51622e98 gfx/layers/wr/WebRenderCommandBuilder.cpp
--- a/gfx/layers/wr/WebRenderCommandBuilder.cpp	Thu Mar 21 23:14:26 2019 +0000
+++ b/gfx/layers/wr/WebRenderCommandBuilder.cpp	Fri Mar 22 03:15:14 2019 +0000
@@ -300,7 +300,7 @@
   // mImageBounds clipped to the container/parent of the
   // current item being processed.
   IntRect mClippedImageBounds;
-  Maybe<wr::BlobImageKey> mKey;
+  Maybe<mozilla::Pair<wr::RenderRoot, wr::BlobImageKey>> mKey;
   std::vector<RefPtr<SourceSurface>> mExternalSurfaces;
   std::vector<RefPtr<ScaledFont>> mFonts;
 
@@ -331,7 +331,7 @@
   void ClearImageKey(RenderRootStateManager* aManager, bool aForce = false) {
     if (mKey) {
       MOZ_RELEASE_ASSERT(aForce || mInvalidRect.IsEmpty());
-      aManager->AddBlobImageKeyForDiscard(mKey.value());
+      aManager->AddBlobImageKeyForDiscard(mKey.value().second());
       mKey = Nothing();
     }
     mFonts.clear();
@@ -632,7 +632,7 @@
       GP("End EndGroup\n");
       if (mKey) {
         aResources.SetBlobImageVisibleArea(
-            mKey.value(),
+            mKey.value().second(),
             ViewAs<ImagePixel>(mPaintRect,
                                PixelCastJustification::LayerIsImage));
         PushImage(aBuilder, bounds);
@@ -652,7 +652,7 @@
               for (auto& scaled : aScaledFonts) {
                 Maybe<wr::FontInstanceKey> key =
                     aWrManager->WrBridge()->GetFontKeyForScaledFont(
-                        scaled, &aResources);
+                        scaled, aBuilder.GetRenderRoot(), &aResources);
                 if (key.isNothing()) {
                   validFonts = false;
                   break;
@@ -679,7 +679,9 @@
 
     bool empty = aStartItem == aEndItem;
     if (empty) {
-      ClearImageKey(aWrManager->GetRenderRootStateManager(), true);
+      ClearImageKey(
+          aWrManager->GetRenderRootStateManager(aBuilder.GetRenderRoot()),
+          true);
       return;
     }
 
@@ -690,8 +692,10 @@
     //   Contains(paintBounds);?
     wr::OpacityType opacity = wr::OpacityType::HasAlphaChannel;
 
-    TakeExternalSurfaces(recorder, mExternalSurfaces,
-                         aWrManager->GetRenderRootStateManager(), aResources);
+    TakeExternalSurfaces(
+        recorder, mExternalSurfaces,
+        aWrManager->GetRenderRootStateManager(aBuilder.GetRenderRoot()),
+        aResources);
     bool hasItems = recorder->Finish();
     GP("%d Finish\n", hasItems);
     if (!validFonts) {
@@ -712,7 +716,7 @@
       if (!aResources.AddBlobImage(key, descriptor, bytes)) {
         return;
       }
-      mKey = Some(key);
+      mKey = Some(MakePair(aBuilder.GetRenderRoot(), key));
     } else {
       wr::ImageDescriptor descriptor(dtSize, 0, dt->GetFormat(), opacity);
       auto bottomRight = mInvalidRect.BottomRight();
@@ -722,7 +726,7 @@
                          bottomRight.y <= dtSize.height);
       GP("Update Blob %d %d %d %d\n", mInvalidRect.x, mInvalidRect.y,
          mInvalidRect.width, mInvalidRect.height);
-      if (!aResources.UpdateBlobImage(mKey.value(), descriptor, bytes,
+      if (!aResources.UpdateBlobImage(mKey.value().second(), descriptor, bytes,
                                       ViewAs<ImagePixel>(mInvalidRect))) {
         return;
       }
@@ -730,7 +734,7 @@
     mFonts = std::move(fonts);
     mInvalidRect.SetEmpty();
     aResources.SetBlobImageVisibleArea(
-        mKey.value(),
+        mKey.value().second(),
         ViewAs<ImagePixel>(mPaintRect, PixelCastJustification::LayerIsImage));
     PushImage(aBuilder, bounds);
     GP("End EndGroup\n\n");
@@ -756,7 +760,7 @@
     aBuilder.SetHitTestInfo(mScrollId, hitInfo);
     aBuilder.PushImage(dest, dest, !backfaceHidden,
                        wr::ToImageRendering(sampleFilter),
-                       wr::AsImageKey(mKey.value()));
+                       wr::AsImageKey(mKey.value().second()));
     aBuilder.ClearHitTestInfo();
   }
 
@@ -1006,6 +1010,62 @@
   }
 }
 
+size_t WebRenderScrollDataCollection::GetLayerCount(
+    wr::RenderRoot aRoot) const {
+  return mInternalScrollDatas[aRoot].size();
+}
+
+void WebRenderScrollDataCollection::AppendRoot(
+    Maybe<ScrollMetadata>& aRootMetadata,
+    wr::RenderRootArray<WebRenderScrollData>& aScrollDatas) {
+  mSeenRenderRoot[wr::RenderRoot::Default] = true;
+
+  for (auto renderRoot : wr::kRenderRoots) {
+    if (mSeenRenderRoot[renderRoot]) {
+      auto& layerScrollData = mInternalScrollDatas[renderRoot];
+      layerScrollData.emplace_back();
+      layerScrollData.back().InitializeRoot(layerScrollData.size() - 1);
+
+      if (aRootMetadata) {
+        layerScrollData.back().AppendScrollMetadata(aScrollDatas[renderRoot],
+                                                    aRootMetadata.ref());
+      }
+    }
+  }
+}
+
+void WebRenderScrollDataCollection::AppendWrapper(
+    const RenderRootBoundary& aBoundary, size_t aLayerCountBeforeRecursing) {
+  wr::RenderRoot root = aBoundary.GetChildType();
+  size_t layerCountAfterRecursing = GetLayerCount(root);
+  MOZ_ASSERT(layerCountAfterRecursing >= aLayerCountBeforeRecursing);
+  if (layerCountAfterRecursing == aLayerCountBeforeRecursing) {
+    // nothing to wrap
+    return;
+  }
+  mInternalScrollDatas[root].emplace_back();
+  mInternalScrollDatas[root].back().InitializeRoot(layerCountAfterRecursing -
+                                                   aLayerCountBeforeRecursing);
+  mInternalScrollDatas[root].back().SetBoundaryRoot(aBoundary);
+}
+
+void WebRenderScrollDataCollection::AppendScrollData(
+    const wr::DisplayListBuilder& aBuilder, WebRenderLayerManager* aManager,
+    nsDisplayItem* aItem, size_t aLayerCountBeforeRecursing,
+    const ActiveScrolledRoot* aStopAtAsr,
+    const Maybe<gfx::Matrix4x4>& aAncestorTransform) {
+  wr::RenderRoot renderRoot = aBuilder.GetRenderRoot();
+  mSeenRenderRoot[renderRoot] = true;
+
+  int descendants =
+      mInternalScrollDatas[renderRoot].size() - aLayerCountBeforeRecursing;
+
+  mInternalScrollDatas[renderRoot].emplace_back();
+  mInternalScrollDatas[renderRoot].back().Initialize(
+      aManager->GetScrollData(renderRoot), aItem, descendants, aStopAtAsr,
+      aAncestorTransform, renderRoot);
+}
+
 class WebRenderGroupData : public WebRenderUserData {
  public:
   explicit WebRenderGroupData(RenderRootStateManager* aWRManager,
@@ -1102,6 +1162,7 @@
                              item);
 
       {
+        MOZ_ASSERT(item->GetType() != DisplayItemType::TYPE_RENDER_ROOT);
         auto spaceAndClipChain = mClipManager.SwitchItem(item);
         wr::SpaceAndClipChainHelper saccHelper(aBuilder, spaceAndClipChain);
 
@@ -1109,7 +1170,8 @@
         // Note: this call to CreateWebRenderCommands can recurse back into
         // this function.
         RenderRootStateManager* manager =
-            aCommandBuilder->mManager->GetRenderRootStateManager();
+            aCommandBuilder->mManager->GetRenderRootStateManager(
+                aBuilder.GetRenderRoot());
         bool createdWRCommands = item->CreateWebRenderCommands(
             aBuilder, aResources, aSc, manager, mDisplayListBuilder);
         sIndent--;
@@ -1121,7 +1183,7 @@
 
       RefPtr<WebRenderGroupData> groupData =
           aCommandBuilder->CreateOrRecycleWebRenderUserData<WebRenderGroupData>(
-              item);
+              item, aBuilder.GetRenderRoot());
 
       // Initialize groupData->mFollowingGroup
       // TODO: compute the group bounds post-grouping, so that they can be
@@ -1145,7 +1207,8 @@
         GP("Inner group size change\n");
         groupData->mFollowingGroup.ClearItems();
         groupData->mFollowingGroup.ClearImageKey(
-            aCommandBuilder->mManager->GetRenderRootStateManager());
+            aCommandBuilder->mManager->GetRenderRootStateManager(
+                aBuilder.GetRenderRoot()));
       }
       groupData->mFollowingGroup.mGroupBounds = currentGroup->mGroupBounds;
       groupData->mFollowingGroup.mAppUnitsPerDevPixel =
@@ -1285,8 +1348,9 @@
   return rect;
 }
 
-RenderRootStateManager* WebRenderCommandBuilder::GetRenderRootStateManager() {
-  return mManager->GetRenderRootStateManager();
+RenderRootStateManager* WebRenderCommandBuilder::GetRenderRootStateManager(
+    wr::RenderRoot aRenderRoot) {
+  return mManager->GetRenderRootStateManager(aRenderRoot);
 }
 
 void WebRenderCommandBuilder::DoGroupingForDisplayList(
@@ -1299,15 +1363,16 @@
 
   GP("DoGroupingForDisplayList\n");
 
-  mClipManager.BeginList(aSc);
-  Grouper g(mClipManager);
+  mCurrentClipManager->BeginList(aSc);
+  Grouper g(*mCurrentClipManager);
 
   int32_t appUnitsPerDevPixel =
       aWrappingItem->Frame()->PresContext()->AppUnitsPerDevPixel();
 
   g.mDisplayListBuilder = aDisplayListBuilder;
   RefPtr<WebRenderGroupData> groupData =
-      CreateOrRecycleWebRenderUserData<WebRenderGroupData>(aWrappingItem);
+      CreateOrRecycleWebRenderUserData<WebRenderGroupData>(
+          aWrappingItem, aBuilder.GetRenderRoot());
 
   bool snapped;
   nsRect groupBounds =
@@ -1365,7 +1430,8 @@
     }
 
     group.ClearItems();
-    group.ClearImageKey(mManager->GetRenderRootStateManager());
+    group.ClearImageKey(
+        mManager->GetRenderRootStateManager(aBuilder.GetRenderRoot()));
   }
 
   ScrollableLayerGuid::ViewID scrollId = ScrollableLayerGuid::NULL_SCROLL_ID;
@@ -1402,7 +1468,7 @@
   group.mScrollId = scrollId;
   g.ConstructGroups(aDisplayListBuilder, this, aBuilder, aResources, &group,
                     aList, aSc);
-  mClipManager.EndList(aSc);
+  mCurrentClipManager->EndList(aSc);
 }
 
 void WebRenderCommandBuilder::Destroy() {
@@ -1428,19 +1494,26 @@
 void WebRenderCommandBuilder::BuildWebRenderCommands(
     wr::DisplayListBuilder& aBuilder,
     wr::IpcResourceUpdateQueue& aResourceUpdates, nsDisplayList* aDisplayList,
-    nsDisplayListBuilder* aDisplayListBuilder, WebRenderScrollData& aScrollData,
-    wr::LayoutSize& aContentSize, WrFiltersHolder&& aFilters) {
+    nsDisplayListBuilder* aDisplayListBuilder,
+    wr::RenderRootArray<WebRenderScrollData>& aScrollDatas,
+    WrFiltersHolder&& aFilters) {
   AUTO_PROFILER_LABEL_CATEGORY_PAIR(GRAPHICS_WRDisplayList);
+  wr::RenderRootArray<StackingContextHelper> rootScs;
+  MOZ_ASSERT(aBuilder.GetRenderRoot() == wr::RenderRoot::Default);
 
-  StackingContextHelper sc;
-  aScrollData = WebRenderScrollData(mManager);
-  MOZ_ASSERT(mLayerScrollData.empty());
+  for (auto renderRoot : wr::kRenderRoots) {
+    aScrollDatas[renderRoot] = WebRenderScrollData(mManager);
+    if (aBuilder.HasSubBuilder(renderRoot)) {
+      mClipManagers[renderRoot].BeginBuild(mManager,
+                                           aBuilder.SubBuilder(renderRoot));
+    }
+  }
+  MOZ_ASSERT(mLayerScrollDatas.IsEmpty());
   mLastCanvasDatas.Clear();
   mLastAsr = nullptr;
   mBuilderDumpIndex = 0;
   mContainsSVGGroup = false;
   MOZ_ASSERT(mDumpIndent == 0);
-  mClipManager.BeginBuild(mManager, aBuilder);
 
   {
     nsPresContext* presContext =
@@ -1448,46 +1521,64 @@
     bool isTopLevelContent =
         presContext->Document()->IsTopLevelContentDocument();
 
-    wr::StackingContextParams params;
-    params.mFilters = std::move(aFilters.filters);
-    params.mFilterDatas = std::move(aFilters.filter_datas);
-    params.cache_tiles = isTopLevelContent;
-    params.clip =
-        wr::WrStackingContextClip::ClipChain(aBuilder.CurrentClipChainId());
-
-    StackingContextHelper pageRootSc(sc, nullptr, nullptr, nullptr, aBuilder,
-                                     params);
+    wr::RenderRootArray<Maybe<StackingContextHelper>> pageRootScs;
+    for (auto renderRoot : wr::kRenderRoots) {
+      if (aBuilder.HasSubBuilder(renderRoot)) {
+        wr::StackingContextParams params;
+        // Just making this explicit - we assume that we do not want any
+        // filters traversing a RenderRoot boundary
+        if (renderRoot == wr::RenderRoot::Default) {
+          params.mFilters = std::move(aFilters.filters);
+          params.mFilterDatas = std::move(aFilters.filter_datas);
+        }
+        params.cache_tiles = isTopLevelContent;
+        params.clip = wr::WrStackingContextClip::ClipChain(
+            aBuilder.SubBuilder(renderRoot).CurrentClipChainId());
+        pageRootScs[renderRoot].emplace(
+            rootScs[renderRoot], nullptr, nullptr, nullptr,
+            aBuilder.SubBuilder(renderRoot), params);
+      }
+    }
     if (ShouldDumpDisplayList(aDisplayListBuilder)) {
       mBuilderDumpIndex =
           aBuilder.Dump(mDumpIndent + 1, Some(mBuilderDumpIndex), Nothing());
     }
-    CreateWebRenderCommandsFromDisplayList(aDisplayList, nullptr,
-                                           aDisplayListBuilder, pageRootSc,
-                                           aBuilder, aResourceUpdates);
+    MOZ_ASSERT(mRootStackingContexts == nullptr);
+    AutoRestore<wr::RenderRootArray<Maybe<StackingContextHelper>>*> rootScs(
+        mRootStackingContexts);
+    mRootStackingContexts = &pageRootScs;
+    CreateWebRenderCommandsFromDisplayList(
+        aDisplayList, nullptr, aDisplayListBuilder,
+        *pageRootScs[wr::RenderRoot::Default], aBuilder, aResourceUpdates);
   }
 
-  // Make a "root" layer data that has everything else as descendants
-  mLayerScrollData.emplace_back();
-  mLayerScrollData.back().InitializeRoot(mLayerScrollData.size() - 1);
   auto callback =
-      [&aScrollData](ScrollableLayerGuid::ViewID aScrollId) -> bool {
-    return aScrollData.HasMetadataFor(aScrollId).isSome();
+      [&aScrollDatas](ScrollableLayerGuid::ViewID aScrollId) -> bool {
+    for (auto renderRoot : wr::kRenderRoots) {
+      if (aScrollDatas[renderRoot].HasMetadataFor(aScrollId).isSome()) {
+        return true;
+      }
+    }
+    return false;
   };
-  if (Maybe<ScrollMetadata> rootMetadata = nsLayoutUtils::GetRootMetadata(
-          aDisplayListBuilder, mManager, ContainerLayerParameters(),
-          callback)) {
-    mLayerScrollData.back().AppendScrollMetadata(aScrollData,
-                                                 rootMetadata.ref());
+  Maybe<ScrollMetadata> rootMetadata = nsLayoutUtils::GetRootMetadata(
+      aDisplayListBuilder, mManager, ContainerLayerParameters(), callback);
+
+  mLayerScrollDatas.AppendRoot(rootMetadata, aScrollDatas);
+
+  for (auto renderRoot : wr::kRenderRoots) {
+    // Append the WebRenderLayerScrollData items into WebRenderScrollData
+    // in reverse order, from topmost to bottommost. This is in keeping with
+    // the semantics of WebRenderScrollData.
+    for (auto it = mLayerScrollDatas[renderRoot].crbegin();
+         it != mLayerScrollDatas[renderRoot].crend(); it++) {
+      aScrollDatas[renderRoot].AddLayerData(*it);
+    }
+    if (aBuilder.HasSubBuilder(renderRoot)) {
+      mClipManagers[renderRoot].EndBuild();
+    }
   }
-  // Append the WebRenderLayerScrollData items into WebRenderScrollData
-  // in reverse order, from topmost to bottommost. This is in keeping with
-  // the semantics of WebRenderScrollData.
-  for (auto i = mLayerScrollData.crbegin(); i != mLayerScrollData.crend();
-       i++) {
-    aScrollData.AddLayerData(*i);
-  }
-  mLayerScrollData.clear();
-  mClipManager.EndBuild();
+  mLayerScrollDatas.Clear();
 
   // Remove the user data those are not displayed on the screen and
   // also reset the data to unused for next transaction.
@@ -1505,6 +1596,8 @@
     nsDisplayList* aDisplayList, nsDisplayItem* aWrappingItem,
     nsDisplayListBuilder* aDisplayListBuilder, const StackingContextHelper& aSc,
     wr::DisplayListBuilder& aBuilder, wr::IpcResourceUpdateQueue& aResources) {
+  AutoRestore<ClipManager*> prevClipManager(mCurrentClipManager);
+  mCurrentClipManager = &mClipManagers[aBuilder.GetRenderRoot()];
   if (mDoGrouping) {
     MOZ_RELEASE_ASSERT(
         aWrappingItem,
@@ -1525,7 +1618,7 @@
   }
 
   mDumpIndent++;
-  mClipManager.BeginList(aSc);
+  mCurrentClipManager->BeginList(aSc);
 
   bool apzEnabled = mManager->AsyncPanZoomEnabled();
 
@@ -1543,7 +1636,8 @@
     }
 
     bool forceNewLayerData = false;
-    size_t layerCountBeforeRecursing = mLayerScrollData.size();
+    size_t layerCountBeforeRecursing =
+        mLayerScrollDatas.GetLayerCount(aBuilder.GetRenderRoot());
     if (apzEnabled) {
       // For some types of display items we want to force a new
       // WebRenderLayerScrollData object, to ensure we preserve the APZ-relevant
@@ -1584,7 +1678,7 @@
 
     // This is where we emulate the clip/scroll stack that was previously
     // implemented on the WR display list side.
-    auto spaceAndClipChain = mClipManager.SwitchItem(item);
+    auto spaceAndClipChain = mCurrentClipManager->SwitchItem(item);
     wr::SpaceAndClipChainHelper saccHelper(aBuilder, spaceAndClipChain);
 
     {  // scope restoreDoGrouping
@@ -1634,7 +1728,8 @@
       // Note: this call to CreateWebRenderCommands can recurse back into
       // this function if the |item| is a wrapper for a sublist.
       item->SetPaintRect(item->GetBuildingRect());
-      RenderRootStateManager* manager = mManager->GetRenderRootStateManager();
+      RenderRootStateManager* manager =
+          mManager->GetRenderRootStateManager(aBuilder.GetRenderRoot());
       bool createdWRCommands = item->CreateWebRenderCommands(
           aBuilder, aResources, aSc, manager, aDisplayListBuilder);
       if (!createdWRCommands) {
@@ -1655,9 +1750,6 @@
         const ActiveScrolledRoot* stopAtAsr =
             mAsrStack.empty() ? nullptr : mAsrStack.back();
 
-        int32_t descendants =
-            mLayerScrollData.size() - layerCountBeforeRecursing;
-
         // See the comments on StackingContextHelper::mDeferredTransformItem
         // for an overview of what deferred transforms are.
         // In the case where we deferred a transform, but have a child display
@@ -1677,52 +1769,45 @@
                             item->GetActiveScrolledRoot()) {
           // This creates the child WebRenderLayerScrollData for |item|, but
           // omits the transform (hence the Nothing() as the last argument to
-          // Initialize(...)). We also need to make sure that the ASR from
+          // AppendScrollData(...)). We also need to make sure that the ASR from
           // the deferred transform item is not on this node, so we use that
           // ASR as the "stop at" ASR for this WebRenderLayerScrollData.
-          mLayerScrollData.emplace_back();
-          mLayerScrollData.back().Initialize(
-              mManager->GetScrollData(), item, descendants,
+          mLayerScrollDatas.AppendScrollData(
+              aBuilder, mManager, item, layerCountBeforeRecursing,
               (*deferred)->GetActiveScrolledRoot(), Nothing());
 
-          // The above WebRenderLayerScrollData will also be a descendant of
-          // the transform-holding WebRenderLayerScrollData we create below.
-          descendants++;
-
           // This creates the WebRenderLayerScrollData for the deferred
           // transform item. This holds the transform matrix and the remaining
           // ASRs needed to complete the ASR chain (i.e. the ones from the
           // stopAtAsr down to the deferred transform item's ASR, which must be
           // "between" stopAtAsr and |item|'s ASR in the ASR tree).
-          mLayerScrollData.emplace_back();
-          mLayerScrollData.back().Initialize(mManager->GetScrollData(),
-                                             *deferred, descendants, stopAtAsr,
-                                             aSc.GetDeferredTransformMatrix());
+          mLayerScrollDatas.AppendScrollData(
+              aBuilder, mManager, *deferred, layerCountBeforeRecursing,
+              stopAtAsr, aSc.GetDeferredTransformMatrix());
         } else {
           // This is the "simple" case where we don't need to create two
           // WebRenderLayerScrollData items; we can just create one that also
           // holds the deferred transform matrix, if any.
-          mLayerScrollData.emplace_back();
-          mLayerScrollData.back().Initialize(mManager->GetScrollData(), item,
-                                             descendants, stopAtAsr,
-                                             aSc.GetDeferredTransformMatrix());
+          mLayerScrollDatas.AppendScrollData(
+              aBuilder, mManager, item, layerCountBeforeRecursing, stopAtAsr,
+              aSc.GetDeferredTransformMatrix());
         }
       }
     }
   }
 
   mDumpIndent--;
-  mClipManager.EndList(aSc);
+  mCurrentClipManager->EndList(aSc);
 }
 
 void WebRenderCommandBuilder::PushOverrideForASR(
     const ActiveScrolledRoot* aASR, const wr::WrSpatialId& aSpatialId) {
-  mClipManager.PushOverrideForASR(aASR, aSpatialId);
+  mCurrentClipManager->PushOverrideForASR(aASR, aSpatialId);
 }
 
 void WebRenderCommandBuilder::PopOverrideForASR(
     const ActiveScrolledRoot* aASR) {
-  mClipManager.PopOverrideForASR(aASR);
+  mCurrentClipManager->PopOverrideForASR(aASR);
 }
 
 Maybe<wr::ImageKey> WebRenderCommandBuilder::CreateImageKey(
@@ -1732,7 +1817,8 @@
     mozilla::wr::ImageRendering aRendering, const StackingContextHelper& aSc,
     gfx::IntSize& aSize, const Maybe<LayoutDeviceRect>& aAsyncImageBounds) {
   RefPtr<WebRenderImageData> imageData =
-      CreateOrRecycleWebRenderUserData<WebRenderImageData>(aItem);
+      CreateOrRecycleWebRenderUserData<WebRenderImageData>(
+          aItem, aBuilder.GetRenderRoot());
   MOZ_ASSERT(imageData);
 
   if (aContainer->IsAsync()) {
@@ -1990,7 +2076,8 @@
   }
 
   RefPtr<WebRenderFallbackData> fallbackData =
-      CreateOrRecycleWebRenderUserData<WebRenderFallbackData>(aItem);
+      CreateOrRecycleWebRenderUserData<WebRenderFallbackData>(
+          aItem, aBuilder.GetRenderRoot());
 
   bool snap;
   nsRect itemBounds = aItem->GetBounds(aDisplayListBuilder, &snap);
@@ -2117,7 +2204,7 @@
                 for (auto& scaled : aScaledFonts) {
                   Maybe<wr::FontInstanceKey> key =
                       mManager->WrBridge()->GetFontKeyForScaledFont(
-                          scaled, &aResources);
+                          scaled, aBuilder.GetRenderRoot(), &aResources);
                   if (key.isNothing()) {
                     validFonts = false;
                     break;
@@ -2139,8 +2226,10 @@
           aItem, dt, offset, aDisplayListBuilder,
           fallbackData->mBasicLayerManager, scale, highlight);
       recorder->FlushItem(IntRect({0, 0}, dtSize.ToUnknownSize()));
-      TakeExternalSurfaces(recorder, fallbackData->mExternalSurfaces,
-                           mManager->GetRenderRootStateManager(), aResources);
+      TakeExternalSurfaces(
+          recorder, fallbackData->mExternalSurfaces,
+          mManager->GetRenderRootStateManager(aBuilder.GetRenderRoot()),
+          aResources);
       recorder->Finish();
 
       if (!validFonts) {
@@ -2199,7 +2288,7 @@
 
         if (isInvalidated) {
           // Update image if there it's invalidated.
-          if (!helper.UpdateImage()) {
+          if (!helper.UpdateImage(aBuilder.GetRenderRoot())) {
             return nullptr;
           }
         } else {
@@ -2271,7 +2360,8 @@
     nsDisplayListBuilder* aDisplayListBuilder,
     const LayoutDeviceRect& aBounds) {
   RefPtr<WebRenderMaskData> maskData =
-      CreateOrRecycleWebRenderUserData<WebRenderMaskData>(aMaskItem);
+      CreateOrRecycleWebRenderUserData<WebRenderMaskData>(
+          aMaskItem, aBuilder.GetRenderRoot());
 
   if (!maskData) {
     return Nothing();
@@ -2322,8 +2412,8 @@
 
               for (auto& scaled : aScaledFonts) {
                 Maybe<wr::FontInstanceKey> key =
-                    mManager->WrBridge()->GetFontKeyForScaledFont(scaled,
-                                                                  &aResources);
+                    mManager->WrBridge()->GetFontKeyForScaledFont(
+                        scaled, aBuilder.GetRenderRoot(), &aResources);
                 if (key.isNothing()) {
                   validFonts = false;
                   break;
@@ -2355,8 +2445,10 @@
     }
 
     recorder->FlushItem(IntRect(0, 0, size.width, size.height));
-    TakeExternalSurfaces(recorder, maskData->mExternalSurfaces,
-                         mManager->GetRenderRootStateManager(), aResources);
+    TakeExternalSurfaces(
+        recorder, maskData->mExternalSurfaces,
+        mManager->GetRenderRootStateManager(aBuilder.GetRenderRoot()),
+        aResources);
     recorder->Finish();
 
     if (!validFonts) {
@@ -2467,5 +2559,18 @@
   mFollowingGroup.ClearImageKey(mManager, true);
 }
 
+WebRenderCommandBuilder::ScrollDataBoundaryWrapper::ScrollDataBoundaryWrapper(
+    WebRenderCommandBuilder& aBuilder, RenderRootBoundary& aBoundary)
+    : mBuilder(aBuilder), mBoundary(aBoundary) {
+  mLayerCountBeforeRecursing =
+      mBuilder.mLayerScrollDatas.GetLayerCount(mBoundary.GetChildType());
+}
+
+WebRenderCommandBuilder::ScrollDataBoundaryWrapper::
+    ~ScrollDataBoundaryWrapper() {
+  mBuilder.mLayerScrollDatas.AppendWrapper(mBoundary,
+                                           mLayerCountBeforeRecursing);
+}
+
 }  // namespace layers
 }  // namespace mozilla