# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderScrollDataWrapper.h
# Commit: c09a51622e98
# Full Hash: c09a51622e988e81077c75e3aaa5a49df66284b3
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-22 16:44:08
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 737807563dd5 -r c09a51622e98 gfx/layers/wr/WebRenderScrollDataWrapper.h
--- a/gfx/layers/wr/WebRenderScrollDataWrapper.h	Thu Mar 21 23:14:26 2019 +0000
+++ b/gfx/layers/wr/WebRenderScrollDataWrapper.h	Fri Mar 22 03:15:14 2019 +0000
@@ -45,9 +45,11 @@
   // Basic constructor for external callers. Starts the walker at the root of
   // the tree.
   explicit WebRenderScrollDataWrapper(
-      const APZUpdater& aUpdater, const WebRenderScrollData* aData = nullptr)
+      const APZUpdater& aUpdater, WRRootId aWrRootId,
+      const WebRenderScrollData* aData = nullptr)
       : mUpdater(&aUpdater),
         mData(aData),
+        mWrRootId(aWrRootId),
         mLayerIndex(0),
         mContainingSubtreeLastIndex(0),
         mLayer(nullptr),
@@ -77,12 +79,13 @@
   // Internal constructor for walking from one WebRenderLayerScrollData to
   // another. In this case we need to recompute the mMetadataIndex to be the
   // "topmost" scroll metadata on the new layer.
-  WebRenderScrollDataWrapper(const APZUpdater* aUpdater,
+  WebRenderScrollDataWrapper(const APZUpdater* aUpdater, WRRootId aWrRootId,
                              const WebRenderScrollData* aData,
                              size_t aLayerIndex,
                              size_t aContainingSubtreeLastIndex)
       : mUpdater(aUpdater),
         mData(aData),
+        mWrRootId(aWrRootId),
         mLayerIndex(aLayerIndex),
         mContainingSubtreeLastIndex(aContainingSubtreeLastIndex),
         mLayer(nullptr),
@@ -101,7 +104,7 @@
 
   // Internal constructor for walking from one metadata to another metadata on
   // the same WebRenderLayerScrollData.
-  WebRenderScrollDataWrapper(const APZUpdater* aUpdater,
+  WebRenderScrollDataWrapper(const APZUpdater* aUpdater, WRRootId aWrRootId,
                              const WebRenderScrollData* aData,
                              size_t aLayerIndex,
                              size_t aContainingSubtreeLastIndex,
@@ -109,6 +112,7 @@
                              uint32_t aMetadataIndex)
       : mUpdater(aUpdater),
         mData(aData),
+        mWrRootId(aWrRootId),
         mLayerIndex(aLayerIndex),
         mContainingSubtreeLastIndex(aContainingSubtreeLastIndex),
         mLayer(aLayer),
@@ -132,7 +136,7 @@
       // If we're still walking around in the virtual container layers created
       // by the ScrollMetadata array, we just need to update the metadata index
       // and that's it.
-      return WebRenderScrollDataWrapper(mUpdater, mData, mLayerIndex,
+      return WebRenderScrollDataWrapper(mUpdater, mWrRootId, mData, mLayerIndex,
                                         mContainingSubtreeLastIndex, mLayer,
                                         mMetadataIndex - 1);
     }
@@ -150,8 +154,42 @@
       size_t prevSiblingIndex = mLayerIndex + 1 + mLayer->GetDescendantCount();
       size_t subtreeLastIndex =
           std::min(mContainingSubtreeLastIndex, prevSiblingIndex);
-      return WebRenderScrollDataWrapper(mUpdater, mData, mLayerIndex + 1,
-                                        subtreeLastIndex);
+      return WebRenderScrollDataWrapper(mUpdater, mWrRootId, mData,
+                                        mLayerIndex + 1, subtreeLastIndex);
+    }
+
+    if (mLayer->GetReferentRenderRoot()) {
+      MOZ_ASSERT(!mLayer->GetReferentId());
+      MOZ_ASSERT(mLayer->GetReferentRenderRoot()->GetChildType() !=
+                 mWrRootId.mRenderRoot);
+
+      WRRootId newWrRootId = WRRootId(
+          mWrRootId.mLayersId, mLayer->GetReferentRenderRoot()->GetChildType());
+      const WebRenderScrollData* childData =
+          mUpdater->GetScrollData(newWrRootId);
+      // See the comment above RenderRootBoundary for more context on what's
+      // happening here. We need to fish out the appropriate wrapper root from
+      // inside the dummy root. Note that the wrapper root should always be a
+      // direct descendant of the dummy root, so we can pass
+      // `childData->GetLayerCount()` for the `aContainingSubtreeLastIndex`
+      // parameter below.
+      Maybe<size_t> layerIndex;
+      for (size_t i = 0; i < childData->GetLayerCount(); i++) {
+        const WebRenderLayerScrollData* wrlsd = childData->GetLayerData(i);
+        if (wrlsd->GetBoundaryRoot() == mLayer->GetReferentRenderRoot()) {
+          // found it
+          layerIndex = Some(i);
+          break;
+        }
+      }
+      if (!layerIndex) {
+        // It's possible that there's no wrapper root. In that case there are
+        // no descendants
+        return WebRenderScrollDataWrapper(*mUpdater, mWrRootId);
+      }
+      return WebRenderScrollDataWrapper(mUpdater, newWrRootId, childData,
+                                        *layerIndex,
+                                        childData->GetLayerCount());
     }
 
     // We've run out of descendants. But! If the original layer was a RefLayer,
@@ -159,11 +197,13 @@
     // So return a WebRenderScrollDataWrapper for the root of the child layer
     // tree.
     if (mLayer->GetReferentId()) {
-      return WebRenderScrollDataWrapper(
-          *mUpdater, mUpdater->GetScrollData(*mLayer->GetReferentId()));
+      WRRootId newWrRootId =
+          WRRootId(*mLayer->GetReferentId(), mWrRootId.mRenderRoot);
+      return WebRenderScrollDataWrapper(*mUpdater, newWrRootId,
+                                        mUpdater->GetScrollData(newWrRootId));
     }
 
-    return WebRenderScrollDataWrapper(*mUpdater);
+    return WebRenderScrollDataWrapper(*mUpdater, mWrRootId);
   }
 
   WebRenderScrollDataWrapper GetPrevSibling() const {
@@ -171,17 +211,18 @@
 
     if (!AtTopLayer()) {
       // The virtual container layers don't have siblings
-      return WebRenderScrollDataWrapper(*mUpdater);
+      return WebRenderScrollDataWrapper(*mUpdater, mWrRootId);
     }
 
     // Skip past the descendants to get to the previous sibling. However, we
     // might be at the last sibling already.
     size_t prevSiblingIndex = mLayerIndex + 1 + mLayer->GetDescendantCount();
     if (prevSiblingIndex < mContainingSubtreeLastIndex) {
-      return WebRenderScrollDataWrapper(mUpdater, mData, prevSiblingIndex,
+      return WebRenderScrollDataWrapper(mUpdater, mWrRootId, mData,
+                                        prevSiblingIndex,
                                         mContainingSubtreeLastIndex);
     }
-    return WebRenderScrollDataWrapper(*mUpdater);
+    return WebRenderScrollDataWrapper(*mUpdater, mWrRootId);
   }
 
   const ScrollMetadata& Metadata() const {
@@ -263,6 +304,17 @@
     return Nothing();
   }
 
+  Maybe<wr::RenderRoot> GetReferentRenderRoot() const {
+    MOZ_ASSERT(IsValid());
+
+    if (AtBottomLayer()) {
+      if (mLayer->GetReferentRenderRoot()) {
+        return Some(mLayer->GetReferentRenderRoot()->GetChildType());
+      }
+    }
+    return Nothing();
+  }
+
   Maybe<ParentLayerIntRect> GetClipRect() const {
     // TODO
     return Nothing();
@@ -310,6 +362,8 @@
     return mLayer;
   }
 
+  wr::RenderRoot GetRenderRoot() const { return mWrRootId.mRenderRoot; }
+
  private:
   bool AtBottomLayer() const { return mMetadataIndex == 0; }
 
@@ -321,6 +375,7 @@
  private:
   const APZUpdater* mUpdater;
   const WebRenderScrollData* mData;
+  WRRootId mWrRootId;
   // The index (in mData->mLayerScrollData) of the WebRenderLayerScrollData this
   // wrapper is pointing to.
   size_t mLayerIndex;