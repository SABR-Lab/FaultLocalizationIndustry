# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderUserData.cpp
# Commit: c09a51622e98
# Full Hash: c09a51622e988e81077c75e3aaa5a49df66284b3
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2019-03-22 16:44:08
# Regressor Bug: 1441308
# File Overlap Count: 2
# Description:
#   Bug 1441308 - Core renderroot splitting changes r=kats,sotaro
#   
#   This is a large patch that contains all of the core changes for
#   renderroot splitting.
#   
# ==============================================================================

diff -r 737807563dd5 -r c09a51622e98 gfx/layers/wr/WebRenderUserData.cpp
--- a/gfx/layers/wr/WebRenderUserData.cpp	Thu Mar 21 23:14:26 2019 +0000
+++ b/gfx/layers/wr/WebRenderUserData.cpp	Fri Mar 22 03:15:14 2019 +0000
@@ -130,7 +130,8 @@
     if (mOwnsKey) {
       mManager->AddImageKeyForDiscard(mKey.value());
       if (mTextureOfImage) {
-        WrBridge()->ReleaseTextureOfImage(mKey.value());
+        WrBridge()->ReleaseTextureOfImage(mKey.value(),
+                                          mManager->GetRenderRoot());
         mTextureOfImage = nullptr;
       }
     }
@@ -179,7 +180,8 @@
   ImageClientSingle* imageClient = mImageClient->AsImageClientSingle();
   uint32_t oldCounter = imageClient->GetLastUpdateGenerationCounter();
 
-  bool ret = imageClient->UpdateImage(aContainer, /* unused */ 0);
+  bool ret = imageClient->UpdateImage(aContainer, /* unused */ 0,
+                                      Some(mManager->GetRenderRoot()));
   RefPtr<TextureClient> currentTexture = imageClient->GetForwardedTexture();
   if (!ret || !currentTexture) {
     // Delete old key
@@ -237,7 +239,8 @@
   if (mPipelineId.isSome() && mContainer != aContainer) {
     // In this case, we need to remove the existed pipeline and create new one
     // because the ImageContainer is changed.
-    WrBridge()->RemovePipelineIdForCompositable(mPipelineId.ref());
+    WrBridge()->RemovePipelineIdForCompositable(mPipelineId.ref(),
+                                                mManager->GetRenderRoot());
     mPipelineId.reset();
   }
 
@@ -246,7 +249,8 @@
     mPipelineId =
         Some(WrBridge()->GetCompositorBridgeChild()->GetNextPipelineId());
     WrBridge()->AddPipelineIdForAsyncCompositable(
-        mPipelineId.ref(), aContainer->GetAsyncContainerHandle());
+        mPipelineId.ref(), aContainer->GetAsyncContainerHandle(),
+        mManager->GetRenderRoot());
     mContainer = aContainer;
   }
   MOZ_ASSERT(!mImageClient);
@@ -265,7 +269,8 @@
 
   WrBridge()->AddWebRenderParentCommand(
       OpUpdateAsyncImagePipeline(mPipelineId.value(), aSCBounds, aSCTransform,
-                                 aScaleToSize, aFilter, aMixBlendMode));
+                                 aScaleToSize, aFilter, aMixBlendMode),
+      mManager->GetRenderRoot());
 }
 
 void WebRenderImageData::CreateImageClientIfNeeded() {
@@ -367,6 +372,22 @@
   return mCanvasRenderer.get();
 }
 
+WebRenderRenderRootData::WebRenderRenderRootData(RenderRootStateManager* aManager,
+                                                 nsDisplayItem* aItem)
+    : WebRenderUserData(aManager, aItem) {}
+
+RenderRootBoundary& WebRenderRenderRootData::EnsureHasBoundary(
+    wr::RenderRoot aChildType) {
+  if (mBoundary) {
+    MOZ_ASSERT(mBoundary->GetChildType() == aChildType);
+  } else {
+    mBoundary.emplace(aChildType);
+  }
+  return mBoundary.ref();
+}
+
+WebRenderRenderRootData::~WebRenderRenderRootData() {}
+
 void DestroyWebRenderUserDataTable(WebRenderUserDataTable* aTable) {
   for (auto iter = aTable->Iter(); !iter.Done(); iter.Next()) {
     iter.UserData()->RemoveFromTable();