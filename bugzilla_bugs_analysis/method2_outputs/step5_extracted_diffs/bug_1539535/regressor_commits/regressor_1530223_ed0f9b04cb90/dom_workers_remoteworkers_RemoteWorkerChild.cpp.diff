# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/remoteworkers/RemoteWorkerChild.cpp
# Commit: ed0f9b04cb90
# Full Hash: ed0f9b04cb90ae9959ed5d37bec8454c676ff48e
# Author: Yaron Tausky <ytausky@mozilla.com>
# Date: 2019-03-07 04:32:57
# Regressor Bug: 1530223
# File Overlap Count: 1
# Description:
#   Bug 1530223: Use ThreadBound for RemoteWorkerChild members accessed on launcher thread r=perry,asuth
#   
#   This adds runtime checks that verify thread safety.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D22338
# ==============================================================================

diff -r c66813164419 -r ed0f9b04cb90 dom/workers/remoteworkers/RemoteWorkerChild.cpp
--- a/dom/workers/remoteworkers/RemoteWorkerChild.cpp	Wed Mar 06 19:12:47 2019 +0000
+++ b/dom/workers/remoteworkers/RemoteWorkerChild.cpp	Wed Mar 06 19:00:10 2019 +0000
@@ -201,8 +201,9 @@
 }
 
 void RemoteWorkerChild::ActorDestroy(ActorDestroyReason aWhy) {
+  MOZ_ACCESS_THREAD_BOUND(mLauncherData, data);
   mIPCActive = false;
-  mPendingOps.Clear();
+  data->mPendingOps.Clear();
 }
 
 void RemoteWorkerChild::ExecWorker(const RemoteWorkerData& aData) {
@@ -367,10 +368,10 @@
 }
 
 void RemoteWorkerChild::WorkerTerminated() {
-  MOZ_ASSERT(RemoteWorkerService::Thread()->IsOnCurrentThread());
+  MOZ_ACCESS_THREAD_BOUND(mLauncherData, data);
 
   mWorkerState = eTerminated;
-  mPendingOps.Clear();
+  data->mPendingOps.Clear();
 
   if (!mIPCActive) {
     return;
@@ -469,13 +470,15 @@
 }
 
 IPCResult RemoteWorkerChild::RecvExecOp(const RemoteWorkerOp& aOp) {
+  MOZ_ACCESS_THREAD_BOUND(mLauncherData, data);
+
   if (!mIPCActive) {
     return IPC_OK();
   }
 
   // The worker is not ready yet.
   if (mWorkerState == ePending) {
-    mPendingOps.AppendElement(aOp);
+    data->mPendingOps.AppendElement(aOp);
     return IPC_OK();
   }
 
@@ -589,7 +592,7 @@
 }
 
 void RemoteWorkerChild::CreationSucceeded() {
-  MOZ_ASSERT(RemoteWorkerService::Thread()->IsOnCurrentThread());
+  MOZ_ACCESS_THREAD_BOUND(mLauncherData, data);
 
   // The worker is created but we need to terminate it already.
   if (mWorkerState == ePendingTerminated) {
@@ -610,11 +613,11 @@
     return;
   }
 
-  for (const RemoteWorkerOp& op : mPendingOps) {
+  for (const RemoteWorkerOp& op : data->mPendingOps) {
     RecvExecOp(op);
   }
 
-  mPendingOps.Clear();
+  data->mPendingOps.Clear();
 
   Unused << SendCreated(true);
 }
@@ -629,10 +632,10 @@
 }
 
 void RemoteWorkerChild::CreationFailed() {
-  MOZ_ASSERT(RemoteWorkerService::Thread()->IsOnCurrentThread());
+  MOZ_ACCESS_THREAD_BOUND(mLauncherData, data);
 
   mWorkerState = eTerminated;
-  mPendingOps.Clear();
+  data->mPendingOps.Clear();
 
   if (!mIPCActive) {
     return;