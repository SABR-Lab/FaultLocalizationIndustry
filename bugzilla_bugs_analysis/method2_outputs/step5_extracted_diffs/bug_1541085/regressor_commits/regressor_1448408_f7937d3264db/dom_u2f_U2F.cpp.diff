# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/u2f/U2F.cpp
# Commit: f7937d3264db
# Full Hash: f7937d3264db00771b46cb1fcba71640d8df05cb
# Author: J.C. Jones <jjones@mozilla.com>
# Date: 2019-03-30 09:32:04
# Regressor Bug: 1448408
# File Overlap Count: 2
# Description:
#   Bug 1448408 - Web Authentication - Don't immediately abort on visibility events r=keeler
#   
#   The published recommendation of L1 for WebAuthn changed the visibility/focus
#   listening behaviors to a SHOULD [1], and Chromium, for reasons like our SoftU2F
#   bug [0], opted to not interrupt on tabswitch/visibility change.
# ==============================================================================

diff -r a5c4f7e6069a -r f7937d3264db dom/u2f/U2F.cpp
--- a/dom/u2f/U2F.cpp	Fri Mar 29 19:38:53 2019 +0000
+++ b/dom/u2f/U2F.cpp	Fri Mar 29 17:59:08 2019 +0000
@@ -174,10 +174,6 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aCb);
 
-  // Assert that mTransaction was cleared before before we were called to allow
-  // reentrancy from microtask checkpoints.
-  MOZ_ASSERT(mTransaction.isNothing());
-
   ErrorResult error;
   aCb->Call(aResp, error);
   NS_WARNING_ASSERTION(!error.Failed(), "dom::U2F::Promise callback failed");
@@ -192,10 +188,6 @@
                    ErrorResult& aRv) {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (mTransaction.isSome()) {
-    CancelTransaction(NS_ERROR_ABORT);
-  }
-
   nsMainThreadPtrHandle<U2FRegisterCallback> callback(
       new nsMainThreadPtrHolder<U2FRegisterCallback>("U2F::Register::callback",
                                                      &aCallback));
@@ -205,6 +197,23 @@
     return;
   }
 
+  if (mTransaction.isSome()) {
+    // If there hasn't been a visibility change during the current
+    // transaction, then let's let that one complete rather than
+    // cancelling it on a subsequent call.
+    if (!mTransaction.ref().mVisibilityChanged) {
+      RegisterResponse response;
+      response.mErrorCode.Construct(
+          static_cast<uint32_t>(ErrorCode::OTHER_ERROR));
+      ExecuteCallback(response, callback);
+      return;
+    }
+
+    // Otherwise, the user may well have clicked away, so let's
+    // abort the old transaction and take over control from here.
+    CancelTransaction(NS_ERROR_ABORT);
+  }
+
   // Evaluate the AppID
   nsString adjustedAppId(aAppId);
   if (!EvaluateAppID(mParent, mOrigin, adjustedAppId)) {
@@ -342,10 +351,6 @@
                ErrorResult& aRv) {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (mTransaction.isSome()) {
-    CancelTransaction(NS_ERROR_ABORT);
-  }
-
   nsMainThreadPtrHandle<U2FSignCallback> callback(
       new nsMainThreadPtrHolder<U2FSignCallback>("U2F::Sign::callback",
                                                  &aCallback));
@@ -355,6 +360,23 @@
     return;
   }
 
+  if (mTransaction.isSome()) {
+    // If there hasn't been a visibility change during the current
+    // transaction, then let's let that one complete rather than
+    // cancelling it on a subsequent call.
+    if (!mTransaction.ref().mVisibilityChanged) {
+      SignResponse response;
+      response.mErrorCode.Construct(
+          static_cast<uint32_t>(ErrorCode::OTHER_ERROR));
+      ExecuteCallback(response, callback);
+      return;
+    }
+
+    // Otherwise, the user may well have clicked away, so let's
+    // abort the old transaction and take over control from here.
+    CancelTransaction(NS_ERROR_ABORT);
+  }
+
   // Evaluate the AppID
   nsString adjustedAppId(aAppId);
   if (!EvaluateAppID(mParent, mOrigin, adjustedAppId)) {
@@ -545,5 +567,11 @@
   }
 }
 
+void U2F::HandleVisibilityChange() {
+  if (mTransaction.isSome()) {
+    mTransaction.ref().mVisibilityChanged = true;
+  }
+}
+
 }  // namespace dom
 }  // namespace mozilla