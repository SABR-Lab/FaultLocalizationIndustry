# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webauthn/WebAuthnManager.cpp
# Commit: f7937d3264db
# Full Hash: f7937d3264db00771b46cb1fcba71640d8df05cb
# Author: J.C. Jones <jjones@mozilla.com>
# Date: 2019-03-30 09:32:04
# Regressor Bug: 1448408
# File Overlap Count: 2
# Description:
#   Bug 1448408 - Web Authentication - Don't immediately abort on visibility events r=keeler
#   
#   The published recommendation of L1 for WebAuthn changed the visibility/focus
#   listening behaviors to a SHOULD [1], and Chromium, for reasons like our SoftU2F
#   bug [0], opted to not interrupt on tabswitch/visibility change.
# ==============================================================================

diff -r a5c4f7e6069a -r f7937d3264db dom/webauthn/WebAuthnManager.cpp
--- a/dom/webauthn/WebAuthnManager.cpp	Fri Mar 29 19:38:53 2019 +0000
+++ b/dom/webauthn/WebAuthnManager.cpp	Fri Mar 29 17:59:08 2019 +0000
@@ -180,6 +180,12 @@
   RejectTransaction(aError);
 }
 
+void WebAuthnManager::HandleVisibilityChange() {
+  if (mTransaction.isSome()) {
+    mTransaction.ref().mVisibilityChanged = true;
+  }
+}
+
 WebAuthnManager::~WebAuthnManager() {
   MOZ_ASSERT(NS_IsMainThread());
 
@@ -199,10 +205,6 @@
     const Optional<OwningNonNull<AbortSignal>>& aSignal) {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (mTransaction.isSome()) {
-    CancelTransaction(NS_ERROR_ABORT);
-  }
-
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(mParent);
 
   ErrorResult rv;
@@ -211,6 +213,20 @@
     return nullptr;
   }
 
+  if (mTransaction.isSome()) {
+    // If there hasn't been a visibility change during the current
+    // transaction, then let's let that one complete rather than
+    // cancelling it on a subsequent call.
+    if (!mTransaction.ref().mVisibilityChanged) {
+      promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+      return promise.forget();
+    }
+
+    // Otherwise, the user may well have clicked away, so let's
+    // abort the old transaction and take over control from here.
+    CancelTransaction(NS_ERROR_ABORT);
+  }
+
   // Abort the request if aborted flag is already set.
   if (aSignal.WasPassed() && aSignal.Value().Aborted()) {
     promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
@@ -400,10 +416,6 @@
     const Optional<OwningNonNull<AbortSignal>>& aSignal) {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (mTransaction.isSome()) {
-    CancelTransaction(NS_ERROR_ABORT);
-  }
-
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(mParent);
 
   ErrorResult rv;
@@ -412,6 +424,20 @@
     return nullptr;
   }
 
+  if (mTransaction.isSome()) {
+    // If there hasn't been a visibility change during the current
+    // transaction, then let's let that one complete rather than
+    // cancelling it on a subsequent call.
+    if (!mTransaction.ref().mVisibilityChanged) {
+      promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+      return promise.forget();
+    }
+
+    // Otherwise, the user may well have clicked away, so let's
+    // abort the old transaction and take over control from here.
+    CancelTransaction(NS_ERROR_ABORT);
+  }
+
   // Abort the request if aborted flag is already set.
   if (aSignal.WasPassed() && aSignal.Value().Aborted()) {
     promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
@@ -579,10 +605,6 @@
     const Credential& aCredential) {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (mTransaction.isSome()) {
-    CancelTransaction(NS_ERROR_ABORT);
-  }
-
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(mParent);
 
   ErrorResult rv;
@@ -591,6 +613,20 @@
     return nullptr;
   }
 
+  if (mTransaction.isSome()) {
+    // If there hasn't been a visibility change during the current
+    // transaction, then let's let that one complete rather than
+    // cancelling it on a subsequent call.
+    if (!mTransaction.ref().mVisibilityChanged) {
+      promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+      return promise.forget();
+    }
+
+    // Otherwise, the user may well have clicked away, so let's
+    // abort the old transaction and take over control from here.
+    CancelTransaction(NS_ERROR_ABORT);
+  }
+
   promise->MaybeReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
   return promise.forget();
 }