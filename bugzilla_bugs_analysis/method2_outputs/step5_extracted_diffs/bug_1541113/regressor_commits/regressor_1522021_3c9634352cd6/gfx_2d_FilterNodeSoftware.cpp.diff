# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/2d/FilterNodeSoftware.cpp
# Commit: 3c9634352cd6
# Full Hash: 3c9634352cd66e1debc3beeedd53130d16474db2
# Author: Jeff Muizelaar <jrmuizel@gmail.com>
# Date: 2019-01-28 04:51:03
# Regressor Bug: 1522021
# File Overlap Count: 1
# Description:
#   Bug 1522021. Propagate input size to CreateSimilarDrawTarget for filters. r=mstange
#   
#   This lets us avoid drawing the complete input for ever tile when
#   drawing filters into a tile.
#   
# ==============================================================================

diff -r 747303cab27a -r 3c9634352cd6 gfx/2d/FilterNodeSoftware.cpp
--- a/gfx/2d/FilterNodeSoftware.cpp	Sun Jan 27 22:06:38 2019 +0000
+++ b/gfx/2d/FilterNodeSoftware.cpp	Sun Jan 27 23:36:04 2019 +0000
@@ -665,6 +665,33 @@
   RequestFromInputsForRect(aRect);
 }
 
+IntRect FilterNodeSoftware::MapInputRectToSource(uint32_t aInputEnumIndex,
+                                                 const IntRect &aRect,
+                                                 const IntRect &aMax,
+                                                 FilterNode *aSourceNode) {
+  int32_t inputIndex = InputIndex(aInputEnumIndex);
+  if (inputIndex < 0) {
+    gfxDevCrash(LogReason::FilterInputError)
+        << "Invalid input " << inputIndex << " vs. " << NumberOfSetInputs();
+    return aMax;
+  }
+  if ((uint32_t)inputIndex < NumberOfSetInputs()) {
+    RefPtr<FilterNodeSoftware> filter = mInputFilters[inputIndex];
+    // If we have any input filters call into them to do the mapping,
+    // otherwise we can assume an input surface will be used
+    // and just return aRect.
+    if (filter) {
+      return filter->MapRectToSource(aRect, aMax, aSourceNode);
+    }
+  }
+  // We have an input surface instead of a filter
+  // so check if we're the target node.
+  if (this == aSourceNode) {
+    return aRect;
+  }
+  return IntRect();
+}
+
 void FilterNodeSoftware::RequestInputRect(uint32_t aInputEnumIndex,
                                           const IntRect &aRect) {
   if (aRect.Overflows()) {
@@ -1051,6 +1078,14 @@
   RequestInputRect(IN_BLEND_IN2, aRect);
 }
 
+IntRect FilterNodeBlendSoftware::MapRectToSource(const IntRect &aRect,
+                                                 const IntRect &aMax,
+                                                 FilterNode *aSourceNode) {
+  IntRect result = MapInputRectToSource(IN_BLEND_IN, aRect, aMax, aSourceNode);
+  result.OrWith(MapInputRectToSource(IN_BLEND_IN2, aRect, aMax, aSourceNode));
+  return result;
+}
+
 IntRect FilterNodeBlendSoftware::GetOutputRectInRect(const IntRect &aRect) {
   return GetInputRectInRect(IN_BLEND_IN, aRect)
       .Union(GetInputRectInRect(IN_BLEND_IN2, aRect))
@@ -1103,6 +1138,28 @@
   return GetInputRectInRect(IN_TRANSFORM_IN, neededIntRect);
 }
 
+IntRect FilterNodeTransformSoftware::MapRectToSource(const IntRect &aRect,
+                                                     const IntRect &aMax,
+                                                     FilterNode *aSourceNode) {
+  if (aRect.IsEmpty()) {
+    return IntRect();
+  }
+
+  Matrix inverted(mMatrix);
+  if (!inverted.Invert()) {
+    return aMax;
+  }
+
+  Rect neededRect = inverted.TransformBounds(Rect(aRect));
+  neededRect.RoundOut();
+  IntRect neededIntRect;
+  if (!neededRect.ToIntRect(&neededIntRect)) {
+    return aMax;
+  }
+  return MapInputRectToSource(IN_TRANSFORM_IN, neededIntRect, aMax,
+                              aSourceNode);
+}
+
 already_AddRefed<DataSourceSurface> FilterNodeTransformSoftware::Render(
     const IntRect &aRect) {
   IntRect srcRect = SourceRectForOutputRect(aRect);
@@ -1458,6 +1515,11 @@
   RequestInputRect(IN_COLOR_MATRIX_IN, aRect);
 }
 
+IntRect FilterNodeColorMatrixSoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_COLOR_MATRIX_IN, aRect, aMax, aSourceNode);
+}
+
 IntRect FilterNodeColorMatrixSoftware::GetOutputRectInRect(
     const IntRect &aRect) {
   if (mMatrix._54 > 0.0f) {
@@ -1546,6 +1608,12 @@
   return Render(aRect);
 }
 
+IntRect FilterNodeFloodSoftware::MapRectToSource(const IntRect &aRect,
+                                                 const IntRect &aMax,
+                                                 FilterNode *aSourceNode) {
+  return IntRect();
+}
+
 IntRect FilterNodeFloodSoftware::GetOutputRectInRect(const IntRect &aRect) {
   if (mColor.a == 0.0f) {
     return IntRect();
@@ -1816,6 +1884,11 @@
   RequestInputRect(IN_TRANSFER_IN, aRect);
 }
 
+IntRect FilterNodeComponentTransferSoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_TRANSFER_IN, aRect, aMax, aSourceNode);
+}
+
 IntRect FilterNodeComponentTransferSoftware::GetOutputRectInRect(
     const IntRect &aRect) {
   if (mDisableA) {
@@ -2461,6 +2534,12 @@
   RequestInputRect(IN_CONVOLVE_MATRIX_IN, InflatedSourceRect(aRect));
 }
 
+IntRect FilterNodeConvolveMatrixSoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_CONVOLVE_MATRIX_IN, InflatedSourceRect(aRect),
+                              aMax, aSourceNode);
+}
+
 IntRect FilterNodeConvolveMatrixSoftware::InflatedSourceRect(
     const IntRect &aDestRect) {
   if (aDestRect.IsEmpty()) {
@@ -2611,6 +2690,16 @@
   RequestInputRect(IN_DISPLACEMENT_MAP_IN2, aRect);
 }
 
+IntRect FilterNodeDisplacementMapSoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  IntRect result =
+      MapInputRectToSource(IN_DISPLACEMENT_MAP_IN,
+                           InflatedSourceOrDestRect(aRect), aMax, aSourceNode);
+  result.OrWith(
+      MapInputRectToSource(IN_DISPLACEMENT_MAP_IN2, aRect, aMax, aSourceNode));
+  return result;
+}
+
 IntRect FilterNodeDisplacementMapSoftware::InflatedSourceOrDestRect(
     const IntRect &aDestOrSourceRect) {
   IntRect sourceOrDestRect = aDestOrSourceRect;
@@ -2699,6 +2788,12 @@
   return aRect.Intersect(mRenderRect);
 }
 
+IntRect FilterNodeTurbulenceSoftware::MapRectToSource(const IntRect &aRect,
+                                                      const IntRect &aMax,
+                                                      FilterNode *aSourceNode) {
+  return IntRect();
+}
+
 FilterNodeArithmeticCombineSoftware::FilterNodeArithmeticCombineSoftware()
     : mK1(0), mK2(0), mK3(0), mK4(0) {}
 
@@ -2762,6 +2857,15 @@
   RequestInputRect(IN_ARITHMETIC_COMBINE_IN2, aRect);
 }
 
+IntRect FilterNodeArithmeticCombineSoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  IntRect result =
+      MapInputRectToSource(IN_ARITHMETIC_COMBINE_IN, aRect, aMax, aSourceNode);
+  result.OrWith(MapInputRectToSource(IN_ARITHMETIC_COMBINE_IN2, aRect, aMax,
+                                     aSourceNode));
+  return result;
+}
+
 IntRect FilterNodeArithmeticCombineSoftware::GetOutputRectInRect(
     const IntRect &aRect) {
   if (mK4 > 0.0f) {
@@ -2848,6 +2952,17 @@
   }
 }
 
+IntRect FilterNodeCompositeSoftware::MapRectToSource(const IntRect &aRect,
+                                                     const IntRect &aMax,
+                                                     FilterNode *aSourceNode) {
+  IntRect result;
+  for (size_t inputIndex = 0; inputIndex < NumberOfSetInputs(); inputIndex++) {
+    result.OrWith(MapInputRectToSource(IN_COMPOSITE_IN_START + inputIndex,
+                                       aRect, aMax, aSourceNode));
+  }
+  return result;
+}
+
 IntRect FilterNodeCompositeSoftware::GetOutputRectInRect(const IntRect &aRect) {
   IntRect rect;
   for (size_t inputIndex = 0; inputIndex < NumberOfSetInputs(); inputIndex++) {
@@ -2945,6 +3060,13 @@
   RequestInputRect(IN_GAUSSIAN_BLUR_IN, InflatedSourceOrDestRect(aRect));
 }
 
+IntRect FilterNodeBlurXYSoftware::MapRectToSource(const IntRect &aRect,
+                                                  const IntRect &aMax,
+                                                  FilterNode *aSourceNode) {
+  return MapInputRectToSource(
+      IN_GAUSSIAN_BLUR_IN, InflatedSourceOrDestRect(aRect), aMax, aSourceNode);
+}
+
 IntRect FilterNodeBlurXYSoftware::InflatedSourceOrDestRect(
     const IntRect &aDestRect) {
   Size sigmaXY = StdDeviationXY();
@@ -3047,6 +3169,13 @@
   RequestInputRect(IN_CROP_IN, aRect.Intersect(mCropRect));
 }
 
+IntRect FilterNodeCropSoftware::MapRectToSource(const IntRect &aRect,
+                                                const IntRect &aMax,
+                                                FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_CROP_IN, aRect.Intersect(mCropRect), aMax,
+                              aSourceNode);
+}
+
 IntRect FilterNodeCropSoftware::GetOutputRectInRect(const IntRect &aRect) {
   return GetInputRectInRect(IN_CROP_IN, aRect).Intersect(mCropRect);
 }
@@ -3072,6 +3201,11 @@
   RequestInputRect(IN_PREMULTIPLY_IN, aRect);
 }
 
+IntRect FilterNodePremultiplySoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_PREMULTIPLY_IN, aRect, aMax, aSourceNode);
+}
+
 IntRect FilterNodePremultiplySoftware::GetOutputRectInRect(
     const IntRect &aRect) {
   return GetInputRectInRect(IN_PREMULTIPLY_IN, aRect);
@@ -3098,6 +3232,11 @@
   RequestInputRect(IN_UNPREMULTIPLY_IN, aRect);
 }
 
+IntRect FilterNodeUnpremultiplySoftware::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_UNPREMULTIPLY_IN, aRect, aMax, aSourceNode);
+}
+
 IntRect FilterNodeUnpremultiplySoftware::GetOutputRectInRect(
     const IntRect &aRect) {
   return GetInputRectInRect(IN_UNPREMULTIPLY_IN, aRect);
@@ -3129,6 +3268,12 @@
   RequestInputRect(IN_OPACITY_IN, aRect);
 }
 
+IntRect FilterNodeOpacitySoftware::MapRectToSource(const IntRect &aRect,
+                                                   const IntRect &aMax,
+                                                   FilterNode *aSourceNode) {
+  return MapInputRectToSource(IN_OPACITY_IN, aRect, aMax, aSourceNode);
+}
+
 IntRect FilterNodeOpacitySoftware::GetOutputRectInRect(const IntRect &aRect) {
   return GetInputRectInRect(IN_OPACITY_IN, aRect);
 }
@@ -3413,6 +3558,15 @@
 }
 
 template <typename LightType, typename LightingType>
+IntRect FilterNodeLightingSoftware<LightType, LightingType>::MapRectToSource(
+    const IntRect &aRect, const IntRect &aMax, FilterNode *aSourceNode) {
+  IntRect srcRect = aRect;
+  srcRect.Inflate(ceil(mKernelUnitLength.width),
+                  ceil(mKernelUnitLength.height));
+  return MapInputRectToSource(IN_LIGHTING_IN, srcRect, aMax, aSourceNode);
+}
+
+template <typename LightType, typename LightingType>
 template <typename CoordType>
 already_AddRefed<DataSourceSurface>
 FilterNodeLightingSoftware<LightType, LightingType>::DoRender(