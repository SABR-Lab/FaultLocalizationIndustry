# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/src/FilterSupport.cpp
# Commit: 3c9634352cd6
# Full Hash: 3c9634352cd66e1debc3beeedd53130d16474db2
# Author: Jeff Muizelaar <jrmuizel@gmail.com>
# Date: 2019-01-28 04:51:03
# Regressor Bug: 1522021
# File Overlap Count: 1
# Description:
#   Bug 1522021. Propagate input size to CreateSimilarDrawTarget for filters. r=mstange
#   
#   This lets us avoid drawing the complete input for ever tile when
#   drawing filters into a tile.
#   
# ==============================================================================

diff -r 747303cab27a -r 3c9634352cd6 gfx/src/FilterSupport.cpp
--- a/gfx/src/FilterSupport.cpp	Sun Jan 27 22:06:38 2019 +0000
+++ b/gfx/src/FilterSupport.cpp	Sun Jan 27 23:36:04 2019 +0000
@@ -209,7 +209,7 @@
   return nullptr;
 }
 
-static already_AddRefed<FilterNode> Clear(DrawTarget* aDT) {
+already_AddRefed<FilterNode> Clear(DrawTarget* aDT) {
   RefPtr<FilterNode> filter = aDT->CreateFilter(FilterType::FLOOD);
   if (filter) {
     filter->SetAttribute(ATT_FLOOD_COLOR, Color(0, 0, 0, 0));
@@ -218,9 +218,9 @@
   return nullptr;
 }
 
-static already_AddRefed<FilterNode> ForSurface(
-    DrawTarget* aDT, SourceSurface* aSurface,
-    const IntPoint& aSurfacePosition) {
+already_AddRefed<FilterNode> ForSurface(DrawTarget* aDT,
+                                        SourceSurface* aSurface,
+                                        const IntPoint& aSurfacePosition) {
   RefPtr<FilterNode> filter = aDT->CreateFilter(FilterType::TRANSFORM);
   if (filter) {
     filter->SetAttribute(
@@ -1204,12 +1204,11 @@
 }
 
 // Returns the output FilterNode, in premultiplied sRGB space.
-static already_AddRefed<FilterNode> FilterNodeGraphFromDescription(
+already_AddRefed<FilterNode> FilterNodeGraphFromDescription(
     DrawTarget* aDT, const FilterDescription& aFilter,
-    const Rect& aResultNeededRect, SourceSurface* aSourceGraphic,
-    const IntRect& aSourceGraphicRect, SourceSurface* aFillPaint,
-    const IntRect& aFillPaintRect, SourceSurface* aStrokePaint,
-    const IntRect& aStrokePaintRect,
+    const Rect& aResultNeededRect, FilterNode* aSourceGraphic,
+    const IntRect& aSourceGraphicRect, FilterNode* aFillPaint,
+    FilterNode* aStrokePaint,
     nsTArray<RefPtr<SourceSurface>>& aAdditionalImages) {
   const nsTArray<FilterPrimitiveDescription>& primitives = aFilter.mPrimitives;
   MOZ_RELEASE_ASSERT(!primitives.IsEmpty());
@@ -1249,17 +1248,12 @@
         if (!inputFilter) {
           RefPtr<FilterNode> sourceFilterNode;
 
-          nsTArray<SourceSurface*> primitiveSurfaces;
-          nsTArray<IntRect> primitiveSurfaceRects;
-          RefPtr<SourceSurface> surf =
-              ElementForIndex(inputIndex, primitiveSurfaces, aSourceGraphic,
+          nsTArray<FilterNode*> primitiveFilters;
+          RefPtr<FilterNode> filt =
+              ElementForIndex(inputIndex, primitiveFilters, aSourceGraphic,
                               aFillPaint, aStrokePaint);
-          IntRect surfaceRect = ElementForIndex(
-              inputIndex, primitiveSurfaceRects, aSourceGraphicRect,
-              aFillPaintRect, aStrokePaintRect);
-          if (surf) {
-            IntPoint offset = surfaceRect.TopLeft();
-            sourceFilterNode = FilterWrappers::ForSurface(aDT, surf, offset);
+          if (filt) {
+            sourceFilterNode = filt;
 
             // Clip the original SourceGraphic to the first filter region if the
             // surface isn't already sized appropriately.
@@ -1324,9 +1318,22 @@
     SourceSurface* aStrokePaint, const IntRect& aStrokePaintRect,
     nsTArray<RefPtr<SourceSurface>>& aAdditionalImages, const Point& aDestPoint,
     const DrawOptions& aOptions) {
+  RefPtr<FilterNode> sourceGraphic, fillPaint, strokePaint;
+  if (aSourceGraphic) {
+    sourceGraphic = FilterWrappers::ForSurface(aDT, aSourceGraphic,
+                                               aSourceGraphicRect.TopLeft());
+  }
+  if (aFillPaint) {
+    fillPaint =
+        FilterWrappers::ForSurface(aDT, aFillPaint, aFillPaintRect.TopLeft());
+  }
+  if (aStrokePaint) {
+    strokePaint = FilterWrappers::ForSurface(aDT, aStrokePaint,
+                                             aStrokePaintRect.TopLeft());
+  }
   RefPtr<FilterNode> resultFilter = FilterNodeGraphFromDescription(
-      aDT, aFilter, aRenderRect, aSourceGraphic, aSourceGraphicRect, aFillPaint,
-      aFillPaintRect, aStrokePaint, aStrokePaintRect, aAdditionalImages);
+      aDT, aFilter, aRenderRect, sourceGraphic, aSourceGraphicRect, fillPaint,
+      strokePaint, aAdditionalImages);
   if (!resultFilter) {
     gfxWarning() << "Filter is NULL.";
     return;