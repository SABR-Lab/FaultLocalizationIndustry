# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/media-conduit/RtpPacketQueue.h
# Commit: 909f472c2e40
# Full Hash: 909f472c2e402f81a8326e93e839666d2aba1fc5
# Author: Dan Minor <dminor@mozilla.com>
# Date: 2018-11-03 09:44:53
# Regressor Bug: 1376873
# File Overlap Count: 2
# Description:
#   Bug 1376873 - Add RtpPacketQueue; r=pehrsons
#   
#   We'll need to queue rtp packets in both the AudioConduit and the VideoConduit.
#   This adds a class to manage the packet queue to reduce duplicated code between
#   the conduits.
# ==============================================================================

diff -r 19d9a30b300c -r 909f472c2e40 media/webrtc/signaling/src/media-conduit/RtpPacketQueue.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/webrtc/signaling/src/media-conduit/RtpPacketQueue.h	Thu Mar 22 09:44:49 2018 -0400
@@ -0,0 +1,60 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef RTP_PACKET_QUEUE_H_
+#define RTP_PACKET_QUEUE_H_
+
+#include "nsTArray.h"
+
+#include "MediaConduitInterface.h"
+
+namespace mozilla {
+
+class RtpPacketQueue {
+public:
+
+  void Clear()
+  {
+    mQueuedPackets.Clear();
+    mQueueActive = false;
+  }
+
+  void DequeueAll(MediaSessionConduit* conduit)
+  {
+    // SSRC is set; insert queued packets
+    for (auto& packet : mQueuedPackets) {
+      if (conduit->DeliverPacket(packet->mData, packet->mLen) != kMediaConduitNoError) {
+        // Keep delivering and then clear the queue
+      }
+    }
+    mQueuedPackets.Clear();
+    mQueueActive = false;
+  }
+
+  void Enqueue(const void* data, int len)
+  {
+    UniquePtr<QueuedPacket> packet((QueuedPacket*) malloc(sizeof(QueuedPacket) + len-1));
+    packet->mLen = len;
+    memcpy(packet->mData, data, len);
+    mQueuedPackets.AppendElement(std::move(packet));
+    mQueueActive = true;
+  }
+
+  bool IsQueueActive()
+  {
+    return mQueueActive;
+  }
+
+private:
+  bool mQueueActive = false;
+  struct QueuedPacket {
+    int mLen;
+    uint8_t mData[1];
+  };
+  nsTArray<UniquePtr<QueuedPacket>> mQueuedPackets;
+};
+
+}
+
+#endif