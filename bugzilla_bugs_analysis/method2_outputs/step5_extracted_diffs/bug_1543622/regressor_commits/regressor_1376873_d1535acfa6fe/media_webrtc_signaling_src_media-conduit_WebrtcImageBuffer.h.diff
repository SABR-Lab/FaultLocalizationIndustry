# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/media-conduit/WebrtcImageBuffer.h
# Commit: d1535acfa6fe
# Full Hash: d1535acfa6fe14fcec6bba1fa08607c13e8c3cd3
# Author: Dan Minor <dminor@mozilla.com>
# Date: 2018-11-09 10:01:40
# Regressor Bug: 1376873
# File Overlap Count: 1
# Description:
#   Bug 1376873 - WebrtcMediaDataDecoderCodec updates; r=pehrsons
#   
#   This makes the ImageBuffer class implement VideoFrameBuffer class and makes
#   it available in MediaPipeline. To avoid exposing MediaPipeline to a lot of
#   internal details of WebrtcMediaDataDecoder, ImageBuffer is moved to its
# ==============================================================================

diff -r 2fb84f9968af -r d1535acfa6fe media/webrtc/signaling/src/media-conduit/WebrtcImageBuffer.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/webrtc/signaling/src/media-conduit/WebrtcImageBuffer.h	Tue Aug 21 13:40:45 2018 -0400
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef WebrtcImageBuffer_h__
+#define WebrtcImageBuffer_h__
+
+#include "webrtc/common_video/include/video_frame_buffer.h"
+#include "webrtc/rtc_base/keep_ref_until_done.h"
+
+namespace mozilla {
+namespace layers {
+  class Image;
+}
+
+class ImageBuffer : public webrtc::VideoFrameBuffer
+{
+public:
+  explicit ImageBuffer(RefPtr<layers::Image>&& aImage)
+    : mImage(std::move(aImage))
+  {
+  }
+
+  rtc::scoped_refptr<webrtc::I420BufferInterface> ToI420() override
+  {
+    RefPtr<layers::PlanarYCbCrImage> image = mImage->AsPlanarYCbCrImage();
+    MOZ_ASSERT(image);
+    if (!image) {
+      // TODO. YUV420 ReadBack, Image only provides a RGB readback.
+      return nullptr;
+    }
+    const layers::PlanarYCbCrData* data = image->GetData();
+    rtc::scoped_refptr<webrtc::I420BufferInterface> buf(
+      new rtc::RefCountedObject<webrtc::WrappedI420Buffer>(
+        data->mPicSize.width,
+        data->mPicSize.height,
+        data->mYChannel,
+        data->mYStride,
+        data->mCbChannel,
+        data->mCbCrStride,
+        data->mCrChannel,
+        data->mCbCrStride,
+        rtc::KeepRefUntilDone(image.get())));
+    return buf;
+  }
+
+  Type type() const override
+  {
+    return Type::kNative;
+  }
+
+  int width() const override
+  {
+    return mImage->GetSize().width;
+  }
+
+  int height() const override
+  {
+    return mImage->GetSize().height;
+  }
+
+  RefPtr<layers::Image> GetNativeImage() const
+  {
+    return mImage;
+  }
+
+private:
+  const RefPtr<layers::Image> mImage;
+};
+
+} // namespace mozilla
+
+#endif // WebrtcImageBuffer_h__