# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/mediapipeline/MediaPipeline.cpp
# Commit: d1535acfa6fe
# Full Hash: d1535acfa6fe14fcec6bba1fa08607c13e8c3cd3
# Author: Dan Minor <dminor@mozilla.com>
# Date: 2018-11-09 10:01:40
# Regressor Bug: 1376873
# File Overlap Count: 1
# Description:
#   Bug 1376873 - WebrtcMediaDataDecoderCodec updates; r=pehrsons
#   
#   This makes the ImageBuffer class implement VideoFrameBuffer class and makes
#   it available in MediaPipeline. To avoid exposing MediaPipeline to a lot of
#   internal details of WebrtcMediaDataDecoder, ImageBuffer is moved to its
# ==============================================================================

diff -r 2fb84f9968af -r d1535acfa6fe media/webrtc/signaling/src/mediapipeline/MediaPipeline.cpp
--- a/media/webrtc/signaling/src/mediapipeline/MediaPipeline.cpp	Tue Aug 21 13:40:10 2018 -0400
+++ b/media/webrtc/signaling/src/mediapipeline/MediaPipeline.cpp	Tue Aug 21 13:40:45 2018 -0400
@@ -47,6 +47,7 @@
 #include "runnable_utils.h"
 #include "signaling/src/peerconnection/MediaTransportHandler.h"
 #include "Tracing.h"
+#include "WebrtcImageBuffer.h"
 
 #include "webrtc/base/bind.h"
 #include "webrtc/base/keep_ref_until_done.h"
@@ -2040,15 +2041,18 @@
                         uint32_t aTimeStamp,
                         int64_t aRenderTime)
   {
-    if (aBuffer.native_handle()) {
+    if (aBuffer.type() == webrtc::VideoFrameBuffer::Type::kNative) {
       // We assume that only native handles are used with the
       // WebrtcMediaDataDecoderCodec decoder.
-      RefPtr<Image> image = static_cast<Image*>(aBuffer.native_handle());
+      const ImageBuffer *imageBuffer = static_cast<const ImageBuffer*>(&aBuffer);
       MutexAutoLock lock(mMutex);
-      mImage = image;
+      mImage = imageBuffer->GetNativeImage();
       return;
     }
 
+    MOZ_ASSERT(aBuffer.type() == webrtc::VideoFrameBuffer::Type::kI420);
+    rtc::scoped_refptr<const webrtc::I420BufferInterface> i420 = aBuffer.GetI420();
+
     MOZ_ASSERT(aBuffer.DataY());
     // Create a video frame using |buffer|.
     RefPtr<PlanarYCbCrImage> yuvImage =
