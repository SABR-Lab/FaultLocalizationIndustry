# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/resource_cache.rs
# Commit: 902bff64318d
# Full Hash: 902bff64318d963ea1d5505eebd0f66b11d55f28
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2019-04-17 21:47:29
# Regressor Bug: 1519106
# File Overlap Count: 1
# Description:
#   Bug 1519106 - Converge towards the max number of tiles faster. r=kats
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D27728
# ==============================================================================

diff -r d6c9841c74cd -r 902bff64318d gfx/wr/webrender/src/resource_cache.rs
--- a/gfx/wr/webrender/src/resource_cache.rs	Wed Apr 17 14:43:37 2019 +0000
+++ b/gfx/wr/webrender/src/resource_cache.rs	Wed Apr 17 14:41:47 2019 +0000
@@ -1210,26 +1210,20 @@
                 // Constant here definitely needs to be tweaked.
                 const MAX_TILES_PER_REQUEST: i32 = 512;
                 // For truly nonsensical requests, we might run into overflow
-                // when computing width * height. Even if we don't, the loop
-                // below to reduce the number of tiles is linear and can take
-                // a long time to complete. These preliminary conditions help
-                // get us there faster and avoid the overflow.
-                if tiles.size.width > MAX_TILES_PER_REQUEST {
-                    tiles.origin.x += (tiles.size.width - MAX_TILES_PER_REQUEST) / 2;
-                    tiles.size.width = MAX_TILES_PER_REQUEST;
-                }
-                if tiles.size.height > MAX_TILES_PER_REQUEST {
-                    tiles.origin.y += (tiles.size.height - MAX_TILES_PER_REQUEST) / 2;
-                    tiles.size.height = MAX_TILES_PER_REQUEST;
-                }
-                while tiles.size.width as i32 * tiles.size.height as i32 > MAX_TILES_PER_REQUEST {
+                // when computing width * height, so we first check each extent
+                // individually.
+                while !tiles.size.is_empty_or_negative()
+                    && (tiles.size.width > MAX_TILES_PER_REQUEST
+                        || tiles.size.height > MAX_TILES_PER_REQUEST
+                        || tiles.size.width * tiles.size.height > MAX_TILES_PER_REQUEST) {
+                    let diff = tiles.size.width * tiles.size.height - MAX_TILES_PER_REQUEST;
                     // Remove tiles in the largest dimension.
                     if tiles.size.width > tiles.size.height {
-                        tiles.size.width -= 2;
-                        tiles.origin.x += 1;
+                        tiles.size.width -= diff / tiles.size.height + 1;
+                        tiles.origin.x += diff / (2 * tiles.size.height);
                     } else {
-                        tiles.size.height -= 2;
-                        tiles.origin.y += 1;
+                        tiles.size.height -= diff / tiles.size.width + 1;
+                        tiles.origin.y += diff / (2 * tiles.size.height);
                     }
                 }
 
