# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsGfxScrollFrame.cpp
# Commit: 0e259884f052
# Full Hash: 0e259884f052230b24601efc3cde3a5ef5d4e6ad
# Author: Matt Woodrow <mwoodrow@mozilla.com>
# Date: 2019-05-01 15:54:31
# Regressor Bug: 1535945
# File Overlap Count: 1
# Description:
#   Bug 1535945 - Don't skip invalidating frames when creating displayports for async scrollable ancestors. r=tnikkel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D23816
# ==============================================================================

diff -r 732976d3f555 -r 0e259884f052 layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp	Wed May 01 08:16:44 2019 +0000
+++ b/layout/generic/nsGfxScrollFrame.cpp	Wed May 01 04:23:07 2019 +0000
@@ -2041,10 +2041,8 @@
     // active scroll containers so that we paint by whole tile increments
     // when scrolling.
     nsLayoutUtils::SetDisplayPortMargins(
-        mOuter->GetContent(), mOuter->PresShell(), ScreenMargin(), 0,
-        nsLayoutUtils::RepaintMode::DoNotRepaint);
-    nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(
-        mOuter, nsLayoutUtils::RepaintMode::DoNotRepaint);
+        mOuter->GetContent(), mOuter->PresShell(), ScreenMargin(), 0);
+    nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(mOuter);
   }
 }
 
@@ -3641,7 +3639,11 @@
                  aBuilder->IsPaintingToWindow());
       if (!mWillBuildScrollableLayer) {
         // Set a displayport so next paint we don't have to force layerization
-        // after the fact.
+        // after the fact. It's ok to pass DoNotRepaint here, since we've
+        // already painted the change and we're just optimizing it to be
+        // detected earlier. We also won't confuse RetainedDisplayLists
+        // with the silent change, since we explicitly request partial updates
+        // to be disabled on the next paint.
         nsLayoutUtils::SetDisplayPortMargins(
             mOuter->GetContent(), mOuter->PresShell(), ScreenMargin(), 0,
             nsLayoutUtils::RepaintMode::DoNotRepaint);
@@ -3889,7 +3891,8 @@
     if (usingDisplayPort) {
       // Override the dirty rectangle if the displayport has been set.
       *aVisibleRect = displayPort;
-      if (!aBuilder->IsPartialUpdate() || aBuilder->InInvalidSubtree()) {
+      if (!aBuilder->IsPartialUpdate() || aBuilder->InInvalidSubtree() ||
+          mOuter->IsFrameModified()) {
         *aDirtyRect = displayPort;
         if (aDirtyRectHasBeenOverriden) {
           *aDirtyRectHasBeenOverriden = true;
@@ -3928,6 +3931,10 @@
   // date if we just introduced a new animated geometry root.
   if (oldWillBuildScrollableLayer != mWillBuildScrollableLayer) {
     aBuilder->RecomputeCurrentAnimatedGeometryRoot();
+    MOZ_DIAGNOSTIC_ASSERT(!aBuilder->IsPartialUpdate() ||
+                              aBuilder->InInvalidSubtree() ||
+                              mOuter->IsFrameModified(),
+                          "Displayport changed without an invalidation");
   }
 
   mIsScrollableLayerInRootContainer =
@@ -7070,11 +7077,9 @@
     // this smooth scroll request. We should set a displayport on this
     // frame to force an APZC which can handle the request.
     nsLayoutUtils::CalculateAndSetDisplayPortMargins(
-        mOuter->GetScrollTargetFrame(),
-        nsLayoutUtils::RepaintMode::DoNotRepaint);
+        mOuter->GetScrollTargetFrame(), nsLayoutUtils::RepaintMode::Repaint);
     nsIFrame* frame = do_QueryFrame(mOuter->GetScrollTargetFrame());
-    nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(
-        frame, nsLayoutUtils::RepaintMode::DoNotRepaint);
+    nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(frame);
   }
 
   // Schedule a paint to ensure that the frame metrics get updated on
