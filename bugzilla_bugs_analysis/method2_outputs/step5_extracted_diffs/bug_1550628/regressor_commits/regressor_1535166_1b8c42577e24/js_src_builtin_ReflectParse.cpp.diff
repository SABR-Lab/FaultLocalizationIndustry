# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/ReflectParse.cpp
# Commit: 1b8c42577e24
# Full Hash: 1b8c42577e2410dbbe050bb30b0ccced9d7c3771
# Author: Ashley Hauck <khyperia@mozilla.com>
# Date: 2019-03-20 10:52:37
# Regressor Bug: 1535166
# File Overlap Count: 1
# Description:
#   Bug 1535166 - Implement computed field names. r=jorendorff
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D23408
# ==============================================================================

diff -r 28370bf14b97 -r 1b8c42577e24 js/src/builtin/ReflectParse.cpp
--- a/js/src/builtin/ReflectParse.cpp	Tue Mar 19 22:02:49 2019 +0000
+++ b/js/src/builtin/ReflectParse.cpp	Tue Mar 19 20:23:03 2019 +0000
@@ -611,7 +611,7 @@
   MOZ_MUST_USE bool classMethod(HandleValue name, HandleValue body,
                                 PropKind kind, bool isStatic, TokenPos* pos,
                                 MutableHandleValue dst);
-  MOZ_MUST_USE bool classField(HandleValue name, HandleValue body,
+  MOZ_MUST_USE bool classField(HandleValue name, HandleValue initializer,
                                TokenPos* pos, MutableHandleValue dst);
 
   /*
@@ -1536,8 +1536,7 @@
     return callback(cb, name, initializer, pos, dst);
   }
 
-  return newNode(AST_CLASS_FIELD, pos, "name", name, "initializer", initializer,
-                 dst);
+  return newNode(AST_CLASS_FIELD, pos, "name", name, "init", initializer, dst);
 }
 
 bool NodeBuilder::classMembers(NodeVector& members, MutableHandleValue dst) {
@@ -2541,8 +2540,16 @@
                            .kid()
                            ->as<AssignmentNode>()
                            .right();
-    if (!expression(value, &val)) {
-      return false;
+    // RawUndefinedExpr is the node we use for "there is no initializer". If one
+    // writes, literally, `x = undefined;`, it will not be a RawUndefinedExpr
+    // node, but rather a variable reference.
+    // Behavior for "there is no initializer" should be { ..., "init": null }
+    if (value->getKind() != ParseNodeKind::RawUndefinedExpr) {
+      if (!expression(value, &val)) {
+        return false;
+      }
+    } else {
+      val.setNull();
     }
   }
   return propertyName(&classField->name(), &key) &&