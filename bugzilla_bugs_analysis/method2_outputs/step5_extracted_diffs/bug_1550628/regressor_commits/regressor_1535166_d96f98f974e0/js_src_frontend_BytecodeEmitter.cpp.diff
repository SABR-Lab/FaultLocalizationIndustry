# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/frontend/BytecodeEmitter.cpp
# Commit: d96f98f974e0
# Full Hash: d96f98f974e087224e0a1ef9be67e2fc63397d8b
# Author: Ashley Hauck <khyperia@mozilla.com>
# Date: 2019-03-21 04:34:45
# Regressor Bug: 1535166
# File Overlap Count: 1
# Description:
#   Bug 1535166 - Implement computed field names. r=jorendorff
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D23408
# ==============================================================================

diff -r c786b72a9d8e -r d96f98f974e0 js/src/frontend/BytecodeEmitter.cpp
--- a/js/src/frontend/BytecodeEmitter.cpp	Wed Mar 20 15:50:30 2019 +0000
+++ b/js/src/frontend/BytecodeEmitter.cpp	Wed Mar 20 17:26:01 2019 +0000
@@ -7776,6 +7776,9 @@
   }
 
   if (obj->getKind() == ParseNodeKind::ClassMemberList) {
+    if (!emitCreateFieldKeys(obj)) {
+      return false;
+    }
     if (!emitCreateFieldInitializers(obj)) {
       return false;
     }
@@ -7799,6 +7802,90 @@
   return FieldInitializers(numFields);
 }
 
+// Purpose of .fieldKeys:
+// Computed field names (`["x"] = 2;`) must be ran at class-evaluation time, not
+// object construction time. The transformation to do so is roughly as follows:
+//
+// class C {
+//   [keyExpr] = valueExpr;
+// }
+// -->
+// let .fieldKeys = [keyExpr];
+// let .initializers = [
+//   () => {
+//     this[.fieldKeys[0]] = valueExpr;
+//   }
+// ];
+// class C {
+//   constructor() {
+//     .initializers[0]();
+//   }
+// }
+//
+// BytecodeEmitter::emitCreateFieldKeys does `let .fieldKeys = [keyExpr, ...];`
+// See GeneralParser::fieldInitializer for the `this[.fieldKeys[0]]` part.
+bool BytecodeEmitter::emitCreateFieldKeys(ListNode* obj) {
+  size_t numFieldKeys = 0;
+  for (ParseNode* propdef : obj->contents()) {
+    if (propdef->is<ClassField>()) {
+      ClassField* field = &propdef->as<ClassField>();
+      if (field->name().getKind() == ParseNodeKind::ComputedName) {
+        numFieldKeys++;
+      }
+    }
+  }
+
+  if (numFieldKeys == 0) {
+    return true;
+  }
+
+  NameOpEmitter noe(this, cx->names().dotFieldKeys,
+                    NameOpEmitter::Kind::Initialize);
+  if (!noe.prepareForRhs()) {
+    return false;
+  }
+
+  if (!emitUint32Operand(JSOP_NEWARRAY, numFieldKeys)) {
+    //            [stack] ARRAY
+    return false;
+  }
+
+  size_t curFieldKeyIndex = 0;
+  for (ParseNode* propdef : obj->contents()) {
+    if (propdef->is<ClassField>()) {
+      ClassField* field = &propdef->as<ClassField>();
+      if (field->name().getKind() == ParseNodeKind::ComputedName) {
+        ParseNode* nameExpr = field->name().as<UnaryNode>().kid();
+
+        if (!emitTree(nameExpr)) {
+          //        [stack] ARRAY KEY
+          return false;
+        }
+
+        if (!emitUint32Operand(JSOP_INITELEM_ARRAY, curFieldKeyIndex)) {
+          //        [stack] ARRAY
+          return false;
+        }
+
+        curFieldKeyIndex++;
+      }
+    }
+  }
+  MOZ_ASSERT(curFieldKeyIndex == numFieldKeys);
+
+  if (!noe.emitAssignment()) {
+    //            [stack] ARRAY
+    return false;
+  }
+
+  if (!emit1(JSOP_POP)) {
+    //            [stack]
+    return false;
+  }
+
+  return true;
+}
+
 bool BytecodeEmitter::emitCreateFieldInitializers(ListNode* obj) {
   const FieldInitializers& fieldInitializers = fieldInitializers_;
   MOZ_ASSERT(fieldInitializers.valid);