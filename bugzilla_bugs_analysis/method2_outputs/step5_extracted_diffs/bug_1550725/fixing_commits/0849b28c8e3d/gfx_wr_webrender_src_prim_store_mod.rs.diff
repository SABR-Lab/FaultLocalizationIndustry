# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/prim_store/mod.rs
# Commit: 0849b28c8e3d
# Full Hash: 0849b28c8e3db984273f97a8d6ea4f7284802f49
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2019-05-11 09:48:14
# Description:
#   Bug 1550725 - Cull primitives with an empty clip. r=kvark
#   
#   When the clip chain generates the local clip rect for a primitive, it
#   can be empty. This violated the assumption that the visible rect will
#   never be empty, and so when we snap, it produces NaNs, which in turn,
# ==============================================================================

diff -r 13e26dbd7cc7 -r 0849b28c8e3d gfx/wr/webrender/src/prim_store/mod.rs
--- a/gfx/wr/webrender/src/prim_store/mod.rs	Wed May 01 15:13:43 2019 -0500
+++ b/gfx/wr/webrender/src/prim_store/mod.rs	Fri May 10 11:17:10 2019 -0400
@@ -2028,6 +2028,16 @@
                     prim_instance.local_clip_rect
                 };
 
+                if combined_local_clip_rect.size.is_empty_or_negative() {
+                    debug_assert!(combined_local_clip_rect.size.width >= 0.0 &&
+                                  combined_local_clip_rect.size.height >= 0.0);
+                    if prim_instance.is_chased() {
+                        println!("\tculled for zero local clip rectangle");
+                    }
+                    prim_instance.visibility_info = PrimitiveVisibilityIndex::INVALID;
+                    continue;
+                }
+
                 // All pictures must snap to their primitive rect instead of the
                 // visible rect like most primitives. This is because the picture's
                 // visible rect includes the effect of the picture's clip rect,
@@ -2036,9 +2046,16 @@
                 // children, which they snapped to, which is precisely what we also
                 // need to snap to in order to be consistent.
                 let visible_rect = if snap_to_visible {
-                    combined_local_clip_rect
-                        .intersection(&prim_local_rect)
-                        .unwrap_or(LayoutRect::zero())
+                    match combined_local_clip_rect.intersection(&prim_local_rect) {
+                        Some(r) => r,
+                        None => {
+                            if prim_instance.is_chased() {
+                                println!("\tculled for zero visible rectangle");
+                            }
+                            prim_instance.visibility_info = PrimitiveVisibilityIndex::INVALID;
+                            continue;
+                        }
+                    }
                 } else {
                     prim_local_rect
                 };
