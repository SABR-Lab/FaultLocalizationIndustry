# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/res/prim_shared.glsl
# Commit: 0259eb7967f4
# Full Hash: 0259eb7967f41e2476320a899efa85e59a3fe837
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2019-05-01 15:57:23
# Regressor Bug: 1540200
# File Overlap Count: 1
# Description:
#   Bug 1540200 - Part 3. Reuse snapping offsets calculated on the CPU in the WebRender shaders. r=kvark
#   
#   Historically we calculated the snapping offsets in the GPU shaders.
#   Because this information is always needed on the CPU side, we now just
#   pass the values into the shader instead of recalculating again. This
# ==============================================================================

diff -r 67e8e1f2f00c -r 0259eb7967f4 gfx/wr/webrender/res/prim_shared.glsl
--- a/gfx/wr/webrender/res/prim_shared.glsl	Wed Apr 10 14:20:34 2019 -0400
+++ b/gfx/wr/webrender/res/prim_shared.glsl	Fri Apr 12 09:34:25 2019 -0400
@@ -47,12 +47,13 @@
 // Instanced attributes
 in ivec4 aData;
 
-#define VECS_PER_PRIM_HEADER_F 2U
+#define VECS_PER_PRIM_HEADER_F 3U
 #define VECS_PER_PRIM_HEADER_I 2U
 
 struct PrimitiveHeader {
     RectWithSize local_rect;
     RectWithSize local_clip_rect;
+    vec4 snap_offsets;
     float z;
     int specific_prim_address;
     int render_task_index;
@@ -66,6 +67,7 @@
     ivec2 uv_f = get_fetch_uv(index, VECS_PER_PRIM_HEADER_F);
     vec4 local_rect = TEXEL_FETCH(sPrimitiveHeadersF, uv_f, 0, ivec2(0, 0));
     vec4 local_clip_rect = TEXEL_FETCH(sPrimitiveHeadersF, uv_f, 0, ivec2(1, 0));
+    ph.snap_offsets = TEXEL_FETCH(sPrimitiveHeadersF, uv_f, 0, ivec2(2, 0));
     ph.local_rect = RectWithSize(local_rect.xy, local_rect.zw);
     ph.local_clip_rect = RectWithSize(local_clip_rect.xy, local_clip_rect.zw);
 
@@ -93,7 +95,7 @@
                         Transform transform,
                         PictureTask task,
                         RectWithSize snap_rect,
-                        bool snap_to_primitive) {
+                        vec4 snap_offsets) {
 
     // Select the corner of the local rect that we are processing.
     vec2 local_pos = instance_rect.p0 + instance_rect.size * aPosition.xy;
@@ -101,23 +103,11 @@
     // Clamp to the two local clip rects.
     vec2 clamped_local_pos = clamp_rect(local_pos, local_clip_rect);
 
-    RectWithSize visible_rect;
-    if (snap_to_primitive) {
-        // We are producing a picture. The snap rect has already taken into
-        // account the clipping we wish to consider for snapping purposes.
-        visible_rect = snap_rect;
-    } else {
-        // Compute the visible rect to snap against. This ensures segments along
-        // the edges are snapped consistently with other nearby primitives.
-        visible_rect = intersect_rects(local_clip_rect, snap_rect);
-    }
-
     /// Compute the snapping offset.
     vec2 snap_offset = compute_snap_offset(
         clamped_local_pos,
-        transform.m,
-        visible_rect,
-        task.device_pixel_scale
+        snap_rect,
+        snap_offsets
     );
 
     // Transform the current vertex to world space.