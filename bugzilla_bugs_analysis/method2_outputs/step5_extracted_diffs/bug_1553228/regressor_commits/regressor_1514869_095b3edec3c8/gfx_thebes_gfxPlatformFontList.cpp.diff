# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxPlatformFontList.cpp
# Commit: 095b3edec3c8
# Full Hash: 095b3edec3c8ba9318c71d0acc91e10ce57818dc
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2019-04-29 21:53:38
# Regressor Bug: 1514869
# File Overlap Count: 1
# Description:
#   Bug 1514869 - patch 2 - Adapt platform-font-list code to work with either the existing in-process font list or cross-process shared font list. r=jwatt
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D22938
# ==============================================================================

diff -r 21ef00977ab6 -r 095b3edec3c8 gfx/thebes/gfxPlatformFontList.cpp
--- a/gfx/thebes/gfxPlatformFontList.cpp	Sat Apr 27 15:37:29 2019 +0000
+++ b/gfx/thebes/gfxPlatformFontList.cpp	Sat Apr 27 15:37:58 2019 +0000
@@ -9,6 +9,7 @@
 #include "mozilla/intl/OSPreferences.h"
 
 #include "gfxPlatformFontList.h"
+#include "gfxPrefs.h"
 #include "gfxTextRun.h"
 #include "gfxUserFontSet.h"
 #include "SharedFontList-impl.h"
@@ -27,8 +28,18 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/TimeStamp.h"
+#include "mozilla/dom/BlobImpl.h"
+#include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ContentProcessMessageManager.h"
+#include "mozilla/dom/IPCBlobUtils.h"
 #include "mozilla/gfx/2D.h"
+#include "mozilla/ipc/FileDescriptorUtils.h"
+#include "mozilla/ResultExtensions.h"
+#include "mozilla/Unused.h"
+
+#include "base/eintr_wrapper.h"
+#include "base/file_util.h"
 
 #include <locale.h>
 
@@ -182,6 +193,7 @@
   sizes.mFontTableCacheSize = 0;
   sizes.mCharMapsSize = 0;
   sizes.mLoaderSize = 0;
+  sizes.mSharedSize = 0;
 
   gfxPlatformFontList::PlatformFontList()->AddSizeOfIncludingThis(
       &FontListMallocSizeOf, &sizes);
@@ -207,6 +219,12 @@
                        "Memory used for (platform-specific) font loader.");
   }
 
+  if (sizes.mSharedSize) {
+    MOZ_COLLECT_REPORT(
+        "font-list-shmem", KIND_NONHEAP, UNITS_BYTES, sizes.mSharedSize,
+        "Shared memory for system font list and character coverage data.");
+  }
+
   return NS_OK;
 }
 
@@ -310,6 +328,40 @@
   }
 }
 
+void gfxPlatformFontList::ApplyWhitelist(
+    nsTArray<fontlist::Family::InitData>& aFamilies) {
+  nsTArray<nsCString> list;
+  gfxFontUtils::GetPrefsFontList(kFontSystemWhitelistPref, list);
+  mFontFamilyWhitelistActive = !list.IsEmpty();
+  if (!mFontFamilyWhitelistActive) {
+    return;
+  }
+  nsTHashtable<nsCStringHashKey> familyNamesWhitelist;
+  for (const auto& item : list) {
+    nsAutoCString key;
+    ToLowerCase(item, key);
+    familyNamesWhitelist.PutEntry(key);
+  }
+  int count = int(aFamilies.Length());
+  // Find the first non-hidden family; we won't delete this, if no other
+  // non-hidden family has been kept.
+  int firstNonHidden = 0;
+  while (firstNonHidden < count && aFamilies[firstNonHidden].mHidden) {
+    ++firstNonHidden;
+  }
+  bool keptNonHidden = false;
+  for (int i = count - 1; i >= firstNonHidden; --i) {
+    if (aFamilies[i].mHidden) {
+      continue;
+    }
+    if (familyNamesWhitelist.Contains(aFamilies[i].mKey)) {
+      keptNonHidden = true;
+    } else if (keptNonHidden || i > firstNonHidden) {
+      aFamilies.RemoveElementAt(i);
+    }
+  }
+}
+
 bool gfxPlatformFontList::AddWithLegacyFamilyName(const nsACString& aLegacyName,
                                                   gfxFontEntry* aFontEntry) {
   bool added = false;
@@ -365,15 +417,56 @@
 
   sPlatformFontList = this;
 
-  nsresult rv = InitFontListForPlatform();
-  if (NS_FAILED(rv)) {
-    return rv;
+  // Try to initialize the cross-process shared font list if enabled by prefs,
+  // but not if we're running in Safe Mode.
+  if (gfxPrefs::SharedFontList() && !gfxPlatform::InSafeMode()) {
+    for (auto i = mFontEntries.Iter(); !i.Done(); i.Next()) {
+      i.Data()->mShmemCharacterMap = nullptr;
+      i.Data()->mShmemFace = nullptr;
+      i.Data()->mFamilyName = NS_LITERAL_CSTRING("");
+    }
+    mFontEntries.Clear();
+    mShmemCharMaps.Clear();
+    bool oldSharedList = mSharedFontList != nullptr;
+    mSharedFontList.reset(new fontlist::FontList(mFontlistInitCount));
+    InitSharedFontListForPlatform();
+    if (mSharedFontList->Initialized()) {
+      if (mLocalNameTable.Count()) {
+        SharedFontList()->SetLocalNames(mLocalNameTable);
+        mLocalNameTable.Clear();
+      }
+    } else {
+      // something went wrong, fall back to in-process list
+      mSharedFontList.reset(nullptr);
+    }
+    if (oldSharedList) {
+      if (XRE_IsParentProcess()) {
+        // notify all children of the change
+        mozilla::dom::ContentParent::NotifyRebuildFontList();
+      }
+    }
   }
 
-  ApplyWhitelist();
+  if (!SharedFontList()) {
+    nsresult rv = InitFontListForPlatform();
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+    ApplyWhitelist();
+  }
+
   return NS_OK;
 }
 
+void gfxPlatformFontList::FontListChanged() {
+  MOZ_ASSERT(!XRE_IsParentProcess());
+  if (SharedFontList() && SharedFontList()->NumLocalFaces()) {
+    // If we're using a shared local face-name list, this may have changed.
+    RebuildLocalFonts();
+  }
+  ForceGlobalReflow();
+}
+
 void gfxPlatformFontList::GenerateFontListKey(const nsACString& aKeyName,
                                               nsACString& aResult) {
   aResult = aKeyName;
@@ -388,6 +481,13 @@
     return;
   }
 
+  if (SharedFontList() && !XRE_IsParentProcess()) {
+    dom::ContentChild::GetSingleton()->SendInitOtherFamilyNames(
+        SharedFontList()->GetGeneration(), aDeferOtherFamilyNamesLoading,
+        &mOtherFamilyNamesInitialized);
+    return;
+  }
+
   // If the font loader delay has been set to zero, we don't defer loading
   // additional family names (regardless of the aDefer... parameter), as we
   // take this to mean availability of font info is to be prioritized over
@@ -496,6 +596,37 @@
   return lookup;
 }
 
+gfxFontEntry* gfxPlatformFontList::LookupInSharedFaceNameList(
+    const nsACString& aFaceName, WeightRange aWeightForEntry,
+    StretchRange aStretchForEntry, SlantStyleRange aStyleForEntry) {
+  nsAutoCString keyName(aFaceName);
+  ToLowerCase(keyName);
+  fontlist::FontList* list = SharedFontList();
+  fontlist::Family* family = nullptr;
+  fontlist::Face* face = nullptr;
+  if (list->NumLocalFaces()) {
+    fontlist::LocalFaceRec* rec = list->FindLocalFace(keyName);
+    if (rec) {
+      family = &list->Families()[rec->mFamilyIndex];
+      face = static_cast<fontlist::Face*>(
+          family->Faces(list)[rec->mFaceIndex].ToPtr(list));
+    }
+  } else {
+    list->SearchForLocalFace(keyName, &family, &face);
+  }
+  if (!face || !family) {
+    return nullptr;
+  }
+  gfxFontEntry* fe = CreateFontEntry(face, family);
+  if (fe) {
+    fe->mIsLocalUserFont = true;
+    fe->mWeightRange = aWeightForEntry;
+    fe->mStretchRange = aStretchForEntry;
+    fe->mStyleRange = aStyleForEntry;
+  }
+  return fe;
+}
+
 void gfxPlatformFontList::PreloadNamesList() {
   AutoTArray<nsCString, 10> preloadFonts;
   gfxFontUtils::GetPrefsFontList("font.preload-names-list", preloadFonts);
@@ -524,6 +655,7 @@
 }
 
 void gfxPlatformFontList::UpdateFontList() {
+  MOZ_ASSERT(NS_IsMainThread());
   InitFontList();
   RebuildLocalFonts();
 }
@@ -531,6 +663,21 @@
 void gfxPlatformFontList::GetFontList(nsAtom* aLangGroup,
                                       const nsACString& aGenericFamily,
                                       nsTArray<nsString>& aListOfFonts) {
+  if (SharedFontList()) {
+    fontlist::FontList* list = SharedFontList();
+    const fontlist::Family* families = list->Families();
+    for (uint32_t i = 0; i < list->NumFamilies(); i++) {
+      auto& f = families[i];
+      if (f.IsHidden()) {
+        continue;
+      }
+      // XXX TODO: filter families for aGenericFamily, if supported by platform
+      aListOfFonts.AppendElement(
+          NS_ConvertUTF8toUTF16(f.DisplayName().AsString(list)));
+    }
+    return;
+  }
+
   MutexAutoLock lock(mFontFamiliesMutex);
   for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<gfxFontFamily>& family = iter.Data();
@@ -568,8 +715,17 @@
   // This helps speed up pages with lots of encoding errors, binary-as-text,
   // etc.
   if (aCh == 0xFFFD) {
-    if (!mReplacementCharFallbackFamily.mIsShared &&
-        mReplacementCharFallbackFamily.mUnshared) {
+    if (mReplacementCharFallbackFamily.mIsShared &&
+        mReplacementCharFallbackFamily.mShared) {
+      fontlist::Face* face =
+          mReplacementCharFallbackFamily.mShared->FindFaceForStyle(
+              SharedFontList(), *aStyle);
+      if (face) {
+        fontEntry =
+            GetOrCreateFontEntry(face, mReplacementCharFallbackFamily.mShared);
+      }
+    } else if (!mReplacementCharFallbackFamily.mIsShared &&
+               mReplacementCharFallbackFamily.mUnshared) {
       fontEntry =
           mReplacementCharFallbackFamily.mUnshared->FindFontForStyle(*aStyle);
     }
@@ -644,16 +800,33 @@
   gfxPlatform::GetPlatform()->GetCommonFallbackFonts(aCh, aNextCh, aRunScript,
                                                      defaultFallbacks);
   GlobalFontMatch data(aCh, *aMatchStyle);
-  for (const auto name : defaultFallbacks) {
-    gfxFontFamily* fallback =
-        FindFamilyByCanonicalName(nsDependentCString(name));
-    if (fallback) {
-      fallback->FindFontForChar(&data);
+  if (SharedFontList()) {
+    for (const auto name : defaultFallbacks) {
+      fontlist::Family* family = FindSharedFamily(nsDependentCString(name));
+      if (!family) {
+        continue;
+      }
+      if (family->IsHidden()) {
+        continue;
+      }
+      family->SearchAllFontsForChar(SharedFontList(), &data);
       if (data.mBestMatch) {
-        *aMatchedFamily = FontFamily(fallback);
+        *aMatchedFamily = FontFamily(family);
         return data.mBestMatch;
       }
     }
+  } else {
+    for (const auto name : defaultFallbacks) {
+      gfxFontFamily* fallback =
+          FindFamilyByCanonicalName(nsDependentCString(name));
+      if (fallback) {
+        fallback->FindFontForChar(&data);
+        if (data.mBestMatch) {
+          *aMatchedFamily = FontFamily(fallback);
+          return data.mBestMatch;
+        }
+      }
+    }
   }
   return nullptr;
 }
@@ -674,22 +847,44 @@
 
   // otherwise, try to find it among local fonts
   GlobalFontMatch data(aCh, *aMatchStyle);
+  if (SharedFontList()) {
+    fontlist::Family* families = SharedFontList()->Families();
+    for (uint32_t i = 0; i < SharedFontList()->NumFamilies(); i++) {
+      fontlist::Family& family = families[i];
+      if (family.IsHidden()) {
+        continue;
+      }
+      family.SearchAllFontsForChar(SharedFontList(), &data);
+      if (data.mMatchDistance == 0.0) {
+        // no better style match is possible, so stop searching
+        break;
+      }
+    }
+    if (data.mBestMatch) {
+      *aMatchedFamily = FontFamily(data.mMatchedSharedFamily);
+      return data.mBestMatch;
+    }
+  } else {
+    // iterate over all font families to find a font that support the
+    // character
+    for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
+      RefPtr<gfxFontFamily>& family = iter.Data();
+      // evaluate all fonts in this family for a match
+      family->FindFontForChar(&data);
+      if (data.mMatchDistance == 0.0) {
+        // no better style match is possible, so stop searching
+        break;
+      }
+    }
 
-  // iterate over all font families to find a font that support the character
-  for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
-    RefPtr<gfxFontFamily>& family = iter.Data();
-    // evaluate all fonts in this family for a match
-    family->FindFontForChar(&data);
-    if (data.mMatchDistance == 0.0) {
-      // no better style match is possible, so stop searching
-      break;
+    aCmapCount = data.mCmapsTested;
+    if (data.mBestMatch) {
+      *aMatchedFamily = FontFamily(data.mMatchedFamily);
+      return data.mBestMatch;
     }
   }
 
-  aCmapCount = data.mCmapsTested;
-  *aMatchedFamily = FontFamily(data.mMatchedFamily);
-
-  return data.mBestMatch;
+  return nullptr;
 }
 
 gfxFontFamily* gfxPlatformFontList::CheckFamily(gfxFontFamily* aFamily) {
@@ -710,11 +905,44 @@
 }
 
 bool gfxPlatformFontList::FindAndAddFamilies(
-    const nsACString& aFamily, nsTArray<FamilyAndGeneric>* aOutput,
-    FindFamiliesFlags aFlags, gfxFontStyle* aStyle, gfxFloat aDevToCssSize) {
+    StyleGenericFontFamily aGeneric, const nsACString& aFamily,
+    nsTArray<FamilyAndGeneric>* aOutput, FindFamiliesFlags aFlags,
+    gfxFontStyle* aStyle, gfxFloat aDevToCssSize) {
   nsAutoCString key;
   GenerateFontListKey(aFamily, key);
 
+  if (SharedFontList()) {
+    fontlist::Family* family = SharedFontList()->FindFamily(key);
+    if (family) {
+      aOutput->AppendElement(FamilyAndGeneric(family, aGeneric));
+      return true;
+    }
+    // If not found, and other family names have not yet been initialized,
+    // initialize the rest of the list and try again. This is done lazily
+    // since reading name table entries is expensive.
+    // Although ASCII localized family names are possible they don't occur
+    // in practice, so avoid pulling in names at startup.
+    if (!mOtherFamilyNamesInitialized && !IsASCII(aFamily)) {
+      InitOtherFamilyNames(
+          !(aFlags & FindFamiliesFlags::eForceOtherFamilyNamesLoading));
+      family = SharedFontList()->FindFamily(key);
+      if (family) {
+        aOutput->AppendElement(FamilyAndGeneric(family, aGeneric));
+        return true;
+      }
+      if (!family && !mOtherFamilyNamesInitialized &&
+          !(aFlags & FindFamiliesFlags::eNoAddToNamesMissedWhenSearching)) {
+        // localized family names load timed out, add name to list of
+        // names to check after localized names are loaded
+        if (!mOtherNamesMissed) {
+          mOtherNamesMissed = MakeUnique<nsTHashtable<nsCStringHashKey>>(2);
+        }
+        mOtherNamesMissed->PutEntry(key);
+      }
+    }
+    return false;
+  }
+
   NS_ASSERTION(mFontFamilies.Count() != 0,
                "system font list was not initialized correctly");
 
@@ -765,8 +993,8 @@
     }
     if (index > 0) {
       gfxFontFamily* base =
-          FindFamily(Substring(aFamily, 0, index),
-                     FindFamiliesFlags::eNoSearchForLegacyFamilyNames);
+          FindUnsharedFamily(Substring(aFamily, 0, index),
+                             FindFamiliesFlags::eNoSearchForLegacyFamilyNames);
       // If we found the "base" family name, and if it has members with
       // legacy names, this will add corresponding font-family entries to
       // the mOtherFamilyNames list; then retry the legacy-family search.
@@ -777,20 +1005,66 @@
   }
 
   if (familyEntry) {
-    aOutput->AppendElement(FamilyAndGeneric(familyEntry));
+    aOutput->AppendElement(FamilyAndGeneric(familyEntry, aGeneric));
     return true;
   }
 
   return false;
 }
 
+fontlist::Family* gfxPlatformFontList::FindSharedFamily(
+    const nsACString& aFamily, FindFamiliesFlags aFlags, gfxFontStyle* aStyle,
+    gfxFloat aDevToCss) {
+  if (!SharedFontList()) {
+    return nullptr;
+  }
+  AutoTArray<FamilyAndGeneric, 1> families;
+  if (!FindAndAddFamilies(StyleGenericFontFamily::None, aFamily, &families,
+                          aFlags, aStyle, aDevToCss) ||
+      !families[0].mFamily.mIsShared) {
+    return nullptr;
+  }
+  fontlist::Family* family = families[0].mFamily.mShared;
+  if (!family->IsInitialized()) {
+    if (!InitializeFamily(family)) {
+      return nullptr;
+    }
+  }
+  return family;
+}
+
+bool gfxPlatformFontList::InitializeFamily(fontlist::Family* aFamily) {
+  MOZ_ASSERT(SharedFontList());
+  auto list = SharedFontList();
+  if (!XRE_IsParentProcess()) {
+    uint32_t index = aFamily - list->Families();
+    MOZ_ASSERT(index < list->NumFamilies());
+    dom::ContentChild::GetSingleton()->SendInitializeFamily(
+        list->GetGeneration(), index);
+    return aFamily->IsInitialized();
+  }
+  AutoTArray<fontlist::Face::InitData, 16> faceList;
+  GetFacesInitDataForFamily(aFamily, faceList);
+  aFamily->AddFaces(list, faceList);
+  return aFamily->IsInitialized();
+}
+
 gfxFontEntry* gfxPlatformFontList::FindFontForFamily(
     const nsACString& aFamily, const gfxFontStyle* aStyle) {
-  gfxFontFamily* familyEntry = FindFamily(aFamily);
-
-  if (familyEntry) return familyEntry->FindFontForStyle(*aStyle);
-
-  return nullptr;
+  nsAutoCString key;
+  GenerateFontListKey(aFamily, key);
+  FontFamily family = FindFamily(key);
+  if (family.IsNull()) {
+    return nullptr;
+  }
+  if (family.mIsShared) {
+    auto face = family.mShared->FindFaceForStyle(SharedFontList(), *aStyle);
+    if (!face) {
+      return nullptr;
+    }
+    return GetOrCreateFontEntry(face, family.mShared);
+  }
+  return family.mUnshared->FindFontForStyle(*aStyle);
 }
 
 gfxFontEntry* gfxPlatformFontList::GetOrCreateFontEntry(
@@ -840,20 +1114,23 @@
 
 bool gfxPlatformFontList::GetStandardFamilyName(const nsCString& aFontName,
                                                 nsACString& aFamilyName) {
-  aFamilyName.Truncate();
-  gfxFontFamily* ff = FindFamily(aFontName);
-  if (!ff) {
+  FontFamily family = FindFamily(aFontName);
+  if (family.IsNull()) {
     return false;
   }
-  aFamilyName = ff->Name();
+  if (family.mIsShared) {
+    aFamilyName = family.mShared->DisplayName().AsString(SharedFontList());
+    return true;
+  }
+  family.mUnshared->LocalizedName(aFamilyName);
   return true;
 }
 
-gfxFontFamily* gfxPlatformFontList::GetDefaultFontFamily(
+FamilyAndGeneric gfxPlatformFontList::GetDefaultFontFamily(
     const nsACString& aLangGroup, const nsACString& aGenericFamily) {
   if (NS_WARN_IF(aLangGroup.IsEmpty()) ||
       NS_WARN_IF(aGenericFamily.IsEmpty())) {
-    return nullptr;
+    return FamilyAndGeneric();
   }
 
   AutoTArray<nsCString, 4> names;
@@ -861,12 +1138,31 @@
       NameListPref(aGenericFamily, aLangGroup).get(), names);
 
   for (const nsCString& name : names) {
-    gfxFontFamily* fontFamily = FindFamily(name);
-    if (fontFamily) {
-      return fontFamily;
+    FontFamily family = FindFamily(name);
+    if (!family.IsNull()) {
+      return FamilyAndGeneric(family);
     }
   }
-  return nullptr;
+
+  return FamilyAndGeneric();
+}
+
+ShmemCharMapHashEntry::ShmemCharMapHashEntry(const gfxSparseBitSet* aCharMap)
+    : mList(gfxPlatformFontList::PlatformFontList()->SharedFontList()),
+      mCharMap(),
+      mHash(aCharMap->GetChecksum()) {
+  size_t len = SharedBitSet::RequiredSize(*aCharMap);
+  mCharMap = mList->Alloc(len);
+  SharedBitSet::Create(mCharMap.ToPtr(mList), len, *aCharMap);
+}
+
+fontlist::Pointer gfxPlatformFontList::GetShmemCharMap(
+    const gfxSparseBitSet* aCmap) {
+  auto* entry = mShmemCharMaps.GetEntry(aCmap);
+  if (!entry) {
+    entry = mShmemCharMaps.PutEntry(aCmap);
+  }
+  return entry->GetCharMap();
 }
 
 gfxCharacterMap* gfxPlatformFontList::FindCharMap(gfxCharacterMap* aCmap) {
@@ -921,14 +1217,16 @@
   nsAtom* langGroup = GetLangGroupForPrefLang(aPrefLang);
   NS_ASSERTION(langGroup, "null lang group for pref lang");
 
-  gfxPlatformFontList::GetFontFamiliesFromGenericFamilies(
-      genericFamilies, langGroup, aGenericFamilies);
+  GetFontFamiliesFromGenericFamilies(aGenericType, genericFamilies, langGroup,
+                                     aGenericFamilies);
 
 #if 0  // dump out generic mappings
-    printf("%s ===> ", prefFontName.get());
+    printf("%s ===> ", NamePref(generic, langGroupStr).get());
     for (uint32_t k = 0; k < aGenericFamilies->Length(); k++) {
         if (k > 0) printf(", ");
-        printf("%s", aGenericFamilies[k]->Name().get());
+        printf("%s", (*aGenericFamilies)[k].mIsShared
+            ? (*aGenericFamilies)[k].mShared->DisplayName().AsString(SharedFontList()).get()
+            : (*aGenericFamilies)[k].mUnshared->Name().get());
     }
     printf("\n");
 #endif
@@ -942,11 +1240,13 @@
   nsAutoCString prefFontListName("font.name-list.emoji");
   gfxFontUtils::AppendPrefsFontList(prefFontListName.get(), genericFamilies);
 
-  gfxPlatformFontList::GetFontFamiliesFromGenericFamilies(
-      genericFamilies, nullptr, aGenericFamilies);
+  GetFontFamiliesFromGenericFamilies(StyleGenericFontFamily::MozEmoji,
+                                     genericFamilies, nullptr,
+                                     aGenericFamilies);
 }
 
 void gfxPlatformFontList::GetFontFamiliesFromGenericFamilies(
+    StyleGenericFontFamily aGenericType,
     nsTArray<nsCString>& aGenericNameFamilies, nsAtom* aLangGroup,
     PrefFontList* aGenericFamilies) {
   // lookup and add platform fonts uniquely
@@ -955,7 +1255,8 @@
     style.language = aLangGroup;
     style.systemFont = false;
     AutoTArray<FamilyAndGeneric, 10> families;
-    FindAndAddFamilies(genericFamily, &families, FindFamiliesFlags(0), &style);
+    FindAndAddFamilies(aGenericType, genericFamily, &families,
+                       FindFamiliesFlags(0), &style);
     for (const FamilyAndGeneric& f : families) {
       if (!aGenericFamilies->Contains(f.mFamily)) {
         aGenericFamilies->AppendElement(f.mFamily);
@@ -988,7 +1289,7 @@
 }
 
 void gfxPlatformFontList::AddGenericFonts(
-    mozilla::StyleGenericFontFamily aGenericType, nsAtom* aLanguage,
+    StyleGenericFontFamily aGenericType, nsAtom* aLanguage,
     nsTArray<FamilyAndGeneric>& aFamilyList) {
   // map lang ==> langGroup
   nsAtom* langGroup = GetLangGroup(aLanguage);
@@ -1205,8 +1506,8 @@
     AppendPrefLang(aPrefLangs, aLen, aPageLang);
   }
 
-  // if not set up, set up the default CJK order, based on accept lang settings
-  // and locale
+  // if not set up, set up the default CJK order, based on accept lang
+  // settings and locale
   if (mCJKPrefLangs.Length() == 0) {
     // temp array
     eFontPrefLang tempPrefLangs[kMaxLenPrefLangList];
@@ -1341,7 +1642,7 @@
   }
 }
 
-mozilla::StyleGenericFontFamily gfxPlatformFontList::GetDefaultGeneric(
+StyleGenericFontFamily gfxPlatformFontList::GetDefaultGeneric(
     eFontPrefLang aLang) {
   if (aLang == eFontPrefLang_Emoji) {
     return StyleGenericFontFamily::MozEmoji;
@@ -1371,21 +1672,33 @@
 
 FontFamily gfxPlatformFontList::GetDefaultFont(const gfxFontStyle* aStyle) {
   FontFamily family = GetDefaultFontForPlatform(aStyle);
-  if (!family.mIsShared && family.mUnshared) {
+  if (!family.IsNull()) {
     return family;
   }
   // Something has gone wrong and we were unable to retrieve a default font
   // from the platform. (Likely the whitelist has blocked all potential
-  // default fonts.) As a last resort, we return the first font listed in
-  // mFontFamilies.
+  // default fonts.) As a last resort, we return the first font in our list.
+  if (SharedFontList()) {
+    MOZ_RELEASE_ASSERT(SharedFontList()->NumFamilies() > 0);
+    return FontFamily(SharedFontList()->Families());
+  }
+  MOZ_RELEASE_ASSERT(mFontFamilies.Count() > 0);
   return FontFamily(mFontFamilies.Iter().Data());
 }
 
 void gfxPlatformFontList::GetFontFamilyNames(
     nsTArray<nsCString>& aFontFamilyNames) {
-  for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
-    RefPtr<gfxFontFamily>& family = iter.Data();
-    aFontFamilyNames.AppendElement(family->Name());
+  if (SharedFontList()) {
+    fontlist::FontList* list = SharedFontList();
+    const fontlist::Family* families = list->Families();
+    for (uint32_t i = 0, n = list->NumFamilies(); i < n; i++) {
+      aFontFamilyNames.AppendElement(families[i].DisplayName().AsString(list));
+    }
+  } else {
+    for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
+      RefPtr<gfxFontFamily>& family = iter.Data();
+      aFontFamilyNames.AppendElement(family->Name());
+    }
   }
 }
 
@@ -1441,26 +1754,40 @@
 bool gfxPlatformFontList::LoadFontInfo() {
   TimeStamp start = TimeStamp::Now();
   uint32_t i, endIndex = mNumFamilies;
-  bool loadCmaps = !UsesSystemFallback() ||
-                   gfxPlatform::GetPlatform()->UseCmapsDuringSystemFallback();
+  fontlist::FontList* list = SharedFontList();
+  bool loadCmaps =
+    !list && (!UsesSystemFallback() ||
+              gfxPlatform::GetPlatform()->UseCmapsDuringSystemFallback());
 
   // for each font family, load in various font info
   for (i = mStartIndex; i < endIndex; i++) {
     nsAutoCString key;
-    gfxFontFamily* familyEntry;
     GenerateFontListKey(mFontInfo->mFontFamiliesToLoad[i], key);
 
-    // lookup in canonical (i.e. English) family name list
-    if (!(familyEntry = mFontFamilies.GetWeak(key))) {
-      continue;
-    }
+    if (list) {
+      fontlist::Family* family = list->FindFamily(key);
+      if (!family) {
+        continue;
+      }
+      if (family->IsHidden()) {
+        continue;
+      }
+      ReadFaceNamesForFamily(family, NeedFullnamePostscriptNames());
+    } else {
+      // lookup in canonical (i.e. English) family name list
+      gfxFontFamily* familyEntry = mFontFamilies.GetWeak(key);
+      if (!familyEntry) {
+        continue;
+      }
 
-    // read in face names
-    familyEntry->ReadFaceNames(this, NeedFullnamePostscriptNames(), mFontInfo);
+      // read in face names
+      familyEntry->ReadFaceNames(this, NeedFullnamePostscriptNames(),
+                                 mFontInfo);
 
-    // load the cmaps if needed
-    if (loadCmaps) {
-      familyEntry->ReadAllCMAPs(mFontInfo);
+      // load the cmaps if needed
+      if (loadCmaps) {
+        familyEntry->ReadAllCMAPs(mFontInfo);
+      }
     }
 
     // limit the time spent reading fonts in one pass
@@ -1509,9 +1836,10 @@
 
   if (mOtherNamesMissed) {
     for (auto it = mOtherNamesMissed->Iter(); !it.Done(); it.Next()) {
-      if (FindFamily(it.Get()->GetKey(),
-                     (FindFamiliesFlags::eForceOtherFamilyNamesLoading |
-                      FindFamiliesFlags::eNoAddToNamesMissedWhenSearching))) {
+      if (FindUnsharedFamily(
+              it.Get()->GetKey(),
+              (FindFamiliesFlags::eForceOtherFamilyNamesLoading |
+               FindFamiliesFlags::eNoAddToNamesMissedWhenSearching))) {
         forceReflow = true;
         ForceGlobalReflow();
         break;
@@ -1543,6 +1871,10 @@
   StartLoader(delay, interval);
 }
 
+void gfxPlatformFontList::ForceGlobalReflow() {
+  gfxPlatform::ForceGlobalReflow();
+}
+
 void gfxPlatformFontList::RebuildLocalFonts() {
   for (auto it = mUserFontSetList.Iter(); !it.Done(); it.Next()) {
     it.Get()->GetKey()->RebuildLocalRules();
@@ -1636,6 +1968,20 @@
     aSizes->mCharMapsSize +=
         iter.Get()->GetKey()->SizeOfIncludingThis(aMallocSizeOf);
   }
+
+  aSizes->mFontListSize +=
+      mFontEntries.ShallowSizeOfExcludingThis(aMallocSizeOf);
+  for (auto iter = mFontEntries.ConstIter(); !iter.Done(); iter.Next()) {
+    iter.Data()->AddSizeOfIncludingThis(aMallocSizeOf, aSizes);
+  }
+
+  if (SharedFontList()) {
+    aSizes->mFontListSize +=
+        SharedFontList()->SizeOfIncludingThis(aMallocSizeOf);
+    if (XRE_IsParentProcess()) {
+      aSizes->mSharedSize += SharedFontList()->AllocatedShmemSize();
+    }
+  }
 }
 
 void gfxPlatformFontList::AddSizeOfIncludingThis(MallocSizeOf aMallocSizeOf,
@@ -1658,13 +2004,26 @@
     TimeStamp start = TimeStamp::Now();
     bool timedOut = false;
 
-    for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
-      RefPtr<gfxFontFamily>& family = iter.Data();
-      family->ReadOtherFamilyNames(this);
-      TimeDuration elapsed = TimeStamp::Now() - start;
-      if (elapsed.ToMilliseconds() > OTHERNAMES_TIMEOUT) {
-        timedOut = true;
-        break;
+    auto list = SharedFontList();
+    if (list) {
+      for (auto& f : mozilla::Range<fontlist::Family>(list->Families(),
+                                                      list->NumFamilies())) {
+        ReadFaceNamesForFamily(&f, false);
+        TimeDuration elapsed = TimeStamp::Now() - start;
+        if (elapsed.ToMilliseconds() > OTHERNAMES_TIMEOUT) {
+          timedOut = true;
+          break;
+        }
+      }
+    } else {
+      for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
+        RefPtr<gfxFontFamily>& family = iter.Data();
+        family->ReadOtherFamilyNames(this);
+        TimeDuration elapsed = TimeStamp::Now() - start;
+        if (elapsed.ToMilliseconds() > OTHERNAMES_TIMEOUT) {
+          timedOut = true;
+          break;
+        }
       }
     }
 
@@ -1684,9 +2043,17 @@
   } else {
     TimeStamp start = TimeStamp::Now();
 
-    for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
-      RefPtr<gfxFontFamily>& family = iter.Data();
-      family->ReadOtherFamilyNames(this);
+    auto list = SharedFontList();
+    if (list) {
+      for (auto& f : mozilla::Range<fontlist::Family>(list->Families(),
+                                                      list->NumFamilies())) {
+        ReadFaceNamesForFamily(&f, false);
+      }
+    } else {
+      for (auto iter = mFontFamilies.Iter(); !iter.Done(); iter.Next()) {
+        RefPtr<gfxFontFamily>& family = iter.Data();
+        family->ReadOtherFamilyNames(this);
+      }
     }
 
     mOtherFamilyNamesInitialized = true;
@@ -1710,15 +2077,35 @@
     mPendingOtherFamilyNameTask->Cancel();
     mPendingOtherFamilyNameTask = nullptr;
   }
+  auto list = SharedFontList();
+  if (list) {
+    bool forceReflow = false;
+    if (!mAliasTable.IsEmpty()) {
+      list->SetAliases(mAliasTable);
+      mAliasTable.Clear();
+      forceReflow = true;
+    }
+    if (mLocalNameTable.Count()) {
+      list->SetLocalNames(mLocalNameTable);
+      mLocalNameTable.Clear();
+      forceReflow = true;
+    }
+    if (forceReflow) {
+      dom::ContentParent::BroadcastFontListChanged();
+    }
+  }
 }
 
 void gfxPlatformFontList::ShareFontListShmBlockToProcess(
     uint32_t aGeneration, uint32_t aIndex, /*base::ProcessId*/ uint32_t aPid,
     /*mozilla::ipc::SharedMemoryBasic::Handle*/ void* aOut) {
-  MOZ_ASSERT(SharedFontList());
+  auto list = SharedFontList();
+  if (!list) {
+    return;
+  }
   auto out = static_cast<mozilla::ipc::SharedMemoryBasic::Handle*>(aOut);
-  if (!aGeneration || SharedFontList()->GetGeneration() == aGeneration) {
-    SharedFontList()->ShareShmBlockToProcess(aIndex, aPid, out);
+  if (!aGeneration || list->GetGeneration() == aGeneration) {
+    list->ShareShmBlockToProcess(aIndex, aPid, out);
   } else {
     *out = mozilla::ipc::SharedMemoryBasic::NULLHandle();
   }
@@ -1726,31 +2113,48 @@
 
 void gfxPlatformFontList::InitializeFamily(uint32_t aGeneration,
                                            uint32_t aFamilyIndex) {
-  MOZ_ASSERT(SharedFontList());
-  if (SharedFontList()->GetGeneration() != aGeneration) {
+  auto list = SharedFontList();
+  MOZ_ASSERT(list);
+  if (!list) {
+    return;
+  }
+  if (list->GetGeneration() != aGeneration) {
     return;
   }
-  if (aFamilyIndex >= SharedFontList()->NumFamilies()) {
+  if (aFamilyIndex >= list->NumFamilies()) {
     return;
   }
-  Unused << InitializeFamily(SharedFontList()->Families() + aFamilyIndex);
+  fontlist::Family* family = list->Families() + aFamilyIndex;
+  if (!family->IsInitialized()) {
+    Unused << InitializeFamily(family);
+  }
 }
 
 void gfxPlatformFontList::SetCharacterMap(uint32_t aGeneration,
                                           const fontlist::Pointer& aFacePtr,
                                           const gfxSparseBitSet& aMap) {
-  MOZ_ASSERT(SharedFontList());
-  if (SharedFontList()->GetGeneration() != aGeneration) {
+  auto list = SharedFontList();
+  MOZ_ASSERT(list);
+  if (!list) {
     return;
   }
-  fontlist::Face* face =
-      static_cast<fontlist::Face*>(aFacePtr.ToPtr(SharedFontList()));
-  face->SetCharacterMap(SharedFontList(), &aMap);
+  if (list->GetGeneration() != aGeneration) {
+    return;
+  }
+  fontlist::Face* face = static_cast<fontlist::Face*>(aFacePtr.ToPtr(list));
+  if (face) {
+    face->SetCharacterMap(list, &aMap);
+  }
 }
 
 void gfxPlatformFontList::InitOtherFamilyNames(uint32_t aGeneration,
                                                bool aDefer) {
-  if (SharedFontList()->GetGeneration() != aGeneration) {
+  auto list = SharedFontList();
+  MOZ_ASSERT(list);
+  if (!list) {
+    return;
+  }
+  if (list->GetGeneration() != aGeneration) {
     return;
   }
   InitOtherFamilyNames(aDefer);