# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxPlatform.cpp
# Commit: 75b04de7e99c
# Full Hash: 75b04de7e99cab7bed5cc8b0f2f6d52ddf174bf3
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2019-05-25 09:39:13
# Regressor Bug: 1550422
# File Overlap Count: 1
# Description:
#   Bug 1550422 - P15. Move Skip and Once gfxPrefs to StaticPrefs. r=jrmuizel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D31259
# ==============================================================================

diff -r 91c3acdb2454 -r 75b04de7e99c gfx/thebes/gfxPlatform.cpp
--- a/gfx/thebes/gfxPlatform.cpp	Fri May 24 11:32:20 2019 +0000
+++ b/gfx/thebes/gfxPlatform.cpp	Fri May 24 11:32:54 2019 +0000
@@ -600,7 +600,7 @@
   // We don't need to change the font cache count since we usually
   // cache thrash due to asian character sets in talos.
   // Only increase memory on the content process
-  uint32_t cacheSize = gfxPrefs::SkiaContentFontCacheSize() * 1024 * 1024;
+  uint32_t cacheSize = StaticPrefs::SkiaContentFontCacheSize() * 1024 * 1024;
   if (mozilla::BrowserTabsRemoteAutostart()) {
     return XRE_IsContentProcess() ? cacheSize : kDefaultGlyphCacheSize;
   }
@@ -892,25 +892,25 @@
   {
     nsAutoCString forcedPrefs;
     // D2D prefs
-    forcedPrefs.AppendPrintf("FP(D%d%d", gfxPrefs::Direct2DDisabled(),
-                             gfxPrefs::Direct2DForceEnabled());
+    forcedPrefs.AppendPrintf("FP(D%d%d", StaticPrefs::Direct2DDisabled(),
+                             StaticPrefs::Direct2DForceEnabled());
     // Layers prefs
     forcedPrefs.AppendPrintf(
-        "-L%d%d%d%d", gfxPrefs::LayersAMDSwitchableGfxEnabled(),
-        gfxPrefs::LayersAccelerationDisabledDoNotUseDirectly(),
-        gfxPrefs::LayersAccelerationForceEnabledDoNotUseDirectly(),
-        gfxPrefs::LayersD3D11ForceWARP());
+        "-L%d%d%d%d", StaticPrefs::LayersAMDSwitchableGfxEnabled(),
+        StaticPrefs::LayersAccelerationDisabledDoNotUseDirectly(),
+        StaticPrefs::LayersAccelerationForceEnabledDoNotUseDirectly(),
+        StaticPrefs::LayersD3D11ForceWARP());
     // WebGL prefs
     forcedPrefs.AppendPrintf(
         "-W%d%d%d%d%d%d%d%d", StaticPrefs::WebGLANGLEForceD3D11(),
         StaticPrefs::WebGLANGLEForceWARP(), StaticPrefs::WebGLDisabled(),
         StaticPrefs::WebGLDisableANGLE(), StaticPrefs::WebGLDXGLEnabled(),
-        StaticPrefs::WebGLForceEnabled(), gfxPrefs::WebGLForceLayersReadback(),
-        StaticPrefs::WebGLForceMSAA());
+        StaticPrefs::WebGLForceEnabled(),
+        StaticPrefs::WebGLForceLayersReadback(), StaticPrefs::WebGLForceMSAA());
     // Prefs that don't fit into any of the other sections
-    forcedPrefs.AppendPrintf("-T%d%d%d) ", gfxPrefs::AndroidRGB16Force(),
+    forcedPrefs.AppendPrintf("-T%d%d%d) ", StaticPrefs::AndroidRGB16Force(),
                              0,  // SkiaGL canvas no longer supported
-                             gfxPrefs::ForceShmemTiles());
+                             StaticPrefs::ForceShmemTiles());
     ScopedGfxFeatureReporter::AppNote(forcedPrefs);
   }
 
@@ -951,6 +951,7 @@
   gPlatform->PopulateScreenInfo();
   gPlatform->InitAcceleration();
   gPlatform->InitWebRenderConfig();
+
   // When using WebRender, we defer initialization of the D3D11 devices until
   // the (rare) cases where they're used. Note that the GPU process where
   // WebRender runs doesn't initialize gfxPlatform and performs explicit
@@ -1118,7 +1119,7 @@
   // Make sure we don't completely break rendering because of a typo in the
   // pref or whatnot.
   const int32_t kMinSizePref = 2048;
-  return std::max(kMinSizePref, gfxPrefs::MaxTextureSizeDoNotUseDirectly());
+  return std::max(kMinSizePref, StaticPrefs::MaxTextureSizeDoNotUseDirectly());
 }
 
 /* static */
@@ -1126,14 +1127,14 @@
   // Make sure we don't completely break rendering because of a typo in the
   // pref or whatnot.
   const int32_t kMinAllocPref = 10000000;
-  return std::max(kMinAllocPref, gfxPrefs::MaxAllocSizeDoNotUseDirectly());
+  return std::max(kMinAllocPref, StaticPrefs::MaxAllocSizeDoNotUseDirectly());
 }
 
 /* static */
 void gfxPlatform::InitMoz2DLogging() {
   auto fwd = new CrashStatsLogForwarder(
       CrashReporter::Annotation::GraphicsCriticalError);
-  fwd->SetCircularBufferSize(gfxPrefs::GfxLoggingCrashLength());
+  fwd->SetCircularBufferSize(StaticPrefs::GfxLoggingCrashLength());
 
   mozilla::gfx::Config cfg;
   cfg.mLogForwarder = fwd;
@@ -1538,10 +1539,10 @@
     return;
   }
 
-  int32_t w = gfxPrefs::LayersTileWidth();
-  int32_t h = gfxPrefs::LayersTileHeight();
-
-  if (gfxPrefs::LayersTilesAdjust()) {
+  int32_t w = StaticPrefs::LayersTileWidth();
+  int32_t h = StaticPrefs::LayersTileHeight();
+
+  if (StaticPrefs::LayersTilesAdjust()) {
     gfx::IntSize screenSize = GetScreenSize();
     if (screenSize.width > 0) {
       // Choose a size so that there are between 2 and 4 tiles per screen width.
@@ -2381,7 +2382,7 @@
           gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_HARDWARE_VIDEO_DECODING,
                                     discardFailureId, &status))) {
     if (status == nsIGfxInfo::FEATURE_STATUS_OK ||
-        gfxPrefs::HardwareVideoDecodingForceEnabled()) {
+        StaticPrefs::HardwareVideoDecodingForceEnabled()) {
       sLayersSupportsHardwareVideoDecoding = true;
     }
   }
@@ -2399,7 +2400,8 @@
 void gfxPlatform::InitGPUProcessPrefs() {
   // We want to hide this from about:support, so only set a default if the
   // pref is known to be true.
-  if (!gfxPrefs::GPUProcessEnabled() && !gfxPrefs::GPUProcessForceEnabled()) {
+  if (!StaticPrefs::GPUProcessEnabled() &&
+      !StaticPrefs::GPUProcessForceEnabled()) {
     return;
   }
 
@@ -2413,11 +2415,12 @@
                              "Multi-process mode is not enabled",
                              NS_LITERAL_CSTRING("FEATURE_FAILURE_NO_E10S"));
   } else {
-    gpuProc.SetDefaultFromPref(gfxPrefs::GetGPUProcessEnabledPrefName(), true,
-                               gfxPrefs::GetGPUProcessEnabledPrefDefault());
+    gpuProc.SetDefaultFromPref(StaticPrefs::GetGPUProcessEnabledPrefName(),
+                               true,
+                               StaticPrefs::GetGPUProcessEnabledPrefDefault());
   }
 
-  if (gfxPrefs::GPUProcessForceEnabled()) {
+  if (StaticPrefs::GPUProcessForceEnabled()) {
     gpuProc.UserForceEnable("User force-enabled via pref");
   }
 
@@ -2447,7 +2450,7 @@
   // Base value - does the platform allow acceleration?
   if (feature.SetDefault(AccelerateLayersByDefault(), FeatureStatus::Blocked,
                          "Acceleration blocked by platform")) {
-    if (gfxPrefs::LayersAccelerationDisabledDoNotUseDirectly()) {
+    if (StaticPrefs::LayersAccelerationDisabledDoNotUseDirectly()) {
       feature.UserDisable("Disabled by pref",
                           NS_LITERAL_CSTRING("FEATURE_FAILURE_COMP_PREF"));
     } else if (acceleratedEnv && *acceleratedEnv == '0') {
@@ -2461,7 +2464,7 @@
   }
 
   // This has specific meaning elsewhere, so we always record it.
-  if (gfxPrefs::LayersAccelerationForceEnabledDoNotUseDirectly()) {
+  if (StaticPrefs::LayersAccelerationForceEnabledDoNotUseDirectly()) {
     feature.UserForceEnable("Force-enabled by pref");
   }
 
@@ -2485,8 +2488,8 @@
 
 /*static*/
 bool gfxPlatform::WebRenderPrefEnabled() {
-  return gfxPrefs::WebRenderAll() ||
-         gfxPrefs::WebRenderEnabledDoNotUseDirectly();
+  return StaticPrefs::WebRenderAll() ||
+         StaticPrefs::WebRenderEnabledDoNotUseDirectly();
 }
 
 /*static*/
@@ -2519,10 +2522,11 @@
   if (!Preferences::HasUserValue(WR_ROLLOUT_PREF) &&
       Preferences::HasUserValue(WR_ROLLOUT_PREF_DEFAULT)) {
     // The user has not set a user pref, and we have a default value set by the
-    // shutdown observer. We should use that instead of the gfxPref's default,
-    // as if Normandy had a chance to set it before startup, that is the value
-    // gfxPrefs would return, rather than the default set by DECL_GFX_PREF.
-    return gfxPrefs::WebRenderAllQualifiedDefault();
+    // shutdown observer. We should use that instead of the StaticPrefs's
+    // default, as if Normandy had a chance to set it before startup, that is
+    // the value StaticPrefs would return, rather than the default set by
+    // DECL_GFX_PREF.
+    return StaticPrefs::WebRenderAllQualifiedDefault();
   }
 
   // We don't have a user value for the rollout pref, and we don't have the
@@ -2534,7 +2538,7 @@
   if (Preferences::HasUserValue(WR_ROLLOUT_PREF_OVERRIDE)) {
     return Preferences::GetBool(WR_ROLLOUT_PREF_OVERRIDE);
   }
-  return gfxPrefs::WebRenderAllQualified();
+  return StaticPrefs::WebRenderAllQualified();
 }
 
 static FeatureState& WebRenderHardwareQualificationStatus(
@@ -2805,7 +2809,7 @@
   // If the user set the pref to force-disable, let's do that. This will
   // override all the other enabling prefs (gfx.webrender.enabled,
   // gfx.webrender.all, and gfx.webrender.all.qualified).
-  if (gfxPrefs::WebRenderForceDisabled() || WebRenderEnvvarDisabled()) {
+  if (StaticPrefs::WebRenderForceDisabled() || WebRenderEnvvarDisabled()) {
     featureWebRender.UserDisable(
         "User force-disabled WR",
         NS_LITERAL_CSTRING("FEATURE_FAILURE_USER_FORCE_DISABLED"));
@@ -2967,7 +2971,7 @@
 bool gfxPlatform::BufferRotationEnabled() {
   MutexAutoLock autoLock(*gGfxPlatformPrefsLock);
 
-  return sBufferRotationCheckPref && gfxPrefs::BufferRotationEnabled();
+  return sBufferRotationCheckPref && StaticPrefs::BufferRotationEnabled();
 }
 
 void gfxPlatform::DisableBufferRotation() {
@@ -2988,10 +2992,10 @@
   if (firstTime) {
     MOZ_ASSERT(sLayersAccelerationPrefsInitialized);
     result = gfxVars::BrowserTabsRemoteAutostart() ||
-             !gfxPrefs::LayersOffMainThreadCompositionForceDisabled();
+             !StaticPrefs::LayersOffMainThreadCompositionForceDisabled();
 #if defined(MOZ_WIDGET_GTK)
     // Linux users who chose OpenGL are being grandfathered in to OMTC
-    result |= gfxPrefs::LayersAccelerationForceEnabledDoNotUseDirectly();
+    result |= StaticPrefs::LayersAccelerationForceEnabledDoNotUseDirectly();
 
 #endif
     firstTime = false;
@@ -3007,11 +3011,12 @@
   // this function is used when initializing the PaintThread. So instead we
   // check the conditions that enable OMTP with parallel painting.
   bool usesPOMTP = XRE_IsContentProcess() && gfxVars::UseOMTP() &&
-                   (gfxPrefs::LayersOMTPPaintWorkers() == -1 ||
-                    gfxPrefs::LayersOMTPPaintWorkers() > 1);
-
-  return gfxPrefs::LayersTilesEnabled() ||
-         (gfxPrefs::LayersTilesEnabledIfSkiaPOMTP() && usesSkia && usesPOMTP);
+                   (StaticPrefs::LayersOMTPPaintWorkers() == -1 ||
+                    StaticPrefs::LayersOMTPPaintWorkers() > 1);
+
+  return StaticPrefs::LayersTilesEnabled() ||
+         (StaticPrefs::LayersTilesEnabledIfSkiaPOMTP() && usesSkia &&
+          usesPOMTP);
 }
 
 bool gfxPlatform::ContentUsesTiling() const {
@@ -3023,11 +3028,11 @@
 
   bool contentUsesSkia = contentBackend == BackendType::SKIA;
   bool contentUsesPOMTP =
-      gfxVars::UseOMTP() && (gfxPrefs::LayersOMTPPaintWorkers() == -1 ||
-                             gfxPrefs::LayersOMTPPaintWorkers() > 1);
-
-  return gfxPrefs::LayersTilesEnabled() ||
-         (gfxPrefs::LayersTilesEnabledIfSkiaPOMTP() && contentUsesSkia &&
+      gfxVars::UseOMTP() && (StaticPrefs::LayersOMTPPaintWorkers() == -1 ||
+                             StaticPrefs::LayersOMTPPaintWorkers() > 1);
+
+  return StaticPrefs::LayersTilesEnabled() ||
+         (StaticPrefs::LayersTilesEnabledIfSkiaPOMTP() && contentUsesSkia &&
           contentUsesPOMTP);
 }
 
@@ -3151,7 +3156,7 @@
 }
 
 void gfxPlatform::GetTilesSupportInfo(mozilla::widget::InfoObject& aObj) {
-  if (!gfxPrefs::LayersTilesEnabled()) {
+  if (!StaticPrefs::LayersTilesEnabled()) {
     return;
   }
 
@@ -3199,7 +3204,7 @@
 };
 
 void gfxPlatform::NotifyFrameStats(nsTArray<FrameStats>&& aFrameStats) {
-  if (!gfxPrefs::LoggingSlowFramesEnabled()) {
+  if (!StaticPrefs::LoggingSlowFramesEnabled()) {
     return;
   }
 
@@ -3240,7 +3245,7 @@
     MOZ_ASSERT(NS_IsMainThread());
     gfxPrefs::GetSingleton();
   }
-  return gfxPrefs::AsyncPanZoomEnabledDoNotUseDirectly();
+  return StaticPrefs::AsyncPanZoomEnabledDoNotUseDirectly();
 #endif
 }
 
@@ -3361,7 +3366,7 @@
 }
 
 bool gfxPlatform::SupportsApzKeyboardInput() const {
-  return gfxPrefs::APZKeyboardEnabled();
+  return StaticPrefs::APZKeyboardEnabled();
 }
 
 bool gfxPlatform::SupportsApzAutoscrolling() const {
@@ -3390,15 +3395,15 @@
 
 #ifdef XP_WIN
   openGLFeature.SetDefaultFromPref(
-      gfxPrefs::GetLayersPreferOpenGLPrefName(), true,
-      gfxPrefs::GetLayersPreferOpenGLPrefDefault());
+      StaticPrefs::GetLayersPreferOpenGLPrefName(), true,
+      StaticPrefs::GetLayersPreferOpenGLPrefDefault());
 #else
   openGLFeature.EnableByDefault();
 #endif
 
   // When layers acceleration is force-enabled, enable it even for blacklisted
   // devices.
-  if (gfxPrefs::LayersAccelerationForceEnabledDoNotUseDirectly()) {
+  if (StaticPrefs::LayersAccelerationForceEnabledDoNotUseDirectly()) {
     openGLFeature.UserForceEnable("Force-enabled by pref");
     return;
   }