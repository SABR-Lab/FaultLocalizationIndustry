# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: image/decoders/icon/mac/nsIconChannelCocoa.mm
# Commit: 74f99033251c
# Full Hash: 74f99033251cd6c36eb6b0b5a4713eb6b5c793fa
# Author: Jonathan Kingston <jkt@mozilla.com>
# Date: 2019-02-13 09:48:26
# Regressor Bug: 1520868
# File Overlap Count: 1
# Description:
#   Bug 1520868 - Replacing AsyncOpen2 with AsyncOpen always r=valentin
#   
#   Replacing js and text occurences of asyncOpen2
#   Replacing open2 with open
#   
# ==============================================================================

diff -r 3378fd5f4f22 -r 74f99033251c image/decoders/icon/mac/nsIconChannelCocoa.mm
--- a/image/decoders/icon/mac/nsIconChannelCocoa.mm	Tue Feb 12 17:58:19 2019 +0100
+++ b/image/decoders/icon/mac/nsIconChannelCocoa.mm	Tue Feb 12 16:08:25 2019 +0000
@@ -131,14 +131,13 @@
 }
 
 NS_IMETHODIMP
-nsIconChannel::Open(nsIInputStream** _retval) { return MakeInputStream(_retval, false); }
-
-NS_IMETHODIMP
-nsIconChannel::Open2(nsIInputStream** aStream) {
+nsIconChannel::Open(nsIInputStream** _retval)
+{
   nsCOMPtr<nsIStreamListener> listener;
   nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
   NS_ENSURE_SUCCESS(rv, rv);
-  return Open(aStream);
+
+  return MakeInputStream(_retval, false);
 }
 
 nsresult nsIconChannel::ExtractIconInfoFromUrl(nsIFile** aLocalFile, uint32_t* aDesiredImageSize,
@@ -173,15 +172,24 @@
 }
 
 NS_IMETHODIMP
-nsIconChannel::AsyncOpen(nsIStreamListener* aListener, nsISupports* ctxt) {
+nsIconChannel::AsyncOpen(nsIStreamListener* aListener)
+{
+  nsCOMPtr<nsIStreamListener> listener = aListener;
+  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
+  if (NS_FAILED(rv)) {
+    mCallbacks = nullptr;
+    return rv;
+  }
+
   MOZ_ASSERT(
       !mLoadInfo || mLoadInfo->GetSecurityMode() == 0 || mLoadInfo->GetInitialSecurityCheckDone() ||
           (mLoadInfo->GetSecurityMode() == nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL &&
            nsContentUtils::IsSystemPrincipal(mLoadInfo->LoadingPrincipal())),
-      "security flags in loadInfo but asyncOpen2() not called");
+      "security flags in loadInfo but doContentSecurityCheck() not called");
+
 
   nsCOMPtr<nsIInputStream> inStream;
-  nsresult rv = MakeInputStream(getter_AddRefs(inStream), true);
+  MakeInputStream(getter_AddRefs(inStream), true);
   if (NS_FAILED(rv)) {
     mCallbacks = nullptr;
     return rv;
@@ -196,7 +204,7 @@
     return rv;
   }
 
-  rv = mPump->AsyncRead(this, ctxt);
+  rv = mPump->AsyncRead(this, nullptr);
   if (NS_SUCCEEDED(rv)) {
     // Store our real listener
     mListener = aListener;
@@ -211,17 +219,6 @@
   return rv;
 }
 
-NS_IMETHODIMP
-nsIconChannel::AsyncOpen2(nsIStreamListener* aListener) {
-  nsCOMPtr<nsIStreamListener> listener = aListener;
-  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
-  if (NS_FAILED(rv)) {
-    mCallbacks = nullptr;
-    return rv;
-  }
-  return AsyncOpen(listener, nullptr);
-}
-
 nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, bool aNonBlocking) {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 