# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpChannelChild.cpp
# Commit: 74f99033251c
# Full Hash: 74f99033251cd6c36eb6b0b5a4713eb6b5c793fa
# Author: Jonathan Kingston <jkt@mozilla.com>
# Date: 2019-02-13 09:48:26
# Regressor Bug: 1520868
# File Overlap Count: 1
# Description:
#   Bug 1520868 - Replacing AsyncOpen2 with AsyncOpen always r=valentin
#   
#   Replacing js and text occurences of asyncOpen2
#   Replacing open2 with open
#   
# ==============================================================================

diff -r 3378fd5f4f22 -r 74f99033251c netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp	Tue Feb 12 17:58:19 2019 +0100
+++ b/netwerk/protocol/http/HttpChannelChild.cpp	Tue Feb 12 16:08:25 2019 +0000
@@ -589,7 +589,7 @@
 
   mTransactionTimings = aTiming;
 
-  DoOnStartRequest(this, mListenerContext);
+  DoOnStartRequest(this, nullptr);
 }
 
 class SyntheticDiversionListener final : public nsIStreamListener {
@@ -669,7 +669,6 @@
 
   if (mDivertingToParent) {
     mListener = nullptr;
-    mListenerContext = nullptr;
     mCompressListener = nullptr;
     if (mLoadGroup) {
       mLoadGroup->RemoveRequest(this, nullptr, mStatus);
@@ -687,8 +686,7 @@
   }
 
   nsCOMPtr<nsIStreamListener> listener;
-  rv = DoApplyContentConversions(mListener, getter_AddRefs(listener),
-                                 mListenerContext);
+  rv = DoApplyContentConversions(mListener, getter_AddRefs(listener), nullptr);
   if (NS_FAILED(rv)) {
     Cancel(rv);
   } else if (listener) {
@@ -851,7 +849,7 @@
     return;
   }
 
-  DoOnDataAvailable(this, mListenerContext, stringStream, offset, count);
+  DoOnDataAvailable(this, nullptr, stringStream, offset, count);
   stringStream->Close();
 
   if (NeedToReportBytesRead()) {
@@ -1100,7 +1098,7 @@
     // so make sure this goes out of scope before then.
     AutoEventEnqueuer ensureSerialDispatch(mEventQ);
 
-    DoOnStopRequest(this, channelStatus, mListenerContext);
+    DoOnStopRequest(this, channelStatus, nullptr);
     // DoOnStopRequest() calls ReleaseListeners()
   }
 
@@ -1510,12 +1508,9 @@
 
 void HttpChannelChild::FinishInterceptedRedirect() {
   nsresult rv;
-  if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
-    MOZ_ASSERT(!mInterceptedRedirectContext, "the context should be null!");
-    rv = AsyncOpen2(mInterceptedRedirectListener);
-  } else {
-    rv = AsyncOpen(mInterceptedRedirectListener, mInterceptedRedirectContext);
-  }
+  MOZ_ASSERT(!mInterceptedRedirectContext, "the context should be null!");
+  rv = AsyncOpen(mInterceptedRedirectListener);
+
   mInterceptedRedirectListener = nullptr;
   mInterceptedRedirectContext = nullptr;
 
@@ -1945,8 +1940,7 @@
       httpChannelChild->mOverrideRunnable = aRunnable;
       httpChannelChild->mInterceptingChannel = this;
     }
-    rv = mRedirectChannelChild->CompleteRedirectSetup(mListener,
-                                                      mListenerContext);
+    rv = mRedirectChannelChild->CompleteRedirectSetup(mListener, nullptr);
   }
 
   if (!httpChannelChild || !httpChannelChild->mShouldParentIntercept) {
@@ -2119,7 +2113,6 @@
   mIsPending = true;
   mWasOpened = true;
   mListener = listener;
-  mListenerContext = aContext;
 
   // add ourselves to the load group.
   if (mLoadGroup) mLoadGroup->AddRequest(this, nullptr);
@@ -2181,7 +2174,7 @@
     // nsIHttpChannelChild (it could be a DataChannelChild).
 
     RefPtr<InterceptStreamListener> streamListener =
-        new InterceptStreamListener(redirectedChannel, mListenerContext);
+        new InterceptStreamListener(redirectedChannel, nullptr);
 
     nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
     MOZ_ASSERT(neckoTarget);
@@ -2387,16 +2380,24 @@
   return NS_OK;
 }
 
+
 NS_IMETHODIMP
-HttpChannelChild::AsyncOpen(nsIStreamListener* listener,
-                            nsISupports* aContext) {
+HttpChannelChild::AsyncOpen(nsIStreamListener* aListener) {
+  nsCOMPtr<nsIStreamListener> listener = aListener;
+  nsresult rv =
+      nsContentSecurityManager::doContentSecurityCheck(this, listener);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+
   MOZ_ASSERT(
       !mLoadInfo || mLoadInfo->GetSecurityMode() == 0 ||
           mLoadInfo->GetInitialSecurityCheckDone() ||
           (mLoadInfo->GetSecurityMode() ==
                nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL &&
            nsContentUtils::IsSystemPrincipal(mLoadInfo->LoadingPrincipal())),
-      "security flags in loadInfo but asyncOpen2() not called");
+      "security flags in loadInfo but doContentSecurityCheck() not called");
 
   LOG(("HttpChannelChild::AsyncOpen [this=%p uri=%s]\n", this, mSpec.get()));
   LogCallingScriptLocation(this);
@@ -2419,7 +2420,7 @@
   NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 
-  if (MaybeWaitForUploadStreamLength(listener, aContext)) {
+  if (MaybeWaitForUploadStreamLength(listener, nullptr)) {
     return NS_OK;
   }
 
@@ -2439,7 +2440,6 @@
 
   // Port checked in parent, but duplicate here so we can return with error
   // immediately
-  nsresult rv;
   rv = NS_CheckPortSafety(mURI);
   if (NS_FAILED(rv)) {
     ReleaseListeners();
@@ -2474,7 +2474,6 @@
   mIsPending = true;
   mWasOpened = true;
   mListener = listener;
-  mListenerContext = aContext;
 
   // add ourselves to the load group.
   if (mLoadGroup) mLoadGroup->AddRequest(this, nullptr);
@@ -2511,8 +2510,7 @@
       nsCOMPtr<nsINetworkInterceptController> controller;
       self->GetCallback(controller);
 
-      self->mInterceptListener =
-          new InterceptStreamListener(self, self->mListenerContext);
+      self->mInterceptListener = new InterceptStreamListener(self, nullptr);
 
       RefPtr<InterceptedChannelContent> intercepted =
           new InterceptedChannelContent(
@@ -2539,18 +2537,6 @@
   return ContinueAsyncOpen();
 }
 
-NS_IMETHODIMP
-HttpChannelChild::AsyncOpen2(nsIStreamListener* aListener) {
-  nsCOMPtr<nsIStreamListener> listener = aListener;
-  nsresult rv =
-      nsContentSecurityManager::doContentSecurityCheck(this, listener);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    ReleaseListeners();
-    return rv;
-  }
-  return AsyncOpen(listener, nullptr);
-}
-
 // Assigns an nsIEventTarget to our IPDL actor so that IPC messages are sent to
 // the correct DocGroup/TabGroup.
 void HttpChannelChild::SetEventTarget() {