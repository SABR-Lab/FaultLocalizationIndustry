# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/test/unit/test_synthesized_response.js
# Commit: 74f99033251c
# Full Hash: 74f99033251cd6c36eb6b0b5a4713eb6b5c793fa
# Author: Jonathan Kingston <jkt@mozilla.com>
# Date: 2019-02-13 09:48:26
# Regressor Bug: 1520868
# File Overlap Count: 1
# Description:
#   Bug 1520868 - Replacing AsyncOpen2 with AsyncOpen always r=valentin
#   
#   Replacing js and text occurences of asyncOpen2
#   Replacing open2 with open
#   
# ==============================================================================

diff -r 3378fd5f4f22 -r 74f99033251c netwerk/test/unit/test_synthesized_response.js
--- a/netwerk/test/unit/test_synthesized_response.js	Tue Feb 12 17:58:19 2019 +0100
+++ b/netwerk/test/unit/test_synthesized_response.js	Tue Feb 12 16:08:25 2019 +0000
@@ -118,13 +118,13 @@
   var chan = make_channel(URL + '/body', null, function(chan) {
     chan.resetInterception();
   });
-  chan.asyncOpen2(new ChannelListener(handle_remote_response, null));
+  chan.asyncOpen(new ChannelListener(handle_remote_response, null));
 });
 
 // synthesize a response
 add_test(function() {
   var chan = make_channel(URL + '/body', NON_REMOTE_BODY);
-  chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null, CL_ALLOW_UNKNOWN_CL));
+  chan.asyncOpen(new ChannelListener(handle_synthesized_response, null, CL_ALLOW_UNKNOWN_CL));
 });
 
 // hit the network instead of synthesizing, to test that no previous synthesized
@@ -133,13 +133,13 @@
   var chan = make_channel(URL + '/body', null, function(chan) {
     chan.resetInterception();
   });
-  chan.asyncOpen2(new ChannelListener(handle_remote_response, null));
+  chan.asyncOpen(new ChannelListener(handle_remote_response, null));
 });
 
 // synthesize a different response to ensure no previous response is cached
 add_test(function() {
   var chan = make_channel(URL + '/body', NON_REMOTE_BODY_2);
-  chan.asyncOpen2(new ChannelListener(handle_synthesized_response_2, null, CL_ALLOW_UNKNOWN_CL));
+  chan.asyncOpen(new ChannelListener(handle_synthesized_response_2, null, CL_ALLOW_UNKNOWN_CL));
 });
 
 // ensure that the channel waits for a decision and synthesizes headers correctly
@@ -154,7 +154,7 @@
       channel.finishSynthesizedResponse();
     });
   });
-  chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null));
+  chan.asyncOpen(new ChannelListener(handle_synthesized_response, null));
 });
 
 // ensure that the channel waits for a decision
@@ -164,7 +164,7 @@
       chan.resetInterception();
     });
   });
-  chan.asyncOpen2(new ChannelListener(handle_remote_response, null));
+  chan.asyncOpen(new ChannelListener(handle_remote_response, null));
 });
 
 // ensure that the intercepted channel supports suspend/resume
@@ -180,7 +180,7 @@
     intercepted.startSynthesizedResponse(synthesized, null, null, '', false);
     intercepted.finishSynthesizedResponse();
   });
-  chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null,
+  chan.asyncOpen(new ChannelListener(handle_synthesized_response, null,
 				     CL_ALLOW_UNKNOWN_CL | CL_SUSPEND | CL_EXPECT_3S_DELAY));
 });
 
@@ -189,7 +189,7 @@
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     intercepted.cancelInterception(Cr.NS_BINDING_ABORTED);
   });
-  chan.asyncOpen2(new ChannelListener(run_next_test, null, CL_EXPECT_FAILURE));
+  chan.asyncOpen(new ChannelListener(run_next_test, null, CL_EXPECT_FAILURE));
 });
 
 // ensure that the channel can't be cancelled via nsIInterceptedChannel after making a decision
@@ -206,7 +206,7 @@
       Assert.ok(gotexception);
     });
   });
-  chan.asyncOpen2(new ChannelListener(handle_remote_response, null));
+  chan.asyncOpen(new ChannelListener(handle_remote_response, null));
 });
 
 // ensure that the intercepted channel can be canceled during the response
@@ -221,7 +221,7 @@
     intercepted.finishSynthesizedResponse();
     channel.cancel(Cr.NS_BINDING_ABORTED);
   });
-  chan.asyncOpen2(new ChannelListener(run_next_test, null,
+  chan.asyncOpen(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
@@ -239,7 +239,7 @@
     intercepted.startSynthesizedResponse(synthesized, null, null, '', false);
     intercepted.finishSynthesizedResponse();
   });
-  chan.asyncOpen2(new ChannelListener(run_next_test, null,
+  chan.asyncOpen(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
@@ -250,7 +250,7 @@
   var chan = make_channel(URL + '/body', null, function(chan) {
     throw('boom');
   });
-  chan.asyncOpen2(new ChannelListener(handle_remote_response, null));
+  chan.asyncOpen(new ChannelListener(handle_remote_response, null));
 });
 
 add_test(function() {