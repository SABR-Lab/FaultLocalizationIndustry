# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/values/specified/position.rs
# Commit: 25354cfea038
# Full Hash: 25354cfea03822ff64efeeb420e2fa4a5732eca9
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2019-06-06 09:29:49
# Regressor Bug: 1557110
# File Overlap Count: 2
# Description:
#   Bug 1557110 - Cleanup gradient parsing by removing the simple-moz-gradient parsing pref. r=dholbert
#   
#   It looks like bug 1547939 will stick, given how fast the other regressions came
#   in for bug 1337655.
#   
# ==============================================================================

diff -r c02fd9857532 -r 25354cfea038 servo/components/style/values/specified/position.rs
--- a/servo/components/style/values/specified/position.rs	Thu Jun 06 02:56:52 2019 +0000
+++ b/servo/components/style/values/specified/position.rs	Thu Jun 06 04:08:52 2019 +0000
@@ -14,7 +14,6 @@
 use crate::values::computed::{Context, Percentage, ToComputedValue};
 use crate::values::generics::position::Position as GenericPosition;
 use crate::values::generics::position::ZIndex as GenericZIndex;
-use crate::values::specified::transform::OriginComponent;
 use crate::values::specified::{AllowQuirks, Integer, LengthPercentage};
 use crate::values::{Either, None_};
 use crate::Zero;
@@ -326,117 +325,6 @@
     }
 }
 
-/// The specified value of a legacy CSS `<position>`
-/// Modern position syntax supports 3 and 4-value syntax. That means:
-/// If three or four values are given, then each <percentage> or <length> represents an offset
-/// and must be preceded by a keyword, which specifies from which edge the offset is given.
-/// For example, `bottom 10px right 20px` represents a `10px` vertical
-/// offset up from the bottom edge and a `20px` horizontal offset leftward from the right edge.
-/// If three values are given, the missing offset is assumed to be zero.
-/// But for some historical reasons we need to keep CSS Level 2 syntax which only supports up to
-/// 2-value. This type represents this 2-value syntax.
-pub type LegacyPosition = GenericPosition<LegacyHPosition, LegacyVPosition>;
-
-/// The specified value of a horizontal position.
-pub type LegacyHPosition = OriginComponent<X>;
-
-/// The specified value of a vertical position.
-pub type LegacyVPosition = OriginComponent<Y>;
-
-impl Parse for LegacyPosition {
-    fn parse<'i, 't>(
-        context: &ParserContext,
-        input: &mut Parser<'i, 't>,
-    ) -> Result<Self, ParseError<'i>> {
-        Self::parse_quirky(context, input, AllowQuirks::No)
-    }
-}
-
-impl LegacyPosition {
-    /// Parses a `<position>`, with quirks.
-    pub fn parse_quirky<'i, 't>(
-        context: &ParserContext,
-        input: &mut Parser<'i, 't>,
-        allow_quirks: AllowQuirks,
-    ) -> Result<Self, ParseError<'i>> {
-        match input.try(|i| OriginComponent::parse(context, i)) {
-            Ok(x_pos @ OriginComponent::Center) => {
-                if let Ok(y_pos) = input.try(|i| OriginComponent::parse(context, i)) {
-                    return Ok(Self::new(x_pos, y_pos));
-                }
-                let x_pos = input
-                    .try(|i| OriginComponent::parse(context, i))
-                    .unwrap_or(x_pos);
-                let y_pos = OriginComponent::Center;
-                return Ok(Self::new(x_pos, y_pos));
-            },
-            Ok(OriginComponent::Side(x_keyword)) => {
-                if let Ok(y_keyword) = input.try(Y::parse) {
-                    let x_pos = OriginComponent::Side(x_keyword);
-                    let y_pos = OriginComponent::Side(y_keyword);
-                    return Ok(Self::new(x_pos, y_pos));
-                }
-                let x_pos = OriginComponent::Side(x_keyword);
-                if let Ok(y_lp) =
-                    input.try(|i| LengthPercentage::parse_quirky(context, i, allow_quirks))
-                {
-                    return Ok(Self::new(x_pos, OriginComponent::Length(y_lp)));
-                }
-                let _ = input.try(|i| i.expect_ident_matching("center"));
-                return Ok(Self::new(x_pos, OriginComponent::Center));
-            },
-            Ok(x_pos @ OriginComponent::Length(_)) => {
-                if let Ok(y_keyword) = input.try(Y::parse) {
-                    let y_pos = OriginComponent::Side(y_keyword);
-                    return Ok(Self::new(x_pos, y_pos));
-                }
-                if let Ok(y_lp) =
-                    input.try(|i| LengthPercentage::parse_quirky(context, i, allow_quirks))
-                {
-                    let y_pos = OriginComponent::Length(y_lp);
-                    return Ok(Self::new(x_pos, y_pos));
-                }
-                let _ = input.try(|i| i.expect_ident_matching("center"));
-                return Ok(Self::new(x_pos, OriginComponent::Center));
-            },
-            Err(_) => {},
-        }
-        let y_keyword = Y::parse(input)?;
-        let x_pos: Result<_, ParseError> = input.try(|i| {
-            if let Ok(x_keyword) = i.try(X::parse) {
-                let x_pos = OriginComponent::Side(x_keyword);
-                return Ok(x_pos);
-            }
-            i.expect_ident_matching("center")?;
-            Ok(OriginComponent::Center)
-        });
-        if let Ok(x_pos) = x_pos {
-            let y_pos = OriginComponent::Side(y_keyword);
-            return Ok(Self::new(x_pos, y_pos));
-        }
-        let x_pos = OriginComponent::Center;
-        let y_pos = OriginComponent::Side(y_keyword);
-        Ok(Self::new(x_pos, y_pos))
-    }
-
-    /// `center center`
-    #[inline]
-    pub fn center() -> Self {
-        Self::new(OriginComponent::Center, OriginComponent::Center)
-    }
-}
-
-impl ToCss for LegacyPosition {
-    fn to_css<W>(&self, dest: &mut CssWriter<W>) -> fmt::Result
-    where
-        W: Write,
-    {
-        self.horizontal.to_css(dest)?;
-        dest.write_str(" ")?;
-        self.vertical.to_css(dest)
-    }
-}
-
 #[derive(
     Clone,
     Copy,
