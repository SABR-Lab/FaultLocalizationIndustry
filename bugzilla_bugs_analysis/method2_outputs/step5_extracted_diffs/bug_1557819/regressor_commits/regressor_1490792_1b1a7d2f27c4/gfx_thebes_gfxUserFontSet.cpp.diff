# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxUserFontSet.cpp
# Commit: 1b1a7d2f27c4
# Full Hash: 1b1a7d2f27c4428fb8a9ff42f0ba361ec0bb56e6
# Author: Cameron McCormack <cam@mcc.id.au>
# Date: 2019-06-07 09:47:19
# Regressor Bug: 1490792
# File Overlap Count: 1
# Description:
#   Bug 1490792 - Part 4: Perform OpenType sanitization OMT. r=jfkthame
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D33897
# ==============================================================================

diff -r f38b9eb31da7 -r 1b1a7d2f27c4 gfx/thebes/gfxUserFontSet.cpp
--- a/gfx/thebes/gfxUserFontSet.cpp	Thu Jun 06 18:23:31 2019 +0000
+++ b/gfx/thebes/gfxUserFontSet.cpp	Thu Jun 06 19:08:52 2019 +0000
@@ -688,6 +688,27 @@
   return LoadPlatformFont(aFontData, aLength, fontType, saneData, saneLen);
 }
 
+void gfxUserFontEntry::StartPlatformFontLoadOnWorkerThread(
+    const uint8_t* aFontData, uint32_t aLength,
+    nsMainThreadPtrHandle<nsIFontLoadCompleteCallback> aCallback) {
+  MOZ_ASSERT(sFontLoadingThread);
+  MOZ_ASSERT(sFontLoadingThread->IsOnCurrentThread());
+
+  uint32_t saneLen;
+  gfxUserFontType fontType;
+  const uint8_t* saneData =
+      SanitizeOpenTypeData(aFontData, aLength, saneLen, fontType);
+
+  nsCOMPtr<nsIRunnable> event =
+      NewRunnableMethod<const uint8_t*, uint32_t, gfxUserFontType,
+                        const uint8_t*, uint32_t,
+                        nsMainThreadPtrHandle<nsIFontLoadCompleteCallback>>(
+          "gfxUserFontEntry::ContinuePlatformFontLoadOnMainThread", this,
+          &gfxUserFontEntry::ContinuePlatformFontLoadOnMainThread, aFontData,
+          aLength, fontType, saneData, saneLen, aCallback);
+  NS_DispatchToMainThread(event.forget());
+}
+
 bool gfxUserFontEntry::LoadPlatformFont(const uint8_t* aOriginalFontData,
                                         uint32_t aOriginalLength,
                                         gfxUserFontType aFontType,
@@ -829,9 +850,11 @@
 // This is called when a font download finishes.
 // Ownership of aFontData passes in here, and the font set must
 // ensure that it is eventually deleted via free().
-bool gfxUserFontEntry::FontDataDownloadComplete(const uint8_t* aFontData,
-                                                uint32_t aLength,
-                                                nsresult aDownloadStatus) {
+void gfxUserFontEntry::FontDataDownloadComplete(
+    const uint8_t* aFontData, uint32_t aLength, nsresult aDownloadStatus,
+    nsIFontLoadCompleteCallback* aCallback) {
+  MOZ_ASSERT(NS_IsMainThread());
+
   // forget about the loader, as we no longer potentially need to cancel it
   // if the entry is obsoleted
   mLoader = nullptr;
@@ -839,27 +862,73 @@
   // download successful, make platform font using font data
   if (NS_SUCCEEDED(aDownloadStatus) &&
       mFontDataLoadingState != LOADING_TIMED_OUT) {
-    bool loaded = LoadPlatformFontSync(aFontData, aLength);
-    aFontData = nullptr;
-
-    if (loaded) {
-      IncrementGeneration();
-      return true;
-    }
+    LoadPlatformFontAsync(aFontData, aLength, aCallback);
+    return;
+  }
 
-  } else {
-    // download failed
-    mFontSet->LogMessage(
-        this,
-        (mFontDataLoadingState != LOADING_TIMED_OUT ? "download failed"
-                                                    : "download timed out"),
-        nsIScriptError::errorFlag, aDownloadStatus);
-  }
+  // download failed
+  mFontSet->LogMessage(
+      this,
+      (mFontDataLoadingState != LOADING_TIMED_OUT ? "download failed"
+                                                  : "download timed out"),
+      nsIScriptError::errorFlag, aDownloadStatus);
 
   if (aFontData) {
     free((void*)aFontData);
   }
 
+  FontLoadFailed(aCallback);
+}
+
+void gfxUserFontEntry::LoadPlatformFontAsync(
+    const uint8_t* aFontData, uint32_t aLength,
+    nsIFontLoadCompleteCallback* aCallback) {
+  // Ensure the font loading thread is available.
+  if (!sFontLoadingThread) {
+    sFontLoadingThread =
+        new LazyIdleThread(5000, NS_LITERAL_CSTRING("FontLoader"));
+  }
+
+  nsMainThreadPtrHandle<nsIFontLoadCompleteCallback> cb(
+      new nsMainThreadPtrHolder<nsIFontLoadCompleteCallback>("FontLoader",
+                                                             aCallback));
+
+  // Do the OpenType sanitization over on the font loading thread.  Once that is
+  // complete, we'll continue in ContinuePlatformFontLoadOnMainThread.
+  nsCOMPtr<nsIRunnable> event =
+      NewRunnableMethod<const uint8_t*, uint32_t,
+                        nsMainThreadPtrHandle<nsIFontLoadCompleteCallback>>(
+          "gfxUserFontEntry::StartPlatformFontLoadOnWorkerThread", this,
+          &gfxUserFontEntry::StartPlatformFontLoadOnWorkerThread, aFontData,
+          aLength, cb);
+  MOZ_ALWAYS_SUCCEEDS(
+      sFontLoadingThread->Dispatch(event.forget(), NS_DISPATCH_NORMAL));
+}
+
+void gfxUserFontEntry::ContinuePlatformFontLoadOnMainThread(
+    const uint8_t* aOriginalFontData, uint32_t aOriginalLength,
+    gfxUserFontType aFontType, const uint8_t* aSanitizedFontData,
+    uint32_t aSanitizedLength,
+    nsMainThreadPtrHandle<nsIFontLoadCompleteCallback> aCallback) {
+  MOZ_ASSERT(NS_IsMainThread());
+
+  bool loaded = LoadPlatformFont(aOriginalFontData, aOriginalLength, aFontType,
+                                 aSanitizedFontData, aSanitizedLength);
+  aOriginalFontData = nullptr;
+  aSanitizedFontData = nullptr;
+
+  if (loaded) {
+    IncrementGeneration();
+    aCallback->FontLoadComplete();
+    return;
+  }
+
+  FontLoadFailed(aCallback);
+}
+
+void gfxUserFontEntry::FontLoadFailed(nsIFontLoadCompleteCallback* aCallback) {
+  MOZ_ASSERT(NS_IsMainThread());
+
   // Error occurred.  Make sure the FontFace's promise is rejected if the
   // load timed out, or else load the next src.
   if (mFontDataLoadingState == LOADING_TIMED_OUT) {
@@ -874,7 +943,7 @@
   // and return true in order to trigger reflow, so that fallback
   // will be used where the text was "masked" by the pending download
   IncrementGeneration();
-  return true;
+  aCallback->FontLoadComplete();
 }
 
 void gfxUserFontEntry::GetUserFontSets(nsTArray<gfxUserFontSet*>& aResult) {
@@ -1295,6 +1364,8 @@
   return NS_OK;
 }
 
+StaticRefPtr<LazyIdleThread> gfxUserFontEntry::sFontLoadingThread;
+
 #ifdef DEBUG_USERFONT_CACHE
 
 void gfxUserFontSet::UserFontCache::Entry::Dump() {