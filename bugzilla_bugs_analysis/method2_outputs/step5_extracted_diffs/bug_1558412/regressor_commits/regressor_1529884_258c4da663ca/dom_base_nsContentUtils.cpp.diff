# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsContentUtils.cpp
# Commit: 258c4da663ca
# Full Hash: 258c4da663ca41039139ef94be6ec7e7f3f2333d
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2019-06-10 21:47:35
# Regressor Bug: 1529884
# File Overlap Count: 2
# Description:
#   Bug 1529884 - part 5: Make Document::ExecCommand() use EditorCommand directly as far as possible r=smaug
#   
#   Most commands are dispatched only when the `document` has `contenteditable` or
#   in `designMode`.  In such case, command context is considered with the following
#   order:
# ==============================================================================

diff -r 7af1b30df51c -r 258c4da663ca dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp	Mon Jun 10 10:25:31 2019 +0000
+++ b/dom/base/nsContentUtils.cpp	Mon Jun 10 10:26:04 2019 +0000
@@ -6802,6 +6802,40 @@
 }
 
 // static
+TextEditor* nsContentUtils::GetActiveEditor(nsPresContext* aPresContext) {
+  if (!aPresContext) {
+    return nullptr;
+  }
+
+  nsPIDOMWindowOuter* window = aPresContext->Document()->GetWindow();
+  if (!window) {
+    return nullptr;
+  }
+
+  // If it's in designMode, nobody can have focus.  Therefore, the HTMLEditor
+  // handles all events.  I.e., it's focused editor in this case.
+  if (aPresContext->Document()->HasFlag(NODE_IS_EDITABLE)) {
+    return GetHTMLEditor(aPresContext);
+  }
+
+  // If focused element is associated with TextEditor, it must be <input>
+  // element or <textarea> element.  Let's return it even if it's in a
+  // contenteditable element.
+  nsCOMPtr<nsPIDOMWindowOuter> focusedWindow;
+  if (Element* focusedElement = nsFocusManager::GetFocusedDescendant(
+          window, nsFocusManager::SearchRange::eOnlyCurrentWindow,
+          getter_AddRefs(focusedWindow))) {
+    if (TextEditor* textEditor = focusedElement->GetTextEditorInternal()) {
+      return textEditor;
+    }
+  }
+
+  // Otherwise, HTMLEditor may handle inputs even non-editable element has
+  // focus or nobody has focus.
+  return GetHTMLEditor(aPresContext);
+}
+
+// static
 bool nsContentUtils::IsForbiddenRequestHeader(const nsACString& aHeader) {
   if (IsForbiddenSystemRequestHeader(aHeader)) {
     return true;