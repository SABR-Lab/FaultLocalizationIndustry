# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/Document.cpp
# Commit: 460df951943a
# Full Hash: 460df951943ac41ec2b94d758b3a4602cbede154
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2019-06-10 21:47:35
# Regressor Bug: 1529884
# File Overlap Count: 1
# Description:
#   Bug 1529884 - part 3: Make Document::ConvertToInternalCommand() check the input value when the caller requires adjusted value r=smaug
#   
#   `aAdjustedValue` of `Document::ConvertToInternalCommand()` is not `nullptr`
#   when it's called by `ExecCommand()` or `QueryCommandState()`.  However,
#   `QueryCommandState()` does not need the value actually.  Therefore, we can move
# ==============================================================================

diff -r f44697e42459 -r 460df951943a dom/base/Document.cpp
--- a/dom/base/Document.cpp	Mon Jun 10 10:24:31 2019 +0000
+++ b/dom/base/Document.cpp	Mon Jun 10 10:24:59 2019 +0000
@@ -4205,10 +4205,10 @@
           for (const nsStaticAtom* kTag : kFormattableBlockTags) {
             if (valueAtom == kTag) {
               kTag->ToString(*aAdjustedValue);
-              break;
+              return commandData;
             }
           }
-          return commandData;
+          return InternalCommandData();
         }
         case Command::FormatFontSize: {
           // Per editing spec as of April 23, 2012, we need to reject the value
@@ -4217,12 +4217,30 @@
           // now, we just parse as a legacy font size regardless (matching
           // WebKit) -- bug 747879.
           int32_t size = nsContentUtils::ParseLegacyFontSize(aValue);
-          if (size) {
-            MOZ_ASSERT(aAdjustedValue->IsEmpty());
-            aAdjustedValue->AppendInt(size);
+          if (!size) {
+            return InternalCommandData();
           }
+          MOZ_ASSERT(aAdjustedValue->IsEmpty());
+          aAdjustedValue->AppendInt(size);
           return commandData;
         }
+        case Command::InsertImage:
+        case Command::InsertLink:
+          if (aValue.IsEmpty()) {
+            // Invalid value, return false
+            return InternalCommandData();
+          }
+          aAdjustedValue->Assign(aValue);
+          return commandData;
+        case Command::SetDocumentDefaultParagraphSeparator:
+          if (!aValue.LowerCaseEqualsLiteral("div") &&
+              !aValue.LowerCaseEqualsLiteral("p") &&
+              !aValue.LowerCaseEqualsLiteral("br")) {
+            // Invalid value
+            return InternalCommandData();
+          }
+          aAdjustedValue->Assign(aValue);
+          return commandData;
         default:
           aAdjustedValue->Assign(aValue);
           return commandData;
@@ -4319,28 +4337,6 @@
     return false;
   }
 
-  switch (commandData.mCommand) {
-    case Command::FormatFontSize:
-    case Command::InsertImage:
-    case Command::InsertLink:
-    case Command::FormatBlock:
-      if (adjustedValue.IsEmpty()) {
-        // Invalid value, return false
-        return false;
-      }
-      break;
-    case Command::SetDocumentDefaultParagraphSeparator:
-      if (!adjustedValue.LowerCaseEqualsLiteral("div") &&
-          !adjustedValue.LowerCaseEqualsLiteral("p") &&
-          !adjustedValue.LowerCaseEqualsLiteral("br")) {
-        // Invalid value
-        return false;
-      }
-      break;
-    default:
-      break;
-  }
-
   // Return false for disabled commands (bug 760052)
   if (!commandManager->IsCommandEnabled(
           nsDependentCString(commandData.mXULCommandName), window)) {
@@ -4495,9 +4491,7 @@
     return false;
   }
 
-  nsAutoString adjustedValue;
-  InternalCommandData commandData =
-      ConvertToInternalCommand(commandID, EmptyString(), &adjustedValue);
+  InternalCommandData commandData = ConvertToInternalCommand(commandID);
   if (commandData.mCommand == Command::DoNothing) {
     return false;
   }
@@ -4540,20 +4534,37 @@
   // return the boolean for this particular alignment rather than the
   // string of 'which alignment is this?'
   switch (commandData.mCommand) {
-    case Command::FormatJustifyLeft:
-    case Command::FormatJustifyRight:
-    case Command::FormatJustifyCenter:
-    case Command::FormatJustifyFull: {
-      if (NS_WARN_IF(adjustedValue.IsEmpty())) {
+    case Command::FormatJustifyLeft: {
+      nsAutoCString currentValue;
+      rv = params->GetCString("state_attribute", currentValue);
+      if (rv.Failed()) {
         return false;
       }
+      return currentValue.EqualsLiteral("left");
+    }
+    case Command::FormatJustifyRight: {
       nsAutoCString currentValue;
       rv = params->GetCString("state_attribute", currentValue);
       if (rv.Failed()) {
         return false;
       }
-      NS_LossyConvertUTF16toASCII asciiValue(adjustedValue);
-      return asciiValue == currentValue;
+      return currentValue.EqualsLiteral("right");
+    }
+    case Command::FormatJustifyCenter: {
+      nsAutoCString currentValue;
+      rv = params->GetCString("state_attribute", currentValue);
+      if (rv.Failed()) {
+        return false;
+      }
+      return currentValue.EqualsLiteral("center");
+    }
+    case Command::FormatJustifyFull: {
+      nsAutoCString currentValue;
+      rv = params->GetCString("state_attribute", currentValue);
+      if (rv.Failed()) {
+        return false;
+      }
+      return currentValue.EqualsLiteral("justify");
     }
     default:
       // If command does not have a state_all value, this call fails and sets