# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/TextEditor.cpp
# Commit: 9ee7acab98a4
# Full Hash: 9ee7acab98a470b2860125ba3deb439a64dc83e7
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2019-06-10 21:47:35
# Regressor Bug: 1529884
# File Overlap Count: 1
# Description:
#   Bug 1529884 - part 6: Through subject principal at Document::ExecCommand() to constructor of EditorBase::AutoEditActionDataSetter r=smaug
#   
#   `Document::ExecCommand()` knows subject principal.  This patch makes it tell
#   `EditorCommand::DoCommand()` and `EditorCommand::DoCommandParam()`.  Then,
#   makes they tell each editor public methods which may cause dispatching
# ==============================================================================

diff -r 258c4da663ca -r 9ee7acab98a4 editor/libeditor/TextEditor.cpp
--- a/editor/libeditor/TextEditor.cpp	Mon Jun 10 10:26:04 2019 +0000
+++ b/editor/libeditor/TextEditor.cpp	Mon Jun 10 10:27:07 2019 +0000
@@ -43,6 +43,7 @@
 #include "nsIContent.h"
 #include "nsIDocumentEncoder.h"
 #include "nsINode.h"
+#include "nsIPrincipal.h"
 #include "nsISelectionController.h"
 #include "nsISupportsPrimitives.h"
 #include "nsITransferable.h"
@@ -346,7 +347,7 @@
     case NS_VK_ALT:
       // These keys are handled on EditorBase
       return EditorBase::HandleKeyPressEvent(aKeyboardEvent);
-    case NS_VK_BACK:
+    case NS_VK_BACK: {
       if (aKeyboardEvent->IsControl() || aKeyboardEvent->IsAlt() ||
           aKeyboardEvent->IsMeta() || aKeyboardEvent->IsOS()) {
         return NS_OK;
@@ -354,7 +355,8 @@
       DeleteSelectionAsAction(nsIEditor::ePrevious, nsIEditor::eStrip);
       aKeyboardEvent->PreventDefault();  // consumed
       return NS_OK;
-    case NS_VK_DELETE:
+    }
+    case NS_VK_DELETE: {
       // on certain platforms (such as windows) the shift key
       // modifies what delete does (cmd_cut in this case).
       // bailing here to allow the keybindings to do the cut.
@@ -366,6 +368,7 @@
       DeleteSelectionAsAction(nsIEditor::eNext, nsIEditor::eStrip);
       aKeyboardEvent->PreventDefault();  // consumed
       return NS_OK;
+    }
     case NS_VK_TAB: {
       if (IsTabbable()) {
         return NS_OK;  // let it be used for focus switching
@@ -414,8 +417,9 @@
   return NS_OK;
 }
 
-nsresult TextEditor::InsertLineBreakAsAction() {
-  AutoEditActionDataSetter editActionData(*this, EditAction::eInsertLineBreak);
+nsresult TextEditor::InsertLineBreakAsAction(nsIPrincipal* aPrincipal) {
+  AutoEditActionDataSetter editActionData(*this, EditAction::eInsertLineBreak,
+                                          aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -629,14 +633,13 @@
 NS_IMETHODIMP
 TextEditor::DeleteSelection(EDirection aAction, EStripWrappers aStripWrappers) {
   nsresult rv = DeleteSelectionAsAction(aAction, aStripWrappers);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-  return NS_OK;
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "Failed to do delete selection");
+  return rv;
 }
 
 nsresult TextEditor::DeleteSelectionAsAction(EDirection aDirection,
-                                             EStripWrappers aStripWrappers) {
+                                             EStripWrappers aStripWrappers,
+                                             nsIPrincipal* aPrincipal) {
   MOZ_ASSERT(aStripWrappers == eStrip || aStripWrappers == eNoStrip);
   // Showing this assertion is fine if this method is called by outside via
   // mutation event listener or something.  Otherwise, this is called by
@@ -668,7 +671,7 @@
       break;
   }
 
-  AutoEditActionDataSetter editActionData(*this, editAction);
+  AutoEditActionDataSetter editActionData(*this, editAction, aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -960,13 +963,12 @@
 NS_IMETHODIMP
 TextEditor::InsertText(const nsAString& aStringToInsert) {
   nsresult rv = InsertTextAsAction(aStringToInsert);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-  return NS_OK;
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "Failed to insert text");
+  return rv;
 }
 
-nsresult TextEditor::InsertTextAsAction(const nsAString& aStringToInsert) {
+nsresult TextEditor::InsertTextAsAction(const nsAString& aStringToInsert,
+                                        nsIPrincipal* aPrincipal) {
   // Showing this assertion is fine if this method is called by outside via
   // mutation event listener or something.  Otherwise, this is called by
   // wrong method.
@@ -975,7 +977,8 @@
                "operation "
                "unless mutation event listener nests some operations");
 
-  AutoEditActionDataSetter editActionData(*this, EditAction::eInsertText);
+  AutoEditActionDataSetter editActionData(*this, EditAction::eInsertText,
+                                          aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1088,10 +1091,12 @@
   return NS_OK;
 }
 
-nsresult TextEditor::SetText(const nsAString& aString) {
+nsresult TextEditor::SetTextAsAction(const nsAString& aString,
+                                     nsIPrincipal* aPrincipal) {
   MOZ_ASSERT(aString.FindChar(static_cast<char16_t>('\r')) == kNotFound);
 
-  AutoEditActionDataSetter editActionData(*this, EditAction::eSetText);
+  AutoEditActionDataSetter editActionData(*this, EditAction::eSetText,
+                                          aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1104,9 +1109,11 @@
   return NS_OK;
 }
 
-nsresult TextEditor::ReplaceTextAsAction(
-    const nsAString& aString, nsRange* aReplaceRange /* = nullptr */) {
-  AutoEditActionDataSetter editActionData(*this, EditAction::eReplaceText);
+nsresult TextEditor::ReplaceTextAsAction(const nsAString& aString,
+                                         nsRange* aReplaceRange,
+                                         nsIPrincipal* aPrincipal) {
+  AutoEditActionDataSetter editActionData(*this, EditAction::eReplaceText,
+                                          aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1605,8 +1612,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
-TextEditor::Undo(uint32_t aCount) {
+nsresult TextEditor::UndoAsAction(uint32_t aCount, nsIPrincipal* aPrincipal) {
   // If we don't have transaction in the undo stack, we shouldn't notify
   // anybody of trying to undo since it's not useful notification but we
   // need to pay some runtime cost.
@@ -1622,7 +1628,7 @@
     return NS_OK;
   }
 
-  AutoEditActionDataSetter editActionData(*this, EditAction::eUndo);
+  AutoEditActionDataSetter editActionData(*this, EditAction::eUndo, aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1667,8 +1673,7 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP
-TextEditor::Redo(uint32_t aCount) {
+nsresult TextEditor::RedoAsAction(uint32_t aCount, nsIPrincipal* aPrincipal) {
   // If we don't have transaction in the redo stack, we shouldn't notify
   // anybody of trying to redo since it's not useful notification but we
   // need to pay some runtime cost.
@@ -1684,7 +1689,7 @@
     return NS_OK;
   }
 
-  AutoEditActionDataSetter editActionData(*this, EditAction::eRedo);
+  AutoEditActionDataSetter editActionData(*this, EditAction::eRedo, aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1765,9 +1770,8 @@
   return !mDidPreDestroy;
 }
 
-NS_IMETHODIMP
-TextEditor::Cut() {
-  AutoEditActionDataSetter editActionData(*this, EditAction::eCut);
+nsresult TextEditor::CutAsAction(nsIPrincipal* aPrincipal) {
+  AutoEditActionDataSetter editActionData(*this, EditAction::eCut, aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }
@@ -1966,11 +1970,13 @@
 }
 
 nsresult TextEditor::PasteAsQuotationAsAction(int32_t aClipboardType,
-                                              bool aDispatchPasteEvent) {
+                                              bool aDispatchPasteEvent,
+                                              nsIPrincipal* aPrincipal) {
   MOZ_ASSERT(aClipboardType == nsIClipboard::kGlobalClipboard ||
              aClipboardType == nsIClipboard::kSelectionClipboard);
 
-  AutoEditActionDataSetter editActionData(*this, EditAction::ePasteAsQuotation);
+  AutoEditActionDataSetter editActionData(*this, EditAction::ePasteAsQuotation,
+                                          aPrincipal);
   if (NS_WARN_IF(!editActionData.CanHandle())) {
     return NS_ERROR_NOT_INITIALIZED;
   }