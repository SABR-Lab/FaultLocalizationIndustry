# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/display_list_flattener.rs
# Commit: 11f0e1ee8f0c
# Full Hash: 11f0e1ee8f0c9ec82c81ed842fc68402429d4441
# Author: Glenn Watson <github@intuitionlibrary.com>
# Date: 2019-06-19 15:50:11
# Description:
#   Bug 1559535 - Fix crash related to mismatched clips with picture caching. r=kvark
#   
#   Fixes an edge case where splitting the top level primitive list
#   for picture caching may result in a mismatched push/pop clip
#   pair.
# ==============================================================================

diff -r b9243653712d -r 11f0e1ee8f0c gfx/wr/webrender/src/display_list_flattener.rs
--- a/gfx/wr/webrender/src/display_list_flattener.rs	Wed Jun 19 12:08:45 2019 +0300
+++ b/gfx/wr/webrender/src/display_list_flattener.rs	Wed Jun 19 08:40:27 2019 +0000
@@ -413,11 +413,68 @@
         let mut first_index = None;
         let mut main_scroll_root = None;
 
+        // If the main primitive list that we split for picture caching has
+        // clip chain instances at the top level, it's possible that we will
+        // create a split resulting in one list having unmatched PushClipChain
+        // or PopClipChain instances. This causes panics in pop_surface(),
+        // which asserts that the clip chain instances are matched.
+
+        // The code below is a (very inelegant) solution to that. It records
+        // clip chain instances found during the initial scan for scroll roots.
+        // Later, it uses this information to fix up unopened or unclosed clip
+        // instances on the split primitive lists.
+
+        // This is far from ideal - but it fixes the crash for now. In future
+        // we will be simplifying and/or removing how clip chain instances
+        // and picture cache splitting works, so we can tidy this up as
+        // part of those future changes.
+
+        let mut clip_chain_instances = Vec::new();
+        let mut clip_chain_instance_stack = Vec::new();
+
+        /// Records the indices in the list of a push/pop clip chain instance pair.
+        #[derive(Debug)]
+        struct ClipChainPairInfo {
+            push_index: usize,
+            pop_index: usize,
+            spatial_node_index: SpatialNodeIndex,
+            clip_chain_id: ClipChainId,
+        }
+
         for (i, instance) in primitives.iter().enumerate() {
             let scroll_root = self.clip_scroll_tree.find_scroll_root(
                 instance.spatial_node_index,
             );
 
+            // If we encounter a push/pop clip, record where they occurred in the
+            // primitive list for later processing.
+            match instance.kind {
+                PrimitiveInstanceKind::PushClipChain => {
+                    clip_chain_instance_stack.push(clip_chain_instances.len());
+                    clip_chain_instances.push(ClipChainPairInfo {
+                        push_index: i,
+                        pop_index: usize::MAX,
+                        spatial_node_index: instance.spatial_node_index,
+                        clip_chain_id: instance.clip_chain_id,
+                    });
+                }
+                PrimitiveInstanceKind::PopClipChain => {
+                    let index = clip_chain_instance_stack.pop().unwrap();
+                    let clip_chain_instance = &mut clip_chain_instances[index];
+                    debug_assert_eq!(clip_chain_instance.pop_index, usize::MAX);
+                    debug_assert_eq!(
+                        clip_chain_instance.clip_chain_id,
+                        instance.clip_chain_id,
+                    );
+                    debug_assert_eq!(
+                        clip_chain_instance.spatial_node_index,
+                        instance.spatial_node_index,
+                    );
+                    clip_chain_instance.pop_index = i;
+                }
+                _ => {}
+            }
+
             if scroll_root != ROOT_SPATIAL_NODE_INDEX {
                 // If we find multiple scroll roots in this page, then skip
                 // picture caching for now. In future, we can handle picture
@@ -454,9 +511,9 @@
         // this case specially to avoid underflow error in the Some(..)
         // path below.
 
-        let preceding_prims;
+        let mut preceding_prims;
         let mut remaining_prims;
-        let trailing_prims;
+        let mut trailing_prims;
 
         match first_index {
             Some(first_index) => {
@@ -482,6 +539,136 @@
             }
         }
 
+        let mid_index = preceding_prims.len();
+        let post_index = mid_index + remaining_prims.len();
+
+        #[derive(Debug, Copy, Clone)]
+        enum ClipLocation {
+            Pre,        // The prims preceding the picture cache content slice.
+            Mid,        // Prims in the content / cache slice.
+            Post,       // Prims trailing the cache slice.
+        }
+
+        // Step through each clip chain pair, and see if it crosses a slice boundary.
+        for clip_chain_instance in clip_chain_instances {
+            // Get the location of the push / pop for this clip chain.
+            let push_location = if clip_chain_instance.push_index < mid_index {
+                ClipLocation::Pre
+            } else if clip_chain_instance.push_index < post_index {
+                ClipLocation::Mid
+            } else {
+                ClipLocation::Post
+            };
+
+            let pop_location = if clip_chain_instance.pop_index < mid_index {
+                ClipLocation::Pre
+            } else if clip_chain_instance.pop_index < post_index {
+                ClipLocation::Mid
+            } else {
+                ClipLocation::Post
+            };
+
+            // Apply fixups for any clip chain instances as required. Although this
+            // code can result in memcpys, it's unlikely to be a problem. The case
+            // itself where this occurs is rare, and the prim lists are typically
+            // quite short here. Nonetheless, we'll want to improve this as part
+            // of the changes to clip chain instances + picture cache slice splitting.
+            match (push_location, pop_location) {
+                (ClipLocation::Pre, ClipLocation::Pre) |
+                (ClipLocation::Mid, ClipLocation::Mid) |
+                (ClipLocation::Post, ClipLocation::Post) => {
+                    // If the clip exists within a slice, no fixup needed. This is the
+                    // common case for clip chain instances at the top level.
+                    continue;
+                }
+                (ClipLocation::Pre, ClipLocation::Post) => {
+                    // Close off the pre list, enclose the cache slice and
+                    // open a clip chain for the trailing prims.
+
+                    preceding_prims.push(
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PopClipChain,
+                        )
+                    );
+
+                    remaining_prims.insert(
+                        0,
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PushClipChain,
+                        )
+                    );
+
+                    remaining_prims.push(
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PopClipChain,
+                        )
+                    );
+
+                    trailing_prims.insert(
+                        0,
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PushClipChain,
+                        )
+                    );
+                }
+                (ClipLocation::Pre, ClipLocation::Mid) => {
+                    // Close off the preceding prims, and open a clip for the
+                    // content cache slice.
+
+                    preceding_prims.push(
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PopClipChain,
+                        )
+                    );
+
+                    remaining_prims.insert(
+                        0,
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PushClipChain,
+                        )
+                    );
+                }
+                (ClipLocation::Mid, ClipLocation::Post) => {
+                    // Close off the cache content slice, and open up a clip for
+                    // the trailing prims.
+
+                    remaining_prims.push(
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PopClipChain,
+                        )
+                    );
+
+                    trailing_prims.insert(
+                        0,
+                        create_clip_prim_instance(
+                            clip_chain_instance.spatial_node_index,
+                            clip_chain_instance.clip_chain_id,
+                            PrimitiveInstanceKind::PushClipChain,
+                        )
+                    );
+                }
+                (ClipLocation::Mid, ClipLocation::Pre) |
+                (ClipLocation::Post, ClipLocation::Pre) |
+                (ClipLocation::Post, ClipLocation::Mid) => {
+                    unreachable!();
+                }
+            }
+        }
+
         let prim_list = PrimitiveList::new(
             remaining_prims,
             &self.interners,
