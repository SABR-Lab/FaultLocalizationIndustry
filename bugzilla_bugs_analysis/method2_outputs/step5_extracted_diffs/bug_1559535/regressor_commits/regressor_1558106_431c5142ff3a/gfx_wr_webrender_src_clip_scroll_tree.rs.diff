# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/clip_scroll_tree.rs
# Commit: 431c5142ff3a
# Full Hash: 431c5142ff3ad102328d90cb29470b20ccd1271e
# Author: Glenn Watson <github@intuitionlibrary.com>
# Date: 2019-06-13 21:50:57
# Regressor Bug: 1558106
# File Overlap Count: 1
# Description:
#   Bug 1558106 - Support picture caching for multiple scroll roots. r=kvark
#   
#   This patch implements the majority of the planned picture caching
#   improvements. It supports most of the functionality required to
#   (as a follow up) support OS compositor integration. It also improves
# ==============================================================================

diff -r 855d557b82a2 -r 431c5142ff3a gfx/wr/webrender/src/clip_scroll_tree.rs
--- a/gfx/wr/webrender/src/clip_scroll_tree.rs	Wed Jun 12 16:18:22 2019 +0000
+++ b/gfx/wr/webrender/src/clip_scroll_tree.rs	Thu Jun 13 04:43:56 2019 +0000
@@ -5,7 +5,7 @@
 use api::{ExternalScrollId, PropertyBinding, ReferenceFrameKind, TransformStyle};
 use api::{PipelineId, ScrollClamping, ScrollNodeState, ScrollLocation, ScrollSensitivity};
 use api::units::*;
-use euclid::{TypedPoint2D, TypedScale, TypedTransform3D};
+use euclid::TypedTransform3D;
 use crate::gpu_types::TransformPalette;
 use crate::internal_types::{FastHashMap, FastHashSet};
 use crate::print_tree::{PrintableTree, PrintTree, PrintTreePrinter};
@@ -184,30 +184,6 @@
         }
     }
 
-    pub fn project_2d_origin(&self) -> Option<TypedPoint2D<f32, Dst>> {
-        match *self {
-            CoordinateSpaceMapping::Local => Some(TypedPoint2D::zero()),
-            CoordinateSpaceMapping::ScaleOffset(ref scale_offset) => Some(
-                scale_offset.offset.to_point() * TypedScale::new(1.0)
-            ),
-            CoordinateSpaceMapping::Transform(ref transform) => {
-                transform.transform_point2d(&TypedPoint2D::zero())
-            }
-        }
-    }
-
-    pub fn inverse_project_2d_origin(&self) -> Option<TypedPoint2D<f32, Src>> {
-        match *self {
-            CoordinateSpaceMapping::Local => Some(TypedPoint2D::zero()),
-            CoordinateSpaceMapping::ScaleOffset(ref scale_offset) => Some(
-                scale_offset.inverse().offset.to_point() * TypedScale::new(1.0)
-            ),
-            CoordinateSpaceMapping::Transform(ref transform) => {
-                transform.inverse_project_2d_origin()
-            }
-        }
-    }
-
     pub fn scale_factors(&self) -> (f32, f32) {
         match *self {
             CoordinateSpaceMapping::Local => (1.0, 1.0),
@@ -367,28 +343,6 @@
         self.get_world_transform_impl(index, TransformScroll::Unscrolled)
     }
 
-
-    /// Returns true if the spatial node is the same as the parent, or is
-    /// a child of the parent.
-    pub fn is_same_or_child_of(
-        &self,
-        spatial_node_index: SpatialNodeIndex,
-        parent_spatial_node_index: SpatialNodeIndex,
-    ) -> bool {
-        let mut index = spatial_node_index;
-
-        loop {
-            if index == parent_spatial_node_index {
-                return true;
-            }
-
-            index = match self.spatial_nodes[index.0 as usize].parent {
-                Some(parent) => parent,
-                None => return false,
-            }
-        }
-    }
-
     /// The root reference frame, which is the true root of the ClipScrollTree. Initially
     /// this ID is not valid, which is indicated by ```spatial_nodes``` being empty.
     pub fn root_reference_frame_index(&self) -> SpatialNodeIndex {
@@ -632,6 +586,37 @@
         self.pipelines_to_discard.insert(pipeline_id);
     }
 
+    /// Find the spatial node that is the scroll root for a given spatial node.
+    /// A scroll root is the first spatial node when found travelling up the
+    /// spatial node tree that is an explicit scroll frame.
+    pub fn find_scroll_root(
+        &self,
+        spatial_node_index: SpatialNodeIndex,
+    ) -> SpatialNodeIndex {
+        let mut scroll_root = ROOT_SPATIAL_NODE_INDEX;
+        let mut node_index = spatial_node_index;
+
+        while node_index != ROOT_SPATIAL_NODE_INDEX {
+            let node = &self.spatial_nodes[node_index.0 as usize];
+            match node.node_type {
+                SpatialNodeType::ReferenceFrame(..) |
+                SpatialNodeType::StickyFrame(..) => {
+                    // TODO(gw): In future, we may need to consider sticky frames.
+                }
+                SpatialNodeType::ScrollFrame(ref info) => {
+                    // If we found an explicit scroll root, store that
+                    // and keep looking up the tree.
+                    if let ScrollFrameKind::Explicit = info.frame_kind {
+                        scroll_root = node_index;
+                    }
+                }
+            }
+            node_index = node.parent.expect("unable to find parent node");
+        }
+
+        scroll_root
+    }
+
     fn print_node<T: PrintTreePrinter>(
         &self,
         index: SpatialNodeIndex,
@@ -649,6 +634,7 @@
                 pt.add_item(format!("scrollable_size: {:?}", scrolling_info.scrollable_size));
                 pt.add_item(format!("scroll offset: {:?}", scrolling_info.offset));
                 pt.add_item(format!("external_scroll_offset: {:?}", scrolling_info.external_scroll_offset));
+                pt.add_item(format!("kind: {:?}", scrolling_info.frame_kind));
             }
             SpatialNodeType::ReferenceFrame(ref info) => {
                 pt.new_level(format!("ReferenceFrame"));