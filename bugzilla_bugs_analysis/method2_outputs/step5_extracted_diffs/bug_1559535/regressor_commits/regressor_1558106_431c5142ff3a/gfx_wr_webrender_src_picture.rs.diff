# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/picture.rs
# Commit: 431c5142ff3a
# Full Hash: 431c5142ff3ad102328d90cb29470b20ccd1271e
# Author: Glenn Watson <github@intuitionlibrary.com>
# Date: 2019-06-13 21:50:57
# Regressor Bug: 1558106
# File Overlap Count: 1
# Description:
#   Bug 1558106 - Support picture caching for multiple scroll roots. r=kvark
#   
#   This patch implements the majority of the planned picture caching
#   improvements. It supports most of the functionality required to
#   (as a follow up) support OS compositor integration. It also improves
# ==============================================================================

diff -r 855d557b82a2 -r 431c5142ff3a gfx/wr/webrender/src/picture.rs
--- a/gfx/wr/webrender/src/picture.rs	Wed Jun 12 16:18:22 2019 +0000
+++ b/gfx/wr/webrender/src/picture.rs	Thu Jun 13 04:43:56 2019 +0000
@@ -4,15 +4,15 @@
 
 use api::{MixBlendMode, PipelineId, PremultipliedColorF};
 use api::{PropertyBinding, PropertyBindingId};
-use api::{DebugFlags, RasterSpace, ColorF, ImageKey, ClipMode};
+use api::{DebugFlags, RasterSpace, ImageKey, ColorF};
 use api::units::*;
 use crate::box_shadow::{BLUR_SAMPLE_SCALE};
-use crate::clip::{ClipChainId, ClipChainNode, ClipItem, ClipStore, ClipDataStore, ClipChainStack};
+use crate::clip::{ClipStore, ClipDataStore, ClipChainInstance};
 use crate::clip_scroll_tree::{ROOT_SPATIAL_NODE_INDEX,
-    ClipScrollTree, CoordinateSystemId, CoordinateSpaceMapping, SpatialNodeIndex, VisibleFace
+    ClipScrollTree, CoordinateSpaceMapping, SpatialNodeIndex, VisibleFace, CoordinateSystemId
 };
 use crate::debug_colors;
-use euclid::{size2, vec3, TypedPoint2D, TypedScale, TypedSize2D, Vector2D};
+use euclid::{vec3, TypedPoint2D, TypedScale, TypedSize2D, Vector2D, TypedRect};
 use euclid::approxeq::ApproxEq;
 use crate::frame_builder::{FrameVisibilityContext, FrameVisibilityState};
 use crate::intern::ItemUid;
@@ -21,17 +21,18 @@
 use crate::gpu_cache::{GpuCache, GpuCacheAddress, GpuCacheHandle};
 use crate::gpu_types::UvRectKind;
 use plane_split::{Clipper, Polygon, Splitter};
-use crate::prim_store::SpaceMapper;
+use crate::prim_store::{SpaceMapper, PrimitiveVisibilityMask, PointKey, PrimitiveTemplateKind};
 use crate::prim_store::{PictureIndex, PrimitiveInstance, PrimitiveInstanceKind};
-use crate::prim_store::{get_raster_rects, PrimitiveScratchBuffer, VectorKey, PointKey};
-use crate::prim_store::{OpacityBindingStorage, ImageInstanceStorage, OpacityBindingIndex, RectangleKey};
+use crate::prim_store::{get_raster_rects, PrimitiveScratchBuffer, RectangleKey};
+use crate::prim_store::{OpacityBindingStorage, ImageInstanceStorage, OpacityBindingIndex};
 use crate::print_tree::PrintTreePrinter;
 use crate::render_backend::DataStores;
-use crate::render_task::{ClearMode, RenderTask, TileBlit};
+use crate::render_task::{ClearMode, RenderTask};
 use crate::render_task::{RenderTaskId, RenderTaskLocation, BlurTaskCache};
 use crate::resource_cache::ResourceCache;
 use crate::scene::SceneProperties;
 use crate::scene_builder::Interners;
+use crate::spatial_node::SpatialNodeType;
 use smallvec::SmallVec;
 use std::{mem, u16};
 use std::sync::atomic::{AtomicUsize, Ordering};
@@ -50,6 +51,58 @@
    this picture (e.g. in screen space or local space).
  */
 
+/// Specify whether a surface allows subpixel AA text rendering.
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub enum SubpixelMode {
+    /// This surface allows subpixel AA text
+    Allow,
+    /// Subpixel AA text cannot be drawn on this surface
+    Deny,
+}
+
+/// A comparable / hashable version of a coordinate space mapping. Used to determine
+/// if a transform dependency for a tile has changed.
+#[derive(Debug, PartialEq, Clone)]
+enum TransformKey {
+    Local,
+    ScaleOffset {
+        scale_x: f32,
+        scale_y: f32,
+        offset_x: f32,
+        offset_y: f32,
+    },
+    Transform {
+        m: [f32; 16],
+    }
+}
+
+impl<Src, Dst> From<CoordinateSpaceMapping<Src, Dst>> for TransformKey {
+    fn from(transform: CoordinateSpaceMapping<Src, Dst>) -> TransformKey {
+        match transform {
+            CoordinateSpaceMapping::Local => {
+                TransformKey::Local
+            }
+            CoordinateSpaceMapping::ScaleOffset(ref scale_offset) => {
+                // TODO(gw): We should consider quantizing / rounding these values
+                //           to avoid invalidations due to floating point inaccuracies.
+                TransformKey::ScaleOffset {
+                    scale_x: scale_offset.scale.x,
+                    scale_y: scale_offset.scale.y,
+                    offset_x: scale_offset.offset.x,
+                    offset_y: scale_offset.offset.y,
+                }
+            }
+            CoordinateSpaceMapping::Transform(ref m) => {
+                // TODO(gw): We should consider quantizing / rounding these values
+                //           to avoid invalidations due to floating point inaccuracies.
+                TransformKey::Transform {
+                    m: m.to_row_major_array(),
+                }
+            }
+        }
+    }
+}
+
 /// Information about a picture that is pushed / popped on the
 /// PictureUpdateState during picture traversal pass.
 struct PictureInfo {
@@ -63,18 +116,13 @@
 pub struct RetainedTiles {
     /// The tiles retained between display lists.
     #[cfg_attr(feature = "capture", serde(skip))] //TODO
-    pub tiles: Vec<Tile>,
-    /// List of reference primitives that we will compare
-    /// to try and correlate the positioning of items
-    /// between display lists.
-    pub ref_prims: FastHashMap<ItemUid, WorldPoint>,
+    pub tiles: FastHashMap<TileKey, Tile>,
 }
 
 impl RetainedTiles {
     pub fn new() -> Self {
         RetainedTiles {
-            tiles: Vec::new(),
-            ref_prims: FastHashMap::default(),
+            tiles: FastHashMap::default(),
         }
     }
 
@@ -82,7 +130,6 @@
     pub fn merge(&mut self, other: RetainedTiles) {
         assert!(self.tiles.is_empty() || other.tiles.is_empty());
         self.tiles.extend(other.tiles);
-        self.ref_prims.extend(other.ref_prims);
     }
 }
 
@@ -93,7 +140,7 @@
 // Geometry types for tile coordinates.
 pub type TileOffset = TypedPoint2D<i32, TileCoordinate>;
 pub type TileSize = TypedSize2D<i32, TileCoordinate>;
-pub struct TileIndex(pub usize);
+pub type TileRect = TypedRect<i32, TileCoordinate>;
 
 /// The size in device pixels of a cached tile. The currently chosen
 /// size is arbitrary. We should do some profiling to find the best
@@ -102,22 +149,13 @@
 /// Note that we use a separate, smaller size during wrench testing, so that
 /// we get tighter dirty rects and can do more meaningful invalidation
 /// tests.
-const TILE_SIZE_WIDTH: i32 = 1024;
-const TILE_SIZE_HEIGHT: i32 = 256;
-const TILE_SIZE_TESTING: i32 = 64;
-
-const FRAMES_BEFORE_PICTURE_CACHING: usize = 2;
-const MAX_DIRTY_RECTS: usize = 3;
+pub const TILE_SIZE_WIDTH: i32 = 1024;
+pub const TILE_SIZE_HEIGHT: i32 = 512;
 
 /// The maximum size per axis of a surface,
 ///  in WorldPixel coordinates.
 const MAX_SURFACE_SIZE: f32 = 4096.0;
 
-
-/// The maximum number of primitives to look for in a display
-/// list, trying to find unique primitives.
-const MAX_PRIMS_TO_SEARCH: usize = 128;
-
 /// Used to get unique tile IDs, even when the tile cache is
 /// destroyed between display lists / scenes.
 static NEXT_TILE_ID: AtomicUsize = AtomicUsize::new(0);
@@ -126,6 +164,10 @@
     value.max(low).min(high)
 }
 
+fn clampf(value: f32, low: f32, high: f32) -> f32 {
+    value.max(low).min(high)
+}
+
 /// Information about the state of an opacity binding.
 #[derive(Debug)]
 pub struct OpacityBindingInfo {
@@ -153,48 +195,48 @@
 
 /// A stable ID for a given tile, to help debugging.
 #[derive(Debug, Copy, Clone, PartialEq)]
-struct TileId(usize);
+pub struct TileId(usize);
+
+#[derive(Debug, Copy, Clone, PartialEq, Hash, Eq)]
+pub struct TileKey {
+    /// The picture cache slice that this belongs to.
+    slice: usize,
+    /// Offset (in tile coords) of the tile within this slice.
+    offset: TileOffset,
+}
 
 /// Information about a cached tile.
 #[derive(Debug)]
 pub struct Tile {
-    /// The current world rect of thie tile.
-    world_rect: WorldRect,
+    /// The current world rect of this tile.
+    pub world_rect: WorldRect,
     /// The current local rect of this tile.
-    pub local_rect: LayoutRect,
-    /// The currently visible rect within this tile, updated per frame.
-    /// If None, this tile is not currently visible.
-    visible_rect: Option<WorldRect>,
-    /// The currently valid rect of the tile, used to invalidate
-    /// tiles that were only partially drawn.
-    valid_rect: WorldRect,
+    pub rect: PictureRect,
+    /// The local rect of the tile clipped to the overal picture local rect.
+    clipped_rect: PictureRect,
     /// Uniquely describes the content of this tile, in a way that can be
     /// (reasonably) efficiently hashed and compared.
-    descriptor: TileDescriptor,
+    pub descriptor: TileDescriptor,
     /// Handle to the cached texture for this tile.
     pub handle: TextureCacheHandle,
     /// If true, this tile is marked valid, and the existing texture
     /// cache handle can be used. Tiles are invalidated during the
     /// build_dirty_regions method.
-    is_valid: bool,
+    pub is_valid: bool,
     /// If true, the content on this tile is the same as last frame.
     is_same_content: bool,
-    /// The number of frames this tile has had the same content.
-    same_frames: usize,
     /// The tile id is stable between display lists and / or frames,
     /// if the tile is retained. Useful for debugging tile evictions.
-    id: TileId,
+    pub id: TileId,
     /// The set of transforms that affect primitives on this tile we
     /// care about. Stored as a set here, and then collected, sorted
     /// and converted to transform key values during post_update.
     transforms: FastHashSet<SpatialNodeIndex>,
-    /// A list of potentially important clips. We can't know if
-    /// they were important or can be discarded until we know the
-    /// tile cache bounding rect.
-    potential_clips: FastHashMap<RectangleKey, SpatialNodeIndex>,
-    /// If true, this tile should still be considered as part of
-    /// the dirty rect calculations.
-    consider_for_dirty_rect: bool,
+    /// Bitfield specifying the dirty region(s) that are relevant to this tile.
+    visibility_mask: PrimitiveVisibilityMask,
+    /// If true, the tile was determined to be opaque, which means blending
+    /// can be disabled when drawing it.
+    pub is_opaque: bool,
 }
 
 impl Tile {
@@ -203,19 +245,17 @@
         id: TileId,
     ) -> Self {
         Tile {
-            local_rect: LayoutRect::zero(),
+            rect: PictureRect::zero(),
+            clipped_rect: PictureRect::zero(),
             world_rect: WorldRect::zero(),
-            visible_rect: None,
-            valid_rect: WorldRect::zero(),
             handle: TextureCacheHandle::invalid(),
             descriptor: TileDescriptor::new(),
             is_same_content: false,
             is_valid: false,
-            same_frames: 0,
             transforms: FastHashSet::default(),
-            potential_clips: FastHashMap::default(),
             id,
-            consider_for_dirty_rect: false,
+            visibility_mask: PrimitiveVisibilityMask::empty(),
+            is_opaque: false,
         }
     }
 
@@ -223,34 +263,18 @@
     fn clear(&mut self) {
         self.transforms.clear();
         self.descriptor.clear();
-        self.potential_clips.clear();
     }
 
     /// Invalidate a tile based on change in content. This
-    /// muct be called even if the tile is not currently
+    /// must be called even if the tile is not currently
     /// visible on screen. We might be able to improve this
     /// later by changing how ComparableVec is used.
     fn update_content_validity(&mut self) {
         // Check if the contents of the primitives, clips, and
         // other dependencies are the same.
-        self.is_same_content &= self.descriptor.is_same_content();
+        self.is_same_content &= self.descriptor.is_same_content(self.id);
         self.is_valid &= self.is_same_content;
     }
-
-    /// Update state related to whether a tile has a valid rect that
-    /// covers the required visible part of the tile.
-    fn update_rect_validity(&mut self, tile_bounding_rect: &WorldRect) {
-        // The tile is only valid if:
-        // - The content is the same *and*
-        // - The valid part of the tile includes the needed part.
-        self.is_valid &= self.valid_rect.contains_rect(tile_bounding_rect);
-
-        // Update count of how many times this tile has had the same content.
-        if !self.is_same_content {
-            self.same_frames = 0;
-        }
-        self.same_frames += 1;
-    }
 }
 
 /// Defines a key that uniquely identifies a primitive instance.
@@ -259,13 +283,15 @@
     /// Uniquely identifies the content of the primitive template.
     prim_uid: ItemUid,
     /// The origin in world space of this primitive.
-    origin: WorldPoint,
+    origin: PointKey,
+    /// The clip rect for this primitive. Included here in
+    /// dependencies since there is no entry in the clip chain
+    /// dependencies for the local clip rect.
+    prim_clip_rect: RectangleKey,
     /// The first clip in the clip_uids array of clips that affect this tile.
     first_clip: u16,
     /// The number of clips that affect this primitive instance.
     clip_count: u16,
-    /// The combined local clips + prim rect for this primitive.
-    world_culling_rect: WorldRect,
 }
 
 /// Uniquely describes the content of this tile, in a way that can be
@@ -275,7 +301,7 @@
     /// List of primitive instance unique identifiers. The uid is guaranteed
     /// to uniquely describe the content of the primitive template, while
     /// the other parameters describe the clip chain and instance params.
-    prims: ComparableVec<PrimitiveDescriptor>,
+    pub prims: ComparableVec<PrimitiveDescriptor>,
 
     /// List of clip node unique identifiers. The uid is guaranteed
     /// to uniquely describe the content of the clip node.
@@ -295,7 +321,7 @@
 
     /// List of the effects of transforms that we care about
     /// tracking for this tile.
-    transforms: ComparableVec<PointKey>,
+    transforms: ComparableVec<TransformKey>,
 }
 
 impl TileDescriptor {
@@ -324,7 +350,7 @@
     /// Return true if the content of the tile is the same
     /// as last frame. This doesn't check validity of the
     /// tile based on the currently valid regions.
-    fn is_same_content(&self) -> bool {
+    fn is_same_content(&self, _id: TileId) -> bool {
         if !self.image_keys.is_valid() {
             return false;
         }
@@ -351,7 +377,10 @@
 /// Stores both the world and devices rects for a single dirty rect.
 #[derive(Debug, Clone)]
 pub struct DirtyRegionRect {
+    /// World rect of this dirty region
     pub world_rect: WorldRect,
+    /// Bitfield for picture render tasks that draw this dirty region.
+    pub visibility_mask: PrimitiveVisibilityMask,
 }
 
 /// Represents the dirty region of a tile cache picture.
@@ -361,67 +390,68 @@
     pub dirty_rects: Vec<DirtyRegionRect>,
 
     /// The overall dirty rect, a combination of dirty_rects
-    pub combined: DirtyRegionRect,
+    pub combined: WorldRect,
 }
 
 impl DirtyRegion {
     /// Construct a new dirty region tracker.
-    pub fn new() -> Self {
+    pub fn new(
+    ) -> Self {
         DirtyRegion {
-            dirty_rects: Vec::with_capacity(MAX_DIRTY_RECTS),
-            combined: DirtyRegionRect {
-                world_rect: WorldRect::zero(),
-            },
+            dirty_rects: Vec::with_capacity(PrimitiveVisibilityMask::MAX_DIRTY_REGIONS),
+            combined: WorldRect::zero(),
         }
     }
 
     /// Reset the dirty regions back to empty
     pub fn clear(&mut self) {
         self.dirty_rects.clear();
-        self.combined = DirtyRegionRect {
-            world_rect: WorldRect::zero(),
-        }
+        self.combined = WorldRect::zero();
     }
 
     /// Push a dirty rect into this region
     pub fn push(
         &mut self,
         rect: WorldRect,
+        visibility_mask: PrimitiveVisibilityMask,
     ) {
         // Include this in the overall dirty rect
-        self.combined.world_rect = self.combined.world_rect.union(&rect);
+        self.combined = self.combined.union(&rect);
 
         // Store the individual dirty rect.
         self.dirty_rects.push(DirtyRegionRect {
             world_rect: rect,
+            visibility_mask,
         });
     }
 
-    /// Returns true if this region has no dirty rects
-    pub fn is_empty(&self) -> bool {
-        self.dirty_rects.is_empty()
+    /// Include another rect into an existing dirty region.
+    pub fn include_rect(
+        &mut self,
+        region_index: usize,
+        rect: WorldRect,
+    ) {
+        self.combined = self.combined.union(&rect);
+
+        let region = &mut self.dirty_rects[region_index];
+        region.world_rect = region.world_rect.union(&rect);
     }
 
-    /// Collapse all dirty rects into a single dirty rect.
-    pub fn collapse(&mut self) {
-        self.dirty_rects.clear();
-        self.dirty_rects.push(self.combined.clone());
-    }
-
+    // TODO(gw): This returns a heap allocated object. Perhaps we can simplify this
+    //           logic? Although - it's only used very rarely so it may not be an issue.
     pub fn inflate(
         &self,
         inflate_amount: f32,
     ) -> DirtyRegion {
         let mut dirty_rects = Vec::with_capacity(self.dirty_rects.len());
-        let mut combined = DirtyRegionRect {
-            world_rect: WorldRect::zero(),
-        };
+        let mut combined = WorldRect::zero();
 
         for rect in &self.dirty_rects {
             let world_rect = rect.world_rect.inflate(inflate_amount, inflate_amount);
-            combined.world_rect = combined.world_rect.union(&world_rect);
+            combined = combined.union(&world_rect);
             dirty_rects.push(DirtyRegionRect {
                 world_rect,
+                visibility_mask: rect.visibility_mask,
             });
         }
 
@@ -461,304 +491,120 @@
     }
 }
 
-/// A helper struct to build a (roughly) minimal set of dirty rectangles
-/// from a list of individual dirty rectangles. This minimizes the number
-/// of scissors rects and batch resubmissions that are needed.
-struct DirtyRegionBuilder<'a> {
-    tiles: &'a mut [Tile],
-    tile_count: TileSize,
-}
-
-impl<'a> DirtyRegionBuilder<'a> {
-    fn new(
-        tiles: &'a mut [Tile],
-        tile_count: TileSize,
-    ) -> Self {
-        DirtyRegionBuilder {
-            tiles,
-            tile_count,
-        }
-    }
-
-    fn tile_index(&self, x: i32, y: i32) -> usize {
-        (y * self.tile_count.width + x) as usize
-    }
-
-    fn is_dirty(&self, x: i32, y: i32) -> bool {
-        if x == self.tile_count.width || y == self.tile_count.height {
-            return false;
-        }
-
-        self.get_tile(x, y).consider_for_dirty_rect
-    }
-
-    fn get_tile(&self, x: i32, y: i32) -> &Tile {
-        &self.tiles[self.tile_index(x, y)]
-    }
-
-    fn get_tile_mut(&mut self, x: i32, y: i32) -> &mut Tile {
-        &mut self.tiles[self.tile_index(x, y)]
-    }
-
-    /// Return true if the entire column is dirty
-    fn column_is_dirty(&self, x: i32, y0: i32, y1: i32) -> bool {
-        for y in y0 .. y1 {
-            if !self.is_dirty(x, y) {
-                return false;
-            }
-        }
-
-        true
-    }
-
-    /// Push a dirty rect into the final region list.
-    fn push_dirty_rect(
-        &mut self,
-        x0: i32,
-        y0: i32,
-        x1: i32,
-        y1: i32,
-        dirty_region: &mut DirtyRegion,
-    ) {
-        // Construct the overall dirty rect by combining the visible
-        // parts of the dirty rects that were combined.
-        let mut dirty_world_rect = WorldRect::zero();
-
-        for y in y0 .. y1 {
-            for x in x0 .. x1 {
-                let tile = self.get_tile_mut(x, y);
-                tile.consider_for_dirty_rect = false;
-                if let Some(visible_rect) = tile.visible_rect {
-                    dirty_world_rect = dirty_world_rect.union(&visible_rect);
-                }
-            }
-        }
-
-        dirty_region.push(dirty_world_rect);
-    }
-
-    /// Simple sweep through the tile grid to try and coalesce individual
-    /// dirty rects into a smaller number of larger dirty rectangles.
-    fn build(&mut self, dirty_region: &mut DirtyRegion) {
-        for x0 in 0 .. self.tile_count.width {
-            for y0 in 0 .. self.tile_count.height {
-                let mut y1 = y0;
-
-                while self.is_dirty(x0, y1) {
-                    y1 += 1;
-                }
-
-                if y1 > y0 {
-                    let mut x1 = x0;
-
-                    while self.column_is_dirty(x1, y0, y1) {
-                        x1 += 1;
-                    }
-
-                    self.push_dirty_rect(x0, y0, x1, y1, dirty_region);
-                }
-            }
-        }
-    }
-}
-
 /// Represents a cache of tiles that make up a picture primitives.
-pub struct TileCache {
+pub struct TileCacheInstance {
+    /// Index of the tile cache / slice for this frame builder. It's determined
+    /// by the setup_picture_caching method during flattening, which splits the
+    /// picture tree into multiple slices. It's used as a simple input to the tile
+    /// keys. It does mean we invalidate tiles if a new layer gets inserted / removed
+    /// between display lists - this seems very unlikely to occur on most pages, but
+    /// can be revisited if we ever notice that.
+    pub slice: usize,
     /// The positioning node for this tile cache.
-    spatial_node_index: SpatialNodeIndex,
-    /// List of tiles present in this picture (stored as a 2D array)
-    pub tiles: Vec<Tile>,
-    /// A helper struct to map local rects into world coords.
-    map_local_to_world: SpaceMapper<LayoutPixel, WorldPixel>,
-    /// A list of tiles to draw during batching.
-    pub tiles_to_draw: Vec<TileIndex>,
+    pub spatial_node_index: SpatialNodeIndex,
+    /// Hash of tiles present in this picture.
+    pub tiles: FastHashMap<TileKey, Tile>,
+    /// A helper struct to map local rects into surface coords.
+    map_local_to_surface: SpaceMapper<LayoutPixel, PicturePixel>,
     /// List of opacity bindings, with some extra information
     /// about whether they changed since last frame.
     opacity_bindings: FastHashMap<PropertyBindingId, OpacityBindingInfo>,
     /// The current dirty region tracker for this picture.
     pub dirty_region: DirtyRegion,
-    /// The current world reference point that tiles are created around.
-    world_origin: WorldPoint,
-    /// Current size of tiles in world units.
-    world_tile_size: WorldSize,
-    /// Current number of tiles in the allocated grid.
-    tile_count: TileSize,
-    /// The current scroll offset for this frame builder. Reset when
-    /// a new scene arrives.
-    scroll_offset: Option<WorldVector2D>,
-    /// A list of blits from the framebuffer to be applied during this frame.
-    pub pending_blits: Vec<TileBlit>,
-    /// The current world bounding rect of this tile cache. This is used
-    /// to derive a local clip rect, such that we don't obscure in the
-    /// z-buffer any items placed earlier in the render order (such as
-    /// scroll bars in gecko, when the content overflows under the
-    /// scroll bar).
-    world_bounding_rect: WorldRect,
-    /// World space clip rect of the root clipping node. Every primitive
-    /// has this as the root of the clip chain attached to the primitive.
-    root_clip_rect: WorldRect,
-    /// List of reference primitive information used for
-    /// correlating the position between display lists.
-    reference_prims: ReferencePrimitiveList,
-    /// The root clip chain for this tile cache.
-    root_clip_chain_id: ClipChainId,
-    /// If true, this tile cache is enabled. For now, it doesn't
-    /// support tile caching if the surface is not the main framebuffer.
-    pub is_enabled: bool,
+    /// Current size of tiles in picture units.
+    tile_size: PictureSize,
+    /// Tile coords of the currently allocated grid.
+    tile_rect: TileRect,
+    /// Pre-calculated versions of the tile_rect above, used to speed up the
+    /// calculations in get_tile_coords_for_rect.
+    tile_bounds_p0: TileOffset,
+    tile_bounds_p1: TileOffset,
+    /// Local rect (unclipped) of the picture this cache covers.
+    pub local_rect: PictureRect,
     /// Local clip rect for this tile cache.
-    pub local_clip_rect: LayoutRect,
+    pub local_clip_rect: PictureRect,
+    /// If true, the entire tile cache was determined to be opaque. This allows
+    /// WR to enable subpixel AA text rendering for text runs on this slice.
+    pub is_opaque: bool,
+    /// A list of tiles that are valid and visible, which should be drawn to the main scene.
+    pub tiles_to_draw: Vec<TileKey>,
+    /// The world space viewport that this tile cache draws into.
+    /// Any clips outside this viewport can be ignored (and must be removed so that
+    /// we can draw outside the bounds of the viewport).
+    pub world_viewport_rect: WorldRect,
+    /// The surface index that this tile cache will be drawn into.
+    surface_index: SurfaceIndex,
+    /// The background color from the renderer. If this is set opaque, we know it's
+    /// fine to clear the tiles to this and allow subpixel text on the first slice.
+    pub background_color: Option<ColorF>,
 }
 
-/// Stores information about a primitive in the cache that we will
-/// try to use to correlate positions between display lists.
-#[derive(Clone)]
-struct ReferencePrimitive {
-    uid: ItemUid,
-    local_pos: LayoutPoint,
-    spatial_node_index: SpatialNodeIndex,
-    ref_count: usize,
-}
-
-/// A list of primitive with uids that only exist once in a display
-/// list. Used to obtain reference points to correlate the offset
-/// between two similar display lists.
-struct ReferencePrimitiveList {
-    ref_prims: Vec<ReferencePrimitive>,
-}
-
-impl ReferencePrimitiveList {
-    fn new(
-        prim_instances: &[PrimitiveInstance],
-        pictures: &[PicturePrimitive],
+impl TileCacheInstance {
+    pub fn new(
+        slice: usize,
+        spatial_node_index: SpatialNodeIndex,
+        background_color: Option<ColorF>,
     ) -> Self {
-        let mut map = FastHashMap::default();
-        let mut search_count = 0;
-
-        // Collect a set of primitives that we can
-        // potentially use for correlation.
-        collect_ref_prims(
-            prim_instances,
-            pictures,
-            &mut map,
-            &mut search_count,
-        );
-
-        // Select only primitives where the uid is unique
-        // in the display list, giving the best chance
-        // of finding correct correlations.
-        let ref_prims = map.values().filter(|prim| {
-            prim.ref_count == 1
-        }).cloned().collect();
-
-        ReferencePrimitiveList {
-            ref_prims,
+        TileCacheInstance {
+            slice,
+            spatial_node_index,
+            tiles: FastHashMap::default(),
+            map_local_to_surface: SpaceMapper::new(
+                ROOT_SPATIAL_NODE_INDEX,
+                PictureRect::zero(),
+            ),
+            opacity_bindings: FastHashMap::default(),
+            dirty_region: DirtyRegion::new(),
+            tile_size: PictureSize::zero(),
+            tile_rect: TileRect::zero(),
+            tile_bounds_p0: TileOffset::zero(),
+            tile_bounds_p1: TileOffset::zero(),
+            local_rect: PictureRect::zero(),
+            local_clip_rect: PictureRect::zero(),
+            is_opaque: false,
+            tiles_to_draw: Vec::new(),
+            world_viewport_rect: WorldRect::zero(),
+            surface_index: SurfaceIndex(0),
+            background_color,
         }
     }
-}
-
-/// Collect a sample of primitives from the prim list that can
-/// be used to correlate positions.
-fn collect_ref_prims(
-    prim_instances: &[PrimitiveInstance],
-    pictures: &[PicturePrimitive],
-    map: &mut FastHashMap<ItemUid, ReferencePrimitive>,
-    search_count: &mut usize,
-) {
-    for prim_instance in prim_instances {
-        if *search_count > MAX_PRIMS_TO_SEARCH {
-            return;
+
+    /// Returns true if this tile cache is considered opaque.
+    pub fn is_opaque(&self) -> bool {
+        // If we detected an explicit background rect that is opaque and covers all tiles.
+        if self.is_opaque {
+            return true;
         }
 
-        match prim_instance.kind {
-            PrimitiveInstanceKind::Picture { pic_index, .. } => {
-                collect_ref_prims(
-                    &pictures[pic_index.0].prim_list.prim_instances,
-                    pictures,
-                    map,
-                    search_count,
-                );
-            }
-            _ => {
-                let uid = prim_instance.uid();
-
-                let entry = map.entry(uid).or_insert_with(|| {
-                    ReferencePrimitive {
-                        uid,
-                        local_pos: prim_instance.prim_origin,
-                        spatial_node_index: prim_instance.spatial_node_index,
-                        ref_count: 0,
-                    }
-                });
-                entry.ref_count += 1;
-
-                *search_count = *search_count + 1;
-            }
-        }
-    }
-}
-
-impl TileCache {
-    pub fn new(
-        spatial_node_index: SpatialNodeIndex,
-        prim_instances: &[PrimitiveInstance],
-        root_clip_chain_id: ClipChainId,
-        pictures: &[PicturePrimitive],
-    ) -> Self {
-        // Build the list of reference primitives
-        // for this picture cache.
-        let reference_prims = ReferencePrimitiveList::new(
-            prim_instances,
-            pictures,
-        );
-
-        TileCache {
-            spatial_node_index,
-            tiles: Vec::new(),
-            map_local_to_world: SpaceMapper::new(
-                ROOT_SPATIAL_NODE_INDEX,
-                WorldRect::zero(),
-            ),
-            tiles_to_draw: Vec::new(),
-            opacity_bindings: FastHashMap::default(),
-            dirty_region: DirtyRegion::new(),
-            world_origin: WorldPoint::zero(),
-            world_tile_size: WorldSize::zero(),
-            tile_count: TileSize::zero(),
-            scroll_offset: None,
-            pending_blits: Vec::new(),
-            world_bounding_rect: WorldRect::zero(),
-            root_clip_rect: WorldRect::max_rect(),
-            reference_prims,
-            root_clip_chain_id,
-            is_enabled: true,
-            local_clip_rect: LayoutRect::zero(),
+        // If known opaque due to background clear color and being the first slice.
+        // The background_color will only be Some(..) if this is the first slice.
+        match self.background_color {
+            Some(color) => color.a >= 1.0,
+            None => false
         }
     }
 
     /// Get the tile coordinates for a given rectangle.
     fn get_tile_coords_for_rect(
         &self,
-        rect: &WorldRect,
+        rect: &PictureRect,
     ) -> (TileOffset, TileOffset) {
-        // Translate the rectangle into the virtual tile space
-        let origin = rect.origin - self.world_origin;
-
         // Get the tile coordinates in the picture space.
         let mut p0 = TileOffset::new(
-            (origin.x / self.world_tile_size.width).floor() as i32,
-            (origin.y / self.world_tile_size.height).floor() as i32,
+            (rect.origin.x / self.tile_size.width).floor() as i32,
+            (rect.origin.y / self.tile_size.height).floor() as i32,
         );
 
         let mut p1 = TileOffset::new(
-            ((origin.x + rect.size.width) / self.world_tile_size.width).ceil() as i32,
-            ((origin.y + rect.size.height) / self.world_tile_size.height).ceil() as i32,
+            ((rect.origin.x + rect.size.width) / self.tile_size.width).ceil() as i32,
+            ((rect.origin.y + rect.size.height) / self.tile_size.height).ceil() as i32,
         );
 
         // Clamp the tile coordinates here to avoid looping over irrelevant tiles later on.
-        p0.x = clamp(p0.x, 0, self.tile_count.width);
-        p0.y = clamp(p0.y, 0, self.tile_count.height);
-        p1.x = clamp(p1.x, 0, self.tile_count.width);
-        p1.y = clamp(p1.y, 0, self.tile_count.height);
+        p0.x = clamp(p0.x, self.tile_bounds_p0.x, self.tile_bounds_p1.x);
+        p0.y = clamp(p0.y, self.tile_bounds_p0.y, self.tile_bounds_p1.y);
+        p1.x = clamp(p1.x, self.tile_bounds_p0.x, self.tile_bounds_p1.x);
+        p1.y = clamp(p1.y, self.tile_bounds_p0.y, self.tile_bounds_p1.y);
 
         (p0, p1)
     }
@@ -766,81 +612,71 @@
     /// Update transforms, opacity bindings and tile rects.
     pub fn pre_update(
         &mut self,
-        pic_rect: LayoutRect,
+        pic_rect: PictureRect,
+        surface_index: SurfaceIndex,
         frame_context: &FrameVisibilityContext,
         frame_state: &mut FrameVisibilityState,
-        surface_index: SurfaceIndex,
-    ) {
-        // If the tile cache is the first surface on the root
-        // surface, then we can enable it. If the client has
-        // requested caching on an offscreen surface, we will
-        // need to disable it (for now).
-        self.is_enabled = surface_index == SurfaceIndex(1);
-        if !self.is_enabled {
-            // TODO(gw): It's technically possible that this tile cache
-            //           might have been enabled in a valid state, and
-            //           then got an offscreen surface. In this case,
-            //           there may be some pre-cached tiles still existing.
-            //           They will expire from the texture cache as normal,
-            //           but we should check this path a bit more carefully
-            //           to see if any other memory should be freed.
-            return;
-        }
-
-        let DeviceIntSize { width: tile_width, height: tile_height, _unit: _ } =
-            Self::tile_dimensions(frame_context.config.testing);
-
-        // Work out the scroll offset to apply to the world reference point.
-        let scroll_offset_point = frame_context.clip_scroll_tree
-            .get_world_transform(self.spatial_node_index)
-            .inverse_project_2d_origin()
-            .unwrap_or_else(LayoutPoint::zero);
-
-        let scroll_offset = WorldVector2D::new(scroll_offset_point.x, scroll_offset_point.y);
-        let scroll_delta = match self.scroll_offset {
-            Some(prev) => prev - scroll_offset,
-            None => WorldVector2D::zero(),
-        };
-        self.scroll_offset = Some(scroll_offset);
-
-        // Pull any retained tiles from the previous scene.
-        let world_offset = if frame_state.retained_tiles.tiles.is_empty() {
-            None
-        } else {
-            assert!(self.tiles.is_empty());
-            self.tiles = mem::replace(&mut frame_state.retained_tiles.tiles, Vec::new());
-
-            // Get the positions of the reference primitives for this
-            // new display list.
-            let mut new_prim_map = FastHashMap::default();
-            build_ref_prims(
-                &self.reference_prims.ref_prims,
-                &mut new_prim_map,
-                frame_context.clip_scroll_tree,
-            );
-
-            // Attempt to correlate them to work out which offset to apply.
-            correlate_prim_maps(
-                &frame_state.retained_tiles.ref_prims,
-                &new_prim_map,
-            )
-        }.unwrap_or_else(WorldVector2D::zero);
-
-        // Assume no tiles are valid to draw by default
-        self.tiles_to_draw.clear();
-
-        self.map_local_to_world = SpaceMapper::new(
-            ROOT_SPATIAL_NODE_INDEX,
-            frame_context.screen_world_rect,
+    ) -> WorldRect {
+        let tile_width = TILE_SIZE_WIDTH;
+        let tile_height = TILE_SIZE_HEIGHT;
+        self.surface_index = surface_index;
+
+        self.map_local_to_surface = SpaceMapper::new(
+            self.spatial_node_index,
+            PictureRect::from_untyped(&pic_rect.to_untyped()),
         );
 
-        let world_mapper = SpaceMapper::new_with_target(
+        let pic_to_world_mapper = SpaceMapper::new_with_target(
             ROOT_SPATIAL_NODE_INDEX,
             self.spatial_node_index,
-            frame_context.screen_world_rect,
+            frame_context.global_screen_world_rect,
             frame_context.clip_scroll_tree,
         );
 
+        let spatial_node = &frame_context
+            .clip_scroll_tree
+            .spatial_nodes[self.spatial_node_index.0 as usize];
+        let (viewport_rect, viewport_spatial_node_index) = match spatial_node.node_type {
+            SpatialNodeType::ScrollFrame(ref info) => {
+                (info.viewport_rect, spatial_node.parent.unwrap())
+            }
+            SpatialNodeType::StickyFrame(..) => {
+                unreachable!();
+            }
+            SpatialNodeType::ReferenceFrame(..) => {
+                assert_eq!(self.spatial_node_index, ROOT_SPATIAL_NODE_INDEX);
+                (LayoutRect::max_rect(), ROOT_SPATIAL_NODE_INDEX)
+            }
+        };
+
+        let viewport_to_world_mapper = SpaceMapper::new_with_target(
+            ROOT_SPATIAL_NODE_INDEX,
+            viewport_spatial_node_index,
+            frame_context.global_screen_world_rect,
+            frame_context.clip_scroll_tree,
+        );
+        self.world_viewport_rect = viewport_to_world_mapper
+            .map(&viewport_rect)
+            .expect("bug: unable to map viewport to world space");
+
+        // TODO(gw): This is a reverse mapping. It should always work since we know
+        //           that this path only runs for slices in the root coordinate system.
+        //           But perhaps we should assert that?
+        // TODO(gw): We could change to directly use the ScaleOffset in content_transform
+        //           which would make this clearer that we know the coordinate systems are the
+        //           same and that it's a safe / exact conversion.
+        self.map_local_to_surface.set_target_spatial_node(
+            viewport_spatial_node_index,
+            frame_context.clip_scroll_tree,
+        );
+        let local_viewport_rect = self
+            .map_local_to_surface
+            .map(&viewport_rect)
+            .expect("bug: unable to map to local viewport rect");
+
+        self.local_rect = pic_rect;
+        self.local_clip_rect = local_viewport_rect;
+
         // Do a hacky diff of opacity binding values from the last frame. This is
         // used later on during tile invalidation tests.
         let current_properties = frame_context.scene_properties.float_properties();
@@ -857,171 +693,120 @@
             });
         }
 
-        // Map the picture rect to world and device space and work out the tiles
-        // that we need in order to ensure the screen is covered. We haven't done
-        // any snapping yet, so we need to round out in device space to ensure we
-        // cover all pixels the picture may touch.
-        let pic_device_rect = {
-            let unsnapped_world_rect = world_mapper
-                .map(&pic_rect)
-                .expect("bug: unable to map picture rect to world");
-            (unsnapped_world_rect * frame_context.global_device_pixel_scale)
-                .round_out()
-        };
-        let pic_world_rect = pic_device_rect / frame_context.global_device_pixel_scale;
-
-        // If the bounding rect of the picture to cache doesn't intersect with
-        // the visible world rect at all, just take the screen world rect as
-        // a reference for the area to create tiles for. This allows existing
-        // tiles to be retained in case they are still valid if / when they
-        // get scrolled back onto the screen.
-
-        let needed_world_rect = frame_context
-            .screen_world_rect
-            .intersection(&pic_world_rect)
-            .unwrap_or(frame_context.screen_world_rect);
-
-        // Get a reference point that serves as an origin that all tiles we create
-        // must be aligned to. This ensures that tiles get reused correctly between
-        // scrolls and display list changes, even with the different local coord
-        // systems that gecko supplies.
-        let mut world_ref_point = if self.tiles.is_empty() {
-            needed_world_rect.origin.floor()
-        } else {
-            self.tiles[0].world_rect.origin + world_offset
-        };
-
-        // Apply the scroll delta so that existing tiles still get used.
-        world_ref_point += scroll_delta;
-
-        // Work out the required device rect that we need to cover the screen,
-        // given the world reference point constraint.
-        let device_ref_point = world_ref_point * frame_context.global_device_pixel_scale;
-        let device_world_rect = frame_context.screen_world_rect * frame_context.global_device_pixel_scale;
-        let needed_device_rect = pic_device_rect
-            .intersection(&device_world_rect)
-            .unwrap_or(device_world_rect);
-
-        // Expand the needed device rect vertically by a small number of tiles. This
-        // ensures that as tiles are scrolled in/out of view, they are retained for
-        // a while before being discarded.
-        // TODO(gw): On some pages it might be worth also inflating horizontally.
-        //           (is this locale specific?). It might be possible to make a good
-        //           guess based on the size of the picture rect for the tile cache.
-        let needed_device_rect = needed_device_rect.inflate(
-            0.0,
-            3.0 * tile_height as f32,
-        );
-
-        let p0 = needed_device_rect.origin;
-        let p1 = needed_device_rect.bottom_right();
-
-        let p0 = DevicePoint::new(
-            device_ref_point.x + ((p0.x - device_ref_point.x) / tile_width as f32).floor() * tile_width as f32,
-            device_ref_point.y + ((p0.y - device_ref_point.y) / tile_height as f32).floor() * tile_height as f32,
-        );
-
-        let p1 = DevicePoint::new(
-            device_ref_point.x + ((p1.x - device_ref_point.x) / tile_width as f32).ceil() * tile_width as f32,
-            device_ref_point.y + ((p1.y - device_ref_point.y) / tile_height as f32).ceil() * tile_height as f32,
-        );
-
-        // And now the number of tiles from that device rect.
-        let x_tiles = ((p1.x - p0.x) / tile_width as f32).round() as i32;
-        let y_tiles = ((p1.y - p0.y) / tile_height as f32).round() as i32;
-
-        // Step through any old tiles, and retain them if we can. They are keyed only on
-        // the (scroll adjusted) world position, relying on the descriptor content checks
-        // later to invalidate them if the content has changed.
-        let mut old_tiles = FastHashMap::default();
-        for tile in self.tiles.drain(..) {
-            let tile_device_pos = (tile.world_rect.origin + scroll_delta) * frame_context.global_device_pixel_scale;
-            let key = (
-                (tile_device_pos.x + world_offset.x).round() as i32,
-                (tile_device_pos.y + world_offset.y).round() as i32,
-            );
-            old_tiles.insert(key, tile);
-        }
-
-        // Store parameters about the current tiling rect for use during dependency updates.
-        self.world_origin = WorldPoint::new(
-            p0.x / frame_context.global_device_pixel_scale.0,
-            p0.y / frame_context.global_device_pixel_scale.0,
-        );
-        self.world_tile_size = WorldSize::new(
+        let world_tile_size = WorldSize::new(
             tile_width as f32 / frame_context.global_device_pixel_scale.0,
             tile_height as f32 / frame_context.global_device_pixel_scale.0,
         );
-        self.tile_count = TileSize::new(x_tiles, y_tiles);
-
-        // Step through each tile and try to retain an old tile from the
-        // previous frame, and update bounding rects.
-        for y in 0 .. y_tiles {
-            for x in 0 .. x_tiles {
-                let px = p0.x + x as f32 * tile_width as f32;
-                let py = p0.y + y as f32 * tile_height as f32;
-                let key = (px.round() as i32, py.round() as i32);
-
-                let mut tile = match old_tiles.remove(&key) {
-                    Some(tile) => tile,
-                    None => {
+
+        // We know that this is an exact rectangle, since we (for now) only support tile
+        // caches where the scroll root is in the root coordinate system.
+        let local_tile_rect = pic_to_world_mapper
+            .unmap(&WorldRect::new(WorldPoint::zero(), world_tile_size))
+            .expect("bug: unable to get local tile rect");
+
+        self.tile_size = local_tile_rect.size;
+
+        let screen_rect_in_pic_space = pic_to_world_mapper
+            .unmap(&frame_context.global_screen_world_rect)
+            .expect("unable to unmap screen rect");
+
+        let visible_rect_in_pic_space = screen_rect_in_pic_space
+            .intersection(&self.local_clip_rect)
+            .unwrap_or(PictureRect::zero());
+
+        // Inflate the needed rect a bit, so that we retain tiles that we have drawn
+        // but have just recently gone off-screen. This means that we avoid re-drawing
+        // tiles if the user is scrolling up and down small amounts, at the cost of
+        // a bit of extra texture memory.
+        let desired_rect_in_pic_space = visible_rect_in_pic_space
+            .inflate(0.0, 3.0 * self.tile_size.height);
+
+        let needed_rect_in_pic_space = desired_rect_in_pic_space
+            .intersection(&pic_rect)
+            .unwrap_or(PictureRect::zero());
+
+        let p0 = needed_rect_in_pic_space.origin;
+        let p1 = needed_rect_in_pic_space.bottom_right();
+
+        let x0 = (p0.x / local_tile_rect.size.width).floor() as i32;
+        let x1 = (p1.x / local_tile_rect.size.width).ceil() as i32;
+
+        let y0 = (p0.y / local_tile_rect.size.height).floor() as i32;
+        let y1 = (p1.y / local_tile_rect.size.height).ceil() as i32;
+
+        let x_tiles = x1 - x0;
+        let y_tiles = y1 - y0;
+        self.tile_rect = TileRect::new(
+            TileOffset::new(x0, y0),
+            TileSize::new(x_tiles, y_tiles),
+        );
+        // This is duplicated information from tile_rect, but cached here to avoid
+        // redundant calculations during get_tile_coords_for_rect
+        self.tile_bounds_p0 = TileOffset::new(x0, y0);
+        self.tile_bounds_p1 = TileOffset::new(x1, y1);
+
+        // TODO(gw): Tidy this up as we add better support for retaining
+        //           slices and sub-grid dirty areas.
+        let mut keys = Vec::new();
+        for key in frame_state.retained_tiles.tiles.keys() {
+            if key.slice == self.slice {
+                keys.push(*key);
+            }
+        }
+        for key in keys {
+            self.tiles.insert(key, frame_state.retained_tiles.tiles.remove(&key).unwrap());
+        }
+
+        let mut old_tiles = mem::replace(
+            &mut self.tiles,
+            FastHashMap::default(),
+        );
+
+        let mut world_culling_rect = WorldRect::zero();
+
+        for y in y0 .. y1 {
+            for x in x0 .. x1 {
+                let key = TileKey {
+                    offset: TileOffset::new(x, y),
+                    slice: self.slice,
+                };
+
+                let mut tile = old_tiles
+                    .remove(&key)
+                    .unwrap_or_else(|| {
                         let next_id = TileId(NEXT_TILE_ID.fetch_add(1, Ordering::Relaxed));
                         Tile::new(next_id)
-                    }
-                };
-
-                tile.world_rect = WorldRect::new(
-                    WorldPoint::new(
-                        px / frame_context.global_device_pixel_scale.0,
-                        py / frame_context.global_device_pixel_scale.0,
+                    });
+
+                tile.rect = PictureRect::new(
+                    PicturePoint::new(
+                        x as f32 * self.tile_size.width,
+                        y as f32 * self.tile_size.height,
                     ),
-                    self.world_tile_size,
+                    self.tile_size,
                 );
 
-                tile.local_rect = world_mapper
-                    .unmap(&tile.world_rect)
-                    .expect("bug: can't unmap world rect");
-
-                tile.visible_rect = tile.world_rect.intersection(&frame_context.screen_world_rect);
-
-                self.tiles.push(tile);
-            }
-        }
-
-        if !old_tiles.is_empty() {
-            // TODO(gw): Should we explicitly drop the tile texture cache handles here?
-        }
-
-        self.world_bounding_rect = WorldRect::zero();
-        self.root_clip_rect = WorldRect::max_rect();
-
-        // Calculate the world space of the root clip node, that every primitive has
-        // at the root of its clip chain (this is enforced by the per-pipeline-root
-        // clip node added implicitly during display list flattening). Doing it once
-        // here saves doing it for every primitive during update_prim_dependencies.
-        if self.root_clip_chain_id != ClipChainId::NONE {
-            let root_clip_chain_node = &frame_state
-                .clip_store
-                .clip_chain_nodes[self.root_clip_chain_id.0 as usize];
-            let root_clip_node = &frame_state
-                .data_stores
-                .clip[root_clip_chain_node.handle];
-            if let Some(clip_rect) = root_clip_node.item.get_local_clip_rect(root_clip_chain_node.local_pos) {
-                self.map_local_to_world.set_target_spatial_node(
-                    root_clip_chain_node.spatial_node_index,
-                    frame_context.clip_scroll_tree,
-                );
-
-                if let Some(world_clip_rect) = self.map_local_to_world.map(&clip_rect) {
-                    self.root_clip_rect = world_clip_rect;
-                }
+                tile.clipped_rect = tile.rect
+                    .intersection(&self.local_rect)
+                    .unwrap_or(PictureRect::zero());
+
+                tile.world_rect = pic_to_world_mapper
+                    .map(&tile.rect)
+                    .expect("bug: map local tile rect");
+
+                world_culling_rect = world_culling_rect.union(&tile.world_rect);
+
+                self.tiles.insert(key, tile);
             }
         }
 
         // Do tile invalidation for any dependencies that we know now.
-        for tile in &mut self.tiles {
+        for (_, tile) in &mut self.tiles {
             // Start frame assuming that the tile has the same content.
             tile.is_same_content = true;
+            // Reset the opacity of the tile to false, since it may change each frame.
+            // The primitive dependency updates will determine if it is opaque again.
+            tile.is_opaque = false;
 
             // Content has changed if any images have changed
             for image_key in tile.descriptor.image_keys.items() {
@@ -1049,47 +834,43 @@
             // can compare if the tile has the same content.
             tile.clear();
         }
+
+        world_culling_rect
     }
 
     /// Update the dependencies for each tile for a given primitive instance.
     pub fn update_prim_dependencies(
         &mut self,
         prim_instance: &PrimitiveInstance,
-        clip_chain_stack: &ClipChainStack,
-        prim_rect: LayoutRect,
+        prim_clip_chain: Option<&ClipChainInstance>,
+        local_prim_rect: LayoutRect,
         clip_scroll_tree: &ClipScrollTree,
         data_stores: &DataStores,
-        clip_chain_nodes: &[ClipChainNode],
+        clip_store: &ClipStore,
         pictures: &[PicturePrimitive],
         resource_cache: &ResourceCache,
         opacity_binding_store: &OpacityBindingStorage,
         image_instances: &ImageInstanceStorage,
+        surface_index: SurfaceIndex,
     ) -> bool {
-        // If the tile cache is disabled, there's no need to update
-        // the primitive dependencies.
-        if !self.is_enabled {
-            // Return true to signal that we didn't early cull this primitive.
-            return true;
-        }
-
-        self.map_local_to_world.set_target_spatial_node(
+        self.map_local_to_surface.set_target_spatial_node(
             prim_instance.spatial_node_index,
             clip_scroll_tree,
         );
 
-        // Map the primitive local rect into world space.
-        let world_rect = match self.map_local_to_world.map(&prim_rect) {
+        // Map the primitive local rect into picture space.
+        let prim_rect = match self.map_local_to_surface.map(&local_prim_rect) {
             Some(rect) => rect,
             None => return false,
         };
 
         // If the rect is invalid, no need to create dependencies.
-        if world_rect.size.width <= 0.0 || world_rect.size.height <= 0.0 {
+        if prim_rect.size.is_empty_or_negative() {
             return false;
         }
 
         // Get the tile coordinates in the picture space.
-        let (p0, p1) = self.get_tile_coords_for_rect(&world_rect);
+        let (p0, p1) = self.get_tile_coords_for_rect(&prim_rect);
 
         // If the primitive is outside the tiling rects, it's known to not
         // be visible.
@@ -1100,14 +881,11 @@
         // Build the list of resources that this primitive has dependencies on.
         let mut opacity_bindings: SmallVec<[OpacityBinding; 4]> = SmallVec::new();
         let mut clip_chain_uids: SmallVec<[ItemUid; 8]> = SmallVec::new();
-        let mut clip_vertices: SmallVec<[WorldPoint; 8]> = SmallVec::new();
+        let mut clip_vertices: SmallVec<[LayoutPoint; 8]> = SmallVec::new();
         let mut image_keys: SmallVec<[ImageKey; 8]> = SmallVec::new();
         let mut clip_spatial_nodes = FastHashSet::default();
-
-        // TODO(gw): We only care about world clip rects that don't have the main
-        //           scroll root as an ancestor. It may be a worthwhile optimization
-        //           to check for these and skip them.
-        let mut world_clips: SmallVec<[(RectangleKey, SpatialNodeIndex); 4]> = SmallVec::default();
+        let mut opaque_rect = None;
+        let mut prim_clip_rect = PictureRect::zero();
 
         // Some primitives can not be cached (e.g. external video images)
         let is_cacheable = prim_instance.is_cacheable(
@@ -1126,7 +904,7 @@
         // rect eventually means it doesn't affect that tile).
         // TODO(gw): Get picture clips earlier (during the initial picture traversal
         //           pass) so that we can calculate these correctly.
-        let include_clip_rect = match prim_instance.kind {
+        let clip_by_tile = match prim_instance.kind {
             PrimitiveInstanceKind::Picture { pic_index,.. } => {
                 // Pictures can depend on animated opacity bindings.
                 let pic = &pictures[pic_index.0];
@@ -1136,8 +914,40 @@
 
                 false
             }
-            PrimitiveInstanceKind::Rectangle { opacity_binding_index, .. } => {
-                if opacity_binding_index != OpacityBindingIndex::INVALID {
+            PrimitiveInstanceKind::Rectangle { data_handle, opacity_binding_index, .. } => {
+                if opacity_binding_index == OpacityBindingIndex::INVALID {
+                    // Check a number of conditions to see if we can consider this
+                    // primitive as an opaque rect. Several of these are conservative
+                    // checks and could be relaxed in future. However, these checks
+                    // are quick and capture the common cases of background rects.
+                    // Specifically, we currently require:
+                    //  - No opacity binding (to avoid resolving the opacity here).
+                    //  - Color.a >= 1.0 (the primitive is opaque).
+                    //  - Same coord system as picture cache (ensures rects are axis-aligned).
+                    //  - No clip masks exist.
+
+                    let on_picture_surface = surface_index == self.surface_index;
+
+                    let prim_is_opaque = match data_stores.prim[data_handle].kind {
+                        PrimitiveTemplateKind::Rectangle { ref color, .. } => color.a >= 1.0,
+                        _ => unreachable!(),
+                    };
+
+                    let same_coord_system = {
+                        let prim_spatial_node = &clip_scroll_tree
+                            .spatial_nodes[prim_instance.spatial_node_index.0 as usize];
+                        let surface_spatial_node = &clip_scroll_tree
+                            .spatial_nodes[self.spatial_node_index.0 as usize];
+
+                        prim_spatial_node.coordinate_system_id == surface_spatial_node.coordinate_system_id
+                    };
+
+                    if let Some(ref clip_chain) = prim_clip_chain {
+                        if prim_is_opaque && same_coord_system && !clip_chain.needs_mask && on_picture_surface {
+                            opaque_rect = Some(clip_chain.pic_clip_rect);
+                        }
+                    };
+                } else {
                     let opacity_binding = &opacity_binding_store[opacity_binding_index];
                     for binding in &opacity_binding.bindings {
                         opacity_bindings.push(OpacityBinding::from(*binding));
@@ -1159,12 +969,17 @@
                 }
 
                 image_keys.push(image_data.key);
-                true
+                false
             }
             PrimitiveInstanceKind::YuvImage { data_handle, .. } => {
                 let yuv_image_data = &data_stores.yuv_image[data_handle].kind;
                 image_keys.extend_from_slice(&yuv_image_data.yuv_key);
-                true
+                false
+            }
+            PrimitiveInstanceKind::PushClipChain |
+            PrimitiveInstanceKind::PopClipChain => {
+                // Early exit to ensure this doesn't get added as a dependency on the tile.
+                return false;
             }
             PrimitiveInstanceKind::TextRun { .. } |
             PrimitiveInstanceKind::LineDecoration { .. } |
@@ -1174,169 +989,48 @@
             PrimitiveInstanceKind::RadialGradient { .. } |
             PrimitiveInstanceKind::ImageBorder { .. } => {
                 // These don't contribute dependencies
-                true
+                false
             }
         };
 
-        // The transforms of any clips that are relative to the picture may affect
-        // the content rendered by this primitive.
-        let mut world_clip_rect = world_rect;
-        let mut culling_rect = prim_rect
-            .intersection(&prim_instance.local_clip_rect)
-            .unwrap_or_else(LayoutRect::zero);
-
-        // To maintain the previous logic, consider every clip in the current active
-        // clip stack that could affect this primitive.
-        // TODO(gw): We can make this much more efficient now, by taking advantage
-        //           of the per-picture clip chain information, rather then considering
-        //           it for every primitive, as we do here for simplicity.
-        for clip_stack in &clip_chain_stack.stack {
-            for clip_chain_id in clip_stack {
-                let mut current_clip_chain_id = *clip_chain_id;
-                while current_clip_chain_id != ClipChainId::NONE {
-                    let clip_chain_node = &clip_chain_nodes[current_clip_chain_id.0 as usize];
-                    let clip_node = &data_stores.clip[clip_chain_node.handle];
-
-                    // We can skip the root clip node - it will be taken care of by the
-                    // world bounding rect calculated for the cache.
-                    if current_clip_chain_id == self.root_clip_chain_id {
-                        current_clip_chain_id = clip_chain_node.parent_clip_chain_id;
-                        continue;
-                    }
-
-                    self.map_local_to_world.set_target_spatial_node(
-                        clip_chain_node.spatial_node_index,
-                        clip_scroll_tree,
-                    );
-
-                    // Clips that are simple rects and handled by collapsing them into a single
-                    // clip rect. This avoids the need to store vertices for these cases, and also
-                    // allows easy calculation of the overall bounds of the tile cache.
-                    let add_to_clip_deps = match clip_node.item {
-                        ClipItem::Rectangle(size, ClipMode::Clip) => {
-                            let clip_spatial_node = &clip_scroll_tree.spatial_nodes[clip_chain_node.spatial_node_index.0 as usize];
-
-                            let local_clip_rect = LayoutRect::new(
-                                clip_chain_node.local_pos,
-                                size,
-                            );
-
-                            if clip_spatial_node.coordinate_system_id == CoordinateSystemId(0) {
-                                // Clips that are not in the root coordinate system are not axis-aligned,
-                                // so we need to treat them as normal style clips with vertices.
-                                match self.map_local_to_world.map(&local_clip_rect) {
-                                    Some(clip_world_rect) => {
-                                        // Even if this ends up getting clipped out by the current clip
-                                        // stack, we want to ensure the primitive gets added to the tiles
-                                        // below, to ensure invalidation isn't tripped up by the wrong
-                                        // number of primitives that affect this tile.
-                                        world_clip_rect = world_clip_rect
-                                            .intersection(&clip_world_rect)
-                                            .unwrap_or_else(WorldRect::zero);
-
-                                        // If the clip rect is in the same spatial node, it can be handled by the
-                                        // local clip rect.
-                                        if clip_chain_node.spatial_node_index == prim_instance.spatial_node_index {
-                                            culling_rect = culling_rect.intersection(&local_clip_rect).unwrap_or_else(LayoutRect::zero);
-
-                                            false
-                                        } else if !clip_scroll_tree.is_same_or_child_of(
-                                            clip_chain_node.spatial_node_index,
-                                            self.spatial_node_index,
-                                        ) {
-                                            // If the clip node is *not* a child of the main scroll root,
-                                            // add it to the list of potential world clips to be checked later.
-                                            // If it *is* a child of the main scroll root, then just track
-                                            // it as a normal clip dependency, since it likely moves in
-                                            // the same way as the primitive when scrolling (and if it doesn't,
-                                            // we want to invalidate and rasterize).
-                                            world_clips.push((
-                                                clip_world_rect.into(),
-                                                clip_chain_node.spatial_node_index,
-                                            ));
-
-                                            false
-                                        } else {
-                                            true
-                                        }
-                                    }
-                                    None => {
-                                        true
-                                    }
-                                }
-                            } else {
-                                true
-                            }
-                        }
-                        ClipItem::Rectangle(_, ClipMode::ClipOut) |
-                        ClipItem::RoundedRectangle(..) |
-                        ClipItem::Image { .. } |
-                        ClipItem::BoxShadow(..) => {
-                            true
-                        }
-                    };
-
-                    if add_to_clip_deps {
-                        clip_chain_uids.push(clip_chain_node.handle.uid());
-
-                        // If the clip has the same spatial node, the relative transform
-                        // will always be the same, so there's no need to depend on it.
-                        if clip_chain_node.spatial_node_index != self.spatial_node_index {
-                            clip_spatial_nodes.insert(clip_chain_node.spatial_node_index);
-                        }
-
-                        let local_clip_rect = LayoutRect::new(
-                            clip_chain_node.local_pos,
-                            LayoutSize::zero(),
-                        );
-                        if let Some(world_clip_rect) = self.map_local_to_world.map(&local_clip_rect) {
-                            clip_vertices.push(world_clip_rect.origin);
-                        }
-                    }
-
-                    current_clip_chain_id = clip_chain_node.parent_clip_chain_id;
+        // If there was a clip chain, add any clip dependencies to the list for this tile.
+        if let Some(prim_clip_chain) = prim_clip_chain {
+            prim_clip_rect = prim_clip_chain.pic_clip_rect;
+
+            let clip_instances = &clip_store
+                .clip_node_instances[prim_clip_chain.clips_range.to_range()];
+            for clip_instance in clip_instances {
+                clip_chain_uids.push(clip_instance.handle.uid());
+
+                // If the clip has the same spatial node, the relative transform
+                // will always be the same, so there's no need to depend on it.
+                if clip_instance.spatial_node_index != self.spatial_node_index {
+                    clip_spatial_nodes.insert(clip_instance.spatial_node_index);
                 }
+
+                clip_vertices.push(clip_instance.local_pos);
             }
         }
 
-        if include_clip_rect {
-            // Intersect the calculated prim bounds with the root clip rect, to save
-            // having to process and transform the root clip rect in every primitive.
-            if let Some(clipped_world_rect) = world_clip_rect.intersection(&self.root_clip_rect) {
-                self.world_bounding_rect = self.world_bounding_rect.union(&clipped_world_rect);
-            }
-        }
-
-        self.map_local_to_world.set_target_spatial_node(
-            prim_instance.spatial_node_index,
-            clip_scroll_tree,
-        );
-        let world_culling_rect = match self.map_local_to_world.map(&culling_rect) {
-            Some(rect) => rect,
-            None => return false,
-        };
-
         // Normalize the tile coordinates before adding to tile dependencies.
         // For each affected tile, mark any of the primitive dependencies.
         for y in p0.y .. p1.y {
             for x in p0.x .. p1.x {
-                let index = (y * self.tile_count.width + x) as usize;
-                let tile = &mut self.tiles[index];
-
-                // Store the local clip rect by calculating what portion
-                // of the tile it covers.
-                let world_culling_rect = world_culling_rect
-                    .intersection(&tile.world_rect)
-                    .map(|rect| {
-                        rect.translate(&-tile.world_rect.origin.to_vector())
-                    })
-                    .unwrap_or_else(WorldRect::zero)
-                    .round();
-
-                // Work out the needed rect for the primitive on this tile.
-                // TODO(gw): We should be able to remove this for any tile that is not
-                //           a partially clipped tile, which would be a significant
-                //           optimization for the common case (non-clipped tiles).
+                // TODO(gw): Convert to 2d array temporarily to avoid hash lookups per-tile?
+                let key = TileKey {
+                    slice: self.slice,
+                    offset: TileOffset::new(x, y),
+                };
+                let tile = self.tiles.get_mut(&key).expect("bug: no tile");
+
+                // Check if this tile becomes opaque due to this primitive.
+                if !tile.is_opaque {
+                    if let Some(ref opaque_rect) = opaque_rect {
+                        if opaque_rect.contains_rect(&tile.clipped_rect) {
+                            tile.is_opaque = true;
+                        }
+                    }
+                }
 
                 // Mark if the tile is cacheable at all.
                 tile.is_same_content &= is_cacheable;
@@ -1347,18 +1041,52 @@
                 // // Include any opacity bindings this primitive depends on.
                 tile.descriptor.opacity_bindings.extend_from_slice(&opacity_bindings);
 
+                // TODO(gw): The origin of background rects produced by APZ changes
+                //           in Gecko during scrolling. Consider investigating this so the
+                //           hack / workaround below is not required.
+                let (prim_origin, prim_clip_rect) = if clip_by_tile {
+                    let tile_p0 = tile.clipped_rect.origin;
+                    let tile_p1 = tile.clipped_rect.bottom_right();
+
+                    let clip_p0 = PicturePoint::new(
+                        clampf(prim_clip_rect.origin.x, tile_p0.x, tile_p1.x),
+                        clampf(prim_clip_rect.origin.y, tile_p0.y, tile_p1.y),
+                    );
+
+                    let clip_p1 = PicturePoint::new(
+                        clampf(prim_clip_rect.origin.x + prim_clip_rect.size.width, tile_p0.x, tile_p1.x),
+                        clampf(prim_clip_rect.origin.y + prim_clip_rect.size.height, tile_p0.y, tile_p1.y),
+                    );
+
+                    (
+                        PicturePoint::new(
+                            clampf(prim_rect.origin.x, tile_p0.x, tile_p1.x),
+                            clampf(prim_rect.origin.y, tile_p0.y, tile_p1.y),
+                        ),
+                        PictureRect::new(
+                            clip_p0,
+                            PictureSize::new(
+                                clip_p1.x - clip_p0.x,
+                                clip_p1.y - clip_p0.y,
+                            ),
+                        ),
+                    )
+                } else {
+                    (prim_rect.origin, prim_clip_rect)
+                };
+
                 // Update the tile descriptor, used for tile comparison during scene swaps.
                 tile.descriptor.prims.push(PrimitiveDescriptor {
                     prim_uid: prim_instance.uid(),
-                    origin: (world_rect.origin - tile.world_rect.origin.to_vector()).round(),
+                    origin: prim_origin.into(),
                     first_clip: tile.descriptor.clip_uids.len() as u16,
                     clip_count: clip_chain_uids.len() as u16,
-                    world_culling_rect,
+                    prim_clip_rect: prim_clip_rect.into(),
                 });
+
                 tile.descriptor.clip_uids.extend_from_slice(&clip_chain_uids);
                 for clip_vertex in &clip_vertices {
-                    let clip_vertex = (*clip_vertex - tile.world_rect.origin.to_vector()).round();
-                    tile.descriptor.clip_vertices.push(clip_vertex.into());
+                    tile.descriptor.clip_vertices.push((*clip_vertex).into());
                 }
 
                 // If the primitive has the same spatial node, the relative transform
@@ -1366,13 +1094,9 @@
                 if prim_instance.spatial_node_index != self.spatial_node_index {
                     tile.transforms.insert(prim_instance.spatial_node_index);
                 }
-
                 for spatial_node_index in &clip_spatial_nodes {
                     tile.transforms.insert(*spatial_node_index);
                 }
-                for (world_rect, spatial_node_index) in &world_clips {
-                    tile.potential_clips.insert(world_rect.clone(), *spatial_node_index);
-                }
             }
         }
 
@@ -1389,42 +1113,17 @@
         frame_context: &FrameVisibilityContext,
         scratch: &mut PrimitiveScratchBuffer,
     ) {
+        self.tiles_to_draw.clear();
         self.dirty_region.clear();
-        self.pending_blits.clear();
-
-        // If the tile cache is disabled, just return a no-op local clip rect.
-        if !self.is_enabled {
-            return;
-        }
-
-        // Skip all tiles if completely off-screen.
-        if !self.world_bounding_rect.intersects(&frame_context.screen_world_rect) {
-            return;
-        }
-
-        let map_surface_to_world: SpaceMapper<LayoutPixel, WorldPixel> = SpaceMapper::new_with_target(
-            ROOT_SPATIAL_NODE_INDEX,
-            self.spatial_node_index,
-            frame_context.screen_world_rect,
-            frame_context.clip_scroll_tree,
-        );
-
-        self.local_clip_rect = map_surface_to_world
-            .unmap(&self.world_bounding_rect)
-            .expect("bug: unable to map local clip rect");
+        let mut dirty_region_index = 0;
+
+        // Track if all tiles are detected as opaque. Only when this occurs will
+        // we allow subpixel AA on this surface.
+        self.is_opaque = true;
 
         // Step through each tile and invalidate if the dependencies have changed.
-        for (i, tile) in self.tiles.iter_mut().enumerate() {
-            // Deal with any potential world clips. Check to see if they are
-            // outside the tile cache bounding rect. If they are, they're not
-            // relevant and we don't care if they move relative to the content
-            // itself. This avoids a lot of redundant invalidations.
-            for (clip_world_rect, spatial_node_index) in &tile.potential_clips {
-                let clip_world_rect = WorldRect::from(clip_world_rect.clone());
-                if !clip_world_rect.contains_rect(&self.world_bounding_rect) {
-                    tile.transforms.insert(*spatial_node_index);
-                }
-            }
+        for (key, tile) in self.tiles.iter_mut() {
+            self.is_opaque &= tile.is_opaque;
 
             // Update tile transforms
             let mut transform_spatial_nodes: Vec<SpatialNodeIndex> = tile.transforms.drain().collect();
@@ -1432,29 +1131,20 @@
             for spatial_node_index in transform_spatial_nodes {
                 // Note: this is the only place where we don't know beforehand if the tile-affecting
                 // spatial node is below or above the current picture.
-                let inverse_origin = if self.spatial_node_index >= spatial_node_index {
+                let transform = if self.spatial_node_index >= spatial_node_index {
                     frame_context.clip_scroll_tree
                         .get_relative_transform(
                             self.spatial_node_index,
                             spatial_node_index,
                         )
-                        .project_2d_origin()
                 } else {
                     frame_context.clip_scroll_tree
                         .get_relative_transform(
                             spatial_node_index,
                             self.spatial_node_index,
                         )
-                        .inverse_project_2d_origin()
                 };
-                // Store the result of transforming a fixed point by this
-                // transform.
-                // TODO(gw): This could in theory give incorrect results for a
-                //           primitive behind the near plane.
-                let key = inverse_origin
-                    .unwrap_or_else(LayoutPoint::zero)
-                    .round();
-                tile.descriptor.transforms.push(key.into());
+                tile.descriptor.transforms.push(transform.into());
             }
 
             // Invalidate if the backing texture was evicted.
@@ -1469,146 +1159,95 @@
                 // TODO(gw): Consider switching to manual eviction policy?
                 resource_cache.texture_cache.request(&tile.handle, gpu_cache);
             } else {
+                // When a tile is invalidated, reset the opacity information
+                // so that it is recalculated during prim dependency updates.
                 tile.is_valid = false;
             }
 
             // Invalidate the tile based on the content changing.
             tile.update_content_validity();
 
-            let visible_rect = match tile.visible_rect {
-                Some(rect) => rect,
-                None => continue,
-            };
-
-            // Check the valid rect of the primitive is sufficient.
-            let tile_bounding_rect = match visible_rect.intersection(&self.world_bounding_rect) {
-                Some(rect) => rect.translate(&-tile.world_rect.origin.to_vector()),
-                None => continue,
-            };
-
-            tile.update_rect_validity(&tile_bounding_rect);
-
             // If there are no primitives there is no need to draw or cache it.
             if tile.descriptor.prims.is_empty() {
                 continue;
             }
 
+            if !tile.world_rect.intersects(&frame_context.global_screen_world_rect) {
+                continue;
+            }
+
+            self.tiles_to_draw.push(*key);
+
             // Decide how to handle this tile when drawing this frame.
             if tile.is_valid {
-                // No need to include this is any dirty rect calculations.
-                tile.consider_for_dirty_rect = false;
-                self.tiles_to_draw.push(TileIndex(i));
-
                 if frame_context.debug_flags.contains(DebugFlags::PICTURE_CACHING_DBG) {
-                    if let Some(world_rect) = tile.world_rect.intersection(&self.world_bounding_rect) {
-                        let tile_device_rect = world_rect * frame_context.global_device_pixel_scale;
-                        let mut label_offset = DeviceVector2D::new(20.0, 30.0);
-                        scratch.push_debug_rect(
-                            tile_device_rect,
-                            debug_colors::GREEN,
+                    let tile_device_rect = tile.world_rect * frame_context.global_device_pixel_scale;
+                    let label_offset = DeviceVector2D::new(20.0, 30.0);
+                    let color = if tile.is_opaque {
+                        debug_colors::GREEN
+                    } else {
+                        debug_colors::YELLOW
+                    };
+                    scratch.push_debug_rect(
+                        tile_device_rect,
+                        color.scale_alpha(0.3),
+                    );
+                    if tile_device_rect.size.height >= label_offset.y {
+                        scratch.push_debug_string(
+                            tile_device_rect.origin + label_offset,
+                            debug_colors::RED,
+                            format!("{:?}: is_opaque={}", tile.id, tile.is_opaque),
                         );
-                        if tile_device_rect.size.height >= label_offset.y {
-                            scratch.push_debug_string(
-                                tile_device_rect.origin + label_offset,
-                                debug_colors::RED,
-                                format!("{:?} {:?} {:?}", tile.id, tile.handle, tile.world_rect),
-                            );
-                        }
-                        label_offset.y += 20.0;
-                        if tile_device_rect.size.height >= label_offset.y {
-                            scratch.push_debug_string(
-                                tile_device_rect.origin + label_offset,
-                                debug_colors::RED,
-                                format!("same: {} frames", tile.same_frames),
-                            );
-                        }
                     }
                 }
             } else {
                 if frame_context.debug_flags.contains(DebugFlags::PICTURE_CACHING_DBG) {
-                    if let Some(world_rect) = visible_rect.intersection(&self.world_bounding_rect) {
-                        scratch.push_debug_rect(
-                            world_rect * frame_context.global_device_pixel_scale,
-                            debug_colors::RED,
-                        );
-                    }
+                    scratch.push_debug_rect(
+                        tile.world_rect * frame_context.global_device_pixel_scale,
+                        debug_colors::RED,
+                    );
+                }
+
+                // Ensure that this texture is allocated.
+                if !resource_cache.texture_cache.is_allocated(&tile.handle) {
+                    resource_cache.texture_cache.update_picture_cache(
+                        &mut tile.handle,
+                        gpu_cache,
+                    );
                 }
 
-                // Only cache tiles that have had the same content for at least two
-                // frames. This skips caching on pages / benchmarks that are changing
-                // every frame, which is wasteful.
-                // When we are testing invalidation, we want WR to try to cache tiles each
-                // frame, to make it simpler to define the expected dirty rects.
-                if tile.same_frames >= FRAMES_BEFORE_PICTURE_CACHING || frame_context.config.testing {
-                    // Ensure that this texture is allocated.
-                    if !resource_cache.texture_cache.is_allocated(&tile.handle) {
-                        resource_cache.texture_cache.update_picture_cache(
-                            &mut tile.handle,
-                            gpu_cache,
-                        );
-                    }
-
-                    let cache_item = resource_cache
-                        .get_texture_cache_item(&tile.handle);
-
-                    let src_origin = (visible_rect.origin * frame_context.global_device_pixel_scale).round().to_i32();
-                    let valid_rect = visible_rect.translate(&-tile.world_rect.origin.to_vector());
-
-                    tile.valid_rect = visible_rect
-                        .intersection(&self.world_bounding_rect)
-                        .map(|rect| rect.translate(&-tile.world_rect.origin.to_vector()))
-                        .unwrap_or_else(WorldRect::zero);
-
-                    // Store a blit operation to be done after drawing the
-                    // frame in order to update the cached texture tile.
-                    let dest_rect = (valid_rect * frame_context.global_device_pixel_scale).round().to_i32();
-                    self.pending_blits.push(TileBlit {
-                        target: cache_item,
-                        src_offset: src_origin,
-                        dest_offset: dest_rect.origin,
-                        size: dest_rect.size,
-                    });
-
-                    // We can consider this tile valid now.
-                    tile.is_valid = true;
+                tile.visibility_mask = PrimitiveVisibilityMask::empty();
+
+                // If we run out of dirty regions, then force the last dirty region to
+                // be a union of any remaining regions. This is an inefficiency, in that
+                // we'll add items to batches later on that are redundant / outside this
+                // tile, but it's really rare except in pathological cases (even on a
+                // 4k screen, the typical dirty region count is < 16).
+                if dirty_region_index < PrimitiveVisibilityMask::MAX_DIRTY_REGIONS {
+                    tile.visibility_mask.set_visible(dirty_region_index);
+
+                    self.dirty_region.push(
+                        tile.world_rect,
+                        tile.visibility_mask,
+                    );
+
+                    dirty_region_index += 1;
+                } else {
+                    tile.visibility_mask.set_visible(PrimitiveVisibilityMask::MAX_DIRTY_REGIONS - 1);
+
+                    self.dirty_region.include_rect(
+                        PrimitiveVisibilityMask::MAX_DIRTY_REGIONS - 1,
+                        tile.world_rect,
+                    );
                 }
-
-                // This tile should be considered as part of the dirty rect calculations.
-                tile.consider_for_dirty_rect = true;
             }
         }
 
-        // Build a minimal set of dirty rects from the set of dirty tiles that
-        // were found above.
-        let mut builder = DirtyRegionBuilder::new(
-            &mut self.tiles,
-            self.tile_count,
-        );
-
-        builder.build(&mut self.dirty_region);
-
         // When under test, record a copy of the dirty region to support
         // invalidation testing in wrench.
         if frame_context.config.testing {
             scratch.recorded_dirty_regions.push(self.dirty_region.record());
         }
-
-        // If we end up with too many dirty rects, then it's going to be a lot
-        // of extra draw calls to submit (since we currently just submit every
-        // draw call for every dirty rect). In this case, bail out and work
-        // with a single, large dirty rect. In future we can consider improving
-        // on this by supporting batching per dirty region.
-        if self.dirty_region.dirty_rects.len() > MAX_DIRTY_RECTS {
-            self.dirty_region.collapse();
-        }
-    }
-
-    pub fn tile_dimensions(testing: bool) -> DeviceIntSize {
-        if testing {
-            size2(TILE_SIZE_TESTING, TILE_SIZE_TESTING)
-        } else {
-            size2(TILE_SIZE_WIDTH, TILE_SIZE_HEIGHT)
-        }
     }
 }
 
@@ -1806,8 +1445,6 @@
     pub inflation_factor: f32,
     /// The device pixel ratio specific to this surface.
     pub device_pixel_scale: DevicePixelScale,
-    /// If true, subpixel AA rendering can be used on this surface.
-    pub allow_subpixel_aa: bool,
 }
 
 impl SurfaceInfo {
@@ -1818,7 +1455,6 @@
         world_rect: WorldRect,
         clip_scroll_tree: &ClipScrollTree,
         device_pixel_scale: DevicePixelScale,
-        allow_subpixel_aa: bool,
     ) -> Self {
         let map_surface_to_world = SpaceMapper::new_with_target(
             ROOT_SPATIAL_NODE_INDEX,
@@ -1844,7 +1480,6 @@
             surface_spatial_node_index,
             inflation_factor,
             device_pixel_scale,
-            allow_subpixel_aa,
         }
     }
 }
@@ -1892,7 +1527,6 @@
     Blit(BlitReason),
     /// Used to cache a picture as a series of tiles.
     TileCache {
-        clear_color: ColorF,
     },
 }
 
@@ -2042,37 +1676,51 @@
                 }
             };
 
-            let prim_data = match prim_instance.kind {
+            let (is_backface_visible, prim_size) = match prim_instance.kind {
                 PrimitiveInstanceKind::Rectangle { data_handle, .. } |
                 PrimitiveInstanceKind::Clear { data_handle, .. } => {
-                    &interners.prim[data_handle]
+                    let data = &interners.prim[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::Image { data_handle, .. } => {
-                    &interners.image[data_handle]
+                    let data = &interners.image[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::ImageBorder { data_handle, .. } => {
-                    &interners.image_border[data_handle]
+                    let data = &interners.image_border[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::LineDecoration { data_handle, .. } => {
-                    &interners.line_decoration[data_handle]
+                    let data = &interners.line_decoration[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::LinearGradient { data_handle, .. } => {
-                    &interners.linear_grad[data_handle]
+                    let data = &interners.linear_grad[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::NormalBorder { data_handle, .. } => {
-                    &interners.normal_border[data_handle]
+                    let data = &interners.normal_border[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::Picture { data_handle, .. } => {
-                    &interners.picture[data_handle]
+                    let data = &interners.picture[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::RadialGradient { data_handle, ..} => {
-                    &interners.radial_grad[data_handle]
+                    let data = &interners.radial_grad[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::TextRun { data_handle, .. } => {
-                    &interners.text_run[data_handle]
+                    let data = &interners.text_run[data_handle];
+                    (data.is_backface_visible, data.prim_size)
                 }
                 PrimitiveInstanceKind::YuvImage { data_handle, .. } => {
-                    &interners.yuv_image[data_handle]
+                    let data = &interners.yuv_image[data_handle];
+                    (data.is_backface_visible, data.prim_size)
+                }
+                PrimitiveInstanceKind::PushClipChain |
+                PrimitiveInstanceKind::PopClipChain => {
+                    (true, LayoutSize::zero())
                 }
             };
 
@@ -2080,7 +1728,7 @@
             // belong to.
             let key = PrimitiveClusterKey {
                 spatial_node_index: prim_instance.spatial_node_index,
-                is_backface_visible: prim_data.is_backface_visible,
+                is_backface_visible,
             };
 
             // Find the cluster, or create a new one.
@@ -2090,7 +1738,7 @@
                     let index = clusters.len();
                     clusters.push(PrimitiveCluster::new(
                         prim_instance.spatial_node_index,
-                        prim_data.is_backface_visible,
+                        is_backface_visible,
                     ));
                     index
                 }
@@ -2103,7 +1751,7 @@
             if !is_pic {
                 let prim_rect = LayoutRect::new(
                     prim_instance.prim_origin,
-                    prim_data.prim_size,
+                    prim_size,
                 );
                 let culling_rect = prim_instance.local_clip_rect
                     .intersection(&prim_rect)
@@ -2147,9 +1795,6 @@
     #[cfg_attr(feature = "capture", serde(skip))]
     pub state: Option<PictureState>,
 
-    /// The pipeline that the primitives on this picture belong to.
-    pub pipeline_id: PipelineId,
-
     /// If true, apply the local clip rect to primitive drawn
     /// in this picture.
     pub apply_local_clip_rect: bool,
@@ -2207,7 +1852,7 @@
 
     /// If Some(..) the tile cache that is associated with this picture.
     #[cfg_attr(feature = "capture", serde(skip))] //TODO
-    pub tile_cache: Option<Box<TileCache>>,
+    pub tile_cache: Option<Box<TileCacheInstance>>,
 
     /// The config options for this picture.
     options: PictureOptions,
@@ -2286,17 +1931,8 @@
     pub fn destroy(
         &mut self,
         retained_tiles: &mut RetainedTiles,
-        clip_scroll_tree: &ClipScrollTree,
     ) {
         if let Some(tile_cache) = self.tile_cache.take() {
-            // Calculate and store positions of the reference
-            // primitives for this tile cache.
-            build_ref_prims(
-                &tile_cache.reference_prims.ref_prims,
-                &mut retained_tiles.ref_prims,
-                clip_scroll_tree,
-            );
-
             retained_tiles.tiles.extend(tile_cache.tiles);
         }
     }
@@ -2308,14 +1944,13 @@
     pub fn new_image(
         requested_composite_mode: Option<PictureCompositeMode>,
         context_3d: Picture3DContext<OrderedPictureChild>,
-        pipeline_id: PipelineId,
         frame_output_pipeline_id: Option<PipelineId>,
         apply_local_clip_rect: bool,
         is_backface_visible: bool,
         requested_raster_space: RasterSpace,
         prim_list: PrimitiveList,
         spatial_node_index: SpatialNodeIndex,
-        tile_cache: Option<Box<TileCache>>,
+        tile_cache: Option<Box<TileCacheInstance>>,
         options: PictureOptions,
     ) -> Self {
         PicturePrimitive {
@@ -2329,7 +1964,6 @@
             extra_gpu_data_handles: SmallVec::new(),
             apply_local_clip_rect,
             is_backface_visible,
-            pipeline_id,
             requested_raster_space,
             spatial_node_index,
             snapped_local_rect: LayoutRect::zero(),
@@ -2369,6 +2003,7 @@
         surface_spatial_node_index: SpatialNodeIndex,
         raster_spatial_node_index: SpatialNodeIndex,
         parent_surface_index: SurfaceIndex,
+        parent_subpixel_mode: SubpixelMode,
         frame_state: &mut FrameBuildingState,
         frame_context: &FrameBuildingContext,
     ) -> Option<(PictureContext, PictureState, PrimitiveList)> {
@@ -2403,7 +2038,7 @@
         let map_pic_to_world = SpaceMapper::new_with_target(
             ROOT_SPATIAL_NODE_INDEX,
             surface_spatial_node_index,
-            frame_context.screen_world_rect,
+            frame_context.global_screen_world_rect,
             frame_context.clip_scroll_tree,
         );
 
@@ -2418,7 +2053,7 @@
         let (map_raster_to_world, map_pic_to_raster) = create_raster_mappers(
             surface_spatial_node_index,
             raster_spatial_node_index,
-            frame_context.screen_world_rect,
+            frame_context.global_screen_world_rect,
             frame_context.clip_scroll_tree,
         );
 
@@ -2434,25 +2069,7 @@
             }
         };
 
-        let (is_composite, is_passthrough) = match self.raster_config {
-            Some(ref rc @ RasterConfig { composite_mode: PictureCompositeMode::TileCache { .. }, .. }) => {
-                // For a picture surface, just push any child tasks and tile
-                // blits up to the parent surface.
-                let port = frame_state
-                    .surfaces[parent_surface_index.0]
-                    .render_tasks
-                    .expect("bug: no render tasks set for parent!")
-                    .port;
-
-                frame_state
-                    .surfaces[rc.surface_index.0]
-                    .render_tasks = Some(SurfaceRenderTasks {
-                        root: RenderTaskId::INVALID,
-                        port,
-                    });
-
-                (false, false)
-            },
+        match self.raster_config {
             Some(ref raster_config) => {
                 let pic_rect = PictureRect::from_untyped(&self.snapped_local_rect.to_untyped());
 
@@ -2474,10 +2091,7 @@
                 };
                 let transform = map_pic_to_raster.get_transform();
 
-                let (root, port) = match raster_config.composite_mode {
-                    PictureCompositeMode::TileCache { .. } => {
-                        unreachable!();
-                    }
+                let dep_info = match raster_config.composite_mode {
                     PictureCompositeMode::Filter(Filter::Blur(blur_radius)) => {
                         let blur_std_deviation = blur_radius * device_pixel_scale.0;
                         let scale_factors = scale_factors(&transform);
@@ -2522,9 +2136,9 @@
                             pic_index,
                             device_rect.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
 
                         let picture_task_id = frame_state.render_tasks.add(picture_task);
@@ -2538,7 +2152,7 @@
                             None,
                         );
 
-                        (blur_render_task_id, picture_task_id)
+                        Some((blur_render_task_id, picture_task_id))
                     }
                     PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
                         let mut max_std_deviation = 0.0;
@@ -2572,9 +2186,9 @@
                             pic_index,
                             device_rect.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
                         picture_task.mark_for_saving();
 
@@ -2600,7 +2214,7 @@
                         }
 
                         // TODO(nical) the second one should to be the blur's task id but we have several blurs now
-                        (blur_render_task_id, picture_task_id)
+                        Some((blur_render_task_id, picture_task_id))
                     }
                     PictureCompositeMode::MixBlend(..) if !frame_context.fb_config.gpu_supports_advanced_blend => {
                         let uv_rect_kind = calculate_uv_rect_kind(
@@ -2617,9 +2231,9 @@
                             pic_index,
                             clipped.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
 
                         let readback_task_id = frame_state.render_tasks.add(
@@ -2635,7 +2249,7 @@
 
                         let render_task_id = frame_state.render_tasks.add(picture_task);
 
-                        (render_task_id, render_task_id)
+                        Some((render_task_id, render_task_id))
                     }
                     PictureCompositeMode::Filter(..) => {
                         let uv_rect_kind = calculate_uv_rect_kind(
@@ -2652,14 +2266,14 @@
                             pic_index,
                             clipped.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
 
                         let render_task_id = frame_state.render_tasks.add(picture_task);
 
-                        (render_task_id, render_task_id)
+                        Some((render_task_id, render_task_id))
                     }
                     PictureCompositeMode::ComponentTransferFilter(..) => {
                         let uv_rect_kind = calculate_uv_rect_kind(
@@ -2676,14 +2290,75 @@
                             pic_index,
                             clipped.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
 
                         let render_task_id = frame_state.render_tasks.add(picture_task);
 
-                        (render_task_id, render_task_id)
+                        Some((render_task_id, render_task_id))
+                    }
+                    PictureCompositeMode::TileCache { .. } => {
+                        let tile_cache = self.tile_cache.as_mut().unwrap();
+                        let mut first = true;
+
+                        let tile_size = DeviceSize::new(
+                            TILE_SIZE_WIDTH as f32,
+                            TILE_SIZE_HEIGHT as f32,
+                        );
+
+                        for key in &tile_cache.tiles_to_draw {
+                            let tile = tile_cache.tiles.get_mut(key).expect("bug: no tile found!");
+
+                            if tile.is_valid {
+                                continue;
+                            }
+
+                            // TODO(gw): Is this ever fractional? Can that cause seams?
+                            let content_origin = (tile.world_rect.origin * device_pixel_scale)
+                                .round().to_i32();
+
+                            let cache_item = frame_state.resource_cache.texture_cache.get(&tile.handle);
+
+                            let task = RenderTask::new_picture(
+                                RenderTaskLocation::PictureCache {
+                                    texture: cache_item.texture_id,
+                                    layer: cache_item.texture_layer,
+                                    size: tile_size.to_i32(),
+                                },
+                                tile_size,
+                                pic_index,
+                                content_origin,
+                                UvRectKind::Rect,
+                                surface_spatial_node_index,
+                                device_pixel_scale,
+                                tile.visibility_mask,
+                            );
+
+                            let render_task_id = frame_state.render_tasks.add(task);
+
+                            frame_state.render_tasks.add_dependency(
+                                frame_state.surfaces[parent_surface_index.0].render_tasks.unwrap().port,
+                                render_task_id,
+                            );
+
+                            if first {
+                                // TODO(gw): Maybe we can restructure this code to avoid the
+                                //           first hack here. Or at least explain it with a follow up
+                                //           bug.
+                                frame_state.surfaces[raster_config.surface_index.0].render_tasks = Some(SurfaceRenderTasks {
+                                    root: render_task_id,
+                                    port: render_task_id,
+                                });
+
+                                first = false;
+                            }
+
+                            tile.is_valid = true;
+                        }
+
+                        None
                     }
                     PictureCompositeMode::MixBlend(..) |
                     PictureCompositeMode::Blit(_) => {
@@ -2708,32 +2383,30 @@
                             pic_index,
                             clipped.origin,
                             uv_rect_kind,
-                            raster_spatial_node_index,
                             surface_spatial_node_index,
                             device_pixel_scale,
+                            PrimitiveVisibilityMask::all(),
                         );
 
                         let render_task_id = frame_state.render_tasks.add(picture_task);
 
-                        (render_task_id, render_task_id)
+                        Some((render_task_id, render_task_id))
                     }
                 };
 
-                frame_state.surfaces[raster_config.surface_index.0].render_tasks = Some(SurfaceRenderTasks {
-                    root,
-                    port,
-                });
-
-                frame_state.render_tasks.add_dependency(
-                    frame_state.surfaces[parent_surface_index.0].render_tasks.unwrap().port,
-                    root,
-                );
-
-                (true, false)
+                if let Some((root, port)) = dep_info {
+                    frame_state.surfaces[raster_config.surface_index.0].render_tasks = Some(SurfaceRenderTasks {
+                        root,
+                        port,
+                    });
+
+                    frame_state.render_tasks.add_dependency(
+                        frame_state.surfaces[parent_surface_index.0].render_tasks.unwrap().port,
+                        root,
+                    );
+                }
             }
-            None => {
-                (false, true)
-            }
+            None => {}
         };
 
         let state = PictureState {
@@ -2749,13 +2422,10 @@
 
         // If this is a picture cache, push the dirty region to ensure any
         // child primitives are culled and clipped to the dirty rect(s).
-        if let Some(ref tile_cache) = self.tile_cache {
-            // If the tile cache is disabled, it doesn't have a valid
-            // dirty region to exclude primitives from.
-            if tile_cache.is_enabled {
-                frame_state.push_dirty_region(tile_cache.dirty_region.clone());
-                dirty_region_count += 1;
-            }
+        if let Some(RasterConfig { composite_mode: PictureCompositeMode::TileCache { .. }, .. }) = self.raster_config {
+            let dirty_region = self.tile_cache.as_ref().unwrap().dirty_region.clone();
+            frame_state.push_dirty_region(dirty_region);
+            dirty_region_count += 1;
         }
 
         if inflation_factor > 0.0 {
@@ -2764,15 +2434,48 @@
             dirty_region_count += 1;
         }
 
+        // Disallow subpixel AA if an intermediate surface is needed.
+        // TODO(lsalzman): allow overriding parent if intermediate surface is opaque
+        let (is_passthrough, subpixel_mode) = match self.raster_config {
+            Some(RasterConfig { ref composite_mode, .. }) => {
+                let subpixel_mode = match composite_mode {
+                    PictureCompositeMode::TileCache { .. } => {
+                        // TODO(gw): Maintaining old behaviour, we know that any slice
+                        //           that was created is allowed to have subpixel text on it.
+                        //           Once we enable multiple slices, we'll need to handle this
+                        //           condition properly.
+                        SubpixelMode::Allow
+                    }
+                    PictureCompositeMode::Blit(..) |
+                    PictureCompositeMode::ComponentTransferFilter(..) |
+                    PictureCompositeMode::Filter(..) |
+                    PictureCompositeMode::MixBlend(..) => {
+                        SubpixelMode::Deny
+                    }
+                };
+
+                (false, subpixel_mode)
+            }
+            None => {
+                (true, SubpixelMode::Allow)
+            }
+        };
+
+        // Still disable subpixel AA if parent forbids it
+        let subpixel_mode = match (parent_subpixel_mode, subpixel_mode) {
+            (SubpixelMode::Allow, SubpixelMode::Allow) => SubpixelMode::Allow,
+            _ => SubpixelMode::Deny,
+        };
+
         let context = PictureContext {
             pic_index,
             apply_local_clip_rect: self.apply_local_clip_rect,
-            is_composite,
             is_passthrough,
             raster_spatial_node_index,
             surface_spatial_node_index,
             surface_index,
             dirty_region_count,
+            subpixel_mode,
         };
 
         let prim_list = mem::replace(&mut self.prim_list, PrimitiveList::empty());
@@ -2954,15 +2657,25 @@
         // See if this picture actually needs a surface for compositing.
         let actual_composite_mode = match self.requested_composite_mode {
             Some(PictureCompositeMode::Filter(ref filter)) if filter.is_noop() => None,
+            Some(PictureCompositeMode::TileCache { .. }) => {
+                // Disable tile cache if the scroll root has a perspective transform, since
+                // this breaks many assumptions (it's a very rare edge case anyway, and
+                // is probably (?) going to be moving / animated in this case).
+                let spatial_node = &frame_context
+                    .clip_scroll_tree
+                    .spatial_nodes[self.spatial_node_index.0 as usize];
+                if spatial_node.coordinate_system_id == CoordinateSystemId::root() {
+                    Some(PictureCompositeMode::TileCache { })
+                } else {
+                    None
+                }
+            },
             ref mode => mode.clone(),
         };
 
         if let Some(composite_mode) = actual_composite_mode {
             // Retrieve the positioning node information for the parent surface.
-            let (parent_raster_node_index, parent_allows_subpixel_aa)= {
-                let parent_surface = state.current_surface();
-                (parent_surface.raster_spatial_node_index, parent_surface.allow_subpixel_aa)
-            };
+            let parent_raster_node_index = state.current_surface().raster_spatial_node_index;
             let surface_spatial_node_index = self.spatial_node_index;
 
             // This inflation factor is to be applied to all primitives within the surface.
@@ -2989,24 +2702,6 @@
                 .get_relative_transform(surface_spatial_node_index, parent_raster_node_index)
                 .is_perspective();
 
-            // Disallow subpixel AA if an intermediate surface is needed.
-            // TODO(lsalzman): allow overriding parent if intermediate surface is opaque
-            let allow_subpixel_aa = match composite_mode {
-                PictureCompositeMode::TileCache { clear_color, .. } => {
-                    // If the tile cache has an opaque background, then it's fine to use
-                    // subpixel rendering (this is the common case).
-                    clear_color.a >= 1.0
-                }
-                PictureCompositeMode::Blit(..) |
-                PictureCompositeMode::ComponentTransferFilter(..) |
-                PictureCompositeMode::Filter(..) |
-                PictureCompositeMode::MixBlend(..) => {
-                    false
-                }
-            };
-            // Still disable subpixel AA if parent forbids it
-            let allow_subpixel_aa = parent_allows_subpixel_aa && allow_subpixel_aa;
-
             let surface = SurfaceInfo::new(
                 surface_spatial_node_index,
                 if establishes_raster_root {
@@ -3015,10 +2710,9 @@
                     parent_raster_node_index
                 },
                 inflation_factor,
-                frame_context.screen_world_rect,
+                frame_context.global_screen_world_rect,
                 &frame_context.clip_scroll_tree,
                 frame_context.global_device_pixel_scale,
-                allow_subpixel_aa,
             );
 
             self.raster_config = Some(RasterConfig {
@@ -3364,76 +3058,3 @@
 
     (map_raster_to_world, map_pic_to_raster)
 }
-
-// Convert a list of reference primitives into a map of prim uid -> world position.
-fn build_ref_prims(
-    ref_prims: &[ReferencePrimitive],
-    prim_map: &mut FastHashMap<ItemUid, WorldPoint>,
-    clip_scroll_tree: &ClipScrollTree,
-) {
-    prim_map.clear();
-
-    let mut map_local_to_world = SpaceMapper::new(
-        ROOT_SPATIAL_NODE_INDEX,
-        WorldRect::zero(),
-    );
-
-    for ref_prim in ref_prims {
-        map_local_to_world.set_target_spatial_node(
-            ref_prim.spatial_node_index,
-            clip_scroll_tree,
-        );
-
-        // We only care about the origin.
-        // TODO(gw): Consider adding a map_point to SpaceMapper.
-        let rect = LayoutRect::new(
-            ref_prim.local_pos,
-            LayoutSize::zero(),
-        );
-
-        if let Some(rect) = map_local_to_world.map(&rect) {
-            prim_map.insert(ref_prim.uid, rect.origin);
-        }
-    }
-}
-
-// Attempt to correlate the offset between two display lists by
-// comparing the offsets between a small number of primitives in
-// each display list.
-// TODO(gw): This is basically a horrible hack - there must be a better
-//           way to achieve this!
-fn correlate_prim_maps(
-    old_prims: &FastHashMap<ItemUid, WorldPoint>,
-    new_prims: &FastHashMap<ItemUid, WorldPoint>,
-) -> Option<WorldVector2D> {
-    let mut map: FastHashMap<VectorKey, usize> = FastHashMap::default();
-
-    // Find primitives with the same uid, find the difference
-    // between them and store the frequency of this offset
-    // in a hash map.
-    for (uid, old_point) in old_prims {
-        if let Some(new_point) = new_prims.get(uid) {
-            let key = (*new_point - *old_point).round().into();
-
-            let key_count = map.entry(key).or_insert(0);
-            *key_count += 1;
-        }
-    }
-
-    // Calculate the mode (the most common frequency of offset). This
-    // can be different for some primitives, if they've animated, or
-    // are attached to a different scroll node etc.
-    map.into_iter()
-        .max_by_key(|&(_, count)| count)
-        .and_then(|(offset, count)| {
-            // We will assume we can use the calculated offset if we
-            // found more than one quarter of the selected reference
-            // primitives to have the same offset.
-            let prims_available = new_prims.len().min(old_prims.len());
-            if count >= prims_available / 4 {
-                Some(offset.into())
-            } else {
-                None
-            }
-        })
-}