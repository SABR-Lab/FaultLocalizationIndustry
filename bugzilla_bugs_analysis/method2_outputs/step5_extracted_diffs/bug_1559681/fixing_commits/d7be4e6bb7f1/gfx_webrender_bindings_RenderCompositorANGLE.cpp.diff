# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/webrender_bindings/RenderCompositorANGLE.cpp
# Commit: d7be4e6bb7f1
# Full Hash: d7be4e6bb7f108cca7e643fdb47ffad1bded1775
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2019-06-26 21:52:21
# Description:
#   Bug 1559681 - Repair device-reset handling in RenderCompositorANGLE. r=sotaro
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D35882
# ==============================================================================

diff -r 88184dadb61a -r d7be4e6bb7f1 gfx/webrender_bindings/RenderCompositorANGLE.cpp
--- a/gfx/webrender_bindings/RenderCompositorANGLE.cpp	Wed Jun 26 15:34:14 2019 +0000
+++ b/gfx/webrender_bindings/RenderCompositorANGLE.cpp	Wed Jun 26 06:03:23 2019 +0000
@@ -38,11 +38,8 @@
     return nullptr;
   }
 
-  const auto& gle = gl::GLContextEGL::Cast(gl);
-  const auto& egl = gle->mEgl;
-
   UniquePtr<RenderCompositorANGLE> compositor =
-      MakeUnique<RenderCompositorANGLE>(std::move(aWidget), egl);
+      MakeUnique<RenderCompositorANGLE>(std::move(aWidget));
   if (!compositor->Initialize()) {
     return nullptr;
   }
@@ -50,14 +47,11 @@
 }
 
 RenderCompositorANGLE::RenderCompositorANGLE(
-    RefPtr<widget::CompositorWidget>&& aWidget, gl::GLLibraryEGL* const egl)
+    RefPtr<widget::CompositorWidget>&& aWidget)
     : RenderCompositor(std::move(aWidget)),
-      mEgl(egl),
       mEGLConfig(nullptr),
       mEGLSurface(nullptr),
-      mUseTripleBuffering(false) {
-  MOZ_ASSERT(mEgl);
-}
+      mUseTripleBuffering(false) {}
 
 RenderCompositorANGLE::~RenderCompositorANGLE() {
   DestroyEGLSurface();
@@ -65,20 +59,20 @@
 }
 
 ID3D11Device* RenderCompositorANGLE::GetDeviceOfEGLDisplay() {
-  MOZ_ASSERT(mEgl);
-  if (!mEgl ||
-      !mEgl->IsExtensionSupported(gl::GLLibraryEGL::EXT_device_query)) {
+  auto* egl = gl::GLLibraryEGL::Get();
+  MOZ_ASSERT(egl);
+  if (!egl || !egl->IsExtensionSupported(gl::GLLibraryEGL::EXT_device_query)) {
     return nullptr;
   }
 
   // Fetch the D3D11 device.
   EGLDeviceEXT eglDevice = nullptr;
-  mEgl->fQueryDisplayAttribEXT(mEgl->Display(), LOCAL_EGL_DEVICE_EXT,
-                               (EGLAttrib*)&eglDevice);
+  egl->fQueryDisplayAttribEXT(egl->Display(), LOCAL_EGL_DEVICE_EXT,
+                              (EGLAttrib*)&eglDevice);
   MOZ_ASSERT(eglDevice);
   ID3D11Device* device = nullptr;
-  mEgl->fQueryDeviceAttribEXT(eglDevice, LOCAL_EGL_D3D11_DEVICE_ANGLE,
-                              (EGLAttrib*)&device);
+  egl->fQueryDeviceAttribEXT(eglDevice, LOCAL_EGL_D3D11_DEVICE_ANGLE,
+                             (EGLAttrib*)&device);
   if (!device) {
     gfxCriticalNote << "Failed to get D3D11Device from EGLDisplay";
     return nullptr;
@@ -87,7 +81,8 @@
 }
 
 bool RenderCompositorANGLE::SutdownEGLLibraryIfNecessary() {
-  if (!mEgl) {
+  const RefPtr<gl::GLLibraryEGL> egl = gl::GLLibraryEGL::Get();
+  if (!egl) {
     // egl is not initialized yet;
     return true;
   }
@@ -105,7 +100,7 @@
       RenderThread::Get()->RendererCount() == 0) {
     // Shutdown GLLibraryEGL for updating EGLDisplay.
     RenderThread::Get()->ClearSharedGL();
-    mEgl->Shutdown();
+    egl->Shutdown();
   }
   return true;
 }
@@ -120,7 +115,8 @@
   if (!SutdownEGLLibraryIfNecessary()) {
     return false;
   }
-  if (!RenderThread::Get()->SharedGL()) {
+  const auto gl = RenderThread::Get()->SharedGL();
+  if (!gl) {
     gfxCriticalNote << "[WR] failed to get shared GL context.";
     return false;
   }
@@ -231,7 +227,9 @@
 
   // Force enable alpha channel to make sure ANGLE use correct framebuffer
   // formart
-  if (!gl::CreateConfig(mEgl, &mEGLConfig, /* bpp */ 32,
+  const auto& gle = gl::GLContextEGL::Cast(gl);
+  const auto& egl = gle->mEgl;
+  if (!gl::CreateConfig(egl, &mEGLConfig, /* bpp */ 32,
                         /* enableDepthBuffer */ true)) {
     gfxCriticalNote << "Failed to create EGLConfig for WebRender";
   }
@@ -442,11 +440,14 @@
 
   const auto buffer = reinterpret_cast<EGLClientBuffer>(backBuf.get());
 
-  const EGLSurface surface = mEgl->fCreatePbufferFromClientBuffer(
-      mEgl->Display(), LOCAL_EGL_D3D_TEXTURE_ANGLE, buffer, mEGLConfig,
+  const auto gl = RenderThread::Get()->SharedGL();
+  const auto& gle = gl::GLContextEGL::Cast(gl);
+  const auto& egl = gle->mEgl;
+  const EGLSurface surface = egl->fCreatePbufferFromClientBuffer(
+      egl->Display(), LOCAL_EGL_D3D_TEXTURE_ANGLE, buffer, mEGLConfig,
       pbuffer_attribs);
 
-  EGLint err = mEgl->fGetError();
+  EGLint err = egl->fGetError();
   if (err != LOCAL_EGL_SUCCESS) {
     gfxCriticalError() << "Failed to create Pbuffer of back buffer error: "
                        << gfx::hexa(err) << " Size : " << size;
@@ -462,8 +463,10 @@
 void RenderCompositorANGLE::DestroyEGLSurface() {
   // Release EGLSurface of back buffer before calling ResizeBuffers().
   if (mEGLSurface) {
-    gl::GLContextEGL::Cast(gl())->SetEGLSurfaceOverride(EGL_NO_SURFACE);
-    mEgl->fDestroySurface(mEgl->Display(), mEGLSurface);
+    const auto& gle = gl::GLContextEGL::Cast(gl());
+    const auto& egl = gle->mEgl;
+    gle->SetEGLSurfaceOverride(EGL_NO_SURFACE);
+    egl->fDestroySurface(egl->Display(), mEGLSurface);
     mEGLSurface = nullptr;
   }
 }