# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/webrender_bindings/RenderCompositorANGLE.cpp
# Commit: edfb73b96d5a
# Full Hash: edfb73b96d5ad946bbdd9da2e98d07b1f4565e1f
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2019-06-15 21:44:24
# Regressor Bug: 1559524
# File Overlap Count: 2
# Description:
#   Bug 1559524 - Reduce calls to GLLibraryEGL::Get(). r=lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D35103
# ==============================================================================

diff -r 0378898329b2 -r edfb73b96d5a gfx/webrender_bindings/RenderCompositorANGLE.cpp
--- a/gfx/webrender_bindings/RenderCompositorANGLE.cpp	Sat Jun 15 05:14:53 2019 +0000
+++ b/gfx/webrender_bindings/RenderCompositorANGLE.cpp	Sat Jun 15 05:21:12 2019 +0000
@@ -32,13 +32,17 @@
 /* static */
 UniquePtr<RenderCompositor> RenderCompositorANGLE::Create(
     RefPtr<widget::CompositorWidget>&& aWidget) {
-  if (!RenderThread::Get()->SharedGL()) {
+  const auto& gl = RenderThread::Get()->SharedGL();
+  if (!gl) {
     gfxCriticalNote << "Failed to get shared GL context";
     return nullptr;
   }
 
+  const auto& gle = gl::GLContextEGL::Cast(gl);
+  const auto& egl = gle->mEgl;
+
   UniquePtr<RenderCompositorANGLE> compositor =
-      MakeUnique<RenderCompositorANGLE>(std::move(aWidget));
+      MakeUnique<RenderCompositorANGLE>(std::move(aWidget), egl);
   if (!compositor->Initialize()) {
     return nullptr;
   }
@@ -46,11 +50,14 @@
 }
 
 RenderCompositorANGLE::RenderCompositorANGLE(
-    RefPtr<widget::CompositorWidget>&& aWidget)
+    RefPtr<widget::CompositorWidget>&& aWidget, gl::GLLibraryEGL* const egl)
     : RenderCompositor(std::move(aWidget)),
+      mEgl(egl),
       mEGLConfig(nullptr),
       mEGLSurface(nullptr),
-      mUseTripleBuffering(false) {}
+      mUseTripleBuffering(false) {
+  MOZ_ASSERT(mEgl);
+}
 
 RenderCompositorANGLE::~RenderCompositorANGLE() {
   DestroyEGLSurface();
@@ -58,20 +65,20 @@
 }
 
 ID3D11Device* RenderCompositorANGLE::GetDeviceOfEGLDisplay() {
-  auto* egl = gl::GLLibraryEGL::Get();
-  MOZ_ASSERT(egl);
-  if (!egl || !egl->IsExtensionSupported(gl::GLLibraryEGL::EXT_device_query)) {
+  MOZ_ASSERT(mEgl);
+  if (!mEgl ||
+      !mEgl->IsExtensionSupported(gl::GLLibraryEGL::EXT_device_query)) {
     return nullptr;
   }
 
   // Fetch the D3D11 device.
   EGLDeviceEXT eglDevice = nullptr;
-  egl->fQueryDisplayAttribEXT(egl->Display(), LOCAL_EGL_DEVICE_EXT,
-                              (EGLAttrib*)&eglDevice);
+  mEgl->fQueryDisplayAttribEXT(mEgl->Display(), LOCAL_EGL_DEVICE_EXT,
+                               (EGLAttrib*)&eglDevice);
   MOZ_ASSERT(eglDevice);
   ID3D11Device* device = nullptr;
-  egl->fQueryDeviceAttribEXT(eglDevice, LOCAL_EGL_D3D11_DEVICE_ANGLE,
-                             (EGLAttrib*)&device);
+  mEgl->fQueryDeviceAttribEXT(eglDevice, LOCAL_EGL_D3D11_DEVICE_ANGLE,
+                              (EGLAttrib*)&device);
   if (!device) {
     gfxCriticalNote << "Failed to get D3D11Device from EGLDisplay";
     return nullptr;
@@ -80,8 +87,7 @@
 }
 
 bool RenderCompositorANGLE::SutdownEGLLibraryIfNecessary() {
-  const RefPtr<gl::GLLibraryEGL> egl = gl::GLLibraryEGL::Get();
-  if (!egl) {
+  if (!mEgl) {
     // egl is not initialized yet;
     return true;
   }
@@ -99,7 +105,7 @@
       RenderThread::Get()->RendererCount() == 0) {
     // Shutdown GLLibraryEGL for updating EGLDisplay.
     RenderThread::Get()->ClearSharedGL();
-    egl->Shutdown();
+    mEgl->Shutdown();
   }
   return true;
 }
@@ -225,7 +231,7 @@
 
   // Force enable alpha channel to make sure ANGLE use correct framebuffer
   // formart
-  if (!gl::CreateConfig(&mEGLConfig, /* bpp */ 32,
+  if (!gl::CreateConfig(mEgl, &mEGLConfig, /* bpp */ 32,
                         /* enableDepthBuffer */ true)) {
     gfxCriticalNote << "Failed to create EGLConfig for WebRender";
   }
@@ -425,8 +431,6 @@
     }
   }
 
-  auto* egl = gl::GLLibraryEGL::Get();
-
   const EGLint pbuffer_attribs[]{
       LOCAL_EGL_WIDTH,
       size.width,
@@ -438,11 +442,11 @@
 
   const auto buffer = reinterpret_cast<EGLClientBuffer>(backBuf.get());
 
-  const EGLSurface surface = egl->fCreatePbufferFromClientBuffer(
-      egl->Display(), LOCAL_EGL_D3D_TEXTURE_ANGLE, buffer, mEGLConfig,
+  const EGLSurface surface = mEgl->fCreatePbufferFromClientBuffer(
+      mEgl->Display(), LOCAL_EGL_D3D_TEXTURE_ANGLE, buffer, mEGLConfig,
       pbuffer_attribs);
 
-  EGLint err = egl->fGetError();
+  EGLint err = mEgl->fGetError();
   if (err != LOCAL_EGL_SUCCESS) {
     gfxCriticalError() << "Failed to create Pbuffer of back buffer error: "
                        << gfx::hexa(err) << " Size : " << size;
@@ -456,12 +460,10 @@
 }
 
 void RenderCompositorANGLE::DestroyEGLSurface() {
-  auto* egl = gl::GLLibraryEGL::Get();
-
   // Release EGLSurface of back buffer before calling ResizeBuffers().
   if (mEGLSurface) {
     gl::GLContextEGL::Cast(gl())->SetEGLSurfaceOverride(EGL_NO_SURFACE);
-    egl->fDestroySurface(egl->Display(), mEGLSurface);
+    mEgl->fDestroySurface(mEgl->Display(), mEGLSurface);
     mEGLSurface = nullptr;
   }
 }