# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: xpcom/io/FilePreferences.cpp
# Commit: 762a04455b86
# Full Hash: 762a04455b864f5dbbe6d28995142477ffbb4edd
# Author: Honza Bambas <honzab.moz@firemni.cz>
# Date: 2019-07-31 21:55:44
# Description:
#   Bug 1561912, r=michal
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D37297
# ==============================================================================

diff -r 5cba74a67e19 -r 762a04455b86 xpcom/io/FilePreferences.cpp
--- a/xpcom/io/FilePreferences.cpp	Wed Jul 31 14:13:23 2019 +0000
+++ b/xpcom/io/FilePreferences.cpp	Fri Jul 26 22:58:39 2019 +0000
@@ -8,6 +8,7 @@
 
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/Preferences.h"
+#include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/Tokenizer.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -18,10 +19,14 @@
 namespace mozilla {
 namespace FilePreferences {
 
+static StaticMutex sMutex;
+
 static bool sBlockUNCPaths = false;
 typedef nsTArray<nsString> WinPaths;
 
 static WinPaths& PathWhitelist() {
+  sMutex.AssertCurrentThreadOwns();
+
   static WinPaths sPaths;
   return sPaths;
 }
@@ -32,10 +37,14 @@
 typedef char char_path_t;
 #endif
 
+// Initially false to make concurrent consumers acquire the lock and sync
+static bool sBlacklistEmpty = false;
+
 typedef nsTArray<nsTString<char_path_t>> Paths;
 static StaticAutoPtr<Paths> sBlacklist;
 
 static Paths& PathBlacklist() {
+  sMutex.AssertCurrentThreadOwns();
   if (!sBlacklist) {
     sBlacklist = new nsTArray<nsTString<char_path_t>>();
     ClearOnShutdown(&sBlacklist);
@@ -62,6 +71,8 @@
     return;
   }
 
+  StaticMutexAutoLock lock(sMutex);
+
   if (!PathWhitelist().Contains(path)) {
     PathWhitelist().AppendElement(path);
   }
@@ -71,7 +82,6 @@
   sBlockUNCPaths =
       Preferences::GetBool("network.file.disable_unc_paths", false);
 
-  PathBlacklist().Clear();
   nsTAutoString<char_path_t> blacklist;
 #ifdef XP_WIN
   Preferences::GetString("network.file.path_blacklist", blacklist);
@@ -79,6 +89,14 @@
   Preferences::GetCString("network.file.path_blacklist", blacklist);
 #endif
 
+  StaticMutexAutoLock lock(sMutex);
+
+  if (blacklist.IsEmpty()) {
+    sBlacklistEmpty = true;
+    return;
+  }
+
+  PathBlacklist().Clear();
   TTokenizer<char_path_t> p(blacklist);
   while (!p.CheckEOF()) {
     nsTString<char_path_t> path;
@@ -89,6 +107,8 @@
     }
     Unused << p.CheckChar(',');
   }
+
+  sBlacklistEmpty = PathBlacklist().Length() == 0;
 }
 
 void InitDirectoriesWhitelist() {
@@ -165,7 +185,7 @@
     nsTDependentSubstring<TChar> name;
     if (base::ReadUntil(mSeparator, name, base::INCLUDE_LAST) &&
         name.Length() == 1) {
-      // this means and empty name (a lone slash), which is illegal
+      // this means an empty name (a lone slash), which is illegal
       return false;
     }
     mStack.AppendElement(name);
@@ -217,6 +237,8 @@
     return true;
   }
 
+  StaticMutexAutoLock lock(sMutex);
+
   for (const auto& allowedPrefix : PathWhitelist()) {
     if (StringBeginsWith(normalized, allowedPrefix)) {
       if (normalized.Length() == allowedPrefix.Length()) {
@@ -245,16 +267,25 @@
 
 bool IsAllowedPath(const nsTSubstring<char_path_t>& aFilePath) {
   typedef TNormalizer<char_path_t> Normalizer;
+
+  // A quick check out of the lock.
+  if (sBlacklistEmpty) {
+    return true;
+  }
+
+  StaticMutexAutoLock lock(sMutex);
+
+  // Recheck the flag under the lock to reload it.
+  if (sBlacklistEmpty) {
+    return true;
+  }
+
   // If sBlacklist has been cleared at shutdown, we must avoid calling
   // PathBlacklist() again, as that will recreate the array and we will leak.
   if (!sBlacklist) {
     return true;
   }
 
-  if (PathBlacklist().Length() == 0) {
-    return true;
-  }
-
   nsTAutoString<char_path_t> normalized;
   if (!Normalizer(aFilePath, Normalizer::Token::Char(kPathSeparator))
            .Get(normalized)) {
@@ -278,6 +309,7 @@
 void testing::SetBlockUNCPaths(bool aBlock) { sBlockUNCPaths = aBlock; }
 
 void testing::AddDirectoryToWhitelist(nsAString const& aPath) {
+  StaticMutexAutoLock lock(sMutex);
   PathWhitelist().AppendElement(aPath);
 }
 
