# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/ReflectParse.cpp
# Commit: d96f98f974e0
# Full Hash: d96f98f974e087224e0a1ef9be67e2fc63397d8b
# Author: Ashley Hauck <khyperia@mozilla.com>
# Date: 2019-03-21 04:34:45
# Regressor Bug: 1535166
# File Overlap Count: 1
# Description:
#   Bug 1535166 - Implement computed field names. r=jorendorff
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D23408
# ==============================================================================

diff -r c786b72a9d8e -r d96f98f974e0 js/src/builtin/ReflectParse.cpp
--- a/js/src/builtin/ReflectParse.cpp	Wed Mar 20 15:50:30 2019 +0000
+++ b/js/src/builtin/ReflectParse.cpp	Wed Mar 20 17:26:01 2019 +0000
@@ -611,7 +611,7 @@
   MOZ_MUST_USE bool classMethod(HandleValue name, HandleValue body,
                                 PropKind kind, bool isStatic, TokenPos* pos,
                                 MutableHandleValue dst);
-  MOZ_MUST_USE bool classField(HandleValue name, HandleValue body,
+  MOZ_MUST_USE bool classField(HandleValue name, HandleValue initializer,
                                TokenPos* pos, MutableHandleValue dst);
 
   /*
@@ -1536,8 +1536,7 @@
     return callback(cb, name, initializer, pos, dst);
   }
 
-  return newNode(AST_CLASS_FIELD, pos, "name", name, "initializer", initializer,
-                 dst);
+  return newNode(AST_CLASS_FIELD, pos, "name", name, "init", initializer, dst);
 }
 
 bool NodeBuilder::classMembers(NodeVector& members, MutableHandleValue dst) {
@@ -2541,8 +2540,16 @@
                            .kid()
                            ->as<AssignmentNode>()
                            .right();
-    if (!expression(value, &val)) {
-      return false;
+    // RawUndefinedExpr is the node we use for "there is no initializer". If one
+    // writes, literally, `x = undefined;`, it will not be a RawUndefinedExpr
+    // node, but rather a variable reference.
+    // Behavior for "there is no initializer" should be { ..., "init": null }
+    if (value->getKind() != ParseNodeKind::RawUndefinedExpr) {
+      if (!expression(value, &val)) {
+        return false;
+      }
+    } else {
+      val.setNull();
     }
   }
   return propertyName(&classField->name(), &key) &&