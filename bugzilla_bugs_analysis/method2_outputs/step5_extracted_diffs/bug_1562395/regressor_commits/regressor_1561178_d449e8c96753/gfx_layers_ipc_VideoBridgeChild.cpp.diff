# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/VideoBridgeChild.cpp
# Commit: d449e8c96753
# Full Hash: d449e8c96753f50a34d3aaf260a00390f729954c
# Author: Matt Woodrow <mwoodrow@mozilla.com>
# Date: 2019-06-27 09:34:48
# Regressor Bug: 1561178
# File Overlap Count: 1
# Description:
#   Bug 1561178 - Use Endpoints for VideoBridge construction, and support the possibility that there are multiple at the same time. r=jya
#   
#   In the future we're going to want VideoBridge connections from the RDD process into both the parent process and the GPU process.
#   This does the preparation work for unifying the way we create VideoBridges (using Endpoints, required for cross-process connections),
#   and detects which one to use based on where the video will be composited.
# ==============================================================================

diff -r 557f55a90c8a -r d449e8c96753 gfx/layers/ipc/VideoBridgeChild.cpp
--- a/gfx/layers/ipc/VideoBridgeChild.cpp	Thu Jun 27 01:28:56 2019 +0000
+++ b/gfx/layers/ipc/VideoBridgeChild.cpp	Thu Jun 27 01:29:15 2019 +0000
@@ -11,36 +11,61 @@
 namespace mozilla {
 namespace layers {
 
-StaticRefPtr<VideoBridgeChild> sVideoBridgeChildSingleton;
+StaticRefPtr<VideoBridgeChild> sVideoBridgeToParentProcess;
+StaticRefPtr<VideoBridgeChild> sVideoBridgeToGPUProcess;
 
 /* static */
-void VideoBridgeChild::Startup() {
-  sVideoBridgeChildSingleton = new VideoBridgeChild();
-  RefPtr<VideoBridgeParent> parent = new VideoBridgeParent();
+void VideoBridgeChild::StartupForGPUProcess() {
+  ipc::Endpoint<PVideoBridgeParent> parentPipe;
+  ipc::Endpoint<PVideoBridgeChild> childPipe;
+
+  PVideoBridge::CreateEndpoints(base::GetCurrentProcId(),
+                                base::GetCurrentProcId(), &parentPipe,
+                                &childPipe);
+
+  VideoBridgeChild::OpenToGPUProcess(std::move(childPipe));
 
-  MessageLoop* loop = CompositorThreadHolder::Loop();
+  CompositorThreadHolder::Loop()->PostTask(
+      NewRunnableFunction("gfx::VideoBridgeParent::Open",
+                          &VideoBridgeParent::Open, std::move(parentPipe)));
+}
+
 
-  sVideoBridgeChildSingleton->Open(parent->GetIPCChannel(), loop,
-                                   ipc::ChildSide);
-  sVideoBridgeChildSingleton->mIPDLSelfRef = sVideoBridgeChildSingleton;
-  parent->SetOtherProcessId(base::GetCurrentProcId());
+void VideoBridgeChild::OpenToGPUProcess(
+    Endpoint<PVideoBridgeChild>&& aEndpoint) {
+  sVideoBridgeToGPUProcess = new VideoBridgeChild();
+
+  if (!aEndpoint.Bind(sVideoBridgeToGPUProcess)) {
+    // We can't recover from this.
+    MOZ_CRASH("Failed to bind RemoteDecoderManagerParent to endpoint");
+  }
 }
 
 /* static */
 void VideoBridgeChild::Shutdown() {
-  if (sVideoBridgeChildSingleton) {
-    sVideoBridgeChildSingleton->Close();
-    sVideoBridgeChildSingleton = nullptr;
+  if (sVideoBridgeToParentProcess) {
+    sVideoBridgeToParentProcess->Close();
+    sVideoBridgeToParentProcess = nullptr;
+  }
+  if (sVideoBridgeToGPUProcess) {
+    sVideoBridgeToGPUProcess->Close();
+    sVideoBridgeToGPUProcess = nullptr;
   }
 }
 
 VideoBridgeChild::VideoBridgeChild()
-    : mMessageLoop(MessageLoop::current()), mCanSend(true) {}
+    : mIPDLSelfRef(this),
+      mMessageLoop(MessageLoop::current()),
+      mCanSend(true) {}
 
 VideoBridgeChild::~VideoBridgeChild() {}
 
-VideoBridgeChild* VideoBridgeChild::GetSingleton() {
-  return sVideoBridgeChildSingleton;
+VideoBridgeChild* VideoBridgeChild::GetSingletonToParentProcess() {
+  return sVideoBridgeToParentProcess;
+}
+
+VideoBridgeChild* VideoBridgeChild::GetSingletonToGPUProcess() {
+  return sVideoBridgeToGPUProcess;
 }
 
 bool VideoBridgeChild::AllocUnsafeShmem(