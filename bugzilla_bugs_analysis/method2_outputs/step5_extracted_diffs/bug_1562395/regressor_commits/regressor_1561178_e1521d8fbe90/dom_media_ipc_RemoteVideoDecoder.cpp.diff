# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/ipc/RemoteVideoDecoder.cpp
# Commit: e1521d8fbe90
# Full Hash: e1521d8fbe9007e783ea1c094b0d3e5574d0fbf1
# Author: Matt Woodrow <mwoodrow@mozilla.com>
# Date: 2019-06-27 09:34:48
# Regressor Bug: 1561178
# File Overlap Count: 1
# Description:
#   Bug 1561178 - Combine the two video RecvOutput methods and switch based on the descriptor type. r=jya
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D35964
# ==============================================================================

diff -r 5ffc2eb8ac9f -r e1521d8fbe90 dom/media/ipc/RemoteVideoDecoder.cpp
--- a/dom/media/ipc/RemoteVideoDecoder.cpp	Thu Jun 27 05:59:05 2019 +0300
+++ b/dom/media/ipc/RemoteVideoDecoder.cpp	Thu Jun 27 01:28:47 2019 +0000
@@ -119,17 +119,33 @@
     const DecodedOutputIPDL& aDecodedData) {
   AssertOnManagerThread();
   MOZ_ASSERT(aDecodedData.type() == DecodedOutputIPDL::TRemoteVideoDataIPDL);
+
   const RemoteVideoDataIPDL& aData = aDecodedData.get_RemoteVideoDataIPDL();
 
-  RefPtr<Image> image = DeserializeImage(
-      aData.sd().get_SurfaceDescriptorBuffer(), aData.frameSize());
+  if (aData.sd().type() == SurfaceDescriptor::TSurfaceDescriptorBuffer) {
+    RefPtr<Image> image = DeserializeImage(
+        aData.sd().get_SurfaceDescriptorBuffer(), aData.frameSize());
+
+    RefPtr<VideoData> video = VideoData::CreateFromImage(
+        aData.display(), aData.base().offset(), aData.base().time(),
+        aData.base().duration(), image, aData.base().keyframe(),
+        aData.base().timecode());
 
-  RefPtr<VideoData> video = VideoData::CreateFromImage(
-      aData.display(), aData.base().offset(), aData.base().time(),
-      aData.base().duration(), image, aData.base().keyframe(),
-      aData.base().timecode());
+    mDecodedData.AppendElement(std::move(video));
+  } else {
+    // The Image here creates a TextureData object that takes ownership
+    // of the SurfaceDescriptor, and is responsible for making sure that
+    // it gets deallocated.
+    RefPtr<Image> image =
+        new GPUVideoImage(GetManager(), aData.sd(), aData.frameSize());
 
-  mDecodedData.AppendElement(std::move(video));
+    RefPtr<VideoData> video = VideoData::CreateFromImage(
+        aData.display(), aData.base().offset(), aData.base().time(),
+        aData.base().duration(), image, aData.base().keyframe(),
+        aData.base().timecode());
+
+    mDecodedData.AppendElement(std::move(video));
+  }
   return IPC_OK();
 }
 
@@ -188,27 +204,6 @@
 GpuRemoteVideoDecoderChild::GpuRemoteVideoDecoderChild()
     : RemoteVideoDecoderChild(true) {}
 
-mozilla::ipc::IPCResult GpuRemoteVideoDecoderChild::RecvOutput(
-    const DecodedOutputIPDL& aDecodedData) {
-  AssertOnManagerThread();
-  MOZ_ASSERT(aDecodedData.type() == DecodedOutputIPDL::TRemoteVideoDataIPDL);
-  const RemoteVideoDataIPDL& aData = aDecodedData.get_RemoteVideoDataIPDL();
-
-  // The Image here creates a TextureData object that takes ownership
-  // of the SurfaceDescriptor, and is responsible for making sure that
-  // it gets deallocated.
-  RefPtr<Image> image =
-      new GPUVideoImage(GetManager(), aData.sd(), aData.frameSize());
-
-  RefPtr<VideoData> video = VideoData::CreateFromImage(
-      aData.display(), aData.base().offset(), aData.base().time(),
-      aData.base().duration(), image, aData.base().keyframe(),
-      aData.base().timecode());
-
-  mDecodedData.AppendElement(std::move(video));
-  return IPC_OK();
-}
-
 void GpuRemoteVideoDecoderChild::RecordShutdownTelemetry(
     bool aAbnormalShutdown) {
 #ifdef XP_WIN