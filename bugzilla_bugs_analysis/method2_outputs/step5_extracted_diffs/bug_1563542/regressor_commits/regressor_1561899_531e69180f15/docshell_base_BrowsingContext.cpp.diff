# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/BrowsingContext.cpp
# Commit: 531e69180f15
# Full Hash: 531e69180f15e79c2449e747c0204b83e3a1aee7
# Author: Andreas Farre <farre@mozilla.com>
# Date: 2019-07-03 04:09:04
# Regressor Bug: 1561899
# File Overlap Count: 2
# Description:
#   Bug 1561899 - Add mIsDiscarded and use that when detaching. r=nika
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D36195
# ==============================================================================

diff -r 9c6775d713e8 -r 531e69180f15 docshell/base/BrowsingContext.cpp
--- a/docshell/base/BrowsingContext.cpp	Tue Jul 02 17:15:18 2019 +0000
+++ b/docshell/base/BrowsingContext.cpp	Tue Jul 02 20:48:13 2019 +0000
@@ -60,6 +60,12 @@
   aBrowsingContext->Group()->Register(aBrowsingContext);
 }
 
+void BrowsingContext::Unregister() {
+  MOZ_DIAGNOSTIC_ASSERT(mGroup);
+  mGroup->Unregister(this);
+  mIsDiscarded = true;
+}
+
 BrowsingContext* BrowsingContext::Top() {
   BrowsingContext* bc = this;
   while (bc->mParent) {
@@ -179,7 +185,8 @@
       mBrowsingContextId(aBrowsingContextId),
       mGroup(aGroup),
       mParent(aParent),
-      mIsInProcess(false) {
+      mIsInProcess(false),
+      mIsDiscarded(false) {
   MOZ_RELEASE_ASSERT(!mParent || mParent->Group() == mGroup);
   MOZ_RELEASE_ASSERT(mBrowsingContextId != 0);
   MOZ_RELEASE_ASSERT(mGroup);
@@ -210,7 +217,7 @@
 
       MOZ_DIAGNOSTIC_ASSERT(mType == Type::Chrome, "must be chrome");
       MOZ_DIAGNOSTIC_ASSERT(XRE_IsParentProcess(), "must be in parent");
-      MOZ_DIAGNOSTIC_ASSERT(!Group()->IsContextCached(this),
+      MOZ_DIAGNOSTIC_ASSERT(!mGroup->IsContextCached(this),
                             "cannot be in bfcache");
 
       RefPtr<BrowsingContext> kungFuDeathGrip(this);
@@ -248,7 +255,9 @@
            XRE_IsParentProcess() ? "Parent" : "Child", Id(),
            mParent ? mParent->Id() : 0));
 
-  MOZ_DIAGNOSTIC_ASSERT(!Group()->IsContextCached(this));
+  MOZ_DIAGNOSTIC_ASSERT(mGroup);
+  MOZ_DIAGNOSTIC_ASSERT(!mGroup->IsContextCached(this));
+  MOZ_DIAGNOSTIC_ASSERT(!mIsDiscarded);
 
   auto* children = mParent ? &mParent->mChildren : &mGroup->Toplevels();
   MOZ_DIAGNOSTIC_ASSERT(!children->Contains(this));
@@ -262,7 +271,7 @@
           GetIPCInitializer());
     } else if (IsContent()) {
       MOZ_DIAGNOSTIC_ASSERT(XRE_IsParentProcess());
-      Group()->EachParent([&](ContentParent* aParent) {
+      mGroup->EachParent([&](ContentParent* aParent) {
         Unused << aParent->SendAttachBrowsingContext(GetIPCInitializer());
       });
     }
@@ -275,36 +284,28 @@
            XRE_IsParentProcess() ? "Parent" : "Child", Id(),
            mParent ? mParent->Id() : 0));
 
+  // Unlinking might remove our group before Detach gets called.
+  if (NS_WARN_IF(!mGroup)) {
+    return;
+  }
+
   RefPtr<BrowsingContext> kungFuDeathGrip(this);
 
-  if (Group() && !Group()->EvictCachedContext(this)) {
+  if (!mGroup->EvictCachedContext(this)) {
     Children* children = nullptr;
     if (mParent) {
       children = &mParent->mChildren;
-    } else if (mGroup) {
+    } else {
       children = &mGroup->Toplevels();
     }
 
-    if (children) {
-      // TODO(farre): This assert looks extremely fishy, I know, but
-      // what we're actually saying is this: if we're detaching, but our
-      // parent doesn't have any children, it is because we're being
-      // detached by the cycle collector destroying docshells out of
-      // order.
-      MOZ_DIAGNOSTIC_ASSERT(children->IsEmpty() || children->Contains(this));
-
-      children->RemoveElement(this);
-    }
-  }
-
-  if (mGroup) {
-    mGroup->Unregister(this);
+    children->RemoveElement(this);
   }
 
   // As our nsDocShell is going away, this should implicitly mark us as closed.
   // We directly set our member, rather than using a transaction as we're going
   // to send a `Detach` message to other processes either way.
-  mClosed = true;
+  Unregister();
 
   if (!aFromIPC && XRE_IsContentProcess()) {
     auto cc = ContentChild::GetSingleton();
@@ -338,7 +339,7 @@
           ("%s: Caching children of 0x%08" PRIx64 "",
            XRE_IsParentProcess() ? "Parent" : "Child", Id()));
 
-  Group()->CacheContexts(mChildren);
+  mGroup->CacheContexts(mChildren);
   mChildren.Clear();
 
   if (!aFromIPC && XRE_IsContentProcess()) {
@@ -355,7 +356,7 @@
 
   for (BrowsingContext* child : aChildren) {
     MOZ_DIAGNOSTIC_ASSERT(child->GetParent() == this);
-    Unused << Group()->EvictCachedContext(child);
+    Unused << mGroup->EvictCachedContext(child);
   }
 
   mChildren.AppendElements(aChildren);
@@ -367,7 +368,7 @@
   }
 }
 
-bool BrowsingContext::IsCached() { return Group()->IsContextCached(this); }
+bool BrowsingContext::IsCached() { return mGroup->IsContextCached(this); }
 
 bool BrowsingContext::HasOpener() const {
   return sBrowsingContexts->Contains(mOpenerId);
@@ -670,7 +671,7 @@
 }
 
 Nullable<WindowProxyHolder> BrowsingContext::GetTop(ErrorResult& aError) {
-  if (mClosed) {
+  if (mIsDiscarded) {
     return nullptr;
   }
 
@@ -694,7 +695,7 @@
 }
 
 Nullable<WindowProxyHolder> BrowsingContext::GetParent(ErrorResult& aError) {
-  if (mClosed) {
+  if (mIsDiscarded) {
     return nullptr;
   }
 