# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/cpu.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/cpu.cc
--- a/security/sandbox/chromium/base/cpu.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/cpu.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -10,8 +10,9 @@
 #include <string.h>
 
 #include <algorithm>
+#include <utility>
 
-#include "base/macros.h"
+#include "base/stl_util.h"
 #include "build/build_config.h"
 
 #if defined(ARCH_CPU_ARM_FAMILY) && (defined(OS_ANDROID) || defined(OS_LINUX))
@@ -78,18 +79,22 @@
 }
 
 #endif
+#endif  // !defined(COMPILER_MSVC)
 
-// _xgetbv returns the value of an Intel Extended Control Register (XCR).
+// xgetbv returns the value of an Intel Extended Control Register (XCR).
 // Currently only XCR0 is defined by Intel so |xcr| should always be zero.
-uint64_t _xgetbv(uint32_t xcr) {
+uint64_t xgetbv(uint32_t xcr) {
+#if defined(COMPILER_MSVC)
+  return _xgetbv(xcr);
+#else
   uint32_t eax, edx;
 
   __asm__ volatile (
     "xgetbv" : "=a"(eax), "=d"(edx) : "c"(xcr));
   return (static_cast<uint64_t>(edx) << 32) | eax;
+#endif  // defined(COMPILER_MSVC)
 }
 
-#endif  // !defined(COMPILER_MSVC)
 #endif  // ARCH_CPU_X86_FAMILY
 
 #if defined(ARCH_CPU_ARM_FAMILY) && (defined(OS_ANDROID) || defined(OS_LINUX))
@@ -106,17 +111,14 @@
     std::string contents;
     ReadFileToString(FilePath("/proc/cpuinfo"), &contents);
     DCHECK(!contents.empty());
-    if (contents.empty()) {
-      return new std::string();
-    }
 
     std::istringstream iss(contents);
     std::string line;
     while (std::getline(iss, line)) {
-      if ((line.compare(0, strlen(kModelNamePrefix), kModelNamePrefix) == 0 ||
-           line.compare(0, strlen(kProcessorPrefix), kProcessorPrefix) == 0)) {
+      if (line.compare(0, strlen(kModelNamePrefix), kModelNamePrefix) == 0)
         return new std::string(line.substr(strlen(kModelNamePrefix)));
-      }
+      if (line.compare(0, strlen(kProcessorPrefix), kProcessorPrefix) == 0)
+        return new std::string(line.substr(strlen(kProcessorPrefix)));
     }
 
     return new std::string();
@@ -127,12 +129,16 @@
 #endif  // defined(ARCH_CPU_ARM_FAMILY) && (defined(OS_ANDROID) ||
         // defined(OS_LINUX))
 
-}  // anonymous namespace
+}  // namespace
 
 void CPU::Initialize() {
 #if defined(ARCH_CPU_X86_FAMILY)
   int cpu_info[4] = {-1};
-  char cpu_string[48];
+  // This array is used to temporarily hold the vendor name and then the brand
+  // name. Thus it has to be big enough for both use cases. There are
+  // static_asserts below for each of the use cases to make sure this array is
+  // big enough.
+  char cpu_string[sizeof(cpu_info) * 3 + 1];
 
   // __cpuid with an InfoType argument of 0 returns the number of
   // valid Ids in CPUInfo[0] and the CPU identification string in
@@ -140,12 +146,17 @@
   // not in linear order. The code below arranges the information
   // in a human readable form. The human readable order is CPUInfo[1] |
   // CPUInfo[3] | CPUInfo[2]. CPUInfo[2] and CPUInfo[3] are swapped
-  // before using memcpy to copy these three array elements to cpu_string.
+  // before using memcpy() to copy these three array elements to |cpu_string|.
   __cpuid(cpu_info, 0);
   int num_ids = cpu_info[0];
   std::swap(cpu_info[2], cpu_info[3]);
-  memcpy(cpu_string, &cpu_info[1], 3 * sizeof(cpu_info[1]));
-  cpu_vendor_.assign(cpu_string, 3 * sizeof(cpu_info[1]));
+  static constexpr size_t kVendorNameSize = 3 * sizeof(cpu_info[1]);
+  static_assert(kVendorNameSize < base::size(cpu_string),
+                "cpu_string too small");
+  memcpy(cpu_string, &cpu_info[1], kVendorNameSize);
+  cpu_string[kVendorNameSize] = '\0';
+  cpu_vendor_ = cpu_string;
+  bool hypervisor = false;
 
   // Interpret CPU feature information.
   if (num_ids > 0) {
@@ -170,6 +181,13 @@
     has_sse42_ = (cpu_info[2] & 0x00100000) != 0;
     has_popcnt_ = (cpu_info[2] & 0x00800000) != 0;
 
+    // "Hypervisor Present Bit: Bit 31 of ECX of CPUID leaf 0x1."
+    // See https://lwn.net/Articles/301888/
+    // This is checking for any hypervisor. Hypervisors may choose not to
+    // announce themselves. Hypervisors trap CPUID and sometimes return
+    // different results to underlying hardware.
+    hypervisor = (cpu_info[2] & 0x80000000) != 0;
+
     // AVX instructions will generate an illegal instruction exception unless
     //   a) they are supported by the CPU,
     //   b) XSAVE is supported by the CPU and
@@ -184,35 +202,57 @@
         (cpu_info[2] & 0x10000000) != 0 &&
         (cpu_info[2] & 0x04000000) != 0 /* XSAVE */ &&
         (cpu_info[2] & 0x08000000) != 0 /* OSXSAVE */ &&
-        (_xgetbv(0) & 6) == 6 /* XSAVE enabled by kernel */;
+        (xgetbv(0) & 6) == 6 /* XSAVE enabled by kernel */;
     has_aesni_ = (cpu_info[2] & 0x02000000) != 0;
     has_avx2_ = has_avx_ && (cpu_info7[1] & 0x00000020) != 0;
   }
 
   // Get the brand string of the cpu.
   __cpuid(cpu_info, 0x80000000);
-  const int parameter_end = 0x80000004;
-  int max_parameter = cpu_info[0];
+  const int max_parameter = cpu_info[0];
 
-  if (cpu_info[0] >= parameter_end) {
-    char* cpu_string_ptr = cpu_string;
+  static constexpr int kParameterStart = 0x80000002;
+  static constexpr int kParameterEnd = 0x80000004;
+  static constexpr int kParameterSize = kParameterEnd - kParameterStart + 1;
+  static_assert(kParameterSize * sizeof(cpu_info) + 1 == base::size(cpu_string),
+                "cpu_string has wrong size");
 
-    for (int parameter = 0x80000002; parameter <= parameter_end &&
-         cpu_string_ptr < &cpu_string[sizeof(cpu_string)]; parameter++) {
+  if (max_parameter >= kParameterEnd) {
+    size_t i = 0;
+    for (int parameter = kParameterStart; parameter <= kParameterEnd;
+         ++parameter) {
       __cpuid(cpu_info, parameter);
-      memcpy(cpu_string_ptr, cpu_info, sizeof(cpu_info));
-      cpu_string_ptr += sizeof(cpu_info);
+      memcpy(&cpu_string[i], cpu_info, sizeof(cpu_info));
+      i += sizeof(cpu_info);
     }
-    cpu_brand_.assign(cpu_string, cpu_string_ptr - cpu_string);
+    cpu_string[i] = '\0';
+    cpu_brand_ = cpu_string;
   }
 
-  const int parameter_containing_non_stop_time_stamp_counter = 0x80000007;
-  if (max_parameter >= parameter_containing_non_stop_time_stamp_counter) {
-    __cpuid(cpu_info, parameter_containing_non_stop_time_stamp_counter);
+  static constexpr int kParameterContainingNonStopTimeStampCounter = 0x80000007;
+  if (max_parameter >= kParameterContainingNonStopTimeStampCounter) {
+    __cpuid(cpu_info, kParameterContainingNonStopTimeStampCounter);
     has_non_stop_time_stamp_counter_ = (cpu_info[3] & (1 << 8)) != 0;
   }
+
+  if (!has_non_stop_time_stamp_counter_ && hypervisor) {
+    int cpu_info_hv[4] = {};
+    __cpuid(cpu_info_hv, 0x40000000);
+    if (cpu_info_hv[1] == 0x7263694D &&  // Micr
+        cpu_info_hv[2] == 0x666F736F &&  // osof
+        cpu_info_hv[3] == 0x76482074) {  // t Hv
+      // If CPUID says we have a variant TSC and a hypervisor has identified
+      // itself and the hypervisor says it is Microsoft Hyper-V, then treat
+      // TSC as invariant.
+      //
+      // Microsoft Hyper-V hypervisor reports variant TSC as there are some
+      // scenarios (eg. VM live migration) where the TSC is variant, but for
+      // our purposes we can treat it as invariant.
+      has_non_stop_time_stamp_counter_ = true;
+    }
+  }
 #elif defined(ARCH_CPU_ARM_FAMILY) && (defined(OS_ANDROID) || defined(OS_LINUX))
-  cpu_brand_.assign(*CpuInfoBrand());
+  cpu_brand_ = *CpuInfoBrand();
 #endif
 }
 