# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/lazy_instance.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/lazy_instance.h
--- a/security/sandbox/chromium/base/lazy_instance.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/lazy_instance.h	Wed Jun 12 11:10:48 2019 +0100
@@ -1,7 +1,17 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+//
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DEPRECATED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+// Please don't introduce new instances of LazyInstance<T>. Use a function-local
+// static of type base::NoDestructor<T> instead:
+//
+// Factory& Factory::GetInstance() {
+//   static base::NoDestructor<Factory> instance;
+//   return *instance;
+// }
+// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+//
 // The LazyInstance<Type, Traits> class manages a single instance of Type,
 // which will be lazily created on the first time it's accessed.  This class is
 // useful for places you would normally use a function-level static, but you
@@ -38,16 +48,14 @@
 #include <new>  // For placement new.
 
 #include "base/atomicops.h"
-#include "base/base_export.h"
 #include "base/debug/leak_annotations.h"
+#include "base/lazy_instance_helpers.h"
 #include "base/logging.h"
 #include "base/threading/thread_restrictions.h"
 
 // LazyInstance uses its own struct initializer-list style static
-// initialization, as base's LINKER_INITIALIZED requires a constructor and on
-// some compilers (notably gcc 4.4) this still ends up needing runtime
-// initialization.
-#define LAZY_INSTANCE_INITIALIZER {0}
+// initialization, which does not require a constructor.
+#define LAZY_INSTANCE_INITIALIZER {}
 
 namespace base {
 
@@ -115,52 +123,6 @@
 template <typename Type>
 struct ErrorMustSelectLazyOrDestructorAtExitForLazyInstance {};
 
-// Our AtomicWord doubles as a spinlock, where a value of
-// kLazyInstanceStateCreating means the spinlock is being held for creation.
-constexpr subtle::AtomicWord kLazyInstanceStateCreating = 1;
-
-// Check if instance needs to be created. If so return true otherwise
-// if another thread has beat us, wait for instance to be created and
-// return false.
-BASE_EXPORT bool NeedsLazyInstance(subtle::AtomicWord* state);
-
-// After creating an instance, call this to register the dtor to be called
-// at program exit and to update the atomic state to hold the |new_instance|
-BASE_EXPORT void CompleteLazyInstance(subtle::AtomicWord* state,
-                                      subtle::AtomicWord new_instance,
-                                      void (*destructor)(void*),
-                                      void* destructor_arg);
-
-// If |state| is uninitialized, constructs a value using |creator_func|, stores
-// it into |state| and registers |destructor| to be called with |destructor_arg|
-// as argument when the current AtExitManager goes out of scope. Then, returns
-// the value stored in |state|. It is safe to have concurrent calls to this
-// function with the same |state|.
-template <typename CreatorFunc>
-void* GetOrCreateLazyPointer(subtle::AtomicWord* state,
-                             const CreatorFunc& creator_func,
-                             void (*destructor)(void*),
-                             void* destructor_arg) {
-  // If any bit in the created mask is true, the instance has already been
-  // fully constructed.
-  constexpr subtle::AtomicWord kLazyInstanceCreatedMask =
-      ~internal::kLazyInstanceStateCreating;
-
-  // We will hopefully have fast access when the instance is already created.
-  // Since a thread sees |state| == 0 or kLazyInstanceStateCreating at most
-  // once, the load is taken out of NeedsLazyInstance() as a fast-path. The load
-  // has acquire memory ordering as a thread which sees |state| > creating needs
-  // to acquire visibility over the associated data. Pairing Release_Store is in
-  // CompleteLazyInstance().
-  subtle::AtomicWord value = subtle::Acquire_Load(state);
-  if (!(value & kLazyInstanceCreatedMask) && NeedsLazyInstance(state)) {
-    // Create the instance in the space provided by |private_buf_|.
-    value = reinterpret_cast<subtle::AtomicWord>(creator_func());
-    CompleteLazyInstance(state, value, destructor, destructor_arg);
-  }
-  return reinterpret_cast<void*>(subtle::NoBarrier_Load(state));
-}
-
 }  // namespace internal
 
 template <
@@ -188,25 +150,23 @@
 
   Type* Pointer() {
 #if DCHECK_IS_ON()
-    // Avoid making TLS lookup on release builds.
     if (!Traits::kAllowedToAccessOnNonjoinableThread)
       ThreadRestrictions::AssertSingletonAllowed();
 #endif
-    return static_cast<Type*>(internal::GetOrCreateLazyPointer(
-        &private_instance_,
-        [this]() { return Traits::New(private_buf_); },
-        Traits::kRegisterOnExit ? OnExit : nullptr, this));
+
+    return subtle::GetOrCreateLazyPointer(
+        &private_instance_, &Traits::New, private_buf_,
+        Traits::kRegisterOnExit ? OnExit : nullptr, this);
   }
 
-  bool operator==(Type* p) {
-    switch (subtle::NoBarrier_Load(&private_instance_)) {
-      case 0:
-        return p == NULL;
-      case internal::kLazyInstanceStateCreating:
-        return static_cast<void*>(p) == private_buf_;
-      default:
-        return p == instance();
-    }
+  // Returns true if the lazy instance has been created.  Unlike Get() and
+  // Pointer(), calling IsCreated() will not instantiate the object of Type.
+  bool IsCreated() {
+    // Return true (i.e. "created") if |private_instance_| is either being
+    // created right now (i.e. |private_instance_| has value of
+    // internal::kLazyInstanceStateCreating) or was already created (i.e.
+    // |private_instance_| has any other non-zero value).
+    return 0 != subtle::NoBarrier_Load(&private_instance_);
   }
 
   // MSVC gives a warning that the alignment expands the size of the