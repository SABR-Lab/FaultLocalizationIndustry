# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/memory/ref_counted.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/memory/ref_counted.h
--- a/security/sandbox/chromium/base/memory/ref_counted.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/memory/ref_counted.h	Wed Jun 12 11:10:48 2019 +0100
@@ -7,36 +7,26 @@
 
 #include <stddef.h>
 
-#include <cassert>
-#include <iosfwd>
-#include <type_traits>
+#include <utility>
 
 #include "base/atomic_ref_count.h"
 #include "base/base_export.h"
 #include "base/compiler_specific.h"
+#include "base/gtest_prod_util.h"
 #include "base/logging.h"
 #include "base/macros.h"
+#include "base/memory/scoped_refptr.h"
 #include "base/sequence_checker.h"
 #include "base/threading/thread_collision_warner.h"
 #include "build/build_config.h"
 
-template <class T>
-class scoped_refptr;
-
 namespace base {
-
-template <typename T>
-scoped_refptr<T> AdoptRef(T* t);
-
 namespace subtle {
 
-enum AdoptRefTag { kAdoptRefTag };
-enum StartRefCountFromZeroTag { kStartRefCountFromZeroTag };
-enum StartRefCountFromOneTag { kStartRefCountFromOneTag };
-
 class BASE_EXPORT RefCountedBase {
  public:
   bool HasOneRef() const { return ref_count_ == 1; }
+  bool HasAtLeastOneRef() const { return ref_count_ >= 1; }
 
  protected:
   explicit RefCountedBase(StartRefCountFromZeroTag) {
@@ -74,7 +64,7 @@
     }
 #endif
 
-    ++ref_count_;
+    AddRefImpl();
   }
 
   // Returns true if the object should self-delete.
@@ -125,6 +115,8 @@
   template <typename U>
   friend scoped_refptr<U> base::AdoptRef(U*);
 
+  FRIEND_TEST_ALL_PREFIXES(RefCountedDeathTest, TestOverflowCheck);
+
   void Adopted() const {
 #if DCHECK_IS_ON()
     DCHECK(needs_adopt_ref_);
@@ -132,11 +124,17 @@
 #endif
   }
 
+#if defined(ARCH_CPU_64_BITS)
+  void AddRefImpl() const;
+#else
+  void AddRefImpl() const { ++ref_count_; }
+#endif
+
 #if DCHECK_IS_ON()
   bool CalledOnValidSequence() const;
 #endif
 
-  mutable size_t ref_count_ = 0;
+  mutable uint32_t ref_count_ = 0;
 
 #if DCHECK_IS_ON()
   mutable bool needs_adopt_ref_ = false;
@@ -152,16 +150,22 @@
 class BASE_EXPORT RefCountedThreadSafeBase {
  public:
   bool HasOneRef() const;
+  bool HasAtLeastOneRef() const;
 
  protected:
-  explicit RefCountedThreadSafeBase(StartRefCountFromZeroTag) {}
-  explicit RefCountedThreadSafeBase(StartRefCountFromOneTag) : ref_count_(1) {
+  explicit constexpr RefCountedThreadSafeBase(StartRefCountFromZeroTag) {}
+  explicit constexpr RefCountedThreadSafeBase(StartRefCountFromOneTag)
+      : ref_count_(1) {
 #if DCHECK_IS_ON()
     needs_adopt_ref_ = true;
 #endif
   }
 
+#if DCHECK_IS_ON()
   ~RefCountedThreadSafeBase();
+#else
+  ~RefCountedThreadSafeBase() = default;
+#endif
 
 // Release and AddRef are suitable for inlining on X86 because they generate
 // very small code sequences. On other platforms (ARM), it causes a size
@@ -170,10 +174,12 @@
   // Returns true if the object should self-delete.
   bool Release() const { return ReleaseImpl(); }
   void AddRef() const { AddRefImpl(); }
+  void AddRefWithCheck() const { AddRefWithCheckImpl(); }
 #else
   // Returns true if the object should self-delete.
   bool Release() const;
   void AddRef() const;
+  void AddRefWithCheck() const;
 #endif
 
  private:
@@ -198,6 +204,17 @@
     ref_count_.Increment();
   }
 
+  ALWAYS_INLINE void AddRefWithCheckImpl() const {
+#if DCHECK_IS_ON()
+    DCHECK(!in_dtor_);
+    DCHECK(!needs_adopt_ref_)
+        << "This RefCounted object is created with non-zero reference count."
+        << " The first reference to such a object has to be made by AdoptRef or"
+        << " MakeRefCounted.";
+#endif
+    CHECK(ref_count_.Increment() > 0);
+  }
+
   ALWAYS_INLINE bool ReleaseImpl() const {
 #if DCHECK_IS_ON()
     DCHECK(!in_dtor_);
@@ -292,7 +309,17 @@
   static constexpr ::base::subtle::StartRefCountFromOneTag \
       kRefCountPreference = ::base::subtle::kStartRefCountFromOneTag
 
-template <class T>
+template <class T, typename Traits>
+class RefCounted;
+
+template <typename T>
+struct DefaultRefCountedTraits {
+  static void Destruct(const T* x) {
+    RefCounted<T, DefaultRefCountedTraits>::DeleteInternal(x);
+  }
+};
+
+template <class T, typename Traits = DefaultRefCountedTraits<T>>
 class RefCounted : public subtle::RefCountedBase {
  public:
   static constexpr subtle::StartRefCountFromZeroTag kRefCountPreference =
@@ -311,7 +338,7 @@
       // lifetime guarantees of the refcounting system.
       ANALYZER_SKIP_THIS_PATH();
 
-      delete static_cast<const T*>(this);
+      Traits::Destruct(static_cast<const T*>(this));
     }
   }
 
@@ -319,6 +346,12 @@
   ~RefCounted() = default;
 
  private:
+  friend struct DefaultRefCountedTraits<T>;
+  template <typename U>
+  static void DeleteInternal(const U* x) {
+    delete x;
+  }
+
   DISALLOW_COPY_AND_ASSIGN(RefCounted);
 };
 
@@ -362,9 +395,7 @@
   explicit RefCountedThreadSafe()
       : subtle::RefCountedThreadSafeBase(T::kRefCountPreference) {}
 
-  void AddRef() const {
-    subtle::RefCountedThreadSafeBase::AddRef();
-  }
+  void AddRef() const { AddRefImpl(T::kRefCountPreference); }
 
   void Release() const {
     if (subtle::RefCountedThreadSafeBase::Release()) {
@@ -378,7 +409,18 @@
 
  private:
   friend struct DefaultRefCountedThreadSafeTraits<T>;
-  static void DeleteInternal(const T* x) { delete x; }
+  template <typename U>
+  static void DeleteInternal(const U* x) {
+    delete x;
+  }
+
+  void AddRefImpl(subtle::StartRefCountFromZeroTag) const {
+    subtle::RefCountedThreadSafeBase::AddRef();
+  }
+
+  void AddRefImpl(subtle::StartRefCountFromOneTag) const {
+    subtle::RefCountedThreadSafeBase::AddRefWithCheck();
+  }
 
   DISALLOW_COPY_AND_ASSIGN(RefCountedThreadSafe);
 };
@@ -393,6 +435,7 @@
  public:
   RefCountedData() : data() {}
   RefCountedData(const T& in_value) : data(in_value) {}
+  RefCountedData(T&& in_value) : data(std::move(in_value)) {}
 
   T data;
 
@@ -401,295 +444,6 @@
   ~RefCountedData() = default;
 };
 
-// Creates a scoped_refptr from a raw pointer without incrementing the reference
-// count. Use this only for a newly created object whose reference count starts
-// from 1 instead of 0.
-template <typename T>
-scoped_refptr<T> AdoptRef(T* obj) {
-  using Tag = typename std::decay<decltype(T::kRefCountPreference)>::type;
-  static_assert(std::is_same<subtle::StartRefCountFromOneTag, Tag>::value,
-                "Use AdoptRef only for the reference count starts from one.");
-
-  DCHECK(obj);
-  DCHECK(obj->HasOneRef());
-  obj->Adopted();
-  return scoped_refptr<T>(obj, subtle::kAdoptRefTag);
-}
-
-namespace subtle {
-
-template <typename T>
-scoped_refptr<T> AdoptRefIfNeeded(T* obj, StartRefCountFromZeroTag) {
-  return scoped_refptr<T>(obj);
-}
-
-template <typename T>
-scoped_refptr<T> AdoptRefIfNeeded(T* obj, StartRefCountFromOneTag) {
-  return AdoptRef(obj);
-}
-
-}  // namespace subtle
-
-// Constructs an instance of T, which is a ref counted type, and wraps the
-// object into a scoped_refptr.
-template <typename T, typename... Args>
-scoped_refptr<T> MakeRefCounted(Args&&... args) {
-  T* obj = new T(std::forward<Args>(args)...);
-  return subtle::AdoptRefIfNeeded(obj, T::kRefCountPreference);
-}
-
 }  // namespace base
 
-//
-// A smart pointer class for reference counted objects.  Use this class instead
-// of calling AddRef and Release manually on a reference counted object to
-// avoid common memory leaks caused by forgetting to Release an object
-// reference.  Sample usage:
-//
-//   class MyFoo : public RefCounted<MyFoo> {
-//    ...
-//    private:
-//     friend class RefCounted<MyFoo>;  // Allow destruction by RefCounted<>.
-//     ~MyFoo();                        // Destructor must be private/protected.
-//   };
-//
-//   void some_function() {
-//     scoped_refptr<MyFoo> foo = new MyFoo();
-//     foo->Method(param);
-//     // |foo| is released when this function returns
-//   }
-//
-//   void some_other_function() {
-//     scoped_refptr<MyFoo> foo = new MyFoo();
-//     ...
-//     foo = nullptr;  // explicitly releases |foo|
-//     ...
-//     if (foo)
-//       foo->Method(param);
-//   }
-//
-// The above examples show how scoped_refptr<T> acts like a pointer to T.
-// Given two scoped_refptr<T> classes, it is also possible to exchange
-// references between the two objects, like so:
-//
-//   {
-//     scoped_refptr<MyFoo> a = new MyFoo();
-//     scoped_refptr<MyFoo> b;
-//
-//     b.swap(a);
-//     // now, |b| references the MyFoo object, and |a| references nullptr.
-//   }
-//
-// To make both |a| and |b| in the above example reference the same MyFoo
-// object, simply use the assignment operator:
-//
-//   {
-//     scoped_refptr<MyFoo> a = new MyFoo();
-//     scoped_refptr<MyFoo> b;
-//
-//     b = a;
-//     // now, |a| and |b| each own a reference to the same MyFoo object.
-//   }
-//
-template <class T>
-class scoped_refptr {
- public:
-  typedef T element_type;
-
-  scoped_refptr() {}
-
-  scoped_refptr(T* p) : ptr_(p) {
-    if (ptr_)
-      AddRef(ptr_);
-  }
-
-  // Copy constructor.
-  scoped_refptr(const scoped_refptr<T>& r) : ptr_(r.ptr_) {
-    if (ptr_)
-      AddRef(ptr_);
-  }
-
-  // Copy conversion constructor.
-  template <typename U,
-            typename = typename std::enable_if<
-                std::is_convertible<U*, T*>::value>::type>
-  scoped_refptr(const scoped_refptr<U>& r) : ptr_(r.get()) {
-    if (ptr_)
-      AddRef(ptr_);
-  }
-
-  // Move constructor. This is required in addition to the conversion
-  // constructor below in order for clang to warn about pessimizing moves.
-  scoped_refptr(scoped_refptr&& r) : ptr_(r.get()) { r.ptr_ = nullptr; }
-
-  // Move conversion constructor.
-  template <typename U,
-            typename = typename std::enable_if<
-                std::is_convertible<U*, T*>::value>::type>
-  scoped_refptr(scoped_refptr<U>&& r) : ptr_(r.get()) {
-    r.ptr_ = nullptr;
-  }
-
-  ~scoped_refptr() {
-    if (ptr_)
-      Release(ptr_);
-  }
-
-  T* get() const { return ptr_; }
-
-  T& operator*() const {
-    assert(ptr_ != nullptr);
-    return *ptr_;
-  }
-
-  T* operator->() const {
-    assert(ptr_ != nullptr);
-    return ptr_;
-  }
-
-  scoped_refptr<T>& operator=(T* p) {
-    // AddRef first so that self assignment should work
-    if (p)
-      AddRef(p);
-    T* old_ptr = ptr_;
-    ptr_ = p;
-    if (old_ptr)
-      Release(old_ptr);
-    return *this;
-  }
-
-  scoped_refptr<T>& operator=(const scoped_refptr<T>& r) {
-    return *this = r.ptr_;
-  }
-
-  template <typename U>
-  scoped_refptr<T>& operator=(const scoped_refptr<U>& r) {
-    return *this = r.get();
-  }
-
-  scoped_refptr<T>& operator=(scoped_refptr<T>&& r) {
-    scoped_refptr<T> tmp(std::move(r));
-    tmp.swap(*this);
-    return *this;
-  }
-
-  template <typename U>
-  scoped_refptr<T>& operator=(scoped_refptr<U>&& r) {
-    // We swap with a temporary variable to guarantee that |ptr_| is released
-    // immediately. A naive implementation which swaps |this| and |r| would
-    // unintentionally extend the lifetime of |ptr_| to at least the lifetime of
-    // |r|.
-    scoped_refptr<T> tmp(std::move(r));
-    tmp.swap(*this);
-    return *this;
-  }
-
-  void swap(scoped_refptr<T>& r) {
-    T* tmp = ptr_;
-    ptr_ = r.ptr_;
-    r.ptr_ = tmp;
-  }
-
-  explicit operator bool() const { return ptr_ != nullptr; }
-
-  template <typename U>
-  bool operator==(const scoped_refptr<U>& rhs) const {
-    return ptr_ == rhs.get();
-  }
-
-  template <typename U>
-  bool operator!=(const scoped_refptr<U>& rhs) const {
-    return !operator==(rhs);
-  }
-
-  template <typename U>
-  bool operator<(const scoped_refptr<U>& rhs) const {
-    return ptr_ < rhs.get();
-  }
-
- protected:
-  T* ptr_ = nullptr;
-
- private:
-  template <typename U>
-  friend scoped_refptr<U> base::AdoptRef(U*);
-
-  scoped_refptr(T* p, base::subtle::AdoptRefTag) : ptr_(p) {}
-
-  // Friend required for move constructors that set r.ptr_ to null.
-  template <typename U>
-  friend class scoped_refptr;
-
-  // Non-inline helpers to allow:
-  //     class Opaque;
-  //     extern template class scoped_refptr<Opaque>;
-  // Otherwise the compiler will complain that Opaque is an incomplete type.
-  static void AddRef(T* ptr);
-  static void Release(T* ptr);
-};
-
-// static
-template <typename T>
-void scoped_refptr<T>::AddRef(T* ptr) {
-  ptr->AddRef();
-}
-
-// static
-template <typename T>
-void scoped_refptr<T>::Release(T* ptr) {
-  ptr->Release();
-}
-
-// Handy utility for creating a scoped_refptr<T> out of a T* explicitly without
-// having to retype all the template arguments
-template <typename T>
-scoped_refptr<T> make_scoped_refptr(T* t) {
-  return scoped_refptr<T>(t);
-}
-
-template <typename T, typename U>
-bool operator==(const scoped_refptr<T>& lhs, const U* rhs) {
-  return lhs.get() == rhs;
-}
-
-template <typename T, typename U>
-bool operator==(const T* lhs, const scoped_refptr<U>& rhs) {
-  return lhs == rhs.get();
-}
-
-template <typename T>
-bool operator==(const scoped_refptr<T>& lhs, std::nullptr_t null) {
-  return !static_cast<bool>(lhs);
-}
-
-template <typename T>
-bool operator==(std::nullptr_t null, const scoped_refptr<T>& rhs) {
-  return !static_cast<bool>(rhs);
-}
-
-template <typename T, typename U>
-bool operator!=(const scoped_refptr<T>& lhs, const U* rhs) {
-  return !operator==(lhs, rhs);
-}
-
-template <typename T, typename U>
-bool operator!=(const T* lhs, const scoped_refptr<U>& rhs) {
-  return !operator==(lhs, rhs);
-}
-
-template <typename T>
-bool operator!=(const scoped_refptr<T>& lhs, std::nullptr_t null) {
-  return !operator==(lhs, null);
-}
-
-template <typename T>
-bool operator!=(std::nullptr_t null, const scoped_refptr<T>& rhs) {
-  return !operator==(null, rhs);
-}
-
-template <typename T>
-std::ostream& operator<<(std::ostream& out, const scoped_refptr<T>& p) {
-  return out << p.get();
-}
-
 #endif  // BASE_MEMORY_REF_COUNTED_H_