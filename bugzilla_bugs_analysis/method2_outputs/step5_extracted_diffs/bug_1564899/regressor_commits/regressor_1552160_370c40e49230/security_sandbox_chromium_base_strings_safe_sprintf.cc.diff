# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/strings/safe_sprintf.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/strings/safe_sprintf.cc
--- a/security/sandbox/chromium/base/strings/safe_sprintf.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/strings/safe_sprintf.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include <string.h>
 
+#include <algorithm>
 #include <limits>
 
 #include "base/macros.h"
@@ -236,10 +237,9 @@
     if (count_ > kSSizeMax - 1 - inc) {
       count_ = kSSizeMax - 1;
       return false;
-    } else {
-      count_ += inc;
-      return true;
     }
+    count_ += inc;
+    return true;
   }
 
   // Convenience method for the common case of incrementing |count_| by one.
@@ -318,7 +318,7 @@
   // We cannot choose the easier approach of just reversing the number, as that
   // fails in situations where we need to truncate numbers that have padding
   // and/or prefixes.
-  const char* reverse_prefix = NULL;
+  const char* reverse_prefix = nullptr;
   if (prefix && *prefix) {
     if (pad == '0') {
       while (*prefix) {
@@ -327,13 +327,13 @@
         }
         Out(*prefix++);
       }
-      prefix = NULL;
+      prefix = nullptr;
     } else {
       for (reverse_prefix = prefix; *reverse_prefix; ++reverse_prefix) {
       }
     }
   } else
-    prefix = NULL;
+    prefix = nullptr;
   const size_t prefix_length = reverse_prefix - prefix;
 
   // Loop until we have converted the entire number. Output at least one
@@ -433,11 +433,9 @@
   // never overflows kSSizeMax. Not only does that use up most or all of the
   // address space, it also would result in a return code that cannot be
   // represented.
-  if (static_cast<ssize_t>(sz) < 1) {
+  if (static_cast<ssize_t>(sz) < 1)
     return -1;
-  } else if (sz > kSSizeMax) {
-    sz = kSSizeMax;
-  }
+  sz = std::min(sz, kSSizeMax);
 
   // Iterate over format string and interpret '%' arguments as they are
   // encountered.
@@ -530,7 +528,7 @@
 
         const Arg& arg = args[cur_arg++];
         int64_t i;
-        const char* prefix = NULL;
+        const char* prefix = nullptr;
         if (ch != 'p') {
           // Check that the argument has the expected type.
           if (arg.type != Arg::INT && arg.type != Arg::UINT) {
@@ -659,11 +657,9 @@
   // never overflows kSSizeMax. Not only does that use up most or all of the
   // address space, it also would result in a return code that cannot be
   // represented.
-  if (static_cast<ssize_t>(sz) < 1) {
+  if (static_cast<ssize_t>(sz) < 1)
     return -1;
-  } else if (sz > kSSizeMax) {
-    sz = kSSizeMax;
-  }
+  sz = std::min(sz, kSSizeMax);
 
   Buffer buffer(buf, sz);
 