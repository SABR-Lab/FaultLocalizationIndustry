# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/threading/thread_id_name_manager.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/threading/thread_id_name_manager.cc
--- a/security/sandbox/chromium/base/threading/thread_id_name_manager.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/threading/thread_id_name_manager.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -9,7 +9,9 @@
 
 #include "base/logging.h"
 #include "base/memory/singleton.h"
+#include "base/no_destructor.h"
 #include "base/strings/string_util.h"
+#include "base/threading/thread_local.h"
 #include "base/trace_event/heap_profiler_allocation_context_tracker.h"
 
 namespace base {
@@ -18,19 +20,21 @@
 static const char kDefaultName[] = "";
 static std::string* g_default_name;
 
+ThreadLocalStorage::Slot& GetThreadNameTLS() {
+  static base::NoDestructor<base::ThreadLocalStorage::Slot> thread_name_tls;
+  return *thread_name_tls;
+}
 }
 
 ThreadIdNameManager::ThreadIdNameManager()
-    : main_process_name_(NULL),
-      main_process_id_(kInvalidThreadId) {
+    : main_process_name_(nullptr), main_process_id_(kInvalidThreadId) {
   g_default_name = new std::string(kDefaultName);
 
   AutoLock locked(lock_);
   name_to_interned_name_[kDefaultName] = g_default_name;
 }
 
-ThreadIdNameManager::~ThreadIdNameManager() {
-}
+ThreadIdNameManager::~ThreadIdNameManager() = default;
 
 ThreadIdNameManager* ThreadIdNameManager::GetInstance() {
   return Singleton<ThreadIdNameManager,
@@ -49,12 +53,17 @@
       name_to_interned_name_[kDefaultName];
 }
 
-void ThreadIdNameManager::SetName(PlatformThreadId id,
-                                  const std::string& name) {
-  std::string* leaked_str = NULL;
+void ThreadIdNameManager::InstallSetNameCallback(SetNameCallback callback) {
+  AutoLock locked(lock_);
+  set_name_callback_ = std::move(callback);
+}
+
+void ThreadIdNameManager::SetName(const std::string& name) {
+  PlatformThreadId id = PlatformThread::CurrentId();
+  std::string* leaked_str = nullptr;
   {
     AutoLock locked(lock_);
-    NameToInternedNameMap::iterator iter = name_to_interned_name_.find(name);
+    auto iter = name_to_interned_name_.find(name);
     if (iter != name_to_interned_name_.end()) {
       leaked_str = iter->second;
     } else {
@@ -62,8 +71,12 @@
       name_to_interned_name_[name] = leaked_str;
     }
 
-    ThreadIdToHandleMap::iterator id_to_handle_iter =
-        thread_id_to_handle_.find(id);
+    auto id_to_handle_iter = thread_id_to_handle_.find(id);
+
+    GetThreadNameTLS().Set(const_cast<char*>(leaked_str->c_str()));
+    if (set_name_callback_) {
+      set_name_callback_.Run(leaked_str->c_str());
+    }
 
     // The main thread of a process will not be created as a Thread object which
     // means there is no PlatformThreadHandler registered.
@@ -90,27 +103,29 @@
   if (id == main_process_id_)
     return main_process_name_->c_str();
 
-  ThreadIdToHandleMap::iterator id_to_handle_iter =
-      thread_id_to_handle_.find(id);
+  auto id_to_handle_iter = thread_id_to_handle_.find(id);
   if (id_to_handle_iter == thread_id_to_handle_.end())
     return name_to_interned_name_[kDefaultName]->c_str();
 
-  ThreadHandleToInternedNameMap::iterator handle_to_name_iter =
+  auto handle_to_name_iter =
       thread_handle_to_interned_name_.find(id_to_handle_iter->second);
   return handle_to_name_iter->second->c_str();
 }
 
+const char* ThreadIdNameManager::GetNameForCurrentThread() {
+  const char* name = reinterpret_cast<const char*>(GetThreadNameTLS().Get());
+  return name ? name : kDefaultName;
+}
+
 void ThreadIdNameManager::RemoveName(PlatformThreadHandle::Handle handle,
                                      PlatformThreadId id) {
   AutoLock locked(lock_);
-  ThreadHandleToInternedNameMap::iterator handle_to_name_iter =
-      thread_handle_to_interned_name_.find(handle);
+  auto handle_to_name_iter = thread_handle_to_interned_name_.find(handle);
 
   DCHECK(handle_to_name_iter != thread_handle_to_interned_name_.end());
   thread_handle_to_interned_name_.erase(handle_to_name_iter);
 
-  ThreadIdToHandleMap::iterator id_to_handle_iter =
-      thread_id_to_handle_.find(id);
+  auto id_to_handle_iter = thread_id_to_handle_.find(id);
   DCHECK((id_to_handle_iter!= thread_id_to_handle_.end()));
   // The given |id| may have been re-used by the system. Make sure the
   // mapping points to the provided |handle| before removal.