# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/job_unittest.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/job_unittest.cc
--- a/security/sandbox/chromium/sandbox/win/src/job_unittest.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/job_unittest.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -4,8 +4,9 @@
 
 // This file contains unit tests for the job object.
 
+#include "sandbox/win/src/job.h"
+
 #include "base/win/scoped_process_information.h"
-#include "sandbox/win/src/job.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace sandbox {
@@ -20,17 +21,17 @@
               job.Init(JOB_LOCKDOWN, L"my_test_job_name", 0, 0));
 
     // check if the job exists.
-    HANDLE job_handle = ::OpenJobObjectW(GENERIC_ALL, FALSE,
-                                         L"my_test_job_name");
-    ASSERT_TRUE(job_handle != NULL);
+    HANDLE job_handle =
+        ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+    ASSERT_TRUE(job_handle);
 
     if (job_handle)
       CloseHandle(job_handle);
   }
 
   // Check if the job is destroyed when the object goes out of scope.
-  HANDLE job_handle = ::OpenJobObjectW(GENERIC_ALL, FALSE, L"my_test_job_name");
-  ASSERT_TRUE(job_handle == NULL);
+  HANDLE job_handle = ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+  ASSERT_TRUE(!job_handle);
   ASSERT_EQ(static_cast<DWORD>(ERROR_FILE_NOT_FOUND), ::GetLastError());
 }
 
@@ -50,9 +51,9 @@
 
   // Check to be sure that the job is still alive even after the object is gone
   // out of scope.
-  HANDLE job_handle_dup = ::OpenJobObjectW(GENERIC_ALL, FALSE,
-                                           L"my_test_job_name");
-  ASSERT_TRUE(job_handle_dup != NULL);
+  HANDLE job_handle_dup =
+      ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+  ASSERT_TRUE(job_handle_dup);
 
   // Remove all references.
   if (job_handle_dup)
@@ -61,8 +62,8 @@
   job_handle.Close();
 
   // Check if the jbo is really dead.
-  job_handle_dup = ::OpenJobObjectW(GENERIC_ALL, FALSE, L"my_test_job_name");
-  ASSERT_TRUE(job_handle_dup == NULL);
+  job_handle_dup = ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+  ASSERT_TRUE(!job_handle_dup);
   ASSERT_EQ(static_cast<DWORD>(ERROR_FILE_NOT_FOUND), ::GetLastError());
 }
 
@@ -82,10 +83,8 @@
 
     JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = {0};
     DWORD size = sizeof(jbur);
-    BOOL result = ::QueryInformationJobObject(job_handle.Get(),
-                                              JobObjectBasicUIRestrictions,
-                                              &jbur, size, &size);
-    ASSERT_TRUE(result);
+    ASSERT_TRUE(::QueryInformationJobObject(
+        job_handle.Get(), JobObjectBasicUIRestrictions, &jbur, size, &size));
 
     ASSERT_EQ(0u, jbur.UIRestrictionsClass & JOB_OBJECT_UILIMIT_READCLIPBOARD);
     job_handle.Close();
@@ -103,10 +102,8 @@
 
     JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = {0};
     DWORD size = sizeof(jbur);
-    BOOL result = ::QueryInformationJobObject(job_handle.Get(),
-                                              JobObjectBasicUIRestrictions,
-                                              &jbur, size, &size);
-    ASSERT_TRUE(result);
+    ASSERT_TRUE(::QueryInformationJobObject(
+        job_handle.Get(), JobObjectBasicUIRestrictions, &jbur, size, &size));
 
     ASSERT_EQ(static_cast<DWORD>(JOB_OBJECT_UILIMIT_READCLIPBOARD),
               jbur.UIRestrictionsClass & JOB_OBJECT_UILIMIT_READCLIPBOARD);
@@ -127,8 +124,9 @@
 // initialized.
 TEST(JobTest, NoInit) {
   Job job;
-  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA), job.UserHandleGrantAccess(NULL));
-  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA), job.AssignProcessToJob(NULL));
+  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA),
+            job.UserHandleGrantAccess(nullptr));
+  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA), job.AssignProcessToJob(nullptr));
   ASSERT_FALSE(job.Take().IsValid());
 }
 
@@ -171,14 +169,11 @@
   ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
             job.Init(JOB_UNPROTECTED, L"job_test_process", 0, 0));
 
-  BOOL result = FALSE;
-
   wchar_t notepad[] = L"notepad";
-  STARTUPINFO si = { sizeof(si) };
+  STARTUPINFO si = {sizeof(si)};
   PROCESS_INFORMATION temp_process_info = {};
-  result = ::CreateProcess(NULL, notepad, NULL, NULL, FALSE, 0, NULL, NULL, &si,
-                           &temp_process_info);
-  ASSERT_TRUE(result);
+  ASSERT_TRUE(::CreateProcess(nullptr, notepad, nullptr, nullptr, false, 0,
+                              nullptr, nullptr, &si, &temp_process_info));
   base::win::ScopedProcessInformation pi(temp_process_info);
   ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
             job.AssignProcessToJob(pi.process_handle()));
@@ -189,10 +184,8 @@
   // Check if the process is in the job.
   JOBOBJECT_BASIC_PROCESS_ID_LIST jbpidl = {0};
   DWORD size = sizeof(jbpidl);
-  result = ::QueryInformationJobObject(job_handle.Get(),
-                                       JobObjectBasicProcessIdList,
-                                       &jbpidl, size, &size);
-  EXPECT_TRUE(result);
+  EXPECT_TRUE(::QueryInformationJobObject(
+      job_handle.Get(), JobObjectBasicProcessIdList, &jbpidl, size, &size));
 
   EXPECT_EQ(1u, jbpidl.NumberOfAssignedProcesses);
   EXPECT_EQ(1u, jbpidl.NumberOfProcessIdsInList);