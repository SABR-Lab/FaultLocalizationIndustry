# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/policy_engine_opcodes.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/policy_engine_opcodes.cc
--- a/security/sandbox/chromium/sandbox/win/src/policy_engine_opcodes.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/policy_engine_opcodes.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -13,15 +13,15 @@
 namespace {
 const unsigned short kMaxUniStrSize = 0xfffc / sizeof(wchar_t);
 
-bool InitStringUnicode(const wchar_t* source, size_t length,
+bool InitStringUnicode(const wchar_t* source,
+                       size_t length,
                        UNICODE_STRING* ustring) {
   if (length > kMaxUniStrSize) {
     return false;
   }
   ustring->Buffer = const_cast<wchar_t*>(source);
   ustring->Length = static_cast<USHORT>(length) * sizeof(wchar_t);
-  ustring->MaximumLength = (NULL != source) ?
-                                ustring->Length + sizeof(wchar_t) : 0;
+  ustring->MaximumLength = source ? ustring->Length + sizeof(wchar_t) : 0;
   return true;
 }
 
@@ -43,7 +43,8 @@
 // order and meaning.
 
 template <int>
-EvalResult OpcodeEval(PolicyOpcode* opcode, const ParameterSet* pp,
+EvalResult OpcodeEval(PolicyOpcode* opcode,
+                      const ParameterSet* pp,
                       MatchContext* match);
 
 //////////////////////////////////////////////////////////////////////////////
@@ -83,7 +84,8 @@
 
 PolicyOpcode* OpcodeFactory::MakeOpAction(EvalResult action, uint32_t options) {
   PolicyOpcode* opcode = MakeBase(OP_ACTION, options, 0);
-  if (NULL == opcode) return NULL;
+  if (!opcode)
+    return nullptr;
   opcode->SetArgument(0, action);
   return opcode;
 }
@@ -107,7 +109,8 @@
                                                uint32_t match,
                                                uint32_t options) {
   PolicyOpcode* opcode = MakeBase(OP_NUMBER_MATCH, options, selected_param);
-  if (NULL == opcode) return NULL;
+  if (!opcode)
+    return nullptr;
   opcode->SetArgument(0, match);
   opcode->SetArgument(1, UINT32_TYPE);
   return opcode;
@@ -117,7 +120,8 @@
                                                 const void* match,
                                                 uint32_t options) {
   PolicyOpcode* opcode = MakeBase(OP_NUMBER_MATCH, options, selected_param);
-  if (NULL == opcode) return NULL;
+  if (!opcode)
+    return nullptr;
   opcode->SetArgument(0, match);
   opcode->SetArgument(1, VOIDPTR_TYPE);
   return opcode;
@@ -131,13 +135,13 @@
   if (param->Get(&value_uint32)) {
     uint32_t match_uint32 = 0;
     opcode->GetArgument(0, &match_uint32);
-    return (match_uint32 != value_uint32)? EVAL_FALSE : EVAL_TRUE;
+    return (match_uint32 != value_uint32) ? EVAL_FALSE : EVAL_TRUE;
   } else {
-    const void* value_ptr = NULL;
+    const void* value_ptr = nullptr;
     if (param->Get(&value_ptr)) {
-      const void* match_ptr = NULL;
+      const void* match_ptr = nullptr;
       opcode->GetArgument(0, &match_ptr);
-      return (match_ptr != value_ptr)? EVAL_FALSE : EVAL_TRUE;
+      return (match_ptr != value_ptr) ? EVAL_FALSE : EVAL_TRUE;
     }
   }
   return EVAL_ERROR;
@@ -154,11 +158,12 @@
                                                     uint32_t upper_bound,
                                                     uint32_t options) {
   if (lower_bound > upper_bound) {
-    return NULL;
+    return nullptr;
   }
-  PolicyOpcode* opcode = MakeBase(OP_NUMBER_MATCH_RANGE, options,
-                                  selected_param);
-  if (NULL == opcode) return NULL;
+  PolicyOpcode* opcode =
+      MakeBase(OP_NUMBER_MATCH_RANGE, options, selected_param);
+  if (!opcode)
+    return nullptr;
   opcode->SetArgument(0, lower_bound);
   opcode->SetArgument(1, upper_bound);
   return opcode;
@@ -169,14 +174,15 @@
                                              const ParameterSet* param,
                                              MatchContext* context) {
   uint32_t value = 0;
-  if (!param->Get(&value)) return EVAL_ERROR;
+  if (!param->Get(&value))
+    return EVAL_ERROR;
 
   uint32_t lower_bound = 0;
   uint32_t upper_bound = 0;
   opcode->GetArgument(0, &lower_bound);
   opcode->GetArgument(1, &upper_bound);
-  return((lower_bound <= value) && (upper_bound >= value))?
-    EVAL_TRUE : EVAL_FALSE;
+  return ((lower_bound <= value) && (upper_bound >= value)) ? EVAL_TRUE
+                                                            : EVAL_FALSE;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -188,7 +194,8 @@
                                                   uint32_t match,
                                                   uint32_t options) {
   PolicyOpcode* opcode = MakeBase(OP_NUMBER_AND_MATCH, options, selected_param);
-  if (NULL == opcode) return NULL;
+  if (!opcode)
+    return nullptr;
   opcode->SetArgument(0, match);
   return opcode;
 }
@@ -198,18 +205,19 @@
                                            const ParameterSet* param,
                                            MatchContext* context) {
   uint32_t value = 0;
-  if (!param->Get(&value)) return EVAL_ERROR;
+  if (!param->Get(&value))
+    return EVAL_ERROR;
 
   uint32_t number = 0;
   opcode->GetArgument(0, &number);
-  return (number & value)? EVAL_TRUE : EVAL_FALSE;
+  return (number & value) ? EVAL_TRUE : EVAL_FALSE;
 }
 
 //////////////////////////////////////////////////////////////////////////////
 // Opcode OpWStringMatch:
 // Requires a wchar_t* in selected_param.
 // Argument 0 is the byte displacement of the stored string.
-// Argument 1 is the lenght in chars of the stored string.
+// Argument 1 is the length in chars of the stored string.
 // Argument 2 is the offset to apply on the input string. It has special values.
 // as noted in the header file.
 // Argument 3 is the string matching options.
@@ -219,39 +227,36 @@
                                                 int start_position,
                                                 StringMatchOptions match_opts,
                                                 uint32_t options) {
-  if (NULL == match_str) {
-    return NULL;
-  }
-  if ('\0' == match_str[0]) {
-    return NULL;
-  }
+  if (!match_str)
+    return nullptr;
+  if ('\0' == match_str[0])
+    return nullptr;
 
-  int lenght = lstrlenW(match_str);
+  int length = lstrlenW(match_str);
 
   PolicyOpcode* opcode = MakeBase(OP_WSTRING_MATCH, options, selected_param);
-  if (NULL == opcode) {
-    return NULL;
-  }
-  ptrdiff_t delta_str = AllocRelative(opcode, match_str, wcslen(match_str)+1);
-  if (0 == delta_str) {
-    return NULL;
-  }
+  if (!opcode)
+    return nullptr;
+  ptrdiff_t delta_str = AllocRelative(opcode, match_str, wcslen(match_str) + 1);
+  if (0 == delta_str)
+    return nullptr;
   opcode->SetArgument(0, delta_str);
-  opcode->SetArgument(1, lenght);
+  opcode->SetArgument(1, length);
   opcode->SetArgument(2, start_position);
   opcode->SetArgument(3, match_opts);
   return opcode;
 }
 
-template<>
+template <>
 EvalResult OpcodeEval<OP_WSTRING_MATCH>(PolicyOpcode* opcode,
                                         const ParameterSet* param,
                                         MatchContext* context) {
-  if (NULL == context) {
+  if (!context) {
     return EVAL_ERROR;
   }
-  const wchar_t* source_str = NULL;
-  if (!param->Get(&source_str)) return EVAL_ERROR;
+  const wchar_t* source_str = nullptr;
+  if (!param->Get(&source_str))
+    return EVAL_ERROR;
 
   int start_position = 0;
   int match_len = 0;
@@ -264,7 +269,7 @@
   // Advance the source string to the last successfully evaluated position
   // according to the match context.
   source_str = &source_str[context->position];
-  int source_len  = static_cast<int>(g_nt.wcslen(source_str));
+  int source_len = static_cast<int>(g_nt.wcslen(source_str));
 
   if (0 == source_len) {
     // If we reached the end of the source string there is nothing we can
@@ -285,13 +290,13 @@
   // Case 3: We match the first substring (if we find any).
   if (start_position >= 0) {
     if (kSeekToEnd == start_position) {
-        start_position = source_len - match_len;
-    } else if (match_opts & EXACT_LENGHT) {
-        // A sub-case of case 3 is when the EXACT_LENGHT flag is on
-        // the match needs to be not just substring but full match.
-        if ((match_len + start_position) != source_len) {
-          return EVAL_FALSE;
-        }
+      start_position = source_len - match_len;
+    } else if (match_opts & EXACT_LENGTH) {
+      // A sub-case of case 3 is when the EXACT_LENGTH flag is on
+      // the match needs to be not just substring but full match.
+      if ((match_len + start_position) != source_len) {
+        return EVAL_FALSE;
+      }
     }
 
     // Advance start_pos characters. Warning! this does not consider
@@ -344,12 +349,11 @@
 PolicyOpcode* OpcodeFactory::MakeBase(OpcodeID opcode_id,
                                       uint32_t options,
                                       int16_t selected_param) {
-  if (memory_size() < sizeof(PolicyOpcode)) {
-    return NULL;
-  }
+  if (memory_size() < sizeof(PolicyOpcode))
+    return nullptr;
 
   // Create opcode using placement-new on the buffer memory.
-  PolicyOpcode* opcode = new(memory_top_) PolicyOpcode();
+  PolicyOpcode* opcode = new (memory_top_) PolicyOpcode();
 
   // Fill in the standard fields, that every opcode has.
   memory_top_ += sizeof(PolicyOpcode);
@@ -359,12 +363,12 @@
   return opcode;
 }
 
-ptrdiff_t OpcodeFactory::AllocRelative(void* start, const wchar_t* str,
-                                       size_t lenght) {
-  size_t bytes = lenght * sizeof(wchar_t);
-  if (memory_size() < bytes) {
+ptrdiff_t OpcodeFactory::AllocRelative(void* start,
+                                       const wchar_t* str,
+                                       size_t length) {
+  size_t bytes = length * sizeof(wchar_t);
+  if (memory_size() < bytes)
     return 0;
-  }
   memory_bottom_ -= bytes;
   if (reinterpret_cast<UINT_PTR>(memory_bottom_) & 1) {
     // TODO(cpu) replace this for something better.
@@ -386,11 +390,11 @@
 // raw memory to the target process.
 
 EvalResult PolicyOpcode::Evaluate(const ParameterSet* call_params,
-                                  size_t param_count, MatchContext* match) {
-  if (NULL == call_params) {
+                                  size_t param_count,
+                                  MatchContext* match) {
+  if (!call_params)
     return EVAL_ERROR;
-  }
-  const ParameterSet* selected_param = NULL;
+  const ParameterSet* selected_param = nullptr;
   if (parameter_ >= 0) {
     if (static_cast<size_t>(parameter_) >= param_count) {
       return EVAL_ERROR;
@@ -413,21 +417,21 @@
       result = EVAL_ERROR;
     }
   }
-  if (NULL != match) {
-    if (options_ & kPolClearContext) {
+  if (match) {
+    if (options_ & kPolClearContext)
       match->Clear();
-    }
-    if (options_ & kPolUseOREval) {
+    if (options_ & kPolUseOREval)
       match->options = kPolUseOREval;
-    }
   }
   return result;
 }
 
-#define OPCODE_EVAL(op, x, y, z) case op: return OpcodeEval<op>(x, y, z)
+#define OPCODE_EVAL(op, x, y, z) \
+  case op:                       \
+    return OpcodeEval<op>(x, y, z)
 
 EvalResult PolicyOpcode::EvaluateHelper(const ParameterSet* parameters,
-                                       MatchContext* match) {
+                                        MatchContext* match) {
   switch (opcode_id_) {
     OPCODE_EVAL(OP_ALWAYS_FALSE, this, parameters, match);
     OPCODE_EVAL(OP_ALWAYS_TRUE, this, parameters, match);