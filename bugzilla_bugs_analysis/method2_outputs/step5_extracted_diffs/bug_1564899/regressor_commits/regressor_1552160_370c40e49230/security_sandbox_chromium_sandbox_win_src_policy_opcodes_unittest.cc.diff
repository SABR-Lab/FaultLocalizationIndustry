# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/policy_opcodes_unittest.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/policy_opcodes_unittest.cc
--- a/security/sandbox/chromium/sandbox/win/src/policy_opcodes_unittest.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/policy_opcodes_unittest.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -2,20 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "sandbox/win/src/policy_engine_opcodes.h"
+
 #include <stddef.h>
 #include <stdint.h>
 
-#include "sandbox/win/src/policy_engine_opcodes.h"
 #include "sandbox/win/src/policy_engine_params.h"
 #include "sandbox/win/src/sandbox_nt_types.h"
 #include "sandbox/win/src/sandbox_types.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-
-#define INIT_GLOBAL_RTL(member) \
-  g_nt.member = reinterpret_cast<member##Function>( \
-  ::GetProcAddress(ntdll, #member)); \
-  if (NULL == g_nt.member) \
+#define INIT_GLOBAL_RTL(member)                                             \
+  g_nt.member =                                                             \
+      reinterpret_cast<member##Function>(::GetProcAddress(ntdll, #member)); \
+  if (!g_nt.member)                                                         \
   return false
 
 namespace sandbox {
@@ -25,17 +25,17 @@
 SANDBOX_INTERCEPT NtExports g_nt;
 
 bool SetupNtdllImports() {
-    HMODULE ntdll = ::GetModuleHandle(kNtdllName);
+  HMODULE ntdll = ::GetModuleHandle(kNtdllName);
 
-    INIT_GLOBAL_RTL(RtlAllocateHeap);
-    INIT_GLOBAL_RTL(RtlAnsiStringToUnicodeString);
-    INIT_GLOBAL_RTL(RtlCompareUnicodeString);
-    INIT_GLOBAL_RTL(RtlCreateHeap);
-    INIT_GLOBAL_RTL(RtlDestroyHeap);
-    INIT_GLOBAL_RTL(RtlFreeHeap);
-    INIT_GLOBAL_RTL(_strnicmp);
-    INIT_GLOBAL_RTL(strlen);
-    INIT_GLOBAL_RTL(wcslen);
+  INIT_GLOBAL_RTL(RtlAllocateHeap);
+  INIT_GLOBAL_RTL(RtlAnsiStringToUnicodeString);
+  INIT_GLOBAL_RTL(RtlCompareUnicodeString);
+  INIT_GLOBAL_RTL(RtlCreateHeap);
+  INIT_GLOBAL_RTL(RtlDestroyHeap);
+  INIT_GLOBAL_RTL(RtlFreeHeap);
+  INIT_GLOBAL_RTL(_strnicmp);
+  INIT_GLOBAL_RTL(strlen);
+  INIT_GLOBAL_RTL(wcslen);
 
   return true;
 }
@@ -47,7 +47,7 @@
   ParameterSet pset2 = ParamPickerMake(pv2);
 
   // Test that we can store and retrieve a void pointer:
-  const void* result1 =0;
+  const void* result1 = 0;
   uint32_t result2 = 0;
   EXPECT_TRUE(pset1.Get(&result1));
   EXPECT_TRUE(pv1 == result1);
@@ -66,7 +66,7 @@
   // Test that we can store and retrieve a string:
   const wchar_t* txt = L"S231L";
   ParameterSet pset4 = ParamPickerMake(txt);
-  const wchar_t* result3 = NULL;
+  const wchar_t* result3 = nullptr;
   EXPECT_TRUE(pset4.Get(&result3));
   EXPECT_EQ(0, wcscmp(txt, result3));
 }
@@ -84,7 +84,7 @@
 }
 
 TEST(PolicyEngineTest, TrueFalseOpcodes) {
-  void* dummy = NULL;
+  void* dummy = nullptr;
   ParameterSet ppb1 = ParamPickerMake(dummy);
   char memory[kOpcodeMemory];
   OpcodeFactory opcode_maker(memory, sizeof(memory));
@@ -92,31 +92,31 @@
   // This opcode always evaluates to true.
   PolicyOpcode* op1 = opcode_maker.MakeOpAlwaysFalse(kPolNone);
   ASSERT_NE(nullptr, op1);
-  EXPECT_EQ(EVAL_FALSE, op1->Evaluate(&ppb1, 1, NULL));
+  EXPECT_EQ(EVAL_FALSE, op1->Evaluate(&ppb1, 1, nullptr));
   EXPECT_FALSE(op1->IsAction());
 
   // This opcode always evaluates to false.
   PolicyOpcode* op2 = opcode_maker.MakeOpAlwaysTrue(kPolNone);
   ASSERT_NE(nullptr, op2);
-  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 1, nullptr));
 
   // Nulls not allowed on the params.
-  EXPECT_EQ(EVAL_ERROR, op2->Evaluate(NULL, 0, NULL));
-  EXPECT_EQ(EVAL_ERROR, op2->Evaluate(NULL, 1, NULL));
+  EXPECT_EQ(EVAL_ERROR, op2->Evaluate(nullptr, 0, nullptr));
+  EXPECT_EQ(EVAL_ERROR, op2->Evaluate(nullptr, 1, nullptr));
 
   // True and False opcodes do not 'require' a number of parameters
-  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 0, NULL));
-  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 0, nullptr));
+  EXPECT_EQ(EVAL_TRUE, op2->Evaluate(&ppb1, 1, nullptr));
 
   // Test Inverting the logic. Note that inversion is done outside
   // any particular opcode evaluation so no need to repeat for all
   // opcodes.
   PolicyOpcode* op3 = opcode_maker.MakeOpAlwaysFalse(kPolNegateEval);
   ASSERT_NE(nullptr, op3);
-  EXPECT_EQ(EVAL_TRUE, op3->Evaluate(&ppb1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op3->Evaluate(&ppb1, 1, nullptr));
   PolicyOpcode* op4 = opcode_maker.MakeOpAlwaysTrue(kPolNegateEval);
   ASSERT_NE(nullptr, op4);
-  EXPECT_EQ(EVAL_FALSE, op4->Evaluate(&ppb1, 1, NULL));
+  EXPECT_EQ(EVAL_FALSE, op4->Evaluate(&ppb1, 1, nullptr));
 
   // Test that we clear the match context
   PolicyOpcode* op5 = opcode_maker.MakeOpAlwaysTrue(kPolClearContext);
@@ -133,17 +133,17 @@
 TEST(PolicyEngineTest, OpcodeMakerCase1) {
   // Testing that the opcode maker does not overrun the
   // supplied buffer. It should only be able to make 'count' opcodes.
-  void* dummy = NULL;
+  void* dummy = nullptr;
   ParameterSet ppb1 = ParamPickerMake(dummy);
 
   char memory[kOpcodeMemory];
   OpcodeFactory opcode_maker(memory, sizeof(memory));
   size_t count = sizeof(memory) / sizeof(PolicyOpcode);
 
-  for (size_t ix =0; ix != count; ++ix) {
+  for (size_t ix = 0; ix != count; ++ix) {
     PolicyOpcode* op = opcode_maker.MakeOpAlwaysFalse(kPolNone);
     ASSERT_NE(nullptr, op);
-    EXPECT_EQ(EVAL_FALSE, op->Evaluate(&ppb1, 1, NULL));
+    EXPECT_EQ(EVAL_FALSE, op->Evaluate(&ppb1, 1, nullptr));
   }
   // There should be no room more another opcode:
   PolicyOpcode* op1 = opcode_maker.MakeOpAlwaysFalse(kPolNone);
@@ -167,18 +167,16 @@
   size_t count = sizeof(memory) / (sizeof(PolicyOpcode) + sizeof(txt2));
 
   // Test that it does not overrun the buffer.
-  for (size_t ix =0; ix != count; ++ix) {
-    PolicyOpcode* op = opcode_maker.MakeOpWStringMatch(0, txt2, 0,
-                                                       CASE_SENSITIVE,
-                                                       kPolClearContext);
+  for (size_t ix = 0; ix != count; ++ix) {
+    PolicyOpcode* op = opcode_maker.MakeOpWStringMatch(
+        0, txt2, 0, CASE_SENSITIVE, kPolClearContext);
     ASSERT_NE(nullptr, op);
     EXPECT_EQ(EVAL_TRUE, op->Evaluate(&ppb1, 1, &mc1));
   }
 
   // There should be no room more another opcode:
-  PolicyOpcode* op1 = opcode_maker.MakeOpWStringMatch(0, txt2, 0,
-                                                      CASE_SENSITIVE,
-                                                      kPolNone);
+  PolicyOpcode* op1 =
+      opcode_maker.MakeOpWStringMatch(0, txt2, 0, CASE_SENSITIVE, kPolNone);
   ASSERT_EQ(nullptr, op1);
 }
 
@@ -197,27 +195,27 @@
   // Test basic match for uint32s 42 == 42 and 42 != 113377.
   PolicyOpcode* op_m42 = opcode_maker.MakeOpNumberMatch(0, 42UL, kPolNone);
   ASSERT_NE(nullptr, op_m42);
-  EXPECT_EQ(EVAL_TRUE, op_m42->Evaluate(&pp_num1, 1, NULL));
-  EXPECT_EQ(EVAL_FALSE, op_m42->Evaluate(&pp_num2, 1, NULL));
-  EXPECT_EQ(EVAL_ERROR, op_m42->Evaluate(&pp_wrong1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op_m42->Evaluate(&pp_num1, 1, nullptr));
+  EXPECT_EQ(EVAL_FALSE, op_m42->Evaluate(&pp_num2, 1, nullptr));
+  EXPECT_EQ(EVAL_ERROR, op_m42->Evaluate(&pp_wrong1, 1, nullptr));
 
   // Test basic match for void pointers.
-  const void* vp = NULL;
+  const void* vp = nullptr;
   ParameterSet pp_num3 = ParamPickerMake(vp);
-  PolicyOpcode* op_vp_null = opcode_maker.MakeOpVoidPtrMatch(0, NULL,
-                                                             kPolNone);
+  PolicyOpcode* op_vp_null =
+      opcode_maker.MakeOpVoidPtrMatch(0, nullptr, kPolNone);
   ASSERT_NE(nullptr, op_vp_null);
-  EXPECT_EQ(EVAL_TRUE, op_vp_null->Evaluate(&pp_num3, 1, NULL));
-  EXPECT_EQ(EVAL_FALSE, op_vp_null->Evaluate(&pp_num1, 1, NULL));
-  EXPECT_EQ(EVAL_ERROR, op_vp_null->Evaluate(&pp_wrong1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op_vp_null->Evaluate(&pp_num3, 1, nullptr));
+  EXPECT_EQ(EVAL_FALSE, op_vp_null->Evaluate(&pp_num1, 1, nullptr));
+  EXPECT_EQ(EVAL_ERROR, op_vp_null->Evaluate(&pp_wrong1, 1, nullptr));
 
   // Basic range test [41 43] (inclusive).
   PolicyOpcode* op_range1 =
       opcode_maker.MakeOpNumberMatchRange(0, 41, 43, kPolNone);
   ASSERT_NE(nullptr, op_range1);
-  EXPECT_EQ(EVAL_TRUE, op_range1->Evaluate(&pp_num1, 1, NULL));
-  EXPECT_EQ(EVAL_FALSE, op_range1->Evaluate(&pp_num2, 1, NULL));
-  EXPECT_EQ(EVAL_ERROR, op_range1->Evaluate(&pp_wrong1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op_range1->Evaluate(&pp_num1, 1, nullptr));
+  EXPECT_EQ(EVAL_FALSE, op_range1->Evaluate(&pp_num2, 1, nullptr));
+  EXPECT_EQ(EVAL_ERROR, op_range1->Evaluate(&pp_wrong1, 1, nullptr));
 }
 
 TEST(PolicyEngineTest, LogicalOpcodes) {
@@ -230,11 +228,11 @@
   PolicyOpcode* op_and1 =
       opcode_maker.MakeOpNumberAndMatch(0, 0x00100000, kPolNone);
   ASSERT_NE(nullptr, op_and1);
-  EXPECT_EQ(EVAL_TRUE, op_and1->Evaluate(&pp_num1, 1, NULL));
+  EXPECT_EQ(EVAL_TRUE, op_and1->Evaluate(&pp_num1, 1, nullptr));
   PolicyOpcode* op_and2 =
       opcode_maker.MakeOpNumberAndMatch(0, 0x00000001, kPolNone);
   ASSERT_NE(nullptr, op_and2);
-  EXPECT_EQ(EVAL_FALSE, op_and2->Evaluate(&pp_num1, 1, NULL));
+  EXPECT_EQ(EVAL_FALSE, op_and2->Evaluate(&pp_num1, 1, nullptr));
 }
 
 TEST(PolicyEngineTest, WCharOpcodes1) {
@@ -251,9 +249,8 @@
   char memory[kOpcodeMemory];
   OpcodeFactory opcode_maker(memory, sizeof(memory));
 
-  PolicyOpcode* op1 = opcode_maker.MakeOpWStringMatch(0, txt2, 0,
-                                                      CASE_SENSITIVE,
-                                                      kPolNone);
+  PolicyOpcode* op1 =
+      opcode_maker.MakeOpWStringMatch(0, txt2, 0, CASE_SENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op1);
 
   // Simplest substring match from pos 0. It should be a successful match
@@ -268,9 +265,8 @@
 
   // Using the same match context we should continue where we left
   // in the previous successful match,
-  PolicyOpcode* op3 = opcode_maker.MakeOpWStringMatch(0, txt3, 0,
-                                                      CASE_SENSITIVE,
-                                                      kPolNone);
+  PolicyOpcode* op3 =
+      opcode_maker.MakeOpWStringMatch(0, txt3, 0, CASE_SENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op3);
   EXPECT_EQ(EVAL_TRUE, op3->Evaluate(&pp_tc1, 1, &mc1));
   EXPECT_TRUE(_countof(txt3) + _countof(txt2) == mc1.position + 2);
@@ -278,17 +274,15 @@
   // We now keep on matching but now we skip 6 characters which means
   // we skip the string ' over '. And we zero the match context. This is
   // the primitive that we use to build '??'.
-  PolicyOpcode* op4 = opcode_maker.MakeOpWStringMatch(0, txt4, 6,
-                                                      CASE_SENSITIVE,
-                                                      kPolClearContext);
+  PolicyOpcode* op4 = opcode_maker.MakeOpWStringMatch(
+      0, txt4, 6, CASE_SENSITIVE, kPolClearContext);
   ASSERT_NE(nullptr, op4);
   EXPECT_EQ(EVAL_TRUE, op4->Evaluate(&pp_tc1, 1, &mc1));
   EXPECT_EQ(0u, mc1.position);
 
   // Test that we can properly match the last part of the string
-  PolicyOpcode* op4b = opcode_maker.MakeOpWStringMatch(0, txt4, kSeekToEnd,
-                                                       CASE_SENSITIVE,
-                                                       kPolClearContext);
+  PolicyOpcode* op4b = opcode_maker.MakeOpWStringMatch(
+      0, txt4, kSeekToEnd, CASE_SENSITIVE, kPolClearContext);
   ASSERT_NE(nullptr, op4b);
   EXPECT_EQ(EVAL_TRUE, op4b->Evaluate(&pp_tc1, 1, &mc1));
   EXPECT_EQ(0u, mc1.position);
@@ -302,17 +296,16 @@
   EXPECT_EQ(24u, mc1.position);
 
   // Test that we don't match because it is not at the end of the string
-  PolicyOpcode* op5b = opcode_maker.MakeOpWStringMatch(0, txt5, kSeekToEnd,
-                                                       CASE_SENSITIVE,
-                                                       kPolNone);
+  PolicyOpcode* op5b = opcode_maker.MakeOpWStringMatch(
+      0, txt5, kSeekToEnd, CASE_SENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op5b);
   EXPECT_EQ(EVAL_FALSE, op5b->Evaluate(&pp_tc1, 1, &mc1));
   EXPECT_EQ(24u, mc1.position);
 
   // Test that we function if the string does not fit. In this case we
   // try to match 'the lazy dog' against 'he lazy dog'.
-  PolicyOpcode* op6 = opcode_maker.MakeOpWStringMatch(0, txt4, 2,
-                                                      CASE_SENSITIVE, kPolNone);
+  PolicyOpcode* op6 =
+      opcode_maker.MakeOpWStringMatch(0, txt4, 2, CASE_SENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op6);
   EXPECT_EQ(EVAL_FALSE, op6->Evaluate(&pp_tc1, 1, &mc1));
 
@@ -344,12 +337,11 @@
   // Testing case-insensitive does not buy us much since it this option
   // is just passed to the Microsoft API that we use normally, but just for
   // coverage, here it is:
-  PolicyOpcode* op1s = opcode_maker.MakeOpWStringMatch(0, txt1, kSeekForward,
-                                                      CASE_SENSITIVE, kPolNone);
+  PolicyOpcode* op1s = opcode_maker.MakeOpWStringMatch(
+      0, txt1, kSeekForward, CASE_SENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op1s);
-  PolicyOpcode* op1i = opcode_maker.MakeOpWStringMatch(0, txt1, kSeekForward,
-                                                       CASE_INSENSITIVE,
-                                                       kPolNone);
+  PolicyOpcode* op1i = opcode_maker.MakeOpWStringMatch(
+      0, txt1, kSeekForward, CASE_INSENSITIVE, kPolNone);
   ASSERT_NE(nullptr, op1i);
   EXPECT_EQ(EVAL_FALSE, op1s->Evaluate(&pp_tc1, 1, &mc1));
   EXPECT_EQ(EVAL_TRUE, op1i->Evaluate(&pp_tc1, 1, &mc1));
@@ -360,7 +352,7 @@
   char memory[kOpcodeMemory];
   OpcodeFactory opcode_maker(memory, sizeof(memory));
   MatchContext mc1;
-  void* dummy = NULL;
+  void* dummy = nullptr;
   ParameterSet ppb1 = ParamPickerMake(dummy);
 
   PolicyOpcode* op1 = opcode_maker.MakeOpAction(ASK_BROKER, kPolNone);