# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/process_thread_policy.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/process_thread_policy.cc
--- a/security/sandbox/chromium/sandbox/win/src/process_thread_policy.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/process_thread_policy.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -22,34 +22,34 @@
 // These are the only safe rights that can be given to a sandboxed
 // process for the process created by the broker. All others are potential
 // vectors of privilege elevation.
-const DWORD kProcessRights = SYNCHRONIZE |
-                             PROCESS_QUERY_INFORMATION |
+const DWORD kProcessRights = SYNCHRONIZE | PROCESS_QUERY_INFORMATION |
                              PROCESS_QUERY_LIMITED_INFORMATION |
-                             PROCESS_TERMINATE |
-                             PROCESS_SUSPEND_RESUME;
+                             PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME;
 
-const DWORD kThreadRights = SYNCHRONIZE |
-                            THREAD_TERMINATE |
-                            THREAD_SUSPEND_RESUME |
-                            THREAD_QUERY_INFORMATION |
+const DWORD kThreadRights = SYNCHRONIZE | THREAD_TERMINATE |
+                            THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION |
                             THREAD_QUERY_LIMITED_INFORMATION |
                             THREAD_SET_LIMITED_INFORMATION;
 
 // Creates a child process and duplicates the handles to 'target_process'. The
 // remaining parameters are the same as CreateProcess().
-BOOL CreateProcessExWHelper(HANDLE target_process, BOOL give_full_access,
-                            LPCWSTR lpApplicationName, LPWSTR lpCommandLine,
+bool CreateProcessExWHelper(HANDLE target_process,
+                            bool give_full_access,
+                            LPCWSTR lpApplicationName,
+                            LPWSTR lpCommandLine,
                             LPSECURITY_ATTRIBUTES lpProcessAttributes,
                             LPSECURITY_ATTRIBUTES lpThreadAttributes,
-                            BOOL bInheritHandles, DWORD dwCreationFlags,
-                            LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory,
+                            bool bInheritHandles,
+                            DWORD dwCreationFlags,
+                            LPVOID lpEnvironment,
+                            LPCWSTR lpCurrentDirectory,
                             LPSTARTUPINFOW lpStartupInfo,
                             LPPROCESS_INFORMATION lpProcessInformation) {
   if (!::CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes,
                         lpThreadAttributes, bInheritHandles, dwCreationFlags,
                         lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                         lpProcessInformation)) {
-    return FALSE;
+    return false;
   }
 
   DWORD process_access = kProcessRights;
@@ -60,19 +60,19 @@
   }
   if (!::DuplicateHandle(::GetCurrentProcess(), lpProcessInformation->hProcess,
                          target_process, &lpProcessInformation->hProcess,
-                         process_access, FALSE, DUPLICATE_CLOSE_SOURCE)) {
+                         process_access, false, DUPLICATE_CLOSE_SOURCE)) {
     ::CloseHandle(lpProcessInformation->hThread);
-    return FALSE;
+    return false;
   }
   if (!::DuplicateHandle(::GetCurrentProcess(), lpProcessInformation->hThread,
                          target_process, &lpProcessInformation->hThread,
-                         thread_access, FALSE, DUPLICATE_CLOSE_SOURCE)) {
-    return FALSE;
+                         thread_access, false, DUPLICATE_CLOSE_SOURCE)) {
+    return false;
   }
-  return TRUE;
+  return true;
 }
 
-}
+}  // namespace
 
 namespace sandbox {
 
@@ -89,9 +89,7 @@
       process.reset(new PolicyRule(GIVE_ALLACCESS));
       break;
     };
-    default: {
-      return false;
-    };
+    default: { return false; };
   }
 
   if (!process->AddStringMatch(IF, NameBased::NAME, name, CASE_INSENSITIVE)) {
@@ -107,25 +105,25 @@
                                          uint32_t desired_access,
                                          uint32_t thread_id,
                                          HANDLE* handle) {
-  *handle = NULL;
+  *handle = nullptr;
 
-  NtOpenThreadFunction NtOpenThread = NULL;
+  NtOpenThreadFunction NtOpenThread = nullptr;
   ResolveNTFunctionPtr("NtOpenThread", &NtOpenThread);
 
   OBJECT_ATTRIBUTES attributes = {0};
   attributes.Length = sizeof(attributes);
   CLIENT_ID client_id = {0};
-  client_id.UniqueProcess = reinterpret_cast<PVOID>(
-                                static_cast<ULONG_PTR>(client_info.process_id));
+  client_id.UniqueProcess =
+      reinterpret_cast<PVOID>(static_cast<ULONG_PTR>(client_info.process_id));
   client_id.UniqueThread =
       reinterpret_cast<PVOID>(static_cast<ULONG_PTR>(thread_id));
 
-  HANDLE local_handle = NULL;
-  NTSTATUS status = NtOpenThread(&local_handle, desired_access, &attributes,
-                                 &client_id);
+  HANDLE local_handle = nullptr;
+  NTSTATUS status =
+      NtOpenThread(&local_handle, desired_access, &attributes, &client_id);
   if (NT_SUCCESS(status)) {
     if (!::DuplicateHandle(::GetCurrentProcess(), local_handle,
-                           client_info.process, handle, 0, FALSE,
+                           client_info.process, handle, 0, false,
                            DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) {
       return STATUS_ACCESS_DENIED;
     }
@@ -138,9 +136,9 @@
                                           uint32_t desired_access,
                                           uint32_t process_id,
                                           HANDLE* handle) {
-  *handle = NULL;
+  *handle = nullptr;
 
-  NtOpenProcessFunction NtOpenProcess = NULL;
+  NtOpenProcessFunction NtOpenProcess = nullptr;
   ResolveNTFunctionPtr("NtOpenProcess", &NtOpenProcess);
 
   if (client_info.process_id != process_id)
@@ -149,14 +147,14 @@
   OBJECT_ATTRIBUTES attributes = {0};
   attributes.Length = sizeof(attributes);
   CLIENT_ID client_id = {0};
-  client_id.UniqueProcess = reinterpret_cast<PVOID>(
-                                static_cast<ULONG_PTR>(client_info.process_id));
-  HANDLE local_handle = NULL;
-  NTSTATUS status = NtOpenProcess(&local_handle, desired_access, &attributes,
-                                  &client_id);
+  client_id.UniqueProcess =
+      reinterpret_cast<PVOID>(static_cast<ULONG_PTR>(client_info.process_id));
+  HANDLE local_handle = nullptr;
+  NTSTATUS status =
+      NtOpenProcess(&local_handle, desired_access, &attributes, &client_id);
   if (NT_SUCCESS(status)) {
     if (!::DuplicateHandle(::GetCurrentProcess(), local_handle,
-                           client_info.process, handle, 0, FALSE,
+                           client_info.process, handle, 0, false,
                            DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) {
       return STATUS_ACCESS_DENIED;
     }
@@ -169,19 +167,19 @@
                                                HANDLE process,
                                                uint32_t desired_access,
                                                HANDLE* handle) {
-  *handle = NULL;
-  NtOpenProcessTokenFunction NtOpenProcessToken = NULL;
+  *handle = nullptr;
+  NtOpenProcessTokenFunction NtOpenProcessToken = nullptr;
   ResolveNTFunctionPtr("NtOpenProcessToken", &NtOpenProcessToken);
 
   if (CURRENT_PROCESS != process)
     return STATUS_ACCESS_DENIED;
 
-  HANDLE local_handle = NULL;
-  NTSTATUS status = NtOpenProcessToken(client_info.process, desired_access,
-                                       &local_handle);
+  HANDLE local_handle = nullptr;
+  NTSTATUS status =
+      NtOpenProcessToken(client_info.process, desired_access, &local_handle);
   if (NT_SUCCESS(status)) {
     if (!::DuplicateHandle(::GetCurrentProcess(), local_handle,
-                           client_info.process, handle, 0, FALSE,
+                           client_info.process, handle, 0, false,
                            DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) {
       return STATUS_ACCESS_DENIED;
     }
@@ -194,19 +192,19 @@
                                                  uint32_t desired_access,
                                                  uint32_t attributes,
                                                  HANDLE* handle) {
-  *handle = NULL;
-  NtOpenProcessTokenExFunction NtOpenProcessTokenEx = NULL;
+  *handle = nullptr;
+  NtOpenProcessTokenExFunction NtOpenProcessTokenEx = nullptr;
   ResolveNTFunctionPtr("NtOpenProcessTokenEx", &NtOpenProcessTokenEx);
 
   if (CURRENT_PROCESS != process)
     return STATUS_ACCESS_DENIED;
 
-  HANDLE local_handle = NULL;
+  HANDLE local_handle = nullptr;
   NTSTATUS status = NtOpenProcessTokenEx(client_info.process, desired_access,
                                          attributes, &local_handle);
   if (NT_SUCCESS(status)) {
     if (!::DuplicateHandle(::GetCurrentProcess(), local_handle,
-                           client_info.process, handle, 0, FALSE,
+                           client_info.process, handle, 0, false,
                            DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) {
       return STATUS_ACCESS_DENIED;
     }
@@ -216,9 +214,9 @@
 
 DWORD ProcessPolicy::CreateProcessWAction(EvalResult eval_result,
                                           const ClientInfo& client_info,
-                                          const base::string16 &app_name,
-                                          const base::string16 &command_line,
-                                          const base::string16 &current_dir,
+                                          const base::string16& app_name,
+                                          const base::string16& command_line,
+                                          const base::string16& current_dir,
                                           PROCESS_INFORMATION* process_info) {
   // The only action supported is ASK_BROKER which means create the process.
   if (GIVE_ALLACCESS != eval_result && GIVE_READONLY != eval_result) {
@@ -230,16 +228,16 @@
   std::unique_ptr<wchar_t, base::FreeDeleter> cmd_line(
       _wcsdup(command_line.c_str()));
 
-  BOOL should_give_full_access = (GIVE_ALLACCESS == eval_result);
+  bool should_give_full_access = (GIVE_ALLACCESS == eval_result);
 
   const wchar_t* cwd = current_dir.c_str();
   if (current_dir.empty())
-    cwd = NULL;
+    cwd = nullptr;
 
   if (!CreateProcessExWHelper(client_info.process, should_give_full_access,
-                              app_name.c_str(), cmd_line.get(), NULL, NULL,
-                              FALSE, 0, NULL, cwd,
-                              &startup_info, process_info)) {
+                              app_name.c_str(), cmd_line.get(), nullptr,
+                              nullptr, false, 0, nullptr, cwd, &startup_info,
+                              process_info)) {
     return ERROR_ACCESS_DENIED;
   }
   return ERROR_SUCCESS;
@@ -253,7 +251,7 @@
     const DWORD creation_flags,
     LPDWORD thread_id,
     HANDLE* handle) {
-  *handle = NULL;
+  *handle = nullptr;
   HANDLE local_handle =
       ::CreateRemoteThread(client_info.process, nullptr, stack_size,
                            start_address, parameter, creation_flags, thread_id);
@@ -261,7 +259,7 @@
     return ::GetLastError();
   }
   if (!::DuplicateHandle(::GetCurrentProcess(), local_handle,
-                         client_info.process, handle, 0, FALSE,
+                         client_info.process, handle, 0, false,
                          DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)) {
     return ERROR_ACCESS_DENIED;
   }