# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/service_resolver_unittest.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 2
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/service_resolver_unittest.cc
--- a/security/sandbox/chromium/sandbox/win/src/service_resolver_unittest.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/service_resolver_unittest.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -4,6 +4,8 @@
 
 // This file contains unit tests for ServiceResolverThunk.
 
+#include "sandbox/win/src/service_resolver.h"
+
 #include <stddef.h>
 
 #include <memory>
@@ -13,24 +15,34 @@
 #include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "sandbox/win/src/sandbox_utils.h"
-#include "sandbox/win/src/service_resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  void* fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-template<typename T>
-class ResolverThunkTest : public T {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ResolverThunkTest(bool relaxed)
+  explicit ResolverThunkTestImpl(bool relaxed)
       : T(::GetCurrentProcess(), relaxed) {}
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) {
-    fake_target_ = target;
-  }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
@@ -50,22 +62,20 @@
     this->target_ = fake_target_;
 
     return ret;
-  };
+  }
 
- private:
-  // Holds the address of the fake target.
-  void* fake_target_;
-
-  DISALLOW_COPY_AND_ASSIGN(ResolverThunkTest);
+  DISALLOW_COPY_AND_ASSIGN(ResolverThunkTestImpl);
 };
 
-typedef ResolverThunkTest<sandbox::ServiceResolverThunk> WinXpResolverTest;
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
 
 #if !defined(_WIN64)
-typedef ResolverThunkTest<sandbox::Win8ResolverThunk> Win8ResolverTest;
-typedef ResolverThunkTest<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
-typedef ResolverThunkTest<sandbox::Wow64W8ResolverThunk> Wow64W8ResolverTest;
-typedef ResolverThunkTest<sandbox::Wow64W10ResolverThunk> Wow64W10ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
 #endif
 
 const BYTE kJump32 = 0xE9;
@@ -91,21 +101,24 @@
 #endif
 }
 
-NTSTATUS PatchNtdllWithResolver(const char* function, bool relaxed,
-                                sandbox::ServiceResolverThunk* resolver) {
+NTSTATUS PatchNtdllWithResolver(const char* function,
+                                bool relaxed,
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
-  EXPECT_TRUE(NULL != ntdll_base);
+  EXPECT_TRUE(ntdll_base);
 
-  void* target = ::GetProcAddress(ntdll_base, function);
-  EXPECT_TRUE(NULL != target);
-  if (NULL == target)
+  void* target =
+      reinterpret_cast<void*>(::GetProcAddress(ntdll_base, function));
+  EXPECT_TRUE(target);
+  if (!target)
     return STATUS_UNSUCCESSFUL;
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  static_cast<WinXpResolverTest*>(resolver)->set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
   void* function_entry = resolver;
   size_t thunk_size = resolver->GetThunkSize();
@@ -114,9 +127,9 @@
 
   resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver->Setup(ntdll_base, NULL, function, NULL,
-                                 function_entry, thunk.get(), thunk_size,
-                                 &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
@@ -125,8 +138,8 @@
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver->Setup(ntdll_base, NULL, function, NULL, function_entry,
-                            thunk.get(), thunk_size, &used);
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
       CheckJump(service, thunk.get());
     }
   }
@@ -134,32 +147,29 @@
   return ret;
 }
 
-sandbox::ServiceResolverThunk* GetTestResolver(bool relaxed) {
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
 #if defined(_WIN64)
-  return new WinXpResolverTest(relaxed);
+  return std::make_unique<WinXpResolverTest>(relaxed);
 #else
   base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
   if (os_info->wow64_status() == base::win::OSInfo::WOW64_ENABLED) {
     if (os_info->version() >= base::win::VERSION_WIN10)
-      return new Wow64W10ResolverTest(relaxed);
+      return std::make_unique<Wow64W10ResolverTest>(relaxed);
     if (os_info->version() >= base::win::VERSION_WIN8)
-      return new Wow64W8ResolverTest(relaxed);
-    return new Wow64ResolverTest(relaxed);
+      return std::make_unique<Wow64W8ResolverTest>(relaxed);
+    return std::make_unique<Wow64ResolverTest>(relaxed);
   }
 
   if (os_info->version() >= base::win::VERSION_WIN8)
-    return new Win8ResolverTest(relaxed);
+    return std::make_unique<Win8ResolverTest>(relaxed);
 
-  return new WinXpResolverTest(relaxed);
+  return std::make_unique<WinXpResolverTest>(relaxed);
 #endif
 }
 
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  sandbox::ServiceResolverThunk* resolver = GetTestResolver(relaxed);
-
-  NTSTATUS ret = PatchNtdllWithResolver(function, relaxed, resolver);
-  delete resolver;
-  return ret;
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -167,16 +177,16 @@
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtCreateFile", false);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateFile, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateFile, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtCreateMutant", false);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateMutant, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateMutant, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtMapViewOfSection", false);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtMapViewOfSection, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtMapViewOfSection, last error: " << ::GetLastError();
 }
 
 TEST(ServiceResolverTest, FailsIfNotService) {
@@ -194,56 +204,57 @@
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtCreateFile", true);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateFile, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateFile, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtCreateMutant", true);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateMutant, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateMutant, last error: " << ::GetLastError();
 
   ret = PatchNtdll("NtMapViewOfSection", true);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtMapViewOfSection, last error: " <<
-    ::GetLastError();
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  sandbox::ServiceResolverThunk* resolver = GetTestResolver(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, resolver);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateFile, last error: " <<
-    ::GetLastError();
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, resolver);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtCreateMutant, last error: " <<
-    ::GetLastError();
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, resolver);
-  EXPECT_EQ(STATUS_SUCCESS, ret) << "NtMapViewOfSection, last error: " <<
-    ::GetLastError();
-  delete resolver;
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
+  EXPECT_EQ(STATUS_SUCCESS, ret)
+      << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  sandbox::ServiceResolverThunk* resolver = GetTestResolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
-  ASSERT_TRUE(NULL != ntdll_base);
+  ASSERT_TRUE(ntdll_base);
 
   const char kFunctionName[] = "NtClose";
 
-  void* target = ::GetProcAddress(ntdll_base, kFunctionName);
-  ASSERT_TRUE(NULL != target);
+  void* target =
+      reinterpret_cast<void*>(::GetProcAddress(ntdll_base, kFunctionName));
+  ASSERT_TRUE(target);
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  static_cast<WinXpResolverTest*>(resolver)->set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
   void* function_entry = resolver;
   size_t thunk_size = resolver->GetThunkSize();
@@ -253,16 +264,14 @@
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver->Setup(ntdll_base, NULL, kFunctionName, NULL,
-                        function_entry, thunk.get(), thunk_size,
-                        &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
   resolver->AllowLocalPatches();
-  ret = resolver->Setup(ntdll_base, NULL, kFunctionName, NULL,
-                        function_entry, thunk.get(), thunk_size,
-                        &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 