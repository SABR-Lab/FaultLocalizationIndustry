# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasource/TrackBuffersManager.cpp
# Commit: 098ce3586133
# Full Hash: 098ce3586133fe57aa1d53fe4bdf541b26243563
# Author: Chris Pearce <cpearce@mozilla.com>
# Date: 2019-06-14 10:00:22
# Regressor Bug: 1558364
# File Overlap Count: 1
# Description:
#   Bug 1558364 - Convert TrackBuffersManager::mPendingInput into a MediaSpan. r=jya
#   
#   This allows us to avoid a (probably small) copy when we stash the pending input.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D34662
# ==============================================================================

diff -r 2e64d8db2b4b -r 098ce3586133 dom/media/mediasource/TrackBuffersManager.cpp
--- a/dom/media/mediasource/TrackBuffersManager.cpp	Fri Jun 14 00:31:02 2019 +0000
+++ b/dom/media/mediasource/TrackBuffersManager.cpp	Fri Jun 14 00:31:06 2019 +0000
@@ -447,7 +447,7 @@
   }
 
   // 7. Remove all bytes from the input buffer.
-  mPendingInputBuffer = nullptr;
+  mPendingInputBuffer.reset();
   mInputBuffer.reset();
   if (mCurrentInputBuffer) {
     mCurrentInputBuffer->EvictAll();
@@ -787,8 +787,8 @@
           if (mPendingInputBuffer) {
             // We now have a complete media segment header. We can resume
             // parsing the data.
-            AppendDataToCurrentInputBuffer(mPendingInputBuffer);
-            mPendingInputBuffer = nullptr;
+            AppendDataToCurrentInputBuffer(*mPendingInputBuffer);
+            mPendingInputBuffer.reset();
           }
           mNewMediaSegmentStarted = false;
         } else {
@@ -797,10 +797,12 @@
           // 2. If the input buffer does not contain a complete media segment
           // header yet, then jump to the need more data step below.
           if (!mPendingInputBuffer) {
-            mPendingInputBuffer = new MediaByteBuffer();
+            mPendingInputBuffer = Some(MediaSpan(*mInputBuffer));
+          } else {
+            // Note we reset mInputBuffer below, so this won't end up appending
+            // the contents of mInputBuffer to itself.
+            mPendingInputBuffer->Append(*mInputBuffer);
           }
-          mPendingInputBuffer->AppendElements(mInputBuffer->Elements(),
-                                              mInputBuffer->Length());
 
           mInputBuffer.reset();
           NeedMoreData();
@@ -974,8 +976,7 @@
     // We had a partial media segment header stashed aside.
     // Reparse its content so we can continue parsing the current input buffer.
     int64_t start, end;
-    mParser->ParseStartAndEndTimestamps(MediaSpan(mPendingInputBuffer), start,
-                                        end);
+    mParser->ParseStartAndEndTimestamps(*mPendingInputBuffer, start, end);
     mProcessedInput += mPendingInputBuffer->Length();
   }
 
@@ -989,13 +990,6 @@
   mInputDemuxer->NotifyDataArrived();
 }
 
-void TrackBuffersManager::AppendDataToCurrentInputBuffer(
-    MediaByteBuffer* aData) {
-  MOZ_ASSERT(mCurrentInputBuffer);
-  mCurrentInputBuffer->AppendData(MediaSpan(aData));
-  mInputDemuxer->NotifyDataArrived();
-}
-
 void TrackBuffersManager::InitializationSegmentReceived() {
   MOZ_ASSERT(OnTaskQueue());
   MOZ_ASSERT(mParser->HasCompleteInitData());