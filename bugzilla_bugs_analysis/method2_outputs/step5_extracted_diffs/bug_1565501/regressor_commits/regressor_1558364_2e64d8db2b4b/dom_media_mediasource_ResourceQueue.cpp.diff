# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasource/ResourceQueue.cpp
# Commit: 2e64d8db2b4b
# Full Hash: 2e64d8db2b4b630e990903a57bc75c0bfbaca237
# Author: Chris Pearce <cpearce@mozilla.com>
# Date: 2019-06-14 10:00:22
# Regressor Bug: 1558364
# File Overlap Count: 1
# Description:
#   Bug 1558364 - Add MediaSpan and use it for TrackBuffersManager::mInputBuffer. r=jya
#   
#   As seen in this profile of a Twitch replay: https://perfht.ml/2K9Ydb3 we can
#   often end up spending time in TrackBuffersManager::CodedFrameProcessing()
#   shaving off bytes from the front off TrackBuffersManager::mInputBuffer. This
# ==============================================================================

diff -r 1eba4a29505b -r 2e64d8db2b4b dom/media/mediasource/ResourceQueue.cpp
--- a/dom/media/mediasource/ResourceQueue.cpp	Thu Jun 13 22:27:30 2019 +0000
+++ b/dom/media/mediasource/ResourceQueue.cpp	Fri Jun 14 00:31:02 2019 +0000
@@ -24,17 +24,11 @@
 
 namespace mozilla {
 
-ResourceItem::ResourceItem(MediaByteBuffer* aData, uint64_t aOffset)
+ResourceItem::ResourceItem(const MediaSpan& aData, uint64_t aOffset)
     : mData(aData), mOffset(aOffset) {}
 
 size_t ResourceItem::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const {
-  // size including this
-  size_t size = aMallocSizeOf(this);
-
-  // size excluding this
-  size += mData->ShallowSizeOfExcludingThis(aMallocSizeOf);
-
-  return size;
+  return aMallocSizeOf(this);
 }
 
 class ResourceQueueDeallocator : public nsDequeFunctor {
@@ -58,10 +52,10 @@
     return nullptr;
   }
   ResourceItem* item = ResourceAt(start);
-  if (offset + aSize > item->mData->Length()) {
+  if (offset + aSize > item->mData.Length()) {
     return nullptr;
   }
-  return item->mData->Elements() + offset;
+  return item->mData.Elements() + offset;
 }
 
 void ResourceQueue::CopyData(uint64_t aOffset, uint32_t aCount, char* aDest) {
@@ -70,9 +64,9 @@
   size_t i = start;
   while (i < uint32_t(GetSize()) && aCount > 0) {
     ResourceItem* item = ResourceAt(i++);
-    uint32_t bytes = std::min(aCount, uint32_t(item->mData->Length() - offset));
+    uint32_t bytes = std::min(aCount, uint32_t(item->mData.Length() - offset));
     if (bytes != 0) {
-      memcpy(aDest, &(*item->mData)[offset], bytes);
+      memcpy(aDest, item->mData.Elements() + offset, bytes);
       offset = 0;
       aCount -= bytes;
       aDest += bytes;
@@ -80,44 +74,37 @@
   }
 }
 
-void ResourceQueue::AppendItem(MediaByteBuffer* aData) {
+void ResourceQueue::AppendItem(const MediaSpan& aData) {
   uint64_t offset = mLogicalLength;
-  mLogicalLength += aData->Length();
+  mLogicalLength += aData.Length();
   Push(new ResourceItem(aData, offset));
 }
 
-uint32_t ResourceQueue::Evict(uint64_t aOffset, uint32_t aSizeToEvict,
-                              ErrorResult& aRv) {
+uint32_t ResourceQueue::Evict(uint64_t aOffset, uint32_t aSizeToEvict) {
   SBR_DEBUG("Evict(aOffset=%" PRIu64 ", aSizeToEvict=%u)", aOffset,
             aSizeToEvict);
-  return EvictBefore(std::min(aOffset, mOffset + (uint64_t)aSizeToEvict), aRv);
+  return EvictBefore(std::min(aOffset, mOffset + (uint64_t)aSizeToEvict));
 }
 
-uint32_t ResourceQueue::EvictBefore(uint64_t aOffset, ErrorResult& aRv) {
+uint32_t ResourceQueue::EvictBefore(uint64_t aOffset) {
   SBR_DEBUG("EvictBefore(%" PRIu64 ")", aOffset);
   uint32_t evicted = 0;
   while (ResourceItem* item = ResourceAt(0)) {
-    SBR_DEBUG("item=%p length=%zu offset=%" PRIu64, item, item->mData->Length(),
+    SBR_DEBUG("item=%p length=%zu offset=%" PRIu64, item, item->mData.Length(),
               mOffset);
-    if (item->mData->Length() + mOffset >= aOffset) {
+    if (item->mData.Length() + mOffset >= aOffset) {
       if (aOffset <= mOffset) {
         break;
       }
       uint32_t offset = aOffset - mOffset;
       mOffset += offset;
       evicted += offset;
-      RefPtr<MediaByteBuffer> data = new MediaByteBuffer;
-      if (!data->AppendElements(item->mData->Elements() + offset,
-                                item->mData->Length() - offset, fallible)) {
-        aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
-        return 0;
-      }
+      item->mData.RemoveFront(offset);
       item->mOffset += offset;
-      item->mData = data;
       break;
     }
-    mOffset += item->mData->Length();
-    evicted += item->mData->Length();
+    mOffset += item->mData.Length();
+    evicted += item->mData.Length();
     delete PopFront();
   }
   return evicted;
@@ -127,10 +114,10 @@
   SBR_DEBUG("EvictAll()");
   uint32_t evicted = 0;
   while (ResourceItem* item = ResourceAt(0)) {
-    SBR_DEBUG("item=%p length=%zu offset=%" PRIu64, item, item->mData->Length(),
+    SBR_DEBUG("item=%p length=%zu offset=%" PRIu64, item, item->mData.Length(),
               mOffset);
-    mOffset += item->mData->Length();
-    evicted += item->mData->Length();
+    mOffset += item->mData.Length();
+    evicted += item->mData.Length();
     delete PopFront();
   }
   return evicted;
@@ -140,10 +127,20 @@
   // Calculate the size of the internal deque.
   size_t size = nsDeque::SizeOfExcludingThis(aMallocSizeOf);
 
-  // Sum the ResourceItems.
+  // Sum the ResourceItems. The ResourceItems's MediaSpans may share the
+  // same underlying MediaByteBuffers, so we need to de-dupe the buffers
+  // in order to report an accurate size.
+  nsTArray<MediaByteBuffer*> buffers;
   for (uint32_t i = 0; i < uint32_t(GetSize()); ++i) {
     const ResourceItem* item = ResourceAt(i);
     size += item->SizeOfIncludingThis(aMallocSizeOf);
+    if (!buffers.Contains(item->mData.Buffer())) {
+      buffers.AppendElement(item->mData.Buffer());
+    }
+  }
+
+  for (MediaByteBuffer* buffer : buffers) {
+    size += buffer->ShallowSizeOfExcludingThis(aMallocSizeOf);
   }
 
   return size;
@@ -160,7 +157,7 @@
     if (!fp) {
       return;
     }
-    Unused << fwrite(item->mData->Elements(), item->mData->Length(), 1, fp);
+    Unused << fwrite(item->mData.Elements(), item->mData.Length(), 1, fp);
     fclose(fp);
   }
 }
@@ -180,13 +177,13 @@
     size_t mid = lo + (hi - lo) / 2;
     const ResourceItem* resource = ResourceAt(mid);
     if (resource->mOffset <= aOffset &&
-        aOffset < resource->mOffset + resource->mData->Length()) {
+        aOffset < resource->mOffset + resource->mData.Length()) {
       if (aResourceOffset) {
         *aResourceOffset = aOffset - resource->mOffset;
       }
       return uint32_t(mid);
     }
-    if (resource->mOffset + resource->mData->Length() <= aOffset) {
+    if (resource->mOffset + resource->mData.Length() <= aOffset) {
       lo = mid + 1;
     } else {
       hi = mid;