# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasource/TrackBuffersManager.cpp
# Commit: 2e64d8db2b4b
# Full Hash: 2e64d8db2b4b630e990903a57bc75c0bfbaca237
# Author: Chris Pearce <cpearce@mozilla.com>
# Date: 2019-06-14 10:00:22
# Regressor Bug: 1558364
# File Overlap Count: 1
# Description:
#   Bug 1558364 - Add MediaSpan and use it for TrackBuffersManager::mInputBuffer. r=jya
#   
#   As seen in this profile of a Twitch replay: https://perfht.ml/2K9Ydb3 we can
#   often end up spending time in TrackBuffersManager::CodedFrameProcessing()
#   shaving off bytes from the front off TrackBuffersManager::mInputBuffer. This
# ==============================================================================

diff -r 1eba4a29505b -r 2e64d8db2b4b dom/media/mediasource/TrackBuffersManager.cpp
--- a/dom/media/mediasource/TrackBuffersManager.cpp	Thu Jun 13 22:27:30 2019 +0000
+++ b/dom/media/mediasource/TrackBuffersManager.cpp	Fri Jun 14 00:31:02 2019 +0000
@@ -93,8 +93,7 @@
 
 TrackBuffersManager::TrackBuffersManager(MediaSourceDecoder* aParentDecoder,
                                          const MediaContainerType& aType)
-    : mInputBuffer(new MediaByteBuffer),
-      mBufferFull(false),
+    : mBufferFull(false),
       mFirstInitializationSegmentReceived(false),
       mChangeTypeReceived(false),
       mNewMediaSegmentStarted(false),
@@ -211,10 +210,11 @@
   switch (task->GetType()) {
     case Type::AppendBuffer:
       mCurrentTask = task;
-      if (!mInputBuffer) {
-        mInputBuffer = task->As<AppendBufferTask>()->mBuffer;
-      } else if (!mInputBuffer->AppendElements(
-                     *task->As<AppendBufferTask>()->mBuffer, fallible)) {
+      if (!mInputBuffer || mInputBuffer->IsEmpty()) {
+        // Note: we reset mInputBuffer here to ensure it doesn't grow unbounded.
+        mInputBuffer.reset();
+        mInputBuffer = Some(MediaSpan(task->As<AppendBufferTask>()->mBuffer));
+      } else if (!mInputBuffer->Append(task->As<AppendBufferTask>()->mBuffer)) {
         RejectAppend(NS_ERROR_OUT_OF_MEMORY, __func__);
         return;
       }
@@ -448,7 +448,7 @@
 
   // 7. Remove all bytes from the input buffer.
   mPendingInputBuffer = nullptr;
-  mInputBuffer = nullptr;
+  mInputBuffer.reset();
   if (mCurrentInputBuffer) {
     mCurrentInputBuffer->EvictAll();
     // The demuxer will be recreated during the next run of SegmentParserLoop.
@@ -470,8 +470,7 @@
     CreateDemuxerforMIMEType();
     // Recreate our input buffer. We can't directly assign the initData buffer
     // to mInputBuffer as it will get modified in the Segment Parser Loop.
-    mInputBuffer = new MediaByteBuffer;
-    mInputBuffer->AppendElements(*mInitData);
+    mInputBuffer = Some(MediaSpan::WithCopyOf(mInitData));
     RecreateParser(true);
   } else {
     RecreateParser(false);
@@ -705,7 +704,8 @@
     // steps:
     if (mSourceBufferAttributes->GetAppendState() ==
         AppendState::WAITING_FOR_SEGMENT) {
-      MediaResult haveInitSegment = mParser->IsInitSegmentPresent(mInputBuffer);
+      MediaResult haveInitSegment =
+          mParser->IsInitSegmentPresent(*mInputBuffer);
       if (NS_SUCCEEDED(haveInitSegment)) {
         SetAppendState(AppendState::PARSING_INIT_SEGMENT);
         if (mFirstInitializationSegmentReceived && !mChangeTypeReceived) {
@@ -715,7 +715,7 @@
         continue;
       }
       MediaResult haveMediaSegment =
-          mParser->IsMediaSegmentPresent(mInputBuffer);
+          mParser->IsMediaSegmentPresent(*mInputBuffer);
       if (NS_SUCCEEDED(haveMediaSegment)) {
         SetAppendState(AppendState::PARSING_MEDIA_SEGMENT);
         mNewMediaSegmentStarted = true;
@@ -740,7 +740,7 @@
 
     int64_t start, end;
     MediaResult newData =
-        mParser->ParseStartAndEndTimestamps(mInputBuffer, start, end);
+        mParser->ParseStartAndEndTimestamps(*mInputBuffer, start, end);
     if (!NS_SUCCEEDED(newData) && newData.Code() != NS_ERROR_NOT_AVAILABLE) {
       RejectAppend(newData, __func__);
       return;
@@ -752,7 +752,7 @@
     if (mSourceBufferAttributes->GetAppendState() ==
         AppendState::PARSING_INIT_SEGMENT) {
       if (mParser->InitSegmentRange().IsEmpty()) {
-        mInputBuffer = nullptr;
+        mInputBuffer.reset();
         NeedMoreData();
         return;
       }
@@ -797,11 +797,12 @@
           // 2. If the input buffer does not contain a complete media segment
           // header yet, then jump to the need more data step below.
           if (!mPendingInputBuffer) {
-            mPendingInputBuffer = mInputBuffer;
-          } else {
-            mPendingInputBuffer->AppendElements(*mInputBuffer);
+            mPendingInputBuffer = new MediaByteBuffer();
           }
-          mInputBuffer = nullptr;
+          mPendingInputBuffer->AppendElements(mInputBuffer->Elements(),
+                                              mInputBuffer->Length());
+
+          mInputBuffer.reset();
           NeedMoreData();
           return;
         }
@@ -973,7 +974,8 @@
     // We had a partial media segment header stashed aside.
     // Reparse its content so we can continue parsing the current input buffer.
     int64_t start, end;
-    mParser->ParseStartAndEndTimestamps(mPendingInputBuffer, start, end);
+    mParser->ParseStartAndEndTimestamps(MediaSpan(mPendingInputBuffer), start,
+                                        end);
     mProcessedInput += mPendingInputBuffer->Length();
   }
 
@@ -981,9 +983,16 @@
 }
 
 void TrackBuffersManager::AppendDataToCurrentInputBuffer(
+    const MediaSpan& aData) {
+  MOZ_ASSERT(mCurrentInputBuffer);
+  mCurrentInputBuffer->AppendData(aData);
+  mInputDemuxer->NotifyDataArrived();
+}
+
+void TrackBuffersManager::AppendDataToCurrentInputBuffer(
     MediaByteBuffer* aData) {
   MOZ_ASSERT(mCurrentInputBuffer);
-  mCurrentInputBuffer->AppendData(aData);
+  mCurrentInputBuffer->AppendData(MediaSpan(aData));
   mInputDemuxer->NotifyDataArrived();
 }
 
@@ -1007,12 +1016,8 @@
   // to the resource.
   mCurrentInputBuffer->AppendData(mParser->InitData());
   uint32_t length = endInit - (mProcessedInput - mInputBuffer->Length());
-  if (mInputBuffer->Length() == length) {
-    mInputBuffer = nullptr;
-  } else {
-    MOZ_RELEASE_ASSERT(length <= mInputBuffer->Length());
-    mInputBuffer->RemoveElementsAt(0, length);
-  }
+  MOZ_RELEASE_ASSERT(length <= mInputBuffer->Length());
+  mInputBuffer->RemoveFront(length);
   CreateDemuxerforMIMEType();
   if (!mInputDemuxer) {
     NS_WARNING("TODO type not supported");
@@ -1337,8 +1342,8 @@
 
   MediaByteRange mediaRange = mParser->MediaSegmentRange();
   if (mediaRange.IsEmpty()) {
-    AppendDataToCurrentInputBuffer(mInputBuffer);
-    mInputBuffer = nullptr;
+    AppendDataToCurrentInputBuffer(*mInputBuffer);
+    mInputBuffer.reset();
   } else {
     MOZ_ASSERT(mProcessedInput >= mInputBuffer->Length());
     if (int64_t(mProcessedInput - mInputBuffer->Length()) > mediaRange.mEnd) {
@@ -1360,13 +1365,8 @@
       CompleteCodedFrameProcessing();
       return p;
     }
-    RefPtr<MediaByteBuffer> segment = new MediaByteBuffer;
-    if (!segment->AppendElements(mInputBuffer->Elements(), length, fallible)) {
-      return CodedFrameProcessingPromise::CreateAndReject(
-          NS_ERROR_OUT_OF_MEMORY, __func__);
-    }
-    AppendDataToCurrentInputBuffer(segment);
-    mInputBuffer->RemoveElementsAt(0, length);
+    AppendDataToCurrentInputBuffer(mInputBuffer->To(length));
+    mInputBuffer->RemoveFront(length);
   }
 
   RefPtr<CodedFrameProcessingPromise> p = mProcessingPromise.Ensure(__func__);
@@ -1543,13 +1543,7 @@
                HasAudio() ? mAudioTracks.mDemuxer->GetEvictionOffset(
                                 mAudioTracks.mLastParsedEndTime)
                           : INT64_MAX);
-  ErrorResult rv;
-  mCurrentInputBuffer->EvictBefore(safeToEvict, rv);
-  if (rv.Failed()) {
-    rv.SuppressException();
-    RejectProcessing(NS_ERROR_OUT_OF_MEMORY, __func__);
-    return;
-  }
+  mCurrentInputBuffer->EvictBefore(safeToEvict);
 
   mInputDemuxer->NotifyDataRemoved();
   RecreateParser(true);
@@ -2252,7 +2246,7 @@
   DDLINKCHILD("parser", mParser.get());
   if (aReuseInitData && mInitData) {
     int64_t start, end;
-    mParser->ParseStartAndEndTimestamps(mInitData, start, end);
+    mParser->ParseStartAndEndTimestamps(MediaSpan(mInitData), start, end);
     mProcessedInput = mInitData->Length();
   } else {
     mProcessedInput = 0;