# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/location.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/location.cc
--- a/security/sandbox/chromium/base/location.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/location.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -2,17 +2,24 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "build/build_config.h"
+#include "base/location.h"
 
 #if defined(COMPILER_MSVC)
 #include <intrin.h>
 #endif
 
-#include "base/location.h"
+#include "base/compiler_specific.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/stringprintf.h"
+#include "build/build_config.h"
 
-namespace tracked_objects {
+namespace base {
+
+Location::Location() = default;
+Location::Location(const Location& other) = default;
+
+Location::Location(const char* file_name, const void* program_counter)
+    : file_name_(file_name), program_counter_(program_counter) {}
 
 Location::Location(const char* function_name,
                    const char* file_name,
@@ -22,85 +29,49 @@
       file_name_(file_name),
       line_number_(line_number),
       program_counter_(program_counter) {
-}
-
-Location::Location()
-    : function_name_("Unknown"),
-      file_name_("Unknown"),
-      line_number_(-1),
-      program_counter_(NULL) {
-}
-
-Location::Location(const Location& other)
-    : function_name_(other.function_name_),
-      file_name_(other.file_name_),
-      line_number_(other.line_number_),
-      program_counter_(other.program_counter_) {
+#if !defined(OS_NACL)
+  // The program counter should not be null except in a default constructed
+  // (empty) Location object. This value is used for identity, so if it doesn't
+  // uniquely identify a location, things will break.
+  //
+  // The program counter isn't supported in NaCl so location objects won't work
+  // properly in that context.
+  DCHECK(program_counter);
+#endif
 }
 
 std::string Location::ToString() const {
-  return std::string(function_name_) + "@" + file_name_ + ":" +
-      base::IntToString(line_number_);
-}
-
-void Location::Write(bool display_filename, bool display_function_name,
-                     std::string* output) const {
-  base::StringAppendF(output, "%s[%d] ",
-      display_filename ? file_name_ : "line",
-      line_number_);
-
-  if (display_function_name) {
-    WriteFunctionName(output);
-    output->push_back(' ');
+  if (has_source_info()) {
+    return std::string(function_name_) + "@" + file_name_ + ":" +
+           IntToString(line_number_);
   }
+  return StringPrintf("pc:%p", program_counter_);
 }
 
-void Location::WriteFunctionName(std::string* output) const {
-  // Translate "<" to "&lt;" for HTML safety.
-  // TODO(jar): Support ASCII or html for logging in ASCII.
-  for (const char *p = function_name_; *p; p++) {
-    switch (*p) {
-      case '<':
-        output->append("&lt;");
-        break;
+#if defined(COMPILER_MSVC)
+#define RETURN_ADDRESS() _ReturnAddress()
+#elif defined(COMPILER_GCC) && !defined(OS_NACL)
+#define RETURN_ADDRESS() \
+  __builtin_extract_return_addr(__builtin_return_address(0))
+#else
+#define RETURN_ADDRESS() nullptr
+#endif
 
-      case '>':
-        output->append("&gt;");
-        break;
+// static
+NOINLINE Location Location::CreateFromHere(const char* file_name) {
+  return Location(file_name, RETURN_ADDRESS());
+}
 
-      default:
-        output->push_back(*p);
-        break;
-    }
-  }
+// static
+NOINLINE Location Location::CreateFromHere(const char* function_name,
+                                           const char* file_name,
+                                           int line_number) {
+  return Location(function_name, file_name, line_number, RETURN_ADDRESS());
 }
 
 //------------------------------------------------------------------------------
-LocationSnapshot::LocationSnapshot() : line_number(-1) {
-}
-
-LocationSnapshot::LocationSnapshot(
-    const tracked_objects::Location& location)
-    : file_name(location.file_name()),
-      function_name(location.function_name()),
-      line_number(location.line_number()) {
-}
-
-LocationSnapshot::~LocationSnapshot() {
+NOINLINE const void* GetProgramCounter() {
+  return RETURN_ADDRESS();
 }
 
-//------------------------------------------------------------------------------
-#if defined(COMPILER_MSVC)
-__declspec(noinline)
-#endif
-BASE_EXPORT const void* GetProgramCounter() {
-#if defined(COMPILER_MSVC)
-  return _ReturnAddress();
-#elif defined(COMPILER_GCC) && !defined(OS_NACL)
-  return __builtin_extract_return_addr(__builtin_return_address(0));
-#else
-  return NULL;
-#endif
-}
-
-}  // namespace tracked_objects
+}  // namespace base