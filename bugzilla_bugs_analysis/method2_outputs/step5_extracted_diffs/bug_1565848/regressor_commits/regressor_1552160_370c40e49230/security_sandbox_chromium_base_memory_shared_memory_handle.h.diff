# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/memory/shared_memory_handle.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/memory/shared_memory_handle.h
--- a/security/sandbox/chromium/base/memory/shared_memory_handle.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/memory/shared_memory_handle.h	Wed Jun 12 11:10:48 2019 +0100
@@ -11,17 +11,18 @@
 #include "build/build_config.h"
 
 #if defined(OS_WIN)
-#include <windows.h>
 #include "base/process/process_handle.h"
+#include "base/win/windows_types.h"
 #elif defined(OS_MACOSX) && !defined(OS_IOS)
 #include <mach/mach.h>
 #include "base/base_export.h"
-#include "base/file_descriptor_posix.h"
 #include "base/macros.h"
 #include "base/process/process_handle.h"
 #elif defined(OS_POSIX)
 #include <sys/types.h>
 #include "base/file_descriptor_posix.h"
+#elif defined(OS_FUCHSIA)
+#include <zircon/types.h>
 #endif
 
 namespace base {
@@ -74,34 +75,31 @@
   // Returns the size of the memory region that SharedMemoryHandle points to.
   size_t GetSize() const;
 
-#if defined(OS_MACOSX) && !defined(OS_IOS)
-  enum Type {
-    // The SharedMemoryHandle is backed by a POSIX fd.
-    POSIX,
-    // The SharedMemoryHandle is backed by the Mach primitive "memory object".
-    MACH,
-  };
-
-  // Constructs a SharedMemoryHandle backed by the components of a
-  // FileDescriptor. The newly created instance has the same ownership semantics
-  // as base::FileDescriptor. This typically means that the SharedMemoryHandle
-  // takes ownership of the |fd| if |auto_close| is true. Unfortunately, it's
-  // common for existing code to make shallow copies of SharedMemoryHandle, and
-  // the one that is finally passed into a base::SharedMemory is the one that
-  // "consumes" the fd.
+#if defined(OS_WIN)
+  // Takes implicit ownership of |h|.
   // |guid| uniquely identifies the shared memory region pointed to by the
-  // underlying OS resource. If |file_descriptor| is associated with another
+  // underlying OS resource. If the HANDLE is associated with another
   // SharedMemoryHandle, the caller must pass the |guid| of that
   // SharedMemoryHandle. Otherwise, the caller should generate a new
   // UnguessableToken.
-  // |size| refers to the size of the memory region pointed to by
-  // file_descriptor.fd. Passing the wrong |size| has no immediate consequence,
-  // but may cause errors when trying to map the SharedMemoryHandle at a later
-  // point in time.
-  SharedMemoryHandle(const base::FileDescriptor& file_descriptor,
+  // Passing the wrong |size| has no immediate consequence, but may cause errors
+  // when trying to map the SharedMemoryHandle at a later point in time.
+  SharedMemoryHandle(HANDLE h, size_t size, const base::UnguessableToken& guid);
+  HANDLE GetHandle() const;
+#elif defined(OS_FUCHSIA)
+  // Takes implicit ownership of |h|.
+  // |guid| uniquely identifies the shared memory region pointed to by the
+  // underlying OS resource. If the zx_handle_t is associated with another
+  // SharedMemoryHandle, the caller must pass the |guid| of that
+  // SharedMemoryHandle. Otherwise, the caller should generate a new
+  // UnguessableToken.
+  // Passing the wrong |size| has no immediate consequence, but may cause errors
+  // when trying to map the SharedMemoryHandle at a later point in time.
+  SharedMemoryHandle(zx_handle_t h,
                      size_t size,
                      const base::UnguessableToken& guid);
-
+  zx_handle_t GetHandle() const;
+#elif defined(OS_MACOSX) && !defined(OS_IOS)
   // Makes a Mach-based SharedMemoryHandle of the given size. On error,
   // subsequent calls to IsValid() return false.
   // Passing the wrong |size| has no immediate consequence, but may cause errors
@@ -125,42 +123,7 @@
   // On success, |memory| is an output variable that contains the start of the
   // mapped memory.
   bool MapAt(off_t offset, size_t bytes, void** memory, bool read_only);
-#elif defined(OS_FUCHSIA)
-  // Takes implicit ownership of |h|.
-  // |guid| uniquely identifies the shared memory region pointed to by the
-  // underlying OS resource. If the mx_handle_t is associated with another
-  // SharedMemoryHandle, the caller must pass the |guid| of that
-  // SharedMemoryHandle. Otherwise, the caller should generate a new
-  // UnguessableToken.
-  // Passing the wrong |size| has no immediate consequence, but may cause errors
-  // when trying to map the SharedMemoryHandle at a later point in time.
-  SharedMemoryHandle(mx_handle_t h,
-                     size_t size,
-                     const base::UnguessableToken& guid);
-  mx_handle_t GetHandle() const;
-#elif defined(OS_WIN)
-  // Takes implicit ownership of |h|.
-  // |guid| uniquely identifies the shared memory region pointed to by the
-  // underlying OS resource. If the HANDLE is associated with another
-  // SharedMemoryHandle, the caller must pass the |guid| of that
-  // SharedMemoryHandle. Otherwise, the caller should generate a new
-  // UnguessableToken.
-  // Passing the wrong |size| has no immediate consequence, but may cause errors
-  // when trying to map the SharedMemoryHandle at a later point in time.
-  SharedMemoryHandle(HANDLE h, size_t size, const base::UnguessableToken& guid);
-  HANDLE GetHandle() const;
-#else
-  // |guid| uniquely identifies the shared memory region pointed to by the
-  // underlying OS resource. If |file_descriptor| is associated with another
-  // SharedMemoryHandle, the caller must pass the |guid| of that
-  // SharedMemoryHandle. Otherwise, the caller should generate a new
-  // UnguessableToken.
-  // Passing the wrong |size| has no immediate consequence, but may cause errors
-  // when trying to map the SharedMemoryHandle at a later point in time.
-  SharedMemoryHandle(const base::FileDescriptor& file_descriptor,
-                     size_t size,
-                     const base::UnguessableToken& guid);
-
+#elif defined(OS_POSIX)
   // Creates a SharedMemoryHandle from an |fd| supplied from an external
   // service.
   // Passing the wrong |size| has no immediate consequence, but may cause errors
@@ -175,31 +138,45 @@
   int Release();
 #endif
 
- private:
-#if defined(OS_MACOSX) && !defined(OS_IOS)
-  friend class SharedMemory;
+#if defined(OS_ANDROID)
+  // Marks the current file descriptor as read-only, for the purpose of
+  // mapping. This is independent of the region's read-only status.
+  void SetReadOnly() { read_only_ = true; }
 
-  Type type_ = MACH;
+  // Returns true iff the descriptor is to be used for read-only
+  // mappings.
+  bool IsReadOnly() const { return read_only_; }
 
-  // Each instance of a SharedMemoryHandle is backed either by a POSIX fd or a
-  // mach port. |type_| determines the backing member.
-  union {
-    FileDescriptor file_descriptor_;
+  // Returns true iff the corresponding region is read-only.
+  bool IsRegionReadOnly() const;
+
+  // Try to set the region read-only. This will fail any future attempt
+  // at read-write mapping.
+  bool SetRegionReadOnly() const;
+#endif
 
-    struct {
-      mach_port_t memory_object_ = MACH_PORT_NULL;
+#if defined(OS_POSIX) && !(defined(OS_MACOSX) && !defined(OS_IOS))
+  // Constructs a SharedMemoryHandle backed by a FileDescriptor. The newly
+  // created instance has the same ownership semantics as base::FileDescriptor.
+  // This typically means that the SharedMemoryHandle takes ownership of the
+  // |fd| if |auto_close| is true. Unfortunately, it's common for existing code
+  // to make shallow copies of SharedMemoryHandle, and the one that is finally
+  // passed into a base::SharedMemory is the one that "consumes" the fd.
+  //
+  // |guid| uniquely identifies the shared memory region pointed to by the
+  // underlying OS resource. If |file_descriptor| is associated with another
+  // SharedMemoryHandle, the caller must pass the |guid| of that
+  // SharedMemoryHandle. Otherwise, the caller should generate a new
+  // UnguessableToken.
+  // Passing the wrong |size| has no immediate consequence, but may cause errors
+  // when trying to map the SharedMemoryHandle at a later point in time.
+  SharedMemoryHandle(const base::FileDescriptor& file_descriptor,
+                     size_t size,
+                     const base::UnguessableToken& guid);
+#endif
 
-      // Whether passing this object as a parameter to an IPC message passes
-      // ownership of |memory_object_| to the IPC stack. This is meant to mimic
-      // the behavior of the |auto_close| parameter of FileDescriptor.
-      // Defaults to |false|.
-      bool ownership_passes_to_ipc_ = false;
-    };
-  };
-#elif defined(OS_FUCHSIA)
-  mx_handle_t handle_ = MX_HANDLE_INVALID;
-  bool ownership_passes_to_ipc_ = false;
-#elif defined(OS_WIN)
+ private:
+#if defined(OS_WIN)
   HANDLE handle_ = nullptr;
 
   // Whether passing this object as a parameter to an IPC message passes
@@ -208,7 +185,27 @@
   // affects attachment-brokered SharedMemoryHandles.
   // Defaults to |false|.
   bool ownership_passes_to_ipc_ = false;
-#else
+#elif defined(OS_FUCHSIA)
+  zx_handle_t handle_ = ZX_HANDLE_INVALID;
+  bool ownership_passes_to_ipc_ = false;
+#elif defined(OS_MACOSX) && !defined(OS_IOS)
+  friend class SharedMemory;
+  friend bool CheckReadOnlySharedMemoryHandleForTesting(
+      SharedMemoryHandle handle);
+
+  mach_port_t memory_object_ = MACH_PORT_NULL;
+
+  // Whether passing this object as a parameter to an IPC message passes
+  // ownership of |memory_object_| to the IPC stack. This is meant to mimic
+  // the behavior of the |auto_close| parameter of FileDescriptor.
+  // Defaults to |false|.
+  bool ownership_passes_to_ipc_ = false;
+#elif defined(OS_ANDROID)
+  friend class SharedMemory;
+
+  FileDescriptor file_descriptor_;
+  bool read_only_ = false;
+#elif defined(OS_POSIX)
   FileDescriptor file_descriptor_;
 #endif
 