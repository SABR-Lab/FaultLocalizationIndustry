# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/process/launch.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/process/launch.h
--- a/security/sandbox/chromium/base/process/launch.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/process/launch.h	Wed Jun 12 11:10:48 2019 +0100
@@ -21,14 +21,19 @@
 #include "base/strings/string_piece.h"
 #include "build/build_config.h"
 
-#if defined(OS_POSIX)
-#include "base/posix/file_descriptor_shuffle.h"
-#elif defined(OS_WIN)
+#if defined(OS_WIN)
 #include <windows.h>
+#elif defined(OS_FUCHSIA)
+#include <lib/fdio/spawn.h>
+#include <zircon/types.h>
 #endif
 
-#if defined(OS_FUCHSIA)
-#include <magenta/types.h>
+#if defined(OS_POSIX) || defined(OS_FUCHSIA)
+#include "base/posix/file_descriptor_shuffle.h"
+#endif
+
+#if defined(OS_MACOSX) && !defined(OS_IOS)
+#include "base/mac/mach_port_rendezvous.h"
 #endif
 
 namespace base {
@@ -37,30 +42,31 @@
 
 #if defined(OS_WIN)
 typedef std::vector<HANDLE> HandlesToInheritVector;
-#endif
-
-#if defined(OS_FUCHSIA)
+#elif defined(OS_FUCHSIA)
+struct PathToTransfer {
+  base::FilePath path;
+  zx_handle_t handle;
+};
 struct HandleToTransfer {
   uint32_t id;
-  mx_handle_t handle;
+  zx_handle_t handle;
 };
 typedef std::vector<HandleToTransfer> HandlesToTransferVector;
-#endif
-
-#if defined(OS_POSIX)
 typedef std::vector<std::pair<int, int>> FileHandleMappingVector;
-#endif
+#elif defined(OS_POSIX)
+typedef std::vector<std::pair<int, int>> FileHandleMappingVector;
+#endif  // defined(OS_WIN)
 
 // Options for launching a subprocess that are passed to LaunchProcess().
 // The default constructor constructs the object with default options.
 struct BASE_EXPORT LaunchOptions {
-#if defined(OS_POSIX)
+#if (defined(OS_POSIX) || defined(OS_FUCHSIA)) && !defined(OS_MACOSX)
   // Delegate to be run in between fork and exec in the subprocess (see
   // pre_exec_delegate below)
   class BASE_EXPORT PreExecDelegate {
    public:
-    PreExecDelegate() {}
-    virtual ~PreExecDelegate() {}
+    PreExecDelegate() = default;
+    virtual ~PreExecDelegate() = default;
 
     // Since this is to be run between fork and exec, and fork may have happened
     // while multiple threads were running, this function needs to be async
@@ -85,6 +91,10 @@
 #if defined(OS_WIN)
   bool start_hidden = false;
 
+  // Sets STARTF_FORCEOFFFEEDBACK so that the feedback cursor is forced off
+  // while the process is starting.
+  bool feedback_cursor_off = false;
+
   // Windows can inherit handles when it launches child processes.
   // See https://blogs.msdn.microsoft.com/oldnewthing/20111216-00/?p=8873
   // for a good overview of Windows handle inheritance.
@@ -150,7 +160,11 @@
   // CREATE_BREAKAWAY_FROM_JOB flag which allows it to breakout of the parent
   // job if any.
   bool force_breakaway_from_job_ = false;
-#else  // !defined(OS_WIN)
+
+  // If set to true, permission to bring windows to the foreground is passed to
+  // the launched process if the current process has such permission.
+  bool grant_foreground_privilege = false;
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
   // Set/unset environment variables. These are applied on top of the parent
   // process environment.  Empty (the default) means to inherit the same
   // environment. See AlterEnvironment().
@@ -163,16 +177,7 @@
   // Remap file descriptors according to the mapping of src_fd->dest_fd to
   // propagate FDs into the child process.
   FileHandleMappingVector fds_to_remap;
-
-  // Each element is an RLIMIT_* constant that should be raised to its
-  // rlim_max.  This pointer is owned by the caller and must live through
-  // the call to LaunchProcess().
-  const std::vector<int>* maximize_rlimits = nullptr;
-
-  // If true, start the process in a new process group, instead of
-  // inheriting the parent's process group.  The pgid of the child process
-  // will be the same as its pid.
-  bool new_process_group = false;
+#endif  // defined(OS_WIN)
 
 #if defined(OS_LINUX)
   // If non-zero, start the process using clone(), using flags as provided.
@@ -189,15 +194,56 @@
   bool kill_on_parent_death = false;
 #endif  // defined(OS_LINUX)
 
+#if defined(OS_MACOSX) && !defined(OS_IOS)
+  // Mach ports that will be accessible to the child process. These are not
+  // directly inherited across process creation, but they are stored by a Mach
+  // IPC server that a child process can communicate with to retrieve them.
+  //
+  // After calling LaunchProcess(), any rights that were transferred with MOVE
+  // dispositions will be consumed, even on failure.
+  //
+  // See base/mac/mach_port_rendezvous.h for details.
+  MachPortsForRendezvous mach_ports_for_rendezvous;
+#endif
+
 #if defined(OS_FUCHSIA)
   // If valid, launches the application in that job object.
-  mx_handle_t job_handle = MX_HANDLE_INVALID;
+  zx_handle_t job_handle = ZX_HANDLE_INVALID;
 
   // Specifies additional handles to transfer (not duplicate) to the child
-  // process. The handles remain valid in this process if launch fails.
-  // Each entry is an <id,handle> pair, with an |id| created using the PA_HND()
-  // macro. The child retrieves the handle |mx_get_startup_handle(id)|.
+  // process. Each entry is an <id,handle> pair, with an |id| created using the
+  // PA_HND() macro. The child retrieves the handle
+  // |zx_take_startup_handle(id)|. The supplied handles are consumed by
+  // LaunchProcess() even on failure.
+  // Note that PA_USER1 ids are reserved for use by AddHandleToTransfer(), below
+  // and by convention PA_USER0 is reserved for use by the embedding
+  // application.
   HandlesToTransferVector handles_to_transfer;
+
+  // Allocates a unique id for |handle| in |handles_to_transfer|, inserts it,
+  // and returns the generated id.
+  static uint32_t AddHandleToTransfer(
+      HandlesToTransferVector* handles_to_transfer,
+      zx_handle_t handle);
+
+  // Specifies which basic capabilities to grant to the child process.
+  // By default the child process will receive the caller's complete namespace,
+  // access to the current base::fuchsia::DefaultJob(), handles for stdio and
+  // access to the dynamic library loader.
+  // Note that the child is always provided access to the loader service.
+  uint32_t spawn_flags = FDIO_SPAWN_CLONE_NAMESPACE | FDIO_SPAWN_CLONE_STDIO |
+                         FDIO_SPAWN_CLONE_JOB;
+
+  // Specifies paths to clone from the calling process' namespace into that of
+  // the child process. If |paths_to_clone| is empty then the process will
+  // receive either a full copy of the parent's namespace, or an empty one,
+  // depending on whether FDIO_SPAWN_CLONE_NAMESPACE is set.
+  std::vector<FilePath> paths_to_clone;
+
+  // Specifies handles which will be installed as files or directories in the
+  // child process' namespace. Paths installed by |paths_to_clone| will be
+  // overridden by these entries.
+  std::vector<PathToTransfer> paths_to_transfer;
 #endif  // defined(OS_FUCHSIA)
 
 #if defined(OS_POSIX)
@@ -206,6 +252,7 @@
   // argv[0].
   base::FilePath real_path;
 
+#if !defined(OS_MACOSX)
   // If non-null, a delegate to be run immediately prior to executing the new
   // program in the child process.
   //
@@ -213,6 +260,17 @@
   // code running in this delegate essentially needs to be async-signal safe
   // (see man 7 signal for a list of allowed functions).
   PreExecDelegate* pre_exec_delegate = nullptr;
+#endif  // !defined(OS_MACOSX)
+
+  // Each element is an RLIMIT_* constant that should be raised to its
+  // rlim_max.  This pointer is owned by the caller and must live through
+  // the call to LaunchProcess().
+  const std::vector<int>* maximize_rlimits = nullptr;
+
+  // If true, start the process in a new process group, instead of
+  // inheriting the parent's process group.  The pgid of the child process
+  // will be the same as its pid.
+  bool new_process_group = false;
 #endif  // defined(OS_POSIX)
 
 #if defined(OS_CHROMEOS)
@@ -220,7 +278,6 @@
   // process' controlling terminal.
   int ctrl_terminal_fd = -1;
 #endif  // defined(OS_CHROMEOS)
-#endif  // !defined(OS_WIN)
 };
 
 // Launch a process via the command line |cmdline|.
@@ -261,7 +318,7 @@
 BASE_EXPORT Process LaunchElevatedProcess(const CommandLine& cmdline,
                                           const LaunchOptions& options);
 
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 // A POSIX-specific version of LaunchProcess that takes an argv array
 // instead of a CommandLine.  Useful for situations where you need to
 // control the command line arguments directly, but prefer the
@@ -269,11 +326,13 @@
 BASE_EXPORT Process LaunchProcess(const std::vector<std::string>& argv,
                                   const LaunchOptions& options);
 
+#if !defined(OS_MACOSX)
 // Close all file descriptors, except those which are a destination in the
 // given multimap. Only call this function in a child process where you know
 // that there aren't any other threads.
 BASE_EXPORT void CloseSuperfluousFds(const InjectiveMultimap& saved_map);
-#endif  // defined(OS_POSIX)
+#endif  // defined(OS_MACOSX)
+#endif  // defined(OS_WIN)
 
 #if defined(OS_WIN)
 // Set |job_object|'s JOBOBJECT_EXTENDED_LIMIT_INFORMATION
@@ -307,9 +366,7 @@
 // instead of a CommandLine object. Useful for situations where you need to
 // control the command line arguments directly.
 BASE_EXPORT bool GetAppOutput(const StringPiece16& cl, std::string* output);
-#endif
-
-#if defined(OS_POSIX)
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 // A POSIX-specific version of GetAppOutput that takes an argv array
 // instead of a CommandLine.  Useful for situations where you need to
 // control the command line arguments directly.
@@ -320,29 +377,12 @@
 // stderr.
 BASE_EXPORT bool GetAppOutputAndError(const std::vector<std::string>& argv,
                                       std::string* output);
-#endif  // defined(OS_POSIX)
+#endif  // defined(OS_WIN)
 
 // If supported on the platform, and the user has sufficent rights, increase
 // the current process's scheduling priority to a high priority.
 BASE_EXPORT void RaiseProcessToHighPriority();
 
-#if defined(OS_MACOSX)
-// An implementation of LaunchProcess() that uses posix_spawn() instead of
-// fork()+exec(). This does not support the |pre_exec_delegate| and
-// |current_directory| options.
-Process LaunchProcessPosixSpawn(const std::vector<std::string>& argv,
-                                const LaunchOptions& options);
-
-// Restore the default exception handler, setting it to Apple Crash Reporter
-// (ReportCrash).  When forking and execing a new process, the child will
-// inherit the parent's exception ports, which may be set to the Breakpad
-// instance running inside the parent.  The parent's Breakpad instance should
-// not handle the child's exceptions.  Calling RestoreDefaultExceptionHandler
-// in the child after forking will restore the standard exception handler.
-// See http://crbug.com/20371/ for more details.
-void RestoreDefaultExceptionHandler();
-#endif  // defined(OS_MACOSX)
-
 // Creates a LaunchOptions object suitable for launching processes in a test
 // binary. This should not be called in production/released code.
 BASE_EXPORT LaunchOptions LaunchOptionsForTest();
@@ -354,9 +394,7 @@
 //
 // This function uses the libc clone wrapper (which updates libc's pid cache)
 // internally, so callers may expect things like getpid() to work correctly
-// after in both the child and parent. An exception is when this code is run
-// under Valgrind. Valgrind does not support the libc clone wrapper, so the libc
-// pid cache may be incorrect after this function is called under Valgrind.
+// after in both the child and parent.
 //
 // As with fork(), callers should be extremely careful when calling this while
 // multiple threads are running, since at the time the fork happened, the