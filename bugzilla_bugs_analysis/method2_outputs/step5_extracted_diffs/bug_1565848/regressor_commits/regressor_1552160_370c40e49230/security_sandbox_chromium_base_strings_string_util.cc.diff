# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/strings/string_util.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/strings/string_util.cc
--- a/security/sandbox/chromium/base/strings/string_util.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/strings/string_util.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -21,8 +21,8 @@
 #include <vector>
 
 #include "base/logging.h"
-#include "base/macros.h"
-#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/stl_util.h"
 #include "base/strings/utf_string_conversion_utils.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/third_party/icu/icu_utf.h"
@@ -32,19 +32,6 @@
 
 namespace {
 
-// Force the singleton used by EmptyString[16] to be a unique type. This
-// prevents other code that might accidentally use Singleton<string> from
-// getting our internal one.
-struct EmptyStrings {
-  EmptyStrings() {}
-  const std::string s;
-  const string16 s16;
-
-  static EmptyStrings* GetInstance() {
-    return Singleton<EmptyStrings>::get();
-  }
-};
-
 // Used by ReplaceStringPlaceholders to track the position in the string of
 // replaced parameters.
 struct ReplacementOffset {
@@ -81,37 +68,32 @@
 
 // Assuming that a pointer is the size of a "machine word", then
 // uintptr_t is an integer type that is also a machine word.
-typedef uintptr_t MachineWord;
-const uintptr_t kMachineWordAlignmentMask = sizeof(MachineWord) - 1;
+using MachineWord = uintptr_t;
 
-inline bool IsAlignedToMachineWord(const void* pointer) {
-  return !(reinterpret_cast<MachineWord>(pointer) & kMachineWordAlignmentMask);
-}
-
-template<typename T> inline T* AlignToMachineWord(T* pointer) {
-  return reinterpret_cast<T*>(reinterpret_cast<MachineWord>(pointer) &
-                              ~kMachineWordAlignmentMask);
+inline bool IsMachineWordAligned(const void* pointer) {
+  return !(reinterpret_cast<MachineWord>(pointer) & (sizeof(MachineWord) - 1));
 }
 
-template<size_t size, typename CharacterType> struct NonASCIIMask;
-template<> struct NonASCIIMask<4, char16> {
-    static inline uint32_t value() { return 0xFF80FF80U; }
+template <typename CharacterType>
+struct NonASCIIMask;
+template <>
+struct NonASCIIMask<char> {
+  static constexpr MachineWord value() {
+    return static_cast<MachineWord>(0x8080808080808080ULL);
+  }
 };
-template<> struct NonASCIIMask<4, char> {
-    static inline uint32_t value() { return 0x80808080U; }
-};
-template<> struct NonASCIIMask<8, char16> {
-    static inline uint64_t value() { return 0xFF80FF80FF80FF80ULL; }
-};
-template<> struct NonASCIIMask<8, char> {
-    static inline uint64_t value() { return 0x8080808080808080ULL; }
+template <>
+struct NonASCIIMask<char16> {
+  static constexpr MachineWord value() {
+    return static_cast<MachineWord>(0xFF80FF80FF80FF80ULL);
+  }
 };
 #if defined(WCHAR_T_IS_UTF32)
-template<> struct NonASCIIMask<4, wchar_t> {
-    static inline uint32_t value() { return 0xFFFFFF80U; }
-};
-template<> struct NonASCIIMask<8, wchar_t> {
-    static inline uint64_t value() { return 0xFFFFFF80FFFFFF80ULL; }
+template <>
+struct NonASCIIMask<wchar_t> {
+  static constexpr MachineWord value() {
+    return static_cast<MachineWord>(0xFFFFFF80FFFFFF80ULL);
+  }
 };
 #endif  // WCHAR_T_IS_UTF32
 
@@ -238,57 +220,46 @@
 }
 
 const std::string& EmptyString() {
-  return EmptyStrings::GetInstance()->s;
+  static const base::NoDestructor<std::string> s;
+  return *s;
 }
 
 const string16& EmptyString16() {
-  return EmptyStrings::GetInstance()->s16;
+  static const base::NoDestructor<string16> s16;
+  return *s16;
 }
 
-template<typename STR>
-bool ReplaceCharsT(const STR& input,
-                   const STR& replace_chars,
-                   const STR& replace_with,
-                   STR* output) {
-  bool removed = false;
-  size_t replace_length = replace_with.length();
-
-  *output = input;
-
-  size_t found = output->find_first_of(replace_chars);
-  while (found != STR::npos) {
-    removed = true;
-    output->replace(found, 1, replace_with);
-    found = output->find_first_of(replace_chars, found + replace_length);
-  }
-
-  return removed;
-}
+template <class StringType>
+bool ReplaceCharsT(const StringType& input,
+                   BasicStringPiece<StringType> find_any_of_these,
+                   BasicStringPiece<StringType> replace_with,
+                   StringType* output);
 
 bool ReplaceChars(const string16& input,
-                  const StringPiece16& replace_chars,
+                  StringPiece16 replace_chars,
                   const string16& replace_with,
                   string16* output) {
-  return ReplaceCharsT(input, replace_chars.as_string(), replace_with, output);
+  return ReplaceCharsT(input, replace_chars, StringPiece16(replace_with),
+                       output);
 }
 
 bool ReplaceChars(const std::string& input,
-                  const StringPiece& replace_chars,
+                  StringPiece replace_chars,
                   const std::string& replace_with,
                   std::string* output) {
-  return ReplaceCharsT(input, replace_chars.as_string(), replace_with, output);
+  return ReplaceCharsT(input, replace_chars, StringPiece(replace_with), output);
 }
 
 bool RemoveChars(const string16& input,
-                 const StringPiece16& remove_chars,
+                 StringPiece16 remove_chars,
                  string16* output) {
-  return ReplaceChars(input, remove_chars.as_string(), string16(), output);
+  return ReplaceCharsT(input, remove_chars, StringPiece16(), output);
 }
 
 bool RemoveChars(const std::string& input,
-                 const StringPiece& remove_chars,
+                 StringPiece remove_chars,
                  std::string* output) {
-  return ReplaceChars(input, remove_chars.as_string(), std::string(), output);
+  return ReplaceCharsT(input, remove_chars, StringPiece(), output);
 }
 
 template<typename Str>
@@ -351,13 +322,13 @@
 }
 
 StringPiece16 TrimString(StringPiece16 input,
-                         const StringPiece16& trim_chars,
+                         StringPiece16 trim_chars,
                          TrimPositions positions) {
   return TrimStringPieceT(input, trim_chars, positions);
 }
 
 StringPiece TrimString(StringPiece input,
-                       const StringPiece& trim_chars,
+                       StringPiece trim_chars,
                        TrimPositions positions) {
   return TrimStringPieceT(input, trim_chars, positions);
 }
@@ -472,65 +443,70 @@
   return CollapseWhitespaceT(text, trim_sequences_with_line_breaks);
 }
 
-bool ContainsOnlyChars(const StringPiece& input,
-                       const StringPiece& characters) {
+bool ContainsOnlyChars(StringPiece input, StringPiece characters) {
   return input.find_first_not_of(characters) == StringPiece::npos;
 }
 
-bool ContainsOnlyChars(const StringPiece16& input,
-                       const StringPiece16& characters) {
+bool ContainsOnlyChars(StringPiece16 input, StringPiece16 characters) {
   return input.find_first_not_of(characters) == StringPiece16::npos;
 }
 
 template <class Char>
 inline bool DoIsStringASCII(const Char* characters, size_t length) {
+  if (!length)
+    return true;
+  constexpr MachineWord non_ascii_bit_mask = NonASCIIMask<Char>::value();
   MachineWord all_char_bits = 0;
   const Char* end = characters + length;
 
   // Prologue: align the input.
-  while (!IsAlignedToMachineWord(characters) && characters != end) {
-    all_char_bits |= *characters;
-    ++characters;
-  }
+  while (!IsMachineWordAligned(characters) && characters < end)
+    all_char_bits |= *characters++;
+  if (all_char_bits & non_ascii_bit_mask)
+    return false;
 
   // Compare the values of CPU word size.
-  const Char* word_end = AlignToMachineWord(end);
-  const size_t loop_increment = sizeof(MachineWord) / sizeof(Char);
-  while (characters < word_end) {
+  constexpr size_t chars_per_word = sizeof(MachineWord) / sizeof(Char);
+  constexpr int batch_count = 16;
+  while (characters <= end - batch_count * chars_per_word) {
+    all_char_bits = 0;
+    for (int i = 0; i < batch_count; ++i) {
+      all_char_bits |= *(reinterpret_cast<const MachineWord*>(characters));
+      characters += chars_per_word;
+    }
+    if (all_char_bits & non_ascii_bit_mask)
+      return false;
+  }
+
+  // Process the remaining words.
+  all_char_bits = 0;
+  while (characters <= end - chars_per_word) {
     all_char_bits |= *(reinterpret_cast<const MachineWord*>(characters));
-    characters += loop_increment;
+    characters += chars_per_word;
   }
 
   // Process the remaining bytes.
-  while (characters != end) {
-    all_char_bits |= *characters;
-    ++characters;
-  }
+  while (characters < end)
+    all_char_bits |= *characters++;
 
-  MachineWord non_ascii_bit_mask =
-      NonASCIIMask<sizeof(MachineWord), Char>::value();
   return !(all_char_bits & non_ascii_bit_mask);
 }
 
-bool IsStringASCII(const StringPiece& str) {
+bool IsStringASCII(StringPiece str) {
   return DoIsStringASCII(str.data(), str.length());
 }
 
-bool IsStringASCII(const StringPiece16& str) {
-  return DoIsStringASCII(str.data(), str.length());
-}
-
-bool IsStringASCII(const string16& str) {
+bool IsStringASCII(StringPiece16 str) {
   return DoIsStringASCII(str.data(), str.length());
 }
 
 #if defined(WCHAR_T_IS_UTF32)
-bool IsStringASCII(const std::wstring& str) {
+bool IsStringASCII(WStringPiece str) {
   return DoIsStringASCII(str.data(), str.length());
 }
 #endif
 
-bool IsStringUTF8(const StringPiece& str) {
+bool IsStringUTF8(StringPiece str) {
   const char *src = str.data();
   int32_t src_len = static_cast<int32_t>(str.length());
   int32_t char_index = 0;
@@ -694,45 +670,76 @@
   size_t dimension = 0;
   const int kKilo = 1024;
   while (unit_amount >= kKilo &&
-         dimension < arraysize(kByteStringsUnlocalized) - 1) {
+         dimension < base::size(kByteStringsUnlocalized) - 1) {
     unit_amount /= kKilo;
     dimension++;
   }
 
   char buf[64];
   if (bytes != 0 && dimension > 0 && unit_amount < 100) {
-    base::snprintf(buf, arraysize(buf), "%.1lf%s", unit_amount,
+    base::snprintf(buf, base::size(buf), "%.1lf%s", unit_amount,
                    kByteStringsUnlocalized[dimension]);
   } else {
-    base::snprintf(buf, arraysize(buf), "%.0lf%s", unit_amount,
+    base::snprintf(buf, base::size(buf), "%.0lf%s", unit_amount,
                    kByteStringsUnlocalized[dimension]);
   }
 
   return ASCIIToUTF16(buf);
 }
 
-// Runs in O(n) time in the length of |str|.
+// A Matcher for DoReplaceMatchesAfterOffset() that matches substrings.
+template <class StringType>
+struct SubstringMatcher {
+  BasicStringPiece<StringType> find_this;
+
+  size_t Find(const StringType& input, size_t pos) {
+    return input.find(find_this.data(), pos, find_this.length());
+  }
+  size_t MatchSize() { return find_this.length(); }
+};
+
+// A Matcher for DoReplaceMatchesAfterOffset() that matches single characters.
 template <class StringType>
-void DoReplaceSubstringsAfterOffset(StringType* str,
-                                    size_t initial_offset,
-                                    BasicStringPiece<StringType> find_this,
-                                    BasicStringPiece<StringType> replace_with,
-                                    bool replace_all) {
+struct CharacterMatcher {
+  BasicStringPiece<StringType> find_any_of_these;
+
+  size_t Find(const StringType& input, size_t pos) {
+    return input.find_first_of(find_any_of_these.data(), pos,
+                               find_any_of_these.length());
+  }
+  constexpr size_t MatchSize() { return 1; }
+};
+
+enum class ReplaceType { REPLACE_ALL, REPLACE_FIRST };
+
+// Runs in O(n) time in the length of |str|, and transforms the string without
+// reallocating when possible. Returns |true| if any matches were found.
+//
+// This is parameterized on a |Matcher| traits type, so that it can be the
+// implementation for both ReplaceChars() and ReplaceSubstringsAfterOffset().
+template <class StringType, class Matcher>
+bool DoReplaceMatchesAfterOffset(StringType* str,
+                                 size_t initial_offset,
+                                 Matcher matcher,
+                                 BasicStringPiece<StringType> replace_with,
+                                 ReplaceType replace_type) {
   using CharTraits = typename StringType::traits_type;
-  DCHECK(!find_this.empty());
+
+  const size_t find_length = matcher.MatchSize();
+  if (!find_length)
+    return false;
 
   // If the find string doesn't appear, there's nothing to do.
-  const size_t find_length = find_this.length();
-  size_t first_match = str->find(find_this.data(), initial_offset, find_length);
+  size_t first_match = matcher.Find(*str, initial_offset);
   if (first_match == StringType::npos)
-    return;
+    return false;
 
   // If we're only replacing one instance, there's no need to do anything
   // complicated.
   const size_t replace_length = replace_with.length();
-  if (!replace_all) {
+  if (replace_type == ReplaceType::REPLACE_FIRST) {
     str->replace(first_match, find_length, replace_with.data(), replace_length);
-    return;
+    return true;
   }
 
   // If the find and replace strings are the same length, we can simply use
@@ -740,11 +747,10 @@
   if (find_length == replace_length) {
     auto* buffer = &((*str)[0]);
     for (size_t offset = first_match; offset != StringType::npos;
-         offset = str->find(find_this.data(), offset + replace_length,
-                            find_length)) {
+         offset = matcher.Find(*str, offset + replace_length)) {
       CharTraits::copy(buffer + offset, replace_with.data(), replace_length);
     }
-    return;
+    return true;
   }
 
   // Since the find and replace strings aren't the same length, a loop like the
@@ -771,8 +777,7 @@
     const size_t expansion_per_match = (replace_length - find_length);
     size_t num_matches = 0;
     for (size_t match = first_match; match != StringType::npos;
-         match =
-             str->find(find_this.data(), match + find_length, find_length)) {
+         match = matcher.Find(*str, match + find_length)) {
       expansion += expansion_per_match;
       ++num_matches;
     }
@@ -786,13 +791,12 @@
       str->reserve(final_length);
 
       size_t pos = 0;
-      for (size_t match = first_match;;
-           match = src.find(find_this.data(), pos, find_length)) {
+      for (size_t match = first_match;; match = matcher.Find(src, pos)) {
         str->append(src, pos, match - pos);
         str->append(replace_with.data(), replace_length);
         pos = match + find_length;
 
-        // A mid-loop test/break enables skipping the final find() call; the
+        // A mid-loop test/break enables skipping the final Find() call; the
         // number of matches is known, so don't search past the last one.
         if (!--num_matches)
           break;
@@ -800,7 +804,7 @@
 
       // Handle substring after the final match.
       str->append(src, pos, str_length - pos);
-      return;
+      return true;
     }
 
     // Prepare for the copy/move loop below -- expand the string to its final
@@ -841,8 +845,7 @@
     read_offset += find_length;
 
     // min() clamps StringType::npos (the largest unsigned value) to str_length.
-    size_t match = std::min(
-        str->find(find_this.data(), read_offset, find_length), str_length);
+    size_t match = std::min(matcher.Find(*str, read_offset), str_length);
 
     size_t length = match - read_offset;
     if (length) {
@@ -854,38 +857,57 @@
 
   // If we're shortening the string, truncate it now.
   str->resize(write_offset);
+  return true;
+}
+
+template <class StringType>
+bool ReplaceCharsT(const StringType& input,
+                   BasicStringPiece<StringType> find_any_of_these,
+                   BasicStringPiece<StringType> replace_with,
+                   StringType* output) {
+  // Commonly, this is called with output and input being the same string; in
+  // that case, this assignment is inexpensive.
+  *output = input;
+
+  return DoReplaceMatchesAfterOffset(
+      output, 0, CharacterMatcher<StringType>{find_any_of_these}, replace_with,
+      ReplaceType::REPLACE_ALL);
 }
 
 void ReplaceFirstSubstringAfterOffset(string16* str,
                                       size_t start_offset,
                                       StringPiece16 find_this,
                                       StringPiece16 replace_with) {
-  DoReplaceSubstringsAfterOffset<string16>(
-      str, start_offset, find_this, replace_with, false);  // Replace first.
+  DoReplaceMatchesAfterOffset(str, start_offset,
+                              SubstringMatcher<string16>{find_this},
+                              replace_with, ReplaceType::REPLACE_FIRST);
 }
 
 void ReplaceFirstSubstringAfterOffset(std::string* str,
                                       size_t start_offset,
                                       StringPiece find_this,
                                       StringPiece replace_with) {
-  DoReplaceSubstringsAfterOffset<std::string>(
-      str, start_offset, find_this, replace_with, false);  // Replace first.
+  DoReplaceMatchesAfterOffset(str, start_offset,
+                              SubstringMatcher<std::string>{find_this},
+                              replace_with, ReplaceType::REPLACE_FIRST);
 }
 
 void ReplaceSubstringsAfterOffset(string16* str,
                                   size_t start_offset,
                                   StringPiece16 find_this,
                                   StringPiece16 replace_with) {
-  DoReplaceSubstringsAfterOffset<string16>(
-      str, start_offset, find_this, replace_with, true);  // Replace all.
+  DoReplaceMatchesAfterOffset(str, start_offset,
+                              SubstringMatcher<string16>{find_this},
+                              replace_with, ReplaceType::REPLACE_ALL);
 }
 
 void ReplaceSubstringsAfterOffset(std::string* str,
                                   size_t start_offset,
                                   StringPiece find_this,
                                   StringPiece replace_with) {
-  DoReplaceSubstringsAfterOffset<std::string>(
-      str, start_offset, find_this, replace_with, true);  // Replace all.
+  DoReplaceMatchesAfterOffset(str, start_offset,
+                              SubstringMatcher<std::string>{find_this},
+                              replace_with, ReplaceType::REPLACE_ALL);
 }
 
 template <class string_type>
@@ -905,6 +927,11 @@
   return WriteIntoT(str, length_with_null);
 }
 
+#if defined(_MSC_VER) && !defined(__clang__)
+// Work around VC++ code-gen bug. https://crbug.com/804884
+#pragma optimize("", off)
+#endif
+
 // Generic version for all JoinString overloads. |list_type| must be a sequence
 // (std::vector or std::initializer_list) of strings/StringPieces (std::string,
 // string16, StringPiece or StringPiece16). |string_type| is either std::string
@@ -952,6 +979,11 @@
   return JoinStringT(parts, separator);
 }
 
+#if defined(_MSC_VER) && !defined(__clang__)
+// Work around VC++ code-gen bug. https://crbug.com/804884
+#pragma optimize("", on)
+#endif
+
 std::string JoinString(const std::vector<StringPiece>& parts,
                        StringPiece separator) {
   return JoinStringT(parts, separator);
@@ -1006,12 +1038,11 @@
           uintptr_t index = *i - '1';
           if (offsets) {
             ReplacementOffset r_offset(index,
-                static_cast<int>(formatted.size()));
-            r_offsets.insert(std::lower_bound(r_offsets.begin(),
-                                              r_offsets.end(),
-                                              r_offset,
-                                              &CompareParameter),
-                             r_offset);
+                                       static_cast<int>(formatted.size()));
+            r_offsets.insert(
+                std::upper_bound(r_offsets.begin(), r_offsets.end(), r_offset,
+                                 &CompareParameter),
+                r_offset);
           }
           if (index < substitutions)
             formatted.append(subst.at(index));
@@ -1034,7 +1065,7 @@
   return DoReplaceStringPlaceholders(format_string, subst, offsets);
 }
 
-std::string ReplaceStringPlaceholders(const StringPiece& format_string,
+std::string ReplaceStringPlaceholders(StringPiece format_string,
                                       const std::vector<std::string>& subst,
                                       std::vector<size_t>* offsets) {
   return DoReplaceStringPlaceholders(format_string, subst, offsets);