# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/threading/thread_local_storage.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/threading/thread_local_storage.h
--- a/security/sandbox/chromium/base/threading/thread_local_storage.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/threading/thread_local_storage.h	Wed Jun 12 11:10:48 2019 +0100
@@ -13,15 +13,35 @@
 #include "build/build_config.h"
 
 #if defined(OS_WIN)
-#include <windows.h>
-#elif defined(OS_POSIX)
+#include "base/win/windows_types.h"
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 #include <pthread.h>
 #endif
 
+namespace heap_profiling {
+class ScopedAllowAlloc;
+}  // namespace heap_profiling
+
+namespace ui {
+class TLSDestructionCheckerForX11;
+}
+
 namespace base {
 
+class SamplingHeapProfiler;
+
+namespace debug {
+class GlobalActivityTracker;
+}  // namespace debug
+
+namespace trace_event {
+class MallocDumpProvider;
+}  // namespace trace_event
+
 namespace internal {
 
+class ThreadLocalStorageTestInternal;
+
 // WARNING: You should *NOT* use this class directly.
 // PlatformThreadLocalStorage is a low-level abstraction of the OS's TLS
 // interface. Instead, you should use one of the following:
@@ -34,7 +54,7 @@
 #if defined(OS_WIN)
   typedef unsigned long TLSKey;
   enum : unsigned { TLS_KEY_OUT_OF_INDEXES = TLS_OUT_OF_INDEXES };
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
   typedef pthread_key_t TLSKey;
   // The following is a "reserved key" which is used in our generic Chromium
   // ThreadLocalStorage implementation.  We expect that an OS will not return
@@ -59,7 +79,7 @@
   static void* GetTLSValue(TLSKey key) {
 #if defined(OS_WIN)
     return TlsGetValue(key);
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
     return pthread_getspecific(key);
 #endif
   }
@@ -76,7 +96,7 @@
   // Since Windows which doesn't support TLS destructor, the implementation
   // should use GetTLSValue() to retrieve the value of TLS slot.
   static void OnThreadExit();
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) || defined(OS_FUCHSIA)
   // |Value| is the data stored in TLS slot, The implementation can't use
   // GetTLSValue() to retrieve the value of slot as it has already been reset
   // in Posix.
@@ -90,34 +110,28 @@
 // an API for portability.
 class BASE_EXPORT ThreadLocalStorage {
  public:
-
   // Prototype for the TLS destructor function, which can be optionally used to
   // cleanup thread local storage on thread exit.  'value' is the data that is
   // stored in thread local storage.
   typedef void (*TLSDestructorFunc)(void* value);
 
-  // StaticSlot uses its own struct initializer-list style static
-  // initialization, as base's LINKER_INITIALIZED requires a constructor and on
-  // some compilers (notably gcc 4.4) this still ends up needing runtime
-  // initialization.
-  #define TLS_INITIALIZER {0}
-
-  // A key representing one value stored in TLS.
-  // Initialize like
-  //   ThreadLocalStorage::StaticSlot my_slot = TLS_INITIALIZER;
-  // If you're not using a static variable, use the convenience class
-  // ThreadLocalStorage::Slot (below) instead.
-  struct BASE_EXPORT StaticSlot {
-    // Set up the TLS slot.  Called by the constructor.
-    // 'destructor' is a pointer to a function to perform per-thread cleanup of
-    // this object.  If set to NULL, no cleanup is done for this TLS slot.
-    void Initialize(TLSDestructorFunc destructor);
-
-    // Free a previously allocated TLS 'slot'.
-    // If a destructor was set for this slot, removes
-    // the destructor so that remaining threads exiting
-    // will not free data.
-    void Free();
+  // A key representing one value stored in TLS. Use as a class member or a
+  // local variable. If you need a static storage duration variable, use the
+  // following pattern with a NoDestructor<Slot>:
+  // void MyDestructorFunc(void* value);
+  // ThreadLocalStorage::Slot& ImportantContentTLS() {
+  //   static NoDestructor<ThreadLocalStorage::Slot> important_content_tls(
+  //       &MyDestructorFunc);
+  //   return *important_content_tls;
+  // }
+  class BASE_EXPORT Slot final {
+   public:
+    // |destructor| is a pointer to a function to perform per-thread cleanup of
+    // this object.  If set to nullptr, no cleanup is done for this TLS slot.
+    explicit Slot(TLSDestructorFunc destructor = nullptr);
+    // If a destructor was set for this slot, removes the destructor so that
+    // remaining threads exiting will not free data.
+    ~Slot();
 
     // Get the thread-local value stored in slot 'slot'.
     // Values are guaranteed to initially be zero.
@@ -127,37 +141,34 @@
     // value 'value'.
     void Set(void* value);
 
-    bool initialized() const {
-      return base::subtle::Acquire_Load(&initialized_) != 0;
-    }
-
-    // The internals of this struct should be considered private.
-    base::subtle::Atomic32 initialized_;
-    int slot_;
-    uint32_t version_;
-  };
+   private:
+    void Initialize(TLSDestructorFunc destructor);
+    void Free();
 
-  // A convenience wrapper around StaticSlot with a constructor. Can be used
-  // as a member variable.
-  class BASE_EXPORT Slot {
-   public:
-    explicit Slot(TLSDestructorFunc destructor = NULL);
-    ~Slot();
-
-    // Get the thread-local value stored in this slot.
-    // Values are guaranteed to initially be zero.
-    void* Get() const;
-
-    // Set the slot's thread-local value to |value|.
-    void Set(void* value);
-
-   private:
-    StaticSlot tls_slot_;
+    static constexpr int kInvalidSlotValue = -1;
+    int slot_ = kInvalidSlotValue;
+    uint32_t version_ = 0;
 
     DISALLOW_COPY_AND_ASSIGN(Slot);
   };
 
  private:
+  // In most cases, most callers should not need access to HasBeenDestroyed().
+  // If you are working in code that runs during thread destruction, contact the
+  // base OWNERs for advice and then make a friend request.
+  //
+  // Returns |true| if Chrome's implementation of TLS has been destroyed during
+  // thread destruction. Attempting to call Slot::Get() during destruction is
+  // disallowed and will hit a DCHECK. Any code that relies on TLS during thread
+  // destruction must first check this method before calling Slot::Get().
+  friend class base::SamplingHeapProfiler;
+  friend class base::internal::ThreadLocalStorageTestInternal;
+  friend class base::trace_event::MallocDumpProvider;
+  friend class debug::GlobalActivityTracker;
+  friend class heap_profiling::ScopedAllowAlloc;
+  friend class ui::TLSDestructionCheckerForX11;
+  static bool HasBeenDestroyed();
+
   DISALLOW_COPY_AND_ASSIGN(ThreadLocalStorage);
 };
 