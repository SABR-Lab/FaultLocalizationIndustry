# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/time/time_win.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/time/time_win.cc
--- a/security/sandbox/chromium/base/time/time_win.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/time/time_win.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -43,11 +43,9 @@
 #include "base/logging.h"
 #include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
+#include "base/time/time_override.h"
 
-using base::ThreadTicks;
-using base::Time;
-using base::TimeDelta;
-using base::TimeTicks;
+namespace base {
 
 namespace {
 
@@ -75,15 +73,15 @@
   return FileTimeToMicroseconds(ft);
 }
 
-// Time between resampling the un-granular clock for this API.  60 seconds.
-const int kMaxMillisecondsToAvoidDrift = 60 * Time::kMillisecondsPerSecond;
+// Time between resampling the un-granular clock for this API.
+constexpr TimeDelta kMaxTimeToAvoidDrift = TimeDelta::FromSeconds(60);
 
-int64_t initial_time = 0;
-TimeTicks initial_ticks;
+int64_t g_initial_time = 0;
+TimeTicks g_initial_ticks;
 
 void InitializeClock() {
-  initial_ticks = TimeTicks::Now();
-  initial_time = CurrentWallclockMicroseconds();
+  g_initial_ticks = subtle::TimeTicksNowIgnoringOverride();
+  g_initial_time = CurrentWallclockMicroseconds();
 }
 
 // The two values that ActivateHighResolutionTimer uses to set the systemwide
@@ -105,8 +103,8 @@
 // is used to calculate the cumulative usage.
 TimeTicks g_high_res_timer_last_activation;
 // The lock to control access to the above two variables.
-base::Lock* GetHighResLock() {
-  static auto* lock = new base::Lock();
+Lock* GetHighResLock() {
+  static auto* lock = new Lock();
   return lock;
 }
 
@@ -121,7 +119,7 @@
 }
 
 bool SafeConvertToWord(int in, WORD* out) {
-  base::CheckedNumeric<WORD> result = in;
+  CheckedNumeric<WORD> result = in;
   *out = result.ValueOrDefault(std::numeric_limits<WORD>::max());
   return result.IsValid();
 }
@@ -130,43 +128,43 @@
 
 // Time -----------------------------------------------------------------------
 
-// static
-Time Time::Now() {
-  if (initial_time == 0)
+namespace subtle {
+Time TimeNowIgnoringOverride() {
+  if (g_initial_time == 0)
     InitializeClock();
 
   // We implement time using the high-resolution timers so that we can get
   // timeouts which are smaller than 10-15ms.  If we just used
   // CurrentWallclockMicroseconds(), we'd have the less-granular timer.
   //
-  // To make this work, we initialize the clock (initial_time) and the
+  // To make this work, we initialize the clock (g_initial_time) and the
   // counter (initial_ctr).  To compute the initial time, we can check
   // the number of ticks that have elapsed, and compute the delta.
   //
   // To avoid any drift, we periodically resync the counters to the system
   // clock.
   while (true) {
-    TimeTicks ticks = TimeTicks::Now();
+    TimeTicks ticks = TimeTicksNowIgnoringOverride();
 
     // Calculate the time elapsed since we started our timer
-    TimeDelta elapsed = ticks - initial_ticks;
+    TimeDelta elapsed = ticks - g_initial_ticks;
 
     // Check if enough time has elapsed that we need to resync the clock.
-    if (elapsed.InMilliseconds() > kMaxMillisecondsToAvoidDrift) {
+    if (elapsed > kMaxTimeToAvoidDrift) {
       InitializeClock();
       continue;
     }
 
-    return Time(elapsed + Time(initial_time));
+    return Time() + elapsed + TimeDelta::FromMicroseconds(g_initial_time);
   }
 }
 
-// static
-Time Time::NowFromSystemTime() {
+Time TimeNowFromSystemTimeIgnoringOverride() {
   // Force resync.
   InitializeClock();
-  return Time(initial_time);
+  return Time() + TimeDelta::FromMicroseconds(g_initial_time);
 }
+}  // namespace subtle
 
 // static
 Time Time::FromFileTime(FILETIME ft) {
@@ -194,7 +192,7 @@
 
 // static
 void Time::EnableHighResolutionTimer(bool enable) {
-  base::AutoLock lock(*GetHighResLock());
+  AutoLock lock(*GetHighResLock());
   if (g_high_res_timer_enabled == enable)
     return;
   g_high_res_timer_enabled = enable;
@@ -221,22 +219,22 @@
   // called.
   const uint32_t max = std::numeric_limits<uint32_t>::max();
 
-  base::AutoLock lock(*GetHighResLock());
+  AutoLock lock(*GetHighResLock());
   UINT period = g_high_res_timer_enabled ? kMinTimerIntervalHighResMs
                                          : kMinTimerIntervalLowResMs;
   if (activating) {
     DCHECK_NE(g_high_res_timer_count, max);
     ++g_high_res_timer_count;
     if (g_high_res_timer_count == 1) {
-      g_high_res_timer_last_activation = TimeTicks::Now();
+      g_high_res_timer_last_activation = subtle::TimeTicksNowIgnoringOverride();
       timeBeginPeriod(period);
     }
   } else {
     DCHECK_NE(g_high_res_timer_count, 0u);
     --g_high_res_timer_count;
     if (g_high_res_timer_count == 0) {
-      g_high_res_timer_usage +=
-          TimeTicks::Now() - g_high_res_timer_last_activation;
+      g_high_res_timer_usage += subtle::TimeTicksNowIgnoringOverride() -
+                                g_high_res_timer_last_activation;
       timeEndPeriod(period);
     }
   }
@@ -245,23 +243,23 @@
 
 // static
 bool Time::IsHighResolutionTimerInUse() {
-  base::AutoLock lock(*GetHighResLock());
+  AutoLock lock(*GetHighResLock());
   return g_high_res_timer_enabled && g_high_res_timer_count > 0;
 }
 
 // static
 void Time::ResetHighResolutionTimerUsage() {
-  base::AutoLock lock(*GetHighResLock());
+  AutoLock lock(*GetHighResLock());
   g_high_res_timer_usage = TimeDelta();
-  g_high_res_timer_usage_start = TimeTicks::Now();
+  g_high_res_timer_usage_start = subtle::TimeTicksNowIgnoringOverride();
   if (g_high_res_timer_count > 0)
     g_high_res_timer_last_activation = g_high_res_timer_usage_start;
 }
 
 // static
 double Time::GetHighResolutionTimerUsage() {
-  base::AutoLock lock(*GetHighResLock());
-  TimeTicks now = TimeTicks::Now();
+  AutoLock lock(*GetHighResLock());
+  TimeTicks now = subtle::TimeTicksNowIgnoringOverride();
   TimeDelta elapsed_time = now - g_high_res_timer_usage_start;
   if (elapsed_time.is_zero()) {
     // This is unexpected but possible if TimeTicks resolution is low and
@@ -292,7 +290,7 @@
       !SafeConvertToWord(exploded.minute, &st.wMinute) ||
       !SafeConvertToWord(exploded.second, &st.wSecond) ||
       !SafeConvertToWord(exploded.millisecond, &st.wMilliseconds)) {
-    *time = base::Time(0);
+    *time = Time(0);
     return false;
   }
 
@@ -360,6 +358,7 @@
 }
 
 // TimeTicks ------------------------------------------------------------------
+
 namespace {
 
 // We define a wrapper to adapt between the __stdcall and __cdecl call of the
@@ -375,7 +374,7 @@
 // "rollover" counter.
 union LastTimeAndRolloversState {
   // The state as a single 32-bit opaque value.
-  base::subtle::Atomic32 as_opaque_32;
+  subtle::Atomic32 as_opaque_32;
 
   // The state as usable values.
   struct {
@@ -391,7 +390,7 @@
     uint16_t rollovers;
   } as_values;
 };
-base::subtle::Atomic32 g_last_time_and_rollovers = 0;
+subtle::Atomic32 g_last_time_and_rollovers = 0;
 static_assert(
     sizeof(LastTimeAndRolloversState) <= sizeof(g_last_time_and_rollovers),
     "LastTimeAndRolloversState does not fit in a single atomic word");
@@ -401,7 +400,7 @@
 // which will roll over the 32-bit value every ~49 days.  We try to track
 // rollover ourselves, which works if TimeTicks::Now() is called at least every
 // 48.8 days (not 49 days because only changes in the top 8 bits get noticed).
-TimeDelta RolloverProtectedNow() {
+TimeTicks RolloverProtectedNow() {
   LastTimeAndRolloversState state;
   DWORD now;  // DWORD is always unsigned 32 bits.
 
@@ -410,7 +409,7 @@
     // incrementing the "rollovers" counter if the tick-value has wrapped back
     // around. Atomic operations ensure that both "last" and "rollovers" are
     // always updated together.
-    int32_t original = base::subtle::Acquire_Load(&g_last_time_and_rollovers);
+    int32_t original = subtle::Acquire_Load(&g_last_time_and_rollovers);
     state.as_opaque_32 = original;
     now = g_tick_function();
     uint8_t now_8 = static_cast<uint8_t>(now >> 24);
@@ -424,7 +423,7 @@
 
     // Save the changed state. If the existing value is unchanged from the
     // original, exit the loop.
-    int32_t check = base::subtle::Release_CompareAndSwap(
+    int32_t check = subtle::Release_CompareAndSwap(
         &g_last_time_and_rollovers, original, state.as_opaque_32);
     if (check == original)
       break;
@@ -432,8 +431,9 @@
     // Another thread has done something in between so retry from the top.
   }
 
-  return TimeDelta::FromMilliseconds(
-      now + (static_cast<uint64_t>(state.as_values.rollovers) << 32));
+  return TimeTicks() +
+         TimeDelta::FromMilliseconds(
+             now + (static_cast<uint64_t>(state.as_values.rollovers) << 32));
 }
 
 // Discussion of tick counter options on Windows:
@@ -471,13 +471,12 @@
 // this timer; and also other Windows applications can alter it, affecting this
 // one.
 
-using NowFunction = TimeDelta (*)(void);
-
-TimeDelta InitialNowFunction();
+TimeTicks InitialNowFunction();
 
 // See "threading notes" in InitializeNowFunctionPointer() for details on how
 // concurrent reads/writes to these globals has been made safe.
-NowFunction g_now_function = &InitialNowFunction;
+TimeTicksNowFunction g_time_ticks_now_ignoring_override_function =
+    &InitialNowFunction;
 int64_t g_qpc_ticks_per_second = 0;
 
 // As of January 2015, use of <atomic> is forbidden in Chromium code. This is
@@ -508,13 +507,8 @@
        g_qpc_ticks_per_second));
 }
 
-TimeDelta QPCNow() {
-  return QPCValueToTimeDelta(QPCNowRaw());
-}
-
-bool IsBuggyAthlon(const base::CPU& cpu) {
-  // On Athlon X2 CPUs (e.g. model 15) QueryPerformanceCounter is unreliable.
-  return cpu.vendor_name() == "AuthenticAMD" && cpu.family() == 15;
+TimeTicks QPCNow() {
+  return TimeTicks() + QPCValueToTimeDelta(QPCNowRaw());
 }
 
 void InitializeNowFunctionPointer() {
@@ -528,15 +522,13 @@
   // If the QPC implementation is expensive and/or unreliable, TimeTicks::Now()
   // will still use the low-resolution clock. A CPU lacking a non-stop time
   // counter will cause Windows to provide an alternate QPC implementation that
-  // works, but is expensive to use. Certain Athlon CPUs are known to make the
-  // QPC implementation unreliable.
+  // works, but is expensive to use.
   //
   // Otherwise, Now uses the high-resolution QPC clock. As of 21 August 2015,
   // ~72% of users fall within this category.
-  NowFunction now_function;
-  base::CPU cpu;
-  if (ticks_per_sec.QuadPart <= 0 ||
-      !cpu.has_non_stop_time_stamp_counter() || IsBuggyAthlon(cpu)) {
+  TimeTicksNowFunction now_function;
+  CPU cpu;
+  if (ticks_per_sec.QuadPart <= 0 || !cpu.has_non_stop_time_stamp_counter()) {
     now_function = &RolloverProtectedNow;
   } else {
     now_function = &QPCNow;
@@ -553,12 +545,19 @@
   // are changed.
   g_qpc_ticks_per_second = ticks_per_sec.QuadPart;
   ATOMIC_THREAD_FENCE(memory_order_release);
-  g_now_function = now_function;
+  // Also set g_time_ticks_now_function to avoid the additional indirection via
+  // TimeTicksNowIgnoringOverride() for future calls to TimeTicks::Now(). But
+  // g_time_ticks_now_function may have already be overridden.
+  if (internal::g_time_ticks_now_function ==
+      &subtle::TimeTicksNowIgnoringOverride) {
+    internal::g_time_ticks_now_function = now_function;
+  }
+  g_time_ticks_now_ignoring_override_function = now_function;
 }
 
-TimeDelta InitialNowFunction() {
+TimeTicks InitialNowFunction() {
   InitializeNowFunctionPointer();
-  return g_now_function();
+  return g_time_ticks_now_ignoring_override_function();
 }
 
 }  // namespace
@@ -568,20 +567,21 @@
     TickFunctionType ticker) {
   TickFunctionType old = g_tick_function;
   g_tick_function = ticker;
-  base::subtle::NoBarrier_Store(&g_last_time_and_rollovers, 0);
+  subtle::NoBarrier_Store(&g_last_time_and_rollovers, 0);
   return old;
 }
 
-// static
-TimeTicks TimeTicks::Now() {
-  return TimeTicks() + g_now_function();
+namespace subtle {
+TimeTicks TimeTicksNowIgnoringOverride() {
+  return g_time_ticks_now_ignoring_override_function();
 }
+}  // namespace subtle
 
 // static
 bool TimeTicks::IsHighResolution() {
-  if (g_now_function == &InitialNowFunction)
+  if (g_time_ticks_now_ignoring_override_function == &InitialNowFunction)
     InitializeNowFunctionPointer();
-  return g_now_function == &QPCNow;
+  return g_time_ticks_now_ignoring_override_function == &QPCNow;
 }
 
 // static
@@ -610,14 +610,17 @@
       Clock::WIN_QPC : Clock::WIN_ROLLOVER_PROTECTED_TIME_GET_TIME;
 }
 
-// static
-ThreadTicks ThreadTicks::Now() {
+// ThreadTicks ----------------------------------------------------------------
+
+namespace subtle {
+ThreadTicks ThreadTicksNowIgnoringOverride() {
   return ThreadTicks::GetForThread(PlatformThread::CurrentHandle());
 }
+}  // namespace subtle
 
 // static
 ThreadTicks ThreadTicks::GetForThread(
-    const base::PlatformThreadHandle& thread_handle) {
+    const PlatformThreadHandle& thread_handle) {
   DCHECK(IsSupported());
 
   // Get the number of TSC ticks used by the current thread.
@@ -637,8 +640,7 @@
 
 // static
 bool ThreadTicks::IsSupportedWin() {
-  static bool is_supported = base::CPU().has_non_stop_time_stamp_counter() &&
-                             !IsBuggyAthlon(base::CPU());
+  static bool is_supported = CPU().has_non_stop_time_stamp_counter();
   return is_supported;
 }
 
@@ -648,7 +650,7 @@
     ::Sleep(10);
 }
 
-#if defined(_M_ARM64)
+#if defined(_M_ARM64) && defined(__clang__)
 #define ReadCycleCounter() _ReadStatusReg(ARM64_PMCCNTR_EL0)
 #else
 #define ReadCycleCounter() __rdtsc()
@@ -674,6 +676,7 @@
 
   // The first time that this function is called, make an initial reading of the
   // TSC and the performance counter.
+
   static const uint64_t tsc_initial = ReadCycleCounter();
   static const uint64_t perf_counter_initial = QPCNowRaw();
 
@@ -701,7 +704,7 @@
   double elapsed_time_seconds =
       perf_counter_ticks / static_cast<double>(perf_counter_frequency.QuadPart);
 
-  const double kMinimumEvaluationPeriodSeconds = 0.05;
+  static constexpr double kMinimumEvaluationPeriodSeconds = 0.05;
   if (elapsed_time_seconds < kMinimumEvaluationPeriodSeconds)
     return 0;
 
@@ -714,7 +717,6 @@
 }
 
 #undef ReadCycleCounter
-
 // static
 TimeTicks TimeTicks::FromQPCValue(LONGLONG qpc_value) {
   return TimeTicks() + QPCValueToTimeDelta(qpc_value);
@@ -726,3 +728,10 @@
 TimeDelta TimeDelta::FromQPCValue(LONGLONG qpc_value) {
   return QPCValueToTimeDelta(qpc_value);
 }
+
+// static
+TimeDelta TimeDelta::FromFileTime(FILETIME ft) {
+  return TimeDelta::FromMicroseconds(FileTimeToMicroseconds(ft));
+}
+
+}  // namespace base