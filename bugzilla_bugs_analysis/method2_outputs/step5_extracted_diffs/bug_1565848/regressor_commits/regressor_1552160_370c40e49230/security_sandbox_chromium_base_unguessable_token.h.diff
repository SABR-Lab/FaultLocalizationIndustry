# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/unguessable_token.h
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/unguessable_token.h
--- a/security/sandbox/chromium/base/unguessable_token.h	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/unguessable_token.h	Wed Jun 12 11:10:48 2019 +0100
@@ -13,17 +13,26 @@
 #include "base/base_export.h"
 #include "base/hash.h"
 #include "base/logging.h"
+#include "base/token.h"
 
 namespace base {
 
 struct UnguessableTokenHash;
 
-// A UnguessableToken is an 128-bit token generated from a cryptographically
-// strong random source.
+// UnguessableToken is, like Token, a randomly chosen 128-bit value. Unlike
+// Token however, a new UnguessableToken must always be generated at runtime
+// from a cryptographically strong random source (or copied or serialized and
+// deserialized from another such UnguessableToken). It can be used as part of a
+// larger aggregate type, or as an ID in and of itself.
 //
-// UnguessableToken should be used when a sensitive ID needs to be unguessable,
-// and is shared across processes. It can be used as part of a larger aggregate
-// type, or as an ID in and of itself.
+// UnguessableToken can be used to implement "Capability-Based Security".
+// In other words, UnguessableToken can be used when the resource associated
+// with the ID needs to be protected against manipulation by other untrusted
+// agents in the system, and there is no other convenient way to verify the
+// authority of the agent to do so (because the resource is part of a table
+// shared across processes, for instance). In such a scheme, knowledge of the
+// token value in and of itself is sufficient proof of authority to carry out
+// an operation against the associated resource.
 //
 // Use Create() for creating new UnguessableTokens.
 //
@@ -36,6 +45,12 @@
   // Create a unique UnguessableToken.
   static UnguessableToken Create();
 
+  // Returns a reference to a global null UnguessableToken. This should only be
+  // used for functions that need to return a reference to an UnguessableToken,
+  // and should not be used as a general-purpose substitute for invoking the
+  // default constructor.
+  static const UnguessableToken& Null();
+
   // Return a UnguessableToken built from the high/low bytes provided.
   // It should only be used in deserialization scenarios.
   //
@@ -50,27 +65,28 @@
   // NOTE: Serializing an empty UnguessableToken is an illegal operation.
   uint64_t GetHighForSerialization() const {
     DCHECK(!is_empty());
-    return high_;
+    return token_.high();
   }
 
   // NOTE: Serializing an empty UnguessableToken is an illegal operation.
   uint64_t GetLowForSerialization() const {
     DCHECK(!is_empty());
-    return low_;
+    return token_.low();
   }
 
-  bool is_empty() const { return high_ == 0 && low_ == 0; }
+  bool is_empty() const { return token_.is_zero(); }
 
-  std::string ToString() const;
+  // Hex representation of the unguessable token.
+  std::string ToString() const { return token_.ToString(); }
 
   explicit operator bool() const { return !is_empty(); }
 
   bool operator<(const UnguessableToken& other) const {
-    return std::tie(high_, low_) < std::tie(other.high_, other.low_);
+    return token_ < other.token_;
   }
 
   bool operator==(const UnguessableToken& other) const {
-    return high_ == other.high_ && low_ == other.low_;
+    return token_ == other.token_;
   }
 
   bool operator!=(const UnguessableToken& other) const {
@@ -79,12 +95,9 @@
 
  private:
   friend struct UnguessableTokenHash;
-  UnguessableToken(uint64_t high, uint64_t low);
+  explicit UnguessableToken(const Token& token);
 
-  // Note: Two uint64_t are used instead of uint8_t[16], in order to have a
-  // simpler ToString() and is_empty().
-  uint64_t high_ = 0;
-  uint64_t low_ = 0;
+  base::Token token_;
 };
 
 BASE_EXPORT std::ostream& operator<<(std::ostream& out,
@@ -94,7 +107,7 @@
 struct UnguessableTokenHash {
   size_t operator()(const base::UnguessableToken& token) const {
     DCHECK(token);
-    return base::HashInts64(token.high_, token.low_);
+    return TokenHash()(token.token_);
   }
 };
 