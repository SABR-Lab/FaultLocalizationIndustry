# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/base/win/windows_version.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/base/win/windows_version.cc
--- a/security/sandbox/chromium/base/win/windows_version.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/base/win/windows_version.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -11,11 +11,19 @@
 #include "base/file_version_info_win.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/strings/string16.h"
+#include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/registry.h"
 
-#if !defined(__clang__) && _MSC_FULL_VER < 190024213
-#error VS 2015 Update 3 with Cumulative Servicing Release or higher is required
+#if !defined(__clang__) && _MSC_FULL_VER < 191125507
+#error VS 2017 Update 3.2 or higher is required
+#endif
+
+#if !defined(NTDDI_WIN10_RS2)
+// Windows 10 April 2018 SDK is required to build Chrome.
+#error April 2018 SDK (10.0.17134.0) or higher required.
 #endif
 
 namespace {
@@ -27,113 +35,85 @@
 
 namespace {
 
-// Helper to map a major.minor.x.build version (e.g. 6.1) to a Windows release.
-Version MajorMinorBuildToVersion(int major, int minor, int build) {
-  if ((major == 5) && (minor > 0)) {
-    // Treat XP Pro x64, Home Server, and Server 2003 R2 as Server 2003.
-    return (minor == 1) ? VERSION_XP : VERSION_SERVER_2003;
-  } else if (major == 6) {
-    switch (minor) {
-      case 0:
-        // Treat Windows Server 2008 the same as Windows Vista.
-        return VERSION_VISTA;
-      case 1:
-        // Treat Windows Server 2008 R2 the same as Windows 7.
-        return VERSION_WIN7;
-      case 2:
-        // Treat Windows Server 2012 the same as Windows 8.
-        return VERSION_WIN8;
-      default:
-        DCHECK_EQ(minor, 3);
-        return VERSION_WIN8_1;
-    }
-  } else if (major == 10) {
-    if (build < 10586) {
-      return VERSION_WIN10;
-    } else if (build < 14393) {
-      return VERSION_WIN10_TH2;
-    } else if (build < 15063) {
-      return VERSION_WIN10_RS1;
-    } else {
-      return VERSION_WIN10_RS2;
-    }
-  } else if (major > 6) {
-    NOTREACHED();
-    return VERSION_WIN_LAST;
-  }
-
-  return VERSION_PRE_XP;
-}
-
-// Retrieve a version from kernel32. This is useful because when running in
-// compatibility mode for a down-level version of the OS, the file version of
-// kernel32 will still be the "real" version.
-Version GetVersionFromKernel32() {
-  std::unique_ptr<FileVersionInfoWin> file_version_info(
-      static_cast<FileVersionInfoWin*>(
-          FileVersionInfoWin::CreateFileVersionInfo(
-              base::FilePath(FILE_PATH_LITERAL("kernel32.dll")))));
-  if (file_version_info) {
-    const int major =
-        HIWORD(file_version_info->fixed_file_info()->dwFileVersionMS);
-    const int minor =
-        LOWORD(file_version_info->fixed_file_info()->dwFileVersionMS);
-    const int build =
-        HIWORD(file_version_info->fixed_file_info()->dwFileVersionLS);
-    return MajorMinorBuildToVersion(major, minor, build);
-  }
-
-  NOTREACHED();
-  return VERSION_WIN_LAST;
-}
-
 // Returns the the "UBR" value from the registry. Introduced in Windows 10,
 // this undocumented value appears to be similar to a patch number.
 // Returns 0 if the value does not exist or it could not be read.
 int GetUBR() {
   // The values under the CurrentVersion registry hive are mirrored under
   // the corresponding Wow6432 hive.
-  static constexpr wchar_t kRegKeyWindowsNTCurrentVersion[] =
-      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
+  static constexpr char16 kRegKeyWindowsNTCurrentVersion[] =
+      STRING16_LITERAL("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
 
-  base::win::RegKey key;
+  RegKey key;
   if (key.Open(HKEY_LOCAL_MACHINE, kRegKeyWindowsNTCurrentVersion,
                KEY_QUERY_VALUE) != ERROR_SUCCESS) {
     return 0;
   }
 
   DWORD ubr = 0;
-  key.ReadValueDW(L"UBR", &ubr);
+  key.ReadValueDW(STRING16_LITERAL("UBR"), &ubr);
 
   return static_cast<int>(ubr);
 }
 
+const _SYSTEM_INFO& GetSystemInfoStorage() {
+  static _SYSTEM_INFO system_info = {};
+  ::GetNativeSystemInfo(&system_info);
+  return system_info;
+}
+
 }  // namespace
 
 // static
-OSInfo* OSInfo::GetInstance() {
+OSInfo** OSInfo::GetInstanceStorage() {
   // Note: we don't use the Singleton class because it depends on AtExitManager,
-  // and it's convenient for other modules to use this classs without it. This
-  // pattern is copied from gurl.cc.
-  static OSInfo* info;
-  if (!info) {
-    OSInfo* new_info = new OSInfo();
-    if (InterlockedCompareExchangePointer(
-        reinterpret_cast<PVOID*>(&info), new_info, NULL)) {
-      delete new_info;
+  // and it's convenient for other modules to use this class without it.
+  static OSInfo* info = []() {
+    _OSVERSIONINFOEXW version_info = {sizeof(version_info)};
+    ::GetVersionEx(reinterpret_cast<_OSVERSIONINFOW*>(&version_info));
+
+    DWORD os_type = 0;
+    if (version_info.dwMajorVersion == 6 || version_info.dwMajorVersion == 10) {
+      // Only present on Vista+.
+      GetProductInfoPtr get_product_info =
+          reinterpret_cast<GetProductInfoPtr>(::GetProcAddress(
+              ::GetModuleHandle(L"kernel32.dll"), "GetProductInfo"));
+      get_product_info(version_info.dwMajorVersion, version_info.dwMinorVersion,
+                       0, 0, &os_type);
     }
-  }
-  return info;
+
+    return new OSInfo(version_info, GetSystemInfoStorage(), os_type);
+  }();
+
+  return &info;
 }
 
-OSInfo::OSInfo()
+// static
+OSInfo* OSInfo::GetInstance() {
+  return *GetInstanceStorage();
+}
+
+// static
+OSInfo::WindowsArchitecture OSInfo::GetArchitecture() {
+  switch (GetSystemInfoStorage().wProcessorArchitecture) {
+    case PROCESSOR_ARCHITECTURE_INTEL:
+      return X86_ARCHITECTURE;
+    case PROCESSOR_ARCHITECTURE_AMD64:
+      return X64_ARCHITECTURE;
+    case PROCESSOR_ARCHITECTURE_IA64:
+      return IA64_ARCHITECTURE;
+    case PROCESSOR_ARCHITECTURE_ARM64:
+      return ARM64_ARCHITECTURE;
+    default:
+      return OTHER_ARCHITECTURE;
+  }
+}
+
+OSInfo::OSInfo(const _OSVERSIONINFOEXW& version_info,
+               const _SYSTEM_INFO& system_info,
+               int os_type)
     : version_(VERSION_PRE_XP),
-      kernel32_version_(VERSION_PRE_XP),
-      got_kernel32_version_(false),
-      architecture_(OTHER_ARCHITECTURE),
       wow64_status_(GetWOW64StatusForProcess(GetCurrentProcess())) {
-  OSVERSIONINFOEX version_info = { sizeof version_info };
-  ::GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&version_info));
   version_number_.major = version_info.dwMajorVersion;
   version_number_.minor = version_info.dwMinorVersion;
   version_number_.build = version_info.dwBuildNumber;
@@ -142,28 +122,13 @@
       version_number_.major, version_number_.minor, version_number_.build);
   service_pack_.major = version_info.wServicePackMajor;
   service_pack_.minor = version_info.wServicePackMinor;
-  service_pack_str_ = base::WideToUTF8(version_info.szCSDVersion);
+  service_pack_str_ = WideToUTF8(version_info.szCSDVersion);
 
-  SYSTEM_INFO system_info = {};
-  ::GetNativeSystemInfo(&system_info);
-  switch (system_info.wProcessorArchitecture) {
-    case PROCESSOR_ARCHITECTURE_INTEL: architecture_ = X86_ARCHITECTURE; break;
-    case PROCESSOR_ARCHITECTURE_AMD64: architecture_ = X64_ARCHITECTURE; break;
-    case PROCESSOR_ARCHITECTURE_IA64:  architecture_ = IA64_ARCHITECTURE; break;
-  }
   processors_ = system_info.dwNumberOfProcessors;
   allocation_granularity_ = system_info.dwAllocationGranularity;
 
-  GetProductInfoPtr get_product_info;
-  DWORD os_type;
-
   if (version_info.dwMajorVersion == 6 || version_info.dwMajorVersion == 10) {
     // Only present on Vista+.
-    get_product_info = reinterpret_cast<GetProductInfoPtr>(
-        ::GetProcAddress(::GetModuleHandle(L"kernel32.dll"), "GetProductInfo"));
-
-    get_product_info(version_info.dwMajorVersion, version_info.dwMinorVersion,
-                     0, 0, &os_type);
     switch (os_type) {
       case PRODUCT_CLUSTER_SERVER:
       case PRODUCT_DATACENTER_SERVER:
@@ -232,20 +197,49 @@
 }
 
 Version OSInfo::Kernel32Version() const {
-  if (!got_kernel32_version_) {
-    kernel32_version_ = GetVersionFromKernel32();
-    got_kernel32_version_ = true;
-  }
-  return kernel32_version_;
+  static const Version kernel32_version =
+      MajorMinorBuildToVersion(Kernel32BaseVersion().components()[0],
+                               Kernel32BaseVersion().components()[1],
+                               Kernel32BaseVersion().components()[2]);
+  return kernel32_version;
+}
+
+// Retrieve a version from kernel32. This is useful because when running in
+// compatibility mode for a down-level version of the OS, the file version of
+// kernel32 will still be the "real" version.
+base::Version OSInfo::Kernel32BaseVersion() const {
+  static const NoDestructor<base::Version> version([] {
+    std::unique_ptr<FileVersionInfoWin> file_version_info =
+        FileVersionInfoWin::CreateFileVersionInfoWin(
+            FilePath(FILE_PATH_LITERAL("kernel32.dll")));
+    if (!file_version_info) {
+      // crbug.com/912061: on some systems it seems kernel32.dll might be
+      // corrupted or not in a state to get version info. In this case try
+      // kernelbase.dll as a fallback.
+      file_version_info = FileVersionInfoWin::CreateFileVersionInfoWin(
+          FilePath(FILE_PATH_LITERAL("kernelbase.dll")));
+    }
+    CHECK(file_version_info);
+    const uint32_t major =
+        HIWORD(file_version_info->fixed_file_info()->dwFileVersionMS);
+    const uint32_t minor =
+        LOWORD(file_version_info->fixed_file_info()->dwFileVersionMS);
+    const uint32_t build =
+        HIWORD(file_version_info->fixed_file_info()->dwFileVersionLS);
+    const uint32_t patch =
+        LOWORD(file_version_info->fixed_file_info()->dwFileVersionLS);
+    return base::Version(std::vector<uint32_t>{major, minor, build, patch});
+  }());
+  return *version;
 }
 
 std::string OSInfo::processor_model_name() {
   if (processor_model_name_.empty()) {
-    const wchar_t kProcessorNameString[] =
-        L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0";
-    base::win::RegKey key(HKEY_LOCAL_MACHINE, kProcessorNameString, KEY_READ);
+    const char16 kProcessorNameString[] =
+        STRING16_LITERAL("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0");
+    RegKey key(HKEY_LOCAL_MACHINE, kProcessorNameString, KEY_READ);
     string16 value;
-    key.ReadValue(L"ProcessorNameString", &value);
+    key.ReadValue(STRING16_LITERAL("ProcessorNameString"), &value);
     processor_model_name_ = UTF16ToUTF8(value);
   }
   return processor_model_name_;
@@ -264,6 +258,55 @@
   return is_wow64 ? WOW64_ENABLED : WOW64_DISABLED;
 }
 
+// With the exception of Server 2003, server variants are treated the same as
+// the corresponding workstation release.
+// static
+Version OSInfo::MajorMinorBuildToVersion(int major, int minor, int build) {
+  if (major == 10) {
+    if (build >= 17763)
+      return VERSION_WIN10_RS5;
+    if (build >= 17134)
+      return VERSION_WIN10_RS4;
+    if (build >= 16299)
+      return VERSION_WIN10_RS3;
+    if (build >= 15063)
+      return VERSION_WIN10_RS2;
+    if (build >= 14393)
+      return VERSION_WIN10_RS1;
+    if (build >= 10586)
+      return VERSION_WIN10_TH2;
+    return VERSION_WIN10;
+  }
+
+  if (major > 6) {
+    // Hitting this likely means that it's time for a >10 block above.
+    NOTREACHED() << major << "." << minor << "." << build;
+    return VERSION_WIN_LAST;
+  }
+
+  if (major == 6) {
+    switch (minor) {
+      case 0:
+        return VERSION_VISTA;
+      case 1:
+        return VERSION_WIN7;
+      case 2:
+        return VERSION_WIN8;
+      default:
+        DCHECK_EQ(minor, 3);
+        return VERSION_WIN8_1;
+    }
+  }
+
+  if (major == 5 && minor != 0) {
+    // Treat XP Pro x64, Home Server, and Server 2003 R2 as Server 2003.
+    return minor == 1 ? VERSION_XP : VERSION_SERVER_2003;
+  }
+
+  // Win 2000 or older.
+  return VERSION_PRE_XP;
+}
+
 Version GetVersion() {
   return OSInfo::GetInstance()->version();
 }