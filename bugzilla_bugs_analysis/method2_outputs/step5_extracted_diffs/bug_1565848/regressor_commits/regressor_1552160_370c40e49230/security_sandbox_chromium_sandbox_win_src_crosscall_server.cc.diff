# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/crosscall_server.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/crosscall_server.cc
--- a/security/sandbox/chromium/sandbox/win/src/crosscall_server.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/crosscall_server.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -10,10 +10,16 @@
 #include <string>
 #include <vector>
 
+#include "base/atomicops.h"
 #include "base/logging.h"
+#include "base/strings/utf_string_conversions.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/crosscall_params.h"
 
+// See comment in atomicops.h. This is needed any time windows.h is included
+// after atomicops.h.
+#undef MemoryBarrier
+
 // This code performs the ipc message validation. Potential security flaws
 // on the ipc are likelier to be found in this code than in the rest of
 // the ipc code.
@@ -23,7 +29,7 @@
 // The buffer for a message must match the max channel size.
 const size_t kMaxBufferSize = sandbox::kIPCChannelSize;
 
-}
+}  // namespace
 
 namespace sandbox {
 
@@ -118,16 +124,14 @@
   return true;
 }
 
-CrossCallParamsEx::CrossCallParamsEx()
-  :CrossCallParams(0, 0) {
-}
+CrossCallParamsEx::CrossCallParamsEx() : CrossCallParams(0, 0) {}
 
 // We override the delete operator because the object's backing memory
 // is hand allocated in CreateFromBuffer. We don't override the new operator
 // because the constructors are private so there is no way to mismatch
 // new & delete.
 void CrossCallParamsEx::operator delete(void* raw_memory) throw() {
-  if (NULL == raw_memory) {
+  if (!raw_memory) {
     // C++ standard allows 'delete 0' behavior.
     return;
   }
@@ -142,21 +146,18 @@
                                                        uint32_t* output_size) {
   // IMPORTANT: Everything inside buffer_base and derived from it such
   // as param_count and declared_size is untrusted.
-  if (NULL == buffer_base) {
-    return NULL;
-  }
-  if (buffer_size < sizeof(CrossCallParams)) {
-    return NULL;
-  }
-  if (buffer_size > kMaxBufferSize) {
-    return NULL;
-  }
+  if (!buffer_base)
+    return nullptr;
+  if (buffer_size < sizeof(CrossCallParams))
+    return nullptr;
+  if (buffer_size > kMaxBufferSize)
+    return nullptr;
 
-  char* backing_mem = NULL;
+  char* backing_mem = nullptr;
   uint32_t param_count = 0;
   uint32_t declared_size;
   uint32_t min_declared_size;
-  CrossCallParamsEx* copied_params = NULL;
+  CrossCallParamsEx* copied_params = nullptr;
 
   // Touching the untrusted buffer is done under a SEH try block. This
   // will catch memory access violations so we don't crash.
@@ -169,11 +170,16 @@
     param_count = call_params->GetParamsCount();
     min_declared_size = GetMinDeclaredActualCallParamsSize(param_count);
 
+    // Initial check for the buffer being big enough to determine the actual
+    // buffer size.
+    if (buffer_size < min_declared_size)
+      return nullptr;
+
     // Retrieve the declared size which if it fails returns 0.
     declared_size = GetActualBufferSize(param_count, buffer_base);
 
     if (!IsSizeWithinRange(buffer_size, min_declared_size, declared_size))
-      return NULL;
+      return nullptr;
 
     // Now we copy the actual amount of the message.
     *output_size = declared_size;
@@ -184,7 +190,7 @@
     // Avoid compiler optimizations across this point. Any value stored in
     // memory should be stored for real, and values previously read from memory
     // should be actually read.
-    _ReadWriteBarrier();
+    base::subtle::MemoryBarrier();
 
     min_declared_size = GetMinDeclaredActualCallParamsSize(param_count);
 
@@ -192,37 +198,41 @@
     if (copied_params->GetParamsCount() != param_count ||
         GetActualBufferSize(param_count, backing_mem) != declared_size ||
         !IsSizeWithinRange(buffer_size, min_declared_size, declared_size)) {
-      delete [] backing_mem;
-      return NULL;
+      delete[] backing_mem;
+      return nullptr;
     }
 
-  } __except(EXCEPTION_EXECUTE_HANDLER) {
+  } __except (EXCEPTION_EXECUTE_HANDLER) {
     // In case of a windows exception we know it occurred while touching the
     // untrusted buffer so we bail out as is.
-    delete [] backing_mem;
-    return NULL;
+    delete[] backing_mem;
+    return nullptr;
   }
 
-  const char* last_byte = &backing_mem[declared_size];
-  const char* first_byte = &backing_mem[min_declared_size];
+  // Here and below we're making use of uintptr_t to have well-defined integer
+  // overflow when doing pointer arithmetic.
+  auto backing_mem_ptr = reinterpret_cast<uintptr_t>(backing_mem);
+  auto last_byte = reinterpret_cast<uintptr_t>(&backing_mem[declared_size]);
+  auto first_byte =
+      reinterpret_cast<uintptr_t>(&backing_mem[min_declared_size]);
 
   // Verify here that all and each parameters make sense. This is done in the
   // local copy.
   for (uint32_t ix = 0; ix != param_count; ++ix) {
     uint32_t size = 0;
     ArgType type;
-    char* address = reinterpret_cast<char*>(
-                        copied_params->GetRawParameter(ix, &size, &type));
-    if ((NULL == address) ||               // No null params.
+    auto address = reinterpret_cast<uintptr_t>(
+        copied_params->GetRawParameter(ix, &size, &type));
+    if ((!address) ||                                     // No null params.
         (INVALID_TYPE >= type) || (LAST_TYPE <= type) ||  // Unknown type.
-        (address < backing_mem) ||         // Start cannot point before buffer.
+        (address < backing_mem_ptr) ||     // Start cannot point before buffer.
         (address < first_byte) ||          // Start cannot point too low.
         (address > last_byte) ||           // Start cannot point past buffer.
         ((address + size) < address) ||    // Invalid size.
         ((address + size) > last_byte)) {  // End cannot point past buffer.
       // Malformed.
       delete[] backing_mem;
-      return NULL;
+      return nullptr;
     }
   }
   // The parameter buffer looks good.
@@ -233,9 +243,8 @@
 void* CrossCallParamsEx::GetRawParameter(uint32_t index,
                                          uint32_t* size,
                                          ArgType* type) {
-  if (index >= GetParamsCount()) {
-    return NULL;
-  }
+  if (index >= GetParamsCount())
+    return nullptr;
   // The size is always computed from the parameter minus the next
   // parameter, this works because the message has an extra parameter slot
   *size = param_info_[index].size_;
@@ -249,9 +258,8 @@
   uint32_t size = 0;
   ArgType type;
   void* start = GetRawParameter(index, &size, &type);
-  if ((NULL == start) || (4 != size) || (UINT32_TYPE != type)) {
+  if (!start || (4 != size) || (UINT32_TYPE != type))
     return false;
-  }
   // Copy the 4 bytes.
   *(reinterpret_cast<uint32_t*>(param)) = *(reinterpret_cast<uint32_t*>(start));
   return true;
@@ -261,9 +269,8 @@
   uint32_t size = 0;
   ArgType type;
   void* start = GetRawParameter(index, &size, &type);
-  if ((NULL == start) || (sizeof(void*) != size) || (VOIDPTR_TYPE != type)) {
+  if (!start || (sizeof(void*) != size) || (VOIDPTR_TYPE != type))
     return false;
-  }
   *param = *(reinterpret_cast<void**>(start));
   return true;
 }
@@ -272,24 +279,23 @@
 // scanned for invalid characters.
 bool CrossCallParamsEx::GetParameterStr(uint32_t index,
                                         base::string16* string) {
+  DCHECK(string->empty());
   uint32_t size = 0;
   ArgType type;
   void* start = GetRawParameter(index, &size, &type);
-  if (WCHAR_TYPE != type) {
+  if (WCHAR_TYPE != type)
     return false;
-  }
 
   // Check if this is an empty string.
   if (size == 0) {
-    *string = L"";
+    *string = base::WideToUTF16(L"");
     return true;
   }
 
-  if ((NULL == start) || ((size % sizeof(wchar_t)) != 0)) {
+  if (!start || ((size % sizeof(wchar_t)) != 0))
     return false;
-  }
-  string->append(reinterpret_cast<wchar_t*>(start), size/(sizeof(wchar_t)));
-  return true;
+  return base::WideToUTF16(reinterpret_cast<wchar_t*>(start),
+                           size / sizeof(wchar_t), string);
 }
 
 bool CrossCallParamsEx::GetParameterPtr(uint32_t index,
@@ -299,13 +305,11 @@
   ArgType type;
   void* start = GetRawParameter(index, &size, &type);
 
-  if ((size != expected_size) || (INOUTPTR_TYPE != type)) {
+  if ((size != expected_size) || (INOUTPTR_TYPE != type))
     return false;
-  }
 
-  if (NULL == start) {
+  if (!start)
     return false;
-  }
 
   *pointer = start;
   return true;
@@ -321,7 +325,7 @@
 }
 
 Dispatcher* Dispatcher::OnMessageReady(IPCParams* ipc,
-                                      CallbackGeneric* callback) {
+                                       CallbackGeneric* callback) {
   DCHECK(callback);
   std::vector<IPCCall>::iterator it = ipc_calls_.begin();
   for (; it != ipc_calls_.end(); ++it) {
@@ -330,13 +334,11 @@
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
-Dispatcher::Dispatcher() {
-}
+Dispatcher::Dispatcher() {}
 
-Dispatcher::~Dispatcher() {
-}
+Dispatcher::~Dispatcher() {}
 
 }  // namespace sandbox