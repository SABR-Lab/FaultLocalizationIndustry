# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/filesystem_dispatcher.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/filesystem_dispatcher.cc
--- a/security/sandbox/chromium/sandbox/win/src/filesystem_dispatcher.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/filesystem_dispatcher.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -17,21 +17,14 @@
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 
-#include "mozilla/sandboxing/permissionsService.h"
-
 namespace sandbox {
 
 FilesystemDispatcher::FilesystemDispatcher(PolicyBase* policy_base)
     : policy_base_(policy_base) {
   static const IPCCall create_params = {
       {IPC_NTCREATEFILE_TAG,
-       {WCHAR_TYPE,
-        UINT32_TYPE,
-        UINT32_TYPE,
-        UINT32_TYPE,
-        UINT32_TYPE,
-        UINT32_TYPE,
-        UINT32_TYPE}},
+       {WCHAR_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE, UINT32_TYPE,
+        UINT32_TYPE, UINT32_TYPE}},
       reinterpret_cast<CallbackGeneric>(&FilesystemDispatcher::NtCreateFile)};
 
   static const IPCCall open_file = {
@@ -77,8 +70,8 @@
                           12);
 
     case IPC_NTQUERYFULLATTRIBUTESFILE_TAG:
-        return INTERCEPT_NT(manager, NtQueryFullAttributesFile,
-                            QUERY_FULL_ATTRIB_FILE_ID, 12);
+      return INTERCEPT_NT(manager, NtQueryFullAttributesFile,
+                          QUERY_FULL_ATTRIB_FILE_ID, 12);
 
     case IPC_NTSETINFO_RENAME_TAG:
       return INTERCEPT_NT(manager, NtSetInformationFile, SET_INFO_FILE_ID, 24);
@@ -104,7 +97,7 @@
 
   const wchar_t* filename = name->c_str();
 
-  uint32_t broker = TRUE;
+  uint32_t broker = BROKER_TRUE;
   CountedParameterSet<OpenFile> params;
   params[OpenFile::NAME] = ParamPickerMake(filename);
   params[OpenFile::ACCESS] = ParamPickerMake(desired_access);
@@ -115,27 +108,15 @@
   // To evaluate the policy we need to call back to the policy object. We
   // are just middlemen in the operation since is the FileSystemPolicy which
   // knows what to do.
-  EvalResult result = policy_base_->EvalPolicy(IPC_NTCREATEFILE_TAG,
-                                               params.GetBase());
-
-  // If the policies forbid access (any result other than ASK_BROKER),
-  // then check for user-granted access to file.
-  if (ASK_BROKER != result &&
-      mozilla::sandboxing::PermissionsService::GetInstance()->
-        UserGrantedFileAccess(ipc->client_info->process_id, filename,
-                              desired_access, create_disposition)) {
-    result = ASK_BROKER;
-  }
-
+  EvalResult result =
+      policy_base_->EvalPolicy(IPC_NTCREATEFILE_TAG, params.GetBase());
   HANDLE handle;
   ULONG_PTR io_information = 0;
   NTSTATUS nt_status;
-  if (!FileSystemPolicy::CreateFileAction(result, *ipc->client_info, *name,
-                                          attributes, desired_access,
-                                          file_attributes, share_access,
-                                          create_disposition, create_options,
-                                          &handle, &nt_status,
-                                          &io_information)) {
+  if (!FileSystemPolicy::CreateFileAction(
+          result, *ipc->client_info, *name, attributes, desired_access,
+          file_attributes, share_access, create_disposition, create_options,
+          &handle, &nt_status, &io_information)) {
     ipc->return_info.nt_status = STATUS_ACCESS_DENIED;
     return true;
   }
@@ -160,7 +141,7 @@
 
   const wchar_t* filename = name->c_str();
 
-  uint32_t broker = TRUE;
+  uint32_t broker = BROKER_TRUE;
   uint32_t create_disposition = FILE_OPEN;
   CountedParameterSet<OpenFile> params;
   params[OpenFile::NAME] = ParamPickerMake(filename);
@@ -172,25 +153,14 @@
   // To evaluate the policy we need to call back to the policy object. We
   // are just middlemen in the operation since is the FileSystemPolicy which
   // knows what to do.
-  EvalResult result = policy_base_->EvalPolicy(IPC_NTOPENFILE_TAG,
-                                               params.GetBase());
-
-  // If the policies forbid access (any result other than ASK_BROKER),
-  // then check for user-granted access to file.
-  if (ASK_BROKER != result &&
-      mozilla::sandboxing::PermissionsService::GetInstance()->UserGrantedFileAccess(
-                                    ipc->client_info->process_id, filename,
-                                    desired_access, create_disposition)) {
-    result = ASK_BROKER;
-  }
-
+  EvalResult result =
+      policy_base_->EvalPolicy(IPC_NTOPENFILE_TAG, params.GetBase());
   HANDLE handle;
   ULONG_PTR io_information = 0;
   NTSTATUS nt_status;
-  if (!FileSystemPolicy::OpenFileAction(result, *ipc->client_info, *name,
-                                        attributes, desired_access,
-                                        share_access, open_options, &handle,
-                                        &nt_status, &io_information)) {
+  if (!FileSystemPolicy::OpenFileAction(
+          result, *ipc->client_info, *name, attributes, desired_access,
+          share_access, open_options, &handle, &nt_status, &io_information)) {
     ipc->return_info.nt_status = STATUS_ACCESS_DENIED;
     return true;
   }
@@ -214,7 +184,7 @@
     return true;
   }
 
-  uint32_t broker = TRUE;
+  uint32_t broker = BROKER_TRUE;
   const wchar_t* filename = name->c_str();
   CountedParameterSet<FileName> params;
   params[FileName::NAME] = ParamPickerMake(filename);
@@ -223,20 +193,11 @@
   // To evaluate the policy we need to call back to the policy object. We
   // are just middlemen in the operation since is the FileSystemPolicy which
   // knows what to do.
-  EvalResult result = policy_base_->EvalPolicy(IPC_NTQUERYATTRIBUTESFILE_TAG,
-                                               params.GetBase());
-
-  // If the policies forbid access (any result other than ASK_BROKER),
-  // then check for user-granted access to file.
-  if (ASK_BROKER != result &&
-      mozilla::sandboxing::PermissionsService::GetInstance()->
-        UserGrantedFileAccess(ipc->client_info->process_id, filename,
-                              0, 0)) {
-    result = ASK_BROKER;
-  }
+  EvalResult result =
+      policy_base_->EvalPolicy(IPC_NTQUERYATTRIBUTESFILE_TAG, params.GetBase());
 
   FILE_BASIC_INFORMATION* information =
-        reinterpret_cast<FILE_BASIC_INFORMATION*>(info->Buffer());
+      reinterpret_cast<FILE_BASIC_INFORMATION*>(info->Buffer());
   NTSTATUS nt_status;
   if (!FileSystemPolicy::QueryAttributesFileAction(result, *ipc->client_info,
                                                    *name, attributes,
@@ -263,7 +224,7 @@
     return true;
   }
 
-  uint32_t broker = TRUE;
+  uint32_t broker = BROKER_TRUE;
   const wchar_t* filename = name->c_str();
   CountedParameterSet<FileName> params;
   params[FileName::NAME] = ParamPickerMake(filename);
@@ -273,25 +234,14 @@
   // are just middlemen in the operation since is the FileSystemPolicy which
   // knows what to do.
   EvalResult result = policy_base_->EvalPolicy(
-                          IPC_NTQUERYFULLATTRIBUTESFILE_TAG, params.GetBase());
-
-  // If the policies forbid access (any result other than ASK_BROKER),
-  // then check for user-granted access to file.
-  if (ASK_BROKER != result &&
-      mozilla::sandboxing::PermissionsService::GetInstance()->
-        UserGrantedFileAccess(ipc->client_info->process_id, filename,
-                              0, 0)) {
-    result = ASK_BROKER;
-  }
+      IPC_NTQUERYFULLATTRIBUTESFILE_TAG, params.GetBase());
 
   FILE_NETWORK_OPEN_INFORMATION* information =
-        reinterpret_cast<FILE_NETWORK_OPEN_INFORMATION*>(info->Buffer());
+      reinterpret_cast<FILE_NETWORK_OPEN_INFORMATION*>(info->Buffer());
   NTSTATUS nt_status;
-  if (!FileSystemPolicy::QueryFullAttributesFileAction(result,
-                                                       *ipc->client_info,
-                                                       *name, attributes,
-                                                       information,
-                                                       &nt_status)) {
+  if (!FileSystemPolicy::QueryFullAttributesFileAction(
+          result, *ipc->client_info, *name, attributes, information,
+          &nt_status)) {
     ipc->return_info.nt_status = STATUS_ACCESS_DENIED;
     return true;
   }
@@ -319,15 +269,15 @@
     return false;
 
   base::string16 name;
-  name.assign(rename_info->FileName, rename_info->FileNameLength /
-                                     sizeof(rename_info->FileName[0]));
+  name.assign(rename_info->FileName,
+              rename_info->FileNameLength / sizeof(rename_info->FileName[0]));
   if (!PreProcessName(&name)) {
     // The path requested might contain a reparse point.
     ipc->return_info.nt_status = STATUS_ACCESS_DENIED;
     return true;
   }
 
-  uint32_t broker = TRUE;
+  uint32_t broker = BROKER_TRUE;
   const wchar_t* filename = name.c_str();
   CountedParameterSet<FileName> params;
   params[FileName::NAME] = ParamPickerMake(filename);
@@ -336,26 +286,15 @@
   // To evaluate the policy we need to call back to the policy object. We
   // are just middlemen in the operation since is the FileSystemPolicy which
   // knows what to do.
-  EvalResult result = policy_base_->EvalPolicy(IPC_NTSETINFO_RENAME_TAG,
-                                               params.GetBase());
-
-  // If the policies forbid access (any result other than ASK_BROKER),
-  // then check for user-granted write access to file.  We only permit
-  // the FileRenameInformation action.
-  if (ASK_BROKER != result && info_class == FileRenameInformation &&
-      mozilla::sandboxing::PermissionsService::GetInstance()->
-        UserGrantedFileAccess(ipc->client_info->process_id, filename,
-                              FILE_WRITE_ATTRIBUTES, 0)) {
-    result = ASK_BROKER;
-  }
+  EvalResult result =
+      policy_base_->EvalPolicy(IPC_NTSETINFO_RENAME_TAG, params.GetBase());
 
   IO_STATUS_BLOCK* io_status =
-        reinterpret_cast<IO_STATUS_BLOCK*>(status->Buffer());
+      reinterpret_cast<IO_STATUS_BLOCK*>(status->Buffer());
   NTSTATUS nt_status;
-  if (!FileSystemPolicy::SetInformationFileAction(result, *ipc->client_info,
-                                                  handle, rename_info, length,
-                                                  info_class, io_status,
-                                                  &nt_status)) {
+  if (!FileSystemPolicy::SetInformationFileAction(
+          result, *ipc->client_info, handle, rename_info, length, info_class,
+          io_status, &nt_status)) {
     ipc->return_info.nt_status = STATUS_ACCESS_DENIED;
     return true;
   }