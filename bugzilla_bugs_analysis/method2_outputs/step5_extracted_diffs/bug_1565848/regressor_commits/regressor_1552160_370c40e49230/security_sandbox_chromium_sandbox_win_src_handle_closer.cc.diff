# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/handle_closer.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/handle_closer.cc
--- a/security/sandbox/chromium/sandbox/win/src/handle_closer.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/handle_closer.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -19,13 +19,15 @@
 
 namespace {
 
-template<typename T> T RoundUpToWordSize(T v) {
+template <typename T>
+T RoundUpToWordSize(T v) {
   if (size_t mod = v % sizeof(size_t))
     v += sizeof(size_t) - mod;
   return v;
 }
 
-template<typename T> T* RoundUpToWordSize(T* v) {
+template <typename T>
+T* RoundUpToWordSize(T* v) {
   return reinterpret_cast<T*>(RoundUpToWordSize(reinterpret_cast<size_t>(v)));
 }
 
@@ -36,11 +38,9 @@
 // Memory buffer mapped from the parent, with the list of handles.
 SANDBOX_INTERCEPT HandleCloserInfo* g_handles_to_close;
 
-HandleCloser::HandleCloser() {
-}
+HandleCloser::HandleCloser() {}
 
-HandleCloser::~HandleCloser() {
-}
+HandleCloser::~HandleCloser() {}
 
 ResultCode HandleCloser::AddHandle(const base::char16* handle_type,
                                    const base::char16* handle_name) {
@@ -77,7 +77,7 @@
   for (HandleMap::iterator i = handles_to_close_.begin();
        i != handles_to_close_.end(); ++i) {
     size_t bytes_entry = offsetof(HandleListEntry, handle_type) +
-        (i->first.size() + 1) * sizeof(base::char16);
+                         (i->first.size() + 1) * sizeof(base::char16);
     for (HandleMap::mapped_type::iterator j = i->second.begin();
          j != i->second.end(); ++j) {
       bytes_entry += ((*j).size() + 1) * sizeof(base::char16);
@@ -92,7 +92,8 @@
 }
 
 bool HandleCloser::InitializeTargetHandles(TargetProcess* target) {
-  // Do nothing on an empty list (global pointer already initialized to NULL).
+  // Do nothing on an empty list (global pointer already initialized to
+  // nullptr).
   if (handles_to_close_.empty())
     return true;
 
@@ -106,14 +107,14 @@
   HANDLE child = target->Process();
 
   // Allocate memory in the target process without specifying the address
-  void* remote_data = ::VirtualAllocEx(child, NULL, bytes_needed,
-                                       MEM_COMMIT, PAGE_READWRITE);
-  if (NULL == remote_data)
+  void* remote_data = ::VirtualAllocEx(child, nullptr, bytes_needed, MEM_COMMIT,
+                                       PAGE_READWRITE);
+  if (!remote_data)
     return false;
 
   // Copy the handle buffer over.
   SIZE_T bytes_written;
-  BOOL result = ::WriteProcessMemory(child, remote_data, local_buffer.get(),
+  bool result = ::WriteProcessMemory(child, remote_data, local_buffer.get(),
                                      bytes_needed, &bytes_written);
   if (!result || bytes_written != bytes_needed) {
     ::VirtualFreeEx(child, remote_data, 0, MEM_RELEASE);
@@ -122,9 +123,8 @@
 
   g_handles_to_close = reinterpret_cast<HandleCloserInfo*>(remote_data);
 
-  ResultCode rc = target->TransferVariable("g_handles_to_close",
-                                           &g_handles_to_close,
-                                           sizeof(g_handles_to_close));
+  ResultCode rc = target->TransferVariable(
+      "g_handles_to_close", &g_handles_to_close, sizeof(g_handles_to_close));
 
   return (SBOX_ALL_OK == rc);
 }
@@ -135,8 +135,8 @@
   handle_info->record_bytes = buffer_bytes;
   handle_info->num_handle_types = handles_to_close_.size();
 
-  base::char16* output = reinterpret_cast<base::char16*>(
-      &handle_info->handle_entries[0]);
+  base::char16* output =
+      reinterpret_cast<base::char16*>(&handle_info->handle_entries[0]);
   base::char16* end = reinterpret_cast<base::char16*>(
       reinterpret_cast<char*>(buffer) + buffer_bytes);
   for (HandleMap::iterator i = handles_to_close_.begin();
@@ -147,11 +147,11 @@
     output = &list_entry->handle_type[0];
 
     // Copy the typename and set the offset and count.
-    i->first._Copy_s(output, i->first.size(), i->first.size());
+    i->first.copy(output, i->first.size());
     *(output += i->first.size()) = L'\0';
     output++;
-    list_entry->offset_to_names = reinterpret_cast<char*>(output) -
-        reinterpret_cast<char*>(list_entry);
+    list_entry->offset_to_names =
+        reinterpret_cast<char*>(output) - reinterpret_cast<char*>(list_entry);
     list_entry->name_count = i->second.size();
 
     // Copy the handle names.
@@ -162,8 +162,8 @@
 
     // Round up to the nearest multiple of sizeof(size_t).
     output = RoundUpToWordSize(output);
-    list_entry->record_bytes = reinterpret_cast<char*>(output) -
-        reinterpret_cast<char*>(list_entry);
+    list_entry->record_bytes =
+        reinterpret_cast<char*>(output) - reinterpret_cast<char*>(list_entry);
   }
 
   DCHECK_EQ(reinterpret_cast<size_t>(output), reinterpret_cast<size_t>(end));
@@ -171,7 +171,7 @@
 }
 
 bool GetHandleName(HANDLE handle, base::string16* handle_name) {
-  static NtQueryObject QueryObject = NULL;
+  static NtQueryObject QueryObject = nullptr;
   if (!QueryObject)
     ResolveNTFunctionPtr("NtQueryObject", &QueryObject);
 
@@ -182,8 +182,8 @@
   do {
     name.reset(static_cast<UNICODE_STRING*>(malloc(size)));
     DCHECK(name.get());
-    result = QueryObject(handle, ObjectNameInformation, name.get(),
-                         size, &size);
+    result =
+        QueryObject(handle, ObjectNameInformation, name.get(), size, &size);
   } while (result == STATUS_INFO_LENGTH_MISMATCH ||
            result == STATUS_BUFFER_OVERFLOW);
 