# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/handle_closer_agent.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/handle_closer_agent.cc
--- a/security/sandbox/chromium/sandbox/win/src/handle_closer_agent.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/handle_closer_agent.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -16,18 +16,17 @@
 // Returns type infomation for an NT object. This routine is expected to be
 // called for invalid handles so it catches STATUS_INVALID_HANDLE exceptions
 // that can be generated when handle tracing is enabled.
-NTSTATUS QueryObjectTypeInformation(HANDLE handle,
-                                    void* buffer,
-                                    ULONG* size) {
-  static NtQueryObject QueryObject = NULL;
+NTSTATUS QueryObjectTypeInformation(HANDLE handle, void* buffer, ULONG* size) {
+  static NtQueryObject QueryObject = nullptr;
   if (!QueryObject)
     ResolveNTFunctionPtr("NtQueryObject", &QueryObject);
 
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   __try {
     status = QueryObject(handle, ObjectTypeInformation, buffer, *size, size);
-  } __except(GetExceptionCode() == STATUS_INVALID_HANDLE ?
-                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
+  } __except (GetExceptionCode() == STATUS_INVALID_HANDLE
+                  ? EXCEPTION_EXECUTE_HANDLER
+                  : EXCEPTION_CONTINUE_SEARCH) {
     status = STATUS_INVALID_HANDLE;
   }
   return status;
@@ -38,18 +37,16 @@
 namespace sandbox {
 
 // Memory buffer mapped from the parent, with the list of handles.
-SANDBOX_INTERCEPT HandleCloserInfo* g_handles_to_close = NULL;
+SANDBOX_INTERCEPT HandleCloserInfo* g_handles_to_close = nullptr;
 
 bool HandleCloserAgent::NeedsHandlesClosed() {
-  return g_handles_to_close != NULL;
+  return !!g_handles_to_close;
 }
 
 HandleCloserAgent::HandleCloserAgent()
-    : dummy_handle_(::CreateEvent(NULL, FALSE, FALSE, NULL)) {
-}
+    : dummy_handle_(::CreateEvent(nullptr, false, false, nullptr)) {}
 
-HandleCloserAgent::~HandleCloserAgent() {
-}
+HandleCloserAgent::~HandleCloserAgent() {}
 
 // Attempts to stuff |closed_handle| with a duplicated handle for a dummy Event
 // with no access. This should allow the handle to be closed, to avoid
@@ -69,18 +66,17 @@
   DCHECK(dummy_handle_.Get() != closed_handle);
 
   std::vector<HANDLE> to_close;
-  HANDLE dup_dummy = NULL;
+  HANDLE dup_dummy = nullptr;
   size_t count = 16;
 
   do {
     if (!::DuplicateHandle(::GetCurrentProcess(), dummy_handle_.Get(),
-                           ::GetCurrentProcess(), &dup_dummy, 0, FALSE, 0))
+                           ::GetCurrentProcess(), &dup_dummy, 0, false, 0))
       break;
     if (dup_dummy != closed_handle)
       to_close.push_back(dup_dummy);
-  } while (count-- &&
-           reinterpret_cast<uintptr_t>(dup_dummy) <
-               reinterpret_cast<uintptr_t>(closed_handle));
+  } while (count-- && reinterpret_cast<uintptr_t>(dup_dummy) <
+                          reinterpret_cast<uintptr_t>(closed_handle));
 
   for (HANDLE h : to_close)
     ::CloseHandle(h);
@@ -92,7 +88,7 @@
 
 // Reads g_handles_to_close and creates the lookup map.
 void HandleCloserAgent::InitializeHandlesToClose(bool* is_csrss_connected) {
-  CHECK(g_handles_to_close != NULL);
+  CHECK(g_handles_to_close);
 
   // Default to connected state
   *is_csrss_connected = true;
@@ -106,19 +102,19 @@
       *is_csrss_connected = false;
     }
     HandleMap::mapped_type& handle_names = handles_to_close_[input];
-    input = reinterpret_cast<base::char16*>(reinterpret_cast<char*>(entry)
-        + entry->offset_to_names);
+    input = reinterpret_cast<base::char16*>(reinterpret_cast<char*>(entry) +
+                                            entry->offset_to_names);
     // Grab all the handle names.
     for (size_t j = 0; j < entry->name_count; ++j) {
-      std::pair<HandleMap::mapped_type::iterator, bool> name
-          = handle_names.insert(input);
+      std::pair<HandleMap::mapped_type::iterator, bool> name =
+          handle_names.insert(input);
       CHECK(name.second);
       input += name.first->size() + 1;
     }
 
     // Move on to the next entry.
-    entry = reinterpret_cast<HandleListEntry*>(reinterpret_cast<char*>(entry)
-        + entry->record_bytes);
+    entry = reinterpret_cast<HandleListEntry*>(reinterpret_cast<char*>(entry) +
+                                               entry->record_bytes);
 
     DCHECK(reinterpret_cast<base::char16*>(entry) >= input);
     DCHECK(reinterpret_cast<base::char16*>(entry) - input <
@@ -127,7 +123,7 @@
 
   // Clean up the memory we copied over.
   ::VirtualFree(g_handles_to_close, 0, MEM_RELEASE);
-  g_handles_to_close = NULL;
+  g_handles_to_close = nullptr;
 }
 
 bool HandleCloserAgent::CloseHandles() {
@@ -138,13 +134,18 @@
   if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
     return false;
 
+  // Skip closing these handles when Application Verifier is in use in order to
+  // avoid invalid-handle exceptions.
+  if (GetModuleHandleW(L"vrfcore.dll"))
+    return true;
+
   // Set up buffers for the type info and the name.
   std::vector<BYTE> type_info_buffer(sizeof(OBJECT_TYPE_INFORMATION) +
                                      32 * sizeof(wchar_t));
   OBJECT_TYPE_INFORMATION* type_info =
       reinterpret_cast<OBJECT_TYPE_INFORMATION*>(&(type_info_buffer[0]));
   base::string16 handle_name;
-  HANDLE handle = NULL;
+  HANDLE handle = nullptr;
   int invalid_count = 0;
 
   // Keep incrementing until we hit the number of handles reported by
@@ -157,11 +158,10 @@
     // Get the type name, reusing the buffer.
     ULONG size = static_cast<ULONG>(type_info_buffer.size());
     rc = QueryObjectTypeInformation(handle, type_info, &size);
-    while (rc == STATUS_INFO_LENGTH_MISMATCH ||
-           rc == STATUS_BUFFER_OVERFLOW) {
+    while (rc == STATUS_INFO_LENGTH_MISMATCH || rc == STATUS_BUFFER_OVERFLOW) {
       type_info_buffer.resize(size + sizeof(wchar_t));
-      type_info = reinterpret_cast<OBJECT_TYPE_INFORMATION*>(
-          &(type_info_buffer[0]));
+      type_info =
+          reinterpret_cast<OBJECT_TYPE_INFORMATION*>(&(type_info_buffer[0]));
       rc = QueryObjectTypeInformation(handle, type_info, &size);
       // Leave padding for the nul terminator.
       if (NT_SUCCESS(rc) && size == type_info_buffer.size())
@@ -176,8 +176,7 @@
     type_info->Name.Buffer[type_info->Name.Length / sizeof(wchar_t)] = L'\0';
 
     // Check if we're looking for this type of handle.
-    HandleMap::iterator result =
-        handles_to_close_.find(type_info->Name.Buffer);
+    HandleMap::iterator result = handles_to_close_.find(type_info->Name.Buffer);
     if (result != handles_to_close_.end()) {
       HandleMap::mapped_type& names = result->second;
       // Empty set means close all handles of this type; otherwise check name.