# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/handle_closer_test.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/handle_closer_test.cc
--- a/security/sandbox/chromium/sandbox/win/src/handle_closer_test.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/handle_closer_test.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -17,50 +17,48 @@
 
 namespace {
 
-const wchar_t *kFileExtensions[] = { L".1", L".2", L".3", L".4" };
+const wchar_t* kFileExtensions[] = {L".1", L".2", L".3", L".4"};
 
 // Returns a handle to a unique marker file that can be retrieved between runs.
-HANDLE GetMarkerFile(const wchar_t *extension) {
+HANDLE GetMarkerFile(const wchar_t* extension) {
   wchar_t path_buffer[MAX_PATH + 1];
   CHECK(::GetTempPath(MAX_PATH, path_buffer));
   base::string16 marker_path = path_buffer;
   marker_path += L"\\sbox_marker_";
 
   // Generate a unique value from the exe's size and timestamp.
-  CHECK(::GetModuleFileName(NULL, path_buffer, MAX_PATH));
-  base::win::ScopedHandle module(::CreateFile(path_buffer,
-                                 FILE_READ_ATTRIBUTES, FILE_SHARE_READ, NULL,
-                                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
+  CHECK(::GetModuleFileName(nullptr, path_buffer, MAX_PATH));
+  base::win::ScopedHandle module(
+      ::CreateFile(path_buffer, FILE_READ_ATTRIBUTES, FILE_SHARE_READ, nullptr,
+                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr));
   CHECK(module.IsValid());
   FILETIME timestamp;
-  CHECK(::GetFileTime(module.Get(), &timestamp, NULL, NULL));
-  marker_path += base::StringPrintf(L"%08x%08x%08x",
-                                    ::GetFileSize(module.Get(), NULL),
-                                    timestamp.dwLowDateTime,
-                                    timestamp.dwHighDateTime);
+  CHECK(::GetFileTime(module.Get(), &timestamp, nullptr, nullptr));
+  marker_path +=
+      base::StringPrintf(L"%08x%08x%08x", ::GetFileSize(module.Get(), nullptr),
+                         timestamp.dwLowDateTime, timestamp.dwHighDateTime);
   marker_path += extension;
 
   // Make the file delete-on-close so cleanup is automatic.
   return CreateFile(marker_path.c_str(), FILE_ALL_ACCESS,
-      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-      NULL, OPEN_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE, NULL);
+                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                    nullptr, OPEN_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE, nullptr);
 }
 
 // Returns type infomation for an NT object. This routine is expected to be
 // called for invalid handles so it catches STATUS_INVALID_HANDLE exceptions
 // that can be generated when handle tracing is enabled.
 NTSTATUS QueryObjectTypeInformation(HANDLE handle, void* buffer, ULONG* size) {
-  static NtQueryObject QueryObject = NULL;
+  static NtQueryObject QueryObject = nullptr;
   if (!QueryObject)
     ResolveNTFunctionPtr("NtQueryObject", &QueryObject);
 
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   __try {
     status = QueryObject(handle, ObjectTypeInformation, buffer, *size, size);
-  }
-  __except(GetExceptionCode() == STATUS_INVALID_HANDLE
-               ? EXCEPTION_EXECUTE_HANDLER
-               : EXCEPTION_CONTINUE_SEARCH) {
+  } __except (GetExceptionCode() == STATUS_INVALID_HANDLE
+                  ? EXCEPTION_EXECUTE_HANDLER
+                  : EXCEPTION_CONTINUE_SEARCH) {
     status = STATUS_INVALID_HANDLE;
   }
   return status;
@@ -77,7 +75,7 @@
 // Checks for the presence of a list of files (in object path form).
 // Format: CheckForFileHandle (Y|N) \path\to\file1 [\path\to\file2 ...]
 // - Y or N depending if the file should exist or not.
-SBOX_TESTS_COMMAND int CheckForFileHandles(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int CheckForFileHandles(int argc, wchar_t** argv) {
   if (argc < 2)
     return SBOX_TEST_FAILED_TO_RUN_TEST;
   bool should_find = argv[0][0] == L'Y';
@@ -98,7 +96,7 @@
       DWORD handle_count = UINT_MAX;
       const int kInvalidHandleThreshold = 100;
       const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
-      HANDLE handle = NULL;
+      HANDLE handle = nullptr;
       int invalid_count = 0;
       base::string16 handle_name;
 
@@ -181,7 +179,7 @@
         CHECK_EQ(WaitForSingleObject(handle, INFINITE), WAIT_FAILED);
 
         // Should be able to close.
-        CHECK_EQ(TRUE, CloseHandle(handle));
+        CHECK(::CloseHandle(handle));
       }
       return SBOX_TEST_SUCCEEDED;
 
@@ -207,8 +205,8 @@
     command += handle_name;
   }
 
-  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(command.c_str())) <<
-    "Failed: " << command;
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(command.c_str()))
+      << "Failed: " << command;
 }
 
 TEST(HandleCloserTest, CloseMarkerFiles) {
@@ -224,13 +222,13 @@
     CHECK(marker.IsValid());
     CHECK(sandbox::GetHandleName(marker.Get(), &handle_name));
     CHECK_EQ(policy->AddKernelObjectToClose(L"File", handle_name.c_str()),
-              SBOX_ALL_OK);
+             SBOX_ALL_OK);
     command += (L" ");
     command += handle_name;
   }
 
-  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(command.c_str())) <<
-    "Failed: " << command;
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(command.c_str()))
+      << "Failed: " << command;
 }
 
 TEST(HandleCloserTest, CheckStuffedHandle) {
@@ -260,15 +258,15 @@
 }
 
 // Run a thread pool inside a sandbox without a CSRSS connection.
-SBOX_TESTS_COMMAND int RunThreadPool(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int RunThreadPool(int argc, wchar_t** argv) {
   HANDLE wait_list[20];
-  finish_event = ::CreateEvent(NULL, TRUE, FALSE, NULL);
+  finish_event = ::CreateEvent(nullptr, true, false, nullptr);
   CHECK(finish_event);
 
   // Set up a bunch of waiters.
-  HANDLE pool = NULL;
+  HANDLE pool = nullptr;
   for (int i = 0; i < kWaitCount; ++i) {
-    HANDLE event = ::CreateEvent(NULL, TRUE, FALSE, NULL);
+    HANDLE event = ::CreateEvent(nullptr, true, false, nullptr);
     CHECK(event);
     CHECK(::RegisterWaitForSingleObject(&pool, event, ThreadPoolTask, event,
                                         INFINITE, WT_EXECUTEONLYONCE));