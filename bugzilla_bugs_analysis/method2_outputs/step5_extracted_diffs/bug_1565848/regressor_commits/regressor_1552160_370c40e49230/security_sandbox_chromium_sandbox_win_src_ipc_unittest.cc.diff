# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/ipc_unittest.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/ipc_unittest.cc
--- a/security/sandbox/chromium/sandbox/win/src/ipc_unittest.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/ipc_unittest.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -15,7 +15,8 @@
 
 // Helper function to make the fake shared memory with some
 // basic elements initialized.
-IPCControl* MakeChannels(size_t channel_size, size_t total_shared_size,
+IPCControl* MakeChannels(size_t channel_size,
+                         size_t total_shared_size,
                          size_t* base_start) {
   // Allocate memory
   char* mem = new char[total_shared_size];
@@ -23,32 +24,30 @@
   // Calculate how many channels we can fit in the shared memory.
   total_shared_size -= offsetof(IPCControl, channels);
   size_t channel_count =
-    total_shared_size / (sizeof(ChannelControl) + channel_size);
+      total_shared_size / (sizeof(ChannelControl) + channel_size);
   // Calculate the start of the first channel.
-  *base_start = (sizeof(ChannelControl)* channel_count) +
-    offsetof(IPCControl, channels);
+  *base_start =
+      (sizeof(ChannelControl) * channel_count) + offsetof(IPCControl, channels);
   // Setup client structure.
   IPCControl* client_control = reinterpret_cast<IPCControl*>(mem);
   client_control->channels_count = channel_count;
   return client_control;
 }
 
-enum TestFixMode {
-  FIX_NO_EVENTS,
-  FIX_PONG_READY,
-  FIX_PONG_NOT_READY
-};
+enum TestFixMode { FIX_NO_EVENTS, FIX_PONG_READY, FIX_PONG_NOT_READY };
 
-void FixChannels(IPCControl* client_control, size_t base_start,
-                 size_t channel_size, TestFixMode mode) {
+void FixChannels(IPCControl* client_control,
+                 size_t base_start,
+                 size_t channel_size,
+                 TestFixMode mode) {
   for (size_t ix = 0; ix != client_control->channels_count; ++ix) {
     ChannelControl& channel = client_control->channels[ix];
     channel.channel_base = base_start;
     channel.state = kFreeChannel;
     if (mode != FIX_NO_EVENTS) {
-      BOOL signaled = (FIX_PONG_READY == mode)? TRUE : FALSE;
-      channel.ping_event = ::CreateEventW(NULL, FALSE, FALSE, NULL);
-      channel.pong_event = ::CreateEventW(NULL, FALSE, signaled, NULL);
+      bool signaled = (FIX_PONG_READY == mode) ? true : false;
+      channel.ping_event = ::CreateEventW(nullptr, false, false, nullptr);
+      channel.pong_event = ::CreateEventW(nullptr, false, signaled, nullptr);
     }
     base_start += channel_size;
   }
@@ -68,7 +67,7 @@
   // and 216 in 64 bits.
   size_t channel_start = 0;
   IPCControl* client_control = MakeChannels(12 * 64, 4096, &channel_start);
-  ASSERT_TRUE(NULL != client_control);
+  ASSERT_TRUE(client_control);
   EXPECT_EQ(5u, client_control->channels_count);
 #if defined(_WIN64)
   EXPECT_EQ(216u, channel_start);
@@ -161,7 +160,7 @@
 
   CrossCallReturn answer;
   uint32_t tag1 = 666;
-  const wchar_t *text = L"98765 - 43210";
+  const wchar_t* text = L"98765 - 43210";
   base::string16 copied_text;
   CrossCallParamsEx* actual_params;
 
@@ -171,10 +170,11 @@
   EXPECT_EQ(tag1, actual_params->GetTag());
   EXPECT_TRUE(actual_params->GetParameterStr(0, &copied_text));
   EXPECT_STREQ(text, copied_text.c_str());
+  copied_text.clear();
 
   // Check with an empty string.
   uint32_t tag2 = 777;
-  const wchar_t* null_text = NULL;
+  const wchar_t* null_text = nullptr;
   CrossCall(client, tag2, null_text, &answer);
   actual_params = reinterpret_cast<CrossCallParamsEx*>(client.GetBuffer());
   EXPECT_EQ(1u, actual_params->GetParamsCount());
@@ -182,10 +182,11 @@
   uint32_t param_size = 1;
   ArgType type = INVALID_TYPE;
   void* param_addr = actual_params->GetRawParameter(0, &param_size, &type);
-  EXPECT_TRUE(NULL != param_addr);
+  EXPECT_TRUE(param_addr);
   EXPECT_EQ(0u, param_size);
   EXPECT_EQ(WCHAR_TYPE, type);
   EXPECT_TRUE(actual_params->GetParameterStr(0, &copied_text));
+  EXPECT_TRUE(copied_text.empty());
 
   uint32_t tag3 = 888;
   param_size = 1;
@@ -198,17 +199,18 @@
   EXPECT_EQ(tag3, actual_params->GetTag());
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(0, &param_size, &type);
-  EXPECT_TRUE(NULL != param_addr);
+  EXPECT_TRUE(param_addr);
   EXPECT_EQ(0u, param_size);
   EXPECT_EQ(WCHAR_TYPE, type);
   EXPECT_TRUE(actual_params->GetParameterStr(0, &copied_text));
+  EXPECT_TRUE(copied_text.empty());
   EXPECT_TRUE(actual_params->GetParameterStr(1, &copied_text));
   EXPECT_STREQ(text, copied_text.c_str());
 
   param_size = 1;
   base::string16 copied_text_p0, copied_text_p2;
 
-  const wchar_t *text2 = L"AeFG";
+  const wchar_t* text2 = L"AeFG";
   CrossCall(client, tag1, text2, null_text, text, &answer);
   actual_params = reinterpret_cast<CrossCallParamsEx*>(client.GetBuffer());
   EXPECT_EQ(3u, actual_params->GetParamsCount());
@@ -219,7 +221,7 @@
   EXPECT_STREQ(text, copied_text_p2.c_str());
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(1, &param_size, &type);
-  EXPECT_TRUE(NULL != param_addr);
+  EXPECT_TRUE(param_addr);
   EXPECT_EQ(0u, param_size);
   EXPECT_EQ(WCHAR_TYPE, type);
 
@@ -237,7 +239,7 @@
 
   uint32_t tag1 = 999;
   uint32_t tag2 = 111;
-  const wchar_t *text = L"godzilla";
+  const wchar_t* text = L"godzilla";
   CrossCallParamsEx* actual_params;
 
   char* mem = reinterpret_cast<char*>(client_control);
@@ -254,7 +256,7 @@
   void* param_addr = actual_params->GetRawParameter(0, &param_size, &type);
   ASSERT_EQ(sizeof(dw), param_size);
   EXPECT_EQ(UINT32_TYPE, type);
-  ASSERT_TRUE(NULL != param_addr);
+  ASSERT_TRUE(param_addr);
   EXPECT_EQ(0, memcmp(&dw, param_addr, param_size));
 
   // Check handling for windows HANDLES.
@@ -267,7 +269,7 @@
   param_addr = actual_params->GetRawParameter(1, &param_size, &type);
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
-  ASSERT_TRUE(NULL != param_addr);
+  ASSERT_TRUE(param_addr);
   EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
 
   // Check combination of 32 and 64 bits.
@@ -279,19 +281,19 @@
   param_addr = actual_params->GetRawParameter(0, &param_size, &type);
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
-  ASSERT_TRUE(NULL != param_addr);
+  ASSERT_TRUE(param_addr);
   EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(1, &param_size, &type);
   ASSERT_EQ(sizeof(dw), param_size);
   EXPECT_EQ(UINT32_TYPE, type);
-  ASSERT_TRUE(NULL != param_addr);
+  ASSERT_TRUE(param_addr);
   EXPECT_EQ(0, memcmp(&dw, param_addr, param_size));
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(2, &param_size, &type);
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
-  ASSERT_TRUE(NULL != param_addr);
+  ASSERT_TRUE(param_addr);
   EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
 
   CloseChannelEvents(client_control);
@@ -311,11 +313,11 @@
   CrossCallParamsEx* ccp = 0;
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, params_1.GetSize(),
                                             &out_size);
-  ASSERT_TRUE(NULL != ccp);
+  ASSERT_TRUE(ccp);
   EXPECT_TRUE(ccp->GetBuffer() != buffer);
   EXPECT_EQ(kTag, ccp->GetTag());
   EXPECT_EQ(1u, ccp->GetParamsCount());
-  delete[] (reinterpret_cast<char*>(ccp));
+  delete[](reinterpret_cast<char*>(ccp));
 
   // Test that we handle integer overflow on the number of params
   // correctly. We use a test-only ctor for ActualCallParams that
@@ -327,46 +329,46 @@
     params_2.CopyParamIn(0, &value, sizeof(value), false, UINT32_TYPE);
     buffer = const_cast<void*>(params_2.GetBuffer());
 
-    EXPECT_TRUE(NULL != buffer);
+    EXPECT_TRUE(buffer);
     ccp = CrossCallParamsEx::CreateFromBuffer(buffer, params_1.GetSize(),
                                               &out_size);
-    // If the buffer is malformed the return is NULL.
-    EXPECT_TRUE(NULL == ccp);
+    // If the buffer is malformed the return is nullptr.
+    EXPECT_TRUE(!ccp);
   }
 
   ActualCallParams<1, kBufferSize> params_3(kTag, 1);
   params_3.CopyParamIn(0, &value, sizeof(value), false, UINT32_TYPE);
   buffer = const_cast<void*>(params_3.GetBuffer());
-  EXPECT_TRUE(NULL != buffer);
+  EXPECT_TRUE(buffer);
 
   uint32_t correct_size = params_3.OverrideSize(1);
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, kBufferSize, &out_size);
-  EXPECT_TRUE(NULL == ccp);
+  EXPECT_TRUE(!ccp);
 
   // The correct_size is 8 bytes aligned.
   params_3.OverrideSize(correct_size - 7);
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, kBufferSize, &out_size);
-  EXPECT_TRUE(NULL == ccp);
+  EXPECT_TRUE(!ccp);
 
   params_3.OverrideSize(correct_size);
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, kBufferSize, &out_size);
-  EXPECT_TRUE(NULL != ccp);
+  EXPECT_TRUE(ccp);
 
   // Make sure that two parameters work as expected.
   ActualCallParams<2, kBufferSize> params_4(kTag, 2);
   params_4.CopyParamIn(0, &value, sizeof(value), false, UINT32_TYPE);
   params_4.CopyParamIn(1, buffer, sizeof(buffer), false, VOIDPTR_TYPE);
   buffer = const_cast<void*>(params_4.GetBuffer());
-  EXPECT_TRUE(NULL != buffer);
+  EXPECT_TRUE(buffer);
 
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, kBufferSize, &out_size);
-  EXPECT_TRUE(NULL != ccp);
+  EXPECT_TRUE(ccp);
 
 #if defined(_WIN64)
   correct_size = params_4.OverrideSize(1);
   params_4.OverrideSize(correct_size - 1);
   ccp = CrossCallParamsEx::CreateFromBuffer(buffer, kBufferSize, &out_size);
-  EXPECT_TRUE(NULL == ccp);
+  EXPECT_TRUE(!ccp);
 #endif
 }
 
@@ -409,7 +411,7 @@
   IPCControl* client_control =
       MakeChannels(channel_size, 4096 * 2, &base_start);
   FixChannels(client_control, base_start, kIPCChannelSize, FIX_PONG_NOT_READY);
-  client_control->server_alive = ::CreateMutex(NULL, FALSE, NULL);
+  client_control->server_alive = ::CreateMutex(nullptr, false, nullptr);
 
   char* mem = reinterpret_cast<char*>(client_control);
   SharedMemIPCClient client(mem);
@@ -419,8 +421,9 @@
   events.pong = client_control->channels[1].pong_event;
   events.state = &client_control->channels[1].state;
 
-  HANDLE t1 = ::CreateThread(NULL, 0, QuickResponseServer, &events, 0, NULL);
-  ASSERT_TRUE(NULL != t1);
+  HANDLE t1 =
+      ::CreateThread(nullptr, 0, QuickResponseServer, &events, 0, nullptr);
+  ASSERT_TRUE(t1);
   ::CloseHandle(t1);
 
   void* buff0 = client.GetBuffer();
@@ -439,7 +442,7 @@
 
   uint32_t tag = 7654;
   CrossCallReturn answer;
-  CrossCallParamsMock* params1 = new(buff1) CrossCallParamsMock(tag, 1);
+  CrossCallParamsMock* params1 = new (buff1) CrossCallParamsMock(tag, 1);
   FakeOkAnswerInChannel(buff1);
 
   ResultCode result = client.DoCall(params1, &answer);
@@ -452,8 +455,9 @@
   EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
   EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
 
-  HANDLE t2 = ::CreateThread(NULL, 0, QuickResponseServer, &events, 0, NULL);
-  ASSERT_TRUE(NULL != t2);
+  HANDLE t2 =
+      ::CreateThread(nullptr, 0, QuickResponseServer, &events, 0, nullptr);
+  ASSERT_TRUE(t2);
   ::CloseHandle(t2);
 
   client.FreeBuffer(buff0);
@@ -462,7 +466,7 @@
   events.state = &client_control->channels[0].state;
 
   tag = 4567;
-  CrossCallParamsMock* params2 = new(buff0) CrossCallParamsMock(tag, 1);
+  CrossCallParamsMock* params2 = new (buff0) CrossCallParamsMock(tag, 1);
   FakeOkAnswerInChannel(buff0);
 
   result = client.DoCall(params2, &answer);
@@ -509,9 +513,9 @@
 TEST(IPCTest, ClientSlowServer) {
   size_t base_start = 0;
   IPCControl* client_control =
-      MakeChannels(kIPCChannelSize, 4096*2, &base_start);
+      MakeChannels(kIPCChannelSize, 4096 * 2, &base_start);
   FixChannels(client_control, base_start, kIPCChannelSize, FIX_PONG_NOT_READY);
-  client_control->server_alive = ::CreateMutex(NULL, FALSE, NULL);
+  client_control->server_alive = ::CreateMutex(nullptr, false, nullptr);
 
   char* mem = reinterpret_cast<char*>(client_control);
   SharedMemIPCClient client(mem);
@@ -521,16 +525,18 @@
   events.pong = client_control->channels[0].pong_event;
   events.state = &client_control->channels[0].state;
 
-  HANDLE t1 = ::CreateThread(NULL, 0, SlowResponseServer, &events, 0, NULL);
-  ASSERT_TRUE(NULL != t1);
+  HANDLE t1 =
+      ::CreateThread(nullptr, 0, SlowResponseServer, &events, 0, nullptr);
+  ASSERT_TRUE(t1);
   ::CloseHandle(t1);
 
   ServerEvents events2 = {0};
   events2.pong = events.pong;
   events2.mutex = client_control->server_alive;
 
-  HANDLE t2 = ::CreateThread(NULL, 0, MainServerThread, &events2, 0, NULL);
-  ASSERT_TRUE(NULL != t2);
+  HANDLE t2 =
+      ::CreateThread(nullptr, 0, MainServerThread, &events2, 0, nullptr);
+  ASSERT_TRUE(t2);
   ::CloseHandle(t2);
 
   ::Sleep(1);
@@ -538,7 +544,7 @@
   void* buff0 = client.GetBuffer();
   uint32_t tag = 4321;
   CrossCallReturn answer;
-  CrossCallParamsMock* params1 = new(buff0) CrossCallParamsMock(tag, 1);
+  CrossCallParamsMock* params1 = new (buff0) CrossCallParamsMock(tag, 1);
   FakeOkAnswerInChannel(buff0);
 
   ResultCode result = client.DoCall(params1, &answer);
@@ -558,10 +564,7 @@
 // but only CallOneHandler should be used.
 class UnitTestIPCDispatcher : public Dispatcher {
  public:
-  enum {
-    CALL_ONE_TAG = 78,
-    CALL_TWO_TAG = 87
-  };
+  enum { CALL_ONE_TAG = 78, CALL_TWO_TAG = 87 };
 
   UnitTestIPCDispatcher();
   ~UnitTestIPCDispatcher() override {}
@@ -595,8 +598,7 @@
 // and tests the packing, unpacking and call dispatching.
 TEST(IPCTest, SharedMemServerTests) {
   size_t base_start = 0;
-  IPCControl* client_control =
-      MakeChannels(kIPCChannelSize, 4096, &base_start);
+  IPCControl* client_control = MakeChannels(kIPCChannelSize, 4096, &base_start);
   client_control->server_alive = HANDLE(1);
   FixChannels(client_control, base_start, kIPCChannelSize, FIX_PONG_READY);
 
@@ -608,19 +610,19 @@
   DWORD foo = 6767676;
   CrossCall(client, UnitTestIPCDispatcher::CALL_ONE_TAG, bar, foo, &answer);
   void* buff = client.GetBuffer();
-  ASSERT_TRUE(NULL != buff);
+  ASSERT_TRUE(buff);
 
   UnitTestIPCDispatcher dispatcher;
   // Since we are directly calling InvokeCallback, most of this structure
-  // can be set to NULL.
+  // can be set to nullptr.
   sandbox::SharedMemIPCServer::ServerControl srv_control = {};
   srv_control.channel_size = kIPCChannelSize;
   srv_control.shared_base = reinterpret_cast<char*>(client_control);
   srv_control.dispatcher = &dispatcher;
 
   sandbox::CrossCallReturn call_return = {0};
-  EXPECT_TRUE(SharedMemIPCServer::InvokeCallback(&srv_control, buff,
-                                                 &call_return));
+  EXPECT_TRUE(
+      SharedMemIPCServer::InvokeCallback(&srv_control, buff, &call_return));
   EXPECT_EQ(SBOX_ALL_OK, call_return.call_outcome);
   EXPECT_TRUE(bar == call_return.extended[0].handle);
   EXPECT_EQ(foo, call_return.extended[1].unsigned_int);