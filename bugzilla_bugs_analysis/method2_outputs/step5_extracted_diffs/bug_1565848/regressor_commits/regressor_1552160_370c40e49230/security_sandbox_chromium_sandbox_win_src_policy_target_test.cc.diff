# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/policy_target_test.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/policy_target_test.cc
--- a/security/sandbox/chromium/sandbox/win/src/policy_target_test.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/policy_target_test.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -20,17 +20,18 @@
 
 namespace sandbox {
 
-#define BINDNTDLL(name) \
-    name ## Function name = reinterpret_cast<name ## Function>( \
+#define BINDNTDLL(name)                                   \
+  name##Function name = reinterpret_cast<name##Function>( \
       ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), #name))
 
 // Reverts to self and verify that SetInformationToken was faked. Returns
 // SBOX_TEST_SUCCEEDED if faked and SBOX_TEST_FAILED if not faked.
-SBOX_TESTS_COMMAND int PolicyTargetTest_token(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_token(int argc, wchar_t** argv) {
   HANDLE thread_token;
   // Get the thread token, using impersonation.
-  if (!::OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE |
-                             TOKEN_DUPLICATE, FALSE, &thread_token))
+  if (!::OpenThreadToken(GetCurrentThread(),
+                         TOKEN_IMPERSONATE | TOKEN_DUPLICATE, false,
+                         &thread_token))
     return ::GetLastError();
 
   ::RevertToSelf();
@@ -38,7 +39,7 @@
 
   int ret = SBOX_TEST_FAILED;
   if (::OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
-                        FALSE, &thread_token)) {
+                        false, &thread_token)) {
     ret = SBOX_TEST_SUCCEEDED;
     ::CloseHandle(thread_token);
   }
@@ -48,14 +49,15 @@
 // Stores the high privilege token on a static variable, change impersonation
 // again to that one and verify that we are not interfering anymore with
 // RevertToSelf.
-SBOX_TESTS_COMMAND int PolicyTargetTest_steal(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_steal(int argc, wchar_t** argv) {
   static HANDLE thread_token;
   if (!SandboxFactory::GetTargetServices()->GetState()->RevertedToSelf()) {
-    if (!::OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE |
-                               TOKEN_DUPLICATE, FALSE, &thread_token))
+    if (!::OpenThreadToken(GetCurrentThread(),
+                           TOKEN_IMPERSONATE | TOKEN_DUPLICATE, false,
+                           &thread_token))
       return ::GetLastError();
   } else {
-    if (!::SetThreadToken(NULL, thread_token))
+    if (!::SetThreadToken(nullptr, thread_token))
       return ::GetLastError();
 
     // See if we fake the call again.
@@ -67,17 +69,18 @@
 }
 
 // Opens the thread token with and without impersonation.
-SBOX_TESTS_COMMAND int PolicyTargetTest_token2(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_token2(int argc, wchar_t** argv) {
   HANDLE thread_token;
   // Get the thread token, using impersonation.
-  if (!::OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE |
-                             TOKEN_DUPLICATE, FALSE, &thread_token))
+  if (!::OpenThreadToken(GetCurrentThread(),
+                         TOKEN_IMPERSONATE | TOKEN_DUPLICATE, false,
+                         &thread_token))
     return ::GetLastError();
   ::CloseHandle(thread_token);
 
   // Get the thread token, without impersonation.
   if (!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
-                       TRUE, &thread_token))
+                       true, &thread_token))
     return ::GetLastError();
   ::CloseHandle(thread_token);
   return SBOX_TEST_SUCCEEDED;
@@ -85,7 +88,7 @@
 
 // Opens the thread token with and without impersonation, using
 // NtOpenThreadTokenEX.
-SBOX_TESTS_COMMAND int PolicyTargetTest_token3(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_token3(int argc, wchar_t** argv) {
   BINDNTDLL(NtOpenThreadTokenEx);
   if (!NtOpenThreadTokenEx)
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
@@ -94,7 +97,7 @@
   // Get the thread token, using impersonation.
   NTSTATUS status = NtOpenThreadTokenEx(GetCurrentThread(),
                                         TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
-                                        FALSE, 0, &thread_token);
+                                        false, 0, &thread_token);
   if (status == STATUS_NO_TOKEN)
     return ERROR_NO_TOKEN;
   if (!NT_SUCCESS(status))
@@ -104,7 +107,7 @@
 
   // Get the thread token, without impersonation.
   status = NtOpenThreadTokenEx(GetCurrentThread(),
-                               TOKEN_IMPERSONATE | TOKEN_DUPLICATE, TRUE, 0,
+                               TOKEN_IMPERSONATE | TOKEN_DUPLICATE, true, 0,
                                &thread_token);
   if (!NT_SUCCESS(status))
     return SBOX_TEST_FAILED;
@@ -114,9 +117,9 @@
 }
 
 // Tests that we can open the current thread.
-SBOX_TESTS_COMMAND int PolicyTargetTest_thread(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_thread(int argc, wchar_t** argv) {
   DWORD thread_id = ::GetCurrentThreadId();
-  HANDLE thread = ::OpenThread(SYNCHRONIZE, FALSE, thread_id);
+  HANDLE thread = ::OpenThread(SYNCHRONIZE, false, thread_id);
   if (!thread)
     return ::GetLastError();
   if (!::CloseHandle(thread))
@@ -132,17 +135,17 @@
 }
 
 // Tests that we can create a new thread, and open it.
-SBOX_TESTS_COMMAND int PolicyTargetTest_thread2(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_thread2(int argc, wchar_t** argv) {
   // Use default values to create a new thread.
   DWORD thread_id;
-  HANDLE thread = ::CreateThread(NULL, 0, &PolicyTargetTest_thread_main, 0, 0,
-                                 &thread_id);
+  HANDLE thread = ::CreateThread(nullptr, 0, &PolicyTargetTest_thread_main, 0,
+                                 0, &thread_id);
   if (!thread)
     return ::GetLastError();
   if (!::CloseHandle(thread))
     return ::GetLastError();
 
-  thread = ::OpenThread(SYNCHRONIZE, FALSE, thread_id);
+  thread = ::OpenThread(SYNCHRONIZE, false, thread_id);
   if (!thread)
     return ::GetLastError();
 
@@ -153,7 +156,7 @@
 }
 
 // Tests that we can call CreateProcess.
-SBOX_TESTS_COMMAND int PolicyTargetTest_process(int argc, wchar_t **argv) {
+SBOX_TESTS_COMMAND int PolicyTargetTest_process(int argc, wchar_t** argv) {
   // Use default values to create a new process.
   STARTUPINFO startup_info = {0};
   startup_info.cb = sizeof(startup_info);
@@ -161,8 +164,9 @@
   // Note: CreateProcessW() can write to its lpCommandLine, don't pass a
   // raw string literal.
   base::string16 writable_cmdline_str(L"foo.exe");
-  if (!::CreateProcessW(L"foo.exe", &writable_cmdline_str[0], NULL, NULL, FALSE,
-                        0, NULL, NULL, &startup_info, &temp_process_info))
+  if (!::CreateProcessW(L"foo.exe", &writable_cmdline_str[0], nullptr, nullptr,
+                        false, 0, nullptr, nullptr, &startup_info,
+                        &temp_process_info))
     return SBOX_TEST_SUCCEEDED;
   base::win::ScopedProcessInformation process_info(temp_process_info);
   return SBOX_TEST_FAILED;
@@ -201,17 +205,17 @@
 
 TEST(PolicyTargetTest, OpenThread) {
   TestRunner runner;
-  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_thread")) <<
-      "Opens the current thread";
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_thread"))
+      << "Opens the current thread";
 
-  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_thread2")) <<
-      "Creates a new thread and opens it";
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_thread2"))
+      << "Creates a new thread and opens it";
 }
 
 TEST(PolicyTargetTest, OpenProcess) {
   TestRunner runner;
-  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_process")) <<
-      "Opens a process";
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"PolicyTargetTest_process"))
+      << "Opens a process";
 }
 
 TEST(PolicyTargetTest, PolicyBaseNoJobLifetime) {
@@ -235,11 +239,11 @@
   temp_policy->CreateAlternateDesktop(false);
   temp_policy = nullptr;
 
-  ASSERT_TRUE(broker != NULL);
+  ASSERT_TRUE(broker);
 
   // Get the path to the sandboxed app.
   wchar_t prog_name[MAX_PATH];
-  GetModuleFileNameW(NULL, prog_name, MAX_PATH);
+  GetModuleFileNameW(nullptr, prog_name, MAX_PATH);
 
   base::string16 arguments(L"\"");
   arguments += prog_name;
@@ -273,8 +277,8 @@
   EXPECT_NE(::GetThreadDesktop(target.thread_id()),
             ::GetThreadDesktop(::GetCurrentThreadId()));
 
-  HDESK desk = ::OpenDesktop(desktop_name.c_str(), 0, FALSE, DESKTOP_ENUMERATE);
-  EXPECT_TRUE(NULL != desk);
+  HDESK desk = ::OpenDesktop(desktop_name.c_str(), 0, false, DESKTOP_ENUMERATE);
+  EXPECT_TRUE(desk);
   EXPECT_TRUE(::CloseDesktop(desk));
   EXPECT_TRUE(::TerminateProcess(target.process_handle(), 0));
 
@@ -286,8 +290,8 @@
   temp_policy = nullptr;
 
   // Make sure the desktop does not exist anymore.
-  desk = ::OpenDesktop(desktop_name.c_str(), 0, FALSE, DESKTOP_ENUMERATE);
-  EXPECT_TRUE(NULL == desk);
+  desk = ::OpenDesktop(desktop_name.c_str(), 0, false, DESKTOP_ENUMERATE);
+  EXPECT_FALSE(desk);
 }
 
 // Launches the app in the sandbox and ask it to wait in an
@@ -302,11 +306,11 @@
   temp_policy->CreateAlternateDesktop(true);
   temp_policy = nullptr;
 
-  ASSERT_TRUE(broker != NULL);
+  ASSERT_TRUE(broker);
 
   // Get the path to the sandboxed app.
   wchar_t prog_name[MAX_PATH];
-  GetModuleFileNameW(NULL, prog_name, MAX_PATH);
+  GetModuleFileNameW(nullptr, prog_name, MAX_PATH);
 
   base::string16 arguments(L"\"");
   arguments += prog_name;
@@ -348,9 +352,9 @@
   // Isolate the desktop name.
   desktop_name = desktop_name.substr(desktop_name.find_first_of(L'\\') + 1);
 
-  HDESK desk = ::OpenDesktop(desktop_name.c_str(), 0, FALSE, DESKTOP_ENUMERATE);
+  HDESK desk = ::OpenDesktop(desktop_name.c_str(), 0, false, DESKTOP_ENUMERATE);
   // This should fail if the desktop is really on another window station.
-  EXPECT_FALSE(NULL != desk);
+  EXPECT_FALSE(desk);
   EXPECT_TRUE(::TerminateProcess(target.process_handle(), 0));
 
   ::WaitForSingleObject(target.process_handle(), INFINITE);
@@ -397,7 +401,7 @@
 // be able to use the handle.
 TEST(PolicyTargetTest, ShareHandleTest) {
   BrokerServices* broker = GetBroker();
-  ASSERT_TRUE(broker != NULL);
+  ASSERT_TRUE(broker);
 
   base::StringPiece contents = "Hello World";
   std::string name = "TestSharedMemory";
@@ -415,7 +419,7 @@
 
   // Get the path to the sandboxed app.
   wchar_t prog_name[MAX_PATH];
-  GetModuleFileNameW(NULL, prog_name, MAX_PATH);
+  GetModuleFileNameW(nullptr, prog_name, MAX_PATH);
 
   scoped_refptr<TargetPolicy> policy = broker->CreatePolicy();
   policy->AddHandleToShare(read_only_view.handle().GetHandle());
@@ -423,7 +427,7 @@
   base::string16 arguments(L"\"");
   arguments += prog_name;
   arguments += L"\" -child 0 shared_memory_handle ";
-  arguments += base::UintToString16(
+  arguments += base::NumberToString16(
       base::win::HandleToUint32(read_only_view.handle().GetHandle()));
 
   // Launch the app.
@@ -453,4 +457,29 @@
   ::WaitForSingleObject(target.process_handle(), INFINITE);
 }
 
+// Dummy target that just reports that's it spawned correctly.
+SBOX_TESTS_COMMAND int PolicyTargetTest_SetEffectiveToken(int argc,
+                                                          wchar_t** argv) {
+  return SBOX_TEST_SUCCEEDED;
+}
+
+// Test whether after using SetEffectiveToken spawning a target works as
+// expected.
+TEST(PolicyTargetTest, SetEffectiveToken) {
+  TestRunner runner;
+  HANDLE token;
+
+  // Get current process token.
+  EXPECT_TRUE(
+      ::OpenProcessToken(::GetCurrentProcess(), TOKEN_ALL_ACCESS, &token));
+
+  // Setup token guard.
+  base::win::ScopedHandle token_guard(token);
+
+  // Set token and run target.
+  runner.GetPolicy()->SetEffectiveToken(token_guard.Get());
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED,
+            runner.RunTest(L"PolicyTargetTest_SetEffectiveToken"));
+}
+
 }  // namespace sandbox