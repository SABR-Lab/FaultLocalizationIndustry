# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/process_thread_dispatcher.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/process_thread_dispatcher.cc
--- a/security/sandbox/chromium/sandbox/win/src/process_thread_dispatcher.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/process_thread_dispatcher.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -31,7 +31,7 @@
 // "c:\program files\test param" will first try to launch c:\program.exe then
 // c:\program files\test.exe. We don't do that, we stop after at the first
 // space when there is no quotes.
-base::string16 GetPathFromCmdLine(const base::string16 &cmd_line) {
+base::string16 GetPathFromCmdLine(const base::string16& cmd_line) {
   base::string16 exe_name;
   // Check if it starts with '"'.
   if (cmd_line[0] == L'\"') {
@@ -57,7 +57,7 @@
 
 // Returns true is the path in parameter is relative. False if it's
 // absolute.
-bool IsPathRelative(const base::string16 &path) {
+bool IsPathRelative(const base::string16& path) {
   // A path is Relative if it's not a UNC path beginnning with \\ or a
   // path beginning with a drive. (i.e. X:\)
   if (path.find(L"\\\\") == 0 || path.find(L":\\") == 1)
@@ -67,23 +67,24 @@
 
 // Converts a relative path to an absolute path.
 bool ConvertToAbsolutePath(const base::string16& child_current_directory,
-                           bool use_env_path, base::string16 *path) {
+                           bool use_env_path,
+                           base::string16* path) {
   wchar_t file_buffer[MAX_PATH];
-  wchar_t *file_part = NULL;
+  wchar_t* file_part = nullptr;
 
   // Here we should start by looking at the path where the child application was
   // started. We don't have this information yet.
   DWORD result = 0;
   if (use_env_path) {
     // Try with the complete path
-    result = ::SearchPath(NULL, path->c_str(), NULL, MAX_PATH, file_buffer,
-                          &file_part);
+    result = ::SearchPath(nullptr, path->c_str(), nullptr, MAX_PATH,
+                          file_buffer, &file_part);
   }
 
   if (0 == result) {
     // Try with the current directory of the child
-    result = ::SearchPath(child_current_directory.c_str(), path->c_str(), NULL,
-                          MAX_PATH, file_buffer, &file_part);
+    result = ::SearchPath(child_current_directory.c_str(), path->c_str(),
+                          nullptr, MAX_PATH, file_buffer, &file_part);
   }
 
   if (0 == result || result >= MAX_PATH)
@@ -169,9 +170,8 @@
                                            uint32_t desired_access,
                                            uint32_t thread_id) {
   HANDLE handle;
-  NTSTATUS ret = ProcessPolicy::OpenThreadAction(*ipc->client_info,
-                                                 desired_access, thread_id,
-                                                 &handle);
+  NTSTATUS ret = ProcessPolicy::OpenThreadAction(
+      *ipc->client_info, desired_access, thread_id, &handle);
   ipc->return_info.nt_status = ret;
   ipc->return_info.handle = handle;
   return true;
@@ -181,9 +181,8 @@
                                             uint32_t desired_access,
                                             uint32_t process_id) {
   HANDLE handle;
-  NTSTATUS ret = ProcessPolicy::OpenProcessAction(*ipc->client_info,
-                                                  desired_access, process_id,
-                                                  &handle);
+  NTSTATUS ret = ProcessPolicy::OpenProcessAction(
+      *ipc->client_info, desired_access, process_id, &handle);
   ipc->return_info.nt_status = ret;
   ipc->return_info.handle = handle;
   return true;
@@ -193,9 +192,8 @@
                                                  HANDLE process,
                                                  uint32_t desired_access) {
   HANDLE handle;
-  NTSTATUS ret = ProcessPolicy::OpenProcessTokenAction(*ipc->client_info,
-                                                       process, desired_access,
-                                                       &handle);
+  NTSTATUS ret = ProcessPolicy::OpenProcessTokenAction(
+      *ipc->client_info, process, desired_access, &handle);
   ipc->return_info.nt_status = ret;
   ipc->return_info.handle = handle;
   return true;
@@ -206,16 +204,15 @@
                                                    uint32_t desired_access,
                                                    uint32_t attributes) {
   HANDLE handle;
-  NTSTATUS ret = ProcessPolicy::OpenProcessTokenExAction(*ipc->client_info,
-                                                         process,
-                                                         desired_access,
-                                                         attributes, &handle);
+  NTSTATUS ret = ProcessPolicy::OpenProcessTokenExAction(
+      *ipc->client_info, process, desired_access, attributes, &handle);
   ipc->return_info.nt_status = ret;
   ipc->return_info.handle = handle;
   return true;
 }
 
-bool ThreadProcessDispatcher::CreateProcessW(IPCInfo* ipc, base::string16* name,
+bool ThreadProcessDispatcher::CreateProcessW(IPCInfo* ipc,
+                                             base::string16* name,
                                              base::string16* cmd_line,
                                              base::string16* cur_dir,
                                              base::string16* target_cur_dir,
@@ -242,16 +239,15 @@
   CountedParameterSet<NameBased> params;
   params[NameBased::NAME] = ParamPickerMake(const_exe_name);
 
-  EvalResult eval = policy_base_->EvalPolicy(IPC_CREATEPROCESSW_TAG,
-                                             params.GetBase());
+  EvalResult eval =
+      policy_base_->EvalPolicy(IPC_CREATEPROCESSW_TAG, params.GetBase());
 
   PROCESS_INFORMATION* proc_info =
       reinterpret_cast<PROCESS_INFORMATION*>(info->Buffer());
   // Here we force the app_name to be the one we used for the policy lookup.
   // If our logic was wrong, at least we wont allow create a random process.
-  DWORD ret = ProcessPolicy::CreateProcessWAction(eval, *ipc->client_info,
-                                                  exe_name, *cmd_line,
-                                                  *target_cur_dir, proc_info);
+  DWORD ret = ProcessPolicy::CreateProcessWAction(
+      eval, *ipc->client_info, exe_name, *cmd_line, *target_cur_dir, proc_info);
 
   ipc->return_info.win32_result = ret;
   return true;
@@ -267,9 +263,9 @@
   }
 
   HANDLE handle;
-  DWORD ret = ProcessPolicy::CreateThreadAction(*ipc->client_info, stack_size,
-                                                start_address, parameter,
-                                                creation_flags, NULL, &handle);
+  DWORD ret = ProcessPolicy::CreateThreadAction(
+      *ipc->client_info, stack_size, start_address, parameter, creation_flags,
+      nullptr, &handle);
 
   ipc->return_info.nt_status = ret;
   ipc->return_info.handle = handle;