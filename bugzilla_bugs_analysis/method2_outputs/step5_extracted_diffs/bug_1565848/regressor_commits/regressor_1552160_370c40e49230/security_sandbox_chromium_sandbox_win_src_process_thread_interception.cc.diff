# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/process_thread_interception.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/process_thread_interception.cc
--- a/security/sandbox/chromium/sandbox/win/src/process_thread_interception.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/process_thread_interception.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -5,6 +5,7 @@
 #include "sandbox/win/src/process_thread_interception.h"
 
 #include <stdint.h>
+
 #include "base/win/windows_version.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/ipc_tags.h"
@@ -14,7 +15,6 @@
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/sharedmem_ipc_client.h"
 #include "sandbox/win/src/target_services.h"
-#include "mozilla/sandboxing/sandboxLogging.h"
 
 namespace sandbox {
 
@@ -23,15 +23,15 @@
 // Hooks NtOpenThread and proxy the call to the broker if it's trying to
 // open a thread in the same process.
 NTSTATUS WINAPI TargetNtOpenThread(NtOpenThreadFunction orig_OpenThread,
-                                   PHANDLE thread, ACCESS_MASK desired_access,
+                                   PHANDLE thread,
+                                   ACCESS_MASK desired_access,
                                    POBJECT_ATTRIBUTES object_attributes,
                                    PCLIENT_ID client_id) {
-  NTSTATUS status = orig_OpenThread(thread, desired_access, object_attributes,
-                                    client_id);
+  NTSTATUS status =
+      orig_OpenThread(thread, desired_access, object_attributes, client_id);
   if (NT_SUCCESS(status))
     return status;
 
-  mozilla::sandboxing::LogBlocked("NtOpenThread");
   do {
     if (!SandboxFactory::GetTargetServices()->GetState()->InitCalled())
       break;
@@ -42,23 +42,22 @@
     bool should_break = false;
     __try {
       // We support only the calls for the current process
-      if (NULL != client_id->UniqueProcess)
+      if (client_id->UniqueProcess)
         should_break = true;
 
-      // Object attributes should be NULL or empty.
-      if (!should_break && NULL != object_attributes) {
-        if (0 != object_attributes->Attributes ||
-            NULL != object_attributes->ObjectName ||
-            NULL != object_attributes->RootDirectory ||
-            NULL != object_attributes->SecurityDescriptor ||
-            NULL != object_attributes->SecurityQualityOfService) {
+      // Object attributes should be nullptr or empty.
+      if (!should_break && object_attributes) {
+        if (object_attributes->Attributes || object_attributes->ObjectName ||
+            object_attributes->RootDirectory ||
+            object_attributes->SecurityDescriptor ||
+            object_attributes->SecurityQualityOfService) {
           should_break = true;
         }
       }
 
       thread_id = static_cast<uint32_t>(
           reinterpret_cast<ULONG_PTR>(client_id->UniqueThread));
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
@@ -69,7 +68,7 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
     SharedMemIPCClient ipc(memory);
@@ -93,11 +92,10 @@
     __try {
       // Write the output parameters.
       *thread = answer.handle;
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
-    mozilla::sandboxing::LogAllowed("NtOpenThread");
     return answer.nt_status;
   } while (false);
 
@@ -107,11 +105,12 @@
 // Hooks NtOpenProcess and proxy the call to the broker if it's trying to
 // open the current process.
 NTSTATUS WINAPI TargetNtOpenProcess(NtOpenProcessFunction orig_OpenProcess,
-                                   PHANDLE process, ACCESS_MASK desired_access,
-                                   POBJECT_ATTRIBUTES object_attributes,
-                                   PCLIENT_ID client_id) {
-  NTSTATUS status = orig_OpenProcess(process, desired_access, object_attributes,
-                                     client_id);
+                                    PHANDLE process,
+                                    ACCESS_MASK desired_access,
+                                    POBJECT_ATTRIBUTES object_attributes,
+                                    PCLIENT_ID client_id) {
+  NTSTATUS status =
+      orig_OpenProcess(process, desired_access, object_attributes, client_id);
   if (NT_SUCCESS(status))
     return status;
 
@@ -124,20 +123,19 @@
     uint32_t process_id = 0;
     bool should_break = false;
     __try {
-      // Object attributes should be NULL or empty.
-      if (!should_break && NULL != object_attributes) {
-        if (0 != object_attributes->Attributes ||
-            NULL != object_attributes->ObjectName ||
-            NULL != object_attributes->RootDirectory ||
-            NULL != object_attributes->SecurityDescriptor ||
-            NULL != object_attributes->SecurityQualityOfService) {
+      // Object attributes should be nullptr or empty.
+      if (!should_break && object_attributes) {
+        if (object_attributes->Attributes || object_attributes->ObjectName ||
+            object_attributes->RootDirectory ||
+            object_attributes->SecurityDescriptor ||
+            object_attributes->SecurityQualityOfService) {
           should_break = true;
         }
       }
 
       process_id = static_cast<uint32_t>(
           reinterpret_cast<ULONG_PTR>(client_id->UniqueProcess));
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
@@ -148,7 +146,7 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
     SharedMemIPCClient ipc(memory);
@@ -164,7 +162,7 @@
     __try {
       // Write the output parameters.
       *process = answer.handle;
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
@@ -174,15 +172,15 @@
   return status;
 }
 
-
-NTSTATUS WINAPI TargetNtOpenProcessToken(
-    NtOpenProcessTokenFunction orig_OpenProcessToken, HANDLE process,
-    ACCESS_MASK desired_access, PHANDLE token) {
+NTSTATUS WINAPI
+TargetNtOpenProcessToken(NtOpenProcessTokenFunction orig_OpenProcessToken,
+                         HANDLE process,
+                         ACCESS_MASK desired_access,
+                         PHANDLE token) {
   NTSTATUS status = orig_OpenProcessToken(process, desired_access, token);
   if (NT_SUCCESS(status))
     return status;
 
-  mozilla::sandboxing::LogBlocked("NtOpenProcessToken");
   do {
     if (!SandboxFactory::GetTargetServices()->GetState()->InitCalled())
       break;
@@ -194,7 +192,7 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
     SharedMemIPCClient ipc(memory);
@@ -210,26 +208,27 @@
     __try {
       // Write the output parameters.
       *token = answer.handle;
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
-    mozilla::sandboxing::LogAllowed("NtOpenProcessToken");
     return answer.nt_status;
   } while (false);
 
   return status;
 }
 
-NTSTATUS WINAPI TargetNtOpenProcessTokenEx(
-    NtOpenProcessTokenExFunction orig_OpenProcessTokenEx, HANDLE process,
-    ACCESS_MASK desired_access, ULONG handle_attributes, PHANDLE token) {
+NTSTATUS WINAPI
+TargetNtOpenProcessTokenEx(NtOpenProcessTokenExFunction orig_OpenProcessTokenEx,
+                           HANDLE process,
+                           ACCESS_MASK desired_access,
+                           ULONG handle_attributes,
+                           PHANDLE token) {
   NTSTATUS status = orig_OpenProcessTokenEx(process, desired_access,
                                             handle_attributes, token);
   if (NT_SUCCESS(status))
     return status;
 
-  mozilla::sandboxing::LogBlocked("NtOpenProcessTokenEx");
   do {
     if (!SandboxFactory::GetTargetServices()->GetState()->InitCalled())
       break;
@@ -241,7 +240,7 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
     SharedMemIPCClient ipc(memory);
@@ -257,11 +256,10 @@
     __try {
       // Write the output parameters.
       *token = answer.handle;
-    } __except(EXCEPTION_EXECUTE_HANDLER) {
+    } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
-    mozilla::sandboxing::LogAllowed("NtOpenProcessTokenEx");
     return answer.nt_status;
   } while (false);
 
@@ -269,11 +267,14 @@
 }
 
 BOOL WINAPI TargetCreateProcessW(CreateProcessWFunction orig_CreateProcessW,
-                                 LPCWSTR application_name, LPWSTR command_line,
+                                 LPCWSTR application_name,
+                                 LPWSTR command_line,
                                  LPSECURITY_ATTRIBUTES process_attributes,
                                  LPSECURITY_ATTRIBUTES thread_attributes,
-                                 BOOL inherit_handles, DWORD flags,
-                                 LPVOID environment, LPCWSTR current_directory,
+                                 BOOL inherit_handles,
+                                 DWORD flags,
+                                 LPVOID environment,
+                                 LPCWSTR current_directory,
                                  LPSTARTUPINFOW startup_info,
                                  LPPROCESS_INFORMATION process_information) {
   if (SandboxFactory::GetTargetServices()->GetState()->IsCsrssConnected() &&
@@ -281,14 +282,12 @@
                           thread_attributes, inherit_handles, flags,
                           environment, current_directory, startup_info,
                           process_information)) {
-    return TRUE;
+    return true;
   }
 
-  mozilla::sandboxing::LogBlocked("CreateProcessW", application_name);
-
   // We don't trust that the IPC can work this early.
   if (!SandboxFactory::GetTargetServices()->GetState()->InitCalled())
-    return FALSE;
+    return false;
 
   // Don't call GetLastError before InitCalled() succeeds because kernel32 may
   // not be mapped yet.
@@ -300,10 +299,10 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
-    const wchar_t* cur_dir = NULL;
+    const wchar_t* cur_dir = nullptr;
 
     wchar_t this_current_directory[MAX_PATH];
     DWORD result = ::GetCurrentDirectory(MAX_PATH, this_current_directory);
@@ -316,30 +315,32 @@
     InOutCountedBuffer proc_info(process_information,
                                  sizeof(PROCESS_INFORMATION));
 
-    ResultCode code = CrossCall(ipc, IPC_CREATEPROCESSW_TAG, application_name,
-                                command_line, cur_dir, current_directory,
-                                proc_info, &answer);
+    ResultCode code =
+        CrossCall(ipc, IPC_CREATEPROCESSW_TAG, application_name, command_line,
+                  cur_dir, current_directory, proc_info, &answer);
     if (SBOX_ALL_OK != code)
       break;
 
     ::SetLastError(answer.win32_result);
     if (ERROR_SUCCESS != answer.win32_result)
-      return FALSE;
+      return false;
 
-    mozilla::sandboxing::LogAllowed("CreateProcessW", application_name);
-    return TRUE;
+    return true;
   } while (false);
 
   ::SetLastError(original_error);
-  return FALSE;
+  return false;
 }
 
 BOOL WINAPI TargetCreateProcessA(CreateProcessAFunction orig_CreateProcessA,
-                                 LPCSTR application_name, LPSTR command_line,
+                                 LPCSTR application_name,
+                                 LPSTR command_line,
                                  LPSECURITY_ATTRIBUTES process_attributes,
                                  LPSECURITY_ATTRIBUTES thread_attributes,
-                                 BOOL inherit_handles, DWORD flags,
-                                 LPVOID environment, LPCSTR current_directory,
+                                 BOOL inherit_handles,
+                                 DWORD flags,
+                                 LPVOID environment,
+                                 LPCSTR current_directory,
                                  LPSTARTUPINFOA startup_info,
                                  LPPROCESS_INFORMATION process_information) {
   if (SandboxFactory::GetTargetServices()->GetState()->IsCsrssConnected() &&
@@ -347,14 +348,12 @@
                           thread_attributes, inherit_handles, flags,
                           environment, current_directory, startup_info,
                           process_information)) {
-    return TRUE;
+    return true;
   }
 
-  mozilla::sandboxing::LogBlocked("CreateProcessA", application_name);
-
   // We don't trust that the IPC can work this early.
   if (!SandboxFactory::GetTargetServices()->GetState()->InitCalled())
-    return FALSE;
+    return false;
 
   // Don't call GetLastError before InitCalled() succeeds because kernel32 may
   // not be mapped yet.
@@ -366,13 +365,13 @@
       break;
 
     void* memory = GetGlobalIPCMemory();
-    if (NULL == memory)
+    if (!memory)
       break;
 
     // Convert the input params to unicode.
-    UNICODE_STRING *cmd_unicode = NULL;
-    UNICODE_STRING *app_unicode = NULL;
-    UNICODE_STRING *cwd_unicode = NULL;
+    UNICODE_STRING* cmd_unicode = nullptr;
+    UNICODE_STRING* app_unicode = nullptr;
+    UNICODE_STRING* cwd_unicode = nullptr;
     if (command_line) {
       cmd_unicode = AnsiToUnicode(command_line);
       if (!cmd_unicode)
@@ -396,10 +395,10 @@
       }
     }
 
-    const wchar_t* cmd_line = cmd_unicode ? cmd_unicode->Buffer : NULL;
-    const wchar_t* app_name = app_unicode ? app_unicode->Buffer : NULL;
-    const wchar_t* cwd = cwd_unicode ? cwd_unicode->Buffer : NULL;
-    const wchar_t* cur_dir = NULL;
+    const wchar_t* cmd_line = cmd_unicode ? cmd_unicode->Buffer : nullptr;
+    const wchar_t* app_name = app_unicode ? app_unicode->Buffer : nullptr;
+    const wchar_t* cwd = cwd_unicode ? cwd_unicode->Buffer : nullptr;
+    const wchar_t* cur_dir = nullptr;
 
     wchar_t target_current_directory[MAX_PATH];
     DWORD result = ::GetCurrentDirectory(MAX_PATH, target_current_directory);
@@ -412,8 +411,8 @@
     InOutCountedBuffer proc_info(process_information,
                                  sizeof(PROCESS_INFORMATION));
 
-    ResultCode code = CrossCall(ipc, IPC_CREATEPROCESSW_TAG, app_name,
-                                cmd_line, cur_dir, cwd, proc_info, &answer);
+    ResultCode code = CrossCall(ipc, IPC_CREATEPROCESSW_TAG, app_name, cmd_line,
+                                cur_dir, cwd, proc_info, &answer);
 
     operator delete(cmd_unicode, NT_ALLOC);
     operator delete(app_unicode, NT_ALLOC);
@@ -424,14 +423,13 @@
 
     ::SetLastError(answer.win32_result);
     if (ERROR_SUCCESS != answer.win32_result)
-      return FALSE;
+      return false;
 
-    mozilla::sandboxing::LogAllowed("CreateProcessA", application_name);
-    return TRUE;
+    return true;
   } while (false);
 
   ::SetLastError(original_error);
-  return FALSE;
+  return false;
 }
 
 HANDLE WINAPI TargetCreateThread(CreateThreadFunction orig_CreateThread,
@@ -441,21 +439,19 @@
                                  LPVOID parameter,
                                  DWORD creation_flags,
                                  LPDWORD thread_id) {
-  HANDLE hThread = NULL;
+  HANDLE hThread = nullptr;
 
   TargetServices* target_services = SandboxFactory::GetTargetServices();
-  if (NULL == target_services ||
-      target_services->GetState()->IsCsrssConnected()) {
+  if (!target_services || target_services->GetState()->IsCsrssConnected()) {
     hThread = orig_CreateThread(thread_attributes, stack_size, start_address,
                                 parameter, creation_flags, thread_id);
-    if (hThread) {
+    if (hThread)
       return hThread;
-    }
   }
 
   DWORD original_error = ::GetLastError();
   do {
-    if (NULL == target_services)
+    if (!target_services)
       break;
 
     // We don't trust that the IPC can work this early.
@@ -463,21 +459,20 @@
       break;
 
     __try {
-      if (NULL != thread_id &&
-          !ValidParameter(thread_id, sizeof(*thread_id), WRITE))
+      if (thread_id && !ValidParameter(thread_id, sizeof(*thread_id), WRITE))
         break;
 
-      if (nullptr == start_address)
+      if (!start_address)
         break;
       // We don't support thread_attributes not being null.
-      if (nullptr != thread_attributes)
+      if (thread_attributes)
         break;
     } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
     }
 
     void* memory = GetGlobalIPCMemory();
-    if (nullptr == memory)
+    if (!memory)
       break;
 
     SharedMemIPCClient ipc(memory);
@@ -493,14 +488,12 @@
       break;
 
     ::SetLastError(answer.win32_result);
-    if (ERROR_SUCCESS != answer.win32_result) {
-      return NULL;
-    }
+    if (ERROR_SUCCESS != answer.win32_result)
+      return nullptr;
 
     __try {
-      if (thread_id != NULL) {
+      if (thread_id)
         *thread_id = ::GetThreadId(answer.handle);
-      }
       return answer.handle;
     } __except (EXCEPTION_EXECUTE_HANDLER) {
       break;
@@ -508,7 +501,7 @@
   } while (false);
 
   ::SetLastError(original_error);
-  return NULL;
+  return nullptr;
 }
 
 }  // namespace sandbox