# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/restricted_token_utils.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/restricted_token_utils.cc
--- a/security/sandbox/chromium/sandbox/win/src/restricted_token_utils.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/restricted_token_utils.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -2,30 +2,64 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "sandbox/win/src/restricted_token_utils.h"
+
 #include <aclapi.h>
 #include <sddl.h>
+
+#include <memory>
 #include <vector>
 
-#include "sandbox/win/src/restricted_token_utils.h"
-
 #include "base/logging.h"
+#include "base/strings/stringprintf.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/windows_version.h"
 #include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
+#include "sandbox/win/src/sandbox_utils.h"
 #include "sandbox/win/src/security_level.h"
 #include "sandbox/win/src/sid.h"
+#include "sandbox/win/src/win_utils.h"
 
 namespace sandbox {
 
-DWORD CreateRestrictedToken(TokenLevel security_level,
+namespace {
+
+DWORD GetObjectSecurityDescriptor(HANDLE handle,
+                                  SECURITY_INFORMATION security_info,
+                                  std::vector<char>* security_desc_buffer,
+                                  PSECURITY_DESCRIPTOR* security_desc) {
+  DWORD last_error = 0;
+  DWORD length_needed = 0;
+
+  ::GetKernelObjectSecurity(handle, security_info, nullptr, 0, &length_needed);
+  last_error = ::GetLastError();
+  if (last_error != ERROR_INSUFFICIENT_BUFFER)
+    return last_error;
+
+  security_desc_buffer->resize(length_needed);
+  *security_desc =
+      reinterpret_cast<PSECURITY_DESCRIPTOR>(security_desc_buffer->data());
+
+  if (!::GetKernelObjectSecurity(handle, security_info, *security_desc,
+                                 length_needed, &length_needed)) {
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+}  // namespace
+
+DWORD CreateRestrictedToken(HANDLE effective_token,
+                            TokenLevel security_level,
                             IntegrityLevel integrity_level,
                             TokenType token_type,
                             bool lockdown_default_dacl,
                             bool use_restricting_sids,
                             base::win::ScopedHandle* token) {
   RestrictedToken restricted_token;
-  restricted_token.Init(NULL);  // Initialized with the current process token
+  restricted_token.Init(effective_token);
   if (lockdown_default_dacl)
     restricted_token.SetLockdownDefaultDacl();
 
@@ -111,9 +145,7 @@
       }
       break;
     }
-    default: {
-      return ERROR_BAD_ARGUMENTS;
-    }
+    default: { return ERROR_BAD_ARGUMENTS; }
   }
 
   DWORD err_code = ERROR_SUCCESS;
@@ -149,40 +181,39 @@
   return err_code;
 }
 
-DWORD SetObjectIntegrityLabel(HANDLE handle, SE_OBJECT_TYPE type,
+DWORD SetObjectIntegrityLabel(HANDLE handle,
+                              SE_OBJECT_TYPE type,
                               const wchar_t* ace_access,
                               const wchar_t* integrity_level_sid) {
   // Build the SDDL string for the label.
-  base::string16 sddl = L"S:(";   // SDDL for a SACL.
-  sddl += SDDL_MANDATORY_LABEL;   // Ace Type is "Mandatory Label".
-  sddl += L";;";                  // No Ace Flags.
-  sddl += ace_access;             // Add the ACE access.
-  sddl += L";;;";                 // No ObjectType and Inherited Object Type.
-  sddl += integrity_level_sid;    // Trustee Sid.
+  base::string16 sddl = L"S:(";  // SDDL for a SACL.
+  sddl += SDDL_MANDATORY_LABEL;  // Ace Type is "Mandatory Label".
+  sddl += L";;";                 // No Ace Flags.
+  sddl += ace_access;            // Add the ACE access.
+  sddl += L";;;";                // No ObjectType and Inherited Object Type.
+  sddl += integrity_level_sid;   // Trustee Sid.
   sddl += L")";
 
   DWORD error = ERROR_SUCCESS;
-  PSECURITY_DESCRIPTOR sec_desc = NULL;
+  PSECURITY_DESCRIPTOR sec_desc = nullptr;
 
-  PACL sacl = NULL;
-  BOOL sacl_present = FALSE;
-  BOOL sacl_defaulted = FALSE;
+  PACL sacl = nullptr;
+  BOOL sacl_present = false;
+  BOOL sacl_defaulted = false;
 
-  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl.c_str(),
-                                                             SDDL_REVISION,
-                                                             &sec_desc, NULL)) {
+  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(
+          sddl.c_str(), SDDL_REVISION, &sec_desc, nullptr)) {
     if (::GetSecurityDescriptorSacl(sec_desc, &sacl_present, &sacl,
                                     &sacl_defaulted)) {
-      error = ::SetSecurityInfo(handle, type,
-                                LABEL_SECURITY_INFORMATION, NULL, NULL, NULL,
-                                sacl);
+      error = ::SetSecurityInfo(handle, type, LABEL_SECURITY_INFORMATION,
+                                nullptr, nullptr, nullptr, sacl);
     } else {
       error = ::GetLastError();
     }
 
     ::LocalFree(sec_desc);
   } else {
-    return::GetLastError();
+    return ::GetLastError();
   }
 
   return error;
@@ -205,21 +236,20 @@
     case INTEGRITY_LEVEL_UNTRUSTED:
       return L"S-1-16-0";
     case INTEGRITY_LEVEL_LAST:
-      return NULL;
+      return nullptr;
   }
 
   NOTREACHED();
-  return NULL;
+  return nullptr;
 }
 DWORD SetTokenIntegrityLevel(HANDLE token, IntegrityLevel integrity_level) {
-
   const wchar_t* integrity_level_str = GetIntegrityLevelString(integrity_level);
   if (!integrity_level_str) {
     // No mandatory level specified, we don't change it.
     return ERROR_SUCCESS;
   }
 
-  PSID integrity_sid = NULL;
+  PSID integrity_sid = nullptr;
   if (!::ConvertStringSidToSid(integrity_level_str, &integrity_sid))
     return ::GetLastError();
 
@@ -228,8 +258,7 @@
   label.Label.Sid = integrity_sid;
 
   DWORD size = sizeof(TOKEN_MANDATORY_LABEL) + ::GetLengthSid(integrity_sid);
-  BOOL result = ::SetTokenInformation(token, TokenIntegrityLevel, &label,
-                                      size);
+  bool result = ::SetTokenInformation(token, TokenIntegrityLevel, &label, size);
   auto last_error = ::GetLastError();
   ::LocalFree(integrity_sid);
 
@@ -237,7 +266,6 @@
 }
 
 DWORD SetProcessIntegrityLevel(IntegrityLevel integrity_level) {
-
   // We don't check for an invalid level here because we'll just let it
   // fail on the SetTokenIntegrityLevel call later on.
   if (integrity_level == INTEGRITY_LEVEL_LAST) {
@@ -256,41 +284,29 @@
 }
 
 DWORD HardenTokenIntegrityLevelPolicy(HANDLE token) {
-
-  DWORD last_error = 0;
-  DWORD length_needed = 0;
-
-  ::GetKernelObjectSecurity(token, LABEL_SECURITY_INFORMATION,
-                            NULL, 0, &length_needed);
-
-  last_error = ::GetLastError();
-  if (last_error != ERROR_INSUFFICIENT_BUFFER)
+  std::vector<char> security_desc_buffer;
+  PSECURITY_DESCRIPTOR security_desc = nullptr;
+  DWORD last_error = GetObjectSecurityDescriptor(
+      token, LABEL_SECURITY_INFORMATION, &security_desc_buffer, &security_desc);
+  if (last_error != ERROR_SUCCESS)
     return last_error;
 
-  std::vector<char> security_desc_buffer(length_needed);
-  PSECURITY_DESCRIPTOR security_desc =
-      reinterpret_cast<PSECURITY_DESCRIPTOR>(&security_desc_buffer[0]);
+  PACL sacl = nullptr;
+  BOOL sacl_present = false;
+  BOOL sacl_defaulted = false;
 
-  if (!::GetKernelObjectSecurity(token, LABEL_SECURITY_INFORMATION,
-                                 security_desc, length_needed,
-                                 &length_needed))
+  if (!::GetSecurityDescriptorSacl(security_desc, &sacl_present, &sacl,
+                                   &sacl_defaulted)) {
     return ::GetLastError();
-
-  PACL sacl = NULL;
-  BOOL sacl_present = FALSE;
-  BOOL sacl_defaulted = FALSE;
-
-  if (!::GetSecurityDescriptorSacl(security_desc, &sacl_present,
-                                   &sacl, &sacl_defaulted))
-    return ::GetLastError();
+  }
 
   for (DWORD ace_index = 0; ace_index < sacl->AceCount; ++ace_index) {
     PSYSTEM_MANDATORY_LABEL_ACE ace;
 
-    if (::GetAce(sacl, ace_index, reinterpret_cast<LPVOID*>(&ace))
-        && ace->Header.AceType == SYSTEM_MANDATORY_LABEL_ACE_TYPE) {
-      ace->Mask |= SYSTEM_MANDATORY_LABEL_NO_READ_UP
-                |  SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP;
+    if (::GetAce(sacl, ace_index, reinterpret_cast<LPVOID*>(&ace)) &&
+        ace->Header.AceType == SYSTEM_MANDATORY_LABEL_ACE_TYPE) {
+      ace->Mask |= SYSTEM_MANDATORY_LABEL_NO_READ_UP |
+                   SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP;
       break;
     }
   }
@@ -303,7 +319,6 @@
 }
 
 DWORD HardenProcessIntegrityLevelPolicy() {
-
   HANDLE token_handle;
   if (!::OpenProcessToken(GetCurrentProcess(), READ_CONTROL | WRITE_OWNER,
                           &token_handle))
@@ -314,4 +329,119 @@
   return HardenTokenIntegrityLevelPolicy(token.Get());
 }
 
+DWORD CreateLowBoxToken(HANDLE base_token,
+                        TokenType token_type,
+                        PSECURITY_CAPABILITIES security_capabilities,
+                        PHANDLE saved_handles,
+                        DWORD saved_handles_count,
+                        base::win::ScopedHandle* token) {
+  NtCreateLowBoxToken CreateLowBoxToken = nullptr;
+  ResolveNTFunctionPtr("NtCreateLowBoxToken", &CreateLowBoxToken);
+
+  if (base::win::GetVersion() < base::win::VERSION_WIN8)
+    return ERROR_CALL_NOT_IMPLEMENTED;
+
+  if (token_type != PRIMARY && token_type != IMPERSONATION)
+    return ERROR_INVALID_PARAMETER;
+
+  if (!token)
+    return ERROR_INVALID_PARAMETER;
+
+  base::win::ScopedHandle base_token_handle;
+  if (!base_token) {
+    HANDLE process_token = nullptr;
+    if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_ALL_ACCESS,
+                            &process_token)) {
+      return ::GetLastError();
+    }
+    base_token_handle.Set(process_token);
+    base_token = process_token;
+  }
+  OBJECT_ATTRIBUTES obj_attr;
+  InitializeObjectAttributes(&obj_attr, nullptr, 0, nullptr, nullptr);
+  HANDLE token_lowbox = nullptr;
+
+  NTSTATUS status = CreateLowBoxToken(
+      &token_lowbox, base_token, TOKEN_ALL_ACCESS, &obj_attr,
+      security_capabilities->AppContainerSid,
+      security_capabilities->CapabilityCount,
+      security_capabilities->Capabilities, saved_handles_count, saved_handles);
+  if (!NT_SUCCESS(status))
+    return GetLastErrorFromNtStatus(status);
+
+  base::win::ScopedHandle token_lowbox_handle(token_lowbox);
+  DCHECK(token_lowbox_handle.IsValid());
+
+  // Default from NtCreateLowBoxToken is a Primary token.
+  if (token_type == PRIMARY) {
+    *token = std::move(token_lowbox_handle);
+    return ERROR_SUCCESS;
+  }
+
+  HANDLE dup_handle = nullptr;
+  if (!::DuplicateTokenEx(token_lowbox_handle.Get(), TOKEN_ALL_ACCESS, nullptr,
+                          ::SecurityImpersonation, ::TokenImpersonation,
+                          &dup_handle)) {
+    return ::GetLastError();
+  }
+
+  // Copy security descriptor from primary token as the new object will have
+  // the DACL from the current token's default DACL.
+  base::win::ScopedHandle token_for_sd(dup_handle);
+  std::vector<char> security_desc_buffer;
+  PSECURITY_DESCRIPTOR security_desc = nullptr;
+  DWORD last_error = GetObjectSecurityDescriptor(
+      token_lowbox_handle.Get(), DACL_SECURITY_INFORMATION,
+      &security_desc_buffer, &security_desc);
+  if (last_error != ERROR_SUCCESS)
+    return last_error;
+
+  if (!::SetKernelObjectSecurity(token_for_sd.Get(), DACL_SECURITY_INFORMATION,
+                                 security_desc)) {
+    return ::GetLastError();
+  }
+
+  *token = std::move(token_for_sd);
+
+  return ERROR_SUCCESS;
+}
+
+DWORD CreateLowBoxObjectDirectory(PSID lowbox_sid,
+                                  bool open_directory,
+                                  base::win::ScopedHandle* directory) {
+  DWORD session_id = 0;
+  if (!::ProcessIdToSessionId(::GetCurrentProcessId(), &session_id))
+    return ::GetLastError();
+
+  LPWSTR sid_string = nullptr;
+  if (!::ConvertSidToStringSid(lowbox_sid, &sid_string))
+    return ::GetLastError();
+
+  std::unique_ptr<wchar_t, LocalFreeDeleter> sid_string_ptr(sid_string);
+  base::string16 directory_path = base::StringPrintf(
+      L"\\Sessions\\%d\\AppContainerNamedObjects\\%ls", session_id, sid_string);
+
+  NtCreateDirectoryObjectFunction CreateObjectDirectory = nullptr;
+  ResolveNTFunctionPtr("NtCreateDirectoryObject", &CreateObjectDirectory);
+
+  OBJECT_ATTRIBUTES obj_attr;
+  UNICODE_STRING obj_name;
+  DWORD attributes = OBJ_CASE_INSENSITIVE;
+  if (open_directory)
+    attributes |= OBJ_OPENIF;
+
+  sandbox::InitObjectAttribs(directory_path, attributes, nullptr, &obj_attr,
+                             &obj_name, nullptr);
+
+  HANDLE handle = nullptr;
+  NTSTATUS status =
+      CreateObjectDirectory(&handle, DIRECTORY_ALL_ACCESS, &obj_attr);
+
+  if (!NT_SUCCESS(status))
+    return GetLastErrorFromNtStatus(status);
+  directory->Set(handle);
+
+  return ERROR_SUCCESS;
+}
+
 }  // namespace sandbox