# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/sandbox_policy_base.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/sandbox_policy_base.cc
--- a/security/sandbox/chromium/sandbox/win/src/sandbox_policy_base.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/sandbox_policy_base.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -29,6 +29,7 @@
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/sandbox_policy.h"
 #include "sandbox/win/src/sandbox_utils.h"
+#include "sandbox/win/src/security_capabilities.h"
 #include "sandbox/win/src/sync_policy.h"
 #include "sandbox/win/src/target_process.h"
 #include "sandbox/win/src/top_level_dispatcher.h"
@@ -37,16 +38,16 @@
 namespace {
 
 // The standard windows size for one memory page.
-const size_t kOneMemPage = 4096;
+constexpr size_t kOneMemPage = 4096;
 // The IPC and Policy shared memory sizes.
-const size_t kIPCMemSize = kOneMemPage * 2;
-const size_t kPolMemSize = kOneMemPage * 14;
+constexpr size_t kIPCMemSize = kOneMemPage * 2;
+constexpr size_t kPolMemSize = kOneMemPage * 14;
 
 // Helper function to allocate space (on the heap) for policy.
 sandbox::PolicyGlobal* MakeBrokerPolicyMemory() {
   const size_t kTotalPolicySz = kPolMemSize;
-  sandbox::PolicyGlobal* policy = static_cast<sandbox::PolicyGlobal*>
-      (::operator new(kTotalPolicySz));
+  sandbox::PolicyGlobal* policy =
+      static_cast<sandbox::PolicyGlobal*>(::operator new(kTotalPolicySz));
   DCHECK(policy);
   memset(policy, 0, kTotalPolicySz);
   policy->data_size = kTotalPolicySz - sizeof(sandbox::PolicyGlobal);
@@ -65,43 +66,6 @@
   return handle_type == FILE_TYPE_DISK || handle_type == FILE_TYPE_PIPE;
 }
 
-HANDLE CreateLowBoxObjectDirectory(PSID lowbox_sid) {
-  DWORD session_id = 0;
-  if (!::ProcessIdToSessionId(::GetCurrentProcessId(), &session_id))
-    return NULL;
-
-  LPWSTR sid_string = NULL;
-  if (!::ConvertSidToStringSid(lowbox_sid, &sid_string))
-    return NULL;
-
-  base::string16 directory_path = base::StringPrintf(
-                   L"\\Sessions\\%d\\AppContainerNamedObjects\\%ls",
-                   session_id, sid_string).c_str();
-  ::LocalFree(sid_string);
-
-  NtCreateDirectoryObjectFunction CreateObjectDirectory = NULL;
-  ResolveNTFunctionPtr("NtCreateDirectoryObject", &CreateObjectDirectory);
-
-  OBJECT_ATTRIBUTES obj_attr;
-  UNICODE_STRING obj_name;
-  sandbox::InitObjectAttribs(directory_path,
-                             OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
-                             NULL,
-                             &obj_attr,
-                             &obj_name,
-                             NULL);
-
-  HANDLE handle = NULL;
-  NTSTATUS status = CreateObjectDirectory(&handle,
-                                          DIRECTORY_ALL_ACCESS,
-                                          &obj_attr);
-
-  if (!NT_SUCCESS(status))
-    return NULL;
-
-  return handle;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -139,11 +103,12 @@
       mitigations_(0),
       delayed_mitigations_(0),
       is_csrss_connected_(true),
-      policy_maker_(NULL),
-      policy_(NULL),
-      lowbox_sid_(NULL),
+      policy_maker_(nullptr),
+      policy_(nullptr),
+      lowbox_sid_(nullptr),
       lockdown_default_dacl_(false),
-      enable_opm_redirection_(false) {
+      enable_opm_redirection_(false),
+      effective_token_(nullptr) {
   ::InitializeCriticalSection(&lock_);
   dispatcher_.reset(new TopLevelDispatcher(this));
 }
@@ -227,18 +192,18 @@
     // The desktop and winstation should have been created by now.
     // If we hit this scenario, it means that the user ignored the failure
     // during SetAlternateDesktop, so we ignore it here too.
-    if (!alternate_desktop_handle_ || !alternate_winstation_handle_) {
+    if (!alternate_desktop_handle_ || !alternate_winstation_handle_)
       return base::string16();
-    }
+
     return GetFullDesktopName(alternate_winstation_handle_,
                               alternate_desktop_handle_);
-  } else {
-    if (!alternate_desktop_local_winstation_handle_) {
-      return base::string16();
-    }
-    return GetFullDesktopName(nullptr,
-                              alternate_desktop_local_winstation_handle_);
   }
+
+  if (!alternate_desktop_local_winstation_handle_)
+    return base::string16();
+
+  return GetFullDesktopName(nullptr,
+                            alternate_desktop_local_winstation_handle_);
 }
 
 ResultCode PolicyBase::CreateAlternateDesktop(bool alternate_winstation) {
@@ -266,8 +231,9 @@
 
     // Verify that everything is fine.
     if (!alternate_desktop_handle_ ||
-        GetWindowObjectName(alternate_desktop_handle_).empty())
+        GetWindowObjectName(alternate_desktop_handle_).empty()) {
       return SBOX_ERROR_CANNOT_CREATE_DESKTOP;
+    }
   } else {
     // Check if it already exists.
     if (alternate_desktop_local_winstation_handle_)
@@ -281,8 +247,10 @@
 
     // Verify that everything is fine.
     if (!alternate_desktop_local_winstation_handle_ ||
-        GetWindowObjectName(alternate_desktop_local_winstation_handle_).empty())
+        GetWindowObjectName(alternate_desktop_local_winstation_handle_)
+            .empty()) {
       return SBOX_ERROR_CANNOT_CREATE_DESKTOP;
+    }
   }
 
   return SBOX_ALL_OK;
@@ -308,6 +276,8 @@
 }
 
 ResultCode PolicyBase::SetIntegrityLevel(IntegrityLevel integrity_level) {
+  if (app_container_profile_)
+    return SBOX_ERROR_BAD_PARAMS;
   integrity_level_ = integrity_level;
   return SBOX_ALL_OK;
 }
@@ -322,17 +292,12 @@
   return SBOX_ALL_OK;
 }
 
-ResultCode PolicyBase::SetCapability(const wchar_t* sid) {
-  capabilities_.push_back(sid);
-  return SBOX_ALL_OK;
-}
-
 ResultCode PolicyBase::SetLowBox(const wchar_t* sid) {
-  if (base::win::OSInfo::GetInstance()->version() < base::win::VERSION_WIN8)
+  if (base::win::GetVersion() < base::win::VERSION_WIN8)
     return SBOX_ERROR_UNSUPPORTED;
 
   DCHECK(sid);
-  if (lowbox_sid_)
+  if (lowbox_sid_ || app_container_profile_)
     return SBOX_ERROR_BAD_PARAMS;
 
   if (!ConvertStringSidToSid(sid, &lowbox_sid_))
@@ -341,9 +306,8 @@
   return SBOX_ALL_OK;
 }
 
-ResultCode PolicyBase::SetProcessMitigations(
-    MitigationFlags flags) {
-  if (!CanSetProcessMitigationsPreStartup(flags))
+ResultCode PolicyBase::SetProcessMitigations(MitigationFlags flags) {
+  if (app_container_profile_ || !CanSetProcessMitigationsPreStartup(flags))
     return SBOX_ERROR_BAD_PARAMS;
   mitigations_ = flags;
   return SBOX_ALL_OK;
@@ -353,8 +317,7 @@
   return mitigations_;
 }
 
-ResultCode PolicyBase::SetDelayedProcessMitigations(
-    MitigationFlags flags) {
+ResultCode PolicyBase::SetDelayedProcessMitigations(MitigationFlags flags) {
   if (!CanSetProcessMitigationsPostStartup(flags))
     return SBOX_ERROR_BAD_PARAMS;
   delayed_mitigations_ = flags;
@@ -387,11 +350,10 @@
                                Semantics semantics,
                                const wchar_t* pattern) {
   ResultCode result = AddRuleInternal(subsystem, semantics, pattern);
-  LOG_IF(ERROR, result != SBOX_ALL_OK) << "Failed to add sandbox rule."
-                                       << " error = " << result
-                                       << ", subsystem = " << subsystem
-                                       << ", semantics = " << semantics
-                                       << ", pattern = '" << pattern << "'";
+  LOG_IF(ERROR, result != SBOX_ALL_OK)
+      << "Failed to add sandbox rule."
+      << " error = " << result << ", subsystem = " << subsystem
+      << ", semantics = " << semantics << ", pattern = '" << pattern << "'";
   return result;
 }
 
@@ -406,11 +368,12 @@
 }
 
 void PolicyBase::AddHandleToShare(HANDLE handle) {
-  CHECK(handle && handle != INVALID_HANDLE_VALUE);
+  CHECK(handle);
+  CHECK_NE(handle, INVALID_HANDLE_VALUE);
 
   // Ensure the handle can be inherited.
-  BOOL result = SetHandleInformation(handle, HANDLE_FLAG_INHERIT,
-                                     HANDLE_FLAG_INHERIT);
+  bool result =
+      SetHandleInformation(handle, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
   PCHECK(result);
 
   handles_to_share_.push_back(handle);
@@ -425,18 +388,19 @@
 }
 
 ResultCode PolicyBase::MakeJobObject(base::win::ScopedHandle* job) {
-  if (job_level_ != JOB_NONE) {
-    // Create the windows job object.
-    Job job_obj;
-    DWORD result = job_obj.Init(job_level_, NULL, ui_exceptions_,
-                                memory_limit_);
-    if (ERROR_SUCCESS != result)
-      return SBOX_ERROR_GENERIC;
+  if (job_level_ == JOB_NONE) {
+    job->Close();
+    return SBOX_ALL_OK;
+  }
 
-    *job = job_obj.Take();
-  } else {
-    *job = base::win::ScopedHandle();
-  }
+  // Create the windows job object.
+  Job job_obj;
+  DWORD result =
+      job_obj.Init(job_level_, nullptr, ui_exceptions_, memory_limit_);
+  if (ERROR_SUCCESS != result)
+    return SBOX_ERROR_GENERIC;
+
+  *job = job_obj.Take();
   return SBOX_ALL_OK;
 }
 
@@ -446,9 +410,9 @@
   // Create the 'naked' token. This will be the permanent token associated
   // with the process and therefore with any thread that is not impersonating.
   DWORD result =
-      CreateRestrictedToken(lockdown_level_, integrity_level_, PRIMARY,
-                            lockdown_default_dacl_, use_restricting_sids_,
-                            lockdown);
+      CreateRestrictedToken(effective_token_, lockdown_level_, integrity_level_,
+                            PRIMARY, lockdown_default_dacl_,
+                            use_restricting_sids_, lockdown);
   if (ERROR_SUCCESS != result)
     return SBOX_ERROR_GENERIC;
 
@@ -488,39 +452,32 @@
   }
 
   if (lowbox_sid_) {
-    NtCreateLowBoxToken CreateLowBoxToken = NULL;
-    ResolveNTFunctionPtr("NtCreateLowBoxToken", &CreateLowBoxToken);
-    OBJECT_ATTRIBUTES obj_attr;
-    InitializeObjectAttributes(&obj_attr, NULL, 0, NULL, NULL);
-    HANDLE token_lowbox = NULL;
-
-    if (!lowbox_directory_.IsValid())
-      lowbox_directory_.Set(CreateLowBoxObjectDirectory(lowbox_sid_));
-    DCHECK(lowbox_directory_.IsValid());
+    if (!lowbox_directory_.IsValid()) {
+      result =
+          CreateLowBoxObjectDirectory(lowbox_sid_, true, &lowbox_directory_);
+      DCHECK(result == ERROR_SUCCESS);
+    }
 
     // The order of handles isn't important in the CreateLowBoxToken call.
     // The kernel will maintain a reference to the object directory handle.
     HANDLE saved_handles[1] = {lowbox_directory_.Get()};
     DWORD saved_handles_count = lowbox_directory_.IsValid() ? 1 : 0;
 
-    NTSTATUS status = CreateLowBoxToken(&token_lowbox, lockdown->Get(),
-                                        TOKEN_ALL_ACCESS, &obj_attr,
-                                        lowbox_sid_, 0, NULL,
-                                        saved_handles_count, saved_handles);
-    if (!NT_SUCCESS(status))
+    Sid package_sid(lowbox_sid_);
+    SecurityCapabilities caps(package_sid);
+    if (CreateLowBoxToken(lockdown->Get(), PRIMARY, &caps, saved_handles,
+                          saved_handles_count, lowbox) != ERROR_SUCCESS) {
       return SBOX_ERROR_GENERIC;
-
-    DCHECK(token_lowbox);
-    lowbox->Set(token_lowbox);
+    }
   }
 
   // Create the 'better' token. We use this token as the one that the main
   // thread uses when booting up the process. It should contain most of
   // what we need (before reaching main( ))
   result =
-      CreateRestrictedToken(initial_level_, integrity_level_, IMPERSONATION,
-                            lockdown_default_dacl_, use_restricting_sids_,
-                            initial);
+      CreateRestrictedToken(effective_token_, initial_level_, integrity_level_,
+                            IMPERSONATION, lockdown_default_dacl_,
+                            use_restricting_sids_, initial);
   if (ERROR_SUCCESS != result)
     return SBOX_ERROR_GENERIC;
 
@@ -532,7 +489,7 @@
 }
 
 ResultCode PolicyBase::AddTarget(TargetProcess* target) {
-  if (NULL != policy_)
+  if (policy_)
     policy_maker_->Done();
 
   if (!ApplyProcessMitigationsToSuspendedProcess(target->Process(),
@@ -566,8 +523,8 @@
     return ret;
 
   // Add in delayed mitigations and pseudo-mitigations enforced at startup.
-  g_shared_delayed_mitigations = delayed_mitigations_ |
-      FilterPostStartupProcessMitigations(mitigations_);
+  g_shared_delayed_mitigations =
+      delayed_mitigations_ | FilterPostStartupProcessMitigations(mitigations_);
   if (!CanSetProcessMitigationsPostStartup(g_shared_delayed_mitigations))
     return SBOX_ERROR_BAD_PARAMS;
 
@@ -600,11 +557,13 @@
 }
 
 ResultCode PolicyBase::SetDisconnectCsrss() {
-// Does not work on 32-bit.
-#if defined(_WIN64)
+// Does not work on 32-bit, and the ASAN runtime falls over with the
+// CreateThread EAT patch used when this is enabled.
+// See https://crbug.com/783296#c27.
+#if defined(_WIN64) && !defined(ADDRESS_SANITIZER)
   if (base::win::GetVersion() >= base::win::VERSION_WIN10) {
     is_csrss_connected_ = false;
-    return AddKernelObjectToClose(L"ALPC Port", NULL);
+    return AddKernelObjectToClose(L"ALPC Port", nullptr);
   }
 #endif  // !defined(_WIN64)
   return SBOX_ALL_OK;
@@ -612,25 +571,24 @@
 
 EvalResult PolicyBase::EvalPolicy(int service,
                                   CountedParameterSetBase* params) {
-  if (NULL != policy_) {
-    if (NULL == policy_->entry[service]) {
+  if (policy_) {
+    if (!policy_->entry[service]) {
       // There is no policy for this particular service. This is not a big
       // deal.
       return DENY_ACCESS;
     }
-    for (int i = 0; i < params->count; i++) {
+    for (size_t i = 0; i < params->count; i++) {
       if (!params->parameters[i].IsValid()) {
         NOTREACHED();
         return SIGNAL_ALARM;
       }
     }
     PolicyProcessor pol_evaluator(policy_->entry[service]);
-    PolicyResult result =  pol_evaluator.Evaluate(kShortEval,
-                                                  params->parameters,
-                                                  params->count);
-    if (POLICY_MATCH == result) {
+    PolicyResult result =
+        pol_evaluator.Evaluate(kShortEval, params->parameters, params->count);
+    if (POLICY_MATCH == result)
       return pol_evaluator.GetAction();
-    }
+
     DCHECK(POLICY_ERROR != result);
   }
 
@@ -653,6 +611,49 @@
   return enable_opm_redirection_;
 }
 
+ResultCode PolicyBase::AddAppContainerProfile(const wchar_t* package_name,
+                                              bool create_profile) {
+  if (base::win::GetVersion() < base::win::VERSION_WIN8)
+    return SBOX_ERROR_UNSUPPORTED;
+
+  DCHECK(package_name);
+  if (lowbox_sid_ || app_container_profile_ ||
+      integrity_level_ != INTEGRITY_LEVEL_LAST) {
+    return SBOX_ERROR_BAD_PARAMS;
+  }
+
+  if (create_profile) {
+    app_container_profile_ = AppContainerProfileBase::Create(
+        package_name, L"Chrome Sandbox", L"Profile for Chrome Sandbox");
+  } else {
+    app_container_profile_ = AppContainerProfileBase::Open(package_name);
+  }
+  if (!app_container_profile_)
+    return SBOX_ERROR_CREATE_APPCONTAINER_PROFILE;
+  // A bug exists in CreateProcess where enabling an AppContainer profile and
+  // passing a set of mitigation flags will generate ERROR_INVALID_PARAMETER.
+  // Apply best efforts here and convert set mitigations to delayed mitigations.
+  delayed_mitigations_ =
+      mitigations_ & GetAllowedPostStartupProcessMitigations();
+  DCHECK(delayed_mitigations_ == (mitigations_ & ~MITIGATION_SEHOP));
+  mitigations_ = 0;
+  return SBOX_ALL_OK;
+}
+
+scoped_refptr<AppContainerProfile> PolicyBase::GetAppContainerProfile() {
+  return GetAppContainerProfileBase();
+}
+
+void PolicyBase::SetEffectiveToken(HANDLE token) {
+  CHECK(token);
+  effective_token_ = token;
+}
+
+scoped_refptr<AppContainerProfileBase>
+PolicyBase::GetAppContainerProfileBase() {
+  return app_container_profile_;
+}
+
 ResultCode PolicyBase::SetupAllInterceptions(TargetProcess* target) {
   InterceptionManager manager(target, relaxed_interceptions_);
 
@@ -663,12 +664,8 @@
     }
   }
 
-  if (!blacklisted_dlls_.empty()) {
-    std::vector<base::string16>::iterator it = blacklisted_dlls_.begin();
-    for (; it != blacklisted_dlls_.end(); ++it) {
-      manager.AddToUnloadModules(it->c_str());
-    }
-  }
+  for (const base::string16& dll : blacklisted_dlls_)
+    manager.AddToUnloadModules(dll.c_str());
 
   if (!SetupBasicInterceptions(&manager, is_csrss_connected_))
     return SBOX_ERROR_SETUP_BASIC_INTERCEPTIONS;
@@ -691,7 +688,7 @@
 ResultCode PolicyBase::AddRuleInternal(SubSystem subsystem,
                                        Semantics semantics,
                                        const wchar_t* pattern) {
-  if (NULL == policy_) {
+  if (!policy_) {
     policy_ = MakeBrokerPolicyMemory();
     DCHECK(policy_);
     policy_maker_ = new LowLevelPolicy(policy_);