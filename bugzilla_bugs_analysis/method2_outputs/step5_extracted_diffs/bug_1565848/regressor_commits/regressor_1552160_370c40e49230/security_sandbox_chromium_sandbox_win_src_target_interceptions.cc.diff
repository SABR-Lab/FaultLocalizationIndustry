# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/chromium/sandbox/win/src/target_interceptions.cc
# Commit: 370c40e49230
# Full Hash: 370c40e4923073a87845b57c1f4851bacd9663da
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2019-06-12 21:42:35
# Regressor Bug: 1552160
# File Overlap Count: 3
# Description:
#   Bug 1552160 Part 1: Roll-up of chromium sandbox update and mozilla patches to get a running browser. r=jld,aklotz,tjr,bobowen
#   
#   This updates security/sandbox/chromium/ files to chromium commit 84108231f6e6e0772fb9a4643679ce76aa771e67.
#   
#   Existing and new patches applied from security/sandbox/chromium-shim/patches/with_update/ to give a compiling and mostly working browser.
# ==============================================================================

diff -r bd5ecd72f76c -r 370c40e49230 security/sandbox/chromium/sandbox/win/src/target_interceptions.cc
--- a/security/sandbox/chromium/sandbox/win/src/target_interceptions.cc	Wed Jun 12 21:55:59 2019 +1200
+++ b/security/sandbox/chromium/sandbox/win/src/target_interceptions.cc	Wed Jun 12 11:10:48 2019 +0100
@@ -13,31 +13,69 @@
 
 SANDBOX_INTERCEPT NtExports g_nt;
 
+const char VERIFIER_DLL_NAME[] = "verifier.dll";
+const char KERNEL32_DLL_NAME[] = "kernel32.dll";
+
+enum SectionLoadState {
+  kBeforeKernel32,
+  kAfterKernel32,
+};
+
 // Hooks NtMapViewOfSection to detect the load of DLLs. If hot patching is
 // required for this dll, this functions patches it.
-NTSTATUS WINAPI TargetNtMapViewOfSection(
-    NtMapViewOfSectionFunction orig_MapViewOfSection, HANDLE section,
-    HANDLE process, PVOID *base, ULONG_PTR zero_bits, SIZE_T commit_size,
-    PLARGE_INTEGER offset, PSIZE_T view_size, SECTION_INHERIT inherit,
-    ULONG allocation_type, ULONG protect) {
+NTSTATUS WINAPI
+TargetNtMapViewOfSection(NtMapViewOfSectionFunction orig_MapViewOfSection,
+                         HANDLE section,
+                         HANDLE process,
+                         PVOID* base,
+                         ULONG_PTR zero_bits,
+                         SIZE_T commit_size,
+                         PLARGE_INTEGER offset,
+                         PSIZE_T view_size,
+                         SECTION_INHERIT inherit,
+                         ULONG allocation_type,
+                         ULONG protect) {
   NTSTATUS ret = orig_MapViewOfSection(section, process, base, zero_bits,
                                        commit_size, offset, view_size, inherit,
                                        allocation_type, protect);
-
-  static int s_load_count = 0;
-  if (1 == s_load_count) {
-    SandboxFactory::GetTargetServices()->GetState()->SetKernel32Loaded();
-    s_load_count = 2;
-  }
+  static SectionLoadState s_state = kBeforeKernel32;
 
   do {
     if (!NT_SUCCESS(ret))
       break;
 
-    if (!InitHeap())
+    if (!IsSameProcess(process))
       break;
 
-    if (!IsSameProcess(process))
+    // Only check for verifier.dll or kernel32.dll loading if we haven't moved
+    // past that state yet.
+    if (s_state == kBeforeKernel32) {
+      const char* ansi_module_name =
+          GetAnsiImageInfoFromModule(reinterpret_cast<HMODULE>(*base));
+
+      // _strnicmp below may hit read access violations for some sections. We
+      // find what looks like a valid export directory for a PE module but the
+      // pointer to the module name will be pointing to invalid memory.
+      __try {
+        // Don't initialize the heap if verifier.dll is being loaded. This
+        // indicates Application Verifier is enabled and we should wait until
+        // the next module is loaded.
+        if (ansi_module_name &&
+            (g_nt._strnicmp(ansi_module_name, VERIFIER_DLL_NAME,
+                            sizeof(VERIFIER_DLL_NAME)) == 0))
+          break;
+
+        if (ansi_module_name &&
+            (g_nt._strnicmp(ansi_module_name, KERNEL32_DLL_NAME,
+                            sizeof(KERNEL32_DLL_NAME)) == 0)) {
+          SandboxFactory::GetTargetServices()->GetState()->SetKernel32Loaded();
+          s_state = kAfterKernel32;
+        }
+      } __except (EXCEPTION_EXECUTE_HANDLER) {
+      }
+    }
+
+    if (!InitHeap())
       break;
 
     if (!IsValidImageSection(section, base, offset, view_size))
@@ -60,6 +98,7 @@
       if (!agent->OnDllLoad(file_name, module_name, *base)) {
         // Interception agent is demanding to un-map the module.
         g_nt.UnmapViewOfSection(process, *base);
+        *base = nullptr;
         ret = STATUS_UNSUCCESSFUL;
       }
     }
@@ -72,15 +111,13 @@
 
   } while (false);
 
-  if (!s_load_count)
-    s_load_count = 1;
-
   return ret;
 }
 
-NTSTATUS WINAPI TargetNtUnmapViewOfSection(
-    NtUnmapViewOfSectionFunction orig_UnmapViewOfSection, HANDLE process,
-    PVOID base) {
+NTSTATUS WINAPI
+TargetNtUnmapViewOfSection(NtUnmapViewOfSectionFunction orig_UnmapViewOfSection,
+                           HANDLE process,
+                           PVOID base) {
   NTSTATUS ret = orig_UnmapViewOfSection(process, base);
 
   if (!NT_SUCCESS(ret))