# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/apz/src/APZUpdater.cpp
# Commit: 0c25260c4edf
# Full Hash: 0c25260c4edf97fdfef11320c2a91bc0698b4c11
# Author: Alexis Beingessner <a.beingessner@gmail.com>
# Date: 2019-07-25 03:53:31
# Regressor Bug: 1547351
# File Overlap Count: 2
# Description:
#   Bug 1547351 - Automatically set content process render root r=kats
#   
#   This implements the idea of automatically setting a content proc's
#   render root based on the render root enclosing the iframe that
#   points to it. There was a bit of cleanup in here that was a bit
# ==============================================================================

diff -r f96bd2aae39c -r 0c25260c4edf gfx/layers/apz/src/APZUpdater.cpp
--- a/gfx/layers/apz/src/APZUpdater.cpp	Wed Jul 24 14:10:56 2019 +0000
+++ b/gfx/layers/apz/src/APZUpdater.cpp	Wed Jul 24 14:10:56 2019 +0000
@@ -204,22 +204,24 @@
         }
         self->mEpochData[aOriginatingWrRootId].mRequired = aEpoch;
       }));
-  RunOnUpdaterThread(UpdaterQueueSelector(aOriginatingWrRootId),
-                     NS_NewRunnableFunction(
-                         "APZUpdater::UpdateHitTestingTree",
-                         [=, aScrollData = std::move(aScrollData)]() {
-                           self->mScrollData[aOriginatingWrRootId] =
-                               aScrollData;
-                           auto root = self->mScrollData.find(aRootLayerTreeId);
-                           if (root == self->mScrollData.end()) {
-                             return;
-                           }
-                           self->mApz->UpdateHitTestingTree(
-                               WebRenderScrollDataWrapper(
-                                   *self, aRootLayerTreeId, &(root->second)),
-                               aScrollData.IsFirstPaint(), aOriginatingWrRootId,
-                               aScrollData.GetPaintSequenceNumber());
-                         }));
+  RunOnUpdaterThread(
+      UpdaterQueueSelector(aOriginatingWrRootId),
+      NS_NewRunnableFunction(
+          "APZUpdater::UpdateHitTestingTree",
+          [=, aScrollData = std::move(aScrollData)]() mutable {
+            auto isFirstPaint = aScrollData.IsFirstPaint();
+            auto paintSequenceNumber = aScrollData.GetPaintSequenceNumber();
+
+            self->mScrollData[aOriginatingWrRootId] = std::move(aScrollData);
+            auto root = self->mScrollData.find(aRootLayerTreeId);
+            if (root == self->mScrollData.end()) {
+              return;
+            }
+            self->mApz->UpdateHitTestingTree(
+                WebRenderScrollDataWrapper(*self, aRootLayerTreeId,
+                                           &(root->second)),
+                isFirstPaint, aOriginatingWrRootId, paintSequenceNumber);
+          }));
 }
 
 void APZUpdater::UpdateScrollOffsets(WRRootId aRootLayerTreeId,
@@ -231,7 +233,7 @@
   RunOnUpdaterThread(UpdaterQueueSelector(aOriginatingWrRootId),
                      NS_NewRunnableFunction(
                          "APZUpdater::UpdateScrollOffsets",
-                         [=, updates = std::move(aUpdates)]() {
+                         [=, updates = std::move(aUpdates)]() mutable {
                            self->mScrollData[aOriginatingWrRootId].ApplyUpdates(
                                updates, aPaintSequenceNumber);
                            auto root = self->mScrollData.find(aRootLayerTreeId);