# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/WebRenderBridgeParent.cpp
# Commit: 0c25260c4edf
# Full Hash: 0c25260c4edf97fdfef11320c2a91bc0698b4c11
# Author: Alexis Beingessner <a.beingessner@gmail.com>
# Date: 2019-07-25 03:53:31
# Regressor Bug: 1547351
# File Overlap Count: 2
# Description:
#   Bug 1547351 - Automatically set content process render root r=kats
#   
#   This implements the idea of automatically setting a content proc's
#   render root based on the render root enclosing the iframe that
#   points to it. There was a bit of cleanup in here that was a bit
# ==============================================================================

diff -r f96bd2aae39c -r 0c25260c4edf gfx/layers/wr/WebRenderBridgeParent.cpp
--- a/gfx/layers/wr/WebRenderBridgeParent.cpp	Wed Jul 24 14:10:56 2019 +0000
+++ b/gfx/layers/wr/WebRenderBridgeParent.cpp	Wed Jul 24 14:10:56 2019 +0000
@@ -306,7 +306,6 @@
       mWrEpoch{0},
       mIdNamespace(aApis[0]->GetNamespace()),
       mRenderRootRectMutex("WebRenderBridgeParent::mRenderRootRectMutex"),
-      mRenderRoot(wr::RenderRoot::Default),
       mPaused(false),
       mDestroyed(false),
       mReceivedDisplayList(false),
@@ -320,9 +319,9 @@
     mCompositorScheduler = new CompositorVsyncScheduler(this, mWidget);
   }
 
-  if (!IsRootWebRenderBridgeParent() &&
-      StaticPrefs::gfx_webrender_split_render_roots_AtStartup()) {
-    mRenderRoot = wr::RenderRoot::Content;
+  if (IsRootWebRenderBridgeParent() ||
+      !StaticPrefs::gfx_webrender_split_render_roots_AtStartup()) {
+    mRenderRoot = Some(wr::RenderRoot::Default);
   }
 
   for (auto& api : aApis) {
@@ -339,19 +338,196 @@
       mWrEpoch{0},
       mIdNamespace{0},
       mRenderRootRectMutex("WebRenderBridgeParent::mRenderRootRectMutex"),
-      mRenderRoot(wr::RenderRoot::Default),
       mPaused(false),
       mDestroyed(true),
       mReceivedDisplayList(false),
       mIsFirstPaint(false),
       mSkippedComposite(false) {}
 
+WebRenderBridgeParent::~WebRenderBridgeParent() {
+  if (RefPtr<WebRenderBridgeParent> root = GetRootWebRenderBridgeParent()) {
+    root->RemoveDeferredPipeline(mPipelineId);
+  }
+}
+
+bool WebRenderBridgeParent::RenderRootIsValid(wr::RenderRoot aRenderRoot) {
+  if (StaticPrefs::gfx_webrender_split_render_roots_AtStartup() &&
+      IsRootWebRenderBridgeParent()) {
+    return aRenderRoot <= wr::kHighestRenderRoot;
+  } else {
+    return aRenderRoot == wr::RenderRoot::Default;
+  }
+}
+
+void WebRenderBridgeParent::RemoveDeferredPipeline(wr::PipelineId aPipelineId) {
+  MOZ_ASSERT(IsRootWebRenderBridgeParent());
+  mPipelineRenderRoots.Remove(wr::AsUint64(aPipelineId));
+  if (auto entry = mPipelineDeferredUpdates.Lookup(wr::AsUint64(aPipelineId))) {
+    RefPtr<WebRenderBridgeParent> self = this;
+    for (auto& variant : entry.Data()) {
+      variant.match(
+          [=](RenderRootDisplayListData& x) {
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mSmallShmems);
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mLargeShmems);
+          },
+          [=](RenderRootUpdates& x) {
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mSmallShmems);
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mLargeShmems);
+          },
+          [=](ResourceUpdates& x) {
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mSmallShmems);
+            wr::IpcResourceUpdateQueue::ReleaseShmems(self, x.mLargeShmems);
+          },
+          [=](FocusTarget& x) {});
+    }
+    entry.Remove();
+  }
+}
+
+
 /* static */
 WebRenderBridgeParent* WebRenderBridgeParent::CreateDestroyed(
     const wr::PipelineId& aPipelineId) {
   return new WebRenderBridgeParent(aPipelineId);
 }
 
+void WebRenderBridgeParent::PushDeferredPipelineData(
+    RenderRootDeferredData&& aDeferredData) {
+  MOZ_ASSERT(!IsRootWebRenderBridgeParent());
+  if (RefPtr<WebRenderBridgeParent> root = GetRootWebRenderBridgeParent()) {
+    uint64_t key = wr::AsUint64(mPipelineId);
+    root->mPipelineDeferredUpdates.LookupForAdd(key)
+        .OrInsert([]() { return nsTArray<RenderRootDeferredData>(); })
+        .AppendElement(std::move(aDeferredData));
+  }
+}
+
+bool WebRenderBridgeParent::HandleDeferredPipelineData(
+    nsTArray<RenderRootDeferredData>& aDeferredData,
+    const TimeStamp& aTxnStartTime) {
+  MOZ_ASSERT(!IsRootWebRenderBridgeParent());
+  for (auto& entry : aDeferredData) {
+    bool success = entry.match(
+        [&](RenderRootDisplayListData& data) {
+          // We ensure this with RenderRootIsValid before calling
+          // PushDeferredPipelineData:
+          MOZ_ASSERT(data.mRenderRoot == wr::RenderRoot::Default);
+          wr::Epoch wrEpoch = GetNextWrEpoch();
+          bool validTransaction = data.mIdNamespace == mIdNamespace;
+
+          if (!ProcessRenderRootDisplayListData(data,
+                                                wrEpoch,
+                                                aTxnStartTime,
+                                                validTransaction,
+                                                false)){
+            return false;
+          }
+
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mSmallShmems);
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mLargeShmems);
+          return true;
+        },
+        [&](RenderRootUpdates& data) {
+          // We ensure this with RenderRootIsValid before calling
+          // PushDeferredPipelineData:
+          MOZ_ASSERT(data.mRenderRoot == wr::RenderRoot::Default);
+          bool scheduleComposite;
+          if (!ProcessEmptyTransactionUpdates(data, &scheduleComposite)) {
+            return false;
+          }
+          if (scheduleComposite) {
+            ScheduleGenerateFrame(Nothing());
+          }
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mSmallShmems);
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mLargeShmems);
+          return true;
+        },
+        [&](ResourceUpdates& data) {
+          wr::TransactionBuilder txn;
+          txn.SetLowPriority(!IsRootWebRenderBridgeParent());
+
+          if (!UpdateResources(data.mResourceUpdates, data.mSmallShmems,
+                               data.mLargeShmems, txn)) {
+            return false;
+          }
+
+          Api(wr::RenderRoot::Default)->SendTransaction(txn);
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mSmallShmems);
+          wr::IpcResourceUpdateQueue::ReleaseShmems(this, data.mLargeShmems);
+          return true;
+        },
+        [&](FocusTarget& data) {
+          UpdateAPZFocusState(data);
+          return true;
+        });
+
+    if (!success) {
+      return false;
+    }
+  }
+  aDeferredData.Clear();
+  return true;
+}
+
+bool WebRenderBridgeParent::MaybeHandleDeferredPipelineDataForPipeline(
+    wr::RenderRoot aRenderRoot, wr::PipelineId aPipelineId,
+    const TimeStamp& aTxnStartTime) {
+  MOZ_ASSERT(IsRootWebRenderBridgeParent());
+
+  uint64_t key = wr::AsUint64(aPipelineId);
+  auto entry = mPipelineRenderRoots.LookupForAdd(key);
+  if (!entry) {
+    entry.OrInsert([=]() { return aRenderRoot; });
+
+    CompositorBridgeParent::LayerTreeState* lts =
+        CompositorBridgeParent::GetIndirectShadowTree(
+            wr::AsLayersId(aPipelineId));
+    if (!lts) {
+      return true;
+    }
+    RefPtr<WebRenderBridgeParent> wrbp = lts->mWrBridge;
+    if (!wrbp) {
+      return true;
+    }
+    MOZ_ASSERT(wrbp->mRenderRoot.refOr(aRenderRoot) == aRenderRoot);
+    wrbp->mRenderRoot = Some(aRenderRoot);
+
+    if (auto entry = mPipelineDeferredUpdates.Lookup(key)) {
+      wrbp->HandleDeferredPipelineData(entry.Data(), aTxnStartTime);
+      entry.Remove();
+
+      for (auto it = wrbp->mChildPipelines.Iter(); !it.Done(); it.Next()) {
+        if (!MaybeHandleDeferredPipelineDataForPipeline(
+                aRenderRoot, wr::AsPipelineId(it.Get()->GetKey()),
+                aTxnStartTime)) {
+          return false;
+        }
+      }
+    }
+  }
+
+  return true;
+}
+
+bool WebRenderBridgeParent::MaybeHandleDeferredPipelineData(
+    wr::RenderRoot aRenderRoot, const nsTArray<wr::PipelineId>& aPipelineIds,
+    const TimeStamp& aTxnStartTime) {
+  MOZ_ASSERT(IsRootWebRenderBridgeParent());
+  if (!StaticPrefs::gfx_webrender_split_render_roots_AtStartup()) {
+    return true;
+  }
+  for (wr::PipelineId pipelineId : aPipelineIds) {
+    if (!MaybeHandleDeferredPipelineDataForPipeline(aRenderRoot, pipelineId,
+                                                    aTxnStartTime)) {
+      return false;
+    }
+
+  }
+
+  return true;
+}
+
+
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvEnsureConnected(
     TextureFactoryIdentifier* aTextureFactoryIdentifier,
     MaybeIdNamespace* aMaybeIdNamespace) {
@@ -366,6 +542,16 @@
   *aTextureFactoryIdentifier = GetTextureFactoryIdentifier();
   *aMaybeIdNamespace = Some(mIdNamespace);
 
+  if (!mRenderRoot) {
+    RefPtr<WebRenderBridgeParent> root = GetRootWebRenderBridgeParent();
+    if (!root) {
+      return IPC_FAIL(this, "Root WRBP is missing (shutting down?)");
+    }
+    if (auto p = root->mPipelineRenderRoots.Lookup(wr::AsUint64(mPipelineId))) {
+      mRenderRoot.emplace(p.Data());
+    }
+  }
+
   return IPC_OK();
 }
 
@@ -736,7 +922,18 @@
     return IPC_OK();
   }
 
-  MOZ_RELEASE_ASSERT(aRenderRoot <= wr::kHighestRenderRoot);
+  if (!RenderRootIsValid(aRenderRoot)) {
+    return IPC_FAIL(this, "Received an invalid renderRoot");
+  }
+
+  if (!mRenderRoot) {
+    PushDeferredPipelineData(AsVariant(ResourceUpdates{
+        std::move(aResourceUpdates),
+        std::move(aSmallShmems),
+        std::move(aLargeShmems),
+    }));
+    return IPC_OK();
+  }
 
   wr::TransactionBuilder txn;
   txn.SetLowPriority(!IsRootWebRenderBridgeParent());
@@ -832,13 +1029,18 @@
 }
 
 void WebRenderBridgeParent::UpdateAPZFocusState(const FocusTarget& aFocus) {
+  if (!mRenderRoot) {
+    PushDeferredPipelineData(AsVariant(aFocus));
+    return;
+  }
+
   CompositorBridgeParent* cbp = GetRootCompositorBridgeParent();
   if (!cbp) {
     return;
   }
   LayersId rootLayersId = cbp->RootLayerTreeId();
   if (RefPtr<APZUpdater> apz = cbp->GetAPZUpdater()) {
-    apz->UpdateFocusState(rootLayersId, WRRootId(GetLayersId(), mRenderRoot),
+    apz->UpdateFocusState(rootLayersId, WRRootId(GetLayersId(), *mRenderRoot),
                           aFocus);
   }
 }
@@ -962,14 +1164,57 @@
   return true;
 }
 
+bool WebRenderBridgeParent::ProcessRenderRootDisplayListData(
+    RenderRootDisplayListData& aDisplayList,
+    wr::Epoch aWrEpoch,
+    const TimeStamp& aTxnStartTime,
+    bool aValidTransaction,
+    bool aObserveLayersUpdate) {
+  wr::TransactionBuilder txn;
+  Maybe<wr::AutoTransactionSender> sender;
+
+  // Note that this needs to happen before the display list transaction is
+  // sent to WebRender, so that the UpdateHitTestingTree call is guaranteed to
+  // be in the updater queue at the time that the scene swap completes.
+  if (aDisplayList.mScrollData) {
+    UpdateAPZScrollData(aWrEpoch, std::move(aDisplayList.mScrollData.ref()),
+                        aDisplayList.mRenderRoot);
+  }
+
+  MOZ_ASSERT(aDisplayList.mRenderRoot == wr::RenderRoot::Default ||
+             IsRootWebRenderBridgeParent());
+  auto renderRoot = aDisplayList.mRenderRoot;
+
+  txn.SetLowPriority(!IsRootWebRenderBridgeParent());
+  if (aValidTransaction) {
+    MOZ_ASSERT(aDisplayList.mIdNamespace == mIdNamespace);
+    sender.emplace(Api(renderRoot), &txn);
+  }
+
+  if (NS_WARN_IF(!ProcessWebRenderParentCommands(aDisplayList.mCommands, txn,
+                                                 renderRoot))) {
+    return false;
+  }
+
+  if (aDisplayList.mDL &&
+      !SetDisplayList(renderRoot, aDisplayList.mRect, aDisplayList.mContentSize,
+                      std::move(aDisplayList.mDL.ref()), aDisplayList.mDLDesc,
+                      aDisplayList.mResourceUpdates, aDisplayList.mSmallShmems,
+                      aDisplayList.mLargeShmems, aTxnStartTime, txn, aWrEpoch,
+                      aValidTransaction, aObserveLayersUpdate)) {
+    return false;
+  }
+  return true;
+}
+
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvSetDisplayList(
     nsTArray<RenderRootDisplayListData>&& aDisplayLists,
     nsTArray<OpDestroy>&& aToDestroy, const uint64_t& aFwdTransactionId,
-    const TransactionId& aTransactionId, const wr::IdNamespace& aIdNamespace,
-    const bool& aContainsSVGGroup, const VsyncId& aVsyncId,
-    const TimeStamp& aVsyncStartTime, const TimeStamp& aRefreshStartTime,
-    const TimeStamp& aTxnStartTime, const nsCString& aTxnURL,
-    const TimeStamp& aFwdTime, nsTArray<CompositionPayload>&& aPayloads) {
+    const TransactionId& aTransactionId, const bool& aContainsSVGGroup,
+    const VsyncId& aVsyncId, const TimeStamp& aVsyncStartTime,
+    const TimeStamp& aRefreshStartTime, const TimeStamp& aTxnStartTime,
+    const nsCString& aTxnURL, const TimeStamp& aFwdTime,
+    nsTArray<CompositionPayload>&& aPayloads) {
   if (mDestroyed) {
     for (const auto& op : aToDestroy) {
       DestroyActor(op);
@@ -978,9 +1223,13 @@
   }
 
   // Guard against malicious content processes
-  MOZ_RELEASE_ASSERT(aDisplayLists.Length() > 0);
+  if (aDisplayLists.Length() == 0) {
+    return IPC_FAIL(this, "Must send at least one RenderRootDisplayListData.");
+  }
   for (auto& displayList : aDisplayLists) {
-    MOZ_RELEASE_ASSERT(displayList.mRenderRoot <= wr::kHighestRenderRoot);
+    if (!RenderRootIsValid(displayList.mRenderRoot)) {
+      return IPC_FAIL(this, "Received an invalid renderRoot");
+    }
   }
 
   if (!IsRootWebRenderBridgeParent()) {
@@ -1000,7 +1249,6 @@
   mAsyncImageManager->SetCompositionTime(TimeStamp::Now());
 
   mReceivedDisplayList = true;
-  bool observeLayersUpdate = ShouldParentObserveEpoch();
 
   // The IsFirstPaint() flag should be the same for all the non-empty
   // scrolldata across all the renderroot display lists in a given
@@ -1016,7 +1264,7 @@
           mIsFirstPaint = true;
         }
       } else {
-        auto firstNonEmpty = aDisplayLists[*firstScrollDataIndex].mScrollData;
+        auto& firstNonEmpty = aDisplayLists[*firstScrollDataIndex].mScrollData;
         // Ensure the flag is the same on all of them.
         MOZ_RELEASE_ASSERT(scrollData->IsFirstPaint() ==
                            firstNonEmpty->IsFirstPaint());
@@ -1024,47 +1272,50 @@
     }
   }
 
-  // aScrollData is moved into this function but that is not reflected by the
-  // function signature due to the way the IPDL generator works. We remove the
-  // const so that we can move this structure all the way to the desired
-  // destination.
-  // Also note that this needs to happen before the display list transaction is
-  // sent to WebRender, so that the UpdateHitTestingTree call is guaranteed to
-  // be in the updater queue at the time that the scene swap completes.
+  if (!mRenderRoot) {
+    // Only non-root WRBPs will ever have an unresolved mRenderRoot
+    MOZ_ASSERT(!IsRootWebRenderBridgeParent());
+    if (aDisplayLists.Length() != 1) {
+      return IPC_FAIL(this, "Well-behaved content processes must only send a DL for a single renderRoot");
+    }
+    PushDeferredPipelineData(AsVariant(std::move(aDisplayLists[0])));
+    aDisplayLists.Clear();
+  }
+
   for (auto& displayList : aDisplayLists) {
-    if (displayList.mScrollData) {
-      UpdateAPZScrollData(wrEpoch, std::move(displayList.mScrollData.ref()),
-                          displayList.mRenderRoot);
+    if (IsRootWebRenderBridgeParent()) {
+      if (!MaybeHandleDeferredPipelineData(
+              displayList.mRenderRoot,
+              displayList.mRemotePipelineIds,
+              aTxnStartTime)) {
+        return IPC_FAIL(this, "Failed processing deferred pipeline data");
+      }
+    } else {
+      RefPtr<WebRenderBridgeParent> root = GetRootWebRenderBridgeParent();
+      if (!root) {
+        return IPC_FAIL(this, "Root WRBP is missing (shutting down?)");
+      }
+
+      for (auto pipelineId : displayList.mRemotePipelineIds) {
+        auto id = wr::AsUint64(pipelineId);
+        root->mPipelineRenderRoots.Put(id, *mRenderRoot);
+        mChildPipelines.PutEntry(id);
+      }
     }
   }
 
-  bool validTransaction = aIdNamespace == mIdNamespace;
-
-  wr::RenderRootArray<wr::TransactionBuilder> txns;
-  wr::RenderRootArray<Maybe<wr::AutoTransactionSender>> senders;
-  for (auto& displayList : aDisplayLists) {
-    MOZ_ASSERT(displayList.mRenderRoot == wr::RenderRoot::Default ||
-               IsRootWebRenderBridgeParent());
-    auto renderRoot = displayList.mRenderRoot;
-    auto& txn = txns[renderRoot];
+  bool validTransaction = aDisplayLists.Length() > 0 &&
+                          aDisplayLists[0].mIdNamespace == mIdNamespace;
+  bool observeLayersUpdate = ShouldParentObserveEpoch();
 
-    txn.SetLowPriority(!IsRootWebRenderBridgeParent());
-    if (validTransaction) {
-      senders[renderRoot].emplace(Api(renderRoot), &txn);
-    }
-
-    if (NS_WARN_IF(!ProcessWebRenderParentCommands(displayList.mCommands, txn,
-                                                   renderRoot))) {
-      return IPC_FAIL(this, "Invalid parent command found");
-    }
-
-    if (displayList.mDL &&
-        !SetDisplayList(renderRoot, displayList.mRect, displayList.mContentSize,
-                        std::move(displayList.mDL.ref()), displayList.mDLDesc,
-                        displayList.mResourceUpdates, displayList.mSmallShmems,
-                        displayList.mLargeShmems, aTxnStartTime, txn, wrEpoch,
-                        validTransaction, observeLayersUpdate)) {
-      return IPC_FAIL(this, "Failed call to SetDisplayList");
+  for (auto& displayList : aDisplayLists) {
+    if (!ProcessRenderRootDisplayListData(
+            displayList,
+            wrEpoch,
+            aTxnStartTime,
+            validTransaction,
+            observeLayersUpdate)) {
+      return IPC_FAIL(this, "Failed to process RenderRootDisplayListData.");
     }
   }
 
@@ -1103,8 +1354,7 @@
 }
 
 bool WebRenderBridgeParent::ProcessEmptyTransactionUpdates(
-    RenderRootUpdates& aUpdates, uint32_t aPaintSequenceNumber,
-    bool* aScheduleComposite) {
+    RenderRootUpdates& aUpdates, bool* aScheduleComposite) {
   *aScheduleComposite = false;
   wr::TransactionBuilder txn;
   txn.SetLowPriority(!IsRootWebRenderBridgeParent());
@@ -1112,9 +1362,9 @@
   MOZ_ASSERT(aUpdates.mRenderRoot == wr::RenderRoot::Default ||
              IsRootWebRenderBridgeParent());
 
-  if (!aUpdates.mScrollUpdates.empty()) {
+  if (!aUpdates.mScrollUpdates.IsEmpty()) {
     UpdateAPZScrollOffsets(std::move(aUpdates.mScrollUpdates),
-                           aPaintSequenceNumber, aUpdates.mRenderRoot);
+                           aUpdates.mPaintSequenceNumber, aUpdates.mRenderRoot);
   }
 
   // Update WrEpoch for UpdateResources() and ProcessWebRenderParentCommands().
@@ -1169,14 +1419,13 @@
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvEmptyTransaction(
-    const FocusTarget& aFocusTarget, const uint32_t& aPaintSequenceNumber,
+    const FocusTarget& aFocusTarget,
     nsTArray<RenderRootUpdates>&& aRenderRootUpdates,
     nsTArray<OpDestroy>&& aToDestroy, const uint64_t& aFwdTransactionId,
-    const TransactionId& aTransactionId, const wr::IdNamespace& aIdNamespace,
-    const VsyncId& aVsyncId, const TimeStamp& aVsyncStartTime,
-    const TimeStamp& aRefreshStartTime, const TimeStamp& aTxnStartTime,
-    const nsCString& aTxnURL, const TimeStamp& aFwdTime,
-    nsTArray<CompositionPayload>&& aPayloads) {
+    const TransactionId& aTransactionId, const VsyncId& aVsyncId,
+    const TimeStamp& aVsyncStartTime, const TimeStamp& aRefreshStartTime,
+    const TimeStamp& aTxnStartTime, const nsCString& aTxnURL,
+    const TimeStamp& aFwdTime, nsTArray<CompositionPayload>&& aPayloads) {
   if (mDestroyed) {
     for (const auto& op : aToDestroy) {
       DestroyActor(op);
@@ -1186,7 +1435,9 @@
 
   // Guard against malicious content processes
   for (auto& update : aRenderRootUpdates) {
-    MOZ_RELEASE_ASSERT(update.mRenderRoot <= wr::kHighestRenderRoot);
+    if (!RenderRootIsValid(update.mRenderRoot)) {
+      return IPC_FAIL(this, "Received an invalid renderRoot");
+    }
   }
 
   if (!IsRootWebRenderBridgeParent()) {
@@ -1201,16 +1452,26 @@
   AutoWebRenderBridgeParentAsyncMessageSender autoAsyncMessageSender(
       this, &aToDestroy);
 
+  if (!mRenderRoot && aRenderRootUpdates.Length() > 0) {
+    // Only non-root WRBPs will ever have an unresolved mRenderRoot
+    MOZ_ASSERT(!IsRootWebRenderBridgeParent());
+    if (aRenderRootUpdates.Length() != 1) {
+      return IPC_FAIL(this, "Well-behaved content processes must only send a DL for a single renderRoot");
+    }
+    PushDeferredPipelineData(AsVariant(std::move(aRenderRootUpdates[0])));
+    aRenderRootUpdates.Clear();
+  }
+
   UpdateAPZFocusState(aFocusTarget);
 
   bool scheduleAnyComposite = false;
+
   for (auto& update : aRenderRootUpdates) {
     MOZ_ASSERT(update.mRenderRoot == wr::RenderRoot::Default ||
                IsRootWebRenderBridgeParent());
 
     bool scheduleComposite = false;
-    if (!ProcessEmptyTransactionUpdates(update, aPaintSequenceNumber,
-                                        &scheduleComposite)) {
+    if (!ProcessEmptyTransactionUpdates(update, &scheduleComposite)) {
       return IPC_FAIL(this, "Failed to process empty transaction update.");
     }
     scheduleAnyComposite = scheduleAnyComposite || scheduleComposite;
@@ -1370,7 +1631,7 @@
   // to block until all the inflight transactions have been processed. This
   // flush message blocks until all previously sent scenes have been built
   // and received by the render backend thread.
-  Api(wr::RenderRoot::Default)->FlushSceneBuilder();
+  mApis[wr::RenderRoot::Default]->FlushSceneBuilder();
   // The post-swap hook for async-scene-building calls the
   // ScheduleRenderOnCompositorThread function from the scene builder thread,
   // which then triggers a call to ScheduleGenerateFrame() on the compositor
@@ -1410,7 +1671,7 @@
   // this effectively blocks on the render backend and renderer threads,
   // following the same codepath that WebRender takes to render and composite
   // a frame.
-  Api(wr::RenderRoot::Default)->WaitFlushed();
+  mApis[wr::RenderRoot::Default]->WaitFlushed();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvGetSnapshot(
@@ -1465,9 +1726,9 @@
 
   FlushSceneBuilds();
   FlushFrameGeneration();
-  Api(wr::RenderRoot::Default)
-      ->Readback(start, size, bufferTexture->GetFormat(),
-                 Range<uint8_t>(buffer, buffer_size));
+  mApis[wr::RenderRoot::Default]->Readback(start, size,
+                                           bufferTexture->GetFormat(),
+                                           Range<uint8_t>(buffer, buffer_size));
 
   return IPC_OK();
 }
@@ -1603,16 +1864,22 @@
     if (renderRoot == wr::RenderRoot::Default ||
         (IsRootWebRenderBridgeParent() &&
          StaticPrefs::gfx_webrender_split_render_roots_AtStartup())) {
-      // Clear resources
-      wr::TransactionBuilder txn;
-      txn.SetLowPriority(true);
-      txn.ClearDisplayList(GetNextWrEpoch(), mPipelineId);
-      txn.Notify(wr::Checkpoint::SceneBuilt,
-                 MakeUnique<ScheduleObserveLayersUpdate>(
-                     mCompositorBridge, GetLayersId(),
-                     mChildLayersObserverEpoch, false));
-
-      Api(renderRoot)->SendTransaction(txn);
+      if (mRenderRoot) {
+        // Clear resources
+        wr::TransactionBuilder txn;
+        txn.SetLowPriority(true);
+        txn.ClearDisplayList(GetNextWrEpoch(), mPipelineId);
+        txn.Notify(wr::Checkpoint::SceneBuilt,
+                   MakeUnique<ScheduleObserveLayersUpdate>(
+                       mCompositorBridge, GetLayersId(),
+                       mChildLayersObserverEpoch, false));
+        Api(renderRoot)->SendTransaction(txn);
+      } else {
+        if (RefPtr<WebRenderBridgeParent> root =
+                GetRootWebRenderBridgeParent()) {
+          root->RemoveDeferredPipeline(mPipelineId);
+        }
+      }
     }
   }
   // Schedule generate frame to clean up Pipeline
@@ -1702,7 +1969,7 @@
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvCapture() {
   if (!mDestroyed) {
-    Api(wr::RenderRoot::Default)->Capture();
+    mApis[wr::RenderRoot::Default]->Capture();
   }
   return IPC_OK();
 }
@@ -1790,7 +2057,7 @@
     return IPC_OK();
   }
   mCompositorBridge->SetTestAsyncScrollOffset(
-      WRRootId(GetLayersId(), mRenderRoot), aScrollId, CSSPoint(aX, aY));
+      WRRootId(GetLayersId(), *mRenderRoot), aScrollId, CSSPoint(aX, aY));
   return IPC_OK();
 }
 
@@ -1799,7 +2066,7 @@
   if (mDestroyed) {
     return IPC_OK();
   }
-  mCompositorBridge->SetTestAsyncZoom(WRRootId(GetLayersId(), mRenderRoot),
+  mCompositorBridge->SetTestAsyncZoom(WRRootId(GetLayersId(), *mRenderRoot),
                                       aScrollId,
                                       LayerToParentLayerScale(aZoom));
   return IPC_OK();
@@ -1809,13 +2076,13 @@
   if (mDestroyed) {
     return IPC_OK();
   }
-  mCompositorBridge->FlushApzRepaints(WRRootId(GetLayersId(), mRenderRoot));
+  mCompositorBridge->FlushApzRepaints(WRRootId(GetLayersId(), *mRenderRoot));
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult WebRenderBridgeParent::RecvGetAPZTestData(
     APZTestData* aOutData) {
-  mCompositorBridge->GetAPZTestData(WRRootId(GetLayersId(), mRenderRoot),
+  mCompositorBridge->GetAPZTestData(WRRootId(GetLayersId(), *mRenderRoot),
                                     aOutData);
   return IPC_OK();
 }
@@ -1899,7 +2166,7 @@
   }
 
   if (mSkippedComposite || wr::RenderThread::Get()->TooManyPendingFrames(
-                               Api(wr::RenderRoot::Default)->GetId())) {
+                               mApis[wr::RenderRoot::Default]->GetId())) {
     // Render thread is busy, try next time.
     mSkippedComposite = true;
     mSkippedCompositeId = aId;
@@ -2015,11 +2282,11 @@
   SetAPZSampleTime();
 
   wr::RenderThread::Get()->IncPendingFrameCount(
-      Api(wr::RenderRoot::Default)->GetId(), aId, start, framesGenerated);
+      mApis[wr::RenderRoot::Default]->GetId(), aId, start, framesGenerated);
 
 #if defined(ENABLE_FRAME_LATENCY_LOG)
   auto startTime = TimeStamp::Now();
-  Api(wr::RenderRoot::Default)->SetFrameStartTime(startTime);
+  mApis[wr::RenderRoot::Default]->SetFrameStartTime(startTime);
 #endif
 
   MOZ_ASSERT(framesGenerated > 0);
@@ -2169,7 +2436,7 @@
             transactionId.mSkippedComposites, transactionId.mTxnURL));
 
         wr::RenderThread::Get()->NotifySlowFrame(
-            Api(wr::RenderRoot::Default)->GetId());
+            mApis[wr::RenderRoot::Default]->GetId());
       }
     }
 
@@ -2259,7 +2526,7 @@
     return;
   }
 
-  Api(wr::RenderRoot::Default)->Pause();
+  mApis[wr::RenderRoot::Default]->Pause();
 #endif
   mPaused = true;
 }
@@ -2271,7 +2538,7 @@
     return false;
   }
 
-  if (!Api(wr::RenderRoot::Default)->Resume()) {
+  if (!mApis[wr::RenderRoot::Default]->Resume()) {
     return false;
   }
 #endif
@@ -2409,10 +2676,10 @@
 
   return TextureFactoryIdentifier(
       LayersBackend::LAYERS_WR, XRE_GetProcessType(),
-      Api(wr::RenderRoot::Default)->GetMaxTextureSize(), false,
-      Api(wr::RenderRoot::Default)->GetUseANGLE(),
-      Api(wr::RenderRoot::Default)->GetUseDComp(), false, false, false,
-      Api(wr::RenderRoot::Default)->GetSyncHandle());
+      mApis[wr::RenderRoot::Default]->GetMaxTextureSize(), false,
+      mApis[wr::RenderRoot::Default]->GetUseANGLE(),
+      mApis[wr::RenderRoot::Default]->GetUseDComp(), false, false, false,
+      mApis[wr::RenderRoot::Default]->GetSyncHandle());
 }
 
 wr::Epoch WebRenderBridgeParent::GetNextWrEpoch() {