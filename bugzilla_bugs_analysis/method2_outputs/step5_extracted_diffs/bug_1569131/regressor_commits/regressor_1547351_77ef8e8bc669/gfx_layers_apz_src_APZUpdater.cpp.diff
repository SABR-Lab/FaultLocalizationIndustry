# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/apz/src/APZUpdater.cpp
# Commit: 77ef8e8bc669
# Full Hash: 77ef8e8bc669c9ecab4d94505b11b3cb732446c5
# Author: Alexis Beingessner <a.beingessner@gmail.com>
# Date: 2019-07-15 21:39:46
# Regressor Bug: 1547351
# File Overlap Count: 2
# Description:
#   Bug 1547351 - Automatically set content process render root r=kats
#   
#   This implements the idea of automatically setting a content proc's
#   render root based on the render root enclosing the iframe that
#   points to it. There was a bit of cleanup in here that was a bit
# ==============================================================================

diff -r b594f8e47025 -r 77ef8e8bc669 gfx/layers/apz/src/APZUpdater.cpp
--- a/gfx/layers/apz/src/APZUpdater.cpp	Mon Jul 15 13:20:31 2019 +0000
+++ b/gfx/layers/apz/src/APZUpdater.cpp	Mon Jul 15 13:18:44 2019 +0000
@@ -204,22 +204,24 @@
         }
         self->mEpochData[aOriginatingWrRootId].mRequired = aEpoch;
       }));
-  RunOnUpdaterThread(UpdaterQueueSelector(aOriginatingWrRootId),
-                     NS_NewRunnableFunction(
-                         "APZUpdater::UpdateHitTestingTree",
-                         [=, aScrollData = std::move(aScrollData)]() {
-                           self->mScrollData[aOriginatingWrRootId] =
-                               aScrollData;
-                           auto root = self->mScrollData.find(aRootLayerTreeId);
-                           if (root == self->mScrollData.end()) {
-                             return;
-                           }
-                           self->mApz->UpdateHitTestingTree(
-                               WebRenderScrollDataWrapper(
-                                   *self, aRootLayerTreeId, &(root->second)),
-                               aScrollData.IsFirstPaint(), aOriginatingWrRootId,
-                               aScrollData.GetPaintSequenceNumber());
-                         }));
+  RunOnUpdaterThread(
+      UpdaterQueueSelector(aOriginatingWrRootId),
+      NS_NewRunnableFunction(
+          "APZUpdater::UpdateHitTestingTree",
+          [=, aScrollData = std::move(aScrollData)]() mutable {
+            auto isFirstPaint = aScrollData.IsFirstPaint();
+            auto paintSequenceNumber = aScrollData.GetPaintSequenceNumber();
+
+            self->mScrollData[aOriginatingWrRootId] = std::move(aScrollData);
+            auto root = self->mScrollData.find(aRootLayerTreeId);
+            if (root == self->mScrollData.end()) {
+              return;
+            }
+            self->mApz->UpdateHitTestingTree(
+                WebRenderScrollDataWrapper(*self, aRootLayerTreeId,
+                                           &(root->second)),
+                isFirstPaint, aOriginatingWrRootId, paintSequenceNumber);
+          }));
 }
 
 void APZUpdater::UpdateScrollOffsets(WRRootId aRootLayerTreeId,