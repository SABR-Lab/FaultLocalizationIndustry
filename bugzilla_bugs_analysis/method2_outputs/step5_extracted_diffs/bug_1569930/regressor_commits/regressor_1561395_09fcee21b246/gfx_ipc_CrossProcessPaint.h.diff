# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/ipc/CrossProcessPaint.h
# Commit: 09fcee21b246
# Full Hash: 09fcee21b246dbd3622203d214234ee5116805f4
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2019-07-10 21:50:49
# Regressor Bug: 1561395
# File Overlap Count: 2
# Description:
#   Bug 1561395 - Move drawSnapshot API to WindowGlobalParent and allow specifying the whole viewport as a rect. r=mattwoodrow,nika
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D35842
# ==============================================================================

diff -r 0873b1c9bca7 -r 09fcee21b246 gfx/ipc/CrossProcessPaint.h
--- a/gfx/ipc/CrossProcessPaint.h	Thu Jul 04 00:40:02 2019 +0000
+++ b/gfx/ipc/CrossProcessPaint.h	Wed Jul 10 16:45:46 2019 +0000
@@ -10,7 +10,9 @@
 
 #include "mozilla/dom/ipc/IdType.h"
 #include "mozilla/dom/Promise.h"
+#include "mozilla/dom/DOMRect.h"
 #include "mozilla/gfx/2D.h"
+#include "mozilla/Maybe.h"
 #include "mozilla/ipc/ByteBuf.h"
 #include "nsDataHashtable.h"
 #include "nsHashKeys.h"
@@ -23,6 +25,11 @@
 }  // namespace IPC
 
 namespace mozilla {
+
+namespace dom {
+class WindowGlobalParent;
+}  // namespace dom
+
 namespace gfx {
 
 class CrossProcessPaint;
@@ -40,7 +47,8 @@
    * for an nsIDocShell.
    *
    * @param aDocShell The document shell to record.
-   * @param aRect The rectangle relative to the viewport to use.
+   * @param aRect The rectangle relative to the viewport to use. If no
+   *   rectangle is specified, then the whole viewport will be used.
    * @param aScale The coordinate scale to use. The size of the resolved
    *   surface will be `aRect.Size() * aScale`, with aScale clamped to
    *   at least kMinPaintScale.
@@ -49,8 +57,9 @@
    * @return A paint fragment. The paint fragment may be `empty` if rendering
    *         was unable to be accomplished for some reason.
    */
-  static PaintFragment Record(nsIDocShell* aDocShell, const IntRect& aRect,
-                              float aScale, nscolor aBackgroundColor);
+  static PaintFragment Record(nsIDocShell* aDocShell,
+                              const Maybe<IntRect>& aRect, float aScale,
+                              nscolor aBackgroundColor);
 
   /// Returns whether this paint fragment contains a valid recording.
   bool IsEmpty() const;
@@ -80,56 +89,42 @@
  public:
   /**
    * Begin an asynchronous paint of a cross process document tree starting at
-   * a local document shell. The local document will be painted, then async
-   * paints will be queued for remote subframes. Once all subframes have been
-   * recorded, the final image will be resolved, and the promise will be
-   * resolved with a dom::ImageBitmap.
+   * a WindowGlobalParent. A maybe-async paint for the root WGP will be done,
+   * then async paints will be recursively queued for remote subframes. Once
+   * all subframes have been recorded, the final image will be resolved, and
+   * the promise will be resolved with a dom::ImageBitmap.
    *
-   * @param aDocShell The document shell to paint.
-   * @param aRect The rectangle relative to the viewport to use.
+   * @param aRoot The WindowGlobalParent to paint.
+   * @param aRect The rectangle relative to the viewport to use, or null to
+   *   render the whole viewport.
    * @param aScale The coordinate scale to use. The size of the resolved
    *   surface will be `aRect.Size() * aScale`, with aScale clamped to
    *   at least kMinPaintScale. See the implementation for the current
    *   minimum value.
    * @param aBackgroundColor The background color to use.
    * @param aPromise The promise to resolve with a dom::ImageBitmap.
+   *
+   * @returns Whether the paint was able to be initiated or not.
    */
-  static void StartLocal(nsIDocShell* aRoot, const IntRect& aRect, float aScale,
-                         nscolor aBackgroundColor, dom::Promise* aPromise);
+  static bool Start(dom::WindowGlobalParent* aRoot, const dom::DOMRect* aRect,
+                    float aScale, nscolor aBackgroundColor,
+                    dom::Promise* aPromise);
 
-  /**
-   * Begin an asynchronous paint of a cross process document tree starting at
-   * a remote tab. An async paint for the remote tab will be queued, then async
-   * paints will be recursively queued for remote subframes. Once all subframes
-   * have been recorded, the final image will be resolved, and the promise will
-   * be resolved with a dom::ImageBitmap.
-   *
-   * @param aDocShell The document shell to paint.
-   * @param aRect The rectangle relative to the viewport to use.
-   * @param aScale The coordinate scale to use. The size of the resolved
-   *   surface will be `aRect.Size() * aScale`, with aScale clamped to
-   *   at least kMinPaintScale. See the implementation for the current
-   *   minimum value.
-   * @param aBackgroundColor The background color to use.
-   * @param aPromise The promise to resolve with a dom::ImageBitmap.
-   */
-  static void StartRemote(dom::TabId aRoot, const IntRect& aRect, float aScale,
-                          nscolor aBackgroundColor, dom::Promise* aPromise);
-
-  void ReceiveFragment(dom::TabId aId, PaintFragment&& aFragment);
-  void LostFragment(dom::TabId aId);
+  void ReceiveFragment(dom::WindowGlobalParent* aWGP,
+                       PaintFragment&& aFragment);
+  void LostFragment(dom::WindowGlobalParent* aWGP);
 
  private:
   typedef nsRefPtrHashtable<nsUint64HashKey, SourceSurface> ResolvedSurfaceMap;
-  typedef nsDataHashtable<nsUint64HashKey, PaintFragment> ReceivedFragmentMap;
+  typedef nsDataHashtable<nsRefPtrHashKey<dom::WindowGlobalParent>,
+                          PaintFragment>
+      ReceivedFragmentMap;
 
   CrossProcessPaint(dom::Promise* aPromise, float aScale,
-                    nscolor aBackgroundColor, dom::TabId aRootId);
+                    nscolor aBackgroundColor, dom::WindowGlobalParent* aRoot);
   ~CrossProcessPaint();
 
-  void QueueRootPaint(dom::TabId aId, const IntRect& aRect, float aScale,
-                      nscolor aBackgroundColor);
-  void QueueSubPaint(dom::TabId aId);
+  void QueuePaint(dom::WindowGlobalParent* aWGP, const Maybe<IntRect>& aRect);
 
   /// Clear the state of this paint so that it cannot be resolved or receive
   /// any paint fragments.
@@ -141,10 +136,11 @@
   /// Resolves the paint fragments if we have none pending and resolves the
   /// promise.
   void MaybeResolve();
-  bool ResolveInternal(dom::TabId aId, ResolvedSurfaceMap* aResolved);
+  bool ResolveInternal(dom::WindowGlobalParent* aWGP,
+                       ResolvedSurfaceMap* aResolved);
 
   RefPtr<dom::Promise> mPromise;
-  dom::TabId mRootId;
+  RefPtr<dom::WindowGlobalParent> mRoot;
   float mScale;
   nscolor mBackgroundColor;
   uint32_t mPendingFragments;
