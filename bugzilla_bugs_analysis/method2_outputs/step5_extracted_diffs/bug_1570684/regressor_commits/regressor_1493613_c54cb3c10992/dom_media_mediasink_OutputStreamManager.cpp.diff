# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/OutputStreamManager.cpp
# Commit: c54cb3c10992
# Full Hash: c54cb3c109922bc15fb6d0ca67e5f2a05980c1a5
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2019-07-31 15:46:43
# Regressor Bug: 1493613
# File Overlap Count: 2
# Description:
#   Bug 1493613 - Move MediaStream control from DOMMediaStream to MediaStreamTrack. r=padenot
#   
#   This is inherently large, because modifying these bits of DOMMediaStream and
#   MediaStreamTrack affects all consumers and producers of all DOMMediaStreams and
#   MediaStreamTracks.
# ==============================================================================

diff -r 0b03dd9d20ac -r c54cb3c10992 dom/media/mediasink/OutputStreamManager.cpp
--- a/dom/media/mediasink/OutputStreamManager.cpp	Wed Jul 31 09:35:06 2019 +0000
+++ b/dom/media/mediasink/OutputStreamManager.cpp	Wed Jul 31 07:58:17 2019 +0000
@@ -7,8 +7,10 @@
 #include "OutputStreamManager.h"
 
 #include "DOMMediaStream.h"
-#include "MediaStreamGraph.h"
+#include "../MediaStreamGraphImpl.h"
 #include "mozilla/dom/MediaStreamTrack.h"
+#include "mozilla/dom/AudioStreamTrack.h"
+#include "mozilla/dom/VideoStreamTrack.h"
 #include "nsContentUtils.h"
 
 namespace mozilla {
@@ -22,11 +24,11 @@
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(DecodedStreamTrackSource,
                                            dom::MediaStreamTrackSource)
 
-  explicit DecodedStreamTrackSource(OutputStreamManager* aManager,
-                                    OutputStreamData* aData, TrackID aTrackID,
-                                    nsIPrincipal* aPrincipal,
-                                    AbstractThread* aAbstractMainThread)
-      : dom::MediaStreamTrackSource(aPrincipal, nsString()) {
+  explicit DecodedStreamTrackSource(SourceMediaStream* aSourceStream,
+                                    nsIPrincipal* aPrincipal)
+      : dom::MediaStreamTrackSource(aPrincipal, nsString()),
+        mStream(aSourceStream->Graph()->CreateTrackUnionStream()),
+        mPort(mStream->AllocateInputPort(aSourceStream)) {
     MOZ_ASSERT(NS_IsMainThread());
   }
 
@@ -40,7 +42,12 @@
     // We don't notify the source that a track was stopped since it will keep
     // producing tracks until the element ends. The decoder also needs the
     // tracks it created to be live at the source since the decoder's clock is
-    // based on MediaStreams during capture.
+    // based on MediaStreams during capture. We do however, disconnect this
+    // track's underlying stream.
+    if (!mStream->IsDestroyed()) {
+      mStream->Destroy();
+      mPort->Destroy();
+    }
   }
 
   void Disable() override {}
@@ -53,8 +60,16 @@
     PrincipalChanged();
   }
 
+  void ForceEnded() { OverrideEnded(); }
+
+  const RefPtr<ProcessedMediaStream> mStream;
+  const RefPtr<MediaInputPort> mPort;
+
  protected:
-  virtual ~DecodedStreamTrackSource() { MOZ_ASSERT(NS_IsMainThread()); }
+  virtual ~DecodedStreamTrackSource() {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(mStream->IsDestroyed());
+  }
 };
 
 NS_IMPL_ADDREF_INHERITED(DecodedStreamTrackSource, dom::MediaStreamTrackSource)
@@ -69,34 +84,35 @@
                                    DOMMediaStream* aDOMStream)
     : mManager(aManager),
       mAbstractMainThread(aAbstractMainThread),
-      mDOMStream(aDOMStream),
-      mInputStream(mDOMStream->GetInputStream()->AsProcessedStream()),
-      mPort(mInputStream->AllocateInputPort(mManager->mSourceStream)) {
+      mDOMStream(aDOMStream) {
   MOZ_ASSERT(NS_IsMainThread());
 }
 
-OutputStreamData::~OutputStreamData() {
-  MOZ_ASSERT(NS_IsMainThread());
+OutputStreamData::~OutputStreamData() = default;
 
-  // Disconnect any existing port.
-  if (mPort) {
-    mPort->Destroy();
-  }
-}
-
-void OutputStreamData::AddTrack(TrackID aTrackID, MediaSegment::Type aType,
+void OutputStreamData::AddTrack(SourceMediaStream* aStream,
+                                MediaSegment::Type aType,
                                 nsIPrincipal* aPrincipal, bool aAsyncAddTrack) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mDOMStream);
 
-  LOG(LogLevel::Debug, "Adding output %s track with id %d to MediaStream %p%s",
-      aType == MediaSegment::AUDIO ? "audio" : "video", aTrackID,
+  LOG(LogLevel::Debug,
+      "Adding output %s track sourced from stream %p to MediaStream %p%s",
+      aType == MediaSegment::AUDIO ? "audio" : "video", aStream,
       mDOMStream.get(), aAsyncAddTrack ? " (async)" : "");
 
-  RefPtr<dom::MediaStreamTrackSource> source = new DecodedStreamTrackSource(
-      mManager, this, aTrackID, aPrincipal, mAbstractMainThread);
-  RefPtr<dom::MediaStreamTrack> track =
-      mDOMStream->CreateDOMTrack(aTrackID, aType, source);
+  auto source = MakeRefPtr<DecodedStreamTrackSource>(aStream, aPrincipal);
+  RefPtr<dom::MediaStreamTrack> track;
+  if (aType == MediaSegment::AUDIO) {
+    track = new dom::AudioStreamTrack(mDOMStream->GetParentObject(),
+                                      source->mStream,
+                                      OutputStreamManager::sTrackID, source);
+  } else {
+    MOZ_ASSERT(aType == MediaSegment::VIDEO);
+    track = new dom::VideoStreamTrack(mDOMStream->GetParentObject(),
+                                      source->mStream,
+                                      OutputStreamManager::sTrackID, source);
+  }
   mTracks.AppendElement(track.get());
   if (aAsyncAddTrack) {
     GetMainThreadEventTarget()->Dispatch(
@@ -108,54 +124,54 @@
   }
 }
 
-void OutputStreamData::RemoveTrack(TrackID aTrackID) {
+void OutputStreamData::RemoveTrack(SourceMediaStream* aStream) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mDOMStream);
 
-  LOG(LogLevel::Debug, "Removing output track with id %d from MediaStream %p",
-      aTrackID, mDOMStream.get());
+  LOG(LogLevel::Debug,
+      "Removing output track sourced by stream %p from MediaStream %p", aStream,
+      mDOMStream.get());
 
-  RefPtr<dom::MediaStreamTrack> track =
-      mDOMStream->FindOwnedDOMTrack(mInputStream, aTrackID);
-  MOZ_DIAGNOSTIC_ASSERT(track);
-  mTracks.RemoveElement(track);
-  GetMainThreadEventTarget()->Dispatch(
-      NewRunnableMethod("MediaStreamTrack::OverrideEnded", track,
-                        &dom::MediaStreamTrack::OverrideEnded));
+  for (const auto& t : nsTArray<WeakPtr<dom::MediaStreamTrack>>(mTracks)) {
+    mTracks.RemoveElement(t);
+    if (!t || t->Ended()) {
+      continue;
+    }
+    DecodedStreamTrackSource& source =
+        static_cast<DecodedStreamTrackSource&>(t->GetSource());
+    GetMainThreadEventTarget()->Dispatch(
+        NewRunnableMethod("DecodedStreamTrackSource::ForceEnded", &source,
+                          &DecodedStreamTrackSource::ForceEnded));
+  }
 }
 
 void OutputStreamData::SetPrincipal(nsIPrincipal* aPrincipal) {
   MOZ_DIAGNOSTIC_ASSERT(mDOMStream);
   for (const WeakPtr<dom::MediaStreamTrack>& track : mTracks) {
-    MOZ_DIAGNOSTIC_ASSERT(track);
+    if (!track || track->Ended()) {
+      continue;
+    }
     DecodedStreamTrackSource& source =
         static_cast<DecodedStreamTrackSource&>(track->GetSource());
     source.SetPrincipal(aPrincipal);
   }
 }
 
-OutputStreamManager::OutputStreamManager(SourceMediaStream* aSourceStream,
-                                         TrackID aNextTrackID,
+OutputStreamManager::OutputStreamManager(MediaStreamGraphImpl* aGraph,
                                          nsIPrincipal* aPrincipal,
                                          AbstractThread* aAbstractMainThread)
-    : mSourceStream(aSourceStream),
-      mAbstractMainThread(aAbstractMainThread),
+    : mAbstractMainThread(aAbstractMainThread),
+      mGraph(aGraph),
       mPrincipalHandle(
           aAbstractMainThread,
           aPrincipal ? MakePrincipalHandle(aPrincipal) : PRINCIPAL_HANDLE_NONE,
           "OutputStreamManager::mPrincipalHandle (Canonical)"),
-      mPrincipal(aPrincipal),
-      mNextTrackID(aNextTrackID),
-      mPlaying(true)  // mSourceStream always starts non-suspended
-{
+      mPrincipal(aPrincipal) {
   MOZ_ASSERT(NS_IsMainThread());
 }
 
 void OutputStreamManager::Add(DOMMediaStream* aDOMStream) {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(!mSourceStream->IsDestroyed());
-  // All streams must belong to the same graph.
-  MOZ_ASSERT(mSourceStream->Graph() == aDOMStream->GetInputStream()->Graph());
 
   LOG(LogLevel::Info, "Adding MediaStream %p", aDOMStream);
 
@@ -163,14 +179,13 @@
                             .AppendElement(new OutputStreamData(
                                 this, mAbstractMainThread, aDOMStream))
                             ->get();
-  for (const Pair<TrackID, MediaSegment::Type>& pair : mLiveTracks) {
-    p->AddTrack(pair.first(), pair.second(), mPrincipal, false);
+  for (const auto& lt : mLiveTracks) {
+    p->AddTrack(lt->mSourceStream, lt->mType, mPrincipal, false);
   }
 }
 
 void OutputStreamManager::Remove(DOMMediaStream* aDOMStream) {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(!mSourceStream->IsDestroyed());
 
   LOG(LogLevel::Info, "Removing MediaStream %p", aDOMStream);
 
@@ -178,8 +193,8 @@
   mStreams.ApplyIf(
       aDOMStream, 0, StreamComparator(),
       [&](const UniquePtr<OutputStreamData>& aData) {
-        for (const Pair<TrackID, MediaSegment::Type>& pair : mLiveTracks) {
-          aData->RemoveTrack(pair.first());
+        for (const auto& lt : mLiveTracks) {
+          aData->RemoveTrack(lt->mSourceStream);
         }
       },
       []() { MOZ_ASSERT_UNREACHABLE("Didn't exist"); });
@@ -193,80 +208,93 @@
   return mLiveTracks.Contains(aType, TrackTypeComparator());
 }
 
-bool OutputStreamManager::HasTracks(TrackID aAudioTrack, TrackID aVideoTrack) {
+bool OutputStreamManager::HasTracks(SourceMediaStream* aAudioStream,
+                                    SourceMediaStream* aVideoStream) {
   MOZ_ASSERT(NS_IsMainThread());
 
   size_t nrExpectedTracks = 0;
   bool asExpected = true;
-  if (IsTrackIDExplicit(aAudioTrack)) {
+  if (aAudioStream) {
     Unused << ++nrExpectedTracks;
     asExpected = asExpected && mLiveTracks.Contains(
-                                   MakePair(aAudioTrack, MediaSegment::AUDIO),
+                                   MakePair(aAudioStream, MediaSegment::AUDIO),
                                    TrackComparator());
   }
-  if (IsTrackIDExplicit(aVideoTrack)) {
+  if (aVideoStream) {
     Unused << ++nrExpectedTracks;
     asExpected = asExpected && mLiveTracks.Contains(
-                                   MakePair(aVideoTrack, MediaSegment::VIDEO),
+                                   MakePair(aVideoStream, MediaSegment::VIDEO),
                                    TrackComparator());
   }
   asExpected = asExpected && mLiveTracks.Length() == nrExpectedTracks;
   return asExpected;
 }
 
+SourceMediaStream* OutputStreamManager::GetPrecreatedTrackOfType(
+    MediaSegment::Type aType) const {
+  auto i = mLiveTracks.IndexOf(aType, 0, PrecreatedTrackTypeComparator());
+  return i == nsTArray<UniquePtr<LiveTrack>>::NoIndex
+             ? nullptr
+             : mLiveTracks[i]->mSourceStream.get();
+}
+
 size_t OutputStreamManager::NumberOfTracks() {
   MOZ_ASSERT(NS_IsMainThread());
   return mLiveTracks.Length();
 }
 
-void OutputStreamManager::AddTrack(MediaSegment::Type aType) {
+already_AddRefed<SourceMediaStream> OutputStreamManager::AddTrack(
+    MediaSegment::Type aType) {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(!mSourceStream->IsDestroyed());
   MOZ_ASSERT(!HasTrackType(aType),
              "Cannot have two tracks of the same type at the same time");
 
-  TrackID id = mNextTrackID++;
+  RefPtr<SourceMediaStream> stream = mGraph->CreateSourceStream();
+  if (!mPlaying) {
+    stream->Suspend();
+  }
 
-  LOG(LogLevel::Info, "Adding %s track with id %d",
-      aType == MediaSegment::AUDIO ? "audio" : "video", id);
+  LOG(LogLevel::Info, "Adding %s track sourced by stream %p",
+      aType == MediaSegment::AUDIO ? "audio" : "video", stream.get());
 
-  mLiveTracks.AppendElement(MakePair(id, aType));
+  mLiveTracks.AppendElement(MakeUnique<LiveTrack>(stream, aType));
   AutoRemoveDestroyedStreams();
   for (const auto& data : mStreams) {
-    data->AddTrack(id, aType, mPrincipal, true);
+    data->AddTrack(stream, aType, mPrincipal, true);
   }
+
+  return stream.forget();
 }
 
+OutputStreamManager::LiveTrack::~LiveTrack() { mSourceStream->Destroy(); }
+
 void OutputStreamManager::AutoRemoveDestroyedStreams() {
   MOZ_ASSERT(NS_IsMainThread());
   for (size_t i = mStreams.Length(); i > 0; --i) {
     const auto& data = mStreams[i - 1];
-    if (!data->mDOMStream || !data->mDOMStream->GetInputStream()) {
+    if (!data->mDOMStream) {
       // If the mDOMStream WeakPtr is now null, mDOMStream has been destructed.
-      // If mDOMStream's input stream is now null, it has been unlinked but not
-      // yet destructed. In both cases we can consider it dead.
       mStreams.RemoveElementAt(i - 1);
     }
   }
 }
 
-void OutputStreamManager::RemoveTrack(TrackID aTrackID) {
+void OutputStreamManager::RemoveTrack(SourceMediaStream* aStream) {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(!mSourceStream->IsDestroyed());
-  LOG(LogLevel::Info, "Removing track with id %d", aTrackID);
-  DebugOnly<bool> rv = mLiveTracks.RemoveElement(aTrackID, TrackIDComparator());
+  LOG(LogLevel::Info, "Removing track with source stream %p", aStream);
+  DebugOnly<bool> rv =
+      mLiveTracks.RemoveElement(aStream, TrackStreamComparator());
   MOZ_ASSERT(rv);
   AutoRemoveDestroyedStreams();
   for (const auto& data : mStreams) {
-    data->RemoveTrack(aTrackID);
+    data->RemoveTrack(aStream);
   }
 }
 
 void OutputStreamManager::RemoveTracks() {
   MOZ_ASSERT(NS_IsMainThread());
-  nsTArray<Pair<TrackID, MediaSegment::Type>> liveTracks(mLiveTracks);
-  for (const auto& pair : liveTracks) {
-    RemoveTrack(pair.first());
+  for (size_t i = mLiveTracks.Length(); i > 0; --i) {
+    RemoveTrack(mLiveTracks[i - 1]->mSourceStream);
   }
 }
 
@@ -283,9 +311,6 @@
     Remove(domStream);
   }
   MOZ_ASSERT(mStreams.IsEmpty());
-  if (!mSourceStream->IsDestroyed()) {
-    mSourceStream->Destroy();
-  }
 }
 
 AbstractCanonical<PrincipalHandle>*
@@ -306,21 +331,6 @@
   }
 }
 
-TrackID OutputStreamManager::NextTrackID() const {
-  MOZ_ASSERT(NS_IsMainThread());
-  return mNextTrackID;
-}
-
-TrackID OutputStreamManager::GetLiveTrackIDFor(MediaSegment::Type aType) const {
-  MOZ_ASSERT(NS_IsMainThread());
-  for (const auto& pair : mLiveTracks) {
-    if (pair.second() == aType) {
-      return pair.first();
-    }
-  }
-  return TRACK_NONE;
-}
-
 void OutputStreamManager::SetPlaying(bool aPlaying) {
   MOZ_ASSERT(NS_IsMainThread());
   if (mPlaying == aPlaying) {
@@ -328,13 +338,18 @@
   }
 
   mPlaying = aPlaying;
-  if (mPlaying) {
-    mSourceStream->Resume();
-  } else {
-    mSourceStream->Suspend();
+  for (auto& lt : mLiveTracks) {
+    if (mPlaying) {
+      lt->mSourceStream->Resume();
+      lt->mEverPlayed = true;
+    } else {
+      lt->mSourceStream->Suspend();
+    }
   }
 }
 
+OutputStreamManager::~OutputStreamManager() = default;
+
 #undef LOG
 
 }  // namespace mozilla