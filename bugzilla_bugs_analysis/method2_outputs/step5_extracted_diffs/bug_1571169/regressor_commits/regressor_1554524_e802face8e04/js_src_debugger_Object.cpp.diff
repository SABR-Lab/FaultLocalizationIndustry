# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/debugger/Object.cpp
# Commit: e802face8e04
# Full Hash: e802face8e042d03933c1495d36fd02a9def7dd9
# Author: Brian Hackett <bhackett1024@gmail.com>
# Date: 2019-07-25 21:51:57
# Regressor Bug: 1554524
# File Overlap Count: 1
# Description:
#   Bug 1554524 Part 4 - Add Debugger interface for instrumenting scripts, r=jimb,tcampbell.
# ==============================================================================

diff -r fc204daba6f3 -r e802face8e04 js/src/debugger/Object.cpp
--- a/js/src/debugger/Object.cpp	Mon Jul 08 09:39:52 2019 -1000
+++ b/js/src/debugger/Object.cpp	Mon Jul 08 09:41:21 2019 -1000
@@ -10,6 +10,7 @@
 #include "debugger/Script.h"
 #include "proxy/ScriptedProxyHandler.h"
 #include "vm/EnvironmentObject.h"
+#include "vm/Instrumentation.h"
 #include "vm/WrapperObject.h"
 
 #include "debugger/Debugger-inl.h"
@@ -1239,6 +1240,101 @@
   return true;
 }
 
+/* static */
+bool DebuggerObject::setInstrumentationMethod(JSContext* cx, unsigned argc,
+                                              Value* vp) {
+  THIS_DEBUGOBJECT(cx, argc, vp, "setInstrumentation", args, object);
+
+  if (!args.requireAtLeast(
+           cx, "Debugger.Object.prototype.setInstrumentation", 2)) {
+    return false;
+  }
+
+  if (!DebuggerObject::requireGlobal(cx, object)) {
+    return false;
+  }
+  RootedGlobalObject global(cx, &object->referent()->as<GlobalObject>());
+
+  RootedValue v(cx, args[0]);
+  if (!object->owner()->unwrapDebuggeeValue(cx, &v)) {
+    return false;
+  }
+  if (!v.isObject()) {
+    JS_ReportErrorASCII(cx, "Instrumentation callback must be an object");
+    return false;
+  }
+  RootedObject callback(cx, &v.toObject());
+
+  if (!args[1].isObject()) {
+    JS_ReportErrorASCII(cx, "Instrumentation kinds must be an object");
+    return false;
+  }
+  RootedObject kindsObj(cx, &args[1].toObject());
+
+  unsigned length = 0;
+  if (!GetLengthProperty(cx, kindsObj, &length)) {
+    return false;
+  }
+
+  Rooted<ValueVector> values(cx, ValueVector(cx));
+  if (!values.growBy(length) ||
+      !GetElements(cx, kindsObj, length, values.begin())) {
+    return false;
+  }
+
+  Rooted<StringVector> kinds(cx, StringVector(cx));
+  for (size_t i = 0; i < values.length(); i++) {
+    if (!values[i].isString()) {
+      JS_ReportErrorASCII(cx, "Instrumentation kind must be a string");
+      return false;
+    }
+    if (!kinds.append(values[i].toString())) {
+      return false;
+    }
+  }
+
+  {
+    AutoRealm ar(cx, global);
+    RootedObject dbgObject(cx, object->owner()->toJSObject());
+    if (!RealmInstrumentation::install(cx, global, callback, dbgObject,
+                                       kinds)) {
+      return false;
+    }
+  }
+
+  args.rval().setUndefined();
+  return true;
+}
+
+/* static */
+bool DebuggerObject::setInstrumentationActiveMethod(JSContext* cx,
+                                                    unsigned argc,
+                                                    Value* vp) {
+  THIS_DEBUGOBJECT(cx, argc, vp, "setInstrumentationActive", args, object);
+
+  if (!DebuggerObject::requireGlobal(cx, object)) {
+    return false;
+  }
+
+  if (!args.requireAtLeast(
+      cx, "Debugger.Object.prototype.setInstrumentationActive", 1)) {
+    return false;
+  }
+
+  RootedGlobalObject global(cx, &object->referent()->as<GlobalObject>());
+  bool active = ToBoolean(args[0]);
+
+  {
+    AutoRealm ar(cx, global);
+    if (!RealmInstrumentation::setActive(cx, global, object->owner(), active)) {
+      return false;
+    }
+  }
+
+  args.rval().setUndefined();
+  return true;
+}
+
 const JSPropertySpec DebuggerObject::properties_[] = {
     JS_PSG("callable", DebuggerObject::callableGetter, 0),
     JS_PSG("isBoundFunction", DebuggerObject::isBoundFunctionGetter, 0),
@@ -1311,6 +1407,9 @@
     JS_FN("makeDebuggeeValue", DebuggerObject::makeDebuggeeValueMethod, 1, 0),
     JS_FN("unsafeDereference", DebuggerObject::unsafeDereferenceMethod, 0, 0),
     JS_FN("unwrap", DebuggerObject::unwrapMethod, 0, 0),
+    JS_FN("setInstrumentation", DebuggerObject::setInstrumentationMethod, 2, 0),
+    JS_FN("setInstrumentationActive",
+          DebuggerObject::setInstrumentationActiveMethod, 1, 0),
     JS_FS_END};
 
 /* static */