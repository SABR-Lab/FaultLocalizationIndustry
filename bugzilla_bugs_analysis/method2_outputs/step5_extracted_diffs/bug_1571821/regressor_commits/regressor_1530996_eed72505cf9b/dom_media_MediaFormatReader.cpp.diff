# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaFormatReader.cpp
# Commit: eed72505cf9b
# Full Hash: eed72505cf9b3c968aced5a6488f2660e1f02da4
# Author: Alex Chronopoulos <achronop@gmail.com>
# Date: 2019-08-06 16:15:05
# Regressor Bug: 1530996
# File Overlap Count: 1
# Description:
#   Bug 1530996 - Use the new storage mechanism to save the current playback benchmark. r=jya
#   
#   Create an event in MediaFormatReader the will signal to the HTMLMediaElement to initiate a new storing according to the latest VideoInfo. Also when the application is shutting down, trigger a new storing early enough, before all the events are disconnected.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D38316
# ==============================================================================

diff -r 426b558f2f43 -r eed72505cf9b dom/media/MediaFormatReader.cpp
--- a/dom/media/MediaFormatReader.cpp	Tue Aug 06 09:24:40 2019 +0000
+++ b/dom/media/MediaFormatReader.cpp	Tue Aug 06 09:25:45 2019 +0000
@@ -894,10 +894,21 @@
   auto& decoder = GetDecoderData(aTrack);
   // Flush the decoder if necessary.
   decoder.Flush();
+
   // Shut down the decoder if any.
   decoder.ShutdownDecoder();
 }
 
+void MediaFormatReader::NotifyDecoderBenchmarkStore() {
+  MOZ_ASSERT(OnTaskQueue());
+  auto& decoder = GetDecoderData(TrackInfo::kVideoTrack);
+  if (decoder.GetCurrentInfo() && decoder.GetCurrentInfo()->GetAsVideoInfo()) {
+    VideoInfo info = *(decoder.GetCurrentInfo()->GetAsVideoInfo());
+    info.SetFrameRate(static_cast<int32_t>(ceil(decoder.mMeanRate.Mean())));
+    mOnStoreDecoderBenchmark.Notify(std::move(info));
+  }
+}
+
 RefPtr<ShutdownPromise> MediaFormatReader::TearDownDecoders() {
   if (mAudio.mTaskQueue) {
     mAudio.mTaskQueue->BeginShutdown();
@@ -1838,6 +1849,11 @@
     LOG("%s stream id has changed from:%d to:%d.", TrackTypeToStr(aTrack),
         decoder.mLastStreamSourceID, info->GetID());
 
+    if (aTrack == TrackInfo::kVideoTrack) {
+      // We are about to create a new decoder thus the benchmark,
+      // up to this point, is stored.
+      NotifyDecoderBenchmarkStore();
+    }
     decoder.mNextStreamSourceID.reset();
     decoder.mLastStreamSourceID = info->GetID();
     decoder.mInfo = info;
@@ -2111,6 +2127,10 @@
     } else if (decoder.HasCompletedDrain()) {
       if (decoder.mDemuxEOS) {
         LOG("Rejecting %s promise: EOS", TrackTypeToStr(aTrack));
+        if (aTrack == TrackInfo::kVideoTrack) {
+          // End of video, store the benchmark of the decoder.
+          NotifyDecoderBenchmarkStore();
+        }
         decoder.RejectPromise(NS_ERROR_DOM_MEDIA_END_OF_STREAM, __func__);
       } else if (decoder.mWaitingForData) {
         if (decoder.mDrainState == DrainState::DrainCompleted &&