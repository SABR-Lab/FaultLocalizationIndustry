# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/svg/SVGRect.cpp
# Commit: b848ca90888e
# Full Hash: b848ca90888ee8e446f3d54b65c3ef68c71a1451
# Author: longsonr <longsonr@gmail.com>
# Date: 2019-06-20 22:06:31
# Regressor Bug: 1551030
# File Overlap Count: 2
# Description:
#   Bug 1551030 - Merge all SVGRect classes r=dholbert
# ==============================================================================

diff -r 20956a783e08 -r b848ca90888e dom/svg/SVGRect.cpp
--- a/dom/svg/SVGRect.cpp	Thu Jun 20 14:19:57 2019 +0300
+++ b/dom/svg/SVGRect.cpp	Thu Jun 20 07:03:54 2019 -0700
@@ -5,7 +5,11 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/SVGRect.h"
-#include "SVGElement.h"
+
+#include "mozilla/dom/SVGRectBinding.h"
+#include "mozilla/dom/SVGSVGElement.h"
+#include "SVGAnimatedViewBox.h"
+#include "nsWrapperCache.h"
 
 using namespace mozilla::gfx;
 
@@ -13,12 +17,6 @@
 namespace dom {
 
 //----------------------------------------------------------------------
-// implementation:
-
-SVGRect::SVGRect(nsIContent* aParent, float x, float y, float w, float h)
-    : SVGIRect(), mParent(aParent), mX(x), mY(y), mWidth(w), mHeight(h) {}
-
-//----------------------------------------------------------------------
 // nsISupports methods:
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(SVGRect, mParent)
@@ -31,23 +29,132 @@
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
+//----------------------------------------------------------------------
+// implementation:
+
+SVGRect::SVGRect(SVGSVGElement* aSVGElement)
+    : mVal(nullptr), mParent(aSVGElement), mType(CreatedValue) {
+  MOZ_ASSERT(mParent);
+  mRect = gfx::Rect(0, 0, 0, 0);
+}
+
+JSObject* SVGRect::WrapObject(JSContext* aCx,
+                              JS::Handle<JSObject*> aGivenProto) {
+  MOZ_ASSERT(mParent);
+  return SVGRect_Binding::Wrap(aCx, this, aGivenProto);
+}
+
+float SVGRect::X() {
+  switch (mType) {
+    case AnimValue:
+      static_cast<SVGElement*>(mParent->AsElement())->FlushAnimations();
+      return mVal->GetAnimValue().x;
+    case BaseValue:
+      return mVal->GetBaseValue().x;
+    default:
+      return mRect.x;
+  }
+}
+
+float SVGRect::Y() {
+  switch (mType) {
+    case AnimValue:
+      static_cast<SVGElement*>(mParent->AsElement())->FlushAnimations();
+      return mVal->GetAnimValue().y;
+    case BaseValue:
+      return mVal->GetBaseValue().y;
+    default:
+      return mRect.y;
+  }
+}
+
+float SVGRect::Width() {
+  switch (mType) {
+    case AnimValue:
+      static_cast<SVGElement*>(mParent->AsElement())->FlushAnimations();
+      return mVal->GetAnimValue().width;
+    case BaseValue:
+      return mVal->GetBaseValue().width;
+    default:
+      return mRect.width;
+  }
+}
+
+float SVGRect::Height() {
+  switch (mType) {
+    case AnimValue:
+      static_cast<SVGElement*>(mParent->AsElement())->FlushAnimations();
+      return mVal->GetAnimValue().height;
+    case BaseValue:
+      return mVal->GetBaseValue().height;
+    default:
+      return mRect.height;
+  }
+}
+
+void SVGRect::SetX(float aX, ErrorResult& aRv) {
+  switch (mType) {
+    case AnimValue:
+      aRv.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
+      return;
+    case BaseValue: {
+      SVGViewBox rect = mVal->GetBaseValue();
+      rect.x = aX;
+      mVal->SetBaseValue(rect, static_cast<SVGElement*>(mParent->AsElement()));
+      return;
+    }
+    default:
+      mRect.x = aX;
+  }
+}
+
+void SVGRect::SetY(float aY, ErrorResult& aRv) {
+  switch (mType) {
+    case AnimValue:
+      aRv.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
+      return;
+    case BaseValue: {
+      SVGViewBox rect = mVal->GetBaseValue();
+      rect.y = aY;
+      mVal->SetBaseValue(rect, static_cast<SVGElement*>(mParent->AsElement()));
+      return;
+    }
+    default:
+      mRect.y = aY;
+  }
+}
+
+void SVGRect::SetWidth(float aWidth, ErrorResult& aRv) {
+  switch (mType) {
+    case AnimValue:
+      aRv.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
+      return;
+    case BaseValue: {
+      SVGViewBox rect = mVal->GetBaseValue();
+      rect.width = aWidth;
+      mVal->SetBaseValue(rect, static_cast<SVGElement*>(mParent->AsElement()));
+      return;
+    }
+    default:
+      mRect.width = aWidth;
+  }
+}
+
+void SVGRect::SetHeight(float aHeight, ErrorResult& aRv) {
+  switch (mType) {
+    case AnimValue:
+      aRv.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
+      return;
+    case BaseValue: {
+      SVGViewBox rect = mVal->GetBaseValue();
+      rect.height = aHeight;
+      mVal->SetBaseValue(rect, static_cast<SVGElement*>(mParent->AsElement()));
+      return;
+    }
+    default:
+      mRect.height = aHeight;
+  }
+}
+
 }  // namespace dom
 }  // namespace mozilla
-
-////////////////////////////////////////////////////////////////////////
-// Exported creation functions:
-
-already_AddRefed<mozilla::dom::SVGRect> NS_NewSVGRect(nsIContent* aParent,
-                                                      float aX, float aY,
-                                                      float aWidth,
-                                                      float aHeight) {
-  RefPtr<mozilla::dom::SVGRect> rect =
-      new mozilla::dom::SVGRect(aParent, aX, aY, aWidth, aHeight);
-
-  return rect.forget();
-}
-
-already_AddRefed<mozilla::dom::SVGRect> NS_NewSVGRect(nsIContent* aParent,
-                                                      const Rect& aRect) {
-  return NS_NewSVGRect(aParent, aRect.x, aRect.y, aRect.width, aRect.height);
-}