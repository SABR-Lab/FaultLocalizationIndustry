# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/windowwatcher/nsWindowWatcher.cpp
# Commit: 8303383dd95b
# Full Hash: 8303383dd95b60e0b23d961bc397f670b2fd0383
# Author: Kris Maglione <maglione.k@gmail.com>
# Date: 2019-08-15 09:46:49
# Regressor Bug: 1562292
# File Overlap Count: 1
# Description:
#   Bug 1562292: Part 2d - Operate on BrowsingContext in most of OpenWindowInternal. r=nika
#   
#   This allows us to actually correctly load URIs into and return BCs for
#   cross-process named targets. It still leaves a lot of code which needs to
#   operate directly on DocShells, but it only applies to new windows, which
# ==============================================================================

diff -r b47a29dc541a -r 8303383dd95b toolkit/components/windowwatcher/nsWindowWatcher.cpp
--- a/toolkit/components/windowwatcher/nsWindowWatcher.cpp	Fri Jun 28 14:34:58 2019 -0700
+++ b/toolkit/components/windowwatcher/nsWindowWatcher.cpp	Thu Aug 01 17:08:54 2019 -0700
@@ -600,8 +600,8 @@
   nsAutoCString features;      // string version of aFeatures
   nsCOMPtr<nsIURI> uriToLoad;  // from aUrl, if any
   nsCOMPtr<nsIDocShellTreeOwner>
-      parentTreeOwner;  // from the parent window, if any
-  nsCOMPtr<nsIDocShellTreeItem> newDocShellItem;  // from the new window
+      parentTreeOwner;            // from the parent window, if any
+  RefPtr<BrowsingContext> newBC;  // from the new window
 
   nsCOMPtr<nsPIDOMWindowOuter> parentWindow =
       aParent ? nsPIDOMWindowOuter::From(aParent) : nullptr;
@@ -642,13 +642,11 @@
     features.SetIsVoid(true);
   }
 
-  // try to find an extant browsing context with the given name
-  RefPtr<BrowsingContext> foundContext = GetBrowsingContextByName(
-      name, aForceNoOpener,
+  RefPtr<BrowsingContext> parentBC(
       parentWindow ? parentWindow->GetBrowsingContext() : nullptr);
-  if (foundContext) {
-    newDocShellItem = foundContext->GetDocShell();
-  }
+
+  // try to find an extant browsing context with the given name
+  newBC = GetBrowsingContextByName(name, aForceNoOpener, parentBC);
 
   // Do sandbox checks here, instead of waiting until nsIDocShell::LoadURI.
   // The state of the window can change before this call and if we are blocked
@@ -657,8 +655,7 @@
   if (parentWindow) {
     parentDocShell = parentWindow->GetDocShell();
     if (parentDocShell) {
-      if (parentDocShell->IsSandboxedFrom(
-              newDocShellItem->GetBrowsingContext())) {
+      if (parentDocShell->IsSandboxedFrom(newBC)) {
         return NS_ERROR_DOM_INVALID_ACCESS_ERR;
       }
     }
@@ -730,7 +727,7 @@
   }
 
   uint32_t activeDocsSandboxFlags = 0;
-  if (!newDocShellItem) {
+  if (!newBC) {
     // We're going to either open up a new window ourselves or ask a
     // nsIWindowProvider for one.  In either case, we'll want to set the right
     // name on it.
@@ -766,32 +763,28 @@
       }
 
       if (provider) {
-        RefPtr<BrowsingContext> newBC;
         rv = provider->ProvideWindow(
             aParent, chromeFlags, aCalledFromJS, sizeSpec.PositionSpecified(),
             sizeSpec.SizeSpecified(), uriToLoad, name, features, aForceNoOpener,
             aForceNoReferrer, aLoadState, &windowIsNew, getter_AddRefs(newBC));
 
         if (NS_SUCCEEDED(rv) && newBC) {
-          newDocShellItem = newBC->GetDocShell();
-          if (windowIsNew && newDocShellItem) {
+          nsCOMPtr<nsIDocShell> newDocShell = newBC->GetDocShell();
+          if (windowIsNew && newDocShell) {
             // Make sure to stop any loads happening in this window that the
             // window provider might have started.  Otherwise if our caller
             // manipulates the window it just opened and then the load
             // completes their stuff will get blown away.
-            nsCOMPtr<nsIWebNavigation> webNav =
-                do_QueryInterface(newDocShellItem);
+            nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(newDocShell);
             webNav->Stop(nsIWebNavigation::STOP_NETWORK);
           }
 
           // If this is a new window, but it's incompatible with the current
           // userContextId, we ignore it and we pretend that nothing has been
           // returned by ProvideWindow.
-          if (!windowIsNew && newDocShellItem) {
-            nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(newDocShellItem);
-            if (!CheckUserContextCompatibility(docShell)) {
+          if (!windowIsNew && newDocShell) {
+            if (!CheckUserContextCompatibility(newDocShell)) {
               newBC = nullptr;
-              newDocShellItem = nullptr;
               windowIsNew = false;
             }
           }
@@ -810,7 +803,7 @@
 
   bool newWindowShouldBeModal = false;
   bool parentIsModal = false;
-  if (!newDocShellItem) {
+  if (!newBC) {
     windowIsNew = true;
     isNewToplevelWindow = true;
 
@@ -899,6 +892,7 @@
             an nsIDOMWindow (primary content shell). But in that case, it'll
             be able to hand over an nsIDocShellTreeItem directly. */
         nsCOMPtr<nsPIDOMWindowOuter> newWindow(do_GetInterface(newChrome));
+        nsCOMPtr<nsIDocShellTreeItem> newDocShellItem;
         if (newWindow) {
           GetWindowTreeItem(newWindow, getter_AddRefs(newDocShellItem));
         }
@@ -908,57 +902,88 @@
         if (!newDocShellItem) {
           rv = NS_ERROR_FAILURE;
         }
+        newBC = newDocShellItem->GetBrowsingContext();
       }
     }
   }
 
   // better have a window to use by this point
-  if (!newDocShellItem) {
+  if (!newBC) {
     return rv;
   }
 
-  nsCOMPtr<nsIDocShell> newDocShell(do_QueryInterface(newDocShellItem));
-  NS_ENSURE_TRUE(newDocShell, NS_ERROR_UNEXPECTED);
-
   // If our parent is sandboxed, set it as the one permitted sandboxed navigator
   // on the new window we're opening.
-  if (activeDocsSandboxFlags && parentWindow) {
-    newDocShell->GetBrowsingContext()->SetOnePermittedSandboxedNavigator(
-        parentWindow->GetBrowsingContext());
+  if (activeDocsSandboxFlags && parentBC) {
+    newBC->SetOnePermittedSandboxedNavigator(parentBC);
   }
 
+  RefPtr<nsDocShell> newDocShell(nsDocShell::Cast(newBC->GetDocShell()));
+
+  // As required by spec, new windows always start out same-process, even if the
+  // URL being loaded will eventually load in a new process.
+  MOZ_ASSERT_IF(windowIsNew, newDocShell);
+  // New top-level windows are only opened in the parent process and are, by
+  // definition, always in-process.
+  MOZ_ASSERT_IF(isNewToplevelWindow, newDocShell);
+
   // Copy sandbox flags to the new window if activeDocsSandboxFlags says to do
   // so.  Note that it's only nonzero if the window is new, so clobbering
   // sandbox flags on the window makes sense in that case.
   if (activeDocsSandboxFlags &
       SANDBOX_PROPAGATES_TO_AUXILIARY_BROWSING_CONTEXTS) {
+    MOZ_ASSERT(windowIsNew, "Should only get here for new windows");
     newDocShell->SetSandboxFlags(activeDocsSandboxFlags);
   }
 
-  nsCOMPtr<mozIDOMWindowProxy> win;
-  rv = ReadyOpenedDocShellItem(newDocShellItem, parentWindow, windowIsNew,
-                               aForceNoOpener, getter_AddRefs(win));
-  if (NS_FAILED(rv)) {
-    return rv;
+  nsCOMPtr<nsPIDOMWindowOuter> win(newBC->GetDOMWindow());
+  if (win) {
+    if (!aForceNoOpener) {
+      win->SetOpenerWindow(parentWindow, windowIsNew);
+    } else if (parentWindow && parentWindow != win) {
+      MOZ_ASSERT(
+          win->TabGroup() != parentWindow->TabGroup(),
+          "If we're forcing no opener, they should be in different tab groups");
+    }
+
+    if (windowIsNew) {
+#ifdef DEBUG
+      // Assert that we're not loading things right now.  If we are, when
+      // that load completes it will clobber whatever principals we set up
+      // on this new window!
+      nsCOMPtr<nsIChannel> chan;
+      newDocShell->GetDocumentChannel(getter_AddRefs(chan));
+      MOZ_ASSERT(!chan, "Why is there a document channel?");
+#endif
+
+      if (RefPtr<Document> doc = win->GetExtantDoc()) {
+        doc->SetIsInitialDocument(true);
+      }
+    }
+  } else {
+    MOZ_ASSERT(!windowIsNew, "New windows are always created in-process");
+    if (!aForceNoOpener) {
+      // FIXME: We need to change the opener of this window, but
+      // BrowsingContext::SetOpener can only be called by the process which
+      // currently owns the BrowsingContext, and that isn't us.
+      // newBC->SetOpener(parentBC);
+    }
   }
 
-  RefPtr<BrowsingContext> bc(
-      nsPIDOMWindowOuter::From(win)->GetBrowsingContext());
-  bc.forget(aResult);
+  *aResult = do_AddRef(newBC).take();
 
   if (isNewToplevelWindow) {
     nsCOMPtr<nsIDocShellTreeOwner> newTreeOwner;
-    newDocShellItem->GetTreeOwner(getter_AddRefs(newTreeOwner));
+    newDocShell->GetTreeOwner(getter_AddRefs(newTreeOwner));
     MaybeDisablePersistence(features, newTreeOwner);
   }
 
   if ((aDialog || windowIsModalContentDialog) && aArgv) {
+    MOZ_ASSERT(win);
+    NS_ENSURE_TRUE(win, NS_ERROR_UNEXPECTED);
+
     // Set the args on the new window.
-    nsCOMPtr<nsPIDOMWindowOuter> piwin(do_QueryInterface(win));
-    NS_ENSURE_TRUE(piwin, NS_ERROR_UNEXPECTED);
-
-    rv = piwin->SetArguments(aArgv);
-    NS_ENSURE_SUCCESS(rv, rv);
+    MOZ_TRY(win->SetArguments(aArgv));
   }
 
   /* allow a window that we found by name to keep its name (important for cases
@@ -966,9 +991,9 @@
      is not a window name. */
   if (windowNeedsName) {
     if (nameSpecified && !name.LowerCaseEqualsLiteral("_blank")) {
-      newDocShellItem->SetName(name);
+      newBC->SetName(name);
     } else {
-      newDocShellItem->SetName(EmptyString());
+      newBC->SetName(EmptyString());
     }
   }
 
@@ -988,16 +1013,14 @@
   bool isPrivateBrowsingWindow = false;
 
   if (windowIsNew) {
-    auto* docShell = static_cast<nsDocShell*>(newDocShell.get());
-
     // If this is not a chrome docShell, we apply originAttributes from the
     // subjectPrincipal unless if it's an expanded or system principal.
     if (subjectPrincipal &&
         !nsContentUtils::IsSystemOrExpandedPrincipal(subjectPrincipal) &&
-        docShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
+        newDocShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
       isPrivateBrowsingWindow =
           !!subjectPrincipal->OriginAttributesRef().mPrivateBrowsingId;
-      docShell->SetOriginAttributes(subjectPrincipal->OriginAttributesRef());
+      newDocShell->SetOriginAttributes(subjectPrincipal->OriginAttributesRef());
     } else {
       nsCOMPtr<nsIDocShellTreeItem> parentItem;
       GetWindowTreeItem(aParent, getter_AddRefs(parentItem));
@@ -1023,26 +1046,25 @@
     // the JS stack, just use the principal of our parent window.  In those
     // cases we do _not_ set the parent window principal as the owner of the
     // load--since we really don't know who the owner is, just leave it null.
-    nsCOMPtr<nsPIDOMWindowOuter> newWindow = do_QueryInterface(win);
-    NS_ASSERTION(newWindow == newDocShell->GetWindow(), "Different windows??");
+    NS_ASSERTION(win == newDocShell->GetWindow(), "Different windows??");
 
     // The principal of the initial about:blank document gets set up in
     // nsWindowWatcher::AddWindow. Make sure to call it. In the common case
     // this call already happened when the window was created, but
     // SetInitialPrincipalToSubject is safe to call multiple times.
-    if (newWindow) {
+    if (win) {
       nsCOMPtr<nsIContentSecurityPolicy> cspToInheritForAboutBlank;
-      nsCOMPtr<mozIDOMWindowProxy> targetOpener = newWindow->GetOpener();
+      nsCOMPtr<mozIDOMWindowProxy> targetOpener = win->GetOpener();
       nsCOMPtr<nsIDocShell> openerDocShell(do_GetInterface(targetOpener));
       if (openerDocShell) {
         RefPtr<Document> openerDoc =
             static_cast<nsDocShell*>(openerDocShell.get())->GetDocument();
         cspToInheritForAboutBlank = openerDoc ? openerDoc->GetCsp() : nullptr;
       }
-      newWindow->SetInitialPrincipalToSubject(cspToInheritForAboutBlank);
+      win->SetInitialPrincipalToSubject(cspToInheritForAboutBlank);
 
       if (aIsPopupSpam) {
-        nsGlobalWindowOuter* globalWin = nsGlobalWindowOuter::Cast(newWindow);
+        auto* globalWin = nsGlobalWindowOuter::Cast(win);
         MOZ_ASSERT(!globalWin->IsPopupSpamWindow(),
                    "Who marked it as popup spam already???");
         if (!globalWin->IsPopupSpamWindow()) {  // Make sure we don't mess up
@@ -1063,7 +1085,7 @@
 
   if (isNewToplevelWindow) {
     nsCOMPtr<nsIDocShellTreeItem> childRoot;
-    newDocShellItem->GetInProcessRootTreeItem(getter_AddRefs(childRoot));
+    newDocShell->GetInProcessRootTreeItem(getter_AddRefs(childRoot));
     nsCOMPtr<nsILoadContext> childContext = do_QueryInterface(childRoot);
     if (childContext) {
       childContext->SetPrivateBrowsing(isPrivateBrowsingWindow);
@@ -1071,12 +1093,9 @@
       childContext->SetRemoteSubframes(isFissionWindow);
     }
   } else if (windowIsNew) {
-    nsCOMPtr<nsILoadContext> childContext = do_QueryInterface(newDocShellItem);
-    if (childContext) {
-      childContext->SetPrivateBrowsing(isPrivateBrowsingWindow);
-      childContext->SetRemoteTabs(isRemoteWindow);
-      childContext->SetRemoteSubframes(isFissionWindow);
-    }
+    newDocShell->SetPrivateBrowsing(isPrivateBrowsingWindow);
+    newDocShell->SetRemoteTabs(isRemoteWindow);
+    newDocShell->SetRemoteSubframes(isFissionWindow);
   }
 
   RefPtr<nsDocShellLoadState> loadState = aLoadState;
@@ -1134,12 +1153,12 @@
 
   // Before loading the URI we want to be 100% sure that we use the correct
   // userContextId.
-  MOZ_ASSERT(CheckUserContextCompatibility(newDocShell));
+  MOZ_ASSERT_IF(newDocShell, CheckUserContextCompatibility(newDocShell));
 
   // If this tab or window has been opened by a window.open call, we have to
   // provide all the data needed to send a
   // webNavigation.onCreatedNavigationTarget event.
-  if (parentDocShell && newDocShellItem) {
+  if (parentDocShell && windowIsNew) {
     nsCOMPtr<nsIObserverService> obsSvc =
         mozilla::services::GetObserverService();
 
@@ -1156,7 +1175,7 @@
       props->SetPropertyAsInterface(NS_LITERAL_STRING("sourceTabDocShell"),
                                     parentDocShell);
       props->SetPropertyAsInterface(NS_LITERAL_STRING("createdTabDocShell"),
-                                    newDocShellItem);
+                                    ToSupports(newDocShell));
 
       obsSvc->NotifyObservers(static_cast<nsIPropertyBag2*>(props),
                               "webNavigation-createdNavigationTarget-from-js",
@@ -1170,8 +1189,9 @@
             ? static_cast<uint32_t>(nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD)
             : static_cast<uint32_t>(nsIWebNavigation::LOAD_FLAGS_NONE));
     loadState->SetFirstParty(true);
+
     // Should this pay attention to errors returned by LoadURI?
-    newDocShell->LoadURI(loadState);
+    newBC->LoadURI(parentBC, loadState);
   }
 
   // Copy the current session storage for the current domain. Don't perform the
@@ -1179,8 +1199,7 @@
   if (!aForceNoOpener && subjectPrincipal && parentDocShell) {
     nsCOMPtr<nsIDOMStorageManager> parentStorageManager =
         do_QueryInterface(parentDocShell);
-    nsCOMPtr<nsIDOMStorageManager> newStorageManager =
-        do_QueryInterface(newDocShell);
+    nsCOMPtr<nsIDOMStorageManager> newStorageManager(newDocShell);
 
     if (parentStorageManager && newStorageManager) {
       RefPtr<Storage> storage;
@@ -1197,14 +1216,16 @@
 
   if (isNewToplevelWindow) {
     nsCOMPtr<nsIDocShellTreeOwner> newTreeOwner;
-    newDocShellItem->GetTreeOwner(getter_AddRefs(newTreeOwner));
+    newDocShell->GetTreeOwner(getter_AddRefs(newTreeOwner));
     SizeOpenedWindow(newTreeOwner, aParent, isCallerChrome, sizeSpec);
   }
 
   // XXXbz isn't windowIsModal always true when windowIsModalContentDialog?
   if (windowIsModal || windowIsModalContentDialog) {
+    NS_ENSURE_TRUE(newDocShell, NS_ERROR_NOT_IMPLEMENTED);
+
     nsCOMPtr<nsIDocShellTreeOwner> newTreeOwner;
-    newDocShellItem->GetTreeOwner(getter_AddRefs(newTreeOwner));
+    newDocShell->GetTreeOwner(getter_AddRefs(newTreeOwner));
     nsCOMPtr<nsIWebBrowserChrome> newChrome(do_GetInterface(newTreeOwner));
 
     // Throw an exception here if no web browser chrome is available,
@@ -2009,54 +2030,6 @@
   return foundContext.forget();
 }
 
-/* Fetch the nsIDOMWindow corresponding to the given nsIDocShellTreeItem.
-   This forces the creation of a script context, if one has not already
-   been created. Note it also sets the window's opener to the parent,
-   if applicable -- because it's just convenient, that's all. null aParent
-   is acceptable. */
-nsresult nsWindowWatcher::ReadyOpenedDocShellItem(
-    nsIDocShellTreeItem* aOpenedItem, nsPIDOMWindowOuter* aParent,
-    bool aWindowIsNew, bool aForceNoOpener,
-    mozIDOMWindowProxy** aOpenedWindow) {
-  nsresult rv = NS_ERROR_FAILURE;
-
-  NS_ENSURE_ARG(aOpenedWindow);
-
-  *aOpenedWindow = 0;
-  nsCOMPtr<nsPIDOMWindowOuter> piOpenedWindow = aOpenedItem->GetWindow();
-  if (piOpenedWindow) {
-    if (!aForceNoOpener) {
-      piOpenedWindow->SetOpenerWindow(aParent, aWindowIsNew);  // damnit
-    } else if (aParent && aParent != piOpenedWindow) {
-      MOZ_ASSERT(
-          piOpenedWindow->TabGroup() != aParent->TabGroup(),
-          "If we're forcing no opener, they should be in different tab groups");
-    }
-
-    if (aWindowIsNew) {
-#ifdef DEBUG
-      // Assert that we're not loading things right now.  If we are, when
-      // that load completes it will clobber whatever principals we set up
-      // on this new window!
-      nsCOMPtr<nsIDocumentLoader> docloader = do_QueryInterface(aOpenedItem);
-      NS_ASSERTION(docloader, "How can we not have a docloader here?");
-
-      nsCOMPtr<nsIChannel> chan;
-      docloader->GetDocumentChannel(getter_AddRefs(chan));
-      NS_ASSERTION(!chan, "Why is there a document channel?");
-#endif
-
-      RefPtr<Document> doc = piOpenedWindow->GetExtantDoc();
-      if (doc) {
-        doc->SetIsInitialDocument(true);
-      }
-    }
-    piOpenedWindow.forget(aOpenedWindow);
-    rv = NS_OK;
-  }
-  return rv;
-}
-
 // static
 void nsWindowWatcher::CalcSizeSpec(const nsACString& aFeatures,
                                    SizeSpec& aResult) {