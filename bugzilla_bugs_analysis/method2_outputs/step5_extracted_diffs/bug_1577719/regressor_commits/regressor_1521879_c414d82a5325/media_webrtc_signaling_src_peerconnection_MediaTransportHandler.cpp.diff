# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/peerconnection/MediaTransportHandler.cpp
# Commit: c414d82a5325
# Full Hash: c414d82a532508523d40ce63111cb30b2a1076be
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2019-02-22 05:26:22
# Regressor Bug: 1521879
# File Overlap Count: 1
# Description:
#   Bug 1521879 - Part 1: IPC-based MediaTransport implementation r=mjf
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D17273
# ==============================================================================

diff -r 3a182b05e2c1 -r c414d82a5325 media/webrtc/signaling/src/peerconnection/MediaTransportHandler.cpp
--- a/media/webrtc/signaling/src/peerconnection/MediaTransportHandler.cpp	Thu Feb 21 19:01:32 2019 +0200
+++ b/media/webrtc/signaling/src/peerconnection/MediaTransportHandler.cpp	Thu Feb 21 16:42:12 2019 +0000
@@ -3,6 +3,7 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "MediaTransportHandler.h"
+#include "MediaTransportHandlerIPC.h"
 #include "nricemediastream.h"
 #include "nriceresolver.h"
 #include "transportflow.h"
@@ -29,6 +30,8 @@
 // DTLS
 #include "signaling/src/sdp/SdpAttribute.h"
 
+#include "runnable_utils.h"
+
 #include "mozilla/Telemetry.h"
 
 #include "mozilla/dom/RTCStatsReportBinding.h"
@@ -48,16 +51,16 @@
 class MediaTransportHandlerSTS : public MediaTransportHandler,
                                  public sigslot::has_slots<> {
  public:
-  MediaTransportHandlerSTS();
+  explicit MediaTransportHandlerSTS(nsISerialEventTarget* aCallbackThread);
 
   RefPtr<IceLogPromise> GetIceLog(const nsCString& aPattern) override;
   void ClearIceLog() override;
   void EnterPrivateMode() override;
   void ExitPrivateMode() override;
 
-  nsresult Init(const std::string& aName,
-                const nsTArray<dom::RTCIceServer>& aIceServers,
-                dom::RTCIceTransportPolicy aIcePolicy) override;
+  nsresult CreateIceCtx(const std::string& aName,
+                        const nsTArray<dom::RTCIceServer>& aIceServers,
+                        dom::RTCIceTransportPolicy aIcePolicy) override;
   void Destroy() override;
 
   // We will probably be able to move the proxy lookup stuff into
@@ -101,9 +104,6 @@
   void SendPacket(const std::string& aTransportId,
                   MediaPacket&& aPacket) override;
 
-  TransportLayer::State GetState(const std::string& aTransportId,
-                                 bool aRtcp) const override;
-
   RefPtr<StatsPromise> GetIceStats(
       const std::string& aTransportId, DOMHighResTimeStamp aNow,
       std::unique_ptr<dom::RTCStatsReportInternal>&& aReport) override;
@@ -121,6 +121,15 @@
     RefPtr<TransportFlow> mRtcpFlow;
   };
 
+  using MediaTransportHandler::OnAlpnNegotiated;
+  using MediaTransportHandler::OnCandidate;
+  using MediaTransportHandler::OnConnectionStateChange;
+  using MediaTransportHandler::OnEncryptedSending;
+  using MediaTransportHandler::OnGatheringStateChange;
+  using MediaTransportHandler::OnPacketReceived;
+  using MediaTransportHandler::OnRtcpStateChange;
+  using MediaTransportHandler::OnStateChange;
+
   void OnGatheringStateChange(NrIceCtx* aIceCtx,
                               NrIceCtx::GatheringState aState);
   void OnConnectionStateChange(NrIceCtx* aIceCtx,
@@ -141,23 +150,25 @@
   RefPtr<NrIceCtx> mIceCtx;
   RefPtr<NrIceResolver> mDNSResolver;
   std::map<std::string, Transport> mTransports;
-  std::map<std::string, TransportLayer::State> mStateCache;
-  std::map<std::string, TransportLayer::State> mRtcpStateCache;
   bool mProxyOnly = false;
 };
 
 /* static */
-already_AddRefed<MediaTransportHandler> MediaTransportHandler::Create() {
+already_AddRefed<MediaTransportHandler> MediaTransportHandler::Create(
+    nsISerialEventTarget* aCallbackThread) {
   RefPtr<MediaTransportHandler> result;
-  if (Preferences::GetBool("media.peerconnection.mtransport_process")) {
-    // TODO: Return a MediaTransportHandlerIPC
+  if (XRE_IsContentProcess() &&
+      Preferences::GetBool("media.peerconnection.mtransport_process")) {
+    result = new MediaTransportHandlerIPC(aCallbackThread);
   } else {
-    result = new MediaTransportHandlerSTS;
+    result = new MediaTransportHandlerSTS(aCallbackThread);
   }
   return result.forget();
 }
 
-MediaTransportHandlerSTS::MediaTransportHandlerSTS() {
+MediaTransportHandlerSTS::MediaTransportHandlerSTS(
+    nsISerialEventTarget* aCallbackThread)
+    : MediaTransportHandler(aCallbackThread) {
   nsresult rv;
   mStsThread = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
   if (!mStsThread) {
@@ -284,18 +295,17 @@
   return NS_OK;
 }
 
-nsresult MediaTransportHandlerSTS::Init(
-    const std::string& aName, const nsTArray<dom::RTCIceServer>& aIceServers,
-    dom::RTCIceTransportPolicy aIcePolicy) {
-  std::vector<NrIceStunServer> stunServers;
-  std::vector<NrIceTurnServer> turnServers;
-
-  nsresult rv;
+/* static */
+nsresult MediaTransportHandler::ConvertIceServers(
+    const nsTArray<dom::RTCIceServer>& aIceServers,
+    std::vector<NrIceStunServer>* aStunServers,
+    std::vector<NrIceTurnServer>* aTurnServers) {
   for (const auto& iceServer : aIceServers) {
     NS_ENSURE_STATE(iceServer.mUrls.WasPassed());
     NS_ENSURE_STATE(iceServer.mUrls.Value().IsStringSequence());
     for (const auto& iceUrl : iceServer.mUrls.Value().GetAsStringSequence()) {
-      rv = addNrIceServer(iceUrl, iceServer, &stunServers, &turnServers);
+      nsresult rv =
+          addNrIceServer(iceUrl, iceServer, aStunServers, aTurnServers);
       if (NS_FAILED(rv)) {
         CSFLogError(LOGTAG, "%s: invalid STUN/TURN server: %s", __FUNCTION__,
                     NS_ConvertUTF16toUTF8(iceUrl).get());
@@ -304,6 +314,19 @@
     }
   }
 
+  return NS_OK;
+}
+
+nsresult MediaTransportHandlerSTS::CreateIceCtx(
+    const std::string& aName, const nsTArray<dom::RTCIceServer>& aIceServers,
+    dom::RTCIceTransportPolicy aIcePolicy) {
+  std::vector<NrIceStunServer> stunServers;
+  std::vector<NrIceTurnServer> turnServers;
+  nsresult rv = ConvertIceServers(aIceServers, &stunServers, &turnServers);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
   // This stuff will probably live on the other side of IPC; errors down here
   // will either need to be ignored, or plumbed back in some way other than
   // the return.
@@ -357,6 +380,13 @@
 }
 
 void MediaTransportHandlerSTS::Destroy() {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                                      &MediaTransportHandlerSTS::Destroy),
+                         NS_DISPATCH_NORMAL);
+    return;
+  }
+
   disconnect_all();
   if (mIceCtx) {
     NrIceStats stats = mIceCtx->Destroy();
@@ -381,12 +411,28 @@
 
 void MediaTransportHandlerSTS::SetProxyServer(
     NrSocketProxyConfig&& aProxyConfig) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(NewRunnableMethod<NrSocketProxyConfig&&>(
+        __func__, this, &MediaTransportHandlerSTS::SetProxyServer,
+        std::move(aProxyConfig)));
+    return;
+  }
+
   mIceCtx->SetProxyServer(std::move(aProxyConfig));
 }
 
 void MediaTransportHandlerSTS::EnsureProvisionalTransport(
     const std::string& aTransportId, const std::string& aUfrag,
     const std::string& aPwd, size_t aComponentCount) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::EnsureProvisionalTransport,
+                     aTransportId, aUfrag, aPwd, aComponentCount),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   RefPtr<NrIceMediaStream> stream(mIceCtx->GetStream(aTransportId));
   if (!stream) {
     CSFLogDebug(LOGTAG, "%s: Creating ICE media stream=%s components=%u",
@@ -420,6 +466,17 @@
     const nsTArray<uint8_t>& aKeyDer, const nsTArray<uint8_t>& aCertDer,
     SSLKEAType aAuthType, bool aDtlsClient, const DtlsDigestList& aDigests,
     bool aPrivacyRequested) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::ActivateTransport, aTransportId,
+                     aLocalUfrag, aLocalPwd, aComponentCount, aUfrag, aPassword,
+                     aKeyDer, aCertDer, aAuthType, aDtlsClient, aDigests,
+                     aPrivacyRequested),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   MOZ_ASSERT(aComponentCount);
   RefPtr<DtlsIdentity> dtlsIdentity(
       DtlsIdentity::Deserialize(aKeyDer, aCertDer, aAuthType));
@@ -494,6 +551,15 @@
 
 void MediaTransportHandlerSTS::StartIceGathering(
     bool aDefaultRouteOnly, const nsTArray<NrIceStunAddr>& aStunAddrs) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::StartIceGathering,
+                     aDefaultRouteOnly, aStunAddrs),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   // Belt and suspenders - in e10s mode, the call below to SetStunAddrs
   // needs to have the proper flags set on ice ctx.  For non-e10s,
   // setting those flags happens in StartGathering.  We could probably
@@ -517,12 +583,20 @@
   // If there are no streams, we're probably in a situation where we've rolled
   // back while still waiting for our proxy configuration to come back. Make
   // sure content knows that the rollback has stuck wrt gathering.
-  SignalGatheringStateChange(dom::PCImplIceGatheringState::Complete);
+  OnGatheringStateChange(dom::PCImplIceGatheringState::Complete);
 }
 
 void MediaTransportHandlerSTS::StartIceChecks(
     bool aIsControlling, bool aIsOfferer,
     const std::vector<std::string>& aIceOptions) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                                      &MediaTransportHandlerSTS::StartIceChecks,
+                                      aIsControlling, aIsOfferer, aIceOptions),
+                         NS_DISPATCH_NORMAL);
+    return;
+  }
+
   nsresult rv = mIceCtx->ParseGlobalAttributes(aIceOptions);
   if (NS_FAILED(rv)) {
     CSFLogError(LOGTAG, "%s: couldn't parse global parameters", __FUNCTION__);
@@ -546,6 +620,15 @@
 
 void MediaTransportHandlerSTS::AddIceCandidate(const std::string& aTransportId,
                                                const std::string& aCandidate) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::AddIceCandidate, aTransportId,
+                     aCandidate),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   RefPtr<NrIceMediaStream> stream(mIceCtx->GetStream(aTransportId));
   if (!stream) {
     CSFLogError(LOGTAG, "No ICE stream for candidate with transport id %s: %s",
@@ -563,16 +646,33 @@
 }
 
 void MediaTransportHandlerSTS::UpdateNetworkState(bool aOnline) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::UpdateNetworkState, aOnline),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   mIceCtx->UpdateNetworkState(aOnline);
 }
 
 void MediaTransportHandlerSTS::RemoveTransportsExcept(
     const std::set<std::string>& aTransportIds) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::RemoveTransportsExcept,
+                     aTransportIds),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   for (auto it = mTransports.begin(); it != mTransports.end();) {
     if (!aTransportIds.count(it->first)) {
       if (it->second.mFlow) {
-        SignalStateChange(it->first, TransportLayer::TS_NONE);
-        SignalRtcpStateChange(it->first, TransportLayer::TS_NONE);
+        OnStateChange(it->first, TransportLayer::TS_NONE);
+        OnRtcpStateChange(it->first, TransportLayer::TS_NONE);
       }
       mIceCtx->DestroyStream(it->first);
       it = mTransports.erase(it);
@@ -585,6 +685,13 @@
 
 void MediaTransportHandlerSTS::SendPacket(const std::string& aTransportId,
                                           MediaPacket&& aPacket) {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(NewRunnableMethod<std::string, MediaPacket&&>(
+        __func__, this, &MediaTransportHandlerSTS::SendPacket, aTransportId,
+        std::move(aPacket)));
+    return;
+  }
+
   MOZ_ASSERT(aPacket.type() != MediaPacket::UNCLASSIFIED);
   RefPtr<TransportFlow> flow =
       GetTransportFlow(aTransportId, aPacket.type() == MediaPacket::RTCP);
@@ -620,45 +727,191 @@
   }
 }
 
-TransportLayer::State MediaTransportHandlerSTS::GetState(
+TransportLayer::State MediaTransportHandler::GetState(
     const std::string& aTransportId, bool aRtcp) const {
   // TODO Bug 1520692: we should allow Datachannel to connect without
   // DTLS SRTP keys
-  RefPtr<TransportFlow> flow = GetTransportFlow(aTransportId, aRtcp);
-  if (flow) {
-    return flow->GetLayer(TransportLayerDtls::ID())->state();
+  if (mCallbackThread) {
+    MOZ_ASSERT(mCallbackThread->IsOnCurrentThread());
+  }
+
+  const std::map<std::string, TransportLayer::State>* cache = nullptr;
+  if (aRtcp) {
+    cache = &mRtcpStateCache;
+  } else {
+    cache = &mStateCache;
+  }
+
+  auto it = cache->find(aTransportId);
+  if (it != cache->end()) {
+    return it->second;
   }
   return TransportLayer::TS_NONE;
 }
 
+void MediaTransportHandler::OnCandidate(const std::string& aTransportId,
+                                        const CandidateInfo& aCandidateInfo) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                                           &MediaTransportHandler::OnCandidate,
+                                           aTransportId, aCandidateInfo),
+                              NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalCandidate(aTransportId, aCandidateInfo);
+}
+
+void MediaTransportHandler::OnAlpnNegotiated(const std::string& aAlpn) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnAlpnNegotiated, aAlpn),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalAlpnNegotiated(aAlpn);
+}
+
+void MediaTransportHandler::OnGatheringStateChange(
+    dom::PCImplIceGatheringState aState) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnGatheringStateChange, aState),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalGatheringStateChange(aState);
+}
+
+void MediaTransportHandler::OnConnectionStateChange(
+    dom::PCImplIceConnectionState aState) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnConnectionStateChange, aState),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalConnectionStateChange(aState);
+}
+
+void MediaTransportHandler::OnPacketReceived(const std::string& aTransportId,
+                                             MediaPacket& aPacket) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnPacketReceived, aTransportId,
+                     aPacket),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalPacketReceived(aTransportId, aPacket);
+}
+
+void MediaTransportHandler::OnEncryptedSending(const std::string& aTransportId,
+                                               MediaPacket& aPacket) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnEncryptedSending, aTransportId,
+                     aPacket),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  SignalEncryptedSending(aTransportId, aPacket);
+}
+
+void MediaTransportHandler::OnStateChange(const std::string& aTransportId,
+                                          TransportLayer::State aState) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnStateChange, aTransportId,
+                     aState),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  if (aState == TransportLayer::TS_NONE) {
+    mStateCache.erase(aTransportId);
+  } else {
+    mStateCache[aTransportId] = aState;
+  }
+  SignalStateChange(aTransportId, aState);
+}
+
+void MediaTransportHandler::OnRtcpStateChange(const std::string& aTransportId,
+                                              TransportLayer::State aState) {
+  if (mCallbackThread && !mCallbackThread->IsOnCurrentThread()) {
+    mCallbackThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandler>(this),
+                     &MediaTransportHandler::OnRtcpStateChange, aTransportId,
+                     aState),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
+  if (aState == TransportLayer::TS_NONE) {
+    mRtcpStateCache.erase(aTransportId);
+  } else {
+    mRtcpStateCache[aTransportId] = aState;
+  }
+  SignalRtcpStateChange(aTransportId, aState);
+}
+
 RefPtr<MediaTransportHandler::StatsPromise>
 MediaTransportHandlerSTS::GetIceStats(
     const std::string& aTransportId, DOMHighResTimeStamp aNow,
     std::unique_ptr<dom::RTCStatsReportInternal>&& aReport) {
-  for (const auto& stream : mIceCtx->GetStreams()) {
-    if (aTransportId.empty() || aTransportId == stream->GetId()) {
-      GetIceStats(*stream, aNow, aReport.get());
-    }
-  }
-  return StatsPromise::CreateAndResolve(std::move(aReport), __func__);
+  return InvokeAsync(
+      mStsThread, __func__,
+      [=, aReport = std::move(aReport),
+       self = RefPtr<MediaTransportHandlerSTS>(this)]() mutable {
+        if (mIceCtx) {
+          for (const auto& stream : mIceCtx->GetStreams()) {
+            if (aTransportId.empty() || aTransportId == stream->GetId()) {
+              GetIceStats(*stream, aNow, aReport.get());
+            }
+          }
+        }
+        return StatsPromise::CreateAndResolve(std::move(aReport), __func__);
+      });
 }
 
 RefPtr<MediaTransportHandler::IceLogPromise>
 MediaTransportHandlerSTS::GetIceLog(const nsCString& aPattern) {
-  RLogConnector* logs = RLogConnector::GetInstance();
-  nsAutoPtr<std::deque<std::string>> result(new std::deque<std::string>);
-  // Might not exist yet.
-  if (logs) {
-    logs->Filter(aPattern.get(), 0, result);
-  }
-  dom::Sequence<nsString> converted;
-  for (auto& line : *result) {
-    converted.AppendElement(NS_ConvertUTF8toUTF16(line.c_str()), fallible);
-  }
-  return IceLogPromise::CreateAndResolve(std::move(converted), __func__);
+  return InvokeAsync(
+      mStsThread, __func__, [=, self = RefPtr<MediaTransportHandlerSTS>(this)] {
+        dom::Sequence<nsString> converted;
+        RLogConnector* logs = RLogConnector::GetInstance();
+        nsAutoPtr<std::deque<std::string>> result(new std::deque<std::string>);
+        // Might not exist yet.
+        if (logs) {
+          logs->Filter(aPattern.get(), 0, result);
+        }
+        for (auto& line : *result) {
+          converted.AppendElement(NS_ConvertUTF8toUTF16(line.c_str()),
+                                  fallible);
+        }
+        return IceLogPromise::CreateAndResolve(std::move(converted), __func__);
+      });
 }
 
 void MediaTransportHandlerSTS::ClearIceLog() {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                                      &MediaTransportHandlerSTS::ClearIceLog),
+                         NS_DISPATCH_NORMAL);
+    return;
+  }
+
   RLogConnector* logs = RLogConnector::GetInstance();
   if (logs) {
     logs->Clear();
@@ -666,10 +919,26 @@
 }
 
 void MediaTransportHandlerSTS::EnterPrivateMode() {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::EnterPrivateMode),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   RLogConnector::CreateInstance()->EnterPrivateMode();
 }
 
 void MediaTransportHandlerSTS::ExitPrivateMode() {
+  if (!mStsThread->IsOnCurrentThread()) {
+    mStsThread->Dispatch(
+        WrapRunnable(RefPtr<MediaTransportHandlerSTS>(this),
+                     &MediaTransportHandlerSTS::ExitPrivateMode),
+        NS_DISPATCH_NORMAL);
+    return;
+  }
+
   auto* log = RLogConnector::GetInstance();
   MOZ_ASSERT(log);
   if (log) {
@@ -712,6 +981,8 @@
 void MediaTransportHandlerSTS::GetIceStats(
     const NrIceMediaStream& aStream, DOMHighResTimeStamp aNow,
     dom::RTCStatsReportInternal* aReport) const {
+  MOZ_ASSERT(mStsThread->IsOnCurrentThread());
+
   NS_ConvertASCIItoUTF16 transportId(aStream.GetId().c_str());
 
   std::vector<NrIceCandidatePair> candPairs;
@@ -877,7 +1148,7 @@
       OnCandidateFound(stream, "");
     }
   }
-  SignalGatheringStateChange(toDomIceGatheringState(aState));
+  OnGatheringStateChange(toDomIceGatheringState(aState));
 }
 
 static mozilla::dom::PCImplIceConnectionState toDomIceConnectionState(
@@ -903,7 +1174,7 @@
 
 void MediaTransportHandlerSTS::OnConnectionStateChange(
     NrIceCtx* aIceCtx, NrIceCtx::ConnectionState aState) {
-  SignalConnectionStateChange(toDomIceConnectionState(aState));
+  OnConnectionStateChange(toDomIceConnectionState(aState));
 }
 
 // The stuff below here will eventually go into the MediaTransportChild class
@@ -931,7 +1202,7 @@
     info.mDefaultPortRtcp = defaultRtcpCandidate.cand_addr.port;
   }
 
-  SignalCandidate(aStream->GetId(), info);
+  OnCandidate(aStream->GetId(), info);
 }
 
 void MediaTransportHandlerSTS::OnStateChange(TransportLayer* aLayer,
@@ -939,36 +1210,26 @@
   if (aState == TransportLayer::TS_OPEN) {
     MOZ_ASSERT(aLayer->id() == TransportLayerDtls::ID());
     TransportLayerDtls* dtlsLayer = static_cast<TransportLayerDtls*>(aLayer);
-    SignalAlpnNegotiated(dtlsLayer->GetNegotiatedAlpn());
+    OnAlpnNegotiated(dtlsLayer->GetNegotiatedAlpn());
   }
 
   // DTLS state indicates the readiness of the transport as a whole, because
   // SRTP uses the keys from the DTLS handshake.
-  if (aState == TransportLayer::TS_NONE) {
-    mStateCache.erase(aLayer->flow_id());
-  } else {
-    mStateCache[aLayer->flow_id()] = aState;
-  }
-  SignalStateChange(aLayer->flow_id(), aState);
+  MediaTransportHandler::OnStateChange(aLayer->flow_id(), aState);
 }
 
 void MediaTransportHandlerSTS::OnRtcpStateChange(TransportLayer* aLayer,
                                                  TransportLayer::State aState) {
-  if (aState == TransportLayer::TS_NONE) {
-    mRtcpStateCache.erase(aLayer->flow_id());
-  } else {
-    mRtcpStateCache[aLayer->flow_id()] = aState;
-  }
-  SignalRtcpStateChange(aLayer->flow_id(), aState);
+  MediaTransportHandler::OnRtcpStateChange(aLayer->flow_id(), aState);
 }
 
 void MediaTransportHandlerSTS::PacketReceived(TransportLayer* aLayer,
                                               MediaPacket& aPacket) {
-  SignalPacketReceived(aLayer->flow_id(), aPacket);
+  OnPacketReceived(aLayer->flow_id(), aPacket);
 }
 
 void MediaTransportHandlerSTS::EncryptedPacketSending(TransportLayer* aLayer,
                                                       MediaPacket& aPacket) {
-  SignalEncryptedSending(aLayer->flow_id(), aPacket);
+  OnEncryptedSending(aLayer->flow_id(), aPacket);
 }
 }  // namespace mozilla