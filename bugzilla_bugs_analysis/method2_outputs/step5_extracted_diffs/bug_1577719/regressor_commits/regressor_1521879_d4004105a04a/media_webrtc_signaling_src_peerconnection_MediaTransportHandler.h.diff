# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/peerconnection/MediaTransportHandler.h
# Commit: d4004105a04a
# Full Hash: d4004105a04ad9a473930acb9c6a05d90cd9f028
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2019-02-23 04:13:22
# Regressor Bug: 1521879
# File Overlap Count: 1
# Description:
#   Bug 1521879 - Part 1: IPC-based MediaTransport implementation r=mjf
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D17273
# ==============================================================================

diff -r baecf588657c -r d4004105a04a media/webrtc/signaling/src/peerconnection/MediaTransportHandler.h
--- a/media/webrtc/signaling/src/peerconnection/MediaTransportHandler.h	Thu Feb 21 23:16:40 2019 +0000
+++ b/media/webrtc/signaling/src/peerconnection/MediaTransportHandler.h	Thu Feb 21 20:24:54 2019 +0000
@@ -15,6 +15,7 @@
 #include "nricectx.h"               // Need some enums
 #include "nsDOMNavigationTiming.h"  // DOMHighResTimeStamp
 #include "signaling/src/common/CandidateInfo.h"
+#include "nr_socket_proxy_config.h"
 
 #include "nsString.h"
 
@@ -37,8 +38,20 @@
 class MediaTransportHandler {
  public:
   // Creates either a MediaTransportHandlerSTS or a MediaTransportHandlerIPC,
-  // as appropriate.
-  static already_AddRefed<MediaTransportHandler> Create();
+  // as appropriate. If you want signals to fire on a specific thread, pass
+  // the event target here, otherwise they will fire on whatever is convenient.
+  // Note: This also determines what thread the state cache is updated on!
+  // Don't call GetState on any other thread!
+  static already_AddRefed<MediaTransportHandler> Create(
+      nsISerialEventTarget* aCallbackThread);
+
+  explicit MediaTransportHandler(nsISerialEventTarget* aCallbackThread)
+      : mCallbackThread(aCallbackThread) {}
+
+  static nsresult ConvertIceServers(
+      const nsTArray<dom::RTCIceServer>& aIceServers,
+      std::vector<NrIceStunServer>* aStunServers,
+      std::vector<NrIceTurnServer>* aTurnServers);
 
   typedef MozPromise<dom::Sequence<nsString>, nsresult, true> IceLogPromise;
 
@@ -50,11 +63,12 @@
   virtual void EnterPrivateMode() = 0;
   virtual void ExitPrivateMode() = 0;
 
-  virtual nsresult Init(const std::string& aName,
-                        const nsTArray<dom::RTCIceServer>& aIceServers,
-                        dom::RTCIceTransportPolicy aIcePolicy) = 0;
   virtual void Destroy() = 0;
 
+  virtual nsresult CreateIceCtx(const std::string& aName,
+                                const nsTArray<dom::RTCIceServer>& aIceServers,
+                                dom::RTCIceTransportPolicy aIcePolicy) = 0;
+
   // We will probably be able to move the proxy lookup stuff into
   // this class once we move mtransport to its own process.
   virtual void SetProxyServer(NrSocketProxyConfig&& aProxyConfig) = 0;
@@ -95,9 +109,6 @@
 
   virtual void UpdateNetworkState(bool aOnline) = 0;
 
-  virtual TransportLayer::State GetState(const std::string& aTransportId,
-                                         bool aRtcp) const = 0;
-
   // dom::RTCStatsReportInternal doesn't have move semantics.
   typedef MozPromise<std::unique_ptr<dom::RTCStatsReportInternal>, nsresult,
                      true>
@@ -118,8 +129,26 @@
       SignalRtcpStateChange;
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaTransportHandler)
 
+  TransportLayer::State GetState(const std::string& aTransportId,
+                                 bool aRtcp) const;
+
  protected:
+  void OnCandidate(const std::string& aTransportId,
+                   const CandidateInfo& aCandidateInfo);
+  void OnAlpnNegotiated(const std::string& aAlpn);
+  void OnGatheringStateChange(dom::PCImplIceGatheringState aState);
+  void OnConnectionStateChange(dom::PCImplIceConnectionState aState);
+  void OnPacketReceived(const std::string& aTransportId, MediaPacket& aPacket);
+  void OnEncryptedSending(const std::string& aTransportId,
+                          MediaPacket& aPacket);
+  void OnStateChange(const std::string& aTransportId,
+                     TransportLayer::State aState);
+  void OnRtcpStateChange(const std::string& aTransportId,
+                         TransportLayer::State aState);
   virtual ~MediaTransportHandler() = default;
+  std::map<std::string, TransportLayer::State> mStateCache;
+  std::map<std::string, TransportLayer::State> mRtcpStateCache;
+  RefPtr<nsISerialEventTarget> mCallbackThread;
 };
 
 }  // namespace mozilla