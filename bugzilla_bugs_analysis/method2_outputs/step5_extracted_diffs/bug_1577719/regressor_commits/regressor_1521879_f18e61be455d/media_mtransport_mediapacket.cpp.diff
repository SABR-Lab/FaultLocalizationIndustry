# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/mtransport/mediapacket.cpp
# Commit: f18e61be455d
# Full Hash: f18e61be455d493f10a2cc651cd254859894e02e
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2019-02-26 03:52:35
# Regressor Bug: 1521879
# File Overlap Count: 1
# Description:
#   Bug 1521879 - Part 1: IPC-based MediaTransport implementation r=mjf
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D17273
# ==============================================================================

diff -r 8136a17fbec9 -r f18e61be455d media/mtransport/mediapacket.cpp
--- a/media/mtransport/mediapacket.cpp	Mon Feb 25 21:48:20 2019 +0000
+++ b/media/mtransport/mediapacket.cpp	Mon Feb 25 21:50:42 2019 +0000
@@ -7,9 +7,15 @@
 #include "mediapacket.h"
 
 #include <cstring>
+#include "ipc/IPCMessageUtils.h"
 
 namespace mozilla {
 
+MediaPacket::MediaPacket(const MediaPacket& orig)
+    : sdp_level_(orig.sdp_level_), type_(orig.type_) {
+  Copy(orig.data(), orig.len(), orig.capacity_);
+}
+
 void MediaPacket::Copy(const uint8_t* data, size_t len, size_t capacity) {
   if (capacity < len) {
     capacity = len;
@@ -20,6 +26,70 @@
   memcpy(data_.get(), data, len);
 }
 
+void MediaPacket::Serialize(IPC::Message* aMsg) const {
+  aMsg->WriteSize(len_);
+  aMsg->WriteSize(capacity_);
+  if (len_) {
+    aMsg->WriteBytes(data_.get(), len_);
+  }
+  aMsg->WriteSize(encrypted_len_);
+  if (encrypted_len_) {
+    aMsg->WriteBytes(encrypted_data_.get(), encrypted_len_);
+  }
+  aMsg->WriteInt32(sdp_level_.isSome() ? *sdp_level_ : -1);
+  aMsg->WriteInt32(type_);
+}
+
+bool MediaPacket::Deserialize(const IPC::Message* aMsg, PickleIterator* aIter) {
+  Reset();
+  size_t len;
+  if (!aMsg->ReadSize(aIter, &len)) {
+    return false;
+  }
+  size_t capacity;
+  if (!aMsg->ReadSize(aIter, &capacity)) {
+    return false;
+  }
+  if (len) {
+    MOZ_RELEASE_ASSERT(capacity >= len);
+    UniquePtr<uint8_t[]> data(new uint8_t[capacity]);
+    if (!aMsg->ReadBytesInto(aIter, data.get(), len)) {
+      return false;
+    }
+    data_ = std::move(data);
+    len_ = len;
+    capacity_ = capacity;
+  }
+
+  if (!aMsg->ReadSize(aIter, &len)) {
+    return false;
+  }
+  if (len) {
+    UniquePtr<uint8_t[]> data(new uint8_t[len]);
+    if (!aMsg->ReadBytesInto(aIter, data.get(), len)) {
+      return false;
+    }
+    encrypted_data_ = std::move(data);
+    encrypted_len_ = len;
+  }
+
+  int32_t sdp_level;
+  if (!aMsg->ReadInt32(aIter, &sdp_level)) {
+    return false;
+  }
+
+  if (sdp_level >= 0) {
+    sdp_level_ = Some(sdp_level);
+  }
+
+  int32_t type;
+  if (!aMsg->ReadInt32(aIter, &type)) {
+    return false;
+  }
+  type_ = static_cast<Type>(type);
+  return true;
+}
+
 static bool IsRtp(const uint8_t* data, size_t len) {
   if (len < 2) return false;
 