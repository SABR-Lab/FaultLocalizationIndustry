# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/clients/manager/ClientHandleOpParent.cpp
# Commit: 6125bb02952a
# Full Hash: 6125bb02952aff71c0d757e238a7752101b2d6c2
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2019-09-03 04:06:20
# Regressor Bug: 1556489
# File Overlap Count: 1
# Description:
#   Bug 1556489 - P23 - Only create new ClientSource objects in the content, but use the recreated info from redirects in the parent. r=asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D42260
# ==============================================================================

diff -r 06529d12b589 -r 6125bb02952a dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp	Mon Aug 26 12:18:57 2019 +1000
+++ b/dom/clients/manager/ClientHandleOpParent.cpp	Tue Aug 27 08:53:37 2019 +1000
@@ -20,59 +20,71 @@
 
 void ClientHandleOpParent::ActorDestroy(ActorDestroyReason aReason) {
   mPromiseRequestHolder.DisconnectIfExists();
+  mSourcePromiseRequestHolder.DisconnectIfExists();
 }
 
 void ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs) {
-  ClientSourceParent* source = GetSource();
-  if (!source) {
-    Unused << PClientHandleOpParent::Send__delete__(this,
-                                                    NS_ERROR_DOM_ABORT_ERR);
-    return;
-  }
-
-  RefPtr<ClientOpPromise> p;
+  auto handle = static_cast<ClientHandleParent*>(Manager());
+  handle->EnsureSource()
+      ->Then(
+          GetCurrentThreadSerialEventTarget(), __func__,
+          [=](ClientSourceParent* source) {
+            mSourcePromiseRequestHolder.Complete();
+            RefPtr<ClientOpPromise> p;
 
-  // ClientPostMessageArgs can contain PBlob actors.  This means we
-  // can't just forward the args from one PBackground manager to
-  // another.  Instead, unpack the structured clone data and repack
-  // it into a new set of arguments.
-  if (aArgs.type() == ClientOpConstructorArgs::TClientPostMessageArgs) {
-    const ClientPostMessageArgs& orig = aArgs.get_ClientPostMessageArgs();
+            // ClientPostMessageArgs can contain PBlob actors.  This means we
+            // can't just forward the args from one PBackground manager to
+            // another.  Instead, unpack the structured clone data and repack
+            // it into a new set of arguments.
+            if (aArgs.type() ==
+                ClientOpConstructorArgs::TClientPostMessageArgs) {
+              const ClientPostMessageArgs& orig =
+                  aArgs.get_ClientPostMessageArgs();
 
-    ClientPostMessageArgs rebuild;
-    rebuild.serviceWorker() = orig.serviceWorker();
+              ClientPostMessageArgs rebuild;
+              rebuild.serviceWorker() = orig.serviceWorker();
+
+              StructuredCloneData data;
+              data.BorrowFromClonedMessageDataForBackgroundParent(
+                  orig.clonedData());
+              if (!data.BuildClonedMessageDataForBackgroundParent(
+                      source->Manager()->Manager(), rebuild.clonedData())) {
+                Unused << PClientHandleOpParent::Send__delete__(
+                    this, NS_ERROR_DOM_ABORT_ERR);
+                return;
+              }
 
-    StructuredCloneData data;
-    data.BorrowFromClonedMessageDataForBackgroundParent(orig.clonedData());
-    if (!data.BuildClonedMessageDataForBackgroundParent(
-            source->Manager()->Manager(), rebuild.clonedData())) {
-      Unused << PClientHandleOpParent::Send__delete__(this,
-                                                      NS_ERROR_DOM_ABORT_ERR);
-      return;
-    }
+              p = source->StartOp(rebuild);
+            }
 
-    p = source->StartOp(rebuild);
-  }
+            // Other argument types can just be forwarded straight through.
+            else {
+              p = source->StartOp(aArgs);
+            }
 
-  // Other argument types can just be forwarded straight through.
-  else {
-    p = source->StartOp(aArgs);
-  }
-
-  // Capturing 'this' is safe here because we disconnect the promise in
-  // ActorDestroy() which ensures neither lambda is called if the actor
-  // is destroyed before the source operation completes.
-  p->Then(
-       GetCurrentThreadSerialEventTarget(), __func__,
-       [this](const ClientOpResult& aResult) {
-         mPromiseRequestHolder.Complete();
-         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
-       },
-       [this](nsresult aRv) {
-         mPromiseRequestHolder.Complete();
-         Unused << PClientHandleOpParent::Send__delete__(this, aRv);
-       })
-      ->Track(mPromiseRequestHolder);
+            // Capturing 'this' is safe here because we disconnect the promise
+            // in ActorDestroy() which ensures neither lambda is called if the
+            // actor is destroyed before the source operation completes.
+            p->Then(
+                 GetCurrentThreadSerialEventTarget(), __func__,
+                 [this](const ClientOpResult& aResult) {
+                   mPromiseRequestHolder.Complete();
+                   Unused << PClientHandleOpParent::Send__delete__(this,
+                                                                   aResult);
+                 },
+                 [this](nsresult aRv) {
+                   mPromiseRequestHolder.Complete();
+                   Unused << PClientHandleOpParent::Send__delete__(this, aRv);
+                 })
+                ->Track(mPromiseRequestHolder);
+          },
+          [=](nsresult failure) {
+            mSourcePromiseRequestHolder.Complete();
+            Unused << PClientHandleOpParent::Send__delete__(
+                this, NS_ERROR_DOM_ABORT_ERR);
+            return;
+          })
+      ->Track(mSourcePromiseRequestHolder);
 }
 
 }  // namespace dom