# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/agnostic/bytestreams/H264.cpp
# Commit: a14b6849e7b7
# Full Hash: a14b6849e7b71c8ef260f8c4baacb7d9d52e6b3e
# Author: alwu <alwu@mozilla.com>
# Date: 2019-09-07 09:40:21
# Description:
#   Bug 1579136 - do not read content from null NAL. r=jya
#   
#   Dealing with a case where `DecodeNALUnit()` returns nullptr which we should not try to create bit reader and decode anything.
#   
#   In addition, wrap these logic to `DecodedISlice()` in order to keep consistent with a case where we decode SEI.
# ==============================================================================

diff -r 3f813fd91f92 -r a14b6849e7b7 dom/media/platforms/agnostic/bytestreams/H264.cpp
--- a/dom/media/platforms/agnostic/bytestreams/H264.cpp	Fri Sep 06 20:08:52 2019 +0000
+++ b/dom/media/platforms/agnostic/bytestreams/H264.cpp	Fri Sep 06 20:11:22 2019 +0000
@@ -985,16 +985,8 @@
         return FrameType::I_FRAME;
       }
     } else if (nalType == H264_NAL_SLICE) {
-      // According to ITU-T Rec H.264 Table 7.3.3, read the slice type from
-      // slice_header, and the slice type 2 and 7 are representing I slice.
       RefPtr<mozilla::MediaByteBuffer> decodedNAL = DecodeNALUnit(p, nalLen);
-      BitReader br(decodedNAL);
-      // Skip `first_mb_in_slice`
-      br.ReadUE();
-      // The value of slice type can go from 0 to 9, but the value between 5 to
-      // 9 are actually equal to 0 to 4.
-      const uint32_t sliceType = br.ReadUE() % 5;
-      if (sliceType == SLICE_TYPES::I_SLICE || sliceType == SI_SLICE) {
+      if (DecodeISlice(decodedNAL)) {
         return FrameType::I_FRAME;
       }
     }
@@ -1188,6 +1180,23 @@
 }
 
 /* static */
+bool H264::DecodeISlice(const mozilla::MediaByteBuffer* aSlice) {
+  if (!aSlice) {
+    return false;
+  }
+
+  // According to ITU-T Rec H.264 Table 7.3.3, read the slice type from
+  // slice_header, and the slice type 2 and 7 are representing I slice.
+  BitReader br(aSlice);
+  // Skip `first_mb_in_slice`
+  br.ReadUE();
+  // The value of slice type can go from 0 to 9, but the value between 5 to
+  // 9 are actually equal to 0 to 4.
+  const uint32_t sliceType = br.ReadUE() % 5;
+  return sliceType == SLICE_TYPES::I_SLICE || sliceType == SI_SLICE;
+}
+
+/* static */
 bool H264::DecodeRecoverySEI(const mozilla::MediaByteBuffer* aSEI,
                              SEIRecoveryData& aDest) {
   if (!aSEI) {