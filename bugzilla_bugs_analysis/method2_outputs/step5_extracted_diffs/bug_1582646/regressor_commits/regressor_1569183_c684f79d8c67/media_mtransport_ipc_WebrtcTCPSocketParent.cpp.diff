# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/mtransport/ipc/WebrtcTCPSocketParent.cpp
# Commit: c684f79d8c67
# Full Hash: c684f79d8c673f21179fce00358d70845a9692c0
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2019-09-18 21:49:27
# Regressor Bug: 1569183
# File Overlap Count: 2
# Description:
#   Bug 1569183: Rename PWebrtcProxyChannel to PWebrtcTCPSocket. r=mjf
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D45098
# ==============================================================================

diff -r 82af7b115f60 -r c684f79d8c67 media/mtransport/ipc/WebrtcTCPSocketParent.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/mtransport/ipc/WebrtcTCPSocketParent.cpp	Tue Sep 17 18:15:41 2019 +0000
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WebrtcTCPSocketParent.h"
+
+#include "mozilla/net/NeckoParent.h"
+
+#include "WebrtcTCPSocket.h"
+#include "WebrtcTCPSocketLog.h"
+
+using namespace mozilla::dom;
+using namespace mozilla::ipc;
+
+namespace mozilla {
+namespace net {
+
+mozilla::ipc::IPCResult WebrtcTCPSocketParent::RecvAsyncOpen(
+    const nsCString& aHost, const int& aPort, const LoadInfoArgs& aLoadInfoArgs,
+    const nsCString& aAlpn) {
+  LOG(("WebrtcTCPSocketParent::RecvAsyncOpen %p to %s:%d\n", this, aHost.get(),
+       aPort));
+
+  MOZ_ASSERT(mChannel, "webrtc TCP socket should be non-null");
+  mChannel->Open(aHost, aPort, aLoadInfoArgs, aAlpn);
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult WebrtcTCPSocketParent::RecvWrite(
+    nsTArray<uint8_t>&& aWriteData) {
+  LOG(("WebrtcTCPSocketParent::RecvWrite %p for %zu\n", this,
+       aWriteData.Length()));
+
+  // Need to check this here in case there are Writes in the queue after OnClose
+  if (mChannel) {
+    mChannel->Write(std::move(aWriteData));
+  }
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult WebrtcTCPSocketParent::RecvClose() {
+  LOG(("WebrtcTCPSocketParent::RecvClose %p\n", this));
+
+  CleanupChannel();
+
+  IProtocol* mgr = Manager();
+  if (!Send__delete__(this)) {
+    return IPC_FAIL_NO_REASON(mgr);
+  }
+
+  return IPC_OK();
+}
+
+void WebrtcTCPSocketParent::ActorDestroy(ActorDestroyReason aWhy) {
+  LOG(("WebrtcTCPSocketParent::ActorDestroy %p for %d\n", this, aWhy));
+
+  CleanupChannel();
+}
+
+WebrtcTCPSocketParent::WebrtcTCPSocketParent(dom::TabId aTabId) {
+  MOZ_COUNT_CTOR(WebrtcTCPSocketParent);
+
+  LOG(("WebrtcTCPSocketParent::WebrtcTCPSocketParent %p\n", this));
+
+  mChannel = new WebrtcTCPSocket(this);
+  mChannel->SetTabId(aTabId);
+}
+
+WebrtcTCPSocketParent::~WebrtcTCPSocketParent() {
+  MOZ_COUNT_DTOR(WebrtcTCPSocketParent);
+
+  LOG(("WebrtcTCPSocketParent::~WebrtcTCPSocketParent %p\n", this));
+
+  CleanupChannel();
+}
+
+// WebrtcTCPSocketCallback
+void WebrtcTCPSocketParent::OnClose(nsresult aReason) {
+  LOG(("WebrtcTCPSocketParent::OnClose %p\n", this));
+
+  if (mChannel) {
+    Unused << SendOnClose(aReason);
+  }
+
+  CleanupChannel();
+}
+
+void WebrtcTCPSocketParent::OnRead(nsTArray<uint8_t>&& aReadData) {
+  LOG(("WebrtcTCPSocketParent::OnRead %p %zu\n", this, aReadData.Length()));
+
+  if (mChannel && !SendOnRead(std::move(aReadData))) {
+    CleanupChannel();
+  }
+}
+
+void WebrtcTCPSocketParent::OnConnected() {
+  LOG(("WebrtcTCPSocketParent::OnConnected %p\n", this));
+
+  if (mChannel && !SendOnConnected()) {
+    CleanupChannel();
+  }
+}
+
+void WebrtcTCPSocketParent::CleanupChannel() {
+  if (mChannel) {
+    mChannel->Close();
+    mChannel = nullptr;
+  }
+}
+
+}  // namespace net
+}  // namespace mozilla