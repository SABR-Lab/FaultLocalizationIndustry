# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/src/peerconnection/PeerConnectionMedia.cpp
# Commit: f5353ea9f1df
# Full Hash: f5353ea9f1dfe15a65076bc7aa272d688ebdb8ca
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2019-09-18 21:49:27
# Regressor Bug: 1569183
# File Overlap Count: 2
# Description:
#   Bug 1569183: Add a proxy policy argument to NrSocketProxyConfig, and always set this config on the NrIceCtx. r=mjf
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D45101
# ==============================================================================

diff -r ed1ae6a85255 -r f5353ea9f1df media/webrtc/signaling/src/peerconnection/PeerConnectionMedia.cpp
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionMedia.cpp	Tue Sep 17 18:17:13 2019 +0000
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionMedia.cpp	Tue Sep 17 18:17:14 2019 +0000
@@ -70,8 +70,8 @@
       mParentName(parent->GetName()),
       mMainThread(mParent->GetMainThread()),
       mSTSThread(mParent->GetSTSThread()),
-      mProxyResolveCompleted(false),
-      mProxyConfig(nullptr),
+      mWaitingOnProxyLookup(false),
+      mForceProxy(false),
       mStunAddrsRequest(nullptr),
       mLocalAddrsCompleted(false),
       mTargetForDefaultLocalAddressLookupIsSet(false),
@@ -108,13 +108,22 @@
 nsresult PeerConnectionMedia::InitProxy() {
   // Allow mochitests to disable this, since mochitest configures a fake proxy
   // that serves up content.
-  bool disable =
-      Preferences::GetBool("media.peerconnection.disable_http_proxy", false);
-  if (disable) {
-    mProxyResolveCompleted = true;
+  mForceProxy =
+      Preferences::GetBool("media.peerconnection.ice.proxy_only", false);
+  if (mForceProxy) {
+    // Matter is settled, we're done.
     return NS_OK;
   }
 
+  mWaitingOnProxyLookup = Preferences::GetBool(
+      "media.peerconnection.ice.proxy_only_if_behind_proxy", false);
+  if (!mWaitingOnProxyLookup) {
+    // We won't be forcing the use of a proxy.
+    return NS_OK;
+  }
+
+  // We have to determine if we're behind a proxy before we can decide whether
+  // to set mForceProxy.
   if (XRE_IsContentProcess()) {
     if (NS_WARN_IF(!net::gNeckoChild)) {
       return NS_ERROR_FAILURE;
@@ -141,7 +150,9 @@
 
 nsresult PeerConnectionMedia::Init() {
   nsresult rv = InitProxy();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
 
   // setup the stun local addresses IPC async call
   InitLocalAddrs();
@@ -415,14 +426,14 @@
 
 void PeerConnectionMedia::EnsureIceGathering(bool aDefaultRouteOnly,
                                              bool aObfuscateHostAddresses) {
-  if (mProxyConfig) {
+  auto proxyConfig = GetProxyConfig();
+  if (proxyConfig) {
     // Note that this could check if PrivacyRequested() is set on the PC and
     // remove "webrtc" from the ALPN list.  But that would only work if the PC
     // was constructed with a peerIdentity constraint, not when isolated
     // streams are added.  If we ever need to signal to the proxy that the
     // media is isolated, then we would need to restructure this code.
-    mTransportHandler->SetProxyConfig(std::move(*mProxyConfig));
-    mProxyConfig.reset();
+    mTransportHandler->SetProxyConfig(std::move(*proxyConfig));
   }
 
   if (!mTargetForDefaultLocalAddressLookupIsSet) {
@@ -759,24 +770,30 @@
     // PeerConnectionMedia is no longer waiting
     return;
   }
-
-  if (aProxied) {
-    SetProxy();
-  }
-
-  mProxyResolveCompleted = true;
+  mWaitingOnProxyLookup = false;
+  mForceProxy = aProxied;
   FlushIceCtxOperationQueueIfReady();
 }
 
-void PeerConnectionMedia::SetProxy() {
-  CSFLogInfo(LOGTAG, "%s: Had proxyinfo", __FUNCTION__);
+std::unique_ptr<NrSocketProxyConfig> PeerConnectionMedia::GetProxyConfig()
+    const {
   MOZ_ASSERT(NS_IsMainThread());
 
+  NrSocketProxyConfig::ProxyPolicy proxyPolicy =
+      NrSocketProxyConfig::kEnableProxy;
+
+  if (mForceProxy) {
+    proxyPolicy = NrSocketProxyConfig::kForceProxy;
+  } else if (Preferences::GetBool("media.peerconnection.disable_http_proxy",
+                                  false)) {
+    proxyPolicy = NrSocketProxyConfig::kDisableProxy;
+  }
+
   nsCString alpn = NS_LITERAL_CSTRING("webrtc,c-webrtc");
   auto browserChild = BrowserChild::GetFrom(GetWindow());
   if (!browserChild) {
     // Android doesn't have browser child apparently...
-    return;
+    return nullptr;
   }
   TabId id = browserChild->GetTabId();
   nsCOMPtr<nsILoadInfo> loadInfo = new net::LoadInfo(
@@ -785,7 +802,8 @@
   Maybe<net::LoadInfoArgs> loadInfoArgs;
   MOZ_ALWAYS_SUCCEEDS(
       mozilla::ipc::LoadInfoToLoadInfoArgs(loadInfo, &loadInfoArgs));
-  mProxyConfig.reset(new NrSocketProxyConfig(id, alpn, *loadInfoArgs));
+  return std::unique_ptr<NrSocketProxyConfig>(
+      new NrSocketProxyConfig(id, alpn, *loadInfoArgs, proxyPolicy));
 }
 
 }  // namespace mozilla