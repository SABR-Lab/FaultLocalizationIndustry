# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/image.rs
# Commit: 32951c9cc186
# Full Hash: 32951c9cc186f044c7a59e0b132339139dfb9713
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2019-09-18 09:56:40
# Regressor Bug: 1570081
# File Overlap Count: 1
# Description:
#   Bug 1570081 - Support changing the blob image visible rect in WebRender. r=jrmuizel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D39911
# ==============================================================================

diff -r 37598891cea6 -r 32951c9cc186 gfx/wr/webrender/src/image.rs
--- a/gfx/wr/webrender/src/image.rs	Tue Sep 17 09:20:04 2019 +0000
+++ b/gfx/wr/webrender/src/image.rs	Tue Sep 17 09:12:26 2019 +0000
@@ -491,6 +491,37 @@
     )
 }
 
+pub fn compute_tile_rect(
+    image_rect: &DeviceIntRect,
+    regular_tile_size: TileSize,
+    tile: TileOffset,
+) -> DeviceIntRect {
+    let regular_tile_size = regular_tile_size as i32;
+    DeviceIntRect {
+        origin: point2(
+            compute_tile_origin_1d(image_rect.x_range(), regular_tile_size, tile.x as i32),
+            compute_tile_origin_1d(image_rect.y_range(), regular_tile_size, tile.y as i32),
+        ),
+        size: size2(
+            compute_tile_size_1d(image_rect.x_range(), regular_tile_size, tile.x as i32),
+            compute_tile_size_1d(image_rect.y_range(), regular_tile_size, tile.y as i32),
+        ),
+    }
+}
+
+fn compute_tile_origin_1d(
+    img_range: Range<i32>,
+    regular_tile_size: i32,
+    tile_offset: i32,
+) -> i32 {
+    let tile_range = tile_range_1d(&img_range, regular_tile_size);
+    if tile_offset == tile_range.start {
+        img_range.start
+    } else {
+        tile_offset * regular_tile_size
+    }
+}
+
 // Compute the width and height in pixels of a tile depending on its position in the image.
 pub fn compute_tile_size(
     image_rect: &DeviceIntRect,
@@ -551,6 +582,47 @@
     }
 }
 
+pub fn compute_valid_tiles_if_bounds_change(
+    prev_rect: &DeviceIntRect,
+    new_rect: &DeviceIntRect,
+    tile_size: u16,
+) -> Option<TileRange> {
+    let intersection = prev_rect.intersection(new_rect);
+
+    if intersection.is_none() {
+        return Some(TileRange::zero());
+    }
+
+    let intersection = intersection.unwrap_or(DeviceIntRect::zero());
+
+    let left = prev_rect.min_x() != new_rect.min_x();
+    let right = prev_rect.max_x() != new_rect.max_x();
+    let top = prev_rect.min_y() != new_rect.min_y();
+    let bottom = prev_rect.max_y() != new_rect.max_y();
+
+    if !left && !right && !top && !bottom {
+        // Bounds have not changed.
+        return None;
+    }
+
+    let tw = 1.0 / (tile_size as f32);
+    let th = 1.0 / (tile_size as f32);
+
+    let tiles = intersection
+        .cast::<f32>()
+        .scale(tw, th);
+
+    let min_x = if left { f32::ceil(tiles.min_x()) } else { f32::floor(tiles.min_x()) };
+    let min_y = if top { f32::ceil(tiles.min_y()) } else { f32::floor(tiles.min_y()) };
+    let max_x = if right { f32::floor(tiles.max_x()) } else { f32::ceil(tiles.max_x()) };
+    let max_y = if bottom { f32::floor(tiles.max_y()) } else { f32::ceil(tiles.max_y()) };
+
+    Some(TileRange {
+        origin: point2(min_x as i32, min_y as i32),
+        size: size2((max_x - min_x) as i32, (max_y - min_y) as i32),
+    })
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -714,4 +786,26 @@
         assert_eq!(result.first_tile_layout_size, 10.0);
         assert_eq!(result.last_tile_layout_size, 10.0);
     }
+
+    #[test]
+    fn smaller_than_tile_size_at_origin() {
+        let r = compute_tile_rect(
+            &rect(0, 0, 80, 80),
+            256,
+            point2(0, 0),
+        );
+
+        assert_eq!(r, rect(0, 0, 80, 80));
+    }
+
+    #[test]
+    fn smaller_than_tile_size_with_offset() {
+        let r = compute_tile_rect(
+            &rect(20, 20, 80, 80),
+            256,
+            point2(0, 0),
+        );
+
+        assert_eq!(r, rect(20, 20, 80, 80));
+    }
 }