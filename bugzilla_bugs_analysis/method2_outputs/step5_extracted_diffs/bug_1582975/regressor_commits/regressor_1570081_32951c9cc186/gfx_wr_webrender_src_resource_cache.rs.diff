# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/resource_cache.rs
# Commit: 32951c9cc186
# Full Hash: 32951c9cc186f044c7a59e0b132339139dfb9713
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2019-09-18 09:56:40
# Regressor Bug: 1570081
# File Overlap Count: 1
# Description:
#   Bug 1570081 - Support changing the blob image visible rect in WebRender. r=jrmuizel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D39911
# ==============================================================================

diff -r 37598891cea6 -r 32951c9cc186 gfx/wr/webrender/src/resource_cache.rs
--- a/gfx/wr/webrender/src/resource_cache.rs	Tue Sep 17 09:20:04 2019 +0000
+++ b/gfx/wr/webrender/src/resource_cache.rs	Tue Sep 17 09:12:26 2019 +0000
@@ -24,7 +24,8 @@
 use crate::glyph_rasterizer::{BaseFontInstance, FontInstance, GlyphFormat, GlyphKey, GlyphRasterizer};
 use crate::gpu_cache::{GpuCache, GpuCacheAddress, GpuCacheHandle};
 use crate::gpu_types::UvRectKind;
-use crate::image::{compute_tile_size, compute_tile_range, for_each_tile_in_range};
+use crate::image::{compute_tile_size, compute_tile_rect, compute_tile_range, for_each_tile_in_range};
+use crate::image::compute_valid_tiles_if_bounds_change;
 use crate::internal_types::{FastHashMap, FastHashSet, TextureSource, TextureUpdateList};
 use crate::profiler::{ResourceProfileCounters, TextureCacheProfileCounters};
 use crate::render_backend::{FrameId, FrameStamp};
@@ -143,6 +144,9 @@
     pub descriptor: ImageDescriptor,
     pub external_image: Option<ExternalImageData>,
     pub tiling: Option<TileSize>,
+    // Potentially a subset of the image's total rectangle. This rectangle is what
+    // we map to the (layout space) display item bounds.
+    pub visible_rect: DeviceIntRect,
 }
 
 #[derive(Debug, Copy, Clone, PartialEq)]
@@ -164,13 +168,24 @@
     descriptor: ImageDescriptor,
     tiling: Option<TileSize>,
     dirty_rect: BlobDirtyRect,
-    viewport_tiles: Option<TileRange>,
+    /// See ImageResource::visible_rect.
+    visible_rect: DeviceIntRect,
+    // If the active rect of the blob changes, this represents the
+    // range of tiles that remain valid. This must be taken into
+    // account in addition to the valid rect when submitting blob
+    // rasterization requests.
+    // `None` means the bounds have not changed (tiles are still valid).
+    // `Some(TileRange::zero())` means all of the tiles are invalid.
+    valid_tiles_after_bounds_change: Option<TileRange>,
 }
 
 struct ImageResource {
     data: CachedImageData,
     descriptor: ImageDescriptor,
     tiling: Option<TileSize>,
+    /// This is used to express images that are virtually very large
+    /// but with only a visible sub-set that is valid at a given time.
+    visible_rect: DeviceIntRect,
 }
 
 #[derive(Clone, Debug)]
@@ -586,7 +601,13 @@
                     if let ImageData::Raw(ref bytes) = img.data {
                         profile_counters.image_templates.inc(bytes.len());
                     }
-                    self.add_image_template(img.key, img.descriptor, img.data.into(), img.tiling);
+                    self.add_image_template(
+                        img.key,
+                        img.descriptor,
+                        img.data.into(),
+                        &img.descriptor.size.into(),
+                        img.tiling,
+                    );
                 }
                 ResourceUpdate::UpdateImage(img) => {
                     self.update_image_template(img.key, img.descriptor, img.data.into(), &img.dirty_rect);
@@ -596,6 +617,7 @@
                         img.key.as_image(),
                         img.descriptor,
                         CachedImageData::Blob,
+                        &img.visible_rect,
                         img.tiling,
                     );
                 }
@@ -608,7 +630,8 @@
                             &img.dirty_rect
                         ),
                     );
-                    self.discard_tiles_outside_visible_area(img.key, &img.visible_rect);
+                    self.discard_tiles_outside_visible_area(img.key, &img.visible_rect); // TODO: remove?
+                    self.set_image_visible_rect(img.key.as_image(), &img.visible_rect);
                 }
                 ResourceUpdate::DeleteImage(img) => {
                     self.delete_image_template(img);
@@ -621,6 +644,7 @@
                 }
                 ResourceUpdate::SetBlobImageVisibleArea(key, area) => {
                     self.discard_tiles_outside_visible_area(key, &area);
+                    self.set_image_visible_rect(key.as_image(), &area);
                 }
                 ResourceUpdate::AddFont(_) |
                 ResourceUpdate::AddFontInstance(_) => {
@@ -657,12 +681,7 @@
                 }
                 ResourceUpdate::SetBlobImageVisibleArea(ref key, ref area) => {
                     if let Some(template) = self.blob_image_templates.get_mut(&key) {
-                        if let Some(tile_size) = template.tiling {
-                            template.viewport_tiles = Some(compute_tile_range(
-                                &area,
-                                tile_size,
-                            ));
-                        }
+                        template.visible_rect = *area;
                     }
                 }
                 _ => {}
@@ -773,6 +792,20 @@
                 if let RasterizedBlob::Tiled(ref mut tiles) = *image {
                     tiles.insert(tile, data);
                 }
+
+                match self.cached_images.try_get_mut(&request.key.as_image()) {
+                    Some(&mut ImageResult::Multi(ref mut entries)) => {
+                        let cached_key = CachedImageKey {
+                            rendering: ImageRendering::Auto, // TODO(nical)
+                            tile: Some(tile),
+                        };
+                        if let Some(entry) = entries.try_get_mut(&cached_key) {
+                            entry.dirty_rect = DirtyRect::All;
+                        }
+                    }
+                    _ => {}
+                }
+
             } else {
                 if let RasterizedBlob::NonTiled(ref mut queue) = *image {
                     // If our new rasterized rect overwrites items in the queue, discard them.
@@ -862,6 +895,7 @@
         image_key: ImageKey,
         descriptor: ImageDescriptor,
         data: CachedImageData,
+        visible_rect: &DeviceIntRect,
         mut tiling: Option<TileSize>,
     ) {
         if tiling.is_none() && Self::should_tile(self.max_texture_size(), &descriptor, &data) {
@@ -874,6 +908,7 @@
             descriptor,
             data,
             tiling,
+            visible_rect: *visible_rect,
         };
 
         self.resources.image_templates.insert(image_key, resource);
@@ -941,6 +976,7 @@
             descriptor,
             data,
             tiling,
+            visible_rect: descriptor.size.into(),
         };
     }
 
@@ -956,8 +992,6 @@
         let max_texture_size = self.max_texture_size();
         tiling = get_blob_tiling(tiling, descriptor, max_texture_size);
 
-        let viewport_tiles = tiling.map(|tile_size| compute_tile_range(&visible_rect, tile_size));
-
         self.blob_image_handler.as_mut().unwrap().add(key, data, visible_rect, tiling);
 
         self.blob_image_templates.insert(
@@ -966,7 +1000,8 @@
                 descriptor: *descriptor,
                 tiling,
                 dirty_rect: DirtyRect::All,
-                viewport_tiles,
+                valid_tiles_after_bounds_change: None,
+                visible_rect: *visible_rect,
             },
         );
     }
@@ -990,13 +1025,32 @@
 
         let tiling = get_blob_tiling(image.tiling, descriptor, max_texture_size);
 
-        let viewport_tiles = image.tiling.map(|tile_size| compute_tile_range(&visible_rect, tile_size));
+        let mut valid_tiles_after_bounds_change = None;
+
+        if let Some(tile_size) = image.tiling {
+            valid_tiles_after_bounds_change = compute_valid_tiles_if_bounds_change(
+                &image.visible_rect,
+                visible_rect,
+                tile_size,
+            );
+        }
+
+        match (image.valid_tiles_after_bounds_change, valid_tiles_after_bounds_change) {
+            (Some(old), Some(ref mut new)) => {
+                *new = new.intersection(&old).unwrap_or(TileRange::zero());
+            }
+            (Some(old), None) => {
+                valid_tiles_after_bounds_change = Some(old);
+            }
+            _ => {}
+        }
 
         *image = BlobImageTemplate {
             descriptor: *descriptor,
             tiling,
             dirty_rect: dirty_rect.union(&image.dirty_rect),
-            viewport_tiles,
+            valid_tiles_after_bounds_change,
+            visible_rect: *visible_rect,
         };
     }
 
@@ -1166,14 +1220,11 @@
                     rect: match template.tiling {
                         Some(tile_size) => {
                             let tile = request.tile.unwrap();
-                            LayoutIntRect {
-                                origin: point2(tile.x, tile.y) * tile_size as i32,
-                                size: blob_size(compute_tile_size(
-                                    &template.descriptor.size.into(),
-                                    tile_size,
-                                    tile,
-                                )),
-                            }
+                            blob_rect(compute_tile_rect(
+                                &template.visible_rect,
+                                tile_size,
+                                tile,
+                            ))
                         }
                         None => blob_size(template.descriptor.size).into(),
                     },
@@ -1213,37 +1264,33 @@
             if let Some(tile_size) = template.tiling {
                 // If we know that only a portion of the blob image is in the viewport,
                 // only request these visible tiles since blob images can be huge.
-                let mut tiles = template.viewport_tiles.unwrap_or_else(|| {
-                    // Default to requesting the full range of tiles.
-                    compute_tile_range(
-                        &DeviceIntRect {
-                            origin: point2(0, 0),
-                            size: template.descriptor.size,
-                        },
-                        tile_size,
-                    )
-                });
+                let mut tiles = compute_tile_range(
+                    &template.visible_rect,
+                    tile_size,
+                );
 
                 let image_dirty_rect = to_image_dirty_rect(&template.dirty_rect);
                 // Don't request tiles that weren't invalidated.
-                if let DirtyRect::Partial(dirty_rect) = image_dirty_rect {
-                    let dirty_rect = DeviceIntRect {
-                        origin: point2(
-                            dirty_rect.origin.x,
-                            dirty_rect.origin.y,
-                        ),
-                        size: size2(
-                            dirty_rect.size.width,
-                            dirty_rect.size.height,
-                        ),
-                    };
-                    let dirty_tiles = compute_tile_range(
-                        &dirty_rect,
-                        tile_size,
-                    );
+                let dirty_tiles = match image_dirty_rect {
+                    DirtyRect::Partial(dirty_rect) => {
+                        let dirty_rect = DeviceIntRect {
+                            origin: point2(
+                                dirty_rect.origin.x,
+                                dirty_rect.origin.y,
+                            ),
+                            size: size2(
+                                dirty_rect.size.width,
+                                dirty_rect.size.height,
+                            ),
+                        };
 
-                    tiles = tiles.intersection(&dirty_tiles).unwrap_or_else(TileRange::zero);
-                }
+                        compute_tile_range(
+                            &dirty_rect,
+                            tile_size,
+                        )
+                    }
+                    DirtyRect::All => tiles,
+                };
 
                 let original_tile_range = tiles;
 
@@ -1284,16 +1331,22 @@
                     blob_tiles_clear_requests.push(clear_params);
                 }
 
+
                 for_each_tile_in_range(&tiles, |tile| {
+                    let still_valid = template.valid_tiles_after_bounds_change
+                        .map(|valid_tiles| valid_tiles.contains(tile))
+                        .unwrap_or(true);
+
+                    if still_valid && !dirty_tiles.contains(tile) {
+                        return;
+                    }
+
                     let descriptor = BlobImageDescriptor {
-                        rect: LayoutIntRect {
-                            origin: point2(tile.x, tile.y) * tile_size as i32,
-                            size: blob_size(compute_tile_size(
-                                &template.descriptor.size.into(),
-                                tile_size,
-                                tile,
-                            )),
-                        },
+                        rect: blob_rect(compute_tile_rect(
+                            &template.visible_rect,
+                            tile_size,
+                            tile,
+                        )),
                         format: template.descriptor.format,
                     };
 
@@ -1312,6 +1365,8 @@
                         }
                     );
                 });
+
+                template.valid_tiles_after_bounds_change = None;
             } else {
                 let mut needs_upload = match self.cached_images.try_get(&key.as_image()) {
                     Some(&ImageResult::UntiledAuto(ref entry)) => {
@@ -1320,7 +1375,7 @@
                     _ => true,
                 };
 
-                // If the queue of ratserized updates is growing it probably means that
+                // If the queue of rasterized updates is growing it probably means that
                 // the texture is not getting uploaded because the display item is off-screen.
                 // In that case we are better off
                 // - Either not kicking rasterization for that image (avoid wasted cpu work
@@ -1417,6 +1472,12 @@
         }
     }
 
+    fn set_image_visible_rect(&mut self, key: ImageKey, rect: &DeviceIntRect) {
+        if let Some(image) = self.resources.image_templates.get_mut(key) {
+            image.visible_rect = * rect;
+        }
+    }
+
     pub fn request_glyphs(
         &mut self,
         mut font: FontInstance,
@@ -1555,6 +1616,7 @@
                 descriptor: image_template.descriptor,
                 external_image,
                 tiling: image_template.tiling,
+                visible_rect: image_template.visible_rect,
             }
         })
     }
@@ -1698,13 +1760,15 @@
 
                 if let Some(tile) = request.tile {
                     let tile_size = image_template.tiling.unwrap();
-                    let clipped_tile_size = compute_tile_size(&descriptor.size.into(), tile_size, tile);
-
+                    let clipped_tile_size = compute_tile_size(&image_template.visible_rect, tile_size, tile);
                     // The tiled image could be stored on the CPU as one large image or be
                     // already broken up into tiles. This affects the way we compute the stride
                     // and offset.
                     let tiled_on_cpu = image_template.data.is_blob();
                     if !tiled_on_cpu {
+                        // we don't expect to have partial tiles at the top and left of non-blob
+                        // images.
+                        debug_assert_eq!(image_template.visible_rect.origin, point2(0, 0));
                         let bpp = descriptor.format.bytes_per_pixel();
                         let stride = descriptor.compute_stride();
                         descriptor.stride = Some(stride);
@@ -2283,6 +2347,7 @@
                 data,
                 descriptor: template.descriptor,
                 tiling: template.tiling,
+                visible_rect: template.descriptor.size.into(),
             });
         }
 
@@ -2298,3 +2363,11 @@
 fn blob_size(device_size: DeviceIntSize) -> LayoutIntSize {
     size2(device_size.width, device_size.height)
 }
+
+#[inline]
+fn blob_rect(device_rect: DeviceIntRect) -> LayoutIntRect {
+    LayoutIntRect {
+        origin: point2(device_rect.origin.x, device_rect.origin.y),
+        size: blob_size(device_rect.size),
+    }
+}
