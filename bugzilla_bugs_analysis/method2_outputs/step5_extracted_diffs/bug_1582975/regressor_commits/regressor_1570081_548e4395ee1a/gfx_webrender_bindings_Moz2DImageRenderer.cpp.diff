# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/webrender_bindings/Moz2DImageRenderer.cpp
# Commit: 548e4395ee1a
# Full Hash: 548e4395ee1a10700a729f93c0340d44ebe91ac7
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2019-09-13 15:46:31
# Regressor Bug: 1570081
# File Overlap Count: 1
# Description:
#   Bug 1570081 - Support changing the blob image visible rect in WebRender. r=jrmuizel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D39911
# ==============================================================================

diff -r 8eeddedeedb8 -r 548e4395ee1a gfx/webrender_bindings/Moz2DImageRenderer.cpp
--- a/gfx/webrender_bindings/Moz2DImageRenderer.cpp	Thu Sep 12 21:27:06 2019 +0000
+++ b/gfx/webrender_bindings/Moz2DImageRenderer.cpp	Thu Sep 12 15:54:50 2019 +0000
@@ -336,21 +336,23 @@
 };
 
 static bool Moz2DRenderCallback(const Range<const uint8_t> aBlob,
-                                gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
+                                gfx::SurfaceFormat aFormat,
                                 const mozilla::wr::DeviceIntRect* aVisibleRect,
+                                const mozilla::wr::LayoutIntRect* aRenderRect,
                                 const uint16_t* aTileSize,
                                 const mozilla::wr::TileOffset* aTileOffset,
                                 const mozilla::wr::LayoutIntRect* aDirtyRect,
                                 Range<uint8_t> aOutput) {
+  IntSize size(aRenderRect->size.width, aRenderRect->size.height);
   AUTO_PROFILER_TRACING("WebRender", "RasterizeSingleBlob", GRAPHICS);
-  MOZ_RELEASE_ASSERT(aSize.width > 0 && aSize.height > 0);
-  if (aSize.width <= 0 || aSize.height <= 0) {
+  MOZ_RELEASE_ASSERT(size.width > 0 && size.height > 0);
+  if (size.width <= 0 || size.height <= 0) {
     return false;
   }
 
-  auto stride = aSize.width * gfx::BytesPerPixel(aFormat);
+  auto stride = size.width * gfx::BytesPerPixel(aFormat);
 
-  if (aOutput.length() < static_cast<size_t>(aSize.height * stride)) {
+  if (aOutput.length() < static_cast<size_t>(size.height * stride)) {
     return false;
   }
 
@@ -358,7 +360,7 @@
   bool uninitialized = false;
 
   RefPtr<gfx::DrawTarget> dt = gfx::Factory::CreateDrawTargetForData(
-      gfx::BackendType::SKIA, aOutput.begin().get(), aSize, stride, aFormat,
+      gfx::BackendType::SKIA, aOutput.begin().get(), size, stride, aFormat,
       uninitialized);
 
   if (!dt) {
@@ -370,22 +372,18 @@
   size_t footerSize = sizeof(size_t) + sizeof(IntPoint);
   MOZ_RELEASE_ASSERT(aBlob.length() >= footerSize);
   size_t indexOffset = ConvertFromBytes<size_t>(aBlob.end().get() - footerSize);
-  IntPoint origin = ConvertFromBytes<IntPoint>(aBlob.end().get() - footerSize +
-                                               sizeof(size_t));
-  // Apply the visibleRect's offset to make (0, 0) in the DT correspond to (0,
-  // 0) in the texture
+
+  // aRenderRect is the part of the blob that we are currently rendering
+  // (for example a tile) in the same coordinate space as aVisibleRect.
+  IntPoint origin = gfx::IntPoint(aRenderRect->origin.x, aRenderRect->origin.y);
 
   MOZ_RELEASE_ASSERT(indexOffset <= aBlob.length() - footerSize);
   Reader reader(aBlob.begin().get() + indexOffset,
                 aBlob.length() - footerSize - indexOffset);
 
-  if (aTileOffset) {
-    origin +=
-        gfx::IntPoint(aTileOffset->x * *aTileSize, aTileOffset->y * *aTileSize);
-  }
   dt = gfx::Factory::CreateOffsetDrawTarget(dt, origin);
 
-  auto bounds = gfx::IntRect(origin, aSize);
+  auto bounds = gfx::IntRect(origin, size);
 
   if (aDirtyRect) {
     gfx::Rect dirty(aDirtyRect->origin.x, aDirtyRect->origin.y,
@@ -436,7 +434,7 @@
     float r = float(rand()) / float(RAND_MAX);
     float g = float(rand()) / float(RAND_MAX);
     float b = float(rand()) / float(RAND_MAX);
-    dt->FillRect(gfx::Rect(origin.x, origin.y, aSize.width, aSize.height),
+    dt->FillRect(gfx::Rect(origin.x, origin.y, size.width, size.height),
                  gfx::ColorPattern(gfx::Color(r, g, b, 0.5)));
   }
 
@@ -459,17 +457,19 @@
 
 extern "C" {
 
-bool wr_moz2d_render_cb(const mozilla::wr::ByteSlice blob, int32_t width,
-                        int32_t height, mozilla::wr::ImageFormat aFormat,
+bool wr_moz2d_render_cb(const mozilla::wr::ByteSlice blob,
+                        mozilla::wr::ImageFormat aFormat,
+                        const mozilla::wr::LayoutIntRect* aRenderRect,
                         const mozilla::wr::DeviceIntRect* aVisibleRect,
                         const uint16_t* aTileSize,
                         const mozilla::wr::TileOffset* aTileOffset,
                         const mozilla::wr::LayoutIntRect* aDirtyRect,
                         mozilla::wr::MutByteSlice output) {
   return mozilla::wr::Moz2DRenderCallback(
-      mozilla::wr::ByteSliceToRange(blob), mozilla::gfx::IntSize(width, height),
-      mozilla::wr::ImageFormatToSurfaceFormat(aFormat), aVisibleRect, aTileSize,
-      aTileOffset, aDirtyRect, mozilla::wr::MutByteSliceToRange(output));
+      mozilla::wr::ByteSliceToRange(blob),
+      mozilla::wr::ImageFormatToSurfaceFormat(aFormat), aVisibleRect,
+      aRenderRect, aTileSize, aTileOffset, aDirtyRect,
+      mozilla::wr::MutByteSliceToRange(output));
 }
 
 }  // extern