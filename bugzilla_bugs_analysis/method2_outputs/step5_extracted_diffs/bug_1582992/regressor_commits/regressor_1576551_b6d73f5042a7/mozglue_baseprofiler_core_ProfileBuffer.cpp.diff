# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: mozglue/baseprofiler/core/ProfileBuffer.cpp
# Commit: b6d73f5042a7
# Full Hash: b6d73f5042a7f3703b5d16e222e9f71153a43164
# Author: Gerald Squelart <gsquelart@mozilla.com>
# Date: 2019-09-17 15:54:53
# Regressor Bug: 1576551
# File Overlap Count: 1
# Description:
#   Bug 1576551 - Store BlocksRingBuffer outside of ProfileBuffer - r=gregtatum
#   
#   The main `BlocksRingBuffer`s will be stored in `CorePS` (outside of
#   `ProfileBuffer`s), as we need to be able to safely access the underlying buffers
#   when profilers are not enabled.
# ==============================================================================

diff -r 366030bd2d84 -r b6d73f5042a7 mozglue/baseprofiler/core/ProfileBuffer.cpp
--- a/mozglue/baseprofiler/core/ProfileBuffer.cpp	Tue Sep 17 01:50:19 2019 +0000
+++ b/mozglue/baseprofiler/core/ProfileBuffer.cpp	Tue Sep 17 02:12:42 2019 +0000
@@ -20,16 +20,25 @@
 // 65536 bytes should be plenty for a single backtrace.
 static constexpr auto DuplicationBufferBytes = MakePowerOfTwo32<65536>();
 
-// mEntries doesn't need its own mutex, because it is guarded by gPSMutex.
-ProfileBuffer::ProfileBuffer(PowerOfTwo32 aCapacity)
-    : mEntries(BlocksRingBuffer::ThreadSafety::WithoutMutex, aCapacity),
+ProfileBuffer::ProfileBuffer(BlocksRingBuffer& aBuffer, PowerOfTwo32 aCapacity)
+    : mEntries(aBuffer),
       mDuplicationBuffer(MakeUnique<BlocksRingBuffer::Byte[]>(
-          DuplicationBufferBytes.Value())) {}
+          DuplicationBufferBytes.Value())) {
+  // Only ProfileBuffer should control this buffer, and it should be empty when
+  // there is no ProfileBuffer using it.
+  MOZ_ASSERT(mEntries.BufferLength().isNothing());
+  // Allocate the requested capacity.
+  mEntries.Set(aCapacity);
+}
 
 ProfileBuffer::~ProfileBuffer() {
   while (mStoredMarkers.peek()) {
     delete mStoredMarkers.popHead();
   }
+  // Only ProfileBuffer controls this buffer, and it should be empty when there
+  // is no ProfileBuffer using it.
+  mEntries.Reset();
+  MOZ_ASSERT(mEntries.BufferLength().isNothing());
 }
 
 /* static */