# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: mozglue/baseprofiler/core/ProfilerBacktrace.cpp
# Commit: b6d73f5042a7
# Full Hash: b6d73f5042a7f3703b5d16e222e9f71153a43164
# Author: Gerald Squelart <gsquelart@mozilla.com>
# Date: 2019-09-17 15:54:53
# Regressor Bug: 1576551
# File Overlap Count: 1
# Description:
#   Bug 1576551 - Store BlocksRingBuffer outside of ProfileBuffer - r=gregtatum
#   
#   The main `BlocksRingBuffer`s will be stored in `CorePS` (outside of
#   `ProfileBuffer`s), as we need to be able to safely access the underlying buffers
#   when profilers are not enabled.
# ==============================================================================

diff -r 366030bd2d84 -r b6d73f5042a7 mozglue/baseprofiler/core/ProfilerBacktrace.cpp
--- a/mozglue/baseprofiler/core/ProfilerBacktrace.cpp	Tue Sep 17 01:50:19 2019 +0000
+++ b/mozglue/baseprofiler/core/ProfilerBacktrace.cpp	Tue Sep 17 02:12:42 2019 +0000
@@ -18,9 +18,21 @@
 namespace mozilla {
 namespace baseprofiler {
 
-ProfilerBacktrace::ProfilerBacktrace(const char* aName, int aThreadId,
-                                     UniquePtr<ProfileBuffer> aBuffer)
-    : mName(strdup(aName)), mThreadId(aThreadId), mBuffer(std::move(aBuffer)) {}
+ProfilerBacktrace::ProfilerBacktrace(
+    const char* aName, int aThreadId,
+    UniquePtr<BlocksRingBuffer> aBlocksRingBuffer,
+    UniquePtr<ProfileBuffer> aProfileBuffer)
+    : mName(strdup(aName)),
+      mThreadId(aThreadId),
+      mBlocksRingBuffer(std::move(aBlocksRingBuffer)),
+      mProfileBuffer(std::move(aProfileBuffer)) {
+  MOZ_ASSERT(
+      !!mBlocksRingBuffer,
+      "ProfilerBacktrace only takes a non-null UniquePtr<BlocksRingBuffer>");
+  MOZ_ASSERT(
+      !!mProfileBuffer,
+      "ProfilerBacktrace only takes a non-null UniquePtr<ProfileBuffer>");
+}
 
 ProfilerBacktrace::~ProfilerBacktrace() {}
 
@@ -28,10 +40,10 @@
                                    const TimeStamp& aProcessStartTime,
                                    UniqueStacks& aUniqueStacks) {
   // Unlike ProfiledThreadData::StreamJSON, we don't need to call
-  // ProfileBuffer::AddJITInfoForRange because mBuffer does not contain any
-  // JitReturnAddr entries. For synchronous samples, JIT frames get expanded
+  // ProfileBuffer::AddJITInfoForRange because mProfileBuffer does not contain
+  // any JitReturnAddr entries. For synchronous samples, JIT frames get expanded
   // at sample time.
-  StreamSamplesAndMarkers(mName.get(), mThreadId, *mBuffer.get(), aWriter, "",
+  StreamSamplesAndMarkers(mName.get(), mThreadId, *mProfileBuffer, aWriter, "",
                           aProcessStartTime,
                           /* aRegisterTime */ TimeStamp(),
                           /* aUnregisterTime */ TimeStamp(),