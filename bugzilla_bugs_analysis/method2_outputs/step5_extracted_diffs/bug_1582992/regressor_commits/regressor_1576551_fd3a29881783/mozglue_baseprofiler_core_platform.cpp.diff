# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: mozglue/baseprofiler/core/platform.cpp
# Commit: fd3a29881783
# Full Hash: fd3a29881783aad22258c96c6ea04220a40f2648
# Author: Gerald Squelart <gsquelart@mozilla.com>
# Date: 2019-09-18 09:56:40
# Regressor Bug: 1576551
# File Overlap Count: 1
# Description:
#   Bug 1576551 - Store BlocksRingBuffer outside of ProfileBuffer - r=gregtatum
#   
#   The main `BlocksRingBuffer`s will be stored in `CorePS` (outside of
#   `ProfileBuffer`s), as we need to be able to safely access the underlying buffers
#   when profilers are not enabled.
# ==============================================================================

diff -r 3dfc76ea7bd9 -r fd3a29881783 mozglue/baseprofiler/core/platform.cpp
--- a/mozglue/baseprofiler/core/platform.cpp	Wed Sep 18 01:19:14 2019 +0000
+++ b/mozglue/baseprofiler/core/platform.cpp	Wed Sep 18 01:19:21 2019 +0000
@@ -261,7 +261,12 @@
  private:
   CorePS()
       : mMainThreadId(profiler_current_thread_id()),
-        mProcessStartTime(TimeStamp::ProcessCreation())
+        mProcessStartTime(TimeStamp::ProcessCreation()),
+        // This doesn't need its own mutex, because all uses are currently
+        // guarded by gPSMutex, and it is used inside the critical section of
+        // the sampler, where mutexes cannot be used.
+        // TODO: Make it `WithMutex` in later patch...
+        mCoreBlocksRingBuffer(BlocksRingBuffer::ThreadSafety::WithoutMutex)
 #  ifdef USE_LUL_STACKWALK
         ,
         mLul(nullptr)
@@ -319,6 +324,9 @@
   // No PSLockRef is needed for this field because it's immutable.
   PS_GET_LOCKLESS(TimeStamp, ProcessStartTime)
 
+  // No PSLockRef is needed for this field because it's thread-safe.
+  PS_GET_LOCKLESS(BlocksRingBuffer&, CoreBlocksRingBuffer)
+
   PS_GET(const Vector<UniquePtr<RegisteredThread>>&, RegisteredThreads)
 
   static void AppendRegisteredThread(
@@ -406,6 +414,17 @@
   // The time that the process started.
   const TimeStamp mProcessStartTime;
 
+  // The thread-safe blocks-oriented ring buffer into which all profiling data
+  // is recorded.
+  // ActivePS controls the lifetime of the underlying contents buffer: When
+  // ActivePS does not exist, mCoreBlocksRingBuffer is empty and rejects all
+  // reads&writes; see ActivePS for further details.
+  // Note: This needs to live here outside of ActivePS, because some producers
+  // are indirectly controlled (e.g., by atomic flags) and therefore may still
+  // attempt to write some data shortly after ActivePS has shutdown and deleted
+  // the underlying buffer in memory.
+  BlocksRingBuffer mCoreBlocksRingBuffer;
+
   // Info on all the registered threads.
   // ThreadIds in mRegisteredThreads are unique.
   Vector<UniquePtr<RegisteredThread>> mRegisteredThreads;
@@ -469,7 +488,9 @@
         mInterval(aInterval),
         mFeatures(AdjustFeatures(aFeatures, aFilterCount)),
         // 8 bytes per entry.
-        mBuffer(MakeUnique<ProfileBuffer>(PowerOfTwo32(aCapacity.Value() * 8))),
+        mProfileBuffer(
+            MakeUnique<ProfileBuffer>(CorePS::CoreBlocksRingBuffer(),
+                                      PowerOfTwo32(aCapacity.Value() * 8))),
         // The new sampler thread doesn't start sampling immediately because the
         // main loop within Run() is blocked until this function's caller
         // unlocks gPSMutex.
@@ -563,7 +584,7 @@
   static size_t SizeOf(PSLockRef, MallocSizeOf aMallocSizeOf) {
     size_t n = aMallocSizeOf(sInstance);
 
-    n += sInstance->mBuffer->SizeOfIncludingThis(aMallocSizeOf);
+    n += sInstance->mProfileBuffer->SizeOfIncludingThis(aMallocSizeOf);
 
     // Measurement of the following members may be added later if DMD finds it
     // is worthwhile:
@@ -602,7 +623,7 @@
 
   PS_GET(const Vector<std::string>&, Filters)
 
-  static ProfileBuffer& Buffer(PSLockRef) { return *sInstance->mBuffer.get(); }
+  static ProfileBuffer& Buffer(PSLockRef) { return *sInstance->mProfileBuffer; }
 
   static const Vector<LiveProfiledThreadData>& LiveProfiledThreads(PSLockRef) {
     return sInstance->mLiveProfiledThreads;
@@ -690,7 +711,7 @@
       LiveProfiledThreadData& thread = sInstance->mLiveProfiledThreads[i];
       if (thread.mRegisteredThread == aRegisteredThread) {
         thread.mProfiledThreadData->NotifyUnregistered(
-            sInstance->mBuffer->BufferRangeEnd());
+            sInstance->mProfileBuffer->BufferRangeEnd());
         MOZ_RELEASE_ASSERT(sInstance->mDeadProfiledThreads.append(
             std::move(thread.mProfiledThreadData)));
         sInstance->mLiveProfiledThreads.erase(
@@ -707,7 +728,7 @@
 #  endif
 
   static void DiscardExpiredDeadProfiledThreads(PSLockRef) {
-    uint64_t bufferRangeStart = sInstance->mBuffer->BufferRangeStart();
+    uint64_t bufferRangeStart = sInstance->mProfileBuffer->BufferRangeStart();
     // Discard any dead threads that were unregistered before bufferRangeStart.
     sInstance->mDeadProfiledThreads.eraseIf(
         [bufferRangeStart](
@@ -726,7 +747,7 @@
     for (size_t i = 0; i < registeredPages.length(); i++) {
       RefPtr<PageInformation>& page = registeredPages[i];
       if (page->DocShellId() == aRegisteredDocShellId) {
-        page->NotifyUnregistered(sInstance->mBuffer->BufferRangeEnd());
+        page->NotifyUnregistered(sInstance->mProfileBuffer->BufferRangeEnd());
         MOZ_RELEASE_ASSERT(
             sInstance->mDeadProfiledPages.append(std::move(page)));
         registeredPages.erase(&registeredPages[i--]);
@@ -735,7 +756,7 @@
   }
 
   static void DiscardExpiredPages(PSLockRef) {
-    uint64_t bufferRangeStart = sInstance->mBuffer->BufferRangeStart();
+    uint64_t bufferRangeStart = sInstance->mProfileBuffer->BufferRangeStart();
     // Discard any dead pages that were unregistered before
     // bufferRangeStart.
     sInstance->mDeadProfiledPages.eraseIf(
@@ -753,7 +774,7 @@
   }
 
   static void ClearExpiredExitProfiles(PSLockRef) {
-    uint64_t bufferRangeStart = sInstance->mBuffer->BufferRangeStart();
+    uint64_t bufferRangeStart = sInstance->mProfileBuffer->BufferRangeStart();
     // Discard exit profiles that were gathered before our buffer RangeStart.
     sInstance->mExitProfiles.eraseIf(
         [bufferRangeStart](const ExitProfile& aExitProfile) {
@@ -764,8 +785,8 @@
   static void AddExitProfile(PSLockRef aLock, const std::string& aExitProfile) {
     ClearExpiredExitProfiles(aLock);
 
-    MOZ_RELEASE_ASSERT(sInstance->mExitProfiles.append(
-        ExitProfile{aExitProfile, sInstance->mBuffer->BufferRangeEnd()}));
+    MOZ_RELEASE_ASSERT(sInstance->mExitProfiles.append(ExitProfile{
+        aExitProfile, sInstance->mProfileBuffer->BufferRangeEnd()}));
   }
 
   static Vector<std::string> MoveExitProfiles(PSLockRef aLock) {
@@ -805,10 +826,10 @@
   const uint32_t mGeneration;
   static uint32_t sNextGeneration;
 
-  // The maximum number of 8-byte entries in mBuffer.
+  // The maximum number of 8-byte entries in mProfileBuffer.
   const PowerOfTwo32 mCapacity;
 
-  // The maximum duration of entries in mBuffer, in seconds.
+  // The maximum duration of entries in mProfileBuffer, in seconds.
   const Maybe<double> mDuration;
 
   // The interval between samples, measured in milliseconds.
@@ -822,7 +843,7 @@
 
   // The buffer into which all samples are recorded. Always non-null. Always
   // used in conjunction with CorePS::m{Live,Dead}Threads.
-  const UniquePtr<ProfileBuffer> mBuffer;
+  const UniquePtr<ProfileBuffer> mProfileBuffer;
 
   // ProfiledThreadData objects for any threads that were profiled at any point
   // during this run of the profiler:
@@ -3117,12 +3138,15 @@
 #  endif
 
   // 65536 bytes should be plenty for a single backtrace.
-  auto buffer = MakeUnique<ProfileBuffer>(MakePowerOfTwo32<65536>());
+  auto bufferManager = MakeUnique<BlocksRingBuffer>(
+      BlocksRingBuffer::ThreadSafety::WithoutMutex);
+  auto buffer =
+      MakeUnique<ProfileBuffer>(*bufferManager, MakePowerOfTwo32<65536>());
 
   DoSyncSample(lock, *registeredThread, now, regs, *buffer.get());
 
-  return UniqueProfilerBacktrace(
-      new ProfilerBacktrace("SyncProfile", tid, std::move(buffer)));
+  return UniqueProfilerBacktrace(new ProfilerBacktrace(
+      "SyncProfile", tid, std::move(bufferManager), std::move(buffer)));
 }
 
 void ProfilerBacktraceDestructor::operator()(ProfilerBacktrace* aBacktrace) {