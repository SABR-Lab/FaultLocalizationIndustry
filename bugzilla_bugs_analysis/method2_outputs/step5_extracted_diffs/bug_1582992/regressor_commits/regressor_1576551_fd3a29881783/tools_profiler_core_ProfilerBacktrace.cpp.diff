# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: tools/profiler/core/ProfilerBacktrace.cpp
# Commit: fd3a29881783
# Full Hash: fd3a29881783aad22258c96c6ea04220a40f2648
# Author: Gerald Squelart <gsquelart@mozilla.com>
# Date: 2019-09-18 09:56:40
# Regressor Bug: 1576551
# File Overlap Count: 1
# Description:
#   Bug 1576551 - Store BlocksRingBuffer outside of ProfileBuffer - r=gregtatum
#   
#   The main `BlocksRingBuffer`s will be stored in `CorePS` (outside of
#   `ProfileBuffer`s), as we need to be able to safely access the underlying buffers
#   when profilers are not enabled.
# ==============================================================================

diff -r 3dfc76ea7bd9 -r fd3a29881783 tools/profiler/core/ProfilerBacktrace.cpp
--- a/tools/profiler/core/ProfilerBacktrace.cpp	Wed Sep 18 01:19:14 2019 +0000
+++ b/tools/profiler/core/ProfilerBacktrace.cpp	Wed Sep 18 01:19:21 2019 +0000
@@ -11,10 +11,21 @@
 #include "ProfileJSONWriter.h"
 #include "ThreadInfo.h"
 
-ProfilerBacktrace::ProfilerBacktrace(const char* aName, int aThreadId,
-                                     mozilla::UniquePtr<ProfileBuffer> aBuffer)
-    : mName(strdup(aName)), mThreadId(aThreadId), mBuffer(std::move(aBuffer)) {
+ProfilerBacktrace::ProfilerBacktrace(
+    const char* aName, int aThreadId,
+    UniquePtr<mozilla::BlocksRingBuffer> aBlocksRingBuffer,
+    mozilla::UniquePtr<ProfileBuffer> aProfileBuffer)
+    : mName(strdup(aName)),
+      mThreadId(aThreadId),
+      mBlocksRingBuffer(std::move(aBlocksRingBuffer)),
+      mProfileBuffer(std::move(aProfileBuffer)) {
   MOZ_COUNT_CTOR(ProfilerBacktrace);
+  MOZ_ASSERT(
+      !!mBlocksRingBuffer,
+      "ProfilerBacktrace only takes a non-null UniquePtr<BlocksRingBuffer>");
+  MOZ_ASSERT(
+      !!mProfileBuffer,
+      "ProfilerBacktrace only takes a non-null UniquePtr<ProfileBuffer>");
 }
 
 ProfilerBacktrace::~ProfilerBacktrace() { MOZ_COUNT_DTOR(ProfilerBacktrace); }
@@ -23,10 +34,10 @@
                                    const mozilla::TimeStamp& aProcessStartTime,
                                    UniqueStacks& aUniqueStacks) {
   // Unlike ProfiledThreadData::StreamJSON, we don't need to call
-  // ProfileBuffer::AddJITInfoForRange because mBuffer does not contain any
-  // JitReturnAddr entries. For synchronous samples, JIT frames get expanded
+  // ProfileBuffer::AddJITInfoForRange because mProfileBuffer does not contain
+  // any JitReturnAddr entries. For synchronous samples, JIT frames get expanded
   // at sample time.
-  StreamSamplesAndMarkers(mName.get(), mThreadId, *mBuffer.get(), aWriter,
+  StreamSamplesAndMarkers(mName.get(), mThreadId, *mProfileBuffer, aWriter,
                           NS_LITERAL_CSTRING(""), aProcessStartTime,
                           /* aRegisterTime */ mozilla::TimeStamp(),
                           /* aUnregisterTime */ mozilla::TimeStamp(),