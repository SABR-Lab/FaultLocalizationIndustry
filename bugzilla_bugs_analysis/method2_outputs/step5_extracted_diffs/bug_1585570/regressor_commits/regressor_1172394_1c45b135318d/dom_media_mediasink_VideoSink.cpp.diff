# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/VideoSink.cpp
# Commit: 1c45b135318d
# Full Hash: 1c45b135318d8cb519b8d58af72ab864fe6bfd62
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2019-11-14 17:12:31
# Regressor Bug: 1172394
# File Overlap Count: 1
# Description:
#   Bug 1172394 - Simplify MediaSink somewhat. r=padenot
#   
#   This patches does several minor things:
#   - Moves SetSink (from setSinkid) to automatic coalescing of multiple calls
#     through a Canonical/Mirror setup instead of a manual atomic counter.
# ==============================================================================

diff -r c57c41e8c39e -r 1c45b135318d dom/media/mediasink/VideoSink.cpp
--- a/dom/media/mediasink/VideoSink.cpp	Wed Nov 13 08:55:39 2019 +0000
+++ b/dom/media/mediasink/VideoSink.cpp	Wed Nov 13 08:55:54 2019 +0000
@@ -156,18 +156,6 @@
 #endif
 }
 
-const MediaSink::PlaybackParams& VideoSink::GetPlaybackParams() const {
-  AssertOwnerThread();
-
-  return mAudioSink->GetPlaybackParams();
-}
-
-void VideoSink::SetPlaybackParams(const PlaybackParams& aParams) {
-  AssertOwnerThread();
-
-  mAudioSink->SetPlaybackParams(aParams);
-}
-
 RefPtr<VideoSink::EndedPromise> VideoSink::OnEnded(TrackType aType) {
   AssertOwnerThread();
   MOZ_ASSERT(mAudioSink->IsStarted(), "Must be called after playback starts.");
@@ -223,6 +211,12 @@
   mAudioSink->SetPreservesPitch(aPreservesPitch);
 }
 
+double VideoSink::PlaybackRate() const {
+  AssertOwnerThread();
+
+  return mAudioSink->PlaybackRate();
+}
+
 void VideoSink::EnsureHighResTimersOnOnlyIfPlaying() {
 #ifdef XP_WIN
   const bool needed = IsPlaying();
@@ -440,8 +434,8 @@
   // If we send this future frame to the compositor now, it will be rendered
   // immediately and break A/V sync. Instead, we schedule a timer to send it
   // later.
-  int64_t delta = (v->mTime - clockTime).ToMicroseconds() /
-                  mAudioSink->GetPlaybackParams().mPlaybackRate;
+  int64_t delta =
+      (v->mTime - clockTime).ToMicroseconds() / mAudioSink->PlaybackRate();
   TimeStamp target = nowTime + TimeDuration::FromMicroseconds(delta);
   RefPtr<VideoSink> self = this;
   mUpdateScheduler.Ensure(
@@ -481,7 +475,7 @@
 
   AutoTArray<ImageContainer::NonOwningImage, 16> images;
   TimeStamp lastFrameTime;
-  MediaSink::PlaybackParams params = mAudioSink->GetPlaybackParams();
+  double playbackRate = mAudioSink->PlaybackRate();
   for (uint32_t i = 0; i < frames.Length(); ++i) {
     VideoData* frame = frames[i];
     bool wasSent = frame->IsSentToCompositor();
@@ -499,8 +493,8 @@
 
     MOZ_ASSERT(!aClockTimeStamp.IsNull());
     int64_t delta = frame->mTime.ToMicroseconds() - aClockTime;
-    TimeStamp t = aClockTimeStamp +
-                  TimeDuration::FromMicroseconds(delta / params.mPlaybackRate);
+    TimeStamp t =
+        aClockTimeStamp + TimeDuration::FromMicroseconds(delta / playbackRate);
     if (!lastFrameTime.IsNull() && t <= lastFrameTime) {
       // Timestamps out of order; drop the new frame. In theory we should
       // probably replace the previous frame with the new frame if the
@@ -613,9 +607,8 @@
   int64_t nextFrameTime = frames[1]->mTime.ToMicroseconds();
   int64_t delta = std::max(nextFrameTime - clockTime.ToMicroseconds(),
                            MIN_UPDATE_INTERVAL_US);
-  TimeStamp target =
-      nowTime + TimeDuration::FromMicroseconds(
-                    delta / mAudioSink->GetPlaybackParams().mPlaybackRate);
+  TimeStamp target = nowTime + TimeDuration::FromMicroseconds(
+                                   delta / mAudioSink->PlaybackRate());
 
   RefPtr<VideoSink> self = this;
   mUpdateScheduler.Ensure(
@@ -647,7 +640,7 @@
           "end promise. clockTime=%" PRId64 ", endTime=%" PRId64,
           clockTime.ToMicroseconds(), mVideoFrameEndTime.ToMicroseconds());
       int64_t delta = (mVideoFrameEndTime - clockTime).ToMicroseconds() /
-                      mAudioSink->GetPlaybackParams().mPlaybackRate;
+                      mAudioSink->PlaybackRate();
       TimeStamp target = nowTime + TimeDuration::FromMicroseconds(delta);
       auto resolveEndPromise = [self = RefPtr<VideoSink>(this)]() {
         self->mEndPromiseHolder.ResolveIfExists(true, __func__);