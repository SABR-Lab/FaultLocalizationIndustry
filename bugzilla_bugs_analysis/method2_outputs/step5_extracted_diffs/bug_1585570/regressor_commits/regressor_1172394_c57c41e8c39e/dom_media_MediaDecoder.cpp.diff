# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaDecoder.cpp
# Commit: c57c41e8c39e
# Full Hash: c57c41e8c39ea51e96c13af8ecdcbe1640e2a9d6
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2019-11-14 17:12:31
# Regressor Bug: 1172394
# File Overlap Count: 1
# Description:
#   Bug 1172394 - Refactor how DecodedStream is set up. r=padenot
#   
#   This patch removes the responsibility of js-facing MediaStreamTracks from the
#   MediaDecoder stack, and moves the machinery for setting up DecodedStream to
#   higher order functions like state mirroring and watchables.
# ==============================================================================

diff -r a796541fe5ef -r c57c41e8c39e dom/media/MediaDecoder.cpp
--- a/dom/media/MediaDecoder.cpp	Wed Nov 13 08:55:29 2019 +0000
+++ b/dom/media/MediaDecoder.cpp	Wed Nov 13 08:55:39 2019 +0000
@@ -235,14 +235,16 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  mOutputCaptured = aCaptured;
 }
 
 void MediaDecoder::AddOutputTrack(RefPtr<ProcessedMediaTrack> aTrack) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  nsTArray<RefPtr<ProcessedMediaTrack>> tracks = mOutputTracks;
+  tracks.AppendElement(std::move(aTrack));
+  mOutputTracks = tracks;
 }
 
 void MediaDecoder::RemoveOutputTrack(
@@ -250,7 +252,10 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  nsTArray<RefPtr<ProcessedMediaTrack>> tracks = mOutputTracks;
+  if (tracks.RemoveElement(aTrack)) {
+    mOutputTracks = tracks;
+  }
 }
 
 void MediaDecoder::SetOutputTracksPrincipal(
@@ -258,7 +263,7 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  mOutputPrincipal = MakePrincipalHandle(aPrincipal);
 }
 
 double MediaDecoder::GetDuration() {
@@ -304,6 +309,9 @@
       INIT_CANONICAL(mVolume, aInit.mVolume),
       INIT_CANONICAL(mPreservesPitch, aInit.mPreservesPitch),
       INIT_CANONICAL(mLooping, aInit.mLooping),
+      INIT_CANONICAL(mOutputCaptured, false),
+      INIT_CANONICAL(mOutputTracks, nsTArray<RefPtr<ProcessedMediaTrack>>()),
+      INIT_CANONICAL(mOutputPrincipal, PRINCIPAL_HANDLE_NONE),
       INIT_CANONICAL(mPlayState, PLAY_STATE_LOADING),
       mSameOriginMedia(false),
       mVideoDecodingOberver(
@@ -665,7 +673,6 @@
   mMediaSeekableOnlyInBufferedRanges =
       aInfo->mMediaSeekableOnlyInBufferedRanges;
   mInfo = aInfo.release();
-  mDecoderStateMachine->EnsureOutputStreamManagerHasTracks(*mInfo);
 
   // Make sure the element and the frame (if any) are told about
   // our new size.