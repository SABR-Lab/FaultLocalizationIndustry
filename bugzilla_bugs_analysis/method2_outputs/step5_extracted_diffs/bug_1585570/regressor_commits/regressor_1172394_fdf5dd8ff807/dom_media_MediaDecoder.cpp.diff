# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaDecoder.cpp
# Commit: fdf5dd8ff807
# Full Hash: fdf5dd8ff80792a48fd00771850104df655cd866
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2019-11-14 21:46:28
# Regressor Bug: 1172394
# File Overlap Count: 1
# Description:
#   Bug 1172394 - Refactor how DecodedStream is set up. r=padenot
#   
#   This patch removes the responsibility of js-facing MediaStreamTracks from the
#   MediaDecoder stack, and moves the machinery for setting up DecodedStream to
#   higher order functions like state mirroring and watchables.
# ==============================================================================

diff -r 9114318b6493 -r fdf5dd8ff807 dom/media/MediaDecoder.cpp
--- a/dom/media/MediaDecoder.cpp	Wed Nov 13 22:40:09 2019 +0000
+++ b/dom/media/MediaDecoder.cpp	Wed Nov 13 22:40:07 2019 +0000
@@ -235,14 +235,16 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  mOutputCaptured = aCaptured;
 }
 
 void MediaDecoder::AddOutputTrack(RefPtr<ProcessedMediaTrack> aTrack) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  nsTArray<RefPtr<ProcessedMediaTrack>> tracks = mOutputTracks;
+  tracks.AppendElement(std::move(aTrack));
+  mOutputTracks = tracks;
 }
 
 void MediaDecoder::RemoveOutputTrack(
@@ -250,7 +252,10 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  nsTArray<RefPtr<ProcessedMediaTrack>> tracks = mOutputTracks;
+  if (tracks.RemoveElement(aTrack)) {
+    mOutputTracks = tracks;
+  }
 }
 
 void MediaDecoder::SetOutputTracksPrincipal(
@@ -258,7 +263,7 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDecoderStateMachine, "Must be called after Load().");
   AbstractThread::AutoEnter context(AbstractMainThread());
-  MOZ_CRASH("Not implemented");
+  mOutputPrincipal = MakePrincipalHandle(aPrincipal);
 }
 
 double MediaDecoder::GetDuration() {
@@ -304,6 +309,9 @@
       INIT_CANONICAL(mVolume, aInit.mVolume),
       INIT_CANONICAL(mPreservesPitch, aInit.mPreservesPitch),
       INIT_CANONICAL(mLooping, aInit.mLooping),
+      INIT_CANONICAL(mOutputCaptured, false),
+      INIT_CANONICAL(mOutputTracks, nsTArray<RefPtr<ProcessedMediaTrack>>()),
+      INIT_CANONICAL(mOutputPrincipal, PRINCIPAL_HANDLE_NONE),
       INIT_CANONICAL(mPlayState, PLAY_STATE_LOADING),
       mSameOriginMedia(false),
       mVideoDecodingOberver(
@@ -665,7 +673,6 @@
   mMediaSeekableOnlyInBufferedRanges =
       aInfo->mMediaSeekableOnlyInBufferedRanges;
   mInfo = aInfo.release();
-  mDecoderStateMachine->EnsureOutputStreamManagerHasTracks(*mInfo);
 
   // Make sure the element and the frame (if any) are told about
   // our new size.