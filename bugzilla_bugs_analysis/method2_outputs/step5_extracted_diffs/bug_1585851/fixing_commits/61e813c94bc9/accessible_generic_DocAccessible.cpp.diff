# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: accessible/generic/DocAccessible.cpp
# Commit: 61e813c94bc9
# Full Hash: 61e813c94bc98cd2ebb03113fb3c1c1bf02283c8
# Author: James Teh <jteh@mozilla.com>
# Date: 2019-10-30 15:06:46
# Description:
#   Bug 1585851: When processing a11y insertions, don't try to move an accessible if its new previous sibling hasn't been moved into its new container yet. r=MarcoZ
#   
#   Sometimes, depending on how children were changed, children might be in the insertion list out of order; e.g. [child2, child1].
#   It's also possible that an earlier child (child1 in the above example) is being moved out of another container.
#   When processing the earlier insertion (child2), we'll determine we need to move it within its parent and will fetch its new previous sibling so we can move it into the right place.
# ==============================================================================

diff -r 1ee997d2152a -r 61e813c94bc9 accessible/generic/DocAccessible.cpp
--- a/accessible/generic/DocAccessible.cpp	Tue Oct 29 18:15:28 2019 +0000
+++ b/accessible/generic/DocAccessible.cpp	Wed Oct 30 06:32:50 2019 +0000
@@ -1941,6 +1941,14 @@
       Accessible* previousSibling = iter.ChildBefore();
       if (parent != aContainer ||
           iter.Child()->PrevSibling() != previousSibling) {
+        if (previousSibling && previousSibling->Parent() != aContainer) {
+          // previousSibling hasn't been moved into aContainer yet.
+          // previousSibling should be later in the insertion list, so the tree
+          // will get adjusted when we process it later.
+          MOZ_DIAGNOSTIC_ASSERT(parent == aContainer,
+            "Child moving to new parent, but previous sibling in wrong parent");
+          continue;
+        }
 #ifdef A11Y_LOG
         logging::TreeInfo("relocating accessible", 0, "old parent", parent,
                           "new parent", aContainer, "child", iter.Child(),