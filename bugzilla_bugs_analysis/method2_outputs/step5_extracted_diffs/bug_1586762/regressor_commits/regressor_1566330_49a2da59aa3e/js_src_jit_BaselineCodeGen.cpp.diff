# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BaselineCodeGen.cpp
# Commit: 49a2da59aa3e
# Full Hash: 49a2da59aa3e33b3719c7953a98fac6c24b8a514
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2019-07-21 21:59:35
# Regressor Bug: 1566330
# File Overlap Count: 2
# Description:
#   Bug 1566330 - Let BaselineDebugModeOSR resume in the interpreter, remove BaselineDebugModeOSRInfo. r=iain
#   
#   At this point most of the DebugModeOSR complexity came from dealing with the
#   On -> Off case because debugger callVMs are not present in the recompiled script.
#   We also had to worry about loading unsynced stack values in R0/R1 in the
# ==============================================================================

diff -r ad5e0980c273 -r 49a2da59aa3e js/src/jit/BaselineCodeGen.cpp
--- a/js/src/jit/BaselineCodeGen.cpp	Sun Jul 21 09:27:47 2019 +0000
+++ b/js/src/jit/BaselineCodeGen.cpp	Fri Jul 19 09:01:45 2019 +0000
@@ -130,9 +130,9 @@
   return true;
 }
 
-bool BaselineCompilerHandler::appendRetAddrEntry(JSContext* cx,
-                                                 RetAddrEntry::Kind kind,
-                                                 uint32_t retOffset) {
+bool BaselineCompilerHandler::recordCallRetAddr(JSContext* cx,
+                                                RetAddrEntry::Kind kind,
+                                                uint32_t retOffset) {
   uint32_t pcOffset = script_->pcToOffset(pc_);
 
   // Entries must be sorted by pcOffset for binary search to work.
@@ -153,6 +153,26 @@
   return true;
 }
 
+bool BaselineInterpreterHandler::recordCallRetAddr(JSContext* cx,
+                                                   RetAddrEntry::Kind kind,
+                                                   uint32_t retOffset) {
+  switch (kind) {
+    case RetAddrEntry::Kind::DebugPrologue:
+      callVMOffsets_.debugPrologueOffset = retOffset;
+      break;
+    case RetAddrEntry::Kind::DebugEpilogue:
+      callVMOffsets_.debugEpilogueOffset = retOffset;
+      break;
+    case RetAddrEntry::Kind::DebugAfterYield:
+      callVMOffsets_.debugAfterYieldOffset = retOffset;
+      break;
+    default:
+      break;
+  }
+
+  return true;
+}
+
 bool BaselineCompiler::addPCMappingEntry(bool addIndexEntry) {
   // Don't add multiple entries for a single pc.
   size_t nentries = pcMappingEntries_.length();
@@ -295,15 +315,14 @@
   }
 
   UniquePtr<BaselineScript> baselineScript(
-      BaselineScript::New(
-          script, bailoutPrologueOffset_.offset(),
-          warmUpCheckPrologueOffset_.offset(), debugOsrPrologueOffset_.offset(),
-          debugOsrEpilogueOffset_.offset(),
-          profilerEnterFrameToggleOffset_.offset(),
-          profilerExitFrameToggleOffset_.offset(),
-          handler.retAddrEntries().length(), pcMappingIndexEntries.length(),
-          pcEntries.length(), script->resumeOffsets().size(),
-          traceLoggerToggleOffsets_.length()),
+      BaselineScript::New(script, bailoutPrologueOffset_.offset(),
+                          warmUpCheckPrologueOffset_.offset(),
+                          profilerEnterFrameToggleOffset_.offset(),
+                          profilerExitFrameToggleOffset_.offset(),
+                          handler.retAddrEntries().length(),
+                          pcMappingIndexEntries.length(), pcEntries.length(),
+                          script->resumeOffsets().size(),
+                          traceLoggerToggleOffsets_.length()),
       JS::DeletePolicy<BaselineScript>(cx->runtime()));
   if (!baselineScript) {
     ReportOutOfMemory(cx);
@@ -773,7 +792,7 @@
   }
 #endif
 
-  return handler.appendRetAddrEntry(cx, kind, callOffset);
+  return handler.recordCallRetAddr(cx, kind, callOffset);
 }
 
 template <typename Handler>
@@ -1155,13 +1174,7 @@
     masm.bind(&done);
     return true;
   };
-  if (!emitDebugInstrumentation(ifDebuggee)) {
-    return false;
-  }
-
-  debugOsrPrologueOffset_ = CodeOffset(masm.currentOffset());
-
-  return true;
+  return emitDebugInstrumentation(ifDebuggee);
 }
 
 template <>
@@ -1585,8 +1598,8 @@
 #endif
 
   // Add a RetAddrEntry for the return offset -> pc mapping.
-  return handler.appendRetAddrEntry(cx, RetAddrEntry::Kind::DebugTrap,
-                                    masm.currentOffset());
+  return handler.recordCallRetAddr(cx, RetAddrEntry::Kind::DebugTrap,
+                                   masm.currentOffset());
 }
 
 #ifdef JS_TRACE_LOGGING
@@ -6177,9 +6190,9 @@
   masm.callAndPushReturnAddress(&genStart);
 #endif
 
-  // Add a RetAddrEntry so the return offset -> pc mapping works.
-  if (!handler.appendRetAddrEntry(cx, RetAddrEntry::Kind::IC,
-                                  masm.currentOffset())) {
+  // Record the return address so the return offset -> pc mapping works.
+  if (!handler.recordCallRetAddr(cx, RetAddrEntry::Kind::IC,
+                                 masm.currentOffset())) {
     return false;
   }
 
@@ -6775,10 +6788,6 @@
 
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emitEpilogue() {
-  // Record the offset of the epilogue, so we can do early return from
-  // Debugger handlers during on-stack recompile.
-  debugOsrEpilogueOffset_ = CodeOffset(masm.currentOffset());
-
   masm.bind(&return_);
 
 #ifdef JS_TRACE_LOGGING
@@ -7006,7 +7015,8 @@
 #undef EMIT_OP
 
   // External entry point to start interpreting bytecode ops. This is used for
-  // things like exception handling and OSR.
+  // things like exception handling and OSR. DebugModeOSR patches JIT frames to
+  // return here from the DebugTrapHandler.
   masm.bind(handler.interpretOpLabel());
   interpretOpOffset_ = masm.currentOffset();
   restoreInterpreterPCReg();
@@ -7152,7 +7162,8 @@
                      profilerExitFrameToggleOffset_.offset(),
                      std::move(handler.debugInstrumentationOffsets()),
                      std::move(debugTrapOffsets_),
-                     std::move(handler.codeCoverageOffsets()));
+                     std::move(handler.codeCoverageOffsets()),
+                     handler.callVMOffsets());
   }
 
   if (cx->runtime()->geckoProfiler().enabled()) {