# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsChild.cpp
# Commit: 13e00068cb2b
# Full Hash: 13e00068cb2bf553f6badfbacbbc7decfcfdf4bf
# Author: Birunthan Mohanathas <birunthan@mohanathas.com>
# Date: 2015-08-23 21:18:49
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Part 5: Send two records with every ObjectStoreCursorResponse. r=khuey
# ==============================================================================

diff -r 8e9fb56cc22a -r 13e00068cb2b dom/indexedDB/ActorsChild.cpp
--- a/dom/indexedDB/ActorsChild.cpp	Wed Aug 19 14:59:28 2015 -0700
+++ b/dom/indexedDB/ActorsChild.cpp	Wed Aug 19 14:59:29 2015 -0700
@@ -2462,7 +2462,66 @@
 
   mTransaction->OnNewRequest();
 
-  MOZ_ALWAYS_TRUE(PBackgroundIDBCursorChild::SendContinue(aParams, aKey));
+  CursorRequestParams params = aParams;
+  Key key = aKey;
+
+  switch (params.type()) {
+    case CursorRequestParams::TContinueParams: {
+      if (key.IsUnset()) {
+        break;
+      }
+      while (!mCachedResponses.IsEmpty()) {
+        if (mCachedResponses[0].mKey == key) {
+          break;
+        }
+        mCachedResponses.RemoveElementAt(0);
+      }
+      break;
+    }
+
+    case CursorRequestParams::TAdvanceParams: {
+      uint32_t& advanceCount = params.get_AdvanceParams().count();
+      while (advanceCount > 1 && !mCachedResponses.IsEmpty()) {
+        key = mCachedResponses[0].mKey;
+        mCachedResponses.RemoveElementAt(0);
+        --advanceCount;
+      }
+      break;
+    }
+
+    default:
+      MOZ_CRASH("Should never get here!");
+  }
+
+  if (!mCachedResponses.IsEmpty()) {
+    nsCOMPtr<nsIRunnable> continueRunnable = new DelayedActionRunnable(
+      this, &BackgroundCursorChild::SendDelayedContinueInternal);
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToCurrentThread(continueRunnable)));
+  } else {
+    MOZ_ALWAYS_TRUE(PBackgroundIDBCursorChild::SendContinue(params, key));
+  }
+}
+
+void
+BackgroundCursorChild::SendDelayedContinueInternal()
+{
+  AssertIsOnOwningThread();
+  MOZ_ASSERT(mTransaction);
+  MOZ_ASSERT(mCursor);
+  MOZ_ASSERT(mStrongCursor);
+  MOZ_ASSERT(!mCachedResponses.IsEmpty());
+
+  nsRefPtr<IDBCursor> cursor;
+  mStrongCursor.swap(cursor);
+
+  auto& item = mCachedResponses[0];
+  mCursor->Reset(Move(item.mKey), Move(item.mCloneInfo));
+  mCachedResponses.RemoveElementAt(0);
+
+  ResultHelper helper(mRequest, mTransaction, mCursor);
+  DispatchSuccessEvent(&helper);
+
+  mTransaction->OnRequestFinished(/* aActorDestroyedNormally */ true);
 }
 
 void
@@ -2486,6 +2545,14 @@
 }
 
 void
+BackgroundCursorChild::InvalidateCachedResponses()
+{
+  AssertIsOnOwningThread();
+
+  mCachedResponses.Clear();
+}
+
+void
 BackgroundCursorChild::HandleResponse(nsresult aResponse)
 {
   AssertIsOnOwningThread();
@@ -2550,7 +2617,14 @@
     nsRefPtr<IDBCursor> newCursor;
 
     if (mCursor) {
-      mCursor->Reset(Move(response.key()), Move(cloneReadInfo));
+      if (mCursor->IsContinueCalled()) {
+        mCursor->Reset(Move(response.key()), Move(cloneReadInfo));
+      } else {
+        CachedResponse cachedResponse;
+        cachedResponse.mKey = Move(response.key());
+        cachedResponse.mCloneInfo = Move(cloneReadInfo);
+        mCachedResponses.AppendElement(Move(cachedResponse));
+      }
     } else {
       newCursor = IDBCursor::Create(this,
                                     Move(response.key()),
@@ -2792,6 +2866,16 @@
   return NS_OK;
 }
 
+BackgroundCursorChild::CachedResponse::CachedResponse()
+{
+}
+
+BackgroundCursorChild::CachedResponse::CachedResponse(CachedResponse&& aOther)
+  : mKey(Move(aOther.mKey))
+{
+  mCloneInfo = Move(aOther.mCloneInfo);
+}
+
 } // namespace indexedDB
 } // namespace dom
 } // namespace mozilla