# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsParent.cpp
# Commit: 9966f5d71bb2
# Full Hash: 9966f5d71bb2db2228a914743dca457dcc337d02
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2019-09-18 21:49:27
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Apply renamings suggested for Cursor::*Key members and related identifiers. r=ytausky,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D43249
# ==============================================================================

diff -r 714d36c43204 -r 9966f5d71bb2 dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp	Wed Sep 18 06:41:23 2019 +0000
+++ b/dom/indexedDB/ActorsParent.cpp	Wed Sep 18 06:41:35 2019 +0000
@@ -272,8 +272,9 @@
 // name) should not be mixed for the same statement. The decision must be made
 // for each statement based on the proximity of statement and binding calls.
 constexpr auto kStmtParamNameCurrentKey = NS_LITERAL_CSTRING("current_key");
-constexpr auto kStmtParamNameRangeKey = NS_LITERAL_CSTRING("range_key");
-constexpr auto kStmtParamNameObjectKey = NS_LITERAL_CSTRING("object_key");
+constexpr auto kStmtParamNameRangeBound = NS_LITERAL_CSTRING("range_bound");
+constexpr auto kStmtParamNameObjectStorePosition =
+    NS_LITERAL_CSTRING("object_store_position");
 constexpr auto kStmtParamNameLowerKey = NS_LITERAL_CSTRING("lower_key");
 constexpr auto kStmtParamNameUpperKey = NS_LITERAL_CSTRING("upper_key");
 constexpr auto kStmtParamNameKey = NS_LITERAL_CSTRING("key");
@@ -495,8 +496,8 @@
 
 struct IndexDataValue final {
   int64_t mIndexId;
-  Key mKey;
-  Key mSortKey;
+  Key mPosition;
+  Key mLocaleAwarePosition;
   bool mUnique;
 
   IndexDataValue() : mIndexId(0), mUnique(false) {
@@ -505,25 +506,28 @@
 
   explicit IndexDataValue(const IndexDataValue& aOther)
       : mIndexId(aOther.mIndexId),
-        mKey(aOther.mKey),
-        mSortKey(aOther.mSortKey),
+        mPosition(aOther.mPosition),
+        mLocaleAwarePosition(aOther.mLocaleAwarePosition),
         mUnique(aOther.mUnique) {
-    MOZ_ASSERT(!aOther.mKey.IsUnset());
+    MOZ_ASSERT(!aOther.mPosition.IsUnset());
 
     MOZ_COUNT_CTOR(IndexDataValue);
   }
 
-  IndexDataValue(int64_t aIndexId, bool aUnique, const Key& aKey)
-      : mIndexId(aIndexId), mKey(aKey), mUnique(aUnique) {
-    MOZ_ASSERT(!aKey.IsUnset());
+  IndexDataValue(int64_t aIndexId, bool aUnique, const Key& aPosition)
+      : mIndexId(aIndexId), mPosition(aPosition), mUnique(aUnique) {
+    MOZ_ASSERT(!aPosition.IsUnset());
 
     MOZ_COUNT_CTOR(IndexDataValue);
   }
 
-  IndexDataValue(int64_t aIndexId, bool aUnique, const Key& aKey,
-                 const Key& aSortKey)
-      : mIndexId(aIndexId), mKey(aKey), mSortKey(aSortKey), mUnique(aUnique) {
-    MOZ_ASSERT(!aKey.IsUnset());
+  IndexDataValue(int64_t aIndexId, bool aUnique, const Key& aPosition,
+                 const Key& aLocaleAwarePosition)
+      : mIndexId(aIndexId),
+        mPosition(aPosition),
+        mLocaleAwarePosition(aLocaleAwarePosition),
+        mUnique(aUnique) {
+    MOZ_ASSERT(!aPosition.IsUnset());
 
     MOZ_COUNT_CTOR(IndexDataValue);
   }
@@ -534,18 +538,18 @@
     if (mIndexId != aOther.mIndexId) {
       return false;
     }
-    if (mSortKey.IsUnset()) {
-      return mKey == aOther.mKey;
-    }
-    return mSortKey == aOther.mSortKey;
+    if (mLocaleAwarePosition.IsUnset()) {
+      return mPosition == aOther.mPosition;
+    }
+    return mLocaleAwarePosition == aOther.mLocaleAwarePosition;
   }
 
   bool operator<(const IndexDataValue& aOther) const {
     if (mIndexId == aOther.mIndexId) {
-      if (mSortKey.IsUnset()) {
-        return mKey < aOther.mKey;
-      }
-      return mSortKey < aOther.mSortKey;
+      if (mLocaleAwarePosition.IsUnset()) {
+        return mPosition < aOther.mPosition;
+      }
+      return mLocaleAwarePosition < aOther.mLocaleAwarePosition;
     }
 
     return mIndexId < aOther.mIndexId;
@@ -772,8 +776,8 @@
 
   for (uint32_t arrayIndex = 0; arrayIndex < arrayLength; arrayIndex++) {
     const IndexDataValue& info = aIndexValues[arrayIndex];
-    const nsCString& keyBuffer = info.mKey.GetBuffer();
-    const nsCString& sortKeyBuffer = info.mSortKey.GetBuffer();
+    const nsCString& keyBuffer = info.mPosition.GetBuffer();
+    const nsCString& sortKeyBuffer = info.mLocaleAwarePosition.GetBuffer();
     const uint32_t keyBufferLength = keyBuffer.Length();
     const uint32_t sortKeyBufferLength = sortKeyBuffer.Length();
 
@@ -810,8 +814,8 @@
 
   for (uint32_t arrayIndex = 0; arrayIndex < arrayLength; arrayIndex++) {
     const IndexDataValue& info = aIndexValues[arrayIndex];
-    const nsCString& keyBuffer = info.mKey.GetBuffer();
-    const nsCString& sortKeyBuffer = info.mSortKey.GetBuffer();
+    const nsCString& keyBuffer = info.mPosition.GetBuffer();
+    const nsCString& sortKeyBuffer = info.mLocaleAwarePosition.GetBuffer();
     const uint32_t keyBufferLength = keyBuffer.Length();
     const uint32_t sortKeyBufferLength = sortKeyBuffer.Length();
 
@@ -899,7 +903,7 @@
                               uint32_t(sortKeyBufferLength));
       blobDataIter += sortKeyBufferLength;
 
-      idv.mSortKey = Key(sortKeyBuffer);
+      idv.mLocaleAwarePosition = Key(sortKeyBuffer);
     }
 
     if (NS_WARN_IF(!aIndexValues.InsertElementSorted(idv, fallible))) {
@@ -7590,28 +7594,24 @@
   nsCString mContinuePrimaryKeyQuery;
   const nsCString mLocale;
 
-  // TODO: Apply the renamings suggested below, and also change related
-  // identifiers (e.g. local variables) and literals.
-
-  Key mKey;  ///< The current key, i.e. the key representing the cursor's
-             ///< position (https://w3c.github.io/IndexedDB/#cursor-position).
-             ///<
-             ///< TODO: Rename this to mPosition
-  Key mObjectKey;  ///< The key representing the cursor's object store position
+  // TODO: Probably, it is still necessary to change more related identifiers
+  // (e.g. local variables) and literals, to be in line with the new member
+  // names below.
+
+  Key mPosition;  ///< The current key, i.e. the key representing the cursor's
+                  ///< position
+                  ///< (https://w3c.github.io/IndexedDB/#cursor-position).
+  Key mObjectStorePosition;  ///< The key representing the cursor's object store
+                             ///< position
   ///< (https://w3c.github.io/IndexedDB/#cursor-object-store-position).
-  ///<
-  ///< TODO: Rename this to mObjectStorePosition
-  Key mRangeKey;  ///< If the cursor is based on a key range, the bound in the
-                  ///< direction of iteration (e.g. the upper bound in case of
-                  ///< mDirection == NEXT). If the cursor is based on a key, it
-                  ///< is unset. If mLocale is set, this was converted to
-                  ///< mLocale.
-                  ///<
-                  ///< TODO: Rename this to mLocaleAwareRangeBound
-  Key mSortKey;   ///< If mLocale is set, this is mKey converted to mLocale.
-                  ///< Otherwise, it is unset.
-                  ///<
-                  ///< TODO: Rename this to mLocaleAwarePosition
+  Key mLocaleAwareRangeBound;  ///< If the cursor is based on a key range, the
+                               ///< bound in the direction of iteration (e.g.
+                               ///< the upper bound in case of mDirection ==
+                               ///< NEXT). If the cursor is based on a key, it
+                               ///< is unset. If mLocale is set, this was
+                               ///< converted to mLocale.
+  Key mLocaleAwarePosition;  ///< If mLocale is set, this is mPosition converted
+                             ///< to mLocale. Otherwise, it is unset.
 
   CursorOpBase* mCurrentlyRunningOp;
 
@@ -9288,7 +9288,7 @@
 
   ErrorResult errorResult;
   const auto result =
-      aBaseKey.ToLocaleBasedKey(*aLocalizedKey, aLocale, errorResult);
+      aBaseKey.ToLocaleAwareKey(*aLocalizedKey, aLocale, errorResult);
   if (!result.Is(Ok, errorResult)) {
     return NS_WARN_IF(result.Is(Exception, errorResult))
                ? errorResult.StealNSResult()
@@ -15034,7 +15034,7 @@
     return false;
   }
 
-  const Key& sortKey = IsLocaleAware() ? mSortKey : mKey;
+  const Key& sortKey = IsLocaleAware() ? mLocaleAwarePosition : mPosition;
 
   switch (aParams.type()) {
     case CursorRequestParams::TContinueParams: {
@@ -15072,16 +15072,18 @@
       MOZ_ASSERT(!primaryKey.IsUnset());
       switch (mDirection) {
         case IDBCursor::NEXT:
-          if (NS_WARN_IF(key < sortKey ||
-                         (key == sortKey && primaryKey <= mObjectKey))) {
+          if (NS_WARN_IF(
+                  key < sortKey ||
+                  (key == sortKey && primaryKey <= mObjectStorePosition))) {
             ASSERT_UNLESS_FUZZING();
             return false;
           }
           break;
 
         case IDBCursor::PREV:
-          if (NS_WARN_IF(key > sortKey ||
-                         (key == sortKey && primaryKey >= mObjectKey))) {
+          if (NS_WARN_IF(
+                  key > sortKey ||
+                  (key == sortKey && primaryKey >= mObjectStorePosition))) {
             ASSERT_UNLESS_FUZZING();
             return false;
           }
@@ -15143,11 +15145,12 @@
   MOZ_ASSERT_IF(aResponse.type() == CursorResponse::Tnsresult,
                 NS_ERROR_GET_MODULE(aResponse.get_nsresult()) ==
                     NS_ERROR_MODULE_DOM_INDEXEDDB);
-  MOZ_ASSERT_IF(aResponse.type() == CursorResponse::Tvoid_t, mKey.IsUnset());
+  MOZ_ASSERT_IF(aResponse.type() == CursorResponse::Tvoid_t,
+                mPosition.IsUnset());
   MOZ_ASSERT_IF(aResponse.type() == CursorResponse::Tvoid_t,
-                mRangeKey.IsUnset());
+                mLocaleAwareRangeBound.IsUnset());
   MOZ_ASSERT_IF(aResponse.type() == CursorResponse::Tvoid_t,
-                mObjectKey.IsUnset());
+                mObjectStorePosition.IsUnset());
   MOZ_ASSERT_IF(
       aResponse.type() == CursorResponse::Tnsresult ||
           aResponse.type() == CursorResponse::Tvoid_t ||
@@ -18623,12 +18626,13 @@
       return rv;
     }
 
-    rv = info.mKey.BindToStatement(stmt, kStmtParamNameValue);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-    rv = info.mSortKey.BindToStatement(stmt, kStmtParamNameValueLocale);
+    rv = info.mPosition.BindToStatement(stmt, kStmtParamNameValue);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    rv = info.mLocaleAwarePosition.BindToStatement(stmt,
+                                                   kStmtParamNameValueLocale);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -18651,7 +18655,7 @@
       for (int32_t index2 = int32_t(index) - 1;
            index2 >= 0 && aIndexValues[index2].mIndexId == info.mIndexId;
            --index2) {
-        if (info.mKey == aIndexValues[index2].mKey) {
+        if (info.mPosition == aIndexValues[index2].mPosition) {
           // We found a key with the same value for the same index. So we
           // must have had a collision with a value we just inserted.
           rv = NS_OK;
@@ -18725,7 +18729,7 @@
       return rv;
     }
 
-    rv = indexValue.mKey.BindToStatement(stmt, kStmtParamNameValue);
+    rv = indexValue.mPosition.BindToStatement(stmt, kStmtParamNameValue);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -20631,7 +20635,7 @@
       return rv;
     }
 
-    Key oldKey, newSortKey, objectKey;
+    Key oldKey, newSortKey, objectStorePosition;
     rv = oldKey.SetFromStatement(readStmt, 0);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
@@ -20643,7 +20647,7 @@
     }
 
     ErrorResult errorResult;
-    auto result = oldKey.ToLocaleBasedKey(newSortKey, aLocale, errorResult);
+    auto result = oldKey.ToLocaleAwareKey(newSortKey, aLocale, errorResult);
     if (!result.Is(Ok, errorResult)) {
       return NS_WARN_IF(result.Is(Exception, errorResult))
                  ? errorResult.StealNSResult()
@@ -20655,12 +20659,13 @@
       return rv;
     }
 
-    rv = objectKey.SetFromStatement(readStmt, 1);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-    rv = objectKey.BindToStatement(writeStmt, kStmtParamNameObjectDataKey);
+    rv = objectStorePosition.SetFromStatement(readStmt, 1);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    rv = objectStorePosition.BindToStatement(writeStmt,
+                                             kStmtParamNameObjectDataKey);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -25625,7 +25630,7 @@
   MOZ_ASSERT(mResponse.type() == CursorResponse::T__None);
   MOZ_ASSERT_IF(mFiles.IsEmpty(), aInitializeResponse);
 
-  nsresult rv = mCursor->mKey.SetFromStatement(aStmt, 0);
+  nsresult rv = mCursor->mPosition.SetFromStatement(aStmt, 0);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
@@ -25655,7 +25660,7 @@
       auto& responses = mResponse.get_ArrayOfObjectStoreCursorResponse();
       auto& response = *responses.AppendElement();
       response.cloneInfo().data().data = std::move(cloneInfo.mData);
-      response.key() = mCursor->mKey;
+      response.key() = mCursor->mPosition;
 
       mFiles.AppendElement(std::move(cloneInfo.mFiles));
       break;
@@ -25663,17 +25668,17 @@
 
     case OpenCursorParams::TObjectStoreOpenKeyCursorParams: {
       MOZ_ASSERT(aInitializeResponse);
-      mResponse = ObjectStoreKeyCursorResponse(mCursor->mKey);
+      mResponse = ObjectStoreKeyCursorResponse(mCursor->mPosition);
       break;
     }
 
     case OpenCursorParams::TIndexOpenCursorParams: {
-      rv = mCursor->mSortKey.SetFromStatement(aStmt, 1);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
-      }
-
-      rv = mCursor->mObjectKey.SetFromStatement(aStmt, 2);
+      rv = mCursor->mLocaleAwarePosition.SetFromStatement(aStmt, 1);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      rv = mCursor->mObjectStorePosition.SetFromStatement(aStmt, 2);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
@@ -25696,28 +25701,29 @@
 
       auto& response = mResponse.get_IndexCursorResponse();
       response.cloneInfo().data().data = std::move(cloneInfo.mData);
-      response.key() = mCursor->mKey;
-      response.sortKey() = mCursor->mSortKey;
-      response.objectKey() = mCursor->mObjectKey;
+      response.key() = mCursor->mPosition;
+      response.sortKey() = mCursor->mLocaleAwarePosition;
+      response.objectKey() = mCursor->mObjectStorePosition;
 
       mFiles.AppendElement(std::move(cloneInfo.mFiles));
       break;
     }
 
     case OpenCursorParams::TIndexOpenKeyCursorParams: {
-      rv = mCursor->mSortKey.SetFromStatement(aStmt, 1);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
-      }
-
-      rv = mCursor->mObjectKey.SetFromStatement(aStmt, 2);
+      rv = mCursor->mLocaleAwarePosition.SetFromStatement(aStmt, 1);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      rv = mCursor->mObjectStorePosition.SetFromStatement(aStmt, 2);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
 
       MOZ_ASSERT(aInitializeResponse);
-      mResponse = IndexKeyCursorResponse(mCursor->mKey, mCursor->mSortKey,
-                                         mCursor->mObjectKey);
+      mResponse = IndexKeyCursorResponse(mCursor->mPosition,
+                                         mCursor->mLocaleAwarePosition,
+                                         mCursor->mObjectStorePosition);
       break;
     }
 
@@ -25730,7 +25736,7 @@
 
 void Cursor::SetOptionalKeyRange(
     const Maybe<SerializedKeyRange>& aOptionalKeyRange, bool* const aOpen) {
-  MOZ_ASSERT(mRangeKey.IsUnset());
+  MOZ_ASSERT(mLocaleAwareRangeBound.IsUnset());
   MOZ_ASSERT(aOpen);
 
   if (aOptionalKeyRange.isSome()) {
@@ -25744,7 +25750,7 @@
         (range.isOnly() || lowerBound) ? range.lower() : range.upper();
     if (IsLocaleAware()) {
       ErrorResult rv;
-      Unused << bound.ToLocaleBasedKey(mRangeKey, mLocale, rv);
+      Unused << bound.ToLocaleAwareKey(mLocaleAwareRangeBound, mLocale, rv);
 
       // XXX Explain why the error is ignored here (If it's impossible, then we
       //     should change this to an assertion.)
@@ -25752,7 +25758,7 @@
         rv.SuppressException();
       }
     } else {
-      mRangeKey = bound;
+      mLocaleAwareRangeBound = bound;
     }
   } else {
     *aOpen = false;
@@ -25776,10 +25782,11 @@
     mCursor->SetOptionalKeyRange(mOptionalKeyRange, &open);
 
     // TODO: The first condition is probably redundant.
-    if (mOptionalKeyRange.isSome() && !mCursor->mRangeKey.IsUnset()) {
-      AppendConditionClause(aKeyString, kStmtParamNameRangeKey,
+    if (mOptionalKeyRange.isSome() &&
+        !mCursor->mLocaleAwareRangeBound.IsUnset()) {
+      AppendConditionClause(aKeyString, kStmtParamNameRangeBound,
                             isIncreasingOrder, !open, keyRangeClause);
-      AppendConditionClause(aKeyString, kStmtParamNameRangeKey,
+      AppendConditionClause(aKeyString, kStmtParamNameRangeBound,
                             isIncreasingOrder, !open, continueToKeyRangeClause);
     }
   }
@@ -25799,8 +25806,9 @@
   {
     bool open;
     mCursor->SetOptionalKeyRange(mOptionalKeyRange, &open);
-    if (mOptionalKeyRange.isSome() && !mCursor->mRangeKey.IsUnset()) {
-      AppendConditionClause(aSortColumn, kStmtParamNameRangeKey,
+    if (mOptionalKeyRange.isSome() &&
+        !mCursor->mLocaleAwareRangeBound.IsUnset()) {
+      AppendConditionClause(aSortColumn, kStmtParamNameRangeBound,
                             isIncreasingOrder, !open, aQueryStart);
     }
   }
@@ -25822,7 +25830,7 @@
           comparisonChar + NS_LITERAL_CSTRING(" :") + kStmtParamNameCurrentKey +
           NS_LITERAL_CSTRING(" OR ") + aObjectDataKeyPrefix +
           NS_LITERAL_CSTRING("object_data_key ") + comparisonChar +
-          NS_LITERAL_CSTRING(" :") + kStmtParamNameObjectKey +
+          NS_LITERAL_CSTRING(" :") + kStmtParamNameObjectStorePosition +
           NS_LITERAL_CSTRING(" ) ");
 
       mCursor->mContinuePrimaryKeyQuery =
@@ -25832,7 +25840,8 @@
               "(sort_column == :") +
           kStmtParamNameCurrentKey + NS_LITERAL_CSTRING(" AND ") +
           aObjectDataKeyPrefix + NS_LITERAL_CSTRING("object_data_key ") +
-          comparisonChar + NS_LITERAL_CSTRING("= :") + kStmtParamNameObjectKey +
+          comparisonChar + NS_LITERAL_CSTRING("= :") +
+          kStmtParamNameObjectStorePosition +
           NS_LITERAL_CSTRING(
               ") OR "
               "sort_column ") +
@@ -26238,8 +26247,8 @@
   MOZ_ASSERT(mCursor->mContinueQuery.IsEmpty());
   MOZ_ASSERT(mCursor->mContinueToQuery.IsEmpty());
   MOZ_ASSERT(mCursor->mContinuePrimaryKeyQuery.IsEmpty());
-  MOZ_ASSERT(mCursor->mKey.IsUnset());
-  MOZ_ASSERT(mCursor->mRangeKey.IsUnset());
+  MOZ_ASSERT(mCursor->mPosition.IsUnset());
+  MOZ_ASSERT(mCursor->mLocaleAwareRangeBound.IsUnset());
 
   AUTO_PROFILER_LABEL("Cursor::OpenOp::DoDatabaseWork", DOM);
 
@@ -26279,13 +26288,13 @@
   MOZ_ASSERT(mCursor->mCurrentlyRunningOp == this);
   MOZ_ASSERT(mResponse.type() != CursorResponse::T__None);
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mKey.IsUnset());
+                mCursor->mPosition.IsUnset());
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mSortKey.IsUnset());
+                mCursor->mLocaleAwarePosition.IsUnset());
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mRangeKey.IsUnset());
+                mCursor->mLocaleAwareRangeBound.IsUnset());
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mObjectKey.IsUnset());
+                mCursor->mObjectStorePosition.IsUnset());
 
   if (IsActorDestroyed()) {
     return NS_ERROR_DOM_INDEXEDDB_ABORT_ERR;
@@ -26306,7 +26315,7 @@
   MOZ_ASSERT(mCursor->mObjectStoreId);
   MOZ_ASSERT(!mCursor->mContinueQuery.IsEmpty());
   MOZ_ASSERT(!mCursor->mContinueToQuery.IsEmpty());
-  MOZ_ASSERT(!mCursor->mKey.IsUnset());
+  MOZ_ASSERT(!mCursor->mPosition.IsUnset());
 
   const bool isIndex =
       mCursor->mType == OpenCursorParams::TIndexOpenCursorParams ||
@@ -26316,7 +26325,7 @@
                             mCursor->mDirection == IDBCursor::PREV),
                 !mCursor->mContinuePrimaryKeyQuery.IsEmpty());
   MOZ_ASSERT_IF(isIndex, mCursor->mIndexId);
-  MOZ_ASSERT_IF(isIndex, !mCursor->mObjectKey.IsUnset());
+  MOZ_ASSERT_IF(isIndex, !mCursor->mObjectStorePosition.IsUnset());
 
   AUTO_PROFILER_LABEL("Cursor::ContinueOp::DoDatabaseWork", DOM);
 
@@ -26332,8 +26341,8 @@
   bool hasContinueKey = false;
   bool hasContinuePrimaryKey = false;
   uint32_t advanceCount = 1;
-  Key& currentKey =
-      mCursor->IsLocaleAware() ? mCursor->mSortKey : mCursor->mKey;
+  Key& currentKey = mCursor->IsLocaleAware() ? mCursor->mLocaleAwarePosition
+                                             : mCursor->mPosition;
 
   switch (mParams.type()) {
     case CursorRequestParams::TContinueParams:
@@ -26368,8 +26377,6 @@
   nsAutoCString countString;
   countString.AppendInt(advanceCount);
 
-  const bool usingRangeKey = !mCursor->mRangeKey.IsUnset();
-
   DatabaseConnection::CachedStatement stmt;
   nsresult rv = aConnection->GetCachedStatement(continueQuery, &stmt);
   if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -26396,29 +26403,31 @@
     return rv;
   }
 
-  // Bind range key if it is specified.
-  if (usingRangeKey) {
-    rv = mCursor->mRangeKey.BindToStatement(stmt, kStmtParamNameRangeKey);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-  }
-
-  // Bind object key if duplicates are allowed and we're not continuing to a
-  // specific key.
+  // Bind range bound if it is specified.
+  if (!mCursor->mLocaleAwareRangeBound.IsUnset()) {
+    rv = mCursor->mLocaleAwareRangeBound.BindToStatement(
+        stmt, kStmtParamNameRangeBound);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+  }
+
+  // Bind object store position if duplicates are allowed and we're not
+  // continuing to a specific key.
   if (isIndex && !hasContinueKey &&
       (mCursor->mDirection == IDBCursor::NEXT ||
        mCursor->mDirection == IDBCursor::PREV)) {
-    rv = mCursor->mObjectKey.BindToStatement(stmt, kStmtParamNameObjectKey);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-  }
-
-  // Bind object key if primaryKey is specified.
+    rv = mCursor->mObjectStorePosition.BindToStatement(
+        stmt, kStmtParamNameObjectStorePosition);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+  }
+
+  // Bind object store position if primaryKey is specified.
   if (hasContinuePrimaryKey) {
     rv = mParams.get_ContinuePrimaryKeyParams().primaryKey().BindToStatement(
-        stmt, kStmtParamNameObjectKey);
+        stmt, kStmtParamNameObjectStorePosition);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -26432,10 +26441,10 @@
     }
 
     if (!hasResult) {
-      mCursor->mKey.Unset();
-      mCursor->mSortKey.Unset();
-      mCursor->mRangeKey.Unset();
-      mCursor->mObjectKey.Unset();
+      mCursor->mPosition.Unset();
+      mCursor->mLocaleAwarePosition.Unset();
+      mCursor->mLocaleAwareRangeBound.Unset();
+      mCursor->mObjectStorePosition.Unset();
       mResponse = void_t();
       return NS_OK;
     }
@@ -26454,11 +26463,11 @@
   MOZ_ASSERT(mCursor);
   MOZ_ASSERT(mCursor->mCurrentlyRunningOp == this);
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mKey.IsUnset());
+                mCursor->mPosition.IsUnset());
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mRangeKey.IsUnset());
+                mCursor->mLocaleAwareRangeBound.IsUnset());
   MOZ_ASSERT_IF(mResponse.type() == CursorResponse::Tvoid_t,
-                mCursor->mObjectKey.IsUnset());
+                mCursor->mObjectStorePosition.IsUnset());
 
   if (IsActorDestroyed()) {
     return NS_ERROR_DOM_INDEXEDDB_ABORT_ERR;