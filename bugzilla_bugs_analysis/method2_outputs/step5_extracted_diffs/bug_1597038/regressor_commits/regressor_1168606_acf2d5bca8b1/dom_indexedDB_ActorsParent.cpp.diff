# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsParent.cpp
# Commit: acf2d5bca8b1
# Full Hash: acf2d5bca8b12f1b4ec38fae19e39b04f2afe502
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2019-10-03 16:42:51
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Replaced custom for loops by range-based for or STL algorithms. r=ttung
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44988
# ==============================================================================

diff -r cddcfdcb52f6 -r acf2d5bca8b1 dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp	Thu Oct 03 07:56:45 2019 +0000
+++ b/dom/indexedDB/ActorsParent.cpp	Thu Oct 03 07:56:57 2019 +0000
@@ -580,15 +580,11 @@
 
   static const uint32_t kGoldenRatioU32 = 0x9e3779b9u;
 
-  const char16_t* str = aName.BeginReading();
-  size_t length = aName.Length();
-
-  uint32_t hash = 0;
-  for (size_t i = 0; i < length; i++) {
-    hash = kGoldenRatioU32 * (Helper::RotateBitsLeft32(hash, 5) ^ str[i]);
-  }
-
-  return hash;
+  return std::accumulate(aName.BeginReading(), aName.EndReading(), uint32_t(0),
+                         [](uint32_t hash, char16_t ch) {
+                           return kGoldenRatioU32 *
+                                  (Helper::RotateBitsLeft32(hash, 5) ^ ch);
+                         });
 }
 
 nsresult ClampResultCode(nsresult aResultCode) {
@@ -775,8 +771,7 @@
   // First calculate the size of the final buffer.
   uint32_t blobDataLength = 0;
 
-  for (uint32_t arrayIndex = 0; arrayIndex < arrayLength; arrayIndex++) {
-    const IndexDataValue& info = aIndexValues[arrayIndex];
+  for (const IndexDataValue& info : aIndexValues) {
     const nsCString& keyBuffer = info.mPosition.GetBuffer();
     const nsCString& sortKeyBuffer = info.mLocaleAwarePosition.GetBuffer();
     const uint32_t keyBufferLength = keyBuffer.Length();
@@ -813,8 +808,7 @@
 
   uint8_t* blobDataIter = blobData.get();
 
-  for (uint32_t arrayIndex = 0; arrayIndex < arrayLength; arrayIndex++) {
-    const IndexDataValue& info = aIndexValues[arrayIndex];
+  for (const IndexDataValue& info : aIndexValues) {
     const nsCString& keyBuffer = info.mPosition.GetBuffer();
     const nsCString& sortKeyBuffer = info.mLocaleAwarePosition.GetBuffer();
     const uint32_t keyBufferLength = keyBuffer.Length();
@@ -2722,9 +2716,8 @@
     const uint32_t byteCount =
         AdjustedSize(sizeof(uint64_t), aSource, aSourceEnd);
 
-    for (uint32_t count = 0; count < byteCount; count++) {
-      *aDestination++ = *aSource++;
-    }
+    aDestination = std::copy(aSource, aSource + byteCount, aDestination);
+    aSource += byteCount;
 
     return NS_OK;
   }
@@ -2749,9 +2742,8 @@
         const uint32_t byteCount =
             AdjustedSize((byte & 0x40) ? 2 : 1, aSource, aSourceEnd);
 
-        for (uint32_t count = 0; count < byteCount; count++) {
-          *aDestination++ = *aSource++;
-        }
+        aDestination = std::copy(aSource, aSource + byteCount, aDestination);
+        aSource += byteCount;
       }
     }
 
@@ -7342,7 +7334,7 @@
     MOZ_COUNT_DTOR(ObjectStoreAddOrPutRequestOp::StoredFileInfo);
   }
 
-  void Serialize(nsString& aText) {
+  void Serialize(nsString& aText) const {
     MOZ_ASSERT(mFileInfo);
 
     const int64_t id = mFileInfo->Id();
@@ -8651,9 +8643,7 @@
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  for (uint32_t index = 0; index < count; index++) {
-    const StructuredCloneFile& file = aFiles[index];
-
+  for (const StructuredCloneFile& file : aFiles) {
     if (aForPreprocess && file.mType != StructuredCloneFile::eStructuredClone) {
       continue;
     }
@@ -10541,10 +10531,7 @@
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
-
-  for (uint32_t i = 0; i < files.Length(); i++) {
-    const StructuredCloneFile& file = files[i];
-
+  for (const StructuredCloneFile& file : files) {
     const int64_t id = file.mFileInfo->Id();
     MOZ_ASSERT(id > 0);
 
@@ -10591,9 +10578,7 @@
     return NS_ERROR_FAILURE;
   }
 
-  for (uint32_t i = 0; i < mJournalsToCreateBeforeCommit.Length(); i++) {
-    int64_t id = mJournalsToCreateBeforeCommit[i];
-
+  for (const int64_t id : mJournalsToCreateBeforeCommit) {
     nsCOMPtr<nsIFile> file = FileManager::GetFileForId(journalDirectory, id);
     if (NS_WARN_IF(!file)) {
       return NS_ERROR_FAILURE;
@@ -10623,9 +10608,9 @@
     return NS_ERROR_FAILURE;
   }
 
-  for (uint32_t index = 0; index < aJournals.Length(); index++) {
+  for (const auto& journal : aJournals) {
     nsCOMPtr<nsIFile> file =
-        FileManager::GetFileForId(journalDirectory, aJournals[index]);
+        FileManager::GetFileForId(journalDirectory, journal);
     if (NS_WARN_IF(!file)) {
       return NS_ERROR_FAILURE;
     }
@@ -11005,10 +10990,7 @@
 
   auto& blockingTransactions = dbInfo->mBlockingTransactions;
 
-  for (uint32_t nameIndex = 0, nameCount = aObjectStoreNames.Length();
-       nameIndex < nameCount; nameIndex++) {
-    const nsString& objectStoreName = aObjectStoreNames[nameIndex];
-
+  for (const nsString& objectStoreName : aObjectStoreNames) {
     TransactionInfoPair* blockInfo = blockingTransactions.Get(objectStoreName);
     if (!blockInfo) {
       blockInfo = new TransactionInfoPair();
@@ -11022,15 +11004,11 @@
     }
 
     if (aIsWriteTransaction) {
-      if (const uint32_t writeCount = blockInfo->mLastBlockingWrites.Length()) {
-        for (uint32_t writeIndex = 0; writeIndex < writeCount; writeIndex++) {
-          TransactionInfo* blockingWrite =
-              blockInfo->mLastBlockingWrites[writeIndex];
-          MOZ_ASSERT(blockingWrite);
-
-          transactionInfo->mBlockedOn.PutEntry(blockingWrite);
-          blockingWrite->AddBlockingTransaction(transactionInfo);
-        }
+      for (TransactionInfo* blockingWrite : blockInfo->mLastBlockingWrites) {
+        MOZ_ASSERT(blockingWrite);
+
+        transactionInfo->mBlockedOn.PutEntry(blockingWrite);
+        blockingWrite->AddBlockingTransaction(transactionInfo);
       }
 
       blockInfo->mLastBlockingReads = transactionInfo;
@@ -11113,9 +11091,7 @@
 
   bool mayRunCallbackImmediately = true;
 
-  for (uint32_t index = 0, count = aDatabaseIds.Length(); index < count;
-       index++) {
-    const nsCString& databaseId = aDatabaseIds[index];
+  for (const nsCString& databaseId : aDatabaseIds) {
     MOZ_ASSERT(!databaseId.IsEmpty());
 
     if (CloseDatabaseWhenIdleInternal(databaseId)) {
@@ -11315,13 +11291,10 @@
 
   AUTO_PROFILER_LABEL("ConnectionPool::ShutdownIdleThreads", DOM);
 
-  if (!mIdleThreads.IsEmpty()) {
-    for (uint32_t threadCount = mIdleThreads.Length(), threadIndex = 0;
-         threadIndex < threadCount; threadIndex++) {
-      ShutdownThread(mIdleThreads[threadIndex].mThreadInfo);
-    }
-    mIdleThreads.Clear();
-  }
+  for (auto& idleThread : mIdleThreads) {
+    ShutdownThread(idleThread.mThreadInfo);
+  }
+  mIdleThreads.Clear();
 }
 
 bool ConnectionPool::ScheduleTransaction(TransactionInfo* aTransactionInfo,
@@ -11437,10 +11410,11 @@
       aTransactionInfo->mQueuedRunnables;
 
   if (!queuedRunnables.IsEmpty()) {
-    for (uint32_t index = 0, count = queuedRunnables.Length(); index < count;
-         index++) {
+    for (auto& queuedRunnable : queuedRunnables) {
+      // TODO: Why do we need this? queuedRunnables is cleared afterwards
+      // anyway.
       nsCOMPtr<nsIRunnable> runnable;
-      queuedRunnables[index].swap(runnable);
+      queuedRunnable.swap(runnable);
 
       MOZ_ALWAYS_SUCCEEDS(dbInfo->mThreadInfo.mThread->Dispatch(
           runnable.forget(), NS_DISPATCH_NORMAL));
@@ -11489,13 +11463,9 @@
     }
   }
 
-  const nsTArray<nsString>& objectStoreNames =
-      transactionInfo->mObjectStoreNames;
-
-  for (uint32_t index = 0, count = objectStoreNames.Length(); index < count;
-       index++) {
+  for (const auto& objectStoreName : transactionInfo->mObjectStoreNames) {
     TransactionInfoPair* blockInfo =
-        dbInfo->mBlockingTransactions.Get(objectStoreNames[index]);
+        dbInfo->mBlockingTransactions.Get(objectStoreName);
     MOZ_ASSERT(blockInfo);
 
     if (transactionInfo->mIsWriteTransaction &&
@@ -11545,17 +11515,14 @@
   aThreadInfo.mRunnable = nullptr;
   aThreadInfo.mThread = nullptr;
 
-  uint32_t index = 0;
-  for (uint32_t count = mQueuedTransactions.Length(); index < count; index++) {
-    if (!ScheduleTransaction(mQueuedTransactions[index],
-                             /* aFromQueuedTransactions */ true)) {
-      break;
-    }
-  }
-
-  if (index) {
-    mQueuedTransactions.RemoveElementsAt(0, index);
-  }
+  const auto foundIt = std::find_if(
+      mQueuedTransactions.begin(), mQueuedTransactions.end(),
+      [& me = *this](const auto& queuedTransaction) {
+        return !me.ScheduleTransaction(queuedTransaction,
+                                       /* aFromQueuedTransactions */ true);
+      });
+
+  mQueuedTransactions.RemoveElementsAt(mQueuedTransactions.begin(), foundIt);
 
   AdjustIdleTimer();
 }
@@ -11653,9 +11620,8 @@
 
     MOZ_ASSERT(!scheduledTransactions.IsEmpty());
 
-    for (uint32_t index = 0, count = scheduledTransactions.Length();
-         index < count; index++) {
-      Unused << ScheduleTransaction(scheduledTransactions[index],
+    for (const auto& scheduledTransaction : scheduledTransactions) {
+      Unused << ScheduleTransaction(scheduledTransaction,
                                     /* aFromQueuedTransactions */ false);
     }
 
@@ -11679,14 +11645,12 @@
 
   // See if we need to fire any complete callbacks now that the database is
   // finished.
-  for (uint32_t index = 0; index < mCompleteCallbacks.Length();
-       /* conditionally incremented */) {
-    if (MaybeFireCallback(mCompleteCallbacks[index])) {
-      mCompleteCallbacks.RemoveElementAt(index);
-    } else {
-      index++;
-    }
-  }
+  mCompleteCallbacks.RemoveElementsAt(
+      std::remove_if(mCompleteCallbacks.begin(), mCompleteCallbacks.end(),
+                     [& me = *this](const auto& completeCallback) {
+                       return me.MaybeFireCallback(completeCallback);
+                     }),
+      mCompleteCallbacks.end());
 
   // If that was the last database and we're supposed to be shutting down then
   // we are finished.
@@ -12183,9 +12147,7 @@
 void ConnectionPool::TransactionInfo::RemoveBlockingTransactions() {
   AssertIsOnBackgroundThread();
 
-  for (uint32_t index = 0, count = mBlockingOrdered.Length(); index < count;
-       index++) {
-    TransactionInfo* blockedInfo = mBlockingOrdered[index];
+  for (TransactionInfo* blockedInfo : mBlockingOrdered) {
     MOZ_ASSERT(blockedInfo);
 
     blockedInfo->MaybeUnblock(this);
@@ -12670,8 +12632,7 @@
       if (count) {
         IDB_REPORT_INTERNAL_ERR();
 
-        for (uint32_t index = 0; index < count; index++) {
-          RefPtr<TransactionBase> transaction = transactions[index].forget();
+        for (auto& transaction : transactions) {
           MOZ_ASSERT(transaction);
 
           transaction->Invalidate();
@@ -12705,8 +12666,7 @@
       if (count) {
         IDB_REPORT_INTERNAL_ERR();
 
-        for (uint32_t index = 0; index < count; index++) {
-          RefPtr<MutableFile> mutableFile = mutableFiles[index].forget();
+        for (auto& mutableFile : mutableFiles) {
           MOZ_ASSERT(mutableFile);
 
           mutableFile->Invalidate();
@@ -13934,29 +13894,23 @@
     return false;
   }
 
-  const nsTArray<IndexUpdateInfo>& updates = aParams.indexUpdateInfos();
-
-  for (uint32_t index = 0; index < updates.Length(); index++) {
+  for (const auto& updateInfo : aParams.indexUpdateInfos()) {
     RefPtr<FullIndexMetadata> indexMetadata =
-        GetMetadataForIndexId(objMetadata, updates[index].indexId());
+        GetMetadataForIndexId(objMetadata, updateInfo.indexId());
     if (NS_WARN_IF(!indexMetadata)) {
       ASSERT_UNLESS_FUZZING();
       return false;
     }
 
-    if (NS_WARN_IF(updates[index].value().IsUnset())) {
+    if (NS_WARN_IF(updateInfo.value().IsUnset())) {
       ASSERT_UNLESS_FUZZING();
       return false;
     }
 
-    MOZ_ASSERT(!updates[index].value().GetBuffer().IsEmpty());
-  }
-
-  const nsTArray<FileAddInfo>& fileAddInfos = aParams.fileAddInfos();
-
-  for (uint32_t index = 0; index < fileAddInfos.Length(); index++) {
-    const FileAddInfo& fileAddInfo = fileAddInfos[index];
-
+    MOZ_ASSERT(!updateInfo.value().GetBuffer().IsEmpty());
+  }
+
+  for (const FileAddInfo& fileAddInfo : aParams.fileAddInfos()) {
     const DatabaseOrMutableFile& file = fileAddInfo.file();
     MOZ_ASSERT(file.type() != DatabaseOrMutableFile::T__None);
 
@@ -14459,9 +14413,8 @@
   info->mMetadata.swap(newMetadata);
 
   // Replace metadata pointers for all live databases.
-  for (uint32_t count = info->mLiveDatabases.Length(), index = 0; index < count;
-       index++) {
-    info->mLiveDatabases[index]->mMetadata = info->mMetadata;
+  for (const auto& liveDatabase : info->mLiveDatabases) {
+    liveDatabase->mMetadata = info->mMetadata;
   }
 
   return true;
@@ -14522,9 +14475,8 @@
     // Replace metadata pointers for all live databases.
     info->mMetadata = oldMetadata.forget();
 
-    for (uint32_t count = info->mLiveDatabases.Length(), index = 0;
-         index < count; index++) {
-      info->mLiveDatabases[index]->mMetadata = info->mMetadata;
+    for (auto& liveDatabase : info->mLiveDatabases) {
+      liveDatabase->mMetadata = info->mMetadata;
     }
   }
 }
@@ -16032,9 +15984,7 @@
     return rv;
   }
 
-  for (uint32_t count = subdirsToProcess.Length(), i = 0; i < count; i++) {
-    const nsString& subdirName = subdirsToProcess[i];
-
+  for (const nsString& subdirName : subdirsToProcess) {
     // If the directory has the correct suffix then it should exist in
     // databaseFilenames.
     nsDependentSubstring subdirNameBase;
@@ -16188,9 +16138,7 @@
     return rv;
   }
 
-  for (uint32_t count = subdirsToProcess.Length(), i = 0; i < count; i++) {
-    const nsString& subdirName = subdirsToProcess[i];
-
+  for (const nsString& subdirName : subdirsToProcess) {
     // The directory must have the correct suffix.
     nsDependentSubstring subdirNameBase;
     if (NS_WARN_IF(!GetBaseFilename(subdirName, kFileManagerDirectoryNameSuffix,
@@ -18675,8 +18623,7 @@
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  for (uint32_t idxIndex = 0; idxIndex < count; idxIndex++) {
-    const IndexUpdateInfo& updateInfo = aUpdateInfos[idxIndex];
+  for (const IndexUpdateInfo& updateInfo : aUpdateInfos) {
     const int64_t& indexId = updateInfo.indexId();
     const Key& key = updateInfo.value();
     const Key& sortKey = updateInfo.localizedValue();
@@ -19841,8 +19788,7 @@
   const uint32_t liveCount = aDatabaseActorInfo->mLiveDatabases.Length();
   if (liveCount > expectedCount) {
     FallibleTArray<MaybeBlockedDatabaseInfo> maybeBlockedDatabases;
-    for (uint32_t index = 0; index < liveCount; index++) {
-      Database* database = aDatabaseActorInfo->mLiveDatabases[index];
+    for (const auto& database : aDatabaseActorInfo->mLiveDatabases) {
       if ((!aOpeningDatabase || database != aOpeningDatabase) &&
           !database->IsClosed() &&
           NS_WARN_IF(
@@ -19856,24 +19802,19 @@
     }
   }
 
-  if (!mMaybeBlockedDatabases.IsEmpty()) {
-    for (uint32_t count = mMaybeBlockedDatabases.Length(), index = 0;
-         index < count;
-         /* incremented conditionally */) {
-      if (mMaybeBlockedDatabases[index]->SendVersionChange(aOldVersion,
-                                                           aNewVersion)) {
-        index++;
-      } else {
-        // We don't want to wait forever if we were not able to send the
-        // message.
-        mMaybeBlockedDatabases.RemoveElementAt(index);
-        count--;
-      }
-    }
-  }
-
-  return NS_OK;
-}
+  // We don't want to wait forever if we were not able to send the
+  // message.
+  mMaybeBlockedDatabases.RemoveElementsAt(
+      std::remove_if(mMaybeBlockedDatabases.begin(),
+                     mMaybeBlockedDatabases.end(),
+                     [aOldVersion, &aNewVersion](auto& maybeBlockedDatabase) {
+                       return !maybeBlockedDatabase->SendVersionChange(
+                           aOldVersion, aNewVersion);
+                     }),
+      mMaybeBlockedDatabases.end());
+
+  return NS_OK;
+}  // namespace indexedDB
 
 // static
 bool FactoryOp::CheckAtLeastOneAppHasPermission(
@@ -19998,9 +19939,7 @@
   // Otherwise if it was blocked its |mBlocked| flag will be true.
   bool sendBlockedEvent = true;
 
-  for (uint32_t count = mMaybeBlockedDatabases.Length(), index = 0;
-       index < count; index++) {
-    MaybeBlockedDatabaseInfo& info = mMaybeBlockedDatabases[index];
+  for (auto& info : mMaybeBlockedDatabases) {
     if (info == aDatabase) {
       // This database was blocked, mark accordingly.
       info.mBlocked = true;
@@ -21846,9 +21785,10 @@
           // here to make sure we find invalid uses later.
           info = nullptr;
 #endif
-          for (uint32_t count = liveDatabases.Length(), index = 0;
-               index < count; index++) {
-            RefPtr<Database> database = liveDatabases[index];
+          // TODO: Why do we convert to RefPtr here? If this is really
+          // necessary, this is very error-prone, and provide the type of
+          // liveDatabases should be changed.
+          for (RefPtr<Database> database : liveDatabases) {
             database->Invalidate();
           }
 
@@ -22225,9 +22165,7 @@
     DatabaseConnection::CachedStatement stmt;
     nsresult rv;
 
-    for (uint32_t count = metadataArray.Length(), index = 0; index < count;
-         index++) {
-      const RefPtr<FullObjectStoreMetadata>& metadata = metadataArray[index];
+    for (const auto& metadata : metadataArray) {
       MOZ_ASSERT(!metadata->mDeleted);
       MOZ_ASSERT(metadata->mNextAutoIncrementId > 1);
 
@@ -22280,10 +22218,7 @@
   if (!metadataArray.IsEmpty()) {
     bool committed = NS_SUCCEEDED(mResultCode);
 
-    for (uint32_t count = metadataArray.Length(), index = 0; index < count;
-         index++) {
-      RefPtr<FullObjectStoreMetadata>& metadata = metadataArray[index];
-
+    for (const auto& metadata : metadataArray) {
       if (committed) {
         metadata->mCommittedAutoIncrementId = metadata->mNextAutoIncrementId;
       } else {
@@ -23381,9 +23316,7 @@
   }
 
   // First construct the full list to update the index_data_values row.
-  for (uint32_t index = 0; index < updateInfoCount; index++) {
-    const IndexUpdateInfo& info = updateInfos[index];
-
+  for (const IndexUpdateInfo& info : updateInfos) {
     MOZ_ALWAYS_TRUE(indexValues.InsertElementSorted(
         IndexDataValue(metadata.id(), metadata.unique(), info.value(),
                        info.localizedValue()),
@@ -23416,9 +23349,7 @@
 
     MOZ_ASSERT(indexValues.Capacity() >= updateInfoCount);
 
-    for (uint32_t index = 0; index < updateInfoCount; index++) {
-      const IndexUpdateInfo& info = updateInfos[index];
-
+    for (const IndexUpdateInfo& info : updateInfos) {
       MOZ_ALWAYS_TRUE(indexValues.InsertElementSorted(
           IndexDataValue(metadata.id(), metadata.unique(), info.value(),
                          info.localizedValue()),
@@ -24213,13 +24144,9 @@
       mParams.indexUpdateInfos();
 
   if (!indexUpdateInfos.IsEmpty()) {
-    const uint32_t count = indexUpdateInfos.Length();
-
     mUniqueIndexTable.emplace();
 
-    for (uint32_t index = 0; index < count; index++) {
-      const IndexUpdateInfo& updateInfo = indexUpdateInfos[index];
-
+    for (const auto& updateInfo : indexUpdateInfos) {
       RefPtr<FullIndexMetadata> indexMetadata;
       MOZ_ALWAYS_TRUE(mMetadata->mIndexes.Get(updateInfo.indexId(),
                                               getter_AddRefs(indexMetadata)));
@@ -24256,9 +24183,7 @@
       return false;
     }
 
-    for (uint32_t index = 0; index < count; index++) {
-      const FileAddInfo& fileAddInfo = fileAddInfos[index];
-
+    for (const auto& fileAddInfo : fileAddInfos) {
       MOZ_ASSERT(fileAddInfo.type() == StructuredCloneFile::eBlob ||
                  fileAddInfo.type() == StructuredCloneFile::eMutableFile);
 
@@ -24505,9 +24430,7 @@
     Maybe<FileHelper> fileHelper;
     nsAutoString fileIds;
 
-    for (uint32_t count = mStoredFileInfos.Length(), index = 0; index < count;
-         index++) {
-      StoredFileInfo& storedFileInfo = mStoredFileInfos[index];
+    for (auto& storedFileInfo : mStoredFileInfos) {
       MOZ_ASSERT(storedFileInfo.mFileInfo);
 
       // If there is a StoredFileInfo, then one of the following is true:
@@ -24546,7 +24469,7 @@
           }
         }
 
-        RefPtr<FileInfo>& fileInfo = storedFileInfo.mFileInfo;
+        const RefPtr<FileInfo>& fileInfo = storedFileInfo.mFileInfo;
 
         nsCOMPtr<nsIFile> file = fileHelper->GetFile(fileInfo);
         if (NS_WARN_IF(!file)) {
@@ -24584,7 +24507,7 @@
         }
       }
 
-      if (index) {
+      if (!fileIds.IsEmpty()) {
         fileIds.Append(' ');
       }
       storedFileInfo.Serialize(fileIds);
@@ -24873,10 +24796,7 @@
     }
 
     uint32_t fallibleIndex = 0;
-    for (uint32_t count = mResponse.Length(), index = 0; index < count;
-         index++) {
-      StructuredCloneReadInfo& info = mResponse[index];
-
+    for (auto& info : mResponse) {
       if (info.mHasPreprocessInfo) {
         nsresult rv = ConvertResponse<true>(
             info, falliblePreprocessInfos[fallibleIndex++]);
