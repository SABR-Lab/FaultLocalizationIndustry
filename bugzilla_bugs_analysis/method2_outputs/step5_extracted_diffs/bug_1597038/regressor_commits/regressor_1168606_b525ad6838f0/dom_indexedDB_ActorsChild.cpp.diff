# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsChild.cpp
# Commit: b525ad6838f0
# Full Hash: b525ad6838f091c2ab7cfc52cda593eca7941fa8
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2019-11-05 22:07:34
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Add support for preloading key-only cursors. r=ttung,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44009
# ==============================================================================

diff -r c009bbdbbfd5 -r b525ad6838f0 dom/indexedDB/ActorsChild.cpp
--- a/dom/indexedDB/ActorsChild.cpp	Tue Nov 05 14:40:35 2019 +0000
+++ b/dom/indexedDB/ActorsChild.cpp	Tue Nov 05 14:40:31 2019 +0000
@@ -3227,6 +3227,16 @@
       mObjectStoreKey{std::move(aObjectStoreKey)},
       mCloneInfo{std::move(aCloneInfo)} {}
 
+BackgroundCursorChild::CachedResponse::CachedResponse(Key aKey)
+    : mKey{std::move(aKey)} {}
+
+BackgroundCursorChild::CachedResponse::CachedResponse(Key aKey,
+                                                      Key aLocaleAwareKey,
+                                                      Key aObjectStoreKey)
+    : mKey{std::move(aKey)},
+      mLocaleAwareKey{std::move(aLocaleAwareKey)},
+      mObjectStoreKey{std::move(aObjectStoreKey)} {}
+
 // Does not need to be threadsafe since this only runs on one thread, but
 // inheriting from CancelableRunnable is easy.
 class BackgroundCursorChild::DelayedActionRunnable final
@@ -3433,9 +3443,6 @@
   MOZ_ASSERT(mCursor);
   MOZ_ASSERT(mStrongCursor);
   MOZ_ASSERT(!mDelayedResponses.empty());
-  // TODO: Also support the other types.
-  MOZ_ASSERT(mCursor->GetType() == IDBCursor::Type_ObjectStore ||
-             mCursor->GetType() == IDBCursor::Type_Index);
 
   RefPtr<IDBCursor> cursor;
   mStrongCursor.swap(cursor);
@@ -3450,8 +3457,14 @@
                      std::move(item.mObjectStoreKey),
                      std::move(item.mCloneInfo));
       break;
+    case IDBCursor::Type_ObjectStoreKey:
+      mCursor->Reset(std::move(item.mKey));
+      break;
+    case IDBCursor::Type_IndexKey:
+      mCursor->Reset(std::move(item.mKey), std::move(item.mLocaleAwareKey),
+                     std::move(item.mObjectStoreKey));
+      break;
     default:
-      // TODO: Also support the other types.
       MOZ_CRASH("Should never get here.");
   }
   mDelayedResponses.pop_front();
@@ -3629,28 +3642,25 @@
 }
 
 void BackgroundCursorChild::HandleResponse(
-    const ObjectStoreKeyCursorResponse& aResponse) {
+    const nsTArray<ObjectStoreKeyCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mRequest);
-  MOZ_ASSERT(mTransaction);
   MOZ_ASSERT(mObjectStore);
-  MOZ_ASSERT(!mStrongRequest);
-  MOZ_ASSERT(!mStrongCursor);
-
-  // XXX Fix this somehow...
-  auto& response = const_cast<ObjectStoreKeyCursorResponse&>(aResponse);
-
-  RefPtr<IDBCursor> newCursor;
-
-  if (mCursor) {
-    mCursor->Reset(std::move(response.key()));
-  } else {
-    newCursor = IDBCursor::Create(this, std::move(response.key()));
-    mCursor = newCursor;
-  }
-
-  ResultHelper helper(mRequest, mTransaction, mCursor);
-  DispatchSuccessEvent(&helper);
+
+  HandleMultipleCursorResponses(
+      aResponses, [this](ObjectStoreKeyCursorResponse& response) {
+        RefPtr<IDBCursor> newCursor;
+
+        if (mCursor) {
+          if (mCursor->IsContinueCalled()) {
+            mCursor->Reset(std::move(response.key()));
+          } else {
+            mCachedResponses.emplace_back(std::move(response.key()));
+          }
+        } else {
+          newCursor = IDBCursor::Create(this, std::move(response.key()));
+          mCursor = newCursor;
+        }
+      });
 }
 
 void BackgroundCursorChild::HandleResponse(
@@ -3688,31 +3698,31 @@
 }
 
 void BackgroundCursorChild::HandleResponse(
-    const IndexKeyCursorResponse& aResponse) {
+    const nsTArray<IndexKeyCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mRequest);
-  MOZ_ASSERT(mTransaction);
   MOZ_ASSERT(mIndex);
-  MOZ_ASSERT(!mStrongRequest);
-  MOZ_ASSERT(!mStrongCursor);
-
-  // XXX Fix this somehow...
-  auto& response = const_cast<IndexKeyCursorResponse&>(aResponse);
-
-  RefPtr<IDBCursor> newCursor;
-
-  if (mCursor) {
-    mCursor->Reset(std::move(response.key()), std::move(response.sortKey()),
-                   std::move(response.objectKey()));
-  } else {
-    newCursor = IDBCursor::Create(this, std::move(response.key()),
-                                  std::move(response.sortKey()),
-                                  std::move(response.objectKey()));
-    mCursor = newCursor;
-  }
-
-  ResultHelper helper(mRequest, mTransaction, mCursor);
-  DispatchSuccessEvent(&helper);
+
+  HandleMultipleCursorResponses(
+      aResponses, [this](IndexKeyCursorResponse& response) {
+        RefPtr<IDBCursor> newCursor;
+
+        if (mCursor) {
+          if (mCursor->IsContinueCalled()) {
+            mCursor->Reset(std::move(response.key()),
+                           std::move(response.sortKey()),
+                           std::move(response.objectKey()));
+          } else {
+            mCachedResponses.emplace_back(std::move(response.key()),
+                                          std::move(response.sortKey()),
+                                          std::move(response.objectKey()));
+          }
+        } else {
+          newCursor = IDBCursor::Create(this, std::move(response.key()),
+                                        std::move(response.sortKey()),
+                                        std::move(response.objectKey()));
+          mCursor = newCursor;
+        }
+      });
 }
 
 void BackgroundCursorChild::ActorDestroy(ActorDestroyReason aWhy) {
@@ -3774,16 +3784,16 @@
       HandleResponse(aResponse.get_ArrayOfObjectStoreCursorResponse());
       break;
 
-    case CursorResponse::TObjectStoreKeyCursorResponse:
-      HandleResponse(aResponse.get_ObjectStoreKeyCursorResponse());
+    case CursorResponse::TArrayOfObjectStoreKeyCursorResponse:
+      HandleResponse(aResponse.get_ArrayOfObjectStoreKeyCursorResponse());
       break;
 
     case CursorResponse::TArrayOfIndexCursorResponse:
       HandleResponse(aResponse.get_ArrayOfIndexCursorResponse());
       break;
 
-    case CursorResponse::TIndexKeyCursorResponse:
-      HandleResponse(aResponse.get_IndexKeyCursorResponse());
+    case CursorResponse::TArrayOfIndexKeyCursorResponse:
+      HandleResponse(aResponse.get_ArrayOfIndexKeyCursorResponse());
       break;
 
     default: