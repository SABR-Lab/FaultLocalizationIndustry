# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/IDBObjectStore.cpp
# Commit: cddcfdcb52f6
# Full Hash: cddcfdcb52f6a465f62bdfb36bf9dc9a8dbd11a7
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2019-10-03 16:42:51
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Use const where easily possible. r=ttung,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D43631
# ==============================================================================

diff -r fc11a47c3ea7 -r cddcfdcb52f6 dom/indexedDB/IDBObjectStore.cpp
--- a/dom/indexedDB/IDBObjectStore.cpp	Thu Oct 03 07:56:32 2019 +0000
+++ b/dom/indexedDB/IDBObjectStore.cpp	Thu Oct 03 07:56:45 2019 +0000
@@ -182,7 +182,7 @@
   MOZ_ASSERT(aObjectStore);
   aObjectStore->AssertIsOnOwningThread();
 
-  IDBTransaction* transaction = aObjectStore->Transaction();
+  IDBTransaction* const transaction = aObjectStore->Transaction();
 
   RefPtr<IDBRequest> request = IDBRequest::Create(
       aCx, aObjectStore, transaction->Database(), transaction);
@@ -198,7 +198,7 @@
   MOZ_ASSERT(aWriter);
   MOZ_ASSERT(aClosure);
 
-  auto* cloneWriteInfo =
+  auto* const cloneWriteInfo =
       static_cast<IDBObjectStore::StructuredCloneWriteInfo*>(aClosure);
 
   if (JS_GetClass(aObj) == IDBObjectStore::DummyPropClass()) {
@@ -219,7 +219,7 @@
       return false;
     }
 
-    IDBDatabase* database = mutableFile->Database();
+    IDBDatabase* const database = mutableFile->Database();
     MOZ_ASSERT(database);
 
     // Throw when trying to store IDBMutableFile objects that live in a
@@ -257,12 +257,12 @@
 
     const uint32_t index = cloneWriteInfo->mFiles.Length();
 
-    NS_ConvertUTF16toUTF8 convType(mutableFile->Type());
-    uint32_t convTypeLength =
+    const NS_ConvertUTF16toUTF8 convType(mutableFile->Type());
+    const uint32_t convTypeLength =
         NativeEndian::swapToLittleEndian(convType.Length());
 
-    NS_ConvertUTF16toUTF8 convName(mutableFile->Name());
-    uint32_t convNameLength =
+    const NS_ConvertUTF16toUTF8 convName(mutableFile->Name());
+    const uint32_t convNameLength =
         NativeEndian::swapToLittleEndian(convName.Length());
 
     if (!JS_WriteUint32Pair(aWriter, SCTAG_DOM_MUTABLEFILE, uint32_t(index)) ||
@@ -273,7 +273,7 @@
       return false;
     }
 
-    StructuredCloneFile* newFile = cloneWriteInfo->mFiles.AppendElement();
+    StructuredCloneFile* const newFile = cloneWriteInfo->mFiles.AppendElement();
     newFile->mMutableFile = mutableFile;
     newFile->mType = StructuredCloneFile::eMutableFile;
 
@@ -284,16 +284,16 @@
     Blob* blob = nullptr;
     if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, &obj, blob))) {
       ErrorResult rv;
-      uint64_t size = blob->GetSize(rv);
+      const uint64_t nativeEndianSize = blob->GetSize(rv);
       MOZ_ASSERT(!rv.Failed());
 
-      size = NativeEndian::swapToLittleEndian(size);
+      const uint64_t size = NativeEndian::swapToLittleEndian(nativeEndianSize);
 
       nsString type;
       blob->GetType(type);
 
-      NS_ConvertUTF16toUTF8 convType(type);
-      uint32_t convTypeLength =
+      const NS_ConvertUTF16toUTF8 convType(type);
+      const uint32_t convTypeLength =
           NativeEndian::swapToLittleEndian(convType.Length());
 
       if (cloneWriteInfo->mFiles.Length() > size_t(UINT32_MAX)) {
@@ -313,19 +313,20 @@
         return false;
       }
 
-      RefPtr<File> file = blob->ToFile();
+      const RefPtr<File> file = blob->ToFile();
       if (file) {
         ErrorResult rv;
-        int64_t lastModifiedDate = file->GetLastModified(rv);
+        const int64_t nativeEndianLastModifiedDate = file->GetLastModified(rv);
         MOZ_ALWAYS_TRUE(!rv.Failed());
 
-        lastModifiedDate = NativeEndian::swapToLittleEndian(lastModifiedDate);
+        const int64_t lastModifiedDate =
+            NativeEndian::swapToLittleEndian(nativeEndianLastModifiedDate);
 
         nsString name;
         file->GetName(name);
 
-        NS_ConvertUTF16toUTF8 convName(name);
-        uint32_t convNameLength =
+        const NS_ConvertUTF16toUTF8 convName(name);
+        const uint32_t convNameLength =
             NativeEndian::swapToLittleEndian(convName.Length());
 
         if (!JS_WriteBytes(aWriter, &lastModifiedDate,
@@ -336,7 +337,8 @@
         }
       }
 
-      StructuredCloneFile* newFile = cloneWriteInfo->mFiles.AppendElement();
+      StructuredCloneFile* const newFile =
+          cloneWriteInfo->mFiles.AppendElement();
       newFile->mBlob = blob;
       newFile->mType = StructuredCloneFile::eBlob;
 
@@ -356,7 +358,8 @@
   MOZ_ASSERT(aWriter);
   MOZ_ASSERT(aClosure);
 
-  auto* cloneInfo = static_cast<IDBObjectStore::StructuredCloneInfo*>(aClosure);
+  auto* const cloneInfo =
+      static_cast<IDBObjectStore::StructuredCloneInfo*>(aClosure);
 
   // UNWRAP_OBJECT calls might mutate this.
   JS::Rooted<JSObject*> obj(aCx, aObj);
@@ -378,7 +381,7 @@
         return false;
       }
 
-      StructuredCloneFile* newFile = cloneInfo->mFiles.AppendElement();
+      StructuredCloneFile* const newFile = cloneInfo->mFiles.AppendElement();
       newFile->mBlob = blob;
       newFile->mType = StructuredCloneFile::eBlob;
 
@@ -401,7 +404,7 @@
         return false;
       }
 
-      StructuredCloneFile* newFile = cloneInfo->mFiles.AppendElement();
+      StructuredCloneFile* const newFile = cloneInfo->mFiles.AppendElement();
       newFile->mMutableFile = mutableFile;
       newFile->mType = StructuredCloneFile::eMutableFile;
 
@@ -426,7 +429,7 @@
 
   MOZ_ASSERT(aCx);
 
-  auto* data = static_cast<GetAddInfoClosure*>(aClosure);
+  auto* const data = static_cast<GetAddInfoClosure*>(aClosure);
   MOZ_ASSERT(data);
 
   data->mCloneWriteInfo.mOffsetToKeyProp = 0;
@@ -460,7 +463,7 @@
     NS_WARNING("Out of memory?");
     return false;
   }
-  char* buffer = aString.BeginWriting();
+  char* const buffer = aString.BeginWriting();
 
   if (!JS_ReadBytes(aReader, buffer, length)) {
     NS_WARNING("Failed to read type!");
@@ -630,12 +633,13 @@
      * Blob. */
     if (!blob) {
       MOZ_ASSERT(aFile.mFileInfo);
-      nsCOMPtr<nsIFile> file = FileInfo::GetFileForFileInfo(aFile.mFileInfo);
+      const nsCOMPtr<nsIFile> file =
+          FileInfo::GetFileForFileInfo(aFile.mFileInfo);
       if (!file) {
         return false;
       }
 
-      RefPtr<FileBlobImpl> impl = new FileBlobImpl(file);
+      const RefPtr<FileBlobImpl> impl = new FileBlobImpl(file);
       impl->SetFileId(aFile.mFileInfo->Id());
       blob = File::Create(nullptr, impl);
     }
@@ -673,7 +677,7 @@
       // File wrapping.
       // Before exposing it to content, we must recreate a DOM Blob object.
 
-      RefPtr<Blob> exposedBlob =
+      const RefPtr<Blob> exposedBlob =
           Blob::Create(blob->GetParentObject(), blob->Impl());
       MOZ_ASSERT(exposedBlob);
       JS::Rooted<JS::Value> wrappedBlob(aCx);
@@ -689,7 +693,7 @@
                               aData.lastModifiedDate * PR_USEC_PER_MSEC);
 
     MOZ_ASSERT(blob->IsFile());
-    RefPtr<File> file = blob->ToFile();
+    const RefPtr<File> file = blob->ToFile();
     MOZ_ASSERT(file);
 
     JS::Rooted<JS::Value> wrappedFile(aCx);
@@ -740,7 +744,7 @@
   if (aTag == SCTAG_DOM_FILE_WITHOUT_LASTMODIFIEDDATE ||
       aTag == SCTAG_DOM_BLOB || aTag == SCTAG_DOM_FILE ||
       aTag == SCTAG_DOM_MUTABLEFILE || aTag == SCTAG_DOM_WASM) {
-    auto* cloneReadInfo = static_cast<StructuredCloneReadInfo*>(aClosure);
+    auto* const cloneReadInfo = static_cast<StructuredCloneReadInfo*>(aClosure);
 
     JS::Rooted<JSObject*> result(aCx);
 
@@ -815,7 +819,7 @@
 
   if (aTag == SCTAG_DOM_BLOB || aTag == SCTAG_DOM_FILE ||
       aTag == SCTAG_DOM_MUTABLEFILE) {
-    auto* cloneInfo =
+    auto* const cloneInfo =
         static_cast<IDBObjectStore::StructuredCloneInfo*>(aClosure);
 
     JS::Rooted<JSObject*> result(aCx);
@@ -847,10 +851,10 @@
       {
         // Create a scope so ~RefPtr fires before returning an unwrapped
         // JS::Value.
-        RefPtr<Blob> blob = file.mBlob;
+        const RefPtr<Blob> blob = file.mBlob;
         MOZ_ASSERT(blob->IsFile());
 
-        RefPtr<File> file = blob->ToFile();
+        const RefPtr<File> file = blob->ToFile();
         MOZ_ASSERT(file);
 
         JS::Rooted<JS::Value> wrappedFile(aCx);
@@ -1095,11 +1099,11 @@
 
   JSObject* GetSandboxInternal(JSContext* aCx) {
     if (!mSandbox) {
-      nsIXPConnect* xpc = nsContentUtils::XPConnect();
+      nsIXPConnect* const xpc = nsContentUtils::XPConnect();
       MOZ_ASSERT(xpc, "This should never be null!");
 
       // Let's use a null principal.
-      nsCOMPtr<nsIPrincipal> principal =
+      const nsCOMPtr<nsIPrincipal> principal =
           NullPrincipal::CreateWithoutOriginAttributes();
 
       JS::Rooted<JSObject*> sandbox(aCx);
@@ -1173,7 +1177,7 @@
 
     AutoJSAPI jsapi;
     jsapi.Init();
-    JSContext* cx = jsapi.cx();
+    JSContext* const cx = jsapi.cx();
 
     JS::Rooted<JSObject*> global(cx, SandboxHolder::GetSandbox(cx));
     if (NS_WARN_IF(!global)) {
@@ -1181,7 +1185,7 @@
       return NS_OK;
     }
 
-    JSAutoRealm ar(cx, global);
+    const JSAutoRealm ar(cx, global);
 
     JS::Rooted<JS::Value> value(cx);
     const nsresult rv = DeserializeIndexValue(cx, &value);
@@ -1234,9 +1238,9 @@
 
   Monitor mMonitor;
 
-  int64_t mIndexID;
+  const int64_t mIndexID;
   const KeyPath& mKeyPath;
-  bool mMultiEntry;
+  const bool mMultiEntry;
   const nsCString mLocale;
   StructuredCloneReadInfo& mCloneReadInfo;
   nsTArray<IndexUpdateInfo>& mUpdateInfoArray;
@@ -1266,7 +1270,8 @@
     MonitorAutoLock lock(mMonitor);
 
     RefPtr<Runnable> self = this;
-    nsresult rv = SystemGroup::Dispatch(TaskCategory::Other, self.forget());
+    const nsresult rv =
+        SystemGroup::Dispatch(TaskCategory::Other, self.forget());
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -1295,10 +1300,10 @@
       return NS_OK;
     }
 
-    JSAutoRealm ar(cx, global);
+    const JSAutoRealm ar(cx, global);
 
     JS::Rooted<JS::Value> value(cx);
-    nsresult rv = DeserializeUpgradeValue(cx, &value);
+    const nsresult rv = DeserializeUpgradeValue(cx, &value);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       OperationCompleted(rv);
       return NS_OK;
@@ -1333,7 +1338,7 @@
   void PopulateFileIds(nsAString& aFileIds) {
     for (uint32_t count = mCloneReadInfo.mFiles.Length(), index = 0;
          index < count; index++) {
-      StructuredCloneFile& file = mCloneReadInfo.mFiles[index];
+      const StructuredCloneFile& file = mCloneReadInfo.mFiles[index];
       MOZ_ASSERT(file.mFileInfo);
 
       const int64_t id = file.mFileInfo->Id();
@@ -1366,7 +1371,7 @@
     nsTArray<IndexUpdateInfo>& aUpdateInfoArray, ErrorResult& aRv) {
   MOZ_ASSERT(!NS_IsMainThread());
 
-  RefPtr<DeserializeIndexValueHelper> helper =
+  const RefPtr<DeserializeIndexValueHelper> helper =
       new DeserializeIndexValueHelper(aIndexID, aKeyPath, aMultiEntry, aLocale,
                                       aCloneReadInfo, aUpdateInfoArray);
   helper->DispatchAndWait(aRv);
@@ -1377,7 +1382,7 @@
     StructuredCloneReadInfo& aCloneReadInfo, nsAString& aFileIds) {
   MOZ_ASSERT(!NS_IsMainThread());
 
-  RefPtr<DeserializeUpgradeValueHelper> helper =
+  const RefPtr<DeserializeUpgradeValueHelper> helper =
       new DeserializeUpgradeValueHelper(aCloneReadInfo);
   return helper->DispatchAndWait(aFileIds);
 }
@@ -1404,11 +1409,11 @@
     return;
   }
 
-  bool isAutoIncrement = AutoIncrement();
+  const bool isAutoIncrement = AutoIncrement();
 
   if (!HasValidKeyPath()) {
     // Out-of-line keys must be passed in.
-    auto result = aKey.SetFromJSVal(aCx, aKeyVal, aRv);
+    const auto result = aKey.SetFromJSVal(aCx, aKeyVal, aRv);
     if (!result.Is(Ok, aRv)) {
       if (result.Is(Invalid, aRv)) {
         aRv.Throw(NS_ERROR_DOM_INDEXEDDB_DATA_ERR);
@@ -1443,7 +1448,7 @@
 
   {
     const nsTArray<IndexMetadata>& indexes = mSpec->indexes();
-    uint32_t idxCount = indexes.Length();
+    const uint32_t idxCount = indexes.Length();
 
     aUpdateInfoArray.SetCapacity(idxCount);  // Pretty good estimate
 
@@ -1530,8 +1535,8 @@
     indexUpdateInfoSize += updateInfo[i].localizedValue().GetBuffer().Length();
   }
 
-  size_t messageSize = cloneWriteInfo.mCloneBuffer.data().Size() +
-                       key.GetBuffer().Length() + indexUpdateInfoSize;
+  const size_t messageSize = cloneWriteInfo.mCloneBuffer.data().Size() +
+                             key.GetBuffer().Length() + indexUpdateInfoSize;
 
   if (messageSize > kMaxMessageSize) {
     IDB_REPORT_INTERNAL_ERR();
@@ -1562,12 +1567,12 @@
       return nullptr;
     }
 
-    IDBDatabase* database = mTransaction->Database();
+    IDBDatabase* const database = mTransaction->Database();
 
     for (uint32_t index = 0; index < count; index++) {
       StructuredCloneFile& file = files[index];
 
-      FileAddInfo* fileAddInfo = fileAddInfos.AppendElement(fallible);
+      FileAddInfo* const fileAddInfo = fileAddInfos.AppendElement(fallible);
       MOZ_ASSERT(fileAddInfo);
 
       switch (file.mType) {
@@ -1575,7 +1580,7 @@
           MOZ_ASSERT(file.mBlob);
           MOZ_ASSERT(!file.mMutableFile);
 
-          PBackgroundIDBDatabaseFileChild* fileActor =
+          PBackgroundIDBDatabaseFileChild* const fileActor =
               database->GetOrCreateFileActorForBlob(file.mBlob);
           if (NS_WARN_IF(!fileActor)) {
             IDB_REPORT_INTERNAL_ERR();
@@ -1593,7 +1598,7 @@
           MOZ_ASSERT(file.mMutableFile);
           MOZ_ASSERT(!file.mBlob);
 
-          PBackgroundMutableFileChild* mutableFileActor =
+          PBackgroundMutableFileChild* const mutableFileActor =
               file.mMutableFile->GetBackgroundActor();
           if (NS_WARN_IF(!mutableFileActor)) {
             IDB_REPORT_INTERNAL_ERR();
@@ -1612,7 +1617,7 @@
           MOZ_ASSERT(file.mBlob);
           MOZ_ASSERT(!file.mMutableFile);
 
-          PBackgroundIDBDatabaseFileChild* fileActor =
+          PBackgroundIDBDatabaseFileChild* const fileActor =
               database->GetOrCreateFileActorForBlob(file.mBlob);
           if (NS_WARN_IF(!fileActor)) {
             IDB_REPORT_INTERNAL_ERR();
@@ -1634,12 +1639,9 @@
     commonParams.fileAddInfos().SwapElements(fileAddInfos);
   }
 
-  RequestParams params;
-  if (aOverwrite) {
-    params = ObjectStorePutParams(commonParams);
-  } else {
-    params = ObjectStoreAddParams(commonParams);
-  }
+  const auto& params = aOverwrite
+                           ? RequestParams{ObjectStorePutParams(commonParams)}
+                           : RequestParams{ObjectStoreAddParams(commonParams)};
 
   RefPtr<IDBRequest> request = GenerateRequest(aCx, this);
   MOZ_ASSERT(request);
@@ -1755,8 +1757,7 @@
     return nullptr;
   }
 
-  ObjectStoreClearParams params;
-  params.objectStoreId() = Id();
+  const ObjectStoreClearParams params = {Id()};
 
   RefPtr<IDBRequest> request = GenerateRequest(aCx, this);
   MOZ_ASSERT(request);
@@ -1942,12 +1943,9 @@
   SerializedKeyRange serializedKeyRange;
   keyRange->ToSerialized(serializedKeyRange);
 
-  RequestParams params;
-  if (aKeyOnly) {
-    params = ObjectStoreGetKeyParams(id, serializedKeyRange);
-  } else {
-    params = ObjectStoreGetParams(id, serializedKeyRange);
-  }
+  const auto& params =
+      aKeyOnly ? RequestParams{ObjectStoreGetKeyParams(id, serializedKeyRange)}
+               : RequestParams{ObjectStoreGetParams(id, serializedKeyRange)};
 
   RefPtr<IDBRequest> request = GenerateRequest(aCx, this);
   MOZ_ASSERT(request);
@@ -2030,7 +2028,7 @@
     return nullptr;
   }
 
-  IDBTransaction* transaction = IDBTransaction::GetCurrent();
+  IDBTransaction* const transaction = IDBTransaction::GetCurrent();
   if (!transaction || transaction != mTransaction || !transaction->IsOpen()) {
     aRv.Throw(NS_ERROR_DOM_INDEXEDDB_TRANSACTION_INACTIVE_ERR);
     return nullptr;
@@ -2075,7 +2073,7 @@
   }
 #endif
 
-  const IndexMetadata* oldMetadataElements =
+  const IndexMetadata* const oldMetadataElements =
       indexes.IsEmpty() ? nullptr : indexes.Elements();
 
   // With this setup we only validate the passed in locale name by the time we
@@ -2088,7 +2086,7 @@
     locale = IndexedDatabaseManager::GetLocale();
   }
 
-  IndexMetadata* metadata = indexes.AppendElement(
+  IndexMetadata* const metadata = indexes.AppendElement(
       IndexMetadata(transaction->NextIndexId(), nsString(aName), keyPath,
                     locale, aOptionalParameters.mUnique,
                     aOptionalParameters.mMultiEntry, autoLocale));
@@ -2259,7 +2257,7 @@
     return nullptr;
   }
 
-  int64_t objectStoreId = Id();
+  const int64_t objectStoreId = Id();
 
   Maybe<SerializedKeyRange> optionalKeyRange;
 
@@ -2270,7 +2268,8 @@
     optionalKeyRange.emplace(std::move(serializedKeyRange));
   }
 
-  IDBCursor::Direction direction = IDBCursor::ConvertDirection(aDirection);
+  const IDBCursor::Direction direction =
+      IDBCursor::ConvertDirection(aDirection);
 
   const CommonOpenCursorParams commonParams = {
       objectStoreId, std::move(optionalKeyRange), direction};
@@ -2304,7 +2303,7 @@
         IDB_LOG_STRINGIFY(keyRange), IDB_LOG_STRINGIFY(direction));
   }
 
-  BackgroundCursorChild* actor =
+  BackgroundCursorChild* const actor =
       new BackgroundCursorChild(request, this, direction);
 
   mTransaction->OpenCursor(actor, params);
@@ -2415,7 +2414,7 @@
   // Cache logging string of this object store before renaming.
   const LoggingString loggingOldObjectStore(this);
 
-  nsresult rv =
+  const nsresult rv =
       transaction->Database()->RenameObjectStore(mSpec->metadata().id(), aName);
 
   if (NS_FAILED(rv)) {
