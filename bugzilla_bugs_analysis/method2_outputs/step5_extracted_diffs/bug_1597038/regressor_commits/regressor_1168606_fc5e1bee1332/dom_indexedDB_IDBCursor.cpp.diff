# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/IDBCursor.cpp
# Commit: fc5e1bee1332
# Full Hash: fc5e1bee13321946704a915ef4c7c80c0941dcb3
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2019-10-02 03:38:52
# Regressor Bug: 1168606
# File Overlap Count: 1
# Description:
#   Bug 1168606 - Send two records with every ObjectStoreCursorResponse. r=ttung,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D43252
# ==============================================================================

diff -r 63cf0966cb41 -r fc5e1bee1332 dom/indexedDB/IDBCursor.cpp
--- a/dom/indexedDB/IDBCursor.cpp	Tue Oct 01 09:15:47 2019 +0000
+++ b/dom/indexedDB/IDBCursor.cpp	Tue Oct 01 09:15:49 2019 +0000
@@ -54,6 +54,8 @@
   MOZ_ASSERT_IF(aType == Type_Index || aType == Type_IndexKey, mSourceIndex);
   MOZ_ASSERT(mTransaction);
   MOZ_ASSERT(!aKey.IsUnset());
+
+  mTransaction->RegisterCursor(this);
 }
 
 bool IDBCursor::IsLocaleAware() const {
@@ -63,6 +65,8 @@
 IDBCursor::~IDBCursor() {
   AssertIsOnOwningThread();
 
+  mTransaction->UnregisterCursor(this);
+
   DropJSObjects();
 
   if (mBackgroundActor) {
@@ -449,7 +453,7 @@
         IDB_LOG_STRINGIFY(key));
   }
 
-  mBackgroundActor->SendContinueInternal(ContinueParams(key), Key());
+  mBackgroundActor->SendContinueInternal(ContinueParams(key), mKey);
 
   mContinueCalled = true;
 }
@@ -555,7 +559,7 @@
       IDB_LOG_STRINGIFY(key), IDB_LOG_STRINGIFY(primaryKey));
 
   mBackgroundActor->SendContinueInternal(
-      ContinuePrimaryKeyParams(key, primaryKey), Key());
+      ContinuePrimaryKeyParams(key, primaryKey), mKey);
 
   mContinueCalled = true;
 }
@@ -600,7 +604,7 @@
         IDB_LOG_STRINGIFY(mSourceIndex), IDB_LOG_STRINGIFY(mDirection), aCount);
   }
 
-  mBackgroundActor->SendContinueInternal(AdvanceParams(aCount), Key());
+  mBackgroundActor->SendContinueInternal(AdvanceParams(aCount), mKey);
 
   mContinueCalled = true;
 }
@@ -631,6 +635,8 @@
   MOZ_ASSERT(!mKey.IsUnset());
   MOZ_ASSERT_IF(mType == Type_Index, !mPrimaryKey.IsUnset());
 
+  mTransaction->InvalidateCursorCaches();
+
   IDBObjectStore* objectStore;
   if (mType == Type_ObjectStore) {
     objectStore = mSourceObjectStore;
@@ -739,6 +745,8 @@
   MOZ_ASSERT(mType == Type_ObjectStore || mType == Type_Index);
   MOZ_ASSERT(!mKey.IsUnset());
 
+  mTransaction->InvalidateCursorCaches();
+
   IDBObjectStore* const objectStore = mType == Type_ObjectStore
                                           ? mSourceObjectStore.get()
                                           : mSourceIndex->ObjectStore();
@@ -837,6 +845,15 @@
   mHaveValue = !mKey.IsUnset();
 }
 
+void IDBCursor::InvalidateCachedResponses() {
+  AssertIsOnOwningThread();
+
+  // TODO: In what case would mBackgroundActor be nullptr?
+  if (mBackgroundActor) {
+    mBackgroundActor->InvalidateCachedResponses();
+  }
+}
+
 NS_IMPL_CYCLE_COLLECTING_ADDREF(IDBCursor)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(IDBCursor)
 