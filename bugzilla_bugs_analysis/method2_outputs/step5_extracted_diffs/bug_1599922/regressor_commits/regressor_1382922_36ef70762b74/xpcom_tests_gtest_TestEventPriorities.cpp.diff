# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/tests/gtest/TestEventPriorities.cpp
# Commit: 36ef70762b74
# Full Hash: 36ef70762b74b3c6b8bd0f26c57ab4b54467f64b
# Author: Bill McCloskey <billm@mozilla.com>
# Date: 2017-08-17 23:17:14
# Regressor Bug: 1382922
# File Overlap Count: 3
# Description:
#   Bug 1382922 - Refactor event queue to allow multiple implementations (r=erahm)
#   
#   This patch refactors the nsThread event queue to clean it up and to make it easier to restructure. The fundamental concepts are as follows:
#   
#   Each nsThread will have a pointer to a refcounted SynchronizedEventQueue. A SynchronizedEQ takes care of doing the locking and condition variable work when posting and popping events. For the actual storage of events, it delegates to an AbstractEventQueue data structure. It keeps a UniquePtr to the AbstractEventQueue that it uses for storage.
# ==============================================================================

diff -r ca6618d0bc17 -r 36ef70762b74 xpcom/tests/gtest/TestEventPriorities.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/tests/gtest/TestEventPriorities.cpp	Tue Jun 20 19:42:13 2017 -0700
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsIThreadManager.h"
+#include "nsCOMPtr.h"
+#include "nsIRunnable.h"
+#include "nsXPCOM.h"
+#include "nsThreadUtils.h"
+#include "gtest/gtest.h"
+
+using mozilla::Runnable;
+
+class TestEvent final : public Runnable, nsIRunnablePriority
+{
+public:
+  explicit TestEvent(int* aCounter, std::function<void()> aCheck, uint32_t aPriority = nsIRunnablePriority::PRIORITY_NORMAL)
+    : Runnable("TestEvent")
+    , mCounter(aCounter)
+    , mCheck(Move(aCheck))
+    , mPriority(aPriority)
+  {
+  }
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+  NS_IMETHOD GetPriority(uint32_t* aPriority) override
+  {
+    *aPriority = mPriority;
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    (*mCounter)++;
+    mCheck();
+    return NS_OK;
+  }
+
+private:
+  ~TestEvent() {}
+
+  int* mCounter;
+  std::function<void()> mCheck;
+  uint32_t mPriority;
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(TestEvent,
+                            Runnable,
+                            nsIRunnablePriority)
+
+TEST(EventPriorities, IdleAfterNormal)
+{
+  int normalRan = 0, idleRan = 0;
+
+  RefPtr<TestEvent> evNormal = new TestEvent(&normalRan, [&] { ASSERT_EQ(idleRan, 0); });
+  RefPtr<TestEvent> evIdle = new TestEvent(&idleRan, [&] { ASSERT_EQ(normalRan, 3); });
+
+  NS_IdleDispatchToCurrentThread(do_AddRef(evIdle));
+  NS_IdleDispatchToCurrentThread(do_AddRef(evIdle));
+  NS_IdleDispatchToCurrentThread(do_AddRef(evIdle));
+  NS_DispatchToMainThread(evNormal);
+  NS_DispatchToMainThread(evNormal);
+  NS_DispatchToMainThread(evNormal);
+
+  MOZ_ALWAYS_TRUE(SpinEventLoopUntil([&]() { return normalRan == 3 && idleRan == 3; }));
+}
+
+TEST(EventPriorities, InterleaveHighNormal)
+{
+  int normalRan = 0, highRan = 0;
+
+  RefPtr<TestEvent> evNormal = new TestEvent(&normalRan, [&] {
+      ASSERT_TRUE(abs(normalRan - highRan) <= 1);
+    });
+  RefPtr<TestEvent> evHigh = new TestEvent(&highRan, [&] {
+      ASSERT_TRUE(abs(normalRan - highRan) <= 1);
+    },
+    nsIRunnablePriority::PRIORITY_HIGH);
+
+  NS_DispatchToMainThread(evNormal);
+  NS_DispatchToMainThread(evNormal);
+  NS_DispatchToMainThread(evNormal);
+  NS_DispatchToMainThread(evHigh);
+  NS_DispatchToMainThread(evHigh);
+  NS_DispatchToMainThread(evHigh);
+
+  MOZ_ALWAYS_TRUE(SpinEventLoopUntil([&]() { return normalRan == 3 && highRan == 3; }));
+}