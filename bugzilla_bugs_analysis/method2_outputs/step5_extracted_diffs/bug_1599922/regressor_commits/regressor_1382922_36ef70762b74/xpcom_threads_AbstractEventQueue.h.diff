# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/AbstractEventQueue.h
# Commit: 36ef70762b74
# Full Hash: 36ef70762b74b3c6b8bd0f26c57ab4b54467f64b
# Author: Bill McCloskey <billm@mozilla.com>
# Date: 2017-08-17 23:17:14
# Regressor Bug: 1382922
# File Overlap Count: 3
# Description:
#   Bug 1382922 - Refactor event queue to allow multiple implementations (r=erahm)
#   
#   This patch refactors the nsThread event queue to clean it up and to make it easier to restructure. The fundamental concepts are as follows:
#   
#   Each nsThread will have a pointer to a refcounted SynchronizedEventQueue. A SynchronizedEQ takes care of doing the locking and condition variable work when posting and popping events. For the actual storage of events, it delegates to an AbstractEventQueue data structure. It keeps a UniquePtr to the AbstractEventQueue that it uses for storage.
# ==============================================================================

diff -r ca6618d0bc17 -r 36ef70762b74 xpcom/threads/AbstractEventQueue.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/xpcom/threads/AbstractEventQueue.h	Tue Jun 20 19:42:13 2017 -0700
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_AbstractEventQueue_h
+#define mozilla_AbstractEventQueue_h
+
+#include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/Mutex.h"
+
+class nsIRunnable;
+
+namespace mozilla {
+
+enum class EventPriority
+{
+  High,
+  Input,
+  Normal,
+  Idle
+};
+
+// AbstractEventQueue is an abstract base class for all our unsynchronized event
+// queue implementations:
+// - EventQueue: A queue of runnables. Used for non-main threads.
+// - PrioritizedEventQueue: Contains a queue for each priority level.
+//       Has heuristics to decide which queue to pop from. Events are
+//       pushed into the queue corresponding to their priority.
+//       Used for the main thread.
+//
+// Since AbstractEventQueue implementations are unsynchronized, they should be
+// wrapped in an outer SynchronizedEventQueue implementation (like
+// ThreadEventQueue).
+class AbstractEventQueue
+{
+public:
+  // Add an event to the end of the queue. Implementors are free to use
+  // aPriority however they wish. They may ignore it if the runnable has its own
+  // intrinsic priority (via nsIRunnablePriority).
+  virtual void PutEvent(already_AddRefed<nsIRunnable>&& aEvent,
+                        EventPriority aPriority,
+                        const MutexAutoLock& aProofOfLock) = 0;
+
+  // Get an event from the front of the queue. aPriority is an out param. If the
+  // implementation supports priorities, then this should be the same priority
+  // that the event was pushed with. aPriority may be null.
+  virtual already_AddRefed<nsIRunnable> GetEvent(EventPriority* aPriority,
+                                                 const MutexAutoLock& aProofOfLock) = 0;
+
+  // Returns true if the queue is non-empty.
+  virtual bool HasPendingEvent(const MutexAutoLock& aProofOfLock) = 0;
+
+  // Returns the number of events in the queue.
+  virtual size_t Count(const MutexAutoLock& aProofOfLock) const = 0;
+
+  virtual void EnableInputEventPrioritization(const MutexAutoLock& aProofOfLock) = 0;
+
+  virtual ~AbstractEventQueue() {}
+};
+
+} // namespace mozilla
+
+#endif // mozilla_AbstractEventQueue_h