# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/ThrottledEventQueue.cpp
# Commit: 36ef70762b74
# Full Hash: 36ef70762b74b3c6b8bd0f26c57ab4b54467f64b
# Author: Bill McCloskey <billm@mozilla.com>
# Date: 2017-08-17 23:17:14
# Regressor Bug: 1382922
# File Overlap Count: 3
# Description:
#   Bug 1382922 - Refactor event queue to allow multiple implementations (r=erahm)
#   
#   This patch refactors the nsThread event queue to clean it up and to make it easier to restructure. The fundamental concepts are as follows:
#   
#   Each nsThread will have a pointer to a refcounted SynchronizedEventQueue. A SynchronizedEQ takes care of doing the locking and condition variable work when posting and popping events. For the actual storage of events, it delegates to an AbstractEventQueue data structure. It keeps a UniquePtr to the AbstractEventQueue that it uses for storage.
# ==============================================================================

diff -r ca6618d0bc17 -r 36ef70762b74 xpcom/threads/ThrottledEventQueue.cpp
--- a/xpcom/threads/ThrottledEventQueue.cpp	Tue Aug 01 12:55:21 2017 -0400
+++ b/xpcom/threads/ThrottledEventQueue.cpp	Tue Jun 20 19:42:13 2017 -0700
@@ -8,9 +8,12 @@
 
 #include "mozilla/Atomics.h"
 #include "mozilla/ClearOnShutdown.h"
+#include "mozilla/EventQueue.h"
 #include "mozilla/Mutex.h"
+#include "mozilla/Services.h"
 #include "mozilla/Unused.h"
-#include "nsEventQueue.h"
+#include "nsIObserverService.h"
+#include "nsThreadUtils.h"
 
 namespace mozilla {
 
@@ -86,10 +89,8 @@
   mutable Mutex mMutex;
   mutable CondVar mIdleCondVar;
 
-  mozilla::CondVar mEventsAvailable;
-
   // any thread, protected by mutex
-  nsEventQueue mEventQueue;
+  EventQueue mEventQueue;
 
   // written on main thread, read on any thread
   nsCOMPtr<nsISerialEventTarget> mBaseTarget;
@@ -103,8 +104,6 @@
   explicit Inner(nsISerialEventTarget* aBaseTarget)
     : mMutex("ThrottledEventQueue")
     , mIdleCondVar(mMutex, "ThrottledEventQueue:Idle")
-    , mEventsAvailable(mMutex, "[ThrottledEventQueue::Inner.mEventsAvailable]")
-    , mEventQueue(mEventsAvailable, nsEventQueue::eNormalQueue)
     , mBaseTarget(aBaseTarget)
     , mShutdownStarted(false)
   {
@@ -132,7 +131,8 @@
 
       // We only check the name of an executor runnable when we know there is something
       // in the queue, so this should never fail.
-      MOZ_ALWAYS_TRUE(mEventQueue.PeekEvent(getter_AddRefs(event), lock));
+      event = mEventQueue.PeekEvent(lock);
+      MOZ_ALWAYS_TRUE(event);
     }
 
     if (nsCOMPtr<nsINamed> named = do_QueryInterface(event)) {
@@ -162,7 +162,8 @@
 
       // We only dispatch an executor runnable when we know there is something
       // in the queue, so this should never fail.
-      MOZ_ALWAYS_TRUE(mEventQueue.GetPendingEvent(getter_AddRefs(event), lock));
+      event = mEventQueue.GetEvent(nullptr, lock);
+      MOZ_ASSERT(event);
 
       // If there are more events in the queue, then dispatch the next
       // executor.  We do this now, before running the event, because
@@ -352,7 +353,7 @@
 
     // Only add the event to the underlying queue if are able to
     // dispatch to our base target.
-    mEventQueue.PutEvent(Move(aEvent), lock);
+    mEventQueue.PutEvent(Move(aEvent), EventPriority::Normal, lock);
     return NS_OK;
   }
 