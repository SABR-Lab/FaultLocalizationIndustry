# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/nsEventQueue.h
# Commit: 36ef70762b74
# Full Hash: 36ef70762b74b3c6b8bd0f26c57ab4b54467f64b
# Author: Bill McCloskey <billm@mozilla.com>
# Date: 2017-08-17 23:17:14
# Regressor Bug: 1382922
# File Overlap Count: 3
# Description:
#   Bug 1382922 - Refactor event queue to allow multiple implementations (r=erahm)
#   
#   This patch refactors the nsThread event queue to clean it up and to make it easier to restructure. The fundamental concepts are as follows:
#   
#   Each nsThread will have a pointer to a refcounted SynchronizedEventQueue. A SynchronizedEQ takes care of doing the locking and condition variable work when posting and popping events. For the actual storage of events, it delegates to an AbstractEventQueue data structure. It keeps a UniquePtr to the AbstractEventQueue that it uses for storage.
# ==============================================================================

diff -r ca6618d0bc17 -r 36ef70762b74 xpcom/threads/nsEventQueue.h
--- a/xpcom/threads/nsEventQueue.h	Tue Aug 01 12:55:21 2017 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,127 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsEventQueue_h__
-#define nsEventQueue_h__
-
-#include <stdlib.h>
-#include "mozilla/CondVar.h"
-#include "mozilla/Mutex.h"
-#include "nsIRunnable.h"
-#include "nsCOMPtr.h"
-#include "mozilla/AlreadyAddRefed.h"
-#include "mozilla/UniquePtr.h"
-
-class nsThreadPool;
-
-// A threadsafe FIFO event queue...
-class nsEventQueue
-{
-public:
-  typedef mozilla::MutexAutoLock MutexAutoLock;
-
-  enum EventQueueType
-  {
-    eNormalQueue,
-    eSharedCondVarQueue
-  };
-
-  nsEventQueue(mozilla::CondVar& aCondVar, EventQueueType aType);
-  ~nsEventQueue();
-
-  // This method adds a new event to the pending event queue.  The queue holds
-  // a strong reference to the event after this method returns.  This method
-  // cannot fail.
-  void PutEvent(nsIRunnable* aEvent, MutexAutoLock& aProofOfLock);
-  void PutEvent(already_AddRefed<nsIRunnable>&& aEvent,
-                MutexAutoLock& aProofOfLock);
-
-  // Return the first event in the queue without popping it. Returns whether the
-  // queue was empty or not. aEvent is set to null if the queue was empty.
-  bool PeekEvent(nsIRunnable** aEvent, MutexAutoLock& aProofOfLock);
-
-  // This method gets an event from the event queue.  If mayWait is true, then
-  // the method will block the calling thread until an event is available.  If
-  // the event is null, then the method returns immediately indicating whether
-  // or not an event is pending.  When the resulting event is non-null, the
-  // caller is responsible for releasing the event object.  This method does
-  // not alter the reference count of the resulting event.
-  bool GetEvent(bool aMayWait, nsIRunnable** aEvent,
-                MutexAutoLock& aProofOfLock);
-
-  // This method returns true if there is a pending event.
-  bool HasPendingEvent(MutexAutoLock& aProofOfLock)
-  {
-    return GetEvent(false, nullptr, aProofOfLock);
-  }
-
-  // This method returns the next pending event or null.
-  bool GetPendingEvent(nsIRunnable** aRunnable, MutexAutoLock& aProofOfLock)
-  {
-    return GetEvent(false, aRunnable, aProofOfLock);
-  }
-
-  size_t Count(MutexAutoLock&) const;
-
-private:
-  bool IsEmpty()
-  {
-    return !mHead || (mHead == mTail && mOffsetHead == mOffsetTail);
-  }
-
-  enum
-  {
-    EVENTS_PER_PAGE = 255
-  };
-
-  // Page objects are linked together to form a simple deque.
-
-  struct Page
-  {
-    struct Page* mNext;
-    nsIRunnable* mEvents[EVENTS_PER_PAGE];
-  };
-
-  static_assert((sizeof(Page) & (sizeof(Page) - 1)) == 0,
-                "sizeof(Page) should be a power of two to avoid heap slop.");
-
-  static Page* NewPage()
-  {
-    return static_cast<Page*>(moz_xcalloc(1, sizeof(Page)));
-  }
-
-  static void FreePage(Page* aPage)
-  {
-    free(aPage);
-  }
-
-  Page* mHead;
-  Page* mTail;
-
-  uint16_t mOffsetHead;  // offset into mHead where next item is removed
-  uint16_t mOffsetTail;  // offset into mTail where next item is added
-  mozilla::CondVar& mEventsAvailable;
-
-  EventQueueType mType;
-
-  // These methods are made available to nsThreadPool as a hack, since
-  // nsThreadPool needs to have its threads sleep for fixed amounts of
-  // time as well as being able to wake up all threads when thread
-  // limits change.
-  friend class nsThreadPool;
-  void Wait(PRIntervalTime aInterval)
-  {
-    MOZ_ASSERT(mType == eNormalQueue);
-    mEventsAvailable.Wait(aInterval);
-  }
-  void NotifyAll()
-  {
-    MOZ_ASSERT(mType == eNormalQueue);
-    mEventsAvailable.NotifyAll();
-  }
-};
-
-#endif  // nsEventQueue_h__