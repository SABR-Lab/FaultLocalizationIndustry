# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/nsThread.h
# Commit: 36ef70762b74
# Full Hash: 36ef70762b74b3c6b8bd0f26c57ab4b54467f64b
# Author: Bill McCloskey <billm@mozilla.com>
# Date: 2017-08-17 23:17:14
# Regressor Bug: 1382922
# File Overlap Count: 3
# Description:
#   Bug 1382922 - Refactor event queue to allow multiple implementations (r=erahm)
#   
#   This patch refactors the nsThread event queue to clean it up and to make it easier to restructure. The fundamental concepts are as follows:
#   
#   Each nsThread will have a pointer to a refcounted SynchronizedEventQueue. A SynchronizedEQ takes care of doing the locking and condition variable work when posting and popping events. For the actual storage of events, it delegates to an AbstractEventQueue data structure. It keeps a UniquePtr to the AbstractEventQueue that it uses for storage.
# ==============================================================================

diff -r ca6618d0bc17 -r 36ef70762b74 xpcom/threads/nsThread.h
--- a/xpcom/threads/nsThread.h	Tue Aug 01 12:55:21 2017 -0400
+++ b/xpcom/threads/nsThread.h	Tue Jun 20 19:42:13 2017 -0700
@@ -11,11 +11,11 @@
 #include "nsIIdlePeriod.h"
 #include "nsIThreadInternal.h"
 #include "nsISupportsPriority.h"
-#include "nsEventQueue.h"
 #include "nsThreadUtils.h"
 #include "nsString.h"
 #include "nsTObserverArray.h"
 #include "mozilla/Attributes.h"
+#include "mozilla/SynchronizedEventQueue.h"
 #include "mozilla/NotNull.h"
 #include "mozilla/TimeStamp.h"
 #include "nsAutoPtr.h"
@@ -25,6 +25,7 @@
 
 namespace mozilla {
 class CycleCollectedJSContext;
+class ThreadEventTarget;
 }
 
 using mozilla::NotNull;
@@ -47,7 +48,9 @@
     NOT_MAIN_THREAD
   };
 
-  nsThread(MainThreadFlag aMainThread, uint32_t aStackSize);
+  nsThread(NotNull<mozilla::SynchronizedEventQueue*> aQueue,
+           MainThreadFlag aMainThread,
+           uint32_t aStackSize);
 
   // Initialize this as a wrapper for a new PRThread, and optionally give it a name.
   nsresult Init(const nsACString& aName = NS_LITERAL_CSTRING(""));
@@ -97,41 +100,28 @@
   static const uint32_t kRunnableNameBufSize = 1000;
   static mozilla::Array<char, kRunnableNameBufSize> sMainThreadRunnableName;
 
-  // Query whether there are some pending input events in the queue. This method
-  // is supposed to be called on main thread with input event prioritization
-  // enabled.
-  bool HasPendingInputEvents()
+  void EnableInputEventPrioritization()
   {
-    MOZ_ASSERT(NS_IsMainThread());
-    mozilla::MutexAutoLock lock(mLock);
-    return mEventsRoot.HasPendingEventsInInputQueue(lock);
+    EventQueue()->EnableInputEventPrioritization();
+  }
+
+  mozilla::TimeStamp& NextIdleDeadlineRef() { return mNextIdleDeadline; }
+
+  mozilla::SynchronizedEventQueue* EventQueue() { return mEvents.get(); }
+
+  bool ShuttingDown()
+  {
+    return mShutdownContext != nullptr;
   }
 
 private:
   void DoMainThreadSpecificProcessing(bool aReallyWait);
 
-  // Returns a null TimeStamp if we're not in the idle period.
-  mozilla::TimeStamp GetIdleDeadline();
-  void GetIdleEvent(nsIRunnable** aEvent, mozilla::MutexAutoLock& aProofOfLock);
-  void GetEvent(bool aWait, nsIRunnable** aEvent,
-                unsigned short* aPriority,
-                mozilla::MutexAutoLock& aProofOfLock);
-
 protected:
-  class nsChainedEventQueue;
-
-  class nsNestedEventTarget;
-  friend class nsNestedEventTarget;
-
   friend class nsThreadShutdownEvent;
 
   virtual ~nsThread();
 
-  bool ShuttingDown()
-  {
-    return mShutdownContext != nullptr;
-  }
-
   static void ThreadFunc(void* aArg);
 
   // Helper
@@ -142,192 +132,16 @@
     return already_AddRefed<nsIThreadObserver>(obs);
   }
 
-  // Wrappers for event queue methods:
-  nsresult PutEvent(nsIRunnable* aEvent, nsNestedEventTarget* aTarget);
-  nsresult PutEvent(already_AddRefed<nsIRunnable> aEvent,
-                    nsNestedEventTarget* aTarget);
-
-  nsresult DispatchInternal(already_AddRefed<nsIRunnable> aEvent,
-                            uint32_t aFlags, nsNestedEventTarget* aTarget);
-
   struct nsThreadShutdownContext* ShutdownInternal(bool aSync);
 
-  // Wrapper for nsEventQueue that supports chaining and prioritization.
-  class nsChainedEventQueue
-  {
-  public:
-    explicit nsChainedEventQueue(mozilla::Mutex& aLock)
-      : mNext(nullptr)
-      , mEventsAvailable(aLock, "[nsChainedEventQueue.mEventsAvailable]")
-      , mIsInputPrioritizationEnabled(false)
-      , mIsReadyToPrioritizeEvents(false)
-      , mProcessHighPriorityQueueRunnable(false)
-    {
-      mNormalQueue =
-        mozilla::MakeUnique<nsEventQueue>(mEventsAvailable,
-                                          nsEventQueue::eSharedCondVarQueue);
-      // All queues need to use the same CondVar!
-      mInputQueue =
-        mozilla::MakeUnique<nsEventQueue>(mEventsAvailable,
-                                          nsEventQueue::eSharedCondVarQueue);
-      mHighQueue =
-        mozilla::MakeUnique<nsEventQueue>(mEventsAvailable,
-                                          nsEventQueue::eSharedCondVarQueue);
-    }
-
-    void EnablePrioritization(mozilla::MutexAutoLock& aProofOfLock);
-
-    bool IsPrioritizationEnabled()
-    {
-      return mIsInputPrioritizationEnabled;
-    }
-
-    bool GetEvent(bool aMayWait, nsIRunnable** aEvent,
-                  unsigned short* aPriority,
-                  mozilla::MutexAutoLock& aProofOfLock) {
-      return mIsReadyToPrioritizeEvents
-        ? GetNormalOrInputOrHighPriorityEvent(aMayWait, aEvent, aPriority, aProofOfLock)
-        : GetNormalOrHighPriorityEvent(aMayWait, aEvent, aPriority, aProofOfLock);
-    }
-
-    void PutEvent(nsIRunnable* aEvent, mozilla::MutexAutoLock& aProofOfLock)
-    {
-      RefPtr<nsIRunnable> event(aEvent);
-      PutEvent(event.forget(), aProofOfLock);
-    }
-
-    void PutEvent(already_AddRefed<nsIRunnable> aEvent,
-                  mozilla::MutexAutoLock& aProofOfLock);
-
-    bool HasPendingEvent(mozilla::MutexAutoLock& aProofOfLock)
-    {
-      return mNormalQueue->HasPendingEvent(aProofOfLock) ||
-             mInputQueue->HasPendingEvent(aProofOfLock) ||
-             mHighQueue->HasPendingEvent(aProofOfLock);
-    }
-
-    bool HasPendingEventsInInputQueue(mozilla::MutexAutoLock& aProofOfLock)
-    {
-      MOZ_ASSERT(mIsInputPrioritizationEnabled);
-      return mInputQueue->HasPendingEvent(aProofOfLock);
-    }
-
-    nsChainedEventQueue* mNext;
-    RefPtr<nsNestedEventTarget> mEventTarget;
-
-  private:
-    bool GetNormalOrInputOrHighPriorityEvent(bool aMayWait,
-                                             nsIRunnable** aEvent,
-                                             unsigned short* aPriority,
-                                             mozilla::MutexAutoLock& aProofOfLock);
-
-    bool GetNormalOrHighPriorityEvent(bool aMayWait, nsIRunnable** aEvent,
-                                      unsigned short* aPriority,
-                                      mozilla::MutexAutoLock& aProofOfLock);
-
-    // This is used to flush pending events in nsChainedEventQueue::mNormalQueue
-    // before starting event prioritization.
-    class EnablePrioritizationRunnable final : public nsIRunnable
-    {
-      nsChainedEventQueue* mEventQueue;
+  RefPtr<mozilla::SynchronizedEventQueue> mEvents;
+  RefPtr<mozilla::ThreadEventTarget> mEventTarget;
 
-    public:
-      NS_DECL_ISUPPORTS
-
-      explicit EnablePrioritizationRunnable(nsChainedEventQueue* aQueue)
-        : mEventQueue(aQueue)
-      {
-      }
-
-      NS_IMETHOD Run() override
-      {
-        mEventQueue->mIsReadyToPrioritizeEvents = true;
-        return NS_OK;
-      }
-    private:
-      ~EnablePrioritizationRunnable()
-      {
-      }
-    };
-
-    static void SetPriorityIfNotNull(unsigned short* aPriority, short aValue)
-    {
-      if (aPriority) {
-        *aPriority = aValue;
-      }
-    }
-    mozilla::CondVar mEventsAvailable;
-    mozilla::TimeStamp mInputHandlingStartTime;
-    mozilla::UniquePtr<nsEventQueue> mNormalQueue;
-    mozilla::UniquePtr<nsEventQueue> mInputQueue;
-    mozilla::UniquePtr<nsEventQueue> mHighQueue;
-    bool mIsInputPrioritizationEnabled;
-
-    // When enabling input event prioritization, there may be some events in the
-    // queue. We have to process all of them before the new coming events to
-    // prevent the queued events are preempted by the newly ones with the same
-    // priority.
-    bool mIsReadyToPrioritizeEvents;
-    // Try to process one high priority runnable after each normal
-    // priority runnable. This gives the processing model HTML spec has for
-    // 'Update the rendering' in the case only vsync messages are in the
-    // secondary queue and prevents starving the normal queue.
-    bool mProcessHighPriorityQueueRunnable;
-  };
-
-  class nsNestedEventTarget final : public nsIEventTarget
-  {
-  public:
-    NS_DECL_THREADSAFE_ISUPPORTS
-    NS_DECL_NSIEVENTTARGET_FULL
-
-    nsNestedEventTarget(NotNull<nsThread*> aThread,
-                        NotNull<nsChainedEventQueue*> aQueue)
-      : mThread(aThread)
-      , mQueue(aQueue)
-
-
-
-    {
-    }
-
-    NotNull<RefPtr<nsThread>> mThread;
-
-    // This is protected by mThread->mLock.
-    nsChainedEventQueue* mQueue;
-
-  private:
-    ~nsNestedEventTarget()
-    {
-    }
-  };
-
-  // This lock protects access to mObserver, mEvents, mIdleEvents,
-  // mIdlePeriod and mEventsAreDoomed.  All of those fields are only
-  // modified on the thread itself (never from another thread).  This
-  // means that we can avoid holding the lock while using mObserver
-  // and mEvents on the thread itself.  When calling PutEvent on
-  // mEvents, we have to hold the lock to synchronize with
-  // PopEventQueue.
-  mozilla::Mutex mLock;
-
-  nsCOMPtr<nsIThreadObserver> mObserver;
   mozilla::CycleCollectedJSContext* mScriptObserver;
 
   // Only accessed on the target thread.
   nsAutoTObserverArray<NotNull<nsCOMPtr<nsIThreadObserver>>, 2> mEventObservers;
 
-  NotNull<nsChainedEventQueue*> mEvents;  // never null
-  nsChainedEventQueue mEventsRoot;
-
-  // mIdlePeriod keeps track of the current idle period. If at any
-  // time the main event queue is empty, calling
-  // mIdlePeriod->GetIdlePeriodHint() will give an estimate of when
-  // the current idle period will end.
-  nsCOMPtr<nsIIdlePeriod> mIdlePeriod;
-  mozilla::CondVar mIdleEventsAvailable;
-  nsEventQueue mIdleEvents;
-
   int32_t   mPriority;
   PRThread* mThread;
   uint32_t  mNestedEventLoopDepth;
@@ -338,9 +152,7 @@
   // The shutdown contexts for any other threads we've asked to shut down.
   nsTArray<nsAutoPtr<struct nsThreadShutdownContext>> mRequestedShutdownContexts;
 
-  bool mShutdownRequired;
-  // Set to true when events posted to this thread will never run.
-  bool mEventsAreDoomed;
+  mozilla::Atomic<bool> mShutdownRequired;
   MainThreadFlag mIsMainThread;
 
   // The time when we last ran an unlabeled runnable (one not associated with a
@@ -349,10 +161,6 @@
 
   // Set to true if this thread creates a JSRuntime.
   bool mCanInvokeJS;
-  // Set to true if HasPendingEvents() has been called and returned true because
-  // of a pending idle event.  This is used to remember to return that idle
-  // event from GetIdleEvent() to ensure that HasPendingEvents() never lies.
-  bool mHasPendingEventsPromisedIdleEvent;
 
 #ifndef RELEASE_OR_BETA
   mozilla::TimeStamp mNextIdleDeadline;