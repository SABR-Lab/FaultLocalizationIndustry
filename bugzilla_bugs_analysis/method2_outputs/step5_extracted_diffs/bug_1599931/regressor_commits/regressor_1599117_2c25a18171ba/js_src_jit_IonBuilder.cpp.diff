# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/IonBuilder.cpp
# Commit: 2c25a18171ba
# Full Hash: 2c25a18171ba0a181781d6395b2e6443e26ac30e
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2019-11-26 16:16:58
# Regressor Bug: 1599117
# File Overlap Count: 1
# Description:
#   Bug 1599117 part 2 - Restore empty-block + improveTypesForTest behavior for test instructions. r=tcampbell
#   
#   When an MTest instruction results in a triangle structure, we now create an
#   empty block (like we did before bug 1595476) to get a diamond structure.
#   We did this for short-circuit operators but not for other cases.
# ==============================================================================

diff -r 95a4904b7465 -r 2c25a18171ba js/src/jit/IonBuilder.cpp
--- a/js/src/jit/IonBuilder.cpp	Tue Nov 26 11:27:18 2019 +0000
+++ b/js/src/jit/IonBuilder.cpp	Tue Nov 26 11:27:59 2019 +0000
@@ -3152,6 +3152,17 @@
   return replaceTypeSet(subject, type, test);
 }
 
+AbortReasonOr<Ok> IonBuilder::improveTypesAtTestSuccessor(
+    MTest* test, MBasicBlock* successor) {
+  MOZ_ASSERT(successor->numPredecessors() == 1);
+  MOZ_ASSERT(test->block() == successor->getPredecessor(0));
+
+  MOZ_ASSERT(test->ifTrue() == successor || test->ifFalse() == successor);
+  bool trueBranch = test->ifTrue() == successor;
+
+  return improveTypesAtTest(test->getOperand(0), trueBranch, test);
+}
+
 AbortReasonOr<Ok> IonBuilder::improveTypesAtTest(MDefinition* ins,
                                                  bool trueBranch, MTest* test) {
   // We explore the test condition to try and deduce as much type information
@@ -3361,6 +3372,25 @@
   return Ok();
 }
 
+// Returns true iff the MTest added for |op| has a true-target corresponding
+// with the join point in the bytecode.
+static bool TestTrueTargetIsJoinPoint(JSOp op) {
+  switch (op) {
+    case JSOP_IFNE:
+    case JSOP_OR:
+    case JSOP_CASE:
+      return true;
+
+    case JSOP_IFEQ:
+    case JSOP_AND:
+    case JSOP_COALESCE:
+      return false;
+
+    default:
+      MOZ_CRASH("Unexpected op");
+  }
+}
+
 AbortReasonOr<Ok> IonBuilder::visitTest(JSOp op, bool* restarted) {
   MOZ_ASSERT(op == JSOP_IFEQ || op == JSOP_IFNE || op == JSOP_AND ||
              op == JSOP_OR || op == JSOP_CASE);
@@ -3384,7 +3414,7 @@
   MTest* mir = newTest(ins, nullptr, nullptr);
   current->end(mir);
 
-  if (op == JSOP_OR || op == JSOP_CASE || op == JSOP_IFNE) {
+  if (TestTrueTargetIsJoinPoint(op)) {
     mozilla::Swap(target1, target2);
   }
 
@@ -3512,56 +3542,85 @@
     return Ok();
   };
 
-  // For JSOP_AND, JSOP_OR, and JSOP_COALESCE we create an empty block for the
-  // case where they jump to the join point. This is not required for
-  // correctness but ensures we create a proper diamond structure the FoldTests
-  // pass can optimize.
-  auto createBlockForShortCircuit =
-      [&](MBasicBlock* pred) -> AbortReasonOr<MBasicBlock*> {
+  // When a block is terminated with an MTest instruction we can end up with the
+  // following triangle structure:
+  //
+  //        testBlock
+  //         /    |
+  //     block    |
+  //         \    |
+  //        joinBlock
+  //
+  // Although this is fine for correctness, it has the following issues:
+  //
+  // 1) The FoldTests pass is unable to optimize this pattern. This matters for
+  //    short-circuit operations (JSOP_AND, JSOP_COALESCE, etc).
+  //
+  // 2) We can't easily use improveTypesAtTest to improve type information in
+  //    this case:
+  //
+  //        var obj = ...;
+  //        if (obj === null) {
+  //          obj = {};
+  //        }
+  //        ... obj must be non-null ...
+  //
+  // To fix these issues, we create an empty block to get a diamond structure:
+  //
+  //        testBlock
+  //         /    |
+  //     block  emptyBlock
+  //         \    |
+  //        joinBlock
+  auto createEmptyBlockForTest =
+      [&](MBasicBlock* pred, size_t successor) -> AbortReasonOr<MBasicBlock*> {
     MOZ_ASSERT(joinBlock);
 
-    MBasicBlock* trueBlock;
-    MOZ_TRY_VAR(trueBlock, newBlock(pred, pc));
-    graph().addBlock(trueBlock);
-
-    trueBlock->end(MGoto::New(alloc(), joinBlock));
-    if (!joinBlock->addPredecessor(alloc(), trueBlock)) {
-      return abort(AbortReason::Alloc);
-    }
-
-    return trueBlock;
+    MBasicBlock* emptyBlock;
+    MOZ_TRY_VAR(emptyBlock, newBlock(pred, pc));
+
+    MTest* test = pred->lastIns()->toTest();
+    test->initSuccessor(successor, emptyBlock);
+
+    MOZ_TRY(startTraversingBlock(emptyBlock));
+    MOZ_TRY(improveTypesAtTestSuccessor(test, emptyBlock));
+
+    emptyBlock->end(MGoto::New(alloc(), joinBlock));
+    setTerminatedBlock();
+
+    return emptyBlock;
   };
 
-  MTest* predecessorTest = nullptr;
-
   for (const PendingEdge& edge : edges) {
     MBasicBlock* source = edge.block();
     MControlInstruction* lastIns = source->lastIns();
     switch (edge.kind()) {
       case PendingEdge::Kind::TestTrue: {
-        MBasicBlock* successorBlock = nullptr;
-        if (edge.testOp() == JSOP_OR) {
-          MOZ_TRY_VAR(successorBlock, createBlockForShortCircuit(source));
+        // JSOP_CASE must pop the value when branching to the true-target.
+        size_t numPopped = (edge.testOp() == JSOP_CASE) ? 1 : 0;
+
+        if (joinBlock && TestTrueTargetIsJoinPoint(edge.testOp())) {
+          MBasicBlock* pred;
+          MOZ_TRY_VAR(pred,
+                      createEmptyBlockForTest(source, /* successor = */ 0));
+          MOZ_TRY(addEdge(pred, numPopped));
         } else {
-          // JSOP_CASE must pop the value when branching to the true-target.
-          MOZ_TRY(addEdge(source, (edge.testOp() == JSOP_CASE) ? 1 : 0));
-          successorBlock = joinBlock;
+          MOZ_TRY(addEdge(source, numPopped));
+          lastIns->toTest()->initSuccessor(0, joinBlock);
         }
-        predecessorTest = lastIns->toTest();
-        predecessorTest->initSuccessor(0, successorBlock);
         continue;
       }
 
       case PendingEdge::Kind::TestFalse: {
-        MBasicBlock* successorBlock = nullptr;
-        if (edge.testOp() == JSOP_AND || edge.testOp() == JSOP_COALESCE) {
-          MOZ_TRY_VAR(successorBlock, createBlockForShortCircuit(source));
+        if (joinBlock && !TestTrueTargetIsJoinPoint(edge.testOp())) {
+          MBasicBlock* pred;
+          MOZ_TRY_VAR(pred,
+                      createEmptyBlockForTest(source, /* successor = */ 1));
+          MOZ_TRY(addEdge(pred, 0));
         } else {
           MOZ_TRY(addEdge(source, 0));
-          successorBlock = joinBlock;
+          lastIns->toTest()->initSuccessor(1, joinBlock);
         }
-        predecessorTest = lastIns->toTest();
-        predecessorTest->initSuccessor(1, successorBlock);
         continue;
       }
 
@@ -3583,15 +3642,12 @@
 
   // If the join block has just one predecessor with an MTest, try to improve
   // type information.
-  if (predecessorTest && joinBlock->numPredecessors() == 1) {
-    MOZ_ASSERT(predecessorTest->block() == joinBlock->getPredecessor(0));
-
-    MOZ_ASSERT(predecessorTest->ifTrue() == joinBlock ||
-               predecessorTest->ifFalse() == joinBlock);
-    bool trueBranch = predecessorTest->ifTrue() == joinBlock;
-
-    MOZ_TRY(improveTypesAtTest(predecessorTest->getOperand(0), trueBranch,
-                               predecessorTest));
+  if (joinBlock->numPredecessors() == 1) {
+    MBasicBlock* pred = joinBlock->getPredecessor(0);
+    if (pred->lastIns()->isTest()) {
+      MTest* test = pred->lastIns()->toTest();
+      MOZ_TRY(improveTypesAtTestSuccessor(test, joinBlock));
+    }
   }
 
   return Ok();