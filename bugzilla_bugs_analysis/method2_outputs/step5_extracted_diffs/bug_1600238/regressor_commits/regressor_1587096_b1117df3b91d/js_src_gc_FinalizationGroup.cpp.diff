# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/FinalizationGroup.cpp
# Commit: b1117df3b91d
# Full Hash: b1117df3b91d10d68d10b399637cf9ac295057e6
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2019-11-01 16:13:11
# Regressor Bug: 1587096
# File Overlap Count: 1
# Description:
#   Bug 1587096 - Part 3: Implmement FinalizationGroup r=sfink
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D49946
# ==============================================================================

diff -r cefc0474e13c -r b1117df3b91d js/src/gc/FinalizationGroup.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/gc/FinalizationGroup.cpp	Fri Nov 01 10:37:47 2019 +0000
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=8 sts=2 et sw=2 tw=80:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * Finalization group GC implementation.
+ */
+
+#include "builtin/FinalizationGroupObject.h"
+#include "gc/GCRuntime.h"
+#include "gc/Zone.h"
+
+#include "gc/PrivateIterators-inl.h"
+
+using namespace js;
+using namespace js::gc;
+
+bool GCRuntime::registerWithFinalizationGroup(JSContext* cx,
+                                              HandleObject target,
+                                              HandleObject record) {
+  MOZ_ASSERT(!IsCrossCompartmentWrapper(target));
+  MOZ_ASSERT(
+      UncheckedUnwrapWithoutExpose(record)->is<FinalizationRecordObject>());
+  MOZ_ASSERT(target->compartment() == record->compartment());
+
+  auto& map = target->zone()->finalizationRecordMap();
+  auto ptr = map.lookupForAdd(target);
+  if (!ptr) {
+    if (!map.add(ptr, target, FinalizationRecordVector(target->zone()))) {
+      return false;
+    }
+  }
+  return ptr->value().append(record);
+}
+
+void GCRuntime::markFinalizationGroupData(JSTracer* trc) {
+  // The finalization groups and holdings for all targets are marked as roots.
+  for (GCZonesIter zone(this); !zone.done(); zone.next()) {
+    auto& map = zone->finalizationRecordMap();
+    for (Zone::FinalizationRecordMap::Enum e(map); !e.empty(); e.popFront()) {
+      e.front().value().trace(trc);
+    }
+  }
+}
+
+void GCRuntime::sweepFinalizationGroups(Zone* zone) {
+  // Queue holdings for cleanup for any entries whose target is dying and remove
+  // them from the map. Sweep remaining unregister tokens.
+
+  auto& map = zone->finalizationRecordMap();
+  for (Zone::FinalizationRecordMap::Enum e(map); !e.empty(); e.popFront()) {
+    auto& records = e.front().value();
+    if (IsAboutToBeFinalized(&e.front().mutableKey())) {
+      // Queue holdings for targets that are dying.
+      for (JSObject* obj : records) {
+        obj = UncheckedUnwrapWithoutExpose(obj);
+        auto record = &obj->as<FinalizationRecordObject>();
+        FinalizationGroupObject* group = record->group();
+        if (group) {
+          group->queueHoldingsToBeCleanedUp(record->holdings());
+          queueFinalizationGroupForCleanup(group);
+        }
+      }
+      e.removeFront();
+    } else {
+      // Update any pointers moved by the GC.
+      records.sweep();
+      // Remove records that have been unregistered.
+      records.eraseIf([](JSObject* obj) {
+        obj = UncheckedUnwrapWithoutExpose(obj);
+        auto record = &obj->as<FinalizationRecordObject>();
+        return !record->group();
+      });
+    }
+  }
+}
+
+void GCRuntime::queueFinalizationGroupForCleanup(
+    FinalizationGroupObject* group) {
+  // Prod the embedding to call us back later to run the finalization callbacks.
+  if (!group->isQueuedForCleanup()) {
+    callHostCleanupFinalizationGroupCallback(group);
+    group->setQueuedForCleanup(true);
+  }
+}
+
+bool GCRuntime::cleanupQueuedFinalizationGroup(
+    JSContext* cx, HandleFinalizationGroupObject group) {
+  group->setQueuedForCleanup(false);
+  bool ok = FinalizationGroupObject::cleanupQueuedHoldings(cx, group);
+  return ok;
+}