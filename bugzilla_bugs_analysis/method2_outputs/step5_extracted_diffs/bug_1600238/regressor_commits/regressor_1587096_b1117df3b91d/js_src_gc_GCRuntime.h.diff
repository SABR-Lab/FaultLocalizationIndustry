# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/GCRuntime.h
# Commit: b1117df3b91d
# Full Hash: b1117df3b91d10d68d10b399637cf9ac295057e6
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2019-11-01 16:13:11
# Regressor Bug: 1587096
# File Overlap Count: 1
# Description:
#   Bug 1587096 - Part 3: Implmement FinalizationGroup r=sfink
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D49946
# ==============================================================================

diff -r cefc0474e13c -r b1117df3b91d js/src/gc/GCRuntime.h
--- a/js/src/gc/GCRuntime.h	Fri Nov 01 10:37:40 2019 +0000
+++ b/js/src/gc/GCRuntime.h	Fri Nov 01 10:37:47 2019 +0000
@@ -248,6 +248,8 @@
   ZoneList& operator=(const ZoneList& other) = delete;
 };
 
+void SweepFinalizationGroups(GCParallelTask* task);
+
 class GCRuntime {
   friend GCMarker::MarkQueueProgress GCMarker::processMarkQueue();
 
@@ -412,6 +414,11 @@
   JS::DoCycleCollectionCallback setDoCycleCollectionCallback(
       JS::DoCycleCollectionCallback callback);
 
+  bool registerWithFinalizationGroup(JSContext* cx, HandleObject target,
+                                     HandleObject record);
+  bool cleanupQueuedFinalizationGroup(JSContext* cx,
+                                      Handle<FinalizationGroupObject*> group);
+
   void setFullCompartmentChecks(bool enable);
 
   JS::Zone* getCurrentSweepGroup() { return currentSweepGroup; }
@@ -650,6 +657,7 @@
   void traceRuntimeCommon(JSTracer* trc, TraceOrMarkRuntime traceOrMark);
   void traceEmbeddingBlackRoots(JSTracer* trc);
   void traceEmbeddingGrayRoots(JSTracer* trc);
+  void markFinalizationGroupData(JSTracer* trc);
   void checkNoRuntimeRoots(AutoGCSession& session);
   void maybeDoCycleCollection();
   void findDeadCompartments();
@@ -682,6 +690,9 @@
   void updateAtomsBitmap();
   void sweepDebuggerOnMainThread(JSFreeOp* fop);
   void sweepJitDataOnMainThread(JSFreeOp* fop);
+  void sweepFinalizationGroups(Zone* zone);
+  friend void SweepFinalizationGroups(GCParallelTask* task);
+  void queueFinalizationGroupForCleanup(FinalizationGroupObject* group);
   IncrementalProgress endSweepingSweepGroup(JSFreeOp* fop, SliceBudget& budget);
   IncrementalProgress performSweepActions(SliceBudget& sliceBudget);
   IncrementalProgress sweepTypeInformation(JSFreeOp* fop, SliceBudget& budget);