# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: uriloader/exthandler/tests/mochitest/browser_protocolhandler_loop.js
# Commit: f0094c9184c4
# Full Hash: f0094c9184c41675f11efc2d4332ec1a63e570bc
# Author: Gijs Kruitbosch <gijskruitbosch@gmail.com>
# Date: 2019-11-27 09:44:05
# Regressor Bug: 1496380
# File Overlap Count: 1
# Description:
#   Bug 1496380 - stop recursion via the external protocol handler if Firefox is either the default OS handler or a configured external handler, r=mossop
#   
#   This is an initial implementation of this idea that works on mac.
#   I've added a Windows implementation in another commit in this stack. I'll
#   look at a Linux one in a follow-up bug. I do not think we need them in the
# ==============================================================================

diff -r 9dbf3a2c8c37 -r f0094c9184c4 uriloader/exthandler/tests/mochitest/browser_protocolhandler_loop.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/uriloader/exthandler/tests/mochitest/browser_protocolhandler_loop.js	Tue Nov 26 18:51:04 2019 +0000
@@ -0,0 +1,82 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+add_task(async function test_helperapp() {
+  // Set up the test infrastructure:
+  const kProt = "foopydoopydoo";
+  const extProtocolSvc = Cc[
+    "@mozilla.org/uriloader/external-protocol-service;1"
+  ].getService(Ci.nsIExternalProtocolService);
+  const handlerSvc = Cc["@mozilla.org/uriloader/handler-service;1"].getService(
+    Ci.nsIHandlerService
+  );
+  let handlerInfo = extProtocolSvc.getProtocolHandlerInfo(kProt);
+  if (handlerSvc.exists(handlerInfo)) {
+    handlerSvc.fillHandlerInfo(handlerInfo, "");
+  }
+  // Say we want to use a specific app:
+  handlerInfo.preferredAction = Ci.nsIHandlerInfo.useHelperApp;
+  handlerInfo.alwaysAskBeforeHandling = false;
+
+  // Say it's us:
+  let selfFile = Services.dirsvc.get("XREExeF", Ci.nsIFile);
+  // Make sure it's the .app
+  if (AppConstants.platform == "macosx") {
+    while (
+      !selfFile.leafName.endsWith(".app") &&
+      !selfFile.leafName.endsWith(".app/")
+    ) {
+      selfFile = selfFile.parent;
+    }
+  }
+  let selfHandlerApp = Cc[
+    "@mozilla.org/uriloader/local-handler-app;1"
+  ].createInstance(Ci.nsILocalHandlerApp);
+  selfHandlerApp.executable = selfFile;
+  handlerInfo.possibleApplicationHandlers.appendElement(selfHandlerApp);
+  handlerInfo.preferredApplicationHandler = selfHandlerApp;
+  handlerSvc.store(handlerInfo);
+
+  await BrowserTestUtils.withNewTab("about:blank", async browser => {
+    // Now, do some safety stubbing. If we do end up recursing we spawn
+    // infinite tabs. We definitely don't want that. Avoid it by stubbing
+    // our external URL handling bits:
+    let oldAddTab = gBrowser.addTab;
+    registerCleanupFunction(
+      () => (gBrowser.addTab = gBrowser.loadOneTab = oldAddTab)
+    );
+    let wrongThingHappenedPromise = new Promise(resolve => {
+      gBrowser.addTab = gBrowser.loadOneTab = function(aURI) {
+        ok(false, "Tried to open unexpected URL in a tab: " + aURI);
+        resolve(null);
+        // Pass a dummy object to avoid upsetting BrowserContentHandler -
+        // if it thinks opening the tab failed, it tries to open a window instead,
+        // which we can't prevent as easily, and at which point we still end up
+        // with runaway tabs.
+        return {};
+      };
+    });
+    // We can't use TestUtils.topicObserved because it leaks.
+    let askedUserPromise = new Promise(r => {
+      let obs = () => {
+        r("yes");
+        Services.obs.removeObserver(obs, "domwindowopened");
+      };
+      Services.obs.addObserver(obs, "domwindowopened");
+    });
+    BrowserTestUtils.loadURI(browser, kProt + ":test");
+    let win = await Promise.race([wrongThingHappenedPromise, askedUserPromise]);
+    ok(win, "Should have gotten a window");
+    // This is really annoying. Hanging on to the window from the observer
+    // leaks for some reason. Just close it now. It has no window type, so use
+    // the lack of one to distinguish it from the browser and the harness.
+    for (let openWin of Services.wm.getEnumerator("")) {
+      if (!openWin.document.documentElement.getAttribute("windowtype")) {
+        openWin.close();
+      }
+    }
+    askedUserPromise = null;
+  });
+});