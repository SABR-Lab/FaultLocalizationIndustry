# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/common/PoolAlloc.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/common/PoolAlloc.cpp
--- a/gfx/angle/checkout/src/common/PoolAlloc.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/common/PoolAlloc.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -15,6 +15,7 @@
 
 #include "common/angleutils.h"
 #include "common/debug.h"
+#include "common/mathutil.h"
 #include "common/platform.h"
 #include "common/tls.h"
 
@@ -36,42 +37,48 @@
 #endif
       mLocked(false)
 {
-    //
-    // Adjust mAlignment to be at least pointer aligned and
-    // power of 2.
-    //
-    size_t minAlign = sizeof(void *);
-    mAlignment &= ~(minAlign - 1);
-    if (mAlignment < minAlign)
-        mAlignment = minAlign;
-    size_t a = 1;
-    while (a < mAlignment)
-        a <<= 1;
-    mAlignment     = a;
-    mAlignmentMask = a - 1;
+#if !defined(ANGLE_DISABLE_POOL_ALLOC)
+    if (mAlignment == 1)
+    {
+        // This is a special fast-path where fastAllocation() is enabled
+        mAlignmentMask = 0;
+        mHeaderSkip    = sizeof(Header);
+    }
+    else
+    {
+#endif
+        //
+        // Adjust mAlignment to be at least pointer aligned and
+        // power of 2.
+        //
+        size_t minAlign = sizeof(void *);
+        mAlignment &= ~(minAlign - 1);
+        if (mAlignment < minAlign)
+            mAlignment = minAlign;
+        mAlignment     = gl::ceilPow2(mAlignment);
+        mAlignmentMask = mAlignment - 1;
 
 #if !defined(ANGLE_DISABLE_POOL_ALLOC)
+        //
+        // Align header skip
+        //
+        mHeaderSkip = minAlign;
+        if (mHeaderSkip < sizeof(Header))
+        {
+            mHeaderSkip = rx::roundUp(sizeof(Header), mAlignment);
+        }
+    }
     //
     // Don't allow page sizes we know are smaller than all common
     // OS page sizes.
     //
     if (mPageSize < 4 * 1024)
         mPageSize = 4 * 1024;
-
     //
     // A large mCurrentPageOffset indicates a new page needs to
     // be obtained to allocate memory.
     //
     mCurrentPageOffset = mPageSize;
-
-    //
-    // Align header skip
-    //
-    mHeaderSkip = minAlign;
-    if (mHeaderSkip < sizeof(Header))
-    {
-        mHeaderSkip = (sizeof(Header) + mAlignmentMask) & ~mAlignmentMask;
-    }
 #else  // !defined(ANGLE_DISABLE_POOL_ALLOC)
     mStack.push_back({});
 #endif
@@ -262,7 +269,22 @@
             reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(memory) + mHeaderSkip);
         return std::align(mAlignment, numBytes, unalignedPtr, allocationSize);
     }
+    unsigned char *newPageAddr =
+        static_cast<unsigned char *>(allocateNewPage(numBytes, allocationSize));
+    return initializeAllocation(mInUseList, newPageAddr, numBytes);
+#else  // !defined(ANGLE_DISABLE_POOL_ALLOC)
+    void *alloc = malloc(numBytes + mAlignmentMask);
+    mStack.back().push_back(alloc);
 
+    intptr_t intAlloc = reinterpret_cast<intptr_t>(alloc);
+    intAlloc          = (intAlloc + mAlignmentMask) & ~mAlignmentMask;
+    return reinterpret_cast<void *>(intAlloc);
+#endif
+}
+
+#if !defined(ANGLE_DISABLE_POOL_ALLOC)
+void *PoolAllocator::allocateNewPage(size_t numBytes, size_t allocationSize)
+{
     //
     // Need a simple page to allocate from.
     //
@@ -278,23 +300,15 @@
         if (memory == 0)
             return 0;
     }
-
     // Use placement-new to initialize header
     new (memory) Header(mInUseList, 1);
     mInUseList = memory;
 
     unsigned char *ret = reinterpret_cast<unsigned char *>(mInUseList) + mHeaderSkip;
     mCurrentPageOffset = (mHeaderSkip + allocationSize + mAlignmentMask) & ~mAlignmentMask;
-    return initializeAllocation(mInUseList, ret, numBytes);
-#else  // !defined(ANGLE_DISABLE_POOL_ALLOC)
-    void *alloc = malloc(numBytes + mAlignmentMask);
-    mStack.back().push_back(alloc);
-
-    intptr_t intAlloc = reinterpret_cast<intptr_t>(alloc);
-    intAlloc          = (intAlloc + mAlignmentMask) & ~mAlignmentMask;
-    return reinterpret_cast<void *>(intAlloc);
+    return ret;
+}
 #endif
-}
 
 void PoolAllocator::lock()
 {