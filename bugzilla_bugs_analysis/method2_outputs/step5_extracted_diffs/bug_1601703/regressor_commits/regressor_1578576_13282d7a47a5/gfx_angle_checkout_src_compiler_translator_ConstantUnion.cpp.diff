# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/compiler/translator/ConstantUnion.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/compiler/translator/ConstantUnion.cpp
--- a/gfx/angle/checkout/src/compiler/translator/ConstantUnion.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/compiler/translator/ConstantUnion.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -9,6 +9,7 @@
 
 #include "common/mathutil.h"
 #include "compiler/translator/Diagnostics.h"
+#include "compiler/translator/util.h"
 
 namespace sh
 {
@@ -86,8 +87,16 @@
 
 float TConstantUnion::getFConst() const
 {
-    ASSERT(type == EbtFloat);
-    return fConst;
+    switch (type)
+    {
+        case EbtInt:
+            return static_cast<float>(iConst);
+        case EbtUInt:
+            return static_cast<float>(uConst);
+        default:
+            ASSERT(type == EbtFloat);
+            return fConst;
+    }
 }
 
 bool TConstantUnion::getBConst() const
@@ -219,17 +228,37 @@
 
 bool TConstantUnion::operator==(const int i) const
 {
-    return i == iConst;
+    switch (type)
+    {
+        case EbtFloat:
+            return static_cast<float>(i) == fConst;
+        default:
+            return i == iConst;
+    }
 }
 
 bool TConstantUnion::operator==(const unsigned int u) const
 {
-    return u == uConst;
+    switch (type)
+    {
+        case EbtFloat:
+            return static_cast<float>(u) == fConst;
+        default:
+            return u == uConst;
+    }
 }
 
 bool TConstantUnion::operator==(const float f) const
 {
-    return f == fConst;
+    switch (type)
+    {
+        case EbtInt:
+            return f == static_cast<float>(iConst);
+        case EbtUInt:
+            return f == static_cast<float>(uConst);
+        default:
+            return f == fConst;
+    }
 }
 
 bool TConstantUnion::operator==(const bool b) const
@@ -244,23 +273,32 @@
 
 bool TConstantUnion::operator==(const TConstantUnion &constant) const
 {
-    if (constant.type != type)
-        return false;
-
-    switch (type)
+    ImplicitTypeConversion conversion = GetConversion(constant.type, type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            return constant.iConst == iConst;
-        case EbtUInt:
-            return constant.uConst == uConst;
-        case EbtFloat:
-            return constant.fConst == fConst;
-        case EbtBool:
-            return constant.bConst == bConst;
-        case EbtYuvCscStandardEXT:
-            return constant.yuvCscStandardEXTConst == yuvCscStandardEXTConst;
-        default:
-            return false;
+        switch (type)
+        {
+            case EbtInt:
+                return constant.iConst == iConst;
+            case EbtUInt:
+                return constant.uConst == uConst;
+            case EbtFloat:
+                return constant.fConst == fConst;
+            case EbtBool:
+                return constant.bConst == bConst;
+            case EbtYuvCscStandardEXT:
+                return constant.yuvCscStandardEXTConst == yuvCscStandardEXTConst;
+            default:
+                return false;
+        }
+    }
+    else if (conversion == ImplicitTypeConversion::Invalid)
+    {
+        return false;
+    }
+    else
+    {
+        return constant.getFConst() == getFConst();
     }
 }
 
@@ -296,33 +334,50 @@
 
 bool TConstantUnion::operator>(const TConstantUnion &constant) const
 {
-    ASSERT(type == constant.type);
-    switch (type)
+
+    ImplicitTypeConversion conversion = GetConversion(constant.type, type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            return iConst > constant.iConst;
-        case EbtUInt:
-            return uConst > constant.uConst;
-        case EbtFloat:
-            return fConst > constant.fConst;
-        default:
-            return false;  // Invalid operation, handled at semantic analysis
+        switch (type)
+        {
+            case EbtInt:
+                return iConst > constant.iConst;
+            case EbtUInt:
+                return uConst > constant.uConst;
+            case EbtFloat:
+                return fConst > constant.fConst;
+            default:
+                return false;  // Invalid operation, handled at semantic analysis
+        }
+    }
+    else
+    {
+        ASSERT(conversion != ImplicitTypeConversion::Invalid);
+        return getFConst() > constant.getFConst();
     }
 }
 
 bool TConstantUnion::operator<(const TConstantUnion &constant) const
 {
-    ASSERT(type == constant.type);
-    switch (type)
+    ImplicitTypeConversion conversion = GetConversion(constant.type, type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            return iConst < constant.iConst;
-        case EbtUInt:
-            return uConst < constant.uConst;
-        case EbtFloat:
-            return fConst < constant.fConst;
-        default:
-            return false;  // Invalid operation, handled at semantic analysis
+        switch (type)
+        {
+            case EbtInt:
+                return iConst < constant.iConst;
+            case EbtUInt:
+                return uConst < constant.uConst;
+            case EbtFloat:
+                return fConst < constant.fConst;
+            default:
+                return false;  // Invalid operation, handled at semantic analysis
+        }
+    }
+    else
+    {
+        ASSERT(conversion != ImplicitTypeConversion::Invalid);
+        return getFConst() < constant.getFConst();
     }
 }
 
@@ -333,20 +388,29 @@
                                    const TSourceLoc &line)
 {
     TConstantUnion returnValue;
-    ASSERT(lhs.type == rhs.type);
-    switch (lhs.type)
+
+    ImplicitTypeConversion conversion = GetConversion(lhs.type, rhs.type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            returnValue.setIConst(gl::WrappingSum<int>(lhs.iConst, rhs.iConst));
-            break;
-        case EbtUInt:
-            returnValue.setUConst(gl::WrappingSum<unsigned int>(lhs.uConst, rhs.uConst));
-            break;
-        case EbtFloat:
-            returnValue.setFConst(CheckedSum(lhs.fConst, rhs.fConst, diag, line));
-            break;
-        default:
-            UNREACHABLE();
+        switch (lhs.type)
+        {
+            case EbtInt:
+                returnValue.setIConst(gl::WrappingSum<int>(lhs.iConst, rhs.iConst));
+                break;
+            case EbtUInt:
+                returnValue.setUConst(gl::WrappingSum<unsigned int>(lhs.uConst, rhs.uConst));
+                break;
+            case EbtFloat:
+                returnValue.setFConst(CheckedSum(lhs.fConst, rhs.fConst, diag, line));
+                break;
+            default:
+                UNREACHABLE();
+        }
+    }
+    else
+    {
+        ASSERT(conversion != ImplicitTypeConversion::Invalid);
+        returnValue.setFConst(CheckedSum(lhs.getFConst(), rhs.getFConst(), diag, line));
     }
 
     return returnValue;
@@ -359,20 +423,29 @@
                                    const TSourceLoc &line)
 {
     TConstantUnion returnValue;
-    ASSERT(lhs.type == rhs.type);
-    switch (lhs.type)
+
+    ImplicitTypeConversion conversion = GetConversion(lhs.type, rhs.type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            returnValue.setIConst(gl::WrappingDiff<int>(lhs.iConst, rhs.iConst));
-            break;
-        case EbtUInt:
-            returnValue.setUConst(gl::WrappingDiff<unsigned int>(lhs.uConst, rhs.uConst));
-            break;
-        case EbtFloat:
-            returnValue.setFConst(CheckedDiff(lhs.fConst, rhs.fConst, diag, line));
-            break;
-        default:
-            UNREACHABLE();
+        switch (lhs.type)
+        {
+            case EbtInt:
+                returnValue.setIConst(gl::WrappingDiff<int>(lhs.iConst, rhs.iConst));
+                break;
+            case EbtUInt:
+                returnValue.setUConst(gl::WrappingDiff<unsigned int>(lhs.uConst, rhs.uConst));
+                break;
+            case EbtFloat:
+                returnValue.setFConst(CheckedDiff(lhs.fConst, rhs.fConst, diag, line));
+                break;
+            default:
+                UNREACHABLE();
+        }
+    }
+    else
+    {
+        ASSERT(conversion != ImplicitTypeConversion::Invalid);
+        returnValue.setFConst(CheckedDiff(lhs.getFConst(), rhs.getFConst(), diag, line));
     }
 
     return returnValue;
@@ -385,22 +458,31 @@
                                    const TSourceLoc &line)
 {
     TConstantUnion returnValue;
-    ASSERT(lhs.type == rhs.type);
-    switch (lhs.type)
+
+    ImplicitTypeConversion conversion = GetConversion(lhs.type, rhs.type);
+    if (conversion == ImplicitTypeConversion::Same)
     {
-        case EbtInt:
-            returnValue.setIConst(gl::WrappingMul(lhs.iConst, rhs.iConst));
-            break;
-        case EbtUInt:
-            // Unsigned integer math in C++ is defined to be done in modulo 2^n, so we rely on that
-            // to implement wrapping multiplication.
-            returnValue.setUConst(lhs.uConst * rhs.uConst);
-            break;
-        case EbtFloat:
-            returnValue.setFConst(CheckedMul(lhs.fConst, rhs.fConst, diag, line));
-            break;
-        default:
-            UNREACHABLE();
+        switch (lhs.type)
+        {
+            case EbtInt:
+                returnValue.setIConst(gl::WrappingMul(lhs.iConst, rhs.iConst));
+                break;
+            case EbtUInt:
+                // Unsigned integer math in C++ is defined to be done in modulo 2^n, so we rely
+                // on that to implement wrapping multiplication.
+                returnValue.setUConst(lhs.uConst * rhs.uConst);
+                break;
+            case EbtFloat:
+                returnValue.setFConst(CheckedMul(lhs.fConst, rhs.fConst, diag, line));
+                break;
+            default:
+                UNREACHABLE();
+        }
+    }
+    else
+    {
+        ASSERT(conversion != ImplicitTypeConversion::Invalid);
+        returnValue.setFConst(CheckedMul(lhs.getFConst(), rhs.getFConst(), diag, line));
     }
 
     return returnValue;