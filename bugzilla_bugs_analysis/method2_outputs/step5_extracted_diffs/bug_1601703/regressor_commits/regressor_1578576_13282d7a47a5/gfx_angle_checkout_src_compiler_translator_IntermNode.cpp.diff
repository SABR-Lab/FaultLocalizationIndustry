# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/compiler/translator/IntermNode.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/compiler/translator/IntermNode.cpp
--- a/gfx/angle/checkout/src/compiler/translator/IntermNode.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/compiler/translator/IntermNode.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -2105,132 +2105,138 @@
             resultArray = new TConstantUnion[objectSize];
             for (size_t i = 0; i < objectSize; i++)
             {
-                switch (leftType.getBasicType())
+                if (IsFloatDivision(leftType.getBasicType(), rightType.getBasicType()))
                 {
-                    case EbtFloat:
+                    // Float division requested, possibly with implicit conversion
+                    ASSERT(op == EOpDiv);
+                    float dividend = leftArray[i].getFConst();
+                    float divisor  = rightArray[i].getFConst();
+
+                    if (divisor == 0.0f)
                     {
-                        ASSERT(op == EOpDiv);
-                        float dividend = leftArray[i].getFConst();
-                        float divisor  = rightArray[i].getFConst();
-                        if (divisor == 0.0f)
-                        {
-                            if (dividend == 0.0f)
-                            {
-                                diagnostics->warning(
-                                    line,
-                                    "Zero divided by zero during constant folding generated NaN",
-                                    "/");
-                                resultArray[i].setFConst(std::numeric_limits<float>::quiet_NaN());
-                            }
-                            else
-                            {
-                                diagnostics->warning(line, "Divide by zero during constant folding",
-                                                     "/");
-                                bool negativeResult =
-                                    std::signbit(dividend) != std::signbit(divisor);
-                                resultArray[i].setFConst(
-                                    negativeResult ? -std::numeric_limits<float>::infinity()
-                                                   : std::numeric_limits<float>::infinity());
-                            }
-                        }
-                        else if (gl::isInf(dividend) && gl::isInf(divisor))
+                        if (dividend == 0.0f)
                         {
                             diagnostics->warning(line,
-                                                 "Infinity divided by infinity during constant "
+                                                 "Zero divided by zero during constant "
                                                  "folding generated NaN",
                                                  "/");
                             resultArray[i].setFConst(std::numeric_limits<float>::quiet_NaN());
                         }
                         else
                         {
-                            float result = dividend / divisor;
-                            if (!gl::isInf(dividend) && gl::isInf(result))
-                            {
-                                diagnostics->warning(
-                                    line, "Constant folded division overflowed to infinity", "/");
-                            }
-                            resultArray[i].setFConst(result);
+                            diagnostics->warning(line, "Divide by zero during constant folding",
+                                                 "/");
+                            bool negativeResult = std::signbit(dividend) != std::signbit(divisor);
+                            resultArray[i].setFConst(negativeResult
+                                                         ? -std::numeric_limits<float>::infinity()
+                                                         : std::numeric_limits<float>::infinity());
                         }
-                        break;
                     }
-                    case EbtInt:
-                        if (rightArray[i] == 0)
+                    else if (gl::isInf(dividend) && gl::isInf(divisor))
+                    {
+                        diagnostics->warning(line,
+                                             "Infinity divided by infinity during constant "
+                                             "folding generated NaN",
+                                             "/");
+                        resultArray[i].setFConst(std::numeric_limits<float>::quiet_NaN());
+                    }
+                    else
+                    {
+                        float result = dividend / divisor;
+                        if (!gl::isInf(dividend) && gl::isInf(result))
                         {
                             diagnostics->warning(
-                                line, "Divide by zero error during constant folding", "/");
-                            resultArray[i].setIConst(INT_MAX);
+                                line, "Constant folded division overflowed to infinity", "/");
                         }
-                        else
+                        resultArray[i].setFConst(result);
+                    }
+                }
+                else
+                {
+                    // Types are either both int or both uint
+                    switch (leftType.getBasicType())
+                    {
+                        case EbtInt:
                         {
-                            int lhs     = leftArray[i].getIConst();
-                            int divisor = rightArray[i].getIConst();
-                            if (op == EOpDiv)
+                            if (rightArray[i] == 0)
                             {
-                                // Check for the special case where the minimum representable number
-                                // is
-                                // divided by -1. If left alone this leads to integer overflow in
-                                // C++.
-                                // ESSL 3.00.6 section 4.1.3 Integers:
-                                // "However, for the case where the minimum representable value is
-                                // divided by -1, it is allowed to return either the minimum
-                                // representable value or the maximum representable value."
-                                if (lhs == -0x7fffffff - 1 && divisor == -1)
-                                {
-                                    resultArray[i].setIConst(0x7fffffff);
-                                }
-                                else
-                                {
-                                    resultArray[i].setIConst(lhs / divisor);
-                                }
+                                diagnostics->warning(
+                                    line, "Divide by zero error during constant folding", "/");
+                                resultArray[i].setIConst(INT_MAX);
                             }
                             else
                             {
-                                ASSERT(op == EOpIMod);
-                                if (lhs < 0 || divisor < 0)
+                                int lhs     = leftArray[i].getIConst();
+                                int divisor = rightArray[i].getIConst();
+                                if (op == EOpDiv)
                                 {
-                                    // ESSL 3.00.6 section 5.9: Results of modulus are undefined
-                                    // when either one of the operands is negative.
-                                    diagnostics->warning(line,
-                                                         "Negative modulus operator operand "
-                                                         "encountered during constant folding. "
-                                                         "Results are undefined.",
-                                                         "%");
-                                    resultArray[i].setIConst(0);
+                                    // Check for the special case where the minimum
+                                    // representable number is divided by -1. If left alone this
+                                    // leads to integer overflow in C++. ESSL 3.00.6
+                                    // section 4.1.3 Integers: "However, for the case where the
+                                    // minimum representable value is divided by -1, it is
+                                    // allowed to return either the minimum representable value
+                                    // or the maximum representable value."
+                                    if (lhs == -0x7fffffff - 1 && divisor == -1)
+                                    {
+                                        resultArray[i].setIConst(0x7fffffff);
+                                    }
+                                    else
+                                    {
+                                        resultArray[i].setIConst(lhs / divisor);
+                                    }
                                 }
                                 else
                                 {
-                                    resultArray[i].setIConst(lhs % divisor);
+                                    ASSERT(op == EOpIMod);
+                                    if (lhs < 0 || divisor < 0)
+                                    {
+                                        // ESSL 3.00.6 section 5.9: Results of modulus are
+                                        // undefined when either one of the operands is
+                                        // negative.
+                                        diagnostics->warning(line,
+                                                             "Negative modulus operator operand "
+                                                             "encountered during constant folding. "
+                                                             "Results are undefined.",
+                                                             "%");
+                                        resultArray[i].setIConst(0);
+                                    }
+                                    else
+                                    {
+                                        resultArray[i].setIConst(lhs % divisor);
+                                    }
                                 }
                             }
+                            break;
                         }
-                        break;
-
-                    case EbtUInt:
-                        if (rightArray[i] == 0)
+                        case EbtUInt:
                         {
-                            diagnostics->warning(
-                                line, "Divide by zero error during constant folding", "/");
-                            resultArray[i].setUConst(UINT_MAX);
-                        }
-                        else
-                        {
-                            if (op == EOpDiv)
+                            if (rightArray[i] == 0)
                             {
-                                resultArray[i].setUConst(leftArray[i].getUConst() /
-                                                         rightArray[i].getUConst());
+                                diagnostics->warning(
+                                    line, "Divide by zero error during constant folding", "/");
+                                resultArray[i].setUConst(UINT_MAX);
                             }
                             else
                             {
-                                ASSERT(op == EOpIMod);
-                                resultArray[i].setUConst(leftArray[i].getUConst() %
-                                                         rightArray[i].getUConst());
+                                if (op == EOpDiv)
+                                {
+                                    resultArray[i].setUConst(leftArray[i].getUConst() /
+                                                             rightArray[i].getUConst());
+                                }
+                                else
+                                {
+                                    ASSERT(op == EOpIMod);
+                                    resultArray[i].setUConst(leftArray[i].getUConst() %
+                                                             rightArray[i].getUConst());
+                                }
                             }
+                            break;
                         }
-                        break;
-
-                    default:
-                        UNREACHABLE();
-                        return nullptr;
+                        default:
+                            UNREACHABLE();
+                            return nullptr;
+                    }
                 }
             }
         }
@@ -3746,6 +3752,20 @@
     return resultArray;
 }
 
+bool TIntermConstantUnion::IsFloatDivision(TBasicType t1, TBasicType t2)
+{
+    ImplicitTypeConversion conversion = GetConversion(t1, t2);
+    ASSERT(conversion != ImplicitTypeConversion::Invalid);
+    if (conversion == ImplicitTypeConversion::Same)
+    {
+        if (t1 == EbtFloat)
+            return true;
+        return false;
+    }
+    ASSERT(t1 == EbtFloat || t2 == EbtFloat);
+    return true;
+}
+
 // TIntermPreprocessorDirective implementation.
 TIntermPreprocessorDirective::TIntermPreprocessorDirective(PreprocessorDirective directive,
                                                            ImmutableString command)