# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/compiler/translator/OutputGLSLBase.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/compiler/translator/OutputGLSLBase.cpp
--- a/gfx/angle/checkout/src/compiler/translator/OutputGLSLBase.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/compiler/translator/OutputGLSLBase.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -61,11 +61,12 @@
   private:
     bool mFirst;
 
-    friend TInfoSinkBase &operator<<(TInfoSinkBase &out,
-                                     CommaSeparatedListItemPrefixGenerator &gen);
+    template <typename Stream>
+    friend Stream &operator<<(Stream &out, CommaSeparatedListItemPrefixGenerator &gen);
 };
 
-TInfoSinkBase &operator<<(TInfoSinkBase &out, CommaSeparatedListItemPrefixGenerator &gen)
+template <typename Stream>
+Stream &operator<<(Stream &out, CommaSeparatedListItemPrefixGenerator &gen)
 {
     if (gen.mFirst)
     {
@@ -160,6 +161,90 @@
     }
 }
 
+// Outputs what goes inside layout(), except for location and binding qualifiers, as they are
+// handled differently between GL GLSL and Vulkan GLSL.
+std::string TOutputGLSLBase::getCommonLayoutQualifiers(TIntermTyped *variable)
+{
+    std::ostringstream out;
+    CommaSeparatedListItemPrefixGenerator listItemPrefix;
+
+    const TType &type                       = variable->getType();
+    const TLayoutQualifier &layoutQualifier = type.getLayoutQualifier();
+
+    if (type.getQualifier() == EvqFragmentOut || type.getQualifier() == EvqVertexIn ||
+        IsVarying(type.getQualifier()))
+    {
+        if (type.getQualifier() == EvqFragmentOut && layoutQualifier.index >= 0)
+        {
+            out << listItemPrefix << "index = " << layoutQualifier.index;
+        }
+    }
+
+    if (type.getQualifier() == EvqFragmentOut)
+    {
+        if (layoutQualifier.yuv == true)
+        {
+            out << listItemPrefix << "yuv";
+        }
+    }
+
+    if (IsImage(type.getBasicType()))
+    {
+        if (layoutQualifier.imageInternalFormat != EiifUnspecified)
+        {
+            ASSERT(type.getQualifier() == EvqTemporary || type.getQualifier() == EvqUniform);
+            out << listItemPrefix
+                << getImageInternalFormatString(layoutQualifier.imageInternalFormat);
+        }
+    }
+
+    if (IsAtomicCounter(type.getBasicType()))
+    {
+        out << listItemPrefix << "offset = " << layoutQualifier.offset;
+    }
+
+    return out.str();
+}
+
+// Outputs what comes after in/out/uniform/buffer storage qualifier.
+std::string TOutputGLSLBase::getMemoryQualifiers(const TType &type)
+{
+    std::ostringstream out;
+
+    const TMemoryQualifier &memoryQualifier = type.getMemoryQualifier();
+    if (memoryQualifier.readonly)
+    {
+        ASSERT(IsImage(type.getBasicType()) || IsStorageBuffer(type.getQualifier()));
+        out << "readonly ";
+    }
+
+    if (memoryQualifier.writeonly)
+    {
+        ASSERT(IsImage(type.getBasicType()) || IsStorageBuffer(type.getQualifier()));
+        out << "writeonly ";
+    }
+
+    if (memoryQualifier.coherent)
+    {
+        ASSERT(IsImage(type.getBasicType()) || IsStorageBuffer(type.getQualifier()));
+        out << "coherent ";
+    }
+
+    if (memoryQualifier.restrictQualifier)
+    {
+        ASSERT(IsImage(type.getBasicType()) || IsStorageBuffer(type.getQualifier()));
+        out << "restrict ";
+    }
+
+    if (memoryQualifier.volatileQualifier)
+    {
+        ASSERT(IsImage(type.getBasicType()) || IsStorageBuffer(type.getQualifier()));
+        out << "volatile ";
+    }
+
+    return out.str();
+}
+
 void TOutputGLSLBase::writeLayoutQualifier(TIntermTyped *variable)
 {
     const TType &type = variable->getType();
@@ -189,18 +274,6 @@
         {
             out << listItemPrefix << "location = " << layoutQualifier.location;
         }
-        if (type.getQualifier() == EvqFragmentOut && layoutQualifier.index >= 0)
-        {
-            out << listItemPrefix << "index = " << layoutQualifier.index;
-        }
-    }
-
-    if (type.getQualifier() == EvqFragmentOut)
-    {
-        if (layoutQualifier.yuv == true)
-        {
-            out << listItemPrefix << "yuv";
-        }
     }
 
     if (IsOpaqueType(type.getBasicType()))
@@ -211,31 +284,24 @@
         }
     }
 
-    if (IsImage(type.getBasicType()))
+    std::string otherQualifiers = getCommonLayoutQualifiers(variable);
+    if (!otherQualifiers.empty())
     {
-        if (layoutQualifier.imageInternalFormat != EiifUnspecified)
-        {
-            ASSERT(type.getQualifier() == EvqTemporary || type.getQualifier() == EvqUniform);
-            out << listItemPrefix
-                << getImageInternalFormatString(layoutQualifier.imageInternalFormat);
-        }
-    }
-
-    if (IsAtomicCounter(type.getBasicType()))
-    {
-        out << listItemPrefix << "offset = " << layoutQualifier.offset;
+        out << listItemPrefix << otherQualifiers;
     }
 
     out << ") ";
 }
 
-void TOutputGLSLBase::writeQualifier(TQualifier qualifier, const TSymbol *symbol)
+void TOutputGLSLBase::writeQualifier(TQualifier qualifier, const TType &type, const TSymbol *symbol)
 {
     const char *result = mapQualifierToString(qualifier);
     if (result && result[0] != '\0')
     {
         objSink() << result << " ";
     }
+
+    objSink() << getMemoryQualifiers(type);
 }
 
 const char *TOutputGLSLBase::mapQualifierToString(TQualifier qualifier)
@@ -284,38 +350,7 @@
     }
     if (qualifier != EvqTemporary && qualifier != EvqGlobal)
     {
-        writeQualifier(qualifier, symbol);
-    }
-
-    const TMemoryQualifier &memoryQualifier = type.getMemoryQualifier();
-    if (memoryQualifier.readonly)
-    {
-        ASSERT(IsImage(type.getBasicType()));
-        out << "readonly ";
-    }
-
-    if (memoryQualifier.writeonly)
-    {
-        ASSERT(IsImage(type.getBasicType()));
-        out << "writeonly ";
-    }
-
-    if (memoryQualifier.coherent)
-    {
-        ASSERT(IsImage(type.getBasicType()));
-        out << "coherent ";
-    }
-
-    if (memoryQualifier.restrictQualifier)
-    {
-        ASSERT(IsImage(type.getBasicType()));
-        out << "restrict ";
-    }
-
-    if (memoryQualifier.volatileQualifier)
-    {
-        ASSERT(IsImage(type.getBasicType()));
-        out << "volatile ";
+        writeQualifier(qualifier, type, symbol);
     }
 
     // Declare the struct if we have not done so already.