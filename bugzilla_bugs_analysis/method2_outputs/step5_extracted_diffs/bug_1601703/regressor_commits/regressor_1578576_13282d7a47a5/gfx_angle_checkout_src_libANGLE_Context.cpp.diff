# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/Context.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/Context.cpp
--- a/gfx/angle/checkout/src/libANGLE/Context.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/Context.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -26,6 +26,7 @@
 #include "libANGLE/Fence.h"
 #include "libANGLE/Framebuffer.h"
 #include "libANGLE/FramebufferAttachment.h"
+#include "libANGLE/MemoryObject.h"
 #include "libANGLE/Path.h"
 #include "libANGLE/Program.h"
 #include "libANGLE/ProgramPipeline.h"
@@ -33,16 +34,15 @@
 #include "libANGLE/Renderbuffer.h"
 #include "libANGLE/ResourceManager.h"
 #include "libANGLE/Sampler.h"
+#include "libANGLE/Semaphore.h"
 #include "libANGLE/Surface.h"
 #include "libANGLE/Texture.h"
 #include "libANGLE/TransformFeedback.h"
 #include "libANGLE/VertexArray.h"
-#include "libANGLE/Workarounds.h"
 #include "libANGLE/formatutils.h"
 #include "libANGLE/queryconversions.h"
 #include "libANGLE/queryutils.h"
-#include "libANGLE/renderer/BufferImpl.h"
-#include "libANGLE/renderer/EGLImplFactory.h"
+#include "libANGLE/renderer/DisplayImpl.h"
 #include "libANGLE/renderer/Format.h"
 #include "libANGLE/validationES.h"
 
@@ -105,7 +105,7 @@
 template <typename T>
 angle::Result GetQueryObjectParameter(const Context *context, Query *query, GLenum pname, T *params)
 {
-    ASSERT(query != nullptr);
+    ASSERT(query != nullptr || pname == GL_QUERY_RESULT_AVAILABLE_EXT);
 
     switch (pname)
     {
@@ -113,8 +113,15 @@
             return query->getResult(context, params);
         case GL_QUERY_RESULT_AVAILABLE_EXT:
         {
-            bool available;
-            ANGLE_TRY(query->isResultAvailable(context, &available));
+            bool available = false;
+            if (context->isContextLost())
+            {
+                available = true;
+            }
+            else
+            {
+                ANGLE_TRY(query->isResultAvailable(context, &available));
+            }
             *params = CastFromStateValue<T>(pname, static_cast<GLuint>(available));
             return angle::Result::Continue;
         }
@@ -135,9 +142,34 @@
     return static_cast<EGLint>(attribs.get(EGL_CONTEXT_MINOR_VERSION, 0));
 }
 
-Version GetClientVersion(const egl::AttributeMap &attribs)
-{
-    return Version(GetClientMajorVersion(attribs), GetClientMinorVersion(attribs));
+bool GetBackwardCompatibleContext(const egl::AttributeMap &attribs)
+{
+    return attribs.get(EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE, EGL_TRUE) == EGL_TRUE;
+}
+
+Version GetClientVersion(egl::Display *display, const egl::AttributeMap &attribs)
+{
+    Version requestedVersion =
+        Version(GetClientMajorVersion(attribs), GetClientMinorVersion(attribs));
+    if (GetBackwardCompatibleContext(attribs))
+    {
+        if (requestedVersion.major == 1)
+        {
+            // If the user requests an ES1 context, we cannot return an ES 2+ context.
+            return Version(1, 1);
+        }
+        else
+        {
+            // Always up the version to at least the max conformant version this display supports.
+            // Only return a higher client version if requested.
+            return std::max(display->getImplementation()->getMaxConformantESVersion(),
+                            requestedVersion);
+        }
+    }
+    else
+    {
+        return requestedVersion;
+    }
 }
 
 GLenum GetResetStrategy(const egl::AttributeMap &attribs)
@@ -264,18 +296,20 @@
 };
 }  // anonymous namespace
 
-Context::Context(rx::EGLImplFactory *implFactory,
+Context::Context(egl::Display *display,
                  const egl::Config *config,
                  const Context *shareContext,
                  TextureManager *shareTextures,
                  MemoryProgramCache *memoryProgramCache,
+                 const EGLenum clientType,
                  const egl::AttributeMap &attribs,
                  const egl::DisplayExtensions &displayExtensions,
                  const egl::ClientExtensions &clientExtensions)
     : mState(reinterpret_cast<ContextID>(this),
              shareContext ? &shareContext->mState : nullptr,
              shareTextures,
-             GetClientVersion(attribs),
+             clientType,
+             GetClientVersion(display, attribs),
              GetDebug(attribs),
              GetBindGeneratesResource(attribs),
              GetClientArraysEnabled(attribs),
@@ -284,21 +318,21 @@
       mSkipValidation(GetNoError(attribs)),
       mDisplayTextureShareGroup(shareTextures != nullptr),
       mErrors(this),
-      mImplementation(implFactory->createContext(mState, &mErrors, config, shareContext, attribs)),
+      mImplementation(display->getImplementation()
+                          ->createContext(mState, &mErrors, config, shareContext, attribs)),
       mLabel(nullptr),
       mCompiler(),
       mConfig(config),
-      mClientType(EGL_OPENGL_ES_API),
       mHasBeenCurrent(false),
       mContextLost(false),
-      mResetStatus(GL_NO_ERROR),
+      mResetStatus(GraphicsResetStatus::NoError),
       mContextLostForced(false),
       mResetStrategy(GetResetStrategy(attribs)),
       mRobustAccess(GetRobustAccess(attribs)),
       mSurfacelessSupported(displayExtensions.surfacelessContext),
       mExplicitContextAvailable(clientExtensions.explicitContext),
       mCurrentSurface(static_cast<egl::Surface *>(EGL_NO_SURFACE)),
-      mCurrentDisplay(static_cast<egl::Display *>(EGL_NO_DISPLAY)),
+      mDisplay(static_cast<egl::Display *>(EGL_NO_DISPLAY)),
       mWebGLContext(GetWebGLContext(attribs)),
       mBufferAccessValidationEnabled(false),
       mExtensionsEnabled(GetExtensionsEnabled(attribs, mWebGLContext)),
@@ -328,7 +362,12 @@
     mImplementation->setMemoryProgramCache(mMemoryProgramCache);
 
     initCaps();
-    initWorkarounds();
+
+    if (mDisplay->getFrontendFeatures().syncFramebufferBindingsOnTexImage.enabled)
+    {
+        mTexImageDirtyBits.set(State::DIRTY_BIT_READ_FRAMEBUFFER_BINDING);
+        mTexImageDirtyBits.set(State::DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING);
+    }
 
     mState.initialize(this);
 
@@ -346,12 +385,13 @@
     Texture *zeroTextureCube = new Texture(mImplementation.get(), 0, TextureType::CubeMap);
     mZeroTextures[TextureType::CubeMap].set(this, zeroTextureCube);
 
-    if (getClientVersion() >= Version(3, 0))
-    {
-        // TODO: These could also be enabled via extension
+    if (getClientVersion() >= Version(3, 0) || mSupportedExtensions.texture3DOES)
+    {
         Texture *zeroTexture3D = new Texture(mImplementation.get(), 0, TextureType::_3D);
         mZeroTextures[TextureType::_3D].set(this, zeroTexture3D);
-
+    }
+    if (getClientVersion() >= Version(3, 0))
+    {
         Texture *zeroTexture2DArray = new Texture(mImplementation.get(), 0, TextureType::_2DArray);
         mZeroTextures[TextureType::_2DArray].set(this, zeroTexture2DArray);
     }
@@ -458,7 +498,9 @@
     mClearDirtyBits.set(State::DIRTY_BIT_STENCIL_WRITEMASK_FRONT);
     mClearDirtyBits.set(State::DIRTY_BIT_STENCIL_WRITEMASK_BACK);
     mClearDirtyBits.set(State::DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING);
-    mClearDirtyObjects.set(State::DIRTY_OBJECT_DRAW_FRAMEBUFFER);
+
+    // We sync the draw Framebuffer manually in prepareForClear to allow the clear calls to do
+    // more custom handling for robust resource init.
 
     mBlitDirtyBits.set(State::DIRTY_BIT_SCISSOR_TEST_ENABLED);
     mBlitDirtyBits.set(State::DIRTY_BIT_SCISSOR);
@@ -481,6 +523,8 @@
     mComputeDirtyObjects.set(State::DIRTY_OBJECT_PROGRAM);
     mComputeDirtyObjects.set(State::DIRTY_OBJECT_SAMPLERS);
 
+    mCopyImageDirtyObjects.set(State::DIRTY_OBJECT_READ_FRAMEBUFFER);
+
     ANGLE_CONTEXT_TRY(mImplementation->initialize());
 }
 
@@ -491,7 +535,7 @@
         mGLES1Renderer->onDestroy(this, &mState);
     }
 
-    ANGLE_TRY(releaseSurface(display));
+    ANGLE_TRY(unMakeCurrent(display));
 
     for (auto fence : mFenceNVMap)
     {
@@ -547,6 +591,8 @@
     mState.mPathManager->release(this);
     mState.mFramebufferManager->release(this);
     mState.mProgramPipelineManager->release(this);
+    mState.mMemoryObjectManager->release(this);
+    mState.mSemaphoreManager->release(this);
 
     mThreadPool.reset();
 
@@ -569,7 +615,7 @@
 
 egl::Error Context::makeCurrent(egl::Display *display, egl::Surface *surface)
 {
-    mCurrentDisplay = display;
+    mDisplay = display;
 
     if (!mHasBeenCurrent)
     {
@@ -596,72 +642,28 @@
     mState.setAllDirtyBits();
     mState.setAllDirtyObjects();
 
-    ANGLE_TRY(releaseSurface(display));
-
-    Framebuffer *newDefault = nullptr;
-    if (surface != nullptr)
-    {
-        ANGLE_TRY(surface->setIsCurrent(this, true));
-        mCurrentSurface = surface;
-        newDefault      = surface->createDefaultFramebuffer(this);
-    }
-    else
-    {
-        newDefault = new Framebuffer(mImplementation.get());
-    }
-
-    // Update default framebuffer, the binding of the previous default
-    // framebuffer (or lack of) will have a nullptr.
-    {
-        mState.mFramebufferManager->setDefaultFramebuffer(newDefault);
-        if (mState.getReadFramebuffer() == nullptr)
-        {
-            bindReadFramebuffer(0);
-        }
-        if (mState.getDrawFramebuffer() == nullptr)
-        {
-            bindDrawFramebuffer(0);
-        }
-    }
+    ANGLE_TRY(setDefaultFramebuffer(surface));
 
     // Notify the renderer of a context switch.
-    return angle::ResultToEGL(mImplementation->onMakeCurrent(this));
-}
-
-egl::Error Context::releaseSurface(const egl::Display *display)
-{
-    gl::Framebuffer *defaultFramebuffer = mState.mFramebufferManager->getFramebuffer(0);
-
-    // Remove the default framebuffer
-    if (mState.getReadFramebuffer() == defaultFramebuffer)
-    {
-        mState.setReadFramebufferBinding(nullptr);
-        mReadFramebufferObserverBinding.bind(nullptr);
-    }
-
-    if (mState.getDrawFramebuffer() == defaultFramebuffer)
-    {
-        mState.setDrawFramebufferBinding(nullptr);
-        mDrawFramebufferObserverBinding.bind(nullptr);
-    }
-
-    if (defaultFramebuffer)
-    {
-        defaultFramebuffer->onDestroy(this);
-        delete defaultFramebuffer;
-    }
-
-    mState.mFramebufferManager->setDefaultFramebuffer(nullptr);
-
-    if (mCurrentSurface)
-    {
-        ANGLE_TRY(mCurrentSurface->setIsCurrent(this, false));
-        mCurrentSurface = nullptr;
+    angle::Result implResult = mImplementation->onMakeCurrent(this);
+
+    // If the implementation fails onMakeCurrent, unset the default framebuffer.
+    if (implResult != angle::Result::Continue)
+    {
+        ANGLE_TRY(unsetDefaultFramebuffer());
+        return angle::ResultToEGL(implResult);
     }
 
     return egl::NoError();
 }
 
+egl::Error Context::unMakeCurrent(const egl::Display *display)
+{
+    ANGLE_TRY(unsetDefaultFramebuffer());
+
+    return angle::ResultToEGL(mImplementation->onUnMakeCurrent(this));
+}
+
 GLuint Context::createBuffer()
 {
     return mState.mBufferManager->createBuffer();
@@ -727,6 +729,16 @@
     return 0u;
 }
 
+GLuint Context::createMemoryObject()
+{
+    return mState.mMemoryObjectManager->createMemoryObject(mImplementation.get());
+}
+
+GLuint Context::createSemaphore()
+{
+    return mState.mSemaphoreManager->createSemaphore(mImplementation.get());
+}
+
 void Context::deleteBuffer(GLuint bufferName)
 {
     Buffer *buffer = mState.mBufferManager->getBuffer(bufferName);
@@ -787,12 +799,22 @@
     mState.mProgramPipelineManager->deleteObject(this, pipeline);
 }
 
+void Context::deleteMemoryObject(GLuint memoryObject)
+{
+    mState.mMemoryObjectManager->deleteMemoryObject(this, memoryObject);
+}
+
+void Context::deleteSemaphore(GLuint semaphore)
+{
+    mState.mSemaphoreManager->deleteSemaphore(this, semaphore);
+}
+
 void Context::deletePaths(GLuint first, GLsizei range)
 {
     mState.mPathManager->deletePaths(first, range);
 }
 
-bool Context::isPath(GLuint path) const
+GLboolean Context::isPath(GLuint path)
 {
     const auto *pathObj = mState.mPathManager->getPath(path);
     if (pathObj == nullptr)
@@ -891,6 +913,14 @@
     mState.setPathStencilFunc(func, ref, mask);
 }
 
+// GL_CHROMIUM_lose_context
+void Context::loseContext(GraphicsResetStatus current, GraphicsResetStatus other)
+{
+    // TODO(geofflang): mark the rest of the share group lost. Requires access to the entire share
+    // group from a context. http://anglebug.com/3379
+    markContextLost(current);
+}
+
 void Context::deleteFramebuffer(GLuint framebuffer)
 {
     if (mState.mFramebufferManager->getFramebuffer(framebuffer))
@@ -1012,7 +1042,7 @@
                              GLuint name,
                              GLsizei bufSize,
                              GLsizei *length,
-                             GLchar *label) const
+                             GLchar *label)
 {
     gl::LabeledObject *object = getLabeledObject(identifier, name);
     ASSERT(object != nullptr);
@@ -1021,10 +1051,7 @@
     GetObjectLabelBase(objectLabel, bufSize, length, label);
 }
 
-void Context::getObjectPtrLabel(const void *ptr,
-                                GLsizei bufSize,
-                                GLsizei *length,
-                                GLchar *label) const
+void Context::getObjectPtrLabel(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
 {
     gl::LabeledObject *object = getLabeledObjectFromPtr(ptr);
     ASSERT(object != nullptr);
@@ -1033,7 +1060,7 @@
     GetObjectLabelBase(objectLabel, bufSize, length, label);
 }
 
-bool Context::isSampler(GLuint samplerName) const
+GLboolean Context::isSampler(GLuint samplerName)
 {
     return mState.mSamplerManager->isSampler(samplerName);
 }
@@ -1100,6 +1127,7 @@
         mState.mSamplerManager->checkSamplerAllocation(mImplementation.get(), samplerHandle);
     mState.setSamplerBinding(this, textureUnit, sampler);
     mSamplerObserverBindings[textureUnit].bind(sampler);
+    mStateCache.onActiveTextureChange(this);
 }
 
 void Context::bindImageTexture(GLuint unit,
@@ -1213,6 +1241,16 @@
     getQueryiv(target, pname, params);
 }
 
+void Context::getUnsignedBytev(GLenum pname, GLubyte *data)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::getUnsignedBytei_v(GLenum target, GLuint index, GLubyte *data)
+{
+    UNIMPLEMENTED();
+}
+
 void Context::getQueryObjectiv(GLuint id, GLenum pname, GLint *params)
 {
     ANGLE_CONTEXT_TRY(GetQueryObjectParameter(this, getQuery(id), pname, params));
@@ -1302,12 +1340,17 @@
     return mQueryMap.query(handle);
 }
 
-Texture *Context::getTargetTexture(TextureType type) const
+Texture *Context::getTextureByType(TextureType type) const
 {
     ASSERT(ValidTextureTarget(this, type) || ValidTextureExternalTarget(this, type));
     return mState.getTargetTexture(type);
 }
 
+Texture *Context::getTextureByTarget(TextureTarget target) const
+{
+    return getTextureByType(TextureTargetToType(target));
+}
+
 Texture *Context::getSamplerTexture(unsigned int sampler, TextureType type) const
 {
     return mState.getSamplerTexture(sampler, type);
@@ -1330,7 +1373,7 @@
             *params = GL_TRUE;
             break;
         case GL_CONTEXT_ROBUST_ACCESS_EXT:
-            *params = mRobustAccess ? GL_TRUE : GL_FALSE;
+            *params = ConvertToGLBoolean(mRobustAccess);
             break;
 
         default:
@@ -1440,7 +1483,7 @@
             *params = mState.mCaps.maxDrawBuffers;
             break;
         case GL_SUBPIXEL_BITS:
-            *params = 4;
+            *params = mState.mCaps.subPixelBits;
             break;
         case GL_MAX_TEXTURE_SIZE:
             *params = mState.mCaps.max2DTextureSize;
@@ -1470,7 +1513,7 @@
             *params = mState.mCaps.maxShaderUniformBlocks[ShaderType::Fragment];
             break;
         case GL_MAX_COMBINED_UNIFORM_BLOCKS:
-            *params = mState.mCaps.maxCombinedTextureImageUnits;
+            *params = mState.mCaps.maxCombinedUniformBlocks;
             break;
         case GL_MAX_VERTEX_OUTPUT_COMPONENTS:
             *params = mState.mCaps.maxVertexOutputComponents;
@@ -2008,7 +2051,7 @@
 
 void Context::getTexParameterfv(TextureType target, GLenum pname, GLfloat *params)
 {
-    const Texture *const texture = getTargetTexture(target);
+    const Texture *const texture = getTextureByType(target);
     QueryTexParameterfv(texture, pname, params);
 }
 
@@ -2023,19 +2066,19 @@
 
 void Context::getTexParameteriv(TextureType target, GLenum pname, GLint *params)
 {
-    const Texture *const texture = getTargetTexture(target);
+    const Texture *const texture = getTextureByType(target);
     QueryTexParameteriv(texture, pname, params);
 }
 
 void Context::getTexParameterIiv(TextureType target, GLenum pname, GLint *params)
 {
-    const Texture *const texture = getTargetTexture(target);
+    const Texture *const texture = getTextureByType(target);
     QueryTexParameterIiv(texture, pname, params);
 }
 
 void Context::getTexParameterIuiv(TextureType target, GLenum pname, GLuint *params)
 {
-    const Texture *const texture = getTargetTexture(target);
+    const Texture *const texture = getTextureByType(target);
     QueryTexParameterIuiv(texture, pname, params);
 }
 
@@ -2068,7 +2111,7 @@
 
 void Context::getTexLevelParameteriv(TextureTarget target, GLint level, GLenum pname, GLint *params)
 {
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
     QueryTexLevelParameteriv(texture, target, level, pname, params);
 }
 
@@ -2087,7 +2130,7 @@
                                      GLenum pname,
                                      GLfloat *params)
 {
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
     QueryTexLevelParameterfv(texture, target, level, pname, params);
 }
 
@@ -2103,13 +2146,13 @@
 
 void Context::texParameterf(TextureType target, GLenum pname, GLfloat param)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameterf(this, texture, pname, param);
 }
 
 void Context::texParameterfv(TextureType target, GLenum pname, const GLfloat *params)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameterfv(this, texture, pname, params);
 }
 
@@ -2123,25 +2166,25 @@
 
 void Context::texParameteri(TextureType target, GLenum pname, GLint param)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameteri(this, texture, pname, param);
 }
 
 void Context::texParameteriv(TextureType target, GLenum pname, const GLint *params)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameteriv(this, texture, pname, params);
 }
 
 void Context::texParameterIiv(TextureType target, GLenum pname, const GLint *params)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameterIiv(this, texture, pname, params);
 }
 
 void Context::texParameterIuiv(TextureType target, GLenum pname, const GLuint *params)
 {
-    Texture *const texture = getTargetTexture(target);
+    Texture *const texture = getTextureByType(target);
     SetTexParameterIuiv(this, texture, pname, params);
 }
 
@@ -2580,11 +2623,12 @@
 }
 
 // NOTE: this function should not assume that this context is current!
-void Context::markContextLost()
-{
+void Context::markContextLost(GraphicsResetStatus status)
+{
+    ASSERT(status != GraphicsResetStatus::NoError);
     if (mResetStrategy == GL_LOSE_CONTEXT_ON_RESET_EXT)
     {
-        mResetStatus       = GL_UNKNOWN_CONTEXT_RESET_EXT;
+        mResetStatus       = status;
         mContextLostForced = true;
     }
     mContextLost = true;
@@ -2596,7 +2640,7 @@
     // as it will allow us to skip all the calls.
     if (mResetStrategy == GL_NO_RESET_NOTIFICATION_EXT)
     {
-        if (!mContextLost && mImplementation->getResetStatus() != GL_NO_ERROR)
+        if (!mContextLost && mImplementation->getResetStatus() != GraphicsResetStatus::NoError)
         {
             mContextLost = true;
         }
@@ -2612,15 +2656,15 @@
     // once the device has finished resetting.
     if (!mContextLost)
     {
-        ASSERT(mResetStatus == GL_NO_ERROR);
+        ASSERT(mResetStatus == GraphicsResetStatus::NoError);
         mResetStatus = mImplementation->getResetStatus();
 
-        if (mResetStatus != GL_NO_ERROR)
+        if (mResetStatus != GraphicsResetStatus::NoError)
         {
             mContextLost = true;
         }
     }
-    else if (!mContextLostForced && mResetStatus != GL_NO_ERROR)
+    else if (!mContextLostForced && mResetStatus != GraphicsResetStatus::NoError)
     {
         // If markContextLost was used to mark the context lost then
         // assume that is not recoverable, and continue to report the
@@ -2628,7 +2672,7 @@
         mResetStatus = mImplementation->getResetStatus();
     }
 
-    return mResetStatus;
+    return ToGLenum(mResetStatus);
 }
 
 bool Context::isResetNotificationEnabled()
@@ -2643,7 +2687,7 @@
 
 EGLenum Context::getClientType() const
 {
-    return mClientType;
+    return mState.getClientType();
 }
 
 EGLenum Context::getRenderBuffer() const
@@ -2668,6 +2712,7 @@
         vertexArray =
             new VertexArray(mImplementation.get(), vertexArrayHandle,
                             mState.mCaps.maxVertexAttributes, mState.mCaps.maxVertexAttribBindings);
+        vertexArray->setBufferAccessValidationEnabled(mBufferAccessValidationEnabled);
 
         mVertexArrayMap.assign(vertexArrayHandle, vertexArray);
     }
@@ -2956,13 +3001,25 @@
     const Version &clientVersion = getClientVersion();
 
     std::ostringstream versionString;
-    versionString << "OpenGL ES " << clientVersion.major << "." << clientVersion.minor << " (ANGLE "
+    if (getClientType() == EGL_OPENGL_ES_API)
+    {
+        versionString << "OpenGL ES ";
+    }
+    versionString << clientVersion.major << "." << clientVersion.minor << ".0 (ANGLE "
                   << ANGLE_VERSION_STRING << ")";
     mVersionString = MakeStaticString(versionString.str());
 
     std::ostringstream shadingLanguageVersionString;
-    shadingLanguageVersionString << "OpenGL ES GLSL ES "
-                                 << (clientVersion.major == 2 ? 1 : clientVersion.major) << "."
+    if (getClientType() == EGL_OPENGL_ES_API)
+    {
+        shadingLanguageVersionString << "OpenGL ES GLSL ES ";
+    }
+    else
+    {
+        ASSERT(getClientType() == EGL_OPENGL_API);
+        shadingLanguageVersionString << "OpenGL GLSL ";
+    }
+    shadingLanguageVersionString << (clientVersion.major == 2 ? 1 : clientVersion.major) << "."
                                  << clientVersion.minor << "0 (ANGLE " << ANGLE_VERSION_STRING
                                  << ")";
     mShadingLanguageString = MakeStaticString(shadingLanguageVersionString.str());
@@ -2997,6 +3054,16 @@
     mRequestableExtensionString = mergeExtensionStrings(mRequestableExtensionStrings);
 }
 
+const GLubyte *Context::getString(GLenum name)
+{
+    return static_cast<const Context *>(this)->getString(name);
+}
+
+const GLubyte *Context::getStringi(GLenum name, GLuint index)
+{
+    return static_cast<const Context *>(this)->getStringi(name, index);
+}
+
 const GLubyte *Context::getString(GLenum name) const
 {
     switch (name)
@@ -3078,16 +3145,16 @@
 
     // Invalidate all textures and framebuffer. Some extensions make new formats renderable or
     // sampleable.
-    mState.mTextureManager->signalAllTexturesDirty(this);
+    mState.mTextureManager->signalAllTexturesDirty();
     for (auto &zeroTexture : mZeroTextures)
     {
         if (zeroTexture.get() != nullptr)
         {
-            zeroTexture->signalDirtyStorage(this, InitState::Initialized);
+            zeroTexture->signalDirtyStorage(InitState::Initialized);
         }
     }
 
-    mState.mFramebufferManager->invalidateFramebufferComplenessCache(this);
+    mState.mFramebufferManager->invalidateFramebufferComplenessCache();
 }
 
 size_t Context::getRequestableExtensionStringCount() const
@@ -3132,6 +3199,7 @@
         supportedExtensions.pointSprite           = true;
         supportedExtensions.drawTexture           = true;
         supportedExtensions.parallelShaderCompile = false;
+        supportedExtensions.texture3DOES          = false;
     }
 
     if (getClientVersion() < ES_3_0)
@@ -3140,11 +3208,15 @@
         supportedExtensions.colorBufferFloat      = false;
         supportedExtensions.eglImageExternalEssl3 = false;
         supportedExtensions.textureNorm16         = false;
+        supportedExtensions.multiview             = false;
         supportedExtensions.multiview2            = false;
         supportedExtensions.maxViews              = 1u;
         supportedExtensions.copyTexture3d         = false;
         supportedExtensions.textureMultisample    = false;
 
+        // Requires glCompressedTexImage3D
+        supportedExtensions.textureCompressionASTCOES = false;
+
         // Don't expose GL_EXT_texture_sRGB_decode without sRGB texture support
         if (!supportedExtensions.sRGB)
         {
@@ -3213,14 +3285,33 @@
     }
 
     // If EGL_KHR_fence_sync is not enabled, don't expose GL_OES_EGL_sync.
-    ASSERT(mCurrentDisplay);
-    if (!mCurrentDisplay->getExtensions().fenceSync)
+    ASSERT(mDisplay);
+    if (!mDisplay->getExtensions().fenceSync)
     {
         supportedExtensions.eglSync = false;
     }
 
     supportedExtensions.memorySize = true;
 
+    // GL_CHROMIUM_lose_context is implemented in the frontend
+    supportedExtensions.loseContextCHROMIUM = true;
+
+    // The ASTC texture extensions have dependency requirements.
+    if (supportedExtensions.textureCompressionASTCHDRKHR)
+    {
+        // GL_KHR_texture_compression_astc_hdr cannot be exposed without also exposing
+        // GL_KHR_texture_compression_astc_ldr
+        ASSERT(supportedExtensions.textureCompressionASTCLDRKHR);
+    }
+
+    if (supportedExtensions.textureCompressionASTCOES)
+    {
+        // GL_OES_texture_compression_astc cannot be exposed without also exposing
+        // GL_KHR_texture_compression_astc_ldr and GL_KHR_texture_compression_astc_hdr
+        ASSERT(supportedExtensions.textureCompressionASTCLDRKHR);
+        ASSERT(supportedExtensions.textureCompressionASTCHDRKHR);
+    }
+
     return supportedExtensions;
 }
 
@@ -3269,18 +3360,41 @@
     LimitCap(&mState.mCaps.maxVertexOutputComponents, IMPLEMENTATION_MAX_VARYING_VECTORS * 4);
     LimitCap(&mState.mCaps.maxFragmentInputComponents, IMPLEMENTATION_MAX_VARYING_VECTORS * 4);
 
+    LimitCap(&mState.mCaps.maxTransformFeedbackInterleavedComponents,
+             IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS);
+    LimitCap(&mState.mCaps.maxTransformFeedbackSeparateAttributes,
+             IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
+    LimitCap(&mState.mCaps.maxTransformFeedbackSeparateComponents,
+             IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS);
+
     // Limit textures as well, so we can use fast bitsets with texture bindings.
     LimitCap(&mState.mCaps.maxCombinedTextureImageUnits, IMPLEMENTATION_MAX_ACTIVE_TEXTURES);
-    LimitCap(&mState.mCaps.maxShaderTextureImageUnits[ShaderType::Vertex],
-             IMPLEMENTATION_MAX_ACTIVE_TEXTURES / 2);
-    LimitCap(&mState.mCaps.maxShaderTextureImageUnits[ShaderType::Fragment],
-             IMPLEMENTATION_MAX_ACTIVE_TEXTURES / 2);
+    for (ShaderType shaderType : AllShaderTypes())
+    {
+        LimitCap(&mState.mCaps.maxShaderTextureImageUnits[shaderType],
+                 IMPLEMENTATION_MAX_SHADER_TEXTURES);
+    }
 
     LimitCap(&mState.mCaps.maxImageUnits, IMPLEMENTATION_MAX_IMAGE_UNITS);
 
+    for (ShaderType shaderType : AllShaderTypes())
+    {
+        LimitCap(&mState.mCaps.maxShaderAtomicCounterBuffers[shaderType],
+                 IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS);
+    }
     LimitCap(&mState.mCaps.maxCombinedAtomicCounterBuffers,
              IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS);
 
+    for (ShaderType shaderType : AllShaderTypes())
+    {
+        LimitCap(&mState.mCaps.maxShaderStorageBlocks[shaderType],
+                 IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS);
+    }
+    LimitCap(&mState.mCaps.maxShaderStorageBufferBindings,
+             IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS);
+    LimitCap(&mState.mCaps.maxCombinedShaderStorageBlocks,
+             IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS);
+
     mState.mCaps.maxSampleMaskWords =
         std::min<GLuint>(mState.mCaps.maxSampleMaskWords, MAX_SAMPLE_MASK_WORDS);
 
@@ -3328,7 +3442,7 @@
         // OpenGL ES 3.0 or prior does not support multisampling with integer formats
         if (!formatCaps.renderbuffer ||
             (getClientVersion() < ES_3_1 && !mSupportedExtensions.textureMultisample &&
-             (formatInfo.componentType == GL_INT || formatInfo.componentType == GL_UNSIGNED_INT)))
+             formatInfo.isInt()))
         {
             formatCaps.sampleCounts.clear();
         }
@@ -3341,8 +3455,7 @@
             // GLES 3.0.5 section 4.4.2.2: "Implementations must support creation of renderbuffers
             // in these required formats with up to the value of MAX_SAMPLES multisamples, with the
             // exception of signed and unsigned integer formats."
-            if (formatInfo.componentType != GL_INT && formatInfo.componentType != GL_UNSIGNED_INT &&
-                formatInfo.isRequiredRenderbufferFormat(getClientVersion()))
+            if (!formatInfo.isInt() && formatInfo.isRequiredRenderbufferFormat(getClientVersion()))
             {
                 ASSERT(getClientVersion() < ES_3_0 || formatMaxSamples >= 4);
                 mState.mCaps.maxSamples = std::min(mState.mCaps.maxSamples, formatMaxSamples);
@@ -3356,8 +3469,7 @@
                 // the exception that the signed and unsigned integer formats are required only to
                 // support creation of renderbuffers with up to the value of MAX_INTEGER_SAMPLES
                 // multisamples, which must be at least one."
-                if (formatInfo.componentType == GL_INT ||
-                    formatInfo.componentType == GL_UNSIGNED_INT)
+                if (formatInfo.isInt())
                 {
                     mState.mCaps.maxIntegerSamples =
                         std::min(mState.mCaps.maxIntegerSamples, formatMaxSamples);
@@ -3424,42 +3536,35 @@
     mThreadPool = angle::WorkerThreadPool::Create(mState.mExtensions.parallelShaderCompile);
 
     // Reinitialize some dirty bits that depend on extensions.
-    bool robustInit = mState.isRobustResourceInitEnabled();
-    mDrawDirtyObjects.set(State::DIRTY_OBJECT_DRAW_ATTACHMENTS, robustInit);
-    mDrawDirtyObjects.set(State::DIRTY_OBJECT_TEXTURES_INIT, robustInit);
-    mDrawDirtyObjects.set(State::DIRTY_OBJECT_IMAGES_INIT, robustInit);
-    mBlitDirtyObjects.set(State::DIRTY_OBJECT_DRAW_ATTACHMENTS, robustInit);
-    mComputeDirtyObjects.set(State::DIRTY_OBJECT_TEXTURES_INIT, robustInit);
-    mComputeDirtyObjects.set(State::DIRTY_OBJECT_IMAGES_INIT, robustInit);
+    if (mState.isRobustResourceInitEnabled())
+    {
+        mDrawDirtyObjects.set(State::DIRTY_OBJECT_DRAW_ATTACHMENTS);
+        mDrawDirtyObjects.set(State::DIRTY_OBJECT_TEXTURES_INIT);
+        mDrawDirtyObjects.set(State::DIRTY_OBJECT_IMAGES_INIT);
+        mBlitDirtyObjects.set(State::DIRTY_OBJECT_DRAW_ATTACHMENTS);
+        mBlitDirtyObjects.set(State::DIRTY_OBJECT_READ_ATTACHMENTS);
+        mComputeDirtyObjects.set(State::DIRTY_OBJECT_TEXTURES_INIT);
+        mComputeDirtyObjects.set(State::DIRTY_OBJECT_IMAGES_INIT);
+        mReadPixelsDirtyObjects.set(State::DIRTY_OBJECT_READ_ATTACHMENTS);
+        mCopyImageDirtyObjects.set(State::DIRTY_OBJECT_READ_ATTACHMENTS);
+    }
 
     // We need to validate buffer bounds if we are in a WebGL or robust access context and the
     // back-end does not support robust buffer access behaviour.
-    if (!mSupportedExtensions.robustBufferAccessBehavior && (mState.isWebGL() || mRobustAccess))
-    {
-        mBufferAccessValidationEnabled = true;
+    mBufferAccessValidationEnabled =
+        (!mSupportedExtensions.robustBufferAccessBehavior && (mState.isWebGL() || mRobustAccess));
+
+    // Cache this in the VertexArrays. They need to check it in state change notifications.
+    for (auto vaoIter : mVertexArrayMap)
+    {
+        VertexArray *vao = vaoIter.second;
+        vao->setBufferAccessValidationEnabled(mBufferAccessValidationEnabled);
     }
 
     // Reinitialize state cache after extension changes.
     mStateCache.initialize(this);
 }
 
-void Context::initWorkarounds()
-{
-    // Apply back-end workarounds.
-    mImplementation->applyNativeWorkarounds(&mWorkarounds);
-
-    // Lose the context upon out of memory error if the application is
-    // expecting to watch for those events.
-    mWorkarounds.loseContextOnOutOfMemory = (mResetStrategy == GL_LOSE_CONTEXT_ON_RESET_EXT);
-
-    if (mWorkarounds.syncFramebufferBindingsOnTexImage)
-    {
-        // Update the Framebuffer bindings on TexImage to work around an Intel bug.
-        mTexImageDirtyBits.set(State::DIRTY_BIT_READ_FRAMEBUFFER_BINDING);
-        mTexImageDirtyBits.set(State::DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING);
-    }
-}
-
 bool Context::noopDrawInstanced(PrimitiveMode mode, GLsizei count, GLsizei instanceCount)
 {
     return (instanceCount == 0) || noopDraw(mode, count);
@@ -3467,17 +3572,21 @@
 
 angle::Result Context::prepareForClear(GLbitfield mask)
 {
-    ANGLE_TRY(syncDirtyObjects(mClearDirtyObjects));
+    // Sync the draw framebuffer manually after the clear attachments.
+    ASSERT(mClearDirtyObjects.none());
     ANGLE_TRY(mState.getDrawFramebuffer()->ensureClearAttachmentsInitialized(this, mask));
+    ANGLE_TRY(mState.syncDirtyObject(this, GL_DRAW_FRAMEBUFFER));
     ANGLE_TRY(syncDirtyBits(mClearDirtyBits));
     return angle::Result::Continue;
 }
 
 angle::Result Context::prepareForClearBuffer(GLenum buffer, GLint drawbuffer)
 {
-    ANGLE_TRY(syncDirtyObjects(mClearDirtyObjects));
+    // Sync the draw framebuffer manually after the clear attachments.
+    ASSERT(mClearDirtyObjects.none());
     ANGLE_TRY(mState.getDrawFramebuffer()->ensureClearBufferAttachmentsInitialized(this, buffer,
                                                                                    drawbuffer));
+    ANGLE_TRY(mState.syncDirtyObject(this, GL_DRAW_FRAMEBUFFER));
     ANGLE_TRY(syncDirtyBits(mClearDirtyBits));
     return angle::Result::Continue;
 }
@@ -3520,6 +3629,11 @@
     Rectangle srcArea(srcX0, srcY0, srcX1 - srcX0, srcY1 - srcY0);
     Rectangle dstArea(dstX0, dstY0, dstX1 - dstX0, dstY1 - dstY0);
 
+    if (dstArea.width == 0 || dstArea.height == 0)
+    {
+        return;
+    }
+
     ANGLE_CONTEXT_TRY(syncStateForBlit());
 
     ANGLE_CONTEXT_TRY(drawFramebuffer->blit(this, srcArea, dstArea, mask, filter));
@@ -3537,12 +3651,12 @@
     const FramebufferAttachment *attachment = nullptr;
     if (buffer == GL_DEPTH)
     {
-        attachment = framebufferObject->getDepthbuffer();
+        attachment = framebufferObject->getDepthAttachment();
     }
     if (buffer == GL_COLOR &&
-        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorBuffers())
-    {
-        attachment = framebufferObject->getColorbuffer(drawbuffer);
+        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorAttachments())
+    {
+        attachment = framebufferObject->getColorAttachment(drawbuffer);
     }
     // It's not an error to try to clear a non-existent buffer, but it's a no-op. We early out so
     // that the backend doesn't need to take this case into account.
@@ -3559,9 +3673,9 @@
     Framebuffer *framebufferObject          = mState.getDrawFramebuffer();
     const FramebufferAttachment *attachment = nullptr;
     if (buffer == GL_COLOR &&
-        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorBuffers())
-    {
-        attachment = framebufferObject->getColorbuffer(drawbuffer);
+        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorAttachments())
+    {
+        attachment = framebufferObject->getColorAttachment(drawbuffer);
     }
     // It's not an error to try to clear a non-existent buffer, but it's a no-op. We early out so
     // that the backend doesn't need to take this case into account.
@@ -3579,12 +3693,12 @@
     const FramebufferAttachment *attachment = nullptr;
     if (buffer == GL_STENCIL)
     {
-        attachment = framebufferObject->getStencilbuffer();
+        attachment = framebufferObject->getStencilAttachment();
     }
     if (buffer == GL_COLOR &&
-        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorBuffers())
-    {
-        attachment = framebufferObject->getColorbuffer(drawbuffer);
+        static_cast<size_t>(drawbuffer) < framebufferObject->getNumColorAttachments())
+    {
+        attachment = framebufferObject->getColorAttachment(drawbuffer);
     }
     // It's not an error to try to clear a non-existent buffer, but it's a no-op. We early out so
     // that the backend doesn't need to take this case into account.
@@ -3602,8 +3716,8 @@
     ASSERT(framebufferObject);
 
     // If a buffer is not present, the clear has no effect
-    if (framebufferObject->getDepthbuffer() == nullptr &&
-        framebufferObject->getStencilbuffer() == nullptr)
+    if (framebufferObject->getDepthAttachment() == nullptr &&
+        framebufferObject->getStencilAttachment() == nullptr)
     {
         return;
     }
@@ -3673,13 +3787,12 @@
                              GLsizei height,
                              GLint border)
 {
-    // Only sync the read FBO
-    ANGLE_CONTEXT_TRY(mState.syncDirtyObject(this, GL_READ_FRAMEBUFFER));
+    ANGLE_CONTEXT_TRY(mState.syncDirtyObjects(this, mCopyImageDirtyObjects));
 
     Rectangle sourceArea(x, y, width, height);
 
     Framebuffer *framebuffer = mState.getReadFramebuffer();
-    Texture *texture         = getTargetTexture(TextureTargetToType(target));
+    Texture *texture         = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(
         texture->copyImage(this, target, level, sourceArea, internalformat, framebuffer));
 }
@@ -3698,20 +3811,19 @@
         return;
     }
 
-    // Only sync the read FBO
-    ANGLE_CONTEXT_TRY(mState.syncDirtyObject(this, GL_READ_FRAMEBUFFER));
+    ANGLE_CONTEXT_TRY(mState.syncDirtyObjects(this, mCopyImageDirtyObjects));
 
     Offset destOffset(xoffset, yoffset, 0);
     Rectangle sourceArea(x, y, width, height);
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, 1);
 
     Framebuffer *framebuffer = mState.getReadFramebuffer();
-    Texture *texture         = getTargetTexture(TextureTargetToType(target));
+    Texture *texture         = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(texture->copySubImage(this, index, destOffset, sourceArea, framebuffer));
 }
 
-void Context::copyTexSubImage3D(TextureType target,
+void Context::copyTexSubImage3D(TextureTarget target,
                                 GLint level,
                                 GLint xoffset,
                                 GLint yoffset,
@@ -3726,16 +3838,15 @@
         return;
     }
 
-    // Only sync the read FBO
-    ANGLE_CONTEXT_TRY(mState.syncDirtyObject(this, GL_READ_FRAMEBUFFER));
+    ANGLE_CONTEXT_TRY(mState.syncDirtyObjects(this, mCopyImageDirtyObjects));
 
     Offset destOffset(xoffset, yoffset, zoffset);
     Rectangle sourceArea(x, y, width, height);
 
-    ImageIndex index = ImageIndex::MakeFromType(target, level, zoffset);
+    ImageIndex index = ImageIndex::MakeFromType(TextureTargetToType(target), level, zoffset);
 
     Framebuffer *framebuffer = mState.getReadFramebuffer();
-    Texture *texture         = getTargetTexture(target);
+    Texture *texture         = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(texture->copySubImage(this, index, destOffset, sourceArea, framebuffer));
 }
 
@@ -3751,7 +3862,7 @@
     if (texture != 0)
     {
         Texture *textureObj = getTexture(texture);
-        ImageIndex index    = ImageIndex::MakeFromTarget(textarget, level);
+        ImageIndex index    = ImageIndex::MakeFromTarget(textarget, level, 1);
         framebuffer->setAttachment(this, GL_TEXTURE, attachment, index, textureObj);
     }
     else
@@ -3762,6 +3873,16 @@
     mState.setObjectDirty(target);
 }
 
+void Context::framebufferTexture3D(GLenum target,
+                                   GLenum attachment,
+                                   TextureTarget textargetPacked,
+                                   GLuint texture,
+                                   GLint level,
+                                   GLint zoffset)
+{
+    UNIMPLEMENTED();
+}
+
 void Context::framebufferRenderbuffer(GLenum target,
                                       GLenum attachment,
                                       GLenum renderbuffertarget,
@@ -3948,7 +4069,7 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Extents size(width, height, 1);
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(texture->setImage(this, mState.getUnpackState(), target, level,
                                         internalformat, size, format, type,
                                         static_cast<const uint8_t *>(pixels)));
@@ -3968,7 +4089,7 @@
     texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
 }
 
-void Context::texImage3D(TextureType target,
+void Context::texImage3D(TextureTarget target,
                          GLint level,
                          GLint internalformat,
                          GLsizei width,
@@ -3982,13 +4103,13 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Extents size(width, height, depth);
-    Texture *texture = getTargetTexture(target);
-    ANGLE_CONTEXT_TRY(texture->setImage(this, mState.getUnpackState(),
-                                        NonCubeTextureTypeToTarget(target), level, internalformat,
-                                        size, format, type, static_cast<const uint8_t *>(pixels)));
-}
-
-void Context::texImage3DRobust(TextureType target,
+    Texture *texture = getTextureByTarget(target);
+    ANGLE_CONTEXT_TRY(texture->setImage(this, mState.getUnpackState(), target, level,
+                                        internalformat, size, format, type,
+                                        static_cast<const uint8_t *>(pixels)));
+}
+
+void Context::texImage3DRobust(TextureTarget target,
                                GLint level,
                                GLint internalformat,
                                GLsizei width,
@@ -4022,7 +4143,7 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Box area(xoffset, yoffset, 0, width, height, 1);
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
 
     gl::Buffer *unpackBuffer = mState.getTargetBuffer(gl::BufferBinding::PixelUnpack);
 
@@ -4045,7 +4166,7 @@
     texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
 }
 
-void Context::texSubImage3D(TextureType target,
+void Context::texSubImage3D(TextureTarget target,
                             GLint level,
                             GLint xoffset,
                             GLint yoffset,
@@ -4066,16 +4187,16 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Box area(xoffset, yoffset, zoffset, width, height, depth);
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByTarget(target);
 
     gl::Buffer *unpackBuffer = mState.getTargetBuffer(gl::BufferBinding::PixelUnpack);
 
-    ANGLE_CONTEXT_TRY(texture->setSubImage(this, mState.getUnpackState(), unpackBuffer,
-                                           NonCubeTextureTypeToTarget(target), level, area, format,
-                                           type, static_cast<const uint8_t *>(pixels)));
-}
-
-void Context::texSubImage3DRobust(TextureType target,
+    ANGLE_CONTEXT_TRY(texture->setSubImage(this, mState.getUnpackState(), unpackBuffer, target,
+                                           level, area, format, type,
+                                           static_cast<const uint8_t *>(pixels)));
+}
+
+void Context::texSubImage3DRobust(TextureTarget target,
                                   GLint level,
                                   GLint xoffset,
                                   GLint yoffset,
@@ -4104,7 +4225,7 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Extents size(width, height, 1);
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(texture->setCompressedImage(this, mState.getUnpackState(), target, level,
                                                   internalformat, size, imageSize,
                                                   static_cast<const uint8_t *>(data)));
@@ -4123,7 +4244,7 @@
     compressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
 }
 
-void Context::compressedTexImage3D(TextureType target,
+void Context::compressedTexImage3D(TextureTarget target,
                                    GLint level,
                                    GLenum internalformat,
                                    GLsizei width,
@@ -4136,13 +4257,13 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Extents size(width, height, depth);
-    Texture *texture = getTargetTexture(target);
-    ANGLE_CONTEXT_TRY(texture->setCompressedImage(
-        this, mState.getUnpackState(), NonCubeTextureTypeToTarget(target), level, internalformat,
-        size, imageSize, static_cast<const uint8_t *>(data)));
-}
-
-void Context::compressedTexImage3DRobust(TextureType target,
+    Texture *texture = getTextureByTarget(target);
+    ANGLE_CONTEXT_TRY(texture->setCompressedImage(this, mState.getUnpackState(), target, level,
+                                                  internalformat, size, imageSize,
+                                                  static_cast<const uint8_t *>(data)));
+}
+
+void Context::compressedTexImage3DRobust(TextureTarget target,
                                          GLint level,
                                          GLenum internalformat,
                                          GLsizei width,
@@ -4170,7 +4291,7 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Box area(xoffset, yoffset, 0, width, height, 1);
-    Texture *texture = getTargetTexture(TextureTargetToType(target));
+    Texture *texture = getTextureByTarget(target);
     ANGLE_CONTEXT_TRY(texture->setCompressedSubImage(this, mState.getUnpackState(), target, level,
                                                      area, format, imageSize,
                                                      static_cast<const uint8_t *>(data)));
@@ -4191,7 +4312,7 @@
                             data);
 }
 
-void Context::compressedTexSubImage3D(TextureType target,
+void Context::compressedTexSubImage3D(TextureTarget target,
                                       GLint level,
                                       GLint xoffset,
                                       GLint yoffset,
@@ -4212,13 +4333,13 @@
     ANGLE_CONTEXT_TRY(syncStateForTexImage());
 
     Box area(xoffset, yoffset, zoffset, width, height, depth);
-    Texture *texture = getTargetTexture(target);
-    ANGLE_CONTEXT_TRY(texture->setCompressedSubImage(
-        this, mState.getUnpackState(), NonCubeTextureTypeToTarget(target), level, area, format,
-        imageSize, static_cast<const uint8_t *>(data)));
-}
-
-void Context::compressedTexSubImage3DRobust(TextureType target,
+    Texture *texture = getTextureByTarget(target);
+    ANGLE_CONTEXT_TRY(texture->setCompressedSubImage(this, mState.getUnpackState(), target, level,
+                                                     area, format, imageSize,
+                                                     static_cast<const uint8_t *>(data)));
+}
+
+void Context::compressedTexSubImage3DRobust(TextureTarget target,
                                             GLint level,
                                             GLint xoffset,
                                             GLint yoffset,
@@ -4237,7 +4358,7 @@
 
 void Context::generateMipmap(TextureType target)
 {
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByType(target);
     ANGLE_CONTEXT_TRY(texture->generateMipmap(this));
 }
 
@@ -4542,6 +4663,7 @@
 {
     mState.setColorMask(ConvertToBool(red), ConvertToBool(green), ConvertToBool(blue),
                         ConvertToBool(alpha));
+    mStateCache.onColorMaskChange(this);
 }
 
 void Context::cullFace(CullFaceMode mode)
@@ -4995,7 +5117,7 @@
                                  const GLchar *buf)
 {
     std::string msg(buf, (length > 0) ? static_cast<size_t>(length) : strlen(buf));
-    mState.getDebug().insertMessage(source, type, id, severity, std::move(msg));
+    mState.getDebug().insertMessage(source, type, id, severity, std::move(msg), gl::LOG_INFO);
 }
 
 void Context::debugMessageCallback(GLDEBUGPROCKHR callback, const void *userParam)
@@ -5059,11 +5181,6 @@
     programObject->attachShader(shaderObject);
 }
 
-const Workarounds &Context::getWorkarounds() const
-{
-    return mWorkarounds;
-}
-
 void Context::copyBufferSubData(BufferBinding readTarget,
                                 BufferBinding writeTarget,
                                 GLintptr readOffset,
@@ -5145,7 +5262,7 @@
                                       GLboolean fixedsamplelocations)
 {
     Extents size(width, height, 1);
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByType(target);
     ANGLE_CONTEXT_TRY(texture->setStorageMultisample(this, target, samples, internalformat, size,
                                                      ConvertToBool(fixedsamplelocations)));
 }
@@ -5159,11 +5276,32 @@
                                       GLboolean fixedsamplelocations)
 {
     Extents size(width, height, depth);
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByType(target);
     ANGLE_CONTEXT_TRY(texture->setStorageMultisample(this, target, samples, internalformat, size,
                                                      ConvertToBool(fixedsamplelocations)));
 }
 
+void Context::texImage2DExternal(TextureTarget target,
+                                 GLint level,
+                                 GLint internalformat,
+                                 GLsizei width,
+                                 GLsizei height,
+                                 GLint border,
+                                 GLenum format,
+                                 GLenum type)
+{
+    Extents size(width, height, 1);
+    Texture *texture = getTextureByTarget(target);
+    ANGLE_CONTEXT_TRY(
+        texture->setImageExternal(this, target, level, internalformat, size, format, type));
+}
+
+void Context::invalidateTexture(TextureType target)
+{
+    mImplementation->invalidateTexture(target);
+    mState.invalidateTexture(target);
+}
+
 void Context::getMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
 {
     // According to spec 3.1 Table 20.49: Framebuffer Dependent Values,
@@ -5218,7 +5356,11 @@
 
 void Context::getSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
 {
-    const Sync *syncObject = getSync(sync);
+    const Sync *syncObject = nullptr;
+    if (!mContextLost)
+    {
+        syncObject = getSync(sync);
+    }
     ANGLE_CONTEXT_TRY(QuerySynciv(this, syncObject, pname, bufSize, length, values));
 }
 
@@ -5279,7 +5421,7 @@
                            GLsizei height)
 {
     Extents size(width, height, 1);
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByType(target);
     ANGLE_CONTEXT_TRY(texture->setStorage(this, target, levels, internalFormat, size));
 }
 
@@ -5291,7 +5433,7 @@
                            GLsizei depth)
 {
     Extents size(width, height, depth);
-    Texture *texture = getTargetTexture(target);
+    Texture *texture = getTextureByType(target);
     ANGLE_CONTEXT_TRY(texture->setStorage(this, target, levels, internalFormat, size));
 }
 
@@ -5453,7 +5595,7 @@
     }
 }
 
-void Context::provokingVertex(ProvokingVertex provokeMode)
+void Context::provokingVertex(ProvokingVertexConvention provokeMode)
 {
     mState.setProvokingVertex(provokeMode);
 }
@@ -5661,10 +5803,14 @@
 
 void Context::getProgramiv(GLuint program, GLenum pname, GLint *params)
 {
-    // Don't resolve link if checking the link completion status.
-    Program *programObject = (pname == GL_COMPLETION_STATUS_KHR ? getProgramNoResolveLink(program)
-                                                                : getProgramResolveLink(program));
-    ASSERT(programObject);
+    Program *programObject = nullptr;
+    if (!mContextLost)
+    {
+        // Don't resolve link if checking the link completion status.
+        programObject = (pname == GL_COMPLETION_STATUS_KHR ? getProgramNoResolveLink(program)
+                                                           : getProgramResolveLink(program));
+        ASSERT(programObject);
+    }
     QueryProgramiv(this, programObject, pname, params);
 }
 
@@ -5682,6 +5828,16 @@
     UNIMPLEMENTED();
 }
 
+MemoryObject *Context::getMemoryObject(GLuint handle) const
+{
+    return mState.mMemoryObjectManager->getMemoryObject(handle);
+}
+
+Semaphore *Context::getSemaphore(GLuint handle) const
+{
+    return mState.mSemaphoreManager->getSemaphore(handle);
+}
+
 void Context::getProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei *length, GLchar *infolog)
 {
     Program *programObject = getProgramResolveLink(program);
@@ -5699,9 +5855,13 @@
 
 void Context::getShaderiv(GLuint shader, GLenum pname, GLint *params)
 {
-    Shader *shaderObject = getShader(shader);
-    ASSERT(shaderObject);
-    QueryShaderiv(shaderObject, pname, params);
+    Shader *shaderObject = nullptr;
+    if (!mContextLost)
+    {
+        shaderObject = getShader(shader);
+        ASSERT(shaderObject);
+    }
+    QueryShaderiv(this, shaderObject, pname, params);
 }
 
 void Context::getShaderivRobust(GLuint shader,
@@ -5846,7 +6006,7 @@
         return GL_FALSE;
     }
 
-    return (getBuffer(buffer) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getBuffer(buffer));
 }
 
 GLboolean Context::isEnabled(GLenum cap)
@@ -5861,7 +6021,7 @@
         return GL_FALSE;
     }
 
-    return (getFramebuffer(framebuffer) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getFramebuffer(framebuffer));
 }
 
 GLboolean Context::isProgram(GLuint program)
@@ -5871,7 +6031,7 @@
         return GL_FALSE;
     }
 
-    return (getProgramNoResolveLink(program) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getProgramNoResolveLink(program));
 }
 
 GLboolean Context::isRenderbuffer(GLuint renderbuffer)
@@ -5881,7 +6041,7 @@
         return GL_FALSE;
     }
 
-    return (getRenderbuffer(renderbuffer) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getRenderbuffer(renderbuffer));
 }
 
 GLboolean Context::isShader(GLuint shader)
@@ -5891,7 +6051,7 @@
         return GL_FALSE;
     }
 
-    return (getShader(shader) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getShader(shader));
 }
 
 GLboolean Context::isTexture(GLuint texture)
@@ -5901,7 +6061,7 @@
         return GL_FALSE;
     }
 
-    return (getTexture(texture) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getTexture(texture));
 }
 
 void Context::linkProgram(GLuint program)
@@ -6233,7 +6393,7 @@
 
 GLboolean Context::isQuery(GLuint id)
 {
-    return (getQuery(id, false, QueryType::InvalidEnum) != nullptr) ? GL_TRUE : GL_FALSE;
+    return ConvertToGLBoolean(getQuery(id, false, QueryType::InvalidEnum) != nullptr);
 }
 
 void Context::uniformMatrix2x3fv(GLint location,
@@ -6323,7 +6483,7 @@
     }
 }
 
-bool Context::isVertexArray(GLuint array)
+GLboolean Context::isVertexArray(GLuint array)
 {
     if (array == 0)
     {
@@ -6331,7 +6491,7 @@
     }
 
     VertexArray *vao = getVertexArray(array);
-    return (vao != nullptr ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(vao != nullptr);
 }
 
 void Context::endTransformFeedback()
@@ -6398,7 +6558,7 @@
     }
 }
 
-bool Context::isTransformFeedback(GLuint id)
+GLboolean Context::isTransformFeedback(GLuint id)
 {
     if (id == 0)
     {
@@ -6408,7 +6568,7 @@
     }
 
     const TransformFeedback *transformFeedback = getTransformFeedback(id);
-    return ((transformFeedback != nullptr) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(transformFeedback != nullptr);
 }
 
 void Context::pauseTransformFeedback()
@@ -6947,7 +7107,7 @@
         return GL_FALSE;
     }
 
-    return (getProgramPipeline(pipeline) ? GL_TRUE : GL_FALSE);
+    return ConvertToGLBoolean(getProgramPipeline(pipeline));
 }
 
 void Context::finishFenceNV(GLuint fence)
@@ -7097,9 +7257,205 @@
     return result;
 }
 
+void Context::deleteMemoryObjects(GLsizei n, const GLuint *memoryObjects)
+{
+    for (int i = 0; i < n; i++)
+    {
+        deleteMemoryObject(memoryObjects[i]);
+    }
+}
+
+GLboolean Context::isMemoryObject(GLuint memoryObject)
+{
+    if (memoryObject == 0)
+    {
+        return GL_FALSE;
+    }
+
+    return ConvertToGLBoolean(getMemoryObject(memoryObject));
+}
+
+void Context::createMemoryObjects(GLsizei n, GLuint *memoryObjects)
+{
+    for (int i = 0; i < n; i++)
+    {
+        memoryObjects[i] = createMemoryObject();
+    }
+}
+
+void Context::memoryObjectParameteriv(GLuint memoryObject, GLenum pname, const GLint *params)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::getMemoryObjectParameteriv(GLuint memoryObject, GLenum pname, GLint *params)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::texStorageMem2D(TextureType target,
+                              GLsizei levels,
+                              GLenum internalFormat,
+                              GLsizei width,
+                              GLsizei height,
+                              GLuint memory,
+                              GLuint64 offset)
+{
+    MemoryObject *memoryObject = getMemoryObject(memory);
+    ASSERT(memoryObject);
+    Extents size(width, height, 1);
+    Texture *texture = getTextureByType(target);
+    ANGLE_CONTEXT_TRY(texture->setStorageExternalMemory(this, target, levels, internalFormat, size,
+                                                        memoryObject, offset));
+}
+
+void Context::texStorageMem2DMultisample(TextureType target,
+                                         GLsizei samples,
+                                         GLenum internalFormat,
+                                         GLsizei width,
+                                         GLsizei height,
+                                         GLboolean fixedSampleLocations,
+                                         GLuint memory,
+                                         GLuint64 offset)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::texStorageMem3D(TextureType target,
+                              GLsizei levels,
+                              GLenum internalFormat,
+                              GLsizei width,
+                              GLsizei height,
+                              GLsizei depth,
+                              GLuint memory,
+                              GLuint64 offset)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::texStorageMem3DMultisample(TextureType target,
+                                         GLsizei samples,
+                                         GLenum internalFormat,
+                                         GLsizei width,
+                                         GLsizei height,
+                                         GLsizei depth,
+                                         GLboolean fixedSampleLocations,
+                                         GLuint memory,
+                                         GLuint64 offset)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::bufferStorageMem(TextureType target, GLsizeiptr size, GLuint memory, GLuint64 offset)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::importMemoryFd(GLuint memory, GLuint64 size, HandleType handleType, GLint fd)
+{
+    MemoryObject *memoryObject = getMemoryObject(memory);
+    ASSERT(memoryObject != nullptr);
+    ANGLE_CONTEXT_TRY(memoryObject->importFd(this, size, handleType, fd));
+}
+
+void Context::genSemaphores(GLsizei n, GLuint *semaphores)
+{
+    for (int i = 0; i < n; i++)
+    {
+        semaphores[i] = createSemaphore();
+    }
+}
+
+void Context::deleteSemaphores(GLsizei n, const GLuint *semaphores)
+{
+    for (int i = 0; i < n; i++)
+    {
+        deleteSemaphore(semaphores[i]);
+    }
+}
+
+GLboolean Context::isSemaphore(GLuint semaphore)
+{
+    if (semaphore == 0)
+    {
+        return GL_FALSE;
+    }
+
+    return ConvertToGLBoolean(getSemaphore(semaphore));
+}
+
+void Context::semaphoreParameterui64v(GLuint semaphore, GLenum pname, const GLuint64 *params)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::getSemaphoreParameterui64v(GLuint semaphore, GLenum pname, GLuint64 *params)
+{
+    UNIMPLEMENTED();
+}
+
+void Context::waitSemaphore(GLuint semaphoreHandle,
+                            GLuint numBufferBarriers,
+                            const GLuint *buffers,
+                            GLuint numTextureBarriers,
+                            const GLuint *textures,
+                            const GLenum *srcLayouts)
+{
+    Semaphore *semaphore = getSemaphore(semaphoreHandle);
+    ASSERT(semaphore);
+
+    BufferBarrierVector bufferBarriers(numBufferBarriers);
+    for (GLuint bufferBarrierIdx = 0; bufferBarrierIdx < numBufferBarriers; bufferBarrierIdx++)
+    {
+        bufferBarriers[bufferBarrierIdx] = getBuffer(buffers[bufferBarrierIdx]);
+    }
+
+    TextureBarrierVector textureBarriers(numTextureBarriers);
+    for (GLuint textureBarrierIdx = 0; textureBarrierIdx < numTextureBarriers; textureBarrierIdx++)
+    {
+        textureBarriers[textureBarrierIdx].texture = getTexture(textures[textureBarrierIdx]);
+        textureBarriers[textureBarrierIdx].layout  = srcLayouts[textureBarrierIdx];
+    }
+
+    ANGLE_CONTEXT_TRY(semaphore->wait(this, bufferBarriers, textureBarriers));
+}
+
+void Context::signalSemaphore(GLuint semaphoreHandle,
+                              GLuint numBufferBarriers,
+                              const GLuint *buffers,
+                              GLuint numTextureBarriers,
+                              const GLuint *textures,
+                              const GLenum *dstLayouts)
+{
+    Semaphore *semaphore = getSemaphore(semaphoreHandle);
+    ASSERT(semaphore);
+
+    BufferBarrierVector bufferBarriers(numBufferBarriers);
+    for (GLuint bufferBarrierIdx = 0; bufferBarrierIdx < numBufferBarriers; bufferBarrierIdx++)
+    {
+        bufferBarriers[bufferBarrierIdx] = getBuffer(buffers[bufferBarrierIdx]);
+    }
+
+    TextureBarrierVector textureBarriers(numTextureBarriers);
+    for (GLuint textureBarrierIdx = 0; textureBarrierIdx < numTextureBarriers; textureBarrierIdx++)
+    {
+        textureBarriers[textureBarrierIdx].texture = getTexture(textures[textureBarrierIdx]);
+        textureBarriers[textureBarrierIdx].layout  = dstLayouts[textureBarrierIdx];
+    }
+
+    ANGLE_CONTEXT_TRY(semaphore->signal(this, bufferBarriers, textureBarriers));
+}
+
+void Context::importSemaphoreFd(GLuint semaphore, HandleType handleType, GLint fd)
+{
+    Semaphore *semaphoreObject = getSemaphore(semaphore);
+    ASSERT(semaphoreObject != nullptr);
+    ANGLE_CONTEXT_TRY(semaphoreObject->importFd(this, handleType, fd));
+}
+
 void Context::eGLImageTargetTexture2D(TextureType target, GLeglImageOES image)
 {
-    Texture *texture        = getTargetTexture(target);
+    Texture *texture        = getTextureByType(target);
     egl::Image *imageObject = static_cast<egl::Image *>(image);
     ANGLE_CONTEXT_TRY(texture->setEGLImageTarget(this, target, imageObject));
 }
@@ -7116,7 +7472,7 @@
     UNIMPLEMENTED();
 }
 
-bool Context::getQueryParameterInfo(GLenum pname, GLenum *type, unsigned int *numParams)
+bool Context::getQueryParameterInfo(GLenum pname, GLenum *type, unsigned int *numParams) const
 {
     // Please note: the query type returned for DEPTH_CLEAR_VALUE in this implementation
     // is FLOAT rather than INT, as would be suggested by the GL ES 2.0 spec. This is due
@@ -7540,6 +7896,22 @@
                 *numParams = 1;
                 return true;
         }
+        case GL_TEXTURE_BINDING_3D:
+            if ((getClientMajorVersion() < 3) && !getExtensions().texture3DOES)
+            {
+                return false;
+            }
+            *type      = GL_INT;
+            *numParams = 1;
+            return true;
+        case GL_MAX_3D_TEXTURE_SIZE:
+            if ((getClientMajorVersion() < 3) && !getExtensions().texture3DOES)
+            {
+                return false;
+            }
+            *type      = GL_INT;
+            *numParams = 1;
+            return true;
     }
 
     if (pname >= GL_DRAW_BUFFER0_EXT && pname <= GL_DRAW_BUFFER15_EXT)
@@ -7553,7 +7925,7 @@
         return true;
     }
 
-    if (getExtensions().multiview2 && pname == GL_MAX_VIEWS_OVR)
+    if ((getExtensions().multiview2 || getExtensions().multiview) && pname == GL_MAX_VIEWS_OVR)
     {
         *type      = GL_INT;
         *numParams = 1;
@@ -7666,7 +8038,6 @@
         case GL_READ_BUFFER:
         case GL_TEXTURE_BINDING_3D:
         case GL_TEXTURE_BINDING_2D_ARRAY:
-        case GL_MAX_3D_TEXTURE_SIZE:
         case GL_MAX_ARRAY_TEXTURE_LAYERS:
         case GL_MAX_VERTEX_UNIFORM_BLOCKS:
         case GL_MAX_FRAGMENT_UNIFORM_BLOCKS:
@@ -7844,7 +8215,9 @@
     return false;
 }
 
-bool Context::getIndexedQueryParameterInfo(GLenum target, GLenum *type, unsigned int *numParams)
+bool Context::getIndexedQueryParameterInfo(GLenum target,
+                                           GLenum *type,
+                                           unsigned int *numParams) const
 {
     if (getClientVersion() < Version(3, 0))
     {
@@ -7927,6 +8300,11 @@
     return mState.mShaderProgramManager->getShader(handle);
 }
 
+const angle::FrontendFeatures &Context::getFrontendFeatures() const
+{
+    return mDisplay->getFrontendFeatures();
+}
+
 bool Context::isRenderbufferGenerated(GLuint renderbuffer) const
 {
     return mState.mRenderbufferManager->isHandleGenerated(renderbuffer);
@@ -7965,6 +8343,7 @@
         mThreadPool = angle::WorkerThreadPool::Create(count > 0);
     }
     mThreadPool->setMaxThreads(count);
+    mImplementation->setMaxShaderCompilerThreads(count);
 }
 
 bool Context::isGLES1() const
@@ -7972,22 +8351,20 @@
     return mState.getClientVersion() < Version(2, 0);
 }
 
-void Context::onSubjectStateChange(const Context *context,
-                                   angle::SubjectIndex index,
-                                   angle::SubjectMessage message)
+void Context::onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMessage message)
 {
     switch (index)
     {
         case kVertexArraySubjectIndex:
             switch (message)
             {
-                case angle::SubjectMessage::CONTENTS_CHANGED:
+                case angle::SubjectMessage::ContentsChanged:
                     mState.setObjectDirty(GL_VERTEX_ARRAY);
                     mStateCache.onVertexArrayBufferContentsChange(this);
                     break;
-                case angle::SubjectMessage::RESOURCE_MAPPED:
-                case angle::SubjectMessage::RESOURCE_UNMAPPED:
-                case angle::SubjectMessage::BINDING_CHANGED:
+                case angle::SubjectMessage::SubjectMapped:
+                case angle::SubjectMessage::SubjectUnmapped:
+                case angle::SubjectMessage::BindingChanged:
                     mStateCache.onVertexArrayBufferStateChange(this);
                     break;
                 default:
@@ -7996,25 +8373,24 @@
             break;
 
         case kReadFramebufferSubjectIndex:
-            if (message == angle::SubjectMessage::STORAGE_CHANGED)
-            {
-                mState.setObjectDirty(GL_READ_FRAMEBUFFER);
-            }
+            ASSERT(message == angle::SubjectMessage::DirtyBitsFlagged);
+            mState.setReadFramebufferDirty();
             break;
 
         case kDrawFramebufferSubjectIndex:
-            if (message == angle::SubjectMessage::STORAGE_CHANGED)
-            {
-                mState.setDrawFramebufferDirty();
-            }
+            ASSERT(message == angle::SubjectMessage::DirtyBitsFlagged);
+            mState.setDrawFramebufferDirty();
             mStateCache.onDrawFramebufferChange(this);
             break;
 
         default:
             if (index < kTextureMaxSubjectIndex)
             {
-                mState.onActiveTextureStateChange(this, index);
-                mStateCache.onActiveTextureChange(this);
+                if (message != angle::SubjectMessage::ContentsChanged)
+                {
+                    mState.onActiveTextureStateChange(this, index);
+                    mStateCache.onActiveTextureChange(this);
+                }
             }
             else if (index < kUniformBufferMaxSubjectIndex)
             {
@@ -8025,6 +8401,7 @@
             {
                 ASSERT(index < kSamplerMaxSubjectIndex);
                 mState.setSamplerDirty(index - kSampler0SubjectIndex);
+                mState.onActiveTextureStateChange(this, index - kSampler0SubjectIndex);
             }
             break;
     }
@@ -8052,6 +8429,80 @@
     return angle::Result::Continue;
 }
 
+egl::Error Context::setDefaultFramebuffer(egl::Surface *surface)
+{
+    ASSERT(mCurrentSurface == nullptr);
+
+    Framebuffer *newDefault = nullptr;
+    if (surface != nullptr)
+    {
+        ANGLE_TRY(surface->makeCurrent(this));
+        mCurrentSurface = surface;
+        newDefault      = surface->createDefaultFramebuffer(this);
+    }
+    else
+    {
+        newDefault = new Framebuffer(mImplementation.get());
+    }
+
+    // Update default framebuffer, the binding of the previous default
+    // framebuffer (or lack of) will have a nullptr.
+    {
+        mState.mFramebufferManager->setDefaultFramebuffer(newDefault);
+        if (mState.getReadFramebuffer() == nullptr)
+        {
+            bindReadFramebuffer(0);
+        }
+        if (mState.getDrawFramebuffer() == nullptr)
+        {
+            bindDrawFramebuffer(0);
+        }
+    }
+
+    return egl::NoError();
+}
+
+egl::Error Context::unsetDefaultFramebuffer()
+{
+    gl::Framebuffer *defaultFramebuffer = mState.mFramebufferManager->getFramebuffer(0);
+
+    // Remove the default framebuffer
+    if (mState.getReadFramebuffer() == defaultFramebuffer)
+    {
+        mState.setReadFramebufferBinding(nullptr);
+        mReadFramebufferObserverBinding.bind(nullptr);
+    }
+
+    if (mState.getDrawFramebuffer() == defaultFramebuffer)
+    {
+        mState.setDrawFramebufferBinding(nullptr);
+        mDrawFramebufferObserverBinding.bind(nullptr);
+    }
+
+    if (defaultFramebuffer)
+    {
+        defaultFramebuffer->onDestroy(this);
+        delete defaultFramebuffer;
+    }
+
+    mState.mFramebufferManager->setDefaultFramebuffer(nullptr);
+
+    // Always unset the current surface, even if setIsCurrent fails.
+    egl::Surface *surface = mCurrentSurface;
+    mCurrentSurface       = nullptr;
+    if (surface)
+    {
+        ANGLE_TRY(surface->unMakeCurrent(this));
+    }
+
+    return egl::NoError();
+}
+
+angle::FrameCapture *Context::getFrameCapture()
+{
+    return mDisplay->getFrameCapture();
+}
+
 // ErrorSet implementation.
 ErrorSet::ErrorSet(Context *context) : mContext(context) {}
 
@@ -8063,9 +8514,11 @@
                            const char *function,
                            unsigned int line)
 {
-    if (errorCode == GL_OUT_OF_MEMORY && mContext->getWorkarounds().loseContextOnOutOfMemory)
-    {
-        mContext->markContextLost();
+    if (errorCode == GL_OUT_OF_MEMORY &&
+        mContext->getGraphicsResetStrategy() == GL_LOSE_CONTEXT_ON_RESET_EXT &&
+        mContext->getDisplay()->getFrontendFeatures().loseContextOnOutOfMemory.enabled)
+    {
+        mContext->markContextLost(GraphicsResetStatus::UnknownContextReset);
     }
 
     std::stringstream errorStream;
@@ -8074,11 +8527,13 @@
 
     std::string formattedMessage = errorStream.str();
 
-    // Always log a warning, this function is only called on unexpected internal errors.
-    WARN() << formattedMessage;
-
-    // validationError does the necessary work to process the error.
-    validationError(errorCode, formattedMessage.c_str());
+    // Process the error, but log it with WARN severity so it shows up in logs.
+    ASSERT(errorCode != GL_NO_ERROR);
+    mErrors.insert(errorCode);
+
+    mContext->getState().getDebug().insertMessage(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR,
+                                                  errorCode, GL_DEBUG_SEVERITY_HIGH, message,
+                                                  gl::LOG_WARN);
 }
 
 void ErrorSet::validationError(GLenum errorCode, const char *message)
@@ -8087,7 +8542,8 @@
     mErrors.insert(errorCode);
 
     mContext->getState().getDebug().insertMessage(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR,
-                                                  errorCode, GL_DEBUG_SEVERITY_HIGH, message);
+                                                  errorCode, GL_DEBUG_SEVERITY_HIGH, message,
+                                                  gl::LOG_INFO);
 }
 
 bool ErrorSet::empty() const
@@ -8314,6 +8770,11 @@
     updateBasicDrawStatesError();
 }
 
+void StateCache::onColorMaskChange(Context *context)
+{
+    updateBasicDrawStatesError();
+}
+
 void StateCache::setValidDrawModes(bool pointsOK,
                                    bool linesOK,
                                    bool trisOK,
@@ -8400,7 +8861,7 @@
         {TextureType::_2DArray, isGLES3},
         {TextureType::_2DMultisample, isGLES31 || exts.textureMultisample},
         {TextureType::_2DMultisampleArray, exts.textureStorageMultisample2DArray},
-        {TextureType::_3D, isGLES3},
+        {TextureType::_3D, isGLES3 || exts.texture3DOES},
         {TextureType::External, exts.eglImageExternal || exts.eglStreamConsumerExternal},
         {TextureType::Rectangle, exts.textureRectangle},
         {TextureType::CubeMap, true},