# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/State.h
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/State.h
--- a/gfx/angle/checkout/src/libANGLE/State.h	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/State.h	Sat Sep 07 13:38:36 2019 +0000
@@ -34,11 +34,13 @@
 struct Caps;
 class Context;
 class FramebufferManager;
+class MemoryObjectManager;
 class PathManager;
 class ProgramPipelineManager;
 class Query;
 class RenderbufferManager;
 class SamplerManager;
+class SemaphoreManager;
 class ShaderProgramManager;
 class SyncManager;
 class TextureManager;
@@ -56,6 +58,7 @@
     State(ContextID contextIn,
           const State *shareContextState,
           TextureManager *shareTextures,
+          const EGLenum clientType,
           const Version &clientVersion,
           bool debug,
           bool bindGeneratesResource,
@@ -69,6 +72,7 @@
 
     // Getters
     ContextID getContextID() const { return mContext; }
+    EGLenum getClientType() const { return mClientType; }
     GLint getClientMajorVersion() const { return mClientVersion.major; }
     GLint getClientMinorVersion() const { return mClientVersion.minor; }
     const Version &getClientVersion() const { return mClientVersion; }
@@ -88,7 +92,7 @@
 
     // State chunk getters
     const RasterizerState &getRasterizerState() const;
-    const BlendState &getBlendState() const;
+    const BlendState &getBlendState() const { return mBlend; }
     const DepthStencilState &getDepthStencilState() const;
 
     // Clear behavior setters & state parameter block generation function
@@ -230,6 +234,8 @@
     void detachTexture(const Context *context, const TextureMap &zeroTextures, GLuint texture);
     void initializeZeroTextures(const Context *context, const TextureMap &zeroTextures);
 
+    void invalidateTexture(TextureType type);
+
     // Sampler object binding manipulation
     void setSamplerBinding(const Context *context, GLuint textureUnit, Sampler *sampler);
     GLuint getSamplerId(GLuint textureUnit) const
@@ -294,6 +300,11 @@
     void setTransformFeedbackBinding(const Context *context, TransformFeedback *transformFeedback);
     TransformFeedback *getCurrentTransformFeedback() const { return mTransformFeedback.get(); }
 
+    ANGLE_INLINE bool isTransformFeedbackActive() const
+    {
+        TransformFeedback *curTransformFeedback = mTransformFeedback.get();
+        return curTransformFeedback && curTransformFeedback->isActive();
+    }
     ANGLE_INLINE bool isTransformFeedbackActiveUnpaused() const
     {
         TransformFeedback *curTransformFeedback = mTransformFeedback.get();
@@ -482,6 +493,11 @@
 
     enum DirtyBitType
     {
+        // Note: process draw framebuffer binding first, so that other dirty bits whose effect
+        // depend on the current draw framebuffer are not processed while the old framebuffer is
+        // still bound.
+        DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING,
+        DIRTY_BIT_READ_FRAMEBUFFER_BINDING,
         DIRTY_BIT_SCISSOR_TEST_ENABLED,
         DIRTY_BIT_SCISSOR,
         DIRTY_BIT_VIEWPORT,
@@ -524,8 +540,6 @@
         DIRTY_BIT_DITHER_ENABLED,
         DIRTY_BIT_GENERATE_MIPMAP_HINT,
         DIRTY_BIT_SHADER_DERIVATIVE_HINT,
-        DIRTY_BIT_READ_FRAMEBUFFER_BINDING,
-        DIRTY_BIT_DRAW_FRAMEBUFFER_BINDING,
         DIRTY_BIT_RENDERBUFFER_BINDING,
         DIRTY_BIT_VERTEX_ARRAY_BINDING,
         DIRTY_BIT_DRAW_INDIRECT_BUFFER_BINDING,
@@ -557,15 +571,16 @@
     // TODO(jmadill): Consider storing dirty objects in a list instead of by binding.
     enum DirtyObjectType
     {
-        DIRTY_OBJECT_READ_FRAMEBUFFER = 0,
+        DIRTY_OBJECT_TEXTURES_INIT,
+        DIRTY_OBJECT_IMAGES_INIT,
+        DIRTY_OBJECT_READ_ATTACHMENTS,
+        DIRTY_OBJECT_DRAW_ATTACHMENTS,
+        DIRTY_OBJECT_READ_FRAMEBUFFER,
         DIRTY_OBJECT_DRAW_FRAMEBUFFER,
-        DIRTY_OBJECT_DRAW_ATTACHMENTS,
         DIRTY_OBJECT_VERTEX_ARRAY,
         DIRTY_OBJECT_TEXTURES,  // Top-level dirty bit. Also see mDirtyTextures.
         DIRTY_OBJECT_SAMPLERS,  // Top-level dirty bit. Also see mDirtySamplers.
         DIRTY_OBJECT_PROGRAM,
-        DIRTY_OBJECT_TEXTURES_INIT,
-        DIRTY_OBJECT_IMAGES_INIT,
         DIRTY_OBJECT_UNKNOWN,
         DIRTY_OBJECT_MAX = DIRTY_OBJECT_UNKNOWN,
     };
@@ -574,7 +589,11 @@
     const DirtyBits &getDirtyBits() const { return mDirtyBits; }
     void clearDirtyBits() { mDirtyBits.reset(); }
     void clearDirtyBits(const DirtyBits &bitset) { mDirtyBits &= ~bitset; }
-    void setAllDirtyBits() { mDirtyBits.set(); }
+    void setAllDirtyBits()
+    {
+        mDirtyBits.set();
+        mDirtyCurrentValues.set();
+    }
 
     using DirtyObjects = angle::BitSet<DIRTY_OBJECT_MAX>;
     void clearDirtyObjects() { mDirtyObjects.reset(); }
@@ -585,6 +604,12 @@
     void setTextureDirty(size_t textureUnitIndex);
     void setSamplerDirty(size_t samplerIndex);
 
+    ANGLE_INLINE void setReadFramebufferDirty()
+    {
+        mDirtyObjects.set(DIRTY_OBJECT_READ_FRAMEBUFFER);
+        mDirtyObjects.set(DIRTY_OBJECT_READ_ATTACHMENTS);
+    }
+
     ANGLE_INLINE void setDrawFramebufferDirty()
     {
         mDirtyObjects.set(DIRTY_OBJECT_DRAW_FRAMEBUFFER);
@@ -642,8 +667,8 @@
         return (mTexturesIncompatibleWithSamplers & mProgram->getActiveSamplersMask()).none();
     }
 
-    ProvokingVertex getProvokingVertex() const { return mProvokingVertex; }
-    void setProvokingVertex(ProvokingVertex val)
+    ProvokingVertexConvention getProvokingVertex() const { return mProvokingVertex; }
+    void setProvokingVertex(ProvokingVertexConvention val)
     {
         mDirtyBits.set(State::DIRTY_BIT_PROVOKING_VERTEX);
         mProvokingVertex = val;
@@ -660,36 +685,46 @@
                                   Texture *texture);
 
     // Functions to synchronize dirty states
+    angle::Result syncTexturesInit(const Context *context);
+    angle::Result syncImagesInit(const Context *context);
+    angle::Result syncReadAttachments(const Context *context);
+    angle::Result syncDrawAttachments(const Context *context);
     angle::Result syncReadFramebuffer(const Context *context);
     angle::Result syncDrawFramebuffer(const Context *context);
-    angle::Result syncDrawAttachments(const Context *context);
     angle::Result syncVertexArray(const Context *context);
     angle::Result syncTextures(const Context *context);
     angle::Result syncSamplers(const Context *context);
     angle::Result syncProgram(const Context *context);
-    angle::Result syncTexturesInit(const Context *context);
-    angle::Result syncImagesInit(const Context *context);
 
     using DirtyObjectHandler = angle::Result (State::*)(const Context *context);
     static constexpr DirtyObjectHandler kDirtyObjectHandlers[DIRTY_OBJECT_MAX] = {
-        &State::syncReadFramebuffer, &State::syncDrawFramebuffer, &State::syncDrawAttachments,
+        &State::syncTexturesInit,    &State::syncImagesInit,      &State::syncReadAttachments,
+        &State::syncDrawAttachments, &State::syncReadFramebuffer, &State::syncDrawFramebuffer,
         &State::syncVertexArray,     &State::syncTextures,        &State::syncSamplers,
-        &State::syncProgram,         &State::syncTexturesInit,    &State::syncImagesInit};
+        &State::syncProgram,
+    };
 
-    static_assert(DIRTY_OBJECT_READ_FRAMEBUFFER == 0, "check DIRTY_OBJECT_READ_FRAMEBUFFER index");
-    static_assert(DIRTY_OBJECT_DRAW_FRAMEBUFFER == 1, "check DIRTY_OBJECT_DRAW_FRAMEBUFFER index");
-    static_assert(DIRTY_OBJECT_DRAW_ATTACHMENTS == 2, "check DIRTY_OBJECT_DRAW_ATTACHMENTS index");
-    static_assert(DIRTY_OBJECT_VERTEX_ARRAY == 3, "check DIRTY_OBJECT_VERTEX_ARRAY index");
-    static_assert(DIRTY_OBJECT_TEXTURES == 4, "check DIRTY_OBJECT_TEXTURES index");
-    static_assert(DIRTY_OBJECT_SAMPLERS == 5, "check DIRTY_OBJECT_SAMPLERS index");
-    static_assert(DIRTY_OBJECT_PROGRAM == 6, "check DIRTY_OBJECT_PROGRAM index");
-    static_assert(DIRTY_OBJECT_TEXTURES_INIT == 7, "check DIRTY_OBJECT_TEXTURES_INIT index");
-    static_assert(DIRTY_OBJECT_IMAGES_INIT == 8, "check DIRTY_OBJECT_IMAGES_INIT index");
-    static_assert(DIRTY_OBJECT_MAX == 9, "check DIRTY_OBJECT_MAX");
+    // Robust init must happen before Framebuffer init for the Vulkan back-end.
+    static_assert(DIRTY_OBJECT_TEXTURES_INIT < DIRTY_OBJECT_DRAW_FRAMEBUFFER, "init order");
+    static_assert(DIRTY_OBJECT_IMAGES_INIT < DIRTY_OBJECT_DRAW_FRAMEBUFFER, "init order");
+    static_assert(DIRTY_OBJECT_DRAW_ATTACHMENTS < DIRTY_OBJECT_DRAW_FRAMEBUFFER, "init order");
+    static_assert(DIRTY_OBJECT_READ_ATTACHMENTS < DIRTY_OBJECT_READ_FRAMEBUFFER, "init order");
+
+    static_assert(DIRTY_OBJECT_TEXTURES_INIT == 0, "check DIRTY_OBJECT_TEXTURES_INIT index");
+    static_assert(DIRTY_OBJECT_IMAGES_INIT == 1, "check DIRTY_OBJECT_IMAGES_INIT index");
+    static_assert(DIRTY_OBJECT_READ_ATTACHMENTS == 2, "check DIRTY_OBJECT_READ_ATTACHMENTS index");
+    static_assert(DIRTY_OBJECT_DRAW_ATTACHMENTS == 3, "check DIRTY_OBJECT_DRAW_ATTACHMENTS index");
+    static_assert(DIRTY_OBJECT_READ_FRAMEBUFFER == 4, "check DIRTY_OBJECT_READ_FRAMEBUFFER index");
+    static_assert(DIRTY_OBJECT_DRAW_FRAMEBUFFER == 5, "check DIRTY_OBJECT_DRAW_FRAMEBUFFER index");
+    static_assert(DIRTY_OBJECT_VERTEX_ARRAY == 6, "check DIRTY_OBJECT_VERTEX_ARRAY index");
+    static_assert(DIRTY_OBJECT_TEXTURES == 7, "check DIRTY_OBJECT_TEXTURES index");
+    static_assert(DIRTY_OBJECT_SAMPLERS == 8, "check DIRTY_OBJECT_SAMPLERS index");
+    static_assert(DIRTY_OBJECT_PROGRAM == 9, "check DIRTY_OBJECT_PROGRAM index");
 
     // Dispatch table for buffer update functions.
     static const angle::PackedEnumMap<BufferBinding, BufferBindingSetter> kBufferSetters;
 
+    EGLenum mClientType;
     Version mClientVersion;
     ContextID mContext;
 
@@ -709,6 +744,8 @@
     PathManager *mPathManager;
     FramebufferManager *mFramebufferManager;
     ProgramPipelineManager *mProgramPipelineManager;
+    MemoryObjectManager *mMemoryObjectManager;
+    SemaphoreManager *mSemaphoreManager;
 
     // Cached values from Context's caps
     GLuint mMaxDrawBuffers;
@@ -754,7 +791,7 @@
     BindingPointer<ProgramPipeline> mProgramPipeline;
 
     // GL_ANGLE_provoking_vertex
-    ProvokingVertex mProvokingVertex;
+    ProvokingVertexConvention mProvokingVertex;
 
     using VertexAttribVector = std::vector<VertexAttribCurrentValueData>;
     VertexAttribVector mVertexAttribCurrentValues;  // From glVertexAttrib