# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/VertexArray.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/VertexArray.cpp
--- a/gfx/angle/checkout/src/libANGLE/VertexArray.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/VertexArray.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -24,33 +24,6 @@
     return (subjectIndex == MAX_VERTEX_ATTRIBS);
 }
 
-ANGLE_INLINE ComponentType GetVertexAttributeComponentType(bool pureInteger, VertexAttribType type)
-{
-    if (pureInteger)
-    {
-        switch (type)
-        {
-            case VertexAttribType::Byte:
-            case VertexAttribType::Short:
-            case VertexAttribType::Int:
-                return ComponentType::Int;
-
-            case VertexAttribType::UnsignedByte:
-            case VertexAttribType::UnsignedShort:
-            case VertexAttribType::UnsignedInt:
-                return ComponentType::UnsignedInt;
-
-            default:
-                UNREACHABLE();
-                return ComponentType::NoType;
-        }
-    }
-    else
-    {
-        return ComponentType::Float;
-    }
-}
-
 constexpr angle::SubjectIndex kElementArrayBufferIndex = MAX_VERTEX_ATTRIBS;
 }  // namespace
 
@@ -127,7 +100,8 @@
                          size_t maxAttribBindings)
     : mId(id),
       mState(this, maxAttribs, maxAttribBindings),
-      mVertexArray(factory->createVertexArray(mState))
+      mVertexArray(factory->createVertexArray(mState)),
+      mBufferAccessValidationEnabled(false)
 {
     for (size_t attribIndex = 0; attribIndex < maxAttribBindings; ++attribIndex)
     {
@@ -248,10 +222,9 @@
     mDirtyBindingBits[bindingIndex].set(dirtyBindingBit);
 }
 
-ANGLE_INLINE void VertexArray::updateCachedBufferBindingSize(const Context *context,
-                                                             VertexBinding *binding)
+ANGLE_INLINE void VertexArray::updateCachedBufferBindingSize(VertexBinding *binding)
 {
-    if (!context->isBufferAccessValidationEnabled())
+    if (!mBufferAccessValidationEnabled)
         return;
 
     for (size_t boundAttribute : binding->getBoundAttributesMask())
@@ -291,7 +264,7 @@
     mCachedTransformFeedbackConflictedBindingsMask.set(bindingIndex, hasConflict);
 }
 
-void VertexArray::bindVertexBufferImpl(const Context *context,
+bool VertexArray::bindVertexBufferImpl(const Context *context,
                                        size_t bindingIndex,
                                        Buffer *boundBuffer,
                                        GLintptr offset,
@@ -302,7 +275,17 @@
 
     VertexBinding *binding = &mState.mVertexBindings[bindingIndex];
 
-    Buffer *oldBuffer                = binding->getBuffer().get();
+    Buffer *oldBuffer = binding->getBuffer().get();
+
+    const bool sameBuffer = oldBuffer == boundBuffer;
+    const bool sameStride = static_cast<GLuint>(stride) == binding->getStride();
+    const bool sameOffset = offset == binding->getOffset();
+
+    if (sameBuffer && sameStride && sameOffset)
+    {
+        return false;
+    }
+
     angle::ObserverBinding *observer = &mArrayBufferObserverBindings[bindingIndex];
     observer->assignSubject(boundBuffer);
 
@@ -317,7 +300,7 @@
     binding->assignBuffer(boundBuffer);
     binding->setOffset(offset);
     binding->setStride(stride);
-    updateCachedBufferBindingSize(context, binding);
+    updateCachedBufferBindingSize(binding);
 
     // Update client memory attribute pointers. Affects all bound attributes.
     if (boundBuffer)
@@ -336,6 +319,8 @@
         mState.mClientMemoryAttribsMask |= binding->getBoundAttributesMask();
         updateCachedMappedArrayBuffers(false, binding->getBoundAttributesMask());
     }
+
+    return true;
 }
 
 void VertexArray::bindVertexBuffer(const Context *context,
@@ -344,8 +329,10 @@
                                    GLintptr offset,
                                    GLsizei stride)
 {
-    bindVertexBufferImpl(context, bindingIndex, boundBuffer, offset, stride);
-    setDirtyBindingBit(bindingIndex, DIRTY_BINDING_BUFFER);
+    if (bindVertexBufferImpl(context, bindingIndex, boundBuffer, offset, stride))
+    {
+        setDirtyBindingBit(bindingIndex, DIRTY_BINDING_BUFFER);
+    }
 }
 
 void VertexArray::setVertexAttribBinding(const Context *context,
@@ -385,16 +372,23 @@
     }
 }
 
-ANGLE_INLINE void VertexArray::setVertexAttribFormatImpl(VertexAttribute *attrib,
+ANGLE_INLINE bool VertexArray::setVertexAttribFormatImpl(VertexAttribute *attrib,
                                                          GLint size,
                                                          VertexAttribType type,
                                                          bool normalized,
+                                                         bool pureInteger,
                                                          GLuint relativeOffset)
 {
-    attrib->size           = size;
-    attrib->type           = type;
-    attrib->normalized     = normalized;
-    attrib->relativeOffset = relativeOffset;
+    angle::FormatID formatID = gl::GetVertexFormatID(type, normalized, size, pureInteger);
+
+    if (formatID != attrib->format->id || attrib->relativeOffset != relativeOffset)
+    {
+        attrib->relativeOffset = relativeOffset;
+        attrib->format         = &angle::Format::Get(formatID);
+        return true;
+    }
+
+    return false;
 }
 
 void VertexArray::setVertexAttribFormat(size_t attribIndex,
@@ -405,13 +399,14 @@
                                         GLuint relativeOffset)
 {
     VertexAttribute &attrib = mState.mVertexAttributes[attribIndex];
-    attrib.pureInteger      = pureInteger;
 
     ComponentType componentType = GetVertexAttributeComponentType(pureInteger, type);
     SetComponentTypeMask(componentType, attribIndex, &mState.mVertexAttributesTypeMask);
 
-    setVertexAttribFormatImpl(&attrib, size, type, normalized, relativeOffset);
-    setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_FORMAT);
+    if (setVertexAttribFormatImpl(&attrib, size, type, normalized, pureInteger, relativeOffset))
+    {
+        setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_FORMAT);
+    }
 
     attrib.updateCachedElementLimit(mState.mVertexBindings[attrib.bindingIndex]);
 }
@@ -461,21 +456,41 @@
     GLintptr offset = boundBuffer ? reinterpret_cast<GLintptr>(pointer) : 0;
 
     VertexAttribute &attrib = mState.mVertexAttributes[attribIndex];
-    attrib.pureInteger      = pureInteger;
 
     SetComponentTypeMask(componentType, attribIndex, &mState.mVertexAttributesTypeMask);
 
-    setVertexAttribFormatImpl(&attrib, size, type, normalized, 0);
-    setVertexAttribBinding(context, attribIndex, static_cast<GLuint>(attribIndex));
+    bool attribDirty = setVertexAttribFormatImpl(&attrib, size, type, normalized, pureInteger, 0);
+
+    if (attrib.bindingIndex != attribIndex)
+    {
+        setVertexAttribBinding(context, attribIndex, static_cast<GLuint>(attribIndex));
+    }
 
     GLsizei effectiveStride =
         stride != 0 ? stride : static_cast<GLsizei>(ComputeVertexAttributeTypeSize(attrib));
+
+    if (pointer != attrib.pointer || attrib.vertexAttribArrayStride != static_cast<GLuint>(stride))
+    {
+        attribDirty = true;
+    }
+
     attrib.pointer                 = pointer;
     attrib.vertexAttribArrayStride = stride;
 
+    // "Pointer buffer" dirty bit disabled because of a bug. http://anglebug.com/3256
     bindVertexBufferImpl(context, attribIndex, boundBuffer, offset, effectiveStride);
+    setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_POINTER);
+    ANGLE_UNUSED_VARIABLE(attribDirty);
 
-    setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_POINTER);
+    // if (bindVertexBufferImpl(context, attribIndex, boundBuffer, offset, effectiveStride) &&
+    //    !attribDirty)
+    //{
+    //    setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_POINTER_BUFFER);
+    //}
+    // else if (attribDirty)
+    //{
+    //    setDirtyAttribBit(attribIndex, DIRTY_ATTRIB_POINTER);
+    //}
 
     mState.mNullPointerClientMemoryAttribsMask.set(attribIndex,
                                                    boundBuffer == nullptr && pointer == nullptr);
@@ -552,25 +567,23 @@
     }
 }
 
-void VertexArray::onSubjectStateChange(const gl::Context *context,
-                                       angle::SubjectIndex index,
-                                       angle::SubjectMessage message)
+void VertexArray::onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMessage message)
 {
     switch (message)
     {
-        case angle::SubjectMessage::CONTENTS_CHANGED:
-            setDependentDirtyBit(context, true, index);
+        case angle::SubjectMessage::ContentsChanged:
+            setDependentDirtyBit(true, index);
             break;
 
-        case angle::SubjectMessage::STORAGE_CHANGED:
+        case angle::SubjectMessage::SubjectChanged:
             if (!IsElementArrayBufferSubjectIndex(index))
             {
-                updateCachedBufferBindingSize(context, &mState.mVertexBindings[index]);
+                updateCachedBufferBindingSize(&mState.mVertexBindings[index]);
             }
-            setDependentDirtyBit(context, false, index);
+            setDependentDirtyBit(false, index);
             break;
 
-        case angle::SubjectMessage::BINDING_CHANGED:
+        case angle::SubjectMessage::BindingChanged:
             if (!IsElementArrayBufferSubjectIndex(index))
             {
                 const Buffer *buffer = mState.mVertexBindings[index].getBuffer().get();
@@ -578,22 +591,22 @@
             }
             break;
 
-        case angle::SubjectMessage::RESOURCE_MAPPED:
+        case angle::SubjectMessage::SubjectMapped:
             if (!IsElementArrayBufferSubjectIndex(index))
             {
                 updateCachedMappedArrayBuffersBinding(mState.mVertexBindings[index]);
             }
-            onStateChange(context, angle::SubjectMessage::RESOURCE_MAPPED);
+            onStateChange(angle::SubjectMessage::SubjectMapped);
             break;
 
-        case angle::SubjectMessage::RESOURCE_UNMAPPED:
-            setDependentDirtyBit(context, true, index);
+        case angle::SubjectMessage::SubjectUnmapped:
+            setDependentDirtyBit(true, index);
 
             if (!IsElementArrayBufferSubjectIndex(index))
             {
                 updateCachedMappedArrayBuffersBinding(mState.mVertexBindings[index]);
             }
-            onStateChange(context, angle::SubjectMessage::RESOURCE_UNMAPPED);
+            onStateChange(angle::SubjectMessage::SubjectUnmapped);
             break;
 
         default:
@@ -602,14 +615,12 @@
     }
 }
 
-void VertexArray::setDependentDirtyBit(const gl::Context *context,
-                                       bool contentsChanged,
-                                       angle::SubjectIndex index)
+void VertexArray::setDependentDirtyBit(bool contentsChanged, angle::SubjectIndex index)
 {
     DirtyBitType dirtyBit = getDirtyBitFromIndex(contentsChanged, index);
     ASSERT(!mDirtyBitsGuard.valid() || mDirtyBitsGuard.value().test(dirtyBit));
     mDirtyBits.set(dirtyBit);
-    onStateChange(context, angle::SubjectMessage::CONTENTS_CHANGED);
+    onStateChange(angle::SubjectMessage::ContentsChanged);
 }
 
 bool VertexArray::hasTransformFeedbackBindingConflict(const gl::Context *context) const