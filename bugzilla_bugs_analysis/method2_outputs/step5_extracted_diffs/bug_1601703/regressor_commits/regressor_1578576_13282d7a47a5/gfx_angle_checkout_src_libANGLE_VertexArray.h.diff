# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/VertexArray.h
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/VertexArray.h
--- a/gfx/angle/checkout/src/libANGLE/VertexArray.h	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/VertexArray.h	Sat Sep 07 13:38:36 2019 +0000
@@ -100,6 +100,65 @@
                           public angle::Subject
 {
   public:
+    // Dirty bits for VertexArrays use a heirarchical design. At the top level, each attribute
+    // has a single dirty bit. Then an array of MAX_ATTRIBS dirty bits each has a dirty bit for
+    // enabled/pointer/format/binding. Bindings are handled similarly. Note that because the
+    // total number of dirty bits is 33, it will not be as fast on a 32-bit machine, which
+    // can't support the advanced 64-bit scanning intrinsics. We could consider packing the
+    // binding and attribute bits together if this becomes a problem.
+    //
+    // Special note on "DIRTY_ATTRIB_POINTER_BUFFER": this is a special case when the app
+    // calls glVertexAttribPointer but only changes a VBO and/or offset binding. This allows
+    // the Vulkan back-end to skip performing a pipeline change for performance.
+    enum DirtyBitType
+    {
+        DIRTY_BIT_ELEMENT_ARRAY_BUFFER,
+        DIRTY_BIT_ELEMENT_ARRAY_BUFFER_DATA,
+
+        // Dirty bits for attributes.
+        DIRTY_BIT_ATTRIB_0,
+        DIRTY_BIT_ATTRIB_MAX = DIRTY_BIT_ATTRIB_0 + gl::MAX_VERTEX_ATTRIBS,
+
+        // Dirty bits for bindings.
+        DIRTY_BIT_BINDING_0   = DIRTY_BIT_ATTRIB_MAX,
+        DIRTY_BIT_BINDING_MAX = DIRTY_BIT_BINDING_0 + gl::MAX_VERTEX_ATTRIB_BINDINGS,
+
+        // We keep separate dirty bits for bound buffers whose data changed since last update.
+        DIRTY_BIT_BUFFER_DATA_0   = DIRTY_BIT_BINDING_MAX,
+        DIRTY_BIT_BUFFER_DATA_MAX = DIRTY_BIT_BUFFER_DATA_0 + gl::MAX_VERTEX_ATTRIB_BINDINGS,
+
+        DIRTY_BIT_UNKNOWN = DIRTY_BIT_BUFFER_DATA_MAX,
+        DIRTY_BIT_MAX     = DIRTY_BIT_UNKNOWN,
+    };
+
+    // We want to keep the number of dirty bits within 64 to keep iteration times fast.
+    static_assert(DIRTY_BIT_MAX <= 64, "Too many vertex array dirty bits.");
+
+    enum DirtyAttribBitType
+    {
+        DIRTY_ATTRIB_ENABLED,
+        DIRTY_ATTRIB_POINTER,
+        DIRTY_ATTRIB_FORMAT,
+        DIRTY_ATTRIB_BINDING,
+        DIRTY_ATTRIB_POINTER_BUFFER,
+        DIRTY_ATTRIB_UNKNOWN,
+        DIRTY_ATTRIB_MAX = DIRTY_ATTRIB_UNKNOWN,
+    };
+
+    enum DirtyBindingBitType
+    {
+        DIRTY_BINDING_BUFFER,
+        DIRTY_BINDING_DIVISOR,
+        DIRTY_BINDING_UNKNOWN,
+        DIRTY_BINDING_MAX = DIRTY_BINDING_UNKNOWN,
+    };
+
+    using DirtyBits             = angle::BitSet<DIRTY_BIT_MAX>;
+    using DirtyAttribBits       = angle::BitSet<DIRTY_ATTRIB_MAX>;
+    using DirtyBindingBits      = angle::BitSet<DIRTY_BINDING_MAX>;
+    using DirtyAttribBitsArray  = std::array<DirtyAttribBits, gl::MAX_VERTEX_ATTRIBS>;
+    using DirtyBindingBitsArray = std::array<DirtyBindingBits, gl::MAX_VERTEX_ATTRIB_BINDINGS>;
+
     VertexArray(rx::GLImplFactory *factory, GLuint id, size_t maxAttribs, size_t maxAttribBindings);
 
     void onDestroy(const Context *context);
@@ -152,16 +211,6 @@
                           GLsizei stride);
     void setVertexAttribBinding(const Context *context, size_t attribIndex, GLuint bindingIndex);
     void setVertexBindingDivisor(size_t bindingIndex, GLuint divisor);
-    void setVertexAttribFormatImpl(VertexAttribute *attrib,
-                                   GLint size,
-                                   VertexAttribType type,
-                                   bool normalized,
-                                   GLuint relativeOffset);
-    void bindVertexBufferImpl(const Context *context,
-                              size_t bindingIndex,
-                              Buffer *boundBuffer,
-                              GLintptr offset,
-                              GLsizei stride);
 
     Buffer *getElementArrayBuffer() const { return mState.getElementArrayBuffer(); }
     size_t getMaxAttribs() const { return mState.getMaxAttribs(); }
@@ -196,63 +245,7 @@
     }
 
     // Observer implementation
-    void onSubjectStateChange(const gl::Context *context,
-                              angle::SubjectIndex index,
-                              angle::SubjectMessage message) override;
-
-    // Dirty bits for VertexArrays use a heirarchical design. At the top level, each attribute
-    // has a single dirty bit. Then an array of MAX_ATTRIBS dirty bits each has a dirty bit for
-    // enabled/pointer/format/binding. Bindings are handled similarly. Note that because the
-    // total number of dirty bits is 33, it will not be as fast on a 32-bit machine, which
-    // can't support the advanced 64-bit scanning intrinsics. We could consider packing the
-    // binding and attribute bits together if this becomes a problem.
-    enum DirtyBitType
-    {
-        DIRTY_BIT_ELEMENT_ARRAY_BUFFER,
-        DIRTY_BIT_ELEMENT_ARRAY_BUFFER_DATA,
-
-        // Dirty bits for attributes.
-        DIRTY_BIT_ATTRIB_0,
-        DIRTY_BIT_ATTRIB_MAX = DIRTY_BIT_ATTRIB_0 + gl::MAX_VERTEX_ATTRIBS,
-
-        // Dirty bits for bindings.
-        DIRTY_BIT_BINDING_0   = DIRTY_BIT_ATTRIB_MAX,
-        DIRTY_BIT_BINDING_MAX = DIRTY_BIT_BINDING_0 + gl::MAX_VERTEX_ATTRIB_BINDINGS,
-
-        // We keep separate dirty bits for bound buffers whose data changed since last update.
-        DIRTY_BIT_BUFFER_DATA_0   = DIRTY_BIT_BINDING_MAX,
-        DIRTY_BIT_BUFFER_DATA_MAX = DIRTY_BIT_BUFFER_DATA_0 + gl::MAX_VERTEX_ATTRIB_BINDINGS,
-
-        DIRTY_BIT_UNKNOWN = DIRTY_BIT_BUFFER_DATA_MAX,
-        DIRTY_BIT_MAX     = DIRTY_BIT_UNKNOWN,
-    };
-
-    // We want to keep the number of dirty bits within 64 to keep iteration times fast.
-    static_assert(DIRTY_BIT_MAX <= 64, "Too many vertex array dirty bits.");
-
-    enum DirtyAttribBitType
-    {
-        DIRTY_ATTRIB_ENABLED,
-        DIRTY_ATTRIB_POINTER,
-        DIRTY_ATTRIB_FORMAT,
-        DIRTY_ATTRIB_BINDING,
-        DIRTY_ATTRIB_UNKNOWN,
-        DIRTY_ATTRIB_MAX = DIRTY_ATTRIB_UNKNOWN,
-    };
-
-    enum DirtyBindingBitType
-    {
-        DIRTY_BINDING_BUFFER,
-        DIRTY_BINDING_DIVISOR,
-        DIRTY_BINDING_UNKNOWN,
-        DIRTY_BINDING_MAX = DIRTY_BINDING_UNKNOWN,
-    };
-
-    using DirtyBits             = angle::BitSet<DIRTY_BIT_MAX>;
-    using DirtyAttribBits       = angle::BitSet<DIRTY_ATTRIB_MAX>;
-    using DirtyBindingBits      = angle::BitSet<DIRTY_BINDING_MAX>;
-    using DirtyAttribBitsArray  = std::array<DirtyAttribBits, gl::MAX_VERTEX_ATTRIBS>;
-    using DirtyBindingBitsArray = std::array<DirtyBindingBits, gl::MAX_VERTEX_ATTRIB_BINDINGS>;
+    void onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMessage message) override;
 
     static size_t GetVertexIndexFromDirtyBit(size_t dirtyBit);
 
@@ -280,6 +273,11 @@
         return getIndexRangeImpl(context, type, indexCount, indices, indexRangeOut);
     }
 
+    void setBufferAccessValidationEnabled(bool enabled)
+    {
+        mBufferAccessValidationEnabled = enabled;
+    }
+
   private:
     ~VertexArray() override;
 
@@ -290,12 +288,10 @@
     void setDirtyBindingBit(size_t bindingIndex, DirtyBindingBitType dirtyBindingBit);
 
     DirtyBitType getDirtyBitFromIndex(bool contentsChanged, angle::SubjectIndex index) const;
-    void setDependentDirtyBit(const gl::Context *context,
-                              bool contentsChanged,
-                              angle::SubjectIndex index);
+    void setDependentDirtyBit(bool contentsChanged, angle::SubjectIndex index);
 
     // These are used to optimize draw call validation.
-    void updateCachedBufferBindingSize(const Context *context, VertexBinding *binding);
+    void updateCachedBufferBindingSize(VertexBinding *binding);
     void updateCachedTransformFeedbackBindingValidation(size_t bindingIndex, const Buffer *buffer);
     void updateCachedMappedArrayBuffers(bool isMapped, const AttributesMask &boundAttributesMask);
     void updateCachedMappedArrayBuffersBinding(const VertexBinding &binding);
@@ -317,6 +313,19 @@
                                     GLsizei stride,
                                     const void *pointer);
 
+    // These two functions return true if the state was dirty.
+    bool setVertexAttribFormatImpl(VertexAttribute *attrib,
+                                   GLint size,
+                                   VertexAttribType type,
+                                   bool normalized,
+                                   bool pureInteger,
+                                   GLuint relativeOffset);
+    bool bindVertexBufferImpl(const Context *context,
+                              size_t bindingIndex,
+                              Buffer *boundBuffer,
+                              GLintptr offset,
+                              GLsizei stride);
+
     GLuint mId;
 
     VertexArrayState mState;
@@ -366,6 +375,7 @@
     };
 
     mutable IndexRangeCache mIndexRangeCache;
+    bool mBufferAccessValidationEnabled;
 };
 
 }  // namespace gl