# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/angletypes.h
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/angletypes.h
--- a/gfx/angle/checkout/src/libANGLE/angletypes.h	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/angletypes.h	Sat Sep 07 13:38:36 2019 +0000
@@ -45,9 +45,14 @@
     bool isReversedX() const { return width < 0; }
     bool isReversedY() const { return height < 0; }
 
+    // Returns a rectangle with the same area but flipped in X, Y, neither or both.
+    Rectangle flip(bool flipX, bool flipY) const;
+
     // Returns a rectangle with the same area but with height and width guaranteed to be positive.
     Rectangle removeReversal() const;
 
+    bool encloses(const gl::Rectangle &inside) const;
+
     int x;
     int y;
     int width;
@@ -146,6 +151,8 @@
     BlendState();
     BlendState(const BlendState &other);
 
+    bool allChannelsMasked() const;
+
     bool blend;
     GLenum sourceBlendRGB;
     GLenum destBlendRGB;
@@ -426,6 +433,23 @@
     *mask |= kComponentMasks[type] << index;
 }
 
+ANGLE_INLINE ComponentType GetComponentTypeMask(const ComponentTypeMask &mask, size_t index)
+{
+    ASSERT(index <= kMaxComponentTypeMaskIndex);
+    uint32_t mask_bits = static_cast<uint32_t>((mask.to_ulong() >> index) & 0x10001);
+    switch (mask_bits)
+    {
+        case 0x10001:
+            return ComponentType::Float;
+        case 0x00001:
+            return ComponentType::Int;
+        case 0x10000:
+            return ComponentType::UnsignedInt;
+        default:
+            return ComponentType::InvalidEnum;
+    }
+}
+
 bool ValidateComponentTypeMasks(unsigned long outputTypes,
                                 unsigned long inputTypes,
                                 unsigned long outputMask,
@@ -437,6 +461,11 @@
 
 using TextureMap = angle::PackedEnumMap<TextureType, BindingPointer<Texture>>;
 
+// ShaderVector can contain one item per shader.  It differs from ShaderMap in that the values are
+// not indexed by ShaderType.
+template <typename T>
+using ShaderVector = angle::FixedVector<T, static_cast<size_t>(ShaderType::EnumCount)>;
+
 template <typename T>
 using AttachmentArray = std::array<T, IMPLEMENTATION_MAX_FRAMEBUFFER_ATTACHMENTS>;
 
@@ -457,8 +486,31 @@
 using ActiveTexturePointerArray = ActiveTextureArray<Texture *>;
 using ActiveTextureTypeArray    = ActiveTextureArray<TextureType>;
 
+template <typename T>
+using UniformBuffersArray = std::array<T, IMPLEMENTATION_MAX_UNIFORM_BUFFER_BINDINGS>;
+template <typename T>
+using StorageBuffersArray = std::array<T, IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS>;
+template <typename T>
+using AtomicCounterBuffersArray = std::array<T, IMPLEMENTATION_MAX_ATOMIC_COUNTER_BUFFERS>;
+
 using ImageUnitMask = angle::BitSet<IMPLEMENTATION_MAX_IMAGE_UNITS>;
 
+using SupportedSampleSet = std::set<GLuint>;
+
+template <typename T>
+using TransformFeedbackBuffersArray =
+    std::array<T, gl::IMPLEMENTATION_MAX_TRANSFORM_FEEDBACK_BUFFERS>;
+
+constexpr size_t kBarrierVectorDefaultSize = 16;
+using BufferBarrierVector                  = angle::FastVector<Buffer *, kBarrierVectorDefaultSize>;
+
+struct TextureAndLayout
+{
+    Texture *texture;
+    GLenum layout;
+};
+using TextureBarrierVector = angle::FastVector<TextureAndLayout, kBarrierVectorDefaultSize>;
+
 // OffsetBindingPointer.getSize() returns the size specified by the user, which may be larger than
 // the size of the bound buffer. This function reduces the returned size to fit the bound buffer if
 // necessary. Returns 0 if no buffer is bound or if integer overflow occurs.
@@ -518,7 +570,7 @@
 
 }  // namespace rx
 
-#include "angletypes.inl"
+#include "angletypes.inc"
 
 namespace angle
 {