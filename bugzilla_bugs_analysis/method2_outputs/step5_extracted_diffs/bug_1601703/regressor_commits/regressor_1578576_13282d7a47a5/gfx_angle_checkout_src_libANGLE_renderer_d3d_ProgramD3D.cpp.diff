# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/d3d/ProgramD3D.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/renderer/d3d/ProgramD3D.cpp
--- a/gfx/angle/checkout/src/libANGLE/renderer/d3d/ProgramD3D.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/d3d/ProgramD3D.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -201,102 +201,6 @@
     return false;
 }
 
-class InterfaceBlockInfo final : angle::NonCopyable
-{
-  public:
-    InterfaceBlockInfo() {}
-
-    void getShaderBlockInfo(const std::vector<sh::InterfaceBlock> &interfaceBlocks);
-
-    bool getBlockSize(const std::string &name, const std::string &mappedName, size_t *sizeOut);
-    bool getBlockMemberInfo(const std::string &name,
-                            const std::string &mappedName,
-                            sh::BlockMemberInfo *infoOut);
-
-  private:
-    size_t getBlockInfo(const sh::InterfaceBlock &interfaceBlock);
-
-    std::map<std::string, size_t> mBlockSizes;
-    sh::BlockLayoutMap mBlockLayout;
-};
-
-void InterfaceBlockInfo::getShaderBlockInfo(const std::vector<sh::InterfaceBlock> &interfaceBlocks)
-{
-    for (const sh::InterfaceBlock &interfaceBlock : interfaceBlocks)
-    {
-        if (!interfaceBlock.active && interfaceBlock.layout == sh::BLOCKLAYOUT_PACKED)
-            continue;
-
-        if (mBlockSizes.count(interfaceBlock.name) > 0)
-            continue;
-
-        size_t dataSize                  = getBlockInfo(interfaceBlock);
-        mBlockSizes[interfaceBlock.name] = dataSize;
-    }
-}
-
-size_t InterfaceBlockInfo::getBlockInfo(const sh::InterfaceBlock &interfaceBlock)
-{
-    ASSERT(interfaceBlock.active || interfaceBlock.layout != sh::BLOCKLAYOUT_PACKED);
-
-    // define member uniforms
-    sh::Std140BlockEncoder std140Encoder;
-    sh::Std430BlockEncoder std430Encoder;
-    sh::HLSLBlockEncoder hlslEncoder(sh::HLSLBlockEncoder::ENCODE_PACKED, false);
-    sh::BlockLayoutEncoder *encoder = nullptr;
-
-    if (interfaceBlock.layout == sh::BLOCKLAYOUT_STD140)
-    {
-        encoder = &std140Encoder;
-    }
-    else if (interfaceBlock.layout == sh::BLOCKLAYOUT_STD430)
-    {
-        encoder = &std430Encoder;
-    }
-    else
-    {
-        encoder = &hlslEncoder;
-    }
-
-    sh::GetInterfaceBlockInfo(interfaceBlock.fields, interfaceBlock.fieldPrefix(), encoder,
-                              &mBlockLayout);
-
-    return encoder->getCurrentOffset();
-}
-
-bool InterfaceBlockInfo::getBlockSize(const std::string &name,
-                                      const std::string &mappedName,
-                                      size_t *sizeOut)
-{
-    size_t nameLengthWithoutArrayIndex;
-    gl::ParseArrayIndex(name, &nameLengthWithoutArrayIndex);
-    std::string baseName = name.substr(0u, nameLengthWithoutArrayIndex);
-    auto sizeIter        = mBlockSizes.find(baseName);
-    if (sizeIter == mBlockSizes.end())
-    {
-        *sizeOut = 0;
-        return false;
-    }
-
-    *sizeOut = sizeIter->second;
-    return true;
-}
-
-bool InterfaceBlockInfo::getBlockMemberInfo(const std::string &name,
-                                            const std::string &mappedName,
-                                            sh::BlockMemberInfo *infoOut)
-{
-    auto infoIter = mBlockLayout.find(name);
-    if (infoIter == mBlockLayout.end())
-    {
-        *infoOut = sh::kDefaultBlockMemberInfo;
-        return false;
-    }
-
-    *infoOut = infoIter->second;
-    return true;
-}
-
 // Helper class that gathers uniform info from the default uniform block.
 class UniformEncodingVisitorD3D : public sh::BlockEncoderVisitor
 {
@@ -356,6 +260,15 @@
     HLSLRegisterType mRegisterType;
     D3DUniformMap *mUniformMapOut;
 };
+
+class HLSLBlockLayoutEncoderFactory : public gl::CustomBlockLayoutEncoderFactory
+{
+  public:
+    sh::BlockLayoutEncoder *makeEncoder() override
+    {
+        return new sh::HLSLBlockEncoder(sh::HLSLBlockEncoder::ENCODE_PACKED, false);
+    }
+};
 }  // anonymous namespace
 
 // D3DUniform Implementation
@@ -473,7 +386,7 @@
     : mRendererMajorShaderModel(renderer->getMajorShaderModel()),
       mShaderModelSuffix(renderer->getShaderModelSuffix()),
       mUsesInstancedPointSpriteEmulation(
-          renderer->getWorkarounds().useInstancedPointSpriteEmulation),
+          renderer->getFeatures().useInstancedPointSpriteEmulation.enabled),
       mUsesViewScale(renderer->presentPathFastEnabled()),
       mCanSelectViewInVertexShader(renderer->canSelectViewInVertexShader()),
       mAttachedShaders(attachedShaders)
@@ -534,6 +447,11 @@
     return mAttachedShaders[gl::ShaderType::Vertex]->hasANGLEMultiviewEnabled();
 }
 
+bool ProgramD3DMetadata::usesVertexID() const
+{
+    return mAttachedShaders[gl::ShaderType::Vertex]->usesVertexID();
+}
+
 bool ProgramD3DMetadata::usesViewID() const
 {
     return mAttachedShaders[gl::ShaderType::Fragment]->usesViewID();
@@ -613,7 +531,10 @@
 
     void popError(d3d::Context *context)
     {
-        context->handleResult(mStoredHR, mStoredMessage, mStoredFile, mStoredFunction, mStoredLine);
+        ASSERT(mStoredFile);
+        ASSERT(mStoredFunction);
+        context->handleResult(mStoredHR, mStoredMessage.c_str(), mStoredFile, mStoredFunction,
+                              mStoredLine);
     }
 
   protected:
@@ -622,10 +543,10 @@
     gl::InfoLog mInfoLog;
     ShaderExecutableD3D *mExecutable = nullptr;
     HRESULT mStoredHR                = S_OK;
-    const char *mStoredMessage       = nullptr;
-    const char *mStoredFile          = nullptr;
-    const char *mStoredFunction      = nullptr;
-    unsigned int mStoredLine         = 0;
+    std::string mStoredMessage;
+    const char *mStoredFile     = nullptr;
+    const char *mStoredFunction = nullptr;
+    unsigned int mStoredLine    = 0;
 };
 
 // ProgramD3D Implementation
@@ -756,6 +677,11 @@
     return usesPointSpriteEmulation() && !usesInstancedPointSpriteEmulation();
 }
 
+bool ProgramD3D::usesGetDimensionsIgnoresBaseLevel() const
+{
+    return mRenderer->getFeatures().getDimensionsIgnoresBaseLevel.enabled;
+}
+
 bool ProgramD3D::usesGeometryShader(const gl::State &state, const gl::PrimitiveMode drawMode) const
 {
     if (mHasANGLEMultiviewEnabled && !mRenderer->canSelectViewInVertexShader())
@@ -768,14 +694,14 @@
         {
             return false;
         }
-        return state.getProvokingVertex() == gl::ProvokingVertex::LastVertexConvention;
+        return state.getProvokingVertex() == gl::ProvokingVertexConvention::LastVertexConvention;
     }
     return usesGeometryShaderForPointSpriteEmulation();
 }
 
 bool ProgramD3D::usesInstancedPointSpriteEmulation() const
 {
-    return mRenderer->getWorkarounds().useInstancedPointSpriteEmulation;
+    return mRenderer->getFeatures().useInstancedPointSpriteEmulation.enabled;
 }
 
 GLint ProgramD3D::getSamplerMapping(gl::ShaderType type,
@@ -918,16 +844,9 @@
 class ProgramD3D::LoadBinaryTask : public ProgramD3D::GetExecutableTask
 {
   public:
-    LoadBinaryTask(const gl::Context *context,
-                   ProgramD3D *program,
-                   gl::BinaryInputStream *stream,
-                   gl::InfoLog &infoLog)
-        : ProgramD3D::GetExecutableTask(program),
-          mContext(context),
-          mProgram(program),
-          mInfoLog(infoLog)
+    LoadBinaryTask(ProgramD3D *program, gl::BinaryInputStream *stream, gl::InfoLog &infoLog)
+        : ProgramD3D::GetExecutableTask(program), mProgram(program), mInfoLog(infoLog)
     {
-        ASSERT(mContext);
         ASSERT(mProgram);
         ASSERT(stream);
 
@@ -946,15 +865,14 @@
         if (!mDataCopySucceeded)
         {
             mInfoLog << "Failed to copy program binary data to local buffer.";
-            return angle::Result::Stop;
+            return angle::Result::Incomplete;
         }
 
         gl::BinaryInputStream stream(mStreamData.data(), mStreamData.size());
-        return mProgram->loadBinaryShaderExecutables(mContext, &stream, mInfoLog);
+        return mProgram->loadBinaryShaderExecutables(this, &stream, mInfoLog);
     }
 
   private:
-    const gl::Context *mContext;
     ProgramD3D *mProgram;
     gl::InfoLog &mInfoLog;
 
@@ -966,12 +884,11 @@
 {
   public:
     LoadBinaryLinkEvent(std::shared_ptr<WorkerThreadPool> workerPool,
-                        const gl::Context *context,
                         ProgramD3D *program,
                         gl::BinaryInputStream *stream,
                         gl::InfoLog &infoLog)
-        : mTask(std::make_shared<ProgramD3D::LoadBinaryTask>(context, program, stream, infoLog)),
-          mWaitableEvent(workerPool->postWorkerTask(mTask))
+        : mTask(std::make_shared<ProgramD3D::LoadBinaryTask>(program, stream, infoLog)),
+          mWaitableEvent(angle::WorkerThreadPool::PostWorkerTask(workerPool, mTask))
     {}
 
     angle::Result wait(const gl::Context *context) override
@@ -1169,6 +1086,7 @@
 
     stream->readBool(&mUsesFragDepth);
     stream->readBool(&mHasANGLEMultiviewEnabled);
+    stream->readBool(&mUsesVertexID);
     stream->readBool(&mUsesViewID);
     stream->readBool(&mUsesPointSize);
     stream->readBool(&mUsesFlatInterpolation);
@@ -1187,11 +1105,11 @@
 
     stream->readString(&mGeometryShaderPreamble);
 
-    return std::make_unique<LoadBinaryLinkEvent>(context->getWorkerThreadPool(), context, this,
-                                                 stream, infoLog);
+    return std::make_unique<LoadBinaryLinkEvent>(context->getWorkerThreadPool(), this, stream,
+                                                 infoLog);
 }
 
-angle::Result ProgramD3D::loadBinaryShaderExecutables(const gl::Context *context,
+angle::Result ProgramD3D::loadBinaryShaderExecutables(d3d::Context *contextD3D,
                                                       gl::BinaryInputStream *stream,
                                                       gl::InfoLog &infoLog)
 {
@@ -1199,8 +1117,6 @@
 
     bool separateAttribs = (mState.getTransformFeedbackBufferMode() == GL_SEPARATE_ATTRIBS);
 
-    d3d::Context *contextD3D = GetImplAs<ContextD3D>(context);
-
     const unsigned int vertexShaderCount = stream->readInt<unsigned int>();
     for (unsigned int vertexShaderIndex = 0; vertexShaderIndex < vertexShaderCount;
          vertexShaderIndex++)
@@ -1451,6 +1367,7 @@
 
     stream->writeInt(mUsesFragDepth);
     stream->writeInt(mHasANGLEMultiviewEnabled);
+    stream->writeInt(mUsesVertexID);
     stream->writeInt(mUsesViewID);
     stream->writeInt(mUsesPointSize);
     stream->writeInt(mUsesFlatInterpolation);
@@ -1774,6 +1691,21 @@
     const gl::State &mState;
 };
 
+class ProgramD3D::GetComputeExecutableTask : public ProgramD3D::GetExecutableTask
+{
+  public:
+    GetComputeExecutableTask(ProgramD3D *program) : GetExecutableTask(program) {}
+    angle::Result run() override
+    {
+        mProgram->updateCachedImage2DBindLayoutFromComputeShader();
+        ShaderExecutableD3D *computeExecutable = nullptr;
+        ANGLE_TRY(mProgram->getComputeExecutableForImage2DBindLayout(this, &computeExecutable,
+                                                                     &mInfoLog));
+
+        return computeExecutable ? angle::Result::Continue : angle::Result::Incomplete;
+    }
+};
+
 // The LinkEvent implementation for linking a rendering(VS, FS, GS) program.
 class ProgramD3D::GraphicsProgramLinkEvent final : public LinkEvent
 {
@@ -1787,14 +1719,15 @@
                              const ShaderD3D *vertexShader,
                              const ShaderD3D *fragmentShader)
         : mInfoLog(infoLog),
-          mWorkerPool(workerPool),
           mVertexTask(vertexTask),
           mPixelTask(pixelTask),
           mGeometryTask(geometryTask),
-          mWaitEvents(
-              {{std::shared_ptr<WaitableEvent>(workerPool->postWorkerTask(mVertexTask)),
-                std::shared_ptr<WaitableEvent>(workerPool->postWorkerTask(mPixelTask)),
-                std::shared_ptr<WaitableEvent>(workerPool->postWorkerTask(mGeometryTask))}}),
+          mWaitEvents({{std::shared_ptr<WaitableEvent>(
+                            angle::WorkerThreadPool::PostWorkerTask(workerPool, mVertexTask)),
+                        std::shared_ptr<WaitableEvent>(
+                            angle::WorkerThreadPool::PostWorkerTask(workerPool, mPixelTask)),
+                        std::shared_ptr<WaitableEvent>(
+                            angle::WorkerThreadPool::PostWorkerTask(workerPool, mGeometryTask))}}),
           mUseGS(useGS),
           mVertexShader(vertexShader),
           mFragmentShader(fragmentShader)
@@ -1808,9 +1741,9 @@
         ANGLE_TRY(checkTask(context, mPixelTask.get()));
         ANGLE_TRY(checkTask(context, mGeometryTask.get()));
 
-        if (mVertexTask.get()->getResult() == angle::Result::Incomplete ||
-            mPixelTask.get()->getResult() == angle::Result::Incomplete ||
-            mGeometryTask.get()->getResult() == angle::Result::Incomplete)
+        if (mVertexTask->getResult() == angle::Result::Incomplete ||
+            mPixelTask->getResult() == angle::Result::Incomplete ||
+            mGeometryTask->getResult() == angle::Result::Incomplete)
         {
             return angle::Result::Incomplete;
         }
@@ -1879,7 +1812,6 @@
     }
 
     gl::InfoLog &mInfoLog;
-    std::shared_ptr<WorkerThreadPool> mWorkerPool;
     std::shared_ptr<ProgramD3D::GetVertexExecutableTask> mVertexTask;
     std::shared_ptr<ProgramD3D::GetPixelExecutableTask> mPixelTask;
     std::shared_ptr<ProgramD3D::GetGeometryExecutableTask> mGeometryTask;
@@ -1889,6 +1821,36 @@
     const ShaderD3D *mFragmentShader;
 };
 
+// The LinkEvent implementation for linking a computing program.
+class ProgramD3D::ComputeProgramLinkEvent final : public LinkEvent
+{
+  public:
+    ComputeProgramLinkEvent(gl::InfoLog &infoLog,
+                            std::shared_ptr<ProgramD3D::GetComputeExecutableTask> computeTask,
+                            std::shared_ptr<WaitableEvent> event)
+        : mInfoLog(infoLog), mComputeTask(computeTask), mWaitEvent(event)
+    {}
+
+    bool isLinking() override { return !mWaitEvent->isReady(); }
+
+    angle::Result wait(const gl::Context *context) override
+    {
+        mWaitEvent->wait();
+
+        angle::Result result = mComputeTask->getResult();
+        if (result != angle::Result::Continue)
+        {
+            mInfoLog << "Failed to create D3D compute shader.";
+        }
+        return result;
+    }
+
+  private:
+    gl::InfoLog &mInfoLog;
+    std::shared_ptr<ProgramD3D::GetComputeExecutableTask> mComputeTask;
+    std::shared_ptr<WaitableEvent> mWaitEvent;
+};
+
 std::unique_ptr<LinkEvent> ProgramD3D::compileProgramExecutables(const gl::Context *context,
                                                                  gl::InfoLog &infoLog)
 {
@@ -1913,6 +1875,36 @@
                                                       vertexShaderD3D, fragmentShaderD3D);
 }
 
+std::unique_ptr<LinkEvent> ProgramD3D::compileComputeExecutable(const gl::Context *context,
+                                                                gl::InfoLog &infoLog)
+{
+    // Ensure the compiler is initialized to avoid race conditions.
+    angle::Result result = mRenderer->ensureHLSLCompilerInitialized(GetImplAs<ContextD3D>(context));
+    if (result != angle::Result::Continue)
+    {
+        return std::make_unique<LinkEventDone>(result);
+    }
+    auto computeTask = std::make_shared<GetComputeExecutableTask>(this);
+
+    std::shared_ptr<WaitableEvent> waitableEvent;
+
+    // TODO(jie.a.chen@intel.com): Fix the flaky bug.
+    // http://anglebug.com/3349
+    bool compileInParallel = false;
+    if (!compileInParallel)
+    {
+        (*computeTask)();
+        waitableEvent = std::make_shared<WaitableEventDone>();
+    }
+    else
+    {
+        waitableEvent =
+            WorkerThreadPool::PostWorkerTask(context->getWorkerThreadPool(), computeTask);
+    }
+
+    return std::make_unique<ComputeProgramLinkEvent>(infoLog, computeTask, waitableEvent);
+}
+
 angle::Result ProgramD3D::getComputeExecutableForImage2DBindLayout(
     d3d::Context *context,
     ShaderExecutableD3D **outExecutable,
@@ -1955,19 +1947,6 @@
     return angle::Result::Continue;
 }
 
-angle::Result ProgramD3D::compileComputeExecutable(d3d::Context *context, gl::InfoLog &infoLog)
-{
-    // Ensure the compiler is initialized to avoid race conditions.
-    ANGLE_TRY(mRenderer->ensureHLSLCompilerInitialized(context));
-
-    updateCachedImage2DBindLayoutFromComputeShader();
-
-    ShaderExecutableD3D *computeExecutable = nullptr;
-    ANGLE_TRY(getComputeExecutableForImage2DBindLayout(context, &computeExecutable, &infoLog));
-
-    return computeExecutable ? angle::Result::Continue : angle::Result::Incomplete;
-}
-
 std::unique_ptr<LinkEvent> ProgramD3D::link(const gl::Context *context,
                                             const gl::ProgramLinkedResources &resources,
                                             gl::InfoLog &infoLog)
@@ -1998,12 +1977,7 @@
 
         defineUniformsAndAssignRegisters();
 
-        angle::Result result = compileComputeExecutable(GetImplAs<ContextD3D>(context), infoLog);
-        if (result != angle::Result::Continue)
-        {
-            infoLog << "Failed to create D3D compute shader.";
-        }
-        return std::make_unique<LinkEventDone>(result);
+        return compileComputeExecutable(context, infoLog);
     }
     else
     {
@@ -2041,6 +2015,7 @@
         mUsesPointSize = shadersD3D[gl::ShaderType::Vertex]->usesPointSize();
         mDynamicHLSL->getPixelShaderOutputKey(data, mState, metadata, &mPixelShaderKey);
         mUsesFragDepth            = metadata.usesFragDepth();
+        mUsesVertexID             = metadata.usesVertexID();
         mUsesViewID               = metadata.usesViewID();
         mHasANGLEMultiviewEnabled = metadata.hasANGLEMultiviewEnabled();
 
@@ -2623,16 +2598,13 @@
     unsigned int arrayElementOffset             = uniformLocation.arrayIndex;
     unsigned int elementCount                   = targetUniform->getArraySizeProduct();
 
-    // Internally store matrices as transposed versions to accomodate HLSL matrix indexing
-    transpose = !transpose;
-
     for (gl::ShaderType shaderType : gl::AllShaderTypes())
     {
         if (targetUniform->mShaderData[shaderType])
         {
-            if (SetFloatUniformMatrix<cols, rows>(arrayElementOffset, elementCount, countIn,
-                                                  transpose, value,
-                                                  targetUniform->mShaderData[shaderType]))
+            if (SetFloatUniformMatrixHLSL<cols, rows>::Run(arrayElementOffset, elementCount,
+                                                           countIn, transpose, value,
+                                                           targetUniform->mShaderData[shaderType]))
             {
                 mShaderUniformsDirty.set(shaderType);
             }
@@ -2884,11 +2856,11 @@
     for (gl::ShaderType shaderType : gl::AllShaderTypes())
     {
         mShaderHLSL[shaderType].clear();
-        mShaderWorkarounds[shaderType] = CompilerWorkaroundsD3D();
     }
 
     mUsesFragDepth            = false;
     mHasANGLEMultiviewEnabled = false;
+    mUsesVertexID             = false;
     mUsesViewID               = false;
     mPixelShaderKey.clear();
     mUsesPointSize         = false;
@@ -3222,80 +3194,13 @@
 
 void ProgramD3D::linkResources(const gl::ProgramLinkedResources &resources)
 {
-    InterfaceBlockInfo uniformBlockInfo;
-    for (gl::ShaderType shaderType : gl::AllShaderTypes())
-    {
-        gl::Shader *shader = mState.getAttachedShader(shaderType);
-        if (shader)
-        {
-            uniformBlockInfo.getShaderBlockInfo(shader->getUniformBlocks());
-        }
-    }
-
-    // Gather interface block info.
-    auto getUniformBlockSize = [&uniformBlockInfo](const std::string &name,
-                                                   const std::string &mappedName, size_t *sizeOut) {
-        return uniformBlockInfo.getBlockSize(name, mappedName, sizeOut);
-    };
-
-    auto getUniformBlockMemberInfo = [&uniformBlockInfo](const std::string &name,
-                                                         const std::string &mappedName,
-                                                         sh::BlockMemberInfo *infoOut) {
-        return uniformBlockInfo.getBlockMemberInfo(name, mappedName, infoOut);
-    };
-
-    resources.uniformBlockLinker.linkBlocks(getUniformBlockSize, getUniformBlockMemberInfo);
+    HLSLBlockLayoutEncoderFactory hlslEncoderFactory;
+    gl::ProgramLinkedResourcesLinker linker(&hlslEncoderFactory);
+
+    linker.linkResources(mState, resources);
+
     initializeUniformBlocks();
-
-    InterfaceBlockInfo shaderStorageBlockInfo;
-    for (gl::ShaderType shaderType : gl::AllShaderTypes())
-    {
-        gl::Shader *shader = mState.getAttachedShader(shaderType);
-        if (shader)
-        {
-            shaderStorageBlockInfo.getShaderBlockInfo(shader->getShaderStorageBlocks());
-        }
-    }
-    auto getShaderStorageBlockSize = [&shaderStorageBlockInfo](const std::string &name,
-                                                               const std::string &mappedName,
-                                                               size_t *sizeOut) {
-        return shaderStorageBlockInfo.getBlockSize(name, mappedName, sizeOut);
-    };
-
-    auto getShaderStorageBlockMemberInfo = [&shaderStorageBlockInfo](const std::string &name,
-                                                                     const std::string &mappedName,
-                                                                     sh::BlockMemberInfo *infoOut) {
-        return shaderStorageBlockInfo.getBlockMemberInfo(name, mappedName, infoOut);
-    };
-
-    resources.shaderStorageBlockLinker.linkBlocks(getShaderStorageBlockSize,
-                                                  getShaderStorageBlockMemberInfo);
     initializeShaderStorageBlocks();
-
-    std::map<int, unsigned int> sizeMap;
-    getAtomicCounterBufferSizeMap(sizeMap);
-    resources.atomicCounterBufferLinker.link(sizeMap);
-}
-
-void ProgramD3D::getAtomicCounterBufferSizeMap(std::map<int, unsigned int> &sizeMapOut) const
-{
-    for (unsigned int index : mState.getAtomicCounterUniformRange())
-    {
-        const gl::LinkedUniform &glUniform = mState.getUniforms()[index];
-
-        auto &bufferDataSize = sizeMapOut[glUniform.binding];
-
-        // Calculate the size of the buffer by finding the end of the last uniform with the same
-        // binding. The end of the uniform is calculated by finding the initial offset of the
-        // uniform and adding size of the uniform. For arrays, the size is the number of elements
-        // times the element size (should always by 4 for atomic_units).
-        unsigned dataOffset =
-            glUniform.offset + (glUniform.getBasicTypeElementCount() * glUniform.getElementSize());
-        if (dataOffset > bufferDataSize)
-        {
-            bufferDataSize = dataOffset;
-        }
-    }
 }
 
 }  // namespace rx