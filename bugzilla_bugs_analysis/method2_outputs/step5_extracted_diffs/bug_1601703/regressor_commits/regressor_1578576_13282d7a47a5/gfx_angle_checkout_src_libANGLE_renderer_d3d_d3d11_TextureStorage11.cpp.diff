# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp
--- a/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/TextureStorage11.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -228,7 +228,7 @@
         ASSERT(mipLevels == 1 || mipLevels == mMipLevels);
     }
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         // We must ensure that the level zero texture is in sync with mipped texture.
         ANGLE_TRY(useLevelZeroWorkaroundTexture(context, mipLevels == 1));
@@ -241,7 +241,8 @@
 
     // We drop the stencil when sampling from the SRV if three conditions hold:
     // 1. the drop stencil workaround is enabled.
-    const bool workaround = mRenderer->getWorkarounds().emulateTinyStencilTextures;
+    const bool emulateTinyStencilTextures =
+        mRenderer->getFeatures().emulateTinyStencilTextures.enabled;
     // 2. this is a stencil texture.
     const bool hasStencil = (mFormatInfo.format().stencilBits > 0);
     // 3. the texture has a 1x1 or 2x2 mip.
@@ -249,7 +250,7 @@
     const bool hasSmallMips =
         (getLevelWidth(effectiveTopLevel) <= 2 || getLevelHeight(effectiveTopLevel) <= 2);
 
-    const bool useDropStencil = (workaround && hasStencil && hasSmallMips);
+    const bool useDropStencil = (emulateTinyStencilTextures && hasStencil && hasSmallMips);
     const SamplerKey key(effectiveBaseLevel, mipLevels, swizzleRequired, useDropStencil);
     if (useDropStencil)
     {
@@ -364,7 +365,7 @@
         ASSERT(mipLevels == 1 || mipLevels == mMipLevels);
     }
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         // We must ensure that the level zero texture is in sync with mipped texture.
         ANGLE_TRY(useLevelZeroWorkaroundTexture(context, mipLevels == 1));
@@ -525,7 +526,7 @@
 
     // If the zero-LOD workaround is active and we want to update a level greater than zero, then we
     // should update the mipmapped texture, even if mapmaps are currently disabled.
-    if (level > 0 && mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (level > 0 && mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ANGLE_TRY(getMippedResource(context, &dstTexture));
     }
@@ -579,7 +580,7 @@
 
     // If the zero-LOD workaround is active and we want to update a level greater than zero, then we
     // should update the mipmapped texture, even if mapmaps are currently disabled.
-    if (index.getLevelIndex() > 0 && mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (index.getLevelIndex() > 0 && mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ANGLE_TRY(getMippedResource(context, &srcTexture));
     }
@@ -702,6 +703,11 @@
     return angle::Result::Continue;
 }
 
+void TextureStorage11::invalidateTextures()
+{
+    mRenderer->getStateManager()->invalidateTexturesAndSamplers();
+}
+
 angle::Result TextureStorage11::setData(const gl::Context *context,
                                         const gl::ImageIndex &index,
                                         ImageD3D *image,
@@ -903,7 +909,7 @@
     mTextureDepth  = 1;
 
     // The LevelZeroOnly hint should only be true if the zero max LOD workaround is active.
-    ASSERT(!mUseLevelZeroTexture || mRenderer->getWorkarounds().zeroMaxLodWorkaround);
+    ASSERT(!mUseLevelZeroTexture || mRenderer->getFeatures().zeroMaxLodWorkaround.enabled);
 }
 
 angle::Result TextureStorage11_2D::onDestroy(const gl::Context *context)
@@ -940,7 +946,7 @@
     TextureStorage11_2D *dest11           = GetAs<TextureStorage11_2D>(destStorage);
     ID3D11DeviceContext *immediateContext = mRenderer->getDeviceContext();
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         // If either mTexture or mLevelZeroTexture exist, then we need to copy them into the
         // corresponding textures in destStorage.
@@ -1096,7 +1102,7 @@
                                                      const TextureHelper11 **outResource)
 {
     // This shouldn't be called unless the zero max LOD workaround is active.
-    ASSERT(mRenderer->getWorkarounds().zeroMaxLodWorkaround);
+    ASSERT(mRenderer->getFeatures().zeroMaxLodWorkaround.enabled);
 
     ANGLE_TRY(ensureTextureExists(context, mMipLevels));
 
@@ -1107,7 +1113,7 @@
 angle::Result TextureStorage11_2D::ensureTextureExists(const gl::Context *context, int mipLevels)
 {
     // If mMipLevels = 1 then always use mTexture rather than mLevelZeroTexture.
-    bool useLevelZeroTexture = mRenderer->getWorkarounds().zeroMaxLodWorkaround
+    bool useLevelZeroTexture = mRenderer->getFeatures().zeroMaxLodWorkaround.enabled
                                    ? (mipLevels == 1) && (mMipLevels > 1)
                                    : false;
     TextureHelper11 *outputTexture = useLevelZeroTexture ? &mLevelZeroTexture : &mTexture;
@@ -1172,7 +1178,7 @@
         return angle::Result::Continue;
     }
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ASSERT(level == 0);
         ANGLE_TRY(useLevelZeroWorkaroundTexture(context, true));
@@ -1269,7 +1275,7 @@
 
     const TextureHelper11 *srvTexture = &texture;
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ASSERT(mTopLevel == 0);
         ASSERT(baseLevel == 0);
@@ -1894,7 +1900,7 @@
     mTextureDepth  = 1;
 
     // The LevelZeroOnly hint should only be true if the zero max LOD workaround is active.
-    ASSERT(!mUseLevelZeroTexture || mRenderer->getWorkarounds().zeroMaxLodWorkaround);
+    ASSERT(!mUseLevelZeroTexture || mRenderer->getFeatures().zeroMaxLodWorkaround.enabled);
 }
 
 angle::Result TextureStorage11_Cube::onDestroy(const gl::Context *context)
@@ -1924,7 +1930,7 @@
                                                          UINT *outSubresourceIndex) const
 {
     UINT arraySlice = index.cubeMapFaceIndex();
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround && mUseLevelZeroTexture &&
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled && mUseLevelZeroTexture &&
         index.getLevelIndex() == 0)
     {
         UINT subresource = D3D11CalcSubresource(0, arraySlice, 1);
@@ -1948,7 +1954,7 @@
 
     TextureStorage11_Cube *dest11 = GetAs<TextureStorage11_Cube>(destStorage);
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ID3D11DeviceContext *immediateContext = mRenderer->getDeviceContext();
 
@@ -2134,7 +2140,7 @@
                                                        const TextureHelper11 **outResource)
 {
     // This shouldn't be called unless the zero max LOD workaround is active.
-    ASSERT(mRenderer->getWorkarounds().zeroMaxLodWorkaround);
+    ASSERT(mRenderer->getFeatures().zeroMaxLodWorkaround.enabled);
 
     ANGLE_TRY(ensureTextureExists(context, mMipLevels));
     *outResource = &mTexture;
@@ -2144,7 +2150,7 @@
 angle::Result TextureStorage11_Cube::ensureTextureExists(const gl::Context *context, int mipLevels)
 {
     // If mMipLevels = 1 then always use mTexture rather than mLevelZeroTexture.
-    bool useLevelZeroTexture = mRenderer->getWorkarounds().zeroMaxLodWorkaround
+    bool useLevelZeroTexture = mRenderer->getFeatures().zeroMaxLodWorkaround.enabled
                                    ? (mipLevels == 1) && (mMipLevels > 1)
                                    : false;
     TextureHelper11 *outputTexture = useLevelZeroTexture ? &mLevelZeroTexture : &mTexture;
@@ -2218,7 +2224,7 @@
 
     if (!mRenderTarget[faceIndex][level])
     {
-        if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+        if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
         {
             ASSERT(index.getLevelIndex() == 0);
             ANGLE_TRY(useLevelZeroWorkaroundTexture(context, true));
@@ -2346,7 +2352,7 @@
 
     const TextureHelper11 *srvTexture = &texture;
 
-    if (mRenderer->getWorkarounds().zeroMaxLodWorkaround)
+    if (mRenderer->getFeatures().zeroMaxLodWorkaround.enabled)
     {
         ASSERT(mTopLevel == 0);
         ASSERT(baseLevel == 0);