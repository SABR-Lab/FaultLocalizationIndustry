# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp
--- a/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d9/Renderer9.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -51,7 +51,7 @@
 #include "libANGLE/renderer/d3d/d3d9/VertexBuffer9.h"
 #include "libANGLE/renderer/d3d/d3d9/formatutils9.h"
 #include "libANGLE/renderer/d3d/d3d9/renderer9_utils.h"
-#include "third_party/trace_event/trace_event.h"
+#include "libANGLE/trace.h"
 
 #if !defined(ANGLE_COMPILE_OPTIMIZATION_LEVEL)
 #    define ANGLE_COMPILE_OPTIMIZATION_LEVEL D3DCOMPILE_OPTIMIZATION_LEVEL3
@@ -193,8 +193,8 @@
 
 egl::Error Renderer9::initialize()
 {
-    TRACE_EVENT0("gpu.angle", "GetModuleHandle_d3d9");
-    mD3d9Module = GetModuleHandle(TEXT("d3d9.dll"));
+    ANGLE_TRACE_EVENT0("gpu.angle", "GetModuleHandle_d3d9");
+    mD3d9Module = ::LoadLibrary(TEXT("d3d9.dll"));
 
     if (mD3d9Module == nullptr)
     {
@@ -212,14 +212,14 @@
     if (ANGLE_D3D9EX == ANGLE_ENABLED && Direct3DCreate9ExPtr &&
         SUCCEEDED(Direct3DCreate9ExPtr(D3D_SDK_VERSION, &mD3d9Ex)))
     {
-        TRACE_EVENT0("gpu.angle", "D3d9Ex_QueryInterface");
+        ANGLE_TRACE_EVENT0("gpu.angle", "D3d9Ex_QueryInterface");
         ASSERT(mD3d9Ex);
         mD3d9Ex->QueryInterface(__uuidof(IDirect3D9), reinterpret_cast<void **>(&mD3d9));
         ASSERT(mD3d9);
     }
     else
     {
-        TRACE_EVENT0("gpu.angle", "Direct3DCreate9");
+        ANGLE_TRACE_EVENT0("gpu.angle", "Direct3DCreate9");
         mD3d9 = Direct3DCreate9(D3D_SDK_VERSION);
     }
 
@@ -238,7 +238,7 @@
 
     // Give up on getting device caps after about one second.
     {
-        TRACE_EVENT0("gpu.angle", "GetDeviceCaps");
+        ANGLE_TRACE_EVENT0("gpu.angle", "GetDeviceCaps");
         for (int i = 0; i < 10; ++i)
         {
             result = mD3d9->GetDeviceCaps(mAdapter, mDeviceType, &mDeviceCaps);
@@ -282,7 +282,7 @@
     }
 
     {
-        TRACE_EVENT0("gpu.angle", "GetAdapterIdentifier");
+        ANGLE_TRACE_EVENT0("gpu.angle", "GetAdapterIdentifier");
         mD3d9->GetAdapterIdentifier(mAdapter, 0, &mAdapterIdentifier);
     }
 
@@ -290,7 +290,7 @@
     static const TCHAR className[]  = TEXT("STATIC");
 
     {
-        TRACE_EVENT0("gpu.angle", "CreateWindowEx");
+        ANGLE_TRACE_EVENT0("gpu.angle", "CreateWindowEx");
         mDeviceWindow =
             CreateWindowEx(WS_EX_NOACTIVATE, className, windowName, WS_DISABLED | WS_POPUP, 0, 0, 1,
                            1, HWND_MESSAGE, nullptr, GetModuleHandle(nullptr), nullptr);
@@ -301,7 +301,7 @@
         D3DCREATE_FPU_PRESERVE | D3DCREATE_NOWINDOWCHANGES | D3DCREATE_MULTITHREADED;
 
     {
-        TRACE_EVENT0("gpu.angle", "D3d9_CreateDevice");
+        ANGLE_TRACE_EVENT0("gpu.angle", "D3d9_CreateDevice");
         result = mD3d9->CreateDevice(
             mAdapter, mDeviceType, mDeviceWindow,
             behaviorFlags | D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE,
@@ -315,7 +315,7 @@
 
     if (FAILED(result))
     {
-        TRACE_EVENT0("gpu.angle", "D3d9_CreateDevice2");
+        ANGLE_TRACE_EVENT0("gpu.angle", "D3d9_CreateDevice2");
         result = mD3d9->CreateDevice(mAdapter, mDeviceType, mDeviceWindow,
                                      behaviorFlags | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                      &presentParameters, &mDevice);
@@ -331,13 +331,13 @@
 
     if (mD3d9Ex)
     {
-        TRACE_EVENT0("gpu.angle", "mDevice_QueryInterface");
+        ANGLE_TRACE_EVENT0("gpu.angle", "mDevice_QueryInterface");
         result = mDevice->QueryInterface(__uuidof(IDirect3DDevice9Ex), (void **)&mDeviceEx);
         ASSERT(SUCCEEDED(result));
     }
 
     {
-        TRACE_EVENT0("gpu.angle", "ShaderCache initialize");
+        ANGLE_TRACE_EVENT0("gpu.angle", "ShaderCache initialize");
         mVertexShaderCache.initialize(mDevice);
         mPixelShaderCache.initialize(mDevice);
     }
@@ -713,10 +713,11 @@
                           backBufferFormat, depthBufferFormat, orientation);
 }
 
-egl::Error Renderer9::getD3DTextureInfo(const egl::Config *config,
+egl::Error Renderer9::getD3DTextureInfo(const egl::Config *configuration,
                                         IUnknown *d3dTexture,
                                         EGLint *width,
                                         EGLint *height,
+                                        EGLint *samples,
                                         const angle::Format **angleFormat) const
 {
     IDirect3DTexture9 *texture = nullptr;
@@ -747,6 +748,17 @@
         *height = static_cast<EGLint>(desc.Height);
     }
 
+    // GetSamplesCount() returns 0 when multisampling isn't used.
+    GLsizei sampleCount = d3d9_gl::GetSamplesCount(desc.MultiSampleType);
+    if ((configuration && configuration->samples > 1) || sampleCount != 0)
+    {
+        return egl::EglBadParameter() << "Multisampling not supported for client buffer texture";
+    }
+    if (samples)
+    {
+        *samples = static_cast<EGLint>(sampleCount);
+    }
+
     // From table egl.restrictions in EGL_ANGLE_d3d_texture_client_buffer.
     switch (desc.Format)
     {
@@ -850,20 +862,20 @@
     }
 }
 
-angle::Result Renderer9::createVertexShader(Context9 *context9,
+angle::Result Renderer9::createVertexShader(d3d::Context *context,
                                             const DWORD *function,
                                             size_t length,
                                             IDirect3DVertexShader9 **outShader)
 {
-    return mVertexShaderCache.create(context9, function, length, outShader);
+    return mVertexShaderCache.create(context, function, length, outShader);
 }
 
-angle::Result Renderer9::createPixelShader(Context9 *context9,
+angle::Result Renderer9::createPixelShader(d3d::Context *context,
                                            const DWORD *function,
                                            size_t length,
                                            IDirect3DPixelShader9 **outShader)
 {
-    return mPixelShaderCache.create(context9, function, length, outShader);
+    return mPixelShaderCache.create(context, function, length, outShader);
 }
 
 HRESULT Renderer9::createVertexBuffer(UINT Length,
@@ -1066,7 +1078,7 @@
     // the sample counts that we set in render target view, here we use renderTarget->getSamples to
     // get the actual samples.
     GLsizei samples                                       = 0;
-    const gl::FramebufferAttachment *firstColorAttachment = framebuffer->getFirstColorbuffer();
+    const gl::FramebufferAttachment *firstColorAttachment = framebuffer->getFirstColorAttachment();
     if (firstColorAttachment)
     {
         ASSERT(firstColorAttachment->isAttached());
@@ -1099,8 +1111,9 @@
     // Since framebuffer->getSamples will return the original samples which may be different with
     // the sample counts that we set in render target view, here we use renderTarget->getSamples to
     // get the actual samples.
-    GLsizei samples                                       = 0;
-    const gl::FramebufferAttachment *firstColorAttachment = drawFramebuffer->getFirstColorbuffer();
+    GLsizei samples = 0;
+    const gl::FramebufferAttachment *firstColorAttachment =
+        drawFramebuffer->getFirstColorAttachment();
     if (firstColorAttachment)
     {
         ASSERT(firstColorAttachment->isAttached());
@@ -2586,21 +2599,19 @@
     // Transform feedback is not supported in ES2 or D3D9
     ASSERT(streamOutVaryings.empty());
 
-    Context9 *context9 = static_cast<Context9 *>(context);
-
     switch (type)
     {
         case gl::ShaderType::Vertex:
         {
             IDirect3DVertexShader9 *vshader = nullptr;
-            ANGLE_TRY(createVertexShader(context9, (DWORD *)function, length, &vshader));
+            ANGLE_TRY(createVertexShader(context, (DWORD *)function, length, &vshader));
             *outExecutable = new ShaderExecutable9(function, length, vshader);
         }
         break;
         case gl::ShaderType::Fragment:
         {
             IDirect3DPixelShader9 *pshader = nullptr;
-            ANGLE_TRY(createPixelShader(context9, (DWORD *)function, length, &pshader));
+            ANGLE_TRY(createPixelShader(context, (DWORD *)function, length, &pshader));
             *outExecutable = new ShaderExecutable9(function, length, pshader);
         }
         break;
@@ -2782,6 +2793,15 @@
     return new Image9(this);
 }
 
+ExternalImageSiblingImpl *Renderer9::createExternalImageSibling(const gl::Context *context,
+                                                                EGLenum target,
+                                                                EGLClientBuffer buffer,
+                                                                const egl::AttributeMap &attribs)
+{
+    UNREACHABLE();
+    return nullptr;
+}
+
 angle::Result Renderer9::generateMipmap(const gl::Context *context, ImageD3D *dest, ImageD3D *src)
 {
     Image9 *src9 = GetAs<Image9>(src);
@@ -2976,9 +2996,10 @@
                           outExtensions, outLimitations);
 }
 
-angle::WorkaroundsD3D Renderer9::generateWorkarounds() const
+void Renderer9::initializeFeatures(angle::FeaturesD3D *features) const
 {
-    return d3d9::GenerateWorkarounds();
+    d3d9::InitializeFeatures(features);
+    OverrideFeaturesWithDisplayState(features, mDisplay->getState());
 }
 
 DeviceImpl *Renderer9::createEGLDevice()
@@ -3063,6 +3084,11 @@
     return gl::Version(2, 0);
 }
 
+gl::Version Renderer9::getMaxConformantESVersion() const
+{
+    return gl::Version(2, 0);
+}
+
 angle::Result Renderer9::clearRenderTarget(const gl::Context *context,
                                            RenderTargetD3D *renderTarget,
                                            const gl::ColorF &clearColorValue,