# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/renderer_utils.h
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/renderer/renderer_utils.h
--- a/gfx/angle/checkout/src/libANGLE/renderer/renderer_utils.h	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/renderer_utils.h	Sat Sep 07 13:38:36 2019 +0000
@@ -12,14 +12,17 @@
 
 #include <cstdint>
 
+#include <atomic>
 #include <limits>
 #include <map>
 
 #include "common/angleutils.h"
+#include "common/utilities.h"
 #include "libANGLE/angletypes.h"
 
 namespace angle
 {
+struct FeatureSetBase;
 struct Format;
 enum class FormatID;
 }  // namespace angle
@@ -28,11 +31,13 @@
 {
 struct FormatType;
 struct InternalFormat;
+class State;
 }  // namespace gl
 
 namespace egl
 {
 class AttributeMap;
+struct DisplayState;
 }  // namespace egl
 
 namespace rx
@@ -60,8 +65,6 @@
     uintptr_t mValue;
 };
 
-class SerialFactory;
-
 class Serial final
 {
   public:
@@ -92,27 +95,32 @@
     constexpr uint64_t getValue() const { return mValue; }
 
   private:
-    friend class SerialFactory;
+    template <typename T>
+    friend class SerialFactoryBase;
     constexpr explicit Serial(uint64_t value) : mValue(value) {}
     uint64_t mValue;
     static constexpr uint64_t kInvalid = 0;
 };
 
-class SerialFactory final : angle::NonCopyable
+template <typename SerialBaseType>
+class SerialFactoryBase final : angle::NonCopyable
 {
   public:
-    SerialFactory() : mSerial(1) {}
+    SerialFactoryBase() : mSerial(1) {}
 
     Serial generate()
     {
-        ASSERT(mSerial != std::numeric_limits<uint64_t>::max());
+        ASSERT(mSerial + 1 > mSerial);
         return Serial(mSerial++);
     }
 
   private:
-    uint64_t mSerial;
+    SerialBaseType mSerial;
 };
 
+using SerialFactory       = SerialFactoryBase<uint64_t>;
+using AtomicSerialFactory = SerialFactoryBase<std::atomic<uint64_t>>;
+
 using MipGenerationFunction = void (*)(size_t sourceWidth,
                                        size_t sourceHeight,
                                        size_t sourceDepth,
@@ -256,14 +264,29 @@
     gl::TextureMap mIncompleteTextures;
 };
 
+// Helpers to set a matrix uniform value based on GLSL or HLSL semantics.
 // The return value indicate if the data was updated or not.
 template <int cols, int rows>
-bool SetFloatUniformMatrix(unsigned int arrayElementOffset,
-                           unsigned int elementCount,
-                           GLsizei countIn,
-                           GLboolean transpose,
-                           const GLfloat *value,
-                           uint8_t *targetData);
+struct SetFloatUniformMatrixGLSL
+{
+    static bool Run(unsigned int arrayElementOffset,
+                    unsigned int elementCount,
+                    GLsizei countIn,
+                    GLboolean transpose,
+                    const GLfloat *value,
+                    uint8_t *targetData);
+};
+
+template <int cols, int rows>
+struct SetFloatUniformMatrixHLSL
+{
+    static bool Run(unsigned int arrayElementOffset,
+                    unsigned int elementCount,
+                    GLsizei countIn,
+                    GLboolean transpose,
+                    const GLfloat *value,
+                    uint8_t *targetData);
+};
 
 // Helper method to de-tranpose a matrix uniform for an API query.
 void GetMatrixUniform(GLenum type, GLfloat *dataOut, const GLfloat *source, bool transpose);
@@ -286,6 +309,98 @@
                                  GLint baseVertex,
                                  GLint *startVertexOut,
                                  size_t *vertexCountOut);
+
+gl::Rectangle ClipRectToScissor(const gl::State &glState, const gl::Rectangle &rect, bool invertY);
+
+// Helper method to intialize a FeatureSet with overrides from the DisplayState
+void OverrideFeaturesWithDisplayState(angle::FeatureSetBase *features,
+                                      const egl::DisplayState &state);
+
+template <typename In>
+size_t LineLoopRestartIndexCountHelper(GLsizei indexCount, const uint8_t *srcPtr)
+{
+    constexpr In restartIndex = gl::GetPrimitiveRestartIndexFromType<In>();
+    const In *inIndices       = reinterpret_cast<const In *>(srcPtr);
+    size_t numIndices         = 0;
+    // See CopyLineLoopIndicesWithRestart() below for more info on how
+    // numIndices is calculated.
+    GLsizei loopStartIndex = 0;
+    for (GLsizei curIndex = 0; curIndex < indexCount; curIndex++)
+    {
+        In vertex = inIndices[curIndex];
+        if (vertex != restartIndex)
+        {
+            numIndices++;
+        }
+        else
+        {
+            if (curIndex > loopStartIndex)
+            {
+                numIndices += 2;
+            }
+            loopStartIndex = curIndex + 1;
+        }
+    }
+    if (indexCount > loopStartIndex)
+    {
+        numIndices++;
+    }
+    return numIndices;
+}
+
+inline size_t GetLineLoopWithRestartIndexCount(gl::DrawElementsType glIndexType,
+                                               GLsizei indexCount,
+                                               const uint8_t *srcPtr)
+{
+    switch (glIndexType)
+    {
+        case gl::DrawElementsType::UnsignedByte:
+            return LineLoopRestartIndexCountHelper<uint8_t>(indexCount, srcPtr);
+        case gl::DrawElementsType::UnsignedShort:
+            return LineLoopRestartIndexCountHelper<uint16_t>(indexCount, srcPtr);
+        case gl::DrawElementsType::UnsignedInt:
+            return LineLoopRestartIndexCountHelper<uint32_t>(indexCount, srcPtr);
+        default:
+            UNREACHABLE();
+            return 0;
+    }
+}
+
+// Writes the line-strip vertices for a line loop to outPtr,
+// where outLimit is calculated as in GetPrimitiveRestartIndexCount.
+template <typename In, typename Out>
+void CopyLineLoopIndicesWithRestart(GLsizei indexCount, const uint8_t *srcPtr, uint8_t *outPtr)
+{
+    constexpr In restartIndex     = gl::GetPrimitiveRestartIndexFromType<In>();
+    constexpr Out outRestartIndex = gl::GetPrimitiveRestartIndexFromType<Out>();
+    const In *inIndices           = reinterpret_cast<const In *>(srcPtr);
+    Out *outIndices               = reinterpret_cast<Out *>(outPtr);
+    GLsizei loopStartIndex        = 0;
+    for (GLsizei curIndex = 0; curIndex < indexCount; curIndex++)
+    {
+        In vertex = inIndices[curIndex];
+        if (vertex != restartIndex)
+        {
+            *(outIndices++) = static_cast<Out>(vertex);
+        }
+        else
+        {
+            if (curIndex > loopStartIndex)
+            {
+                // Emit an extra vertex only if the loop is not empty.
+                *(outIndices++) = inIndices[loopStartIndex];
+                // Then restart the strip.
+                *(outIndices++) = outRestartIndex;
+            }
+            loopStartIndex = curIndex + 1;
+        }
+    }
+    if (indexCount > loopStartIndex)
+    {
+        // Close the last loop if not empty.
+        *(outIndices++) = inIndices[loopStartIndex];
+    }
+}
 }  // namespace rx
 
 #endif  // LIBANGLE_RENDERER_RENDERER_UTILS_H_