# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/validationES3.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libANGLE/validationES3.cpp
--- a/gfx/angle/checkout/src/libANGLE/validationES3.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/validationES3.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -36,7 +36,7 @@
                                                   GLint level,
                                                   GLsizei numViews)
 {
-    if (!context->getExtensions().multiview2)
+    if (!(context->getExtensions().multiview || context->getExtensions().multiview2))
     {
         context->validationError(GL_INVALID_OPERATION, kMultiviewNotAvailable);
         return false;
@@ -369,6 +369,7 @@
     switch (texType)
     {
         case TextureType::_2D:
+        case TextureType::External:
             if (static_cast<GLuint>(width) > (caps.max2DTextureSize >> level) ||
                 static_cast<GLuint>(height) > (caps.max2DTextureSize >> level))
             {
@@ -431,7 +432,7 @@
             return false;
     }
 
-    gl::Texture *texture = context->getTargetTexture(texType);
+    gl::Texture *texture = context->getTextureByType(texType);
     if (!texture)
     {
         context->validationError(GL_INVALID_OPERATION, kMissingTexture);
@@ -467,8 +468,9 @@
         if (isSubImage)
         {
             if (!ValidCompressedSubImageSize(
-                    context, actualFormatInfo.internalFormat, xoffset, yoffset, width, height,
-                    texture->getWidth(target, level), texture->getHeight(target, level)))
+                    context, actualFormatInfo.internalFormat, xoffset, yoffset, zoffset, width,
+                    height, depth, texture->getWidth(target, level),
+                    texture->getHeight(target, level), texture->getDepth(target, level)))
             {
                 context->validationError(GL_INVALID_OPERATION, kInvalidCompressedImageSize);
                 return false;
@@ -488,7 +490,8 @@
         }
         else
         {
-            if (!ValidCompressedImageSize(context, actualInternalFormat, level, width, height))
+            if (!ValidCompressedImageSize(context, actualInternalFormat, level, width, height,
+                                          depth))
             {
                 context->validationError(GL_INVALID_OPERATION, kInvalidCompressedImageSize);
                 return false;
@@ -506,6 +509,13 @@
             context->validationError(GL_INVALID_OPERATION, kInvalidTextureTarget);
             return false;
         }
+
+        // Disallow 3D-only compressed formats from being set on 2D textures
+        if (actualFormatInfo.compressedBlockDepth > 1 && texType != TextureType::_2DArray)
+        {
+            context->validationError(GL_INVALID_OPERATION, kInvalidTextureTarget);
+            return false;
+        }
     }
     else
     {
@@ -622,7 +632,7 @@
 }
 
 bool ValidateES3TexImage3DParameters(Context *context,
-                                     TextureType target,
+                                     TextureTarget target,
                                      GLint level,
                                      GLenum internalformat,
                                      bool isCompressed,
@@ -645,17 +655,16 @@
         return false;
     }
 
-    if (IsETC2EACFormat(format) && target != TextureType::_2DArray)
+    if (IsETC2EACFormat(format) && target != TextureTarget::_2DArray)
     {
         // ES 3.1, Section 8.7, page 169.
         context->validationError(GL_INVALID_OPERATION, kInternalFormatRequiresTexture2DArray);
         return false;
     }
 
-    return ValidateES3TexImageParametersBase(context, NonCubeTextureTypeToTarget(target), level,
-                                             internalformat, isCompressed, isSubImage, xoffset,
-                                             yoffset, zoffset, width, height, depth, border, format,
-                                             type, bufSize, pixels);
+    return ValidateES3TexImageParametersBase(context, target, level, internalformat, isCompressed,
+                                             isSubImage, xoffset, yoffset, zoffset, width, height,
+                                             depth, border, format, type, bufSize, pixels);
 }
 
 struct EffectiveInternalFormatInfo
@@ -801,11 +810,26 @@
     }
 
     if ((textureFormatInfo.componentType == GL_UNSIGNED_NORMALIZED ||
-         textureFormatInfo.componentType == GL_SIGNED_NORMALIZED ||
-         textureFormatInfo.componentType == GL_FLOAT) &&
+         textureFormatInfo.componentType == GL_SIGNED_NORMALIZED) &&
         !(framebufferFormatInfo.componentType == GL_UNSIGNED_NORMALIZED ||
-          framebufferFormatInfo.componentType == GL_SIGNED_NORMALIZED ||
-          framebufferFormatInfo.componentType == GL_FLOAT))
+          framebufferFormatInfo.componentType == GL_SIGNED_NORMALIZED))
+    {
+        return false;
+    }
+
+    // SNORM is not supported (e.g. is not in the tables of "effective internal format" that
+    // correspond to internal formats.
+    if (textureFormatInfo.componentType == GL_SIGNED_NORMALIZED)
+    {
+        return false;
+    }
+
+    // Section 3.8.5 of the GLES 3.0.3 (and section 8.6 of the GLES 3.2) spec has a caveat, that
+    // the KHR dEQP tests enforce:
+    //
+    // Note that the above rules disallow matches where some components sizes are smaller and
+    // others are larger (such as RGB10_A2).
+    if (!textureFormatInfo.sized && (framebufferFormatInfo.internalFormat == GL_RGB10_A2))
     {
         return false;
     }
@@ -937,7 +961,7 @@
         return false;
     }
 
-    const FramebufferAttachment *source = framebuffer->getReadColorbuffer();
+    const FramebufferAttachment *source = framebuffer->getReadColorAttachment();
 
     // According to ES 3.x spec, if the internalformat of the texture
     // is RGB9_E5 and copy to such a texture, generate INVALID_OPERATION.
@@ -998,7 +1022,7 @@
 }
 
 bool ValidateES3CopyTexImage3DParameters(Context *context,
-                                         TextureType target,
+                                         TextureTarget target,
                                          GLint level,
                                          GLenum internalformat,
                                          bool isSubImage,
@@ -1017,9 +1041,9 @@
         return false;
     }
 
-    return ValidateES3CopyTexImageParametersBase(context, NonCubeTextureTypeToTarget(target), level,
-                                                 internalformat, isSubImage, xoffset, yoffset,
-                                                 zoffset, x, y, width, height, border);
+    return ValidateES3CopyTexImageParametersBase(context, target, level, internalformat, isSubImage,
+                                                 xoffset, yoffset, zoffset, x, y, width, height,
+                                                 border);
 }
 
 bool ValidateES3TexStorageParametersBase(Context *context,
@@ -1125,7 +1149,7 @@
             return false;
     }
 
-    gl::Texture *texture = context->getTargetTexture(target);
+    gl::Texture *texture = context->getTextureByType(target);
     if (!texture || texture->id() == 0)
     {
         context->validationError(GL_INVALID_OPERATION, kMissingTexture);
@@ -1157,6 +1181,12 @@
         return false;
     }
 
+    if (formatInfo.compressed && target == TextureType::_3D)
+    {
+        context->validationError(GL_INVALID_OPERATION, kInvalidTextureTarget);
+        return false;
+    }
+
     return true;
 }
 
@@ -1508,7 +1538,7 @@
 }
 
 bool ValidateCompressedTexImage3D(Context *context,
-                                  TextureType target,
+                                  TextureTarget target,
                                   GLint level,
                                   GLenum internalformat,
                                   GLsizei width,
@@ -1518,20 +1548,21 @@
                                   GLsizei imageSize,
                                   const void *data)
 {
-    if (context->getClientMajorVersion() < 3)
+    if ((context->getClientMajorVersion() < 3) && !context->getExtensions().texture3DOES)
     {
         context->validationError(GL_INVALID_OPERATION, kES3Required);
         return false;
     }
 
-    if (!ValidTextureTarget(context, target))
+    if (!ValidTextureTarget(context, TextureTargetToType(target)))
     {
         context->validationError(GL_INVALID_ENUM, kInvalidTextureTarget);
         return false;
     }
 
     // Validate image size
-    if (!ValidImageSizeParameters(context, target, level, width, height, depth, false))
+    if (!ValidImageSizeParameters(context, TextureTargetToType(target), level, width, height, depth,
+                                  false))
     {
         // Error already generated.
         return false;
@@ -1558,7 +1589,7 @@
     }
 
     // 3D texture target validation
-    if (target != TextureType::_3D && target != TextureType::_2DArray)
+    if (target != TextureTarget::_3D && target != TextureTarget::_2DArray)
     {
         context->validationError(GL_INVALID_ENUM, kInvalidTextureTarget);
         return false;
@@ -1576,7 +1607,7 @@
 }
 
 bool ValidateCompressedTexImage3DRobustANGLE(Context *context,
-                                             TextureType target,
+                                             TextureTarget target,
                                              GLint level,
                                              GLenum internalformat,
                                              GLsizei width,
@@ -1661,9 +1692,7 @@
                 return false;
             }
 
-            TransformFeedback *curTransformFeedback =
-                context->getState().getCurrentTransformFeedback();
-            if (curTransformFeedback && curTransformFeedback->isActive())
+            if (context->getState().isTransformFeedbackActive())
             {
                 context->validationError(GL_INVALID_OPERATION, kTransformFeedbackTargetActive);
                 return false;
@@ -1995,7 +2024,7 @@
 }
 
 bool ValidateCopyTexSubImage3D(Context *context,
-                               TextureType target,
+                               TextureTarget target,
                                GLint level,
                                GLint xoffset,
                                GLint yoffset,
@@ -2005,7 +2034,7 @@
                                GLsizei width,
                                GLsizei height)
 {
-    if (context->getClientMajorVersion() < 3)
+    if ((context->getClientMajorVersion() < 3) && !context->getExtensions().texture3DOES)
     {
         context->validationError(GL_INVALID_OPERATION, kES3Required);
         return false;
@@ -2167,7 +2196,7 @@
 }
 
 bool ValidateTexImage3D(Context *context,
-                        TextureType target,
+                        TextureTarget target,
                         GLint level,
                         GLint internalformat,
                         GLsizei width,
@@ -2178,9 +2207,9 @@
                         GLenum type,
                         const void *pixels)
 {
-    if (context->getClientMajorVersion() < 3)
-    {
-        context->validationError(GL_INVALID_OPERATION, kES3Required);
+    if ((context->getClientMajorVersion() < 3) && !context->getExtensions().texture3DOES)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
         return false;
     }
 
@@ -2190,7 +2219,7 @@
 }
 
 bool ValidateTexImage3DRobustANGLE(Context *context,
-                                   TextureType target,
+                                   TextureTarget target,
                                    GLint level,
                                    GLint internalformat,
                                    GLsizei width,
@@ -2219,7 +2248,7 @@
 }
 
 bool ValidateTexSubImage3D(Context *context,
-                           TextureType target,
+                           TextureTarget target,
                            GLint level,
                            GLint xoffset,
                            GLint yoffset,
@@ -2231,7 +2260,7 @@
                            GLenum type,
                            const void *pixels)
 {
-    if (context->getClientMajorVersion() < 3)
+    if ((context->getClientMajorVersion() < 3) && !context->getExtensions().texture3DOES)
     {
         context->validationError(GL_INVALID_OPERATION, kES3Required);
         return false;
@@ -2243,7 +2272,7 @@
 }
 
 bool ValidateTexSubImage3DRobustANGLE(Context *context,
-                                      TextureType target,
+                                      TextureTarget target,
                                       GLint level,
                                       GLint xoffset,
                                       GLint yoffset,
@@ -2273,7 +2302,7 @@
 }
 
 bool ValidateCompressedTexSubImage3D(Context *context,
-                                     TextureType target,
+                                     TextureTarget target,
                                      GLint level,
                                      GLint xoffset,
                                      GLint yoffset,
@@ -2285,7 +2314,7 @@
                                      GLsizei imageSize,
                                      const void *data)
 {
-    if (context->getClientMajorVersion() < 3)
+    if ((context->getClientMajorVersion() < 3) && !context->getExtensions().texture3DOES)
     {
         context->validationError(GL_INVALID_OPERATION, kES3Required);
         return false;
@@ -2328,7 +2357,7 @@
 }
 
 bool ValidateCompressedTexSubImage3DRobustANGLE(Context *context,
-                                                TextureType target,
+                                                TextureTarget target,
                                                 GLint level,
                                                 GLint xoffset,
                                                 GLint yoffset,
@@ -2942,7 +2971,7 @@
     // format if samples is greater than zero. In ES3.1(section 9.2.5), it can support integer
     // multisample renderbuffer, but the samples should not be greater than MAX_INTEGER_SAMPLES.
     const gl::InternalFormat &formatInfo = gl::GetSizedInternalFormatInfo(internalformat);
-    if ((formatInfo.componentType == GL_UNSIGNED_INT || formatInfo.componentType == GL_INT))
+    if (formatInfo.isInt())
     {
         if ((samples > 0 && context->getClientVersion() == ES_3_0) ||
             static_cast<GLuint>(samples) > context->getCaps().maxIntegerSamples)
@@ -3047,6 +3076,22 @@
         return false;
     }
 
+    if (context->isContextLost())
+    {
+        context->validationError(GL_CONTEXT_LOST, kContextLost);
+
+        if (pname == GL_SYNC_STATUS)
+        {
+            // Generate an error but still return true, the context still needs to return a
+            // value in this case.
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
     Sync *syncObject = context->getSync(sync);
     if (!syncObject)
     {
@@ -3445,10 +3490,7 @@
         {
             // Cannot bind a transform feedback object if the current one is started and not
             // paused (3.0.2 pg 85 section 2.14.1)
-            TransformFeedback *curTransformFeedback =
-                context->getState().getCurrentTransformFeedback();
-            if (curTransformFeedback && curTransformFeedback->isActive() &&
-                !curTransformFeedback->isPaused())
+            if (context->getState().isTransformFeedbackActiveUnpaused())
             {
                 context->validationError(GL_INVALID_OPERATION, kTransformFeedbackNotPaused);
                 return false;