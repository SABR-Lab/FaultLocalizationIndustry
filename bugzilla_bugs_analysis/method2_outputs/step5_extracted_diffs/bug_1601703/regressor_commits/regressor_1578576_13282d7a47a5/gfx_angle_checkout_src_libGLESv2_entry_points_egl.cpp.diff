# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libGLESv2/entry_points_egl.cpp
# Commit: 13282d7a47a5
# Full Hash: 13282d7a47a57a73be8d060efd9645b4d642f03e
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-09-08 09:46:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 3064469c073d -r 13282d7a47a5 gfx/angle/checkout/src/libGLESv2/entry_points_egl.cpp
--- a/gfx/angle/checkout/src/libGLESv2/entry_points_egl.cpp	Sat Sep 07 13:36:46 2019 +0000
+++ b/gfx/angle/checkout/src/libGLESv2/entry_points_egl.cpp	Sat Sep 07 13:38:36 2019 +0000
@@ -13,13 +13,14 @@
 #include "common/version.h"
 #include "libANGLE/Context.h"
 #include "libANGLE/Display.h"
+#include "libANGLE/EGLSync.h"
 #include "libANGLE/Surface.h"
 #include "libANGLE/Texture.h"
 #include "libANGLE/Thread.h"
 #include "libANGLE/queryutils.h"
 #include "libANGLE/validationEGL.h"
 #include "libGLESv2/global_state.h"
-#include "libGLESv2/proc_table.h"
+#include "libGLESv2/proc_table_egl.h"
 
 using namespace egl;
 
@@ -104,11 +105,9 @@
     ANGLE_EGL_TRY_RETURN(thread, ValidateTerminate(display), "eglTerminate",
                          GetDisplayIfValid(display), EGL_FALSE);
 
-    if (display->isValidContext(thread->getContext()))
-    {
-        SetContextCurrent(thread, nullptr);
-    }
-
+    ANGLE_EGL_TRY_RETURN(thread, display->makeCurrent(thread, nullptr, nullptr, nullptr),
+                         "eglTerminate", GetDisplayIfValid(display), EGL_FALSE);
+    SetContextCurrent(thread, nullptr);
     ANGLE_EGL_TRY_RETURN(thread, display->terminate(thread), "eglTerminate",
                          GetDisplayIfValid(display), EGL_FALSE);
 
@@ -205,7 +204,7 @@
     ANGLE_EGL_TRY_RETURN(thread, ValidateChooseConfig(display, attribMap, config_size, num_config),
                          "eglChooseConfig", GetDisplayIfValid(display), EGL_FALSE);
 
-    ClipConfigs(display->getConfigs(attribMap), configs, config_size, num_config);
+    ClipConfigs(display->chooseConfig(attribMap), configs, config_size, num_config);
 
     thread->setSuccess();
     return EGL_TRUE;
@@ -383,9 +382,10 @@
                          "eglCreateContext", GetDisplayIfValid(display), EGL_NO_CONTEXT);
 
     gl::Context *context = nullptr;
-    ANGLE_EGL_TRY_RETURN(
-        thread, display->createContext(configuration, sharedGLContext, attributes, &context),
-        "eglCreateContext", GetDisplayIfValid(display), EGL_NO_CONTEXT);
+    ANGLE_EGL_TRY_RETURN(thread,
+                         display->createContext(configuration, sharedGLContext, thread->getAPI(),
+                                                attributes, &context),
+                         "eglCreateContext", GetDisplayIfValid(display), EGL_NO_CONTEXT);
 
     thread->setSuccess();
     return static_cast<EGLContext>(context);
@@ -446,15 +446,8 @@
     // Only call makeCurrent if the context or surfaces have changed.
     if (previousDraw != drawSurface || previousRead != readSurface || previousContext != context)
     {
-        // Release the surface from the previously-current context, to allow
-        // destroyed surfaces to delete themselves.
-        if (previousContext != nullptr && context != previousContext)
-        {
-            ANGLE_EGL_TRY_RETURN(thread, previousContext->releaseSurface(display), "eglMakeCurrent",
-                                 GetContextIfValid(display, context), EGL_FALSE);
-        }
-
-        ANGLE_EGL_TRY_RETURN(thread, display->makeCurrent(drawSurface, readSurface, context),
+        ANGLE_EGL_TRY_RETURN(thread,
+                             display->makeCurrent(thread, drawSurface, readSurface, context),
                              "eglMakeCurrent", GetContextIfValid(display, context), EGL_FALSE);
 
         SetContextCurrent(thread, context);
@@ -496,7 +489,7 @@
     thread->setSuccess();
     if (thread->getContext() != nullptr)
     {
-        return thread->getContext()->getCurrentDisplay();
+        return thread->getContext()->getDisplay();
     }
     return EGL_NO_DISPLAY;
 }
@@ -531,7 +524,7 @@
     EVENT("()");
     Thread *thread = egl::GetCurrentThread();
 
-    egl::Display *display = thread->getCurrentDisplay();
+    egl::Display *display = thread->getDisplay();
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateDisplay(display), "eglWaitGL", GetDisplayIfValid(display),
                          EGL_FALSE);
@@ -551,7 +544,7 @@
     EVENT("(EGLint engine = %d)", engine);
     Thread *thread = egl::GetCurrentThread();
 
-    egl::Display *display = thread->getCurrentDisplay();
+    egl::Display *display = thread->getDisplay();
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateWaitNative(display, engine), "eglWaitNative",
                          GetThreadIfValid(thread), EGL_FALSE);
@@ -778,23 +771,16 @@
     Surface *previousDraw         = thread->getCurrentDrawSurface();
     Surface *previousRead         = thread->getCurrentReadSurface();
     gl::Context *previousContext  = thread->getContext();
-    egl::Display *previousDisplay = thread->getCurrentDisplay();
+    egl::Display *previousDisplay = thread->getDisplay();
 
     // Only call makeCurrent if the context or surfaces have changed.
     if (previousDraw != EGL_NO_SURFACE || previousRead != EGL_NO_SURFACE ||
         previousContext != EGL_NO_CONTEXT)
     {
-        // Release the surface from the previously-current context, to allow
-        // destroyed surfaces to delete themselves.
-        if (previousContext != nullptr && previousDisplay != EGL_NO_DISPLAY)
-        {
-            ANGLE_EGL_TRY_RETURN(thread, previousContext->releaseSurface(previousDisplay),
-                                 "eglReleaseThread", nullptr, EGL_FALSE);
-        }
-
         if (previousDisplay != EGL_NO_DISPLAY)
         {
-            ANGLE_EGL_TRY_RETURN(thread, previousDisplay->makeCurrent(nullptr, nullptr, nullptr),
+            ANGLE_EGL_TRY_RETURN(thread,
+                                 previousDisplay->makeCurrent(thread, nullptr, nullptr, nullptr),
                                  "eglReleaseThread", nullptr, EGL_FALSE);
         }
 
@@ -811,7 +797,7 @@
     EVENT("()");
     Thread *thread = egl::GetCurrentThread();
 
-    egl::Display *display = thread->getCurrentDisplay();
+    egl::Display *display = thread->getDisplay();
     gl::Context *context  = thread->getContext();
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateDisplay(display), "eglWaitClient",
@@ -845,19 +831,19 @@
           ", EGLenum type = 0x%X, const EGLint* attrib_list = 0x%016" PRIxPTR ")",
           (uintptr_t)dpy, type, (uintptr_t)attrib_list);
 
-    Thread *thread        = egl::GetCurrentThread();
-    egl::Display *display = static_cast<egl::Display *>(dpy);
+    Thread *thread          = egl::GetCurrentThread();
+    egl::Display *display   = static_cast<egl::Display *>(dpy);
     AttributeMap attributes = AttributeMap::CreateFromAttribArray(attrib_list);
 
     gl::Context *currentContext  = thread->getContext();
-    egl::Display *currentDisplay = currentContext ? currentContext->getCurrentDisplay() : nullptr;
+    egl::Display *currentDisplay = currentContext ? currentContext->getDisplay() : nullptr;
 
     ANGLE_EGL_TRY_RETURN(
         thread, ValidateCreateSyncKHR(display, type, attributes, currentDisplay, currentContext),
         "eglCreateSync", GetDisplayIfValid(display), EGL_NO_SYNC);
 
     egl::Sync *syncObject = nullptr;
-    ANGLE_EGL_TRY_RETURN(thread, display->createSync(type, attributes, &syncObject),
+    ANGLE_EGL_TRY_RETURN(thread, display->createSync(currentContext, type, attributes, &syncObject),
                          "eglCreateSync", GetDisplayIfValid(display), EGL_NO_SYNC);
 
     thread->setSuccess();
@@ -896,11 +882,13 @@
     egl::Sync *syncObject = static_cast<Sync *>(sync);
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateClientWaitSync(display, syncObject, flags, timeout),
-                         "eglClientWaitSync", GetDisplayIfValid(display), EGL_FALSE);
+                         "eglClientWaitSync", GetSyncIfValid(display, syncObject), EGL_FALSE);
 
-    EGLint syncStatus = EGL_FALSE;
-    ANGLE_EGL_TRY_RETURN(thread, display->clientWaitSync(syncObject, flags, timeout, &syncStatus),
-                         "eglClientWaitSync", GetDisplayIfValid(display), EGL_FALSE);
+    gl::Context *currentContext = thread->getContext();
+    EGLint syncStatus           = EGL_FALSE;
+    ANGLE_EGL_TRY_RETURN(
+        thread, syncObject->clientWait(display, currentContext, flags, timeout, &syncStatus),
+        "eglClientWaitSync", GetSyncIfValid(display, syncObject), EGL_FALSE);
 
     thread->setSuccess();
     return syncStatus;
@@ -922,11 +910,11 @@
     egl::Sync *syncObject = static_cast<Sync *>(sync);
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateGetSyncAttrib(display, syncObject, attribute, value),
-                         "eglGetSyncAttrib", GetDisplayIfValid(display), EGL_FALSE);
+                         "eglGetSyncAttrib", GetSyncIfValid(display, syncObject), EGL_FALSE);
 
     EGLint valueExt;
     ANGLE_EGL_TRY_RETURN(thread, GetSyncAttrib(display, syncObject, attribute, &valueExt),
-                         "eglGetSyncAttrib", GetDisplayIfValid(display), EGL_FALSE);
+                         "eglGetSyncAttrib", GetSyncIfValid(display, syncObject), EGL_FALSE);
     *value = valueExt;
 
     thread->setSuccess();
@@ -945,13 +933,29 @@
           "EGLClientBuffer buffer = 0x%016" PRIxPTR
           ", const EGLAttrib *attrib_list = 0x%016" PRIxPTR ")",
           (uintptr_t)dpy, (uintptr_t)ctx, target, (uintptr_t)buffer, (uintptr_t)attrib_list);
-    Thread *thread        = egl::GetCurrentThread();
-    egl::Display *display = static_cast<egl::Display *>(dpy);
+    Thread *thread = egl::GetCurrentThread();
+
+    egl::Display *display   = static_cast<egl::Display *>(dpy);
+    gl::Context *context    = static_cast<gl::Context *>(ctx);
+    AttributeMap attributes = AttributeMap::CreateFromIntArray((const EGLint *)attrib_list);
 
-    UNIMPLEMENTED();
-    thread->setError(EglBadDisplay() << "eglCreateImage unimplemented.", GetDebug(),
-                     "eglCreateImage", GetDisplayIfValid(display));
-    return EGL_NO_IMAGE;
+    Error error = ValidateCreateImage(display, context, target, buffer, attributes);
+    if (error.isError())
+    {
+        thread->setError(error, GetDebug(), "eglCreateImage", GetDisplayIfValid(display));
+        return EGL_NO_IMAGE;
+    }
+
+    Image *image = nullptr;
+    error        = display->createImage(context, target, buffer, attributes, &image);
+    if (error.isError())
+    {
+        thread->setError(error, GetDebug(), "eglCreateImage", GetDisplayIfValid(display));
+        return EGL_NO_IMAGE;
+    }
+
+    thread->setSuccess();
+    return static_cast<EGLImage>(image);
 }
 
 EGLBoolean EGLAPIENTRY EGL_DestroyImage(EGLDisplay dpy, EGLImage image)
@@ -961,12 +965,19 @@
           (uintptr_t)dpy, (uintptr_t)image);
     Thread *thread        = egl::GetCurrentThread();
     egl::Display *display = static_cast<egl::Display *>(dpy);
-    Image *eglImage       = static_cast<Image *>(image);
+    Image *img            = static_cast<Image *>(image);
 
-    UNIMPLEMENTED();
-    thread->setError(EglBadDisplay() << "eglDestroyImage unimplemented.", GetDebug(),
-                     "eglDestroyImage", GetImageIfValid(display, eglImage));
-    return EGL_FALSE;
+    Error error = ValidateDestroyImage(display, img);
+    if (error.isError())
+    {
+        thread->setError(error, GetDebug(), "eglDestroyImage", GetImageIfValid(display, img));
+        return EGL_FALSE;
+    }
+
+    display->destroyImage(img);
+
+    thread->setSuccess();
+    return EGL_TRUE;
 }
 
 EGLDisplay EGLAPIENTRY EGL_GetPlatformDisplay(EGLenum platform,
@@ -1054,10 +1065,11 @@
     egl::Sync *syncObject = static_cast<Sync *>(sync);
 
     ANGLE_EGL_TRY_RETURN(thread, ValidateWaitSync(display, context, syncObject, flags),
-                         "eglWaitSync", GetDisplayIfValid(display), EGL_FALSE);
+                         "eglWaitSync", GetSyncIfValid(display, syncObject), EGL_FALSE);
 
-    ANGLE_EGL_TRY_RETURN(thread, display->waitSync(syncObject, flags), "eglWaitSync",
-                         GetDisplayIfValid(display), EGL_FALSE);
+    gl::Context *currentContext = thread->getContext();
+    ANGLE_EGL_TRY_RETURN(thread, syncObject->serverWait(display, currentContext, flags),
+                         "eglWaitSync", GetSyncIfValid(display, syncObject), EGL_FALSE);
 
     thread->setSuccess();
     return EGL_TRUE;