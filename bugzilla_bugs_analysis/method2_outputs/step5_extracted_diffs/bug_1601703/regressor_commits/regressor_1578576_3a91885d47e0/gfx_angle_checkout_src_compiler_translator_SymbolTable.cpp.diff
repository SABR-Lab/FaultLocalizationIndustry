# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/compiler/translator/SymbolTable.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/compiler/translator/SymbolTable.cpp
--- a/gfx/angle/checkout/src/compiler/translator/SymbolTable.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/compiler/translator/SymbolTable.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -17,6 +17,7 @@
 #include "compiler/translator/ImmutableString.h"
 #include "compiler/translator/IntermNode.h"
 #include "compiler/translator/StaticType.h"
+#include "compiler/translator/util.h"
 
 namespace sh
 {
@@ -196,7 +197,7 @@
 bool TSymbolTable::isVaryingInvariant(const TVariable &variable) const
 {
     ASSERT(atGlobalLevel());
-    if (mGlobalInvariant)
+    if (mGlobalInvariant && (IsShaderOutput(variable.getType().getQualifier())))
     {
         return true;
     }
@@ -251,6 +252,32 @@
     return mTable[0]->find(name);
 }
 
+const TSymbol *TSymbolTable::findGlobalWithConversion(
+    const std::vector<ImmutableString> &names) const
+{
+    const TSymbol *target;
+    for (ImmutableString name : names)
+    {
+        target = findGlobal(name);
+        if (target != nullptr)
+            break;
+    }
+    return target;
+}
+
+const TSymbol *TSymbolTable::findBuiltInWithConversion(const std::vector<ImmutableString> &names,
+                                                       int shaderVersion) const
+{
+    const TSymbol *target;
+    for (ImmutableString name : names)
+    {
+        target = findBuiltIn(name, shaderVersion);
+        if (target != nullptr)
+            break;
+    }
+    return target;
+}
+
 bool TSymbolTable::declare(TSymbol *symbol)
 {
     ASSERT(!mTable.empty());
@@ -337,20 +364,29 @@
     // We need just one precision stack level for predefined precisions.
     mPrecisionStack.emplace_back(new PrecisionStackLevel);
 
-    switch (type)
+    if (IsDesktopGLSpec(spec))
+    {
+        setDefaultPrecision(EbtInt, EbpUndefined);
+        setDefaultPrecision(EbtFloat, EbpUndefined);
+    }
+    else
     {
-        case GL_FRAGMENT_SHADER:
-            setDefaultPrecision(EbtInt, EbpMedium);
-            break;
-        case GL_VERTEX_SHADER:
-        case GL_COMPUTE_SHADER:
-        case GL_GEOMETRY_SHADER_EXT:
-            setDefaultPrecision(EbtInt, EbpHigh);
-            setDefaultPrecision(EbtFloat, EbpHigh);
-            break;
-        default:
-            UNREACHABLE();
+        switch (type)
+        {
+            case GL_FRAGMENT_SHADER:
+                setDefaultPrecision(EbtInt, EbpMedium);
+                break;
+            case GL_VERTEX_SHADER:
+            case GL_COMPUTE_SHADER:
+            case GL_GEOMETRY_SHADER_EXT:
+                setDefaultPrecision(EbtInt, EbpHigh);
+                setDefaultPrecision(EbtFloat, EbpHigh);
+                break;
+            default:
+                UNREACHABLE();
+        }
     }
+
     // Set defaults for sampler types that have default precision, even those that are
     // only available if an extension exists.
     // New sampler types in ESSL3 don't have default precision. ESSL1 types do.