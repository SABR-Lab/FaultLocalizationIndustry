# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/ErrorStrings.h
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/ErrorStrings.h
--- a/gfx/angle/checkout/src/libANGLE/ErrorStrings.h	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/ErrorStrings.h	Fri Nov 08 17:06:00 2019 +0000
@@ -69,6 +69,7 @@
 MSG kCompressedTextureDimensionsMustMatchData = "Compressed texture dimensions must exactly match the dimensions of the data passed in.";
 MSG kCompressedTexturesNotAttachable = "Compressed textures cannot be attached to a framebuffer.";
 MSG kConstantColorAlphaLimitation = "Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR not supported by this implementation.";
+MSG kContextLost = "Context has been lost.";
 MSG kCopyAlias = "The read and write copy regions alias memory.";
 MSG kCubemapFacesEqualDimensions = "Each cubemap face must have equal width and height.";
 MSG kCubemapIncomplete = "Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.";
@@ -83,6 +84,7 @@
 MSG kDestinationTextureTooSmall = "Destination texture too small.";
 MSG kDimensionsMustBePow2 = "Texture dimensions must be power-of-two.";
 MSG kDispatchIndirectBufferNotBound = "Dispatch indirect buffer must be bound.";
+MSG kDrawBufferMaskMismatch = "Active draw buffers with missing fragment shader outputs.";
 MSG kDrawBufferTypeMismatch = "Fragment shader output type does not match the bound framebuffer attachment type.";
 MSG kDrawFramebufferIncomplete = "Draw framebuffer is incomplete";
 MSG kDrawIndirectBufferNotBound = "Draw indirect buffer must be bound.";
@@ -216,7 +218,9 @@
 MSG kInvalidFramebufferName = "name is not a valid framebuffer.";
 MSG kInvalidFramebufferTarget = "Invalid framebuffer target.";
 MSG kInvalidFramebufferTextureLevel = "Mipmap level must be 0 when attaching a texture.";
+MSG kInvalidHandleType = "Invalid handle type.";
 MSG kInvalidImageAccess = "access is not one of the supported tokens.";
+MSG kInvalidImageLayout = "Invalid image layout.";
 MSG kInvalidImageFormat = "format is not one of supported image unit formats.";
 MSG kInvalidIndentifier = "Invalid identifier.";
 MSG kInvalidIndirectOffset = "indirect must be a multiple of the size of uint in basic machine units.";
@@ -282,6 +286,7 @@
 MSG kInvalidRenderbufferTarget = "Invalid renderbuffer target.";
 MSG kInvalidRenderbufferTextureParameter = "Invalid parameter name for renderbuffer attachment.";
 MSG kInvalidRenderbufferWidthHeight = "Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.";
+MSG kInvalidResetStatus = "Reset status is not valid";
 MSG kInvalidSampleMaskNumber = "MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.";
 MSG kInvalidSampler = "Sampler is not valid";
 MSG kInvalidSamplerName = "name is not a valid sampler.";
@@ -438,6 +443,7 @@
 MSG kStrideMustBeMultipleOfType = "Stride must be a multiple of the passed in datatype.";
 MSG kSyncMissing = "Sync object does not exist.";
 MSG kTargetMustBeTexture2DMultisampleArrayOES = "Target must be TEXTURE_2D_MULTISAMPLE_ARRAY_OES.";
+MSG kTextureFormatMismatch = "Passed in texture target and format must match the one originally used to define the texture.";
 MSG kTextureIsImmutable = "Texture is immutable.";
 MSG kTextureIsNotImmutable = "Texture is not immutable.";
 MSG kTextureNotBound = "A texture must be bound.";
@@ -447,6 +453,7 @@
 MSG kTextureTargetMismatch = "Textarget must match the texture target type.";
 MSG kTextureTargetRequiresES31 = "Texture target requires at least OpenGL ES 3.1.";
 MSG kTextureTypeConflict = "Two textures of different types use the same sampler location.";
+MSG kTextureTypeMismatch = "Passed in texture type must match the one originally used to define the texture.";
 MSG kTextureWidthOrHeightOutOfRange = "Width and height must be less than or equal to GL_MAX_TEXTURE_SIZE.";
 MSG kTransfomFeedbackAlreadyActive = "Transform feedback is already active.";
 MSG kTransformFeedbackActiveDelete = "Attempt to delete an active transform feedback.";
@@ -462,7 +469,6 @@
 MSG kTransformFeedbackTargetActive = "Target is TRANSFORM_FEEDBACK_BUFFER and transform feedback is currently active.";
 MSG kTransformFeedbackUseProgram = "Cannot change active program while transform feedback is unpaused.";
 MSG kTransformFeedbackVaryingIndexOutOfRange = "Index must be less than the transform feedback varying count in the program.";
-MSG kTypeMismatch = "Passed in texture target and format must match the one originally used to define the texture.";
 MSG kTypeNotUnsignedShortByte = "Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.";
 MSG kUniformBufferBoundForTransformFeedback = "It is undefined behavior to use an uniform buffer that is bound for transform feedback.";
 MSG kUniformBufferOffsetAlignment = "Offset must be multiple of value of UNIFORM_BUFFER_OFFSET_ALIGNMENT.";