# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/ResourceManager.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/ResourceManager.cpp
--- a/gfx/angle/checkout/src/libANGLE/ResourceManager.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/ResourceManager.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -12,11 +12,13 @@
 #include "libANGLE/Buffer.h"
 #include "libANGLE/Context.h"
 #include "libANGLE/Fence.h"
+#include "libANGLE/MemoryObject.h"
 #include "libANGLE/Path.h"
 #include "libANGLE/Program.h"
 #include "libANGLE/ProgramPipeline.h"
 #include "libANGLE/Renderbuffer.h"
 #include "libANGLE/Sampler.h"
+#include "libANGLE/Semaphore.h"
 #include "libANGLE/Shader.h"
 #include "libANGLE/Texture.h"
 #include "libANGLE/renderer/ContextImpl.h"
@@ -235,7 +237,7 @@
     return AllocateEmptyObject(&mHandleAllocator, &mObjectMap);
 }
 
-void TextureManager::signalAllTexturesDirty(const Context *context) const
+void TextureManager::signalAllTexturesDirty() const
 {
     for (const auto &texture : mObjectMap)
     {
@@ -243,7 +245,7 @@
         {
             // We don't know if the Texture needs init, but that's ok, since it will only force
             // a re-check, and will not initialize the pixels if it's not needed.
-            texture.second->signalDirtyStorage(context, InitState::MayNeedInit);
+            texture.second->signalDirtyStorage(InitState::MayNeedInit);
         }
     }
 }
@@ -438,13 +440,13 @@
     mObjectMap.assign(0, framebuffer);
 }
 
-void FramebufferManager::invalidateFramebufferComplenessCache(const Context *context) const
+void FramebufferManager::invalidateFramebufferComplenessCache() const
 {
     for (const auto &framebuffer : mObjectMap)
     {
         if (framebuffer.second)
         {
-            framebuffer.second->invalidateCompletenessCache(context);
+            framebuffer.second->invalidateCompletenessCache();
         }
     }
 }
@@ -476,4 +478,102 @@
     return mObjectMap.query(handle);
 }
 
+// MemoryObjectManager Implementation.
+
+MemoryObjectManager::MemoryObjectManager() {}
+
+MemoryObjectManager::~MemoryObjectManager()
+{
+    ASSERT(mMemoryObjects.empty());
+}
+
+void MemoryObjectManager::reset(const Context *context)
+{
+    while (!mMemoryObjects.empty())
+    {
+        deleteMemoryObject(context, mMemoryObjects.begin()->first);
+    }
+    mMemoryObjects.clear();
+}
+
+GLuint MemoryObjectManager::createMemoryObject(rx::GLImplFactory *factory)
+{
+    GLuint handle              = mHandleAllocator.allocate();
+    MemoryObject *memoryObject = new MemoryObject(factory, handle);
+    memoryObject->addRef();
+    mMemoryObjects.assign(handle, memoryObject);
+    return handle;
+}
+
+void MemoryObjectManager::deleteMemoryObject(const Context *context, GLuint handle)
+{
+    MemoryObject *memoryObject = nullptr;
+    if (!mMemoryObjects.erase(handle, &memoryObject))
+    {
+        return;
+    }
+
+    // Requires an explicit this-> because of C++ template rules.
+    this->mHandleAllocator.release(handle);
+
+    if (memoryObject)
+    {
+        memoryObject->release(context);
+    }
+}
+
+MemoryObject *MemoryObjectManager::getMemoryObject(GLuint handle) const
+{
+    return mMemoryObjects.query(handle);
+}
+
+// SemaphoreManager Implementation.
+
+SemaphoreManager::SemaphoreManager() {}
+
+SemaphoreManager::~SemaphoreManager()
+{
+    ASSERT(mSemaphores.empty());
+}
+
+void SemaphoreManager::reset(const Context *context)
+{
+    while (!mSemaphores.empty())
+    {
+        deleteSemaphore(context, mSemaphores.begin()->first);
+    }
+    mSemaphores.clear();
+}
+
+GLuint SemaphoreManager::createSemaphore(rx::GLImplFactory *factory)
+{
+    GLuint handle        = mHandleAllocator.allocate();
+    Semaphore *semaphore = new Semaphore(factory, handle);
+    semaphore->addRef();
+    mSemaphores.assign(handle, semaphore);
+    return handle;
+}
+
+void SemaphoreManager::deleteSemaphore(const Context *context, GLuint handle)
+{
+    Semaphore *semaphore = nullptr;
+    if (!mSemaphores.erase(handle, &semaphore))
+    {
+        return;
+    }
+
+    // Requires an explicit this-> because of C++ template rules.
+    this->mHandleAllocator.release(handle);
+
+    if (semaphore)
+    {
+        semaphore->release(context);
+    }
+}
+
+Semaphore *SemaphoreManager::getSemaphore(GLuint handle) const
+{
+    return mSemaphores.query(handle);
+}
+
 }  // namespace gl