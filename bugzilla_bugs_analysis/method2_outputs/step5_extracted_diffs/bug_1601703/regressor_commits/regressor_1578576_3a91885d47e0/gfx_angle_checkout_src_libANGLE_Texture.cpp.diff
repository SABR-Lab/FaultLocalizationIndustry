# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/Texture.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/Texture.cpp
--- a/gfx/angle/checkout/src/libANGLE/Texture.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/Texture.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -48,7 +48,6 @@
                ? InitState::MayNeedInit
                : InitState::Initialized;
 }
-
 }  // namespace
 
 bool IsMipmapFiltered(const SamplerState &samplerState)
@@ -108,6 +107,7 @@
       mGenerateMipmapHint(GL_FALSE),
       mInitState(InitState::MayNeedInit),
       mCachedSamplerFormat(SamplerFormat::InvalidEnum),
+      mCachedSamplerCompareMode(GL_NONE),
       mCachedSamplerFormatValid(false)
 {}
 
@@ -241,12 +241,12 @@
     return mGenerateMipmapHint;
 }
 
-SamplerFormat TextureState::computeRequiredSamplerFormat() const
+SamplerFormat TextureState::computeRequiredSamplerFormat(const SamplerState &samplerState) const
 {
     const ImageDesc &baseImageDesc = getImageDesc(getBaseImageTarget(), getEffectiveBaseLevel());
     if ((baseImageDesc.format.info->format == GL_DEPTH_COMPONENT ||
          baseImageDesc.format.info->format == GL_DEPTH_STENCIL) &&
-        mSamplerState.getCompareMode() != GL_NONE)
+        samplerState.getCompareMode() != GL_NONE)
     {
         return SamplerFormat::Shadow;
     }
@@ -619,7 +619,7 @@
     : RefCountObject(id),
       mState(type),
       mTexture(factory->createTexture(mState)),
-      mImplObserver(this, 0),
+      mImplObserver(this, rx::kTextureImageImplObserverMessageIndex),
       mLabel(),
       mBoundSurface(nullptr),
       mBoundStream(nullptr)
@@ -659,7 +659,7 @@
 void Texture::setLabel(const Context *context, const std::string &label)
 {
     mLabel = label;
-    signalDirtyState(context, DIRTY_BIT_LABEL);
+    signalDirtyState(DIRTY_BIT_LABEL);
 }
 
 const std::string &Texture::getLabel() const
@@ -670,7 +670,7 @@
 void Texture::setSwizzleRed(const Context *context, GLenum swizzleRed)
 {
     mState.mSwizzleState.swizzleRed = swizzleRed;
-    signalDirtyState(context, DIRTY_BIT_SWIZZLE_RED);
+    signalDirtyState(DIRTY_BIT_SWIZZLE_RED);
 }
 
 GLenum Texture::getSwizzleRed() const
@@ -681,7 +681,7 @@
 void Texture::setSwizzleGreen(const Context *context, GLenum swizzleGreen)
 {
     mState.mSwizzleState.swizzleGreen = swizzleGreen;
-    signalDirtyState(context, DIRTY_BIT_SWIZZLE_GREEN);
+    signalDirtyState(DIRTY_BIT_SWIZZLE_GREEN);
 }
 
 GLenum Texture::getSwizzleGreen() const
@@ -692,7 +692,7 @@
 void Texture::setSwizzleBlue(const Context *context, GLenum swizzleBlue)
 {
     mState.mSwizzleState.swizzleBlue = swizzleBlue;
-    signalDirtyState(context, DIRTY_BIT_SWIZZLE_BLUE);
+    signalDirtyState(DIRTY_BIT_SWIZZLE_BLUE);
 }
 
 GLenum Texture::getSwizzleBlue() const
@@ -703,7 +703,7 @@
 void Texture::setSwizzleAlpha(const Context *context, GLenum swizzleAlpha)
 {
     mState.mSwizzleState.swizzleAlpha = swizzleAlpha;
-    signalDirtyState(context, DIRTY_BIT_SWIZZLE_ALPHA);
+    signalDirtyState(DIRTY_BIT_SWIZZLE_ALPHA);
 }
 
 GLenum Texture::getSwizzleAlpha() const
@@ -714,7 +714,7 @@
 void Texture::setMinFilter(const Context *context, GLenum minFilter)
 {
     mState.mSamplerState.setMinFilter(minFilter);
-    signalDirtyState(context, DIRTY_BIT_MIN_FILTER);
+    signalDirtyState(DIRTY_BIT_MIN_FILTER);
 }
 
 GLenum Texture::getMinFilter() const
@@ -725,7 +725,7 @@
 void Texture::setMagFilter(const Context *context, GLenum magFilter)
 {
     mState.mSamplerState.setMagFilter(magFilter);
-    signalDirtyState(context, DIRTY_BIT_MAG_FILTER);
+    signalDirtyState(DIRTY_BIT_MAG_FILTER);
 }
 
 GLenum Texture::getMagFilter() const
@@ -736,7 +736,7 @@
 void Texture::setWrapS(const Context *context, GLenum wrapS)
 {
     mState.mSamplerState.setWrapS(wrapS);
-    signalDirtyState(context, DIRTY_BIT_WRAP_S);
+    signalDirtyState(DIRTY_BIT_WRAP_S);
 }
 
 GLenum Texture::getWrapS() const
@@ -747,7 +747,7 @@
 void Texture::setWrapT(const Context *context, GLenum wrapT)
 {
     mState.mSamplerState.setWrapT(wrapT);
-    signalDirtyState(context, DIRTY_BIT_WRAP_T);
+    signalDirtyState(DIRTY_BIT_WRAP_T);
 }
 
 GLenum Texture::getWrapT() const
@@ -758,7 +758,7 @@
 void Texture::setWrapR(const Context *context, GLenum wrapR)
 {
     mState.mSamplerState.setWrapR(wrapR);
-    signalDirtyState(context, DIRTY_BIT_WRAP_R);
+    signalDirtyState(DIRTY_BIT_WRAP_R);
 }
 
 GLenum Texture::getWrapR() const
@@ -769,7 +769,7 @@
 void Texture::setMaxAnisotropy(const Context *context, float maxAnisotropy)
 {
     mState.mSamplerState.setMaxAnisotropy(maxAnisotropy);
-    signalDirtyState(context, DIRTY_BIT_MAX_ANISOTROPY);
+    signalDirtyState(DIRTY_BIT_MAX_ANISOTROPY);
 }
 
 float Texture::getMaxAnisotropy() const
@@ -780,7 +780,7 @@
 void Texture::setMinLod(const Context *context, GLfloat minLod)
 {
     mState.mSamplerState.setMinLod(minLod);
-    signalDirtyState(context, DIRTY_BIT_MIN_LOD);
+    signalDirtyState(DIRTY_BIT_MIN_LOD);
 }
 
 GLfloat Texture::getMinLod() const
@@ -791,7 +791,7 @@
 void Texture::setMaxLod(const Context *context, GLfloat maxLod)
 {
     mState.mSamplerState.setMaxLod(maxLod);
-    signalDirtyState(context, DIRTY_BIT_MAX_LOD);
+    signalDirtyState(DIRTY_BIT_MAX_LOD);
 }
 
 GLfloat Texture::getMaxLod() const
@@ -802,7 +802,7 @@
 void Texture::setCompareMode(const Context *context, GLenum compareMode)
 {
     mState.mSamplerState.setCompareMode(compareMode);
-    signalDirtyState(context, DIRTY_BIT_COMPARE_MODE);
+    signalDirtyState(DIRTY_BIT_COMPARE_MODE);
 }
 
 GLenum Texture::getCompareMode() const
@@ -813,7 +813,7 @@
 void Texture::setCompareFunc(const Context *context, GLenum compareFunc)
 {
     mState.mSamplerState.setCompareFunc(compareFunc);
-    signalDirtyState(context, DIRTY_BIT_COMPARE_FUNC);
+    signalDirtyState(DIRTY_BIT_COMPARE_FUNC);
 }
 
 GLenum Texture::getCompareFunc() const
@@ -824,7 +824,7 @@
 void Texture::setSRGBDecode(const Context *context, GLenum sRGBDecode)
 {
     mState.mSamplerState.setSRGBDecode(sRGBDecode);
-    signalDirtyState(context, DIRTY_BIT_SRGB_DECODE);
+    signalDirtyState(DIRTY_BIT_SRGB_DECODE);
 }
 
 GLenum Texture::getSRGBDecode() const
@@ -842,7 +842,7 @@
     if (mState.setBaseLevel(baseLevel))
     {
         ANGLE_TRY(mTexture->setBaseLevel(context, mState.getEffectiveBaseLevel()));
-        signalDirtyState(context, DIRTY_BIT_BASE_LEVEL);
+        signalDirtyState(DIRTY_BIT_BASE_LEVEL);
     }
 
     return angle::Result::Continue;
@@ -857,7 +857,7 @@
 {
     if (mState.setMaxLevel(maxLevel))
     {
-        signalDirtyState(context, DIRTY_BIT_MAX_LEVEL);
+        signalDirtyState(DIRTY_BIT_MAX_LEVEL);
     }
 }
 
@@ -871,7 +871,7 @@
     if (mState.mDepthStencilTextureMode != mode)
     {
         mState.mDepthStencilTextureMode = mode;
-        signalDirtyState(context, DIRTY_BIT_DEPTH_STENCIL_TEXTURE_MODE);
+        signalDirtyState(DIRTY_BIT_DEPTH_STENCIL_TEXTURE_MODE);
     }
 }
 
@@ -893,7 +893,7 @@
 void Texture::setUsage(const Context *context, GLenum usage)
 {
     mState.mUsage = usage;
-    signalDirtyState(context, DIRTY_BIT_USAGE);
+    signalDirtyState(DIRTY_BIT_USAGE);
 }
 
 GLenum Texture::getUsage() const
@@ -989,20 +989,20 @@
     return mState.getImageDesc(target, level).getMemorySize();
 }
 
-void Texture::signalDirtyStorage(const Context *context, InitState initState)
+void Texture::signalDirtyStorage(InitState initState)
 {
     mState.mInitState = initState;
     invalidateCompletenessCache();
     mState.mCachedSamplerFormatValid = false;
-    onStateChange(context, angle::SubjectMessage::STORAGE_CHANGED);
+    onStateChange(angle::SubjectMessage::SubjectChanged);
 }
 
-void Texture::signalDirtyState(const Context *context, size_t dirtyBit)
+void Texture::signalDirtyState(size_t dirtyBit)
 {
     mDirtyBits.set(dirtyBit);
     invalidateCompletenessCache();
     mState.mCachedSamplerFormatValid = false;
-    onStateChange(context, angle::SubjectMessage::DEPENDENT_DIRTY_BITS);
+    onStateChange(angle::SubjectMessage::DirtyBitsFlagged);
 }
 
 angle::Result Texture::setImage(Context *context,
@@ -1021,7 +1021,7 @@
     ANGLE_TRY(releaseTexImageInternal(context));
     ANGLE_TRY(orphanImages(context));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, size.depth);
 
     ANGLE_TRY(mTexture->setImage(context, index, internalFormat, size, format, type, unpackState,
                                  pixels));
@@ -1031,7 +1031,7 @@
 
     ANGLE_TRY(handleMipmapGenerationHint(context, level));
 
-    signalDirtyStorage(context, initState);
+    signalDirtyStorage(initState);
 
     return angle::Result::Continue;
 }
@@ -1050,13 +1050,15 @@
 
     ANGLE_TRY(ensureSubImageInitialized(context, target, level, area));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, area.depth);
 
     ANGLE_TRY(mTexture->setSubImage(context, index, area, format, type, unpackState, unpackBuffer,
                                     pixels));
 
     ANGLE_TRY(handleMipmapGenerationHint(context, level));
 
+    onStateChange(angle::SubjectMessage::ContentsChanged);
+
     return angle::Result::Continue;
 }
 
@@ -1075,14 +1077,14 @@
     ANGLE_TRY(releaseTexImageInternal(context));
     ANGLE_TRY(orphanImages(context));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, size.depth);
 
     ANGLE_TRY(mTexture->setCompressedImage(context, index, internalFormat, size, unpackState,
                                            imageSize, pixels));
 
     InitState initState = DetermineInitState(context, pixels);
     mState.setImageDesc(target, level, ImageDesc(size, Format(internalFormat), initState));
-    signalDirtyStorage(context, initState);
+    signalDirtyStorage(initState);
 
     return angle::Result::Continue;
 }
@@ -1100,10 +1102,14 @@
 
     ANGLE_TRY(ensureSubImageInitialized(context, target, level, area));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, area.depth);
 
-    return mTexture->setCompressedSubImage(context, index, area, format, unpackState, imageSize,
-                                           pixels);
+    ANGLE_TRY(mTexture->setCompressedSubImage(context, index, area, format, unpackState, imageSize,
+                                              pixels));
+
+    onStateChange(angle::SubjectMessage::ContentsChanged);
+
+    return angle::Result::Continue;
 }
 
 angle::Result Texture::copyImage(Context *context,
@@ -1119,14 +1125,11 @@
     ANGLE_TRY(releaseTexImageInternal(context));
     ANGLE_TRY(orphanImages(context));
 
-    // Ensure source FBO is initialized.
-    ANGLE_TRY(source->ensureReadAttachmentInitialized(context, GL_COLOR_BUFFER_BIT));
-
     // Use the source FBO size as the init image area.
     Box destBox(0, 0, 0, sourceArea.width, sourceArea.height, 1);
     ANGLE_TRY(ensureSubImageInitialized(context, target, level, destBox));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, 1);
 
     ANGLE_TRY(mTexture->copyImage(context, index, sourceArea, internalFormat, source));
 
@@ -1140,7 +1143,7 @@
     ANGLE_TRY(handleMipmapGenerationHint(context, level));
 
     // We need to initialize this texture only if the source attachment is not initialized.
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
 
     return angle::Result::Continue;
 }
@@ -1153,9 +1156,6 @@
 {
     ASSERT(TextureTargetToType(index.getTarget()) == mState.mType);
 
-    // Ensure source FBO is initialized.
-    ANGLE_TRY(source->ensureReadAttachmentInitialized(context, GL_COLOR_BUFFER_BIT));
-
     Box destBox(destOffset.x, destOffset.y, destOffset.z, sourceArea.width, sourceArea.height, 1);
     ANGLE_TRY(
         ensureSubImageInitialized(context, index.getTarget(), index.getLevelIndex(), destBox));
@@ -1163,6 +1163,8 @@
     ANGLE_TRY(mTexture->copySubImage(context, index, destOffset, sourceArea, source));
     ANGLE_TRY(handleMipmapGenerationHint(context, index.getLevelIndex()));
 
+    onStateChange(angle::SubjectMessage::ContentsChanged);
+
     return angle::Result::Continue;
 }
 
@@ -1188,7 +1190,7 @@
     // Note: we don't have a way to notify which portions of the image changed currently.
     ANGLE_TRY(source->ensureInitialized(context));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, ImageIndex::kEntireLevel);
 
     ANGLE_TRY(mTexture->copyTexture(context, index, internalFormat, type, sourceLevel, unpackFlipY,
                                     unpackPremultiplyAlpha, unpackUnmultiplyAlpha, source));
@@ -1200,7 +1202,7 @@
         target, level,
         ImageDesc(sourceDesc.size, Format(internalFormatInfo), InitState::Initialized));
 
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
 
     return angle::Result::Continue;
 }
@@ -1225,10 +1227,15 @@
                 sourceBox.depth);
     ANGLE_TRY(ensureSubImageInitialized(context, target, level, destBox));
 
-    ImageIndex index = ImageIndex::MakeFromTarget(target, level);
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, sourceBox.depth);
 
-    return mTexture->copySubTexture(context, index, destOffset, sourceLevel, sourceBox, unpackFlipY,
-                                    unpackPremultiplyAlpha, unpackUnmultiplyAlpha, source);
+    ANGLE_TRY(mTexture->copySubTexture(context, index, destOffset, sourceLevel, sourceBox,
+                                       unpackFlipY, unpackPremultiplyAlpha, unpackUnmultiplyAlpha,
+                                       source));
+
+    onStateChange(angle::SubjectMessage::ContentsChanged);
+
+    return angle::Result::Continue;
 }
 
 angle::Result Texture::copyCompressedTexture(Context *context, const Texture *source)
@@ -1274,7 +1281,35 @@
     mDirtyBits.set(DIRTY_BIT_BASE_LEVEL);
     mDirtyBits.set(DIRTY_BIT_MAX_LEVEL);
 
-    signalDirtyStorage(context, InitState::MayNeedInit);
+    signalDirtyStorage(InitState::MayNeedInit);
+
+    return angle::Result::Continue;
+}
+
+angle::Result Texture::setImageExternal(Context *context,
+                                        TextureTarget target,
+                                        GLint level,
+                                        GLenum internalFormat,
+                                        const Extents &size,
+                                        GLenum format,
+                                        GLenum type)
+{
+    ASSERT(TextureTargetToType(target) == mState.mType);
+
+    // Release from previous calls to eglBindTexImage, to avoid calling the Impl after
+    ANGLE_TRY(releaseTexImageInternal(context));
+    ANGLE_TRY(orphanImages(context));
+
+    ImageIndex index = ImageIndex::MakeFromTarget(target, level, size.depth);
+
+    ANGLE_TRY(mTexture->setImageExternal(context, index, internalFormat, size, format, type));
+
+    InitState initState = InitState::Initialized;
+    mState.setImageDesc(target, level, ImageDesc(size, Format(internalFormat, type), initState));
+
+    ANGLE_TRY(handleMipmapGenerationHint(context, level));
+
+    signalDirtyStorage(initState);
 
     return angle::Result::Continue;
 }
@@ -1301,7 +1336,42 @@
     mState.setImageDescChainMultisample(size, Format(internalFormat), samples, fixedSampleLocations,
                                         InitState::MayNeedInit);
 
-    signalDirtyStorage(context, InitState::MayNeedInit);
+    signalDirtyStorage(InitState::MayNeedInit);
+
+    return angle::Result::Continue;
+}
+
+angle::Result Texture::setStorageExternalMemory(Context *context,
+                                                TextureType type,
+                                                GLsizei levels,
+                                                GLenum internalFormat,
+                                                const Extents &size,
+                                                MemoryObject *memoryObject,
+                                                GLuint64 offset)
+{
+    ASSERT(type == mState.mType);
+
+    // Release from previous calls to eglBindTexImage, to avoid calling the Impl after
+    ANGLE_TRY(releaseTexImageInternal(context));
+    ANGLE_TRY(orphanImages(context));
+
+    ANGLE_TRY(mTexture->setStorageExternalMemory(context, type, levels, internalFormat, size,
+                                                 memoryObject, offset));
+
+    mState.mImmutableFormat = true;
+    mState.mImmutableLevels = static_cast<GLuint>(levels);
+    mState.clearImageDescs();
+    mState.setImageDescChain(0, static_cast<GLuint>(levels - 1), size, Format(internalFormat),
+                             InitState::MayNeedInit);
+
+    // Changing the texture to immutable can trigger a change in the base and max levels:
+    // GLES 3.0.4 section 3.8.10 pg 158:
+    // "For immutable-format textures, levelbase is clamped to the range[0;levels],levelmax is then
+    // clamped to the range[levelbase;levels].
+    mDirtyBits.set(DIRTY_BIT_BASE_LEVEL);
+    mDirtyBits.set(DIRTY_BIT_MAX_LEVEL);
+
+    signalDirtyStorage(InitState::Initialized);
 
     return angle::Result::Continue;
 }
@@ -1357,7 +1427,7 @@
     mState.setImageDescChain(baseLevel, maxLevel, baseImageInfo.size, baseImageInfo.format,
                              InitState::Initialized);
 
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
 
     return angle::Result::Continue;
 }
@@ -1379,7 +1449,7 @@
     Extents size(surface->getWidth(), surface->getHeight(), 1);
     ImageDesc desc(size, surface->getBindTexImageFormat(), InitState::Initialized);
     mState.setImageDesc(NonCubeTextureTypeToTarget(mState.mType), 0, desc);
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
     return angle::Result::Continue;
 }
 
@@ -1392,7 +1462,7 @@
     // Erase the image info for level 0
     ASSERT(mState.mType == TextureType::_2D || mState.mType == TextureType::Rectangle);
     mState.clearImageDesc(NonCubeTextureTypeToTarget(mState.mType), 0);
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
     return angle::Result::Continue;
 }
 
@@ -1423,7 +1493,7 @@
     Extents size(desc.width, desc.height, 1);
     mState.setImageDesc(NonCubeTextureTypeToTarget(mState.mType), 0,
                         ImageDesc(size, Format(desc.internalFormat), InitState::Initialized));
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
     return angle::Result::Continue;
 }
 
@@ -1435,7 +1505,7 @@
 
     // Set to incomplete
     mState.clearImageDesc(NonCubeTextureTypeToTarget(mState.mType), 0);
-    signalDirtyStorage(context, InitState::Initialized);
+    signalDirtyStorage(InitState::Initialized);
     return angle::Result::Continue;
 }
 
@@ -1481,7 +1551,7 @@
     mState.clearImageDescs();
     mState.setImageDesc(NonCubeTextureTypeToTarget(type), 0,
                         ImageDesc(size, imageTarget->getFormat(), initState));
-    signalDirtyStorage(context, initState);
+    signalDirtyStorage(initState);
 
     return angle::Result::Continue;
 }
@@ -1563,7 +1633,7 @@
 void Texture::setBorderColor(const Context *context, const ColorGeneric &color)
 {
     mState.mSamplerState.setBorderColor(color);
-    signalDirtyState(context, DIRTY_BIT_BORDER_COLOR);
+    signalDirtyState(DIRTY_BIT_BORDER_COLOR);
 }
 
 const ColorGeneric &Texture::getBorderColor() const
@@ -1606,6 +1676,11 @@
     return id();
 }
 
+GLuint Texture::getNativeID() const
+{
+    return mTexture->getNativeID();
+}
+
 angle::Result Texture::syncState(const Context *context)
 {
     ASSERT(hasAnyDirtyBit());
@@ -1673,7 +1748,7 @@
     }
     if (anyDirty)
     {
-        signalDirtyStorage(context, InitState::Initialized);
+        signalDirtyStorage(InitState::Initialized);
     }
     mState.mInitState = InitState::Initialized;
 
@@ -1732,8 +1807,9 @@
 
     // Pre-initialize the texture contents if necessary.
     // TODO(jmadill): Check if area overlaps the entire texture.
-    ImageIndex imageIndex = ImageIndex::MakeFromTarget(target, static_cast<GLint>(level));
-    const auto &desc      = mState.getImageDesc(imageIndex);
+    ImageIndex imageIndex =
+        ImageIndex::MakeFromTarget(target, static_cast<GLint>(level), area.depth);
+    const auto &desc = mState.getImageDesc(imageIndex);
     if (desc.initState == InitState::MayNeedInit)
     {
         ASSERT(mState.mInitState == InitState::MayNeedInit);
@@ -1761,13 +1837,16 @@
     return angle::Result::Continue;
 }
 
-void Texture::onSubjectStateChange(const gl::Context *context,
-                                   angle::SubjectIndex index,
-                                   angle::SubjectMessage message)
+void Texture::onSubjectStateChange(angle::SubjectIndex index, angle::SubjectMessage message)
 {
-    if (message == angle::SubjectMessage::DEPENDENT_DIRTY_BITS)
+    ASSERT(message == angle::SubjectMessage::SubjectChanged);
+    mDirtyBits.set(DIRTY_BIT_IMPLEMENTATION);
+    signalDirtyState(DIRTY_BIT_IMPLEMENTATION);
+
+    // Notify siblings that we are dirty.
+    if (index == rx::kTextureImageImplObserverMessageIndex)
     {
-        mDirtyBits.set(DIRTY_BIT_IMPLEMENTATION);
+        notifySiblings(message);
     }
 }
 }  // namespace gl