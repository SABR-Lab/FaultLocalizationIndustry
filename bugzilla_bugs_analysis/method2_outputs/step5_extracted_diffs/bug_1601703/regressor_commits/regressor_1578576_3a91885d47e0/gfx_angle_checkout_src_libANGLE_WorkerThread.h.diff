# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/WorkerThread.h
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/WorkerThread.h
--- a/gfx/angle/checkout/src/libANGLE/WorkerThread.h	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/WorkerThread.h	Fri Nov 08 17:06:00 2019 +0000
@@ -21,6 +21,8 @@
 namespace angle
 {
 
+class WorkerThreadPool;
+
 // A callback function with no return value and no arguments.
 class Closure
 {
@@ -41,6 +43,7 @@
 
     // Peeks whether the event is ready. If ready, wait() will not block.
     virtual bool isReady() = 0;
+    void setWorkerThreadPool(std::shared_ptr<WorkerThreadPool> pool) { mPool = pool; }
 
     template <size_t Count>
     static void WaitMany(std::array<std::shared_ptr<WaitableEvent>, Count> *waitables)
@@ -51,6 +54,17 @@
             (*waitables)[index]->wait();
         }
     }
+
+  private:
+    std::shared_ptr<WorkerThreadPool> mPool;
+};
+
+// A dummy waitable event.
+class WaitableEventDone final : public WaitableEvent
+{
+  public:
+    void wait() override;
+    bool isReady() override;
 };
 
 // Request WorkerThreads from the WorkerThreadPool. Each pool can keep worker threads around so
@@ -62,14 +76,17 @@
     virtual ~WorkerThreadPool();
 
     static std::shared_ptr<WorkerThreadPool> Create(bool multithreaded);
-
-    // Returns an event to wait on for the task to finish.
-    // If the pool fails to create the task, returns null.
-    virtual std::shared_ptr<WaitableEvent> postWorkerTask(std::shared_ptr<Closure> task) = 0;
+    static std::shared_ptr<WaitableEvent> PostWorkerTask(std::shared_ptr<WorkerThreadPool> pool,
+                                                         std::shared_ptr<Closure> task);
 
     virtual void setMaxThreads(size_t maxThreads) = 0;
 
     virtual bool isAsync() = 0;
+
+  private:
+    // Returns an event to wait on for the task to finish.
+    // If the pool fails to create the task, returns null.
+    virtual std::shared_ptr<WaitableEvent> postWorkerTask(std::shared_ptr<Closure> task) = 0;
 };
 
 }  // namespace angle