# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/d3d/ShaderD3D.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/renderer/d3d/ShaderD3D.cpp
--- a/gfx/angle/checkout/src/libANGLE/renderer/d3d/ShaderD3D.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/d3d/ShaderD3D.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -11,6 +11,7 @@
 #include "common/utilities.h"
 #include "libANGLE/Caps.h"
 #include "libANGLE/Compiler.h"
+#include "libANGLE/Context.h"
 #include "libANGLE/Shader.h"
 #include "libANGLE/features.h"
 #include "libANGLE/renderer/d3d/ProgramD3D.h"
@@ -19,40 +20,110 @@
 namespace rx
 {
 
+class TranslateTaskD3D : public angle::Closure
+{
+  public:
+    TranslateTaskD3D(ShHandle handle,
+                     ShCompileOptions options,
+                     const std::string &source,
+                     const std::string &sourcePath)
+        : mHandle(handle),
+          mOptions(options),
+          mSource(source),
+          mSourcePath(sourcePath),
+          mResult(false)
+    {}
+
+    void operator()() override
+    {
+        std::vector<const char *> srcStrings;
+        if (!mSourcePath.empty())
+        {
+            srcStrings.push_back(mSourcePath.c_str());
+        }
+        srcStrings.push_back(mSource.c_str());
+
+        mResult = sh::Compile(mHandle, &srcStrings[0], srcStrings.size(), mOptions);
+    }
+
+    bool getResult() { return mResult; }
+
+  private:
+    ShHandle mHandle;
+    ShCompileOptions mOptions;
+    std::string mSource;
+    std::string mSourcePath;
+    bool mResult;
+};
+
+using PostTranslateFunctor =
+    std::function<bool(gl::ShCompilerInstance *compiler, std::string *infoLog)>;
+
+class WaitableCompileEventD3D final : public WaitableCompileEvent
+{
+  public:
+    WaitableCompileEventD3D(std::shared_ptr<angle::WaitableEvent> waitableEvent,
+                            gl::ShCompilerInstance *compilerInstance,
+                            PostTranslateFunctor &&postTranslateFunctor,
+                            std::shared_ptr<TranslateTaskD3D> translateTask)
+        : WaitableCompileEvent(waitableEvent),
+          mCompilerInstance(compilerInstance),
+          mPostTranslateFunctor(std::move(postTranslateFunctor)),
+          mTranslateTask(translateTask)
+    {}
+
+    bool getResult() override { return mTranslateTask->getResult(); }
+
+    bool postTranslate(std::string *infoLog) override
+    {
+        return mPostTranslateFunctor(mCompilerInstance, infoLog);
+    }
+
+  private:
+    gl::ShCompilerInstance *mCompilerInstance;
+    PostTranslateFunctor mPostTranslateFunctor;
+    std::shared_ptr<TranslateTaskD3D> mTranslateTask;
+};
+
 ShaderD3D::ShaderD3D(const gl::ShaderState &data,
-                     const angle::WorkaroundsD3D &workarounds,
+                     const angle::FeaturesD3D &features,
                      const gl::Extensions &extensions)
     : ShaderImpl(data), mAdditionalOptions(0)
 {
     uncompile();
 
-    if (workarounds.expandIntegerPowExpressions)
+    if (features.expandIntegerPowExpressions.enabled)
     {
         mAdditionalOptions |= SH_EXPAND_SELECT_HLSL_INTEGER_POW_EXPRESSIONS;
     }
 
-    if (workarounds.getDimensionsIgnoresBaseLevel)
+    if (features.getDimensionsIgnoresBaseLevel.enabled)
     {
         mAdditionalOptions |= SH_HLSL_GET_DIMENSIONS_IGNORES_BASE_LEVEL;
     }
 
-    if (workarounds.preAddTexelFetchOffsets)
+    if (features.preAddTexelFetchOffsets.enabled)
     {
         mAdditionalOptions |= SH_REWRITE_TEXELFETCHOFFSET_TO_TEXELFETCH;
     }
-    if (workarounds.rewriteUnaryMinusOperator)
+    if (features.rewriteUnaryMinusOperator.enabled)
     {
         mAdditionalOptions |= SH_REWRITE_INTEGER_UNARY_MINUS_OPERATOR;
     }
-    if (workarounds.emulateIsnanFloat)
+    if (features.emulateIsnanFloat.enabled)
     {
         mAdditionalOptions |= SH_EMULATE_ISNAN_FLOAT_FUNCTION;
     }
-    if (workarounds.skipVSConstantRegisterZero && mData.getShaderType() == gl::ShaderType::Vertex)
+    if (features.skipVSConstantRegisterZero.enabled &&
+        mData.getShaderType() == gl::ShaderType::Vertex)
     {
         mAdditionalOptions |= SH_SKIP_D3D_CONSTANT_REGISTER_ZERO;
     }
-    if (extensions.multiview2)
+    if (features.forceAtomicValueResolution.enabled)
+    {
+        mAdditionalOptions |= SH_FORCE_ATOMIC_VALUE_RESOLUTION;
+    }
+    if (extensions.multiview || extensions.multiview2)
     {
         mAdditionalOptions |= SH_INITIALIZE_BUILTINS_FOR_INSTANCED_MULTIVIEW;
     }
@@ -88,6 +159,7 @@
     mUsesDepthRange              = false;
     mUsesFragDepth               = false;
     mHasANGLEMultiviewEnabled    = false;
+    mUsesVertexID                = false;
     mUsesViewID                  = false;
     mUsesDiscardRewriting        = false;
     mUsesNestedBreak             = false;
@@ -155,36 +227,6 @@
     return mUsedImage2DFunctionNames.find(functionName) != mUsedImage2DFunctionNames.end();
 }
 
-ShCompileOptions ShaderD3D::prepareSourceAndReturnOptions(const gl::Context *context,
-                                                          std::stringstream *shaderSourceStream,
-                                                          std::string *sourcePath)
-{
-    uncompile();
-
-    ShCompileOptions additionalOptions = 0;
-
-    const std::string &source = mData.getSource();
-
-#if !defined(ANGLE_ENABLE_WINDOWS_STORE)
-    if (gl::DebugAnnotationsActive())
-    {
-        *sourcePath = getTempPath();
-        writeFile(sourcePath->c_str(), source.c_str(), source.length());
-        additionalOptions |= SH_LINE_DIRECTIVES | SH_SOURCE_PATH;
-    }
-#endif
-
-    additionalOptions |= mAdditionalOptions;
-
-    *shaderSourceStream << source;
-    return additionalOptions;
-}
-
-bool ShaderD3D::hasUniform(const std::string &name) const
-{
-    return mUniformRegisterMap.find(name) != mUniformRegisterMap.end();
-}
-
 const std::map<std::string, unsigned int> &GetUniformRegisterMap(
     const std::map<std::string, unsigned int> *uniformRegisterMap)
 {
@@ -199,72 +241,111 @@
     return *usedImage2DFunctionNames;
 }
 
-bool ShaderD3D::postTranslateCompile(gl::ShCompilerInstance *compiler, std::string *infoLog)
+std::shared_ptr<WaitableCompileEvent> ShaderD3D::compile(const gl::Context *context,
+                                                         gl::ShCompilerInstance *compilerInstance,
+                                                         ShCompileOptions options)
 {
-    // TODO(jmadill): We shouldn't need to cache this.
-    mCompilerOutputType = compiler->getShaderOutputType();
+    std::string sourcePath;
+    uncompile();
+
+    ShCompileOptions additionalOptions = 0;
+
+    const std::string &source = mData.getSource();
 
-    const std::string &translatedSource = mData.getTranslatedSource();
+#if !defined(ANGLE_ENABLE_WINDOWS_STORE)
+    if (gl::DebugAnnotationsActive())
+    {
+        sourcePath = getTempPath();
+        writeFile(sourcePath.c_str(), source.c_str(), source.length());
+        additionalOptions |= SH_LINE_DIRECTIVES | SH_SOURCE_PATH;
+    }
+#endif
+
+    additionalOptions |= mAdditionalOptions;
+
+    options |= additionalOptions;
 
-    mUsesMultipleRenderTargets = translatedSource.find("GL_USES_MRT") != std::string::npos;
-    mUsesFragColor             = translatedSource.find("GL_USES_FRAG_COLOR") != std::string::npos;
-    mUsesSecondaryColor        = translatedSource.find("GL_USES_SECONDARY_COLOR") != std::string::npos;
-    mUsesFragData              = translatedSource.find("GL_USES_FRAG_DATA") != std::string::npos;
-    mUsesFragCoord             = translatedSource.find("GL_USES_FRAG_COORD") != std::string::npos;
-    mUsesFrontFacing           = translatedSource.find("GL_USES_FRONT_FACING") != std::string::npos;
-    mUsesPointSize             = translatedSource.find("GL_USES_POINT_SIZE") != std::string::npos;
-    mUsesPointCoord            = translatedSource.find("GL_USES_POINT_COORD") != std::string::npos;
-    mUsesDepthRange            = translatedSource.find("GL_USES_DEPTH_RANGE") != std::string::npos;
-    mUsesFragDepth             = translatedSource.find("GL_USES_FRAG_DEPTH") != std::string::npos;
-    mHasANGLEMultiviewEnabled =
-        translatedSource.find("GL_ANGLE_MULTIVIEW_ENABLED") != std::string::npos;
-    mUsesViewID = translatedSource.find("GL_USES_VIEW_ID") != std::string::npos;
-    mUsesDiscardRewriting =
-        translatedSource.find("ANGLE_USES_DISCARD_REWRITING") != std::string::npos;
-    mUsesNestedBreak = translatedSource.find("ANGLE_USES_NESTED_BREAK") != std::string::npos;
-    mRequiresIEEEStrictCompiling =
-        translatedSource.find("ANGLE_REQUIRES_IEEE_STRICT_COMPILING") != std::string::npos;
+    auto postTranslateFunctor = [this](gl::ShCompilerInstance *compiler, std::string *infoLog) {
+        // TODO(jmadill): We shouldn't need to cache this.
+        mCompilerOutputType = compiler->getShaderOutputType();
+
+        const std::string &translatedSource = mData.getTranslatedSource();
 
-    ShHandle compilerHandle = compiler->getHandle();
+        mUsesMultipleRenderTargets = translatedSource.find("GL_USES_MRT") != std::string::npos;
+        mUsesFragColor      = translatedSource.find("GL_USES_FRAG_COLOR") != std::string::npos;
+        mUsesFragData       = translatedSource.find("GL_USES_FRAG_DATA") != std::string::npos;
+        mUsesSecondaryColor = translatedSource.find("GL_USES_SECONDARY_COLOR") != std::string::npos;
+        mUsesFragCoord      = translatedSource.find("GL_USES_FRAG_COORD") != std::string::npos;
+        mUsesFrontFacing    = translatedSource.find("GL_USES_FRONT_FACING") != std::string::npos;
+        mUsesPointSize      = translatedSource.find("GL_USES_POINT_SIZE") != std::string::npos;
+        mUsesPointCoord     = translatedSource.find("GL_USES_POINT_COORD") != std::string::npos;
+        mUsesDepthRange     = translatedSource.find("GL_USES_DEPTH_RANGE") != std::string::npos;
+        mUsesFragDepth      = translatedSource.find("GL_USES_FRAG_DEPTH") != std::string::npos;
+        mHasANGLEMultiviewEnabled =
+            translatedSource.find("GL_ANGLE_MULTIVIEW_ENABLED") != std::string::npos;
+        mUsesVertexID = translatedSource.find("GL_USES_VERTEX_ID") != std::string::npos;
+        mUsesViewID   = translatedSource.find("GL_USES_VIEW_ID") != std::string::npos;
+        mUsesDiscardRewriting =
+            translatedSource.find("ANGLE_USES_DISCARD_REWRITING") != std::string::npos;
+        mUsesNestedBreak = translatedSource.find("ANGLE_USES_NESTED_BREAK") != std::string::npos;
+        mRequiresIEEEStrictCompiling =
+            translatedSource.find("ANGLE_REQUIRES_IEEE_STRICT_COMPILING") != std::string::npos;
+
+        ShHandle compilerHandle = compiler->getHandle();
 
-    mUniformRegisterMap = GetUniformRegisterMap(sh::GetUniformRegisterMap(compilerHandle));
-    mReadonlyImage2DRegisterIndex = sh::GetReadonlyImage2DRegisterIndex(compilerHandle);
-    mImage2DRegisterIndex         = sh::GetImage2DRegisterIndex(compilerHandle);
-    mUsedImage2DFunctionNames =
-        GetUsedImage2DFunctionNames(sh::GetUsedImage2DFunctionNames(compilerHandle));
+        mUniformRegisterMap = GetUniformRegisterMap(sh::GetUniformRegisterMap(compilerHandle));
+        mReadonlyImage2DRegisterIndex = sh::GetReadonlyImage2DRegisterIndex(compilerHandle);
+        mImage2DRegisterIndex         = sh::GetImage2DRegisterIndex(compilerHandle);
+        mUsedImage2DFunctionNames =
+            GetUsedImage2DFunctionNames(sh::GetUsedImage2DFunctionNames(compilerHandle));
 
-    for (const sh::InterfaceBlock &interfaceBlock : mData.getUniformBlocks())
-    {
-        if (interfaceBlock.active)
+        for (const sh::InterfaceBlock &interfaceBlock : mData.getUniformBlocks())
         {
-            unsigned int index = static_cast<unsigned int>(-1);
-            bool blockRegisterResult =
-                sh::GetUniformBlockRegister(compilerHandle, interfaceBlock.name, &index);
-            ASSERT(blockRegisterResult);
+            if (interfaceBlock.active)
+            {
+                unsigned int index = static_cast<unsigned int>(-1);
+                bool blockRegisterResult =
+                    sh::GetUniformBlockRegister(compilerHandle, interfaceBlock.name, &index);
+                ASSERT(blockRegisterResult);
 
-            mUniformBlockRegisterMap[interfaceBlock.name] = index;
+                mUniformBlockRegisterMap[interfaceBlock.name] = index;
+            }
         }
-    }
 
-    for (const sh::InterfaceBlock &interfaceBlock : mData.getShaderStorageBlocks())
-    {
-        if (interfaceBlock.active)
+        for (const sh::InterfaceBlock &interfaceBlock : mData.getShaderStorageBlocks())
         {
-            unsigned int index = static_cast<unsigned int>(-1);
-            bool blockRegisterResult =
-                sh::GetShaderStorageBlockRegister(compilerHandle, interfaceBlock.name, &index);
-            ASSERT(blockRegisterResult);
+            if (interfaceBlock.active)
+            {
+                unsigned int index = static_cast<unsigned int>(-1);
+                bool blockRegisterResult =
+                    sh::GetShaderStorageBlockRegister(compilerHandle, interfaceBlock.name, &index);
+                ASSERT(blockRegisterResult);
+
+                mShaderStorageBlockRegisterMap[interfaceBlock.name] = index;
+            }
+        }
 
-            mShaderStorageBlockRegisterMap[interfaceBlock.name] = index;
-        }
-    }
+        mDebugInfo +=
+            std::string("// ") + gl::GetShaderTypeString(mData.getShaderType()) + " SHADER BEGIN\n";
+        mDebugInfo += "\n// GLSL BEGIN\n\n" + mData.getSource() + "\n\n// GLSL END\n\n\n";
+        mDebugInfo +=
+            "// INITIAL HLSL BEGIN\n\n" + translatedSource + "\n// INITIAL HLSL END\n\n\n";
+        // Successive steps will append more info
+        return true;
+    };
 
-    mDebugInfo +=
-        std::string("// ") + gl::GetShaderTypeString(mData.getShaderType()) + " SHADER BEGIN\n";
-    mDebugInfo += "\n// GLSL BEGIN\n\n" + mData.getSource() + "\n\n// GLSL END\n\n\n";
-    mDebugInfo += "// INITIAL HLSL BEGIN\n\n" + translatedSource + "\n// INITIAL HLSL END\n\n\n";
-    // Successive steps will append more info
-    return true;
+    auto workerThreadPool = context->getWorkerThreadPool();
+    auto translateTask = std::make_shared<TranslateTaskD3D>(compilerInstance->getHandle(), options,
+                                                            source, sourcePath);
+
+    return std::make_shared<WaitableCompileEventD3D>(
+        angle::WorkerThreadPool::PostWorkerTask(workerThreadPool, translateTask), compilerInstance,
+        std::move(postTranslateFunctor), translateTask);
+}
+
+bool ShaderD3D::hasUniform(const std::string &name) const
+{
+    return mUniformRegisterMap.find(name) != mUniformRegisterMap.end();
 }
 
 }  // namespace rx