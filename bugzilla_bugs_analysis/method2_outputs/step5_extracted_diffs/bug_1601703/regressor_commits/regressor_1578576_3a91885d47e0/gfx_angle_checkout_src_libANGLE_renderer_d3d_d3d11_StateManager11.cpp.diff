# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/StateManager11.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/StateManager11.cpp
--- a/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/StateManager11.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/renderer/d3d/d3d11/StateManager11.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -8,6 +8,7 @@
 
 #include "libANGLE/renderer/d3d/d3d11/StateManager11.h"
 
+#include "common/angleutils.h"
 #include "common/bitset_utils.h"
 #include "common/mathutil.h"
 #include "common/utilities.h"
@@ -100,6 +101,47 @@
     return false;
 }
 
+bool ImageIndexConflictsWithUAV(const gl::ImageIndex &index, D3D11_UNORDERED_ACCESS_VIEW_DESC desc)
+{
+    unsigned mipLevel           = index.getLevelIndex();
+    gl::TextureType textureType = index.getType();
+
+    switch (desc.ViewDimension)
+    {
+        case D3D11_UAV_DIMENSION_TEXTURE2D:
+        {
+            return textureType == gl::TextureType::_2D && mipLevel == desc.Texture2D.MipSlice;
+        }
+
+        case D3D11_UAV_DIMENSION_TEXTURE2DARRAY:
+        {
+            GLint layerIndex         = index.getLayerIndex();
+            unsigned mipSlice        = desc.Texture2DArray.MipSlice;
+            unsigned firstArraySlice = desc.Texture2DArray.FirstArraySlice;
+            unsigned lastArraySlice  = firstArraySlice + desc.Texture2DArray.ArraySize;
+
+            return (textureType == gl::TextureType::_2DArray ||
+                    textureType == gl::TextureType::CubeMap) &&
+                   (mipLevel == mipSlice && gl::RangeUI(firstArraySlice, lastArraySlice)
+                                                .contains(static_cast<UINT>(layerIndex)));
+        }
+
+        case D3D11_UAV_DIMENSION_TEXTURE3D:
+        {
+            GLint layerIndex     = index.getLayerIndex();
+            unsigned mipSlice    = desc.Texture3D.MipSlice;
+            unsigned firstWSlice = desc.Texture3D.FirstWSlice;
+            unsigned lastWSlice  = firstWSlice + desc.Texture3D.WSize;
+
+            return textureType == gl::TextureType::_3D &&
+                   (mipLevel == mipSlice &&
+                    gl::RangeUI(firstWSlice, lastWSlice).contains(static_cast<UINT>(layerIndex)));
+        }
+        default:
+            return false;
+    }
+}
+
 // Does *not* increment the resource ref count!!
 ID3D11Resource *GetViewResource(ID3D11View *view)
 {
@@ -405,12 +447,19 @@
 bool ShaderConstants11::updateImageMetadata(ImageMetadata *data, const gl::ImageUnit &imageUnit)
 {
     bool dirty = false;
+
     if (data->layer != static_cast<int>(imageUnit.layer))
     {
         data->layer = static_cast<int>(imageUnit.layer);
         dirty       = true;
     }
 
+    if (data->level != static_cast<unsigned int>(imageUnit.level))
+    {
+        data->level = static_cast<unsigned int>(imageUnit.level);
+        dirty       = true;
+    }
+
     return dirty;
 }
 
@@ -489,6 +538,19 @@
     mVertex.viewScale[1] = mPixel.viewScale[1];
 }
 
+// Update the ShaderConstants with a new first vertex and return whether the update dirties them.
+ANGLE_INLINE bool ShaderConstants11::onFirstVertexChange(GLint firstVertex)
+{
+    uint32_t newFirstVertex = static_cast<uint32_t>(firstVertex);
+    bool firstVertexDirty   = (mVertex.firstVertex != newFirstVertex);
+    if (firstVertexDirty)
+    {
+        mVertex.firstVertex = newFirstVertex;
+        mShaderConstantsDirty.set(gl::ShaderType::Vertex);
+    }
+    return firstVertexDirty;
+}
+
 void ShaderConstants11::onSamplerChange(gl::ShaderType shaderType,
                                         unsigned int samplerIndex,
                                         const gl::Texture &texture,
@@ -676,9 +738,14 @@
     mCurRasterState.pointDrawMode       = false;
     mCurRasterState.multiSample         = false;
 
-    // Start with all internal dirty bits set.
+    // Start with all internal dirty bits set except DIRTY_BIT_COMPUTE_SRVUAV_STATE and
+    // DIRTY_BIT_GRAPHICS_SRVUAV_STATE.
     mInternalDirtyBits.set();
-
+    mInternalDirtyBits.reset(DIRTY_BIT_GRAPHICS_SRVUAV_STATE);
+    mInternalDirtyBits.reset(DIRTY_BIT_COMPUTE_SRVUAV_STATE);
+
+    mGraphicsDirtyBitsMask.set();
+    mGraphicsDirtyBitsMask.reset(DIRTY_BIT_COMPUTE_SRVUAV_STATE);
     mComputeDirtyBitsMask.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
     mComputeDirtyBitsMask.set(DIRTY_BIT_PROGRAM_UNIFORMS);
     mComputeDirtyBitsMask.set(DIRTY_BIT_DRIVER_UNIFORMS);
@@ -686,6 +753,7 @@
     mComputeDirtyBitsMask.set(DIRTY_BIT_PROGRAM_ATOMIC_COUNTER_BUFFERS);
     mComputeDirtyBitsMask.set(DIRTY_BIT_PROGRAM_SHADER_STORAGE_BUFFERS);
     mComputeDirtyBitsMask.set(DIRTY_BIT_SHADERS);
+    mComputeDirtyBitsMask.set(DIRTY_BIT_COMPUTE_SRVUAV_STATE);
 
     // Initially all current value attributes must be updated on first use.
     mDirtyCurrentValueAttribs.set();
@@ -710,6 +778,13 @@
     {
         ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
         ID3D11ShaderResourceView *srvPtr   = srv ? srv->get() : nullptr;
+        if (srvPtr)
+        {
+            uintptr_t resource = reinterpret_cast<uintptr_t>(GetViewResource(srvPtr));
+            unsetConflictingUAVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Compute,
+                                 resource, nullptr);
+        }
+
         switch (shaderType)
         {
             case gl::ShaderType::Vertex:
@@ -719,8 +794,15 @@
                 deviceContext->PSSetShaderResources(resourceSlot, 1, &srvPtr);
                 break;
             case gl::ShaderType::Compute:
+            {
+                if (srvPtr)
+                {
+                    uintptr_t resource = reinterpret_cast<uintptr_t>(GetViewResource(srvPtr));
+                    unsetConflictingRTVs(resource);
+                }
                 deviceContext->CSSetShaderResources(resourceSlot, 1, &srvPtr);
                 break;
+            }
             default:
                 UNREACHABLE();
         }
@@ -744,9 +826,15 @@
         ID3D11UnorderedAccessView *uavPtr  = uav ? uav->get() : nullptr;
         // We need to make sure that resource being set to UnorderedAccessView slot |resourceSlot|
         // is not bound on SRV.
-        if (uavPtr && unsetConflictingView(uavPtr))
+        if (uavPtr)
         {
-            mInternalDirtyBits.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
+            uintptr_t resource = reinterpret_cast<uintptr_t>(GetViewResource(uavPtr));
+            unsetConflictingSRVs(gl::PipelineType::ComputePipeline, gl::ShaderType::Vertex,
+                                 resource, nullptr, false);
+            unsetConflictingSRVs(gl::PipelineType::ComputePipeline, gl::ShaderType::Fragment,
+                                 resource, nullptr, false);
+            unsetConflictingSRVs(gl::PipelineType::ComputePipeline, gl::ShaderType::Compute,
+                                 resource, nullptr, false);
         }
         deviceContext->CSSetUnorderedAccessViews(resourceSlot, 1, &uavPtr, nullptr);
 
@@ -770,7 +858,7 @@
         return;
 
     const auto *framebuffer          = context->getState().getDrawFramebuffer();
-    const auto *firstColorAttachment = framebuffer->getFirstColorbuffer();
+    const auto *firstColorAttachment = framebuffer->getFirstColorAttachment();
     const bool presentPathFastActive = UsePresentPathFast(mRenderer, firstColorAttachment);
 
     const int colorBufferHeight = firstColorAttachment ? firstColorAttachment->getSize().height : 0;
@@ -817,10 +905,16 @@
 
     auto dirtyBitsCopy = mInternalDirtyBits & mComputeDirtyBitsMask;
     mInternalDirtyBits &= ~mComputeDirtyBitsMask;
-    for (auto dirtyBit : dirtyBitsCopy)
+
+    for (auto iter = dirtyBitsCopy.begin(), end = dirtyBitsCopy.end(); iter != end; ++iter)
     {
-        switch (dirtyBit)
+        switch (*iter)
         {
+            case DIRTY_BIT_COMPUTE_SRVUAV_STATE:
+                // Avoid to call syncTexturesForCompute function two times.
+                iter.resetLaterBit(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
+                ANGLE_TRY(syncTexturesForCompute(context));
+                break;
             case DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE:
                 ANGLE_TRY(syncTexturesForCompute(context));
                 break;
@@ -1069,10 +1163,7 @@
                 }
                 break;
             case gl::State::DIRTY_BIT_DEPTH_RANGE:
-                if (state.getNearPlane() != mCurNear || state.getFarPlane() != mCurFar)
-                {
-                    invalidateViewport(context);
-                }
+                invalidateViewport(context);
                 break;
             case gl::State::DIRTY_BIT_VIEWPORT:
                 if (state.getViewport() != mCurViewport)
@@ -1128,24 +1219,30 @@
                 break;
             case gl::State::DIRTY_BIT_PROGRAM_EXECUTABLE:
             {
-                mInternalDirtyBits.set(DIRTY_BIT_PRIMITIVE_TOPOLOGY);
                 invalidateShaders();
-                invalidateVertexBuffer();
-                invalidateRenderTarget();
                 invalidateTexturesAndSamplers();
                 invalidateProgramUniforms();
                 invalidateProgramUniformBuffers();
                 invalidateProgramAtomicCounterBuffers();
                 invalidateProgramShaderStorageBuffers();
                 invalidateDriverUniforms();
-                // If OVR_multiview2 is enabled, the attribute divisor has to be updated for each
-                // binding. When using compute, there could be no vertex array.
-                if (mIsMultiviewEnabled && mVertexArray11)
+                const gl::Program *program = state.getProgram();
+                if (!program || !program->hasLinkedShaderStage(gl::ShaderType::Compute))
                 {
-                    ASSERT(mProgramD3D);
-                    const gl::ProgramState &programState = mProgramD3D->getState();
-                    int numViews = programState.usesMultiview() ? programState.getNumViews() : 1;
-                    mVertexArray11->markAllAttributeDivisorsForAdjustment(numViews);
+                    mInternalDirtyBits.set(DIRTY_BIT_PRIMITIVE_TOPOLOGY);
+                    invalidateVertexBuffer();
+                    invalidateRenderTarget();
+                    // If OVR_multiview2 is enabled, the attribute divisor has to be updated for
+                    // each binding. When using compute, there could be no vertex array.
+                    if (mIsMultiviewEnabled && mVertexArray11)
+                    {
+                        ASSERT(mProgramD3D);
+                        ASSERT(mVertexArray11 == GetImplAs<VertexArray11>(state.getVertexArray()));
+                        const gl::ProgramState &programState = mProgramD3D->getState();
+                        int numViews =
+                            programState.usesMultiview() ? programState.getNumViews() : 1;
+                        mVertexArray11->markAllAttributeDivisorsForAdjustment(numViews);
+                    }
                 }
                 break;
             }
@@ -1618,12 +1715,19 @@
 
 void StateManager11::setRenderTarget(ID3D11RenderTargetView *rtv, ID3D11DepthStencilView *dsv)
 {
-    if ((rtv && unsetConflictingView(rtv)) || (dsv && unsetConflictingView(dsv)))
+    if (rtv)
     {
-        mInternalDirtyBits.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
+        unsetConflictingView(gl::PipelineType::GraphicsPipeline, rtv, true);
+    }
+
+    if (dsv)
+    {
+        unsetConflictingView(gl::PipelineType::GraphicsPipeline, dsv, true);
     }
 
     mRenderer->getDeviceContext()->OMSetRenderTargets(1, &rtv, dsv);
+    mCurRTVs.clear();
+    mCurRTVs.update(0, rtv);
     mInternalDirtyBits.set(DIRTY_BIT_RENDER_TARGET);
 }
 
@@ -1631,24 +1735,22 @@
                                       UINT numRTVs,
                                       ID3D11DepthStencilView *dsv)
 {
-    bool anyDirty = false;
-
     for (UINT rtvIndex = 0; rtvIndex < numRTVs; ++rtvIndex)
     {
-        anyDirty = anyDirty || unsetConflictingView(rtvs[rtvIndex]);
+        unsetConflictingView(gl::PipelineType::GraphicsPipeline, rtvs[rtvIndex], true);
     }
 
     if (dsv)
     {
-        anyDirty = anyDirty || unsetConflictingView(dsv);
-    }
-
-    if (anyDirty)
-    {
-        mInternalDirtyBits.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
+        unsetConflictingView(gl::PipelineType::GraphicsPipeline, dsv, true);
     }
 
     mRenderer->getDeviceContext()->OMSetRenderTargets(numRTVs, (numRTVs > 0) ? rtvs : nullptr, dsv);
+    mCurRTVs.clear();
+    for (UINT i = 0; i < numRTVs; i++)
+    {
+        mCurRTVs.update(i, rtvs[i]);
+    }
     mInternalDirtyBits.set(DIRTY_BIT_RENDER_TARGET);
 }
 
@@ -1687,102 +1789,37 @@
         }
     }
 
-    return angle::Result::Continue;
-}
-
-angle::Result StateManager11::clearSRVs(gl::ShaderType shaderType,
-                                        size_t rangeStart,
-                                        size_t rangeEnd)
-{
-    if (rangeStart == rangeEnd)
-    {
-        return angle::Result::Continue;
-    }
-
-    auto *currentSRVs = getSRVCache(shaderType);
-    gl::Range<size_t> clearRange(rangeStart, std::min(rangeEnd, currentSRVs->highestUsed()));
-    if (clearRange.empty())
-    {
-        return angle::Result::Continue;
-    }
-
-    ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
-    switch (shaderType)
-    {
-        case gl::ShaderType::Vertex:
-            deviceContext->VSSetShaderResources(static_cast<unsigned int>(clearRange.low()),
-                                                static_cast<unsigned int>(clearRange.length()),
-                                                &mNullSRVs[0]);
-            break;
-        case gl::ShaderType::Fragment:
-            deviceContext->PSSetShaderResources(static_cast<unsigned int>(clearRange.low()),
-                                                static_cast<unsigned int>(clearRange.length()),
-                                                &mNullSRVs[0]);
-            break;
-        case gl::ShaderType::Compute:
-            deviceContext->CSSetShaderResources(static_cast<unsigned int>(clearRange.low()),
-                                                static_cast<unsigned int>(clearRange.length()),
-                                                &mNullSRVs[0]);
-            break;
-        default:
-            UNREACHABLE();
-            break;
-    }
-
-    for (size_t samplerIndex : clearRange)
-    {
-        currentSRVs->update(samplerIndex, nullptr);
-    }
+    // Reset the cache objects.
+    mProgramD3D    = nullptr;
+    mVertexArray11 = nullptr;
+    mFramebuffer11 = nullptr;
 
     return angle::Result::Continue;
 }
 
-angle::Result StateManager11::clearUAVs(gl::ShaderType shaderType,
-                                        size_t rangeStart,
-                                        size_t rangeEnd)
-{
-    ASSERT(shaderType == gl::ShaderType::Compute);
-    if (rangeStart == rangeEnd)
-    {
-        return angle::Result::Continue;
-    }
-
-    gl::Range<size_t> clearRange(rangeStart, std::min(rangeEnd, mCurComputeUAVs.highestUsed()));
-    if (clearRange.empty())
-    {
-        return angle::Result::Continue;
-    }
-
-    ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
-    deviceContext->CSSetUnorderedAccessViews(static_cast<unsigned int>(clearRange.low()),
-                                             static_cast<unsigned int>(clearRange.length()),
-                                             &mNullUAVs[0], nullptr);
-
-    for (size_t index : clearRange)
-    {
-        mCurComputeUAVs.update(index, nullptr);
-    }
-
-    return angle::Result::Continue;
-}
-
-bool StateManager11::unsetConflictingView(ID3D11View *view)
+void StateManager11::unsetConflictingView(gl::PipelineType pipeline,
+                                          ID3D11View *view,
+                                          bool isRenderTarget)
 {
     uintptr_t resource = reinterpret_cast<uintptr_t>(GetViewResource(view));
-    return unsetConflictingSRVs(gl::ShaderType::Vertex, resource, nullptr) ||
-           unsetConflictingSRVs(gl::ShaderType::Fragment, resource, nullptr) ||
-           unsetConflictingSRVs(gl::ShaderType::Compute, resource, nullptr);
+
+    unsetConflictingSRVs(pipeline, gl::ShaderType::Vertex, resource, nullptr, isRenderTarget);
+    unsetConflictingSRVs(pipeline, gl::ShaderType::Fragment, resource, nullptr, isRenderTarget);
+    unsetConflictingSRVs(pipeline, gl::ShaderType::Compute, resource, nullptr, isRenderTarget);
+    unsetConflictingUAVs(pipeline, gl::ShaderType::Compute, resource, nullptr);
 }
 
-bool StateManager11::unsetConflictingSRVs(gl::ShaderType shaderType,
+void StateManager11::unsetConflictingSRVs(gl::PipelineType pipeline,
+                                          gl::ShaderType shaderType,
                                           uintptr_t resource,
-                                          const gl::ImageIndex *index)
+                                          const gl::ImageIndex *index,
+                                          bool isRenderTarget)
 {
-    auto *currentSRVs = getSRVCache(shaderType);
-
-    bool foundOne = false;
-
-    for (size_t resourceIndex = 0; resourceIndex < currentSRVs->size(); ++resourceIndex)
+    auto *currentSRVs                 = getSRVCache(shaderType);
+    gl::PipelineType conflictPipeline = gl::GetPipelineType(shaderType);
+    bool foundOne                     = false;
+    size_t count                      = std::min(currentSRVs->size(), currentSRVs->highestUsed());
+    for (size_t resourceIndex = 0; resourceIndex < count; ++resourceIndex)
     {
         auto &record = (*currentSRVs)[resourceIndex];
 
@@ -1795,7 +1832,67 @@
         }
     }
 
-    return foundOne;
+    if (foundOne && (pipeline != conflictPipeline || isRenderTarget))
+    {
+        switch (conflictPipeline)
+        {
+            case gl::PipelineType::GraphicsPipeline:
+                mInternalDirtyBits.set(DIRTY_BIT_GRAPHICS_SRVUAV_STATE);
+                break;
+            case gl::PipelineType::ComputePipeline:
+                mInternalDirtyBits.set(DIRTY_BIT_COMPUTE_SRVUAV_STATE);
+                break;
+            default:
+                UNREACHABLE();
+        }
+    }
+}
+
+void StateManager11::unsetConflictingUAVs(gl::PipelineType pipeline,
+                                          gl::ShaderType shaderType,
+                                          uintptr_t resource,
+                                          const gl::ImageIndex *index)
+{
+    ASSERT(shaderType == gl::ShaderType::Compute);
+    bool foundOne = false;
+
+    ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
+    size_t count = std::min(mCurComputeUAVs.size(), mCurComputeUAVs.highestUsed());
+    for (size_t resourceIndex = 0; resourceIndex < count; ++resourceIndex)
+    {
+        auto &record = mCurComputeUAVs[resourceIndex];
+
+        if (record.view && record.resource == resource &&
+            (!index || ImageIndexConflictsWithUAV(*index, record.desc)))
+        {
+            deviceContext->CSSetUnorderedAccessViews(resourceIndex, 1, &mNullUAVs[0], nullptr);
+            mCurComputeUAVs.update(resourceIndex, nullptr);
+            foundOne = true;
+        }
+    }
+
+    if (foundOne && pipeline == gl::PipelineType::GraphicsPipeline)
+    {
+        mInternalDirtyBits.set(DIRTY_BIT_COMPUTE_SRVUAV_STATE);
+    }
+}
+
+void StateManager11::unsetConflictingRTVs(uintptr_t resource)
+{
+    ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
+    size_t count                       = std::min(mCurRTVs.size(), mCurRTVs.highestUsed());
+    for (size_t resourceIndex = 0; resourceIndex < count; ++resourceIndex)
+    {
+        auto &record = mCurRTVs[resourceIndex];
+
+        if (record.view && record.resource == resource)
+        {
+            deviceContext->OMSetRenderTargets(0, nullptr, nullptr);
+            mCurRTVs.clear();
+            mInternalDirtyBits.set(DIRTY_BIT_RENDER_TARGET);
+            return;
+        }
+    }
 }
 
 void StateManager11::unsetConflictingAttachmentResources(
@@ -1809,14 +1906,26 @@
         const gl::ImageIndex &index = attachment.getTextureImageIndex();
         // The index doesn't need to be corrected for the small compressed texture workaround
         // because a rendertarget is never compressed.
-        unsetConflictingSRVs(gl::ShaderType::Vertex, resourcePtr, &index);
-        unsetConflictingSRVs(gl::ShaderType::Fragment, resourcePtr, &index);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Vertex,
+                             resourcePtr, &index, false);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Fragment,
+                             resourcePtr, &index, false);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Compute,
+                             resourcePtr, &index, false);
+        unsetConflictingUAVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Compute,
+                             resourcePtr, &index);
     }
     else if (attachment.type() == GL_FRAMEBUFFER_DEFAULT)
     {
         uintptr_t resourcePtr = reinterpret_cast<uintptr_t>(resource);
-        unsetConflictingSRVs(gl::ShaderType::Vertex, resourcePtr, nullptr);
-        unsetConflictingSRVs(gl::ShaderType::Fragment, resourcePtr, nullptr);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Vertex,
+                             resourcePtr, nullptr, false);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Fragment,
+                             resourcePtr, nullptr, false);
+        unsetConflictingSRVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Compute,
+                             resourcePtr, nullptr, false);
+        unsetConflictingUAVs(gl::PipelineType::GraphicsPipeline, gl::ShaderType::Compute,
+                             resourcePtr, nullptr);
     }
 }
 
@@ -1835,7 +1944,7 @@
         mForceSetShaderSamplerStates[shaderType].resize(maxShaderTextureImageUnits, true);
         mCurShaderSamplerStates[shaderType].resize(maxShaderTextureImageUnits);
     }
-
+    mCurRTVs.initialize(caps.maxColorAttachments);
     mCurComputeUAVs.initialize(caps.maxImageUnits);
 
     // Initialize cached NULL SRV block
@@ -1847,7 +1956,7 @@
 
     mShaderConstants.init(caps);
 
-    mIsMultiviewEnabled = extensions.multiview2;
+    mIsMultiviewEnabled = extensions.multiview || extensions.multiview2;
 
     ANGLE_TRY(mVertexDataManager.initialize(context));
 
@@ -1893,7 +2002,7 @@
     const auto &colorRTs     = mFramebuffer11->getCachedColorRenderTargets();
 
     size_t appliedRTIndex                   = 0;
-    bool skipInactiveRTs                    = mRenderer->getWorkarounds().mrtPerfWorkaround;
+    bool skipInactiveRTs                    = mRenderer->getFeatures().mrtPerfWorkaround.enabled;
     const auto &drawStates                  = mFramebuffer11->getState().getDrawBufferStates();
     gl::DrawBufferMask activeProgramOutputs = mProgramD3D->getState().getActiveOutputVariables();
     UINT maxExistingRT                      = 0;
@@ -1946,7 +2055,11 @@
     // Apply the render target and depth stencil
     mRenderer->getDeviceContext()->OMSetRenderTargets(maxExistingRT, framebufferRTVs.data(),
                                                       framebufferDSV);
-
+    mCurRTVs.clear();
+    for (UINT i = 0; i < maxExistingRT; i++)
+    {
+        mCurRTVs.update(i, framebufferRTVs[i]);
+    }
     return angle::Result::Continue;
 }
 
@@ -2134,6 +2247,15 @@
         invalidateInputLayout();
     }
 
+    // The ShaderConstants only need to be updated when the program uses vertexID
+    if (mProgramD3D->usesVertexID())
+    {
+        if (mShaderConstants.onFirstVertexChange(firstVertex))
+        {
+            mInternalDirtyBits.set(DIRTY_BIT_DRIVER_UNIFORMS);
+        }
+    }
+
     if (indexTypeOrInvalid != gl::DrawElementsType::InvalidEnum)
     {
         ANGLE_TRY(applyIndexBuffer(context, vertexOrIndexCount, indexTypeOrInvalid, indices));
@@ -2154,12 +2276,12 @@
         }
     }
 
-    auto dirtyBitsCopy = mInternalDirtyBits;
-    mInternalDirtyBits.reset();
-
-    for (auto dirtyBit : dirtyBitsCopy)
+    auto dirtyBitsCopy = mInternalDirtyBits & mGraphicsDirtyBitsMask;
+    mInternalDirtyBits &= ~mGraphicsDirtyBitsMask;
+
+    for (auto iter = dirtyBitsCopy.begin(), end = dirtyBitsCopy.end(); iter != end; ++iter)
     {
-        switch (dirtyBit)
+        switch (*iter)
         {
             case DIRTY_BIT_RENDER_TARGET:
                 ANGLE_TRY(syncFramebuffer(context));
@@ -2180,6 +2302,10 @@
             case DIRTY_BIT_DEPTH_STENCIL_STATE:
                 ANGLE_TRY(syncDepthStencilState(context));
                 break;
+            case DIRTY_BIT_GRAPHICS_SRVUAV_STATE:
+                iter.resetLaterBit(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
+                ANGLE_TRY(syncTextures(context));
+                break;
             case DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE:
                 // TODO(jmadill): More fine-grained update.
                 ANGLE_TRY(syncTextures(context));
@@ -2223,8 +2349,9 @@
         }
     }
 
-    // Check that we haven't set any dirty bits in the flushing of the dirty bits loop.
-    ASSERT(mInternalDirtyBits.none());
+    // Check that we haven't set any dirty bits in the flushing of the dirty bits loop, except
+    // DIRTY_BIT_COMPUTE_SRVUAV_STATE dirty bit.
+    ASSERT((mInternalDirtyBits & mGraphicsDirtyBitsMask).none());
 
     return angle::Result::Continue;
 }
@@ -2683,15 +2810,6 @@
         ANGLE_TRY(setTextureForImage(context, shaderType, readonlyImageIndex, true, imageUnit));
     }
 
-    size_t samplerCount = caps.maxShaderTextureImageUnits[shaderType];
-    size_t readonlyImageCount =
-        context->getClientVersion() >= gl::Version(3, 1) ? caps.maxImageUnits : 0;
-
-    // Samplers and readonly images share the SRVs here, their range is
-    // [0, max(samplerRange.high(), readonlyImageRange.high()).
-    ANGLE_TRY(clearSRVs(shaderType, std::max(samplerRange.high(), readonlyImageRange.high()),
-                        samplerCount + readonlyImageCount));
-
     return angle::Result::Continue;
 }
 
@@ -2717,18 +2835,11 @@
         ANGLE_TRY(setTextureForImage(context, shaderType, imageIndex, false, imageUnit));
     }
 
-    size_t imageCount = caps.maxImageUnits;
-    ANGLE_TRY(clearUAVs(shaderType, imageRange.high(), imageCount));
-
     return angle::Result::Continue;
 }
 
 angle::Result StateManager11::syncTexturesForCompute(const gl::Context *context)
 {
-    // applyTexturesForUAVs must be earlier than applyTexturesForSRVs since we need to do clearUVAs
-    // before set resources to SRVs. Otherwise, it will report the following error:
-    // ID3D11DeviceContext::CSSetShaderResources: Resource being set to CS shader resource slot 0 is
-    // still bound on output! Forcing to NULL.
     ANGLE_TRY(applyTexturesForUAVs(context, gl::ShaderType::Compute));
     ANGLE_TRY(applyTexturesForSRVs(context, gl::ShaderType::Compute));
     return angle::Result::Continue;
@@ -2743,6 +2854,21 @@
     TextureD3D *textureImpl = nullptr;
     if (!imageUnit.texture.get())
     {
+        // The texture is used in shader. However, there is no resource binding to it. We
+        // should clear the corresponding UAV/SRV in case the previous view type is a buffer not a
+        // texture. Otherwise, below error will be reported. The Unordered Access View dimension
+        // declared in the shader code (TEXTURE2D) does not match the view type bound to slot 0
+        // of the Compute Shader unit (BUFFER).
+        if (readonly)
+        {
+            setShaderResourceInternal<d3d11::ShaderResourceView>(type, static_cast<UINT>(index),
+                                                                 nullptr);
+        }
+        else
+        {
+            setUnorderedAccessViewInternal<d3d11::UnorderedAccessView>(
+                type, static_cast<UINT>(index), nullptr);
+        }
         return angle::Result::Continue;
     }
 
@@ -3547,14 +3673,26 @@
 {
     const gl::State &glState   = context->getState();
     const gl::Program *program = glState.getProgram();
-    angle::FixedVector<Buffer11 *, gl::IMPLEMENTATION_MAX_DRAW_BUFFERS> previouslyBound;
+    angle::FixedVector<Buffer11 *, gl::IMPLEMENTATION_MAX_SHADER_STORAGE_BUFFER_BINDINGS>
+        previouslyBound;
     for (size_t blockIndex = 0; blockIndex < program->getActiveShaderStorageBlockCount();
          blockIndex++)
     {
         GLuint binding = program->getShaderStorageBlockBinding(static_cast<GLuint>(blockIndex));
+        const unsigned int registerIndex = mProgramD3D->getShaderStorageBufferRegisterIndex(
+            static_cast<GLuint>(blockIndex), shaderType);
+        // It means this block is active but not statically used.
+        if (registerIndex == GL_INVALID_INDEX)
+        {
+            continue;
+        }
         const auto &shaderStorageBuffer = glState.getIndexedShaderStorageBuffer(binding);
         if (shaderStorageBuffer.get() == nullptr)
         {
+            // We didn't see a driver error like atomic buffer did. But theoretically, the same
+            // thing should be done.
+            setUnorderedAccessViewInternal<d3d11::UnorderedAccessView>(shaderType, registerIndex,
+                                                                       nullptr);
             continue;
         }
 
@@ -3584,29 +3722,11 @@
         ANGLE_TRY(bufferStorage->getRawUAVRange(context, shaderStorageBuffer.getOffset(), viewSize,
                                                 &uavPtr));
 
-        // We need to make sure that resource being set to UnorderedAccessView slot |registerIndex|
-        // is not bound on SRV.
-        if (uavPtr && unsetConflictingView(uavPtr->get()))
-        {
-            mInternalDirtyBits.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
-        }
-
-        const unsigned int registerIndex = mProgramD3D->getShaderStorageBufferRegisterIndex(
-            static_cast<GLuint>(blockIndex), shaderType);
-
-        // It means this block is active but not statically used.
-        if (registerIndex == GL_INVALID_INDEX)
-        {
-            continue;
-        }
-
         switch (shaderType)
         {
             case gl::ShaderType::Compute:
             {
-                ID3D11UnorderedAccessView *uav     = uavPtr->get();
-                ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
-                deviceContext->CSSetUnorderedAccessViews(registerIndex, 1, &uav, nullptr);
+                setUnorderedAccessViewInternal(shaderType, registerIndex, uavPtr);
                 break;
             }
 
@@ -3665,9 +3785,18 @@
     {
         GLuint binding     = atomicCounterBuffer.binding;
         const auto &buffer = glState.getIndexedAtomicCounterBuffer(binding);
-
+        const unsigned int registerIndex =
+            mProgramD3D->getAtomicCounterBufferRegisterIndex(binding, shaderType);
+        ASSERT(registerIndex != GL_INVALID_INDEX);
         if (buffer.get() == nullptr)
         {
+            // The atomic counter is used in shader. However, there is no buffer binding to it. We
+            // should clear the corresponding UAV in case the previous view type is a texture not a
+            // buffer. Otherwise, below error will be reported. The Unordered Access View dimension
+            // declared in the shader code (BUFFER) does not match the view type bound to slot 0
+            // of the Compute Shader unit (TEXTURE2D).
+            setUnorderedAccessViewInternal<d3d11::UnorderedAccessView>(shaderType, registerIndex,
+                                                                       nullptr);
             continue;
         }
 
@@ -3681,21 +3810,9 @@
         d3d11::UnorderedAccessView *uavPtr = nullptr;
         ANGLE_TRY(bufferStorage->getRawUAVRange(context, buffer.getOffset(), viewSize, &uavPtr));
 
-        // We need to make sure that resource being set to UnorderedAccessView slot |registerIndex|
-        // is not bound on SRV.
-        if (uavPtr && unsetConflictingView(uavPtr->get()))
-        {
-            mInternalDirtyBits.set(DIRTY_BIT_TEXTURE_AND_SAMPLER_STATE);
-        }
-
-        const unsigned int registerIndex =
-            mProgramD3D->getAtomicCounterBufferRegisterIndex(binding, shaderType);
-
         if (shaderType == gl::ShaderType::Compute)
         {
-            ID3D11UnorderedAccessView *uav     = uavPtr->get();
-            ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
-            deviceContext->CSSetUnorderedAccessViews(registerIndex, 1, &uav, nullptr);
+            setUnorderedAccessViewInternal(shaderType, registerIndex, uavPtr);
         }
         else
         {
@@ -3780,7 +3897,7 @@
 
             // If instanced pointsprites are enabled and the shader uses gl_PointSize, the topology
             // must be D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST.
-            if (usesPointSize && mRenderer->getWorkarounds().useInstancedPointSpriteEmulation)
+            if (usesPointSize && mRenderer->getFeatures().useInstancedPointSpriteEmulation.enabled)
             {
                 primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
             }