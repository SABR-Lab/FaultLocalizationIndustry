# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/validationEGL.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/validationEGL.cpp
--- a/gfx/angle/checkout/src/libANGLE/validationEGL.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/validationEGL.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -132,11 +132,11 @@
     return NoError();
 }
 
-Error ValidateCreateImageKHRMipLevelCommon(gl::Context *context,
-                                           const gl::Texture *texture,
-                                           EGLAttrib level)
+Error ValidateCreateImageMipLevelCommon(gl::Context *context,
+                                        const gl::Texture *texture,
+                                        EGLAttrib level)
 {
-    // Note that the spec EGL_KHR_create_image spec does not explicitly specify an error
+    // Note that the spec EGL_create_image spec does not explicitly specify an error
     // when the level is outside the base/max level range, but it does mention that the
     // level "must be a part of the complete texture object <buffer>". It can be argued
     // that out-of-range levels are not a part of the complete texture.
@@ -599,6 +599,31 @@
         UNREACHABLE();
     }
 
+    if (attribMap.contains(EGL_FEATURE_OVERRIDES_ENABLED_ANGLE))
+    {
+        if (!clientExtensions.featureControlANGLE)
+        {
+            return EglBadAttribute() << "EGL_ANGLE_feature_control is not supported";
+        }
+        else if (attribMap.get(EGL_FEATURE_OVERRIDES_ENABLED_ANGLE, 0) == 0)
+        {
+            return EglBadAttribute()
+                   << "EGL_FEATURE_OVERRIDES_ENABLED_ANGLE must be a valid pointer";
+        }
+    }
+    if (attribMap.contains(EGL_FEATURE_OVERRIDES_DISABLED_ANGLE))
+    {
+        if (!clientExtensions.featureControlANGLE)
+        {
+            return EglBadAttribute() << "EGL_ANGLE_feature_control is not supported";
+        }
+        else if (attribMap.get(EGL_FEATURE_OVERRIDES_DISABLED_ANGLE, 0) == 0)
+        {
+            return EglBadAttribute()
+                   << "EGL_FEATURE_OVERRIDES_DISABLED_ANGLE must be a valid pointer";
+        }
+    }
+
     return NoError();
 }
 
@@ -675,11 +700,9 @@
 
         case ObjectType::Sync:
         {
-            ANGLE_TRY(ValidateDisplay(display));
-            // TODO(geofflang): Implement sync objects. http://anglebug.com/2466
-            UNIMPLEMENTED();
-            return EglBadDisplay() << "Sync objects are unimplemented.";
-
+            Sync *sync = static_cast<Sync *>(object);
+            ANGLE_TRY(ValidateSync(display, sync));
+            *outLabeledObject = sync;
             break;
         }
 
@@ -1127,6 +1150,35 @@
                 }
                 break;
 
+            case EGL_POWER_PREFERENCE_ANGLE:
+                if (!display->getExtensions().powerPreference)
+                {
+                    return EglBadAttribute() << "Attribute EGL_POWER_PREFERENCE_ANGLE "
+                                                "requires EGL_ANGLE_power_preference.";
+                }
+                if (value != EGL_LOW_POWER_ANGLE && value != EGL_HIGH_POWER_ANGLE)
+                {
+                    return EglBadAttribute()
+                           << "EGL_POWER_PREFERENCE_ANGLE must be "
+                              "either EGL_LOW_POWER_ANGLE or EGL_HIGH_POWER_ANGLE.";
+                }
+                break;
+
+            case EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE:
+                if (!display->getExtensions().createContextBackwardsCompatible)
+                {
+                    return EglBadAttribute()
+                           << "Attribute EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE "
+                              "requires EGL_ANGLE_create_context_backwards_compatible.";
+                }
+                if (value != EGL_TRUE && value != EGL_FALSE)
+                {
+                    return EglBadAttribute()
+                           << "EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE must be "
+                              "either EGL_TRUE or EGL_FALSE.";
+                }
+                break;
+
             default:
                 return EglBadAttribute() << "Unknown attribute.";
         }
@@ -1188,12 +1240,6 @@
         {
             return EglBadMatch();
         }
-
-        if (shareContext->getClientMajorVersion() != clientMajorVersion ||
-            shareContext->getClientMinorVersion() != clientMinorVersion)
-        {
-            return EglBadContext();
-        }
     }
 
     return NoError();
@@ -1786,25 +1832,17 @@
     return NoError();
 }
 
-Error ValidateCreateImageKHR(const Display *display,
-                             gl::Context *context,
-                             EGLenum target,
-                             EGLClientBuffer buffer,
-                             const AttributeMap &attributes)
+Error ValidateCreateImage(const Display *display,
+                          gl::Context *context,
+                          EGLenum target,
+                          EGLClientBuffer buffer,
+                          const AttributeMap &attributes)
 {
 
     ANGLE_TRY(ValidateDisplay(display));
 
     const DisplayExtensions &displayExtensions = display->getExtensions();
 
-    if (!displayExtensions.imageBase && !displayExtensions.image)
-    {
-        // It is out of spec what happens when calling an extension function when the extension is
-        // not available.
-        // EGL_BAD_DISPLAY seems like a reasonable error.
-        return EglBadDisplay() << "EGL_KHR_image not supported.";
-    }
-
     // TODO(geofflang): Complete validation from EGL_KHR_image_base:
     // If the resource specified by <dpy>, <ctx>, <target>, <buffer> and <attrib_list> is itself an
     // EGLImage sibling, the error EGL_BAD_ACCESS is generated.
@@ -1817,7 +1855,7 @@
 
         switch (attribute)
         {
-            case EGL_IMAGE_PRESERVED_KHR:
+            case EGL_IMAGE_PRESERVED:
                 switch (value)
                 {
                     case EGL_TRUE:
@@ -1826,28 +1864,28 @@
 
                     default:
                         return EglBadParameter()
-                               << "EGL_IMAGE_PRESERVED_KHR must be EGL_TRUE or EGL_FALSE.";
+                               << "EGL_IMAGE_PRESERVED must be EGL_TRUE or EGL_FALSE.";
                 }
                 break;
 
-            case EGL_GL_TEXTURE_LEVEL_KHR:
+            case EGL_GL_TEXTURE_LEVEL:
                 if (!displayExtensions.glTexture2DImage &&
                     !displayExtensions.glTextureCubemapImage && !displayExtensions.glTexture3DImage)
                 {
-                    return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL_KHR cannot be used "
+                    return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL cannot be used "
                                                 "without KHR_gl_texture_*_image support.";
                 }
 
                 if (value < 0)
                 {
-                    return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL_KHR cannot be negative.";
+                    return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL cannot be negative.";
                 }
                 break;
 
-            case EGL_GL_TEXTURE_ZOFFSET_KHR:
+            case EGL_GL_TEXTURE_ZOFFSET:
                 if (!displayExtensions.glTexture3DImage)
                 {
-                    return EglBadParameter() << "EGL_GL_TEXTURE_ZOFFSET_KHR cannot be used "
+                    return EglBadParameter() << "EGL_GL_TEXTURE_ZOFFSET cannot be used "
                                                 "without KHR_gl_texture_3D_image support.";
                 }
                 break;
@@ -1860,7 +1898,7 @@
 
     switch (target)
     {
-        case EGL_GL_TEXTURE_2D_KHR:
+        case EGL_GL_TEXTURE_2D:
         {
             if (!displayExtensions.glTexture2DImage)
             {
@@ -1885,7 +1923,7 @@
                 return EglBadAccess() << "texture has a surface bound to it.";
             }
 
-            EGLAttrib level = attributes.get(EGL_GL_TEXTURE_LEVEL_KHR, 0);
+            EGLAttrib level = attributes.get(EGL_GL_TEXTURE_LEVEL, 0);
             if (texture->getWidth(gl::TextureTarget::_2D, static_cast<size_t>(level)) == 0 ||
                 texture->getHeight(gl::TextureTarget::_2D, static_cast<size_t>(level)) == 0)
             {
@@ -1893,16 +1931,16 @@
                        << "target 2D texture does not have a valid size at specified level.";
             }
 
-            ANGLE_TRY(ValidateCreateImageKHRMipLevelCommon(context, texture, level));
+            ANGLE_TRY(ValidateCreateImageMipLevelCommon(context, texture, level));
         }
         break;
 
-        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
-        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
-        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
-        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
-        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
-        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
+        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+        case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         {
             if (!displayExtensions.glTextureCubemapImage)
             {
@@ -1928,7 +1966,7 @@
                 return EglBadAccess() << "texture has a surface bound to it.";
             }
 
-            EGLAttrib level               = attributes.get(EGL_GL_TEXTURE_LEVEL_KHR, 0);
+            EGLAttrib level               = attributes.get(EGL_GL_TEXTURE_LEVEL, 0);
             gl::TextureTarget cubeMapFace = egl_gl::EGLCubeMapTargetToCubeMapTarget(target);
             if (texture->getWidth(cubeMapFace, static_cast<size_t>(level)) == 0 ||
                 texture->getHeight(cubeMapFace, static_cast<size_t>(level)) == 0)
@@ -1937,7 +1975,7 @@
                                             "size at specified level and face.";
             }
 
-            ANGLE_TRY(ValidateCreateImageKHRMipLevelCommon(context, texture, level));
+            ANGLE_TRY(ValidateCreateImageMipLevelCommon(context, texture, level));
 
             if (level == 0 && !texture->isMipmapComplete() &&
                 CubeTextureHasUnspecifiedLevel0Face(texture))
@@ -1949,7 +1987,7 @@
         }
         break;
 
-        case EGL_GL_TEXTURE_3D_KHR:
+        case EGL_GL_TEXTURE_3D:
         {
             if (!displayExtensions.glTexture3DImage)
             {
@@ -1974,8 +2012,8 @@
                 return EglBadAccess() << "texture has a surface bound to it.";
             }
 
-            EGLAttrib level   = attributes.get(EGL_GL_TEXTURE_LEVEL_KHR, 0);
-            EGLAttrib zOffset = attributes.get(EGL_GL_TEXTURE_ZOFFSET_KHR, 0);
+            EGLAttrib level   = attributes.get(EGL_GL_TEXTURE_LEVEL, 0);
+            EGLAttrib zOffset = attributes.get(EGL_GL_TEXTURE_ZOFFSET, 0);
             if (texture->getWidth(gl::TextureTarget::_3D, static_cast<size_t>(level)) == 0 ||
                 texture->getHeight(gl::TextureTarget::_3D, static_cast<size_t>(level)) == 0 ||
                 texture->getDepth(gl::TextureTarget::_3D, static_cast<size_t>(level)) == 0)
@@ -1992,20 +2030,20 @@
                                             "level.";
             }
 
-            ANGLE_TRY(ValidateCreateImageKHRMipLevelCommon(context, texture, level));
+            ANGLE_TRY(ValidateCreateImageMipLevelCommon(context, texture, level));
         }
         break;
 
-        case EGL_GL_RENDERBUFFER_KHR:
+        case EGL_GL_RENDERBUFFER:
         {
             if (!displayExtensions.glRenderbufferImage)
             {
                 return EglBadParameter() << "KHR_gl_renderbuffer_image not supported.";
             }
 
-            if (attributes.contains(EGL_GL_TEXTURE_LEVEL_KHR))
+            if (attributes.contains(EGL_GL_TEXTURE_LEVEL))
             {
-                return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL_KHR cannot be used in "
+                return EglBadParameter() << "EGL_GL_TEXTURE_LEVEL cannot be used in "
                                             "conjunction with a renderbuffer target.";
             }
 
@@ -2046,20 +2084,59 @@
         }
         break;
 
+        case EGL_D3D11_TEXTURE_ANGLE:
+            if (!displayExtensions.imageD3D11Texture)
+            {
+                return EglBadParameter() << "EGL_ANGLE_image_d3d11_texture not supported.";
+            }
+
+            if (context != nullptr)
+            {
+                return EglBadContext() << "ctx must be EGL_NO_CONTEXT.";
+            }
+
+            ANGLE_TRY(display->validateImageClientBuffer(context, target, buffer, attributes));
+            break;
+
         default:
             return EglBadParameter()
                    << "invalid target: 0x" << std::hex << std::uppercase << target;
     }
 
-    if (attributes.contains(EGL_GL_TEXTURE_ZOFFSET_KHR) && target != EGL_GL_TEXTURE_3D_KHR)
+    if (attributes.contains(EGL_GL_TEXTURE_ZOFFSET) && target != EGL_GL_TEXTURE_3D)
     {
-        return EglBadParameter()
-               << "EGL_GL_TEXTURE_ZOFFSET_KHR must be used with a 3D texture target.";
+        return EglBadParameter() << "EGL_GL_TEXTURE_ZOFFSET must be used with a 3D texture target.";
     }
 
     return NoError();
 }
 
+Error ValidateDestroyImage(const Display *display, const Image *image)
+{
+    ANGLE_TRY(ValidateImage(display, image));
+
+    return NoError();
+}
+
+Error ValidateCreateImageKHR(const Display *display,
+                             gl::Context *context,
+                             EGLenum target,
+                             EGLClientBuffer buffer,
+                             const AttributeMap &attributes)
+{
+    ANGLE_TRY(ValidateDisplay(display));
+
+    if (!display->getExtensions().imageBase && !display->getExtensions().image)
+    {
+        // It is out of spec what happens when calling an extension function when the extension is
+        // not available.
+        // EGL_BAD_DISPLAY seems like a reasonable error.
+        return EglBadDisplay() << "EGL_KHR_image not supported.";
+    }
+
+    return ValidateCreateImage(display, context, target, buffer, attributes);
+}
+
 Error ValidateDestroyImageKHR(const Display *display, const Image *image)
 {
     ANGLE_TRY(ValidateImage(display, image));
@@ -2143,20 +2220,30 @@
             {
                 return EglBadAttribute() << "Invalid attribute";
             }
-
-            if (display != currentDisplay)
+            break;
+
+        case EGL_SYNC_NATIVE_FENCE_ANDROID:
+            if (!display->getExtensions().nativeFenceSyncANDROID)
             {
-                return EglBadMatch() << "CreateSync can only be called on the current display";
+                return EglBadDisplay()
+                       << "EGL_ANDROID_native_fence_sync extension is not available.";
             }
 
-            ANGLE_TRY(ValidateContext(currentDisplay, currentContext));
-
-            if (!currentContext->getExtensions().eglSync)
+            for (const auto &attributeIter : attribs)
             {
-                return EglBadMatch() << "EGL_SYNC_FENCE_KHR cannot be used without "
-                                        "GL_OES_EGL_sync support.";
+                EGLAttrib attribute = attributeIter.first;
+
+                switch (attribute)
+                {
+                    case EGL_SYNC_NATIVE_FENCE_FD_ANDROID:
+                        break;
+
+                    default:
+                        return EglBadAttribute() << "Invalid attribute";
+                }
             }
             break;
+
         default:
             if (isExt)
             {
@@ -2168,6 +2255,19 @@
             }
     }
 
+    if (display != currentDisplay)
+    {
+        return EglBadMatch() << "CreateSync can only be called on the current display";
+    }
+
+    ANGLE_TRY(ValidateContext(currentDisplay, currentContext));
+
+    if (!currentContext->getExtensions().eglSync)
+    {
+        return EglBadMatch() << "EGL_SYNC_FENCE_KHR cannot be used without "
+                                "GL_OES_EGL_sync support.";
+    }
+
     return NoError();
 }
 
@@ -2178,15 +2278,23 @@
     switch (attribute)
     {
         case EGL_SYNC_CONDITION_KHR:
-            if (sync->getType() != EGL_SYNC_FENCE_KHR)
+            switch (sync->getType())
             {
-                return EglBadAttribute() << "EGL_SYNC_CONDITION_KHR is only valid for fence syncs";
+                case EGL_SYNC_FENCE_KHR:
+                case EGL_SYNC_NATIVE_FENCE_ANDROID:
+                    break;
+
+                default:
+                    return EglBadAttribute()
+                           << "EGL_SYNC_CONDITION_KHR is not valid for this sync type.";
             }
             break;
+
         // The following attributes are accepted by all types
         case EGL_SYNC_TYPE_KHR:
         case EGL_SYNC_STATUS_KHR:
             break;
+
         default:
             return EglBadAttribute() << "Invalid attribute";
     }
@@ -2869,11 +2977,7 @@
                                        EGLint *rects,
                                        EGLint n_rects)
 {
-    Error error = ValidateSurface(display, surface);
-    if (error.isError())
-    {
-        return error;
-    }
+    ANGLE_TRY(ValidateSurface(display, surface));
 
     if (!display->getExtensions().swapBuffersWithDamage)
     {
@@ -2960,7 +3064,7 @@
     if (context)
     {
         gl::TextureType type = egl_gl::EGLTextureTargetToTextureType(surface->getTextureTarget());
-        *textureObject       = context->getTargetTexture(type);
+        *textureObject       = context->getTextureByType(type);
         ASSERT(*textureObject != nullptr);
 
         if ((*textureObject)->getImmutableFormat())
@@ -3724,4 +3828,111 @@
     return NoError();
 }
 
+Error ValidateQueryStringiANGLE(const Display *display, EGLint name, EGLint index)
+{
+    ANGLE_TRY(ValidateDisplay(display));
+
+    if (!Display::GetClientExtensions().featureControlANGLE)
+    {
+        return EglBadDisplay() << "EGL_ANGLE_feature_control extension is not available.";
+    }
+
+    if (index < 0)
+    {
+        return EglBadParameter() << "index is negative.";
+    }
+
+    switch (name)
+    {
+        case EGL_FEATURE_NAME_ANGLE:
+        case EGL_FEATURE_CATEGORY_ANGLE:
+        case EGL_FEATURE_DESCRIPTION_ANGLE:
+        case EGL_FEATURE_BUG_ANGLE:
+        case EGL_FEATURE_STATUS_ANGLE:
+            break;
+        default:
+            return EglBadParameter() << "name is not valid.";
+    }
+
+    if (static_cast<size_t>(index) >= display->getFeatures().size())
+    {
+        return EglBadParameter() << "index is too big.";
+    }
+
+    return NoError();
+}
+
+Error ValidateQueryDisplayAttribBase(const Display *display, const EGLint attribute)
+{
+    ANGLE_TRY(ValidateDisplay(display));
+
+    switch (attribute)
+    {
+        case EGL_DEVICE_EXT:
+            if (!display->getExtensions().deviceQuery)
+            {
+                return EglBadDisplay() << "EGL_EXT_device_query extension is not available.";
+            }
+            break;
+
+        case EGL_FEATURE_COUNT_ANGLE:
+            if (!Display::GetClientExtensions().featureControlANGLE)
+            {
+                return EglBadDisplay() << "EGL_ANGLE_feature_control extension is not available.";
+            }
+            break;
+
+        default:
+            return EglBadAttribute() << "attribute is not valid.";
+    }
+
+    return NoError();
+}
+
+Error ValidateQueryDisplayAttribEXT(const Display *display, const EGLint attribute)
+{
+    ANGLE_TRY(ValidateQueryDisplayAttribBase(display, attribute));
+
+    return NoError();
+}
+
+Error ValidateQueryDisplayAttribANGLE(const Display *display, const EGLint attribute)
+{
+    ANGLE_TRY(ValidateQueryDisplayAttribBase(display, attribute));
+
+    return NoError();
+}
+
+Error ValidateGetNativeClientBufferANDROID(const AHardwareBuffer *buffer)
+{
+    // No extension check is done because no display is passed to eglGetNativeClientBufferANDROID
+    // despite it being a display extension.  No display is needed for the implementation though.
+    if (buffer == nullptr)
+    {
+        return EglBadParameter() << "NULL buffer.";
+    }
+
+    return NoError();
+}
+
+Error ValidateDupNativeFenceFDANDROID(const Display *display, const Sync *sync)
+{
+    ANGLE_TRY(ValidateDisplay(display));
+
+    if (!display->getExtensions().nativeFenceSyncANDROID)
+    {
+        return EglBadDisplay() << "EGL_ANDROID_native_fence_sync extension is not available.";
+    }
+
+    ANGLE_TRY(ValidateSync(display, sync));
+
+    if (sync->getNativeFenceFD() == EGL_NO_NATIVE_FENCE_FD_ANDROID)
+    {
+        return EglBadParameter() << "EGL_NATIVE_FENCE_FD_ANDROID attribute of sync is "
+                                    "EGL_NO_NATIVE_FENCE_FD_ANDROID";
+    }
+
+    return NoError();
+}
+
 }  // namespace egl