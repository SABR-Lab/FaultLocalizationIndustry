# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/angle/checkout/src/libANGLE/validationES2.cpp
# Commit: 3a91885d47e0
# Full Hash: 3a91885d47e0ef7fba9749562d52300eea67c651
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2019-11-11 21:52:52
# Regressor Bug: 1578576
# File Overlap Count: 4
# Description:
#   Bug 1578576 - Part 2: Update to ANGLE 3865 r=jgilbert
#   
#   Depends on D44561
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44579
# ==============================================================================

diff -r 77cee77c0307 -r 3a91885d47e0 gfx/angle/checkout/src/libANGLE/validationES2.cpp
--- a/gfx/angle/checkout/src/libANGLE/validationES2.cpp	Fri Nov 08 16:41:42 2019 +0000
+++ b/gfx/angle/checkout/src/libANGLE/validationES2.cpp	Fri Nov 08 17:06:00 2019 +0000
@@ -492,7 +492,7 @@
 
     const gl::Framebuffer *framebuffer = context->getState().getReadFramebuffer();
     GLenum colorbufferFormat =
-        framebuffer->getReadColorbuffer()->getFormat().info->sizedInternalFormat;
+        framebuffer->getReadColorAttachment()->getFormat().info->sizedInternalFormat;
     const auto &formatInfo = *textureFormat.info;
 
     // [OpenGL ES 2.0.24] table 3.9
@@ -730,9 +730,7 @@
             case GL_DEPTH_COMPONENT:
             case GL_DEPTH_COMPONENT16:
             case GL_DEPTH_COMPONENT32_OES:
-            case GL_DEPTH_STENCIL_OES:
-            case GL_DEPTH24_STENCIL8_OES:
-                if (context->getExtensions().depthTextures)
+                if (context->getExtensions().depthTextureAny())
                 {
                     context->validationError(GL_INVALID_OPERATION, kInvalidFormat);
                     return false;
@@ -742,6 +740,21 @@
                     context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
                     return false;
                 }
+                break;
+            case GL_DEPTH_STENCIL_OES:
+            case GL_DEPTH24_STENCIL8_OES:
+                if (context->getExtensions().depthTextureAny() ||
+                    context->getExtensions().packedDepthStencil)
+                {
+                    context->validationError(GL_INVALID_OPERATION, kInvalidFormat);
+                    return false;
+                }
+                else
+                {
+                    context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
+                    return false;
+                }
+                break;
             default:
                 context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
                 return false;
@@ -1111,7 +1124,27 @@
 
     return false;
 }
-}  // anonymous namespace
+
+bool IsValidImageLayout(ImageLayout layout)
+{
+    switch (layout)
+    {
+        case ImageLayout::Undefined:
+        case ImageLayout::General:
+        case ImageLayout::ColorAttachment:
+        case ImageLayout::DepthStencilAttachment:
+        case ImageLayout::DepthStencilReadOnlyAttachment:
+        case ImageLayout::ShaderReadOnly:
+        case ImageLayout::TransferSrc:
+        case ImageLayout::TransferDst:
+        case ImageLayout::DepthReadOnlyStencilAttachment:
+        case ImageLayout::DepthAttachmentStencilReadOnly:
+            return true;
+
+        default:
+            return false;
+    }
+}
 
 bool ValidateES2TexImageParameters(Context *context,
                                    TextureTarget target,
@@ -1135,6 +1168,30 @@
         return false;
     }
 
+    return ValidateES2TexImageParametersBase(context, target, level, internalformat, isCompressed,
+                                             isSubImage, xoffset, yoffset, width, height, border,
+                                             format, type, imageSize, pixels);
+}
+
+}  // anonymous namespace
+
+bool ValidateES2TexImageParametersBase(Context *context,
+                                       TextureTarget target,
+                                       GLint level,
+                                       GLenum internalformat,
+                                       bool isCompressed,
+                                       bool isSubImage,
+                                       GLint xoffset,
+                                       GLint yoffset,
+                                       GLsizei width,
+                                       GLsizei height,
+                                       GLint border,
+                                       GLenum format,
+                                       GLenum type,
+                                       GLsizei imageSize,
+                                       const void *pixels)
+{
+
     TextureType texType = TextureTargetToType(target);
     if (!ValidImageSizeParameters(context, texType, level, width, height, 1, isSubImage))
     {
@@ -1155,26 +1212,12 @@
         return false;
     }
 
-    // From GL_CHROMIUM_color_buffer_float_rgb[a]:
-    // GL_RGB[A] / GL_RGB[A]32F becomes an allowable format / internalformat parameter pair for
-    // TexImage2D. The restriction in section 3.7.1 of the OpenGL ES 2.0 spec that the
-    // internalformat parameter and format parameter of TexImage2D must match is lifted for this
-    // case.
-    bool nonEqualFormatsAllowed =
-        (internalformat == GL_RGB32F && context->getExtensions().colorBufferFloatRGB) ||
-        (internalformat == GL_RGBA32F && context->getExtensions().colorBufferFloatRGBA);
-
-    if (!isSubImage && !isCompressed && internalformat != format && !nonEqualFormatsAllowed)
-    {
-        context->validationError(GL_INVALID_OPERATION, kInvalidFormatCombination);
-        return false;
-    }
-
     const gl::Caps &caps = context->getCaps();
 
     switch (texType)
     {
         case TextureType::_2D:
+        case TextureType::External:
             if (static_cast<GLuint>(width) > (caps.max2DTextureSize >> level) ||
                 static_cast<GLuint>(height) > (caps.max2DTextureSize >> level))
             {
@@ -1218,55 +1261,13 @@
             return false;
     }
 
-    gl::Texture *texture = context->getTargetTexture(texType);
+    gl::Texture *texture = context->getTextureByType(texType);
     if (!texture)
     {
         context->validationError(GL_INVALID_OPERATION, kBufferNotBound);
         return false;
     }
 
-    if (isSubImage)
-    {
-        const InternalFormat &textureInternalFormat = *texture->getFormat(target, level).info;
-        if (textureInternalFormat.internalFormat == GL_NONE)
-        {
-            context->validationError(GL_INVALID_OPERATION, kInvalidTextureLevel);
-            return false;
-        }
-
-        if (format != GL_NONE)
-        {
-            if (GetInternalFormatInfo(format, type).sizedInternalFormat !=
-                textureInternalFormat.sizedInternalFormat)
-            {
-                context->validationError(GL_INVALID_OPERATION, kTypeMismatch);
-                return false;
-            }
-        }
-
-        if (static_cast<size_t>(xoffset + width) > texture->getWidth(target, level) ||
-            static_cast<size_t>(yoffset + height) > texture->getHeight(target, level))
-        {
-            context->validationError(GL_INVALID_VALUE, kOffsetOverflow);
-            return false;
-        }
-
-        if (width > 0 && height > 0 && pixels == nullptr &&
-            context->getState().getTargetBuffer(BufferBinding::PixelUnpack) == nullptr)
-        {
-            context->validationError(GL_INVALID_VALUE, kPixelDataNull);
-            return false;
-        }
-    }
-    else
-    {
-        if (texture->getImmutableFormat())
-        {
-            context->validationError(GL_INVALID_OPERATION, kTextureIsImmutable);
-            return false;
-        }
-    }
-
     // Verify zero border
     if (border != 0)
     {
@@ -1274,6 +1275,8 @@
         return false;
     }
 
+    bool nonEqualFormatsAllowed = false;
+
     if (isCompressed)
     {
         GLenum actualInternalFormat =
@@ -1307,9 +1310,10 @@
                 return false;
             }
 
-            if (!ValidCompressedSubImageSize(context, actualInternalFormat, xoffset, yoffset, width,
-                                             height, texture->getWidth(target, level),
-                                             texture->getHeight(target, level)))
+            if (!ValidCompressedSubImageSize(context, actualInternalFormat, xoffset, yoffset, 0,
+                                             width, height, 1, texture->getWidth(target, level),
+                                             texture->getHeight(target, level),
+                                             texture->getDepth(target, level)))
             {
                 context->validationError(GL_INVALID_OPERATION, kInvalidCompressedImageSize);
                 return false;
@@ -1323,7 +1327,7 @@
         }
         else
         {
-            if (!ValidCompressedImageSize(context, actualInternalFormat, level, width, height))
+            if (!ValidCompressedImageSize(context, actualInternalFormat, level, width, height, 1))
             {
                 context->validationError(GL_INVALID_OPERATION, kInvalidCompressedImageSize);
                 return false;
@@ -1552,7 +1556,9 @@
                 break;
             case GL_DEPTH_COMPONENT:
             case GL_DEPTH_STENCIL_OES:
-                if (!context->getExtensions().depthTextures)
+                if (!context->getExtensions().depthTextureANGLE &&
+                    !(context->getExtensions().packedDepthStencil &&
+                      context->getExtensions().depthTextureOES))
                 {
                     context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
                     return false;
@@ -1564,15 +1570,18 @@
                 }
                 // OES_depth_texture supports loading depth data and multiple levels,
                 // but ANGLE_depth_texture does not
-                if (pixels != nullptr)
+                if (!context->getExtensions().depthTextureOES)
                 {
-                    context->validationError(GL_INVALID_OPERATION, kPixelDataNotNull);
-                    return false;
-                }
-                if (level != 0)
-                {
-                    context->validationError(GL_INVALID_OPERATION, kLevelNotZero);
-                    return false;
+                    if (pixels != nullptr)
+                    {
+                        context->validationError(GL_INVALID_OPERATION, kPixelDataNotNull);
+                        return false;
+                    }
+                    if (level != 0)
+                    {
+                        context->validationError(GL_INVALID_OPERATION, kLevelNotZero);
+                        return false;
+                    }
                 }
                 break;
             default:
@@ -1583,12 +1592,23 @@
         {
             switch (internalformat)
             {
+                // Core ES 2.0 formats
+                case GL_ALPHA:
+                case GL_LUMINANCE:
+                case GL_LUMINANCE_ALPHA:
+                case GL_RGB:
+                case GL_RGBA:
+                    break;
+
                 case GL_RGBA32F:
                     if (!context->getExtensions().colorBufferFloatRGBA)
                     {
                         context->validationError(GL_INVALID_ENUM, kInvalidFormat);
                         return false;
                     }
+
+                    nonEqualFormatsAllowed = true;
+
                     if (type != GL_FLOAT)
                     {
                         context->validationError(GL_INVALID_OPERATION, kMismatchedTypeAndFormat);
@@ -1607,6 +1627,9 @@
                         context->validationError(GL_INVALID_ENUM, kInvalidFormat);
                         return false;
                     }
+
+                    nonEqualFormatsAllowed = true;
+
                     if (type != GL_FLOAT)
                     {
                         context->validationError(GL_INVALID_OPERATION, kMismatchedTypeAndFormat);
@@ -1619,8 +1642,52 @@
                     }
                     break;
 
+                case GL_BGRA_EXT:
+                    if (!context->getExtensions().textureFormatBGRA8888)
+                    {
+                        context->validationError(GL_INVALID_ENUM, kInvalidFormat);
+                        return false;
+                    }
+                    break;
+
+                case GL_DEPTH_COMPONENT:
+                    if (!(context->getExtensions().depthTextureAny()))
+                    {
+                        context->validationError(GL_INVALID_ENUM, kInvalidFormat);
+                        return false;
+                    }
+                    break;
+
+                case GL_DEPTH_STENCIL:
+                    if (!(context->getExtensions().depthTextureANGLE ||
+                          context->getExtensions().packedDepthStencil))
+                    {
+                        context->validationError(GL_INVALID_ENUM, kInvalidFormat);
+                        return false;
+                    }
+                    break;
+
+                case GL_RED:
+                case GL_RG:
+                    if (!context->getExtensions().textureRG)
+                    {
+                        context->validationError(GL_INVALID_ENUM, kInvalidFormat);
+                        return false;
+                    }
+                    break;
+
+                case GL_SRGB_EXT:
+                case GL_SRGB_ALPHA_EXT:
+                    if (!context->getExtensions().sRGB)
+                    {
+                        context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
+                        return false;
+                    }
+                    break;
+
                 default:
-                    break;
+                    context->validationError(GL_INVALID_VALUE, kInvalidInternalFormat);
+                    return false;
             }
         }
 
@@ -1642,14 +1709,68 @@
         }
     }
 
+    if (isSubImage)
+    {
+        const InternalFormat &textureInternalFormat = *texture->getFormat(target, level).info;
+        if (textureInternalFormat.internalFormat == GL_NONE)
+        {
+            context->validationError(GL_INVALID_OPERATION, kInvalidTextureLevel);
+            return false;
+        }
+
+        if (format != textureInternalFormat.format)
+        {
+            context->validationError(GL_INVALID_OPERATION, err::kTextureFormatMismatch);
+            return false;
+        }
+
+        if (context->getExtensions().webglCompatibility)
+        {
+            if (GetInternalFormatInfo(format, type).sizedInternalFormat !=
+                textureInternalFormat.sizedInternalFormat)
+            {
+                context->validationError(GL_INVALID_OPERATION, kTextureTypeMismatch);
+                return false;
+            }
+        }
+
+        if (static_cast<size_t>(xoffset + width) > texture->getWidth(target, level) ||
+            static_cast<size_t>(yoffset + height) > texture->getHeight(target, level))
+        {
+            context->validationError(GL_INVALID_VALUE, kOffsetOverflow);
+            return false;
+        }
+
+        if (width > 0 && height > 0 && pixels == nullptr &&
+            context->getState().getTargetBuffer(BufferBinding::PixelUnpack) == nullptr)
+        {
+            context->validationError(GL_INVALID_VALUE, kPixelDataNull);
+            return false;
+        }
+    }
+    else
+    {
+        if (texture->getImmutableFormat())
+        {
+            context->validationError(GL_INVALID_OPERATION, kTextureIsImmutable);
+            return false;
+        }
+    }
+
+    // From GL_CHROMIUM_color_buffer_float_rgb[a]:
+    // GL_RGB[A] / GL_RGB[A]32F becomes an allowable format / internalformat parameter pair for
+    // TexImage2D. The restriction in section 3.7.1 of the OpenGL ES 2.0 spec that the
+    // internalformat parameter and format parameter of TexImage2D must match is lifted for this
+    // case.
+    if (!isSubImage && !isCompressed && internalformat != format && !nonEqualFormatsAllowed)
+    {
+        context->validationError(GL_INVALID_OPERATION, kInvalidFormatCombination);
+        return false;
+    }
+
     GLenum sizeCheckFormat = isSubImage ? format : internalformat;
-    if (!ValidImageDataSize(context, texType, width, height, 1, sizeCheckFormat, type, pixels,
-                            imageSize))
-    {
-        return false;
-    }
-
-    return true;
+    return ValidImageDataSize(context, texType, width, height, 1, sizeCheckFormat, type, pixels,
+                              imageSize);
 }
 
 bool ValidateES2TexStorageParameters(Context *context,
@@ -1834,8 +1955,7 @@
             break;
         case GL_DEPTH_COMPONENT16:
         case GL_DEPTH_COMPONENT32_OES:
-        case GL_DEPTH24_STENCIL8_OES:
-            if (!context->getExtensions().depthTextures)
+            if (!(context->getExtensions().depthTextureAny()))
             {
                 context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
                 return false;
@@ -1846,17 +1966,44 @@
                 return false;
             }
             // ANGLE_depth_texture only supports 1-level textures
-            if (levels != 1)
+            if (!context->getExtensions().depthTextureOES)
             {
-                context->validationError(GL_INVALID_OPERATION, kInvalidMipLevels);
-                return false;
+                if (levels != 1)
+                {
+                    context->validationError(GL_INVALID_OPERATION, kInvalidMipLevels);
+                    return false;
+                }
             }
             break;
+        case GL_DEPTH24_STENCIL8_OES:
+            if (!(context->getExtensions().depthTextureANGLE ||
+                  (context->getExtensions().packedDepthStencil &&
+                   context->getExtensions().textureStorage)))
+            {
+                context->validationError(GL_INVALID_ENUM, kEnumNotSupported);
+                return false;
+            }
+            if (target != TextureType::_2D)
+            {
+                context->validationError(GL_INVALID_OPERATION, kInvalidTextureTarget);
+                return false;
+            }
+            if (!context->getExtensions().packedDepthStencil)
+            {
+                // ANGLE_depth_texture only supports 1-level textures
+                if (levels != 1)
+                {
+                    context->validationError(GL_INVALID_OPERATION, kInvalidMipLevels);
+                    return false;
+                }
+            }
+            break;
+
         default:
             break;
     }
 
-    gl::Texture *texture = context->getTargetTexture(target);
+    gl::Texture *texture = context->getTextureByType(target);
     if (!texture || texture->id() == 0)
     {
         context->validationError(GL_INVALID_OPERATION, kMissingTexture);
@@ -2517,13 +2664,17 @@
 
     if (mask & GL_COLOR_BUFFER_BIT)
     {
-        const FramebufferAttachment *readColorAttachment = readFramebuffer->getReadColorbuffer();
-        const FramebufferAttachment *drawColorAttachment = drawFramebuffer->getFirstColorbuffer();
+        const FramebufferAttachment *readColorAttachment =
+            readFramebuffer->getReadColorAttachment();
+        const FramebufferAttachment *drawColorAttachment =
+            drawFramebuffer->getFirstColorAttachment();
 
         if (readColorAttachment && drawColorAttachment)
         {
             if (!(readColorAttachment->type() == GL_TEXTURE &&
-                  readColorAttachment->getTextureImageIndex().getType() == TextureType::_2D) &&
+                  (readColorAttachment->getTextureImageIndex().getType() == TextureType::_2D ||
+                   readColorAttachment->getTextureImageIndex().getType() ==
+                       TextureType::Rectangle)) &&
                 readColorAttachment->type() != GL_RENDERBUFFER &&
                 readColorAttachment->type() != GL_FRAMEBUFFER_DEFAULT)
             {
@@ -2540,7 +2691,9 @@
                 if (attachment)
                 {
                     if (!(attachment->type() == GL_TEXTURE &&
-                          attachment->getTextureImageIndex().getType() == TextureType::_2D) &&
+                          (attachment->getTextureImageIndex().getType() == TextureType::_2D ||
+                           attachment->getTextureImageIndex().getType() ==
+                               TextureType::Rectangle)) &&
                         attachment->type() != GL_RENDERBUFFER &&
                         attachment->type() != GL_FRAMEBUFFER_DEFAULT)
                     {
@@ -2640,7 +2793,7 @@
         }
     }
 
-    if (extensions.multiview2 && extensions.disjointTimerQuery)
+    if ((extensions.multiview || extensions.multiview2) && extensions.disjointTimerQuery)
     {
         const State &state       = context->getState();
         Framebuffer *framebuffer = state.getDrawFramebuffer();
@@ -2772,6 +2925,23 @@
                                            pixels);
 }
 
+bool ValidateTexSubImage3DOES(Context *context,
+                              TextureTarget target,
+                              GLint level,
+                              GLint xoffset,
+                              GLint yoffset,
+                              GLint zoffset,
+                              GLsizei width,
+                              GLsizei height,
+                              GLsizei depth,
+                              GLenum format,
+                              GLenum type,
+                              const void *pixels)
+{
+    return ValidateTexSubImage3D(context, target, level, xoffset, yoffset, zoffset, width, height,
+                                 depth, format, type, pixels);
+}
+
 bool ValidateCompressedTexImage2D(Context *context,
                                   TextureTarget target,
                                   GLint level,
@@ -2845,6 +3015,21 @@
                                         border, imageSize, data);
 }
 
+bool ValidateCompressedTexImage3DOES(Context *context,
+                                     TextureTarget target,
+                                     GLint level,
+                                     GLenum internalformat,
+                                     GLsizei width,
+                                     GLsizei height,
+                                     GLsizei depth,
+                                     GLint border,
+                                     GLsizei imageSize,
+                                     const void *data)
+{
+    return ValidateCompressedTexImage3D(context, target, level, internalformat, width, height,
+                                        depth, border, imageSize, data);
+}
+
 bool ValidateCompressedTexSubImage2DRobustANGLE(Context *context,
                                                 TextureTarget target,
                                                 GLint level,
@@ -2913,6 +3098,23 @@
     return true;
 }
 
+bool ValidateCompressedTexSubImage3DOES(Context *context,
+                                        TextureTarget target,
+                                        GLint level,
+                                        GLint xoffset,
+                                        GLint yoffset,
+                                        GLint zoffset,
+                                        GLsizei width,
+                                        GLsizei height,
+                                        GLsizei depth,
+                                        GLenum format,
+                                        GLsizei imageSize,
+                                        const void *data)
+{
+    return ValidateCompressedTexSubImage3D(context, target, level, xoffset, yoffset, zoffset, width,
+                                           height, depth, format, imageSize, data);
+}
+
 bool ValidateGetBufferPointervOES(Context *context,
                                   BufferBinding target,
                                   GLenum pname,
@@ -2990,15 +3192,326 @@
     return ValidateMapBufferRangeBase(context, target, offset, length, access);
 }
 
+bool ValidateBufferStorageMemEXT(Context *context,
+                                 TextureType target,
+                                 GLsizeiptr size,
+                                 GLuint memory,
+                                 GLuint64 offset)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateCreateMemoryObjectsEXT(Context *context, GLsizei n, GLuint *memoryObjects)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateGenOrDelete(context, n);
+}
+
+bool ValidateDeleteMemoryObjectsEXT(Context *context, GLsizei n, const GLuint *memoryObjects)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateGenOrDelete(context, n);
+}
+
+bool ValidateGetMemoryObjectParameterivEXT(Context *context,
+                                           GLuint memoryObject,
+                                           GLenum pname,
+                                           GLint *params)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateGetUnsignedBytevEXT(Context *context, GLenum pname, GLubyte *data)
+{
+    if (!context->getExtensions().memoryObject && !context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateGetUnsignedBytei_vEXT(Context *context, GLenum target, GLuint index, GLubyte *data)
+{
+    if (!context->getExtensions().memoryObject && !context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateIsMemoryObjectEXT(Context *context, GLuint memoryObject)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return true;
+}
+
+bool ValidateMemoryObjectParameterivEXT(Context *context,
+                                        GLuint memoryObject,
+                                        GLenum pname,
+                                        const GLint *params)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateTexStorageMem2DEXT(Context *context,
+                                TextureType target,
+                                GLsizei levels,
+                                GLenum internalFormat,
+                                GLsizei width,
+                                GLsizei height,
+                                GLuint memory,
+                                GLuint64 offset)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    if (context->getClientMajorVersion() < 3)
+    {
+        return ValidateES2TexStorageParameters(context, target, levels, internalFormat, width,
+                                               height);
+    }
+
+    ASSERT(context->getClientMajorVersion() >= 3);
+    return ValidateES3TexStorage2DParameters(context, target, levels, internalFormat, width, height,
+                                             1);
+}
+
+bool ValidateTexStorageMem3DEXT(Context *context,
+                                TextureType target,
+                                GLsizei levels,
+                                GLenum internalFormat,
+                                GLsizei width,
+                                GLsizei height,
+                                GLsizei depth,
+                                GLuint memory,
+                                GLuint64 offset)
+{
+    if (!context->getExtensions().memoryObject)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateImportMemoryFdEXT(Context *context,
+                               GLuint memory,
+                               GLuint64 size,
+                               HandleType handleType,
+                               GLint fd)
+{
+    if (!context->getExtensions().memoryObjectFd)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    switch (handleType)
+    {
+        case HandleType::OpaqueFd:
+            break;
+        default:
+            context->validationError(GL_INVALID_ENUM, kInvalidHandleType);
+            return false;
+    }
+
+    return true;
+}
+
+bool ValidateDeleteSemaphoresEXT(Context *context, GLsizei n, const GLuint *semaphores)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateGenOrDelete(context, n);
+}
+
+bool ValidateGenSemaphoresEXT(Context *context, GLsizei n, GLuint *semaphores)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return ValidateGenOrDelete(context, n);
+}
+
+bool ValidateGetSemaphoreParameterui64vEXT(Context *context,
+                                           GLuint semaphore,
+                                           GLenum pname,
+                                           GLuint64 *params)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateIsSemaphoreEXT(Context *context, GLuint semaphore)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    return true;
+}
+
+bool ValidateSemaphoreParameterui64vEXT(Context *context,
+                                        GLuint semaphore,
+                                        GLenum pname,
+                                        const GLuint64 *params)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    UNIMPLEMENTED();
+    return false;
+}
+
+bool ValidateSignalSemaphoreEXT(Context *context,
+                                GLuint semaphore,
+                                GLuint numBufferBarriers,
+                                const GLuint *buffers,
+                                GLuint numTextureBarriers,
+                                const GLuint *textures,
+                                const GLenum *dstLayouts)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    for (GLuint i = 0; i < numTextureBarriers; ++i)
+    {
+        if (!IsValidImageLayout(FromGLenum<ImageLayout>(dstLayouts[i])))
+        {
+            context->validationError(GL_INVALID_ENUM, kInvalidImageLayout);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool ValidateWaitSemaphoreEXT(Context *context,
+                              GLuint semaphore,
+                              GLuint numBufferBarriers,
+                              const GLuint *buffers,
+                              GLuint numTextureBarriers,
+                              const GLuint *textures,
+                              const GLenum *srcLayouts)
+{
+    if (!context->getExtensions().semaphore)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    for (GLuint i = 0; i < numTextureBarriers; ++i)
+    {
+        if (!IsValidImageLayout(FromGLenum<ImageLayout>(srcLayouts[i])))
+        {
+            context->validationError(GL_INVALID_ENUM, kInvalidImageLayout);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool ValidateImportSemaphoreFdEXT(Context *context,
+                                  GLuint semaphore,
+                                  HandleType handleType,
+                                  GLint fd)
+{
+    if (!context->getExtensions().semaphoreFd)
+    {
+        context->validationError(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+
+    switch (handleType)
+    {
+        case HandleType::OpaqueFd:
+            break;
+        default:
+            context->validationError(GL_INVALID_ENUM, kInvalidHandleType);
+            return false;
+    }
+
+    return true;
+}
+
 bool ValidateMapBufferBase(Context *context, BufferBinding target)
 {
     Buffer *buffer = context->getState().getTargetBuffer(target);
     ASSERT(buffer != nullptr);
 
     // Check if this buffer is currently being used as a transform feedback output buffer
-    TransformFeedback *transformFeedback = context->getState().getCurrentTransformFeedback();
-    if (transformFeedback != nullptr && transformFeedback->isActive())
-    {
+    if (context->getState().isTransformFeedbackActive())
+    {
+        TransformFeedback *transformFeedback = context->getState().getCurrentTransformFeedback();
         for (size_t i = 0; i < transformFeedback->getIndexedBufferCount(); i++)
         {
             const auto &transformFeedbackBuffer = transformFeedback->getIndexedBuffer(i);
@@ -3463,6 +3976,7 @@
 
     switch (fillMode)
     {
+        case GL_INVERT:
         case GL_COUNT_UP_CHROMIUM:
         case GL_COUNT_DOWN_CHROMIUM:
             break;
@@ -3633,6 +4147,7 @@
 
     switch (fillMode)
     {
+        case GL_INVERT:
         case GL_COUNT_UP_CHROMIUM:
         case GL_COUNT_DOWN_CHROMIUM:
             break;
@@ -3695,6 +4210,7 @@
 
     switch (fillMode)
     {
+        case GL_INVERT:
         case GL_COUNT_UP_CHROMIUM:
         case GL_COUNT_DOWN_CHROMIUM:
             break;
@@ -5689,6 +6205,21 @@
                                                yoffset, 0, x, y, width, height, 0);
 }
 
+bool ValidateCopyTexSubImage3DOES(Context *context,
+                                  TextureTarget target,
+                                  GLint level,
+                                  GLint xoffset,
+                                  GLint yoffset,
+                                  GLint zoffset,
+                                  GLint x,
+                                  GLint y,
+                                  GLsizei width,
+                                  GLsizei height)
+{
+    return ValidateCopyTexSubImage3D(context, target, level, xoffset, yoffset, zoffset, x, y, width,
+                                     height);
+}
+
 bool ValidateDeleteBuffers(Context *context, GLint n, const GLuint *)
 {
     return ValidateGenOrDelete(context, n);
@@ -5876,6 +6407,18 @@
     return true;
 }
 
+bool ValidateFramebufferTexture3DOES(Context *context,
+                                     GLenum target,
+                                     GLenum attachment,
+                                     TextureTarget textargetPacked,
+                                     GLuint texture,
+                                     GLint level,
+                                     GLint zoffset)
+{
+    UNIMPLEMENTED();
+    return false;
+}
+
 bool ValidateGenBuffers(Context *context, GLint n, GLuint *)
 {
     return ValidateGenOrDelete(context, n);
@@ -5904,7 +6447,7 @@
         return false;
     }
 
-    Texture *texture = context->getTargetTexture(target);
+    Texture *texture = context->getTextureByType(target);
 
     if (texture == nullptr)
     {
@@ -6465,7 +7008,7 @@
 }
 
 bool ValidateTexImage3DOES(Context *context,
-                           GLenum target,
+                           TextureTarget target,
                            GLint level,
                            GLenum internalformat,
                            GLsizei width,
@@ -6476,8 +7019,8 @@
                            GLenum type,
                            const void *pixels)
 {
-    UNIMPLEMENTED();  // FIXME
-    return false;
+    return ValidateTexImage3D(context, target, level, internalformat, width, height, depth, border,
+                              format, type, pixels);
 }
 
 bool ValidatePopGroupMarkerEXT(Context *context)
@@ -6581,7 +7124,7 @@
     return true;
 }
 
-bool ValidateProvokingVertexANGLE(Context *context, ProvokingVertex modePacked)
+bool ValidateProvokingVertexANGLE(Context *context, ProvokingVertexConvention modePacked)
 {
     if (!context->getExtensions().provokingVertex)
     {
@@ -6591,8 +7134,8 @@
 
     switch (modePacked)
     {
-        case ProvokingVertex::FirstVertexConvention:
-        case ProvokingVertex::LastVertexConvention:
+        case ProvokingVertexConvention::FirstVertexConvention:
+        case ProvokingVertexConvention::LastVertexConvention:
             break;
         default:
             context->validationError(GL_INVALID_ENUM, kInvalidProvokingVertex);