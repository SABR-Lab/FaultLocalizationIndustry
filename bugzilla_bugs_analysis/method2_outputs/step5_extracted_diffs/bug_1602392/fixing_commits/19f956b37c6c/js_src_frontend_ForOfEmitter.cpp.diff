# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: js/src/frontend/ForOfEmitter.cpp
# Commit: 19f956b37c6c
# Full Hash: 19f956b37c6cb832b41b8d1ffb8648f38336f4dd
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2019-12-19 21:52:02
# Description:
#   Bug 1602392 - Change for-of bytecode to not have an extra value on the stack across the loop edge. r=arai
#   
#   This fixes a bug with HasLiveStackValueAtDepth because now all stack values that
#   are part of the loop (2 values instead of 3 values) are loop-invariant.
#   
# ==============================================================================

diff -r f1547816cf32 -r 19f956b37c6c js/src/frontend/ForOfEmitter.cpp
--- a/js/src/frontend/ForOfEmitter.cpp	Thu Dec 19 10:57:13 2019 +0000
+++ b/js/src/frontend/ForOfEmitter.cpp	Thu Dec 19 09:06:01 2019 +0000
@@ -58,20 +58,14 @@
     }
   }
 
-  int32_t iterDepth = bce_->bytecodeSection().stackDepth();
+  // For-of loops have the iterator next method and the iterator itself on the
+  // stack.
 
-  // For-of loops have the iterator next method, the iterator itself, and
-  // the result.value on the stack.
-  // Push an undefined to balance the stack.
-  if (!bce_->emit1(JSOP_UNDEFINED)) {
-    //              [stack] NEXT ITER UNDEF
-    return false;
-  }
-
+  int32_t iterDepth = bce_->bytecodeSection().stackDepth();
   loopInfo_.emplace(bce_, iterDepth, allowSelfHostedIter_, iterKind_);
 
   if (!loopInfo_->emitLoopHead(bce_, Nothing())) {
-    //              [stack] NEXT ITER UNDEF
+    //              [stack] NEXT ITER
     return false;
   }
 
@@ -89,7 +83,7 @@
 
     if (headLexicalEmitterScope_->hasEnvironment()) {
       if (!bce_->emit1(JSOP_RECREATELEXICALENV)) {
-        //          [stack] NEXT ITER UNDEF
+        //          [stack] NEXT ITER
         return false;
       }
     }
@@ -111,10 +105,6 @@
     }
   }
 
-  if (!bce_->emit1(JSOP_POP)) {
-    //              [stack] NEXT ITER
-    return false;
-  }
   if (!bce_->emit1(JSOP_DUP2)) {
     //              [stack] NEXT ITER NEXT ITER
     return false;
@@ -134,31 +124,10 @@
     return false;
   }
 
-  InternalIfEmitter ifDone(bce_);
-
-  if (!ifDone.emitThen()) {
-    //              [stack] NEXT ITER RESULT
-    return false;
-  }
-
-  // Remove RESULT from the stack to release it.
-  if (!bce_->emit1(JSOP_POP)) {
-    //              [stack] NEXT ITER
-    return false;
-  }
-  if (!bce_->emit1(JSOP_UNDEFINED)) {
-    //              [stack] NEXT ITER UNDEF
-    return false;
-  }
-
-  // If the iteration is done, leave loop here, instead of the branch at
-  // the end of the loop.
-  if (!loopInfo_->emitSpecialBreakForDone(bce_)) {
-    //              [stack] NEXT ITER UNDEF
-    return false;
-  }
-
-  if (!ifDone.emitEnd()) {
+  // if (done) break;
+  MOZ_ASSERT(bce_->innermostNestableControl == loopInfo_.ptr(),
+             "must be at the top-level of the loop");
+  if (!bce_->emitJump(JSOP_IFNE, &loopInfo_->breaks)) {
     //              [stack] NEXT ITER RESULT
     return false;
   }
@@ -185,20 +154,10 @@
 bool ForOfEmitter::emitBody() {
   MOZ_ASSERT(state_ == State::Initialize);
 
-  MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_,
+  MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_ + 1,
              "the stack must be balanced around the initializing "
              "operation");
 
-  // Remove VALUE from the stack to release it.
-  if (!bce_->emit1(JSOP_POP)) {
-    //              [stack] NEXT ITER
-    return false;
-  }
-  if (!bce_->emit1(JSOP_UNDEFINED)) {
-    //              [stack] NEXT ITER UNDEF
-    return false;
-  }
-
 #ifdef DEBUG
   state_ = State::Body;
 #endif
@@ -208,14 +167,16 @@
 bool ForOfEmitter::emitEnd(const Maybe<uint32_t>& iteratedPos) {
   MOZ_ASSERT(state_ == State::Body);
 
-  MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_,
+  MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_ + 1,
              "the stack must be balanced around the for-of body");
 
   if (!loopInfo_->emitEndCodeNeedingIteratorClose(bce_)) {
+    //              [stack] NEXT ITER VALUE
     return false;
   }
 
   if (!loopInfo_->emitContinueTarget(bce_)) {
+    //              [stack] NEXT ITER VALUE
     return false;
   }
 
@@ -229,12 +190,20 @@
     }
   }
 
-  if (!loopInfo_->emitLoopEnd(bce_, JSOP_GOTO, JSTRY_FOR_OF)) {
-    //              [stack] NEXT ITER UNDEF
+  if (!bce_->emit1(JSOP_POP)) {
+    //              [stack] NEXT ITER
     return false;
   }
 
+  if (!loopInfo_->emitLoopEnd(bce_, JSOP_GOTO, JSTRY_FOR_OF)) {
+    //              [stack] NEXT ITER
+    return false;
+  }
+
+  // All jumps/breaks to this point still have an extra value on the stack.
   MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_);
+  bce_->bytecodeSection().setStackDepth(bce_->bytecodeSection().stackDepth() +
+                                        1);
 
   if (!bce_->emitPopN(3)) {
     //              [stack]