# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsParent.cpp
# Commit: 801f97f67366
# Full Hash: 801f97f673666f312a261f94d99e193db7f28818
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2020-01-09 21:39:42
# Regressor Bug: 1600906
# File Overlap Count: 1
# Description:
#   Bug 1600906 - Use InitializedOnce in DirectoryInfo to allow moving instances without additional state. r=dom-workers-and-storage-reviewers,ytausky
#   
#   Depends on D57989
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D57990
# ==============================================================================

diff -r 8f7410826381 -r 801f97f67366 dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp	Thu Jan 09 14:43:57 2020 +0000
+++ b/dom/indexedDB/ActorsParent.cpp	Thu Jan 09 14:58:17 2020 +0000
@@ -8380,23 +8380,23 @@
 };
 
 struct Maintenance::DirectoryInfo final {
-  const nsCString mGroup;
-  const nsCString mOrigin;
-  nsTArray<nsString> mDatabasePaths;
+  InitializedOnce<const nsCString> mGroup;
+  InitializedOnce<const nsCString> mOrigin;
+  InitializedOnce<const nsTArray<nsString>> mDatabasePaths;
   const PersistenceType mPersistenceType;
 
-  DirectoryInfo(PersistenceType aPersistenceType, const nsACString& aGroup,
-                const nsACString& aOrigin, nsTArray<nsString>&& aDatabasePaths)
-      : mGroup(aGroup),
-        mOrigin(aOrigin),
+  DirectoryInfo(PersistenceType aPersistenceType, nsCString aGroup,
+                nsCString aOrigin, nsTArray<nsString>&& aDatabasePaths)
+      : mGroup(std::move(aGroup)),
+        mOrigin(std::move(aOrigin)),
         mDatabasePaths(std::move(aDatabasePaths)),
         mPersistenceType(aPersistenceType) {
     MOZ_ASSERT(aPersistenceType != PERSISTENCE_TYPE_INVALID);
-    MOZ_ASSERT(!aGroup.IsEmpty());
-    MOZ_ASSERT(!aOrigin.IsEmpty());
-#ifdef DEBUG
-    MOZ_ASSERT(!mDatabasePaths.IsEmpty());
-    for (const nsString& databasePath : mDatabasePaths) {
+    MOZ_ASSERT(!mGroup->IsEmpty());
+    MOZ_ASSERT(!mOrigin->IsEmpty());
+#ifdef DEBUG
+    MOZ_ASSERT(!mDatabasePaths->IsEmpty());
+    for (const nsString& databasePath : *mDatabasePaths) {
       MOZ_ASSERT(!databasePath.IsEmpty());
     }
 #endif
@@ -8408,10 +8408,10 @@
       : mGroup(std::move(aOther.mGroup)),
         mOrigin(std::move(aOther.mOrigin)),
         mDatabasePaths(std::move(aOther.mDatabasePaths)),
-        mPersistenceType(std::move(aOther.mPersistenceType)) {
-#ifdef DEBUG
-    MOZ_ASSERT(!mDatabasePaths.IsEmpty());
-    for (const nsString& databasePath : mDatabasePaths) {
+        mPersistenceType(aOther.mPersistenceType) {
+#ifdef DEBUG
+    MOZ_ASSERT(!mDatabasePaths->IsEmpty());
+    for (const nsString& databasePath : *mDatabasePaths) {
       MOZ_ASSERT(!databasePath.IsEmpty());
     }
 #endif
@@ -17662,8 +17662,8 @@
       }
 
       if (!databasePaths.IsEmpty()) {
-        mDirectoryInfos.AppendElement(DirectoryInfo(
-            persistenceType, group, origin, std::move(databasePaths)));
+        mDirectoryInfos.EmplaceBack(persistenceType, group, origin,
+                                    std::move(databasePaths));
 
         nsCOMPtr<nsIFile> directory;
 
@@ -17737,18 +17737,18 @@
   for (DirectoryInfo& directoryInfo : mDirectoryInfos) {
     RefPtr<DirectoryLock> directoryLock;
 
-    for (const nsString& databasePath : directoryInfo.mDatabasePaths) {
+    for (const nsString& databasePath : *directoryInfo.mDatabasePaths) {
       if (Helper::IsSafeToRunMaintenance(databasePath)) {
         if (!directoryLock) {
           directoryLock = mDirectoryLock->Specialize(
-              directoryInfo.mPersistenceType, directoryInfo.mGroup,
-              directoryInfo.mOrigin, Client::IDB);
+              directoryInfo.mPersistenceType, *directoryInfo.mGroup,
+              *directoryInfo.mOrigin, Client::IDB);
           MOZ_ASSERT(directoryLock);
         }
 
         const auto databaseMaintenance = MakeRefPtr<DatabaseMaintenance>(
             this, directoryLock, directoryInfo.mPersistenceType,
-            directoryInfo.mGroup, directoryInfo.mOrigin, databasePath);
+            *directoryInfo.mGroup, *directoryInfo.mOrigin, databasePath);
 
         if (!threadPool) {
           threadPool = mQuotaClient->GetOrCreateThreadPool();
