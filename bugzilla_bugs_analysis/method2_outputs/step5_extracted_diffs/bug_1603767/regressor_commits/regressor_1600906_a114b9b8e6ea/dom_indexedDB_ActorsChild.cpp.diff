# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsChild.cpp
# Commit: a114b9b8e6ea
# Full Hash: a114b9b8e6eaa23a445a31efc436f4e367f7874f
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2020-01-10 21:49:10
# Regressor Bug: 1600906
# File Overlap Count: 1
# Description:
#   Bug 1600906 - Convert IDBCursor and BackgroundCursorChild to templates to increase type safety and reduce state. r=dom-workers-and-storage-reviewers,ytausky
#   
#   This also simplifies delegating calls that are dependent on the cursor type.
#   
#   Also reduce dependency on IDBCursor.h by moving enums and type traits to IDBCursorType.h
# ==============================================================================

diff -r cc3cfee4a014 -r a114b9b8e6ea dom/indexedDB/ActorsChild.cpp
--- a/dom/indexedDB/ActorsChild.cpp	Fri Jan 10 11:07:59 2020 +0000
+++ b/dom/indexedDB/ActorsChild.cpp	Fri Jan 10 14:21:18 2020 +0000
@@ -1276,19 +1276,48 @@
   MOZ_ASSERT(fileHandle->IsOpen() || fileHandle->IsAborted());
 }
 
-auto GetKeyOperator(const IDBCursor::Direction aDirection) {
+auto GetKeyOperator(const IDBCursorDirection aDirection) {
   switch (aDirection) {
-    case IDBCursor::Direction::Next:
-    case IDBCursor::Direction::NextUnique:
+    case IDBCursorDirection::Next:
+    case IDBCursorDirection::Nextunique:
       return &Key::operator>=;
-    case IDBCursor::Direction::Prev:
-    case IDBCursor::Direction::PrevUnique:
+    case IDBCursorDirection::Prev:
+    case IDBCursorDirection::Prevunique:
       return &Key::operator<=;
     default:
       MOZ_CRASH("Should never get here.");
   }
 }
 
+// Does not need to be threadsafe since this only runs on one thread, but
+// inheriting from CancelableRunnable is easy.
+template <typename T>
+class DelayedActionRunnable final : public CancelableRunnable {
+  using ActionFunc = void (T::*)();
+
+  T* mActor;
+  RefPtr<IDBRequest> mRequest;
+  ActionFunc mActionFunc;
+
+ public:
+  explicit DelayedActionRunnable(T* aActor, ActionFunc aActionFunc)
+      : CancelableRunnable("indexedDB::DelayedActionRunnable"),
+        mActor(aActor),
+        mRequest(aActor->GetRequest()),
+        mActionFunc(aActionFunc) {
+    MOZ_ASSERT(aActor);
+    aActor->AssertIsOnOwningThread();
+    MOZ_ASSERT(mRequest);
+    MOZ_ASSERT(mActionFunc);
+  }
+
+ private:
+  ~DelayedActionRunnable() = default;
+
+  NS_DECL_NSIRUNNABLE
+  nsresult Cancel() override;
+};
+
 }  // namespace
 
 /*******************************************************************************
@@ -2338,7 +2367,7 @@
     PBackgroundIDBCursorChild* aActor) {
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundCursorChild*>(aActor);
+  delete aActor;
   return true;
 }
 
@@ -2456,7 +2485,7 @@
     PBackgroundIDBCursorChild* aActor) {
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundCursorChild*>(aActor);
+  delete aActor;
   return true;
 }
 
@@ -3178,102 +3207,37 @@
  * BackgroundCursorChild
  ******************************************************************************/
 
-BackgroundCursorChild::CachedResponse::CachedResponse(
-    Key aKey, StructuredCloneReadInfo&& aCloneInfo)
-    : mKey{std::move(aKey)}, mCloneInfo{std::move(aCloneInfo)} {}
-
-BackgroundCursorChild::CachedResponse::CachedResponse(
-    Key aKey, Key aLocaleAwareKey, Key aObjectStoreKey,
-    StructuredCloneReadInfo&& aCloneInfo)
-    : mKey{std::move(aKey)},
-      mLocaleAwareKey{std::move(aLocaleAwareKey)},
-      mObjectStoreKey{std::move(aObjectStoreKey)},
-      mCloneInfo{std::move(aCloneInfo)} {}
-
-BackgroundCursorChild::CachedResponse::CachedResponse(Key aKey)
-    : mKey{std::move(aKey)} {}
-
-BackgroundCursorChild::CachedResponse::CachedResponse(Key aKey,
-                                                      Key aLocaleAwareKey,
-                                                      Key aObjectStoreKey)
-    : mKey{std::move(aKey)},
-      mLocaleAwareKey{std::move(aLocaleAwareKey)},
-      mObjectStoreKey{std::move(aObjectStoreKey)} {}
-
-// Does not need to be threadsafe since this only runs on one thread, but
-// inheriting from CancelableRunnable is easy.
-class BackgroundCursorChild::DelayedActionRunnable final
-    : public CancelableRunnable {
-  using ActionFunc = void (BackgroundCursorChild::*)();
-
-  BackgroundCursorChild* mActor;
-  RefPtr<IDBRequest> mRequest;
-  ActionFunc mActionFunc;
-
- public:
-  explicit DelayedActionRunnable(BackgroundCursorChild* aActor,
-                                 ActionFunc aActionFunc)
-      : CancelableRunnable(
-            "indexedDB::BackgroundCursorChild::DelayedActionRunnable"),
-        mActor(aActor),
-        mRequest(aActor->mRequest),
-        mActionFunc(aActionFunc) {
-    MOZ_ASSERT(aActor);
-    aActor->AssertIsOnOwningThread();
-    MOZ_ASSERT(mRequest);
-    MOZ_ASSERT(mActionFunc);
-  }
-
- private:
-  ~DelayedActionRunnable() = default;
-
-  NS_DECL_NSIRUNNABLE
-  nsresult Cancel() override;
-};
-
-BackgroundCursorChild::BackgroundCursorChild(IDBRequest* aRequest,
-                                             IDBObjectStore* aObjectStore,
-                                             Direction aDirection)
+BackgroundCursorChildBase::BackgroundCursorChildBase(IDBRequest* const aRequest,
+                                                     const Direction aDirection)
     : mRequest(aRequest),
       mTransaction(aRequest->GetTransaction()),
-      mObjectStore(aObjectStore),
-      mIndex(nullptr),
-      mCursor(nullptr),
       mStrongRequest(aRequest),
-      mDirection(aDirection),
-      mInFlightResponseInvalidationNeeded(false) {
-  MOZ_ASSERT(aObjectStore);
-  aObjectStore->AssertIsOnOwningThread();
+      mDirection(aDirection) {
   MOZ_ASSERT(mTransaction);
-
-  MOZ_COUNT_CTOR(indexedDB::BackgroundCursorChild);
 }
 
-BackgroundCursorChild::BackgroundCursorChild(IDBRequest* aRequest,
-                                             IDBIndex* aIndex,
-                                             Direction aDirection)
-    : mRequest(aRequest),
-      mTransaction(aRequest->GetTransaction()),
-      mObjectStore(nullptr),
-      mIndex(aIndex),
+template <IDBCursorType CursorType>
+BackgroundCursorChild<CursorType>::BackgroundCursorChild(IDBRequest* aRequest,
+                                                         SourceType* aSource,
+                                                         Direction aDirection)
+    : BackgroundCursorChildBase(aRequest, aDirection),
+      mSource(aSource),
       mCursor(nullptr),
-      mStrongRequest(aRequest),
-      mDirection(aDirection),
       mInFlightResponseInvalidationNeeded(false) {
-  MOZ_ASSERT(aIndex);
-  aIndex->AssertIsOnOwningThread();
-  MOZ_ASSERT(mTransaction);
-
-  MOZ_COUNT_CTOR(indexedDB::BackgroundCursorChild);
+  aSource->AssertIsOnOwningThread();
+
+  MOZ_COUNT_CTOR(indexedDB::BackgroundCursorChild<CursorType>);
 }
 
-BackgroundCursorChild::~BackgroundCursorChild() {
-  MOZ_COUNT_DTOR(indexedDB::BackgroundCursorChild);
+template <IDBCursorType CursorType>
+BackgroundCursorChild<CursorType>::~BackgroundCursorChild() {
+  MOZ_COUNT_DTOR(indexedDB::BackgroundCursorChild<CursorType>);
 }
 
-void BackgroundCursorChild::SendContinueInternal(
-    const CursorRequestParams& aParams, const Key& aCurrentKey,
-    const Key& aCurrentObjectStoreKey) {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::SendContinueInternal(
+    const CursorRequestParams& aParams,
+    const CursorData<CursorType>& aCurrentData) {
   AssertIsOnOwningThread();
   MOZ_ASSERT(mRequest);
   MOZ_ASSERT(mTransaction);
@@ -3284,14 +3248,18 @@
   // Make sure all our DOM objects stay alive.
   mStrongCursor = mCursor;
 
-  MOZ_ASSERT(mRequest->ReadyState() == IDBRequestReadyState::Done);
-  mRequest->Reset();
+  MOZ_ASSERT(GetRequest()->ReadyState() == IDBRequestReadyState::Done);
+  GetRequest()->Reset();
 
   mTransaction->OnNewRequest();
 
   CursorRequestParams params = aParams;
-  Key currentKey = aCurrentKey;
-  Key currentObjectStoreKey = aCurrentObjectStoreKey;
+  Key currentKey = aCurrentData.mKey;
+  Key currentObjectStoreKey;
+  // TODO: This is still not nice.
+  if constexpr (!CursorTypeTraits<CursorType>::IsObjectStoreCursor) {
+    currentObjectStoreKey = aCurrentData.mObjectStoreKey;
+  }
 
   switch (params.type()) {
     case CursorRequestParams::TContinueParams: {
@@ -3305,15 +3273,14 @@
           [&key, isLocaleAware = mCursor->IsLocaleAware(),
            keyOperator = GetKeyOperator(mDirection),
            transactionSerialNumber = mTransaction->LoggingSerialNumber(),
-           requestSerialNumber = mRequest->LoggingSerialNumber()](
+           requestSerialNumber = GetRequest()->LoggingSerialNumber()](
               const auto& currentCachedResponse) {
             // This duplicates the logic from the parent. We could avoid this
             // duplication if we invalidated the cached records always for any
             // continue-with-key operation, but would lose the benefits of
             // preloading then.
             const auto& cachedSortKey =
-                isLocaleAware ? currentCachedResponse.mLocaleAwareKey
-                              : currentCachedResponse.mKey;
+                currentCachedResponse.GetSortKey(isLocaleAware);
             const bool discard = !(cachedSortKey.*keyOperator)(key);
             if (discard) {
               IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
@@ -3321,7 +3288,7 @@
                   "Continue, discarding", transactionSerialNumber,
                   requestSerialNumber, key.GetBuffer().get(),
                   cachedSortKey.GetBuffer().get(),
-                  currentCachedResponse.mObjectStoreKey.GetBuffer().get());
+                  currentCachedResponse.GetObjectStoreKeyForLogging());
             } else {
               IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
                   "PRELOAD: Continue to key %s, keeping cached key %s/%s and "
@@ -3329,7 +3296,7 @@
                   "Continue, keeping", transactionSerialNumber,
                   requestSerialNumber, key.GetBuffer().get(),
                   cachedSortKey.GetBuffer().get(),
-                  currentCachedResponse.mObjectStoreKey.GetBuffer().get());
+                  currentCachedResponse.GetObjectStoreKeyForLogging());
             }
 
             return discard;
@@ -3339,56 +3306,61 @@
     }
 
     case CursorRequestParams::TContinuePrimaryKeyParams: {
-      const auto& key = params.get_ContinuePrimaryKeyParams().key();
-      const auto& primaryKey =
-          params.get_ContinuePrimaryKeyParams().primaryKey();
-      if (key.IsUnset() || primaryKey.IsUnset()) {
-        break;
+      if constexpr (!CursorTypeTraits<CursorType>::IsObjectStoreCursor) {
+        const auto& key = params.get_ContinuePrimaryKeyParams().key();
+        const auto& primaryKey =
+            params.get_ContinuePrimaryKeyParams().primaryKey();
+        if (key.IsUnset() || primaryKey.IsUnset()) {
+          break;
+        }
+
+        // Discard cache entries before the target key.
+        DiscardCachedResponses([&key, &primaryKey,
+                                isLocaleAware = mCursor->IsLocaleAware(),
+                                keyCompareOperator = GetKeyOperator(mDirection),
+                                transactionSerialNumber =
+                                    mTransaction->LoggingSerialNumber(),
+                                requestSerialNumber =
+                                    GetRequest()->LoggingSerialNumber()](
+                                   const auto& currentCachedResponse) {
+          // This duplicates the logic from the parent. We could avoid this
+          // duplication if we invalidated the cached records always for any
+          // continue-with-key operation, but would lose the benefits of
+          // preloading then.
+          const auto& cachedSortKey =
+              currentCachedResponse.GetSortKey(isLocaleAware);
+          const auto& cachedSortPrimaryKey =
+              currentCachedResponse.mObjectStoreKey;
+
+          const bool discard =
+              (cachedSortKey == key &&
+               !(cachedSortPrimaryKey.*keyCompareOperator)(primaryKey)) ||
+              !(cachedSortKey.*keyCompareOperator)(key);
+
+          if (discard) {
+            IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
+                "PRELOAD: Continue to key %s with primary key %s, discarding "
+                "cached key %s with cached primary key %s",
+                "Continue, discarding", transactionSerialNumber,
+                requestSerialNumber, key.GetBuffer().get(),
+                primaryKey.GetBuffer().get(), cachedSortKey.GetBuffer().get(),
+                cachedSortPrimaryKey.GetBuffer().get());
+          } else {
+            IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
+                "PRELOAD: Continue to key %s with primary key %s, keeping "
+                "cached key %s with cached primary key %s and further",
+                "Continue, keeping", transactionSerialNumber,
+                requestSerialNumber, key.GetBuffer().get(),
+                primaryKey.GetBuffer().get(), cachedSortKey.GetBuffer().get(),
+                cachedSortPrimaryKey.GetBuffer().get());
+          }
+
+          return discard;
+        });
+      } else {
+        MOZ_CRASH("Shouldn't get here");
       }
 
-      // Discard cache entries before the target key.
-      DiscardCachedResponses(
-          [&key, &primaryKey, isLocaleAware = mCursor->IsLocaleAware(),
-           keyCompareOperator = GetKeyOperator(mDirection),
-           transactionSerialNumber = mTransaction->LoggingSerialNumber(),
-           requestSerialNumber = mRequest->LoggingSerialNumber()](
-              const auto& currentCachedResponse) {
-            // This duplicates the logic from the parent. We could avoid this
-            // duplication if we invalidated the cached records always for any
-            // continue-with-key operation, but would lose the benefits of
-            // preloading then.
-            const auto& cachedSortKey =
-                isLocaleAware ? currentCachedResponse.mLocaleAwareKey
-                              : currentCachedResponse.mKey;
-            const auto& cachedSortPrimaryKey =
-                currentCachedResponse.mObjectStoreKey;
-
-            const bool discard =
-                (cachedSortKey == key &&
-                 !(cachedSortPrimaryKey.*keyCompareOperator)(primaryKey)) ||
-                !(cachedSortKey.*keyCompareOperator)(key);
-
-            if (discard) {
-              IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
-                  "PRELOAD: Continue to key %s with primary key %s, discarding "
-                  "cached key %s with cached primary key %s",
-                  "Continue, discarding", transactionSerialNumber,
-                  requestSerialNumber, key.GetBuffer().get(),
-                  primaryKey.GetBuffer().get(), cachedSortKey.GetBuffer().get(),
-                  cachedSortPrimaryKey.GetBuffer().get());
-            } else {
-              IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
-                  "PRELOAD: Continue to key %s with primary key %s, keeping "
-                  "cached key %s with cached primary key %s and further",
-                  "Continue, keeping", transactionSerialNumber,
-                  requestSerialNumber, key.GetBuffer().get(),
-                  primaryKey.GetBuffer().get(), cachedSortKey.GetBuffer().get(),
-                  cachedSortPrimaryKey.GetBuffer().get());
-            }
-
-            return discard;
-          });
-
       break;
     }
 
@@ -3396,24 +3368,28 @@
       uint32_t& advanceCount = params.get_AdvanceParams().count();
       IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
           "PRELOAD: Advancing %" PRIu32 " records", "Advancing",
-          mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber(),
-          advanceCount);
+          mTransaction->LoggingSerialNumber(),
+          GetRequest()->LoggingSerialNumber(), advanceCount);
 
       // Discard cache entries.
-      DiscardCachedResponses(
-          [&advanceCount, &currentKey,
-           &currentObjectStoreKey](const auto& currentCachedResponse) {
-            const bool res = advanceCount > 1;
-            if (res) {
-              --advanceCount;
-
-              // TODO: We only need to update currentKey on the last entry, the
-              // others are overwritten in the next iteration anyway.
-              currentKey = currentCachedResponse.mKey;
-              currentObjectStoreKey = currentCachedResponse.mObjectStoreKey;
-            }
-            return res;
-          });
+      DiscardCachedResponses([&advanceCount, &currentKey,
+                              &currentObjectStoreKey](
+                                 const auto& currentCachedResponse) {
+        const bool res = advanceCount > 1;
+        if (res) {
+          --advanceCount;
+
+          // TODO: We only need to update currentKey on the last entry, the
+          // others are overwritten in the next iteration anyway.
+          currentKey = currentCachedResponse.mKey;
+          if constexpr (!CursorTypeTraits<CursorType>::IsObjectStoreCursor) {
+            currentObjectStoreKey = currentCachedResponse.mObjectStoreKey;
+          } else {
+            Unused << currentObjectStoreKey;
+          }
+        }
+        return res;
+      });
       break;
     }
 
@@ -3433,8 +3409,8 @@
     // This is accompanied by invalidating cached entries at proper locations to
     // make it correct. To avoid this, further changes are necessary, see Bug
     // 1580499.
-    MOZ_ALWAYS_SUCCEEDS(
-        NS_DispatchToCurrentThread(MakeAndAddRef<DelayedActionRunnable>(
+    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToCurrentThread(
+        MakeAndAddRef<DelayedActionRunnable<BackgroundCursorChild<CursorType>>>(
             this, &BackgroundCursorChild::CompleteContinueRequestFromCache)));
 
     // TODO: Could we preload further entries in the background when the size of
@@ -3446,58 +3422,44 @@
   }
 }
 
-void BackgroundCursorChild::CompleteContinueRequestFromCache() {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::CompleteContinueRequestFromCache() {
   AssertIsOnOwningThread();
   MOZ_ASSERT(mTransaction);
   MOZ_ASSERT(mCursor);
   MOZ_ASSERT(mStrongCursor);
   MOZ_ASSERT(!mDelayedResponses.empty());
+  MOZ_ASSERT(mCursor->GetType() == CursorType);
 
   const RefPtr<IDBCursor> cursor = std::move(mStrongCursor);
 
-  auto& item = mDelayedResponses.front();
-  switch (mCursor->GetType()) {
-    case IDBCursor::Type::ObjectStore:
-      mCursor->Reset(std::move(item.mKey), std::move(item.mCloneInfo));
-      break;
-    case IDBCursor::Type::Index:
-      mCursor->Reset(std::move(item.mKey), std::move(item.mLocaleAwareKey),
-                     std::move(item.mObjectStoreKey),
-                     std::move(item.mCloneInfo));
-      break;
-    case IDBCursor::Type::ObjectStoreKey:
-      mCursor->Reset(std::move(item.mKey));
-      break;
-    case IDBCursor::Type::IndexKey:
-      mCursor->Reset(std::move(item.mKey), std::move(item.mLocaleAwareKey),
-                     std::move(item.mObjectStoreKey));
-      break;
-    default:
-      MOZ_CRASH("Should never get here.");
-  }
+  mCursor->Reset(std::move(mDelayedResponses.front()));
   mDelayedResponses.pop_front();
 
   IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
       "PRELOAD: Consumed 1 cached response, %zu cached responses remaining",
       "Consumed cached response", mTransaction->LoggingSerialNumber(),
-      mRequest->LoggingSerialNumber(),
+      GetRequest()->LoggingSerialNumber(),
       mDelayedResponses.size() + mCachedResponses.size());
 
-  ResultHelper helper(mRequest, mTransaction, cursor);
+  ResultHelper helper(GetRequest(), mTransaction, cursor);
   DispatchSuccessEvent(&helper);
 
   mTransaction->OnRequestFinished(/* aRequestCompletedSuccessfully */ true);
 }
 
-void BackgroundCursorChild::SendDeleteMeInternal() {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::SendDeleteMeInternal() {
   AssertIsOnOwningThread();
   MOZ_ASSERT(!mStrongRequest);
   MOZ_ASSERT(!mStrongCursor);
 
-  mRequest = nullptr;
+  mRequest.reset();
   mTransaction = nullptr;
-  mObjectStore = nullptr;
-  mIndex = nullptr;
+  // TODO: The things until here could be pulled up to
+  // BackgroundCursorChildBase.
+
+  mSource.reset();
 
   if (mCursor) {
     mCursor->ClearBackgroundActor();
@@ -3507,7 +3469,8 @@
   }
 }
 
-void BackgroundCursorChild::InvalidateCachedResponses() {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::InvalidateCachedResponses() {
   AssertIsOnOwningThread();
   MOZ_ASSERT(mTransaction);
   MOZ_ASSERT(mRequest);
@@ -3520,7 +3483,7 @@
 
   IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
       "PRELOAD: Invalidating all %zu cached responses", "Invalidating",
-      mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber(),
+      mTransaction->LoggingSerialNumber(), GetRequest()->LoggingSerialNumber(),
       mCachedResponses.size());
 
   mCachedResponses.clear();
@@ -3533,14 +3496,16 @@
     IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
         "PRELOAD: Setting flag to invalidate in-flight responses",
         "Set flag to invalidate in-flight responses",
-        mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber());
+        mTransaction->LoggingSerialNumber(),
+        GetRequest()->LoggingSerialNumber());
 
     mInFlightResponseInvalidationNeeded = true;
   }
 }
 
+template <IDBCursorType CursorType>
 template <typename Condition>
-void BackgroundCursorChild::DiscardCachedResponses(
+void BackgroundCursorChild<CursorType>::DiscardCachedResponses(
     const Condition& aConditionFunc) {
   size_t discardedCount = 0;
   while (!mCachedResponses.empty() &&
@@ -3550,11 +3515,11 @@
   }
   IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
       "PRELOAD: Discarded %zu cached responses, %zu remaining", "Discarded",
-      mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber(),
+      mTransaction->LoggingSerialNumber(), GetRequest()->LoggingSerialNumber(),
       discardedCount, mCachedResponses.size());
 }
 
-void BackgroundCursorChild::HandleResponse(nsresult aResponse) {
+void BackgroundCursorChildBase::HandleResponse(nsresult aResponse) {
   AssertIsOnOwningThread();
   MOZ_ASSERT(NS_FAILED(aResponse));
   MOZ_ASSERT(NS_ERROR_GET_MODULE(aResponse) == NS_ERROR_MODULE_DOM_INDEXEDDB);
@@ -3563,10 +3528,12 @@
   MOZ_ASSERT(!mStrongRequest);
   MOZ_ASSERT(!mStrongCursor);
 
-  DispatchErrorEvent(mRequest, aResponse, mTransaction);
+  DispatchErrorEvent(GetRequest(), aResponse, mTransaction);
 }
 
-void BackgroundCursorChild::HandleResponse(const void_t& aResponse) {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::HandleResponse(
+    const void_t& aResponse) {
   AssertIsOnOwningThread();
   MOZ_ASSERT(mRequest);
   MOZ_ASSERT(mTransaction);
@@ -3577,23 +3544,25 @@
     mCursor->Reset();
   }
 
-  ResultHelper helper(mRequest, mTransaction, &JS::NullHandleValue);
+  ResultHelper helper(GetRequest(), mTransaction, &JS::NullHandleValue);
   DispatchSuccessEvent(&helper);
 
   if (!mCursor) {
     MOZ_ALWAYS_SUCCEEDS(this->GetActorEventTarget()->Dispatch(
-        MakeAndAddRef<DelayedActionRunnable>(
+        MakeAndAddRef<DelayedActionRunnable<BackgroundCursorChild<CursorType>>>(
             this, &BackgroundCursorChild::SendDeleteMeInternal),
         NS_DISPATCH_NORMAL));
   }
 }
 
+template <IDBCursorType CursorType>
 template <typename... Args>
-RefPtr<IDBCursor> BackgroundCursorChild::HandleIndividualCursorResponse(
+RefPtr<IDBCursor>
+BackgroundCursorChild<CursorType>::HandleIndividualCursorResponse(
     const bool aUseAsCurrentResult, Args&&... aArgs) {
   if (mCursor) {
     if (aUseAsCurrentResult) {
-      mCursor->Reset(std::forward<Args>(aArgs)...);
+      mCursor->Reset(CursorData<CursorType>{std::forward<Args>(aArgs)...});
     } else {
       mCachedResponses.emplace_back(std::forward<Args>(aArgs)...);
     }
@@ -3602,15 +3571,16 @@
 
   MOZ_ASSERT(aUseAsCurrentResult);
 
-  // TODO: This still looks quite dangerous to me. Why is mCursor not a RefPtr?
-  RefPtr<IDBCursor> newCursor =
-      IDBCursor::Create(this, std::forward<Args>(aArgs)...);
+  // TODO: This still looks quite dangerous to me. Why is mCursor not a
+  // RefPtr?
+  auto newCursor = IDBCursor::Create(this, std::forward<Args>(aArgs)...);
   mCursor = newCursor;
   return newCursor;
 }
 
+template <IDBCursorType CursorType>
 template <typename T, typename Func>
-void BackgroundCursorChild::HandleMultipleCursorResponses(
+void BackgroundCursorChild<CursorType>::HandleMultipleCursorResponses(
     const nsTArray<T>& aResponses, const Func& aHandleRecord) {
   AssertIsOnOwningThread();
   MOZ_ASSERT(mRequest);
@@ -3621,7 +3591,7 @@
 
   IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
       "PRELOAD: Received %zu cursor responses", "Received",
-      mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber(),
+      mTransaction->LoggingSerialNumber(), GetRequest()->LoggingSerialNumber(),
       aResponses.Length());
   MOZ_ASSERT_IF(aResponses.Length() > 1, mCachedResponses.empty());
 
@@ -3636,14 +3606,14 @@
   for (auto& response : responses) {
     IDB_LOG_MARK_CHILD_TRANSACTION_REQUEST(
         "PRELOAD: Processing response for key %s", "Processing",
-        mTransaction->LoggingSerialNumber(), mRequest->LoggingSerialNumber(),
-        response.key().GetBuffer().get());
+        mTransaction->LoggingSerialNumber(),
+        GetRequest()->LoggingSerialNumber(), response.key().GetBuffer().get());
 
     // TODO: At the moment, we only send a cursor request to the parent if
-    // requested by the user code. Therefore, the first result is always used as
-    // the current result, and the potential extra results are cached. If we
-    // extended this towards preloading in the background, all results might
-    // need to be cached.
+    // requested by the user code. Therefore, the first result is always used
+    // as the current result, and the potential extra results are cached. If
+    // we extended this towards preloading in the background, all results
+    // might need to be cached.
     auto maybeNewCursor =
         aHandleRecord(/* aUseAsCurrentResult */ isFirst, response);
     if (maybeNewCursor) {
@@ -3657,29 +3627,29 @@
           "PRELOAD: Discarding remaining responses since "
           "mInFlightResponseInvalidationNeeded is set",
           "Discarding responses", mTransaction->LoggingSerialNumber(),
-          mRequest->LoggingSerialNumber());
+          GetRequest()->LoggingSerialNumber());
 
       mInFlightResponseInvalidationNeeded = false;
       break;
     }
   }
 
-  ResultHelper helper(mRequest, mTransaction, mCursor);
+  ResultHelper helper(GetRequest(), mTransaction, mCursor);
   DispatchSuccessEvent(&helper);
 }
 
-void BackgroundCursorChild::HandleResponse(
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::HandleResponse(
     const nsTArray<ObjectStoreCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mObjectStore);
   MOZ_ASSERT(mTransaction);
 
   HandleMultipleCursorResponses(
       aResponses, [this](const bool useAsCurrentResult,
                          ObjectStoreCursorResponse& response) {
-        // TODO: Maybe move the deserialization of the clone-read-info into the
-        // cursor, so that it is only done for records actually accessed, which
-        // might not be the case for all cached records.
+        // TODO: Maybe move the deserialization of the clone-read-info into
+        // the cursor, so that it is only done for records actually accessed,
+        // which might not be the case for all cached records.
         return HandleIndividualCursorResponse(
             useAsCurrentResult, std::move(response.key()),
             DeserializeStructuredCloneReadInfo(std::move(response.cloneInfo()),
@@ -3687,10 +3657,10 @@
       });
 }
 
-void BackgroundCursorChild::HandleResponse(
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::HandleResponse(
     const nsTArray<ObjectStoreKeyCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mObjectStore);
 
   HandleMultipleCursorResponses(
       aResponses, [this](const bool useAsCurrentResult,
@@ -3700,10 +3670,10 @@
       });
 }
 
-void BackgroundCursorChild::HandleResponse(
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::HandleResponse(
     const nsTArray<IndexCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mIndex);
   MOZ_ASSERT(mTransaction);
 
   HandleMultipleCursorResponses(
@@ -3717,10 +3687,11 @@
       });
 }
 
-void BackgroundCursorChild::HandleResponse(
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::HandleResponse(
     const nsTArray<IndexKeyCursorResponse>& aResponses) {
   AssertIsOnOwningThread();
-  MOZ_ASSERT(mIndex);
+  static_assert(!CursorTypeTraits<CursorType>::IsObjectStoreCursor);
 
   HandleMultipleCursorResponses(
       aResponses,
@@ -3731,7 +3702,8 @@
       });
 }
 
-void BackgroundCursorChild::ActorDestroy(ActorDestroyReason aWhy) {
+template <IDBCursorType CursorType>
+void BackgroundCursorChild<CursorType>::ActorDestroy(ActorDestroyReason aWhy) {
   AssertIsOnOwningThread();
   MOZ_ASSERT_IF(aWhy == Deletion, !mStrongRequest);
   MOZ_ASSERT_IF(aWhy == Deletion, !mStrongCursor);
@@ -3751,14 +3723,14 @@
   }
 
 #ifdef DEBUG
-  mRequest = nullptr;
+  mRequest.maybeReset();
   mTransaction = nullptr;
-  mObjectStore = nullptr;
-  mIndex = nullptr;
+  mSource.maybeReset();
 #endif
 }
 
-mozilla::ipc::IPCResult BackgroundCursorChild::RecvResponse(
+template <IDBCursorType CursorType>
+mozilla::ipc::IPCResult BackgroundCursorChild<CursorType>::RecvResponse(
     const CursorResponse& aResponse) {
   AssertIsOnOwningThread();
   MOZ_ASSERT(aResponse.type() != CursorResponse::T__None);
@@ -3786,19 +3758,35 @@
       break;
 
     case CursorResponse::TArrayOfObjectStoreCursorResponse:
-      HandleResponse(aResponse.get_ArrayOfObjectStoreCursorResponse());
+      if constexpr (CursorType == IDBCursorType::ObjectStore) {
+        HandleResponse(aResponse.get_ArrayOfObjectStoreCursorResponse());
+      } else {
+        MOZ_CRASH("Response type mismatch");
+      }
       break;
 
     case CursorResponse::TArrayOfObjectStoreKeyCursorResponse:
-      HandleResponse(aResponse.get_ArrayOfObjectStoreKeyCursorResponse());
+      if constexpr (CursorType == IDBCursorType::ObjectStoreKey) {
+        HandleResponse(aResponse.get_ArrayOfObjectStoreKeyCursorResponse());
+      } else {
+        MOZ_CRASH("Response type mismatch");
+      }
       break;
 
     case CursorResponse::TArrayOfIndexCursorResponse:
-      HandleResponse(aResponse.get_ArrayOfIndexCursorResponse());
+      if constexpr (CursorType == IDBCursorType::Index) {
+        HandleResponse(aResponse.get_ArrayOfIndexCursorResponse());
+      } else {
+        MOZ_CRASH("Response type mismatch");
+      }
       break;
 
     case CursorResponse::TArrayOfIndexKeyCursorResponse:
-      HandleResponse(aResponse.get_ArrayOfIndexKeyCursorResponse());
+      if constexpr (CursorType == IDBCursorType::IndexKey) {
+        HandleResponse(aResponse.get_ArrayOfIndexKeyCursorResponse());
+      } else {
+        MOZ_CRASH("Response type mismatch");
+      }
       break;
 
     default:
@@ -3810,8 +3798,8 @@
   return IPC_OK();
 }
 
-NS_IMETHODIMP
-BackgroundCursorChild::DelayedActionRunnable::Run() {
+template <typename T>
+NS_IMETHODIMP DelayedActionRunnable<T>::Run() {
   MOZ_ASSERT(mActor);
   mActor->AssertIsOnOwningThread();
   MOZ_ASSERT(mRequest);
@@ -3825,7 +3813,8 @@
   return NS_OK;
 }
 
-nsresult BackgroundCursorChild::DelayedActionRunnable::Cancel() {
+template <typename T>
+nsresult DelayedActionRunnable<T>::Cancel() {
   if (NS_WARN_IF(!mActor)) {
     return NS_ERROR_UNEXPECTED;
   }
@@ -3880,8 +3869,9 @@
     mFileHandle->ClearBackgroundActor();
 
     // Normally this would be DEBUG-only but NoteActorDestroyed is also called
-    // from SendDeleteMeInternal. In that case we're going to receive an actual
-    // ActorDestroy call later and we don't want to touch a dead object.
+    // from SendDeleteMeInternal. In that case we're going to receive an
+    // actual ActorDestroy call later and we don't want to touch a dead
+    // object.
     mTemporaryStrongFileHandle = nullptr;
     mFileHandle = nullptr;
   }