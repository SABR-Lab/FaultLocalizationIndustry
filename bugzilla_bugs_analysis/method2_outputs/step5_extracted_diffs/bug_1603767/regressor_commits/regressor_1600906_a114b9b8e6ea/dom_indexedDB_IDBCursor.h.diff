# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/IDBCursor.h
# Commit: a114b9b8e6ea
# Full Hash: a114b9b8e6eaa23a445a31efc436f4e367f7874f
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2020-01-10 21:49:10
# Regressor Bug: 1600906
# File Overlap Count: 1
# Description:
#   Bug 1600906 - Convert IDBCursor and BackgroundCursorChild to templates to increase type safety and reduce state. r=dom-workers-and-storage-reviewers,ytausky
#   
#   This also simplifies delegating calls that are dependent on the cursor type.
#   
#   Also reduce dependency on IDBCursor.h by moving enums and type traits to IDBCursorType.h
# ==============================================================================

diff -r cc3cfee4a014 -r a114b9b8e6ea dom/indexedDB/IDBCursor.h
--- a/dom/indexedDB/IDBCursor.h	Fri Jan 10 11:07:59 2020 +0000
+++ b/dom/indexedDB/IDBCursor.h	Fri Jan 10 14:21:18 2020 +0000
@@ -7,7 +7,9 @@
 #ifndef mozilla_dom_idbcursor_h__
 #define mozilla_dom_idbcursor_h__
 
+#include "IDBCursorType.h"
 #include "IndexedDatabase.h"
+#include "InitializedOnce.h"
 #include "js/RootingAPI.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/IDBCursorBinding.h"
@@ -30,59 +32,42 @@
 class IDBRequest;
 class OwningIDBObjectStoreOrIDBIndex;
 
-namespace indexedDB {
-class BackgroundCursorChild;
-}
+class IDBObjectStoreCursor;
+class IDBObjectStoreKeyCursor;
+class IDBIndexCursor;
+class IDBIndexKeyCursor;
 
-// TODO: Consider defining different subclasses for the different cursor types,
-// possibly using the CRTP, which would remove the need for various case
-// distinctions.
-class IDBCursor final : public nsISupports, public nsWrapperCache {
+namespace indexedDB {
+class BackgroundCursorChildBase;
+template <IDBCursorType CursorType>
+class BackgroundCursorChild;
+}  // namespace indexedDB
+
+class IDBCursor : public nsISupports, public nsWrapperCache {
  public:
   using Key = indexedDB::Key;
   using StructuredCloneReadInfo = indexedDB::StructuredCloneReadInfo;
 
-  enum struct Direction {
-    Next = 0,
-    NextUnique,
-    Prev,
-    PrevUnique,
-
-    // Only needed for IPC serialization helper, should never be used in code.
-    Invalid
-  };
+  using Direction = IDBCursorDirection;
+  using Type = IDBCursorType;
 
-  enum struct Type {
-    ObjectStore,
-    ObjectStoreKey,
-    Index,
-    IndexKey,
-  };
+ protected:
+  InitializedOnceMustBeTrue<indexedDB::BackgroundCursorChildBase* const>
+      mBackgroundActor;
 
- private:
-  indexedDB::BackgroundCursorChild* mBackgroundActor;
+  // TODO: mRequest could be made const if Bug 1575173 is resolved. It is
+  // initialized in the constructor and never modified/cleared.
+  RefPtr<IDBRequest> mRequest;
 
-  // TODO: mRequest, mSourceObjectStore and mSourceIndex could be made const if
-  // Bug 1575173 is resolved. They are initialized in the constructor and never
-  // modified/cleared.
-  RefPtr<IDBRequest> mRequest;
-  RefPtr<IDBObjectStore> mSourceObjectStore;
-  RefPtr<IDBIndex> mSourceIndex;
-
-  // mSourceObjectStore or mSourceIndex will hold this alive.
+  // Sub-classes' mSource will hold this alive.
   const CheckedUnsafePtr<IDBTransaction> mTransaction;
 
+ protected:
   // These are cycle-collected!
   JS::Heap<JS::Value> mCachedKey;
   JS::Heap<JS::Value> mCachedPrimaryKey;
   JS::Heap<JS::Value> mCachedValue;
 
-  Key mKey;
-  Key mSortKey;     ///< AKA locale aware key/position elsewhere
-  Key mPrimaryKey;  ///< AKA object store key/position elsewhere
-  StructuredCloneReadInfo mCloneInfo;
-
-  const Type mType;
   const Direction mDirection;
 
   bool mHaveCachedKey : 1;
@@ -93,22 +78,21 @@
   bool mHaveValue : 1;
 
  public:
-  static MOZ_MUST_USE RefPtr<IDBCursor> Create(
-      indexedDB::BackgroundCursorChild* aBackgroundActor, Key aKey,
-      StructuredCloneReadInfo&& aCloneInfo);
+  static MOZ_MUST_USE RefPtr<IDBObjectStoreCursor> Create(
+      indexedDB::BackgroundCursorChild<Type::ObjectStore>* aBackgroundActor,
+      Key aKey, StructuredCloneReadInfo&& aCloneInfo);
 
-  static MOZ_MUST_USE RefPtr<IDBCursor> Create(
-      indexedDB::BackgroundCursorChild* aBackgroundActor, Key aKey);
+  static MOZ_MUST_USE RefPtr<IDBObjectStoreKeyCursor> Create(
+      indexedDB::BackgroundCursorChild<Type::ObjectStoreKey>* aBackgroundActor,
+      Key aKey);
 
-  static MOZ_MUST_USE RefPtr<IDBCursor> Create(
-      indexedDB::BackgroundCursorChild* aBackgroundActor, Key aKey,
+  static MOZ_MUST_USE RefPtr<IDBIndexCursor> Create(
+      indexedDB::BackgroundCursorChild<Type::Index>* aBackgroundActor, Key aKey,
       Key aSortKey, Key aPrimaryKey, StructuredCloneReadInfo&& aCloneInfo);
 
-  static MOZ_MUST_USE RefPtr<IDBCursor> Create(
-      indexedDB::BackgroundCursorChild* aBackgroundActor, Key aKey,
-      Key aSortKey, Key aPrimaryKey);
-
-  static Direction ConvertDirection(IDBCursorDirection aDirection);
+  static MOZ_MUST_USE RefPtr<IDBIndexKeyCursor> Create(
+      indexedDB::BackgroundCursorChild<Type::IndexKey>* aBackgroundActor,
+      Key aKey, Key aSortKey, Key aPrimaryKey);
 
   void AssertIsOnOwningThread() const
 #ifdef DEBUG
@@ -120,74 +104,183 @@
 
   nsIGlobalObject* GetParentObject() const;
 
-  void GetSource(OwningIDBObjectStoreOrIDBIndex& aSource) const;
+  // XXX: The virtual methods that are used by the DOM binding could be removed
+  // on the base class, if we provided a non-polymorphic wrapper instead, which
+  // uses a custom dispatch to the actual implementation type. Don't know if
+  // this is worth it.
+
+  virtual void GetSource(OwningIDBObjectStoreOrIDBIndex& aSource) const = 0;
 
   IDBCursorDirection GetDirection() const;
 
-  Type GetType() const;
-
-  void GetKey(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
-              ErrorResult& aRv);
-
-  void GetPrimaryKey(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
-                     ErrorResult& aRv);
+  virtual void GetKey(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
+                      ErrorResult& aRv) = 0;
 
-  void GetValue(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
-                ErrorResult& aRv);
+  virtual void GetPrimaryKey(JSContext* aCx,
+                             JS::MutableHandle<JS::Value> aResult,
+                             ErrorResult& aRv) = 0;
 
-  void Continue(JSContext* aCx, JS::Handle<JS::Value> aKey, ErrorResult& aRv);
-
-  void ContinuePrimaryKey(JSContext* aCx, JS::Handle<JS::Value> aKey,
-                          JS::Handle<JS::Value> aPrimaryKey, ErrorResult& aRv);
+  // XXX: We could move this to a sub-class, since this is only present on
+  // IDBCursorWithValue.
+  virtual void GetValue(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
+                        ErrorResult& aRv) = 0;
 
-  void Advance(uint32_t aCount, ErrorResult& aRv);
+  virtual void Continue(JSContext* aCx, JS::Handle<JS::Value> aKey,
+                        ErrorResult& aRv) = 0;
 
-  MOZ_MUST_USE RefPtr<IDBRequest> Update(JSContext* aCx,
-                                         JS::Handle<JS::Value> aValue,
-                                         ErrorResult& aRv);
-
-  MOZ_MUST_USE RefPtr<IDBRequest> Delete(JSContext* aCx, ErrorResult& aRv);
+  virtual void ContinuePrimaryKey(JSContext* aCx, JS::Handle<JS::Value> aKey,
+                                  JS::Handle<JS::Value> aPrimaryKey,
+                                  ErrorResult& aRv) = 0;
 
-  void Reset();
-
-  void Reset(Key&& aKey, StructuredCloneReadInfo&& aValue);
+  virtual void Advance(uint32_t aCount, ErrorResult& aRv) = 0;
 
-  void Reset(Key&& aKey);
+  virtual MOZ_MUST_USE RefPtr<IDBRequest> Update(JSContext* aCx,
+                                                 JS::Handle<JS::Value> aValue,
+                                                 ErrorResult& aRv) = 0;
 
-  void Reset(Key&& aKey, Key&& aSortKey, Key&& aPrimaryKey,
-             StructuredCloneReadInfo&& aValue);
-
-  void Reset(Key&& aKey, Key&& aSortKey, Key&& aPrimaryKey);
+  virtual MOZ_MUST_USE RefPtr<IDBRequest> Delete(JSContext* aCx,
+                                                 ErrorResult& aRv) = 0;
 
   void ClearBackgroundActor() {
     AssertIsOnOwningThread();
 
-    mBackgroundActor = nullptr;
+    mBackgroundActor.reset();
   }
 
-  void InvalidateCachedResponses();
-
-  // Checks if this is a locale aware cursor (ie. the index's sortKey is unset)
-  bool IsLocaleAware() const;
+  virtual void InvalidateCachedResponses() = 0;
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(IDBCursor)
 
+ protected:
+  IDBCursor(indexedDB::BackgroundCursorChildBase* aBackgroundActor);
+
+  // TODO: Check if we can remove virtual by changing cycle collection.
+  virtual ~IDBCursor() = default;
+
+  void ResetBase();
+};
+
+template <IDBCursor::Type CursorType>
+class IDBTypedCursor : public IDBCursor {
+ public:
+  template <typename... DataArgs>
+  explicit IDBTypedCursor(
+      indexedDB::BackgroundCursorChild<CursorType>* aBackgroundActor,
+      DataArgs&&... aDataArgs);
+
+  static constexpr Type GetType() { return CursorType; }
+
+  // Checks if this is a locale aware cursor (ie. the index's sortKey is unset)
+  bool IsLocaleAware() const;
+
+  void GetSource(OwningIDBObjectStoreOrIDBIndex& aSource) const final;
+
+  void GetKey(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
+              ErrorResult& aRv) final;
+
+  void GetPrimaryKey(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
+                     ErrorResult& aRv) final;
+
+  void GetValue(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
+                ErrorResult& aRv) final;
+
+  void Continue(JSContext* aCx, JS::Handle<JS::Value> aKey,
+                ErrorResult& aRv) final;
+
+  void ContinuePrimaryKey(JSContext* aCx, JS::Handle<JS::Value> aKey,
+                          JS::Handle<JS::Value> aPrimaryKey,
+                          ErrorResult& aRv) final;
+
+  void Advance(uint32_t aCount, ErrorResult& aRv) final;
+
+  MOZ_MUST_USE RefPtr<IDBRequest> Update(JSContext* aCx,
+                                         JS::Handle<JS::Value> aValue,
+                                         ErrorResult& aRv) final;
+
+  MOZ_MUST_USE RefPtr<IDBRequest> Delete(JSContext* aCx,
+                                         ErrorResult& aRv) final;
+
   // nsWrapperCache
-  virtual JSObject* WrapObject(JSContext* aCx,
-                               JS::Handle<JSObject*> aGivenProto) override;
+  JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) final;
+
+  void InvalidateCachedResponses() final;
+
+  void Reset();
+
+  void Reset(CursorData<CursorType>&& aCursorData);
 
  private:
-  IDBCursor(Type aType, indexedDB::BackgroundCursorChild* aBackgroundActor,
-            Key aKey);
+  static constexpr bool IsObjectStoreCursor =
+      CursorTypeTraits<CursorType>::IsObjectStoreCursor;
+  static constexpr bool IsKeyOnlyCursor =
+      CursorTypeTraits<CursorType>::IsKeyOnlyCursor;
+
+  CursorSourceType<CursorType>& GetSourceRef() const {
+    MOZ_ASSERT(mSource);
+    return *mSource;
+  }
+
+  IDBObjectStore& GetSourceObjectStoreRef() const {
+    if constexpr (IsObjectStoreCursor) {
+      return GetSourceRef();
+    } else {
+      MOZ_ASSERT(!GetSourceRef().IsDeleted());
 
-  ~IDBCursor();
+      auto res = GetSourceRef().ObjectStore();
+      MOZ_ASSERT(res);
+      return *res;
+    }
+  }
+
+  indexedDB::BackgroundCursorChild<CursorType>& GetTypedBackgroundActorRef()
+      const {
+    // We can safely downcast to BackgroundCursorChild<CursorType>*, since we
+    // initialized that in the constructor from that type. We just want to avoid
+    // having a second typed field.
+    return *static_cast<indexedDB::BackgroundCursorChild<CursorType>*>(
+        *mBackgroundActor);
+  }
+
+  bool IsSourceDeleted() const;
+
+ protected:
+  virtual ~IDBTypedCursor() override;
 
   void DropJSObjects();
 
-  bool IsSourceDeleted() const;
+  CursorData<CursorType> mData;
+
+  // TODO: mSource could be made const if Bug 1575173 is resolved. It is
+  // initialized in the constructor and never modified/cleared.
+  RefPtr<CursorSourceType<CursorType>> mSource;
 };
 
+// The subclasses defined by this macro are only needed to be able to use the
+// cycle collector macros, which do not support templates. If spelled out, the
+// cycle collection could be implemented directly on IDBTypedCursor, and these
+// classes were not needed.
+#define CONCRETE_IDBCURSOR_SUBCLASS(_subclassName, _cursorType)        \
+  class _subclassName final : public IDBTypedCursor<_cursorType> {     \
+   public:                                                             \
+    NS_DECL_ISUPPORTS_INHERITED                                        \
+    NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(_subclassName, IDBCursor) \
+                                                                       \
+    using IDBTypedCursor<_cursorType>::IDBTypedCursor;                 \
+                                                                       \
+   private:                                                            \
+    ~_subclassName() final = default;                                  \
+  };
+
+CONCRETE_IDBCURSOR_SUBCLASS(IDBObjectStoreCursor, IDBCursor::Type::ObjectStore)
+CONCRETE_IDBCURSOR_SUBCLASS(IDBObjectStoreKeyCursor,
+                            IDBCursor::Type::ObjectStoreKey)
+CONCRETE_IDBCURSOR_SUBCLASS(IDBIndexCursor, IDBCursor::Type::Index)
+CONCRETE_IDBCURSOR_SUBCLASS(IDBIndexKeyCursor, IDBCursor::Type::IndexKey)
+
+template <IDBCursor::Type CursorType>
+using IDBCursorImpl = typename CursorTypeTraits<CursorType>::Type;
+
 }  // namespace dom
 }  // namespace mozilla
 