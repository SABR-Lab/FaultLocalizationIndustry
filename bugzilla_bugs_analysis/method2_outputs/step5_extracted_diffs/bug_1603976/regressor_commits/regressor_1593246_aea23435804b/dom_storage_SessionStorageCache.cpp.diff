# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/storage/SessionStorageCache.cpp
# Commit: aea23435804b
# Full Hash: aea23435804b56798dbae8fa46dfccb8cbdca131
# Author: Yaron Tausky <ytausky@mozilla.com>
# Date: 2019-12-13 16:53:24
# Regressor Bug: 1593246
# File Overlap Count: 6
# Description:
#   Bug 1593246 - Part 5: Replicate session storage data r=janv,asuth
#   
#   This commit implements a simple data replication scheme, where
#   each content process receives a copy of the relevant session
#   storage data when navigating, and sending all its session storage
# ==============================================================================

diff -r da1672f831d1 -r aea23435804b dom/storage/SessionStorageCache.cpp
--- a/dom/storage/SessionStorageCache.cpp	Fri Dec 13 09:16:32 2019 +0000
+++ b/dom/storage/SessionStorageCache.cpp	Fri Dec 13 09:45:55 2019 +0000
@@ -6,6 +6,8 @@
 
 #include "SessionStorageCache.h"
 
+#include "mozilla/dom/PContent.h"
+
 namespace mozilla {
 namespace dom {
 
@@ -129,6 +131,27 @@
   return cache.forget();
 }
 
+nsTArray<KeyValuePair> SessionStorageCache::SerializeData(
+    DataSetType aDataSetType) {
+  nsTArray<KeyValuePair> data;
+  for (auto iter = Set(aDataSetType)->mKeys.Iter(); !iter.Done(); iter.Next()) {
+    KeyValuePair keyValuePair;
+    keyValuePair.key() = iter.Key();
+    keyValuePair.value() = iter.Data();
+    data.EmplaceBack(std::move(keyValuePair));
+  }
+  return data;
+}
+
+void SessionStorageCache::DeserializeData(DataSetType aDataSetType,
+                                          const nsTArray<KeyValuePair>& aData) {
+  Clear(aDataSetType, false);
+  for (const auto& keyValuePair : aData) {
+    nsString oldValue;
+    SetItem(aDataSetType, keyValuePair.key(), keyValuePair.value(), oldValue);
+  }
+}
+
 bool SessionStorageCache::DataSet::ProcessUsageDelta(int64_t aDelta) {
   // Check limit per this origin
   uint64_t newOriginUsage = mOriginQuotaUsage + aDelta;