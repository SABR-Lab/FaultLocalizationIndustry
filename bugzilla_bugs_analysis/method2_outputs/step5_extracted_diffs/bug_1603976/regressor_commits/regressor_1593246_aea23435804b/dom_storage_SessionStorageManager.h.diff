# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/storage/SessionStorageManager.h
# Commit: aea23435804b
# Full Hash: aea23435804b56798dbae8fa46dfccb8cbdca131
# Author: Yaron Tausky <ytausky@mozilla.com>
# Date: 2019-12-13 16:53:24
# Regressor Bug: 1593246
# File Overlap Count: 6
# Description:
#   Bug 1593246 - Part 5: Replicate session storage data r=janv,asuth
#   
#   This commit implements a simple data replication scheme, where
#   each content process receives a copy of the relevant session
#   storage data when navigating, and sending all its session storage
# ==============================================================================

diff -r da1672f831d1 -r aea23435804b dom/storage/SessionStorageManager.h
--- a/dom/storage/SessionStorageManager.h	Fri Dec 13 09:16:32 2019 +0000
+++ b/dom/storage/SessionStorageManager.h	Fri Dec 13 09:45:55 2019 +0000
@@ -9,15 +9,37 @@
 
 #include "nsIDOMStorageManager.h"
 #include "nsClassHashtable.h"
+#include "nsHashKeys.h"
 #include "nsRefPtrHashtable.h"
 #include "StorageObserver.h"
 
 namespace mozilla {
 namespace dom {
 
+class ContentParent;
+class KeyValuePair;
 class SessionStorageCache;
 class SessionStorageObserver;
 
+// sessionStorage is a data store that's unique to each tab (i.e. top-level
+// browsing context) and origin. Before the advent of Fission all the data
+// for a given tab could be stored in a single content process; now each
+// site-specific process stores only its portion of the data. As content
+// processes terminate, their sessionStorage data needs to be saved in the
+// parent process, in case the same origin appears again in the tab (e.g.
+// by navigating an iframe element). Therefore SessionStorageManager
+// objects exist in both the parent and content processes.
+//
+// Whenever a content process terminates it sends its sessionStorage data
+// to the parent process (see SessionStorageService); whenever a content
+// process navigates to an origin for the first time in a given tab, the
+// parent process sends it the saved data. To avoid sending the data
+// multiple times, the parent process maintains a table of content
+// processes that already received it; this table is empty in content
+// processes.
+//
+// Note: the current implementation is expected to be replaced by a new
+// implementation using LSNG.
 class SessionStorageManager final : public nsIDOMSessionStorageManager,
                                     public StorageObserverSink {
  public:
@@ -33,6 +55,16 @@
     return mBrowsingContext;
   }
 
+  void SendSessionStorageDataToParentProcess();
+  void SendSessionStorageDataToContentProcess(ContentParent* aActor,
+                                              nsIPrincipal* aPrincipal);
+
+  void LoadSessionStorageData(ContentParent* aSource,
+                              const nsACString& aOriginAttrs,
+                              const nsACString& aOriginKey,
+                              const nsTArray<KeyValuePair>& aDefaultData,
+                              const nsTArray<KeyValuePair>& aSessionData);
+
  private:
   ~SessionStorageManager();
 
@@ -61,8 +93,22 @@
                                         SessionStorageCache* aCloneFrom,
                                         RefPtr<SessionStorageCache>* aRetVal);
 
-  typedef nsRefPtrHashtable<nsCStringHashKey, SessionStorageCache>
-      OriginKeyHashTable;
+  struct OriginRecord {
+    RefPtr<SessionStorageCache> mCache;
+    nsTHashtable<nsUint64HashKey> mKnownTo;
+  };
+
+  OriginRecord* GetOriginRecord(const nsACString& aOriginAttrs,
+                                const nsACString& aOriginKey,
+                                bool aMakeIfNeeded,
+                                SessionStorageCache* aCloneFrom);
+
+  template <typename Actor>
+  void SendSessionStorageCache(Actor* aActor, const nsACString& aOriginAttrs,
+                               const nsACString& aOriginKey,
+                               SessionStorageCache* aCache);
+
+  using OriginKeyHashTable = nsClassHashtable<nsCStringHashKey, OriginRecord>;
   nsClassHashtable<nsCStringHashKey, OriginKeyHashTable> mOATable;
 
   RefPtr<SessionStorageObserver> mObserver;