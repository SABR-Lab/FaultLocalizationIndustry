# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/storage/SessionStorageService.cpp
# Commit: aea23435804b
# Full Hash: aea23435804b56798dbae8fa46dfccb8cbdca131
# Author: Yaron Tausky <ytausky@mozilla.com>
# Date: 2019-12-13 16:53:24
# Regressor Bug: 1593246
# File Overlap Count: 6
# Description:
#   Bug 1593246 - Part 5: Replicate session storage data r=janv,asuth
#   
#   This commit implements a simple data replication scheme, where
#   each content process receives a copy of the relevant session
#   storage data when navigating, and sending all its session storage
# ==============================================================================

diff -r da1672f831d1 -r aea23435804b dom/storage/SessionStorageService.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/storage/SessionStorageService.cpp	Fri Dec 13 09:45:55 2019 +0000
@@ -0,0 +1,95 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SessionStorageService.h"
+
+#include "mozilla/Services.h"
+#include "mozilla/Unused.h"
+#include "nsIObserverService.h"
+#include "nsXULAppAPI.h"
+
+#include <cstring>
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+const char* const kContentProcessShutdownTopic = "content-child-will-shutdown";
+
+}
+
+RefPtr<SessionStorageService> SessionStorageService::sService = nullptr;
+bool SessionStorageService::sShutdown = false;
+
+NS_IMPL_ISUPPORTS(SessionStorageService, nsIObserver)
+
+SessionStorageService::SessionStorageService() {
+  if (const nsCOMPtr<nsIObserverService> observerService =
+          services::GetObserverService()) {
+    Unused << observerService->AddObserver(this, kContentProcessShutdownTopic,
+                                           false);
+  }
+}
+
+SessionStorageService::~SessionStorageService() {
+  if (const nsCOMPtr<nsIObserverService> observerService =
+          services::GetObserverService()) {
+    Unused << observerService->RemoveObserver(this,
+                                              kContentProcessShutdownTopic);
+  }
+}
+
+SessionStorageService* SessionStorageService::Get() {
+  if (sShutdown) {
+    return nullptr;
+  }
+
+  if (XRE_IsParentProcess()) {
+    ShutDown();
+    return nullptr;
+  }
+
+  if (!sService) {
+    sService = new SessionStorageService();
+  }
+
+  return sService;
+}
+
+NS_IMETHODIMP SessionStorageService::Observe(nsISupports* const aSubject,
+                                             const char* const aTopic,
+                                             const char16_t* const aData) {
+  if (std::strcmp(aTopic, kContentProcessShutdownTopic) == 0) {
+    SendSessionStorageDataToParentProcess();
+    ShutDown();
+  }
+  return NS_OK;
+}
+
+void SessionStorageService::RegisterSessionStorageManager(
+    SessionStorageManager* aManager) {
+  mManagers.PutEntry(aManager);
+}
+
+void SessionStorageService::UnregisterSessionStorageManager(
+    SessionStorageManager* aManager) {
+  if (const auto entry = mManagers.GetEntry(aManager)) {
+    mManagers.RemoveEntry(entry);
+  }
+}
+
+void SessionStorageService::SendSessionStorageDataToParentProcess() {
+  for (auto iter = mManagers.Iter(); !iter.Done(); iter.Next()) {
+    iter.Get()->GetKey()->SendSessionStorageDataToParentProcess();
+  }
+}
+
+void SessionStorageService::ShutDown() {
+  sShutdown = true;
+  sService = nullptr;
+}
+
+}  // namespace dom
+}  // namespace mozilla