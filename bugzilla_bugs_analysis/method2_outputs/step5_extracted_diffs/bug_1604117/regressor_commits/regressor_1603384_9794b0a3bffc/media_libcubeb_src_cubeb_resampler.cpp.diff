# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/libcubeb/src/cubeb_resampler.cpp
# Commit: 9794b0a3bffc
# Full Hash: 9794b0a3bffc474951b33527b738488717caffbf
# Author: Alex Chronopoulos <achronop@gmail.com>
# Date: 2019-12-12 21:50:40
# Regressor Bug: 1603384
# File Overlap Count: 1
# Description:
#   Bug 1603384 - Update cubeb from upstream to aa63601. r=padenot
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D56872
# ==============================================================================

diff -r 7d77d727cd1e -r 9794b0a3bffc media/libcubeb/src/cubeb_resampler.cpp
--- a/media/libcubeb/src/cubeb_resampler.cpp	Thu Dec 12 17:46:46 2019 +0200
+++ b/media/libcubeb/src/cubeb_resampler.cpp	Thu Dec 12 15:24:23 2019 +0000
@@ -61,23 +61,46 @@
   if (input_buffer) {
     assert(input_frames_count);
   }
-  assert((input_buffer && output_buffer) ||
+  assert((input_buffer && output_buffer &&
+         *input_frames_count + static_cast<int>(samples_to_frames(internal_input_buffer.length())) >= output_frames) ||
          (output_buffer && !input_buffer && (!input_frames_count || *input_frames_count == 0)) ||
          (input_buffer && !output_buffer && output_frames == 0));
 
-  if (input_buffer) {
-    if (!output_buffer) {
+  // When we have no pending input data and exactly as much input
+  // as output data, we don't need to copy it into the internal buffer
+  // and can directly forward it to the callback.
+  void * in_buf = input_buffer;
+  unsigned long pop_input_count = 0u;
+  if (input_buffer && !output_buffer) {
       output_frames = *input_frames_count;
+  } else if(input_buffer) {
+    if (internal_input_buffer.length() != 0) {
+      // In this case we have pending input data left and have
+      // to first append the input so we can pass it as one pointer
+      // to the callback
+      internal_input_buffer.push(static_cast<T*>(input_buffer),
+                                 frames_to_samples(*input_frames_count));
+      in_buf = internal_input_buffer.data();
+      pop_input_count = frames_to_samples(output_frames);
+    } else if(*input_frames_count > output_frames) {
+      // In this case we have more input that we need output and
+      // fill the overflowing input into internal_input_buffer
+      // Since we have no other pending data, we can nonetheless
+      // pass the current input data directly to the callback
+      assert(pop_input_count == 0);
+      unsigned long samples_off = frames_to_samples(output_frames);
+      internal_input_buffer.push(static_cast<T*>(input_buffer) + samples_off,
+                                 frames_to_samples(*input_frames_count - output_frames));
     }
-    internal_input_buffer.push(static_cast<T*>(input_buffer),
-                               frames_to_samples(*input_frames_count));
   }
 
-  long rv = data_callback(stream, user_ptr, internal_input_buffer.data(),
-                          output_buffer, output_frames);
+  long rv = data_callback(stream, user_ptr, in_buf, output_buffer, output_frames);
 
   if (input_buffer) {
-    internal_input_buffer.pop(nullptr, frames_to_samples(output_frames));
+    if (pop_input_count) {
+      internal_input_buffer.pop(nullptr, pop_input_count);
+    }
+
     *input_frames_count = output_frames;
     drop_audio_if_needed();
   }