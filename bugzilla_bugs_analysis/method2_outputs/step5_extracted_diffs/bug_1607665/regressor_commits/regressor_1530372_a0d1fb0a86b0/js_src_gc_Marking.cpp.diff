# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Marking.cpp
# Commit: a0d1fb0a86b0
# Full Hash: a0d1fb0a86b04c74a8809c35230382f90cdfe779
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2020-01-07 21:57:58
# Regressor Bug: 1530372
# File Overlap Count: 1
# Description:
#   Bug 1530372 - Part 4: Support nursery allocation for BigInt. r=sfink,jandem
#   
#   Most of the code was copied from the String nursery allocation code paths and
#   then adjusted to work with BigInts. Where applicable, the newly added BigInt
#   functions were placed right next to the String functions, so it's easier to
# ==============================================================================

diff -r 9ae1e055de13 -r a0d1fb0a86b0 js/src/gc/Marking.cpp
--- a/js/src/gc/Marking.cpp	Thu Jan 02 13:04:45 2020 +0000
+++ b/js/src/gc/Marking.cpp	Mon Jan 06 12:49:45 2020 +0000
@@ -859,6 +859,18 @@
   return str->asTenured().zone()->shouldMarkInZone();
 }
 
+// BigInts can also be in the nursery. See ShouldMark<JSObject*> for comments.
+template <>
+bool ShouldMark<JS::BigInt*>(GCMarker* gcmarker, JS::BigInt* bi) {
+  if (IsOwnedByOtherRuntime(gcmarker->runtime(), bi)) {
+    return false;
+  }
+  if (IsInsideNursery(bi)) {
+    return false;
+  }
+  return bi->asTenured().zone()->shouldMarkInZone();
+}
+
 template <typename T>
 void DoMarking(GCMarker* gcmarker, T* thing) {
   // Do per-type marking precondition checks.
@@ -2951,6 +2963,17 @@
   }
 }
 
+template <>
+void TenuringTracer::traverse(JS::BigInt** bip) {
+  // We only ever visit the internals of BigInts after moving them to tenured.
+  MOZ_ASSERT(!nursery().isInside(bip));
+
+  Cell** cellp = reinterpret_cast<Cell**>(bip);
+  if (IsInsideNursery(*cellp) && !nursery().getForwardedPointer(cellp)) {
+    *bip = moveToTenured(*bip);
+  }
+}
+
 template <typename T>
 void TenuringTracer::traverse(T* thingp) {
   auto tenured = MapGCThingTyped(*thingp, [this](auto t) {
@@ -2983,6 +3006,7 @@
 template void StoreBuffer::MonoTypeBuffer<StoreBuffer::SlotsEdge>::trace(
     TenuringTracer&);
 template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::StringPtrEdge>;
+template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::BigIntPtrEdge>;
 template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::ObjectPtrEdge>;
 }  // namespace gc
 }  // namespace js
@@ -3028,6 +3052,10 @@
   str->traceChildren(&mover);
 }
 
+static inline void TraceWholeCell(TenuringTracer& mover, JS::BigInt* bi) {
+  bi->traceChildren(&mover);
+}
+
 static inline void TraceWholeCell(TenuringTracer& mover, JSScript* script) {
   script->traceChildren(&mover);
 }
@@ -3069,6 +3097,9 @@
       case JS::TraceKind::String:
         TraceBufferedCells<JSString>(mover, arena, cells);
         break;
+      case JS::TraceKind::BigInt:
+        TraceBufferedCells<JS::BigInt>(mover, arena, cells);
+        break;
       case JS::TraceKind::Script:
         TraceBufferedCells<JSScript>(mover, arena, cells);
         break;
@@ -3157,6 +3188,10 @@
   str->traceChildren(this);
 }
 
+void js::TenuringTracer::traceBigInt(JS::BigInt* bi) {
+  bi->traceChildren(this);
+}
+
 #ifdef DEBUG
 static inline ptrdiff_t OffsetToChunkEnd(void* p) {
   return ChunkLocationOffset - (uintptr_t(p) & gc::ChunkMask);
@@ -3403,6 +3438,33 @@
   return dst;
 }
 
+inline void js::TenuringTracer::insertIntoBigIntFixupList(
+    RelocationOverlay* entry) {
+  *bigIntTail = entry;
+  bigIntTail = &entry->nextRef();
+  *bigIntTail = nullptr;
+}
+
+JS::BigInt* js::TenuringTracer::moveToTenured(JS::BigInt* src) {
+  MOZ_ASSERT(IsInsideNursery(src));
+  MOZ_ASSERT(!src->zone()->usedByHelperThread());
+
+  AllocKind dstKind = src->getAllocKind();
+  Zone* zone = src->zone();
+  zone->tenuredBigInts++;
+
+  JS::BigInt* dst = allocTenured<JS::BigInt>(zone, dstKind);
+  tenuredSize += moveBigIntToTenured(dst, src, dstKind);
+  tenuredCells++;
+
+  RelocationOverlay* overlay = RelocationOverlay::fromCell(src);
+  overlay->forwardTo(dst);
+  insertIntoBigIntFixupList(overlay);
+
+  gcTracer.tracePromoteToTenured(src, dst);
+  return dst;
+}
+
 void js::Nursery::collectToFixedPoint(TenuringTracer& mover,
                                       TenureCountCache& tenureCounts) {
   for (RelocationOverlay* p = mover.objHead; p; p = p->next()) {
@@ -3421,6 +3483,10 @@
   for (RelocationOverlay* p = mover.stringHead; p; p = p->next()) {
     mover.traceString(static_cast<JSString*>(p->forwardingAddress()));
   }
+
+  for (RelocationOverlay* p = mover.bigIntHead; p; p = p->next()) {
+    mover.traceBigInt(static_cast<JS::BigInt*>(p->forwardingAddress()));
+  }
 }
 
 size_t js::TenuringTracer::moveStringToTenured(JSString* dst, JSString* src,
@@ -3444,6 +3510,48 @@
   return size;
 }
 
+size_t js::TenuringTracer::moveBigIntToTenured(JS::BigInt* dst, JS::BigInt* src,
+                                               AllocKind dstKind) {
+  size_t size = Arena::thingSize(dstKind);
+
+  // At the moment, BigInts always have the same AllocKind between src and
+  // dst. This may change in the future.
+  MOZ_ASSERT(dst->asTenured().getAllocKind() == src->getAllocKind());
+
+  // Copy the Cell contents.
+  MOZ_ASSERT(OffsetToChunkEnd(src) >= ptrdiff_t(size));
+  js_memcpy(dst, src, size);
+
+  MOZ_ASSERT(dst->zone() == src->zone());
+
+  if (src->hasHeapDigits()) {
+    size_t length = dst->digitLength();
+    if (!nursery().isInside(src->heapDigits_)) {
+      nursery().removeMallocedBuffer(src->heapDigits_);
+    } else {
+      Zone* zone = src->zone();
+      {
+        AutoEnterOOMUnsafeRegion oomUnsafe;
+        dst->heapDigits_ = zone->pod_malloc<JS::BigInt::Digit>(length);
+        if (!dst->heapDigits_) {
+          oomUnsafe.crash(sizeof(JS::BigInt::Digit) * length,
+                          "Failed to allocate digits while tenuring.");
+        }
+      }
+
+      PodCopy(dst->heapDigits_, src->heapDigits_, length);
+      nursery().setDirectForwardingPointer(src->heapDigits_, dst->heapDigits_);
+
+      size += length * sizeof(JS::BigInt::Digit);
+    }
+
+    AddCellMemory(dst, length * sizeof(JS::BigInt::Digit),
+                  MemoryUse::BigIntDigits);
+  }
+
+  return size;
+}
+
 /*** IsMarked / IsAboutToBeFinalized ****************************************/
 
 template <typename T>
@@ -3503,7 +3611,8 @@
 template <typename T>
 struct MightBeNurseryAllocated {
   static const bool value = mozilla::IsBaseOf<JSObject, T>::value ||
-                            mozilla::IsBaseOf<JSString, T>::value;
+                            mozilla::IsBaseOf<JSString, T>::value ||
+                            mozilla::IsBaseOf<JS::BigInt, T>::value;
 };
 
 template <typename T>