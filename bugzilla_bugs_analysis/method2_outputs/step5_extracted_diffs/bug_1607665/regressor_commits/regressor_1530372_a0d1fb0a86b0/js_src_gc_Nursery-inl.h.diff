# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Nursery-inl.h
# Commit: a0d1fb0a86b0
# Full Hash: a0d1fb0a86b04c74a8809c35230382f90cdfe779
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2020-01-07 21:57:58
# Regressor Bug: 1530372
# File Overlap Count: 1
# Description:
#   Bug 1530372 - Part 4: Support nursery allocation for BigInt. r=sfink,jandem
#   
#   Most of the code was copied from the String nursery allocation code paths and
#   then adjusted to work with BigInts. Where applicable, the newly added BigInt
#   functions were placed right next to the String functions, so it's easier to
# ==============================================================================

diff -r 9ae1e055de13 -r a0d1fb0a86b0 js/src/gc/Nursery-inl.h
--- a/js/src/gc/Nursery-inl.h	Thu Jan 02 13:04:45 2020 +0000
+++ b/js/src/gc/Nursery-inl.h	Mon Jan 06 12:49:45 2020 +0000
@@ -138,6 +138,43 @@
   return buffer;
 }
 
+static inline JS::BigInt::Digit* AllocateBigIntDigits(JSContext* cx,
+                                                      JS::BigInt* bi,
+                                                      uint32_t length) {
+  if (cx->isHelperThreadContext()) {
+    return cx->pod_malloc<JS::BigInt::Digit>(length);
+  }
+  size_t nbytes = RoundUp(length * sizeof(JS::BigInt::Digit), sizeof(Value));
+  auto* digits =
+      static_cast<JS::BigInt::Digit*>(cx->nursery().allocateBuffer(bi, nbytes));
+  if (!digits) {
+    ReportOutOfMemory(cx);
+  }
+  return digits;
+}
+
+static inline JS::BigInt::Digit* ReallocateBigIntDigits(
+    JSContext* cx, JS::BigInt* obj, JS::BigInt::Digit* oldDigits,
+    uint32_t oldLength, uint32_t newLength) {
+  if (cx->isHelperThreadContext()) {
+    MOZ_ASSERT(!cx->nursery().isInside(oldDigits));
+    return obj->zone()->pod_realloc<JS::BigInt::Digit>(oldDigits, oldLength,
+                                                       newLength);
+  }
+
+  size_t oldBytes =
+      RoundUp(oldLength * sizeof(JS::BigInt::Digit), sizeof(Value));
+  size_t newBytes =
+      RoundUp(newLength * sizeof(JS::BigInt::Digit), sizeof(Value));
+
+  auto* buffer = static_cast<JS::BigInt::Digit*>(
+      cx->nursery().reallocateBuffer(obj, oldDigits, oldBytes, newBytes));
+  if (!buffer) {
+    ReportOutOfMemory(cx);
+  }
+  return buffer;
+}
+
 }  // namespace js
 
 #endif /* gc_Nursery_inl_h */