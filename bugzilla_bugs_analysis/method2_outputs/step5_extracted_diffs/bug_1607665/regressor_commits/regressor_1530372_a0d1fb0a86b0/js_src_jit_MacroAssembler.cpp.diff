# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MacroAssembler.cpp
# Commit: a0d1fb0a86b0
# Full Hash: a0d1fb0a86b04c74a8809c35230382f90cdfe779
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2020-01-07 21:57:58
# Regressor Bug: 1530372
# File Overlap Count: 1
# Description:
#   Bug 1530372 - Part 4: Support nursery allocation for BigInt. r=sfink,jandem
#   
#   Most of the code was copied from the String nursery allocation code paths and
#   then adjusted to work with BigInts. Where applicable, the newly added BigInt
#   functions were placed right next to the String functions, so it's easier to
# ==============================================================================

diff -r 9ae1e055de13 -r a0d1fb0a86b0 js/src/jit/MacroAssembler.cpp
--- a/js/src/jit/MacroAssembler.cpp	Thu Jan 02 13:04:45 2020 +0000
+++ b/js/src/jit/MacroAssembler.cpp	Mon Jan 06 12:49:45 2020 +0000
@@ -748,6 +748,26 @@
   storePtr(ImmPtr(zone), Address(result, -js::Nursery::stringHeaderSize()));
 }
 
+// Inline version of Nursery::allocateBigInt.
+void MacroAssembler::nurseryAllocateBigInt(Register result, Register temp,
+                                           Label* fail) {
+  MOZ_ASSERT(IsNurseryAllocable(gc::AllocKind::BIGINT));
+
+  // No explicit check for nursery.isEnabled() is needed, as the comparison
+  // with the nursery's end will always fail in such cases.
+
+  CompileZone* zone = GetJitContext()->realm()->zone();
+  size_t thingSize = gc::Arena::thingSize(gc::AllocKind::BIGINT);
+  size_t totalSize = js::Nursery::bigIntHeaderSize() + thingSize;
+  MOZ_ASSERT(totalSize < INT32_MAX, "Nursery allocation too large");
+  MOZ_ASSERT(totalSize % gc::CellAlignBytes == 0);
+
+  bumpPointerAllocate(
+      result, temp, fail, zone->addressOfBigIntNurseryPosition(),
+      zone->addressOfBigIntNurseryCurrentEnd(), totalSize, thingSize);
+  storePtr(ImmPtr(zone), Address(result, -js::Nursery::bigIntHeaderSize()));
+}
+
 void MacroAssembler::bumpPointerAllocate(Register result, Register temp,
                                          Label* fail, void* posAddr,
                                          const void* curEndAddr,
@@ -817,8 +837,17 @@
                  attemptNursery ? gc::DefaultHeap : gc::TenuredHeap, fail);
 }
 
-void MacroAssembler::newGCBigInt(Register result, Register temp, Label* fail) {
+void MacroAssembler::newGCBigInt(Register result, Register temp, Label* fail,
+                                 bool attemptNursery) {
   checkAllocatorState(fail);
+
+  gc::InitialHeap initialHeap =
+      attemptNursery ? gc::DefaultHeap : gc::TenuredHeap;
+  if (shouldNurseryAllocate(gc::AllocKind::BIGINT, initialHeap)) {
+    MOZ_ASSERT(initialHeap == gc::DefaultHeap);
+    return nurseryAllocateBigInt(result, temp, fail);
+  }
+
   freeListAllocate(result, temp, gc::AllocKind::BIGINT, fail);
 }
 
@@ -1547,7 +1576,9 @@
                                         Register64 val) {
   MOZ_ASSERT(Scalar::isBigIntType(type));
 
-  store32(Imm32(0), Address(bigInt, BigInt::offsetOfFlags()));
+  uint32_t flags = BigInt::TYPE_FLAGS;
+
+  store32(Imm32(flags), Address(bigInt, BigInt::offsetOfFlags()));
 
   Label done, nonZero;
   branch64(Assembler::NotEqual, val, Imm64(0), &nonZero);
@@ -1563,7 +1594,7 @@
     Label isPositive;
     branch64(Assembler::GreaterThan, val, Imm64(0), &isPositive);
     {
-      store32(Imm32(BigInt::signBitMask()),
+      store32(Imm32(BigInt::signBitMask() | flags),
               Address(bigInt, BigInt::offsetOfFlags()));
       neg64(val);
     }