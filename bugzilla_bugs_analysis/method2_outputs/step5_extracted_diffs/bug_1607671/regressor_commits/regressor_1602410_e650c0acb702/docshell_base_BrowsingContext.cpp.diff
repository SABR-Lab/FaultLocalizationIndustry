# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/BrowsingContext.cpp
# Commit: e650c0acb702
# Full Hash: e650c0acb7027d22d04aeb6525834e5f89eedd92
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-08-19 21:28:29
# Regressor Bug: 1602410
# File Overlap Count: 1
# Description:
#   Bug 1602410 - Make window.print() work with tab-modal printing. r=nika,geckoview-reviewers,agi
#   
#   Do this by spinning the event loop until we've done the clone for
#   preview as appropriate.
#   
# ==============================================================================

diff -r 1f9187fefcb6 -r e650c0acb702 docshell/base/BrowsingContext.cpp
--- a/docshell/base/BrowsingContext.cpp	Tue Aug 18 21:33:15 2020 +0000
+++ b/docshell/base/BrowsingContext.cpp	Wed Aug 19 09:27:18 2020 +0000
@@ -2032,6 +2032,60 @@
   }
 }
 
+// We only care about whether we transition from not-awaiting to waiting. In
+// that case, we actually want to trigger the print process in the parent
+// process (which eventually will toggle this back to false, stopping the
+// event-loop-spinning going on in nsGlobalWindowOuter::PrintOuter).
+void BrowsingContext::DidSet(FieldIndex<IDX_IsAwaitingPrint>, bool aOldValue) {
+  if (!GetIsAwaitingPrint() || aOldValue == GetIsAwaitingPrint()) {
+    return;
+  }
+
+  if (!XRE_IsParentProcess()) {
+    return;
+  }
+
+  auto unsetFlagOnFailure = MakeScopeExit([&] {
+    // If we hit this, the print process failed, but let's not leave the event
+    // loop spinning on the child.
+    //
+    // If it fails because of the browsing context being discarded, then that's
+    // fine as well, the child event loop will also stop spinning.
+    Unused << SetIsAwaitingPrint(false);
+  });
+
+  RefPtr<Element> el = Top()->GetEmbedderElement();
+  if (NS_WARN_IF(!el)) {
+    return;
+  }
+
+  nsCOMPtr<nsPIDOMWindowOuter> outerWin = el->OwnerDoc()->GetWindow();
+  if (NS_WARN_IF(!outerWin)) {
+    return;
+  }
+
+  nsCOMPtr<nsIDOMChromeWindow> chromeWin = do_QueryInterface(outerWin);
+  if (NS_WARN_IF(!chromeWin)) {
+    return;
+  }
+
+  nsCOMPtr<nsIBrowserDOMWindow> browserDOMWin;
+  chromeWin->GetBrowserDOMWindow(getter_AddRefs(browserDOMWin));
+  if (NS_WARN_IF(!browserDOMWin)) {
+    return;
+  }
+
+  // TODO(emilio): This may be simpler by importing a JSM via do_ImportModule
+  // rather than nsIBrowserDOMWindow. Also, maybe we should make this return a
+  // promise that unsets the flag when resolved / rejected instead, once the
+  // print codepaths are unified.
+  if (NS_FAILED(browserDOMWin->Print(this))) {
+    return;
+  }
+  // The flag will be unset by the printing code.
+  unsetFlagOnFailure.release();
+}
+
 void BrowsingContext::DidSet(FieldIndex<IDX_Muted>) {
   MOZ_ASSERT(!GetParent(), "Set muted flag on non top-level context!");
   USER_ACTIVATION_LOG("Set audio muted %d for %s browsing context 0x%08" PRIx64,