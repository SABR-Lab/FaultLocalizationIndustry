# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGL2ContextMRTs.cpp
# Commit: 71c122ac0ca7
# Full Hash: 71c122ac0ca73391866b1ef19f4f82bc2d28568b
# Author: David Parks <davidp99@gmail.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Initial out-of-process WebGL implementation. r=mccr8,handyman
#   
#   Splits WebGLContext into ClientWebGLContext and HostWebGLContext.  The Client enables the JS-control of a WebGL context in a content procecss while the Host executes the WebGL graphics operations (via a WebGLContext that maintains much of the existing code) in the compositor process.  At this point, the cross-process behavior is disabled -- this series of patches is an incremental step toward that final goal.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D54018
# ==============================================================================

diff -r 5cbf5bb11c58 -r 71c122ac0ca7 dom/canvas/WebGL2ContextMRTs.cpp
--- a/dom/canvas/WebGL2ContextMRTs.cpp	Wed Jan 08 21:52:03 2020 +0000
+++ b/dom/canvas/WebGL2ContextMRTs.cpp	Wed Jan 08 22:19:14 2020 +0000
@@ -86,7 +86,8 @@
 ////
 
 void WebGL2Context::ClearBufferfv(GLenum buffer, GLint drawBuffer,
-                                  const Float32Arr& src, GLuint srcElemOffset) {
+                                  const RawBuffer<const float>& src,
+                                  GLuint srcElemOffset) {
   const FuncScope funcScope(*this, "clearBufferfv");
   if (IsContextLost()) return;
 
@@ -95,7 +96,7 @@
     return;
   }
 
-  if (!ValidateClearBuffer(buffer, drawBuffer, src.elemCount, srcElemOffset,
+  if (!ValidateClearBuffer(buffer, drawBuffer, src.Length(), srcElemOffset,
                            LOCAL_GL_FLOAT)) {
     return;
   }
@@ -105,12 +106,13 @@
   }
 
   ScopedDrawCallWrapper wrapper(*this);
-  const auto ptr = src.elemBytes + srcElemOffset;
+  const auto ptr = &src[0] + srcElemOffset;
   gl->fClearBufferfv(buffer, drawBuffer, ptr);
 }
 
 void WebGL2Context::ClearBufferiv(GLenum buffer, GLint drawBuffer,
-                                  const Int32Arr& src, GLuint srcElemOffset) {
+                                  const RawBuffer<const int32_t>& src,
+                                  GLuint srcElemOffset) {
   const FuncScope funcScope(*this, "clearBufferiv");
   if (IsContextLost()) return;
 
@@ -119,7 +121,7 @@
     return;
   }
 
-  if (!ValidateClearBuffer(buffer, drawBuffer, src.elemCount, srcElemOffset,
+  if (!ValidateClearBuffer(buffer, drawBuffer, src.Length(), srcElemOffset,
                            LOCAL_GL_INT)) {
     return;
   }
@@ -130,25 +132,26 @@
   }
 
   ScopedDrawCallWrapper wrapper(*this);
-  const auto ptr = src.elemBytes + srcElemOffset;
+  const auto ptr = &src[0] + srcElemOffset;
   gl->fClearBufferiv(buffer, drawBuffer, ptr);
 }
 
 void WebGL2Context::ClearBufferuiv(GLenum buffer, GLint drawBuffer,
-                                   const Uint32Arr& src, GLuint srcElemOffset) {
+                                   const RawBuffer<const uint32_t>& src,
+                                   GLuint srcElemOffset) {
   const FuncScope funcScope(*this, "clearBufferuiv");
   if (IsContextLost()) return;
 
   if (buffer != LOCAL_GL_COLOR)
     return ErrorInvalidEnum("`buffer` must be COLOR.");
 
-  if (!ValidateClearBuffer(buffer, drawBuffer, src.elemCount, srcElemOffset,
+  if (!ValidateClearBuffer(buffer, drawBuffer, src.Length(), srcElemOffset,
                            LOCAL_GL_UNSIGNED_INT)) {
     return;
   }
 
   ScopedDrawCallWrapper wrapper(*this);
-  const auto ptr = src.elemBytes + srcElemOffset;
+  const auto ptr = &src[0] + srcElemOffset;
   gl->fClearBufferuiv(buffer, drawBuffer, ptr);
 }
 