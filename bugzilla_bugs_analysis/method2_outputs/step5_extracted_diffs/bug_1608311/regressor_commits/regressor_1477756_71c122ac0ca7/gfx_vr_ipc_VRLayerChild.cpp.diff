# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/vr/ipc/VRLayerChild.cpp
# Commit: 71c122ac0ca7
# Full Hash: 71c122ac0ca73391866b1ef19f4f82bc2d28568b
# Author: David Parks <davidp99@gmail.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Initial out-of-process WebGL implementation. r=mccr8,handyman
#   
#   Splits WebGLContext into ClientWebGLContext and HostWebGLContext.  The Client enables the JS-control of a WebGL context in a content procecss while the Host executes the WebGL graphics operations (via a WebGLContext that maintains much of the existing code) in the compositor process.  At this point, the cross-process behavior is disabled -- this series of patches is an incremental step toward that final goal.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D54018
# ==============================================================================

diff -r 5cbf5bb11c58 -r 71c122ac0ca7 gfx/vr/ipc/VRLayerChild.cpp
--- a/gfx/vr/ipc/VRLayerChild.cpp	Wed Jan 08 21:52:03 2020 +0000
+++ b/gfx/vr/ipc/VRLayerChild.cpp	Wed Jan 08 22:19:14 2020 +0000
@@ -6,14 +6,7 @@
 
 #include "VRLayerChild.h"
 #include "gfxPlatform.h"
-#include "GLScreenBuffer.h"
-#include "mozilla/layers/TextureClientSharedSurface.h"
-#include "SharedSurface.h"                  // for SharedSurface
-#include "SharedSurfaceGL.h"                // for SharedSurface
-#include "mozilla/layers/LayersMessages.h"  // for TimedTexture
-#include "nsICanvasRenderingContextInternal.h"
 #include "mozilla/dom/HTMLCanvasElement.h"
-#include "mozilla/layers/SyncObject.h"  // for SyncObjectClient
 
 namespace mozilla {
 namespace gfx {
@@ -49,62 +42,23 @@
     return;
   }
 
-  // Keep the SharedSurfaceTextureClient alive long enough for
-  // 1 extra frame, accomodating overlapped asynchronous rendering.
-  mLastFrameTexture = mThisFrameTexture;
-
-#if defined(MOZ_WIDGET_ANDROID)
-  /**
-   * Do not blit WebGL to a SurfaceTexture until the last submitted frame is
-   * already processed and the new frame poses are ready. SurfaceTextures need
-   * to be released in the VR render thread in order to allow to be used again
-   * in the WebGLContext GLScreenBuffer producer. Not doing so causes some
-   * freezes, crashes or other undefined behaviour.
-   */
-  if (!mThisFrameTexture || aDisplayInfo.mDisplayState.lastSubmittedFrameId ==
-                                mLastSubmittedFrameId) {
-    mThisFrameTexture = mCanvasElement->GetVRFrame();
-  }
-#else
-  mThisFrameTexture = mCanvasElement->GetVRFrame();
-#endif  // defined(MOZ_WIDGET_ANDROID)
-
   mLastSubmittedFrameId = frameId;
 
-  if (!mThisFrameTexture) {
-    return;
-  }
-  VRManagerChild* vrmc = VRManagerChild::Get();
-  layers::SyncObjectClient* syncObject = vrmc->GetSyncObject();
-  mThisFrameTexture->SyncWithObject(syncObject);
-  if (!gfxPlatform::GetPlatform()->DidRenderingDeviceReset()) {
-    if (syncObject && syncObject->IsSyncObjectValid()) {
-      syncObject->Synchronize();
-    }
-  }
-
-  gl::SharedSurface* surf = mThisFrameTexture->Surf();
-  if (surf->mType == gl::SharedSurfaceType::Basic) {
-    gfxCriticalError() << "SharedSurfaceType::Basic not supported for WebVR";
+  PWebGLChild* webGLChild = mCanvasElement->GetWebGLChild();
+  if (!webGLChild) {
     return;
   }
 
-  layers::SurfaceDescriptor desc;
-  if (!surf->ToSurfaceDescriptor(&desc)) {
-    gfxCriticalError() << "SharedSurface::ToSurfaceDescriptor failed in "
-                          "VRLayerChild::SubmitFrame";
-    return;
-  }
-
-  SendSubmitFrame(desc, frameId, mLeftEyeRect, mRightEyeRect);
+  SendSubmitFrame(webGLChild, frameId,
+                  aDisplayInfo.mDisplayState.lastSubmittedFrameId, mLeftEyeRect,
+                  mRightEyeRect);
 }
 
 bool VRLayerChild::IsIPCOpen() { return mIPCOpen; }
 
 void VRLayerChild::ClearSurfaces() {
-  mThisFrameTexture = nullptr;
-  mLastFrameTexture = nullptr;
   mCanvasElement->ClearVRFrame();
+  SendClearSurfaces();
 }
 
 void VRLayerChild::ActorDestroy(ActorDestroyReason aWhy) { mIPCOpen = false; }