# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLMemoryTracker.cpp
# Commit: 7e2a2b1b416f
# Full Hash: 7e2a2b1b416f1a64c6548aab29e92acc9554ae7d
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Fix all webgl regression tests according to CI. r=handyman
#   
#   (This is a combination of 31 commits)
#   
#   * Fix Linux compilation.
# ==============================================================================

diff -r ccfa767dba64 -r 7e2a2b1b416f dom/canvas/WebGLMemoryTracker.cpp
--- a/dom/canvas/WebGLMemoryTracker.cpp	Wed Jan 08 22:19:16 2020 +0000
+++ b/dom/canvas/WebGLMemoryTracker.cpp	Wed Jan 08 22:19:23 2020 +0000
@@ -13,21 +13,82 @@
 
 namespace mozilla {
 
+MOZ_DEFINE_MALLOC_SIZE_OF(WebGLShaderMallocSizeOf)
+
 NS_IMETHODIMP
 WebGLMemoryTracker::CollectReports(nsIHandleReportCallback* aHandleReport,
                                    nsISupports* aData, bool) {
+  const auto locked = HostWebGLContext::OutstandingContexts();
+  const auto& contexts = locked->contexts;
+
+  const auto contextCount = contexts.size();
+
+  size_t bufferCount = 0;
+  int64_t bufferGpuSize = 0;
+  int64_t bufferCacheSize = 0;
+
+  size_t rbCount = 0;
+  int64_t rbGpuSize = 0;
+
+  size_t shaderCount = 0;
+  int64_t shaderCpuSize = 0;
+
+  size_t texCount = 0;
+  int64_t texGpuSize = 0;
+
+  for (const auto& context : contexts) {
+    bufferCount += context->mBufferMap.size();
+    for (const auto& pair : context->mBufferMap) {
+      const auto& buffer = *pair.second;
+      bufferGpuSize += buffer.mByteLength;
+
+      if (buffer.mIndexCache) {
+        bufferCacheSize += buffer.mByteLength;
+      }
+      bufferCacheSize += buffer.mIndexRanges.size() *
+                         sizeof(decltype(buffer.mIndexRanges)::value_type);
+    }
+
+    // -
+
+    rbCount += context->mRenderbufferMap.size();
+    for (const auto& pair : context->mRenderbufferMap) {
+      const auto& rb = pair.second;
+      rbGpuSize += rb->MemoryUsage();
+    }
+
+    // -
+
+    shaderCount += context->mShaderMap.size();
+    for (const auto& pair : context->mShaderMap) {
+      const auto& shader = pair.second;
+      shaderCpuSize += shader->SizeOfIncludingThis(WebGLShaderMallocSizeOf);
+    }
+
+    // -
+
+    texCount += context->mTextureMap.size();
+    for (const auto& pair : context->mTextureMap) {
+      const auto& texture = pair.second;
+      texGpuSize += texture->MemoryUsage();
+    }
+  }
+
+  // -
+
   MOZ_COLLECT_REPORT(
-      "webgl-texture-memory", KIND_OTHER, UNITS_BYTES, GetTextureMemoryUsed(),
+      "webgl-texture-memory", KIND_OTHER, UNITS_BYTES, texGpuSize,
       "Memory used by WebGL textures. The OpenGL implementation is free to "
       "store these textures in either video memory or main memory. This "
       "measurement is only a lower bound, actual memory usage may be higher "
       "for example if the storage is strided.");
 
   MOZ_COLLECT_REPORT("webgl-texture-count", KIND_OTHER, UNITS_COUNT,
-                     GetTextureCount(), "Number of WebGL textures.");
+                     static_cast<int64_t>(texCount),
+                     "Number of WebGL textures.");
 
   MOZ_COLLECT_REPORT(
-      "webgl-buffer-memory", KIND_OTHER, UNITS_BYTES, GetBufferMemoryUsed(),
+      "webgl-buffer-memory", KIND_OTHER, UNITS_BYTES, bufferGpuSize,
       "Memory used by WebGL buffers. The OpenGL implementation is free to "
       "store these buffers in either video memory or main memory. This "
       "measurement is only a lower bound, actual memory usage may be higher "
@@ -35,166 +96,43 @@
 
   MOZ_COLLECT_REPORT(
       "explicit/webgl/buffer-cache-memory", KIND_HEAP, UNITS_BYTES,
-      GetBufferCacheMemoryUsed(),
+      bufferCacheSize,
       "Memory used by WebGL buffer caches. The WebGL implementation caches "
       "the contents of element array buffers only. This adds up with the "
       "'webgl-buffer-memory' value, but contrary to it, this one represents "
       "bytes on the heap, not managed by OpenGL.");
 
   MOZ_COLLECT_REPORT("webgl-buffer-count", KIND_OTHER, UNITS_COUNT,
-                     GetBufferCount(), "Number of WebGL buffers.");
+                     static_cast<int64_t>(bufferCount),
+                     "Number of WebGL buffers.");
 
   MOZ_COLLECT_REPORT(
-      "webgl-renderbuffer-memory", KIND_OTHER, UNITS_BYTES,
-      GetRenderbufferMemoryUsed(),
+      "webgl-renderbuffer-memory", KIND_OTHER, UNITS_BYTES, rbGpuSize,
       "Memory used by WebGL renderbuffers. The OpenGL implementation is free "
       "to store these renderbuffers in either video memory or main memory. "
       "This measurement is only a lower bound, actual memory usage may be "
       "higher, for example if the storage is strided.");
 
   MOZ_COLLECT_REPORT("webgl-renderbuffer-count", KIND_OTHER, UNITS_COUNT,
-                     GetRenderbufferCount(), "Number of WebGL renderbuffers.");
+                     static_cast<int64_t>(rbCount),
+                     "Number of WebGL renderbuffers.");
 
   MOZ_COLLECT_REPORT(
-      "explicit/webgl/shader", KIND_HEAP, UNITS_BYTES, GetShaderSize(),
+      "explicit/webgl/shader", KIND_HEAP, UNITS_BYTES, shaderCpuSize,
       "Combined size of WebGL shader ASCII sources and translation logs "
       "cached on the heap.");
 
   MOZ_COLLECT_REPORT("webgl-shader-count", KIND_OTHER, UNITS_COUNT,
-                     GetShaderCount(), "Number of WebGL shaders.");
+                     static_cast<int64_t>(shaderCount),
+                     "Number of WebGL shaders.");
 
   MOZ_COLLECT_REPORT("webgl-context-count", KIND_OTHER, UNITS_COUNT,
-                     GetContextCount(), "Number of WebGL contexts.");
+                     static_cast<int64_t>(contextCount),
+                     "Number of WebGL contexts.");
 
   return NS_OK;
 }
 
 NS_IMPL_ISUPPORTS(WebGLMemoryTracker, nsIMemoryReporter)
 
-StaticRefPtr<WebGLMemoryTracker> WebGLMemoryTracker::sUniqueInstance;
-
-/*static*/
-RefPtr<WebGLMemoryTracker> WebGLMemoryTracker::Create() {
-  RefPtr<WebGLMemoryTracker> ret = new WebGLMemoryTracker;
-  RegisterWeakMemoryReporter(ret);
-  return ret;
-}
-
-WebGLMemoryTracker::WebGLMemoryTracker() = default;
-
-WebGLMemoryTracker::~WebGLMemoryTracker() {
-  UnregisterWeakMemoryReporter(this);
-}
-
-// -
-
-/*static*/
-int64_t WebGLMemoryTracker::GetBufferCount() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    result += context->mBufferMap.size();
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetBufferMemoryUsed() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    for (const auto& pair : context->mBufferMap) {
-      const auto& buffer = *pair.second;
-      result += buffer.mByteLength;
-    }
-  }
-  return result;
-}
-
-int64_t WebGLMemoryTracker::GetBufferCacheMemoryUsed() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    for (const auto& pair : context->mBufferMap) {
-      const auto& buffer = *pair.second;
-      if (buffer.mIndexCache) {
-        result += buffer.mByteLength;
-      }
-      result += buffer.mIndexRanges.size() *
-                sizeof(decltype(buffer.mIndexRanges)::value_type);
-    }
-  }
-  return result;
-}
-
-MOZ_DEFINE_MALLOC_SIZE_OF(WebGLShaderMallocSizeOf)
-
-int64_t WebGLMemoryTracker::GetShaderSize() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    for (const auto& pair : context->mShaderMap) {
-      const auto& shader = pair.second;
-      result += shader->SizeOfIncludingThis(WebGLShaderMallocSizeOf);
-    }
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetTextureMemoryUsed() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    for (const auto& pair : context->mTextureMap) {
-      const auto& texture = pair.second;
-      result += texture->MemoryUsage();
-    }
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetTextureCount() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    result += context->mTextureMap.size();
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetRenderbufferMemoryUsed() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    for (const auto& pair : context->mRenderbufferMap) {
-      const auto& rb = pair.second;
-      result += rb->MemoryUsage();
-    }
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetRenderbufferCount() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    result += context->mRenderbufferMap.size();
-  }
-  return result;
-}
-
-/*static*/
-int64_t WebGLMemoryTracker::GetShaderCount() {
-  const auto& contexts = Get()->mContexts;
-  int64_t result = 0;
-  for (const auto& context : contexts) {
-    result += context->mShaderMap.size();
-  }
-  return result;
-}
-
 }  // namespace mozilla