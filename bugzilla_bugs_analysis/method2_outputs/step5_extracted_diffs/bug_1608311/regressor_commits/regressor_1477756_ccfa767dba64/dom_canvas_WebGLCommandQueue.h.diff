# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLCommandQueue.h
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLCommandQueue.h
--- a/dom/canvas/WebGLCommandQueue.h	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLCommandQueue.h	Wed Jan 08 22:19:16 2020 +0000
@@ -33,60 +33,9 @@
 
 enum CommandSyncType { ASYNC, SYNC };
 
-/**
- * A CommandQueue is a ProducerConsumerQueue where the contents are commands.
- * Its endpoints are called mSource and mSink and can be sent to other
- * processes via IPDL, the same way ProducerConsumerQueues can.
- * Source and Sink are generic and will work with well with others but
- * CommandSource and CommandSink are designed for use with them.
- * CommandSource offers asynchronous Insert methods that can be used
- * to add commands into the queue.  CommandSink offers ProcessOne, ProcessAll,
- * etc for draining the queue.  See CommandSource and CommandSink for more.
- *
- * NB: When used with IPDL, Sources and Sinks must be labeled "shmemholder"
- * (same as with Producers and Consumers).
- */
-template <typename Source, typename Sink>
-class CommandQueue {
- public:
-  using SelfType = CommandQueue<Source, Sink>;
-  using Source = Source;
-  using Sink = Sink;
-
-  // Technically, we're just mapping the Producer and Consumer in aPcq
-  // by calling the Source and Sink type's constructors on them, respectively,
-  // and passing aArgs as constructor parameters.
-  template <typename... Args>
-  static UniquePtr<SelfType> Create(UniquePtr<ProducerConsumerQueue>&& aPcq,
-                                    Args&... aArgs) {
-    // Prefer WrapUnique to MakeUnique since it allows client code to declare
-    // a private constructor and give this class friend status.
-    UniquePtr<Source> source =
-        WrapUnique(new Source(std::move(aPcq->mProducer), aArgs...));
-    if (!source) {
-      return nullptr;
-    }
-    UniquePtr<Sink> sink =
-        WrapUnique(new Sink(std::move(aPcq->mConsumer), aArgs...));
-    if (!sink) {
-      return nullptr;
-    }
-    return WrapUnique(new CommandQueue(std::move(source), std::move(sink)));
-  }
-
-  UniquePtr<Source> mSource;
-  UniquePtr<Sink> mSink;
-
- protected:
-  CommandQueue(UniquePtr<Source>&& aSource, UniquePtr<Sink>&& aSink)
-      : mSource(std::move(aSource)), mSink(std::move(aSink)) {
-    MOZ_ASSERT(mSource && mSink);
-  }
-};
-
 class BasicSource {
  public:
-  BasicSource(UniquePtr<Producer>&& aProducer)
+  explicit BasicSource(UniquePtr<Producer>&& aProducer)
       : mProducer(std::move(aProducer)) {
     MOZ_ASSERT(mProducer);
   }
@@ -102,7 +51,8 @@
 
 class BasicSink {
  public:
-  BasicSink(UniquePtr<Consumer>&& aConsumer) : mConsumer(std::move(aConsumer)) {
+  explicit BasicSink(UniquePtr<Consumer>&& aConsumer)
+      : mConsumer(std::move(aConsumer)) {
     MOZ_ASSERT(mConsumer);
   }
   virtual ~BasicSink() {}
@@ -125,7 +75,7 @@
 template <typename Command>
 class CommandSource : public BasicSource {
  public:
-  CommandSource(UniquePtr<Producer>&& aProducer)
+  explicit CommandSource(UniquePtr<Producer>&& aProducer)
       : BasicSource(std::move(aProducer)) {}
 
   template <typename... Args>
@@ -162,13 +112,13 @@
 template <typename Command>
 class CommandSink : public BasicSink {
  public:
-  CommandSink(UniquePtr<Consumer>&& aConsumer)
+  explicit CommandSink(UniquePtr<Consumer>&& aConsumer)
       : BasicSink(std::move(aConsumer)) {}
 
   /**
    * Attempts to process the next command in the queue, if one is available.
    */
-  CommandResult ProcessOne(Maybe<TimeDuration> aTimeout) {
+  CommandResult ProcessOne(const Maybe<TimeDuration>& aTimeout) {
     Command command;
     PcqStatus status = (aTimeout.isNothing() || aTimeout.value())
                            ? this->mConsumer->TryWaitRemove(aTimeout, command)
@@ -259,7 +209,7 @@
     if (!ReadArgs(args)) {
       return false;
     }
-    CallFunction(aObj, aFunc, args, std::index_sequence_for<Args...>{});
+    CallFunction(aFunc, args, std::index_sequence_for<Args...>{});
     return true;
   }
 
@@ -344,7 +294,7 @@
   template <typename FunctionType, typename... Args, size_t... Indices,
             typename ReturnType =
                 typename mozilla::FunctionTypeTraits<FunctionType>::ReturnType>
-  ReturnType CallFunction(FunctionType aFun, std::tuple<Args...>& aArgs,
+  ReturnType CallFunction(FunctionType aFunc, std::tuple<Args...>& aArgs,
                           std::index_sequence<Indices...>) {
     return (*aFunc)(std::forward<Args>(std::get<Indices>(aArgs))...);
   }
@@ -357,7 +307,7 @@
   }
 
   template <typename FunctionType, typename... Args, size_t... Indices>
-  void CallVoidFunction(FunctionType aFun, std::tuple<Args...>& aArgs,
+  void CallVoidFunction(FunctionType aFunc, std::tuple<Args...>& aArgs,
                         std::index_sequence<Indices...>) {
     (*aFunc)(std::forward<Args>(std::get<Indices>(aArgs))...);
   }
@@ -382,11 +332,9 @@
  public:
   using BaseType = CommandSource<Command>;
   SyncCommandSource(UniquePtr<Producer>&& aProducer,
-                    UniquePtr<ProducerConsumerQueue>& aResponsePcq)
+                    UniquePtr<Consumer>&& aResponseConsumer)
       : CommandSource<Command>(std::move(aProducer)),
-        mConsumer(std::move(aResponsePcq->mConsumer)) {
-    MOZ_ASSERT(mConsumer);
-  }
+        mConsumer(std::move(aResponseConsumer)) {}
 
   template <typename... Args>
   PcqStatus RunAsyncCommand(Command aCommand, Args&&... aArgs) {
@@ -449,11 +397,9 @@
 
  public:
   SyncCommandSink(UniquePtr<Consumer>&& aConsumer,
-                  UniquePtr<ProducerConsumerQueue>& aResponsePcq)
+                  UniquePtr<Producer>&& aResponseProducer)
       : CommandSink<Command>(std::move(aConsumer)),
-        mProducer(std::move(aResponsePcq->mProducer)) {
-    MOZ_ASSERT(mProducer);
-  }
+        mProducer(std::move(aResponseProducer)) {}
 
   // for IPDL:
   SyncCommandSink() {}
@@ -793,28 +739,28 @@
 // id.  The handler uses a CommandSink to read parameters, call the
 // given method using the given synchronization protocol, and provide
 // compile-time lookup of the ID by class method.
-#define DEFINE_METHOD_DISPATCHER(_DISPATCHER, _ID, _METHOD, _SYNC)         \
-  template <>                                                              \
-  bool _DISPATCHER::DispatchCommand<_ID>(size_t aId, SinkType & aSink,     \
-                                         ObjectType & aObj) {              \
-    return CommandDispatchDriver<_DISPATCHER>::DispatchCommandHelper<_ID>( \
-        aId, aSink, aObj);                                                 \
-  }                                                                        \
-  template <>                                                              \
-  bool _DISPATCHER::Dispatch<_ID>(SinkType & aSink, ObjectType & aObj) {   \
-    return DispatchMethod<_SYNC>::Run(aSink, &_METHOD, aObj);              \
-  }                                                                        \
-  template <>                                                              \
-  struct _DISPATCHER::MethodInfo<_ID> {                                    \
-    using MethodType = decltype(&_METHOD);                                 \
-  };                                                                       \
-  template <>                                                              \
-  constexpr CommandSyncType _DISPATCHER::SyncType<_ID>() {                 \
-    return _SYNC;                                                          \
-  }                                                                        \
-  template <>                                                              \
-  constexpr size_t _DISPATCHER::Id<decltype(&_METHOD), &_METHOD>() {       \
-    return _ID;                                                            \
+#define DEFINE_METHOD_DISPATCHER(_DISPATCHER, _ID, _METHOD, _SYNC)           \
+  /*  template <>                                                            \
+    bool _DISPATCHER::DispatchCommand<_ID>(size_t aId, SinkType & aSink,     \
+                                           ObjectType & aObj) {              \
+      return CommandDispatchDriver<_DISPATCHER>::DispatchCommandHelper<_ID>( \
+          aId, aSink, aObj);                                                 \
+    }                                                                        \
+    template <>                                                              \
+    bool _DISPATCHER::Dispatch<_ID>(SinkType & aSink, ObjectType & aObj) {   \
+      return DispatchMethod<_SYNC>::Run(aSink, &_METHOD, aObj);              \
+    } */                                                                     \
+  template <>                                                                \
+  struct _DISPATCHER::MethodInfo<_ID> {                                      \
+    using MethodType = decltype(&_METHOD);                                   \
+  };                                                                         \
+  template <>                                                                \
+  constexpr CommandSyncType _DISPATCHER::SyncType<_ID>() {                   \
+    return _SYNC;                                                            \
+  }                                                                          \
+  template <>                                                                \
+  constexpr size_t _DISPATCHER::Id<decltype(&_METHOD), &_METHOD>() {         \
+    return _ID;                                                              \
   }
 
 namespace ipc {