# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextExtensions.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLContextExtensions.cpp
--- a/dom/canvas/WebGLContextExtensions.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLContextExtensions.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -4,26 +4,22 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WebGLContext.h"
-#include "WebGLContextEndpoint.h"
-#include "WebGLContextUtils.h"
-#include "WebGLExtensions.h"
 #include "ClientWebGLExtensions.h"
 #include "GLContext.h"
-
-#include "nsString.h"
+#include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/ToJSValue.h"
+#include "mozilla/EnumeratedRange.h"
+#include "mozilla/Preferences.h"
 #include "nsContentUtils.h"
-#include "mozilla/Preferences.h"
-#include "mozilla/dom/BindingDeclarations.h"
-#include "AccessCheck.h"
+#include "nsString.h"
+#include "WebGLContextUtils.h"
+#include "WebGLExtensions.h"
 
 namespace mozilla {
 
-/*static*/ const char* ClientWebGLContext::GetExtensionString(
-    WebGLExtensionID ext) {
-  typedef EnumeratedArray<WebGLExtensionID, WebGLExtensionID::Max, const char*>
-      names_array_t;
-
-  static names_array_t sExtensionNamesEnumeratedArray;
+const char* GetExtensionName(const WebGLExtensionID ext) {
+  static EnumeratedArray<WebGLExtensionID, WebGLExtensionID::Max, const char*>
+      sExtensionNamesEnumeratedArray;
   static bool initialized = false;
 
   if (!initialized) {
@@ -74,46 +70,166 @@
   return sExtensionNamesEnumeratedArray[ext];
 }
 
-bool WebGLContext::IsExtensionSupported(dom::CallerType callerType,
-                                        WebGLExtensionID ext) const {
-  bool allowPrivilegedExts = false;
+// ----------------------------
+// ClientWebGLContext
 
-  // Chrome contexts need access to debug information even when
-  // webgl.disable-extensions is set. This is used in the graphics
-  // section of about:support
-  if (callerType == dom::CallerType::System) {
-    allowPrivilegedExts = true;
-  }
+void ClientWebGLContext::GetExtension(JSContext* cx, const nsAString& wideName,
+                                      JS::MutableHandle<JSObject*> retval,
+                                      dom::CallerType callerType,
+                                      ErrorResult& rv) {
+  retval.set(nullptr);
+  const FuncScope funcScope(*this, "getExtension");
+  if (IsContextLost()) return;
 
-  if (StaticPrefs::webgl_enable_privileged_extensions()) {
-    allowPrivilegedExts = true;
-  }
+  const auto name = NS_ConvertUTF16toUTF8(wideName);
+
+  auto ext = WebGLExtensionID::Max;
 
-  if (allowPrivilegedExts) {
-    switch (ext) {
-      case WebGLExtensionID::EXT_disjoint_timer_query:
-        return WebGLExtensionDisjointTimerQuery::IsSupported(this);
-      case WebGLExtensionID::MOZ_debug:
-        return true;
-      case WebGLExtensionID::WEBGL_debug_renderer_info:
-        return true;
-      case WebGLExtensionID::WEBGL_debug_shaders:
-        return true;
-      default:
-        // For warnings-as-errors.
-        break;
+  // step 1: figure what extension is wanted
+  for (const auto extension : MakeEnumeratedRange(WebGLExtensionID::Max)) {
+    const auto& curName = GetExtensionName(extension);
+    if (name.Equals(curName, nsCaseInsensitiveCStringComparator())) {
+      ext = extension;
+      break;
     }
   }
 
-  return IsExtensionSupported(ext);
+  if (ext == WebGLExtensionID::Max) return;
+
+  RefPtr<ClientWebGLExtensionBase> extObj;
+  if (ext == WebGLExtensionID::WEBGL_lose_context) {
+    extObj = mExtLoseContext;
+  } else {
+    extObj = GetExtension(ext, callerType);
+  }
+  if (!extObj) return;
+
+  // Ugh, this would be easier returning `any` than `object`.
+  JS::Rooted<JS::Value> v(cx);
+  MOZ_ALWAYS_TRUE(dom::ToJSValue(cx, extObj, &v));
+  if (v.isObject()) {
+    retval.set(&v.toObject());
+  }
 }
 
+RefPtr<ClientWebGLExtensionBase> ClientWebGLContext::GetExtension(
+    const WebGLExtensionID ext, const dom::CallerType callerType) {
+  if (ext == WebGLExtensionID::WEBGL_lose_context) {
+    // Always the same.
+    return mExtLoseContext;
+  }
+
+  if (!mNotLost) return nullptr;
+
+  if (!IsSupported(ext, callerType)) return nullptr;
+
+  auto& extSlot = mNotLost->extensions[EnumValue(ext)];
+  if (MOZ_UNLIKELY(!extSlot)) {
+    extSlot = [&]() -> RefPtr<ClientWebGLExtensionBase> {
+      switch (ext) {
+        // ANGLE_
+        case WebGLExtensionID::ANGLE_instanced_arrays:
+          return new ClientWebGLExtensionInstancedArrays(*this);
+
+        // EXT_
+        case WebGLExtensionID::EXT_blend_minmax:
+          return new ClientWebGLExtensionBlendMinMax(*this);
+        case WebGLExtensionID::EXT_color_buffer_float:
+          return new ClientWebGLExtensionEXTColorBufferFloat(*this);
+        case WebGLExtensionID::EXT_color_buffer_half_float:
+          return new ClientWebGLExtensionColorBufferHalfFloat(*this);
+        case WebGLExtensionID::EXT_disjoint_timer_query:
+          return new ClientWebGLExtensionDisjointTimerQuery(*this);
+        case WebGLExtensionID::EXT_float_blend:
+          return new ClientWebGLExtensionFloatBlend(*this);
+        case WebGLExtensionID::EXT_frag_depth:
+          return new ClientWebGLExtensionFragDepth(*this);
+        case WebGLExtensionID::EXT_shader_texture_lod:
+          return new ClientWebGLExtensionShaderTextureLod(*this);
+        case WebGLExtensionID::EXT_sRGB:
+          return new ClientWebGLExtensionSRGB(*this);
+        case WebGLExtensionID::EXT_texture_compression_bptc:
+          return new ClientWebGLExtensionCompressedTextureBPTC(*this);
+        case WebGLExtensionID::EXT_texture_compression_rgtc:
+          return new ClientWebGLExtensionCompressedTextureRGTC(*this);
+        case WebGLExtensionID::EXT_texture_filter_anisotropic:
+          return new ClientWebGLExtensionTextureFilterAnisotropic(*this);
+
+        // MOZ_
+        case WebGLExtensionID::MOZ_debug:
+          return new ClientWebGLExtensionMOZDebug(*this);
+
+        // OES_
+        case WebGLExtensionID::OES_element_index_uint:
+          return new ClientWebGLExtensionElementIndexUint(*this);
+        case WebGLExtensionID::OES_fbo_render_mipmap:
+          return new ClientWebGLExtensionFBORenderMipmap(*this);
+        case WebGLExtensionID::OES_standard_derivatives:
+          return new ClientWebGLExtensionStandardDerivatives(*this);
+        case WebGLExtensionID::OES_texture_float:
+          return new ClientWebGLExtensionTextureFloat(*this);
+        case WebGLExtensionID::OES_texture_float_linear:
+          return new ClientWebGLExtensionTextureFloatLinear(*this);
+        case WebGLExtensionID::OES_texture_half_float:
+          return new ClientWebGLExtensionTextureHalfFloat(*this);
+        case WebGLExtensionID::OES_texture_half_float_linear:
+          return new ClientWebGLExtensionTextureHalfFloatLinear(*this);
+        case WebGLExtensionID::OES_vertex_array_object:
+          return new ClientWebGLExtensionVertexArray(*this);
+
+        // OVR_
+        case WebGLExtensionID::OVR_multiview2:
+          return new ClientWebGLExtensionMultiview(*this);
+
+        // WEBGL_
+        case WebGLExtensionID::WEBGL_color_buffer_float:
+          return new ClientWebGLExtensionColorBufferFloat(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_astc:
+          return new ClientWebGLExtensionCompressedTextureASTC(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_etc:
+          return new ClientWebGLExtensionCompressedTextureES3(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_etc1:
+          return new ClientWebGLExtensionCompressedTextureETC1(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_pvrtc:
+          return new ClientWebGLExtensionCompressedTexturePVRTC(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_s3tc:
+          return new ClientWebGLExtensionCompressedTextureS3TC(*this);
+        case WebGLExtensionID::WEBGL_compressed_texture_s3tc_srgb:
+          return new ClientWebGLExtensionCompressedTextureS3TC_SRGB(*this);
+        case WebGLExtensionID::WEBGL_debug_renderer_info:
+          return new ClientWebGLExtensionDebugRendererInfo(*this);
+        case WebGLExtensionID::WEBGL_debug_shaders:
+          return new ClientWebGLExtensionDebugShaders(*this);
+        case WebGLExtensionID::WEBGL_depth_texture:
+          return new ClientWebGLExtensionDepthTexture(*this);
+        case WebGLExtensionID::WEBGL_draw_buffers:
+          return new ClientWebGLExtensionDrawBuffers(*this);
+        case WebGLExtensionID::WEBGL_explicit_present:
+          return new ClientWebGLExtensionExplicitPresent(*this);
+
+        case WebGLExtensionID::WEBGL_lose_context:
+        case WebGLExtensionID::Max:
+          break;
+      }
+      MOZ_ASSERT_UNREACHABLE("illegal extension enum");
+    }();
+    MOZ_ASSERT(extSlot);
+    RequestExtension(ext);
+  }
+
+  return extSlot;
+}
+
+// ----------------------------
+// WebGLContext
+
 bool WebGLContext::IsExtensionSupported(WebGLExtensionID ext) const {
-  if (mDisableExtensions) return false;
+  switch (ext) {
+    case WebGLExtensionID::WEBGL_lose_context:
+    case WebGLExtensionID::MOZ_debug:
+      // Always supported.
+      return true;
 
-  bool shouldResistFingerprinting = ShouldResistFingerprinting();
-
-  switch (ext) {
     // In alphabetical order
     // ANGLE_
     case WebGLExtensionID::ANGLE_instanced_arrays:
@@ -129,6 +245,9 @@
     case WebGLExtensionID::EXT_color_buffer_half_float:
       return WebGLExtensionColorBufferHalfFloat::IsSupported(this);
 
+    case WebGLExtensionID::EXT_disjoint_timer_query:
+      return WebGLExtensionDisjointTimerQuery::IsSupported(this);
+
     case WebGLExtensionID::EXT_float_blend:
       return WebGLExtensionFloatBlend::IsSupported(this);
 
@@ -211,10 +330,10 @@
 
     case WebGLExtensionID::WEBGL_debug_renderer_info:
       return Preferences::GetBool("webgl.enable-debug-renderer-info", false) &&
-             !shouldResistFingerprinting;
+             !mResistFingerprinting;
 
     case WebGLExtensionID::WEBGL_debug_shaders:
-      return !shouldResistFingerprinting;
+      return !mResistFingerprinting;
 
     case WebGLExtensionID::WEBGL_depth_texture:
       return WebGLExtensionDepthTexture::IsSupported(this);
@@ -225,342 +344,183 @@
     case WebGLExtensionID::WEBGL_explicit_present:
       return WebGLExtensionExplicitPresent::IsSupported(this);
 
-    case WebGLExtensionID::WEBGL_lose_context:
-      // We always support this extension.
-      return true;
-
-    case WebGLExtensionID::EXT_disjoint_timer_query:
-    case WebGLExtensionID::MOZ_debug:
     case WebGLExtensionID::Max:
-      return false;
+      break;
   }
 
-  return false;
+  MOZ_CRASH();
 }
 
 bool WebGLContext::IsExtensionExplicit(const WebGLExtensionID ext) const {
-  MOZ_ASSERT(ext < WebGLExtensionID::Max);
   return mExtensions[ext] && mExtensions[ext]->IsExplicit();
 }
 
-void WebGLContext::WarnIfImplicit(const WebGLExtensionID ext) {
-  MOZ_ASSERT(ext < WebGLExtensionID::Max);
+void WebGLContext::WarnIfImplicit(const WebGLExtensionID ext) const {
   const auto& extension = mExtensions[ext];
   if (!extension || extension->IsExplicit()) return;
 
   GenerateWarning(
       "Using format enabled by implicitly enabled extension: %s. "
       "For maximal portability enable it explicitly.",
-      GetExtensionString(ext));
-  // Don't spam warnings
-  extension->SetExplicit();
-}
-
-static bool CompareWebGLExtensionName(const nsACString& name,
-                                      const char* other) {
-  return name.Equals(other, nsCaseInsensitiveCStringComparator());
-}
-
-WebGLExtensionBase* WebGLContext::EnableSupportedExtension(
-    dom::CallerType callerType, WebGLExtensionID ext, bool explict) {
-  if (!IsExtensionEnabled(ext)) {
-    if (!IsExtensionSupported(callerType, ext)) return nullptr;
-
-    EnableExtension(ext);
-  }
-
-  const auto extension = mExtensions[ext];
-  MOZ_ASSERT(extension);
-  if (explict && !extension->IsExplicit()) {
-    extension->SetExplicit();
-  }
-
-  return extension;
+      GetExtensionName(ext));
 }
 
-void ClientWebGLContext::GetExtension(JSContext* cx, const nsAString& wideName,
-                                      JS::MutableHandle<JSObject*> retval,
-                                      dom::CallerType callerType,
-                                      ErrorResult& rv) {
-  retval.set(nullptr);
-  const FuncScope funcScope(this, "getExtension");
+void WebGLContext::RequestExtension(const WebGLExtensionID ext,
+                                    const bool explicitly) {
+  const auto& limits = Limits();
+  if (!limits.supportedExtensions[ext]) return;
+
+  auto& slot = mExtensions[ext];
+  switch (ext) {
+    // ANGLE_
+    case WebGLExtensionID::ANGLE_instanced_arrays:
+      slot.reset(new WebGLExtensionInstancedArrays(this));
+      break;
 
-  NS_LossyConvertUTF16toASCII name(wideName);
+    // EXT_
+    case WebGLExtensionID::EXT_blend_minmax:
+      slot.reset(new WebGLExtensionBlendMinMax(this));
+      break;
+    case WebGLExtensionID::EXT_color_buffer_float:
+      slot.reset(new WebGLExtensionEXTColorBufferFloat(this));
+      break;
+    case WebGLExtensionID::EXT_color_buffer_half_float:
+      slot.reset(new WebGLExtensionColorBufferHalfFloat(this));
+      break;
+    case WebGLExtensionID::EXT_disjoint_timer_query:
+      slot.reset(new WebGLExtensionDisjointTimerQuery(this));
+      break;
+    case WebGLExtensionID::EXT_float_blend:
+      slot.reset(new WebGLExtensionFloatBlend(this));
+      break;
+    case WebGLExtensionID::EXT_frag_depth:
+      slot.reset(new WebGLExtensionFragDepth(this));
+      break;
+    case WebGLExtensionID::EXT_shader_texture_lod:
+      slot.reset(new WebGLExtensionShaderTextureLod(this));
+      break;
+    case WebGLExtensionID::EXT_sRGB:
+      slot.reset(new WebGLExtensionSRGB(this));
+      break;
+    case WebGLExtensionID::EXT_texture_compression_bptc:
+      slot.reset(new WebGLExtensionCompressedTextureBPTC(this));
+      break;
+    case WebGLExtensionID::EXT_texture_compression_rgtc:
+      slot.reset(new WebGLExtensionCompressedTextureRGTC(this));
+      break;
+    case WebGLExtensionID::EXT_texture_filter_anisotropic:
+      slot.reset(new WebGLExtensionTextureFilterAnisotropic(this));
+      break;
+
+    // MOZ_
+    case WebGLExtensionID::MOZ_debug:
+      slot.reset(new WebGLExtensionMOZDebug(this));
+      break;
 
-  WebGLExtensionID ext = WebGLExtensionID::Max;
+    // OES_
+    case WebGLExtensionID::OES_element_index_uint:
+      slot.reset(new WebGLExtensionElementIndexUint(this));
+      break;
+    case WebGLExtensionID::OES_fbo_render_mipmap:
+      slot.reset(new WebGLExtensionFBORenderMipmap(this));
+      break;
+    case WebGLExtensionID::OES_standard_derivatives:
+      slot.reset(new WebGLExtensionStandardDerivatives(this));
+      break;
+    case WebGLExtensionID::OES_texture_float:
+      slot.reset(new WebGLExtensionTextureFloat(this));
+      break;
+    case WebGLExtensionID::OES_texture_float_linear:
+      slot.reset(new WebGLExtensionTextureFloatLinear(this));
+      break;
+    case WebGLExtensionID::OES_texture_half_float:
+      slot.reset(new WebGLExtensionTextureHalfFloat(this));
+      break;
+    case WebGLExtensionID::OES_texture_half_float_linear:
+      slot.reset(new WebGLExtensionTextureHalfFloatLinear(this));
+      break;
+    case WebGLExtensionID::OES_vertex_array_object:
+      slot.reset(new WebGLExtensionVertexArray(this));
+      break;
+
+    // WEBGL_
+    case WebGLExtensionID::OVR_multiview2:
+      slot.reset(new WebGLExtensionMultiview(this));
+      break;
 
-  // step 1: figure what extension is wanted
-  for (size_t i = 0; i < size_t(WebGLExtensionID::Max); i++) {
-    WebGLExtensionID extension = WebGLExtensionID(i);
+    // WEBGL_
+    case WebGLExtensionID::WEBGL_color_buffer_float:
+      slot.reset(new WebGLExtensionColorBufferFloat(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_astc:
+      slot.reset(new WebGLExtensionCompressedTextureASTC(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_etc:
+      slot.reset(new WebGLExtensionCompressedTextureES3(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_etc1:
+      slot.reset(new WebGLExtensionCompressedTextureETC1(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_pvrtc:
+      slot.reset(new WebGLExtensionCompressedTexturePVRTC(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_s3tc:
+      slot.reset(new WebGLExtensionCompressedTextureS3TC(this));
+      break;
+    case WebGLExtensionID::WEBGL_compressed_texture_s3tc_srgb:
+      slot.reset(new WebGLExtensionCompressedTextureS3TC_SRGB(this));
+      break;
+    case WebGLExtensionID::WEBGL_debug_renderer_info:
+      slot.reset(new WebGLExtensionDebugRendererInfo(this));
+      break;
+    case WebGLExtensionID::WEBGL_debug_shaders:
+      slot.reset(new WebGLExtensionDebugShaders(this));
+      break;
+    case WebGLExtensionID::WEBGL_depth_texture:
+      slot.reset(new WebGLExtensionDepthTexture(this));
+      break;
+    case WebGLExtensionID::WEBGL_draw_buffers:
+      slot.reset(new WebGLExtensionDrawBuffers(this));
+      break;
+    case WebGLExtensionID::WEBGL_explicit_present:
+      slot.reset(new WebGLExtensionExplicitPresent(this));
+      break;
+    case WebGLExtensionID::WEBGL_lose_context:
+      slot.reset(new WebGLExtensionLoseContext(this));
+      break;
 
-    if (CompareWebGLExtensionName(name, GetExtensionString(extension))) {
-      ext = extension;
-      break;
-    }
+    case WebGLExtensionID::Max:
+      MOZ_CRASH();
+  }
+  MOZ_ASSERT(slot);
+  const auto& obj = slot;
+
+  if (explicitly && !obj->IsExplicit()) {
+    obj->SetExplicit();
   }
 
-  if (ext == WebGLExtensionID::Max) return;
-
-  // step 2: if the extension hadn't been previously been created then we
-  // have to tell the host we are using it
-  ClientWebGLExtensionBase* extObj = GetExtension(callerType, ext, true);
-  if (!extObj) return;
-
-  // Step 3: Enable any implied extensions.
+  // Also enable implied extensions.
   switch (ext) {
     case WebGLExtensionID::EXT_color_buffer_float:
-      EnableSupportedExtension(callerType, WebGLExtensionID::EXT_float_blend,
-                               false);
+      RequestExtension(WebGLExtensionID::EXT_float_blend, false);
       break;
 
     case WebGLExtensionID::OES_texture_float:
-      EnableSupportedExtension(
-          callerType, WebGLExtensionID::WEBGL_color_buffer_float, false);
-      EnableSupportedExtension(callerType, WebGLExtensionID::EXT_float_blend,
-                               false);
+      RequestExtension(WebGLExtensionID::EXT_float_blend, false);
+      RequestExtension(WebGLExtensionID::WEBGL_color_buffer_float, false);
       break;
 
     case WebGLExtensionID::OES_texture_half_float:
-      EnableSupportedExtension(
-          callerType, WebGLExtensionID::EXT_color_buffer_half_float, false);
+      RequestExtension(WebGLExtensionID::EXT_color_buffer_half_float, false);
       break;
 
     case WebGLExtensionID::WEBGL_color_buffer_float:
-      EnableSupportedExtension(callerType, WebGLExtensionID::EXT_float_blend,
-                               false);
+      RequestExtension(WebGLExtensionID::EXT_float_blend, false);
       break;
 
     default:
       break;
   }
-
-  retval.set(WebGLObjectAsJSObject(cx, extObj, rv));
-}
-
-void WebGLContext::CreateExtension(WebGLExtensionID ext) {
-  MOZ_ASSERT(IsExtensionEnabled(ext) == false);
-
-  WebGLExtensionBase* obj = nullptr;
-  switch (ext) {
-    // ANGLE_
-    case WebGLExtensionID::ANGLE_instanced_arrays:
-      obj = new WebGLExtensionInstancedArrays(this);
-      break;
-
-    // EXT_
-    case WebGLExtensionID::EXT_blend_minmax:
-      obj = new WebGLExtensionBlendMinMax(this);
-      break;
-    case WebGLExtensionID::EXT_color_buffer_float:
-      obj = new WebGLExtensionEXTColorBufferFloat(this);
-      break;
-    case WebGLExtensionID::EXT_color_buffer_half_float:
-      obj = new WebGLExtensionColorBufferHalfFloat(this);
-      break;
-    case WebGLExtensionID::EXT_disjoint_timer_query:
-      obj = new WebGLExtensionDisjointTimerQuery(this);
-      break;
-    case WebGLExtensionID::EXT_float_blend:
-      obj = new WebGLExtensionFloatBlend(this);
-      break;
-    case WebGLExtensionID::EXT_frag_depth:
-      obj = new WebGLExtensionFragDepth(this);
-      break;
-    case WebGLExtensionID::EXT_shader_texture_lod:
-      obj = new WebGLExtensionShaderTextureLod(this);
-      break;
-    case WebGLExtensionID::EXT_sRGB:
-      obj = new WebGLExtensionSRGB(this);
-      break;
-    case WebGLExtensionID::EXT_texture_compression_bptc:
-      obj = new WebGLExtensionCompressedTextureBPTC(this);
-      break;
-    case WebGLExtensionID::EXT_texture_compression_rgtc:
-      obj = new WebGLExtensionCompressedTextureRGTC(this);
-      break;
-    case WebGLExtensionID::EXT_texture_filter_anisotropic:
-      obj = new WebGLExtensionTextureFilterAnisotropic(this);
-      break;
-
-    // MOZ_
-    case WebGLExtensionID::MOZ_debug:
-      obj = new WebGLExtensionMOZDebug(this);
-      break;
-
-    // OES_
-    case WebGLExtensionID::OES_element_index_uint:
-      obj = new WebGLExtensionElementIndexUint(this);
-      break;
-    case WebGLExtensionID::OES_fbo_render_mipmap:
-      obj = new WebGLExtensionFBORenderMipmap(this);
-      break;
-    case WebGLExtensionID::OES_standard_derivatives:
-      obj = new WebGLExtensionStandardDerivatives(this);
-      break;
-    case WebGLExtensionID::OES_texture_float:
-      obj = new WebGLExtensionTextureFloat(this);
-      break;
-    case WebGLExtensionID::OES_texture_float_linear:
-      obj = new WebGLExtensionTextureFloatLinear(this);
-      break;
-    case WebGLExtensionID::OES_texture_half_float:
-      obj = new WebGLExtensionTextureHalfFloat(this);
-      break;
-    case WebGLExtensionID::OES_texture_half_float_linear:
-      obj = new WebGLExtensionTextureHalfFloatLinear(this);
-      break;
-    case WebGLExtensionID::OES_vertex_array_object:
-      obj = new WebGLExtensionVertexArray(this);
-      break;
-
-    // WEBGL_
-    case WebGLExtensionID::OVR_multiview2:
-      obj = new WebGLExtensionMultiview(this);
-      break;
-
-    // WEBGL_
-    case WebGLExtensionID::WEBGL_color_buffer_float:
-      obj = new WebGLExtensionColorBufferFloat(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_astc:
-      obj = new WebGLExtensionCompressedTextureASTC(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_etc:
-      obj = new WebGLExtensionCompressedTextureES3(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_etc1:
-      obj = new WebGLExtensionCompressedTextureETC1(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_pvrtc:
-      obj = new WebGLExtensionCompressedTexturePVRTC(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_s3tc:
-      obj = new WebGLExtensionCompressedTextureS3TC(this);
-      break;
-    case WebGLExtensionID::WEBGL_compressed_texture_s3tc_srgb:
-      obj = new WebGLExtensionCompressedTextureS3TC_SRGB(this);
-      break;
-    case WebGLExtensionID::WEBGL_debug_renderer_info:
-      obj = new WebGLExtensionDebugRendererInfo(this);
-      break;
-    case WebGLExtensionID::WEBGL_debug_shaders:
-      obj = new WebGLExtensionDebugShaders(this);
-      break;
-    case WebGLExtensionID::WEBGL_depth_texture:
-      obj = new WebGLExtensionDepthTexture(this);
-      break;
-    case WebGLExtensionID::WEBGL_draw_buffers:
-      obj = new WebGLExtensionDrawBuffers(this);
-      break;
-    case WebGLExtensionID::WEBGL_explicit_present:
-      obj = new WebGLExtensionExplicitPresent(this);
-      break;
-    case WebGLExtensionID::WEBGL_lose_context:
-      obj = new WebGLExtensionLoseContext(this);
-      break;
-
-    case WebGLExtensionID::Max:
-      MOZ_CRASH();
-  }
-
-  mExtensions[ext] = obj;
-}
-
-const Maybe<ExtensionSets> WebGLContext::GetSupportedExtensions() {
-  const FuncScope funcScope(*this, "getSupportedExtensions");
-  if (IsContextLost()) return Nothing();
-
-  Maybe<ExtensionSets> ret = Some(ExtensionSets());
-  auto& sets = ret.ref();
-  for (size_t i = 0; i < size_t(WebGLExtensionID::Max); i++) {
-    const auto extension = WebGLExtensionID(i);
-    if (IsExtensionSupported(dom::CallerType::NonSystem, extension)) {
-      sets.mNonSystem.AppendElement(extension);
-    } else if (IsExtensionSupported(dom::CallerType::System, extension)) {
-      sets.mSystem.AppendElement(extension);
-    }
-  }
-  return ret;
-}
-
-ClientWebGLExtensionBase* ClientWebGLContext::UseExtension(
-    WebGLExtensionID ext) {
-  switch (ext) {
-    // ANGLE_
-    case WebGLExtensionID::ANGLE_instanced_arrays:
-      return new ClientWebGLExtensionInstancedArrays(this);
-
-    // EXT_
-    case WebGLExtensionID::EXT_blend_minmax:
-      return new ClientWebGLExtensionBlendMinMax(this);
-    case WebGLExtensionID::EXT_color_buffer_float:
-      return new ClientWebGLExtensionEXTColorBufferFloat(this);
-    case WebGLExtensionID::EXT_color_buffer_half_float:
-      return new ClientWebGLExtensionColorBufferHalfFloat(this);
-    case WebGLExtensionID::EXT_disjoint_timer_query:
-      return new ClientWebGLExtensionDisjointTimerQuery(this);
-    case WebGLExtensionID::EXT_frag_depth:
-      return new ClientWebGLExtensionFragDepth(this);
-    case WebGLExtensionID::EXT_shader_texture_lod:
-      return new ClientWebGLExtensionShaderTextureLod(this);
-    case WebGLExtensionID::EXT_sRGB:
-      return new ClientWebGLExtensionSRGB(this);
-    case WebGLExtensionID::EXT_texture_compression_bptc:
-      return new ClientWebGLExtensionCompressedTextureBPTC(this);
-    case WebGLExtensionID::EXT_texture_compression_rgtc:
-      return new ClientWebGLExtensionCompressedTextureRGTC(this);
-    case WebGLExtensionID::EXT_texture_filter_anisotropic:
-      return new ClientWebGLExtensionTextureFilterAnisotropic(this);
-
-    // MOZ_
-    case WebGLExtensionID::MOZ_debug:
-      return new ClientWebGLExtensionMOZDebug(this);
-
-    // OES_
-    case WebGLExtensionID::OES_element_index_uint:
-      return new ClientWebGLExtensionElementIndexUint(this);
-    case WebGLExtensionID::OES_standard_derivatives:
-      return new ClientWebGLExtensionStandardDerivatives(this);
-    case WebGLExtensionID::OES_texture_float:
-      return new ClientWebGLExtensionTextureFloat(this);
-    case WebGLExtensionID::OES_texture_float_linear:
-      return new ClientWebGLExtensionTextureFloatLinear(this);
-    case WebGLExtensionID::OES_texture_half_float:
-      return new ClientWebGLExtensionTextureHalfFloat(this);
-    case WebGLExtensionID::OES_texture_half_float_linear:
-      return new ClientWebGLExtensionTextureHalfFloatLinear(this);
-    case WebGLExtensionID::OES_vertex_array_object:
-      return new ClientWebGLExtensionVertexArray(this);
-
-    // WEBGL_
-    case WebGLExtensionID::WEBGL_color_buffer_float:
-      return new ClientWebGLExtensionColorBufferFloat(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_astc:
-      return new ClientWebGLExtensionCompressedTextureASTC(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_etc:
-      return new ClientWebGLExtensionCompressedTextureES3(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_etc1:
-      return new ClientWebGLExtensionCompressedTextureETC1(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_pvrtc:
-      return new ClientWebGLExtensionCompressedTexturePVRTC(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_s3tc:
-      return new ClientWebGLExtensionCompressedTextureS3TC(this);
-    case WebGLExtensionID::WEBGL_compressed_texture_s3tc_srgb:
-      return new ClientWebGLExtensionCompressedTextureS3TC_SRGB(this);
-    case WebGLExtensionID::WEBGL_debug_renderer_info:
-      return new ClientWebGLExtensionDebugRendererInfo(this);
-    case WebGLExtensionID::WEBGL_debug_shaders:
-      return new ClientWebGLExtensionDebugShaders(this);
-    case WebGLExtensionID::WEBGL_depth_texture:
-      return new ClientWebGLExtensionDepthTexture(this);
-    case WebGLExtensionID::WEBGL_draw_buffers:
-      return new ClientWebGLExtensionDrawBuffers(this);
-    case WebGLExtensionID::WEBGL_lose_context:
-      return new ClientWebGLExtensionLoseContext(this);
-    default:
-      MOZ_ASSERT_UNREACHABLE("illegal extension enum");
-      return nullptr;
-  }
 }
 
 }  // namespace mozilla