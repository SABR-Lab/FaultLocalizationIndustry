# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextGL.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLContextGL.cpp
--- a/dom/canvas/WebGLContextGL.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLContextGL.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -6,18 +6,15 @@
 #include "WebGLContext.h"
 #include "WebGL2Context.h"
 
-#include "WebGLActiveInfo.h"
 #include "WebGLContextUtils.h"
 #include "WebGLBuffer.h"
 #include "WebGLVertexAttribData.h"
 #include "WebGLShader.h"
 #include "WebGLProgram.h"
-#include "WebGLUniformLocation.h"
 #include "WebGLFormats.h"
 #include "WebGLFramebuffer.h"
 #include "WebGLQuery.h"
 #include "WebGLRenderbuffer.h"
-#include "WebGLShaderPrecisionFormat.h"
 #include "WebGLTexture.h"
 #include "WebGLExtensions.h"
 #include "WebGLVertexArray.h"
@@ -51,23 +48,12 @@
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ImageData.h"
-#include "mozilla/dom/ToJSValue.h"
 #include "mozilla/EndianUtils.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/UniquePtrExtensions.h"
 
 namespace mozilla {
 
-bool WebGLContext::ValidateObject(const char* const argName,
-                                  const WebGLProgram& object) const {
-  return ValidateObject(argName, object, true);
-}
-
-bool WebGLContext::ValidateObject(const char* const argName,
-                                  const WebGLShader& object) const {
-  return ValidateObject(argName, object, true);
-}
-
 using namespace mozilla::dom;
 using namespace mozilla::gfx;
 using namespace mozilla::gl;
@@ -76,53 +62,47 @@
 //  WebGL API
 //
 
-void WebGLContext::ActiveTexture(GLenum texture) {
-  const FuncScope funcScope(*this, "activeTexture");
+void WebGLContext::ActiveTexture(uint32_t texUnit) {
+  FuncScope funcScope(*this, "activeTexture");
   if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
-  if (texture < LOCAL_GL_TEXTURE0 ||
-      texture >= LOCAL_GL_TEXTURE0 + mGLMaxTextureUnits) {
-    return ErrorInvalidEnum(
-        "Texture unit %d out of range. "
-        "Accepted values range from TEXTURE0 to TEXTURE0 + %d. "
-        "Notice that TEXTURE0 != 0.",
-        texture, mGLMaxTextureUnits);
+  if (texUnit >= Limits().maxTexUnits) {
+    return ErrorInvalidEnum("Texture unit %u out of range (%u).", texUnit,
+                            Limits().maxTexUnits);
   }
 
-  mActiveTexture = texture - LOCAL_GL_TEXTURE0;
-  gl->fActiveTexture(texture);
+  mActiveTexture = texUnit;
+  gl->fActiveTexture(LOCAL_GL_TEXTURE0 + texUnit);
+
+  funcScope.mBindFailureGuard = false;
 }
 
-void WebGLContext::AttachShader(WebGLProgram& program, WebGLShader& shader) {
-  const FuncScope funcScope(*this, "attachShader");
+void WebGLContext::AttachShader(WebGLProgram& prog, WebGLShader& shader) {
+  FuncScope funcScope(*this, "attachShader");
   if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
-  if (!ValidateObject("program", program) ||
-      !ValidateObject("shader", shader)) {
-    return;
-  }
+  prog.AttachShader(shader);
 
-  program.AttachShader(&shader);
+  funcScope.mBindFailureGuard = false;
 }
 
 void WebGLContext::BindAttribLocation(WebGLProgram& prog, GLuint location,
-                                      const nsAString& name) {
+                                      const std::string& name) const {
   const FuncScope funcScope(*this, "bindAttribLocation");
   if (IsContextLost()) return;
 
-  if (!ValidateObject("program", prog)) return;
-
   prog.BindAttribLocation(location, name);
 }
 
 void WebGLContext::BindFramebuffer(GLenum target, WebGLFramebuffer* wfb) {
-  const FuncScope funcScope(*this, "bindFramebuffer");
+  FuncScope funcScope(*this, "bindFramebuffer");
   if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
   if (!ValidateFramebufferTarget(target)) return;
 
-  if (wfb && !ValidateObject("fb", *wfb)) return;
-
   if (!wfb) {
     gl->fBindFramebuffer(target, 0);
   } else {
@@ -143,38 +123,9 @@
       mBoundReadFramebuffer = wfb;
       break;
     default:
-      break;
+      return;
   }
-}
-
-void WebGLContext::BindRenderbuffer(GLenum target, WebGLRenderbuffer* wrb) {
-  const FuncScope funcScope(*this, "bindRenderbuffer");
-  if (IsContextLost()) return;
-
-  if (target != LOCAL_GL_RENDERBUFFER)
-    return ErrorInvalidEnumInfo("target", target);
-
-  if (wrb && !ValidateObject("rb", *wrb)) return;
-
-  // Usually, we would now call into glBindRenderbuffer. However, since we have
-  // to potentially emulate packed-depth-stencil, there's not a specific
-  // renderbuffer that we know we should bind here. Instead, we do all
-  // renderbuffer binding lazily.
-
-  if (wrb) {
-    wrb->mHasBeenBound = true;
-  }
-
-  mBoundRenderbuffer = wrb;
-}
-
-void WebGLContext::BlendEquation(GLenum mode) {
-  const FuncScope funcScope(*this, "blendEquation");
-  if (IsContextLost()) return;
-
-  if (!ValidateBlendEquationEnum(mode, "mode")) return;
-
-  gl->fBlendEquation(mode);
+  funcScope.mBindFailureGuard = false;
 }
 
 void WebGLContext::BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
@@ -240,19 +191,6 @@
   return true;
 }
 
-void WebGLContext::BlendFunc(GLenum sfactor, GLenum dfactor) {
-  const FuncScope funcScope(*this, "blendFunc");
-  if (IsContextLost()) return;
-
-  if (!ValidateBlendFuncEnums(this, sfactor, sfactor, dfactor, dfactor)) return;
-
-  if (!ValidateBlendFuncEnumsCompatibility(sfactor, dfactor,
-                                           "srcRGB and dstRGB"))
-    return;
-
-  gl->fBlendFunc(sfactor, dfactor);
-}
-
 void WebGLContext::BlendFuncSeparate(GLenum srcRGB, GLenum dstRGB,
                                      GLenum srcAlpha, GLenum dstAlpha) {
   const FuncScope funcScope(*this, "blendFuncSeparate");
@@ -295,14 +233,14 @@
   return fb->CheckFramebufferStatus().get();
 }
 
-already_AddRefed<WebGLProgram> WebGLContext::CreateProgram() {
+RefPtr<WebGLProgram> WebGLContext::CreateProgram() {
   const FuncScope funcScope(*this, "createProgram");
   if (IsContextLost()) return nullptr;
-  RefPtr<WebGLProgram> globj = new WebGLProgram(this);
-  return globj.forget();
+
+  return new WebGLProgram(this);
 }
 
-already_AddRefed<WebGLShader> WebGLContext::CreateShader(GLenum type) {
+RefPtr<WebGLShader> WebGLContext::CreateShader(GLenum type) {
   const FuncScope funcScope(*this, "createShader");
   if (IsContextLost()) return nullptr;
 
@@ -311,8 +249,7 @@
     return nullptr;
   }
 
-  RefPtr<WebGLShader> shader = new WebGLShader(this, type);
-  return shader.forget();
+  return new WebGLShader(this, type);
 }
 
 void WebGLContext::CullFace(GLenum face) {
@@ -324,88 +261,14 @@
   gl->fCullFace(face);
 }
 
-void WebGLContext::DeleteFramebuffer(WebGLFramebuffer* fbuf) {
-  const FuncScope funcScope(*this, "deleteFramebuffer");
-  if (!ValidateDeleteObject(fbuf)) return;
-
-  fbuf->RequestDelete();
-
-  if (mBoundReadFramebuffer == mBoundDrawFramebuffer) {
-    if (mBoundDrawFramebuffer == fbuf) {
-      BindFramebuffer(LOCAL_GL_FRAMEBUFFER,
-                      static_cast<WebGLFramebuffer*>(nullptr));
-    }
-  } else if (mBoundDrawFramebuffer == fbuf) {
-    BindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER,
-                    static_cast<WebGLFramebuffer*>(nullptr));
-  } else if (mBoundReadFramebuffer == fbuf) {
-    BindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER,
-                    static_cast<WebGLFramebuffer*>(nullptr));
-  }
-}
-
-void WebGLContext::DeleteRenderbuffer(WebGLRenderbuffer* rbuf) {
-  const FuncScope funcScope(*this, "deleteRenderbuffer");
-  if (!ValidateDeleteObject(rbuf)) return;
-
-  if (mBoundDrawFramebuffer) mBoundDrawFramebuffer->DetachRenderbuffer(rbuf);
-
-  if (mBoundReadFramebuffer) mBoundReadFramebuffer->DetachRenderbuffer(rbuf);
-
-  if (mBoundRenderbuffer == rbuf)
-    BindRenderbuffer(LOCAL_GL_RENDERBUFFER, nullptr);
-
-  rbuf->RequestDelete();
-}
-
-void WebGLContext::DeleteTexture(WebGLTexture* tex) {
-  const FuncScope funcScope(*this, "deleteTexture");
-  if (!ValidateDeleteObject(tex)) return;
-
-  if (mBoundDrawFramebuffer) mBoundDrawFramebuffer->DetachTexture(tex);
+void WebGLContext::DetachShader(WebGLProgram& prog, const WebGLShader& shader) {
+  FuncScope funcScope(*this, "detachShader");
+  if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
-  if (mBoundReadFramebuffer) mBoundReadFramebuffer->DetachTexture(tex);
-
-  GLuint activeTexture = mActiveTexture;
-  for (uint32_t i = 0; i < mGLMaxTextureUnits; i++) {
-    if (mBound2DTextures[i] == tex || mBoundCubeMapTextures[i] == tex ||
-        mBound3DTextures[i] == tex || mBound2DArrayTextures[i] == tex) {
-      ActiveTexture(LOCAL_GL_TEXTURE0 + i);
-      BindTexture(tex->Target().get(), nullptr);
-    }
-  }
-  ActiveTexture(LOCAL_GL_TEXTURE0 + activeTexture);
-
-  tex->RequestDelete();
-}
-
-void WebGLContext::DeleteProgram(WebGLProgram* prog) {
-  const FuncScope funcScope(*this, "deleteProgram");
-  if (!ValidateDeleteObject(prog)) return;
+  prog.DetachShader(shader);
 
-  prog->RequestDelete();
-}
-
-void WebGLContext::DeleteShader(WebGLShader* shader) {
-  const FuncScope funcScope(*this, "deleteShader");
-  if (!ValidateDeleteObject(shader)) return;
-
-  shader->RequestDelete();
-}
-
-void WebGLContext::DetachShader(WebGLProgram& program,
-                                const WebGLShader& shader) {
-  const FuncScope funcScope(*this, "detachShader");
-  if (IsContextLost()) return;
-
-  // It's valid to attempt to detach a deleted shader, since it's still a
-  // shader.
-  if (!ValidateObject("program", program) ||
-      !ValidateObjectAllowDeleted("shader", shader)) {
-    return;
-  }
-
-  program.DetachShader(&shader);
+  funcScope.mBindFailureGuard = false;
 }
 
 static bool ValidateComparisonEnum(WebGLContext& webgl, const GLenum func) {
@@ -448,198 +311,45 @@
 
 // -
 
-void WebGLContext::FramebufferAttach(
-    const GLenum target, const GLenum attachEnum, const TexTarget reqTexTarget,
-    const webgl::FbAttachInfo& toAttach) const {
+void WebGLContext::FramebufferAttach(const GLenum target,
+                                     const GLenum attachSlot,
+                                     const GLenum bindImageTarget,
+                                     const webgl::FbAttachInfo& toAttach) {
+  FuncScope funcScope(*this, "framebufferAttach");
+  funcScope.mBindFailureGuard = true;
+  const auto& limits = *mLimits;
+
   if (!ValidateFramebufferTarget(target)) return;
 
-  WebGLFramebuffer* fb = mBoundDrawFramebuffer;
+  auto fb = mBoundDrawFramebuffer;
   if (target == LOCAL_GL_READ_FRAMEBUFFER) {
     fb = mBoundReadFramebuffer;
   }
-  if (!fb) return ErrorInvalidOperation("Cannot modify framebuffer 0.");
-
-  // `rb`
-  if (toAttach.rb) {
-    if (!ValidateObject("rb", *toAttach.rb)) return;
+  if (!fb) return;
 
-    if (!toAttach.rb->mHasBeenBound) {
-      ErrorInvalidOperation(
-          "bindRenderbuffer must be called before"
-          " attachment.");
-      return;
-    }
-  }
+  // `rb` needs no validation.
 
   // `tex`
-  if (toAttach.tex) {
-    if (!ValidateObject("tex", *toAttach.tex)) return;
-    const auto texTarget = toAttach.tex->Target();
-
-    bool targetOk = bool(texTarget);
-    if (reqTexTarget) {
-      targetOk = texTarget == reqTexTarget;
-    }
-    if (!targetOk) {
-      ErrorInvalidOperation("`tex`'s binding target type is not valid.");
-      return;
-    }
-
-    GLint maxMipLevel;
-    GLint maxZLayer;
-    const char* maxMipLevelText;
-    const char* maxZLayerText;
-
-    switch (texTarget.get()) {
-      case LOCAL_GL_TEXTURE_2D:
-        maxMipLevel = FloorLog2(mGLMaxTextureSize);
-        maxMipLevelText = "log2(MAX_TEXTURE_SIZE)";
-        maxZLayer = 1;
-        maxZLayerText = "1";
-        break;
-
-      case LOCAL_GL_TEXTURE_CUBE_MAP:
-        maxMipLevel = FloorLog2(mGLMaxCubeMapTextureSize);
-        maxMipLevelText = "log2(MAX_CUBE_MAP_TEXTURE_SIZE)";
-        maxZLayer = 6;
-        maxZLayerText = "6";
-        break;
-
-      case LOCAL_GL_TEXTURE_3D:
-        maxMipLevel = FloorLog2(mGLMax3DTextureSize);
-        maxMipLevelText = "log2(MAX_3D_TEXTURE_SIZE)";
-        maxZLayer = mGLMax3DTextureSize - 1;
-        maxZLayerText = "MAX_3D_TEXTURE_SIZE";
-        break;
-
-      case LOCAL_GL_TEXTURE_2D_ARRAY:
-        maxMipLevel = FloorLog2(mGLMaxTextureSize);
-        maxMipLevelText = "log2(MAX_TEXTURE_SIZE)";
-        maxZLayer = mGLMaxArrayTextureLayers;
-        maxZLayerText = "MAX_ARRAY_TEXTURE_LAYERS";
-        break;
-
-      default:
-        MOZ_CRASH();
-    }
-    if (!IsWebGL2() &&
-        !IsExtensionEnabled(WebGLExtensionID::OES_fbo_render_mipmap)) {
-      maxMipLevel = 0;
-      maxMipLevelText = "0";
-    }
-
-    if (toAttach.mipLevel < 0)
-      return ErrorInvalidValue("`level` must be >= 0.");
-    if (toAttach.mipLevel > maxMipLevel) {
-      ErrorInvalidValue("`level` must be <= %s.", maxMipLevelText);
-      return;
-    }
-
-    if (toAttach.zLayer < 0) return ErrorInvalidValue("`layer` must be >= 0.");
-    if (toAttach.zLayerCount < 1)
-      return ErrorInvalidValue("`numViews` must be >= 1.");
-    if (AssertedCast<uint32_t>(toAttach.zLayerCount) > mGLMaxMultiviewViews)
-      return ErrorInvalidValue("`numViews` must be <= MAX_VIEWS_OVR.");
-
-    const auto lastZLayer = toAttach.zLayer + toAttach.zLayerCount;
-    if (lastZLayer > maxZLayer) {
-      const char* formatText = "`layer` must be < %s.";
-      if (toAttach.zLayerCount != 1) {
-        formatText = "`layer` + `numViews` must be <= %s.";
-      }
-      ErrorInvalidValue(formatText, maxZLayerText);
-      return;
-    }
+  const auto& tex = toAttach.tex;
+  if (tex) {
+    const auto err = CheckFramebufferAttach(bindImageTarget, tex->mTarget.get(),
+                                            toAttach.mipLevel, toAttach.zLayer,
+                                            toAttach.zLayerCount, limits);
+    if (err) return;
   }
 
-  fb->FramebufferAttach(attachEnum, toAttach);
-}
-
-void WebGLContext::FramebufferRenderbuffer(const GLenum target,
-                                           const GLenum attachEnum,
-                                           const GLenum rbTarget,
-                                           WebGLRenderbuffer* const rb) const {
-  const FuncScope funcScope(*this, "framebufferRenderbuffer");
-  if (IsContextLost()) return;
-
-  if (rbTarget != LOCAL_GL_RENDERBUFFER) {
-    ErrorInvalidEnumArg("rbTarget", rbTarget);
-    return;
+  auto safeToAttach = toAttach;
+  if (!IsWebGL2() &&
+      !IsExtensionEnabled(WebGLExtensionID::OES_fbo_render_mipmap)) {
+    safeToAttach.mipLevel = 0;
+  }
+  if (!IsExtensionEnabled(WebGLExtensionID::OVR_multiview2)) {
+    safeToAttach.isMultiview = false;
   }
 
-  const auto toAttach = webgl::FbAttachInfo{rb};
-  FramebufferAttach(target, attachEnum, 0, toAttach);
-}
-
-void WebGLContext::FramebufferTexture2D(const GLenum target,
-                                        const GLenum attachEnum,
-                                        const GLenum imageTarget,
-                                        WebGLTexture* const tex,
-                                        const GLint level) const {
-  const FuncScope funcScope(*this, "framebufferTexture2D");
-  if (IsContextLost()) return;
-
-  TexTarget reqTexTarget = LOCAL_GL_TEXTURE_2D;
-  auto toAttach = webgl::FbAttachInfo{nullptr, tex, level, 0};
-  if (toAttach.tex) {
-    switch (imageTarget) {
-      case LOCAL_GL_TEXTURE_2D:
-        break;
-      case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-      case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-      case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-      case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-      case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-      case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-        toAttach.zLayer = imageTarget - LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-        reqTexTarget = LOCAL_GL_TEXTURE_CUBE_MAP;
-        break;
-      default:
-        ErrorInvalidEnumArg("texImageTarget", imageTarget);
-        return;
-    }
-  }
-
-  FramebufferAttach(target, attachEnum, reqTexTarget, toAttach);
-}
+  if (!fb->FramebufferAttach(attachSlot, safeToAttach)) return;
 
-void WebGLContext::FramebufferTextureLayer(const GLenum target,
-                                           const GLenum attachEnum,
-                                           WebGLTexture* const tex,
-                                           const GLint mipLevel,
-                                           const GLint zLayer) const {
-  const FuncScope funcScope(*this, "framebufferTextureLayer");
-  if (IsContextLost()) return;
-
-  const auto toAttach = webgl::FbAttachInfo{nullptr, tex, mipLevel, zLayer};
-  if (toAttach.tex) {
-    if (!ValidateObject("tex", *toAttach.tex))
-      return;  // Technically we need to check this first...
-
-    switch (toAttach.tex->Target().get()) {
-      case LOCAL_GL_TEXTURE_3D:
-      case LOCAL_GL_TEXTURE_2D_ARRAY:
-        break;
-      default:
-        ErrorInvalidOperation(
-            "`texture` must be a TEXTURE_3D or"
-            " TEXTURE_2D_ARRAY.");
-        return;
-    }
-  }
-
-  FramebufferAttach(target, attachEnum, 0, toAttach);
-}
-
-void WebGLContext::FramebufferTextureMultiview(
-    const GLenum target, const GLenum attachEnum, WebGLTexture* const tex,
-    const GLint mipLevel, const GLint zLayerBase,
-    const GLsizei numViewLayers) const {
-  if (IsContextLost()) return;
-
-  const auto toAttach = webgl::FbAttachInfo{nullptr,    tex,           mipLevel,
-                                            zLayerBase, numViewLayers, true};
-  FramebufferAttach(target, attachEnum, LOCAL_GL_TEXTURE_2D_ARRAY, toAttach);
+  funcScope.mBindFailureGuard = false;
 }
 
 // -
@@ -659,48 +369,7 @@
   gl->fFrontFace(mode);
 }
 
-Maybe<WebGLActiveInfo> WebGLContext::GetActiveAttrib(const WebGLProgram& prog,
-                                                     GLuint index) {
-  const FuncScope funcScope(*this, "getActiveAttrib");
-  if (IsContextLost()) return Nothing();
-
-  if (!ValidateObject("program", prog)) return Nothing();
-
-  return prog.GetActiveAttrib(index);
-}
-
-Maybe<WebGLActiveInfo> WebGLContext::GetActiveUniform(const WebGLProgram& prog,
-                                                      GLuint index) {
-  const FuncScope funcScope(*this, "getActiveUniform");
-  if (IsContextLost()) return Nothing();
-
-  if (!ValidateObject("program", prog)) return Nothing();
-
-  return prog.GetActiveUniform(index);
-}
-
-MaybeAttachedShaders WebGLContext::GetAttachedShaders(
-    const WebGLProgram& prog) {
-  const FuncScope funcScope(*this, "getAttachedShaders");
-  if (IsContextLost()) return Nothing();
-
-  if (!ValidateObject("prog", prog)) return Nothing();
-
-  return prog.GetAttachedShaders();
-}
-
-GLint WebGLContext::GetAttribLocation(const WebGLProgram& prog,
-                                      const nsAString& name) {
-  const FuncScope funcScope(*this, "getAttribLocation");
-  if (IsContextLost()) return -1;
-
-  if (!ValidateObject("program", prog)) return -1;
-
-  return prog.GetAttribLocation(name);
-}
-
-MaybeWebGLVariant WebGLContext::GetBufferParameter(GLenum target,
-                                                   GLenum pname) {
+Maybe<double> WebGLContext::GetBufferParameter(GLenum target, GLenum pname) {
   const FuncScope funcScope(*this, "getBufferParameter");
   if (IsContextLost()) return Nothing();
 
@@ -715,10 +384,10 @@
 
   switch (pname) {
     case LOCAL_GL_BUFFER_SIZE:
-      return AsSomeVariant(buffer->ByteLength());
+      return Some(buffer->ByteLength());
 
     case LOCAL_GL_BUFFER_USAGE:
-      return AsSomeVariant(buffer->Usage());
+      return Some(buffer->Usage());
 
     default:
       ErrorInvalidEnumInfo("pname", pname);
@@ -726,29 +395,12 @@
   }
 }
 
-MaybeWebGLVariant WebGLContext::GetFramebufferAttachmentParameter(
-    GLenum target, GLenum attachment, GLenum pname) {
+Maybe<double> WebGLContext::GetFramebufferAttachmentParameter(
+    WebGLFramebuffer* const fb, GLenum attachment, GLenum pname) const {
   const FuncScope funcScope(*this, "getFramebufferAttachmentParameter");
   if (IsContextLost()) return Nothing();
 
-  if (!ValidateFramebufferTarget(target)) return Nothing();
-
-  WebGLFramebuffer* fb;
-  switch (target) {
-    case LOCAL_GL_FRAMEBUFFER:
-    case LOCAL_GL_DRAW_FRAMEBUFFER:
-      fb = mBoundDrawFramebuffer;
-      break;
-
-    case LOCAL_GL_READ_FRAMEBUFFER:
-      fb = mBoundReadFramebuffer;
-      break;
-
-    default:
-      MOZ_CRASH("GFX: Bad target.");
-  }
-
-  if (fb) return fb->GetAttachmentParameter(target, attachment, pname);
+  if (fb) return fb->GetAttachmentParameter(attachment, pname);
 
   ////////////////////////////////////
 
@@ -779,12 +431,12 @@
           break;
         case LOCAL_GL_DEPTH:
           if (!mOptions.depth) {
-            return AsSomeVariant(LOCAL_GL_NONE);
+            return Some(LOCAL_GL_NONE);
           }
           break;
         case LOCAL_GL_STENCIL:
           if (!mOptions.stencil) {
-            return AsSomeVariant(LOCAL_GL_NONE);
+            return Some(LOCAL_GL_NONE);
           }
           break;
         default:
@@ -793,64 +445,64 @@
               " or STENCIL for GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE");
           return Nothing();
       }
-      return AsSomeVariant(LOCAL_GL_FRAMEBUFFER_DEFAULT);
+      return Some(LOCAL_GL_FRAMEBUFFER_DEFAULT);
 
       ////////////////
 
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
-      if (attachment == LOCAL_GL_BACK) return AsSomeVariant(8);
-      return AsSomeVariant(0);
+      if (attachment == LOCAL_GL_BACK) return Some(8);
+      return Some(0);
 
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
       if (attachment == LOCAL_GL_BACK) {
         if (mOptions.alpha) {
-          return AsSomeVariant(8);
+          return Some(8);
         }
         ErrorInvalidOperation(
             "The default framebuffer doesn't contain an alpha buffer");
         return Nothing();
       }
-      return AsSomeVariant(0);
+      return Some(0);
 
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
       if (attachment == LOCAL_GL_DEPTH) {
         if (mOptions.depth) {
-          return AsSomeVariant(24);
+          return Some(24);
         }
         ErrorInvalidOperation(
             "The default framebuffer doesn't contain an depth buffer");
         return Nothing();
       }
-      return AsSomeVariant(0);
+      return Some(0);
 
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
       if (attachment == LOCAL_GL_STENCIL) {
         if (mOptions.stencil) {
-          return AsSomeVariant(8);
+          return Some(8);
         }
         ErrorInvalidOperation(
             "The default framebuffer doesn't contain an stencil buffer");
         return Nothing();
       }
-      return AsSomeVariant(0);
+      return Some(0);
 
     case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
       if (attachment == LOCAL_GL_STENCIL) {
         if (mOptions.stencil) {
-          return AsSomeVariant(LOCAL_GL_UNSIGNED_INT);
+          return Some(LOCAL_GL_UNSIGNED_INT);
         }
         ErrorInvalidOperation(
             "The default framebuffer doesn't contain an stencil buffer");
       } else if (attachment == LOCAL_GL_DEPTH) {
         if (mOptions.depth) {
-          return AsSomeVariant(LOCAL_GL_UNSIGNED_NORMALIZED);
+          return Some(LOCAL_GL_UNSIGNED_NORMALIZED);
         }
         ErrorInvalidOperation(
             "The default framebuffer doesn't contain an depth buffer");
       } else {  // LOCAL_GL_BACK
-        return AsSomeVariant(LOCAL_GL_UNSIGNED_NORMALIZED);
+        return Some(LOCAL_GL_UNSIGNED_NORMALIZED);
       }
       return Nothing();
 
@@ -868,28 +520,18 @@
           return Nothing();
         }
       }
-      return AsSomeVariant(LOCAL_GL_LINEAR);
+      return Some(LOCAL_GL_LINEAR);
   }
 
   ErrorInvalidEnumInfo("pname", pname);
   return Nothing();
 }
 
-MaybeWebGLVariant WebGLContext::GetRenderbufferParameter(GLenum target,
-                                                         GLenum pname) {
+Maybe<double> WebGLContext::GetRenderbufferParameter(
+    const WebGLRenderbuffer& rb, GLenum pname) const {
   const FuncScope funcScope(*this, "getRenderbufferParameter");
   if (IsContextLost()) return Nothing();
 
-  if (target != LOCAL_GL_RENDERBUFFER) {
-    ErrorInvalidEnumInfo("target", target);
-    return Nothing();
-  }
-
-  if (!mBoundRenderbuffer) {
-    ErrorInvalidOperation("No renderbuffer is bound.");
-    return Nothing();
-  }
-
   switch (pname) {
     case LOCAL_GL_RENDERBUFFER_SAMPLES:
       if (!IsWebGL2()) break;
@@ -905,8 +547,8 @@
     case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
     case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT: {
       // RB emulation means we have to ask the RB itself.
-      GLint i = mBoundRenderbuffer->GetRenderbufferParameter(target, pname);
-      return AsSomeVariant(i);
+      GLint i = rb.GetRenderbufferParameter(pname);
+      return Some(i);
     }
 
     default:
@@ -917,15 +559,14 @@
   return Nothing();
 }
 
-already_AddRefed<WebGLTexture> WebGLContext::CreateTexture() {
+RefPtr<WebGLTexture> WebGLContext::CreateTexture() {
   const FuncScope funcScope(*this, "createTexture");
   if (IsContextLost()) return nullptr;
 
   GLuint tex = 0;
   gl->fGenTextures(1, &tex);
 
-  RefPtr<WebGLTexture> globj = new WebGLTexture(this, tex);
-  return globj.forget();
+  return new WebGLTexture(this, tex);
 }
 
 GLenum WebGLContext::GetError() {
@@ -952,7 +593,7 @@
   // UnderlyingGL-side errors, now.
   err = gl->fGetError();
   if (gl->IsContextLost()) {
-    UpdateContextLossStatus();
+    CheckForContextLoss();
     return GetError();
   }
   MOZ_ASSERT(err != LOCAL_GL_CONTEXT_LOST);
@@ -967,48 +608,78 @@
   return err;
 }
 
-MaybeWebGLVariant WebGLContext::GetProgramParameter(const WebGLProgram& prog,
-                                                    GLenum pname) {
-  const FuncScope funcScope(*this, "getProgramParameter");
-  if (IsContextLost()) return Nothing();
+webgl::GetUniformData WebGLContext::GetUniform(const WebGLProgram& prog,
+                                               const uint32_t loc) const {
+  const FuncScope funcScope(*this, "getUniform");
+  webgl::GetUniformData ret;
+  [&]() {
+    if (IsContextLost()) return;
 
-  if (!ValidateObjectAllowDeleted("program", prog)) return Nothing();
+    const auto& info = prog.LinkInfo();
+    if (!info) return;
 
-  return prog.GetProgramParameter(pname);
-}
+    const auto locInfo = MaybeFind(info->locationMap, loc);
+    if (!locInfo) return;
 
-nsString WebGLContext::GetProgramInfoLog(const WebGLProgram& prog) {
-  const FuncScope funcScope(*this, "getProgramInfoLog");
-
-  if (IsContextLost()) return EmptyString();
-
-  if (!ValidateObject("program", prog)) return EmptyString();
-
-  return prog.GetProgramInfoLog();
-}
+    ret.type = locInfo->info.info.elemType;
+    switch (ret.type) {
+      case LOCAL_GL_FLOAT:
+      case LOCAL_GL_FLOAT_VEC2:
+      case LOCAL_GL_FLOAT_VEC3:
+      case LOCAL_GL_FLOAT_VEC4:
+      case LOCAL_GL_FLOAT_MAT2:
+      case LOCAL_GL_FLOAT_MAT3:
+      case LOCAL_GL_FLOAT_MAT4:
+      case LOCAL_GL_FLOAT_MAT2x3:
+      case LOCAL_GL_FLOAT_MAT2x4:
+      case LOCAL_GL_FLOAT_MAT3x2:
+      case LOCAL_GL_FLOAT_MAT3x4:
+      case LOCAL_GL_FLOAT_MAT4x2:
+      case LOCAL_GL_FLOAT_MAT4x3:
+        gl->fGetUniformfv(prog.mGLName, loc,
+                          reinterpret_cast<float*>(ret.data));
+        break;
 
-MaybeWebGLVariant WebGLContext::GetUniform(const WebGLProgram& prog,
-                                           const WebGLUniformLocation& loc) {
-  const FuncScope funcScope(*this, "getUniform");
-  if (IsContextLost()) return Nothing();
-
-  if (!ValidateObject("program", prog)) return Nothing();
-
-  if (!ValidateObjectAllowDeleted("location", loc)) return Nothing();
-
-  if (!loc.ValidateForProgram(&prog)) return Nothing();
+      case LOCAL_GL_INT:
+      case LOCAL_GL_INT_VEC2:
+      case LOCAL_GL_INT_VEC3:
+      case LOCAL_GL_INT_VEC4:
+      case LOCAL_GL_SAMPLER_2D:
+      case LOCAL_GL_SAMPLER_3D:
+      case LOCAL_GL_SAMPLER_CUBE:
+      case LOCAL_GL_SAMPLER_2D_SHADOW:
+      case LOCAL_GL_SAMPLER_2D_ARRAY:
+      case LOCAL_GL_SAMPLER_2D_ARRAY_SHADOW:
+      case LOCAL_GL_SAMPLER_CUBE_SHADOW:
+      case LOCAL_GL_INT_SAMPLER_2D:
+      case LOCAL_GL_INT_SAMPLER_3D:
+      case LOCAL_GL_INT_SAMPLER_CUBE:
+      case LOCAL_GL_INT_SAMPLER_2D_ARRAY:
+      case LOCAL_GL_UNSIGNED_INT_SAMPLER_2D:
+      case LOCAL_GL_UNSIGNED_INT_SAMPLER_3D:
+      case LOCAL_GL_UNSIGNED_INT_SAMPLER_CUBE:
+      case LOCAL_GL_UNSIGNED_INT_SAMPLER_2D_ARRAY:
+      case LOCAL_GL_BOOL:
+      case LOCAL_GL_BOOL_VEC2:
+      case LOCAL_GL_BOOL_VEC3:
+      case LOCAL_GL_BOOL_VEC4:
+        gl->fGetUniformiv(prog.mGLName, loc,
+                          reinterpret_cast<int32_t*>(ret.data));
+        break;
 
-  return loc.GetUniform();
-}
+      case LOCAL_GL_UNSIGNED_INT:
+      case LOCAL_GL_UNSIGNED_INT_VEC2:
+      case LOCAL_GL_UNSIGNED_INT_VEC3:
+      case LOCAL_GL_UNSIGNED_INT_VEC4:
+        gl->fGetUniformuiv(prog.mGLName, loc,
+                           reinterpret_cast<uint32_t*>(ret.data));
+        break;
 
-already_AddRefed<WebGLUniformLocation> WebGLContext::GetUniformLocation(
-    const WebGLProgram& prog, const nsAString& name) {
-  const FuncScope funcScope(*this, "getUniformLocation");
-  if (IsContextLost()) return nullptr;
-
-  if (!ValidateObject("program", prog)) return nullptr;
-
-  return prog.GetUniformLocation(name);
+      default:
+        MOZ_CRASH("GFX: Invalid elemType.");
+    }
+  }();
+  return ret;
 }
 
 void WebGLContext::Hint(GLenum target, GLenum mode) {
@@ -1042,78 +713,10 @@
 
 // -
 
-bool WebGLContext::IsBuffer(const WebGLBuffer* const obj) {
-  const FuncScope funcScope(*this, "isBuffer");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return obj->Content() != WebGLBuffer::Kind::Undefined;
-}
-
-bool WebGLContext::IsFramebuffer(const WebGLFramebuffer* const obj) {
-  const FuncScope funcScope(*this, "isFramebuffer");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return obj->mHasBeenBound;
-}
-
-bool WebGLContext::IsProgram(const WebGLProgram* const obj) {
-  const FuncScope funcScope(*this, "isProgram");
-  return ValidateIsObject(obj);
-}
-
-bool WebGLContext::IsQuery(const WebGLQuery* const obj) {
-  const FuncScope funcScope(*this, "isQuery");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return bool(obj->Target());
-}
-
-bool WebGLContext::IsRenderbuffer(const WebGLRenderbuffer* const obj) {
-  const FuncScope funcScope(*this, "isRenderbuffer");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return obj->mHasBeenBound;
-}
-
-bool WebGLContext::IsShader(const WebGLShader* const obj) {
-  const FuncScope funcScope(*this, "isShader");
-  return ValidateIsObject(obj);
-}
-
-bool WebGLContext::IsTexture(const WebGLTexture* const obj) {
-  const FuncScope funcScope(*this, "isTexture");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return bool(obj->Target());
-}
-
-bool WebGLContext::IsVertexArray(const WebGLVertexArray* const obj) {
-  const FuncScope funcScope(*this, "isVertexArray");
-  if (!ValidateIsObject(obj)) return false;
-
-  if (obj->IsDeleteRequested()) return false;
-
-  return obj->mHasBeenBound;
-}
-
-// -
-
 void WebGLContext::LinkProgram(WebGLProgram& prog) {
   const FuncScope funcScope(*this, "linkProgram");
   if (IsContextLost()) return;
 
-  if (!ValidateObject("prog", prog)) return;
-
   prog.LinkProgram();
 
   if (!prog.IsLinked()) {
@@ -1131,9 +734,9 @@
   }
 }
 
-WebGLPixelStore WebGLContext::PixelStorei(GLenum pname, GLint param) {
+void WebGLContext::PixelStorei(GLenum pname, GLint param) {
   const FuncScope funcScope(*this, "pixelStorei");
-  if (IsContextLost()) return mPixelStore;
+  if (IsContextLost()) return;
 
   if (IsWebGL2()) {
     uint32_t* pValueSlot = nullptr;
@@ -1172,39 +775,39 @@
     }
 
     if (pValueSlot) {
-      if (!ValidateNonNegative("param", param)) return mPixelStore;
+      if (!ValidateNonNegative("param", param)) return;
 
       gl->fPixelStorei(pname, param);
       *pValueSlot = param;
-      return mPixelStore;
+      return;
     }
   }
 
   switch (pname) {
     case UNPACK_FLIP_Y_WEBGL:
       mPixelStore.mFlipY = bool(param);
-      return mPixelStore;
+      return;
 
     case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
       mPixelStore.mPremultiplyAlpha = bool(param);
-      return mPixelStore;
+      return;
 
     case UNPACK_COLORSPACE_CONVERSION_WEBGL:
       switch (param) {
         case LOCAL_GL_NONE:
         case BROWSER_DEFAULT_WEBGL:
           mPixelStore.mColorspaceConversion = param;
-          return mPixelStore;
+          return;
 
         default:
           ErrorInvalidEnumInfo("colorspace conversion parameter", param);
-          return mPixelStore;
+          return;
       }
 
     case UNPACK_REQUIRE_FASTPATH:
       if (IsExtensionEnabled(WebGLExtensionID::MOZ_debug)) {
         mPixelStore.mRequireFastPath = bool(param);
-        return mPixelStore;
+        return;
       }
       break;
 
@@ -1221,11 +824,11 @@
             mPixelStore.mUnpackAlignment = param;
 
           gl->fPixelStorei(pname, param);
-          return mPixelStore;
+          return;
 
         default:
           ErrorInvalidValue("Invalid pack/unpack alignment value.");
-          return mPixelStore;
+          return;
       }
 
     default:
@@ -1233,32 +836,34 @@
   }
 
   ErrorInvalidEnumInfo("pname", pname);
-  return mPixelStore;
+  return;
 }
 
 bool WebGLContext::DoReadPixelsAndConvert(const webgl::FormatInfo* srcFormat,
                                           GLint x, GLint y, GLsizei width,
                                           GLsizei height, GLenum format,
-                                          GLenum destType, void* dest,
-                                          uint32_t destSize,
+                                          GLenum destType, uintptr_t dest,
+                                          uint64_t destSize,
                                           uint32_t rowStride) {
   // On at least Win+NV, we'll get PBO errors if we don't have at least
   // `rowStride * height` bytes available to read into.
-  const auto naiveBytesNeeded = CheckedUint32(rowStride) * height;
+  const auto naiveBytesNeeded = CheckedInt<uint64_t>(rowStride) * height;
   const bool isDangerCloseToEdge =
       (!naiveBytesNeeded.isValid() || naiveBytesNeeded.value() > destSize);
   const bool useParanoidHandling =
       (gl->WorkAroundDriverBugs() && isDangerCloseToEdge &&
        mBoundPixelPackBuffer);
   if (!useParanoidHandling) {
-    gl->fReadPixels(x, y, width, height, format, destType, dest);
+    gl->fReadPixels(x, y, width, height, format, destType,
+                    reinterpret_cast<void*>(dest));
     return true;
   }
 
   // Read everything but the last row.
   const auto bodyHeight = height - 1;
   if (bodyHeight) {
-    gl->fReadPixels(x, y, width, bodyHeight, format, destType, dest);
+    gl->fReadPixels(x, y, width, bodyHeight, format, destType,
+                    reinterpret_cast<void*>(dest));
   }
 
   // Now read the last row.
@@ -1318,31 +923,25 @@
   return true;
 }
 
-Maybe<UniquePtr<RawBuffer<>>> WebGLContext::ReadPixels(
-    GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type,
-    size_t byteLen) {
+void WebGLContext::ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
+                              GLenum format, GLenum type,
+                              const Range<uint8_t>& dest) {
   const FuncScope funcScope(*this, "readPixels");
-  if (IsContextLost()) return Nothing();
+  if (IsContextLost()) return;
 
   if (mBoundPixelPackBuffer) {
     ErrorInvalidOperation("PIXEL_PACK_BUFFER must be null.");
-    return Nothing();
+    return;
   }
 
-  // TODO: Allocate the Shmem earlier so we can use it here instead of copying
-  uint8_t* bytes = new uint8_t[byteLen];
-  if (!bytes) {
-    ErrorOutOfMemory("ReadPixels could not allocate temp memory");
-    return Nothing();
-  }
-  UniquePtr<RawBuffer<>> buf = MakeUnique<RawBuffer<>>(byteLen, bytes, true);
-  ReadPixelsImpl(x, y, width, height, format, type, bytes, byteLen);
-  return Some(std::move(buf));
+  ReadPixelsImpl(x, y, width, height, format, type,
+                 reinterpret_cast<uintptr_t>(dest.begin().get()),
+                 dest.length());
 }
 
-void WebGLContext::ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
-                              GLenum format, GLenum type,
-                              WebGLsizeiptr offset) {
+void WebGLContext::ReadPixelsPbo(GLint x, GLint y, GLsizei width,
+                                 GLsizei height, GLenum format, GLenum type,
+                                 uint64_t offset) {
   const FuncScope funcScope(*this, "readPixels");
   if (IsContextLost()) return;
 
@@ -1351,8 +950,6 @@
 
   //////
 
-  if (!ValidateNonNegative("offset", offset)) return;
-
   {
     const auto bytesPerType = webgl::BytesPerPixel({LOCAL_GL_RED, type});
 
@@ -1366,18 +963,18 @@
 
   //////
 
-  const auto bytesAvailable = buffer->ByteLength();
-  const auto checkedBytesAfterOffset = CheckedUint32(bytesAvailable) - offset;
+  auto bytesAvailable = buffer->ByteLength();
+  if (offset > bytesAvailable) {
+    ErrorInvalidOperation("`offset` too large for bound PIXEL_PACK_BUFFER.");
+    return;
+  }
+  bytesAvailable -= offset;
 
-  uint32_t bytesAfterOffset = 0;
-  if (checkedBytesAfterOffset.isValid()) {
-    bytesAfterOffset = checkedBytesAfterOffset.value();
-  }
+  // -
 
   const ScopedLazyBind lazyBind(gl, LOCAL_GL_PIXEL_PACK_BUFFER, buffer);
 
-  ReadPixelsImpl(x, y, width, height, format, type, (void*)offset,
-                 bytesAfterOffset);
+  ReadPixelsImpl(x, y, width, height, format, type, offset, bytesAvailable);
 
   buffer->ResetLastUpdateFenceId();
 }
@@ -1487,8 +1084,8 @@
 
 void WebGLContext::ReadPixelsImpl(GLint x, GLint y, GLsizei rawWidth,
                                   GLsizei rawHeight, GLenum packFormat,
-                                  GLenum packType, void* dest,
-                                  uint32_t dataLen) {
+                                  GLenum packType, uintptr_t dest,
+                                  uint64_t availBytes) {
   if (!ValidateNonNegative("width", rawWidth) ||
       !ValidateNonNegative("height", rawHeight)) {
     return;
@@ -1522,7 +1119,7 @@
   if (!ValidatePackSize(width, height, bytesPerPixel, &rowStride, &bytesNeeded))
     return;
 
-  if (bytesNeeded > dataLen) {
+  if (bytesNeeded > availBytes) {
     ErrorInvalidOperation("buffer too small");
     return;
   }
@@ -1549,7 +1146,7 @@
 
   if (uint32_t(rwWidth) == width && uint32_t(rwHeight) == height) {
     DoReadPixelsAndConvert(srcFormat->format, x, y, width, height, packFormat,
-                           packType, dest, dataLen, rowStride);
+                           packType, dest, bytesNeeded, rowStride);
     return;
   }
 
@@ -1579,7 +1176,7 @@
                      mPixelStore.mPackSkipRows + writeY);
 
     DoReadPixelsAndConvert(srcFormat->format, readX, readY, rwWidth, rwHeight,
-                           packFormat, packType, dest, dataLen, rowStride);
+                           packFormat, packType, dest, bytesNeeded, rowStride);
 
     gl->fPixelStorei(LOCAL_GL_PACK_ROW_LENGTH, mPixelStore.mPackRowLength);
     gl->fPixelStorei(LOCAL_GL_PACK_SKIP_PIXELS, mPixelStore.mPackSkipPixels);
@@ -1587,39 +1184,25 @@
   } else {
     // I *did* say "hilariously slow".
 
-    uint8_t* row = (uint8_t*)dest + writeX * bytesPerPixel;
+    auto row = dest + writeX * bytesPerPixel;
     row += writeY * rowStride;
     for (uint32_t j = 0; j < uint32_t(rwHeight); j++) {
       DoReadPixelsAndConvert(srcFormat->format, readX, readY + j, rwWidth, 1,
-                             packFormat, packType, row, dataLen, rowStride);
+                             packFormat, packType, row, bytesNeeded, rowStride);
       row += rowStride;
     }
   }
 }
 
-void WebGLContext::RenderbufferStorage_base(GLenum target, GLsizei samples,
-                                            GLenum internalFormat,
-                                            GLsizei width, GLsizei height) {
+void WebGLContext::RenderbufferStorageMultisample(WebGLRenderbuffer& rb,
+                                                  uint32_t samples,
+                                                  GLenum internalFormat,
+                                                  uint32_t width,
+                                                  uint32_t height) const {
+  const FuncScope funcScope(*this, "renderbufferStorage(Multisample)?");
   if (IsContextLost()) return;
 
-  if (target != LOCAL_GL_RENDERBUFFER) {
-    ErrorInvalidEnumInfo("target", target);
-    return;
-  }
-
-  if (!mBoundRenderbuffer) {
-    ErrorInvalidOperation("Called on renderbuffer 0.");
-    return;
-  }
-
-  if (!ValidateNonNegative("width", width) ||
-      !ValidateNonNegative("height", height) ||
-      !ValidateNonNegative("samples", samples)) {
-    return;
-  }
-
-  mBoundRenderbuffer->RenderbufferStorage(uint32_t(samples), internalFormat,
-                                          uint32_t(width), uint32_t(height));
+  rb.RenderbufferStorage(samples, internalFormat, width, height);
 }
 
 void WebGLContext::Scissor(GLint x, GLint y, GLsizei width, GLsizei height) {
@@ -1635,20 +1218,6 @@
   mScissorRect.Apply(*gl);
 }
 
-void WebGLContext::StencilFunc(GLenum func, GLint ref, GLuint mask) {
-  const FuncScope funcScope(*this, "stencilFunc");
-  if (IsContextLost()) return;
-
-  if (!ValidateComparisonEnum(*this, func)) return;
-
-  mStencilRefFront = ref;
-  mStencilRefBack = ref;
-  mStencilValueMaskFront = mask;
-  mStencilValueMaskBack = mask;
-
-  gl->fStencilFunc(func, ref, mask);
-}
-
 void WebGLContext::StencilFuncSeparate(GLenum face, GLenum func, GLint ref,
                                        GLuint mask) {
   const FuncScope funcScope(*this, "stencilFuncSeparate");
@@ -1678,18 +1247,6 @@
   gl->fStencilFuncSeparate(face, func, ref, mask);
 }
 
-void WebGLContext::StencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) {
-  const FuncScope funcScope(*this, "stencilOp");
-  if (IsContextLost()) return;
-
-  if (!ValidateStencilOpEnum(sfail, "sfail") ||
-      !ValidateStencilOpEnum(dpfail, "dpfail") ||
-      !ValidateStencilOpEnum(dppass, "dppass"))
-    return;
-
-  gl->fStencilOp(sfail, dpfail, dppass);
-}
-
 void WebGLContext::StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail,
                                      GLenum dppass) {
   const FuncScope funcScope(*this, "stencilOpSeparate");
@@ -1706,238 +1263,6 @@
 ////////////////////////////////////////////////////////////////////////////////
 // Uniform setters.
 
-class ValidateIfSampler {
-  const WebGLUniformLocation* const mLoc;
-  const size_t mDataCount;
-  const GLint* const mData;
-  bool mIsValidatedSampler;
-
- public:
-  ValidateIfSampler(WebGLContext* webgl, WebGLUniformLocation* loc,
-                    size_t dataCount, const GLint* data, bool* const out_error)
-      : mLoc(loc),
-        mDataCount(dataCount),
-        mData(data),
-        mIsValidatedSampler(false) {
-    if (!mLoc->mInfo->mSamplerTexList) {
-      *out_error = false;
-      return;
-    }
-
-    for (size_t i = 0; i < mDataCount; i++) {
-      const auto& val = mData[i];
-      if (val < 0 || uint32_t(val) >= webgl->GLMaxTextureUnits()) {
-        webgl->ErrorInvalidValue(
-            "This uniform location is a sampler, but %d"
-            " is not a valid texture unit.",
-            val);
-        *out_error = true;
-        return;
-      }
-    }
-
-    mIsValidatedSampler = true;
-    *out_error = false;
-  }
-
-  ~ValidateIfSampler() {
-    if (!mIsValidatedSampler) return;
-
-    auto& samplerValues = mLoc->mInfo->mSamplerValues;
-
-    for (size_t i = 0; i < mDataCount; i++) {
-      const size_t curIndex = mLoc->mArrayIndex + i;
-      if (curIndex >= samplerValues.size()) break;
-
-      samplerValues[curIndex] = mData[i];
-    }
-  }
-};
-
-////////////////////
-
-void WebGLContext::Uniform1i(WebGLUniformLocation* loc, GLint a1) {
-  const FuncScope funcScope(*this, "uniform1i");
-  if (!ValidateUniformSetter(loc, 1, webgl::AttribBaseType::Int)) return;
-
-  bool error;
-  const ValidateIfSampler validate(this, loc, 1, &a1, &error);
-  if (error) return;
-
-  gl->fUniform1i(loc->mLoc, a1);
-}
-
-void WebGLContext::Uniform2i(WebGLUniformLocation* loc, GLint a1, GLint a2) {
-  const FuncScope funcScope(*this, "uniform2i");
-  if (!ValidateUniformSetter(loc, 2, webgl::AttribBaseType::Int)) return;
-
-  gl->fUniform2i(loc->mLoc, a1, a2);
-}
-
-void WebGLContext::Uniform3i(WebGLUniformLocation* loc, GLint a1, GLint a2,
-                             GLint a3) {
-  const FuncScope funcScope(*this, "uniform3i");
-  if (!ValidateUniformSetter(loc, 3, webgl::AttribBaseType::Int)) return;
-
-  gl->fUniform3i(loc->mLoc, a1, a2, a3);
-}
-
-void WebGLContext::Uniform4i(WebGLUniformLocation* loc, GLint a1, GLint a2,
-                             GLint a3, GLint a4) {
-  const FuncScope funcScope(*this, "uniform4i");
-  if (!ValidateUniformSetter(loc, 4, webgl::AttribBaseType::Int)) return;
-
-  gl->fUniform4i(loc->mLoc, a1, a2, a3, a4);
-}
-
-//////////
-
-void WebGLContext::Uniform1f(WebGLUniformLocation* loc, GLfloat a1) {
-  const FuncScope funcScope(*this, "uniform1f");
-  if (!ValidateUniformSetter(loc, 1, webgl::AttribBaseType::Float)) return;
-
-  gl->fUniform1f(loc->mLoc, a1);
-}
-
-void WebGLContext::Uniform2f(WebGLUniformLocation* loc, GLfloat a1,
-                             GLfloat a2) {
-  const FuncScope funcScope(*this, "uniform2f");
-  if (!ValidateUniformSetter(loc, 2, webgl::AttribBaseType::Float)) return;
-
-  gl->fUniform2f(loc->mLoc, a1, a2);
-}
-
-void WebGLContext::Uniform3f(WebGLUniformLocation* loc, GLfloat a1, GLfloat a2,
-                             GLfloat a3) {
-  const FuncScope funcScope(*this, "uniform3f");
-  if (!ValidateUniformSetter(loc, 3, webgl::AttribBaseType::Float)) return;
-
-  gl->fUniform3f(loc->mLoc, a1, a2, a3);
-}
-
-void WebGLContext::Uniform4f(WebGLUniformLocation* loc, GLfloat a1, GLfloat a2,
-                             GLfloat a3, GLfloat a4) {
-  const FuncScope funcScope(*this, "uniform4f");
-  if (!ValidateUniformSetter(loc, 4, webgl::AttribBaseType::Float)) return;
-
-  gl->fUniform4f(loc->mLoc, a1, a2, a3, a4);
-}
-
-////////////////////////////////////////
-// Array
-
-static bool ValidateArrOffsetAndCount(WebGLContext* webgl, size_t elemsAvail,
-                                      GLuint elemOffset,
-                                      GLuint elemCountOverride,
-                                      size_t* const out_elemCount) {
-  if (webgl->IsContextLost()) return false;
-
-  if (elemOffset > elemsAvail) {
-    webgl->ErrorInvalidValue("Bad offset into list.");
-    return false;
-  }
-  elemsAvail -= elemOffset;
-
-  if (elemCountOverride) {
-    if (elemCountOverride > elemsAvail) {
-      webgl->ErrorInvalidValue("Bad count override for sub-list.");
-      return false;
-    }
-    elemsAvail = elemCountOverride;
-  }
-
-  *out_elemCount = elemsAvail;
-  return true;
-}
-
-void WebGLContext::UniformNiv(const char* funcName, uint8_t N,
-                              WebGLUniformLocation* loc,
-                              const RawBuffer<const GLint>& arr,
-                              GLuint elemOffset, GLuint elemCountOverride) {
-  const FuncScope funcScope(*this, funcName);
-
-  size_t elemCount;
-  if (!ValidateArrOffsetAndCount(this, arr.Length(), elemOffset,
-                                 elemCountOverride, &elemCount)) {
-    return;
-  }
-  const auto elemBytes = arr.Data() + elemOffset;
-
-  uint32_t numElementsToUpload;
-  if (!ValidateUniformArraySetter(loc, N, webgl::AttribBaseType::Int, elemCount,
-                                  &numElementsToUpload)) {
-    return;
-  }
-
-  bool error;
-  const ValidateIfSampler samplerValidator(this, loc, numElementsToUpload,
-                                           elemBytes, &error);
-  if (error) return;
-
-  static const decltype(&gl::GLContext::fUniform1iv) kFuncList[] = {
-      &gl::GLContext::fUniform1iv, &gl::GLContext::fUniform2iv,
-      &gl::GLContext::fUniform3iv, &gl::GLContext::fUniform4iv};
-  const auto func = kFuncList[N - 1];
-
-  (gl->*func)(loc->mLoc, numElementsToUpload, elemBytes);
-}
-
-void WebGLContext::UniformNuiv(const char* funcName, uint8_t N,
-                               WebGLUniformLocation* loc,
-                               const RawBuffer<const GLuint>& arr,
-                               GLuint elemOffset, GLuint elemCountOverride) {
-  const FuncScope funcScope(*this, funcName);
-
-  size_t elemCount;
-  if (!ValidateArrOffsetAndCount(this, arr.Length(), elemOffset,
-                                 elemCountOverride, &elemCount)) {
-    return;
-  }
-  const auto elemBytes = arr.Data() + elemOffset;
-
-  uint32_t numElementsToUpload;
-  if (!ValidateUniformArraySetter(loc, N, webgl::AttribBaseType::UInt,
-                                  elemCount, &numElementsToUpload)) {
-    return;
-  }
-  MOZ_ASSERT(!loc->mInfo->mSamplerTexList, "Should not be a sampler.");
-
-  static const decltype(&gl::GLContext::fUniform1uiv) kFuncList[] = {
-      &gl::GLContext::fUniform1uiv, &gl::GLContext::fUniform2uiv,
-      &gl::GLContext::fUniform3uiv, &gl::GLContext::fUniform4uiv};
-  const auto func = kFuncList[N - 1];
-
-  (gl->*func)(loc->mLoc, numElementsToUpload, elemBytes);
-}
-
-void WebGLContext::UniformNfv(const char* funcName, uint8_t N,
-                              WebGLUniformLocation* loc,
-                              const RawBuffer<const GLfloat>& arr,
-                              GLuint elemOffset, GLuint elemCountOverride) {
-  const FuncScope funcScope(*this, funcName);
-
-  size_t elemCount;
-  if (!ValidateArrOffsetAndCount(this, arr.Length(), elemOffset,
-                                 elemCountOverride, &elemCount)) {
-    return;
-  }
-  const auto elemBytes = arr.Data() + elemOffset;
-
-  uint32_t numElementsToUpload;
-  if (!ValidateUniformArraySetter(loc, N, webgl::AttribBaseType::Float,
-                                  elemCount, &numElementsToUpload)) {
-    return;
-  }
-  MOZ_ASSERT(!loc->mInfo->mSamplerTexList, "Should not be a sampler.");
-
-  static const decltype(&gl::GLContext::fUniform1fv) kFuncList[] = {
-      &gl::GLContext::fUniform1fv, &gl::GLContext::fUniform2fv,
-      &gl::GLContext::fUniform3fv, &gl::GLContext::fUniform4fv};
-  const auto func = kFuncList[N - 1];
-
-  (gl->*func)(loc->mLoc, numElementsToUpload, elemBytes);
-}
-
 static inline void MatrixAxBToRowMajor(const uint8_t width,
                                        const uint8_t height,
                                        const float* __restrict srcColMajor,
@@ -1949,122 +1274,116 @@
   }
 }
 
-void WebGLContext::UniformMatrixAxBfv(const char* funcName, uint8_t A,
-                                      uint8_t B, WebGLUniformLocation* loc,
-                                      const bool transpose,
-                                      const RawBuffer<const float>& arr,
-                                      GLuint elemOffset,
-                                      GLuint elemCountOverride) {
-  const FuncScope funcScope(*this, funcName);
+void WebGLContext::UniformData(const uint32_t loc, const bool transpose,
+                               const Range<const uint8_t>& data) const {
+  const FuncScope funcScope(*this, "uniform setter");
+  const auto& link = mActiveProgramLinkInfo;
+  if (!link) return;
+
+  const auto locInfo = MaybeFind(link->locationMap, loc);
+  if (!locInfo) return;
 
-  size_t elemCount;
-  if (!ValidateArrOffsetAndCount(this, arr.Length(), elemOffset,
-                                 elemCountOverride, &elemCount)) {
-    return;
-  }
-  const auto elemBytes = arr.Data() + elemOffset;
+  const auto& validationInfo = locInfo->info;
+  const auto& channels = validationInfo.channelsPerElem;
+  const auto& pfn = validationInfo.pfn;
+
+  // -
 
-  uint32_t numMatsToUpload;
-  if (!ValidateUniformMatrixArraySetter(loc, A, B, webgl::AttribBaseType::Float,
-                                        elemCount, transpose,
-                                        &numMatsToUpload)) {
+  const auto lengthInType = data.length() / sizeof(float);
+  if (!lengthInType || lengthInType % channels != 0) {
+    const auto& activeInfo = validationInfo.info;
+    GenerateError(LOCAL_GL_INVALID_VALUE,
+                  "`values` length (%u) must be a positive integer multiple of "
+                  "size of %s.",
+                  lengthInType, EnumString(activeInfo.elemType).c_str());
     return;
   }
-  MOZ_ASSERT(!loc->mInfo->mSamplerTexList, "Should not be a sampler.");
-
-  ////
+  const auto elemCount = lengthInType / channels;
 
-  bool uploadTranspose = transpose;
-  const float* uploadBytes = elemBytes;
-
-  UniqueBuffer temp;
-  if (!transpose && gl->WorkAroundDriverBugs() && gl->IsANGLE() &&
-      gl->IsAtLeast(gl::ContextProfile::OpenGLES, 300)) {
-    // ANGLE is really slow at non-GL-transposed matrices.
-    const size_t kElemsPerMat = A * B;
+  // -
 
-    temp = malloc(numMatsToUpload * kElemsPerMat * sizeof(float));
-    if (!temp) {
-      ErrorOutOfMemory("Failed to alloc temporary buffer for transposition.");
-      return;
+  const auto& samplerInfo = locInfo->samplerInfo;
+  if (samplerInfo) {
+    const auto idata = reinterpret_cast<const uint32_t*>(data.begin().get());
+    const auto maxTexUnits = GLMaxTextureUnits();
+    for (const auto& val : Range<const uint32_t>(idata, elemCount)) {
+      if (val >= maxTexUnits) {
+        ErrorInvalidValue(
+            "This uniform location is a sampler, but %d"
+            " is not a valid texture unit.",
+            val);
+        return;
+      }
     }
-
-    auto srcItr = (const float*)elemBytes;
-    auto dstItr = (float*)temp.get();
-    const auto srcEnd = srcItr + numMatsToUpload * kElemsPerMat;
-
-    while (srcItr != srcEnd) {
-      MatrixAxBToRowMajor(A, B, srcItr, dstItr);
-      srcItr += kElemsPerMat;
-      dstItr += kElemsPerMat;
-    }
-
-    uploadBytes = (const float*)temp.get();
-    uploadTranspose = true;
   }
 
-  ////
+  // -
 
-  static const decltype(&gl::GLContext::fUniformMatrix2fv) kFuncList[] = {
-      &gl::GLContext::fUniformMatrix2fv,   &gl::GLContext::fUniformMatrix2x3fv,
-      &gl::GLContext::fUniformMatrix2x4fv,
+  // This is a little galaxy-brain, sorry!
+  const auto ptr = static_cast<const void*>(data.begin().get());
+  (*pfn)(*gl, static_cast<GLint>(loc), elemCount, transpose, ptr);
+
+  // -
 
-      &gl::GLContext::fUniformMatrix3x2fv, &gl::GLContext::fUniformMatrix3fv,
-      &gl::GLContext::fUniformMatrix3x4fv,
+  if (samplerInfo) {
+    auto& texUnits = samplerInfo->texUnits;
 
-      &gl::GLContext::fUniformMatrix4x2fv, &gl::GLContext::fUniformMatrix4x3fv,
-      &gl::GLContext::fUniformMatrix4fv};
-  const auto func = kFuncList[3 * (A - 2) + (B - 2)];
-
-  (gl->*func)(loc->mLoc, numMatsToUpload, uploadTranspose, uploadBytes);
+    const auto srcBegin = reinterpret_cast<const uint32_t*>(data.begin().get());
+    auto destIndex = locInfo->indexIntoUniform;
+    for (const auto& val : Range<const uint32_t>(srcBegin, elemCount)) {
+      if (destIndex >= texUnits.size()) break;
+      texUnits[destIndex] = val;
+      destIndex += 1;
+    }
+  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 
 void WebGLContext::UseProgram(WebGLProgram* prog) {
-  const FuncScope funcScope(*this, "useProgram");
+  FuncScope funcScope(*this, "useProgram");
   if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
   if (!prog) {
     mCurrentProgram = nullptr;
     mActiveProgramLinkInfo = nullptr;
+    funcScope.mBindFailureGuard = false;
     return;
   }
 
   if (!ValidateObject("prog", *prog)) return;
 
-  if (prog->UseProgram()) {
-    mCurrentProgram = prog;
-    mActiveProgramLinkInfo = mCurrentProgram->LinkInfo();
-  }
+  if (!prog->UseProgram()) return;
+
+  mCurrentProgram = prog;
+  mActiveProgramLinkInfo = mCurrentProgram->LinkInfo();
+
+  funcScope.mBindFailureGuard = false;
 }
 
 void WebGLContext::ValidateProgram(const WebGLProgram& prog) {
   const FuncScope funcScope(*this, "validateProgram");
   if (IsContextLost()) return;
 
-  if (!ValidateObject("prog", prog)) return;
-
   prog.ValidateProgram();
 }
 
-already_AddRefed<WebGLFramebuffer> WebGLContext::CreateFramebuffer() {
+RefPtr<WebGLFramebuffer> WebGLContext::CreateFramebuffer() {
   const FuncScope funcScope(*this, "createFramebuffer");
   if (IsContextLost()) return nullptr;
 
   GLuint fbo = 0;
   gl->fGenFramebuffers(1, &fbo);
 
-  RefPtr<WebGLFramebuffer> globj = new WebGLFramebuffer(this, fbo);
-  return globj.forget();
+  return new WebGLFramebuffer(this, fbo);
 }
 
-already_AddRefed<WebGLRenderbuffer> WebGLContext::CreateRenderbuffer() {
+RefPtr<WebGLRenderbuffer> WebGLContext::CreateRenderbuffer() {
   const FuncScope funcScope(*this, "createRenderbuffer");
   if (IsContextLost()) return nullptr;
 
-  RefPtr<WebGLRenderbuffer> globj = new WebGLRenderbuffer(this);
-  return globj.forget();
+  return new WebGLRenderbuffer(this);
 }
 
 void WebGLContext::Viewport(GLint x, GLint y, GLsizei width, GLsizei height) {
@@ -2076,8 +1395,9 @@
     return;
   }
 
-  width = std::min(width, (GLsizei)mGLMaxViewportDims[0]);
-  height = std::min(height, (GLsizei)mGLMaxViewportDims[1]);
+  const auto& limits = Limits();
+  width = std::min(width, static_cast<GLsizei>(limits.maxViewportDims[0]));
+  height = std::min(height, static_cast<GLsizei>(limits.maxViewportDims[1]));
 
   gl->fViewport(x, y, width, height);
 
@@ -2096,28 +1416,8 @@
   shader.CompileShader();
 }
 
-MaybeWebGLVariant WebGLContext::GetShaderParameter(const WebGLShader& shader,
-                                                   GLenum pname) {
-  const FuncScope funcScope(*this, "getShaderParameter");
-  if (IsContextLost()) return Nothing();
-
-  if (!ValidateObjectAllowDeleted("shader", shader)) return Nothing();
-
-  return shader.GetShaderParameter(pname);
-}
-
-nsString WebGLContext::GetShaderInfoLog(const WebGLShader& shader) {
-  const FuncScope funcScope(*this, "getShaderInfoLog");
-
-  if (IsContextLost()) return EmptyString();
-
-  if (!ValidateObject("shader", shader)) return EmptyString();
-
-  return shader.GetShaderInfoLog();
-}
-
-Maybe<WebGLShaderPrecisionFormat> WebGLContext::GetShaderPrecisionFormat(
-    GLenum shadertype, GLenum precisiontype) {
+Maybe<webgl::ShaderPrecisionFormat> WebGLContext::GetShaderPrecisionFormat(
+    GLenum shadertype, GLenum precisiontype) const {
   const FuncScope funcScope(*this, "getShaderPrecisionFormat");
   if (IsContextLost()) return Nothing();
 
@@ -2155,57 +1455,17 @@
     gl->fGetShaderPrecisionFormat(shadertype, precisiontype, range, &precision);
   }
 
-  return Some(WebGLShaderPrecisionFormat(range[0], range[1], precision));
+  return Some(webgl::ShaderPrecisionFormat{range[0], range[1], precision});
 }
 
-nsString WebGLContext::GetShaderSource(const WebGLShader& shader) {
-  nsString retVoid;
-  retVoid.SetIsVoid(true);
-
-  const FuncScope funcScope(*this, "getShaderSource");
-
-  if (IsContextLost()) return retVoid;
-
-  if (!ValidateObject("shader", shader)) return retVoid;
-
-  return shader.GetShaderSource();
-}
-
-void WebGLContext::ShaderSource(WebGLShader& shader, const nsAString& source) {
+void WebGLContext::ShaderSource(WebGLShader& shader,
+                                const std::string& source) const {
   const FuncScope funcScope(*this, "shaderSource");
   if (IsContextLost()) return;
 
-  if (!ValidateObject("shader", shader)) return;
-
   shader.ShaderSource(source);
 }
 
-void WebGLContext::LoseContext() {
-  const FuncScope funcScope(*this, "loseContext");
-  if (IsContextLost()) return ErrorInvalidOperation("Context is already lost.");
-
-  ForceLoseContext(true);
-}
-
-void WebGLContext::RestoreContext() {
-  const FuncScope funcScope(*this, "restoreContext");
-  if (!IsContextLost()) return ErrorInvalidOperation("Context is not lost.");
-
-  if (!mLastLossWasSimulated) {
-    return ErrorInvalidOperation(
-        "Context loss was not simulated."
-        " Cannot simulate restore.");
-  }
-  // If we're currently lost, and the last loss was simulated, then
-  // we're currently only simulated-lost, allowing us to call
-  // restoreContext().
-
-  if (!mAllowContextRestore)
-    return ErrorInvalidOperation("Context cannot be restored.");
-
-  ForceRestoreContext();
-}
-
 void WebGLContext::BlendColor(GLfloat r, GLfloat g, GLfloat b, GLfloat a) {
   const FuncScope funcScope(*this, "blendColor");
   if (IsContextLost()) return;