# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextValidate.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLContextValidate.cpp
--- a/dom/canvas/WebGLContextValidate.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLContextValidate.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -14,7 +14,6 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_webgl.h"
 #include "nsPrintfCString.h"
-#include "WebGLActiveInfo.h"
 #include "WebGLBuffer.h"
 #include "WebGLContextUtils.h"
 #include "WebGLFramebuffer.h"
@@ -23,7 +22,6 @@
 #include "WebGLSampler.h"
 #include "WebGLShader.h"
 #include "WebGLTexture.h"
-#include "WebGLUniformLocation.h"
 #include "WebGLValidateStrings.h"
 #include "WebGLVertexArray.h"
 #include "WebGLVertexAttribData.h"
@@ -171,25 +169,6 @@
   }
 }
 
-bool WebGLContext::ValidateUniformLocation(
-    const WebGLUniformLocation* const loc) {
-  /* GLES 2.0.25, p38:
-   *   If the value of location is -1, the Uniform* commands will silently
-   *   ignore the data passed in, and the current uniform values will not be
-   *   changed.
-   */
-  if (!loc) return false;
-
-  if (!ValidateObjectAllowDeleted("loc", *loc)) return false;
-
-  if (!mCurrentProgram) {
-    ErrorInvalidOperation("No program is currently bound.");
-    return false;
-  }
-
-  return loc->ValidateForProgram(mCurrentProgram);
-}
-
 bool WebGLContext::ValidateAttribArraySetter(uint32_t setterElemSize,
                                              uint32_t arrayLength) {
   if (IsContextLost()) return false;
@@ -202,66 +181,79 @@
   return true;
 }
 
-bool WebGLContext::ValidateUniformSetter(
-    const WebGLUniformLocation* const loc, const uint8_t setterElemSize,
-    const webgl::AttribBaseType setterType) {
-  if (IsContextLost()) return false;
+// ---------------------
 
-  if (!ValidateUniformLocation(loc)) return false;
-
-  if (!loc->ValidateSizeAndType(setterElemSize, setterType)) return false;
-
-  return true;
-}
+static webgl::Limits MakeLimits(const WebGLContext& webgl) {
+  webgl::Limits limits;
 
-bool WebGLContext::ValidateUniformArraySetter(
-    const WebGLUniformLocation* const loc, const uint8_t setterElemSize,
-    const webgl::AttribBaseType setterType, const uint32_t setterArraySize,
-    uint32_t* const out_numElementsToUpload) {
-  if (IsContextLost()) return false;
+  for (const auto i : IntegerRange(EnumValue(WebGLExtensionID::Max))) {
+    const auto ext = WebGLExtensionID(i);
+    limits.supportedExtensions[ext] = webgl.IsExtensionSupported(ext);
+  }
 
-  if (!ValidateUniformLocation(loc)) return false;
+  gl::GLContext& gl = *webgl.GL();
 
-  if (!loc->ValidateSizeAndType(setterElemSize, setterType)) return false;
-
-  if (!loc->ValidateArrayLength(setterElemSize, setterArraySize)) return false;
+  // -
+  // WebGL 1
 
-  const auto& elemCount = loc->mInfo->mActiveInfo.mElemCount;
-  MOZ_ASSERT(elemCount > loc->mArrayIndex);
-  const uint32_t uniformElemCount = elemCount - loc->mArrayIndex;
-
-  *out_numElementsToUpload =
-      std::min(uniformElemCount, setterArraySize / setterElemSize);
-  return true;
-}
+  // Note: GL_MAX_TEXTURE_UNITS is fixed at 4 for most desktop hardware,
+  // even though the hardware supports much more.  The
+  // GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS value is the accurate value.
+  gl.GetUIntegerv(LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,
+                  &limits.maxTexUnits);
 
-bool WebGLContext::ValidateUniformMatrixArraySetter(
-    const WebGLUniformLocation* const loc, const uint8_t setterCols,
-    const uint8_t setterRows, const webgl::AttribBaseType setterType,
-    const uint32_t setterArraySize, const bool setterTranspose,
-    uint32_t* const out_numElementsToUpload) {
-  const uint8_t setterElemSize = setterCols * setterRows;
-
-  if (IsContextLost()) return false;
+  gl.GetUIntegerv(LOCAL_GL_MAX_TEXTURE_SIZE, &limits.maxTex2dSize);
+  gl.GetUIntegerv(LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE, &limits.maxTexCubeSize);
+  gl.GetUIntegerv(LOCAL_GL_MAX_VERTEX_ATTRIBS, &limits.maxVertexAttribs);
+  gl.GetUIntegerv(LOCAL_GL_MAX_VIEWPORT_DIMS, limits.maxViewportDims.data());
 
-  if (!ValidateUniformLocation(loc)) return false;
-
-  if (!loc->ValidateSizeAndType(setterElemSize, setterType)) return false;
-
-  if (!loc->ValidateArrayLength(setterElemSize, setterArraySize)) return false;
-
-  if (setterTranspose && !IsWebGL2()) {
-    ErrorInvalidValue("`transpose` must be false.");
-    return false;
+  if (!gl.IsCoreProfile()) {
+    gl.fGetFloatv(LOCAL_GL_ALIASED_LINE_WIDTH_RANGE,
+                  limits.lineWidthRange.data());
   }
 
-  const auto& elemCount = loc->mInfo->mActiveInfo.mElemCount;
-  MOZ_ASSERT(elemCount > loc->mArrayIndex);
-  const uint32_t uniformElemCount = elemCount - loc->mArrayIndex;
+  {
+    const GLenum driverPName = gl.IsCoreProfile()
+                                   ? LOCAL_GL_POINT_SIZE_RANGE
+                                   : LOCAL_GL_ALIASED_POINT_SIZE_RANGE;
+    gl.fGetFloatv(driverPName, limits.pointSizeRange.data());
+  }
+
+  if (webgl.IsWebGL2()) {
+    gl.GetUIntegerv(LOCAL_GL_MAX_ARRAY_TEXTURE_LAYERS,
+                    &limits.maxTexArrayLayers);
+    gl.GetUIntegerv(LOCAL_GL_MAX_3D_TEXTURE_SIZE, &limits.maxTex3dSize);
+    gl.GetUIntegerv(LOCAL_GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS,
+                    &limits.maxTransformFeedbackSeparateAttribs);
+    gl.GetUIntegerv(LOCAL_GL_MAX_UNIFORM_BUFFER_BINDINGS,
+                    &limits.maxUniformBufferBindings);
+    gl.GetUIntegerv(LOCAL_GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT,
+                    &limits.uniformBufferOffsetAlignment);
+  }
 
-  *out_numElementsToUpload =
-      std::min(uniformElemCount, setterArraySize / setterElemSize);
-  return true;
+  if (limits.supportedExtensions
+          [WebGLExtensionID::WEBGL_compressed_texture_astc]) {
+    limits.astcHdr = gl.IsExtensionSupported(
+        gl::GLContext::KHR_texture_compression_astc_hdr);
+  }
+
+  if (webgl.IsWebGL2() ||
+      limits.supportedExtensions[WebGLExtensionID::WEBGL_draw_buffers]) {
+    gl.GetUIntegerv(LOCAL_GL_MAX_DRAW_BUFFERS, &limits.maxColorDrawBuffers);
+  }
+
+  if (limits.supportedExtensions[WebGLExtensionID::EXT_disjoint_timer_query]) {
+    gl.fGetQueryiv(LOCAL_GL_TIME_ELAPSED_EXT, LOCAL_GL_QUERY_COUNTER_BITS,
+                   (int32_t*)&limits.queryCounterBitsTimeElapsed);
+    gl.fGetQueryiv(LOCAL_GL_TIMESTAMP_EXT, LOCAL_GL_QUERY_COUNTER_BITS,
+                   (int32_t*)&limits.queryCounterBitsTimestamp);
+  }
+
+  if (limits.supportedExtensions[WebGLExtensionID::OVR_multiview2]) {
+    gl.GetUIntegerv(LOCAL_GL_MAX_VIEWS_OVR, &limits.maxMultiviewLayers);
+  }
+
+  return limits;
 }
 
 bool WebGLContext::InitAndValidateGL(FailureReason* const out_failReason) {
@@ -287,7 +279,6 @@
     return false;
   }
 
-  mDisableExtensions = StaticPrefs::webgl_disable_extensions();
   mLoseContextOnMemoryPressure =
       StaticPrefs::webgl_lose_context_on_memory_pressure();
   mCanLoseContextInForeground =
@@ -364,57 +355,36 @@
 
   mBoundDrawFramebuffer = nullptr;
   mBoundReadFramebuffer = nullptr;
-  mBoundRenderbuffer = nullptr;
 
-  gl->GetUIntegerv(LOCAL_GL_MAX_VERTEX_ATTRIBS, &mGLMaxVertexAttribs);
+  // -----------------------
+
+  auto limits = MakeLimits(*this);
 
-  if (mGLMaxVertexAttribs < 8) {
+  // -
+
+  if (limits.maxVertexAttribs < 8) {
     const nsPrintfCString reason("GL_MAX_VERTEX_ATTRIBS: %d is < 8!",
-                                 mGLMaxVertexAttribs);
+                                 limits.maxVertexAttribs);
     *out_failReason = {"FEATURE_FAILURE_WEBGL_V_ATRB", reason};
     return false;
   }
 
-  // Note: GL_MAX_TEXTURE_UNITS is fixed at 4 for most desktop hardware,
-  // even though the hardware supports much more.  The
-  // GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS value is the accurate value.
-  mGLMaxCombinedTextureImageUnits =
-      gl->GetIntAs<GLuint>(LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);
-  mGLMaxTextureUnits = mGLMaxCombinedTextureImageUnits;
-
-  if (mGLMaxCombinedTextureImageUnits < 8) {
+  if (limits.maxTexUnits < 8) {
     const nsPrintfCString reason(
-        "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: %u is < 8!", mGLMaxTextureUnits);
+        "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: %u is < 8!", limits.maxTexUnits);
     *out_failReason = {"FEATURE_FAILURE_WEBGL_T_UNIT", reason};
     return false;
   }
 
-  mBound2DTextures.SetLength(mGLMaxTextureUnits);
-  mBoundCubeMapTextures.SetLength(mGLMaxTextureUnits);
-  mBound3DTextures.SetLength(mGLMaxTextureUnits);
-  mBound2DArrayTextures.SetLength(mGLMaxTextureUnits);
-  mBoundSamplers.SetLength(mGLMaxTextureUnits);
-
-  gl->fGetIntegerv(LOCAL_GL_MAX_VIEWPORT_DIMS, (GLint*)mGLMaxViewportDims);
+  mBound2DTextures.SetLength(limits.maxTexUnits);
+  mBoundCubeMapTextures.SetLength(limits.maxTexUnits);
+  mBound3DTextures.SetLength(limits.maxTexUnits);
+  mBound2DArrayTextures.SetLength(limits.maxTexUnits);
+  mBoundSamplers.SetLength(limits.maxTexUnits);
 
   ////////////////
 
-  gl->fGetIntegerv(LOCAL_GL_MAX_TEXTURE_SIZE, (GLint*)&mGLMaxTextureSize);
-  gl->fGetIntegerv(LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE,
-                   (GLint*)&mGLMaxCubeMapTextureSize);
-  gl->fGetIntegerv(LOCAL_GL_MAX_RENDERBUFFER_SIZE,
-                   (GLint*)&mGLMaxRenderbufferSize);
-
-  if (!gl->GetPotentialInteger(LOCAL_GL_MAX_3D_TEXTURE_SIZE,
-                               (GLint*)&mGLMax3DTextureSize))
-    mGLMax3DTextureSize = 0;
-  if (!gl->GetPotentialInteger(LOCAL_GL_MAX_ARRAY_TEXTURE_LAYERS,
-                               (GLint*)&mGLMaxArrayTextureLayers))
-    mGLMaxArrayTextureLayers = 0;
-
-  (void)gl->GetPotentialInteger(LOCAL_GL_MAX_VIEWS_OVR,
-                                (GLint*)&mGLMaxMultiviewViews);
-
+  gl->GetUIntegerv(LOCAL_GL_MAX_RENDERBUFFER_SIZE, &mGLMaxRenderbufferSize);
   gl->GetUIntegerv(LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS,
                    &mGLMaxFragmentTextureImageUnits);
   gl->GetUIntegerv(LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS,
@@ -422,15 +392,6 @@
 
   ////////////////
 
-  mGLMaxColorAttachments = 1;
-  mGLMaxDrawBuffers = 1;
-
-  if (IsWebGL2()) {
-    UpdateMaxDrawBuffers();
-  }
-
-  ////////////////
-
   if (gl->IsGLES()) {
     mGLMaxFragmentUniformVectors =
         gl->GetIntAs<uint32_t>(LOCAL_GL_MAX_FRAGMENT_UNIFORM_VECTORS);
@@ -467,20 +428,6 @@
 
   ////////////////
 
-  if (gl->IsCoreProfile()) {
-    mGLAliasedLineWidthRange[0] = 1.0f;
-    mGLAliasedLineWidthRange[1] = 1.0f;
-  } else {
-    gl->fGetFloatv(LOCAL_GL_ALIASED_LINE_WIDTH_RANGE, mGLAliasedLineWidthRange);
-  }
-
-  const GLenum driverPName = gl->IsCoreProfile()
-                                 ? LOCAL_GL_POINT_SIZE_RANGE
-                                 : LOCAL_GL_ALIASED_POINT_SIZE_RANGE;
-  gl->fGetFloatv(driverPName, mGLAliasedPointSizeRange);
-
-  ////////////////
-
   if (StaticPrefs::webgl_min_capability_mode()) {
     bool ok = true;
 
@@ -488,24 +435,22 @@
                       kMinMaxVertexTextureImageUnits);
     ok &= RestrictCap(&mGLMaxFragmentTextureImageUnits,
                       kMinMaxFragmentTextureImageUnits);
-    ok &= RestrictCap(&mGLMaxCombinedTextureImageUnits,
-                      kMinMaxCombinedTextureImageUnits);
+    ok &= RestrictCap(&limits.maxTexUnits, kMinMaxCombinedTextureImageUnits);
 
-    ok &= RestrictCap(&mGLMaxVertexAttribs, kMinMaxVertexAttribs);
+    ok &= RestrictCap(&limits.maxVertexAttribs, kMinMaxVertexAttribs);
     ok &= RestrictCap(&mGLMaxVertexUniformVectors, kMinMaxVertexUniformVectors);
     ok &= RestrictCap(&mGLMaxFragmentUniformVectors,
                       kMinMaxFragmentUniformVectors);
     ok &= RestrictCap(&mGLMaxVertexOutputVectors, kMinMaxVaryingVectors);
     ok &= RestrictCap(&mGLMaxFragmentInputVectors, kMinMaxVaryingVectors);
 
-    ok &= RestrictCap(&mGLMaxColorAttachments, kMinMaxColorAttachments);
-    ok &= RestrictCap(&mGLMaxDrawBuffers, kMinMaxDrawBuffers);
+    ok &= RestrictCap(&limits.maxColorDrawBuffers, kMinMaxDrawBuffers);
 
-    ok &= RestrictCap(&mGLMaxTextureSize, kMinMaxTextureSize);
-    ok &= RestrictCap(&mGLMaxCubeMapTextureSize, kMinMaxCubeMapTextureSize);
-    ok &= RestrictCap(&mGLMax3DTextureSize, kMinMax3DTextureSize);
+    ok &= RestrictCap(&limits.maxTex2dSize, kMinMaxTextureSize);
+    ok &= RestrictCap(&limits.maxTexCubeSize, kMinMaxCubeMapTextureSize);
+    ok &= RestrictCap(&limits.maxTex3dSize, kMinMax3DTextureSize);
 
-    ok &= RestrictCap(&mGLMaxArrayTextureLayers, kMinMaxArrayTextureLayers);
+    ok &= RestrictCap(&limits.maxTexArrayLayers, kMinMaxArrayTextureLayers);
     ok &= RestrictCap(&mGLMaxRenderbufferSize, kMinMaxRenderbufferSize);
 
     if (!ok) {
@@ -514,21 +459,20 @@
     }
 
     mDisableFragHighP = true;
-  } else if (ShouldResistFingerprinting()) {
+  } else if (mResistFingerprinting) {
     bool ok = true;
 
-    ok &= RestrictCap(&mGLMaxTextureSize, kCommonMaxTextureSize);
-    ok &= RestrictCap(&mGLMaxCubeMapTextureSize, kCommonMaxCubeMapTextureSize);
+    ok &= RestrictCap(&limits.maxTex2dSize, kCommonMaxTextureSize);
+    ok &= RestrictCap(&limits.maxTexCubeSize, kCommonMaxCubeMapTextureSize);
     ok &= RestrictCap(&mGLMaxRenderbufferSize, kCommonMaxRenderbufferSize);
 
     ok &= RestrictCap(&mGLMaxVertexTextureImageUnits,
                       kCommonMaxVertexTextureImageUnits);
     ok &= RestrictCap(&mGLMaxFragmentTextureImageUnits,
                       kCommonMaxFragmentTextureImageUnits);
-    ok &= RestrictCap(&mGLMaxCombinedTextureImageUnits,
-                      kCommonMaxCombinedTextureImageUnits);
+    ok &= RestrictCap(&limits.maxTexUnits, kCommonMaxCombinedTextureImageUnits);
 
-    ok &= RestrictCap(&mGLMaxVertexAttribs, kCommonMaxVertexAttribs);
+    ok &= RestrictCap(&limits.maxVertexAttribs, kCommonMaxVertexAttribs);
     ok &= RestrictCap(&mGLMaxVertexUniformVectors,
                       kCommonMaxVertexUniformVectors);
     ok &= RestrictCap(&mGLMaxFragmentUniformVectors,
@@ -536,17 +480,23 @@
     ok &= RestrictCap(&mGLMaxVertexOutputVectors, kCommonMaxVaryingVectors);
     ok &= RestrictCap(&mGLMaxFragmentInputVectors, kCommonMaxVaryingVectors);
 
-    ok &= RestrictCap(&mGLAliasedLineWidthRange[0],
-                      kCommonAliasedLineWidthRangeMin);
-    ok &= RestrictCap(&mGLAliasedLineWidthRange[1],
-                      kCommonAliasedLineWidthRangeMax);
-    ok &= RestrictCap(&mGLAliasedPointSizeRange[0],
-                      kCommonAliasedPointSizeRangeMin);
-    ok &= RestrictCap(&mGLAliasedPointSizeRange[1],
-                      kCommonAliasedPointSizeRangeMax);
+    if (limits.lineWidthRange[0] <= kCommonAliasedLineWidthRangeMin) {
+      limits.lineWidthRange[0] = kCommonAliasedLineWidthRangeMin;
+    } else {
+      ok = false;
+    }
+    if (limits.pointSizeRange[0] <= kCommonAliasedPointSizeRangeMin) {
+      limits.pointSizeRange[0] = kCommonAliasedPointSizeRangeMin;
+    } else {
+      ok = false;
+    }
 
-    ok &= RestrictCap(&mGLMaxViewportDims[0], kCommonMaxViewportDims);
-    ok &= RestrictCap(&mGLMaxViewportDims[1], kCommonMaxViewportDims);
+    ok &=
+        RestrictCap(&limits.lineWidthRange[1], kCommonAliasedLineWidthRangeMax);
+    ok &=
+        RestrictCap(&limits.pointSizeRange[1], kCommonAliasedPointSizeRangeMax);
+    ok &= RestrictCap(&limits.maxViewportDims[0], kCommonMaxViewportDims);
+    ok &= RestrictCap(&limits.maxViewportDims[1], kCommonMaxViewportDims);
 
     if (!ok) {
       GenerateWarning(
@@ -555,6 +505,8 @@
     }
   }
 
+  mLimits = Some(limits);
+
   ////////////////
 
   if (gl->IsCompatibilityProfile()) {
@@ -609,7 +561,7 @@
     return false;
   }
 
-  if (!gl->IsSupported(GLFeature::vertex_array_object)) {
+  if (!gl->IsSupported(gl::GLFeature::vertex_array_object)) {
     *out_failReason = {"FEATURE_FAILURE_WEBGL_VAOS",
                        "Requires vertex_array_object."};
     return false;
@@ -625,7 +577,7 @@
   // vertex array object (the name zero) is also deprecated. [...]"
   mDefaultVertexArray = WebGLVertexArray::Create(this);
   mDefaultVertexArray->BindVertexArray();
-  mDefaultVertexArray->mAttribs.resize(mGLMaxVertexAttribs);
+  mDefaultVertexArray->mAttribs.resize(limits.maxVertexAttribs);
 
   mPixelStore.mFlipY = false;
   mPixelStore.mPremultiplyAlpha = false;
@@ -646,7 +598,7 @@
 
   mPrimRestartTypeBytes = 0;
 
-  mGenericVertexAttribTypes.assign(mGLMaxVertexAttribs,
+  mGenericVertexAttribTypes.assign(limits.maxVertexAttribs,
                                    webgl::AttribBaseType::Float);
   mGenericVertexAttribTypeInvalidator.InvalidateCaches();
 
@@ -670,6 +622,10 @@
       break;
   }
 
+  for (auto& cur : mExtensions) {
+    cur = {};
+  }
+
   return true;
 }
 