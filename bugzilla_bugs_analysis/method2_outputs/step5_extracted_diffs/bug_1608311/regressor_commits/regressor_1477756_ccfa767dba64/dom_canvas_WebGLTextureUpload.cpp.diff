# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLTextureUpload.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLTextureUpload.cpp
--- a/dom/canvas/WebGLTextureUpload.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLTextureUpload.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -31,219 +31,93 @@
 
 namespace mozilla {
 
-/* This file handles:
- * TexStorage2D(texTarget, levels, internalFormat, width, height)
- * TexStorage3D(texTarget, levels, intenralFormat, width, height, depth)
- *
- * TexImage2D(texImageTarget, level, internalFormat, width, height, border,
- *            unpackFormat, unpackType, data)
- * TexImage3D(texImageTarget, level, internalFormat, width, height, depth,
- *            border, unpackFormat, unpackType, data)
- * TexSubImage2D(texImageTarget, level, xOffset, yOffset, width, height,
- *               unpackFormat, unpackType, data)
- * TexSubImage3D(texImageTarget, level, xOffset, yOffset, zOffset, width,
- *               height, depth, unpackFormat, unpackType, data)
- *
- * CompressedTexImage2D(texImageTarget, level, internalFormat, width, height,
- *                      border, imageSize, data)
- * CompressedTexImage3D(texImageTarget, level, internalFormat, width, height,
- *                      depth, border, imageSize, data)
- * CompressedTexSubImage2D(texImageTarget, level, xOffset, yOffset, width,
- *                         height, sizedUnpackFormat, imageSize, data)
- * CompressedTexSubImage3D(texImageTarget, level, xOffset, yOffset, zOffset,
- *                         width, height, depth, sizedUnpackFormat, imageSize,
- *                         data)
- *
- * CopyTexImage2D(texImageTarget, level, internalFormat, x, y, width, height,
- *                border)
- * CopyTexImage3D - "Because the framebuffer is inhererntly two-dimensional,
- *                   there is no CopyTexImage3D command."
- * CopyTexSubImage2D(texImageTarget, level, xOffset, yOffset, x, y, width,
- *                   height)
- * CopyTexSubImage3D(texImageTarget, level, xOffset, yOffset, zOffset, x, y,
- *                   width, height)
- */
-
-bool ClientWebGLContext::ValidateExtents(GLsizei width, GLsizei height,
-                                         GLsizei depth, GLint border,
-                                         uint32_t* const out_width,
-                                         uint32_t* const out_height,
-                                         uint32_t* const out_depth) {
-  // Check border
-  if (border != 0) {
-    EnqueueErrorInvalidValue("`border` must be 0.");
-    return false;
-  }
-
-  if (width < 0 || height < 0 || depth < 0) {
-    /* GL ES Version 2.0.25 - 3.7.1 Texture Image Specification
-     *   "If wt and ht are the specified image width and height,
-     *   and if either wt or ht are less than zero, then the error
-     *   INVALID_VALUE is generated."
-     */
-    EnqueueErrorInvalidValue("`width`/`height`/`depth` must be >= 0.");
-    return false;
-  }
-
-  *out_width = width;
-  *out_height = height;
-  *out_depth = depth;
-  return true;
-}
-
-////////////////////////////////////////
-
-static bool ValidateUnpackInfo(WebGLContext* webgl,
-                               const webgl::PackingInfo& pi) {
-  if (!webgl->mFormatUsage->AreUnpackEnumsValid(pi.format, pi.type)) {
-    webgl->ErrorInvalidEnum("Invalid unpack format/type: 0x%04x/0x%04x",
-                            pi.format, pi.type);
-    return false;
-  }
-
-  return true;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-UniquePtr<webgl::TexUnpackBlob> WebGLContext::ToTexUnpackBytes(
-    const WebGLTexImageData& imageData) {
-  MOZ_ASSERT_UNREACHABLE("TODO: Texure Upload Image fast path");
-  return nullptr;
-  //  return MakeUnique<webgl::TexUnpackImage>(this, target, rowLength,
-  //  imageheight,
-  //                                           width, height, depth,
-  //                                           srcAlphaType);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-UniquePtr<webgl::TexUnpackBytes> WebGLContext::ToTexUnpackBytes(
-    WebGLTexPboOffset& aPbo) {
-  if (aPbo.mPboOffset < 0) {
-    ErrorInvalidValue("offset cannot be negative.");
-    return nullptr;
-  }
-
-  const auto& buffer = ValidateBufferSelection(LOCAL_GL_PIXEL_UNPACK_BUFFER);
-  if (!buffer) return nullptr;
-
-  size_t availBufferBytes = buffer->ByteLength();
-  if (size_t(aPbo.mPboOffset) > availBufferBytes) {
-    ErrorInvalidOperation("Offset is passed end of buffer.");
-    return nullptr;
-  }
-  availBufferBytes -= aPbo.mPboOffset;
-  if (aPbo.mHasExpectedImageSize) {
-    if (aPbo.mExpectedImageSize < 0) {
-      ErrorInvalidValue("ImageSize can't be less than 0.");
-      return nullptr;
-    }
-    if (size_t(aPbo.mExpectedImageSize) != availBufferBytes) {
-      ErrorInvalidOperation(
-          "ImageSize doesn't match the required upload byte size.");
-      return nullptr;
-    }
-    availBufferBytes = size_t(aPbo.mExpectedImageSize);
-  }
-
-  const bool isClientData = false;
-  const auto ptr = (const uint8_t*)aPbo.mPboOffset;
-  UniquePtr<webgl::TexUnpackBytes> texUnpackBlob =
-      MakeUnique<webgl::TexUnpackBytes>(GetPixelStore(), aPbo.mTarget,
-                                        aPbo.mWidth, aPbo.mHeight, aPbo.mDepth,
-                                        isClientData, ptr, availBufferBytes);
-  return texUnpackBlob;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-static MaybeWebGLTexUnpackVariant ClientFromView(
-    ClientWebGLContext* webgl, TexImageTarget target, uint32_t width,
-    uint32_t height, uint32_t depth, const dom::ArrayBufferView* view,
-    GLuint viewElemOffset, GLuint viewElemLengthOverride,
-    const GLenum errorVal) {
+static UniquePtr<webgl::TexUnpackBytes> FromView(
+    const WebGLContext* webgl, TexImageTarget target, const uvec3& size,
+    const dom::ArrayBufferView* view, GLuint viewElemOffset,
+    GLuint viewElemLengthOverride) {
   const bool isClientData = true;
   const uint8_t* bytes = nullptr;
   size_t availByteCount = 0;
   if (view) {
-    if (!webgl->ValidateArrayBufferView(
-            *view, viewElemOffset, viewElemLengthOverride, errorVal,
-            const_cast<uint8_t**>(&bytes), &availByteCount)) {
-      return Nothing();
+    const auto range =
+        GetRangeFromView(*view, viewElemOffset, viewElemLengthOverride);
+    if (!range) {
+      webgl->GenerateError(LOCAL_GL_INVALID_VALUE, "`source` too small.");
+      return nullptr;
     }
+    bytes = range->begin().get();
+    availByteCount = range->length();
   }
-
-  UniquePtr<webgl::TexUnpackBytes> texUnpackBlob =
-      MakeUnique<webgl::TexUnpackBytes>(webgl->GetPixelStore(), target, width,
-                                        height, depth, isClientData, bytes,
-                                        availByteCount);
-  return AsSomeVariant(std::move(texUnpackBlob));
+  return MakeUnique<webgl::TexUnpackBytes>(webgl, target, size.x, size.y,
+                                           size.z, isClientData, bytes,
+                                           availByteCount);
 }
 
-static MaybeWebGLTexUnpackVariant ClientFromPboOffset(
-    ClientWebGLContext* webgl, TexImageTarget target, uint32_t width,
-    uint32_t height, uint32_t depth, WebGLsizeiptr pboOffset,
-    const Maybe<GLsizei>& expectedImageSize) {
-  if (pboOffset < 0) {
-    webgl->EnqueueErrorInvalidValue("offset cannot be negative.");
-    return Nothing();
+static UniquePtr<webgl::TexUnpackBytes> FromPboOffset(const WebGLContext* webgl,
+                                                      TexImageTarget target,
+                                                      const uvec3& size,
+                                                      WebGLintptr pboOffset) {
+  if (!webgl->ValidateNonNegative("offset", pboOffset)) return nullptr;
+
+  const auto& buffer =
+      webgl->ValidateBufferSelection(LOCAL_GL_PIXEL_UNPACK_BUFFER);
+  if (!buffer) return nullptr;
+
+  size_t availBufferBytes = buffer->ByteLength();
+  if (size_t(pboOffset) > availBufferBytes) {
+    webgl->ErrorInvalidOperation("Offset is passed end of buffer.");
+    return nullptr;
   }
-
-  GLsizei imgSize = expectedImageSize ? expectedImageSize.ref()
-                                      : std::numeric_limits<int>::min();
-
-  return AsSomeVariant(
-      WebGLTexPboOffset{target, width, height, depth, pboOffset,
-                        static_cast<bool>(expectedImageSize), imgSize});
+  availBufferBytes -= pboOffset;
+  const bool isClientData = false;
+  const auto ptr = (const uint8_t*)pboOffset;
+  return MakeUnique<webgl::TexUnpackBytes>(webgl, target, size.x, size.y,
+                                           size.z, isClientData, ptr,
+                                           availBufferBytes);
 }
 
-static MaybeWebGLTexUnpackVariant ClientFromImageBitmap(
-    const WebGLPixelStore& pixelStore, TexImageTarget target, uint32_t width,
-    uint32_t height, uint32_t depth, const dom::ImageBitmap& imageBitmap,
-    ErrorResult* aRv) {
+static UniquePtr<webgl::TexUnpackBlob> FromImageBitmap(
+    const WebGLContext* webgl, TexImageTarget target, uvec3 size,
+    const dom::ImageBitmap& imageBitmap, ErrorResult* aRv) {
   if (imageBitmap.IsWriteOnly()) {
     aRv->Throw(NS_ERROR_DOM_SECURITY_ERR);
-    return Nothing();
+    return nullptr;
   }
 
   UniquePtr<dom::ImageBitmapCloneData> cloneData = imageBitmap.ToCloneData();
   if (!cloneData) {
-    return Nothing();
+    return nullptr;
   }
 
   const RefPtr<gfx::DataSourceSurface> surf = cloneData->mSurface;
 
-  if (!width) {
-    width = surf->GetSize().width;
+  if (!size.x) {
+    size.x = surf->GetSize().width;
   }
 
-  if (!height) {
-    height = surf->GetSize().height;
+  if (!size.y) {
+    size.y = surf->GetSize().height;
   }
 
   // WhatWG "HTML Living Standard" (30 October 2015):
   // "The getImageData(sx, sy, sw, sh) method [...] Pixels must be returned as
   // non-premultiplied alpha values."
-  UniquePtr<webgl::TexUnpackSurface> texUnpackSurf =
-      MakeUnique<webgl::TexUnpackSurface>(pixelStore, target, width, height,
-                                          depth, surf, cloneData->mAlphaType);
-  return AsSomeVariant(std::move(texUnpackSurf));
+  return MakeUnique<webgl::TexUnpackSurface>(
+      webgl, target, size.x, size.y, size.z, surf, cloneData->mAlphaType);
 }
 
-static MaybeWebGLTexUnpackVariant ClientFromImageData(
-    ClientWebGLContext* webgl, TexImageTarget target, uint32_t width,
-    uint32_t height, uint32_t depth, const dom::ImageData& imageData) {
-  dom::Uint8ClampedArray scopedArr;
-  DebugOnly<bool> inited = scopedArr.Init(imageData.GetDataObject());
+static UniquePtr<webgl::TexUnpackBlob> FromImageData(
+    const WebGLContext* webgl, TexImageTarget target, uvec3 size,
+    const dom::ImageData& imageData, dom::Uint8ClampedArray* scopedArr) {
+  DebugOnly<bool> inited = scopedArr->Init(imageData.GetDataObject());
   MOZ_ASSERT(inited);
-  scopedArr.ComputeLengthAndData();
 
-  const DebugOnly<size_t> dataSize = scopedArr.Length();
-  const void* const data = scopedArr.Data();
+  scopedArr->ComputeLengthAndData();
+  const DebugOnly<size_t> dataSize = scopedArr->Length();
+  const void* const data = scopedArr->Data();
 
-  const gfx::IntSize size(imageData.Width(), imageData.Height());
-  const size_t stride = size.width * 4;
+  const gfx::IntSize imageSize(imageData.Width(), imageData.Height());
+  const size_t stride = imageSize.width * 4;
   const gfx::SurfaceFormat surfFormat = gfx::SurfaceFormat::R8G8B8A8;
 
   // WhatWG "HTML Living Standard" (30 October 2015):
@@ -251,45 +125,43 @@
   // non-premultiplied alpha values."
   const auto alphaType = gfxAlphaType::NonPremult;
 
-  MOZ_ASSERT(dataSize == stride * size.height);
+  MOZ_ASSERT(dataSize == stride * imageSize.height);
 
   uint8_t* wrappableData = (uint8_t*)data;
 
   const RefPtr<gfx::DataSourceSurface> surf =
-      gfx::Factory::CreateWrappingDataSourceSurface(wrappableData, stride, size,
-                                                    surfFormat);
+      gfx::Factory::CreateWrappingDataSourceSurface(wrappableData, stride,
+                                                    imageSize, surfFormat);
   if (!surf) {
-    webgl->EnqueueErrorOutOfMemory("OOM in FromImageData.");
-    return Nothing();
+    webgl->ErrorOutOfMemory("OOM in FromImageData.");
+    return nullptr;
   }
 
   ////
 
-  if (!width) {
-    width = imageData.Width();
+  if (!size.x) {
+    size.x = imageData.Width();
   }
 
-  if (!height) {
-    height = imageData.Height();
+  if (!size.y) {
+    size.y = imageData.Height();
   }
 
   ////
 
-  UniquePtr<webgl::TexUnpackSurface> texUnpackBlob =
-      MakeUnique<webgl::TexUnpackSurface>(webgl->GetPixelStore(), target, width,
-                                          height, depth, surf, alphaType);
-  return AsSomeVariant(std::move(texUnpackBlob));
+  return MakeUnique<webgl::TexUnpackSurface>(webgl, target, size.x, size.y,
+                                             size.z, surf, alphaType);
 }
 
-MaybeWebGLTexUnpackVariant ClientWebGLContext::ClientFromDomElem(
-    TexImageTarget target, uint32_t width, uint32_t height, uint32_t depth,
-    const dom::Element& elem, ErrorResult* const out_error) {
+UniquePtr<webgl::TexUnpackBlob> WebGLContext::FromDomElem(
+    const dom::HTMLCanvasElement& canvas, TexImageTarget target, uvec3 size,
+    const dom::Element& elem, ErrorResult* const out_error) const {
   if (elem.IsHTMLElement(nsGkAtoms::canvas)) {
     const dom::HTMLCanvasElement* canvas =
         static_cast<const dom::HTMLCanvasElement*>(&elem);
     if (canvas->IsWriteOnly()) {
       out_error->Throw(NS_ERROR_DOM_SECURITY_ERR);
-      return Nothing();
+      return nullptr;
     }
   }
 
@@ -322,10 +194,6 @@
   }
 
   RefPtr<gfx::DataSourceSurface> dataSurf;
-
-  // TODO: DLP: I have abandoned the fast path -- I always use DataSourceSurface
-  layersImage = nullptr;
-
   if (!layersImage && sfer.GetSourceSurface()) {
     const auto surf = sfer.GetSourceSurface();
     elemWidth = surf->GetSize().width;
@@ -337,23 +205,20 @@
 
   //////
 
-  if (!width) {
-    width = elemWidth;
+  if (!size.x) {
+    size.x = elemWidth;
   }
 
-  if (!height) {
-    height = elemHeight;
+  if (!size.y) {
+    size.y = elemHeight;
   }
 
   ////
 
   if (!layersImage && !dataSurf) {
     const bool isClientData = true;
-    UniquePtr<webgl::TexUnpackBytes> texUnpackBlob =
-        MakeUnique<webgl::TexUnpackBytes>(GetPixelStore(), target, width,
-                                          height, depth, isClientData, nullptr,
-                                          0);
-    return AsSomeVariant(std::move(texUnpackBlob));
+    return MakeUnique<webgl::TexUnpackBytes>(this, target, size.x, size.y,
+                                             size.z, isClientData, nullptr, 0);
   }
 
   //////
@@ -364,12 +229,12 @@
 
   if (!sfer.mCORSUsed) {
     auto& srcPrincipal = sfer.mPrincipal;
-    nsIPrincipal* dstPrincipal = GetCanvas()->NodePrincipal();
+    nsIPrincipal* dstPrincipal = canvas.NodePrincipal();
 
     if (!dstPrincipal->Subsumes(srcPrincipal)) {
-      EnqueueWarning(nsCString("Cross-origin elements require CORS."));
+      GenerateWarning("Cross-origin elements require CORS.");
       out_error->Throw(NS_ERROR_DOM_SECURITY_ERR);
-      return Nothing();
+      return nullptr;
     }
   }
 
@@ -377,88 +242,63 @@
     // mIsWriteOnly defaults to true, and so will be true even if SFE merely
     // failed. Thus we must test mIsWriteOnly after successfully retrieving an
     // Image or SourceSurface.
-    EnqueueWarning(
-        nsCString("Element is write-only, thus cannot be uploaded."));
+    GenerateWarning("Element is write-only, thus cannot be uploaded.");
     out_error->Throw(NS_ERROR_DOM_SECURITY_ERR);
-    return Nothing();
+    return nullptr;
   }
 
   //////
   // Ok, we're good!
 
   if (layersImage) {
-    // TODO:
-    //    WebGLTexImageData texImageData{
-    //        target, static_cast<int32_t>(layersImage->GetSize().width),
-    //        width,  height,
-    //        depth,  sfer.mAlphaType};
-    //    return AsSomeVariant(std::move(texImageData));
-    return Nothing();
+    return MakeUnique<webgl::TexUnpackImage>(
+        this, target, size.x, size.y, size.z, layersImage, sfer.mAlphaType);
   }
 
   MOZ_ASSERT(dataSurf);
-  UniquePtr<webgl::TexUnpackSurface> texUnpackSurf =
-      MakeUnique<webgl::TexUnpackSurface>(GetPixelStore(), target, width,
-                                          height, depth, dataSurf,
-                                          sfer.mAlphaType);
-  if ((!texUnpackSurf) || (!texUnpackSurf->mData)) {
-    EnqueueErrorOutOfMemory("Failed to map source surface for upload.");
-    return Nothing();
-  }
-  return AsSomeVariant(std::move(texUnpackSurf));
+  return MakeUnique<webgl::TexUnpackSurface>(this, target, size.x, size.y,
+                                             size.z, dataSurf, sfer.mAlphaType);
 }
 
 ////////////////////////////////////////
 
-////////////////////////////////////////////////////////////////////////////////
-
-static bool ValidateTexOrSubImage(WebGLContext* webgl,
-                                  const webgl::PackingInfo& pi,
-                                  UniquePtr<webgl::TexUnpackBlob>& src) {
-  return ValidateUnpackInfo(webgl, pi) && src && src->Validate(webgl, pi);
-}
+UniquePtr<webgl::TexUnpackBlob> WebGLContext::From(
+    const dom::HTMLCanvasElement& canvas, TexImageTarget target,
+    const uvec3& size, const TexImageSource& src,
+    dom::Uint8ClampedArray* const scopedArr) const {
+  if (src.mPboOffset) {
+    return FromPboOffset(this, target, size, *(src.mPboOffset));
+  }
 
-void WebGLTexture::TexImage(TexImageTarget target, GLint level,
-                            GLenum internalFormat, GLsizei width,
-                            GLsizei height, GLsizei depth, GLint border,
-                            const webgl::PackingInfo& pi,
-                            UniquePtr<webgl::TexUnpackBlob>&& src) {
-  if (!ValidateTexOrSubImage(mContext, pi, src)) {
-    return;
+  if (mBoundPixelUnpackBuffer) {
+    ErrorInvalidOperation("PIXEL_UNPACK_BUFFER must be null.");
+    return nullptr;
   }
 
-  TexImage(target, level, internalFormat, pi, std::move(src));
-}
-
-void WebGLTexture::TexSubImage(TexImageTarget target, GLint level,
-                               GLint xOffset, GLint yOffset, GLint zOffset,
-                               GLsizei width, GLsizei height, GLsizei depth,
-                               const webgl::PackingInfo& pi,
-                               UniquePtr<webgl::TexUnpackBlob>&& src) {
-  if (!ValidateTexOrSubImage(mContext, pi, src)) {
-    return;
+  if (src.mImageBitmap) {
+    return FromImageBitmap(this, target, size, *(src.mImageBitmap),
+                           src.mOut_error);
   }
 
-  if (!src->HasData()) {
-    mContext->ErrorInvalidValue("Source must not be null.");
-    return;
+  if (src.mImageData) {
+    return FromImageData(this, target, size, *(src.mImageData), scopedArr);
   }
 
-  TexSubImage(target, level, xOffset, yOffset, zOffset, pi, std::move(src));
+  if (src.mDomElem) {
+    return FromDomElem(canvas, target, size, *(src.mDomElem), src.mOut_error);
+  }
+
+  return FromView(this, target, size, src.mView, src.mViewElemOffset,
+                  src.mViewElemLengthOverride);
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////////
 
 static bool ValidateTexImage(WebGLContext* webgl, WebGLTexture* texture,
-                             TexImageTarget target, GLint level,
+                             TexImageTarget target, uint32_t level,
                              webgl::ImageInfo** const out_imageInfo) {
   // Check level
-  if (level < 0) {
-    webgl->ErrorInvalidValue("`level` must be >= 0.");
-    return false;
-  }
-
   if (level >= WebGLTexture::kMaxLevelCount) {
     webgl->ErrorInvalidValue("`level` is too large.");
     return false;
@@ -471,8 +311,8 @@
 
 // For *TexImage*
 bool WebGLTexture::ValidateTexImageSpecification(
-    TexImageTarget target, GLint rawLevel, uint32_t width, uint32_t height,
-    uint32_t depth, webgl::ImageInfo** const out_imageInfo) {
+    TexImageTarget target, uint32_t level, const uvec3& size,
+    webgl::ImageInfo** const out_imageInfo) {
   if (mImmutable) {
     mContext->ErrorInvalidOperation("Specified texture is immutable.");
     return false;
@@ -480,11 +320,10 @@
 
   // Do this early to validate `level`.
   webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImage(mContext, this, target, rawLevel, &imageInfo))
+  if (!ValidateTexImage(mContext, this, target, level, &imageInfo))
     return false;
-  const uint32_t level(rawLevel);
 
-  if (mTarget == LOCAL_GL_TEXTURE_CUBE_MAP && width != height) {
+  if (mTarget == LOCAL_GL_TEXTURE_CUBE_MAP && size.x != size.y) {
     mContext->ErrorInvalidValue("Cube map images must be square.");
     return false;
   }
@@ -496,45 +335,46 @@
    * not* result in an INVALID_VALUE, or possibly GL_OOM.
    *
    * However, we have needed to set our maximums lower in the past to prevent
-   * resource corruption. Therefore we have mGLMaxTextureSize, which is neither
-   * necessarily lower nor higher than MAX_TEXTURE_SIZE.
+   * resource corruption. Therefore we have limits.maxTex2dSize, which is
+   * neither necessarily lower nor higher than MAX_TEXTURE_SIZE.
    *
-   * Note that mGLMaxTextureSize must be >= than the advertized
+   * Note that limits.maxTex2dSize must be >= than the advertized
    * MAX_TEXTURE_SIZE. For simplicity, we advertize MAX_TEXTURE_SIZE as
-   * mGLMaxTextureSize.
+   * limits.maxTex2dSize.
    */
 
   uint32_t maxWidthHeight = 0;
   uint32_t maxDepth = 0;
   uint32_t maxLevel = 0;
 
+  const auto& limits = mContext->Limits();
   MOZ_ASSERT(level <= 31);
   switch (target.get()) {
     case LOCAL_GL_TEXTURE_2D:
-      maxWidthHeight = mContext->mGLMaxTextureSize >> level;
+      maxWidthHeight = limits.maxTex2dSize >> level;
       maxDepth = 1;
-      maxLevel = CeilingLog2(mContext->mGLMaxTextureSize);
+      maxLevel = CeilingLog2(limits.maxTex2dSize);
       break;
 
     case LOCAL_GL_TEXTURE_3D:
-      maxWidthHeight = mContext->mGLMax3DTextureSize >> level;
+      maxWidthHeight = limits.maxTex3dSize >> level;
       maxDepth = maxWidthHeight;
-      maxLevel = CeilingLog2(mContext->mGLMax3DTextureSize);
+      maxLevel = CeilingLog2(limits.maxTex3dSize);
       break;
 
     case LOCAL_GL_TEXTURE_2D_ARRAY:
-      maxWidthHeight = mContext->mGLMaxTextureSize >> level;
+      maxWidthHeight = limits.maxTex2dSize >> level;
       // "The maximum number of layers for two-dimensional array textures
       // (depth) must be at least MAX_ARRAY_TEXTURE_LAYERS for all levels."
-      maxDepth = mContext->mGLMaxArrayTextureLayers;
-      maxLevel = CeilingLog2(mContext->mGLMaxTextureSize);
+      maxDepth = limits.maxTexArrayLayers;
+      maxLevel = CeilingLog2(limits.maxTex2dSize);
       break;
 
     default:  // cube maps
       MOZ_ASSERT(IsCubeMap());
-      maxWidthHeight = mContext->mGLMaxCubeMapTextureSize >> level;
+      maxWidthHeight = limits.maxTexCubeSize >> level;
       maxDepth = 1;
-      maxLevel = CeilingLog2(mContext->mGLMaxCubeMapTextureSize);
+      maxLevel = CeilingLog2(limits.maxTexCubeSize);
       break;
   }
 
@@ -543,7 +383,7 @@
     return false;
   }
 
-  if (width > maxWidthHeight || height > maxWidthHeight || depth > maxDepth) {
+  if (size.x > maxWidthHeight || size.y > maxWidthHeight || size.z > maxDepth) {
     mContext->ErrorInvalidValue("Requested size at this level is unsupported.");
     return false;
   }
@@ -559,7 +399,7 @@
     bool requirePOT = (!mContext->IsWebGL2() && level != 0);
 
     if (requirePOT) {
-      if (!IsPowerOfTwo(width) || !IsPowerOfTwo(height)) {
+      if (!IsPowerOfTwo(size.x) || !IsPowerOfTwo(size.y)) {
         mContext->ErrorInvalidValue(
             "For level > 0, width and height must be"
             " powers of two.");
@@ -574,15 +414,8 @@
 
 // For *TexSubImage*
 bool WebGLTexture::ValidateTexImageSelection(
-    TexImageTarget target, GLint level, GLint xOffset, GLint yOffset,
-    GLint zOffset, uint32_t width, uint32_t height, uint32_t depth,
-    webgl::ImageInfo** const out_imageInfo) {
-  // The conformance test wants bad arg checks before imageInfo checks.
-  if (xOffset < 0 || yOffset < 0 || zOffset < 0) {
-    mContext->ErrorInvalidValue("Offsets must be >=0.");
-    return false;
-  }
-
+    TexImageTarget target, uint32_t level, const uvec3& offset,
+    const uvec3& size, webgl::ImageInfo** const out_imageInfo) {
   webgl::ImageInfo* imageInfo;
   if (!ValidateTexImage(mContext, this, target, level, &imageInfo))
     return false;
@@ -594,9 +427,9 @@
     return false;
   }
 
-  const auto totalX = CheckedUint32(xOffset) + width;
-  const auto totalY = CheckedUint32(yOffset) + height;
-  const auto totalZ = CheckedUint32(zOffset) + depth;
+  const auto totalX = CheckedUint32(offset.x) + size.x;
+  const auto totalY = CheckedUint32(offset.y) + size.y;
+  const auto totalZ = CheckedUint32(offset.z) + size.z;
 
   if (!totalX.isValid() || totalX.value() > imageInfo->mWidth ||
       !totalY.isValid() || totalY.value() > imageInfo->mHeight ||
@@ -611,8 +444,7 @@
   return true;
 }
 
-static bool ValidateCompressedTexUnpack(WebGLContext* webgl, GLsizei width,
-                                        GLsizei height, GLsizei depth,
+static bool ValidateCompressedTexUnpack(WebGLContext* webgl, const uvec3& size,
                                         const webgl::FormatInfo* format,
                                         size_t dataSize) {
   auto compression = format->compression;
@@ -621,14 +453,14 @@
   auto blockWidth = compression->blockWidth;
   auto blockHeight = compression->blockHeight;
 
-  auto widthInBlocks = CheckedUint32(width) / blockWidth;
-  auto heightInBlocks = CheckedUint32(height) / blockHeight;
-  if (width % blockWidth) widthInBlocks += 1;
-  if (height % blockHeight) heightInBlocks += 1;
+  auto widthInBlocks = CheckedUint32(size.x) / blockWidth;
+  auto heightInBlocks = CheckedUint32(size.y) / blockHeight;
+  if (size.x % blockWidth) widthInBlocks += 1;
+  if (size.y % blockHeight) heightInBlocks += 1;
 
   const CheckedUint32 blocksPerImage = widthInBlocks * heightInBlocks;
   const CheckedUint32 bytesPerImage = bytesPerBlock * blocksPerImage;
-  const CheckedUint32 bytesNeeded = bytesPerImage * depth;
+  const CheckedUint32 bytesNeeded = bytesPerImage * size.z;
 
   if (!bytesNeeded.isValid()) {
     webgl->ErrorOutOfMemory("Overflow while computing the needed buffer size.");
@@ -702,14 +534,12 @@
 }
 
 static bool EnsureImageDataInitializedForUpload(
-    WebGLTexture* tex, TexImageTarget target, GLint level, GLint xOffset,
-    GLint yOffset, GLint zOffset, uint32_t width, uint32_t height,
-    uint32_t depth, webgl::ImageInfo* imageInfo) {
+    WebGLTexture* tex, TexImageTarget target, uint32_t level,
+    const uvec3& offset, const uvec3& size, webgl::ImageInfo* imageInfo) {
   if (!imageInfo->mUninitializedSlices) return true;
 
-  if (width == imageInfo->mWidth && height == imageInfo->mHeight) {
-    for (const auto z :
-         IntegerRange(uint32_t(zOffset), uint32_t(zOffset) + depth)) {
+  if (size.x == imageInfo->mWidth && size.y == imageInfo->mHeight) {
+    for (const auto z : IntegerRange(offset.z, offset.z + size.z)) {
       (*imageInfo->mUninitializedSlices)[z] = false;
     }
     bool hasUninitialized = false;
@@ -888,9 +718,8 @@
 // Actual (mostly generic) function implementations
 
 static bool ValidateCompressedTexImageRestrictions(
-    WebGLContext* webgl, TexImageTarget target, uint32_t level,
-    const webgl::FormatInfo* format, uint32_t width, uint32_t height,
-    uint32_t depth) {
+    const WebGLContext* webgl, TexImageTarget target, uint32_t level,
+    const webgl::FormatInfo* format, const uvec3& size) {
   const auto fnIsDimValid_S3TC = [level](uint32_t size, uint32_t blockSize) {
     if (size % blockSize == 0) return true;
 
@@ -910,7 +739,7 @@
       break;
 
     case webgl::CompressionFamily::PVRTC:
-      if (!IsPowerOfTwo(width) || !IsPowerOfTwo(height)) {
+      if (!IsPowerOfTwo(size.x) || !IsPowerOfTwo(size.y)) {
         webgl->ErrorInvalidValue("%s requires power-of-two width and height.",
                                  format->name);
         return false;
@@ -919,8 +748,8 @@
       break;
 
     case webgl::CompressionFamily::S3TC:
-      if (!fnIsDimValid_S3TC(width, format->compression->blockWidth) ||
-          !fnIsDimValid_S3TC(height, format->compression->blockHeight)) {
+      if (!fnIsDimValid_S3TC(size.x, format->compression->blockWidth) ||
+          !fnIsDimValid_S3TC(size.y, format->compression->blockHeight)) {
         webgl->ErrorInvalidOperation(
             "%s requires that width and height are"
             " block-aligned, or, if level>0, equal to 0, 1,"
@@ -939,7 +768,8 @@
   return true;
 }
 
-static bool ValidateTargetForFormat(WebGLContext* webgl, TexImageTarget target,
+static bool ValidateTargetForFormat(const WebGLContext* webgl,
+                                    TexImageTarget target,
                                     const webgl::FormatInfo* format) {
   // GLES 3.0.4 p127:
   // "Textures with a base internal format of DEPTH_COMPONENT or DEPTH_STENCIL
@@ -980,16 +810,15 @@
   return true;
 }
 
-void WebGLTexture::TexStorage(TexTarget target, GLsizei levels,
-                              GLenum sizedFormat, GLsizei width, GLsizei height,
-                              GLsizei depth) {
+void WebGLTexture::TexStorage(TexTarget target, uint32_t levels,
+                              GLenum sizedFormat, const uvec3& size) {
   // Check levels
   if (levels < 1) {
     mContext->ErrorInvalidValue("`levels` must be >= 1.");
     return;
   }
 
-  if (!width || !height || !depth) {
+  if (!size.x || !size.y || !size.z) {
     mContext->ErrorInvalidValue("Dimensions must be non-zero.");
     return;
   }
@@ -997,8 +826,7 @@
   const TexImageTarget testTarget =
       IsCubeMap() ? LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X : target.get();
   webgl::ImageInfo* baseImageInfo;
-  if (!ValidateTexImageSpecification(testTarget, 0, width, height, depth,
-                                     &baseImageInfo)) {
+  if (!ValidateTexImageSpecification(testTarget, 0, size, &baseImageInfo)) {
     return;
   }
   MOZ_ALWAYS_TRUE(baseImageInfo);
@@ -1013,8 +841,8 @@
   if (!ValidateTargetForFormat(mContext, testTarget, dstFormat)) return;
 
   if (dstFormat->compression) {
-    if (!ValidateCompressedTexImageRestrictions(
-            mContext, testTarget, 0, dstFormat, width, height, depth)) {
+    if (!ValidateCompressedTexImageRestrictions(mContext, testTarget, 0,
+                                                dstFormat, size)) {
       return;
     }
   }
@@ -1026,14 +854,14 @@
     const auto lastLevel = uint32_t(levels - 1);
     if (lastLevel > 31) return false;
 
-    const auto lastLevelWidth = uint32_t(width) >> lastLevel;
-    const auto lastLevelHeight = uint32_t(height) >> lastLevel;
+    const auto lastLevelWidth = uint32_t(size.x) >> lastLevel;
+    const auto lastLevelHeight = uint32_t(size.y) >> lastLevel;
 
     // If these are all zero, then some earlier level was the final 1x1(x1)
     // level.
     bool ok = lastLevelWidth || lastLevelHeight;
     if (target == LOCAL_GL_TEXTURE_3D) {
-      const auto lastLevelDepth = uint32_t(depth) >> lastLevel;
+      const auto lastLevelDepth = uint32_t(size.z) >> lastLevel;
       ok |= bool(lastLevelDepth);
     }
     return ok;
@@ -1043,7 +871,7 @@
         "Too many levels requested for the given"
         " dimensions. (levels: %u, width: %u, height: %u,"
         " depth: %u)",
-        levels, width, height, depth);
+        levels, size.x, size.y, size.z);
     return;
   }
 
@@ -1051,7 +879,7 @@
   // Do the thing!
 
   GLenum error = DoTexStorage(mContext->gl, target.get(), levels, sizedFormat,
-                              width, height, depth);
+                              size.x, size.y, size.z);
 
   mContext->OnDataAllocCall();
 
@@ -1064,7 +892,7 @@
     mContext->GenerateError(error, "Unexpected error from driver.");
     const nsPrintfCString call(
         "DoTexStorage(0x%04x, %i, 0x%04x, %i,%i,%i) -> 0x%04x", target.get(),
-        levels, sizedFormat, width, height, depth, error);
+        levels, sizedFormat, size.x, size.y, size.z, error);
     gfxCriticalError() << "Unexpected error from driver: "
                        << call.BeginReading();
     return;
@@ -1073,9 +901,8 @@
   ////////////////////////////////////
   // Update our specification data.
 
-  auto uninitializedSlices = Some(std::vector<bool>(depth, true));
-  const webgl::ImageInfo newInfo{dstUsage, uint32_t(width), uint32_t(height),
-                                 uint32_t(depth),
+  auto uninitializedSlices = Some(std::vector<bool>(size.z, true));
+  const webgl::ImageInfo newInfo{dstUsage, size.x, size.y, size.z,
                                  std::move(uninitializedSlices)};
 
   {
@@ -1096,183 +923,145 @@
 ////////////////////////////////////////
 // Tex(Sub)Image
 
-void WebGLTexture::TexImage(TexImageTarget target, GLint level,
-                            GLenum internalFormat, const webgl::PackingInfo& pi,
-                            UniquePtr<webgl::TexUnpackBlob>&& blob) {
+// TexSubImage iff `!respectFormat`
+void WebGLTexture::TexImage(GLenum imageTarget, uint32_t level,
+                            GLenum respecFormat, const uvec3& offset,
+                            const uvec3& size, const webgl::PackingInfo& pi,
+                            const TexImageSource& src,
+                            const dom::HTMLCanvasElement& canvas) {
+  dom::Uint8ClampedArray scopedArr;
+  const auto blob = mContext->From(canvas, imageTarget, size, src, &scopedArr);
+  if (!blob) return;
+
   ////////////////////////////////////
   // Get dest info
 
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSpecification(target, level, blob->mWidth, blob->mHeight,
-                                     blob->mDepth, &imageInfo)) {
-    return;
-  }
-  MOZ_ASSERT(imageInfo);
+  const auto& fua = mContext->mFormatUsage;
+  const auto fnValidateUnpackEnums = [&]() {
+    if (!fua->AreUnpackEnumsValid(pi.format, pi.type)) {
+      mContext->ErrorInvalidEnum("Invalid unpack format/type: %s/%s",
+                                 EnumString(pi.format).c_str(),
+                                 EnumString(pi.type).c_str());
+      return false;
+    }
+    return true;
+  };
 
-  const auto& fua = mContext->mFormatUsage;
-  if (!fua->IsInternalFormatEnumValid(internalFormat)) {
-    mContext->ErrorInvalidValue("Invalid internalformat: 0x%04x",
-                                internalFormat);
-    return;
-  }
+  webgl::ImageInfo* imageInfo;
+  const webgl::FormatUsageInfo* dstUsage;
+  if (respecFormat) {
+    if (!ValidateTexImageSpecification(imageTarget, level, size, &imageInfo))
+      return;
+    MOZ_ASSERT(imageInfo);
 
-  auto dstUsage = fua->GetSizedTexUsage(internalFormat);
-  if (!dstUsage) {
-    if (internalFormat != pi.format) {
-      /* GL ES Version 3.0.4 - 3.8.3 Texture Image Specification
-       *   "Specifying a combination of values for format, type, and
-       *   internalformat that is not listed as a valid combination
-       *   in tables 3.2 or 3.3 generates the error INVALID_OPERATION."
-       */
-      mContext->ErrorInvalidOperation(
-          "Unsized internalFormat must match"
-          " unpack format.");
+    if (!fua->IsInternalFormatEnumValid(respecFormat)) {
+      mContext->ErrorInvalidValue("Invalid internalformat: 0x%04x",
+                                  respecFormat);
       return;
     }
 
-    dstUsage = fua->GetUnsizedTexUsage(pi);
-  }
+    dstUsage = fua->GetSizedTexUsage(respecFormat);
+    if (!dstUsage) {
+      if (respecFormat != pi.format) {
+        /* GL ES Version 3.0.4 - 3.8.3 Texture Image Specification
+         *   "Specifying a combination of values for format, type, and
+         *   internalformat that is not listed as a valid combination
+         *   in tables 3.2 or 3.3 generates the error INVALID_OPERATION."
+         */
+        if (!fnValidateUnpackEnums()) return;
+        mContext->ErrorInvalidOperation(
+            "Unsized internalFormat must match"
+            " unpack format.");
+        return;
+      }
 
-  if (!dstUsage) {
-    mContext->ErrorInvalidOperation(
-        "Invalid internalformat/format/type:"
-        " 0x%04x/0x%04x/0x%04x",
-        internalFormat, pi.format, pi.type);
-    return;
-  }
+      dstUsage = fua->GetUnsizedTexUsage(pi);
+    }
+
+    if (!dstUsage) {
+      if (!fnValidateUnpackEnums()) return;
+      mContext->ErrorInvalidOperation(
+          "Invalid internalformat/format/type:"
+          " 0x%04x/0x%04x/0x%04x",
+          respecFormat, pi.format, pi.type);
+      return;
+    }
 
-  const webgl::DriverUnpackInfo* driverUnpackInfo;
-  if (!dstUsage->IsUnpackValid(pi, &driverUnpackInfo)) {
-    mContext->ErrorInvalidOperation(
-        "Mismatched internalFormat and format/type:"
-        " 0x%04x and 0x%04x/0x%04x",
-        internalFormat, pi.format, pi.type);
-    return;
-  }
+    const auto& dstFormat = dstUsage->format;
+    if (!ValidateTargetForFormat(mContext, imageTarget, dstFormat)) return;
 
-  ////////////////////////////////////
-  // Check that source and dest info are compatible
-  auto dstFormat = dstUsage->format;
-
-  if (!ValidateTargetForFormat(mContext, target, dstFormat)) return;
+    if (!mContext->IsWebGL2() && dstFormat->d) {
+      if (imageTarget != LOCAL_GL_TEXTURE_2D || blob->HasData() || level != 0) {
+        mContext->ErrorInvalidOperation(
+            "With format %s, this function may only"
+            " be called with target=TEXTURE_2D,"
+            " data=null, and level=0.",
+            dstFormat->name);
+        return;
+      }
+    }
+  } else {
+    if (!ValidateTexImageSelection(imageTarget, level, offset, size,
+                                   &imageInfo)) {
+      return;
+    }
+    MOZ_ASSERT(imageInfo);
+    dstUsage = imageInfo->mFormat;
 
-  if (!mContext->IsWebGL2() && dstFormat->d) {
-    if (target != LOCAL_GL_TEXTURE_2D || blob->HasData() || level != 0) {
+    const auto& dstFormat = dstUsage->format;
+    if (!mContext->IsWebGL2() && dstFormat->d) {
       mContext->ErrorInvalidOperation(
-          "With format %s, this function may only"
-          " be called with target=TEXTURE_2D,"
-          " data=null, and level=0.",
+          "Function may not be called on a texture of"
+          " format %s.",
           dstFormat->name);
       return;
     }
   }
 
   ////////////////////////////////////
-  // Do the thing!
-
-  // It's tempting to do allocation first, and TexSubImage second, but this is
-  // generally slower.
-  auto uninitializedSlices =
-      blob->HasData() ? Nothing() : Some(std::vector<bool>(blob->mDepth, true));
-  const webgl::ImageInfo newImageInfo{dstUsage, blob->mWidth, blob->mHeight,
-                                      blob->mDepth,
-                                      std::move(uninitializedSlices)};
-
-  const bool isSubImage = false;
-  const bool needsRespec = (imageInfo->mWidth != newImageInfo.mWidth ||
-                            imageInfo->mHeight != newImageInfo.mHeight ||
-                            imageInfo->mDepth != newImageInfo.mDepth ||
-                            imageInfo->mFormat != newImageInfo.mFormat);
-  const GLint xOffset = 0;
-  const GLint yOffset = 0;
-  const GLint zOffset = 0;
-
-  GLenum glError;
-  if (!blob->TexOrSubImage(isSubImage, needsRespec, this, target, level,
-                           driverUnpackInfo, xOffset, yOffset, zOffset, pi,
-                           &glError)) {
-    return;
-  }
-
-  mContext->OnDataAllocCall();
-
-  if (glError == LOCAL_GL_OUT_OF_MEMORY) {
-    mContext->ErrorOutOfMemory("Driver ran out of memory during upload.");
-    Truncate();
-    return;
-  }
-
-  if (glError) {
-    const auto enumStr = EnumString(glError);
-    const nsPrintfCString dui(
-        "Unexpected error %s during upload. (dui: %x/%x/%x)", enumStr.c_str(),
-        driverUnpackInfo->internalFormat, driverUnpackInfo->unpackFormat,
-        driverUnpackInfo->unpackType);
-    mContext->ErrorInvalidOperation("%s", dui.BeginReading());
-    gfxCriticalError() << mContext->FuncName() << ": " << dui.BeginReading();
-    return;
-  }
-
-  ////////////////////////////////////
-  // Update our specification data.
-
-  *imageInfo = newImageInfo;
-  InvalidateCaches();
-}
-
-void WebGLTexture::TexSubImage(TexImageTarget target, GLint level,
-                               GLint xOffset, GLint yOffset, GLint zOffset,
-                               const webgl::PackingInfo& pi,
-                               UniquePtr<webgl::TexUnpackBlob>&& blob) {
-  ////////////////////////////////////
-  // Get dest info
-
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSelection(target, level, xOffset, yOffset, zOffset,
-                                 blob->mWidth, blob->mHeight, blob->mDepth,
-                                 &imageInfo)) {
-    return;
-  }
-  MOZ_ASSERT(imageInfo);
-
-  auto dstUsage = imageInfo->mFormat;
-  auto dstFormat = dstUsage->format;
-
-  if (!mContext->IsWebGL2() && dstFormat->d) {
-    mContext->ErrorInvalidOperation(
-        "Function may not be called on a texture of"
-        " format %s.",
-        dstFormat->name);
-    return;
-  }
-
-  ////////////////////////////////////
   // Get source info
 
   const webgl::DriverUnpackInfo* driverUnpackInfo;
   if (!dstUsage->IsUnpackValid(pi, &driverUnpackInfo)) {
+    if (!fnValidateUnpackEnums()) return;
     mContext->ErrorInvalidOperation(
         "Mismatched internalFormat and format/type:"
-        " %s and 0x%04x/0x%04x",
-        dstFormat->name, pi.format, pi.type);
+        " 0x%04x and 0x%04x/0x%04x",
+        respecFormat, pi.format, pi.type);
     return;
   }
 
   ////////////////////////////////////
   // Do the thing!
 
-  if (!EnsureImageDataInitializedForUpload(
-          this, target, level, xOffset, yOffset, zOffset, blob->mWidth,
-          blob->mHeight, blob->mDepth, imageInfo)) {
-    return;
+  Maybe<webgl::ImageInfo> newImageInfo;
+  bool isRespec = false;
+  if (respecFormat) {
+    // It's tempting to do allocation first, and TexSubImage second, but this is
+    // generally slower.
+    newImageInfo = Some(webgl::ImageInfo{dstUsage, size.x, size.y, size.z});
+    if (!blob->HasData()) {
+      newImageInfo->mUninitializedSlices =
+          Some(std::vector<bool>(blob->mDepth, true));
+    }
+
+    if (imageInfo->mWidth == newImageInfo->mWidth &&
+        imageInfo->mHeight == newImageInfo->mHeight &&
+        imageInfo->mDepth == newImageInfo->mDepth &&
+        imageInfo->mFormat == newImageInfo->mFormat) {
+      isRespec = true;
+    }
+  } else {
+    if (!EnsureImageDataInitializedForUpload(this, imageTarget, level, offset,
+                                             size, imageInfo)) {
+      return;
+    }
   }
 
-  const bool isSubImage = true;
-  const bool needsRespec = false;
-
+  const bool isSubImage = !respecFormat;
   GLenum glError;
-  if (!blob->TexOrSubImage(isSubImage, needsRespec, this, target, level,
-                           driverUnpackInfo, xOffset, yOffset, zOffset, pi,
+  if (!blob->TexOrSubImage(isSubImage, isRespec, this, imageTarget, level,
+                           driverUnpackInfo, offset.x, offset.y, offset.z, pi,
                            &glError)) {
     return;
   }
@@ -1296,90 +1085,17 @@
 
   ////////////////////////////////////
   // Update our specification data?
+
+  if (respecFormat) {
+    mContext->OnDataAllocCall();
+    *imageInfo = *newImageInfo;
+    InvalidateCaches();
+  }
 }
 
 ////////////////////////////////////////
 // CompressedTex(Sub)Image
 
-void WebGLTexture::CompressedTexImage(TexImageTarget target, GLint level,
-                                      GLenum internalFormat, GLsizei rawWidth,
-                                      GLsizei rawHeight, GLsizei rawDepth,
-                                      GLint border,
-                                      UniquePtr<webgl::TexUnpackBytes>&& blob,
-                                      const Maybe<GLsizei>& expectedImageSize) {
-  ////////////////////////////////////
-  // Get dest info
-
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSpecification(target, level, blob->mWidth, blob->mHeight,
-                                     blob->mDepth, &imageInfo)) {
-    return;
-  }
-  MOZ_ASSERT(imageInfo);
-
-  auto usage = mContext->mFormatUsage->GetSizedTexUsage(internalFormat);
-  if (!usage || !usage->format->compression) {
-    mContext->ErrorInvalidEnumArg("internalFormat", internalFormat);
-    return;
-  }
-  auto format = usage->format;
-
-  if (!ValidateTargetForFormat(mContext, target, format)) return;
-
-  ////////////////////////////////////
-  // Get source info
-
-  if (!ValidateCompressedTexUnpack(mContext, blob->mWidth, blob->mHeight,
-                                   blob->mDepth, format, blob->mPtr.Length())) {
-    return;
-  }
-
-  ////////////////////////////////////
-  // Check that source is compatible with dest
-
-  if (!ValidateCompressedTexImageRestrictions(mContext, target, level, format,
-                                              blob->mWidth, blob->mHeight,
-                                              blob->mDepth)) {
-    return;
-  }
-
-  ////////////////////////////////////
-  // Do the thing!
-
-  const ScopedLazyBind bindPBO(mContext->gl, LOCAL_GL_PIXEL_UNPACK_BUFFER,
-                               mContext->mBoundPixelUnpackBuffer);
-
-  // Warning: Possibly shared memory.  See bug 1225033.
-  const auto error = DoCompressedTexImage(
-      mContext->gl, target, level, internalFormat, blob->mWidth, blob->mHeight,
-      blob->mDepth, blob->mPtr.Length(), blob->mPtr.Data());
-  mContext->OnDataAllocCall();
-  if (error == LOCAL_GL_OUT_OF_MEMORY) {
-    mContext->ErrorOutOfMemory("Ran out of memory during upload.");
-    Truncate();
-    return;
-  }
-  if (error) {
-    mContext->GenerateError(error, "Unexpected error from driver.");
-    const nsPrintfCString call(
-        "DoCompressedTexImage(0x%04x, %i, 0x%04x, %u,%u,%u, %u) -> 0x%04x",
-        target.get(), level, internalFormat, blob->mWidth, blob->mHeight,
-        blob->mDepth, uint32_t(blob->mPtr.Length()), error);
-    gfxCriticalError() << "Unexpected error from driver: "
-                       << call.BeginReading();
-    return;
-  }
-
-  ////////////////////////////////////
-  // Update our specification data.
-
-  const auto uninitializedSlices = Nothing();
-  const webgl::ImageInfo newImageInfo{usage, blob->mWidth, blob->mHeight,
-                                      blob->mDepth, uninitializedSlices};
-  *imageInfo = newImageInfo;
-  InvalidateCaches();
-}
-
 static inline bool IsSubImageBlockAligned(
     const webgl::CompressedFormatInfo* compression,
     const webgl::ImageInfo* imageInfo, GLint xOffset, GLint yOffset,
@@ -1400,102 +1116,146 @@
   return true;
 }
 
-void WebGLTexture::CompressedTexSubImage(
-    TexImageTarget target, GLint level, GLint xOffset, GLint yOffset,
-    GLint zOffset, GLsizei rawWidth, GLsizei rawHeight, GLsizei rawDepth,
-    GLenum sizedUnpackFormat, UniquePtr<webgl::TexUnpackBytes>&& blob,
-    const Maybe<GLsizei>& expectedImageSize) {
-  ////////////////////////////////////
-  // Get dest info
-
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSelection(target, level, xOffset, yOffset, zOffset,
-                                 blob->mWidth, blob->mHeight, blob->mDepth,
-                                 &imageInfo)) {
-    return;
+// CompressedTexSubImage iff `sub`
+void WebGLTexture::CompressedTexImage(bool sub, GLenum imageTarget,
+                                      uint32_t level, GLenum formatEnum,
+                                      const uvec3& offset, const uvec3& size,
+                                      const Range<const uint8_t>& src,
+                                      const uint32_t pboImageSize,
+                                      const Maybe<uint64_t> pboOffset) {
+  auto imageSize = pboImageSize;
+  if (pboOffset) {
+    const auto& buffer =
+        mContext->ValidateBufferSelection(LOCAL_GL_PIXEL_UNPACK_BUFFER);
+    if (!buffer) return;
+    auto availBytes = buffer->ByteLength();
+    if (*pboOffset > availBytes) {
+      mContext->GenerateError(
+          LOCAL_GL_INVALID_OPERATION,
+          "`offset` (%llu) must be <= PIXEL_UNPACK_BUFFER size (%llu).",
+          *pboOffset, availBytes);
+      return;
+    }
+    availBytes -= *pboOffset;
+    if (availBytes < pboImageSize) {
+      mContext->GenerateError(
+          LOCAL_GL_INVALID_OPERATION,
+          "PIXEL_UNPACK_BUFFER size minus `offset` (%llu) too small for"
+          " `pboImageSize` (%u).",
+          availBytes, pboImageSize);
+      return;
+    }
+  } else {
+    if (mContext->mBoundPixelUnpackBuffer) {
+      mContext->GenerateError(LOCAL_GL_INVALID_OPERATION,
+                              "PIXEL_UNPACK_BUFFER is non-null.");
+      return;
+    }
+    imageSize = src.length();
   }
-  MOZ_ASSERT(imageInfo);
 
-  auto dstUsage = imageInfo->mFormat;
-  auto dstFormat = dstUsage->format;
-
-  ////////////////////////////////////
-  // Get source info
+  // -
 
-  auto srcUsage = mContext->mFormatUsage->GetSizedTexUsage(sizedUnpackFormat);
-  if (!srcUsage || !srcUsage->format->compression) {
-    mContext->ErrorInvalidEnumArg("sizedUnpackFormat", sizedUnpackFormat);
-    return;
-  }
-  if (srcUsage != dstUsage) {
-    mContext->ErrorInvalidOperation(
-        "`format` must match the format of the"
-        " existing texture image.");
+  const auto usage = mContext->mFormatUsage->GetSizedTexUsage(formatEnum);
+  if (!usage || !usage->format->compression) {
+    mContext->ErrorInvalidEnumArg("format", formatEnum);
     return;
   }
 
-  auto format = srcUsage->format;
-  MOZ_ASSERT(format == dstFormat);
-  if (!ValidateCompressedTexUnpack(mContext, blob->mWidth, blob->mHeight,
-                                   blob->mDepth, format, blob->mPtr.Length())) {
-    return;
+  webgl::ImageInfo* imageInfo;
+  if (!sub) {
+    if (!ValidateTexImageSpecification(imageTarget, level, size, &imageInfo)) {
+      return;
+    }
+    MOZ_ASSERT(imageInfo);
+
+    if (!ValidateTargetForFormat(mContext, imageTarget, usage->format)) return;
+    if (!ValidateCompressedTexImageRestrictions(mContext, imageTarget, level,
+                                                usage->format, size)) {
+      return;
+    }
+  } else {
+    if (!ValidateTexImageSelection(imageTarget, level, offset, size,
+                                   &imageInfo))
+      return;
+    MOZ_ASSERT(imageInfo);
+
+    const auto dstUsage = imageInfo->mFormat;
+    if (usage != dstUsage) {
+      mContext->ErrorInvalidOperation(
+          "`format` must match the format of the"
+          " existing texture image.");
+      return;
+    }
+
+    const auto& format = usage->format;
+    switch (format->compression->family) {
+      // Forbidden:
+      case webgl::CompressionFamily::ETC1:
+        mContext->ErrorInvalidOperation(
+            "Format does not allow sub-image"
+            " updates.");
+        return;
+
+      // Block-aligned:
+      case webgl::CompressionFamily::ES3:  // Yes, the ES3 formats don't match
+                                           // the ES3
+      case webgl::CompressionFamily::S3TC:  // default behavior.
+      case webgl::CompressionFamily::BPTC:
+      case webgl::CompressionFamily::RGTC:
+        if (!IsSubImageBlockAligned(format->compression, imageInfo, offset.x,
+                                    offset.y, size.x, size.y)) {
+          mContext->ErrorInvalidOperation(
+              "Format requires block-aligned sub-image"
+              " updates.");
+          return;
+        }
+        break;
+
+      // Full-only: (The ES3 default)
+      default:  // PVRTC
+        if (offset.x || offset.y || size.x != imageInfo->mWidth ||
+            size.y != imageInfo->mHeight) {
+          mContext->ErrorInvalidOperation(
+              "Format does not allow partial sub-image"
+              " updates.");
+          return;
+        }
+        break;
+    }
   }
 
-  ////////////////////////////////////
-  // Check that source is compatible with dest
-
-  switch (format->compression->family) {
-    // Forbidden:
-    case webgl::CompressionFamily::ETC1:
-      mContext->ErrorInvalidOperation(
-          "Format does not allow sub-image"
-          " updates.");
-      return;
-
-    // Block-aligned:
-    case webgl::CompressionFamily::ES3:  // Yes, the ES3 formats don't match the
-                                         // ES3
-    case webgl::CompressionFamily::S3TC:  // default behavior.
-    case webgl::CompressionFamily::BPTC:
-    case webgl::CompressionFamily::RGTC:
-      if (!IsSubImageBlockAligned(dstFormat->compression, imageInfo, xOffset,
-                                  yOffset, blob->mWidth, blob->mHeight)) {
-        mContext->ErrorInvalidOperation(
-            "Format requires block-aligned sub-image"
-            " updates.");
-        return;
-      }
-      break;
-
-    // Full-only: (The ES3 default)
-    default:  // PVRTC
-      if (xOffset || yOffset || blob->mWidth != imageInfo->mWidth ||
-          blob->mHeight != imageInfo->mHeight) {
-        mContext->ErrorInvalidOperation(
-            "Format does not allow partial sub-image"
-            " updates.");
-        return;
-      }
-      break;
-  }
+  if (!ValidateCompressedTexUnpack(mContext, size, usage->format, imageSize))
+    return;
 
   ////////////////////////////////////
   // Do the thing!
 
-  if (!EnsureImageDataInitializedForUpload(
-          this, target, level, xOffset, yOffset, zOffset, blob->mWidth,
-          blob->mHeight, blob->mDepth, imageInfo)) {
-    return;
+  if (sub) {
+    if (!EnsureImageDataInitializedForUpload(this, imageTarget, level, offset,
+                                             size, imageInfo)) {
+      return;
+    }
   }
 
   const ScopedLazyBind bindPBO(mContext->gl, LOCAL_GL_PIXEL_UNPACK_BUFFER,
                                mContext->mBoundPixelUnpackBuffer);
+  GLenum error;
+  const void* ptr;
+  if (pboOffset) {
+    ptr = reinterpret_cast<const void*>(*pboOffset);
+  } else {
+    ptr = reinterpret_cast<const void*>(src.begin().get());
+  }
 
-  // Warning: Possibly shared memory.  See bug 1225033.
-  const auto error = DoCompressedTexSubImage(
-      mContext->gl, target, level, xOffset, yOffset, zOffset, blob->mWidth,
-      blob->mHeight, blob->mDepth, sizedUnpackFormat, blob->mPtr.Length(),
-      blob->mPtr.Data());
+  if (!sub) {
+    error = DoCompressedTexImage(mContext->gl, imageTarget, level, formatEnum,
+                                 size.x, size.y, size.z, imageSize, ptr);
+  } else {
+    error = DoCompressedTexSubImage(mContext->gl, imageTarget, level, offset.x,
+                                    offset.y, offset.z, size.x, size.y, size.z,
+                                    formatEnum, imageSize, ptr);
+  }
   if (error == LOCAL_GL_OUT_OF_MEMORY) {
     mContext->ErrorOutOfMemory("Ran out of memory during upload.");
     Truncate();
@@ -1503,19 +1263,35 @@
   }
   if (error) {
     mContext->GenerateError(error, "Unexpected error from driver.");
-    const nsPrintfCString call(
-        "DoCompressedTexSubImage(0x%04x, %i, %i,%i,%i, %u,%u,%u, 0x%04x, %u) "
-        "-> 0x%04x",
-        target.get(), level, xOffset, yOffset, zOffset, blob->mWidth,
-        blob->mHeight, blob->mDepth, sizedUnpackFormat,
-        uint32_t(blob->mPtr.Length()), error);
-    gfxCriticalError() << "Unexpected error from driver: "
-                       << call.BeginReading();
+    nsCString call;
+    if (!sub) {
+      call = nsPrintfCString(
+          "DoCompressedTexImage(0x%04x, %u, 0x%04x, %u,%u,%u, %u, %p)",
+          imageTarget, level, formatEnum, size.x, size.y, size.z, imageSize,
+          ptr);
+    } else {
+      call = nsPrintfCString(
+          "DoCompressedTexSubImage(0x%04x, %u, %u,%u,%u, %u,%u,%u, 0x%04x, %u, "
+          "%p) "
+          "-> 0x%04x",
+          imageTarget, level, offset.x, offset.y, offset.z, size.x, size.y,
+          size.z, formatEnum, imageSize, ptr);
+    }
+    gfxCriticalError() << "Unexpected error " << gfx::hexa(error)
+                       << " from driver: " << call.BeginReading();
     return;
   }
 
   ////////////////////////////////////
   // Update our specification data?
+
+  if (!sub) {
+    const auto uninitializedSlices = Nothing();
+    const webgl::ImageInfo newImageInfo{usage, size.x, size.y, size.z,
+                                        uninitializedSlices};
+    *imageInfo = newImageInfo;
+    InvalidateCaches();
+  }
 }
 
 ////////////////////////////////////////
@@ -1958,20 +1734,10 @@
   return false;
 }
 
-// There is no CopyTexImage3D.
-void WebGLTexture::CopyTexImage2D(TexImageTarget target, GLint level,
-                                  GLenum internalFormat, GLint x, GLint y,
-                                  uint32_t width, uint32_t height,
-                                  uint32_t depth) {
-  ////////////////////////////////////
-  // Get dest info
-
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSpecification(target, level, width, height, depth,
-                                     &imageInfo))
-    return;
-  MOZ_ASSERT(imageInfo);
-
+// CopyTexSubImage if `!respecFormat`
+void WebGLTexture::CopyTexImage(GLenum imageTarget, uint32_t level,
+                                GLenum respecFormat, const uvec3& dstOffset,
+                                const ivec2& srcOffset, const uvec2& size2) {
   ////////////////////////////////////
   // Get source info
 
@@ -1982,176 +1748,83 @@
                                        &srcTotalHeight)) {
     return;
   }
+  const auto& srcFormat = srcUsage->format;
 
   const uint32_t zOffset = 0;
   if (!ValidateCopyTexImageForFeedback(*mContext, *this,
                                        AssertedCast<uint8_t>(level), zOffset))
     return;
 
+  const auto size = uvec3{size2.x, size2.y, 1};
+
   ////////////////////////////////////
-  // Check that source and dest info are compatible
+  // Get dest info
+
+  webgl::ImageInfo* imageInfo;
+  const webgl::FormatUsageInfo* dstUsage;
+  if (respecFormat) {
+    if (!ValidateTexImageSpecification(imageTarget, level, size, &imageInfo))
+      return;
+    MOZ_ASSERT(imageInfo);
 
-  const auto& srcFormat = srcUsage->format;
-  const auto dstUsage =
-      ValidateCopyDestUsage(mContext, srcFormat, internalFormat);
-  if (!dstUsage) return;
+    dstUsage = ValidateCopyDestUsage(mContext, srcFormat, respecFormat);
+    if (!dstUsage) return;
+
+    if (!ValidateTargetForFormat(mContext, imageTarget, dstUsage->format))
+      return;
+  } else {
+    if (!ValidateTexImageSelection(imageTarget, level, dstOffset, size,
+                                   &imageInfo)) {
+      return;
+    }
+    MOZ_ASSERT(imageInfo);
+
+    dstUsage = imageInfo->mFormat;
+    MOZ_ASSERT(dstUsage);
+  }
 
   const auto& dstFormat = dstUsage->format;
-  if (!ValidateTargetForFormat(mContext, target, dstFormat)) return;
-
   if (!mContext->IsWebGL2() && dstFormat->d) {
     mContext->ErrorInvalidOperation(
         "Function may not be called with format %s.", dstFormat->name);
     return;
   }
 
+  ////////////////////////////////////
+  // Check that source and dest info are compatible
+
   if (!ValidateCopyTexImageFormats(mContext, srcFormat, dstFormat)) return;
 
   ////////////////////////////////////
   // Do the thing!
 
-  const bool isSubImage = false;
-  if (!DoCopyTexOrSubImage(mContext, isSubImage, this, target, level, x, y,
-                           srcTotalWidth, srcTotalHeight, srcUsage, 0, 0, 0,
-                           width, height, dstUsage)) {
+  if (!respecFormat) {
+    if (!EnsureImageDataInitializedForUpload(this, imageTarget, level,
+                                             dstOffset, size, imageInfo)) {
+      return;
+    }
+  }
+
+  const bool isSubImage = !respecFormat;
+  if (!DoCopyTexOrSubImage(mContext, isSubImage, this, imageTarget, level,
+                           srcOffset.x, srcOffset.y, srcTotalWidth,
+                           srcTotalHeight, srcUsage, dstOffset.x, dstOffset.y,
+                           dstOffset.z, size.x, size.y, dstUsage)) {
     return;
   }
 
   mContext->OnDataAllocCall();
 
   ////////////////////////////////////
-  // Update our specification data.
-
-  const auto uninitializedSlices = Nothing();
-  const webgl::ImageInfo newImageInfo{dstUsage, width, height, depth,
-                                      uninitializedSlices};
-  *imageInfo = newImageInfo;
-  InvalidateCaches();
-}
-
-void WebGLTexture::CopyTexSubImage(TexImageTarget target, GLint level,
-                                   GLint xOffset, GLint yOffset, GLint zOffset,
-                                   GLint x, GLint y, uint32_t width,
-                                   uint32_t height, uint32_t depth) {
-  ////////////////////////////////////
-  // Get dest info
-
-  webgl::ImageInfo* imageInfo;
-  if (!ValidateTexImageSelection(target, level, xOffset, yOffset, zOffset,
-                                 width, height, depth, &imageInfo)) {
-    return;
-  }
-  MOZ_ASSERT(imageInfo);
-
-  auto dstUsage = imageInfo->mFormat;
-  MOZ_ASSERT(dstUsage);
-
-  auto dstFormat = dstUsage->format;
-  if (!mContext->IsWebGL2() && dstFormat->d) {
-    mContext->ErrorInvalidOperation(
-        "Function may not be called on a texture of"
-        " format %s.",
-        dstFormat->name);
-    return;
-  }
-
-  ////////////////////////////////////
-  // Get source info
-
-  const webgl::FormatUsageInfo* srcUsage;
-  uint32_t srcTotalWidth;
-  uint32_t srcTotalHeight;
-  if (!mContext->BindCurFBForColorRead(&srcUsage, &srcTotalWidth,
-                                       &srcTotalHeight)) {
-    return;
-  }
-
-  if (!ValidateCopyTexImageForFeedback(*mContext, *this,
-                                       AssertedCast<uint8_t>(level),
-                                       AssertedCast<uint32_t>(zOffset)))
-    return;
-
-  ////////////////////////////////////
-  // Check that source and dest info are compatible
-
-  auto srcFormat = srcUsage->format;
-  if (!ValidateCopyTexImageFormats(mContext, srcFormat, dstFormat)) return;
-
-  ////////////////////////////////////
-  // Do the thing!
-
-  if (!EnsureImageDataInitializedForUpload(this, target, level, xOffset,
-                                           yOffset, zOffset, width, height,
-                                           depth, imageInfo)) {
-    return;
-  }
+  // Update our specification data?
 
-  const bool isSubImage = true;
-  if (!DoCopyTexOrSubImage(mContext, isSubImage, this, target, level, x, y,
-                           srcTotalWidth, srcTotalHeight, srcUsage, xOffset,
-                           yOffset, zOffset, width, height, dstUsage)) {
-    return;
-  }
-
-  ////////////////////////////////////
-  // Update our specification data?
-}
-
-//////////////////////////////////////////////////////////////////////////////
-// Driver methods
-
-MaybeWebGLTexUnpackVariant ClientWebGLContext::From(
-    TexImageTarget target, GLsizei rawWidth, GLsizei rawHeight,
-    GLsizei rawDepth, GLint border, const TexImageSource& src) {
-  uint32_t width, height, depth;
-  if (!ValidateExtents(rawWidth, rawHeight, rawDepth, border, &width, &height,
-                       &depth)) {
-    return Nothing();
-  }
-
-  if (src.mPboOffset) {
-    return ClientFromPboOffset(this, target, width, height, depth,
-                               *(src.mPboOffset), Nothing());
-  }
-
-  if (src.mImageBitmap) {
-    return ClientFromImageBitmap(this->GetPixelStore(), target, width, height,
-                                 depth, *(src.mImageBitmap), src.mOut_error);
+  if (respecFormat) {
+    const auto uninitializedSlices = Nothing();
+    const webgl::ImageInfo newImageInfo{dstUsage, size.x, size.y, size.z,
+                                        uninitializedSlices};
+    *imageInfo = newImageInfo;
+    InvalidateCaches();
   }
-
-  if (src.mImageData) {
-    return ClientFromImageData(this, target, width, height, depth,
-                               *(src.mImageData));
-  }
-
-  if (src.mDomElem) {
-    return ClientFromDomElem(target, width, height, depth, *(src.mDomElem),
-                             src.mOut_error);
-  }
-
-  return ClientFromView(this, target, width, height, depth, src.mView,
-                        src.mViewElemOffset, src.mViewElemLengthOverride,
-                        LOCAL_GL_INVALID_OPERATION);
-}
-
-MaybeWebGLTexUnpackVariant ClientWebGLContext::FromCompressed(
-    TexImageTarget target, GLsizei rawWidth, GLsizei rawHeight,
-    GLsizei rawDepth, GLint border, const TexImageSource& src,
-    const Maybe<GLsizei>& expectedImageSize) {
-  uint32_t width, height, depth;
-  if (!ValidateExtents(rawWidth, rawHeight, rawDepth, border, &width, &height,
-                       &depth)) {
-    return Nothing();
-  }
-
-  if (src.mPboOffset) {
-    return ClientFromPboOffset(this, target, width, height, depth,
-                               *(src.mPboOffset), expectedImageSize);
-  }
-
-  return ClientFromView(this, target, width, height, depth, src.mView,
-                        src.mViewElemOffset, src.mViewElemLengthOverride,
-                        LOCAL_GL_INVALID_VALUE);
 }
 
 }  // namespace mozilla