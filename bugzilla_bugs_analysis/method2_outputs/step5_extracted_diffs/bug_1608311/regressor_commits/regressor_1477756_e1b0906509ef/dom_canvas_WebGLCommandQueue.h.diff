# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLCommandQueue.h
# Commit: e1b0906509ef
# Full Hash: e1b0906509efa6433978b9f980ec639b7eafbc6d
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Fix non-webgl CI tests. r=handyman
#   
#   * Revert some partial webgl+oop+vr code.
#   * More missing FuncScope.
#   * Fix compile errors.
# ==============================================================================

diff -r 7e2a2b1b416f -r e1b0906509ef dom/canvas/WebGLCommandQueue.h
--- a/dom/canvas/WebGLCommandQueue.h	Wed Jan 08 22:19:23 2020 +0000
+++ b/dom/canvas/WebGLCommandQueue.h	Wed Jan 08 22:19:26 2020 +0000
@@ -6,8 +6,10 @@
 #ifndef WEBGLCOMMANDQUEUE_H_
 #define WEBGLCOMMANDQUEUE_H_
 
+#include "mozilla/FunctionTypeTraits.h"
 #include "mozilla/dom/ProducerConsumerQueue.h"
 #include "mozilla/ipc/IPDLParamTraits.h"
+#include <type_traits>
 
 // Get around a bug in Clang related to __thiscall method pointers
 #if defined(_M_IX86)
@@ -25,8 +27,6 @@
 using mozilla::webgl::ProducerConsumerQueue;
 
 template <typename Derived, typename SinkType>
-struct FunctionDispatcher;
-template <typename Derived, typename SinkType>
 struct MethodDispatcher;
 
 enum CommandResult { Success, TimeExpired, QueueEmpty, Error };
@@ -84,8 +84,7 @@
                                           aCommand, aArgs...);
   }
 
-  template <>
-  PcqStatus InsertCommand<>(Command aCommand) {
+  PcqStatus InsertCommand(Command aCommand) {
     return this->mProducer->TryWaitInsert(Nothing() /* wait forever */,
                                           aCommand);
   }
@@ -202,17 +201,6 @@
     return true;
   }
 
-  template <typename ReturnType, typename... Args>
-  bool DispatchAsyncFunction(ReturnType (*aFunc)(Args...)) {
-    std::tuple<typename RemoveCV<typename RemoveReference<Args>::Type>::Type...>
-        args;
-    if (!ReadArgs(args)) {
-      return false;
-    }
-    CallFunction(aFunc, args, std::index_sequence_for<Args...>{});
-    return true;
-  }
-
   // void return value, non-const method variant
   template <typename T, typename... Args>
   bool DispatchAsyncMethod(T* aObj, void (T::*aMethod)(Args...)) {
@@ -239,19 +227,6 @@
     return true;
   }
 
-  // void return value form of above
-  template <typename... Args>
-  bool DispatchAsyncFunction(void (*aFunc)(Args...)) {
-    std::tuple<typename RemoveCV<typename RemoveReference<Args>::Type>::Type...>
-        args;
-    if (!ReadArgs(args)) {
-      return false;
-    }
-
-    CallVoidFunction(aFunc, args, std::index_sequence_for<Args...>{});
-    return true;
-  }
-
  protected:
   /**
    * Implementations will usually be something like a big switch statement
@@ -276,29 +251,19 @@
     return status;
   }
 
-  template <>
   PcqStatus CallTryRemove(std::tuple<>& aArgs,
                           std::make_integer_sequence<size_t, 0>) {
     return PcqStatus::Success;
   }
 
   template <typename T, typename MethodType, typename... Args,
-            size_t... Indices,
-            typename ReturnType =
-                typename mozilla::FunctionTypeTraits<MethodType>::ReturnType>
-  ReturnType CallMethod(T& aObj, MethodType aMethod, std::tuple<Args...>& aArgs,
-                        std::index_sequence<Indices...>) {
+            size_t... Indices, typename ReturnType>
+  std::result_of<MethodType> CallMethod(T& aObj, MethodType aMethod,
+                                        std::tuple<Args...>& aArgs,
+                                        std::index_sequence<Indices...>) {
     return (aObj.*aMethod)(std::forward<Args>(std::get<Indices>(aArgs))...);
   }
 
-  template <typename FunctionType, typename... Args, size_t... Indices,
-            typename ReturnType =
-                typename mozilla::FunctionTypeTraits<FunctionType>::ReturnType>
-  ReturnType CallFunction(FunctionType aFunc, std::tuple<Args...>& aArgs,
-                          std::index_sequence<Indices...>) {
-    return (*aFunc)(std::forward<Args>(std::get<Indices>(aArgs))...);
-  }
-
   template <typename T, typename MethodType, typename... Args,
             size_t... Indices>
   void CallVoidMethod(T& aObj, MethodType aMethod, std::tuple<Args...>& aArgs,
@@ -306,12 +271,6 @@
     (aObj.*aMethod)(std::forward<Args>(std::get<Indices>(aArgs))...);
   }
 
-  template <typename FunctionType, typename... Args, size_t... Indices>
-  void CallVoidFunction(FunctionType aFunc, std::tuple<Args...>& aArgs,
-                        std::index_sequence<Indices...>) {
-    (*aFunc)(std::forward<Args>(std::get<Indices>(aArgs))...);
-  }
-
   template <typename... Args>
   bool ReadArgs(std::tuple<Args...>& aArgs) {
     PcqStatus status = CallTryRemove(aArgs, std::index_sequence_for<Args...>{});
@@ -477,21 +436,6 @@
   }
 #endif
 
-  template <typename ReturnType, typename... Args>
-  bool DispatchSyncFunction(ReturnType (*aFunc)(Args...)) {
-    std::tuple<typename RemoveCV<typename RemoveReference<Args>::Type>::Type...>
-        args;
-    if (!BaseType::ReadArgs(args)) {
-      WriteNAK();
-      return false;
-    }
-
-    ReturnType response =
-        BaseType::CallFunction(aFunc, args, std::index_sequence_for<Args...>{});
-
-    return WriteACK(response);
-  }
-
   // __cdecl/__thiscall non-const void method variant
   template <typename T, typename... Args>
   bool DispatchSyncMethod(T& aObj, void SINK_FCN_CC (T::*aMethod)(Args...)) {
@@ -556,19 +500,6 @@
   }
 #endif
 
-  template <typename... Args>
-  bool DispatchSyncFunction(void (*aFunc)(Args...)) {
-    std::tuple<typename RemoveCV<typename RemoveReference<Args>::Type>::Type...>
-        args;
-    if (!BaseType::ReadArgs(args)) {
-      WriteNAK();
-      return false;
-    }
-
-    BaseType::CallVoidFunction(aFunc, args, std::index_sequence_for<Args...>{});
-    return WriteACK();
-  }
-
  protected:
   template <typename... Args>
   bool WriteArgs(const Args&... aArgs) {
@@ -609,36 +540,6 @@
 
 /**
  * This CommandDispatcher provides helper methods that subclasses can
- * use to dispatch sync/async commands to a function via a CommandSink.
- * See DECLARE_FUNCTION_DISPATCHER and DEFINE_FUNCTION_DISPATCHER.
- */
-template <typename Derived, typename _SinkType>
-struct FunctionDispatcher {
-  using SinkType = _SinkType;
-  template <CommandSyncType syncType>
-  struct DispatchFunction;
-
-  // Specialization for dispatching asynchronous functions
-  template <>
-  struct DispatchFunction<CommandSyncType::ASYNC> {
-    template <typename FunctionType>
-    static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, FunctionType function) {
-      return aSink.DispatchAsyncFunction(function);
-    }
-  };
-
-  // Specialization for dispatching synchronous functions
-  template <>
-  struct DispatchFunction<CommandSyncType::SYNC> {
-    template <typename FunctionType>
-    static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, FunctionType function) {
-      return aSink.DispatchSyncFunction(function);
-    }
-  };
-};
-
-/**
- * This CommandDispatcher provides helper methods that subclasses can
  * use to dispatch sync/async commands to a method via a CommandSink.
  * See DECLARE_METHOD_DISPATCHER and DEFINE_METHOD_DISPATCHER.
  */
@@ -647,46 +548,29 @@
   using SinkType = _SinkType;
   template <CommandSyncType syncType>
   struct DispatchMethod;
-
-  // Specialization for dispatching asynchronous methods
-  template <>
-  struct DispatchMethod<CommandSyncType::ASYNC> {
-    template <typename MethodType, typename ObjectType>
-    static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, MethodType mMethod,
-                                      ObjectType& aObj) {
-      return aSink.DispatchAsyncMethod(aObj, mMethod);
-    }
-  };
+  /*
+    // Specialization for dispatching asynchronous methods
+    template <CommandSyncType SyncType>
+    struct DispatchMethod {
+      template <typename MethodType, typename ObjectType>
+      static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, MethodType mMethod,
+                                        ObjectType& aObj) {
+        return aSink.DispatchMethod<SyncType>(aObj, mMethod);
+      }
+    };
 
-  // Specialization for dispatching synchronous methods
-  template <>
-  struct DispatchMethod<CommandSyncType::SYNC> {
-    template <typename MethodType, typename ObjectType>
-    static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, MethodType aMethod,
-                                      ObjectType& aObj) {
-      return aSink.DispatchSyncMethod(aObj, aMethod);
-    }
-  };
+    // Specialization for dispatching synchronous methods
+    template <>
+    struct DispatchMethod<CommandSyncType::SYNC> {
+      template <typename MethodType, typename ObjectType>
+      static MOZ_ALWAYS_INLINE bool Run(SinkType& aSink, MethodType aMethod,
+                                        ObjectType& aObj) {
+        return aSink.DispatchSyncMethod(aObj, aMethod);
+      }
+    };
+    */
 };
 
-// Declares a FunctionDispatcher with the given name and CommandSink type.
-#define DECLARE_FUNCTION_DISPATCHER(_DISPATCHER, _SINKTYPE)                \
-  struct _DISPATCHER : public FunctionDispatcher<_DISPATCHER, _SINKTYPE> { \
-    template <size_t commandId = 0>                                        \
-    static MOZ_ALWAYS_INLINE bool DispatchCommand(size_t aId) {            \
-      MOZ_ASSERT_UNREACHABLE("Unhandled command ID");                      \
-      return false;                                                        \
-    }                                                                      \
-    template <size_t commandId>                                            \
-    static MOZ_ALWAYS_INLINE bool Dispatch(SinkType& aSink);               \
-    template <size_t commandId>                                            \
-    struct FuncInfo;                                                       \
-    template <size_t commandId>                                            \
-    static constexpr CommandSyncType SyncType();                           \
-    template <typename FuncType, FuncType func>                            \
-    static constexpr size_t Id();                                          \
-  };
-
 // Declares a MethodDispatcher with the given name and CommandSink type.
 // The ObjectType is the type of the object this class will dispatch methods to.
 #define DECLARE_METHOD_DISPATCHER(_DISPATCHER, _SINKTYPE, _OBJECTTYPE)         \
@@ -710,33 +594,6 @@
 
 // Defines a handler in the given dispatcher for the command with the given
 // id.  The handler uses a CommandSink to read parameters, call the
-// given function using the given synchronization protocol, and provide
-// compile-time lookup of the ID by function.
-#define DEFINE_FUNCTION_DISPATCHER(_DISPATCHER, _ID, _FUNC, _SYNC)           \
-  template <>                                                                \
-  bool _DISPATCHER::DispatchCommand<_ID>(size_t aId, SinkType & aSink) {     \
-    return CommandDispatchDriver<_DISPATCHER>::DispatchCommandHelper(aId,    \
-                                                                     aSink); \
-  }                                                                          \
-  template <>                                                                \
-  bool _DISPATCHER::Dispatch<_ID>(SinkType & aSink) {                        \
-    return DispatchFunction<_SYNC>::Run(aSink, &_FUNC);                      \
-  }                                                                          \
-  template <>                                                                \
-  struct _DISPATCHER::FuncInfo<_ID> {                                        \
-    using FuncType = decltype(&_FUNC);                                       \
-  };                                                                         \
-  template <>                                                                \
-  constexpr CommandSyncType _DISPATCHER::SyncType<_ID>() {                   \
-    return _SYNC;                                                            \
-  }                                                                          \
-  template <>                                                                \
-  constexpr size_t _DISPATCHER::Id<decltype(&_FUNC), &_FUNC>() {             \
-    return _ID;                                                              \
-  }
-
-// Defines a handler in the given dispatcher for the command with the given
-// id.  The handler uses a CommandSink to read parameters, call the
 // given method using the given synchronization protocol, and provide
 // compile-time lookup of the ID by class method.
 #define DEFINE_METHOD_DISPATCHER(_DISPATCHER, _ID, _METHOD, _SYNC)           \