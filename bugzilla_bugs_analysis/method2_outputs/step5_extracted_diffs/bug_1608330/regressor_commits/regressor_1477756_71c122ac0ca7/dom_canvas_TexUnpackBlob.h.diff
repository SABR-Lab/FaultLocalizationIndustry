# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/TexUnpackBlob.h
# Commit: 71c122ac0ca7
# Full Hash: 71c122ac0ca73391866b1ef19f4f82bc2d28568b
# Author: David Parks <davidp99@gmail.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Initial out-of-process WebGL implementation. r=mccr8,handyman
#   
#   Splits WebGLContext into ClientWebGLContext and HostWebGLContext.  The Client enables the JS-control of a WebGL context in a content procecss while the Host executes the WebGL graphics operations (via a WebGLContext that maintains much of the existing code) in the compositor process.  At this point, the cross-process behavior is disabled -- this series of patches is an incremental step toward that final goal.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D54018
# ==============================================================================

diff -r 5cbf5bb11c58 -r 71c122ac0ca7 dom/canvas/TexUnpackBlob.h
--- a/dom/canvas/TexUnpackBlob.h	Wed Jan 08 21:52:03 2020 +0000
+++ b/dom/canvas/TexUnpackBlob.h	Wed Jan 08 22:19:14 2020 +0000
@@ -13,6 +13,7 @@
 
 namespace mozilla {
 
+class ClientWebGLContext;
 class UniqueBuffer;
 class WebGLContext;
 class WebGLTexture;
@@ -23,6 +24,14 @@
 class HTMLVideoElement;
 }  // namespace dom
 
+namespace ipc {
+template <typename T>
+struct PcqParamTraits;
+class ConsumerView;
+class ProducerView;
+struct PcqStatus;
+}  // namespace ipc
+
 namespace gfx {
 class DataSourceSurface;
 }  // namespace gfx
@@ -39,29 +48,28 @@
 
 class TexUnpackBlob {
  public:
-  const uint32_t mAlignment;
-  const uint32_t mRowLength;
-  const uint32_t mImageHeight;
-  const uint32_t mSkipPixels;
-  const uint32_t mSkipRows;
-  const uint32_t mSkipImages;
-  const uint32_t mWidth;
-  const uint32_t mHeight;
-  const uint32_t mDepth;
+  uint32_t mAlignment = 0;
+  uint32_t mRowLength = 0;
+  uint32_t mImageHeight = 0;
+  uint32_t mSkipPixels = 0;
+  uint32_t mSkipRows = 0;
+  uint32_t mSkipImages = 0;
+  uint32_t mWidth = 0;
+  uint32_t mHeight = 0;
+  uint32_t mDepth = 0;
 
-  const gfxAlphaType mSrcAlphaType;
+  gfxAlphaType mSrcAlphaType;
 
   bool mNeedsExactUpload;
 
  protected:
-  TexUnpackBlob(const WebGLContext* webgl, TexImageTarget target,
+  TexUnpackBlob(const WebGLPixelStore& pixelStore, TexImageTarget target,
                 uint32_t rowLength, uint32_t width, uint32_t height,
                 uint32_t depth, gfxAlphaType srcAlphaType);
 
- public:
-  virtual ~TexUnpackBlob() {}
+  // For IPC
+  TexUnpackBlob() {}
 
- protected:
   bool ConvertIfNeeded(WebGLContext* webgl, const uint32_t rowLength,
                        const uint32_t rowCount, WebGLTexelFormat srcFormat,
                        const uint8_t* const srcBegin, const ptrdiff_t srcStride,
@@ -71,6 +79,10 @@
                        UniqueBuffer* const out_anchoredBuffer) const;
 
  public:
+  virtual ~TexUnpackBlob() {}
+
+  virtual TexUnpackBytes* AsTexUnpackBytes() { return nullptr; }
+
   virtual bool HasData() const { return true; }
 
   virtual bool Validate(WebGLContext* webgl, const webgl::PackingInfo& pi) = 0;
@@ -88,15 +100,18 @@
 
 class TexUnpackBytes final : public TexUnpackBlob {
  public:
-  const bool mIsClientData;
-  const uint8_t* const mPtr;
-  const size_t mAvailBytes;
+  RawBuffer<const uint8_t> mPtr;
 
-  TexUnpackBytes(const WebGLContext* webgl, TexImageTarget target,
+  TexUnpackBytes(const WebGLPixelStore& pixelStore, TexImageTarget target,
                  uint32_t width, uint32_t height, uint32_t depth,
                  bool isClientData, const uint8_t* ptr, size_t availBytes);
 
-  virtual bool HasData() const override { return !mIsClientData || bool(mPtr); }
+  // For IPC
+  TexUnpackBytes() {}
+
+  TexUnpackBytes* AsTexUnpackBytes() override { return this; }
+
+  virtual bool HasData() const override { return mPtr && mPtr.Data(); }
 
   virtual bool Validate(WebGLContext* webgl,
                         const webgl::PackingInfo& pi) override;
@@ -110,11 +125,12 @@
 
 class TexUnpackImage final : public TexUnpackBlob {
  public:
-  const RefPtr<layers::Image> mImage;
+  RefPtr<layers::Image> mImage;
 
   TexUnpackImage(const WebGLContext* webgl, TexImageTarget target,
-                 uint32_t width, uint32_t height, uint32_t depth,
-                 layers::Image* image, gfxAlphaType srcAlphaType);
+                 uint32_t rowLength, uint32_t width, uint32_t height,
+                 uint32_t depth, layers::Image* image,
+                 gfxAlphaType srcAlphaType);
 
   ~TexUnpackImage();  // Prevent needing to define layers::Image in the header.
 
@@ -128,14 +144,24 @@
                              GLenum* const out_error) const override;
 };
 
+// If constructed from a surface, the surface is mapped as long as this object
+// exists.
 class TexUnpackSurface final : public TexUnpackBlob {
  public:
-  const RefPtr<gfx::DataSourceSurface> mSurf;
+  gfx::IntSize mSize;
+  gfx::SurfaceFormat mFormat;
+  RawBuffer<> mData;
+  int32_t mStride;
+  // Map may be null in host process because memory is mapped in the client
+  UniquePtr<gfx::DataSourceSurface::ScopedMap> mMap;
 
-  TexUnpackSurface(const WebGLContext* webgl, TexImageTarget target,
+  TexUnpackSurface(const WebGLPixelStore& pixelStore, TexImageTarget target,
                    uint32_t width, uint32_t height, uint32_t depth,
                    gfx::DataSourceSurface* surf, gfxAlphaType srcAlphaType);
 
+  // For PcqParamTraits
+  TexUnpackSurface() : mStride(0), mMap(nullptr) {}
+
   virtual bool Validate(WebGLContext* webgl,
                         const webgl::PackingInfo& pi) override;
   virtual bool TexOrSubImage(bool isSubImage, bool needsRespec,
@@ -147,6 +173,7 @@
 };
 
 }  // namespace webgl
+
 }  // namespace mozilla
 
 #endif  // TEX_UNPACK_BLOB_H_