# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextExtensions.cpp
# Commit: 71c122ac0ca7
# Full Hash: 71c122ac0ca73391866b1ef19f4f82bc2d28568b
# Author: David Parks <davidp99@gmail.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Initial out-of-process WebGL implementation. r=mccr8,handyman
#   
#   Splits WebGLContext into ClientWebGLContext and HostWebGLContext.  The Client enables the JS-control of a WebGL context in a content procecss while the Host executes the WebGL graphics operations (via a WebGLContext that maintains much of the existing code) in the compositor process.  At this point, the cross-process behavior is disabled -- this series of patches is an incremental step toward that final goal.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D54018
# ==============================================================================

diff -r 5cbf5bb11c58 -r 71c122ac0ca7 dom/canvas/WebGLContextExtensions.cpp
--- a/dom/canvas/WebGLContextExtensions.cpp	Wed Jan 08 21:52:03 2020 +0000
+++ b/dom/canvas/WebGLContextExtensions.cpp	Wed Jan 08 22:19:14 2020 +0000
@@ -4,8 +4,10 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WebGLContext.h"
+#include "WebGLContextEndpoint.h"
 #include "WebGLContextUtils.h"
 #include "WebGLExtensions.h"
+#include "ClientWebGLExtensions.h"
 #include "GLContext.h"
 
 #include "nsString.h"
@@ -16,7 +18,8 @@
 
 namespace mozilla {
 
-/*static*/ const char* WebGLContext::GetExtensionString(WebGLExtensionID ext) {
+/*static*/ const char* ClientWebGLContext::GetExtensionString(
+    WebGLExtensionID ext) {
   typedef EnumeratedArray<WebGLExtensionID, WebGLExtensionID::Max, const char*>
       names_array_t;
 
@@ -275,12 +278,12 @@
   return extension;
 }
 
-void WebGLContext::GetExtension(JSContext* cx, const nsAString& wideName,
-                                JS::MutableHandle<JSObject*> retval,
-                                dom::CallerType callerType, ErrorResult& rv) {
+void ClientWebGLContext::GetExtension(JSContext* cx, const nsAString& wideName,
+                                      JS::MutableHandle<JSObject*> retval,
+                                      dom::CallerType callerType,
+                                      ErrorResult& rv) {
   retval.set(nullptr);
-  const FuncScope funcScope(*this, "getExtension");
-  if (IsContextLost()) return;
+  const FuncScope funcScope(this, "getExtension");
 
   NS_LossyConvertUTF16toASCII name(wideName);
 
@@ -298,15 +301,12 @@
 
   if (ext == WebGLExtensionID::Max) return;
 
-  // step 2: check if the extension is supported
-  if (!IsExtensionSupported(callerType, ext)) return;
-
-  // step 3: if the extension hadn't been previously been created, create it
-  // now, thus enabling it
-  WebGLExtensionBase* extObj = EnableSupportedExtension(callerType, ext);
+  // step 2: if the extension hadn't been previously been created then we
+  // have to tell the host we are using it
+  ClientWebGLExtensionBase* extObj = GetExtension(callerType, ext, true);
   if (!extObj) return;
 
-  // Step 4: Enable any implied extensions.
+  // Step 3: Enable any implied extensions.
   switch (ext) {
     case WebGLExtensionID::EXT_color_buffer_float:
       EnableSupportedExtension(callerType, WebGLExtensionID::EXT_float_blend,
@@ -337,7 +337,7 @@
   retval.set(WebGLObjectAsJSObject(cx, extObj, rv));
 }
 
-void WebGLContext::EnableExtension(WebGLExtensionID ext) {
+void WebGLContext::CreateExtension(WebGLExtensionID ext) {
   MOZ_ASSERT(IsExtensionEnabled(ext) == false);
 
   WebGLExtensionBase* obj = nullptr;
@@ -466,23 +466,100 @@
   mExtensions[ext] = obj;
 }
 
-void WebGLContext::GetSupportedExtensions(
-    dom::Nullable<nsTArray<nsString> >& retval, dom::CallerType callerType) {
-  retval.SetNull();
+const Maybe<ExtensionSets> WebGLContext::GetSupportedExtensions() {
   const FuncScope funcScope(*this, "getSupportedExtensions");
-  if (IsContextLost()) return;
+  if (IsContextLost()) return Nothing();
 
-  nsTArray<nsString>& arr = retval.SetValue();
-
+  Maybe<ExtensionSets> ret = Some(ExtensionSets());
+  auto& sets = ret.ref();
   for (size_t i = 0; i < size_t(WebGLExtensionID::Max); i++) {
     const auto extension = WebGLExtensionID(i);
-    if (extension == WebGLExtensionID::MOZ_debug)
-      continue;  // Hide MOZ_debug from this list.
+    if (IsExtensionSupported(dom::CallerType::NonSystem, extension)) {
+      sets.mNonSystem.AppendElement(extension);
+    } else if (IsExtensionSupported(dom::CallerType::System, extension)) {
+      sets.mSystem.AppendElement(extension);
+    }
+  }
+  return ret;
+}
+
+ClientWebGLExtensionBase* ClientWebGLContext::UseExtension(
+    WebGLExtensionID ext) {
+  switch (ext) {
+    // ANGLE_
+    case WebGLExtensionID::ANGLE_instanced_arrays:
+      return new ClientWebGLExtensionInstancedArrays(this);
+
+    // EXT_
+    case WebGLExtensionID::EXT_blend_minmax:
+      return new ClientWebGLExtensionBlendMinMax(this);
+    case WebGLExtensionID::EXT_color_buffer_float:
+      return new ClientWebGLExtensionEXTColorBufferFloat(this);
+    case WebGLExtensionID::EXT_color_buffer_half_float:
+      return new ClientWebGLExtensionColorBufferHalfFloat(this);
+    case WebGLExtensionID::EXT_disjoint_timer_query:
+      return new ClientWebGLExtensionDisjointTimerQuery(this);
+    case WebGLExtensionID::EXT_frag_depth:
+      return new ClientWebGLExtensionFragDepth(this);
+    case WebGLExtensionID::EXT_shader_texture_lod:
+      return new ClientWebGLExtensionShaderTextureLod(this);
+    case WebGLExtensionID::EXT_sRGB:
+      return new ClientWebGLExtensionSRGB(this);
+    case WebGLExtensionID::EXT_texture_compression_bptc:
+      return new ClientWebGLExtensionCompressedTextureBPTC(this);
+    case WebGLExtensionID::EXT_texture_compression_rgtc:
+      return new ClientWebGLExtensionCompressedTextureRGTC(this);
+    case WebGLExtensionID::EXT_texture_filter_anisotropic:
+      return new ClientWebGLExtensionTextureFilterAnisotropic(this);
+
+    // MOZ_
+    case WebGLExtensionID::MOZ_debug:
+      return new ClientWebGLExtensionMOZDebug(this);
 
-    if (IsExtensionSupported(callerType, extension)) {
-      const char* extStr = GetExtensionString(extension);
-      arr.AppendElement(NS_ConvertUTF8toUTF16(extStr));
-    }
+    // OES_
+    case WebGLExtensionID::OES_element_index_uint:
+      return new ClientWebGLExtensionElementIndexUint(this);
+    case WebGLExtensionID::OES_standard_derivatives:
+      return new ClientWebGLExtensionStandardDerivatives(this);
+    case WebGLExtensionID::OES_texture_float:
+      return new ClientWebGLExtensionTextureFloat(this);
+    case WebGLExtensionID::OES_texture_float_linear:
+      return new ClientWebGLExtensionTextureFloatLinear(this);
+    case WebGLExtensionID::OES_texture_half_float:
+      return new ClientWebGLExtensionTextureHalfFloat(this);
+    case WebGLExtensionID::OES_texture_half_float_linear:
+      return new ClientWebGLExtensionTextureHalfFloatLinear(this);
+    case WebGLExtensionID::OES_vertex_array_object:
+      return new ClientWebGLExtensionVertexArray(this);
+
+    // WEBGL_
+    case WebGLExtensionID::WEBGL_color_buffer_float:
+      return new ClientWebGLExtensionColorBufferFloat(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_astc:
+      return new ClientWebGLExtensionCompressedTextureASTC(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_etc:
+      return new ClientWebGLExtensionCompressedTextureES3(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_etc1:
+      return new ClientWebGLExtensionCompressedTextureETC1(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_pvrtc:
+      return new ClientWebGLExtensionCompressedTexturePVRTC(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_s3tc:
+      return new ClientWebGLExtensionCompressedTextureS3TC(this);
+    case WebGLExtensionID::WEBGL_compressed_texture_s3tc_srgb:
+      return new ClientWebGLExtensionCompressedTextureS3TC_SRGB(this);
+    case WebGLExtensionID::WEBGL_debug_renderer_info:
+      return new ClientWebGLExtensionDebugRendererInfo(this);
+    case WebGLExtensionID::WEBGL_debug_shaders:
+      return new ClientWebGLExtensionDebugShaders(this);
+    case WebGLExtensionID::WEBGL_depth_texture:
+      return new ClientWebGLExtensionDepthTexture(this);
+    case WebGLExtensionID::WEBGL_draw_buffers:
+      return new ClientWebGLExtensionDrawBuffers(this);
+    case WebGLExtensionID::WEBGL_lose_context:
+      return new ClientWebGLExtensionLoseContext(this);
+    default:
+      MOZ_ASSERT_UNREACHABLE("illegal extension enum");
+      return nullptr;
   }
 }
 