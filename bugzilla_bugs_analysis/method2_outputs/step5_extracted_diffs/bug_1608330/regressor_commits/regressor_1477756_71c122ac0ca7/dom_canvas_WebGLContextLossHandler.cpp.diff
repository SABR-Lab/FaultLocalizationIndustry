# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextLossHandler.cpp
# Commit: 71c122ac0ca7
# Full Hash: 71c122ac0ca73391866b1ef19f4f82bc2d28568b
# Author: David Parks <davidp99@gmail.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Initial out-of-process WebGL implementation. r=mccr8,handyman
#   
#   Splits WebGLContext into ClientWebGLContext and HostWebGLContext.  The Client enables the JS-control of a WebGL context in a content procecss while the Host executes the WebGL graphics operations (via a WebGLContext that maintains much of the existing code) in the compositor process.  At this point, the cross-process behavior is disabled -- this series of patches is an incremental step toward that final goal.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D54018
# ==============================================================================

diff -r 5cbf5bb11c58 -r 71c122ac0ca7 dom/canvas/WebGLContextLossHandler.cpp
--- a/dom/canvas/WebGLContextLossHandler.cpp	Wed Jan 08 21:52:03 2020 +0000
+++ b/dom/canvas/WebGLContextLossHandler.cpp	Wed Jan 08 22:19:14 2020 +0000
@@ -4,100 +4,40 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WebGLContextLossHandler.h"
-
-#include "mozilla/DebugOnly.h"
-#include "nsINamed.h"
-#include "nsISupportsImpl.h"
-#include "nsITimer.h"
-#include "nsThreadUtils.h"
 #include "WebGLContext.h"
 
 namespace mozilla {
 
-class WatchdogTimerEvent final : public nsITimerCallback, public nsINamed {
-  const WeakPtr<WebGLContextLossHandler> mHandler;
-
- public:
-  NS_DECL_ISUPPORTS
-
-  explicit WatchdogTimerEvent(WebGLContextLossHandler* handler)
-      : mHandler(handler) {}
-
-  NS_IMETHOD GetName(nsACString& aName) override {
-    aName.AssignLiteral("WatchdogTimerEvent");
-    return NS_OK;
+void MaybeUpdateContextLoss(WeakPtr<WebGLContext> weakCxt) {
+  RefPtr<WebGLContext> cxt = weakCxt.get();
+  if (!cxt) {
+    return;
   }
-
- private:
-  virtual ~WatchdogTimerEvent() {}
-
-  NS_IMETHOD Notify(nsITimer*) override {
-    if (mHandler) {
-      mHandler->TimerCallback();
-    }
-    return NS_OK;
-  }
-};
-
-NS_IMPL_ISUPPORTS(WatchdogTimerEvent, nsITimerCallback, nsINamed)
-
-////////////////////////////////////////
-
-WebGLContextLossHandler::WebGLContextLossHandler(WebGLContext* webgl)
-    : mWebGL(webgl),
-      mTimer(NS_NewTimer()),
-      mTimerPending(false),
-      mShouldRunTimerAgain(false)
-#ifdef DEBUG
-      ,
-      mEventTarget(GetCurrentThreadSerialEventTarget())
-#endif
-{
-  MOZ_ASSERT(mEventTarget);
+  cxt->UpdateContextLossStatus();
 }
 
-WebGLContextLossHandler::~WebGLContextLossHandler() {
-  const DebugOnly<nsISerialEventTarget*> callingThread =
-      GetCurrentThreadSerialEventTarget();
-  MOZ_ASSERT(!callingThread || mEventTarget->IsOnCurrentThread());
+WebGLContextLossHandler::WebGLContextLossHandler(WebGLContext* webgl) {
+  MOZ_ASSERT(webgl);
+  WeakPtr<WebGLContext> weakCxt = webgl;
+  mRunnable = NS_NewRunnableFunction("WebGLContextLossHandler", [weakCxt]() {
+    MaybeUpdateContextLoss(weakCxt);
+  });
+  MOZ_ASSERT(mRunnable);
 }
 
+WebGLContextLossHandler::~WebGLContextLossHandler() {}
+
 ////////////////////
 
 void WebGLContextLossHandler::RunTimer() {
-  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
-
-  // If the timer was already running, don't restart it here. Instead,
-  // wait until the previous call is done, then fire it one more time.
-  // This is also an optimization to prevent unnecessary
-  // cross-communication between threads.
-  if (mTimerPending) {
-    mShouldRunTimerAgain = true;
-    return;
-  }
-
-  const RefPtr<WatchdogTimerEvent> event = new WatchdogTimerEvent(this);
   const uint32_t kDelayMS = 1000;
-  mTimer->InitWithCallback(event, kDelayMS, nsITimer::TYPE_ONE_SHOT);
-
-  mTimerPending = true;
-}
-
-////////////////////
-
-void WebGLContextLossHandler::TimerCallback() {
-  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
-
-  mTimerPending = false;
-
-  const bool runOnceMore = mShouldRunTimerAgain;
-  mShouldRunTimerAgain = false;
-
-  mWebGL->UpdateContextLossStatus();
-
-  if (runOnceMore && !mTimerPending) {
-    RunTimer();
+  MOZ_ASSERT(MessageLoop::current());
+  // Only create a new task if one isn't already queued.
+  if (mTimerIsScheduled.compareExchange(false, true)) {
+    MessageLoop::current()->PostDelayedTask(do_AddRef(mRunnable), kDelayMS);
   }
 }
 
+void WebGLContextLossHandler::ClearTimer() { mTimerIsScheduled = false; }
+
 }  // namespace mozilla