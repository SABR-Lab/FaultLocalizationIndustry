# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLValidateStrings.cpp
# Commit: 7e2a2b1b416f
# Full Hash: 7e2a2b1b416f1a64c6548aab29e92acc9554ae7d
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Fix all webgl regression tests according to CI. r=handyman
#   
#   (This is a combination of 31 commits)
#   
#   * Fix Linux compilation.
# ==============================================================================

diff -r ccfa767dba64 -r 7e2a2b1b416f dom/canvas/WebGLValidateStrings.cpp
--- a/dom/canvas/WebGLValidateStrings.cpp	Wed Jan 08 22:19:16 2020 +0000
+++ b/dom/canvas/WebGLValidateStrings.cpp	Wed Jan 08 22:19:23 2020 +0000
@@ -7,93 +7,84 @@
 
 #include "WebGLContext.h"
 
+#include <regex>
+
 namespace mozilla {
 
-bool TruncateComments(const nsAString& src, nsAString* const out) {
-  const size_t dstByteCount = src.Length() * sizeof(src[0]);
-  const UniqueBuffer dst(malloc(dstByteCount));
-  if (!dst) return false;
+/* GLSL ES 3.00 p17:
+  - Comments are delimited by / * and * /, or by // and a newline.
+
+  - '//' style comments include the initial '//' marker and continue up to, but
+not including, the terminating newline.
 
-  auto srcItr = src.BeginReading();
-  const auto srcEnd = src.EndReading();
-  const auto dstBegin = (decltype(src[0])*)dst.get();
-  auto dstItr = dstBegin;
+  - '/ * ... * /' comments include both the start and end marker.
 
-  const auto fnEmitUntil = [&](const decltype(srcItr)& nextSrcItr) {
-    while (srcItr != nextSrcItr) {
-      *dstItr = *srcItr;
-      ++srcItr;
-      ++dstItr;
-    }
-  };
+  - The begin comment delimiters (/ * or //) are not recognized as comment
+delimiters inside of a comment, hence comments cannot be nested.
+
+  - Comments are treated syntactically as a single space.
 
-  const auto fnFindSoonestOf = [&](const nsString* needles, size_t needleCount,
-                                   size_t* const out_foundId) {
-    auto foundItr = srcItr;
-    while (foundItr != srcEnd) {
-      const auto haystack = Substring(foundItr, srcEnd);
-      for (size_t i = 0; i < needleCount; i++) {
-        if (StringBeginsWith(haystack, needles[i])) {
-          *out_foundId = i;
-          return foundItr;
-        }
-      }
-      ++foundItr;
-    }
-    *out_foundId = needleCount;
-    return foundItr;
-  };
+However, since we want to keep line/character numbers the same, replace
+char-for-char with spaces and newlines.
+*/
 
-  ////
+std::string CommentsToSpaces(const std::string& src) {
+// `[^]` is any-including-newline
+// `*?` is non-greedy `*`, matching the fewest characters, instead of the most.
+// `??` is non-greedy `?`, preferring to match zero times, instead of once.
+// Non-continuing line comment is: `//[^]*?\n`
+// But line-continuation is `\\\n`
+// So we need to match `//[^]*?[^\\]\n`
+// But we need to recognize "//\n", thus: `//([^]*?[^\\])??\n`
+#define LINE_COMMENT "//(?:[^]*?[^\\\\])??\n"
+
+// The fewest characters that match /*...*/
+#define BLOCK_COMMENT "/[*][^]*?[*]/"
 
-  const nsString commentBeginnings[] = {NS_LITERAL_STRING("//"),
-                                        NS_LITERAL_STRING("/*"),
-                                        nsString()};  // Final empty string for
-                                                      // "found nothing".
-  const nsString lineCommentEndings[] = {NS_LITERAL_STRING("\\\n"),
-                                         NS_LITERAL_STRING("\n"), nsString()};
-  const nsString blockCommentEndings[] = {NS_LITERAL_STRING("\n"),
-                                          NS_LITERAL_STRING("*/"), nsString()};
+  static const std::regex COMMENT_RE(
+      "(?:" LINE_COMMENT ")|(?:" BLOCK_COMMENT ")",
+      std::regex::ECMAScript | std::regex::nosubs | std::regex::optimize);
+
+#undef LINE_COMMENT
+#undef BLOCK_COMMENT
+
+  static const std::regex TRAILING_RE("/[*/]", std::regex::ECMAScript |
+                                                   std::regex::nosubs |
+                                                   std::regex::optimize);
+
+  std::string ret;
+  ret.reserve(src.size());
 
-  while (srcItr != srcEnd) {
-    size_t foundId;
-    fnEmitUntil(fnFindSoonestOf(commentBeginnings, 2, &foundId));
-    fnEmitUntil(srcItr +
-                commentBeginnings[foundId].Length());  // Final empty string
-                                                       // allows us to skip
-                                                       // forward here
-                                                       // unconditionally.
-    switch (foundId) {
-      case 0:  // line comment
-        while (true) {
-          size_t endId;
-          srcItr = fnFindSoonestOf(lineCommentEndings, 2, &endId);
-          fnEmitUntil(srcItr + lineCommentEndings[endId].Length());
-          if (endId == 0) continue;
+  auto itr = src.begin();
+  auto end = src.end();
+  std::smatch match;
+  while (std::regex_search(itr, end, match, COMMENT_RE)) {
+    const auto matchBegin = itr + match.position();
+    const auto matchEnd = matchBegin + match.length();
+    ret.append(itr, matchBegin);
+    for (itr = matchBegin; itr != matchEnd; ++itr) {
+      auto cur = *itr;
+      switch (cur) {
+        case '/':
+        case '*':
+        case '\n':
+        case '\\':
           break;
-        }
-        break;
-
-      case 1:  // block comment
-        while (true) {
-          size_t endId;
-          srcItr = fnFindSoonestOf(blockCommentEndings, 2, &endId);
-          fnEmitUntil(srcItr + blockCommentEndings[endId].Length());
-          if (endId == 0) continue;
+        default:
+          cur = ' ';
           break;
-        }
-        break;
-
-      default:  // not found
-        break;
+      }
+      ret += cur;
     }
   }
 
-  MOZ_ASSERT((dstBegin + 1) - dstBegin == 1);
-  const uint32_t dstCharLen = dstItr - dstBegin;
-  if (!out->Assign(dstBegin, dstCharLen, mozilla::fallible)) return false;
-
-  return true;
+  // Check for a trailing comment that hits EOF instead of the end of the
+  // comment.
+  if (std::regex_search(itr, end, match, TRAILING_RE)) {
+    end = itr + match.position();
+  }
+  ret.append(itr, end);
+  return ret;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -143,69 +134,49 @@
   }
 }
 
-static bool IsValidGLSLPreprocChar(const char c) {
-  if (IsValidGLSLChar(c)) return true;
-
-  switch (c) {
-    case '\\':
-    case '#':
-      return true;
-
-    default:
-      return false;
-  }
-}
-
 ////
 
-bool ValidateGLSLPreprocString(WebGLContext* webgl, const std::string& string) {
-  for (const auto cur : string) {
-    if (!IsValidGLSLPreprocChar(cur)) {
-      webgl->ErrorInvalidValue("String contains the illegal character 0x%x.",
-                               cur);
-      return false;
-    }
+Maybe<char> CheckGLSLPreprocString(const bool webgl2,
+                                   const std::string& string) {
+  for (const auto c : string) {
+    if (IsValidGLSLChar(c)) continue;
+    if (c == '#') continue;
+    if (c == '\\' && webgl2) continue;
 
-    if (cur == '\\' && !webgl->IsWebGL2()) {
-      // Todo: Backslash is technically still invalid in WebGLSL 1 under even
-      // under WebGL 2.
-      webgl->ErrorInvalidValue("Backslash is not valid in WebGL 1.");
-      return false;
-    }
+    return Some(c);
   }
-
-  return true;
+  return {};
 }
 
-bool ValidateGLSLVariableName(const std::string& name, WebGLContext* webgl) {
-  if (name.empty()) return false;
+Maybe<webgl::ErrorInfo> CheckGLSLVariableName(const bool webgl2,
+                                              const std::string& name) {
+  if (name.empty()) return {};
 
-  const uint32_t maxSize = webgl->IsWebGL2() ? 1024 : 256;
+  const uint32_t maxSize = webgl2 ? 1024 : 256;
   if (name.size() > maxSize) {
-    webgl->ErrorInvalidValue(
-        "Identifier is %tu characters long, exceeds the"
+    const auto info = nsPrintfCString(
+        "Identifier is %zu characters long, exceeds the"
         " maximum allowed length of %u characters.",
         name.size(), maxSize);
-    return false;
+    return Some(webgl::ErrorInfo{LOCAL_GL_INVALID_VALUE, info.BeginReading()});
   }
 
   for (const auto cur : name) {
     if (!IsValidGLSLChar(cur)) {
-      webgl->ErrorInvalidValue("String contains the illegal character 0x%x'.",
-                               cur);
-      return false;
+      const auto info =
+          nsPrintfCString("String contains the illegal character 0x%x'.", cur);
+      return Some(
+          webgl::ErrorInfo{LOCAL_GL_INVALID_VALUE, info.BeginReading()});
     }
   }
 
-  nsString prefix1 = NS_LITERAL_STRING("webgl_");
-  nsString prefix2 = NS_LITERAL_STRING("_webgl_");
-
   if (name.find("webgl_") == 0 || name.find("_webgl_") == 0) {
-    webgl->ErrorInvalidOperation("String contains a reserved GLSL prefix.");
-    return false;
+    return Some(webgl::ErrorInfo{
+        LOCAL_GL_INVALID_OPERATION,
+        "String matches reserved GLSL prefix pattern /_?webgl_/."});
   }
 
-  return true;
+  return {};
 }
 
 }  // namespace mozilla