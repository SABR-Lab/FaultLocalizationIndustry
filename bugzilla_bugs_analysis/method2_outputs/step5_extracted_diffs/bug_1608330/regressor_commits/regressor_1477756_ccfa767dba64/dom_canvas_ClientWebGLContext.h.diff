# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/ClientWebGLContext.h
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/ClientWebGLContext.h
--- a/dom/canvas/ClientWebGLContext.h	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/ClientWebGLContext.h	Wed Jan 08 22:19:16 2020 +0000
@@ -8,20 +8,25 @@
 
 #include "GLConsts.h"
 #include "mozilla/dom/ImageData.h"
+#include "mozilla/Range.h"
+#include "mozilla/RefCounted.h"
 #include "nsICanvasRenderingContextInternal.h"
 #include "nsWeakReference.h"
 #include "nsWrapperCache.h"
-#include "WebGLActiveInfo.h"
-#include "WebGLContextEndpoint.h"
 #include "mozilla/dom/WebGLRenderingContextBinding.h"
 #include "mozilla/dom/WebGL2RenderingContextBinding.h"
-#include "WebGLShaderPrecisionFormat.h"
+#include "WebGLFormats.h"
 #include "WebGLStrongTypes.h"
 #include "WebGLTypes.h"
 
 #include "mozilla/Logging.h"
 #include "WebGLCrossProcessCommandQueue.h"
 
+#include <memory>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
 #ifndef WEBGL_BRIDGE_LOG_
 #  define WEBGL_BRIDGE_LOG_(lvl, ...) \
     MOZ_LOG(mozilla::gWebGLBridgeLog, lvl, (__VA_ARGS__))
@@ -34,6 +39,8 @@
 
 namespace mozilla {
 
+class ClientWebGLExtensionBase;
+
 namespace dom {
 class WebGLChild;
 }
@@ -47,172 +54,524 @@
 class TexUnpackBytes;
 }  // namespace webgl
 
-extern LazyLogModule gWebGLBridgeLog;
+////////////////////////////////////
 
-class ClientWebGLExtensionBase;
-class ClientWebGLErrorSink;
-
-void DrainWebGLError(nsWeakPtr aWeakContext);
-
-class ClientWebGLRefCount : public nsWrapperCache {
+class WebGLActiveInfoJS final : public RefCounted<WebGLActiveInfoJS> {
  public:
-  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING_VIRTUAL(
-      ClientWebGLRefCount)
-  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(ClientWebGLRefCount)
- protected:
-  virtual ~ClientWebGLRefCount() {}
-};
+  MOZ_DECLARE_REFCOUNTED_TYPENAME(WebGLActiveInfoJS)
+
+  const webgl::ActiveInfo mInfo;
+
+  explicit WebGLActiveInfoJS(const webgl::ActiveInfo& info) : mInfo(info) {}
+
+  virtual ~WebGLActiveInfoJS() = default;
 
-/**
- * The client-side representation of WebGL types is little more than
- * an ID and a ref-count.
- */
-template <typename WebGLType>
-class ClientWebGLObject : public WebGLId<WebGLType>,
-                          public ClientWebGLRefCount {
- public:
-  ClientWebGLContext* GetParentObject() const { return GetContext(); }
+  // -
+  // WebIDL attributes
 
-  bool IsValidForContext(ClientWebGLContext* aContext) const {
-    auto context = GetContext();
-    return context && (context == aContext) &&
-           (mGeneration == aContext->Generation());
+  GLint Size() const { return static_cast<GLint>(mInfo.elemCount); }
+  GLenum Type() const { return mInfo.elemType; }
+
+  void GetName(nsString& retval) const {
+    retval = NS_ConvertUTF8toUTF16(mInfo.name.c_str());
   }
 
-  MozExternalRefCountType AddRef() override {
-    if (mLogMe) {
-      WEBGL_BRIDGE_LOGD("[%p] AddRefing WebGLObject %d from %d to %d", this,
-                        (int)WebGLId<WebGLType>::Id(),
-                        static_cast<int32_t>(mRefCnt),
-                        static_cast<int32_t>(mRefCnt) + 1);
-    }
-    return ClientWebGLRefCount::AddRef();
+  bool WrapObject(JSContext*, JS::Handle<JSObject*>,
+                  JS::MutableHandle<JSObject*>);
+};
+
+class WebGLShaderPrecisionFormatJS final
+    : public RefCounted<WebGLShaderPrecisionFormatJS> {
+ public:
+  MOZ_DECLARE_REFCOUNTED_TYPENAME(WebGLShaderPrecisionFormatJS)
+
+  const webgl::ShaderPrecisionFormat mInfo;
+
+  explicit WebGLShaderPrecisionFormatJS(
+      const webgl::ShaderPrecisionFormat& info)
+      : mInfo(info) {}
+
+  virtual ~WebGLShaderPrecisionFormatJS() = default;
+
+  GLint RangeMin() const { return mInfo.rangeMin; }
+  GLint RangeMax() const { return mInfo.rangeMax; }
+  GLint Precision() const { return mInfo.precision; }
+
+  bool WrapObject(JSContext*, JS::Handle<JSObject*>,
+                  JS::MutableHandle<JSObject*>);
+};
+
+// -----------------------
+
+struct WebGLProgramInner;
+class WebGLBufferJS;
+class WebGLFramebufferJS;
+class WebGLQueryJS;
+class WebGLRenderbufferJS;
+class WebGLSamplerJS;
+class WebGLTextureJS;
+class WebGLTransformFeedbackJS;
+class WebGLVertexArrayJS;
+
+namespace webgl {
+
+struct LinkResult;
+
+class ContextGenerationInfo final {
+ public:
+  ClientWebGLContext& mContext;
+
+ private:
+  ObjectId mLastId = 0;
+
+ public:
+  webgl::ExtensionBits mEnabledExtensions;
+  mutable std::shared_ptr<webgl::LinkResult> mActiveLinkResult;
+  RefPtr<WebGLProgramInner> mCurrentProgram;
+
+  RefPtr<WebGLTransformFeedbackJS> mDefaultTfo;
+  RefPtr<WebGLVertexArrayJS> mDefaultVao;
+
+  std::unordered_map<GLenum, RefPtr<WebGLBufferJS>> mBoundBufferByTarget;
+  std::vector<RefPtr<WebGLBufferJS>> mBoundUbos;
+  RefPtr<WebGLFramebufferJS> mBoundDrawFb;
+  RefPtr<WebGLFramebufferJS> mBoundReadFb;
+  RefPtr<WebGLRenderbufferJS> mBoundRb;
+  RefPtr<WebGLTransformFeedbackJS> mBoundTfo;
+  RefPtr<WebGLVertexArrayJS> mBoundVao;
+  std::unordered_map<GLenum, RefPtr<WebGLQueryJS>> mCurrentQueryByTarget;
+
+  struct TexUnit final {
+    RefPtr<WebGLSamplerJS> sampler;
+    std::unordered_map<GLenum, RefPtr<WebGLTextureJS>> texByTarget;
+  };
+  uint32_t mActiveTexUnit = 0;
+  std::vector<TexUnit> mTexUnits;
+
+  bool mTfActiveAndNotPaused = false;
+
+  std::vector<TypedQuad> mGenericVertexAttribs;
+
+  std::array<bool, 4> mColorWriteMask = {true, true, true, true};
+  std::array<int32_t, 4> mScissor = {};
+  std::array<int32_t, 4> mViewport = {};
+  std::array<float, 4> mClearColor = {1, 1, 1, 1};
+  std::array<float, 4> mBlendColor = {1, 1, 1, 1};
+  std::array<float, 2> mDepthRange = {0, 1};
+
+  std::vector<GLenum> mCompressedTextureFormats;
+
+ public:
+  explicit ContextGenerationInfo(ClientWebGLContext& context);
+  ~ContextGenerationInfo();
+
+  ObjectId NextId() { return mLastId += 1; }
+};
+
+class ObjectJS {
+  friend ClientWebGLContext;
+
+ public:
+  const std::weak_ptr<ContextGenerationInfo> mGeneration;
+  const ObjectId mId;
+
+ protected:
+  bool mDeleteRequested = false;
+
+  explicit ObjectJS(const ClientWebGLContext&);
+  virtual ~ObjectJS() = default;
+
+ public:
+  ClientWebGLContext* Context() const {
+    const auto locked = mGeneration.lock();
+    if (!locked) return nullptr;
+    return &(locked->mContext);
   }
 
-  MozExternalRefCountType Release() override {
-    // If we are deleting the object, let the host know that it can, too.
-    if (mLogMe) {
-      WEBGL_BRIDGE_LOGD("[%p] Releasing WebGLObject %d from %d to %d", this,
-                        (int)WebGLId<WebGLType>::Id(),
-                        static_cast<int32_t>(mRefCnt),
-                        static_cast<int32_t>(mRefCnt) - 1);
-    }
+  ClientWebGLContext* GetParentObject() const { return Context(); }
+
+  bool IsUsable(const ClientWebGLContext&) const;
+
+  bool ValidateUsable(const ClientWebGLContext& context,
+                      const char* const argName) const {
+    if (MOZ_LIKELY(IsUsable(context))) return true;
+    WarnInvalidUse(context, argName);
+    return false;
+  }
+
+ private:
+  void WarnInvalidUse(const ClientWebGLContext&, const char* argName) const;
+
+ public:
+  virtual bool IsDeleted() const { return mDeleteRequested; }
+};
+
+}  // namespace webgl
+
+// -------------------------
+
+class WebGLBufferJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  webgl::BufferKind mKind =
+      webgl::BufferKind::Undefined;  // !IsBuffer until Bind
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLBufferJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLBufferJS)
+
+  explicit WebGLBufferJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+
+ private:
+  ~WebGLBufferJS() = default;
 
-    auto context = GetContext();
-    // If the context is still around then it has a reference to us that we
-    // should release it also via ReleaseWebGLObject when it is the last one
-    // left (so, this call would be going from 2 to 1).  If the context is
-    // gone then so is that reference, so we delete when we go from 1 to 0.
-    int32_t refCountToDeleteAt = context ? 2 : 1;
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLFramebufferJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+ public:
+  struct Attachment final {
+    RefPtr<WebGLRenderbufferJS> rb;
+    RefPtr<WebGLTextureJS> tex;
+  };
+
+ private:
+  bool mHasBeenBound = false;  // !IsFramebuffer until Bind
+  std::unordered_map<GLenum, Attachment> mAttachments;
 
-    if (static_cast<int32_t>(mRefCnt) == refCountToDeleteAt) {
-      // Must release first to avoid an infinite loop
-      bool ret = ClientWebGLRefCount::Release();
-      if (context) {
-        // This will release us again.
-        context->ReleaseWebGLObject(this);
-      }
-      return ret;
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLFramebufferJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLFramebufferJS)
+
+  explicit WebGLFramebufferJS(const ClientWebGLContext&);
+
+ private:
+  ~WebGLFramebufferJS() = default;
+
+  void EnsureColorAttachments();
+
+ public:
+  Attachment* GetAttachment(const GLenum slotEnum) {
+    auto ret = MaybeFind(mAttachments, slotEnum);
+    if (!ret) {
+      EnsureColorAttachments();
+      ret = MaybeFind(mAttachments, slotEnum);
     }
-    return ClientWebGLRefCount::Release();
+    return ret;
   }
 
-  ClientWebGLObject(uint64_t aId, ClientWebGLContext* aContext)
-      : WebGLId<WebGLType>(aId),
-        mGeneration(aContext->Generation()),
-        mLogMe(sLogMe) {
-    if (mLogMe) {
-      WEBGL_BRIDGE_LOGD("[%p] Created WebGLObject %d", this,
-                        WebGLId<WebGLType>::Id());
-    }
-    mContext = do_GetWeakReference(aContext);
-    sLogMe = false;
-  }
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+struct WebGLProgramInner final : public SupportsWeakPtr<WebGLProgramInner> {
+  const RefPtr<WebGLProgramJS> js;
+
+  NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(WebGLProgramInner)
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLProgramInner)
+  MOZ_DECLARE_WEAKREFERENCE_TYPENAME(WebGLProgramInner)
+
+  explicit WebGLProgramInner(const RefPtr<WebGLProgramJS>& _js) : js(_js) {}
+
+ private:
+  virtual ~WebGLProgramInner() = default;
+};
+
+struct WebGLShaderInner;
+
+class WebGLProgramJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLProgramJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLProgramJS)
+  // Must come first!
+  // If the REFCOUNTING macro isn't declared first, the AddRef at
+  // mInnerRef->js will panic when REFCOUNTING's "owning thread" var is still
+  // uninitialized.
+
+ private:
+  RefPtr<WebGLProgramInner> mInnerRef;
+  const WeakPtr<WebGLProgramInner> mInnerWeak;
+
+  std::unordered_map<GLenum, RefPtr<WebGLShaderInner>> mNextLink_Shaders;
+  bool mLastValidate = false;
+  mutable std::shared_ptr<webgl::LinkResult>
+      mResult;  // Never null, often defaulted.
+
+  struct UniformLocInfo final {
+    const uint32_t location;
+    const GLenum elemType;
+  };
+
+  mutable Maybe<std::unordered_map<std::string, UniformLocInfo>>
+      mUniformLocByName;
+  mutable std::vector<uint32_t> mUniformBlockBindings;
+
+  std::unordered_set<const WebGLTransformFeedbackJS*> mActiveTfos;
+
+  explicit WebGLProgramJS(const ClientWebGLContext&);
+  ~WebGLProgramJS() = default;
+
+ public:
+  bool IsDeleted() const override { return !mInnerWeak.get(); }
+
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLQueryJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  GLenum mTarget = 0;  // !IsQuery until Bind
 
- protected:
-  ClientWebGLContext* GetContext() const {
-    nsCOMPtr<nsICanvasRenderingContextInternal> ret =
-        do_QueryReferent(mContext);
-    if (!ret) {
-      return nullptr;
-    }
-    return static_cast<ClientWebGLContext*>(ret.get());
-  }
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLQueryJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLQueryJS)
+
+  explicit WebGLQueryJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+
+ private:
+  ~WebGLQueryJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLRenderbufferJS final : public nsWrapperCache,
+                                  public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLRenderbufferJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLRenderbufferJS)
+
+ private:
+  bool mHasBeenBound = false;  // !IsRenderbuffer until Bind
+
+  explicit WebGLRenderbufferJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+  ~WebGLRenderbufferJS() = default;
 
-  virtual ~ClientWebGLObject(){};
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLSamplerJS final : public nsWrapperCache, public webgl::ObjectJS {
+  // IsSampler without Bind
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLSamplerJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLSamplerJS)
+
+  explicit WebGLSamplerJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+
+ private:
+  ~WebGLSamplerJS() = default;
 
-  nsWeakPtr mContext;
-  uint64_t mGeneration;
-  bool mLogMe;
-  static bool sLogMe;
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+struct WebGLShaderInner final : public SupportsWeakPtr<WebGLShaderInner> {
+  const RefPtr<WebGLShaderJS> js;
+
+  NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(WebGLShaderInner)
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLShaderInner)
+  MOZ_DECLARE_WEAKREFERENCE_TYPENAME(WebGLShaderInner)
+
+  explicit WebGLShaderInner(const RefPtr<WebGLShaderJS>& _js) : js(_js) {}
+
+ private:
+  virtual ~WebGLShaderInner() = default;
 };
 
-template <typename WebGLType>
-bool ClientWebGLObject<WebGLType>::sLogMe = true;
+class WebGLShaderJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLShaderJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLShaderJS)
+  // If the REFCOUNTING macro isn't declared first, the AddRef at
+  // mInnerRef->js will panic when REFCOUNTING's "owning thread" var is still
+  // uninitialized.
+
+ private:
+  const GLenum mType;
+  RefPtr<WebGLShaderInner> mInnerRef;
+  const WeakPtr<WebGLShaderInner> mInnerWeak;
+  std::string mSource;
+
+  mutable webgl::CompileResult mResult;
+
+  WebGLShaderJS(const ClientWebGLContext&, GLenum type);
+  ~WebGLShaderJS() = default;
+
+ public:
+  bool IsDeleted() const override { return !mInnerWeak.get(); }
+
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLSyncJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  bool mSignaled = false;
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLSyncJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLSyncJS)
+
+  explicit WebGLSyncJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+
+ private:
+  ~WebGLSyncJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+class WebGLTextureJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  GLenum mTarget = 0;  // !IsTexture until Bind
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLTextureJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLTextureJS)
+
+  explicit WebGLTextureJS(const ClientWebGLContext& webgl)
+      : webgl::ObjectJS(webgl) {}
+
+ private:
+  ~WebGLTextureJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
 
-// Every WebGL type with a client version exposed to JS needs to use this macro
-// to associate its C++ type with the JS binding interface.
-#define DEFINE_WEBGL_CLIENT_TYPE_2(_WebGLType, _WebGLBindingType)       \
-  class ClientWebGL##_WebGLType                                         \
-      : public ClientWebGLObject<WebGL##_WebGLType> {                   \
-   public:                                                              \
-    ClientWebGL##_WebGLType(uint64_t aId, ClientWebGLContext* aContext) \
-        : ClientWebGLObject<WebGL##_WebGLType>(aId, aContext) {}        \
-    JSObject* WrapObject(JSContext* cx,                                 \
-                         JS::Handle<JSObject*> givenProto) override {   \
-      return dom::WebGL##_WebGLBindingType##_Binding::Wrap(cx, this,    \
-                                                           givenProto); \
-    }                                                                   \
-                                                                        \
-   protected:                                                           \
-    virtual ~ClientWebGL##_WebGLType(){};                               \
-  };                                                                    \
-  RefPtr<ClientWebGL##_WebGLType> downcast(                             \
-      RefPtr<ClientWebGLObject<WebGL##_WebGLType>>&& obj) {             \
-    MOZ_ASSERT(obj);                                                    \
-    return obj.forget().template downcast<ClientWebGL##_WebGLType>();   \
-  }
+class WebGLTransformFeedbackJS final : public nsWrapperCache,
+                                       public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  bool mHasBeenBound = false;  // !IsTransformFeedback until Bind
+  bool mActiveOrPaused = false;
+  std::vector<RefPtr<WebGLBufferJS>> mAttribBuffers;
+  RefPtr<WebGLProgramInner> mActiveProgram;
+
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLTransformFeedbackJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLTransformFeedbackJS)
+
+  explicit WebGLTransformFeedbackJS(const ClientWebGLContext&);
+
+ private:
+  ~WebGLTransformFeedbackJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
+
+// -
+
+std::array<uint16_t, 3> ValidUploadElemTypes(GLenum);
+
+class WebGLUniformLocationJS final : public nsWrapperCache,
+                                     public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  const std::weak_ptr<webgl::LinkResult> mParent;
+  const uint32_t mLocation;
+  const std::array<uint16_t, 3> mValidUploadElemTypes;
 
-// Usually, the JS binding name is the same as the WebGL type name
-#define DEFINE_WEBGL_CLIENT_TYPE(_WebGLType) \
-  DEFINE_WEBGL_CLIENT_TYPE_2(_WebGLType, _WebGLType)
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLUniformLocationJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLUniformLocationJS)
+
+  WebGLUniformLocationJS(const ClientWebGLContext& webgl,
+                         std::weak_ptr<webgl::LinkResult> parent, uint32_t loc,
+                         GLenum elemType)
+      : webgl::ObjectJS(webgl),
+        mParent(parent),
+        mLocation(loc),
+        mValidUploadElemTypes(ValidUploadElemTypes(elemType)) {}
+
+ private:
+  ~WebGLUniformLocationJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
 
-DEFINE_WEBGL_CLIENT_TYPE(Buffer)
-DEFINE_WEBGL_CLIENT_TYPE(Framebuffer)
-DEFINE_WEBGL_CLIENT_TYPE(Program)
-DEFINE_WEBGL_CLIENT_TYPE(Query)
-DEFINE_WEBGL_CLIENT_TYPE(Renderbuffer)
-DEFINE_WEBGL_CLIENT_TYPE(Sampler)
-DEFINE_WEBGL_CLIENT_TYPE(Shader)
-DEFINE_WEBGL_CLIENT_TYPE(Sync)
-DEFINE_WEBGL_CLIENT_TYPE(Texture)
-DEFINE_WEBGL_CLIENT_TYPE(TransformFeedback)
-DEFINE_WEBGL_CLIENT_TYPE(UniformLocation)
-DEFINE_WEBGL_CLIENT_TYPE_2(VertexArray, VertexArrayObject)
+// -
+
+class WebGLVertexArrayJS final : public nsWrapperCache, public webgl::ObjectJS {
+  friend class ClientWebGLContext;
+
+  bool mHasBeenBound = false;  // !IsVertexArray until Bind
+  RefPtr<WebGLBufferJS> mIndexBuffer;
+  std::vector<RefPtr<WebGLBufferJS>> mAttribBuffers;
 
-#undef DEFINE_WEBGL_CLIENT_TYPE
-#undef DEFINE_WEBGL_CLIENT_TYPE_2
+ public:
+  NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(WebGLVertexArrayJS)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(WebGLVertexArrayJS)
+
+  explicit WebGLVertexArrayJS(const ClientWebGLContext&);
+
+ private:
+  ~WebGLVertexArrayJS() = default;
+
+ public:
+  JSObject* WrapObject(JSContext*, JS::Handle<JSObject*>) override;
+};
 
 ////////////////////////////////////
 
-struct TexImageSource {
-  const dom::ArrayBufferView* mView;
-  GLuint mViewElemOffset;
-  GLuint mViewElemLengthOverride;
+typedef dom::Float32ArrayOrUnrestrictedFloatSequence Float32ListU;
+typedef dom::Int32ArrayOrLongSequence Int32ListU;
+typedef dom::Uint32ArrayOrUnsignedLongSequence Uint32ListU;
 
-  const WebGLsizeiptr* mPboOffset;
+inline Range<const float> MakeRange(const Float32ListU& list) {
+  if (list.IsFloat32Array()) return MakeRangeAbv(list.GetAsFloat32Array());
+
+  return MakeRange(list.GetAsUnrestrictedFloatSequence());
+}
 
-  const dom::ImageBitmap* mImageBitmap;
-  const dom::ImageData* mImageData;
+inline Range<const int32_t> MakeRange(const Int32ListU& list) {
+  if (list.IsInt32Array()) return MakeRangeAbv(list.GetAsInt32Array());
 
-  const dom::Element* mDomElem;
-  ErrorResult* mOut_error;
+  return MakeRange(list.GetAsLongSequence());
+}
 
- protected:
-  TexImageSource() { memset(this, 0, sizeof(*this)); }
-};
+inline Range<const uint32_t> MakeRange(const Uint32ListU& list) {
+  if (list.IsUint32Array()) return MakeRangeAbv(list.GetAsUint32Array());
 
-////
+  return MakeRange(list.GetAsUnsignedLongSequence());
+}
+
+// -
 
 struct TexImageSourceAdapter final : public TexImageSource {
   TexImageSourceAdapter(const dom::Nullable<dom::ArrayBufferView>* maybeView,
@@ -241,12 +600,12 @@
     mViewElemLengthOverride = viewElemLengthOverride;
   }
 
-  TexImageSourceAdapter(const WebGLsizeiptr* pboOffset, GLuint ignored1,
-                        GLuint ignored2 = 0) {
+  explicit TexImageSourceAdapter(const WebGLintptr* pboOffset,
+                                 GLuint ignored1 = 0, GLuint ignored2 = 0) {
     mPboOffset = pboOffset;
   }
 
-  TexImageSourceAdapter(const WebGLsizeiptr* pboOffset, ErrorResult* ignored) {
+  TexImageSourceAdapter(const WebGLintptr* pboOffset, ErrorResult* ignored) {
     mPboOffset = pboOffset;
   }
 
@@ -270,10 +629,15 @@
 /**
  * Base class for all IDL implementations of WebGLContext
  */
-class ClientWebGLContext : public nsICanvasRenderingContextInternal,
-                           public nsSupportsWeakReference,
-                           public nsWrapperCache,
-                           public WebGLContextEndpoint {
+class ClientWebGLContext final : public nsICanvasRenderingContextInternal,
+                                 public SupportsWeakPtr<ClientWebGLContext>,
+                                 public nsWrapperCache {
+  friend class WebGLContextUserData;
+  friend class webgl::ObjectJS;
+
+ public:
+  MOZ_DECLARE_WEAKREFERENCE_TYPENAME(ClientWebGLContext)
+
   // ----------------------------- Lifetime and DOM ---------------------------
  public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
@@ -282,190 +646,85 @@
 
   JSObject* WrapObject(JSContext* cx,
                        JS::Handle<JSObject*> givenProto) override {
-    switch (mVersion) {
-      case WEBGL1:
-        return dom::WebGLRenderingContext_Binding::Wrap(cx, this, givenProto);
-      case WEBGL2:
-        return dom::WebGL2RenderingContext_Binding::Wrap(cx, this, givenProto);
-      default:
-        MOZ_ASSERT_UNREACHABLE("Invalid WebGL Version");
-        return nullptr;
+    if (mIsWebGL2) {
+      return dom::WebGL2RenderingContext_Binding::Wrap(cx, this, givenProto);
     }
+    return dom::WebGLRenderingContext_Binding::Wrap(cx, this, givenProto);
   }
 
-  static RefPtr<ClientWebGLContext> Create(WebGLVersion aVersion);
-
-  uint64_t Generation() { return mGeneration; }
-
- protected:
-  uint64_t mGeneration = 0;
-
-  // -------------------------------------------------------------------------
-  // Client WebGL Object Tracking
-  // -------------------------------------------------------------------------
- public:
-  template <typename ObjectType>
-  using ClientObjectIdMap =
-      HashMap<WebGLId<ObjectType>, RefPtr<ClientWebGLObject<ObjectType>>>;
-
- public:
-  JS::Value ToJSValue(JSContext* cx, const MaybeWebGLVariant& aVariant,
-                      ErrorResult& rv) const;
-
- protected:
-  friend struct MaybeWebGLVariantMatcher;
-
-  template <typename WebGLObjectType>
-  JS::Value WebGLObjectAsJSValue(JSContext* cx,
-                                 RefPtr<WebGLObjectType>&& object,
-                                 ErrorResult& rv) const;
-
-  template <typename WebGLObjectType>
-  JS::Value WebGLObjectAsJSValue(JSContext* cx, const WebGLObjectType*,
-                                 ErrorResult& rv) const;
-
-  template <typename WebGLObjectType>
-  JSObject* WebGLObjectAsJSObject(JSContext* cx, const WebGLObjectType*,
-                                  ErrorResult& rv) const;
-
-  template <typename WebGLType>
-  RefPtr<ClientWebGLObject<WebGLType>> EnsureWebGLObject(
-      const WebGLId<WebGLType>& aId);
-
-  template <typename WebGLType>
-  RefPtr<ClientWebGLObject<WebGLType>> Make(const WebGLId<WebGLType>& aId);
-
-  template <typename WebGLType>
-  WebGLId<WebGLType> GenerateId();
-
-#define DEFINE_GENERATEID(_TYPE)                         \
-  typename WebGLId<WebGL##_TYPE>::IdType mId##_TYPE = 1; \
-  template <>                                            \
-  WebGLId<WebGL##_TYPE> GenerateId<WebGL##_TYPE>() {     \
-    return WebGLId<WebGL##_TYPE>(mId##_TYPE++);          \
-  }
-
-  // All but Buffer, Texture and UniformLocation
-  DEFINE_GENERATEID(Framebuffer)
-  DEFINE_GENERATEID(Program)
-  DEFINE_GENERATEID(Renderbuffer)
-  DEFINE_GENERATEID(Sampler)
-  DEFINE_GENERATEID(Shader)
-  DEFINE_GENERATEID(Sync)
-  DEFINE_GENERATEID(TransformFeedback)
-  DEFINE_GENERATEID(Query)
-  DEFINE_GENERATEID(VertexArray)
-
-#undef DEFINE_GENERATEID
+  // -
 
  public:
-  // Define the client ID map and accessors for the given type
-#define DEFINE_CLIENTWEBGLOBJECT_MAP(_TYPE)                    \
-  ClientObjectIdMap<WebGL##_TYPE> m##_TYPE##Map;               \
-  bool Insert(RefPtr<ClientWebGLObject<WebGL##_TYPE>>& aObj) { \
-    MOZ_ASSERT(aObj->Id());                                    \
-    return m##_TYPE##Map.put(*aObj, aObj);                     \
-  }                                                            \
-  RefPtr<ClientWebGLObject<WebGL##_TYPE>> Find(                \
-      const WebGLId<WebGL##_TYPE>& aId) {                      \
-    auto it = m##_TYPE##Map.lookup(aId);                       \
-    return it ? it->value() : nullptr;                         \
-  }                                                            \
-  void Remove(const WebGLId<WebGL##_TYPE>& aId) { m##_TYPE##Map.remove(aId); }
+  const bool mIsWebGL2;
+
+  explicit ClientWebGLContext(bool webgl2);
+
+ private:
+  virtual ~ClientWebGLContext();
 
-  // Annoying but, since we don't want to include the WebGLMethodDispatcher
-  // in this header due to its size, we can't define ReleaseWebGLObject as
-  // a template method.  We expand the template with macros instead.
-#define DECLARE_CLIENTWEBGLOBJECT(_TYPE) \
-  DEFINE_CLIENTWEBGLOBJECT_MAP(_TYPE)    \
-  void ReleaseWebGLObject(const WebGLId<WebGL##_TYPE>* aId);
+  uvec2 mRequestedSize;
+  Maybe<uvec2> mDrawingBufferSize;
+  const RefPtr<ClientWebGLExtensionLoseContext> mExtLoseContext;
 
-  DECLARE_CLIENTWEBGLOBJECT(Buffer)
-  DECLARE_CLIENTWEBGLOBJECT(Framebuffer)
-  DECLARE_CLIENTWEBGLOBJECT(Program)
-  DECLARE_CLIENTWEBGLOBJECT(Query)
-  DECLARE_CLIENTWEBGLOBJECT(Renderbuffer)
-  DECLARE_CLIENTWEBGLOBJECT(Sampler)
-  DECLARE_CLIENTWEBGLOBJECT(Shader)
-  DECLARE_CLIENTWEBGLOBJECT(Sync)
-  DECLARE_CLIENTWEBGLOBJECT(Texture)
-  DECLARE_CLIENTWEBGLOBJECT(TransformFeedback)
-  DECLARE_CLIENTWEBGLOBJECT(UniformLocation)
-  DECLARE_CLIENTWEBGLOBJECT(VertexArray)
-
-#undef DECLARE_CLIENTWEBGLOBJECT
-#undef DEFINE_CLIENTWEBGLOBJECT_MAP
+  webgl::LossStatus mLossStatus = webgl::LossStatus::Ready;
+  bool mAwaitingRestore = false;
 
-  // -------------------------------------------------------------------------
-  // Binary data access/conversion for IPC
-  // -------------------------------------------------------------------------
- protected:
-  typedef dom::Float32ArrayOrUnrestrictedFloatSequence Float32ListU;
-  typedef dom::Int32ArrayOrLongSequence Int32ListU;
-  typedef dom::Uint32ArrayOrUnsignedLongSequence Uint32ListU;
-
-  // Adapter that converts a JS array parameters to pointer/count C-style arrays
-  template <typename elemT, typename viewT>
-  struct Arr {
-    const size_t elemCount;
-    const elemT* const elemBytes;
-
-   private:
-    static size_t ComputeAndReturnLength(const viewT& view) {
-      view.ComputeLengthAndData();
-      return view.LengthAllowShared();
-    }
-
-   public:
-    explicit Arr(const viewT& view)
-        : elemCount(ComputeAndReturnLength(view)),
-          elemBytes(view.DataAllowShared()) {}
-
-    explicit Arr(const dom::Sequence<elemT>& seq)
-        : elemCount(seq.Length()), elemBytes(seq.Elements()) {}
-
-    Arr(size_t _elemCount, const elemT* _elemBytes)
-        : elemCount(_elemCount), elemBytes(_elemBytes) {}
-
-    ////
-
-    static Arr From(const dom::Float32ArrayOrUnrestrictedFloatSequence& list) {
-      if (list.IsFloat32Array()) return Arr(list.GetAsFloat32Array());
-
-      return Arr(list.GetAsUnrestrictedFloatSequence());
-    }
-
-    static Arr From(const dom::Int32ArrayOrLongSequence& list) {
-      if (list.IsInt32Array()) return Arr(list.GetAsInt32Array());
-
-      return Arr(list.GetAsLongSequence());
-    }
-
-    static Arr From(const dom::Uint32ArrayOrUnsignedLongSequence& list) {
-      if (list.IsUint32Array()) return Arr(list.GetAsUint32Array());
-
-      return Arr(list.GetAsUnsignedLongSequence());
-    }
+  // -
+ public:
+  struct RemotingData final {
+    // In the cross process case, the WebGL actor's ownership relationship looks
+    // like this:
+    // ---------------------------------------------------------------------
+    // | ClientWebGLContext -> WebGLChild -> WebGLParent -> HostWebGLContext
+    // ---------------------------------------------------------------------
+    //
+    // where 'A -> B' means "A owns B"
+    RefPtr<mozilla::dom::WebGLChild> mWebGLChild;
+    UniquePtr<ClientWebGLCommandSource> mCommandSource;
+  };
+  struct NotLostData final {
+    std::shared_ptr<webgl::ContextGenerationInfo> generation;
+    Maybe<RemotingData> outOfProcess;
+    UniquePtr<HostWebGLContext> inProcess;
+    webgl::InitContextResult info;
+    std::array<RefPtr<ClientWebGLExtensionBase>,
+               EnumValue(WebGLExtensionID::Max)>
+        extensions;
   };
 
-  typedef Arr<GLfloat, dom::Float32Array> Float32Arr;
-  typedef Arr<GLint, dom::Int32Array> Int32Arr;
-  typedef Arr<GLuint, dom::Uint32Array> Uint32Arr;
+ private:
+  Maybe<NotLostData> mNotLost;
+  mutable GLenum mNextError = 0;
+
+ public:
+  const auto& Limits() const { return mNotLost->info.limits; }
 
-  MaybeWebGLTexUnpackVariant From(TexImageTarget target, GLsizei rawWidth,
-                                  GLsizei rawHeight, GLsizei rawDepth,
-                                  GLint border, const TexImageSource& src);
+  const auto& State() const { return *mNotLost->generation; }
+  auto& State() { return *mNotLost->generation; }
+
+  // -
+
+ public:
+  void EmulateLoseContext();
+  void OnContextLoss(webgl::ContextLossReason);
+  void RestoreContext(webgl::LossStatus requiredStatus);
 
-  MaybeWebGLTexUnpackVariant ClientFromDomElem(TexImageTarget target,
-                                               uint32_t width, uint32_t height,
-                                               uint32_t depth,
-                                               const dom::Element& elem,
-                                               ErrorResult* const out_error);
+ private:
+  bool DispatchEvent(const nsAString&) const;
+  void Event_webglcontextlost();
+  void Event_webglcontextrestored();
+
+  bool CreateHostContext();
+  void ThrowEvent_WebGLContextCreationError(const std::string&) const;
 
-  MaybeWebGLTexUnpackVariant FromCompressed(
-      TexImageTarget target, GLsizei rawWidth, GLsizei rawHeight,
-      GLsizei rawDepth, GLint border, const TexImageSource& src,
-      const Maybe<GLsizei>& expectedImageSize);
+ public:
+  void MarkCanvasDirty() { Invalidate(); }
+
+  mozilla::dom::WebGLChild* GetChild() const {
+    if (!mNotLost) return nullptr;
+    if (!mNotLost->outOfProcess) return nullptr;
+    return mNotLost->outOfProcess->mWebGLChild.get();
+  }
 
   // -------------------------------------------------------------------------
   // Client WebGL API call tracking and error message reporting
@@ -475,28 +734,28 @@
   // error generation.
   class FuncScope final {
    public:
-    const ClientWebGLContext* mWebGL;
+    const ClientWebGLContext& mWebGL;
     const char* const mFuncName;
-    FuncScopeId mId;
+    const FuncScopeId mId;
 
-    FuncScope(const ClientWebGLContext* webgl, const char* funcName)
+    FuncScope(const ClientWebGLContext& webgl, const char* funcName)
         : mWebGL(webgl),
           mFuncName(funcName),
           mId(FuncScopeId::FuncScopeIdError) {
       // Only set if an "outer" scope hasn't already been set.
-      if (!mWebGL->mFuncScope) {
-        mWebGL->mFuncScope = this;
+      if (!mWebGL.mFuncScope) {
+        mWebGL.mFuncScope = this;
       }
     }
 
     FuncScope(const ClientWebGLContext* webgl, FuncScopeId aId)
-        : mWebGL(webgl), mFuncName(GetFuncScopeName(aId)), mId(aId) {
-      mWebGL->mFuncScope = this;
+        : mWebGL(*webgl), mFuncName(GetFuncScopeName(aId)), mId(aId) {
+      mWebGL.mFuncScope = this;
     }
 
     ~FuncScope() {
-      if (this == mWebGL->mFuncScope) {
-        mWebGL->mFuncScope = nullptr;
+      if (this == mWebGL.mFuncScope) {
+        mWebGL.mFuncScope = nullptr;
       }
     }
   };
@@ -516,86 +775,59 @@
 
  public:
   template <typename... Args>
-  void EnqueueErrorPrintf(GLenum aGLError, const char* aFmt,
-                          const Args&... aArgs) {
+  void EnqueueError(const GLenum error, const char* const format,
+                    const Args&... args) const MOZ_FORMAT_PRINTF(3, 4) {
     MOZ_ASSERT(FuncName());
-    nsCString buf;
-    buf.AppendPrintf(aFmt, aArgs...);
-    nsCString msg;
-    msg.AppendPrintf("WebGL warning: %s: %s", FuncName(), buf.Data());
-    EnqueueErrorPrintfHelper(aGLError, msg);
-  }
+    nsCString text;
+    text.AppendPrintf("WebGL warning: %s: ", FuncName());
+    text.AppendPrintf(format, args...);
 
-  // Post a message to the host telling it to post a message back to us
-  // (the client) notifying of a failure that was detected in the client.
-  // We take this roundtrip to guarantee that error messages are received
-  // in the correct order.
-  template <typename... Args>
-  void EnqueueErrorInvalidValue(const char* aFmt, const Args&... aArgs) {
-    EnqueueErrorPrintf(LOCAL_GL_INVALID_VALUE, aFmt, aArgs...);
+    EnqueueErrorImpl(error, text);
   }
 
   template <typename... Args>
-  void EnqueueErrorInvalidEnumInfo(const char* aFmt, const Args&... aArgs) {
-    EnqueueErrorPrintf(LOCAL_GL_INVALID_ENUM, aFmt, aArgs...);
-  }
-
-  template <typename... Args>
-  void EnqueueErrorInvalidOperation(const char* aFmt, const Args&... aArgs) {
-    EnqueueErrorPrintf(LOCAL_GL_INVALID_OPERATION, aFmt, aArgs...);
+  void EnqueueWarning(const char* const format, const Args&... args) const
+      MOZ_FORMAT_PRINTF(2, 3) {
+    EnqueueError(0, format, args...);
   }
 
-  template <typename... Args>
-  void EnqueueErrorOutOfMemory(const char* aFmt, const Args&... aArgs) {
-    EnqueueErrorPrintf(LOCAL_GL_OUT_OF_MEMORY, aFmt, aArgs...);
-  }
+  void EnqueueError_ArgEnum(const char* argName,
+                            GLenum val) const;  // Cold code.
 
-  void EnqueueWarning(const nsCString& msg);
-  void EnqueueWarning(const char* msg) { EnqueueWarning(nsCString(msg)); }
+ private:
+  void EnqueueErrorImpl(GLenum errorOrZero, const nsACString&) const;
 
+ public:
   bool ValidateArrayBufferView(const dom::ArrayBufferView& view,
                                GLuint elemOffset, GLuint elemCountOverride,
                                const GLenum errorEnum,
                                uint8_t** const out_bytes,
-                               size_t* const out_byteLen);
+                               size_t* const out_byteLen) const;
 
  protected:
-  void EnqueueErrorPrintfHelper(GLenum aGLError, const nsCString& msg);
-
-  bool ValidateAttribArraySetter(uint32_t setterElemSize,
-                                 uint32_t arrayLength) {
-    if (arrayLength < setterElemSize) {
-      EnqueueErrorInvalidValue("Array must have >= %d elements.",
-                               setterElemSize);
-      return false;
-    }
-
-    return true;
-  }
-
   template <typename T>
   bool ValidateNonNull(const char* const argName,
-                       const dom::Nullable<T>& maybe) {
+                       const dom::Nullable<T>& maybe) const {
     if (maybe.IsNull()) {
-      EnqueueErrorInvalidValue("%s: Cannot be null.", argName);
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "%s: Cannot be null.", argName);
       return false;
     }
     return true;
   }
 
-  bool ValidateNonNegative(const char* argName, int64_t val) {
+  bool ValidateNonNegative(const char* argName, int64_t val) const {
     if (MOZ_UNLIKELY(val < 0)) {
-      EnqueueErrorInvalidValue("`%s` must be non-negative.", argName);
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "`%s` must be non-negative.",
+                   argName);
       return false;
     }
     return true;
   }
 
-  bool ValidateViewType(GLenum unpackType, const TexImageSource& src);
+  bool ValidateViewType(GLenum unpackType, const TexImageSource& src) const;
 
-  bool ValidateExtents(GLsizei width, GLsizei height, GLsizei depth,
-                       GLint border, uint32_t* const out_width,
-                       uint32_t* const out_height, uint32_t* const out_depth);
+  Maybe<uvec3> ValidateExtents(GLsizei width, GLsizei height, GLsizei depth,
+                               GLint border) const;
 
   // -------------------------------------------------------------------------
   // nsICanvasRenderingContextInternal / nsAPostRefreshObserver
@@ -627,12 +859,12 @@
       layers::WebRenderCanvasData* aCanvasData) override;
 
   bool UpdateCompositableHandle(LayerTransactionChild* aLayerTransaction,
-                                CompositableHandle aHandle);
+                                CompositableHandle aHandle) override;
 
   // ------
 
-  int32_t GetWidth() override { return DrawingBufferWidth(); }
-  int32_t GetHeight() override { return DrawingBufferHeight(); }
+  int32_t GetWidth() override { return AutoAssertCast(DrawingBufferSize().x); }
+  int32_t GetHeight() override { return AutoAssertCast(DrawingBufferSize().y); }
 
   NS_IMETHOD InitializeWithDrawTarget(nsIDocShell*,
                                       NotNull<gfx::DrawTarget*>) override {
@@ -653,7 +885,7 @@
       gfxAlphaType* out_alphaType) override;
 
   void SetOpaqueValueFromOpaqueAttr(bool) override{};
-  bool GetIsOpaque() override { return !mOptions.alpha; }
+  bool GetIsOpaque() override { return !mInitialOptions->alpha; }
 
   NS_IMETHOD SetIsIPC(bool) override { return NS_ERROR_NOT_IMPLEMENTED; }
 
@@ -688,135 +920,236 @@
       dom::Nullable<dom::OwningHTMLCanvasElementOrOffscreenCanvas>& retval);
 
   GLsizei DrawingBufferWidth() {
-    const FuncScope funcScope(this, "drawingBufferWidth");
-    return DrawingBufferSize().width;
+    const FuncScope funcScope(*this, "drawingBufferWidth");
+    return AutoAssertCast(DrawingBufferSize().x);
   }
   GLsizei DrawingBufferHeight() {
-    const FuncScope funcScope(this, "drawingBufferHeight");
-    return DrawingBufferSize().height;
+    const FuncScope funcScope(*this, "drawingBufferHeight");
+    return AutoAssertCast(DrawingBufferSize().y);
   }
   void GetContextAttributes(dom::Nullable<dom::WebGLContextAttributes>& retval);
 
-  mozilla::dom::PWebGLChild* GetWebGLChild();
+  void Present();
+
+  void ClearVRFrame();
 
  private:
-  gfx::IntSize DrawingBufferSize();
+  const uvec2& DrawingBufferSize();
   bool HasAlphaSupport() { return mSurfaceInfo.supportsAlpha; }
-  void AllowContextRestore();
 
   ICRData mSurfaceInfo;
 
+  void AfterDrawCall() {
+    if (!mNotLost) return;
+    const auto& state = *(mNotLost->generation);
+    const bool isBackbuffer = !state.mBoundDrawFb;
+    if (isBackbuffer) {
+      Invalidate();
+    }
+  }
+
   // -------------------------------------------------------------------------
   // Client-side helper methods.  Dispatch to a Host method.
   // -------------------------------------------------------------------------
 
   // ------------------------- GL State -------------------------
  public:
-  bool IsContextLost() const;
-
-  void Disable(GLenum cap);
-
-  void Enable(GLenum cap);
+  bool IsContextLost() const { return !mNotLost; }
 
-  bool IsEnabled(GLenum cap);
-
-  void GetProgramInfoLog(const WebGLId<WebGLProgram>& prog, nsAString& retval);
-
-  void GetShaderInfoLog(const WebGLId<WebGLShader>& shader, nsAString& retval);
-
-  void GetShaderSource(const WebGLId<WebGLShader>& shader, nsAString& retval);
+  void Disable(GLenum cap) const;
+  void Enable(GLenum cap) const;
+  bool IsEnabled(GLenum cap) const;
 
   void GetParameter(JSContext* cx, GLenum pname,
-                    JS::MutableHandle<JS::Value> retval, ErrorResult& rv);
+                    JS::MutableHandle<JS::Value> retval, ErrorResult& rv,
+                    bool debug = false);
 
   void GetBufferParameter(JSContext* cx, GLenum target, GLenum pname,
-                          JS::MutableHandle<JS::Value> retval);
+                          JS::MutableHandle<JS::Value> retval) const;
 
   void GetFramebufferAttachmentParameter(JSContext* cx, GLenum target,
                                          GLenum attachment, GLenum pname,
                                          JS::MutableHandle<JS::Value> retval,
-                                         ErrorResult& rv);
-
-  void GetProgramParameter(JSContext* cx, const WebGLId<WebGLProgram>& prog,
-                           GLenum pname, JS::MutableHandle<JS::Value> retval);
+                                         ErrorResult& rv) const;
 
   void GetRenderbufferParameter(JSContext* cx, GLenum target, GLenum pname,
-                                JS::MutableHandle<JS::Value> retval);
-
-  void GetShaderParameter(JSContext* cx, const WebGLId<WebGLShader>& shader,
-                          GLenum pname, JS::MutableHandle<JS::Value> retval);
+                                JS::MutableHandle<JS::Value> retval) const;
 
   void GetIndexedParameter(JSContext* cx, GLenum target, GLuint index,
-                           JS::MutableHandleValue retval, ErrorResult& rv);
+                           JS::MutableHandleValue retval,
+                           ErrorResult& rv) const;
 
-  void GetUniform(JSContext* cx, const WebGLId<WebGLProgram>& prog,
-                  const WebGLId<WebGLUniformLocation>& loc,
-                  JS::MutableHandle<JS::Value> retval);
-
-  already_AddRefed<ClientWebGLUniformLocation> GetUniformLocation(
-      const WebGLId<WebGLProgram>& prog, const nsAString& name);
-
-  already_AddRefed<ClientWebGLShaderPrecisionFormat> GetShaderPrecisionFormat(
+  already_AddRefed<WebGLShaderPrecisionFormatJS> GetShaderPrecisionFormat(
       GLenum shadertype, GLenum precisiontype);
 
-  bool IsBuffer(const ClientWebGLBuffer* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
+  void UseProgram(const WebGLProgramJS*);
+  void ValidateProgram(WebGLProgramJS&) const;
+
+  // -
 
-  bool IsFramebuffer(const ClientWebGLFramebuffer* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
+  already_AddRefed<WebGLBufferJS> CreateBuffer() const;
+  already_AddRefed<WebGLFramebufferJS> CreateFramebuffer() const;
+  already_AddRefed<WebGLProgramJS> CreateProgram() const;
+  already_AddRefed<WebGLQueryJS> CreateQuery() const;
+  already_AddRefed<WebGLRenderbufferJS> CreateRenderbuffer() const;
+  already_AddRefed<WebGLSamplerJS> CreateSampler() const;
+  already_AddRefed<WebGLShaderJS> CreateShader(GLenum type) const;
+  already_AddRefed<WebGLSyncJS> FenceSync(GLenum condition,
+                                          GLbitfield flags) const;
+  already_AddRefed<WebGLTextureJS> CreateTexture() const;
+  already_AddRefed<WebGLTransformFeedbackJS> CreateTransformFeedback() const;
+  already_AddRefed<WebGLVertexArrayJS> CreateVertexArray() const;
 
-  bool IsProgram(const ClientWebGLProgram* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
+  void DeleteBuffer(WebGLBufferJS*);
+  void DeleteFramebuffer(WebGLFramebufferJS*);
+  void DeleteProgram(WebGLProgramJS*) const;
+  void DeleteQuery(WebGLQueryJS*) const;
+  void DeleteRenderbuffer(WebGLRenderbufferJS*);
+  void DeleteSampler(WebGLSamplerJS*);
+  void DeleteShader(WebGLShaderJS*) const;
+  void DeleteSync(WebGLSyncJS*) const;
+  void DeleteTexture(WebGLTextureJS*);
+  void DeleteTransformFeedback(WebGLTransformFeedbackJS*) const;
+  void DeleteVertexArray(WebGLVertexArrayJS*);
+
+  // -
 
-  bool IsRenderbuffer(const ClientWebGLRenderbuffer* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
+  bool IsBuffer(const WebGLBufferJS*) const;
+  bool IsFramebuffer(const WebGLFramebufferJS*) const;
+  bool IsProgram(const WebGLProgramJS*) const;
+  bool IsQuery(const WebGLQueryJS*) const;
+  bool IsRenderbuffer(const WebGLRenderbufferJS*) const;
+  bool IsSampler(const WebGLSamplerJS*) const;
+  bool IsShader(const WebGLShaderJS*) const;
+  bool IsSync(const WebGLSyncJS*) const;
+  bool IsTexture(const WebGLTextureJS*) const;
+  bool IsTransformFeedback(const WebGLTransformFeedbackJS*) const;
+  bool IsVertexArray(const WebGLVertexArrayJS*) const;
 
-  bool IsShader(const ClientWebGLShader* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
+  // -
+  // WebGLProgramJS
+
+ private:
+  const webgl::LinkResult& GetLinkResult(const WebGLProgramJS&) const;
 
-  bool IsTexture(const ClientWebGLTexture* obj) {
-    return obj && obj->IsValidForContext(this);
-  }
-
-  bool IsVertexArray(const ClientWebGLVertexArray* obj,
-                     bool aFromExtension = false);
-
-  void BindAttribLocation(const WebGLId<WebGLProgram>& prog, GLuint location,
-                          const nsAString& name);
+ public:
+  void AttachShader(WebGLProgramJS&, const WebGLShaderJS&) const;
+  void BindAttribLocation(WebGLProgramJS&, GLuint location,
+                          const nsAString& name) const;
+  void DetachShader(WebGLProgramJS&, const WebGLShaderJS&) const;
+  void GetAttachedShaders(
+      const WebGLProgramJS&,
+      dom::Nullable<nsTArray<RefPtr<WebGLShaderJS>>>& retval) const;
+  void LinkProgram(WebGLProgramJS&) const;
+  void TransformFeedbackVaryings(WebGLProgramJS&,
+                                 const dom::Sequence<nsString>& varyings,
+                                 GLenum bufferMode) const;
+  void UniformBlockBinding(WebGLProgramJS&, GLuint blockIndex,
+                           GLuint blockBinding) const;
 
-  GLint GetAttribLocation(const WebGLId<WebGLProgram>& prog,
-                          const nsAString& name);
-
-  void AttachShader(const WebGLId<WebGLProgram>& progId,
-                    const WebGLId<WebGLShader>& shaderId);
+  // Link result reflection
+  already_AddRefed<WebGLActiveInfoJS> GetActiveAttrib(const WebGLProgramJS&,
+                                                      GLuint index);
+  already_AddRefed<WebGLActiveInfoJS> GetActiveUniform(const WebGLProgramJS&,
+                                                       GLuint index);
+  void GetActiveUniformBlockName(const WebGLProgramJS&,
+                                 GLuint uniformBlockIndex,
+                                 nsAString& retval) const;
+  void GetActiveUniformBlockParameter(JSContext* cx, const WebGLProgramJS&,
+                                      GLuint uniformBlockIndex, GLenum pname,
+                                      JS::MutableHandle<JS::Value> retval,
+                                      ErrorResult& rv);
+  void GetActiveUniforms(JSContext*, const WebGLProgramJS&,
+                         const dom::Sequence<GLuint>& uniformIndices,
+                         GLenum pname,
+                         JS::MutableHandle<JS::Value> retval) const;
+  GLint GetAttribLocation(const WebGLProgramJS&, const nsAString& name) const;
+  GLint GetFragDataLocation(const WebGLProgramJS&, const nsAString& name) const;
+  void GetProgramInfoLog(const WebGLProgramJS& prog, nsAString& retval) const;
+  void GetProgramParameter(JSContext*, const WebGLProgramJS&, GLenum pname,
+                           JS::MutableHandle<JS::Value> retval) const;
+  already_AddRefed<WebGLActiveInfoJS> GetTransformFeedbackVarying(
+      const WebGLProgramJS&, GLuint index);
+  GLuint GetUniformBlockIndex(const WebGLProgramJS&,
+                              const nsAString& uniformBlockName) const;
+  void GetUniformIndices(const WebGLProgramJS&,
+                         const dom::Sequence<nsString>& uniformNames,
+                         dom::Nullable<nsTArray<GLuint>>& retval) const;
 
-  void ShaderSource(const WebGLId<WebGLShader>& shader,
-                    const nsAString& source);
+  // WebGLUniformLocationJS
+  already_AddRefed<WebGLUniformLocationJS> GetUniformLocation(
+      const WebGLProgramJS&, const nsAString& name) const;
+  void GetUniform(JSContext*, const WebGLProgramJS&,
+                  const WebGLUniformLocationJS&,
+                  JS::MutableHandle<JS::Value> retval);
+
+  // -
+  // WebGLShaderJS
+
+ private:
+  const webgl::CompileResult& GetCompileResult(const WebGLShaderJS&) const;
 
-  void BindFramebuffer(GLenum target, const WebGLId<WebGLFramebuffer>& fb);
+ public:
+  void CompileShader(WebGLShaderJS&) const;
+  void GetShaderInfoLog(const WebGLShaderJS&, nsAString& retval) const;
+  void GetShaderParameter(JSContext*, const WebGLShaderJS&, GLenum pname,
+                          JS::MutableHandle<JS::Value> retval) const;
+  void GetShaderSource(const WebGLShaderJS&, nsAString& retval) const;
+  void GetTranslatedShaderSource(const WebGLShaderJS& shader,
+                                 nsAString& retval) const;
+  void ShaderSource(WebGLShaderJS&, const nsAString&) const;
 
-  void BindRenderbuffer(GLenum target, const WebGLId<WebGLRenderbuffer>& fb);
+  // -
+
+  void BindFramebuffer(GLenum target, WebGLFramebufferJS*);
 
   void BlendColor(GLclampf r, GLclampf g, GLclampf b, GLclampf a);
 
-  void BlendEquation(GLenum mode);
+  // -
+
+  void BlendEquation(GLenum mode) { BlendEquationSeparate(mode, mode); }
+  void BlendFunc(GLenum sfactor, GLenum dfactor) {
+    BlendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
+  }
 
   void BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
-
-  void BlendFunc(GLenum sfactor, GLenum dfactor);
-
   void BlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha,
                          GLenum dstAlpha);
 
+  // -
+
   GLenum CheckFramebufferStatus(GLenum target);
 
   void Clear(GLbitfield mask);
 
+  // -
+
+ private:
+  void ClearBufferTv(GLenum buffer, GLint drawBuffer, webgl::AttribBaseType,
+                     const Range<const uint8_t>& view, GLuint srcElemOffset);
+
+ public:
+  void ClearBufferfv(GLenum buffer, GLint drawBuffer, const Float32ListU& list,
+                     GLuint srcElemOffset) {
+    ClearBufferTv(buffer, drawBuffer, webgl::AttribBaseType::Float,
+                  MakeByteRange(list), srcElemOffset);
+  }
+  void ClearBufferiv(GLenum buffer, GLint drawBuffer, const Int32ListU& list,
+                     GLuint srcElemOffset) {
+    ClearBufferTv(buffer, drawBuffer, webgl::AttribBaseType::Int,
+                  MakeByteRange(list), srcElemOffset);
+  }
+  void ClearBufferuiv(GLenum buffer, GLint drawBuffer, const Uint32ListU& list,
+                      GLuint srcElemOffset) {
+    ClearBufferTv(buffer, drawBuffer, webgl::AttribBaseType::Uint,
+                  MakeByteRange(list), srcElemOffset);
+  }
+
+  // -
+
+  void ClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth,
+                     GLint stencil);
+
   void ClearColor(GLclampf r, GLclampf g, GLclampf b, GLclampf a);
 
   void ClearDepth(GLclampf v);
@@ -826,39 +1159,18 @@
   void ColorMask(WebGLboolean r, WebGLboolean g, WebGLboolean b,
                  WebGLboolean a);
 
-  void CompileShader(const WebGLId<WebGLShader>& shaderId);
-
   void CullFace(GLenum face);
 
-  void DeleteFramebuffer(const WebGLId<WebGLFramebuffer>& aFb);
-
-  void DeleteProgram(const WebGLId<WebGLProgram>& aProg);
-
-  void DeleteRenderbuffer(const WebGLId<WebGLRenderbuffer>& aRb);
-
-  void DeleteShader(const WebGLId<WebGLShader>& aShader);
-
   void DepthFunc(GLenum func);
 
   void DepthMask(WebGLboolean b);
 
   void DepthRange(GLclampf zNear, GLclampf zFar);
 
-  void DetachShader(const WebGLId<WebGLProgram>& progId,
-                    const WebGLId<WebGLShader>& shaderId);
-
   void Flush();
 
   void Finish();
 
-  void FramebufferRenderbuffer(GLenum target, GLenum attachment,
-                               GLenum rbTarget,
-                               const WebGLId<WebGLRenderbuffer>& rb);
-
-  void FramebufferTexture2D(GLenum target, GLenum attachment,
-                            GLenum texImageTarget,
-                            const WebGLId<WebGLTexture>& tex, GLint level);
-
   void FrontFace(GLenum mode);
 
   GLenum GetError();
@@ -867,8 +1179,6 @@
 
   void LineWidth(GLfloat width);
 
-  void LinkProgram(const WebGLId<WebGLProgram>& progId);
-
   void PixelStorei(GLenum pname, GLint param);
 
   void PolygonOffset(GLfloat factor, GLfloat units);
@@ -877,38 +1187,68 @@
 
   void Scissor(GLint x, GLint y, GLsizei width, GLsizei height);
 
-  void ShaderSource(const WebGLId<WebGLShader>& shaderId,
-                    const nsString& source);
+  // -
 
-  void StencilFunc(GLenum func, GLint ref, GLuint mask);
+  void StencilFunc(GLenum func, GLint ref, GLuint mask) {
+    StencilFuncSeparate(LOCAL_GL_FRONT_AND_BACK, func, ref, mask);
+  }
+  void StencilMask(GLuint mask) {
+    StencilMaskSeparate(LOCAL_GL_FRONT_AND_BACK, mask);
+  }
+  void StencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) {
+    StencilOpSeparate(LOCAL_GL_FRONT_AND_BACK, sfail, dpfail, dppass);
+  }
 
   void StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
-
-  void StencilMask(GLuint mask);
-
   void StencilMaskSeparate(GLenum face, GLuint mask);
-
-  void StencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);
-
   void StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail,
                          GLenum dppass);
 
+  // -
+
   void Viewport(GLint x, GLint y, GLsizei width, GLsizei height);
 
   // ------------------------- Buffer Objects -------------------------
  public:
-  already_AddRefed<ClientWebGLBuffer> CreateBuffer();
+  void BindBuffer(GLenum target, WebGLBufferJS*);
+
+  // -
+
+ private:
+  void BindBufferRangeImpl(const GLenum target, const GLuint index,
+                           WebGLBufferJS* const buffer, const uint64_t offset,
+                           const uint64_t size);
 
-  void BindBuffer(GLenum target, const WebGLId<WebGLBuffer>& buffer);
+ public:
+  void BindBufferBase(const GLenum target, const GLuint index,
+                      WebGLBufferJS* const buffer) {
+    const FuncScope funcScope(*this, "bindBufferBase");
+    if (IsContextLost()) return;
+
+    BindBufferRangeImpl(target, index, buffer, 0, 0);
+  }
 
-  void BindBufferBase(GLenum target, GLuint index,
-                      const WebGLId<WebGLBuffer>& buffer);
+  void BindBufferRange(const GLenum target, const GLuint index,
+                       WebGLBufferJS* const buffer, const WebGLintptr offset,
+                       const WebGLsizeiptr size) {
+    const FuncScope funcScope(*this, "bindBufferRange");
+    if (IsContextLost()) return;
+
+    if (buffer) {
+      if (!ValidateNonNegative("offset", offset)) return;
 
-  void BindBufferRange(GLenum target, GLuint index,
-                       const WebGLId<WebGLBuffer>& buffer, WebGLintptr offset,
-                       WebGLsizeiptr size);
+      if (size < 1) {
+        EnqueueError(LOCAL_GL_INVALID_VALUE,
+                     "`size` must be positive for non-null `buffer`.");
+        return;
+      }
+    }
 
-  void DeleteBuffer(const WebGLId<WebGLBuffer>& aBuf);
+    BindBufferRangeImpl(target, index, buffer, static_cast<uint64_t>(offset),
+                        static_cast<uint64_t>(size));
+  }
+
+  // -
 
   void CopyBufferSubData(GLenum readTarget, GLenum writeTarget,
                          GLintptr readOffset, GLintptr writeOffset,
@@ -933,20 +1273,67 @@
                         GLuint dstElemOffset, GLuint dstElemCountOverride);
 
   // -------------------------- Framebuffer Objects --------------------------
-  already_AddRefed<ClientWebGLFramebuffer> CreateFramebuffer();
 
   void BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter);
 
-  void FramebufferTextureLayer(GLenum target, GLenum attachment,
-                               const WebGLId<WebGLTexture>& textureId,
-                               GLint level, GLint layer);
+  // -
+
+ private:
+  // `bindTarget` if non-zero allows initializing the rb/tex with that target.
+  void FramebufferAttach(GLenum target, GLenum attachEnum, GLenum bindTarget,
+                         WebGLRenderbufferJS*, WebGLTextureJS*,
+                         uint32_t mipLevel, uint32_t zLayer,
+                         uint32_t numViewLayers) const;
+
+ public:
+  void FramebufferRenderbuffer(GLenum target, GLenum attachSlot,
+                               GLenum rbTarget, WebGLRenderbufferJS* rb) const {
+    const FuncScope funcScope(*this, "framebufferRenderbuffer");
+    if (IsContextLost()) return;
+    if (rbTarget != LOCAL_GL_RENDERBUFFER) {
+      EnqueueError_ArgEnum("rbTarget", rbTarget);
+      return;
+    }
+    FramebufferAttach(target, attachSlot, rbTarget, rb, nullptr, 0, 0, 0);
+  }
+
+  void FramebufferTexture2D(GLenum target, GLenum attachSlot,
+                            GLenum texImageTarget, WebGLTextureJS*,
+                            GLint mipLevel) const;
+
+  void FramebufferTextureLayer(GLenum target, GLenum attachSlot,
+                               WebGLTextureJS* tex, GLint mipLevel,
+                               GLint zLayer) const {
+    const FuncScope funcScope(*this, "framebufferTextureLayer");
+    if (IsContextLost()) return;
+    FramebufferAttach(target, attachSlot, 0, nullptr, tex,
+                      static_cast<uint32_t>(mipLevel),
+                      static_cast<uint32_t>(zLayer), 0);
+  }
+
+  void FramebufferTextureMultiview(GLenum target, GLenum attachSlot,
+                                   WebGLTextureJS* tex, GLint mipLevel,
+                                   GLint zLayerBase,
+                                   GLsizei numViewLayers) const {
+    const FuncScope funcScope(*this, "framebufferTextureMultiview");
+    if (IsContextLost()) return;
+    if (numViewLayers < 1) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "`numViewLayers` must be >=1.");
+      return;
+    }
+    FramebufferAttach(target, attachSlot, 0, nullptr, tex,
+                      static_cast<uint32_t>(mipLevel),
+                      static_cast<uint32_t>(zLayerBase),
+                      static_cast<uint32_t>(numViewLayers));
+  }
+
+  // -
 
   void InvalidateFramebuffer(GLenum target,
                              const dom::Sequence<GLenum>& attachments,
                              ErrorResult& unused);
-
   void InvalidateSubFramebuffer(GLenum target,
                                 const dom::Sequence<GLenum>& attachments,
                                 GLint x, GLint y, GLsizei width, GLsizei height,
@@ -960,471 +1347,409 @@
                                   JS::MutableHandleValue retval,
                                   ErrorResult& rv);
 
-  already_AddRefed<ClientWebGLRenderbuffer> CreateRenderbuffer();
+  void BindRenderbuffer(GLenum target, WebGLRenderbufferJS*);
 
   void RenderbufferStorage(GLenum target, GLenum internalFormat, GLsizei width,
-                           GLsizei height);
+                           GLsizei height) const {
+    RenderbufferStorageMultisample(target, 0, internalFormat, width, height);
+  }
 
   void RenderbufferStorageMultisample(GLenum target, GLsizei samples,
                                       GLenum internalFormat, GLsizei width,
-                                      GLsizei height);
+                                      GLsizei height) const;
 
   // --------------------------- Texture objects ---------------------------
-  already_AddRefed<ClientWebGLTexture> CreateTexture();
 
   void ActiveTexture(GLenum texUnit);
 
-  void BindTexture(GLenum texTarget, const WebGLId<WebGLTexture>& tex);
-
-  void DeleteTexture(const WebGLId<WebGLTexture>& aTex);
+  void BindTexture(GLenum texTarget, WebGLTextureJS*);
 
-  void GenerateMipmap(GLenum texTarget);
-
-  void CopyTexImage2D(GLenum target, GLint level, GLenum internalFormat,
-                      GLint x, GLint y, GLsizei width, GLsizei height,
-                      GLint border);
+  void GenerateMipmap(GLenum texTarget) const;
 
   void GetTexParameter(JSContext* cx, GLenum texTarget, GLenum pname,
-                       JS::MutableHandle<JS::Value> retval);
+                       JS::MutableHandle<JS::Value> retval) const;
 
   void TexParameterf(GLenum texTarget, GLenum pname, GLfloat param);
-
   void TexParameteri(GLenum texTarget, GLenum pname, GLint param);
 
+  // -
+
+ private:
+  void TexStorage(uint8_t funcDims, GLenum target, GLsizei levels,
+                  GLenum internalFormat, const ivec3& size) const;
+
+  // Primitive tex upload functions
+  void TexImage(uint8_t funcDims, GLenum target, GLint level,
+                GLenum respecFormat, const ivec3& offset, const ivec3& size,
+                GLint border, const webgl::PackingInfo& pi,
+                const TexImageSource& src) const;
+  void CompressedTexImage(bool sub, uint8_t funcDims, GLenum target,
+                          GLint level, GLenum format, const ivec3& offset,
+                          const ivec3& size, GLint border,
+                          const TexImageSource& src,
+                          GLsizei pboImageSize) const;
+  void CopyTexImage(uint8_t funcDims, GLenum target, GLint level,
+                    GLenum respecFormat, const ivec3& dstOffset,
+                    const ivec2& srcOffset, const ivec2& size,
+                    GLint border) const;
+
+ public:
   void TexStorage2D(GLenum target, GLsizei levels, GLenum internalFormat,
-                    GLsizei width, GLsizei height);
+                    GLsizei width, GLsizei height) const {
+    TexStorage(2, target, levels, internalFormat, {width, height, 1});
+  }
 
   void TexStorage3D(GLenum target, GLsizei levels, GLenum internalFormat,
-                    GLsizei width, GLsizei height, GLsizei depth);
+                    GLsizei width, GLsizei height, GLsizei depth) const {
+    TexStorage(3, target, levels, internalFormat, {width, height, depth});
+  }
 
   ////////////////////////////////////
 
-  template <typename T>
-  void TexImage2D(GLenum target, GLint level, GLenum internalFormat,
-                  GLenum unpackFormat, GLenum unpackType, const T& src,
-                  ErrorResult& out_error) {
-    GLsizei width = 0;
-    GLsizei height = 0;
-    GLint border = 0;
-    TexImage2D(target, level, internalFormat, width, height, border,
-               unpackFormat, unpackType, src, out_error);
-  }
-
-  template <typename T>
+  template <typename T>  // TexImageSource or WebGLintptr
   void TexImage2D(GLenum target, GLint level, GLenum internalFormat,
                   GLsizei width, GLsizei height, GLint border,
                   GLenum unpackFormat, GLenum unpackType, const T& anySrc,
-                  ErrorResult& out_error) {
+                  ErrorResult& out_error) const {
     const TexImageSourceAdapter src(&anySrc, &out_error);
-    TexImage2D(target, level, internalFormat, width, height, border,
-               unpackFormat, unpackType, src);
+    TexImage(2, target, level, internalFormat, {0, 0, 0}, {width, height, 1},
+             border, {unpackFormat, unpackType}, src);
   }
 
   void TexImage2D(GLenum target, GLint level, GLenum internalFormat,
                   GLsizei width, GLsizei height, GLint border,
                   GLenum unpackFormat, GLenum unpackType,
                   const dom::ArrayBufferView& view, GLuint viewElemOffset,
-                  ErrorResult&) {
+                  ErrorResult&) const {
     const TexImageSourceAdapter src(&view, viewElemOffset);
-    TexImage2D(target, level, internalFormat, width, height, border,
-               unpackFormat, unpackType, src);
+    TexImage(2, target, level, internalFormat, {0, 0, 0}, {width, height, 1},
+             border, {unpackFormat, unpackType}, src);
   }
 
- protected:
-  void TexImage2D(GLenum target, GLint level, GLenum internalFormat,
-                  GLsizei width, GLsizei height, GLint border,
-                  GLenum unpackFormat, GLenum unpackType,
-                  const TexImageSource& src);
-
-  ////////////////////////////////////
+  // -
 
- public:
-  template <typename T>
-  void TexSubImage2D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
-                     GLenum unpackFormat, GLenum unpackType, const T& src,
-                     ErrorResult& out_error) {
-    GLsizei width = 0;
-    GLsizei height = 0;
-    TexSubImage2D(target, level, xOffset, yOffset, width, height, unpackFormat,
-                  unpackType, src, out_error);
-  }
-
-  template <typename T>
+  template <typename T>  // TexImageSource or WebGLintptr
   void TexSubImage2D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
                      GLsizei width, GLsizei height, GLenum unpackFormat,
                      GLenum unpackType, const T& anySrc,
-                     ErrorResult& out_error) {
+                     ErrorResult& out_error) const {
     const TexImageSourceAdapter src(&anySrc, &out_error);
-    TexSubImage2D(target, level, xOffset, yOffset, width, height, unpackFormat,
-                  unpackType, src);
+    TexImage(2, target, level, 0, {xOffset, yOffset, 0}, {width, height, 1}, 0,
+             {unpackFormat, unpackType}, src);
   }
 
   void TexSubImage2D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
                      GLsizei width, GLsizei height, GLenum unpackFormat,
                      GLenum unpackType, const dom::ArrayBufferView& view,
-                     GLuint viewElemOffset, ErrorResult&) {
+                     GLuint viewElemOffset, ErrorResult&) const {
     const TexImageSourceAdapter src(&view, viewElemOffset);
-    TexSubImage2D(target, level, xOffset, yOffset, width, height, unpackFormat,
-                  unpackType, src);
+    TexImage(2, target, level, 0, {xOffset, yOffset, 0}, {width, height, 1}, 0,
+             {unpackFormat, unpackType}, src);
   }
 
- protected:
-  void TexSubImage2D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
-                     GLsizei width, GLsizei height, GLenum unpackFormat,
-                     GLenum unpackType, const TexImageSource& src);
+  // -
 
-  ////////////////////////////////////
-
- public:
-  template <typename T>
+  template <typename T>  // TexImageSource or WebGLintptr
   void TexImage3D(GLenum target, GLint level, GLenum internalFormat,
                   GLsizei width, GLsizei height, GLsizei depth, GLint border,
                   GLenum unpackFormat, GLenum unpackType, const T& anySrc,
-                  ErrorResult& out_error) {
+                  ErrorResult& out_error) const {
     const TexImageSourceAdapter src(&anySrc, &out_error);
-    TexImage3D(target, level, internalFormat, width, height, depth, border,
-               unpackFormat, unpackType, src);
+    TexImage(3, target, level, internalFormat, {0, 0, 0},
+             {width, height, depth}, border, {unpackFormat, unpackType}, src);
   }
 
   void TexImage3D(GLenum target, GLint level, GLenum internalFormat,
                   GLsizei width, GLsizei height, GLsizei depth, GLint border,
                   GLenum unpackFormat, GLenum unpackType,
                   const dom::ArrayBufferView& view, GLuint viewElemOffset,
-                  ErrorResult&) {
+                  ErrorResult&) const {
     const TexImageSourceAdapter src(&view, viewElemOffset);
-    TexImage3D(target, level, internalFormat, width, height, depth, border,
-               unpackFormat, unpackType, src);
+    TexImage(3, target, level, internalFormat, {0, 0, 0},
+             {width, height, depth}, border, {unpackFormat, unpackType}, src);
   }
 
- protected:
-  void TexImage3D(GLenum target, GLint level, GLenum internalFormat,
-                  GLsizei width, GLsizei height, GLsizei depth, GLint border,
-                  GLenum unpackFormat, GLenum unpackType,
-                  const TexImageSource& src);
+  // -
 
-  ////////////////////////////////////
-
- public:
-  template <typename T>
+  template <typename T>  // TexImageSource or WebGLintptr
   void TexSubImage3D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
                      GLint zOffset, GLsizei width, GLsizei height,
                      GLsizei depth, GLenum unpackFormat, GLenum unpackType,
-                     const T& anySrc, ErrorResult& out_error) {
+                     const T& anySrc, ErrorResult& out_error) const {
     const TexImageSourceAdapter src(&anySrc, &out_error);
-    TexSubImage3D(target, level, xOffset, yOffset, zOffset, width, height,
-                  depth, unpackFormat, unpackType, src);
+    TexImage(3, target, level, 0, {xOffset, yOffset, zOffset},
+             {width, height, depth}, 0, {unpackFormat, unpackType}, src);
   }
 
   void TexSubImage3D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
                      GLint zOffset, GLsizei width, GLsizei height,
                      GLsizei depth, GLenum unpackFormat, GLenum unpackType,
                      const dom::Nullable<dom::ArrayBufferView>& maybeSrcView,
-                     GLuint srcElemOffset, ErrorResult&) {
+                     GLuint srcElemOffset, ErrorResult&) const {
     const TexImageSourceAdapter src(&maybeSrcView, srcElemOffset);
-    TexSubImage3D(target, level, xOffset, yOffset, zOffset, width, height,
-                  depth, unpackFormat, unpackType, src);
+    TexImage(3, target, level, 0, {xOffset, yOffset, zOffset},
+             {width, height, depth}, 0, {unpackFormat, unpackType}, src);
   }
 
- protected:
-  void TexSubImage3D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
-                     GLint zOffset, GLsizei width, GLsizei height,
-                     GLsizei depth, GLenum unpackFormat, GLenum unpackType,
-                     const TexImageSource& src);
-
   ////////////////////////////////////
 
  public:
   void CompressedTexImage2D(GLenum target, GLint level, GLenum internalFormat,
                             GLsizei width, GLsizei height, GLint border,
-                            GLsizei imageSize, WebGLsizeiptr offset) {
-    const FuncScope scope(this, FuncScopeId::compressedTexImage2D);
-    const uint8_t funcDims = 2;
-    const GLsizei depth = 1;
-    const TexImageSourceAdapter src(&offset, 0, 0);
-    CompressedTexImage(funcDims, target, level, internalFormat, width, height,
-                       depth, border, src, Some(imageSize), GetFuncScopeId());
+                            GLsizei imageSize, WebGLintptr offset) const {
+    const TexImageSourceAdapter src(&offset);
+    CompressedTexImage(false, 2, target, level, internalFormat, {0, 0, 0},
+                       {width, height, 1}, border, src, imageSize);
   }
 
-  template <typename T>
   void CompressedTexImage2D(GLenum target, GLint level, GLenum internalFormat,
                             GLsizei width, GLsizei height, GLint border,
-                            const T& anySrc, GLuint viewElemOffset = 0,
-                            GLuint viewElemLengthOverride = 0) {
-    const FuncScope scope(this, FuncScopeId::compressedTexImage2D);
-    const uint8_t funcDims = 2;
-    const GLsizei depth = 1;
-    const TexImageSourceAdapter src(&anySrc, viewElemOffset,
+                            const dom::ArrayBufferView& view,
+                            GLuint viewElemOffset = 0,
+                            GLuint viewElemLengthOverride = 0) const {
+    const TexImageSourceAdapter src(&view, viewElemOffset,
                                     viewElemLengthOverride);
-    CompressedTexImage(funcDims, target, level, internalFormat, width, height,
-                       depth, border, src, Nothing(), GetFuncScopeId());
+    CompressedTexImage(false, 2, target, level, internalFormat, {0, 0, 0},
+                       {width, height, 1}, border, src, 0);
   }
 
+  // -
+
   void CompressedTexSubImage2D(GLenum target, GLint level, GLint xOffset,
                                GLint yOffset, GLsizei width, GLsizei height,
                                GLenum unpackFormat, GLsizei imageSize,
-                               WebGLsizeiptr offset) {
-    const FuncScope scope(this, FuncScopeId::compressedTexSubImage2D);
-    const uint8_t funcDims = 2;
-    const GLint zOffset = 0;
-    const GLsizei depth = 1;
-    const TexImageSourceAdapter src(&offset, 0, 0);
-    CompressedTexSubImage(funcDims, target, level, xOffset, yOffset, zOffset,
-                          width, height, depth, unpackFormat, src,
-                          Some(imageSize), GetFuncScopeId());
+                               WebGLintptr offset) const {
+    const TexImageSourceAdapter src(&offset);
+    CompressedTexImage(true, 2, target, level, unpackFormat,
+                       {xOffset, yOffset, 0}, {width, height, 1}, 0, src,
+                       imageSize);
   }
 
-  template <typename T>
   void CompressedTexSubImage2D(GLenum target, GLint level, GLint xOffset,
                                GLint yOffset, GLsizei width, GLsizei height,
-                               GLenum unpackFormat, const T& anySrc,
+                               GLenum unpackFormat,
+                               const dom::ArrayBufferView& view,
                                GLuint viewElemOffset = 0,
-                               GLuint viewElemLengthOverride = 0) {
-    const FuncScope scope(this, FuncScopeId::compressedTexSubImage2D);
-    const uint8_t funcDims = 2;
-    const GLint zOffset = 0;
-    const GLsizei depth = 1;
-    const TexImageSourceAdapter src(&anySrc, viewElemOffset,
+                               GLuint viewElemLengthOverride = 0) const {
+    const TexImageSourceAdapter src(&view, viewElemOffset,
                                     viewElemLengthOverride);
-    CompressedTexSubImage(funcDims, target, level, xOffset, yOffset, zOffset,
-                          width, height, depth, unpackFormat, src, Nothing(),
-                          GetFuncScopeId());
+    CompressedTexImage(true, 2, target, level, unpackFormat,
+                       {xOffset, yOffset, 0}, {width, height, 1}, 0, src, 0);
   }
 
-  ////////////////////////////////////
+  // -
 
- public:
   void CompressedTexImage3D(GLenum target, GLint level, GLenum internalFormat,
                             GLsizei width, GLsizei height, GLsizei depth,
                             GLint border, GLsizei imageSize,
-                            WebGLintptr offset) {
-    const FuncScope scope(this, FuncScopeId::compressedTexImage3D);
-    const uint8_t funcDims = 3;
-    const TexImageSourceAdapter src(&offset, 0, 0);
-    CompressedTexImage(funcDims, target, level, internalFormat, width, height,
-                       depth, border, src, Some(imageSize), GetFuncScopeId());
+                            WebGLintptr offset) const {
+    const TexImageSourceAdapter src(&offset);
+    CompressedTexImage(false, 3, target, level, internalFormat, {0, 0, 0},
+                       {width, height, depth}, border, src, imageSize);
   }
 
-  template <typename T>
   void CompressedTexImage3D(GLenum target, GLint level, GLenum internalFormat,
                             GLsizei width, GLsizei height, GLsizei depth,
-                            GLint border, const T& anySrc,
+                            GLint border, const dom::ArrayBufferView& view,
                             GLuint viewElemOffset = 0,
-                            GLuint viewElemLengthOverride = 0) {
-    const FuncScope scope(this, FuncScopeId::compressedTexImage3D);
-    const uint8_t funcDims = 3;
-    const TexImageSourceAdapter src(&anySrc, viewElemOffset,
+                            GLuint viewElemLengthOverride = 0) const {
+    const TexImageSourceAdapter src(&view, viewElemOffset,
                                     viewElemLengthOverride);
-    CompressedTexImage(funcDims, target, level, internalFormat, width, height,
-                       depth, border, src, Nothing(), GetFuncScopeId());
+    CompressedTexImage(false, 3, target, level, internalFormat, {0, 0, 0},
+                       {width, height, depth}, border, src, 0);
   }
 
+  // -
+
   void CompressedTexSubImage3D(GLenum target, GLint level, GLint xOffset,
                                GLint yOffset, GLint zOffset, GLsizei width,
                                GLsizei height, GLsizei depth,
                                GLenum unpackFormat, GLsizei imageSize,
-                               WebGLintptr offset) {
-    const FuncScope scope(this, FuncScopeId::compressedTexSubImage3D);
-    const uint8_t funcDims = 3;
-    const TexImageSourceAdapter src(&offset, 0, 0);
-    CompressedTexSubImage(funcDims, target, level, xOffset, yOffset, zOffset,
-                          width, height, depth, unpackFormat, src,
-                          Some(imageSize), GetFuncScopeId());
+                               WebGLintptr offset) const {
+    const TexImageSourceAdapter src(&offset);
+    CompressedTexImage(true, 3, target, level, unpackFormat,
+                       {xOffset, yOffset, zOffset}, {width, height, depth}, 0,
+                       src, imageSize);
   }
 
-  template <typename T>
   void CompressedTexSubImage3D(GLenum target, GLint level, GLint xOffset,
                                GLint yOffset, GLint zOffset, GLsizei width,
                                GLsizei height, GLsizei depth,
-                               GLenum unpackFormat, const T& anySrc,
+                               GLenum unpackFormat,
+                               const dom::ArrayBufferView& view,
                                GLuint viewElemOffset = 0,
-                               GLuint viewElemLengthOverride = 0) {
-    const FuncScope scope(this, FuncScopeId::compressedTexSubImage3D);
-    const uint8_t funcDims = 3;
-    const TexImageSourceAdapter src(&anySrc, viewElemOffset,
+                               GLuint viewElemLengthOverride = 0) const {
+    const TexImageSourceAdapter src(&view, viewElemOffset,
                                     viewElemLengthOverride);
-    CompressedTexSubImage(funcDims, target, level, xOffset, yOffset, zOffset,
-                          width, height, depth, unpackFormat, src, Nothing(),
-                          GetFuncScopeId());
+    CompressedTexImage(true, 3, target, level, unpackFormat,
+                       {xOffset, yOffset, zOffset}, {width, height, depth}, 0,
+                       src, 0);
   }
 
- protected:
-  void TexImage(uint8_t funcDims, GLenum target, GLint level,
-                GLenum internalFormat, GLsizei width, GLsizei height,
-                GLsizei depth, GLint border, GLenum unpackFormat,
-                GLenum unpackType, const TexImageSource& src,
-                FuncScopeId aFuncId);
-  void TexSubImage(uint8_t funcDims, GLenum target, GLint level, GLint xOffset,
-                   GLint yOffset, GLint zOffset, GLsizei width, GLsizei height,
-                   GLsizei depth, GLenum unpackFormat, GLenum unpackType,
-                   const TexImageSource& src, FuncScopeId aFuncId);
-  void CompressedTexImage(uint8_t funcDims, GLenum target, GLint level,
-                          GLenum internalFormat, GLsizei width, GLsizei height,
-                          GLsizei depth, GLint border,
-                          const TexImageSource& src,
-                          const Maybe<GLsizei>& expectedImageSize,
-                          FuncScopeId aFuncId);
-  void CompressedTexSubImage(uint8_t funcDims, GLenum target, GLint level,
-                             GLint xOffset, GLint yOffset, GLint zOffset,
-                             GLsizei width, GLsizei height, GLsizei depth,
-                             GLenum unpackFormat, const TexImageSource& src,
-                             const Maybe<GLsizei>& expectedImageSize,
-                             FuncScopeId aFuncId);
+  // --------------------
 
-  ////////////////////////////////////
+  void CopyTexImage2D(GLenum target, GLint level, GLenum internalFormat,
+                      GLint x, GLint y, GLsizei width, GLsizei height,
+                      GLint border) const {
+    CopyTexImage(2, target, level, internalFormat, {0, 0, 0}, {x, y},
+                 {width, height}, border);
+  }
 
- public:
   void CopyTexSubImage2D(GLenum target, GLint level, GLint xOffset,
                          GLint yOffset, GLint x, GLint y, GLsizei width,
-                         GLsizei height);
-
-  ////////////////////////////////////
+                         GLsizei height) const {
+    CopyTexImage(2, target, level, 0, {xOffset, yOffset, 0}, {x, y},
+                 {width, height}, 0);
+  }
 
   void CopyTexSubImage3D(GLenum target, GLint level, GLint xOffset,
                          GLint yOffset, GLint zOffset, GLint x, GLint y,
-                         GLsizei width, GLsizei height);
+                         GLsizei width, GLsizei height) const {
+    CopyTexImage(3, target, level, 0, {xOffset, yOffset, zOffset}, {x, y},
+                 {width, height}, 0);
+  }
+
+  // -------------------
+  // Forward legacy TexImageSource uploads for default width/height
 
-  // ------------------- Programs and shaders --------------------------------
- public:
-  already_AddRefed<ClientWebGLProgram> CreateProgram();
-  already_AddRefed<ClientWebGLShader> CreateShader(GLenum type);
-  void GetAttachedShaders(
-      const WebGLId<WebGLProgram>& prog,
-      dom::Nullable<nsTArray<RefPtr<ClientWebGLShader>>>& retval);
+  template <typename TexImageSourceT>
+  void TexImage2D(GLenum target, GLint level, GLenum internalFormat,
+                  GLenum unpackFormat, GLenum unpackType,
+                  const TexImageSourceT& anySrc, ErrorResult& out_error) const {
+    TexImage2D(target, level, internalFormat, 0, 0, 0, unpackFormat, unpackType,
+               anySrc, out_error);
+  }
 
-  void UseProgram(const WebGLId<WebGLProgram>& prog);
-
-  void ValidateProgram(const WebGLId<WebGLProgram>& prog);
+  template <typename TexImageSourceT>
+  void TexSubImage2D(GLenum target, GLint level, GLint xOffset, GLint yOffset,
+                     GLenum unpackFormat, GLenum unpackType,
+                     const TexImageSourceT& anySrc,
+                     ErrorResult& out_error) const {
+    TexSubImage2D(target, level, xOffset, yOffset, 0, 0, unpackFormat,
+                  unpackType, anySrc, out_error);
+  }
 
-  GLint GetFragDataLocation(const WebGLId<WebGLProgram>& prog,
-                            const nsAString& name);
-
+  // =========================================================================
   // ------------------------ Uniforms and attributes ------------------------
  public:
-  already_AddRefed<ClientWebGLActiveInfo> GetActiveAttrib(
-      const WebGLId<WebGLProgram>& prog, GLuint index);
-
-  already_AddRefed<ClientWebGLActiveInfo> GetActiveUniform(
-      const WebGLId<WebGLProgram>& prog, GLuint index);
-
-  void GetActiveUniforms(JSContext* cx, const WebGLId<WebGLProgram>& prog,
-                         const dom::Sequence<GLuint>& uniformIndices,
-                         GLenum pname, JS::MutableHandleValue retval);
-
-  void GetUniformIndices(const WebGLId<WebGLProgram>& prog,
-                         const dom::Sequence<nsString>& uniformNames,
-                         dom::Nullable<nsTArray<GLuint>>& retval);
-
-  void GetActiveUniformBlockParameter(JSContext* cx,
-                                      const WebGLId<WebGLProgram>& prog,
-                                      GLuint uniformBlockIndex, GLenum pname,
-                                      JS::MutableHandleValue retval,
-                                      ErrorResult& rv);
-
-  void GetActiveUniformBlockName(const WebGLId<WebGLProgram>& prog,
-                                 GLuint uniformBlockIndex, nsAString& retval);
-
-  GLuint GetUniformBlockIndex(const WebGLId<WebGLProgram>& prog,
-                              const nsAString& uniformBlockName);
-
   void GetVertexAttrib(JSContext* cx, GLuint index, GLenum pname,
                        JS::MutableHandle<JS::Value> retval, ErrorResult& rv);
 
-  void Uniform1f(const WebGLId<WebGLUniformLocation>& aLoc, GLfloat x);
-
-  void Uniform2f(const WebGLId<WebGLUniformLocation>& aLoc, GLfloat x,
-                 GLfloat y);
-
-  void Uniform3f(const WebGLId<WebGLUniformLocation>& aLoc, GLfloat x,
-                 GLfloat y, GLfloat z);
-
-  void Uniform4f(const WebGLId<WebGLUniformLocation>& aLoc, GLfloat x,
-                 GLfloat y, GLfloat z, GLfloat w);
+ private:
+  const webgl::LinkResult* GetActiveLinkResult() const {
+    const auto& state = State();
+    if (state.mCurrentProgram) {
+      (void)GetLinkResult(*state.mCurrentProgram->js);
+    }
+    return state.mActiveLinkResult.get();
+  }
 
-  void Uniform1i(const WebGLId<WebGLUniformLocation>& aLoc, GLint x);
-
-  void Uniform2i(const WebGLId<WebGLUniformLocation>& aLoc, GLint x, GLint y);
+  void UniformData(GLenum funcElemType, const WebGLUniformLocationJS* const loc,
+                   bool transpose, const Range<const uint8_t>& bytes,
+                   GLuint elemOffset = 0, GLuint elemCountOverride = 0) const;
 
-  void Uniform3i(const WebGLId<WebGLUniformLocation>& aLoc, GLint x, GLint y,
-                 GLint z);
-
-  void Uniform4i(const WebGLId<WebGLUniformLocation>& aLoc, GLint x, GLint y,
-                 GLint z, GLint w);
-
-  void Uniform1ui(const WebGLId<WebGLUniformLocation>& aLoc, GLuint x);
+  // -
 
-  void Uniform2ui(const WebGLId<WebGLUniformLocation>& aLoc, GLuint x,
-                  GLuint y);
-
-  void Uniform3ui(const WebGLId<WebGLUniformLocation>& aLoc, GLuint x, GLuint y,
-                  GLuint z);
-
-  void Uniform4ui(const WebGLId<WebGLUniformLocation>& aLoc, GLuint x, GLuint y,
-                  GLuint z, GLuint w);
-
-#define FOO(N)                                                         \
-  void Uniform##N##fv(WebGLId<WebGLUniformLocation> loc,               \
-                      const Float32ListU& list, GLuint elemOffset = 0, \
-                      GLuint elemCountOverride = 0);
-
-  FOO(1)
-  FOO(2)
-  FOO(3)
-  FOO(4)
-
-#undef FOO
-
-  //////
+  template <typename T>
+  Maybe<Range<T>> ValidateSubrange(const Range<T>& data, size_t elemOffset,
+                                   size_t elemLengthOverride = 0) const {
+    auto ret = data;
+    if (elemOffset > ret.length()) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE,
+                   "`elemOffset` too large for `data`.");
+      return {};
+    }
+    ret = {ret.begin() + elemOffset, ret.end()};
+    if (elemLengthOverride) {
+      if (elemLengthOverride > ret.length()) {
+        EnqueueError(
+            LOCAL_GL_INVALID_VALUE,
+            "`elemLengthOverride` too large for `data` and `elemOffset`.");
+        return {};
+      }
+      ret = {ret.begin().get(), elemLengthOverride};
+    }
+    return Some(ret);
+  }
 
-#define FOO(N)                                                       \
-  void Uniform##N##iv(WebGLId<WebGLUniformLocation> loc,             \
-                      const Int32ListU& list, GLuint elemOffset = 0, \
-                      GLuint elemCountOverride = 0);
-
-  FOO(1)
-  FOO(2)
-  FOO(3)
-  FOO(4)
-
-#undef FOO
+ public:
+#define _(T, type_t, TYPE)                                                    \
+  void Uniform1##T(const WebGLUniformLocationJS* const loc, type_t x) const { \
+    const type_t arr[] = {x};                                                 \
+    UniformData(TYPE, loc, false, MakeByteRange(arr));                        \
+  }                                                                           \
+  void Uniform2##T(const WebGLUniformLocationJS* const loc, type_t x,         \
+                   type_t y) const {                                          \
+    const type_t arr[] = {x, y};                                              \
+    UniformData(TYPE##_VEC2, loc, false, MakeByteRange(arr));                 \
+  }                                                                           \
+  void Uniform3##T(const WebGLUniformLocationJS* const loc, type_t x,         \
+                   type_t y, type_t z) const {                                \
+    const type_t arr[] = {x, y, z};                                           \
+    UniformData(TYPE##_VEC3, loc, false, MakeByteRange(arr));                 \
+  }                                                                           \
+  void Uniform4##T(const WebGLUniformLocationJS* const loc, type_t x,         \
+                   type_t y, type_t z, type_t w) const {                      \
+    const type_t arr[] = {x, y, z, w};                                        \
+    UniformData(TYPE##_VEC4, loc, false, MakeByteRange(arr));                 \
+  }
 
-  //////
+  _(f, float, LOCAL_GL_FLOAT)
+  _(i, int32_t, LOCAL_GL_INT)
+  _(ui, uint32_t, LOCAL_GL_UNSIGNED_INT)
+
+#undef _
+
+  // -
 
-#define FOO(N)                                                         \
-  void Uniform##N##uiv(WebGLId<WebGLUniformLocation> loc,              \
-                       const Uint32ListU& list, GLuint elemOffset = 0, \
-                       GLuint elemCountOverride = 0);
-
-  FOO(1)
-  FOO(2)
-  FOO(3)
-  FOO(4)
+#define _(NT, TypeListU, TYPE)                                      \
+  void Uniform##NT##v(const WebGLUniformLocationJS* const loc,      \
+                      const TypeListU& list, GLuint elemOffset = 0, \
+                      GLuint elemCountOverride = 0) const {         \
+    UniformData(TYPE, loc, false, MakeByteRange(list), elemOffset,  \
+                elemCountOverride);                                 \
+  }
 
-#undef FOO
-
-  //////
+  _(1f, Float32ListU, LOCAL_GL_FLOAT)
+  _(2f, Float32ListU, LOCAL_GL_FLOAT_VEC2)
+  _(3f, Float32ListU, LOCAL_GL_FLOAT_VEC3)
+  _(4f, Float32ListU, LOCAL_GL_FLOAT_VEC4)
+  _(1i, Int32ListU, LOCAL_GL_INT)
+  _(2i, Int32ListU, LOCAL_GL_INT_VEC2)
+  _(3i, Int32ListU, LOCAL_GL_INT_VEC3)
+  _(4i, Int32ListU, LOCAL_GL_INT_VEC4)
+  _(1ui, Uint32ListU, LOCAL_GL_UNSIGNED_INT)
+  _(2ui, Uint32ListU, LOCAL_GL_UNSIGNED_INT_VEC2)
+  _(3ui, Uint32ListU, LOCAL_GL_UNSIGNED_INT_VEC3)
+  _(4ui, Uint32ListU, LOCAL_GL_UNSIGNED_INT_VEC4)
 
-#define FOO(X, A, B)                                                           \
-  void UniformMatrix##X##fv(WebGLId<WebGLUniformLocation> loc, bool transpose, \
-                            const Float32ListU& list, GLuint elemOffset = 0,   \
-                            GLuint elemCountOverride = 0);
+#undef _
 
-  FOO(2, 2, 2)
-  FOO(2x3, 2, 3)
-  FOO(2x4, 2, 4)
+  // -
 
-  FOO(3x2, 3, 2)
-  FOO(3, 3, 3)
-  FOO(3x4, 3, 4)
+#define _(X)                                                                   \
+  void UniformMatrix##X##fv(const WebGLUniformLocationJS* loc, bool transpose, \
+                            const Float32ListU& list, GLuint elemOffset = 0,   \
+                            GLuint elemCountOverride = 0) const {              \
+    UniformData(LOCAL_GL_FLOAT_MAT##X, loc, transpose, MakeByteRange(list),    \
+                elemOffset, elemCountOverride);                                \
+  }
+
+  _(2)
+  _(2x3)
+  _(2x4)
 
-  FOO(4x2, 4, 2)
-  FOO(4x3, 4, 3)
-  FOO(4, 4, 4)
+  _(3x2)
+  _(3)
+  _(3x4)
 
-#undef FOO
+  _(4x2)
+  _(4x3)
+  _(4)
 
-  void UniformBlockBinding(const WebGLId<WebGLProgram>& progId,
-                           GLuint uniformBlockIndex,
-                           GLuint uniformBlockBinding);
+#undef _
+
+  // -
 
   void EnableVertexAttribArray(GLuint index);
 
@@ -1432,54 +1757,137 @@
 
   WebGLsizeiptr GetVertexAttribOffset(GLuint index, GLenum pname);
 
-  void VertexAttrib1f(GLuint index, GLfloat x);
-  void VertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
-  void VertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
+  // -
+
+ private:
+  void VertexAttrib4Tv(GLuint index, webgl::AttribBaseType,
+                       const Range<const uint8_t>&);
+
+ public:
+  void VertexAttrib1f(GLuint index, GLfloat x) {
+    VertexAttrib4f(index, x, 0, 0, 1);
+  }
+  void VertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
+    VertexAttrib4f(index, x, y, 0, 1);
+  }
+  void VertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
+    VertexAttrib4f(index, x, y, z, 1);
+  }
 
-  void VertexAttrib1fv(GLuint index, const Float32ListU& list);
+  void VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z,
+                      GLfloat w) {
+    const float arr[4] = {x, y, z, w};
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Float, MakeByteRange(arr));
+  }
+
+  // -
+
+  void VertexAttrib1fv(const GLuint index, const Float32ListU& list) {
+    const FuncScope funcScope(*this, "vertexAttrib1fv");
+    if (IsContextLost()) return;
+
+    const auto range = MakeRange(list);
+    if (range.length() < 1) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "Length of `list` must be >=1.");
+      return;
+    }
+
+    VertexAttrib1f(index, range[0]);
+  }
+
+  void VertexAttrib2fv(const GLuint index, const Float32ListU& list) {
+    const FuncScope funcScope(*this, "vertexAttrib1fv");
+    if (IsContextLost()) return;
 
-  void VertexAttrib2fv(GLuint index, const Float32ListU& list);
+    const auto range = MakeRange(list);
+    if (range.length() < 2) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "Length of `list` must be >=2.");
+      return;
+    }
+
+    VertexAttrib2f(index, range[0], range[1]);
+  }
+
+  void VertexAttrib3fv(const GLuint index, const Float32ListU& list) {
+    const FuncScope funcScope(*this, "vertexAttrib1fv");
+    if (IsContextLost()) return;
+
+    const auto range = MakeRange(list);
+    if (range.length() < 3) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "Length of `list` must be >=3.");
+      return;
+    }
+
+    VertexAttrib3f(index, range[0], range[1], range[2]);
+  }
 
-  void VertexAttrib3fv(GLuint index, const Float32ListU& list);
+  void VertexAttrib4fv(GLuint index, const Float32ListU& list) {
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Float, MakeByteRange(list));
+  }
+  void VertexAttribI4iv(GLuint index, const Int32ListU& list) {
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Int, MakeByteRange(list));
+  }
+  void VertexAttribI4uiv(GLuint index, const Uint32ListU& list) {
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Uint, MakeByteRange(list));
+  }
 
-  void VertexAttrib4fv(GLuint index, const Float32ListU& list);
+  void VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
+    const int32_t arr[4] = {x, y, z, w};
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Int, MakeByteRange(arr));
+  }
+  void VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
+    const uint32_t arr[4] = {x, y, z, w};
+    VertexAttrib4Tv(index, webgl::AttribBaseType::Uint, MakeByteRange(arr));
+  }
 
+ private:
+  void VertexAttribPointerImpl(bool isFuncInt, GLuint index, GLint size,
+                               GLenum type, WebGLboolean normalized,
+                               GLsizei iStride, WebGLintptr iByteOffset);
+
+ public:
   void VertexAttribIPointer(GLuint index, GLint size, GLenum type,
-                            GLsizei stride, WebGLintptr byteOffset);
-
-  void VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w,
-                      FuncScopeId aFuncId = FuncScopeId::vertexAttrib4f);
-  void VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w,
-                       FuncScopeId aFuncId = FuncScopeId::vertexAttribI4i);
-
-  void VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w,
-                        FuncScopeId aFuncId = FuncScopeId::vertexAttribI4ui);
-
-  void VertexAttribI4iv(GLuint index, const Int32ListU& list);
-
-  void VertexAttribI4uiv(GLuint index, const Uint32ListU& list);
+                            GLsizei stride, WebGLintptr byteOffset) {
+    VertexAttribPointerImpl(true, index, size, type, false, stride, byteOffset);
+  }
 
   void VertexAttribPointer(GLuint index, GLint size, GLenum type,
                            WebGLboolean normalized, GLsizei stride,
-                           WebGLintptr byteOffset);
+                           WebGLintptr byteOffset) {
+    VertexAttribPointerImpl(false, index, size, type, normalized, stride,
+                            byteOffset);
+  }
 
   // -------------------------------- Drawing -------------------------------
  public:
-  void DrawArrays(GLenum mode, GLint first, GLsizei count);
+  void DrawArrays(GLenum mode, GLint first, GLsizei count) {
+    DrawArraysInstanced(mode, first, count, 1, FuncScopeId::drawArrays);
+  }
 
   void DrawElements(GLenum mode, GLsizei count, GLenum type,
-                    WebGLintptr byteOffset);
+                    WebGLintptr byteOffset) {
+    DrawElementsInstanced(mode, count, type, byteOffset, 1,
+                          FuncScopeId::drawElements);
+  }
 
   void DrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count,
-                         GLenum type, WebGLintptr byteOffset);
+                         GLenum type, WebGLintptr byteOffset) {
+    const FuncScope funcScope(*this, "drawRangeElements");
+    if (end < start) {
+      EnqueueError(LOCAL_GL_INVALID_VALUE, "end must be >= start.");
+      return;
+    }
+    DrawElementsInstanced(mode, count, type, byteOffset, 1,
+                          FuncScopeId::drawRangeElements);
+  }
 
   // ------------------------------ Readback -------------------------------
  public:
   void ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                   GLenum format, GLenum type,
                   const dom::Nullable<dom::ArrayBufferView>& maybeView,
-                  dom::CallerType aCallerType, ErrorResult& out_error) {
-    const FuncScope funcScope(this, "readPixels");
+                  dom::CallerType aCallerType, ErrorResult& out_error) const {
+    const FuncScope funcScope(*this, "readPixels");
     if (!ValidateNonNull("pixels", maybeView)) return;
     ReadPixels(x, y, width, height, format, type, maybeView.Value(), 0,
                aCallerType, out_error);
@@ -1487,325 +1895,168 @@
 
   void ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                   GLenum format, GLenum type, WebGLsizeiptr offset,
-                  dom::CallerType aCallerType, ErrorResult& out_error);
+                  dom::CallerType aCallerType, ErrorResult& out_error) const;
 
   void ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                   GLenum format, GLenum type,
                   const dom::ArrayBufferView& dstData, GLuint dstElemOffset,
-                  dom::CallerType aCallerType, ErrorResult& out_error);
+                  dom::CallerType aCallerType, ErrorResult& out_error) const;
 
  protected:
   bool ReadPixels_SharedPrecheck(dom::CallerType aCallerType,
-                                 ErrorResult& out_error);
+                                 ErrorResult& out_error) const;
 
   // ------------------------------ Vertex Array ------------------------------
  public:
-  already_AddRefed<ClientWebGLVertexArray> CreateVertexArray(
-      bool aFromExtension = false);
-
-  void DeleteVertexArray(const WebGLId<WebGLVertexArray>& array,
-                         bool aFromExtension = false);
-
-  void BindVertexArray(const WebGLId<WebGLVertexArray>& array,
-                       bool aFromExtension = false);
+  void BindVertexArray(WebGLVertexArrayJS*);
 
   void DrawArraysInstanced(GLenum mode, GLint first, GLsizei count,
-                           GLsizei primcount, bool aFromExtension = false);
+                           GLsizei primcount,
+                           FuncScopeId aFuncId = FuncScopeId::drawArrays);
 
   void DrawElementsInstanced(
       GLenum mode, GLsizei count, GLenum type, WebGLintptr offset,
       GLsizei primcount,
-      FuncScopeId aFuncId = FuncScopeId::drawElementsInstanced,
-      bool aFromExtension = false);
+      FuncScopeId aFuncId = FuncScopeId::drawElementsInstanced);
 
-  void VertexAttribDivisor(GLuint index, GLuint divisor,
-                           bool aFromExtension = false);
+  void VertexAttribDivisor(GLuint index, GLuint divisor);
 
   // --------------------------------- GL Query
   // ---------------------------------
  public:
-  already_AddRefed<ClientWebGLQuery> CreateQuery(bool aFromExtension = false);
-
-  bool IsQuery(const WebGLId<WebGLQuery>& query,
-               bool aFromExtension = false) const {
-    return query != WebGLId<WebGLQuery>::Invalid();
-  }
-
-  void GetQuery(JSContext* cx, GLenum target, GLenum pname,
-                JS::MutableHandleValue retval,
-                bool aFromExtension = false) const;
-
-  void GetQueryParameter(JSContext* cx, const WebGLId<WebGLQuery>& query,
-                         GLenum pname, JS::MutableHandleValue retval,
-                         bool aFromExtension = false) const;
-
-  void DeleteQuery(const WebGLId<WebGLQuery>& query,
-                   bool aFromExtension = false) const;
-
-  void BeginQuery(GLenum target, const WebGLId<WebGLQuery>& query,
-                  bool aFromExtension = false) const;
-
-  void EndQuery(GLenum target, bool aFromExtension = false) const;
-
-  void QueryCounter(const WebGLId<WebGLQuery>& query, GLenum target) const;
-
-  // --------------------------- Buffer Operations --------------------------
- public:
-  void ClearBufferfv(GLenum buffer, GLint drawBuffer, const Float32ListU& list,
-                     GLuint srcElemOffset);
-  void ClearBufferiv(GLenum buffer, GLint drawBuffer, const Int32ListU& list,
-                     GLuint srcElemOffset);
-  void ClearBufferuiv(GLenum buffer, GLint drawBuffer, const Uint32ListU& list,
-                      GLuint srcElemOffset);
-  void ClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth,
-                     GLint stencil);
+  void GetQuery(JSContext*, GLenum target, GLenum pname,
+                JS::MutableHandleValue retval) const;
+  void GetQueryParameter(JSContext*, WebGLQueryJS&, GLenum pname,
+                         JS::MutableHandleValue retval) const;
+  void BeginQuery(GLenum target, WebGLQueryJS&);
+  void EndQuery(GLenum target);
+  void QueryCounter(WebGLQueryJS&, GLenum target) const;
 
   // -------------------------------- Sampler -------------------------------
-  already_AddRefed<ClientWebGLSampler> CreateSampler();
-  bool IsSampler(const WebGLId<WebGLSampler>& sampler) {
-    return sampler != WebGLId<WebGLSampler>::Invalid();
-  }
 
-  void GetSamplerParameter(JSContext* cx, const WebGLId<WebGLSampler>& sampler,
-                           GLenum pname, JS::MutableHandleValue retval);
+  void GetSamplerParameter(JSContext*, const WebGLSamplerJS&, GLenum pname,
+                           JS::MutableHandleValue retval) const;
 
-  void DeleteSampler(const WebGLId<WebGLSampler>& aId);
-
-  void BindSampler(GLuint unit, const WebGLId<WebGLSampler>& sampler);
-
-  void SamplerParameteri(const WebGLId<WebGLSampler>& samplerId, GLenum pname,
-                         GLint param);
-
-  void SamplerParameterf(const WebGLId<WebGLSampler>& samplerId, GLenum pname,
-                         GLfloat param);
+  void BindSampler(GLuint unit, WebGLSamplerJS*);
+  void SamplerParameteri(WebGLSamplerJS&, GLenum pname, GLint param) const;
+  void SamplerParameterf(WebGLSamplerJS&, GLenum pname, GLfloat param) const;
 
   // ------------------------------- GL Sync ---------------------------------
-  already_AddRefed<ClientWebGLSync> FenceSync(GLenum condition,
-                                              GLbitfield flags);
 
-  bool IsSync(const WebGLId<WebGLSync>& sync) {
-    return sync != WebGLId<WebGLSync>::Invalid();
-  }
-
-  void GetSyncParameter(JSContext* cx, const WebGLId<WebGLSync>& sync,
-                        GLenum pname, JS::MutableHandleValue retval);
-
-  void DeleteSync(const WebGLId<WebGLSync>& sync);
-
-  GLenum ClientWaitSync(const WebGLId<WebGLSync>& sync, GLbitfield flags,
-                        GLuint64 timeout);
-
-  void WaitSync(const WebGLId<WebGLSync>& sync, GLbitfield flags,
-                GLint64 timeout);
+  GLenum ClientWaitSync(WebGLSyncJS&, GLbitfield flags, GLuint64 timeout) const;
+  void GetSyncParameter(JSContext*, WebGLSyncJS&, GLenum pname,
+                        JS::MutableHandleValue retval) const;
+  void WaitSync(const WebGLSyncJS&, GLbitfield flags, GLint64 timeout) const;
 
   // -------------------------- Transform Feedback ---------------------------
-  already_AddRefed<ClientWebGLTransformFeedback> CreateTransformFeedback();
 
-  void DeleteTransformFeedback(const WebGLId<WebGLTransformFeedback>& tf);
-
-  void BindTransformFeedback(GLenum target,
-                             const WebGLId<WebGLTransformFeedback>& tf);
-
+  void BindTransformFeedback(GLenum target, WebGLTransformFeedbackJS*);
   void BeginTransformFeedback(GLenum primitiveMode);
-
   void EndTransformFeedback();
-
   void PauseTransformFeedback();
-
   void ResumeTransformFeedback();
 
-  already_AddRefed<ClientWebGLActiveInfo> GetTransformFeedbackVarying(
-      const WebGLId<WebGLProgram>& prog, GLuint index);
-
-  bool IsTransformFeedback(const WebGLId<WebGLTransformFeedback>& tf) {
-    return tf != WebGLId<WebGLTransformFeedback>::Invalid();
-  }
-
-  void TransformFeedbackVaryings(const WebGLId<WebGLProgram>& program,
-                                 const dom::Sequence<nsString>& varyings,
-                                 GLenum bufferMode);
-
   // ------------------------------ Extensions ------------------------------
  public:
-  static const char* GetExtensionString(WebGLExtensionID ext);
-
   void GetSupportedExtensions(dom::Nullable<nsTArray<nsString>>& retval,
-                              dom::CallerType callerType) {
-    const Maybe<ExtensionSets>& exts = GetCachedExtensions();
+                              dom::CallerType callerType) const;
 
-    // DLP: TODO: Cache the value and return properly filtered string array
-    if (exts) {
-      nsTArray<nsString>& retarr = retval.SetValue();
-      AddExtensionStrings(retarr, exts.ref().mNonSystem);
-      if (callerType == dom::CallerType::System) {
-        AddExtensionStrings(retarr, exts.ref().mSystem);
-      }
-    } else {
-      retval.SetNull();
-    }
-  }
+  bool IsSupported(WebGLExtensionID, dom::CallerType callerType =
+                                         dom::CallerType::NonSystem) const;
 
   void GetExtension(JSContext* cx, const nsAString& name,
                     JS::MutableHandle<JSObject*> retval,
                     dom::CallerType callerType, ErrorResult& rv);
 
  protected:
-  void AddExtensionStrings(nsTArray<nsString>& retarr,
-                           const nsTArray<WebGLExtensionID>& extarr) {
-    for (auto& extension : extarr) {
-      if (extension == WebGLExtensionID::MOZ_debug)
-        continue;  // Hide MOZ_debug from this list.
+  RefPtr<ClientWebGLExtensionBase> GetExtension(WebGLExtensionID ext,
+                                                dom::CallerType callerType);
+  void RequestExtension(WebGLExtensionID) const;
 
-      const char* extStr = GetExtensionString(extension);
-      retarr.AppendElement(NS_ConvertUTF8toUTF16(extStr));
-    }
+ public:
+  bool IsExtensionEnabled(const WebGLExtensionID id) const {
+    return bool(mNotLost->extensions[EnumValue(id)]);
   }
 
-  const Maybe<ExtensionSets>& GetCachedExtensions();
-
-  ClientWebGLExtensionBase* GetExtension(dom::CallerType callerType,
-                                         WebGLExtensionID ext,
-                                         bool toEnable = false);
-
-  void EnableExtension(dom::CallerType callerType, WebGLExtensionID ext);
-
-  ClientWebGLExtensionBase* UseExtension(WebGLExtensionID ext);
-
-  Maybe<ExtensionSets> mExtensions;
-  bool mEnabledExtension[static_cast<uint8_t>(WebGLExtensionID::Max)];
+  void AddCompressedFormat(GLenum);
 
   // ---------------------------- Misc Extensions ----------------------------
  public:
-  void DrawBuffers(const dom::Sequence<GLenum>& buffers,
-                   bool aFromExtension = false);
-
-  void GetASTCExtensionSupportedProfiles(
-      dom::Nullable<nsTArray<nsString>>& retval) const;
+  void DrawBuffers(const dom::Sequence<GLenum>& buffers);
 
-  void GetTranslatedShaderSource(const WebGLId<WebGLShader>& shader,
-                                 nsAString& retval) const;
-
-  void LoseContext(bool isSimulated = true);
-
-  void RestoreContext();
+  void GetSupportedProfilesASTC(
+      dom::Nullable<nsTArray<nsString>>& retval) const;
 
   void MOZDebugGetParameter(JSContext* cx, GLenum pname,
                             JS::MutableHandle<JS::Value> retval,
-                            ErrorResult& rv) const;
+                            ErrorResult& rv) {
+    GetParameter(cx, pname, retval, rv, true);
+  }
 
   // -------------------------------------------------------------------------
   // Client-side methods.  Calls in the Host are forwarded to the client.
   // -------------------------------------------------------------------------
  public:
-  void PostWarning(const nsCString& aWarning);
-  void PostContextCreationError(const nsCString& msg);
-  void OnLostContext();
-  void OnRestoredContext();
-
- public:
-  // The actor failed on the host side.  Make sure that we don't continue to try
-  // to issue commands.
-  void OnQueueFailed() {
-    mContextLost = true;
-    mWebGLChild = nullptr;
-    DrainErrorQueue();
-  }
+  void JsWarning(const std::string&) const;
 
   // -------------------------------------------------------------------------
   // The cross-process communication mechanism
   // -------------------------------------------------------------------------
  protected:
-  template <size_t command, typename... Args>
-  void DispatchAsync(Args&&... aArgs) const {
-    if (mContextLost) {
-      return;
-    }
+  /*
+   template <size_t command, typename... Args>
+   void DispatchAsync(Args&&... aArgs) const {
+     const auto& oop = *mNotLost->outOfProcess;
+     PcqStatus status = oop.mCommandSource->RunAsyncCommand(command, aArgs...);
+     if (!IsSuccess(status)) {
+       if (status == PcqStatus::PcqOOMError) {
+         JsWarning("Ran out-of-memory during WebGL IPC.");
+       }
+       // Not much to do but shut down.  Since this was a Pcq failure and
+       // may have been catastrophic, we don't try to revive it.  Make sure to
+       // post "webglcontextlost"
+       MOZ_ASSERT_UNREACHABLE(
+           "TODO: Make this shut down the context, actors, everything.");
+     }
+   }
 
-    // This method is const so that const client methods can call it but the
-    // RPC mechanism needs non-const.
-    auto nonConstThis = const_cast<ClientWebGLContext*>(this);
-    PcqStatus status =
-        nonConstThis->mCommandSource->RunAsyncCommand(command, aArgs...);
-    if (!IsSuccess(status)) {
-      if (status == PcqStatus::PcqOOMError) {
-        nonConstThis->PostWarning(
-            nsCString("Ran out-of-memory during WebGL IPC."));
-      }
-      // Not much to do but shut down.  Since this was a Pcq failure and
-      // may have been catastrophic, we don't try to revive it.  Make sure to
-      // post "webglcontextlost"
-      MOZ_ASSERT_UNREACHABLE(
-          "TODO: Make this shut down the context, actors, everything.");
-    }
-  }
-
-  template <size_t command, typename ReturnType, typename... Args>
-  ReturnType DispatchSync(Args&&... aArgs) const {
-    if (mContextLost) {
-      return ReturnType();  // TODO: ?? Is this right?
-    }
-
-    // This method is const so that const client methods can call it but the
-    // RPC mechanism needs non-const.
-    auto nonConstThis = const_cast<ClientWebGLContext*>(this);
-    ReturnType returnValue;
-    PcqStatus status = nonConstThis->mCommandSource->RunSyncCommand(
-        command, returnValue, aArgs...);
+   template <size_t command, typename ReturnType, typename... Args>
+   ReturnType DispatchSync(Args&&... aArgs) const {
+     const auto& oop = *mNotLost->outOfProcess;
+     ReturnType returnValue;
+     PcqStatus status =
+         oop.mCommandSource->RunSyncCommand(command, returnValue, aArgs...);
 
-    if (!IsSuccess(status)) {
-      if (status == PcqStatus::PcqOOMError) {
-        nonConstThis->PostWarning(
-            nsCString("Ran out-of-memory during WebGL IPC."));
-      }
-      // Not much to do but shut down.  Since this was a Pcq failure and
-      // may have been catastrophic, we don't try to revive it.  Make sure to
-      // post "webglcontextlost"
-      MOZ_ASSERT_UNREACHABLE(
-          "TODO: Make this shut down the context, actors, everything.");
-    }
-
-    // TODO: Should I really do this here or require overloads (in this class)
-    // of each function that wants it?
-    nonConstThis->DrainErrorQueue();
-    return returnValue;
-  }
-
-  template <size_t command, typename... Args>
-  void DispatchVoidSync(Args&&... aArgs) const {
-    if (mContextLost) {
-      return;
-    }
+     if (!IsSuccess(status)) {
+       if (status == PcqStatus::PcqOOMError) {
+         JsWarning("Ran out-of-memory during WebGL IPC.");
+       }
+       // Not much to do but shut down.  Since this was a Pcq failure and
+       // may have been catastrophic, we don't try to revive it.  Make sure to
+       // post "webglcontextlost"
+       MOZ_ASSERT_UNREACHABLE(
+           "TODO: Make this shut down the context, actors, everything.");
+     }
+     return returnValue;
+   }
 
-    // This method is const so that const client methods can call it but the
-    // RPC mechanism needs non-const.
-    auto nonConstThis = const_cast<ClientWebGLContext*>(this);
-    PcqStatus status =
-        nonConstThis->mCommandSource->RunVoidSyncCommand(command, aArgs...);
-
-    if (!IsSuccess(status)) {
-      if (status == PcqStatus::PcqOOMError) {
-        nonConstThis->PostWarning(
-            nsCString("Ran out-of-memory during WebGL IPC."));
-      }
-      // Not much to do but shut down.  Since this was a Pcq failure and
-      // may have been catastrophic, we don't try to revive it.  Make sure to
-      // post "webglcontextlost"
-      MOZ_ASSERT_UNREACHABLE(
-          "TODO: Make this shut down the context, actors, everything.");
-    }
-
-    // TODO: Should I really do this here or require overloads (in this class)
-    // of each function that wants it?
-    nonConstThis->DrainErrorQueue();
-  }
-
-  // Drains the error and warning queue completely.
-  // This is called in a recurring fashion, starting with the constructor.
-  // Other methods may call this from the main thread at any time but they
-  // should not tell the drain task to reissue.
-  void DrainErrorQueue(bool toReissue = false);
-
-  friend void mozilla::DrainWebGLError(nsWeakPtr aWeakContext);
+   template <size_t command, typename... Args>
+   void DispatchVoidSync(Args&&... aArgs) const {
+     const auto& oop = *mNotLost->outOfProcess;
+     const auto status =
+         oop.mCommandSource->RunVoidSyncCommand(command, aArgs...);
+     if (!IsSuccess(status)) {
+       if (status == PcqStatus::PcqOOMError) {
+         JsWarning("Ran out-of-memory during WebGL IPC.");
+       }
+       // Not much to do but shut down.  Since this was a Pcq failure and
+       // may have been catastrophic, we don't try to revive it.  Make sure to
+       // post "webglcontextlost"
+       MOZ_ASSERT_UNREACHABLE(
+           "TODO: Make this shut down the context, actors, everything.");
+     }
+   }
+   */
 
   template <typename ReturnType>
   friend struct WebGLClientDispatcher;
@@ -1816,56 +2067,23 @@
             size_t Id, typename... Args>
   ReturnType Run(Args&&... aArgs) const;
 
-  UniquePtr<ClientWebGLCommandSource> mCommandSource;
-
-  UniquePtr<ClientWebGLErrorSink> mErrorSink;
-  RefPtr<Runnable> mDrainErrorRunnable;
-
-  // In the cross process case, the WebGL actor's ownership relationship looks
-  // like this:
-  // ---------------------------------------------------------------------
-  // | ClientWebGLContext -> WebGLChild -> WebGLParent -> HostWebGLContext
-  // ---------------------------------------------------------------------
-  //
-  // where 'A -> B' means "A owns B"
-  mozilla::dom::WebGLChild* mWebGLChild;
-
-  UniquePtr<HostWebGLContext> mHostContext;
-
-  // -------------------------------------------------------------------------
-  // Construction/Destruction
-  // -------------------------------------------------------------------------
- protected:
-  friend class WebGLContextUserData;
-
-  // Cross-process client constructor
-  ClientWebGLContext(dom::WebGLChild* aWebGLChild, WebGLVersion aVersion,
-                     UniquePtr<ClientWebGLCommandSource>&& aCommandSource,
-                     UniquePtr<ClientWebGLErrorSink>&& aErrorSink);
-
-  // The single process constructor.  The host and client point directly at
-  // one another.
-  ClientWebGLContext(UniquePtr<HostWebGLContext>&& aHost);
-
-  static RefPtr<ClientWebGLContext> MakeSingleProcessWebGLContext(
-      WebGLVersion aVersion);
-
-  static RefPtr<ClientWebGLContext> MakeCrossProcessWebGLContext(
-      WebGLVersion aVersion);
-
-  virtual ~ClientWebGLContext();
-
   // -------------------------------------------------------------------------
   // Helpers for DOM operations, composition, actors, etc
   // -------------------------------------------------------------------------
+
  public:
   WebGLPixelStore GetPixelStore() { return mPixelStore; }
   const WebGLPixelStore GetPixelStore() const { return mPixelStore; }
 
+  // https://immersive-web.github.io/webxr/#xr-compatible
+  bool IsXRCompatible() const;
+  already_AddRefed<dom::Promise> MakeXRCompatible(ErrorResult& aRv);
+
  protected:
-  bool IsHostOOP() const { return !mHostContext; }
+  bool IsHostOOP() const { return bool{mNotLost->outOfProcess}; }
 
-  void ForceLoseContext();
+  bool ShouldResistFingerprinting() const;
+
   void LoseOldestWebGLContextIfLimitExceeded();
   void UpdateLastUseIndex();
 
@@ -1877,61 +2095,30 @@
 
   mozilla::dom::Document* GetOwnerDoc() const;
 
-  bool mContextLost = false;
   uint64_t mLastUseIndex = 0;
   bool mResetLayer = true;
-  bool mOptionsFrozen = false;
-  WebGLContextOptions mOptions;
+  Maybe<const WebGLContextOptions> mInitialOptions;
   WebGLPixelStore mPixelStore;
 };
 
-template <typename WebGLObjectType>
-JS::Value ClientWebGLContext::WebGLObjectAsJSValue(
-    JSContext* cx, RefPtr<WebGLObjectType>&& object, ErrorResult& rv) const {
-  if (!object) return JS::NullValue();
-
-  MOZ_ASSERT(this == object->GetParentObject());
-  JS::Rooted<JS::Value> v(cx);
-  JS::Rooted<JSObject*> wrapper(cx, GetWrapper());
-  JSAutoRealm ar(cx, wrapper);
-  if (!dom::GetOrCreateDOMReflector(cx, object, &v)) {
-    rv.Throw(NS_ERROR_FAILURE);
-    return JS::NullValue();
-  }
-  return v;
-}
-
-template <typename WebGLObjectType>
-JS::Value ClientWebGLContext::WebGLObjectAsJSValue(
-    JSContext* cx, const WebGLObjectType* object, ErrorResult& rv) const {
-  if (!object) return JS::NullValue();
-
-  MOZ_ASSERT(this == object->GetParentObject());
-  JS::Rooted<JS::Value> v(cx);
-  JS::Rooted<JSObject*> wrapper(cx, GetWrapper());
-  JSAutoRealm ar(cx, wrapper);
-  if (!dom::GetOrCreateDOMReflector(cx, const_cast<WebGLObjectType*>(object),
-                                    &v)) {
-    rv.Throw(NS_ERROR_FAILURE);
-    return JS::NullValue();
-  }
-  return v;
-}
-
-template <typename WebGLObjectType>
-JSObject* ClientWebGLContext::WebGLObjectAsJSObject(
-    JSContext* cx, const WebGLObjectType* object, ErrorResult& rv) const {
-  JS::Value v = WebGLObjectAsJSValue(cx, object, rv);
-  if (v.isNull()) return nullptr;
-
-  return &v.toObject();
-}
-
 // used by DOM bindings in conjunction with GetParentObject
 inline nsISupports* ToSupports(ClientWebGLContext* webgl) {
   return static_cast<nsICanvasRenderingContextInternal*>(webgl);
 }
 
+const char* GetExtensionName(WebGLExtensionID);
+
+// -
+
+inline bool webgl::ObjectJS::IsUsable(const ClientWebGLContext& context) const {
+  const auto& notLost = context.mNotLost;
+  if (!notLost) return false;
+  if (notLost->generation.get() != mGeneration.lock().get()) return false;
+  return !IsDeleted();
+}
+
+void AutoJsWarning(const std::string& utf8);
+
 }  // namespace mozilla
 
 #endif  // CLIENTWEBGLCONTEXT_H_