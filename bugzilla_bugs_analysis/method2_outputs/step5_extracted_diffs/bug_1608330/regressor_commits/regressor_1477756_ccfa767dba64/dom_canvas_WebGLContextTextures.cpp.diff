# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextTextures.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLContextTextures.cpp
--- a/dom/canvas/WebGLContextTextures.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLContextTextures.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -9,10 +9,8 @@
 #include "WebGLVertexAttribData.h"
 #include "WebGLShader.h"
 #include "WebGLProgram.h"
-#include "WebGLUniformLocation.h"
 #include "WebGLFramebuffer.h"
 #include "WebGLRenderbuffer.h"
-#include "WebGLShaderPrecisionFormat.h"
 #include "WebGLTexture.h"
 #include "WebGLExtensions.h"
 #include "WebGLVertexArray.h"
@@ -46,120 +44,10 @@
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ImageData.h"
-#include "mozilla/dom/ToJSValue.h"
 #include "mozilla/EndianUtils.h"
 
 namespace mozilla {
 
-static bool IsValidTexTarget(WebGLContext* webgl, uint8_t funcDims,
-                             GLenum rawTexTarget, TexTarget* const out) {
-  uint8_t targetDims;
-
-  switch (rawTexTarget) {
-    case LOCAL_GL_TEXTURE_2D:
-    case LOCAL_GL_TEXTURE_CUBE_MAP:
-      targetDims = 2;
-      break;
-
-    case LOCAL_GL_TEXTURE_3D:
-    case LOCAL_GL_TEXTURE_2D_ARRAY:
-      if (!webgl->IsWebGL2()) return false;
-
-      targetDims = 3;
-      break;
-
-    default:
-      return false;
-  }
-
-  // Some funcs (like GenerateMipmap) doesn't know the dimension, so don't check
-  // it.
-  if (funcDims && targetDims != funcDims) return false;
-
-  *out = rawTexTarget;
-  return true;
-}
-
-static bool IsValidTexImageTarget(WebGLContext* webgl, uint8_t funcDims,
-                                  GLenum rawTexImageTarget,
-                                  TexImageTarget* const out) {
-  uint8_t targetDims;
-
-  switch (rawTexImageTarget) {
-    case LOCAL_GL_TEXTURE_2D:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-    case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-      targetDims = 2;
-      break;
-
-    case LOCAL_GL_TEXTURE_3D:
-    case LOCAL_GL_TEXTURE_2D_ARRAY:
-      if (!webgl->IsWebGL2()) return false;
-
-      targetDims = 3;
-      break;
-
-    default:
-      return false;
-  }
-
-  if (targetDims != funcDims) return false;
-
-  *out = rawTexImageTarget;
-  return true;
-}
-
-bool ValidateTexTarget(WebGLContext* webgl, uint8_t funcDims,
-                       GLenum rawTexTarget, TexTarget* const out_texTarget,
-                       WebGLTexture** const out_tex) {
-  if (webgl->IsContextLost()) return false;
-
-  TexTarget texTarget;
-  if (!IsValidTexTarget(webgl, funcDims, rawTexTarget, &texTarget)) {
-    webgl->ErrorInvalidEnumInfo("texTarget", rawTexTarget);
-    return false;
-  }
-
-  WebGLTexture* tex = webgl->ActiveBoundTextureForTarget(texTarget);
-  if (!tex) {
-    webgl->ErrorInvalidOperation("No texture is bound to this target.");
-    return false;
-  }
-
-  *out_texTarget = texTarget;
-  *out_tex = tex;
-  return true;
-}
-
-bool ValidateTexImageTarget(WebGLContext* webgl, uint8_t funcDims,
-                            GLenum rawTexImageTarget,
-                            TexImageTarget* const out_texImageTarget,
-                            WebGLTexture** const out_tex) {
-  if (webgl->IsContextLost()) return false;
-
-  TexImageTarget texImageTarget;
-  if (!IsValidTexImageTarget(webgl, funcDims, rawTexImageTarget,
-                             &texImageTarget)) {
-    webgl->ErrorInvalidEnumInfo("texImageTarget", rawTexImageTarget);
-    return false;
-  }
-
-  WebGLTexture* tex =
-      webgl->ActiveBoundTextureForTexImageTarget(texImageTarget);
-  if (!tex) {
-    webgl->ErrorInvalidOperation("No texture is bound to this target.");
-    return false;
-  }
-
-  *out_texImageTarget = texImageTarget;
-  *out_tex = tex;
-  return true;
-}
-
 /*virtual*/
 bool WebGLContext::IsTexParamValid(GLenum pname) const {
   switch (pname) {
@@ -182,14 +70,15 @@
 // GL calls
 
 void WebGLContext::BindTexture(GLenum rawTarget, WebGLTexture* newTex) {
-  const FuncScope funcScope(*this, "bindTexture");
+  FuncScope funcScope(*this, "bindTexture");
   if (IsContextLost()) return;
+  funcScope.mBindFailureGuard = true;
 
   if (newTex && !ValidateObject("tex", *newTex)) return;
 
   // Need to check rawTarget first before comparing against newTex->Target() as
   // newTex->Target() returns a TexTarget, which will assert on invalid value.
-  WebGLRefPtr<WebGLTexture>* currentTexPtr = nullptr;
+  RefPtr<WebGLTexture>* currentTexPtr = nullptr;
   switch (rawTarget) {
     case LOCAL_GL_TEXTURE_2D:
       currentTexPtr = &mBound2DTextures[mActiveTexture];
@@ -221,148 +110,151 @@
   }
 
   *currentTexPtr = newTex;
+
+  funcScope.mBindFailureGuard = false;
 }
 
-void WebGLContext::GenerateMipmap(GLenum rawTexTarget) {
+void WebGLContext::GenerateMipmap(GLenum texTarget) {
   const FuncScope funcScope(*this, "generateMipmap");
-  const uint8_t funcDims = 0;
 
-  TexTarget texTarget;
-  WebGLTexture* tex;
-  if (!ValidateTexTarget(this, funcDims, rawTexTarget, &texTarget, &tex))
-    return;
-
+  const auto& tex = GetActiveTex(texTarget);
+  if (!tex) return;
   tex->GenerateMipmap();
 }
 
-MaybeWebGLVariant WebGLContext::GetTexParameter(GLenum rawTexTarget,
-                                                GLenum pname) {
+Maybe<double> WebGLContext::GetTexParameter(const WebGLTexture& tex,
+                                            GLenum pname) const {
   const FuncScope funcScope(*this, "getTexParameter");
-  const uint8_t funcDims = 0;
-
-  TexTarget texTarget;
-  WebGLTexture* tex;
-  if (!ValidateTexTarget(this, funcDims, rawTexTarget, &texTarget, &tex))
-    return Nothing();
 
   if (!IsTexParamValid(pname)) {
     ErrorInvalidEnumInfo("pname", pname);
     return Nothing();
   }
 
-  return tex->GetTexParameter(texTarget, pname);
+  return tex.GetTexParameter(pname);
 }
 
-void WebGLContext::TexParameter_base(GLenum rawTexTarget, GLenum pname,
+void WebGLContext::TexParameter_base(GLenum texTarget, GLenum pname,
                                      const FloatOrInt& param) {
   const FuncScope funcScope(*this, "texParameter");
-  const uint8_t funcDims = 0;
 
-  TexTarget texTarget;
-  WebGLTexture* tex;
-  if (!ValidateTexTarget(this, funcDims, rawTexTarget, &texTarget, &tex))
-    return;
-
+  const auto& tex = GetActiveTex(texTarget);
+  if (!tex) return;
   tex->TexParameter(texTarget, pname, param);
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
 // Uploads
 
-void WebGLContext::CompressedTexImage(uint8_t funcDims, GLenum rawTarget,
-                                      GLint level, GLenum internalFormat,
-                                      GLsizei width, GLsizei height,
-                                      GLsizei depth, GLint border,
-                                      UniquePtr<webgl::TexUnpackBytes>&& src,
-                                      const Maybe<GLsizei>& expectedImageSize) {
-  if (!src) {
-    ErrorImplementationBug("No TexUnpackBytes received");
-    return;
+static bool IsTexTarget3D(const GLenum texTarget) {
+  switch (texTarget) {
+    case LOCAL_GL_TEXTURE_2D_ARRAY:
+    case LOCAL_GL_TEXTURE_3D:
+      return true;
+
+    default:
+      return false;
   }
-
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
-  tex->CompressedTexImage(target, level, internalFormat, width, height, depth,
-                          border, std::move(src), expectedImageSize);
 }
 
-void WebGLContext::CompressedTexSubImage(
-    uint8_t funcDims, GLenum rawTarget, GLint level, GLint xOffset,
-    GLint yOffset, GLint zOffset, GLsizei width, GLsizei height, GLsizei depth,
-    GLenum unpackFormat, UniquePtr<webgl::TexUnpackBytes>&& src,
-    const Maybe<GLsizei>& expectedImageSize) {
-  if (!src) {
-    ErrorImplementationBug("No TexUnpackBytes received");
-    return;
+WebGLTexture* WebGLContext::GetActiveTex(const GLenum texTarget) const {
+  const auto* list = &mBound2DTextures;
+  switch (texTarget) {
+    case LOCAL_GL_TEXTURE_2D:
+      break;
+    case LOCAL_GL_TEXTURE_CUBE_MAP:
+      list = &mBoundCubeMapTextures;
+      break;
+    case LOCAL_GL_TEXTURE_3D:
+      list = IsWebGL2() ? &mBound3DTextures : nullptr;
+      break;
+    case LOCAL_GL_TEXTURE_2D_ARRAY:
+      list = IsWebGL2() ? &mBound2DArrayTextures : nullptr;
+      break;
+    default:
+      list = nullptr;
   }
+  if (!list) {
+    ErrorInvalidEnumArg("target", texTarget);
+    return nullptr;
+  }
+  const auto& tex = (*list)[mActiveTexture];
+  if (!tex) {
+    GenerateError(LOCAL_GL_INVALID_OPERATION, "No texture bound to %s[%u].",
+                  EnumString(texTarget).c_str(), mActiveTexture);
+    return nullptr;
+  }
+  return tex;
+}
 
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
-  tex->CompressedTexSubImage(target, level, xOffset, yOffset, zOffset, width,
-                             height, depth, unpackFormat, std::move(src),
-                             expectedImageSize);
+void WebGLContext::TexStorage(GLenum texTarget, uint32_t levels,
+                              GLenum internalFormat, uvec3 size) const {
+  const FuncScope funcScope(*this, "texStorage(Multisample)?");
+  if (!IsTexTarget3D(texTarget)) {
+    size.z = 1;
+  }
+  const auto tex = GetActiveTex(texTarget);
+  if (!tex) return;
+  tex->TexStorage(texTarget, levels, internalFormat, size);
 }
 
-////
+void WebGLContext::TexImage(GLenum imageTarget, uint32_t level,
+                            GLenum respecFormat, uvec3 offset, uvec3 size,
+                            const webgl::PackingInfo& pi,
+                            const TexImageSource& src,
+                            const dom::HTMLCanvasElement& canvas) const {
+  const WebGLContext::FuncScope funcScope(
+      *this, bool(respecFormat) ? "texImage" : "texSubImage");
 
-void WebGLContext::CopyTexImage2D(GLenum rawTarget, GLint level,
-                                  GLenum internalFormat, GLint x, GLint y,
-                                  uint32_t width, uint32_t height,
-                                  uint32_t depth) {
-  const FuncScope funcScope(*this, "copyTexImage2D");
-  const uint8_t funcDims = 2;
-
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
-
-  tex->CopyTexImage2D(target, level, internalFormat, x, y, width, height,
-                      depth);
+  if (respecFormat) {
+    offset = {0, 0, 0};
+  }
+  const auto texTarget = ImageToTexTarget(imageTarget);
+  if (!IsTexTarget3D(texTarget)) {
+    size.z = 1;
+  }
+  const auto tex = GetActiveTex(texTarget);
+  if (!tex) return;
+  tex->TexImage(imageTarget, level, respecFormat, offset, size, pi, src,
+                canvas);
 }
 
-void WebGLContext::CopyTexSubImage(uint8_t funcDims, GLenum rawTarget,
-                                   GLint level, GLint xOffset, GLint yOffset,
-                                   GLint zOffset, GLint x, GLint y,
-                                   uint32_t width, uint32_t height,
-                                   uint32_t depth) {
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
+void WebGLContext::CompressedTexImage(bool sub, GLenum imageTarget,
+                                      uint32_t level, GLenum format,
+                                      uvec3 offset, uvec3 size,
+                                      const Range<const uint8_t>& src,
+                                      const uint32_t pboImageSize,
+                                      const Maybe<uint64_t>& pboOffset) const {
+  const WebGLContext::FuncScope funcScope(
+      *this, !sub ? "compressedTexImage" : "compressedTexSubImage");
 
-  tex->CopyTexSubImage(target, level, xOffset, yOffset, zOffset, x, y, width,
-                       height, depth);
+  if (!sub) {
+    offset = {0, 0, 0};
+  }
+  const auto texTarget = ImageToTexTarget(imageTarget);
+  if (!IsTexTarget3D(texTarget)) {
+    size.z = 1;
+  }
+  const auto tex = GetActiveTex(texTarget);
+  if (!tex) return;
+  tex->CompressedTexImage(sub, imageTarget, level, format, offset, size, src,
+                          pboImageSize, pboOffset);
 }
 
-////
-
-void WebGLContext::TexImage(uint8_t funcDims, GLenum rawTarget, GLint level,
-                            GLenum internalFormat, uint32_t width,
-                            uint32_t height, uint32_t depth, GLint border,
-                            GLenum unpackFormat, GLenum unpackType,
-                            UniquePtr<webgl::TexUnpackBlob>&& src) {
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
+void WebGLContext::CopyTexImage(GLenum imageTarget, uint32_t level,
+                                GLenum respecFormat, uvec3 dstOffset,
+                                const ivec2& srcOffset,
+                                const uvec2& size) const {
+  const WebGLContext::FuncScope funcScope(
+      *this, bool(respecFormat) ? "copyTexImage" : "copyTexSubImage");
 
-  const webgl::PackingInfo pi = {unpackFormat, unpackType};
-  tex->TexImage(target, level, internalFormat, width, height, depth, border, pi,
-                std::move(src));
-}
-
-void WebGLContext::TexSubImage(uint8_t funcDims, GLenum rawTarget, GLint level,
-                               GLint xOffset, GLint yOffset, GLint zOffset,
-                               uint32_t width, uint32_t height, uint32_t depth,
-                               GLenum unpackFormat, GLenum unpackType,
-                               UniquePtr<webgl::TexUnpackBlob>&& src) {
-  TexImageTarget target;
-  WebGLTexture* tex;
-  if (!ValidateTexImageTarget(this, funcDims, rawTarget, &target, &tex)) return;
-
-  const webgl::PackingInfo pi = {unpackFormat, unpackType};
-  tex->TexSubImage(target, level, xOffset, yOffset, zOffset, width, height,
-                   depth, pi, std::move(src));
+  if (respecFormat) {
+    dstOffset = {0, 0, 0};
+  }
+  const auto tex = GetActiveTex(ImageToTexTarget(imageTarget));
+  if (!tex) return;
+  tex->CopyTexImage(imageTarget, level, respecFormat, dstOffset, srcOffset,
+                    size);
 }
 
 }  // namespace mozilla