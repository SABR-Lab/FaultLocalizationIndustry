# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContextVertices.cpp
# Commit: ccfa767dba64
# Full Hash: ccfa767dba644dc193e0246eb8e8ff3377e8b8a5
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-01-09 03:40:18
# Regressor Bug: 1477756
# File Overlap Count: 1
# Description:
#   Bug 1477756 - Client-side bindings mirror for precise CC, and merge similar codepaths. r=handyman
#   
#   * Context loss using RAII
#   * Move Program reflection Client-side
#   
# ==============================================================================

diff -r 71c122ac0ca7 -r ccfa767dba64 dom/canvas/WebGLContextVertices.cpp
--- a/dom/canvas/WebGLContextVertices.cpp	Wed Jan 08 22:19:14 2020 +0000
+++ b/dom/canvas/WebGLContextVertices.cpp	Wed Jan 08 22:19:16 2020 +0000
@@ -44,44 +44,10 @@
   return valid;
 }
 
-Float32Array4&& WebGLContext::GetVertexAttribFloat32Array(GLuint index) {
-  Float32Array4 attrib;
-  if (index) {
-    gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &attrib[0]);
-  } else {
-    memcpy(&attrib[0], mGenericVertexAttrib0Data,
-           sizeof(mGenericVertexAttrib0Data));
-  }
-  return std::move(attrib);
-}
-
-Int32Array4&& WebGLContext::GetVertexAttribInt32Array(GLuint index) {
-  Int32Array4 attrib;
-  if (index) {
-    gl->fGetVertexAttribIiv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &attrib[0]);
-  } else {
-    memcpy(&attrib[0], mGenericVertexAttrib0Data,
-           sizeof(mGenericVertexAttrib0Data));
-  }
-  return std::move(attrib);
-}
-
-Uint32Array4&& WebGLContext::GetVertexAttribUint32Array(GLuint index) {
-  Uint32Array4 attrib;
-  if (index) {
-    gl->fGetVertexAttribIuiv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &attrib[0]);
-  } else {
-    memcpy(&attrib[0], mGenericVertexAttrib0Data,
-           sizeof(mGenericVertexAttrib0Data));
-  }
-  return std::move(attrib);
-}
-
 ////////////////////////////////////////
 
-void WebGLContext::VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z,
-                                  GLfloat w) {
-  const FuncScope funcScope(*this, "vertexAttrib4f");
+void WebGLContext::VertexAttrib4T(GLuint index, const webgl::TypedQuad& src) {
+  const FuncScope funcScope(*this, "vertexAttrib[1234]u?[fi]v?");
   if (IsContextLost()) return;
 
   if (!ValidateAttribIndex(*this, index)) return;
@@ -89,65 +55,30 @@
   ////
 
   if (index || !gl->IsCompatibilityProfile()) {
-    gl->fVertexAttrib4f(index, x, y, z, w);
-  }
-
-  ////
-
-  mGenericVertexAttribTypes[index] = webgl::AttribBaseType::Float;
-  mGenericVertexAttribTypeInvalidator.InvalidateCaches();
-
-  if (!index) {
-    const float data[4] = {x, y, z, w};
-    memcpy(mGenericVertexAttrib0Data, data, sizeof(data));
-  }
-}
-
-void WebGL2Context::VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z,
-                                    GLint w) {
-  const FuncScope funcScope(*this, "vertexAttribI4i");
-  if (IsContextLost()) return;
-
-  if (!ValidateAttribIndex(*this, index)) return;
-
-  ////
-
-  if (index || !gl->IsCompatibilityProfile()) {
-    gl->fVertexAttribI4i(index, x, y, z, w);
+    switch (src.type) {
+      case webgl::AttribBaseType::Boolean:
+      case webgl::AttribBaseType::Float:
+        gl->fVertexAttrib4fv(index, reinterpret_cast<const float*>(src.data));
+        break;
+      case webgl::AttribBaseType::Int:
+        gl->fVertexAttribI4iv(index,
+                              reinterpret_cast<const int32_t*>(src.data));
+        break;
+      case webgl::AttribBaseType::Uint:
+        gl->fVertexAttribI4uiv(index,
+                               reinterpret_cast<const uint32_t*>(src.data));
+        break;
+    }
   }
 
   ////
 
-  mGenericVertexAttribTypes[index] = webgl::AttribBaseType::Int;
+  mGenericVertexAttribTypes[index] = src.type;
   mGenericVertexAttribTypeInvalidator.InvalidateCaches();
 
   if (!index) {
-    const int32_t data[4] = {x, y, z, w};
-    memcpy(mGenericVertexAttrib0Data, data, sizeof(data));
-  }
-}
-
-void WebGL2Context::VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z,
-                                     GLuint w) {
-  const FuncScope funcScope(*this, "vertexAttribI4ui");
-  if (IsContextLost()) return;
-
-  if (!ValidateAttribIndex(*this, index)) return;
-
-  ////
-
-  if (index || !gl->IsCompatibilityProfile()) {
-    gl->fVertexAttribI4ui(index, x, y, z, w);
-  }
-
-  ////
-
-  mGenericVertexAttribTypes[index] = webgl::AttribBaseType::UInt;
-  mGenericVertexAttribTypeInvalidator.InvalidateCaches();
-
-  if (!index) {
-    const uint32_t data[4] = {x, y, z, w};
-    memcpy(mGenericVertexAttrib0Data, data, sizeof(data));
+    memcpy(mGenericVertexAttrib0Data, src.data,
+           sizeof(mGenericVertexAttrib0Data));
   }
 }
 
@@ -181,7 +112,7 @@
   mBoundVertexArray->InvalidateCaches();
 }
 
-MaybeWebGLVariant WebGLContext::GetVertexAttrib(GLuint index, GLenum pname) {
+Maybe<double> WebGLContext::GetVertexAttrib(GLuint index, GLenum pname) {
   const FuncScope funcScope(*this, "getVertexAttrib");
   if (IsContextLost()) return Nothing();
 
@@ -190,24 +121,21 @@
   MOZ_ASSERT(mBoundVertexArray);
 
   switch (pname) {
-    case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
-      return AsSomeVariant(std::move(mBoundVertexArray->mAttribs[index].mBuf));
-
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
-      return AsSomeVariant(
+      return Some(
           static_cast<int32_t>(mBoundVertexArray->mAttribs[index].Stride()));
 
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
-      return AsSomeVariant(
+      return Some(
           static_cast<int32_t>(mBoundVertexArray->mAttribs[index].Size()));
 
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
-      return AsSomeVariant(
+      return Some(
           static_cast<int32_t>(mBoundVertexArray->mAttribs[index].Type()));
 
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_INTEGER:
       if (IsWebGL2())
-        return AsSomeVariant(static_cast<bool>(
+        return Some(static_cast<bool>(
             mBoundVertexArray->mAttribs[index].IntegerFunc()));
 
       break;
@@ -215,29 +143,19 @@
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_DIVISOR:
       if (IsWebGL2() ||
           IsExtensionEnabled(WebGLExtensionID::ANGLE_instanced_arrays)) {
-        return AsSomeVariant(
+        return Some(
             static_cast<int32_t>(mBoundVertexArray->mAttribs[index].mDivisor));
       }
       break;
 
-    case LOCAL_GL_CURRENT_VERTEX_ATTRIB: {
-      switch (mGenericVertexAttribTypes[index]) {
-        case webgl::AttribBaseType::Float:
-          return AsSomeVariant(std::move(GetVertexAttribFloat32Array(index)));
-        case webgl::AttribBaseType::Int:
-          return AsSomeVariant(std::move(GetVertexAttribInt32Array(index)));
-        case webgl::AttribBaseType::UInt:
-          return AsSomeVariant(std::move(GetVertexAttribUint32Array(index)));
-        case webgl::AttribBaseType::Boolean:
-          MOZ_CRASH("impossible");
-      }
-    }
-
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
-      return AsSomeVariant(mBoundVertexArray->mAttribs[index].mEnabled);
+      return Some(mBoundVertexArray->mAttribs[index].mEnabled);
 
     case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
-      return AsSomeVariant(mBoundVertexArray->mAttribs[index].Normalized());
+      return Some(mBoundVertexArray->mAttribs[index].Normalized());
+
+    case LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER:
+      return Some(mBoundVertexArray->mAttribs[index].ByteOffset());
 
     default:
       break;
@@ -247,47 +165,22 @@
   return Nothing();
 }
 
-WebGLsizeiptr WebGLContext::GetVertexAttribOffset(GLuint index, GLenum pname) {
-  const FuncScope funcScope(*this, "getVertexAttribOffset");
-  if (IsContextLost()) return 0;
-
-  if (!ValidateAttribIndex(*this, index)) return 0;
-
-  if (pname != LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER) {
-    ErrorInvalidEnum("`pname` must be VERTEX_ATTRIB_ARRAY_POINTER.");
-    return 0;
-  }
-
-  MOZ_ASSERT(mBoundVertexArray);
-  return mBoundVertexArray->mAttribs[index].ByteOffset();
-}
-
 ////////////////////////////////////////
 
-void WebGLContext::VertexAttribAnyPointer(bool isFuncInt, GLuint index,
-                                          GLint size, GLenum type,
-                                          bool normalized, GLsizei stride,
-                                          WebGLintptr byteOffset) {
-  if (IsContextLost()) return;
-
-  if (!ValidateAttribIndex(*this, index)) return;
-
-  ////
-
+Maybe<webgl::ErrorInfo> CheckVertexAttribPointer(bool webgl2, bool isFuncInt,
+                                                 GLint size, GLenum type,
+                                                 bool normalized,
+                                                 uint32_t stride,
+                                                 uint64_t byteOffset) {
   if (size < 1 || size > 4) {
-    ErrorInvalidValue("Invalid element size.");
-    return;
+    return Some(
+        webgl::ErrorInfo{LOCAL_GL_INVALID_VALUE, "Invalid element size."});
   }
 
   // see WebGL spec section 6.6 "Vertex Attribute Data Stride"
-  if (stride < 0 || stride > 255) {
-    ErrorInvalidValue("Negative or too large stride.");
-    return;
-  }
-
-  if (byteOffset < 0) {
-    ErrorInvalidValue("Negative offset.");
-    return;
+  if (stride > 255) {
+    return Some(webgl::ErrorInfo{LOCAL_GL_INVALID_VALUE,
+                                 "Negative or too large stride."});
   }
 
   ////
@@ -316,21 +209,21 @@
     // WebGL 2:
     case LOCAL_GL_INT:
     case LOCAL_GL_UNSIGNED_INT:
-      if (!IsWebGL2()) {
+      if (!webgl2) {
         isTypeValid = false;
       }
       typeAlignment = 4;
       break;
 
     case LOCAL_GL_HALF_FLOAT:
-      if (isFuncInt || !IsWebGL2()) {
+      if (isFuncInt || !webgl2) {
         isTypeValid = false;
       }
       typeAlignment = 2;
       break;
 
     case LOCAL_GL_FIXED:
-      if (isFuncInt || !IsWebGL2()) {
+      if (isFuncInt || !webgl2) {
         isTypeValid = false;
       }
       typeAlignment = 4;
@@ -338,13 +231,13 @@
 
     case LOCAL_GL_INT_2_10_10_10_REV:
     case LOCAL_GL_UNSIGNED_INT_2_10_10_10_REV:
-      if (isFuncInt || !IsWebGL2()) {
+      if (isFuncInt || !webgl2) {
         isTypeValid = false;
         break;
       }
       if (size != 4) {
-        ErrorInvalidOperation("Size must be 4 for this type.");
-        return;
+        return Some(webgl::ErrorInfo{LOCAL_GL_INVALID_OPERATION,
+                                     "Size must be 4 for this type."});
       }
       typeAlignment = 4;
       break;
@@ -354,20 +247,37 @@
       break;
   }
   if (!isTypeValid) {
-    ErrorInvalidEnumInfo("type", type);
-    return;
+    const auto info =
+        nsPrintfCString("Bad `type`: %s", EnumString(type).c_str());
+    return Some(webgl::ErrorInfo{LOCAL_GL_INVALID_ENUM, info.BeginReading()});
   }
 
   ////
 
   // `alignment` should always be a power of two.
   MOZ_ASSERT(IsPowerOfTwo(typeAlignment));
-  const GLsizei typeAlignmentMask = typeAlignment - 1;
+  const auto typeAlignmentMask = typeAlignment - 1;
 
   if (stride & typeAlignmentMask || byteOffset & typeAlignmentMask) {
-    ErrorInvalidOperation(
-        "`stride` and `byteOffset` must satisfy the alignment"
-        " requirement of `type`.");
+    return Some(
+        webgl::ErrorInfo{LOCAL_GL_INVALID_OPERATION,
+                         "`stride` and `byteOffset` must satisfy the alignment"
+                         " requirement of `type`."});
+  }
+
+  return {};
+}
+
+void WebGLContext::VertexAttribPointer(bool isFuncInt, GLuint index, GLint size,
+                                       GLenum type, bool normalized,
+                                       uint32_t stride, uint64_t byteOffset) {
+  if (IsContextLost()) return;
+  if (!ValidateAttribIndex(*this, index)) return;
+
+  const auto err = CheckVertexAttribPointer(IsWebGL2(), isFuncInt, size, type,
+                                            normalized, stride, byteOffset);
+  if (err) {
+    GenerateError(err->type, "%s", err->info.c_str());
     return;
   }
 
@@ -375,8 +285,7 @@
 
   const auto& buffer = mBoundArrayBuffer;
   if (!buffer && byteOffset) {
-    ErrorInvalidOperation("If ARRAY_BUFFER is null, byteOffset must be zero.");
-    return;
+    byteOffset = 0;
   }
 
   ////