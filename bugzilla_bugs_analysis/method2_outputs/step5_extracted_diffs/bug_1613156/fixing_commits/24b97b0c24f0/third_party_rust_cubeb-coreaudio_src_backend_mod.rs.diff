# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: third_party/rust/cubeb-coreaudio/src/backend/mod.rs
# Commit: 24b97b0c24f0
# Full Hash: 24b97b0c24f0f30965d5d30dfa2a796e3c994e5e
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2020-02-13 21:42:57
# Description:
#   Bug 1613156 - Update cubeb-coreaudio to 7fe03b4. r=padenot
#   
#   Pick commits:
#   - 7fe03b4: Bail out if the output device has no output channel (#50)
#   - ad74bad: Update README
# ==============================================================================

diff -r 8e18b9d4caae -r 24b97b0c24f0 third_party/rust/cubeb-coreaudio/src/backend/mod.rs
--- a/third_party/rust/cubeb-coreaudio/src/backend/mod.rs	Thu Feb 13 16:09:09 2020 +0000
+++ b/third_party/rust/cubeb-coreaudio/src/backend/mod.rs	Thu Feb 13 15:52:30 2020 +0000
@@ -720,13 +720,14 @@
         }
 
         if outframes < 0 || outframes > i64::from(output_frames) {
-            *stm.shutdown.get_mut() = true;
+            stm.shutdown.store(true, Ordering::SeqCst);
             stm.core_stream_data.stop_audiounits();
             audiounit_make_silent(&mut buffers[0]);
             return (NO_ERR, Some(State::Error));
         }
 
-        *stm.draining.get_mut() = outframes < i64::from(output_frames);
+        stm.draining
+            .store(outframes < i64::from(output_frames), Ordering::SeqCst);
         stm.frames_played
             .store(stm.frames_queued, atomic::Ordering::SeqCst);
         stm.frames_queued += outframes as u64;
@@ -794,7 +795,7 @@
         );
         return NO_ERR;
     }
-    *stm.switching_device.get_mut() = true;
+    stm.switching_device.store(true, Ordering::SeqCst);
 
     cubeb_log!(
         "({:p}) Audio device changed, {} events.",
@@ -832,7 +833,7 @@
                     .contains(device_flags::DEV_SYSTEM_DEFAULT)
                 {
                     cubeb_log!("It's the default input device, ignore the event");
-                    *stm.switching_device.get_mut() = false;
+                    stm.switching_device.store(false, Ordering::SeqCst);
                     return NO_ERR;
                 }
             }
@@ -849,7 +850,7 @@
                     i,
                     addr.mSelector
                 );
-                *stm.switching_device.get_mut() = false;
+                stm.switching_device.store(false, Ordering::SeqCst);
                 return NO_ERR;
             }
         }
@@ -2437,6 +2438,12 @@
 
         // Configure I/O stream
         if self.has_input() {
+            cubeb_log!(
+                "({:p}) Initialize input by device info: {:?}",
+                self.stm_ptr,
+                in_dev_info
+            );
+
             self.input_unit = create_audiounit(&in_dev_info).map_err(|e| {
                 cubeb_log!("({:p}) AudioUnit creation for input failed.", self.stm_ptr);
                 e
@@ -2576,6 +2583,12 @@
         }
 
         if self.has_output() {
+            cubeb_log!(
+                "({:p}) Initialize output by device info: {:?}",
+                self.stm_ptr,
+                out_dev_info
+            );
+
             self.output_unit = create_audiounit(&out_dev_info).map_err(|e| {
                 cubeb_log!("({:p}) AudioUnit creation for output failed.", self.stm_ptr);
                 e
@@ -2626,6 +2639,13 @@
             );
             self.output_hw_rate = output_hw_desc.mSampleRate;
             let hw_channels = output_hw_desc.mChannelsPerFrame;
+            if hw_channels == 0 {
+                cubeb_log!(
+                    "({:p}) Output hardware has no output channel! Bail out.",
+                    self.stm_ptr
+                );
+                return Err(Error::device_unavailable());
+            }
 
             self.device_layout = audiounit_get_current_channel_layout(self.output_unit);
 
@@ -3263,8 +3283,8 @@
                     stm_ptr
                 );
             }
-            *stm_guard.switching_device.get_mut() = false;
-            *stm_guard.reinit_pending.get_mut() = false;
+            stm_guard.switching_device.store(false, Ordering::SeqCst);
+            stm_guard.reinit_pending.store(false, Ordering::SeqCst);
         });
     }
 
@@ -3275,7 +3295,7 @@
     }
 
     fn destroy(&mut self) {
-        *self.destroy_pending.get_mut() = true;
+        self.destroy_pending.store(true, Ordering::SeqCst);
 
         let queue = self.context.serial_queue;
 
@@ -3289,7 +3309,7 @@
             // CoreAudio framework that is used by the data callback.
             if !self.shutdown.load(Ordering::SeqCst) {
                 self.core_stream_data.stop_audiounits();
-                *self.shutdown.get_mut() = true;
+                self.shutdown.store(true, Ordering::SeqCst);
             }
 
             self.destroy_internal();
@@ -3307,8 +3327,8 @@
 
 impl<'ctx> StreamOps for AudioUnitStream<'ctx> {
     fn start(&mut self) -> Result<()> {
-        *self.shutdown.get_mut() = false;
-        *self.draining.get_mut() = false;
+        self.shutdown.store(false, Ordering::SeqCst);
+        self.draining.store(false, Ordering::SeqCst);
 
         // Execute start in serial queue to avoid racing with destroy or reinit.
         let queue = self.context.serial_queue;
@@ -3332,7 +3352,7 @@
         Ok(())
     }
     fn stop(&mut self) -> Result<()> {
-        *self.shutdown.get_mut() = true;
+        self.shutdown.store(true, Ordering::SeqCst);
 
         // Execute stop in serial queue to avoid racing with destroy or reinit.
         let queue = self.context.serial_queue;