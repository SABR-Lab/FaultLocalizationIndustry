# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/DocAccessible.cpp
# Commit: 1e75ce1fef67
# Full Hash: 1e75ce1fef67f3139ac4f05993cad693c82c111c
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2020-02-17 09:50:03
# Regressor Bug: 1611060
# File Overlap Count: 1
# Description:
#   Bug 1611060 - Dispatch a11y scroll events for all DOM scrolls. r=Jamie
#   
#   Currently, only documents dispatch scroll events when in reality any
#   element can have scrollable overflows.
#   
# ==============================================================================

diff -r 20b59309d020 -r 1e75ce1fef67 accessible/generic/DocAccessible.cpp
--- a/accessible/generic/DocAccessible.cpp	Mon Feb 17 05:37:24 2020 +0200
+++ b/accessible/generic/DocAccessible.cpp	Mon Feb 17 04:09:34 2020 +0000
@@ -81,7 +81,6 @@
       mAccessibleCache(kDefaultCacheLength),
       mNodeToAccessibleMap(kDefaultCacheLength),
       mDocumentNode(aDocument),
-      mScrollPositionChangedTicks(0),
       mLoadState(eTreeConstructionPending),
       mDocFlags(0),
       mLoadEventType(0),
@@ -510,9 +509,6 @@
 // DocAccessible protected member
 nsresult DocAccessible::RemoveEventListeners() {
   // Remove listeners associated with content documents
-  // Remove scroll position listener
-  RemoveScrollListener();
-
   NS_ASSERTION(mDocumentNode, "No document during removal of listeners.");
 
   if (mDocumentNode) {
@@ -545,7 +541,14 @@
   DocAccessible* docAcc = reinterpret_cast<DocAccessible*>(aClosure);
 
   if (docAcc) {
-    docAcc->DispatchScrollingEvent(nsIAccessibleEvent::EVENT_SCROLLING_END);
+    // Dispatch a scroll-end for all entries in table. They have not
+    // been scrolled in at least `kScrollEventInterval`.
+    for (auto iter = docAcc->mLastScrollingDispatch.Iter(); !iter.Done();
+         iter.Next()) {
+      docAcc->DispatchScrollingEvent(iter.Key(),
+                                     nsIAccessibleEvent::EVENT_SCROLLING_END);
+      iter.Remove();
+    }
 
     if (docAcc->mScrollWatchTimer) {
       docAcc->mScrollWatchTimer = nullptr;
@@ -554,17 +557,16 @@
   }
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// nsIScrollPositionListener
-
-void DocAccessible::ScrollPositionDidChange(nscoord aX, nscoord aY) {
+void DocAccessible::HandleScroll(nsINode* aTarget) {
   const uint32_t kScrollEventInterval = 100;
-  TimeStamp timestamp = TimeStamp::Now();
-  if (mLastScrollingDispatch.IsNull() ||
-      (timestamp - mLastScrollingDispatch).ToMilliseconds() >=
-          kScrollEventInterval) {
-    DispatchScrollingEvent(nsIAccessibleEvent::EVENT_SCROLLING);
-    mLastScrollingDispatch = timestamp;
+  TimeStamp now = TimeStamp::Now();
+  TimeStamp lastDispatch;
+  // If we haven't dispatched a scrolling event for a target in at least
+  // kScrollEventInterval milliseconds, dispatch one now.
+  if (!mLastScrollingDispatch.Get(aTarget, &lastDispatch) ||
+      (now - lastDispatch).ToMilliseconds() >= kScrollEventInterval) {
+    DispatchScrollingEvent(aTarget, nsIAccessibleEvent::EVENT_SCROLLING);
+    mLastScrollingDispatch.Put(aTarget, now);
   }
 
   // If timer callback is still pending, push it 100ms into the future.
@@ -2522,27 +2524,38 @@
   mIPCDoc = aIPCDoc;
 }
 
-void DocAccessible::DispatchScrollingEvent(uint32_t aEventType) {
-  nsIScrollableFrame* sf = mPresShell->GetRootScrollFrameAsScrollable();
-  if (!sf) {
+void DocAccessible::DispatchScrollingEvent(nsINode* aTarget,
+                                           uint32_t aEventType) {
+  Accessible* acc = GetAccessible(aTarget);
+  if (!acc) {
     return;
   }
 
-  int32_t appUnitsPerDevPixel =
-      mPresShell->GetPresContext()->AppUnitsPerDevPixel();
-  LayoutDevicePoint scrollPoint =
-      LayoutDevicePoint::FromAppUnits(sf->GetScrollPosition(),
-                                      appUnitsPerDevPixel) *
-      mPresShell->GetResolution();
-
-  LayoutDeviceRect scrollRange =
-      LayoutDeviceRect::FromAppUnits(sf->GetScrollRange(), appUnitsPerDevPixel);
-  scrollRange.ScaleRoundOut(mPresShell->GetResolution());
+  LayoutDevicePoint scrollPoint;
+  LayoutDeviceRect scrollRange;
+  nsIScrollableFrame* sf = acc == this
+                               ? mPresShell->GetRootScrollFrameAsScrollable()
+                               : acc->GetFrame()->GetScrollTargetFrame();
+
+  // If there is no scrollable frame, it's likely a scroll in a popup, like
+  // <select>. Just send an event with no scroll info. The scroll info
+  // is currently only used on Android, and popups are rendered natively
+  // there.
+  if (sf) {
+    int32_t appUnitsPerDevPixel =
+        mPresShell->GetPresContext()->AppUnitsPerDevPixel();
+    scrollPoint = LayoutDevicePoint::FromAppUnits(sf->GetScrollPosition(),
+                                                  appUnitsPerDevPixel) *
+                  mPresShell->GetResolution();
+
+    scrollRange = LayoutDeviceRect::FromAppUnits(sf->GetScrollRange(),
+                                                 appUnitsPerDevPixel);
+    scrollRange.ScaleRoundOut(mPresShell->GetResolution());
+  }
 
   RefPtr<AccEvent> event =
-      new AccScrollingEvent(aEventType, this, scrollPoint.x, scrollPoint.y,
+      new AccScrollingEvent(aEventType, acc, scrollPoint.x, scrollPoint.y,
                             scrollRange.width, scrollRange.height);
-
   nsEventShell::FireEvent(event);
 }
 