# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: widget/windows/RemoteBackbuffer.cpp
# Commit: 992f5734eb4e
# Full Hash: 992f5734eb4e39b3c76ff35b0f744b129f80b483
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-02-28 09:24:28
# Description:
#   Bug 1617523 - Ensure remote backbuffer only reused if initialized properly r=jrmuizel
#   
#   This crash was caused because there was a case where the Provider would
#   store the SharedImage even if it failed to initialize it or send it to the
#   Client.
# ==============================================================================

diff -r 133376007dce -r 992f5734eb4e widget/windows/RemoteBackbuffer.cpp
--- a/widget/windows/RemoteBackbuffer.cpp	Fri Feb 28 02:37:42 2020 +0000
+++ b/widget/windows/RemoteBackbuffer.cpp	Fri Feb 28 01:34:26 2020 +0000
@@ -19,6 +19,7 @@
 
 enum class SharedDataType {
   BorrowRequest,
+  BorrowRequestAllowSameBuffer,
   BorrowResponse,
   PresentRequest,
   PresentResponse
@@ -386,10 +387,13 @@
     }
 
     switch (mSharedDataPtr->dataType) {
-      case SharedDataType::BorrowRequest: {
+      case SharedDataType::BorrowRequest:
+      case SharedDataType::BorrowRequestAllowSameBuffer: {
         BorrowResponseData responseData = {};
 
-        HandleBorrowRequest(&responseData);
+        HandleBorrowRequest(&responseData,
+                            mSharedDataPtr->dataType ==
+                                SharedDataType::BorrowRequestAllowSameBuffer);
 
         mSharedDataPtr->dataType = SharedDataType::BorrowResponse;
         mSharedDataPtr->data.borrowResponse = responseData;
@@ -416,7 +420,8 @@
   }
 }
 
-void Provider::HandleBorrowRequest(BorrowResponseData* aResponseData) {
+void Provider::HandleBorrowRequest(BorrowResponseData* aResponseData,
+                                   bool aAllowSameBuffer) {
   MOZ_ASSERT(aResponseData);
 
   aResponseData->result = ResponseResult::Error;
@@ -432,7 +437,8 @@
   int32_t width = clientRect.right ? clientRect.right : 1;
   int32_t height = clientRect.bottom ? clientRect.bottom : 1;
 
-  bool needNewBackbuffer = !mBackbuffer || (mBackbuffer->GetWidth() != width) ||
+  bool needNewBackbuffer = !aAllowSameBuffer || !mBackbuffer ||
+                           (mBackbuffer->GetWidth() != width) ||
                            (mBackbuffer->GetHeight() != height);
 
   if (!needNewBackbuffer) {
@@ -442,13 +448,13 @@
 
   mBackbuffer.reset();
 
-  mBackbuffer = std::make_unique<PresentableSharedImage>();
-  if (!mBackbuffer->Initialize(width, height)) {
+  auto newBackbuffer = std::make_unique<PresentableSharedImage>();
+  if (!newBackbuffer->Initialize(width, height)) {
     return;
   }
 
   HANDLE remoteFileMapping =
-      mBackbuffer->CreateRemoteFileMapping(mTargetProcessId);
+      newBackbuffer->CreateRemoteFileMapping(mTargetProcessId);
   if (!remoteFileMapping) {
     return;
   }
@@ -457,6 +463,8 @@
   aResponseData->width = width;
   aResponseData->height = height;
   aResponseData->fileMapping = remoteFileMapping;
+
+  mBackbuffer = std::move(newBackbuffer);
 }
 
 void Provider::HandlePresentRequest(PresentResponseData* aResponseData) {
@@ -526,7 +534,10 @@
 }
 
 already_AddRefed<gfx::DrawTarget> Client::BorrowDrawTarget() {
-  mSharedDataPtr->dataType = SharedDataType::BorrowRequest;
+  mSharedDataPtr->dataType = mBackbuffer
+                                 ? SharedDataType::BorrowRequestAllowSameBuffer
+                                 : SharedDataType::BorrowRequest;
+
   MOZ_ALWAYS_TRUE(::SetEvent(mRequestReadyEvent));
   MOZ_ALWAYS_TRUE(::WaitForSingleObject(mResponseReadyEvent, INFINITE) ==
                   WAIT_OBJECT_0);
@@ -545,13 +556,18 @@
   if (responseData.result == ResponseResult::BorrowSuccess) {
     mBackbuffer.reset();
 
-    mBackbuffer = std::make_unique<SharedImage>();
-    if (!mBackbuffer->InitializeRemote(responseData.width, responseData.height,
-                                       responseData.fileMapping)) {
+    auto newBackbuffer = std::make_unique<SharedImage>();
+    if (!newBackbuffer->InitializeRemote(responseData.width,
+                                         responseData.height,
+                                         responseData.fileMapping)) {
       return nullptr;
     }
+
+    mBackbuffer = std::move(newBackbuffer);
   }
 
+  MOZ_ASSERT(mBackbuffer);
+
   return mBackbuffer->CreateDrawTarget();
 }
 