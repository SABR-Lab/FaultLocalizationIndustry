# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/RemoteBackbuffer.cpp
# Commit: d69f53c5968c
# Full Hash: d69f53c5968cf816bf07c5664b274863c155d19f
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-02-20 09:35:08
# Regressor Bug: 1604412
# File Overlap Count: 2
# Description:
#   Bug 1616000 - Fix broken push notifications r=handyman
#   
#   Bug 1604412 enabled "remote backbuffer" compositing when using non-accelerated
#   layers. However, due to my misunderstanding of how nWindow and compositing
#   handles layered windows, I broke the usecase where a child window is
# ==============================================================================

diff -r 115974724061 -r d69f53c5968c widget/windows/RemoteBackbuffer.cpp
--- a/widget/windows/RemoteBackbuffer.cpp	Wed Feb 19 23:03:12 2020 +0000
+++ b/widget/windows/RemoteBackbuffer.cpp	Wed Feb 19 22:20:33 2020 +0000
@@ -206,16 +206,20 @@
     return true;
   }
 
-  bool PresentToWindow(HWND aWindowHandle) {
-    bool isLayered =
-        ::GetWindowLongPtrW(aWindowHandle, GWL_EXSTYLE) & WS_EX_LAYERED;
+  bool PresentToWindow(HWND aWindowHandle,
+                       nsTransparencyMode aTransparencyMode) {
+    if (aTransparencyMode == eTransparencyTransparent) {
+      // If our window is a child window or a child-of-a-child, the window
+      // that needs to be updated is the top level ancestor of the tree
+      HWND topLevelWindow = WinUtils::GetTopLevelHWND(aWindowHandle, true);
+      MOZ_ASSERT(::GetWindowLongPtr(topLevelWindow, GWL_EXSTYLE) &
+                 WS_EX_LAYERED);
 
-    if (isLayered) {
       BLENDFUNCTION bf = {AC_SRC_OVER, 0, 255, AC_SRC_ALPHA};
       SIZE winSize = {mSharedImage.GetWidth(), mSharedImage.GetHeight()};
       POINT srcPos = {0, 0};
       return !!::UpdateLayeredWindow(
-          aWindowHandle, nullptr /*paletteDC*/, nullptr /*newPos*/, &winSize,
+          topLevelWindow, nullptr /*paletteDC*/, nullptr /*newPos*/, &winSize,
           mDeviceContext, &srcPos, 0 /*colorKey*/, &bf, ULW_ALPHA);
     }
 
@@ -294,7 +298,8 @@
   }
 }
 
-bool Provider::Initialize(HWND aWindowHandle, DWORD aTargetProcessId) {
+bool Provider::Initialize(HWND aWindowHandle, DWORD aTargetProcessId,
+                          nsTransparencyMode aTransparencyMode) {
   MOZ_ASSERT(aWindowHandle);
   MOZ_ASSERT(aTargetProcessId);
 
@@ -335,6 +340,8 @@
 
   mServiceThread = std::thread([this] { this->ThreadMain(); });
 
+  mTransparencyMode = aTransparencyMode;
+
   return true;
 }
 
@@ -365,6 +372,10 @@
       reinterpret_cast<WindowsHandle>(responseReadyEvent)));
 }
 
+void Provider::UpdateTransparencyMode(nsTransparencyMode aTransparencyMode) {
+  mTransparencyMode = aTransparencyMode;
+}
+
 void Provider::ThreadMain() {
   while (true) {
     MOZ_ALWAYS_TRUE(::WaitForSingleObject(mRequestReadyEvent, INFINITE) ==
@@ -457,7 +468,7 @@
     return;
   }
 
-  if (!mBackbuffer->PresentToWindow(mWindowHandle)) {
+  if (!mBackbuffer->PresentToWindow(mWindowHandle, mTransparencyMode)) {
     return;
   }
 