# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/ClientWebGLContext.cpp
# Commit: e030be1d2dd9
# Full Hash: e030be1d2dd9b0bb47680fac29f20447c9d66f8c
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-02-21 09:51:10
# Regressor Bug: 1616715
# File Overlap Count: 1
# Description:
#   Bug 1616715 - Make ReadPixelDesc per-call. r=lsalzman
#   
#   GetSurfaceSnapshot (and similar) want to ReadPixels the backbuffer,
#   without having to navigate the GL PIXEL_PACK state.
#   Since this is cold cold code, it's nice to reduce the backend state by
# ==============================================================================

diff -r adc841b3e204 -r e030be1d2dd9 dom/canvas/ClientWebGLContext.cpp
--- a/dom/canvas/ClientWebGLContext.cpp	Fri Feb 21 02:27:08 2020 +0000
+++ b/dom/canvas/ClientWebGLContext.cpp	Fri Feb 21 03:12:41 2020 +0000
@@ -895,16 +895,17 @@
 
   const auto drawFbWas = state.mBoundDrawFb;
   const auto readFbWas = state.mBoundReadFb;
-
-  const auto alignmentWas = Run<RPROC(GetParameter)>(LOCAL_GL_PACK_ALIGNMENT);
-  if (!alignmentWas) return nullptr;
+  const auto pboWas =
+      Find(state.mBoundBufferByTarget, LOCAL_GL_PIXEL_PACK_BUFFER);
 
   const auto size = DrawingBufferSize();
 
   // -
 
   BindFramebuffer(LOCAL_GL_FRAMEBUFFER, nullptr);
-  PixelStorei(LOCAL_GL_PACK_ALIGNMENT, 4);
+  if (pboWas) {
+    BindBuffer(LOCAL_GL_PIXEL_PACK_BUFFER, nullptr);
+  }
 
   auto reset = MakeScopeExit([&] {
     if (drawFbWas == readFbWas) {
@@ -913,7 +914,9 @@
       BindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER, drawFbWas);
       BindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER, readFbWas);
     }
-    PixelStorei(LOCAL_GL_PACK_ALIGNMENT, *alignmentWas);
+    if (pboWas) {
+      BindBuffer(LOCAL_GL_PIXEL_PACK_BUFFER, pboWas);
+    }
   });
 
   const auto surfFormat = options.alpha ? gfx::SurfaceFormat::B8G8R8A8
@@ -934,10 +937,11 @@
     }
     MOZ_ASSERT(static_cast<uint32_t>(map.GetStride()) == stride);
 
+    const auto desc = webgl::ReadPixelsDesc{{0, 0}, size};
+
     const auto range = Range<uint8_t>(map.GetData(), stride * size.y);
     auto view = RawBufferView(range);
-    Run<RPROC(ReadPixels)>(0, 0, size.x, size.y, LOCAL_GL_RGBA,
-                           LOCAL_GL_UNSIGNED_BYTE, view);
+    Run<RPROC(ReadPixels)>(desc, view);
 
     // -
 
@@ -1695,6 +1699,10 @@
       }
       break;
 
+    case LOCAL_GL_PACK_ALIGNMENT:
+      retval.set(JS::NumberValue(state.mPixelPackState.alignment));
+      return;
+
     // -
     // Array returns
 
@@ -1827,6 +1835,16 @@
       case LOCAL_GL_MAX_ARRAY_TEXTURE_LAYERS:
         retval.set(JS::NumberValue(limits.maxTexArrayLayers));
         return;
+
+      case LOCAL_GL_PACK_ROW_LENGTH:
+        retval.set(JS::NumberValue(state.mPixelPackState.rowLength));
+        return;
+      case LOCAL_GL_PACK_SKIP_PIXELS:
+        retval.set(JS::NumberValue(state.mPixelPackState.skipPixels));
+        return;
+      case LOCAL_GL_PACK_SKIP_ROWS:
+        retval.set(JS::NumberValue(state.mPixelPackState.skipRows));
+        return;
     }  // switch pname
   }    // if webgl2
 
@@ -2410,7 +2428,50 @@
   Run<RPROC(LineWidth)>(width);
 }
 
-void ClientWebGLContext::PixelStorei(GLenum pname, GLint param) {
+void ClientWebGLContext::PixelStorei(const GLenum pname, const GLint iparam) {
+  const FuncScope funcScope(*this, "pixelStorei");
+  if (IsContextLost()) return;
+  if (!ValidateNonNegative("param", iparam)) return;
+  const auto param = static_cast<uint32_t>(iparam);
+
+  auto& state = State();
+  auto& packState = state.mPixelPackState;
+  switch (pname) {
+    case LOCAL_GL_PACK_ALIGNMENT:
+      switch (param) {
+        case 1:
+        case 2:
+        case 4:
+        case 8:
+          break;
+        default:
+          EnqueueError(LOCAL_GL_INVALID_VALUE,
+                       "PACK_ALIGNMENT must be one of [1,2,4,8], was %i.",
+                       iparam);
+          return;
+      }
+      packState.alignment = param;
+      return;
+
+    case LOCAL_GL_PACK_ROW_LENGTH:
+      if (!mIsWebGL2) break;
+      packState.rowLength = param;
+      return;
+
+    case LOCAL_GL_PACK_SKIP_PIXELS:
+      if (!mIsWebGL2) break;
+      packState.skipPixels = param;
+      return;
+
+    case LOCAL_GL_PACK_SKIP_ROWS:
+      if (!mIsWebGL2) break;
+      packState.skipRows = param;
+      return;
+
+    default:
+      break;
+  }
+
   Run<RPROC(PixelStorei)>(pname, param);
 }
 
@@ -3841,9 +3902,16 @@
                                     ErrorResult& out_error) const {
   const FuncScope funcScope(*this, "readPixels");
   if (!ReadPixels_SharedPrecheck(aCallerType, out_error)) return;
+  const auto& state = State();
+  if (!ValidateNonNegative("width", width)) return;
+  if (!ValidateNonNegative("height", height)) return;
   if (!ValidateNonNegative("offset", offset)) return;
-  Run<RPROC(ReadPixelsPbo)>(x, y, width, height, format, type,
-                            static_cast<uint64_t>(offset));
+
+  const auto desc = webgl::ReadPixelsDesc{{x, y},
+                                          *uvec2::From(width, height),
+                                          {format, type},
+                                          state.mPixelPackState};
+  Run<RPROC(ReadPixelsPbo)>(desc, static_cast<uint64_t>(offset));
 }
 
 void ClientWebGLContext::ReadPixels(GLint x, GLint y, GLsizei width,
@@ -3854,6 +3922,9 @@
                                     ErrorResult& out_error) const {
   const FuncScope funcScope(*this, "readPixels");
   if (!ReadPixels_SharedPrecheck(aCallerType, out_error)) return;
+  const auto& state = State();
+  if (!ValidateNonNegative("width", width)) return;
+  if (!ValidateNonNegative("height", height)) return;
 
   ////
 
@@ -3882,9 +3953,14 @@
                                LOCAL_GL_INVALID_VALUE, &bytes, &byteLen)) {
     return;
   }
+
+  const auto desc = webgl::ReadPixelsDesc{{x, y},
+                                          *uvec2::From(width, height),
+                                          {format, type},
+                                          state.mPixelPackState};
   const auto range = Range<uint8_t>(bytes, byteLen);
   auto view = RawBufferView(range);
-  Run<RPROC(ReadPixels)>(x, y, width, height, format, type, view);
+  Run<RPROC(ReadPixels)>(desc, view);
 }
 
 bool ClientWebGLContext::ReadPixels_SharedPrecheck(