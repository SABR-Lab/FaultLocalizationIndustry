# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/WSRunObject.cpp
# Commit: 54a21814751f
# Full Hash: 54a21814751f05d88f3b9cf5a16a821d11ca56eb
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-03-02 21:27:32
# Regressor Bug: 1618089
# File Overlap Count: 2
# Description:
#   Bug 1618089 - part 2: Rename `WSRunScanner::Get(Next|Previous)CharPointInternal()` to `WSRunScanner::LookFor(Next|Previous)CharPointWithinAllTextNodes()` r=m_kato
#   
#   They are fallback methods when the container of given point is not a text node
#   in `WSRunScanner::mNodeArray`, and then, looks for a text node for the given
#   point.
# ==============================================================================

diff -r 4b43fd9bf671 -r 54a21814751f editor/libeditor/WSRunObject.cpp
--- a/editor/libeditor/WSRunObject.cpp	Mon Mar 02 07:33:23 2020 +0000
+++ b/editor/libeditor/WSRunObject.cpp	Mon Mar 02 07:33:56 2020 +0000
@@ -1428,13 +1428,15 @@
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
-  int32_t idx = mNodeArray.IndexOf(aPoint.GetContainer());
-  if (idx == -1) {
+  size_t index = aPoint.IsInTextNode()
+                     ? mNodeArray.IndexOf(aPoint.GetContainer())
+                     : decltype(mNodeArray)::NoIndex;
+  if (index == decltype(mNodeArray)::NoIndex) {
     // Use range comparisons to get next text node which is in mNodeArray.
-    return GetNextCharPointInternal(aPoint);
+    return LookForNextCharPointWithinAllTextNodes(aPoint);
   }
   // Use WSPoint version of GetNextCharPoint()
-  return GetNextCharPoint(WSPoint(mNodeArray[idx], aPoint.Offset(), 0));
+  return GetNextCharPoint(WSPoint(mNodeArray[index], aPoint.Offset(), 0));
 }
 
 template <typename PT, typename CT>
@@ -1442,13 +1444,15 @@
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   MOZ_ASSERT(aPoint.IsSetAndValid());
 
-  int32_t idx = mNodeArray.IndexOf(aPoint.GetContainer());
-  if (idx == -1) {
+  size_t index = aPoint.IsInTextNode()
+                     ? mNodeArray.IndexOf(aPoint.GetContainer())
+                     : decltype(mNodeArray)::NoIndex;
+  if (index == decltype(mNodeArray)::NoIndex) {
     // Use range comparisons to get previous text node which is in mNodeArray.
-    return GetPreviousCharPointInternal(aPoint);
+    return LookForPreviousCharPointWithinAllTextNodes(aPoint);
   }
   // Use WSPoint version of GetPreviousCharPoint()
-  return GetPreviousCharPoint(WSPoint(mNodeArray[idx], aPoint.Offset(), 0));
+  return GetPreviousCharPoint(WSPoint(mNodeArray[index], aPoint.Offset(), 0));
 }
 
 WSRunScanner::WSPoint WSRunScanner::GetNextCharPoint(
@@ -1682,7 +1686,7 @@
 }
 
 template <typename PT, typename CT>
-WSRunScanner::WSPoint WSRunScanner::GetNextCharPointInternal(
+WSRunScanner::WSPoint WSRunScanner::LookForNextCharPointWithinAllTextNodes(
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   // Note: only to be called if aPoint.GetContainer() is not a ws node.
 
@@ -1732,7 +1736,7 @@
 }
 
 template <typename PT, typename CT>
-WSRunScanner::WSPoint WSRunScanner::GetPreviousCharPointInternal(
+WSRunScanner::WSPoint WSRunScanner::LookForPreviousCharPointWithinAllTextNodes(
     const EditorDOMPointBase<PT, CT>& aPoint) const {
   // Note: only to be called if aNode is not a ws node.
 