# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/EditorDOMPoint.h
# Commit: 61f680923525
# Full Hash: 61f680923525df4092faa7da9afc119ce07f4306
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-03-03 09:50:30
# Regressor Bug: 1618089
# File Overlap Count: 2
# Description:
#   Bug 1618089 - part 6: Get rid of `WSRunScanner::WSPoint` r=m_kato
#   
#   With adding new type, `EditorDOMPointInText` whose container is
#   `RefPtr<dom::Text>`, we can replace `WSRunScanner::WSPoint` and make
#   `WSRunScanner` and `WSRunObject` can use its various API.  Then, this
# ==============================================================================

diff -r e42bf0b7e1af -r 61f680923525 editor/libeditor/EditorDOMPoint.h
--- a/editor/libeditor/EditorDOMPoint.h	Mon Mar 02 19:02:51 2020 +0000
+++ b/editor/libeditor/EditorDOMPoint.h	Mon Mar 02 10:08:59 2020 +0000
@@ -13,6 +13,7 @@
 #include "mozilla/dom/Text.h"
 #include "nsAtom.h"
 #include "nsCOMPtr.h"
+#include "nsCRT.h"
 #include "nsGkAtoms.h"
 #include "nsIContent.h"
 #include "nsINode.h"
@@ -67,6 +68,7 @@
 typedef EditorDOMPointBase<nsCOMPtr<nsINode>, nsCOMPtr<nsIContent>>
     EditorDOMPoint;
 typedef EditorDOMPointBase<nsINode*, nsIContent*> EditorRawDOMPoint;
+typedef EditorDOMPointBase<RefPtr<dom::Text>, nsIContent*> EditorDOMPointInText;
 
 template <typename ParentType, typename ChildType>
 class EditorDOMPointBase final {
@@ -156,14 +158,32 @@
     return nsIContent::FromNodeOrNull(mParent);
   }
 
+  MOZ_NEVER_INLINE_DEBUG nsIContent* ContainerAsContent() const {
+    MOZ_ASSERT(mParent);
+    MOZ_ASSERT(mParent->IsContent());
+    return mParent->AsContent();
+  }
+
   dom::Element* GetContainerAsElement() const {
     return dom::Element::FromNodeOrNull(mParent);
   }
 
+  MOZ_NEVER_INLINE_DEBUG dom::Element* ContainerAsElement() const {
+    MOZ_ASSERT(mParent);
+    MOZ_ASSERT(mParent->IsElement());
+    return mParent->AsElement();
+  }
+
   dom::Text* GetContainerAsText() const {
     return dom::Text::FromNodeOrNull(mParent);
   }
 
+  MOZ_NEVER_INLINE_DEBUG dom::Text* ContainerAsText() const {
+    MOZ_ASSERT(mParent);
+    MOZ_ASSERT(IsInTextNode());
+    return mParent->AsText();
+  }
+
   /**
    * GetContainerParent() returns parent of the container node at the point.
    */
@@ -189,6 +209,11 @@
   }
 
   /**
+   * IsContainerEmpty() returns true if it has no children or its text is empty.
+   */
+  bool IsContainerEmpty() const { return mParent && !mParent->Length(); }
+
+  /**
    * IsInDataNode() returns true if the container node is a data node including
    * text node.
    */
@@ -291,6 +316,44 @@
     return mChild ? mChild->GetPreviousSibling() : mParent->GetLastChild();
   }
 
+  /**
+   * Simple accessors of the character in dom::Text so that when you call
+   * these methods, you need to guarantee that the container is a dom::Text.
+   */
+  MOZ_NEVER_INLINE_DEBUG char16_t Char() const {
+    MOZ_ASSERT(IsSetAndValid());
+    MOZ_ASSERT(!IsEndOfContainer());
+    return ContainerAsText()->TextFragment().CharAt(mOffset.value());
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsCharASCIISpace() const {
+    return nsCRT::IsAsciiSpace(Char());
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsCharNBSP() const { return Char() == 0x00A0; }
+
+  MOZ_NEVER_INLINE_DEBUG char16_t PreviousChar() const {
+    MOZ_ASSERT(IsSetAndValid());
+    MOZ_ASSERT(!IsStartOfContainer());
+    return ContainerAsText()->TextFragment().CharAt(mOffset.value() - 1);
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsPreviousCharASCIISpace() const {
+    return nsCRT::IsAsciiSpace(PreviousChar());
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsPreviousCharNBSP() const {
+    return PreviousChar() == 0x00A0;
+  }
+
+  MOZ_NEVER_INLINE_DEBUG char16_t NextChar() const {
+    MOZ_ASSERT(IsSetAndValid());
+    MOZ_ASSERT(!IsAtLastContent() && !IsEndOfContainer());
+    return ContainerAsText()->TextFragment().CharAt(mOffset.value() + 1);
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsNextCharASCIISpace() const {
+    return nsCRT::IsAsciiSpace(NextChar());
+  }
+  MOZ_NEVER_INLINE_DEBUG bool IsNextCharNBSP() const {
+    return NextChar() == 0x00A0;
+  }
+
   uint32_t Offset() const {
     if (mOffset.isSome()) {
       MOZ_ASSERT(mOffset.isSome());
@@ -411,6 +474,24 @@
   }
 
   /**
+   * NextPoint() and PreviousPoint() returns next/previous DOM point in
+   * the container.
+   */
+  MOZ_NEVER_INLINE_DEBUG SelfType NextPoint() const {
+    NS_ASSERTION(!IsEndOfContainer(), "Should not be at end of the container");
+    SelfType result(*this);
+    result.AdvanceOffset();
+    return result;
+  }
+  MOZ_NEVER_INLINE_DEBUG SelfType PreviousPoint() const {
+    NS_ASSERTION(!IsStartOfContainer(),
+                 "Should not be at start of the container");
+    SelfType result(*this);
+    result.RewindOffset();
+    return result;
+  }
+
+  /**
    * Clear() makes the instance not point anywhere.
    */
   void Clear() {
@@ -580,7 +661,7 @@
       }
       NS_WARNING_ASSERTION(!mOffset.isSome() || mParent->GetChildAt_Deprecated(
                                                     mOffset.value()) == mChild,
-                           "If mOffset and mChild are mismatched");
+                           "mOffset and mChild are mismatched");
       return false;
     }
     MOZ_ASSERT(mOffset.isSome());
@@ -609,13 +690,41 @@
       }
       NS_WARNING_ASSERTION(!mOffset.isSome() || mParent->GetChildAt_Deprecated(
                                                     mOffset.value()) == mChild,
-                           "If mOffset and mChild are mismatched");
+                           "mOffset and mChild are mismatched");
       return false;
     }
     MOZ_ASSERT(mOffset.isSome());
     return mOffset.value() == mParent->Length();
   }
 
+  /**
+   * IsAtLastContent() returns true when it refers last child of the container
+   * or last character offset of text node.
+   */
+  bool IsAtLastContent() const {
+    if (NS_WARN_IF(!mParent)) {
+      return false;
+    }
+    if (mParent->IsContainerNode()) {
+      return mOffset.value() == mParent->Length() - 1;
+    }
+    if (mIsChildInitialized) {
+      if (mChild && mChild == mParent->GetLastChild()) {
+        NS_WARNING_ASSERTION(
+            !mOffset.isSome() || mOffset.value() == mParent->Length() - 1,
+            "If mOffset was initialized, it should be length - 1 of the "
+            "container");
+        return true;
+      }
+      NS_WARNING_ASSERTION(!mOffset.isSome() || mParent->GetChildAt_Deprecated(
+                                                    mOffset.value()) == mChild,
+                           "mOffset and mChild are mismatched");
+      return false;
+    }
+    MOZ_ASSERT(mOffset.isSome());
+    return mOffset.value() == mParent->Length() - 1;
+  }
+
   bool IsBRElementAtEndOfContainer() const {
     if (NS_WARN_IF(!mParent)) {
       return false;