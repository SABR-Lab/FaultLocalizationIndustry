# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 75b0efe2d2e1
# Full Hash: 75b0efe2d2e107ba25c9de3ae8a902a542726849
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-03-03 15:54:57
# Regressor Bug: 1618089
# File Overlap Count: 2
# Description:
#   Bug 1618089 - part 8: Make `WSRunObject::PrepareToDeleteRange()` take 2 pointers of `EditorDOMPoint` r=m_kato
#   
#   Note that the input can be `EditorDOMPointInText`, but modified range may start
#   and/or end with different container.  Therefore, it needs to take
#   `EditorDOMPoint` rather than `EditorDOMPointInText`.
# ==============================================================================

diff -r b3fb77a04fc5 -r 75b0efe2d2e1 editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Mon Mar 02 20:07:10 2020 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Tue Mar 03 04:35:26 2020 +0000
@@ -17,6 +17,7 @@
 #include "mozilla/EditAction.h"
 #include "mozilla/EditorDOMPoint.h"
 #include "mozilla/EditorUtils.h"
+#include "mozilla/InternalMutationEvent.h"
 #include "mozilla/MathAlgorithms.h"
 #include "mozilla/OwningNonNull.h"
 #include "mozilla/Preferences.h"
@@ -2505,48 +2506,56 @@
   MOZ_ASSERT(aPointToDelete.IsInTextNode());
 
   OwningNonNull<Text> visibleTextNode = *aPointToDelete.GetContainerAsText();
-  int32_t startOffset = aPointToDelete.Offset();
-  int32_t endOffset = startOffset + 1;
+  EditorDOMPoint startToDelete, endToDelete;
   if (aDirectionAndAmount == nsIEditor::ePrevious) {
-    if (!startOffset) {
+    if (aPointToDelete.IsStartOfContainer()) {
       return EditActionResult(NS_ERROR_UNEXPECTED);
     }
-    startOffset--;
-    endOffset--;
+    startToDelete = aPointToDelete.PreviousPoint();
+    endToDelete = aPointToDelete;
     // Bug 1068979: delete both codepoints if surrogate pair
-    if (startOffset > 0) {
+    if (!startToDelete.IsStartOfContainer()) {
       const nsTextFragment* text = &visibleTextNode->TextFragment();
-      if (text->IsLowSurrogateFollowingHighSurrogateAt(startOffset)) {
-        startOffset--;
+      if (text->IsLowSurrogateFollowingHighSurrogateAt(
+              startToDelete.Offset())) {
+        startToDelete.RewindOffset();
       }
     }
   } else {
     RefPtr<nsRange> range = SelectionRefPtr()->GetRangeAt(0);
-    if (NS_WARN_IF(!range)) {
+    if (NS_WARN_IF(!range) ||
+        NS_WARN_IF(range->GetStartContainer() !=
+                   aPointToDelete.GetContainer()) ||
+        NS_WARN_IF(range->GetEndContainer() != aPointToDelete.GetContainer())) {
       return EditActionResult(NS_ERROR_FAILURE);
     }
-
-    NS_ASSERTION(range->GetStartContainer() == aPointToDelete.GetContainer(),
-                 "selection start not in the text node");
-    NS_ASSERTION(range->GetEndContainer() == aPointToDelete.GetContainer(),
-                 "selection end not in the text node");
-
-    startOffset = range->StartOffset();
-    endOffset = range->EndOffset();
-  }
-  nsCOMPtr<nsINode> textNodeForDeletion = aPointToDelete.GetContainer();
-  nsresult rv = WSRunObject::PrepareToDeleteRange(
-      *this, address_of(textNodeForDeletion), &startOffset,
-      address_of(textNodeForDeletion), &endOffset);
+    startToDelete = range->StartRef();
+    endToDelete = range->EndRef();
+  }
+  nsresult rv =
+      WSRunObject::PrepareToDeleteRange(*this, &startToDelete, &endToDelete);
   if (NS_WARN_IF(Destroyed())) {
     return EditActionResult(NS_ERROR_EDITOR_DESTROYED);
   }
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return EditActionResult(rv);
   }
-  rv = DeleteTextWithTransaction(visibleTextNode,
-                                 std::min(startOffset, endOffset),
-                                 DeprecatedAbs(endOffset - startOffset));
+  if (MaybeHasMutationEventListeners(
+          NS_EVENT_BITS_MUTATION_NODEREMOVED |
+          NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT |
+          NS_EVENT_BITS_MUTATION_ATTRMODIFIED |
+          NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED) &&
+      (NS_WARN_IF(!startToDelete.IsSetAndValid()) ||
+       NS_WARN_IF(!startToDelete.IsInTextNode()) ||
+       NS_WARN_IF(!endToDelete.IsSetAndValid()) ||
+       NS_WARN_IF(!endToDelete.IsInTextNode()) ||
+       NS_WARN_IF(startToDelete.ContainerAsText() != visibleTextNode) ||
+       NS_WARN_IF(endToDelete.ContainerAsText() != visibleTextNode) ||
+       NS_WARN_IF(startToDelete.Offset() <= endToDelete.Offset()))) {
+    return EditActionHandled(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
+  }
+  rv = DeleteTextWithTransaction(visibleTextNode, startToDelete.Offset(),
+                                 endToDelete.Offset() - startToDelete.Offset());
   if (NS_WARN_IF(Destroyed())) {
     return EditActionHandled(NS_ERROR_EDITOR_DESTROYED);
   }
@@ -3016,24 +3025,22 @@
   // surrounding whitespace in preparation to delete selection.
   if (!IsPlaintextEditor()) {
     AutoTransactionsConserveSelection dontChangeMySelection(*this);
-    nsCOMPtr<nsINode> startNode = firstRangeStart.GetContainer();
-    int32_t startOffset = firstRangeStart.Offset();
-    nsCOMPtr<nsINode> endNode = firstRangeEnd.GetContainer();
-    int32_t endOffset = firstRangeEnd.Offset();
-    nsresult rv = WSRunObject::PrepareToDeleteRange(
-        *this, address_of(startNode), &startOffset, address_of(endNode),
-        &endOffset);
+    nsresult rv = WSRunObject::PrepareToDeleteRange(*this, &firstRangeStart,
+                                                    &firstRangeEnd);
     if (NS_WARN_IF(Destroyed())) {
       return EditActionResult(NS_ERROR_EDITOR_DESTROYED);
     }
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return EditActionResult(rv);
     }
-    firstRangeStart.Set(startNode, startOffset);
-    firstRangeEnd.Set(endNode, endOffset);
-    if (NS_WARN_IF(!firstRangeStart.IsSet()) ||
-        NS_WARN_IF(!firstRangeEnd.IsSet())) {
-      return EditActionResult(NS_ERROR_FAILURE);
+    if (MaybeHasMutationEventListeners(
+            NS_EVENT_BITS_MUTATION_NODEREMOVED |
+            NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT |
+            NS_EVENT_BITS_MUTATION_ATTRMODIFIED |
+            NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED) &&
+        (NS_WARN_IF(!firstRangeStart.IsSetAndValid()) ||
+         NS_WARN_IF(!firstRangeEnd.IsSetAndValid()))) {
+      return EditActionHandled(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
     }
   }
 