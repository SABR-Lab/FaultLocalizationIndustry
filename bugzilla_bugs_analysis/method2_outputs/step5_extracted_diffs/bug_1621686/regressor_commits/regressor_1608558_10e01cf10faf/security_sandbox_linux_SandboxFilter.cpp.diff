# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/sandbox/linux/SandboxFilter.cpp
# Commit: 10e01cf10faf
# Full Hash: 10e01cf10fafca4a150c2f76b3ce4e33bbd06223
# Author: Michael Froman <mfroman@mozilla.com>
# Date: 2020-03-09 21:52:54
# Regressor Bug: 1608558
# File Overlap Count: 1
# Description:
#   Bug 1608558 - pt1 - add linux sandboxing to socket process. r=gcp
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D60014
# ==============================================================================

diff -r 61e14505a488 -r 10e01cf10faf security/sandbox/linux/SandboxFilter.cpp
--- a/security/sandbox/linux/SandboxFilter.cpp	Fri Mar 06 20:29:47 2020 +0000
+++ b/security/sandbox/linux/SandboxFilter.cpp	Mon Mar 09 14:56:03 2020 +0000
@@ -1480,4 +1480,122 @@
       new RDDSandboxPolicy(aMaybeBroker));
 }
 
+// Basically a clone of RDDSandboxPolicy until we know exactly what
+// the SocketProcess sandbox looks like.
+class SocketProcessSandboxPolicy final : public SandboxPolicyCommon {
+ public:
+  explicit SocketProcessSandboxPolicy(SandboxBrokerClient* aBroker)
+      : SandboxPolicyCommon(aBroker, ShmemUsage::MAY_CREATE,
+                            AllowUnsafeSocketPair::NO) {}
+
+  static intptr_t FcntlTrap(const sandbox::arch_seccomp_data& aArgs,
+                            void* aux) {
+    const auto cmd = static_cast<int>(aArgs.args[1]);
+    switch (cmd) {
+        // This process can't exec, so the actual close-on-exec flag
+        // doesn't matter; have it always read as true and ignore writes.
+      case F_GETFD:
+        return O_CLOEXEC;
+      case F_SETFD:
+        return 0;
+      default:
+        return -ENOSYS;
+    }
+  }
+
+  ResultExpr EvaluateSyscall(int sysno) const override {
+    switch (sysno) {
+      case __NR_getrusage:
+        return Allow();
+
+      case __NR_ioctl: {
+        static const unsigned long kTypeMask = _IOC_TYPEMASK << _IOC_TYPESHIFT;
+        static const unsigned long kTtyIoctls = TIOCSTI & kTypeMask;
+        // On some older architectures (but not x86 or ARM), ioctls are
+        // assigned type fields differently, and the TIOC/TC/FIO group
+        // isn't all the same type.  If/when we support those archs,
+        // this would need to be revised (but really this should be a
+        // default-deny policy; see below).
+        static_assert(kTtyIoctls == (TCSETA & kTypeMask) &&
+                          kTtyIoctls == (FIOASYNC & kTypeMask),
+                      "tty-related ioctls use the same type");
+
+        Arg<unsigned long> request(1);
+        auto shifted_type = request & kTypeMask;
+
+        // Rust's stdlib seems to use FIOCLEX instead of equivalent fcntls.
+        return If(request == FIOCLEX, Allow())
+            // Rust's stdlib also uses FIONBIO instead of equivalent fcntls.
+            .ElseIf(request == FIONBIO, Allow())
+            // ffmpeg, and anything else that calls isatty(), will be told
+            // that nothing is a typewriter:
+            .ElseIf(request == TCGETS, Error(ENOTTY))
+            // Allow anything that isn't a tty ioctl, for now; bug 1302711
+            // will cover changing this to a default-deny policy.
+            .ElseIf(shifted_type != kTtyIoctls, Allow())
+            .Else(SandboxPolicyCommon::EvaluateSyscall(sysno));
+      }
+
+      CASES_FOR_fcntl : {
+        Arg<int> cmd(1);
+        Arg<int> flags(2);
+        // Typical use of F_SETFL is to modify the flags returned by
+        // F_GETFL and write them back, including some flags that
+        // F_SETFL ignores.  This is a default-deny policy in case any
+        // new SETFL-able flags are added.  (In particular we want to
+        // forbid O_ASYNC; see bug 1328896, but also see bug 1408438.)
+        static const int ignored_flags =
+            O_ACCMODE | O_LARGEFILE_REAL | O_CLOEXEC;
+        static const int allowed_flags = ignored_flags | O_APPEND | O_NONBLOCK;
+        return Switch(cmd)
+            // Close-on-exec is meaningless when execve isn't allowed, but
+            // NSPR reads the bit and asserts that it has the expected value.
+            .Case(F_GETFD, Allow())
+            .Case(
+                F_SETFD,
+                If((flags & ~FD_CLOEXEC) == 0, Allow()).Else(InvalidSyscall()))
+            .Case(F_GETFL, Allow())
+            .Case(F_SETFL, If((flags & ~allowed_flags) == 0, Allow())
+                               .Else(InvalidSyscall()))
+            .Case(F_DUPFD_CLOEXEC, Allow())
+            // Nvidia GL and fontconfig (newer versions) use fcntl file locking.
+            .Case(F_SETLK, Allow())
+#ifdef F_SETLK64
+            .Case(F_SETLK64, Allow())
+#endif
+            // Pulseaudio uses F_SETLKW, as does fontconfig.
+            .Case(F_SETLKW, Allow())
+#ifdef F_SETLKW64
+            .Case(F_SETLKW64, Allow())
+#endif
+            .Default(SandboxPolicyCommon::EvaluateSyscall(sysno));
+      }
+
+#ifdef DESKTOP
+      // This section is borrowed from ContentSandboxPolicy
+      case __NR_prlimit64: {
+        // Allow only the getrlimit() use case.  (glibc seems to use
+        // only pid 0 to indicate the current process; pid == getpid()
+        // is equivalent and could also be allowed if needed.)
+        Arg<pid_t> pid(0);
+        // This is really a const struct ::rlimit*, but Arg<> doesn't
+        // work with pointers, only integer types.
+        Arg<uintptr_t> new_limit(2);
+        return If(AllOf(pid == 0, new_limit == 0), Allow())
+            .Else(InvalidSyscall());
+      }
+#endif  // DESKTOP
+
+      default:
+        return SandboxPolicyCommon::EvaluateSyscall(sysno);
+    }
+  }
+};
+
+UniquePtr<sandbox::bpf_dsl::Policy> GetSocketProcessSandboxPolicy(
+    SandboxBrokerClient* aMaybeBroker) {
+  return UniquePtr<sandbox::bpf_dsl::Policy>(
+      new SocketProcessSandboxPolicy(aMaybeBroker));
+}
+
 }  // namespace mozilla