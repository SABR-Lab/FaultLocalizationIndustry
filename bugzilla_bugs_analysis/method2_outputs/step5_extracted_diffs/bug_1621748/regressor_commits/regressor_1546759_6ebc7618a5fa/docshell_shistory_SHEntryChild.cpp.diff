# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/shistory/SHEntryChild.cpp
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa docshell/shistory/SHEntryChild.cpp
--- a/docshell/shistory/SHEntryChild.cpp	Tue Mar 10 11:39:06 2020 +0000
+++ b/docshell/shistory/SHEntryChild.cpp	Tue Mar 10 14:28:22 2020 +0000
@@ -604,9 +604,11 @@
 
 NS_IMETHODIMP
 SHEntryChild::Clone(nsISHEntry** aResult) {
-  NS_IF_ADDREF(*aResult = static_cast<SHEntryChild*>(
-                   ContentChild::GetSingleton()->SendPSHEntryConstructor(
-                       mShared->mSHistory, this)));
+  RefPtr<CrossProcessSHEntry> result;
+  if (!SendClone(&result)) {
+    return NS_ERROR_FAILURE;
+  }
+  *aResult = result ? do_AddRef(result->ToSHEntryChild()).take() : nullptr;
   return NS_OK;
 }
 
@@ -1009,6 +1011,31 @@
   return NS_OK;
 }
 
+NS_IMETHODIMP_(void)
+SHEntryChild::SyncTreesForSubframeNavigation(nsISHEntry* aEntry,
+                                             BrowsingContext* aBC,
+                                             BrowsingContext* aIgnoreBC) {
+  nsTArray<SwapEntriesDocshellData> entriesToUpdate;
+  Unused << SendSyncTreesForSubframeNavigation(
+      static_cast<SHEntryChild*>(aEntry), aBC, aIgnoreBC, &entriesToUpdate);
+  for (auto& data : entriesToUpdate) {
+    // data.context() is a MaybeDiscardedBrowsingContext
+    // It can't be null, but if it has been discarded we will update
+    // the docshell anyway
+    MOZ_ASSERT(!data.context().IsNull(), "Browsing context cannot be null");
+    nsDocShell* docshell = static_cast<nsDocShell*>(
+        data.context().GetMaybeDiscarded()->GetDocShell());
+    if (docshell) {
+      RefPtr<SHEntryChild> oldEntry = data.oldEntry()->ToSHEntryChild();
+      RefPtr<SHEntryChild> newEntry;
+      if (data.newEntry()) {
+        newEntry = data.newEntry()->ToSHEntryChild();
+      }
+      docshell->SwapHistoryEntries(oldEntry, newEntry);
+    }
+  }
+}
+
 void SHEntryChild::EvictContentViewer() {
   nsCOMPtr<nsIContentViewer> viewer = GetContentViewer();
   if (viewer) {