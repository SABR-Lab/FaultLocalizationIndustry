# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/shistory/SHistoryParent.cpp
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa docshell/shistory/SHistoryParent.cpp
--- a/docshell/shistory/SHistoryParent.cpp	Tue Mar 10 11:39:06 2020 +0000
+++ b/docshell/shistory/SHistoryParent.cpp	Tue Mar 10 14:28:22 2020 +0000
@@ -47,19 +47,12 @@
 
 SHistoryParent::~SHistoryParent() { mHistory->mSHistoryParent = nullptr; }
 
-SHEntryParent* SHistoryParent::CreateEntry(
-    PContentParent* aContentParent, PSHistoryParent* aSHistoryParent,
-    const PSHEntryOrSharedID& aEntryOrSharedID) {
-  RefPtr<LegacySHEntry> entry;
-  if (aEntryOrSharedID.type() == PSHEntryOrSharedID::Tuint64_t) {
-    entry = new LegacySHEntry(
-        aContentParent, static_cast<SHistoryParent*>(aSHistoryParent)->mHistory,
-        aEntryOrSharedID.get_uint64_t());
-  } else {
-    entry = new LegacySHEntry(*(
-        static_cast<const SHEntryParent*>(aEntryOrSharedID.get_PSHEntryParent())
-            ->mEntry));
-  }
+SHEntryParent* SHistoryParent::CreateEntry(PContentParent* aContentParent,
+                                           PSHistoryParent* aSHistoryParent,
+                                           uint64_t aSharedID) {
+  RefPtr<LegacySHEntry> entry = new LegacySHEntry(
+      aContentParent, static_cast<SHistoryParent*>(aSHistoryParent)->mHistory,
+      aSharedID);
   return entry->CreateActor();
 }
 
@@ -375,5 +368,65 @@
                                                             : NS_ERROR_FAILURE;
 }
 
+bool SHistoryParent::RecvAddToRootSessionHistory(
+    bool aCloneChildren, PSHEntryParent* aOSHE,
+    const MaybeDiscarded<BrowsingContext>& aBC, PSHEntryParent* aEntry,
+    uint32_t aLoadType, bool aShouldPersist,
+    Maybe<int32_t>* aPreviousEntryIndex, Maybe<int32_t>* aLoadedEntryIndex,
+    nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+    int32_t* aEntriesPurged, nsresult* aResult) {
+  MOZ_ASSERT(!aBC.IsNull(), "Browsing context cannot be null");
+  nsTArray<EntriesAndBrowsingContextData> entriesToSendOverIDL;
+  *aResult = mHistory->AddToRootSessionHistory(
+      aCloneChildren,
+      aOSHE ? static_cast<SHEntryParent*>(aOSHE)->mEntry.get() : nullptr,
+      aBC.GetMaybeDiscarded(),
+      static_cast<SHEntryParent*>(aEntry)->mEntry.get(), aLoadType,
+      aShouldPersist, static_cast<ContentParent*>(Manager())->ChildID(),
+      aPreviousEntryIndex, aLoadedEntryIndex, &entriesToSendOverIDL,
+      aEntriesPurged);
+  SHistoryParent::CreateActorsForSwapEntries(entriesToSendOverIDL,
+                                             aEntriesToUpdate, Manager());
+  return true;
+}
+
+bool SHistoryParent::RecvAddChildSHEntryHelper(
+    PSHEntryParent* aCloneRef, PSHEntryParent* aNewEntry,
+    const MaybeDiscarded<BrowsingContext>& aBC, bool aCloneChildren,
+    nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+    int32_t* aEntriesPurged, RefPtr<CrossProcessSHEntry>* aChild,
+    nsresult* aResult) {
+  MOZ_ASSERT(!aBC.IsNull(), "Browsing context cannot be null");
+  nsCOMPtr<nsISHEntry> child;
+  nsTArray<EntriesAndBrowsingContextData> entriesToSendOverIPC;
+  *aResult = mHistory->AddChildSHEntryHelper(
+      static_cast<SHEntryParent*>(aCloneRef)->mEntry.get(),
+      aNewEntry ? static_cast<SHEntryParent*>(aNewEntry)->mEntry.get()
+                : nullptr,
+      aBC.GetMaybeDiscarded(), aCloneChildren,
+      static_cast<ContentParent*>(Manager())->ChildID(), &entriesToSendOverIPC,
+      aEntriesPurged, getter_AddRefs(child));
+  SHistoryParent::CreateActorsForSwapEntries(entriesToSendOverIPC,
+                                             aEntriesToUpdate, Manager());
+  *aChild = child.forget().downcast<LegacySHEntry>();
+  return true;
+}
+
+void SHistoryParent::CreateActorsForSwapEntries(
+    const nsTArray<EntriesAndBrowsingContextData>& aEntriesToSendOverIPC,
+    nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+    PContentParent* aContentParent) {
+  for (auto& data : aEntriesToSendOverIPC) {
+    SwapEntriesDocshellData* toUpdate = aEntriesToUpdate->AppendElement();
+
+    // Old entry
+    toUpdate->oldEntry() = static_cast<LegacySHEntry*>(data.oldEntry.get());
+
+    // New entry
+    toUpdate->newEntry() = static_cast<LegacySHEntry*>(data.newEntry.get());
+    toUpdate->context() = data.context;
+  }
+}
+
 }  // namespace dom
 }  // namespace mozilla