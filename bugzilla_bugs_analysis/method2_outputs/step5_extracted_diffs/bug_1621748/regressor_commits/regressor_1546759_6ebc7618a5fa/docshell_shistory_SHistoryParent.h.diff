# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/shistory/SHistoryParent.h
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa docshell/shistory/SHistoryParent.h
--- a/docshell/shistory/SHistoryParent.h	Tue Mar 10 11:39:06 2020 +0000
+++ b/docshell/shistory/SHistoryParent.h	Tue Mar 10 14:28:22 2020 +0000
@@ -59,7 +59,14 @@
 
   static SHEntryParent* CreateEntry(PContentParent* aContentParent,
                                     PSHistoryParent* aSHistoryParent,
-                                    const PSHEntryOrSharedID& aEntryOrSharedID);
+                                    uint64_t aSharedID);
+
+  // We have a list of entries we would like to return from
+  // the IPC call and we need to create actors for all of them
+  static void CreateActorsForSwapEntries(
+      const nsTArray<EntriesAndBrowsingContextData>& aEntriesToSendOverIPC,
+      nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+      PContentParent* aContentParent);
 
  protected:
   void ActorDestroy(ActorDestroyReason aWhy) override;
@@ -99,7 +106,21 @@
   bool RecvEvictContentViewersOrReplaceEntry(PSHEntryParent* aNewSHEntry,
                                              bool aReplace);
   bool RecvNotifyListenersContentViewerEvicted(uint32_t aNumEvicted);
+  bool RecvAddToRootSessionHistory(
+      bool aCloneChildren, PSHEntryParent* aOSHE,
+      const MaybeDiscarded<BrowsingContext>& aBC, PSHEntryParent* aEntry,
+      uint32_t aLoadType, bool aShouldPersist,
+      Maybe<int32_t>* aPreviousEntryIndex, Maybe<int32_t>* aLoadedEntryIndex,
+      nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+      int32_t* aEntriesPurged, nsresult* aResult);
+  bool RecvAddChildSHEntryHelper(
+      PSHEntryParent* aCloneRef, PSHEntryParent* aNewEntry,
+      const MaybeDiscarded<BrowsingContext>& aBC, bool aCloneChildren,
+      nsTArray<SwapEntriesDocshellData>* aEntriesToUpdate,
+      int32_t* aEntriesPurged, RefPtr<CrossProcessSHEntry>* aChild,
+      nsresult* aResult);
 
+  RefPtr<CanonicalBrowsingContext> mContext;
   RefPtr<LegacySHistory> mHistory;
 };
 