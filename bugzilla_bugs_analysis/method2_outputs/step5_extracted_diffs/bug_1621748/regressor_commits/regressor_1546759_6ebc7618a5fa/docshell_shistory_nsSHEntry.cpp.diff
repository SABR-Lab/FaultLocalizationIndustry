# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/shistory/nsSHEntry.cpp
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa docshell/shistory/nsSHEntry.cpp
--- a/docshell/shistory/nsSHEntry.cpp	Tue Mar 10 11:39:06 2020 +0000
+++ b/docshell/shistory/nsSHEntry.cpp	Tue Mar 10 14:28:22 2020 +0000
@@ -1020,6 +1020,48 @@
   return NS_OK;
 }
 
+void nsSHEntry::SyncTreesForSubframeNavigation(
+    uint64_t aOtherPid, nsISHEntry* aEntry,
+    mozilla::dom::BrowsingContext* aTopBC,
+    mozilla::dom::BrowsingContext* aIgnoreBC,
+    nsTArray<EntriesAndBrowsingContextData>* aEntriesToUpdate) {
+  MOZ_ASSERT(aEntriesToUpdate || aOtherPid == 0,
+             "our entries to update is null");
+
+  // We need to sync up the browsing context and session history trees for
+  // subframe navigation.  If the load was in a subframe, we forward up to
+  // the top browsing context, which will then recursively sync up all browsing
+  // contexts to their corresponding entries in the new session history tree. If
+  // we don't do this, then we can cache a content viewer on the wrong cloned
+  // entry, and subsequently restore it at the wrong time.
+  nsCOMPtr<nsISHEntry> newRootEntry = nsSHistory::GetRootSHEntry(aEntry);
+  if (newRootEntry) {
+    // newRootEntry is now the new root entry.
+    // Find the old root entry as well.
+
+    // Need a strong ref. on |oldRootEntry| so it isn't destroyed when
+    // SetChildHistoryEntry() does SwapHistoryEntries() (bug 304639).
+    nsCOMPtr<nsISHEntry> oldRootEntry = nsSHistory::GetRootSHEntry(this);
+
+    if (oldRootEntry) {
+      nsSHistory::SwapEntriesData data = {aIgnoreBC, newRootEntry, nullptr,
+                                          aOtherPid, aEntriesToUpdate};
+      nsSHistory::SetChildHistoryEntry(oldRootEntry, aTopBC, 0, &data);
+    }
+  }
+}
+
+NS_IMETHODIMP_(void)
+nsSHEntry::SyncTreesForSubframeNavigation(
+    nsISHEntry* aEntry, mozilla::dom::BrowsingContext* aTopBC,
+    mozilla::dom::BrowsingContext* aIgnoreBC) {
+  SyncTreesForSubframeNavigation(
+        0 /* unused, this will be set in SHEntryParent::RecvSyncTrees */,
+        aEntry, aTopBC, aIgnoreBC,
+        nullptr /* this will be given in SHEntryCHild::SyncTrees if we
+                are going over IPC, else, it is not needed */);
+}
+
 void nsSHEntry::EvictContentViewer() {
   nsCOMPtr<nsIContentViewer> viewer = GetContentViewer();
   if (viewer) {