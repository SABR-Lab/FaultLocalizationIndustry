# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/shistory/nsSHistory.h
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa docshell/shistory/nsSHistory.h
--- a/docshell/shistory/nsSHistory.h	Tue Mar 10 11:39:06 2020 +0000
+++ b/docshell/shistory/nsSHistory.h	Tue Mar 10 14:28:22 2020 +0000
@@ -58,10 +58,15 @@
 
   // Structure used in SetChildHistoryEntry
   struct SwapEntriesData {
-    nsDocShell* ignoreShell;     // constant; the shell to ignore
+    mozilla::dom::BrowsingContext*
+        ignoreBC;                // constant; the browsing context to ignore
     nsISHEntry* destTreeRoot;    // constant; the root of the dest tree
     nsISHEntry* destTreeParent;  // constant; the node under destTreeRoot
                                  // whose children will correspond to aEntry
+    uint64_t otherPid;  // constant; pid of the process which indirectly called
+                        // SetChildHistoryEntry
+    // see comment for WalkHistoryEntriesFunc
+    nsTArray<EntriesAndBrowsingContextData>* entriesToUpdate;
   };
 
   nsSHistory(mozilla::dom::BrowsingContext* aRootBC, const nsID& aDocShellID);
@@ -83,11 +88,15 @@
   static already_AddRefed<nsISHEntry> GetRootSHEntry(nsISHEntry* aEntry);
 
   // Callback prototype for WalkHistoryEntries.
-  // aEntry is the child history entry, aShell is its corresponding docshell,
-  // aChildIndex is the child's index in its parent entry, and aData is
-  // the opaque pointer passed to WalkHistoryEntries.
+  // `aEntry` is the child history entry, `aBC` is its corresponding browsing
+  // context, `aChildIndex` is the child's index in its parent entry, and
+  // `aData` is the opaque pointer passed to WalkHistoryEntries. Both structs
+  // that are passed as `aData` to this function have a field
+  // `aEntriesToUpdate`, which is an array of entries we need to update in
+  // docshell, if the 'SH in parent' pref is on (which implies that this method
+  // is executed in the parent)
   typedef nsresult (*WalkHistoryEntriesFunc)(nsISHEntry* aEntry,
-                                             nsDocShell* aShell,
+                                             mozilla::dom::BrowsingContext* aBC,
                                              int32_t aChildIndex, void* aData);
 
   // Clone a session history tree for subframe navigation.
@@ -98,26 +107,45 @@
   // have that pointer updated to point to the cloned history entry.
   // If aCloneChildren is true then the children of the entry with id
   // |aCloneID| will be cloned into |aReplaceEntry|.
-  static nsresult CloneAndReplace(nsISHEntry* aSrcEntry, nsDocShell* aSrcShell,
-                                  uint32_t aCloneID, nsISHEntry* aReplaceEntry,
-                                  bool aCloneChildren, nsISHEntry** aDestEntry);
+  static nsresult CloneAndReplace(
+      nsISHEntry* aSrcEntry, mozilla::dom::BrowsingContext* aOwnerBC,
+      uint32_t aCloneID, nsISHEntry* aReplaceEntry, bool aCloneChildren,
+      nsISHEntry** aDestEntry, uint64_t aOtherPid,
+      nsTArray<EntriesAndBrowsingContextData>* aEntriesToUpdate);
 
   // Child-walking callback for CloneAndReplace
-  static nsresult CloneAndReplaceChild(nsISHEntry* aEntry, nsDocShell* aShell,
+  static nsresult CloneAndReplaceChild(nsISHEntry* aEntry,
+                                       mozilla::dom::BrowsingContext* aOwnerBC,
                                        int32_t aChildIndex, void* aData);
 
   // Child-walking callback for SetHistoryEntry
-  static nsresult SetChildHistoryEntry(nsISHEntry* aEntry, nsDocShell* aShell,
+  static nsresult SetChildHistoryEntry(nsISHEntry* aEntry,
+                                       mozilla::dom::BrowsingContext* aBC,
                                        int32_t aEntryIndex, void* aData);
 
-  // For each child of aRootEntry, find the corresponding docshell which is
-  // a child of aRootShell, and call aCallback. The opaque pointer aData
+  // For each child of aRootEntry, find the corresponding shell which is
+  // a child of aBC, and call aCallback. The opaque pointer aData
   // is passed to the callback.
   static nsresult WalkHistoryEntries(nsISHEntry* aRootEntry,
-                                     nsDocShell* aRootShell,
+                                     mozilla::dom::BrowsingContext* aBC,
                                      WalkHistoryEntriesFunc aCallback,
                                      void* aData);
 
+  nsresult AddToRootSessionHistory(
+      bool aCloneChildren, nsISHEntry* aOSHE,
+      mozilla::dom::BrowsingContext* aBC, nsISHEntry* aEntry,
+      uint32_t aLoadType, bool aShouldPersist, uint64_t aOtherPid,
+      Maybe<int32_t>* aPreviousEntryIndex, Maybe<int32_t>* aLoadedEntryIndex,
+      nsTArray<EntriesAndBrowsingContextData>* aEntriesToUpdate,
+      int32_t* aEntriesPurged);
+
+  nsresult AddChildSHEntryHelper(
+      nsISHEntry* aCloneRef, nsISHEntry* aNewEntry,
+      mozilla::dom::BrowsingContext* aBC, bool aCloneChildren,
+      uint64_t aOtherPid,
+      nsTArray<EntriesAndBrowsingContextData>* aEntriesToUpdate,
+      int32_t* aEntriesPurged, nsISHEntry** aNextEntry);
+
   nsTArray<nsCOMPtr<nsISHEntry>>& Entries() { return mEntries; }
 
   nsresult AddEntry(nsISHEntry* aSHEntry, bool aPersist,
@@ -198,6 +226,21 @@
   // otherwise comparison is done to aIndex - 1.
   bool RemoveDuplicate(int32_t aIndex, bool aKeepNext);
 
+  // We need to update entries in docshell and browsing context.
+  // If our docshell is located in parent or 'SH in parent' pref is off we can
+  // update it directly, Otherwise, we have two choices. If the browsing context
+  // that owns the docshell is in the same process as the process who called us
+  // over IPC, then we save entries that need to be updated in a list, and once
+  // we have returned from the IPC call, we update the docshell in the child
+  // process. Otherwise, if the browsing context is in a different process, we
+  // do a nested IPC call to that process to update the docshell in that
+  // process.
+  static void HandleEntriesToSwapInDocShell(
+      mozilla::dom::BrowsingContext* aBC, nsISHEntry* aOldEntry,
+      nsISHEntry* aNewEntry,
+      nsTArray<EntriesAndBrowsingContextData>* aEntriesToUpdate,
+      uint64_t aOtherPid);
+
  protected:
   // Length of mEntries.
   int32_t Length() { return int32_t(mEntries.Length()); }