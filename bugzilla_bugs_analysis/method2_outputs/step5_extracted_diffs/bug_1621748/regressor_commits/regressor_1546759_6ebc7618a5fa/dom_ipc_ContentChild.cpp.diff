# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/ContentChild.cpp
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp	Tue Mar 10 11:39:06 2020 +0000
+++ b/dom/ipc/ContentChild.cpp	Tue Mar 10 14:28:22 2020 +0000
@@ -3433,19 +3433,13 @@
   return true;
 }
 
-PSHEntryChild* ContentChild::AllocPSHEntryChild(
-    PSHistoryChild* aSHistory, const PSHEntryOrSharedID& aEntryOrSharedID) {
+PSHEntryChild* ContentChild::AllocPSHEntryChild(PSHistoryChild* aSHistory,
+                                                uint64_t aSharedID) {
   // We take a strong reference for the IPC layer. The Release implementation
   // for SHEntryChild will ask the IPC layer to release it (through
   // DeallocPSHEntryChild) if that is the only remaining reference.
   RefPtr<SHEntryChild> child;
-  if (aEntryOrSharedID.type() == PSHEntryOrSharedID::Tuint64_t) {
-    child = new SHEntryChild(static_cast<SHistoryChild*>(aSHistory),
-                             aEntryOrSharedID.get_uint64_t());
-  } else {
-    child = new SHEntryChild(
-        static_cast<const SHEntryChild*>(aEntryOrSharedID.get_PSHEntryChild()));
-  }
+  child = new SHEntryChild(static_cast<SHistoryChild*>(aSHistory), aSharedID);
   return child.forget().take();
 }
 
@@ -3764,6 +3758,19 @@
   return IPC_OK();
 }
 
+mozilla::ipc::IPCResult ContentChild::RecvUpdateSHEntriesInDocShell(
+    CrossProcessSHEntry* aOldEntry, CrossProcessSHEntry* aNewEntry,
+    const MaybeDiscarded<BrowsingContext>& aContext) {
+  MOZ_ASSERT(!aContext.IsNull(), "Browsing context cannot be null");
+  nsDocShell* docshell =
+      static_cast<nsDocShell*>(aContext.GetMaybeDiscarded()->GetDocShell());
+  if (docshell) {
+    docshell->SwapHistoryEntries(aOldEntry->ToSHEntryChild(),
+                                 aNewEntry->ToSHEntryChild());
+  }
+  return IPC_OK();
+}
+
 already_AddRefed<nsIEventTarget> ContentChild::GetSpecificMessageEventTarget(
     const Message& aMsg) {
   switch (aMsg.type()) {