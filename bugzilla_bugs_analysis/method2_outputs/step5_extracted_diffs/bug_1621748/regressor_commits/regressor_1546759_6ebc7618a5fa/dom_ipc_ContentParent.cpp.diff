# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/ContentParent.cpp
# Commit: 6ebc7618a5fa
# Full Hash: 6ebc7618a5fadb59585a4d8b9f17eb65e5654cc6
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-03-10 21:44:54
# Regressor Bug: 1546759
# File Overlap Count: 2
# Description:
#   Bug 1546759 - Change nsSHistory::WalkHistoryEntries to walk browsing context tree instead of doc shell tree, r=peterv,nika
#   
#   WalkHistoryEntries function gets called by nsSHistory::CloneAndReplaceChild
#   and nsSHistory::SetChildHistoryEntry recursively, so those have to be moved
#   into the parent process. This eliminates many sync IPC calls.
# ==============================================================================

diff -r ed75364b23c3 -r 6ebc7618a5fa dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp	Tue Mar 10 11:39:06 2020 +0000
+++ b/dom/ipc/ContentParent.cpp	Tue Mar 10 14:28:22 2020 +0000
@@ -5732,9 +5732,9 @@
   return mozilla::dom::DeallocPSessionStorageObserverParent(aActor);
 }
 
-PSHEntryParent* ContentParent::AllocPSHEntryParent(
-    PSHistoryParent* aSHistory, const PSHEntryOrSharedID& aEntryOrSharedID) {
-  return SHistoryParent::CreateEntry(this, aSHistory, aEntryOrSharedID);
+PSHEntryParent* ContentParent::AllocPSHEntryParent(PSHistoryParent* aSHistory,
+                                                   uint64_t aSharedID) {
+  return SHistoryParent::CreateEntry(this, aSHistory, aSharedID);
 }
 
 void ContentParent::DeallocPSHEntryParent(PSHEntryParent* aEntry) {
@@ -5743,12 +5743,8 @@
 
 PSHistoryParent* ContentParent::AllocPSHistoryParent(
     const MaybeDiscarded<BrowsingContext>& aContext) {
-  if (NS_WARN_IF(aContext.IsNullOrDiscarded())) {
-    // FIXME: What should we do here?
-    return nullptr;
-  }
-
-  return new SHistoryParent(aContext.get_canonical());
+  MOZ_ASSERT(!aContext.IsNull());
+  return new SHistoryParent(aContext.GetMaybeDiscarded()->Canonical());
 }
 
 void ContentParent::DeallocPSHistoryParent(PSHistoryParent* aActor) {
@@ -5866,6 +5862,35 @@
   }
   return IPC_OK();
 }
+mozilla::ipc::IPCResult ContentParent::RecvUpdateSHEntriesInBC(
+    PSHEntryParent* aNewLSHE, PSHEntryParent* aNewOSHE,
+    const MaybeDiscarded<BrowsingContext>& aMaybeContext) {
+  if (aMaybeContext.IsNull()) {
+    MOZ_LOG(BrowsingContext::GetLog(), LogLevel::Debug,
+            ("ParentIPC: Trying to update a browsing context that does not "
+             "exist or has been discarded"));
+    return IPC_OK();
+  }
+  // if aContext has been discarded we can still update the entries
+  auto aContext = aMaybeContext.GetMaybeDiscarded()->Canonical();
+  MOZ_ASSERT(aContext);
+  if (!aContext->IsOwnedByProcess(ChildID())) {
+    // We are trying to update a child BrowsingContext in another child
+    // process. This is illegal since the owner of the BrowsingContext
+    // is the proccess with the in-process docshell, which is tracked
+    // by OwnerProcessId.
+    MOZ_DIAGNOSTIC_ASSERT(
+        false,
+        "Trying to update a child BrowsingContext in another child process");
+    return IPC_OK();
+  }
+  SHEntryParent* newLSHEparent = static_cast<SHEntryParent*>(aNewLSHE);
+  SHEntryParent* newOSHEparent = static_cast<SHEntryParent*>(aNewOSHE);
+  nsISHEntry* lshe = newLSHEparent ? newLSHEparent->mEntry.get() : nullptr;
+  nsISHEntry* oshe = newOSHEparent ? newOSHEparent->mEntry.get() : nullptr;
+  aContext->UpdateSHEntries(lshe, oshe);
+  return IPC_OK();
+}
 
 mozilla::ipc::IPCResult ContentParent::RecvNotifyMediaSessionUpdated(
     const MaybeDiscarded<BrowsingContext>& aContext, bool aIsCreated) {