# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/layers/wr/DisplayItemCache.h
# Commit: f215196f1d1c
# Full Hash: f215196f1d1c8c6b42214b35fee351ef021bd704
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2020-03-28 09:32:56
# Description:
#   Bug 1624125 - Track display list changes in DisplayItemCache r=jrmuizel
#   
#   This is needed because display lists and DisplayItemCache have different lifetimes. For example, display lists can outlive WebRenderLayerManager when device reset occurs.
#   
#   A slightly nicer way of fixing this would be to couple DisplayItemCache with nsDisplayList or nsDisplayListBuilder. This is would currently require a lot of refactoring to look nice, because the painting code still supports non-retained display lists and non-WR code paths.
# ==============================================================================

diff -r 13a7265ed731 -r f215196f1d1c gfx/layers/wr/DisplayItemCache.h
--- a/gfx/layers/wr/DisplayItemCache.h	Fri Mar 27 16:49:40 2020 +0000
+++ b/gfx/layers/wr/DisplayItemCache.h	Fri Mar 27 16:49:37 2020 +0000
@@ -8,9 +8,10 @@
 #define GFX_DISPLAY_ITEM_CACHE_H
 
 #include "mozilla/webrender/WebRenderAPI.h"
-#include "mozilla/Maybe.h"
 #include "nsTArray.h"
 
+class nsDisplayList;
+class nsDisplayListBuilder;
 class nsPaintedDisplayItem;
 
 namespace mozilla {
@@ -65,6 +66,28 @@
   DisplayItemCache();
 
   /**
+   * Sets the initial and max cache size to given |aInitialSize| and |aMaxSize|.
+   */
+  void SetCapacity(const size_t aInitialSize, const size_t aMaximumSize);
+
+  /**
+   * Sets the display list used by the cache.
+   */
+  void SetDisplayList(nsDisplayListBuilder* aBuilder, nsDisplayList* aList);
+
+  /**
+   * Sets the pipeline id used by the cache.
+   */
+  void SetPipelineId(const wr::PipelineId& aPipelineId);
+
+  /**
+   * Enables caching immediately if the cache is valid, and display list is set.
+   */
+  void SkipWaitingForPartialDisplayList() {
+    mCaching = mDisplayList && !mInvalid;
+  }
+
+  /**
    * Returns true if display item caching is enabled, otherwise false.
    */
   bool IsEnabled() const { return mMaximumSize > 0; }
@@ -82,16 +105,6 @@
   }
 
   /**
-   * Updates the cache state based on the given display list build information
-   * and pipeline id.
-   *
-   * This is necessary because Gecko display items can only be reused for the
-   * partial display list builds following a full display list build.
-   */
-  void UpdateState(const bool aPartialDisplayListBuildFailed,
-                   const wr::PipelineId& aPipelineId);
-
-  /**
    * Returns the current cache size.
    */
   size_t CurrentSize() const { return mSlots.Length(); }
@@ -131,29 +144,23 @@
 
   void ClearCache();
   void FreeUnusedSlots();
+  Maybe<uint16_t> GetNextFreeSlot();
   bool GrowIfPossible();
-  Maybe<uint16_t> GetNextFreeSlot();
-
-  /**
-   * Sets the initial and max cache size to given |aInitialSize| and |aMaxSize|.
-   */
-  void SetCapacity(const size_t aInitialSize, const size_t aMaximumSize);
+  void UpdateState();
 
-  /**
-   * Returns true if the given |aPipelineId| is different from the previous one,
-   * otherwise returns false.
-   */
-  bool UpdatePipelineId(const wr::PipelineId& aPipelineId) {
-    const bool isSame = mPreviousPipelineId.refOr(aPipelineId) == aPipelineId;
-    mPreviousPipelineId = Some(aPipelineId);
-    return !isSame;
-  }
+  // The lifetime of display lists exceed the lifetime of DisplayItemCache.
+  // This pointer stores the address of the display list that is using this
+  // cache, and it is only used for pointer comparisons.
+  nsDisplayList* mDisplayList;
 
   size_t mMaximumSize;
   nsTArray<Slot> mSlots;
   nsTArray<uint16_t> mFreeSlots;
-  Maybe<wr::PipelineId> mPreviousPipelineId;
-  size_t mConsecutivePartialDisplayLists;
+
+  wr::PipelineId mPipelineId;
+  bool mCaching;
+  bool mInvalid;
+
   CacheStats mCacheStats;
 };
 