# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender_api/src/display_item_cache.rs
# Commit: cc263e909c61
# Full Hash: cc263e909c61d2d9c7d7cc1ccb8d24c8d09bf5b7
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2020-03-19 03:53:34
# Regressor Bug: 1614655
# File Overlap Count: 2
# Description:
#   Bug 1614655 - Part 2: Allow 1:n mapping of Gecko - WR display items r=jrmuizel
#   
#   This patch changes the underlying storage for WR display items in DisplayItemCache
#   from Vec<Option<CachedDisplayItem> to Vec<Vec<CachedDisplayItem>>.
#   This allows storing multiple WebRender display items for one Gecko display item.
# ==============================================================================

diff -r 10897d6106a8 -r cc263e909c61 gfx/wr/webrender_api/src/display_item_cache.rs
--- a/gfx/wr/webrender_api/src/display_item_cache.rs	Wed Mar 18 17:08:49 2020 +0000
+++ b/gfx/wr/webrender_api/src/display_item_cache.rs	Wed Mar 18 17:09:51 2020 +0000
@@ -4,8 +4,6 @@
 
 use crate::display_item::*;
 use crate::display_list::*;
-#[cfg(debug_assertions)]
-use std::collections::HashSet;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CachedDisplayItem {
@@ -14,7 +12,7 @@
 }
 
 impl CachedDisplayItem {
-    pub fn item(&self) -> &DisplayItem {
+    pub fn display_item(&self) -> &DisplayItem {
         &self.item
     }
 
@@ -40,92 +38,71 @@
     }
 }
 
-fn key_from_item(item: &DisplayItem) -> ItemKey {
-    let key = match item {
-        DisplayItem::Rectangle(ref info) => info.common.item_key,
-        DisplayItem::ClearRectangle(ref info) => info.common.item_key,
-        DisplayItem::HitTest(ref info) => info.common.item_key,
-        DisplayItem::Text(ref info) => info.common.item_key,
-        DisplayItem::Image(ref info) => info.common.item_key,
-        _ => unimplemented!("Unexpected item: {:?}", item)
-    };
-
-    key.expect("Cached item without a key")
+#[derive(Clone, Deserialize, Serialize)]
+struct CacheEntry {
+    items: Vec<CachedDisplayItem>,
+    occupied: bool,
 }
 
 #[derive(Clone, Deserialize, Serialize)]
 pub struct DisplayItemCache {
-    items: Vec<Option<CachedDisplayItem>>,
-
-    #[cfg(debug_assertions)]
-    keys: HashSet<ItemKey>,
+    entries: Vec<CacheEntry>,
 }
 
 impl DisplayItemCache {
-    fn grow_if_needed(
-        &mut self,
-        capacity: usize
-    ) {
-        if capacity > self.items.len() {
-            self.items.resize_with(capacity, || None::<CachedDisplayItem>);
-            // println!("Current cache size: {:?} elements, {:?} bytes",
-            //     capacity, std::mem::size_of::<CachedDisplayItem>() * capacity);
+    fn add_item(&mut self, key: ItemKey, item: CachedDisplayItem) {
+        let mut entry = &mut self.entries[key as usize];
+        entry.items.push(item);
+        entry.occupied = true;
+    }
+
+    fn clear_entry(&mut self, key: ItemKey) {
+        let mut entry = &mut self.entries[key as usize];
+        entry.items.clear();
+        entry.occupied = false;
+    }
+
+    fn grow_if_needed(&mut self, capacity: usize) {
+        if capacity > self.entries.len() {
+            self.entries.resize_with(capacity, || CacheEntry {
+                items: Vec::new(),
+                occupied: false,
+            });
         }
     }
 
-    fn add_item(
-        &mut self,
-        item: CachedDisplayItem,
-        key: ItemKey,
-    ) {
-        self.items[key as usize] = Some(item);
-    }
-
-    pub fn get_item(
-        &self,
-        key: ItemKey
-    ) -> Option<&CachedDisplayItem> {
-        self.items[key as usize].as_ref()
+    pub fn get_items(&self, key: ItemKey) -> &[CachedDisplayItem] {
+        let entry = &self.entries[key as usize];
+        debug_assert!(entry.occupied);
+        entry.items.as_slice()
     }
 
     pub fn new() -> Self {
         Self {
-            items: Vec::new(),
-
-            #[cfg(debug_assertions)]
-            /// Used to check that there is only one item per key.
-            keys: HashSet::new(),
+            entries: Vec::new(),
         }
     }
 
-    pub fn update(
-        &mut self,
-        display_list: &BuiltDisplayList
-    ) {
+    pub fn update(&mut self, display_list: &BuiltDisplayList) {
         self.grow_if_needed(display_list.cache_size());
 
         let mut iter = display_list.extra_data_iter();
-
-        #[cfg(debug_assertions)]
-        {
-            self.keys.clear();
-        }
-
+        let mut current_key: Option<ItemKey> = None;
         loop {
             let item = match iter.next() {
                 Some(item) => item,
                 None => break,
             };
 
-            let item_key = key_from_item(item.item());
-            let cached_item = CachedDisplayItem::from(item);
-
-            #[cfg(debug_assertions)]
-            {
-                debug_assert!(self.keys.insert(item_key));
+            if let DisplayItem::RetainedItems(key) = item.item() {
+                current_key = Some(*key);
+                self.clear_entry(*key);
+                continue;
             }
 
-            self.add_item(cached_item, item_key);
+            let key = current_key.expect("Missing RetainedItems marker");
+            let cached_item = CachedDisplayItem::from(item);
+            self.add_item(key, cached_item);
         }
     }
 }