# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/renderer.rs
# Commit: 971767c6ed2b
# Full Hash: 971767c6ed2b2201e172105046ecc61942e03a7e
# Author: sotaro <sotaro.ikeda.g@gmail.com>
# Date: 2020-01-24 21:46:30
# Regressor Bug: 1602643
# File Overlap Count: 1
# Description:
#   Bug 1602643 - Disable WebRender compositor dinamically for async screenshot r=gw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D59658
# ==============================================================================

diff -r 436df7dc06c6 -r 971767c6ed2b gfx/wr/webrender/src/renderer.rs
--- a/gfx/wr/webrender/src/renderer.rs	Fri Jan 24 01:04:09 2020 +0000
+++ b/gfx/wr/webrender/src/renderer.rs	Thu Jan 23 23:52:05 2020 +0000
@@ -1896,6 +1896,8 @@
     /// The compositing config, affecting how WR composites into the final scene.
     compositor_config: CompositorConfig,
 
+    current_compositor_kind: CompositorKind,
+
     /// Maintains a set of allocated native composite surfaces. This allows any
     /// currently allocated surfaces to be cleaned up as soon as deinit() is
     /// called (the normal bookkeeping for native surfaces exists in the
@@ -2423,6 +2425,7 @@
             documents_seen: FastHashSet::default(),
             force_redraw: true,
             compositor_config: options.compositor_config,
+            current_compositor_kind: compositor_kind,
             allocated_native_surfaces: FastHashSet::default(),
             debug_overlay_state: DebugOverlayState::new(),
         };
@@ -2870,7 +2873,8 @@
             }
             DebugCommand::ClearCaches(_)
             | DebugCommand::SimulateLongSceneBuild(_)
-            | DebugCommand::SimulateLongLowPrioritySceneBuild(_) => {}
+            | DebugCommand::SimulateLongLowPrioritySceneBuild(_)
+            | DebugCommand::EnableNativeCompositor(_) => {}
             DebugCommand::InvalidateGpuCache => {
                 match self.gpu_cache_texture.bus {
                     GpuCacheBus::PixelBuffer { ref mut rows, .. } => {
@@ -2961,7 +2965,9 @@
         );
 
         // Update the debug overlay surface, if we are running in native compositor mode.
-        if let CompositorConfig::Native { ref mut compositor, .. } = self.compositor_config {
+        if let CompositorKind::Native { .. } = self.current_compositor_kind {
+            let compositor = self.compositor_config.compositor().unwrap();
+
             // If there is a current surface, destroy it if we don't need it for this frame, or if
             // the size has changed.
             if let Some(current_size) = self.debug_overlay_state.current_size {
@@ -2990,7 +2996,8 @@
     fn bind_debug_overlay(&mut self) {
         // Debug overlay setup are only required in native compositing mode
         if self.debug_overlay_state.is_enabled {
-            if let CompositorConfig::Native { ref mut compositor, .. } = self.compositor_config {
+            if let CompositorKind::Native { .. } = self.current_compositor_kind {
+                let compositor = self.compositor_config.compositor().unwrap();
                 let surface_size = self.debug_overlay_state.current_size.unwrap();
 
                 // Bind the native surface
@@ -3024,7 +3031,8 @@
     fn unbind_debug_overlay(&mut self) {
         // Debug overlay setup are only required in native compositing mode
         if self.debug_overlay_state.is_enabled {
-            if let CompositorConfig::Native { ref mut compositor, .. } = self.compositor_config {
+            if let CompositorKind::Native { .. } = self.current_compositor_kind {
+                let compositor = self.compositor_config.compositor().unwrap();
                 // Unbind the draw target and add it to the visual tree to be composited
                 compositor.unbind();
 
@@ -3055,6 +3063,35 @@
             return Ok(results);
         }
 
+        let compositor_kind = self.active_documents[0].1.frame.composite_state.compositor_kind;
+        // CompositorKind is updated
+        if self.current_compositor_kind != compositor_kind {
+            let enable = match (self.current_compositor_kind, compositor_kind) {
+                (CompositorKind::Native { .. }, CompositorKind::Draw { .. }) => {
+                    if self.debug_overlay_state.current_size.is_some() {
+                        self.compositor_config
+                            .compositor()
+                            .unwrap()
+                            .destroy_surface(NativeSurfaceId::DEBUG_OVERLAY);
+                        self.debug_overlay_state.current_size = None;
+                    }
+                    false
+                }
+                (CompositorKind::Draw { .. }, CompositorKind::Native { .. }) => {
+                    true
+                }
+                (_, _) => {
+                    unreachable!();
+                }
+            };
+
+            self.compositor_config
+                .compositor()
+                .unwrap()
+                .enable_native_compositor(enable);
+            self.current_compositor_kind = compositor_kind;
+        }
+
         let mut frame_profiles = Vec::new();
         let mut profile_timers = RendererProfileTimers::new();
 
@@ -3103,7 +3140,8 @@
         // Inform the client that we are starting a composition transaction if native
         // compositing is enabled. This needs to be done early in the frame, so that
         // we can create debug overlays after drawing the main surfaces.
-        if let CompositorConfig::Native { ref mut compositor, .. } = self.compositor_config {
+        if let CompositorKind::Native { .. } = self.current_compositor_kind {
+            let compositor = self.compositor_config.compositor().unwrap();
             compositor.begin_frame();
         }
 
@@ -3120,6 +3158,8 @@
 
             let last_document_index = active_documents.len() - 1;
             for (doc_index, (document_id, RenderedDocument { ref mut frame, .. })) in active_documents.iter_mut().enumerate() {
+                assert!(self.current_compositor_kind == frame.composite_state.compositor_kind);
+
                 if self.shared_texture_cache_cleared {
                     assert!(self.documents_seen.contains(&document_id),
                             "Cleared texture cache without sending new document frame.");
@@ -3280,9 +3320,9 @@
                 let scale = if small_screen { 1.6 } else { 1.0 };
                 // TODO(gw): Tidy this up so that compositor config integrates better
                 //           with the (non-compositor) surface y-flip options.
-                let surface_origin_is_top_left = match self.compositor_config {
-                    CompositorConfig::Native { .. } => true,
-                    CompositorConfig::Draw { .. } => self.device.surface_origin_is_top_left(),
+                let surface_origin_is_top_left = match self.current_compositor_kind {
+                    CompositorKind::Native { .. } => true,
+                    CompositorKind::Draw { .. } => self.device.surface_origin_is_top_left(),
                 };
                 debug_renderer.render(
                     &mut self.device,
@@ -3311,7 +3351,8 @@
         // Inform the client that we are finished this composition transaction if native
         // compositing is enabled. This must be called after any debug / profiling compositor
         // surfaces have been drawn and added to the visual tree.
-        if let CompositorConfig::Native { ref mut compositor, .. } = self.compositor_config {
+        if let CompositorKind::Native { .. } = self.current_compositor_kind {
+            let compositor = self.compositor_config.compositor().unwrap();
             compositor.end_frame();
         }
 
@@ -5214,11 +5255,12 @@
                         if frame.composite_state.picture_caching_is_enabled {
                             // If we have a native OS compositor, then make use of that interface
                             // to specify how to composite each of the picture cache surfaces.
-                            match self.compositor_config {
-                                CompositorConfig::Native { ref mut compositor, .. } => {
+                            match self.current_compositor_kind {
+                                CompositorKind::Native { .. } => {
+                                    let compositor = self.compositor_config.compositor().unwrap();
                                     frame.composite_state.composite_native(&mut **compositor);
                                 }
-                                CompositorConfig::Draw { max_partial_present_rects, .. } => {
+                                CompositorKind::Draw { max_partial_present_rects, .. } => {
                                     self.composite_simple(
                                         &frame.composite_state,
                                         clear_framebuffer,
@@ -5297,11 +5339,12 @@
                                     )
                                 }
                                 ResolvedSurfaceTexture::Native { id, size } => {
-                                    let surface_info = match self.compositor_config {
-                                        CompositorConfig::Native { ref mut compositor, .. } => {
+                                    let surface_info = match self.current_compositor_kind {
+                                        CompositorKind::Native { .. } => {
+                                            let compositor = self.compositor_config.compositor().unwrap();
                                             compositor.bind(id, picture_target.dirty_rect)
                                         }
-                                        CompositorConfig::Draw { .. } => {
+                                        CompositorKind::Draw { .. } => {
                                             unreachable!();
                                         }
                                     };
@@ -5334,11 +5377,12 @@
 
                             // Native OS surfaces must be unbound at the end of drawing to them
                             if let ResolvedSurfaceTexture::Native { .. } = picture_target.surface {
-                                match self.compositor_config {
-                                    CompositorConfig::Native { ref mut compositor, .. } => {
+                                match self.current_compositor_kind {
+                                    CompositorKind::Native { .. } => {
+                                        let compositor = self.compositor_config.compositor().unwrap();
                                         compositor.unbind();
                                     }
-                                    CompositorConfig::Draw { .. } => {
+                                    CompositorKind::Draw { .. } => {
                                         unreachable!();
                                     }
                                 }