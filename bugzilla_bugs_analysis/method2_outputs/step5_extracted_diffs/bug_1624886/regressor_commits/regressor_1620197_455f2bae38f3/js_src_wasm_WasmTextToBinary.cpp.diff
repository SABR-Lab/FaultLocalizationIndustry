# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmTextToBinary.cpp
# Commit: 455f2bae38f3
# Full Hash: 455f2bae38f3dec9d30a1aa9025de7b7199f39f7
# Author: Andy Wingo <wingo@igalia.com>
# Date: 2020-03-09 21:52:54
# Regressor Bug: 1620197
# File Overlap Count: 1
# Description:
#   Bug 1620197 - Enable multiple results from WebAssembly functions r=lth
#   
#   This patch enables multi-value calls and returns, adding some tests, and
#   conditionally disabling a couple expect-fail reftests that now pass.
#   
# ==============================================================================

diff -r 6cafdb82131f -r 455f2bae38f3 js/src/wasm/WasmTextToBinary.cpp
--- a/js/src/wasm/WasmTextToBinary.cpp	Mon Mar 09 11:54:27 2020 +0000
+++ b/js/src/wasm/WasmTextToBinary.cpp	Mon Mar 09 11:30:43 2020 +0000
@@ -2464,15 +2464,11 @@
   return true;
 }
 
-// For ParseAnonFuncType: allow more than one results.
-enum class MultiResult { False, True };
-
 // This guarantees that the ref has an index when we return and won't need to be
 // resolved later.  If `withLookahead` then whatever comes after the type does
 // not cause an error and is not consumed, and any number of results are
 // allowed.
 static bool ParseAnonFuncType(WasmParseContext& c, AstRef* ref,
-                              MultiResult multiResult,
                               WithLookahead withLookahead) {
   MOZ_ASSERT(ref->isInvalid());
 
@@ -2480,10 +2476,6 @@
   if (!ParseFuncSig(c, &funcType, withLookahead)) {
     return false;
   }
-  if (multiResult == MultiResult::False && funcType.results().length() > 1) {
-    c.ts.generateError(c.ts.peek(), "too many results", c.error);
-    return false;
-  }
   uint32_t funcTypeIndex;
   if (!c.module->declare(std::move(funcType), &funcTypeIndex)) {
     return false;
@@ -2525,7 +2517,7 @@
   }
 
   AstRef t;
-  if (!ParseAnonFuncType(c, &t, MultiResult::True, WithLookahead::True)) {
+  if (!ParseAnonFuncType(c, &t, WithLookahead::True)) {
     return false;
   }
   const AstFuncType& ft = c.module->types()[t.index()]->asFuncType();
@@ -4202,7 +4194,7 @@
     return false;
   }
   if (ref->isInvalid()) {
-    if (!ParseAnonFuncType(c, ref, MultiResult::False, WithLookahead::False)) {
+    if (!ParseAnonFuncType(c, ref, WithLookahead::False)) {
       return false;
     }
   }
@@ -4289,10 +4281,6 @@
         if (!ParseValueTypeList(c, &results)) {
           return false;
         }
-        if (results.length() > 1) {
-          c.ts.generateError(token, "too many results", c.error);
-          return false;
-        }
         break;
       default:
         c.ts.unget(token);
@@ -4382,10 +4370,6 @@
     if (!ParseFuncSig(c, &funcType, WithLookahead::False)) {
       return nullptr;
     }
-    if (funcType.results().length() > 1) {
-      c.ts.generateError(c.ts.peek(), "too many results", c.error);
-      return nullptr;
-    }
     type = new (c.lifo) AstFuncType(name, std::move(funcType));
   } else if (c.ts.getIf(WasmToken::Struct)) {
     AstStructType st(c.lifo);
@@ -4801,8 +4785,7 @@
   }
 
   if (funcTypeRef.isInvalid()) {
-    if (!ParseAnonFuncType(c, &funcTypeRef, MultiResult::False,
-                           WithLookahead::False)) {
+    if (!ParseAnonFuncType(c, &funcTypeRef, WithLookahead::False)) {
       return nullptr;
     }
   }