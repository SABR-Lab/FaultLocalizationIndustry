# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmStubs.cpp
# Commit: 920da79f43fc
# Full Hash: 920da79f43fcf5802ebd5eb2bf610a18e821dacc
# Author: Andy Wingo <wingo@igalia.com>
# Date: 2020-03-19 03:53:34
# Regressor Bug: 1620197
# File Overlap Count: 1
# Description:
#   Bug 1620197 - Enable multiple results from WebAssembly functions r=lth
#   
#   This patch enables multi-value calls and returns, adding some tests, and
#   conditionally disabling a couple expect-fail reftests that now pass.
#   
# ==============================================================================

diff -r 98d7f9e4839f -r 920da79f43fc js/src/wasm/WasmStubs.cpp
--- a/js/src/wasm/WasmStubs.cpp	Wed Mar 18 17:12:14 2020 +0000
+++ b/js/src/wasm/WasmStubs.cpp	Wed Mar 18 16:36:45 2020 +0000
@@ -641,6 +641,12 @@
 #  endif
 #endif
 
+  if (fe.funcType().temporarilyUnsupportedResultCountForEntry()) {
+    // Unreachable as the Instance::callExport doesn't let us get here.
+    masm.breakpoint();
+    return FinishOffsets(masm, offsets);
+  }
+
   // Save all caller non-volatile registers before we clobber them here and in
   // the wasm callee (which does not preserve non-volatile registers).
   masm.setFramePushed(0);
@@ -1566,7 +1572,8 @@
     GenPrintIsize(DebugChannel::Import, masm, scratch);
     masm.store64(scratch64, dst);
 #endif
-  } else if (type == MIRType::RefOrNull || type == MIRType::Pointer) {
+  } else if (type == MIRType::RefOrNull || type == MIRType::Pointer ||
+             type == MIRType::StackResults) {
     masm.loadPtr(src, scratch);
     GenPrintPtr(DebugChannel::Import, masm, scratch);
     masm.storePtr(scratch, dst);
@@ -1606,13 +1613,11 @@
 
   ArgTypeVector args(funcType);
   for (ABIArgIter i(args); !i.done(); i++) {
-    if (args.isSyntheticStackResultPointerArg(i.index())) {
-      MOZ_CRASH("Exit to function returning multiple values unimplemented");
-    }
-
     Address dst(masm.getStackPointer(), argOffset + i.index() * sizeof(Value));
 
     MIRType type = i.mirType();
+    MOZ_ASSERT(args.isSyntheticStackResultPointerArg(i.index()) ==
+               (type == MIRType::StackResults));
     switch (i->kind()) {
       case ABIArg::GPR:
         if (type == MIRType::Int32) {
@@ -1648,6 +1653,10 @@
             GenPrintPtr(DebugChannel::Import, masm, i->gpr());
             masm.storePtr(i->gpr(), dst);
           }
+        } else if (type == MIRType::StackResults) {
+          MOZ_ASSERT(!toValue, "Multi-result exit to JIT unimplemented");
+          GenPrintPtr(DebugChannel::Import, masm, i->gpr());
+          masm.storePtr(i->gpr(), dst);
         } else {
           MOZ_CRASH("FillArgumentArrayForExit, ABIArg::GPR: unexpected type");
         }
@@ -1878,8 +1887,9 @@
   // padding between argv and retaddr ensures that sp is aligned.
   unsigned argOffset =
       AlignBytes(StackArgBytes(invokeArgTypes), sizeof(double));
-  unsigned argBytes =
-      std::max<size_t>(1, fi.funcType().args().length()) * sizeof(Value);
+  // The abiArgCount includes a stack result pointer argument if needed.
+  unsigned abiArgCount = ArgTypeVector(fi.funcType()).length();
+  unsigned argBytes = std::max<size_t>(1, abiArgCount * sizeof(Value));
   unsigned framePushed =
       StackDecrementForCall(ABIStackAlignment,
                             sizeof(Frame),  // pushed by prologue
@@ -1946,16 +1956,22 @@
 
   // Make the call, test whether it succeeded, and extract the return value.
   AssertStackAlignment(masm, ABIStackAlignment);
-  const ValTypeVector& results = fi.funcType().results();
-  if (results.length() == 0) {
+  ResultType resultType = ResultType::Vector(fi.funcType().results());
+  ValType registerResultType;
+  for (ABIResultIter iter(resultType); !iter.done(); iter.next()) {
+    if (iter.cur().inRegister()) {
+      MOZ_ASSERT(!registerResultType.isValid());
+      registerResultType = iter.cur().type();
+    }
+  }
+  if (!registerResultType.isValid()) {
     masm.call(SymbolicAddress::CallImport_Void);
     masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, throwLabel);
     GenPrintf(DebugChannel::Import, masm, "wasm-import[%u]; returns ",
               funcImportIndex);
     GenPrintf(DebugChannel::Import, masm, "void");
   } else {
-    MOZ_ASSERT(results.length() == 1, "multi-value return unimplemented");
-    switch (results[0].kind()) {
+    switch (registerResultType.kind()) {
       case ValType::I32:
         masm.call(SymbolicAddress::CallImport_I32);
         masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, throwLabel);
@@ -1990,7 +2006,7 @@
         GenPrintF64(DebugChannel::Import, masm, ReturnDoubleReg);
         break;
       case ValType::Ref:
-        switch (results[0].refTypeKind()) {
+        switch (registerResultType.refTypeKind()) {
           case RefType::Func:
             masm.call(SymbolicAddress::CallImport_FuncRef);
             masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg,
@@ -2693,6 +2709,11 @@
     return true;
   }
 
+  // Returning multiple values to JS not yet implemented (see bug 1595031).
+  if (fe.funcType().temporarilyUnsupportedResultCountForEntry()) {
+    return true;
+  }
+
   if (!GenerateJitEntry(masm, funcExportIndex, fe, callee, bigIntEnabled,
                         &offsets)) {
     return false;
@@ -2737,6 +2758,12 @@
       continue;
     }
 
+    // Exit to JS returning multiple values not yet implemented (see bug
+    // 1595031).
+    if (fi.funcType().temporarilyUnsupportedResultCountForExit()) {
+      continue;
+    }
+
     JitExitOffsets jitOffsets;
     if (!GenerateImportJitExit(masm, fi, funcIndex, &throwLabel, &jitOffsets)) {
       return false;