# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/QuicSocketControl.cpp
# Commit: 48ce2b670f32
# Full Hash: 48ce2b670f32691b0537c13c165ec8459d74907c
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2019-09-25 09:36:42
# Regressor Bug: 1577643
# File Overlap Count: 1
# Description:
#   Bug 1577643 - Implement a security info class for the quic transport. r=keeler
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44073
# ==============================================================================

diff -r 2a39731bf265 -r 48ce2b670f32 netwerk/protocol/http/QuicSocketControl.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/protocol/http/QuicSocketControl.cpp	Tue Sep 24 20:56:39 2019 +0000
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "QuicSocketControl.h"
+#include "SharedCertVerifier.h"
+#include "nsNSSComponent.h"
+#include "nsWeakReference.h"
+#include "sslt.h"
+#include "ssl.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMPL_ISUPPORTS_INHERITED(QuicSocketControl, TransportSecurityInfo,
+                            nsISSLSocketControl, QuicSocketControl)
+
+QuicSocketControl::QuicSocketControl(uint32_t aProviderFlags)
+    : CommonSocketControl(aProviderFlags) {}
+
+void QuicSocketControl::SetCertVerificationResult(PRErrorCode errorCode) {
+  if (errorCode) {
+    mFailedVerification = true;
+    SetCanceled(errorCode);
+  }
+
+  if (OnSocketThread()) {
+    CallAuthenticated();
+  } else {
+    DebugOnly<nsresult> rv = gSocketTransportService->Dispatch(
+        NewRunnableMethod("QuicSocketControl::CallAuthenticated", this,
+                          &QuicSocketControl::CallAuthenticated),
+        NS_DISPATCH_NORMAL);
+  }
+}
+
+NS_IMETHODIMP
+QuicSocketControl::GetSSLVersionOffered(int16_t* aSSLVersionOffered) {
+  *aSSLVersionOffered = nsISSLSocketControl::TLS_VERSION_1_3;
+  return NS_OK;
+}
+
+void QuicSocketControl::CallAuthenticated() {
+  //  // Will be added when Http3 lands
+  /*  if (mHttp3Session) {
+    RefPtr<Http3Session> http3Session = do_QueryReferent(mHttp3Session);
+    http3Session->Authenticated(GetErrorCode());
+  }
+  mHttp3Session = nullptr;*/
+}
+
+// Will be added when Http3 lands
+// void QuicSocketControl::SetAuthenticationCallback(Http3Session
+// *aHttp3Session) {
+//  mHttp3Session = do_GetWeakReference(
+//      static_cast<nsISupportsWeakReference*>(aHttp3Session));
+//}
+
+void QuicSocketControl::HandshakeCompleted() {
+  psm::RememberCertErrorsTable::GetInstance().LookupCertErrorBits(this);
+
+  uint32_t state = nsIWebProgressListener::STATE_IS_SECURE;
+
+  bool distrustImminent;
+  nsresult srv =
+      IsCertificateDistrustImminent(mSucceededCertChain, distrustImminent);
+  if (NS_SUCCEEDED(srv) && distrustImminent) {
+    state |= nsIWebProgressListener::STATE_CERT_DISTRUST_IMMINENT;
+  }
+
+  // If we're here, the TLS handshake has succeeded. Thus if any of these
+  // booleans are true, the user has added an override for a certificate error.
+  if (mIsDomainMismatch || mIsUntrusted || mIsNotValidAtThisTime) {
+    state |= nsIWebProgressListener::STATE_CERT_USER_OVERRIDDEN;
+  }
+
+  SetSecurityState(state);
+  mHandshakeCompleted = true;
+}
+
+void QuicSocketControl::SetNegotiatedNPN(const nsACString& aValue) {
+  mNegotiatedNPN = aValue;
+  mNPNCompleted = true;
+}
+
+void QuicSocketControl::SetInfo(uint16_t aCipherSuite,
+                                         uint16_t aProtocolVersion,
+                                         uint16_t aKeaGroup,
+                                   uint16_t aSignatureScheme) {
+  SSLCipherSuiteInfo cipherInfo;
+  if (SSL_GetCipherSuiteInfo(aCipherSuite, &cipherInfo, sizeof cipherInfo) ==
+      SECSuccess) {
+    mHaveCipherSuiteAndProtocol = true;
+    mCipherSuite = aCipherSuite;
+    mProtocolVersion = aProtocolVersion & 0xFF;
+    mKeaGroup = getKeaGroupName(aKeaGroup);
+    mSignatureSchemeName = getSignatureName(aSignatureScheme);
+  }
+}
+
+}  // namespace net
+}  // namespace mozilla