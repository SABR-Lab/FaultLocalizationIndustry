# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/ImageLoader.cpp
# Commit: acb3f6f0a64e
# Full Hash: acb3f6f0a64e5e31daee85c5e991b4ed2a69d721
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-03-30 15:54:08
# Regressor Bug: 1625571
# File Overlap Count: 1
# Description:
#   Bug 1625571 - Invalidate canvas background in ImageLoader rather than nsDisplayBackgroundImage. r=tnikkel
#   
#   This is less error prone and also less code.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D68732
# ==============================================================================

diff -r 059be1f4b4ed -r acb3f6f0a64e layout/style/ImageLoader.cpp
--- a/layout/style/ImageLoader.cpp	Mon Mar 30 11:35:20 2020 +0300
+++ b/layout/style/ImageLoader.cpp	Mon Mar 30 08:35:34 2020 +0000
@@ -16,6 +16,7 @@
 #include "nsContentUtils.h"
 #include "nsLayoutUtils.h"
 #include "nsError.h"
+#include "nsCanvasFrame.h"
 #include "nsDisplayList.h"
 #include "nsIFrameInlines.h"
 #include "FrameLayerBuilder.h"
@@ -495,8 +496,27 @@
   return flags & TYPE_RENDERS_NO_IMAGES;
 }
 
-static void InvalidateImages(nsIFrame* aFrame, imgIRequest* aRequest) {
-  bool invalidateFrame = false;
+static void InvalidateImages(nsIFrame* aFrame, imgIRequest* aRequest,
+                             bool aForcePaint) {
+  if (!aFrame->StyleVisibility()->IsVisible()) {
+    return;
+  }
+
+  if (aFrame->IsFrameOfType(nsIFrame::eTablePart)) {
+    // Tables don't necessarily build border/background display items
+    // for the individual table part frames, so IterateRetainedDataFor
+    // might not find the right display item.
+    return aFrame->InvalidateFrame();
+  }
+
+  if (aFrame->IsPrimaryFrameOfRootOrBodyElement()) {
+    // Try to invalidate the canvas too, in the probable case the background
+    // was propagated to it.
+    InvalidateImages(aFrame->PresShell()->GetCanvasFrame(), aRequest,
+                     aForcePaint);
+  }
+
+  bool invalidateFrame = aForcePaint;
   const SmallPointerArray<DisplayItemData>& array = aFrame->DisplayItemData();
   for (uint32_t i = 0; i < array.Length(); i++) {
     DisplayItemData* data =
@@ -541,6 +561,17 @@
     }
   }
 
+  // Update ancestor rendering observers (-moz-element etc)
+  //
+  // NOTE: We need to do this even if invalidateFrame is false, see bug 1114526.
+  {
+    nsIFrame* f = aFrame;
+    while (f && !f->HasAnyStateBits(NS_FRAME_DESCENDANT_NEEDS_PAINT)) {
+      SVGObserverUtils::InvalidateDirectRenderingObservers(f);
+      f = nsLayoutUtils::GetCrossDocParentFrame(f);
+    }
+  }
+
   if (invalidateFrame) {
     aFrame->SchedulePaint();
   }
@@ -553,28 +584,7 @@
   NS_ASSERTION(mDocument, "Should have returned earlier!");
 
   for (FrameWithFlags& fwf : *aFrameSet) {
-    nsIFrame* frame = fwf.mFrame;
-    if (frame->StyleVisibility()->IsVisible()) {
-      if (frame->IsFrameOfType(nsIFrame::eTablePart)) {
-        // Tables don't necessarily build border/background display items
-        // for the individual table part frames, so IterateRetainedDataFor
-        // might not find the right display item.
-        frame->InvalidateFrame();
-      } else {
-        InvalidateImages(frame, aRequest);
-
-        // Update ancestor rendering observers (-moz-element etc)
-        nsIFrame* f = frame;
-        while (f && !f->HasAnyStateBits(NS_FRAME_DESCENDANT_NEEDS_PAINT)) {
-          SVGObserverUtils::InvalidateDirectRenderingObservers(f);
-          f = nsLayoutUtils::GetCrossDocParentFrame(f);
-        }
-
-        if (aForcePaint) {
-          frame->SchedulePaint();
-        }
-      }
-    }
+    InvalidateImages(fwf.mFrame, aRequest, aForcePaint);
   }
 }
 
