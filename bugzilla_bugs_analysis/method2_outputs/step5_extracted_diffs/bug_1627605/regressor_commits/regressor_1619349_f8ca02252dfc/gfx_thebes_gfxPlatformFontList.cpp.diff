# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxPlatformFontList.cpp
# Commit: f8ca02252dfc
# Full Hash: f8ca02252dfc48d7342703e6a635d510b9dc0b5d
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2020-04-02 09:51:45
# Regressor Bug: 1619349
# File Overlap Count: 1
# Description:
#   Bug 1619349 - patch 1 - Record statistics about font-matching behavior in the presContext. r=jwatt
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D67787
# ==============================================================================

diff -r 01a2a527aa1a -r f8ca02252dfc gfx/thebes/gfxPlatformFontList.cpp
--- a/gfx/thebes/gfxPlatformFontList.cpp	Wed Apr 01 21:42:11 2020 +0000
+++ b/gfx/thebes/gfxPlatformFontList.cpp	Wed Apr 01 21:42:36 2020 +0000
@@ -794,7 +794,7 @@
 
 gfxFontEntry* gfxPlatformFontList::SystemFindFontForChar(
     uint32_t aCh, uint32_t aNextCh, Script aRunScript,
-    const gfxFontStyle* aStyle) {
+    const gfxFontStyle* aStyle, FontVisibility* aVisibility) {
   MOZ_ASSERT(!mCodepointsWithNoFonts.test(aCh),
              "don't call for codepoints already known to be unsupported");
 
@@ -813,11 +813,13 @@
       if (face) {
         fontEntry =
             GetOrCreateFontEntry(face, mReplacementCharFallbackFamily.mShared);
+        *aVisibility = mReplacementCharFallbackFamily.mShared->Visibility();
       }
     } else if (!mReplacementCharFallbackFamily.mIsShared &&
                mReplacementCharFallbackFamily.mUnshared) {
       fontEntry =
           mReplacementCharFallbackFamily.mUnshared->FindFontForStyle(*aStyle);
+      *aVisibility = mReplacementCharFallbackFamily.mUnshared->Visibility();
     }
 
     // this should never fail, as we must have found U+FFFD in order to set
@@ -860,8 +862,13 @@
   // no match? add to set of non-matching codepoints
   if (!fontEntry) {
     mCodepointsWithNoFonts.set(aCh);
-  } else if (aCh == 0xFFFD && fontEntry) {
-    mReplacementCharFallbackFamily = fallbackFamily;
+  } else {
+    *aVisibility = fallbackFamily.mIsShared
+                       ? fallbackFamily.mShared->Visibility()
+                       : fallbackFamily.mUnshared->Visibility();
+    if (aCh == 0xFFFD) {
+      mReplacementCharFallbackFamily = fallbackFamily;
+    }
   }
 
   // track system fallback time
@@ -1004,16 +1011,12 @@
   bool allowHidden = bool(aFlags & FindFamiliesFlags::eSearchHiddenFamilies);
   if (SharedFontList()) {
     fontlist::Family* family = SharedFontList()->FindFamily(key, allowHidden);
-    if (family) {
-      aOutput->AppendElement(FamilyAndGeneric(family, aGeneric));
-      return true;
-    }
     // If not found, and other family names have not yet been initialized,
     // initialize the rest of the list and try again. This is done lazily
     // since reading name table entries is expensive.
     // Although ASCII localized family names are possible they don't occur
     // in practice, so avoid pulling in names at startup.
-    if (!mOtherFamilyNamesInitialized) {
+    if (!family && !mOtherFamilyNamesInitialized) {
       bool triggerLoading = true;
       bool mayDefer =
           !(aFlags & FindFamiliesFlags::eForceOtherFamilyNamesLoading);
@@ -1038,10 +1041,6 @@
       if (triggerLoading) {
         InitOtherFamilyNames(mayDefer);
         family = SharedFontList()->FindFamily(key);
-        if (family) {
-          aOutput->AppendElement(FamilyAndGeneric(family, aGeneric));
-          return true;
-        }
       }
       if (!family && !mOtherFamilyNamesInitialized &&
           !(aFlags & FindFamiliesFlags::eNoAddToNamesMissedWhenSearching)) {
@@ -1052,6 +1051,10 @@
         }
         mOtherNamesMissed->PutEntry(key);
       }
+      if (family) {
+        aOutput->AppendElement(FamilyAndGeneric(family, aGeneric));
+        return true;
+      }
     }
     return false;
   }