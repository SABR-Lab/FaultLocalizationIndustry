# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxTextRun.cpp
# Commit: f8ca02252dfc
# Full Hash: f8ca02252dfc48d7342703e6a635d510b9dc0b5d
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2020-04-02 09:51:45
# Regressor Bug: 1619349
# File Overlap Count: 1
# Description:
#   Bug 1619349 - patch 1 - Record statistics about font-matching behavior in the presContext. r=jwatt
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D67787
# ==============================================================================

diff -r 01a2a527aa1a -r f8ca02252dfc gfx/thebes/gfxTextRun.cpp
--- a/gfx/thebes/gfxTextRun.cpp	Wed Apr 01 21:42:11 2020 +0000
+++ b/gfx/thebes/gfxTextRun.cpp	Wed Apr 01 21:42:36 2020 +0000
@@ -525,7 +525,8 @@
     mContext->SnappedClip(gfxRect(
         aBounds.X() / appsPerDevUnit, aBounds.Y() / appsPerDevUnit,
         aBounds.Width() / appsPerDevUnit, aBounds.Height() / appsPerDevUnit));
-    mContext->SetDeviceColor(DeviceColor(aAlphaColor.r, aAlphaColor.g, aAlphaColor.b));
+    mContext->SetDeviceColor(
+        DeviceColor(aAlphaColor.r, aAlphaColor.g, aAlphaColor.b));
     mContext->PushGroupForBlendBack(gfxContentType::COLOR_ALPHA, aAlphaColor.a);
   }
 
@@ -1404,17 +1405,6 @@
   }
 }
 
-uint32_t gfxTextRun::CountMissingGlyphs() const {
-  uint32_t i;
-  uint32_t count = 0;
-  for (i = 0; i < GetLength(); ++i) {
-    if (mCharacterGlyphs[i].IsMissing()) {
-      ++count;
-    }
-  }
-  return count;
-}
-
 void gfxTextRun::CopyGlyphDataFrom(gfxShapedWord* aShapedWord,
                                    uint32_t aOffset) {
   uint32_t wordLen = aShapedWord->GetLength();
@@ -1695,6 +1685,7 @@
 gfxFontGroup::gfxFontGroup(const FontFamilyList& aFontFamilyList,
                            const gfxFontStyle* aStyle,
                            gfxTextPerfMetrics* aTextPerf,
+                           FontMatchingStats* aFontMatchingStats,
                            gfxUserFontSet* aUserFontSet, gfxFloat aDevToCssSize)
     : mFamilyList(aFontFamilyList),
       mStyle(*aStyle),
@@ -1703,6 +1694,7 @@
       mDevToCssSize(aDevToCssSize),
       mUserFontSet(aUserFontSet),
       mTextPerf(aTextPerf),
+      mFontMatchingStats(aFontMatchingStats),
       mLastPrefLang(eFontPrefLang_Western),
       mPageLang(gfxPlatformFontList::GetFontPrefLangFor(aStyle->language)),
       mLastPrefFirstFont(false),
@@ -1739,6 +1731,39 @@
     }
   }
 
+  if (mFontMatchingStats) {
+    for (const auto& f : fonts) {
+      nsAutoCString key;
+      FontVisibility visibility;
+      if (f.mFamily.mIsShared) {
+        key = f.mFamily.mShared->Key().AsString(pfl->SharedFontList());
+        visibility = f.mFamily.mShared->Visibility();
+      } else {
+        key = f.mFamily.mUnshared->Name();
+        ToLowerCase(key);
+        visibility = f.mFamily.mUnshared->Visibility();
+      }
+      if (mFontMatchingStats->mFamilyNames.EnsureInserted(key)) {
+        switch (visibility) {
+          case FontVisibility::Base:
+            mFontMatchingStats->mBaseFonts++;
+            break;
+          case FontVisibility::LangPack:
+            mFontMatchingStats->mLangPackFonts++;
+            break;
+          case FontVisibility::User:
+            mFontMatchingStats->mUserFonts++;
+            break;
+          case FontVisibility::Webfont:
+            mFontMatchingStats->mWebFonts++;
+            break;
+          default:
+            break;
+        }
+      }
+    }
+  }
+
   // if necessary, append default generic onto the end
   if (mFamilyList.GetDefaultFontType() != StyleGenericFontFamily::None &&
       !mFamilyList.HasDefaultGeneric()) {
@@ -2121,12 +2146,6 @@
   return nullptr;
 }
 
-gfxFontGroup* gfxFontGroup::Copy(const gfxFontStyle* aStyle) {
-  gfxFontGroup* fg = new gfxFontGroup(mFamilyList, aStyle, mTextPerf,
-                                      mUserFontSet, mDevToCssSize);
-  return fg;
-}
-
 bool gfxFontGroup::IsInvalidChar(uint8_t ch) {
   return ((ch & 0x7f) < 0x20 || ch == 0x7f);
 }
@@ -2652,6 +2671,9 @@
             index++;
             if (!mSkipDrawing && !IsPUA(usv)) {
               missingChars = true;
+              if (mFontMatchingStats) {
+                mFontMatchingStats->mFallbacks |= FallbackTypes::MissingFont;
+              }
             }
             continue;
           }
@@ -2685,6 +2707,9 @@
         aTextRun->SetMissingGlyph(aOffset + index, ch, mainFont);
         if (!mSkipDrawing && !IsPUA(ch)) {
           missingChars = true;
+          if (mFontMatchingStats) {
+            mFontMatchingStats->mFallbacks |= FallbackTypes::MissingFont;
+          }
         }
       }
     }
@@ -3385,28 +3410,29 @@
       }
 
       // if ch in cmap, create and return a gfxFont
+      gfxFont* prefFont = nullptr;
       if (fe->HasCharacter(aCh)) {
-        gfxFont* prefFont = fe->FindOrMakeFont(&mStyle);
+        prefFont = fe->FindOrMakeFont(&mStyle);
         if (!prefFont) {
           continue;
         }
-        mLastPrefFamily = family;
-        mLastPrefFont = prefFont;
-        mLastPrefLang = charLang;
-        mLastPrefFirstFont = (i == 0 && j == 0);
-        return prefFont;
       }
 
       // If the char was not available, see if we can fall back to an
       // alternative face in the same family.
-      gfxFont* prefFont = family.mIsShared
-                              ? FindFallbackFaceForChar(family.mShared, aCh)
-                              : FindFallbackFaceForChar(family.mUnshared, aCh);
+      if (!prefFont) {
+        prefFont = family.mIsShared
+                       ? FindFallbackFaceForChar(family.mShared, aCh)
+                       : FindFallbackFaceForChar(family.mUnshared, aCh);
+      }
       if (prefFont) {
         mLastPrefFamily = family;
         mLastPrefFont = prefFont;
         mLastPrefLang = charLang;
         mLastPrefFirstFont = (i == 0 && j == 0);
+        if (mFontMatchingStats) {
+          mFontMatchingStats->mFallbacks |= FallbackTypes::FallbackToPrefsFont;
+        }
         return prefFont;
       }
     }
@@ -3418,10 +3444,38 @@
 gfxFont* gfxFontGroup::WhichSystemFontSupportsChar(uint32_t aCh,
                                                    uint32_t aNextCh,
                                                    Script aRunScript) {
+  FontVisibility visibility;
   gfxFontEntry* fe =
       gfxPlatformFontList::PlatformFontList()->SystemFindFontForChar(
-          aCh, aNextCh, aRunScript, &mStyle);
+          aCh, aNextCh, aRunScript, &mStyle, &visibility);
   if (fe) {
+    if (mFontMatchingStats) {
+      switch (visibility) {
+        case FontVisibility::Unknown:
+          // We don't currently track stats for systems lacking font visibility
+          // categories, so just ignore this.
+          break;
+        case FontVisibility::Base:
+          mFontMatchingStats->mFallbacks |= FallbackTypes::FallbackToBaseFont;
+          break;
+        case FontVisibility::LangPack:
+          mFontMatchingStats->mFallbacks |=
+              FallbackTypes::FallbackToLangPackFont;
+          break;
+        case FontVisibility::User:
+          mFontMatchingStats->mFallbacks |= FallbackTypes::FallbackToUserFont;
+          break;
+        case FontVisibility::Hidden:
+          // If macOS font fallback uses the system font, we consider this a
+          // base OS font even though it wouldn't be exposed via font-family.
+          mFontMatchingStats->mFallbacks |= FallbackTypes::FallbackToBaseFont;
+          break;
+        case FontVisibility::Webfont:
+        default:
+          MOZ_ASSERT_UNREACHABLE("this can't happen!");
+          break;
+      }
+    }
     return fe->FindOrMakeFont(&mStyle);
   }
 