# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/base/DocGroup.cpp
# Commit: 207cada50132
# Full Hash: 207cada5013283f4bd078c9648121dfe90ce5ac6
# Author: Andreas Farre <farre@mozilla.com>
# Date: 2020-04-17 09:38:52
# Description:
#   Bug 1628120 - Make sure to dispatch to correct event target. r=peterv
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D71167
# ==============================================================================

diff -r c54901331fd9 -r 207cada50132 dom/base/DocGroup.cpp
--- a/dom/base/DocGroup.cpp	Wed Apr 15 22:11:19 2020 +0000
+++ b/dom/base/DocGroup.cpp	Thu Apr 16 14:14:43 2020 +0000
@@ -47,8 +47,6 @@
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIEVENTTARGET_FULL
 
-  void ClearDocGroup() { mDocGroup = nullptr; }
-
  private:
   ~LabellingEventTarget() = default;
 };
@@ -141,9 +139,9 @@
 
   if (mDocuments.IsEmpty()) {
     mBrowsingContextGroup = nullptr;
-    nsCOMPtr<LabellingEventTarget> target = do_QueryInterface(mEventTarget);
     // This clears the cycle DocGroup has with LabellingEventTarget.
-    target->ClearDocGroup();
+    mEventTarget = nullptr;
+    mAbstractThread = nullptr;
   }
 }
 
@@ -281,12 +279,21 @@
   // Here we have the same event target for every TaskCategory. The
   // reason for that is that currently TaskCategory isn't used, and
   // it's unsure if it ever will be (See Bug 1624819).
-  return mEventTarget;
+  if (mEventTarget) {
+    return mEventTarget;
+  }
+
+  return GetMainThreadSerialEventTarget();
 }
 
 AbstractThread* DocGroup::AbstractMainThreadFor(TaskCategory aCategory) {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mDocuments.IsEmpty());
+
+  if (!mEventTarget) {
+    return AbstractThread::MainThread();
+  }
+
   // Here we have the same thread for every TaskCategory. The reason
   // for that is that currently TaskCategory isn't used, and it's
   // unsure if it ever will be (See Bug 1624819).
