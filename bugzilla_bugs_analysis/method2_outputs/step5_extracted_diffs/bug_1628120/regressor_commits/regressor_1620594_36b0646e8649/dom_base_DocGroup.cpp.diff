# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DocGroup.cpp
# Commit: 36b0646e8649
# Full Hash: 36b0646e86498662e770756ad54b1fd648a82184
# Author: Andreas Farre <farre@mozilla.com>
# Date: 2020-04-07 21:44:02
# Regressor Bug: 1620594
# File Overlap Count: 1
# Description:
#   Bug 1620594 - Part 7: Remove TabGroup and SystemGroup. r=nika,bas
#   
#   TabGroup never really made any difference in which thread something go
#   dispatched to. This was the intended use, but development of TabGroups
#   with abstract main threads never made it that far. The good thing is
# ==============================================================================

diff -r a5ad3b179c92 -r 36b0646e8649 dom/base/DocGroup.cpp
--- a/dom/base/DocGroup.cpp	Tue Apr 07 15:17:14 2020 +0000
+++ b/dom/base/DocGroup.cpp	Tue Apr 07 15:17:47 2020 +0000
@@ -7,9 +7,9 @@
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/JSExecutionManager.h"
-#include "mozilla/dom/TabGroup.h"
 #include "mozilla/AbstractThread.h"
 #include "mozilla/PerformanceUtils.h"
+#include "mozilla/SchedulerGroup.h"
 #include "mozilla/ThrottledEventQueue.h"
 #include "mozilla/StaticPrefs_dom.h"
 #include "mozilla/Telemetry.h"
@@ -21,12 +21,92 @@
 #  include <unistd.h>  // for getpid()
 #endif                 // defined(XP_WIN)
 
+namespace {
+
+#define NS_LABELLINGEVENTTARGET_IID                  \
+  {                                                  \
+    0x6087fa50, 0xe387, 0x45c8, {                    \
+      0xab, 0x72, 0xd2, 0x1f, 0x69, 0xee, 0xd3, 0x15 \
+    }                                                \
+  }
+
+// LabellingEventTarget labels all dispatches with the DocGroup that
+// created it.
+class LabellingEventTarget final : public nsISerialEventTarget {
+  // This creates a cycle with DocGroup. Therefore, when DocGroup
+  // looses its last Document, the DocGroup of the
+  // LabellingEventTarget needs to be cleared.
+  RefPtr<mozilla::dom::DocGroup> mDocGroup;
+
+ public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_LABELLINGEVENTTARGET_IID)
+
+  explicit LabellingEventTarget(mozilla::dom::DocGroup* aDocGroup)
+      : mDocGroup(aDocGroup) {}
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIEVENTTARGET_FULL
+
+  void ClearDocGroup() { mDocGroup = nullptr; }
+
+ private:
+  ~LabellingEventTarget() = default;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(LabellingEventTarget, NS_LABELLINGEVENTTARGET_IID)
+
+}  // namespace
+
+NS_IMETHODIMP
+LabellingEventTarget::DispatchFromScript(nsIRunnable* aRunnable,
+                                         uint32_t aFlags) {
+  return Dispatch(do_AddRef(aRunnable), aFlags);
+}
+
+NS_IMETHODIMP
+LabellingEventTarget::Dispatch(already_AddRefed<nsIRunnable> aRunnable,
+                               uint32_t aFlags) {
+  if (NS_WARN_IF(aFlags != NS_DISPATCH_NORMAL)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  return mozilla::SchedulerGroup::DispatchWithDocGroup(
+      mozilla::TaskCategory::Other, std::move(aRunnable), mDocGroup);
+}
+
+NS_IMETHODIMP
+LabellingEventTarget::DelayedDispatch(already_AddRefed<nsIRunnable>, uint32_t) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+LabellingEventTarget::IsOnCurrentThread(bool* aIsOnCurrentThread) {
+  *aIsOnCurrentThread = NS_IsMainThread();
+  return NS_OK;
+}
+
+NS_IMETHODIMP_(bool)
+LabellingEventTarget::IsOnCurrentThreadInfallible() {
+  return NS_IsMainThread();
+}
+
+NS_IMPL_ISUPPORTS(LabellingEventTarget, LabellingEventTarget, nsIEventTarget,
+                  nsISerialEventTarget)
+
 namespace mozilla {
 namespace dom {
 
 AutoTArray<RefPtr<DocGroup>, 2>* DocGroup::sPendingDocGroups = nullptr;
 
 /* static */
+already_AddRefed<DocGroup> DocGroup::Create(
+    BrowsingContextGroup* aBrowsingContextGroup, const nsACString& aKey) {
+  RefPtr<DocGroup> docGroup = new DocGroup(aBrowsingContextGroup, aKey);
+  docGroup->mEventTarget = new LabellingEventTarget(docGroup);
+  return docGroup.forget();
+}
+
+/* static */
 nsresult DocGroup::GetKey(nsIPrincipal* aPrincipal, nsACString& aKey) {
   // Use GetBaseDomain() to handle things like file URIs, IP address URIs,
   // etc. correctly.
@@ -47,17 +127,34 @@
   mExecutionManager = aManager;
 }
 
+void DocGroup::AddDocument(Document* aDocument) {
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!mDocuments.Contains(aDocument));
+  MOZ_ASSERT(mBrowsingContextGroup);
+  mDocuments.AppendElement(aDocument);
+}
+
 void DocGroup::RemoveDocument(Document* aDocument) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mDocuments.Contains(aDocument));
   mDocuments.RemoveElement(aDocument);
+
+  if (mDocuments.IsEmpty()) {
+    mBrowsingContextGroup = nullptr;
+    nsCOMPtr<LabellingEventTarget> target = do_QueryInterface(mEventTarget);
+    // This clears the cycle DocGroup has with LabellingEventTarget.
+    target->ClearDocGroup();
+  }
 }
 
-DocGroup::DocGroup(TabGroup* aTabGroup, const nsACString& aKey,
-                   const nsID& aAgentClusterId)
-    : mKey(aKey), mTabGroup(aTabGroup), mAgentClusterId(aAgentClusterId) {
-  // This method does not add itself to mTabGroup->mDocGroups as the caller does
-  // it for us.
+DocGroup::DocGroup(BrowsingContextGroup* aBrowsingContextGroup,
+                   const nsACString& aKey)
+    : mKey(aKey),
+      mBrowsingContextGroup(aBrowsingContextGroup),
+      mAgentClusterId(nsContentUtils::GenerateUUID()) {
+  // This method does not add itself to
+  // mBrowsingContextGroup->mDocGroups as the caller does it for us.
+  MOZ_ASSERT(NS_IsMainThread());
   if (StaticPrefs::dom_arena_allocator_enabled_AtStartup()) {
     mArena = new mozilla::dom::DOMArena();
   }
@@ -67,15 +164,15 @@
 }
 
 DocGroup::~DocGroup() {
-  MOZ_ASSERT(mDocuments.IsEmpty());
+  MOZ_RELEASE_ASSERT(mDocuments.IsEmpty());
+  MOZ_RELEASE_ASSERT(!mBrowsingContextGroup);
+
   if (!NS_IsMainThread()) {
     nsIEventTarget* target = EventTargetFor(TaskCategory::Other);
     NS_ProxyRelease("DocGroup::mReactionsStack", target,
                     mReactionsStack.forget());
   }
 
-  mTabGroup->mDocGroups.RemoveEntry(mKey);
-
   if (mIframePostMessageQueue) {
     FlushIframePostMessageQueue();
   }
@@ -175,20 +272,33 @@
   if (mPerformanceCounter) {
     mPerformanceCounter->IncrementDispatchCounter(DispatchCategory(aCategory));
   }
-  return mTabGroup->DispatchWithDocGroup(aCategory, std::move(aRunnable), this);
+  return SchedulerGroup::DispatchWithDocGroup(aCategory, std::move(aRunnable),
+                                              this);
 }
 
 nsISerialEventTarget* DocGroup::EventTargetFor(TaskCategory aCategory) const {
-  return mTabGroup->EventTargetFor(aCategory);
+  MOZ_ASSERT(!mDocuments.IsEmpty());
+  // Here we have the same event target for every TaskCategory. The
+  // reason for that is that currently TaskCategory isn't used, and
+  // it's unsure if it ever will be (See Bug 1624819).
+  return mEventTarget;
 }
 
 AbstractThread* DocGroup::AbstractMainThreadFor(TaskCategory aCategory) {
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
-  return mTabGroup->AbstractMainThreadFor(aCategory);
+  MOZ_ASSERT(!mDocuments.IsEmpty());
+  // Here we have the same thread for every TaskCategory. The reason
+  // for that is that currently TaskCategory isn't used, and it's
+  // unsure if it ever will be (See Bug 1624819).
+  if (!mAbstractThread) {
+    mAbstractThread = AbstractThread::CreateEventTargetWrapper(
+        mEventTarget,
+        /* aRequireTailDispatch = */ true);
+  }
+
+  return mAbstractThread;
 }
 
-bool* DocGroup::GetValidAccessPtr() { return mTabGroup->GetValidAccessPtr(); }
-
 void DocGroup::SignalSlotChange(HTMLSlotElement& aSlot) {
   MOZ_ASSERT(!mSignalSlotList.Contains(&aSlot));
   mSignalSlotList.AppendElement(&aSlot);
@@ -219,10 +329,10 @@
       MOZ_ALWAYS_SUCCEEDS(rv);
     }
 
-    // Ensure the queue is disabled. Unlike the postMessageEvent queue in
-    // TabGroup, this postMessage queue should always be paused, because if
-    // we leave it open, the postMessage may get dispatched to an unloaded
-    // iframe
+    // Ensure the queue is disabled. Unlike the postMessageEvent queue
+    // in BrowsingContextGroup, this postMessage queue should always
+    // be paused, because if we leave it open, the postMessage may get
+    // dispatched to an unloaded iframe
     MOZ_ASSERT(mIframePostMessageQueue);
     MOZ_ASSERT(mIframePostMessageQueue->IsPaused());
 
@@ -272,5 +382,10 @@
   return false;
 }
 
+void DocGroup::ClearEventTarget() {
+  nsCOMPtr<LabellingEventTarget> target = do_QueryInterface(mEventTarget);
+  target->ClearDocGroup();
+}
+
 }  // namespace dom
 }  // namespace mozilla