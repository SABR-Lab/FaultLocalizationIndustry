# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmOpIter.h
# Commit: a9d2b57a99be
# Full Hash: a9d2b57a99be08cf6942e5dd8c300e75ba0b7501
# Author: Andy Wingo <wingo@igalia.com>
# Date: 2019-10-23 15:48:18
# Regressor Bug: 1578418
# File Overlap Count: 1
# Description:
#   Bug 1578418 - Use WasmABIResults iterator to place block and function results r=luke,lth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D44477
# ==============================================================================

diff -r 8e233a18ab9a -r a9d2b57a99be js/src/wasm/WasmOpIter.h
--- a/js/src/wasm/WasmOpIter.h	Wed Oct 23 08:22:36 2019 +0000
+++ b/js/src/wasm/WasmOpIter.h	Tue Oct 22 15:30:10 2019 +0000
@@ -720,10 +720,11 @@
   MOZ_MUST_USE bool readFunctionStart(uint32_t funcIndex);
   MOZ_MUST_USE bool readFunctionEnd(const uint8_t* bodyEnd);
   MOZ_MUST_USE bool readReturn(ValueVector* values);
-  MOZ_MUST_USE bool readBlock();
-  MOZ_MUST_USE bool readLoop();
-  MOZ_MUST_USE bool readIf(Value* condition);
-  MOZ_MUST_USE bool readElse(ResultType* thenType, ValueVector* thenValues);
+  MOZ_MUST_USE bool readBlock(ResultType* paramType);
+  MOZ_MUST_USE bool readLoop(ResultType* paramType);
+  MOZ_MUST_USE bool readIf(ResultType* paramType, Value* condition);
+  MOZ_MUST_USE bool readElse(ResultType* paramType, ResultType* resultType,
+                             ValueVector* thenValues);
   MOZ_MUST_USE bool readEnd(LabelKind* kind, ResultType* type,
                             ValueVector* values);
   void popEnd();
@@ -1262,7 +1263,7 @@
 }
 
 template <typename Policy>
-inline bool OpIter<Policy>::readBlock() {
+inline bool OpIter<Policy>::readBlock(ResultType* paramType) {
   MOZ_ASSERT(Classify(op_) == OpKind::Block);
 
   BlockType type;
@@ -1270,11 +1271,12 @@
     return false;
   }
 
+  *paramType = type.params();
   return pushControl(LabelKind::Block, type);
 }
 
 template <typename Policy>
-inline bool OpIter<Policy>::readLoop() {
+inline bool OpIter<Policy>::readLoop(ResultType* paramType) {
   MOZ_ASSERT(Classify(op_) == OpKind::Loop);
 
   BlockType type;
@@ -1282,11 +1284,12 @@
     return false;
   }
 
+  *paramType = type.params();
   return pushControl(LabelKind::Loop, type);
 }
 
 template <typename Policy>
-inline bool OpIter<Policy>::readIf(Value* condition) {
+inline bool OpIter<Policy>::readIf(ResultType* paramType, Value* condition) {
   MOZ_ASSERT(Classify(op_) == OpKind::If);
 
   BlockType type;
@@ -1302,12 +1305,14 @@
     return false;
   }
 
+  *paramType = type.params();
   size_t paramsLength = type.params().length();
   return thenParamStack_.append(valueStack_.end() - paramsLength, paramsLength);
 }
 
 template <typename Policy>
-inline bool OpIter<Policy>::readElse(ResultType* thenType,
+inline bool OpIter<Policy>::readElse(ResultType* paramType,
+                                     ResultType* resultType,
                                      ValueVector* values) {
   MOZ_ASSERT(Classify(op_) == OpKind::Else);
 
@@ -1316,7 +1321,8 @@
     return fail("else can only be used within an if");
   }
 
-  if (!checkStackAtEndOfBlock(thenType, values)) {
+  *paramType = block.type().params();
+  if (!checkStackAtEndOfBlock(resultType, values)) {
     return false;
   }
 
@@ -1347,7 +1353,8 @@
 
   // If an `if` block ends with `end` instead of `else`, then we must
   // additionally validate that the then-block doesn't push anything.
-  if (block.kind() == LabelKind::Then && !block.resultType().empty()) {
+  if (block.kind() == LabelKind::Then &&
+      block.type().params() != block.type().results()) {
     return fail("if without else with a result value");
   }
 