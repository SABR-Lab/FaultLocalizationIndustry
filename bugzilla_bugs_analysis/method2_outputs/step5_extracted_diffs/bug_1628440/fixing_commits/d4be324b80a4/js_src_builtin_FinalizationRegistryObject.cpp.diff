# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/FinalizationRegistryObject.cpp
# Commit: d4be324b80a4
# Full Hash: d4be324b80a403215e60c3462272fbc46241d3cd
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2020-04-10 02:59:09
# Description:
#   Bug 1628440 - Use WeakHeapPtr for weakly-held vector elements in finalization registry registrations weakmap r=sfink
#   
#   The problem is that HeapPtr<> has a prebarrier in its destructor.  This isn't necessary for weakly held values, and cause problems if the values have already been finalized.  The patch also renames FinalizationRecordVectorObject to FinalizationRegistrationsObject to better describe its purpose.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D70346
# ==============================================================================

diff -r ce494e20e11c -r d4be324b80a4 js/src/builtin/FinalizationRegistryObject.cpp
--- a/js/src/builtin/FinalizationRegistryObject.cpp	Thu Apr 09 15:34:49 2020 +0000
+++ b/js/src/builtin/FinalizationRegistryObject.cpp	Thu Apr 09 16:23:12 2020 +0000
@@ -133,29 +133,29 @@
 }
 
 ///////////////////////////////////////////////////////////////////////////
-// FinalizationRecordVectorObject
+// FinalizationRegistrationsObject
 
-const JSClass FinalizationRecordVectorObject::class_ = {
-    "FinalizationRecordVector",
+const JSClass FinalizationRegistrationsObject::class_ = {
+    "FinalizationRegistrations",
     JSCLASS_HAS_RESERVED_SLOTS(SlotCount) | JSCLASS_BACKGROUND_FINALIZE,
     &classOps_, JS_NULL_CLASS_SPEC};
 
-const JSClassOps FinalizationRecordVectorObject::classOps_ = {
-    nullptr,                                   // addProperty
-    nullptr,                                   // delProperty
-    nullptr,                                   // enumerate
-    nullptr,                                   // newEnumerate
-    nullptr,                                   // resolve
-    nullptr,                                   // mayResolve
-    FinalizationRecordVectorObject::finalize,  // finalize
-    nullptr,                                   // call
-    nullptr,                                   // hasInstance
-    nullptr,                                   // construct
-    nullptr,                                   // trace
+const JSClassOps FinalizationRegistrationsObject::classOps_ = {
+    nullptr,                                    // addProperty
+    nullptr,                                    // delProperty
+    nullptr,                                    // enumerate
+    nullptr,                                    // newEnumerate
+    nullptr,                                    // resolve
+    nullptr,                                    // mayResolve
+    FinalizationRegistrationsObject::finalize,  // finalize
+    nullptr,                                    // call
+    nullptr,                                    // hasInstance
+    nullptr,                                    // construct
+    nullptr,                                    // trace
 };
 
 /* static */
-FinalizationRecordVectorObject* FinalizationRecordVectorObject::create(
+FinalizationRegistrationsObject* FinalizationRegistrationsObject::create(
     JSContext* cx) {
   auto records = cx->make_unique<FinalizationRecordVector>(cx->zone());
   if (!records) {
@@ -163,7 +163,7 @@
   }
 
   auto object =
-      NewObjectWithNullTaggedProto<FinalizationRecordVectorObject>(cx);
+      NewObjectWithNullTaggedProto<FinalizationRegistrationsObject>(cx);
   if (!object) {
     return nullptr;
   }
@@ -175,21 +175,22 @@
 }
 
 /* static */
-void FinalizationRecordVectorObject::finalize(JSFreeOp* fop, JSObject* obj) {
-  auto rv = &obj->as<FinalizationRecordVectorObject>();
+void FinalizationRegistrationsObject::finalize(JSFreeOp* fop, JSObject* obj) {
+  auto rv = &obj->as<FinalizationRegistrationsObject>();
   fop->delete_(obj, rv->records(), MemoryUse::FinalizationRecordVector);
 }
 
-inline FinalizationRecordVector* FinalizationRecordVectorObject::records() {
-  return static_cast<FinalizationRecordVector*>(privatePtr());
+inline WeakFinalizationRecordVector*
+FinalizationRegistrationsObject::records() {
+  return static_cast<WeakFinalizationRecordVector*>(privatePtr());
 }
 
-inline const FinalizationRecordVector* FinalizationRecordVectorObject::records()
-    const {
-  return static_cast<const FinalizationRecordVector*>(privatePtr());
+inline const WeakFinalizationRecordVector*
+FinalizationRegistrationsObject::records() const {
+  return static_cast<const WeakFinalizationRecordVector*>(privatePtr());
 }
 
-inline void* FinalizationRecordVectorObject::privatePtr() const {
+inline void* FinalizationRegistrationsObject::privatePtr() const {
   Value value = getReservedSlot(RecordsSlot);
   if (value.isUndefined()) {
     return nullptr;
@@ -199,24 +200,24 @@
   return ptr;
 }
 
-inline bool FinalizationRecordVectorObject::isEmpty() const {
+inline bool FinalizationRegistrationsObject::isEmpty() const {
   MOZ_ASSERT(records());
   return records()->empty();
 }
 
-inline bool FinalizationRecordVectorObject::append(
+inline bool FinalizationRegistrationsObject::append(
     HandleFinalizationRecordObject record) {
   MOZ_ASSERT(records());
   return records()->append(record);
 }
 
-inline void FinalizationRecordVectorObject::remove(
+inline void FinalizationRegistrationsObject::remove(
     HandleFinalizationRecordObject record) {
   MOZ_ASSERT(records());
   records()->eraseIfEqual(record);
 }
 
-inline void FinalizationRecordVectorObject::sweep() {
+inline void FinalizationRegistrationsObject::sweep() {
   MOZ_ASSERT(records());
   return records()->sweep();
 }
@@ -339,7 +340,7 @@
   auto registry = &obj->as<FinalizationRegistryObject>();
 
   // Trace the registrations weak map. At most this traces the
-  // FinalizationRecordVectorObject values of the map; the contents of those
+  // FinalizationRegistrationsObject values of the map; the contents of those
   // objects are weakly held and are not traced.
   if (ObjectWeakMap* registrations = registry->registrations()) {
     registrations->trace(trc);
@@ -363,7 +364,7 @@
   for (ObjectValueWeakMap::Enum e(registrations()->valueMap()); !e.empty();
        e.popFront()) {
     auto registrations =
-        &e.front().value().toObject().as<FinalizationRecordVectorObject>();
+        &e.front().value().toObject().as<FinalizationRegistrationsObject>();
     registrations->sweep();
     if (registrations->isEmpty()) {
       e.removeFront();
@@ -588,12 +589,12 @@
   MOZ_ASSERT(registry->registrations());
 
   auto& map = *registry->registrations();
-  Rooted<FinalizationRecordVectorObject*> recordsObject(cx);
+  Rooted<FinalizationRegistrationsObject*> recordsObject(cx);
   JSObject* obj = map.lookup(unregisterToken);
   if (obj) {
-    recordsObject = &obj->as<FinalizationRecordVectorObject>();
+    recordsObject = &obj->as<FinalizationRegistrationsObject>();
   } else {
-    recordsObject = FinalizationRecordVectorObject::create(cx);
+    recordsObject = FinalizationRegistrationsObject::create(cx);
     if (!recordsObject || !map.add(cx, unregisterToken, recordsObject)) {
       return false;
     }
@@ -621,7 +622,7 @@
   auto& map = *registry->registrations();
   JSObject* obj = map.lookup(unregisterToken);
   MOZ_ASSERT(obj);
-  auto records = &obj->as<FinalizationRecordVectorObject>();
+  auto records = &obj->as<FinalizationRegistrationsObject>();
   records->remove(record);
 
   if (records->empty()) {
@@ -674,7 +675,7 @@
   FinalizationRecordSet* activeRecords = registry->activeRecords();
   RootedObject obj(cx, registry->registrations()->lookup(unregisterToken));
   if (obj) {
-    auto* records = obj->as<FinalizationRecordVectorObject>().records();
+    auto* records = obj->as<FinalizationRegistrationsObject>().records();
     MOZ_ASSERT(records);
     MOZ_ASSERT(!records->empty());
     for (FinalizationRecordObject* record : *records) {