# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/CacheIR.cpp
# Commit: fbbb339d3fdb
# Full Hash: fbbb339d3fdb70cb2b9f48c1194f6320909b6952
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2020-04-08 21:42:38
# Regressor Bug: 1620997
# File Overlap Count: 1
# Description:
#   Bug 1620997 - Part 2: Add JSOp::Pow support to CacheIR. r=jandem
#   
#   There are too few registers available on x86, so the code tries to reuse the output
#   operand's type register in addition to its payload register.
#   
# ==============================================================================

diff -r 815e8172ee57 -r fbbb339d3fdb js/src/jit/CacheIR.cpp
--- a/js/src/jit/CacheIR.cpp	Tue Apr 07 11:22:51 2020 +0000
+++ b/js/src/jit/CacheIR.cpp	Tue Apr 07 11:46:58 2020 +0000
@@ -6642,7 +6642,7 @@
 AttachDecision BinaryArithIRGenerator::tryAttachDouble() {
   // Check valid opcodes
   if (op_ != JSOp::Add && op_ != JSOp::Sub && op_ != JSOp::Mul &&
-      op_ != JSOp::Div && op_ != JSOp::Mod) {
+      op_ != JSOp::Div && op_ != JSOp::Mod && op_ != JSOp::Pow) {
     return AttachDecision::NoAction;
   }
 
@@ -6678,6 +6678,10 @@
       writer.doubleModResult(lhs, rhs);
       trackAttached("BinaryArith.Double.Mod");
       break;
+    case JSOp::Pow:
+      writer.doublePowResult(lhs, rhs);
+      trackAttached("BinaryArith.Double.Pow");
+      break;
     default:
       MOZ_CRASH("Unhandled Op");
   }
@@ -6699,7 +6703,14 @@
   }
 
   if (op_ != JSOp::Add && op_ != JSOp::Sub && op_ != JSOp::Mul &&
-      op_ != JSOp::Div && op_ != JSOp::Mod) {
+      op_ != JSOp::Div && op_ != JSOp::Mod && op_ != JSOp::Pow) {
+    return AttachDecision::NoAction;
+  }
+
+  // x^y where y < 0 is most of the time not an int32, except when y gets large
+  // enough. It's hard to determine when exactly y is "large enough", so we
+  // don't attach an IC for any negative exponent.
+  if (op_ == JSOp::Pow && rhs_.isInt32() && rhs_.toInt32() < 0) {
     return AttachDecision::NoAction;
   }
 
@@ -6738,6 +6749,10 @@
       writer.int32ModResult(lhsIntId, rhsIntId);
       trackAttached("BinaryArith.Int32.Mod");
       break;
+    case JSOp::Pow:
+      writer.int32PowResult(lhsIntId, rhsIntId);
+      trackAttached("BinaryArith.Int32.Pow");
+      break;
     default:
       MOZ_CRASH("Unhandled op in tryAttachInt32");
   }
@@ -6976,7 +6991,15 @@
 
   // Must _not_ support Add, because it would be string concatenation instead.
   if (op_ != JSOp::Sub && op_ != JSOp::Mul && op_ != JSOp::Div &&
-      op_ != JSOp::Mod) {
+      op_ != JSOp::Mod && op_ != JSOp::Pow) {
+    return AttachDecision::NoAction;
+  }
+
+  // See tryAttachInt32() for why negative exponents are rejected. We can't
+  // easily determine if a string exponent is negative, so any strings are
+  // rejected as well.
+  if (op_ == JSOp::Pow &&
+      ((rhs_.isInt32() && rhs_.toInt32() < 0) || rhs_.isString())) {
     return AttachDecision::NoAction;
   }
 