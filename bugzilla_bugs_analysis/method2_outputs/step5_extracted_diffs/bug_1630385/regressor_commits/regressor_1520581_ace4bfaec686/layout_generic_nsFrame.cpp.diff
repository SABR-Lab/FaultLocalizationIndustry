# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsFrame.cpp
# Commit: ace4bfaec686
# Full Hash: ace4bfaec6861e9d6b4a3cebc07b96194acf9ed7
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-04-14 04:09:24
# Regressor Bug: 1520581
# File Overlap Count: 1
# Description:
#   Bug 1520581 - Allow to select scroll anchors inside nested scroll frames. r=dholbert
#   
#   As long as the nested scrollframe doesn't maintain an anchor itself.
#   
#   This is important for pages which use overflow: hidden to contain large
# ==============================================================================

diff -r ef38e7c833c7 -r ace4bfaec686 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Mon Apr 13 15:42:59 2020 +0000
+++ b/layout/generic/nsFrame.cpp	Mon Apr 13 20:58:14 2020 +0000
@@ -10038,15 +10038,27 @@
     return false;
   }
 
-  ScrollAnchorContainer* container = ScrollAnchorContainer::FindFor(this);
-  if (container->AnchorNode() != this) {
-    return false;
-  }
-
-  if (aOutContainer) {
-    *aOutContainer = container;
-  }
-  return true;
+  nsIFrame* f = this;
+
+  // FIXME(emilio, bug 1629280): We should find a non-null anchor if we have the
+  // flag set, but bug 1629280 makes it so that we cannot really assert it /
+  // make this just a `while (true)`, and uncomment the below assertion.
+  while (auto* container = ScrollAnchorContainer::FindFor(f)) {
+    // MOZ_ASSERT(f->IsInScrollAnchorChain());
+    if (nsIFrame* anchor = container->AnchorNode()) {
+      if (anchor != this) {
+        return false;
+      }
+      if (aOutContainer) {
+        *aOutContainer = container;
+      }
+      return true;
+    }
+
+    f = container->Frame();
+  }
+
+  return false;
 }
 
 bool nsIFrame::IsInScrollAnchorChain() const { return mInScrollAnchorChain; }