# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/performance/PerformanceObserver.cpp
# Commit: 5248abfed275
# Full Hash: 5248abfed275b2938ed64770bec58b3ff68d624b
# Author: Will Hawkins <whawkins@mozilla.com>
# Date: 2019-04-12 21:56:33
# Regressor Bug: 1539006
# File Overlap Count: 1
# Description:
#   Bug 1539006: Properly implement Performance Timeline Level 2 w3c spec. r=mstange,baku
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D27008
# ==============================================================================

diff -r e17500911824 -r 5248abfed275 dom/performance/PerformanceObserver.cpp
--- a/dom/performance/PerformanceObserver.cpp	Fri Apr 12 15:49:22 2019 +0000
+++ b/dom/performance/PerformanceObserver.cpp	Fri Apr 12 16:29:48 2019 +0000
@@ -46,16 +46,22 @@
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
+const char UnsupportedEntryTypesIgnoredMsgId[] = "UnsupportedEntryTypesIgnored";
+const char AllEntryTypesIgnoredMsgId[] = "AllEntryTypesIgnored";
+
 PerformanceObserver::PerformanceObserver(nsPIDOMWindowInner* aOwner,
                                          PerformanceObserverCallback& aCb)
-    : mOwner(aOwner), mCallback(&aCb), mConnected(false) {
+    : mOwner(aOwner),
+      mCallback(&aCb),
+      mObserverType(ObserverTypeUndefined),
+      mConnected(false) {
   MOZ_ASSERT(mOwner);
   mPerformance = aOwner->GetPerformance();
 }
 
 PerformanceObserver::PerformanceObserver(WorkerPrivate* aWorkerPrivate,
                                          PerformanceObserverCallback& aCb)
-    : mCallback(&aCb), mConnected(false) {
+    : mCallback(&aCb), mObserverType(ObserverTypeUndefined), mConnected(false) {
   MOZ_ASSERT(aWorkerPrivate);
   mPerformance = aWorkerPrivate->GlobalScope()->GetPerformance();
 }
@@ -116,85 +122,215 @@
 void PerformanceObserver::QueueEntry(PerformanceEntry* aEntry) {
   MOZ_ASSERT(aEntry);
 
-  nsAutoString entryType;
-  aEntry->GetEntryType(entryType);
-  if (!mEntryTypes.Contains<nsString>(entryType)) {
+  if (!ObservesTypeOfEntry(aEntry)) {
     return;
   }
-
   mQueuedEntries.AppendElement(aEntry);
 }
 
+/*
+ * Keep this list in alphabetical order.
+ * https://w3c.github.io/performance-timeline/#supportedentrytypes-attribute
+ */
 static const char16_t* const sValidTypeNames[4] = {
-    u"navigation",
     u"mark",
     u"measure",
+    u"navigation",
     u"resource",
 };
 
-void PerformanceObserver::Observe(const PerformanceObserverInit& aOptions) {
-  if (aOptions.mEntryTypes.IsEmpty()) {
+void PerformanceObserver::ReportUnsupportedTypesErrorToConsole(
+    bool aIsMainThread, const char* msgId, const nsString& aInvalidTypes) {
+  if (!aIsMainThread) {
+    nsTArray<nsString> params;
+    params.AppendElement(aInvalidTypes);
+    WorkerPrivate::ReportErrorToConsole(msgId, params);
+  } else {
+    nsCOMPtr<nsPIDOMWindowInner> ownerWindow = do_QueryInterface(mOwner);
+    Document* document = ownerWindow->GetExtantDoc();
+    const char16_t* params[] = {aInvalidTypes.get()};
+    nsContentUtils::ReportToConsole(
+        nsIScriptError::warningFlag, NS_LITERAL_CSTRING("DOM"), document,
+        nsContentUtils::eDOM_PROPERTIES, msgId, params, 1);
+  }
+  return;
+}
+
+void PerformanceObserver::Observe(const PerformanceObserverInit& aOptions,
+                                  ErrorResult& aRv) {
+  const Optional<Sequence<nsString>>& maybeEntryTypes = aOptions.mEntryTypes;
+  const Optional<nsString>& maybeType = aOptions.mType;
+  const Optional<bool>& maybeBuffered = aOptions.mBuffered;
+
+  if (!maybeEntryTypes.WasPassed() && !maybeType.WasPassed()) {
+    /* Per spec (3.3.1.2), this should be a syntax error. */
+    aRv.Throw(NS_ERROR_DOM_SYNTAX_ERR);
     return;
   }
 
-  nsTArray<nsString> validEntryTypes;
+  if (maybeEntryTypes.WasPassed() &&
+      (maybeType.WasPassed() || maybeBuffered.WasPassed())) {
+    /* Per spec (3.3.1.3), this, too, should be a syntax error. */
+    aRv.Throw(NS_ERROR_DOM_SYNTAX_ERR);
+    return;
+  }
 
-  for (const char16_t* name : sValidTypeNames) {
-    nsDependentString validTypeName(name);
-    if (aOptions.mEntryTypes.Contains<nsString>(validTypeName) &&
-        !validEntryTypes.Contains<nsString>(validTypeName)) {
-      validEntryTypes.AppendElement(validTypeName);
+  /* 3.3.1.4.1 */
+  if (mObserverType == ObserverTypeUndefined) {
+    if (maybeEntryTypes.WasPassed()) {
+      mObserverType = ObserverTypeMultiple;
+    } else {
+      mObserverType = ObserverTypeSingle;
     }
   }
 
-  nsAutoString invalidTypesJoined;
-  bool addComma = false;
-  for (const auto& type : aOptions.mEntryTypes) {
-    if (!validEntryTypes.Contains<nsString>(type)) {
-      if (addComma) {
-        invalidTypesJoined.AppendLiteral(", ");
-      }
-      addComma = true;
-      invalidTypesJoined.Append(type);
-    }
+  /* 3.3.1.4.2 */
+  if (mObserverType == ObserverTypeSingle && maybeEntryTypes.WasPassed()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_MODIFICATION_ERR);
+    return;
   }
-
-  if (!invalidTypesJoined.IsEmpty()) {
-    if (!NS_IsMainThread()) {
-      nsTArray<nsString> params;
-      params.AppendElement(invalidTypesJoined);
-      WorkerPrivate::ReportErrorToConsole("UnsupportedEntryTypesIgnored",
-                                          params);
-    } else {
-      nsCOMPtr<nsPIDOMWindowInner> ownerWindow = do_QueryInterface(mOwner);
-      Document* document = ownerWindow->GetExtantDoc();
-      const char16_t* params[] = {invalidTypesJoined.get()};
-      nsContentUtils::ReportToConsole(
-          nsIScriptError::warningFlag, NS_LITERAL_CSTRING("DOM"), document,
-          nsContentUtils::eDOM_PROPERTIES, "UnsupportedEntryTypesIgnored",
-          params, 1);
-    }
-  }
-
-  if (validEntryTypes.IsEmpty()) {
+  /* 3.3.1.4.3 */
+  if (mObserverType == ObserverTypeMultiple && maybeType.WasPassed()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_MODIFICATION_ERR);
     return;
   }
 
-  mEntryTypes.SwapElements(validEntryTypes);
+  /* 3.3.1.5 */
+  if (mObserverType == ObserverTypeMultiple) {
+    const Sequence<nsString>& entryTypes = maybeEntryTypes.Value();
+
+    if (entryTypes.IsEmpty()) {
+      return;
+    }
+
+    /* 3.3.1.5.2 */
+    nsTArray<nsString> validEntryTypes;
+    for (const char16_t* name : sValidTypeNames) {
+      nsDependentString validTypeName(name);
+      if (entryTypes.Contains<nsString>(validTypeName) &&
+          !validEntryTypes.Contains<nsString>(validTypeName)) {
+        validEntryTypes.AppendElement(validTypeName);
+      }
+    }
 
-  mPerformance->AddObserver(this);
+    nsAutoString invalidTypesJoined;
+    bool addComma = false;
+    for (const auto& type : entryTypes) {
+      if (!validEntryTypes.Contains<nsString>(type)) {
+        if (addComma) {
+          invalidTypesJoined.AppendLiteral(", ");
+        }
+        addComma = true;
+        invalidTypesJoined.Append(type);
+      }
+    }
+
+    if (!invalidTypesJoined.IsEmpty()) {
+      ReportUnsupportedTypesErrorToConsole(NS_IsMainThread(),
+                                           UnsupportedEntryTypesIgnoredMsgId,
+                                           invalidTypesJoined);
+    }
+
+    /* 3.3.1.5.3 */
+    if (validEntryTypes.IsEmpty()) {
+      nsString errorString;
+      ReportUnsupportedTypesErrorToConsole(
+          NS_IsMainThread(), AllEntryTypesIgnoredMsgId, errorString);
+      return;
+    }
 
-  if (aOptions.mBuffered) {
-    for (auto entryType : mEntryTypes) {
+    /*
+     * Registered or not, we clear out the list of options, and start fresh
+     * with the one that we are using here. (3.3.1.5.4,5)
+     */
+    mOptions.Clear();
+    mOptions.AppendElement(aOptions);
+
+  } else {
+    MOZ_ASSERT(mObserverType == ObserverTypeSingle);
+    bool typeValid = false;
+    nsString type = maybeType.Value();
+
+    /* 3.3.1.6.2 */
+    for (const char16_t* name : sValidTypeNames) {
+      nsDependentString validTypeName(name);
+      if (type == validTypeName) {
+        typeValid = true;
+        break;
+      }
+    }
+
+    if (!typeValid) {
+      ReportUnsupportedTypesErrorToConsole(
+          NS_IsMainThread(), UnsupportedEntryTypesIgnoredMsgId, type);
+      return;
+    }
+
+    /* 3.3.1.6.4, 3.3.1.6.4 */
+    bool didUpdateOptionsList = false;
+    nsTArray<PerformanceObserverInit> updatedOptionsList;
+    for (auto& option : mOptions) {
+      if (option.mType.WasPassed() && option.mType.Value() == type) {
+        updatedOptionsList.AppendElement(aOptions);
+        didUpdateOptionsList = true;
+      } else {
+        updatedOptionsList.AppendElement(option);
+      }
+    }
+    if (!didUpdateOptionsList) {
+      updatedOptionsList.AppendElement(aOptions);
+    }
+    mOptions.SwapElements(updatedOptionsList);
+
+    /* 3.3.1.6.5 */
+    if (maybeBuffered.WasPassed() && maybeBuffered.Value()) {
       nsTArray<RefPtr<PerformanceEntry>> existingEntries;
-      mPerformance->GetEntriesByType(entryType, existingEntries);
+      mPerformance->GetEntriesByType(type, existingEntries);
       if (!existingEntries.IsEmpty()) {
         mQueuedEntries.AppendElements(existingEntries);
       }
     }
   }
+  /* Add ourselves to the list of registered performance
+   * observers, if necessary. (3.3.1.5.4,5; 3.3.1.6.4)
+   */
+  mPerformance->AddObserver(this);
+  mConnected = true;
+}
 
-  mConnected = true;
+void PerformanceObserver::GetSupportedEntryTypes(
+    const GlobalObject& aGlobal, JS::MutableHandle<JSObject*> aObject) {
+  nsTArray<nsString> validTypes;
+  JS::Rooted<JS::Value> val(aGlobal.Context());
+
+  for (const char16_t* name : sValidTypeNames) {
+    nsString validTypeName(name);
+    validTypes.AppendElement(validTypeName);
+  }
+
+  if (!ToJSValue(aGlobal.Context(), validTypes, &val)) {
+    /*
+     * If this conversion fails, we don't set a result.
+     * The spec does not allow us to throw an exception.
+     */
+    return;
+  }
+  aObject.set(&val.toObject());
+}
+
+bool PerformanceObserver::ObservesTypeOfEntry(PerformanceEntry* aEntry) {
+  for (auto& option : mOptions) {
+    if (option.mType.WasPassed()) {
+      if (option.mType.Value() == aEntry->GetEntryType()) {
+        return true;
+      }
+    } else {
+      if (option.mEntryTypes.Value().Contains(aEntry->GetEntryType())) {
+        return true;
+      }
+    }
+  }
+  return false;
 }
 
 void PerformanceObserver::Disconnect() {