# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: browser/components/newtab/content-src/activity-stream.jsx
# Commit: 7ec776d31a2c
# Full Hash: 7ec776d31a2c6e0ffc1e5ee311d63993317ea7ca
# Author: Mike Conley <mconley@mozilla.com>
# Date: 2020-04-17 21:46:50
# Regressor Bug: 1614502
# File Overlap Count: 1
# Description:
#   Bug 1614502 - Expose utility functions for rendering Activity Stream. r=Mardak
#   
#   These will be used by a later patch inside of a ChromeWorker using
#   ReactDOMServer.
#   
# ==============================================================================

diff -r 8bf3fe111c40 -r 7ec776d31a2c browser/components/newtab/content-src/activity-stream.jsx
--- a/browser/components/newtab/content-src/activity-stream.jsx	Fri Apr 17 15:31:06 2020 +0000
+++ b/browser/components/newtab/content-src/activity-stream.jsx	Fri Apr 17 15:31:11 2020 +0000
@@ -11,38 +11,56 @@
 import ReactDOM from "react-dom";
 import { reducers } from "common/Reducers.jsm";
 
-const store = initStore(reducers);
+export const NewTab = ({ store, isFirstrun }) => (
+  <Provider store={store}>
+    <Base isFirstrun={isFirstrun} />
+  </Provider>
+);
 
-new DetectUserSessionStart(store).sendEventOrAddListener();
+export function renderWithoutState() {
+  const store = initStore(reducers);
+  new DetectUserSessionStart(store).sendEventOrAddListener();
 
-// If this document has already gone into the background by the time we've reached
-// here, we can deprioritize requesting the initial state until the event loop
-// frees up. If, however, the visibility changes, we then send the request.
-let didRequest = false;
-let requestIdleCallbackId = 0;
-function doRequest() {
-  if (!didRequest) {
-    if (requestIdleCallbackId) {
-      cancelIdleCallback(requestIdleCallbackId);
+  // If this document has already gone into the background by the time we've reached
+  // here, we can deprioritize requesting the initial state until the event loop
+  // frees up. If, however, the visibility changes, we then send the request.
+  let didRequest = false;
+  let requestIdleCallbackId = 0;
+  function doRequest() {
+    if (!didRequest) {
+      if (requestIdleCallbackId) {
+        cancelIdleCallback(requestIdleCallbackId);
+      }
+      didRequest = true;
+      store.dispatch(ac.AlsoToMain({ type: at.NEW_TAB_STATE_REQUEST }));
     }
-    didRequest = true;
-    store.dispatch(ac.AlsoToMain({ type: at.NEW_TAB_STATE_REQUEST }));
+  }
+
+  if (document.hidden) {
+    requestIdleCallbackId = requestIdleCallback(doRequest);
+    addEventListener("visibilitychange", doRequest, { once: true });
+  } else {
+    doRequest();
   }
+
+  ReactDOM.hydrate(
+    <NewTab
+      store={store}
+      isFirstrun={global.document.location.href === "about:welcome"}
+    />,
+    document.getElementById("root")
+  );
 }
 
-if (document.hidden) {
-  requestIdleCallbackId = requestIdleCallback(doRequest);
-  addEventListener("visibilitychange", doRequest, { once: true });
-} else {
-  doRequest();
-}
+export function renderCache(initialState) {
+  const store = initStore(reducers, initialState);
+  new DetectUserSessionStart(store).sendEventOrAddListener();
 
-ReactDOM.hydrate(
-  <Provider store={store}>
-    <Base
+  ReactDOM.hydrate(
+    <NewTab
+      store={store}
       isFirstrun={global.document.location.href === "about:welcome"}
-      strings={global.gActivityStreamStrings}
-    />
-  </Provider>,
-  document.getElementById("root")
-);
+    />,
+    document.getElementById("root")
+  );
+}