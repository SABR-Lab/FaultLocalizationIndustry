# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: 1bdbc884e289
# Full Hash: 1bdbc884e289f2656391c85a1fb35126c4e21ad8
# Author: Perry Jiang <perry@mozilla.com>
# Date: 2020-07-15 16:06:28
# Description:
#   Bug 1632036 - check for null global when freezing/thawing WorkerPrivate r=dom-workers-and-storage-reviewers,sg
#   
#   - Apply pointer guidelines to ClientSource getter.
#   - When freezing/thawing WorkerPrivate, check if the client/global is null. It seems possible that the client is null because the WorkerPrivate can remain registered to the RuntimeService even if it failed to create its global, and freezing/thawing is done through the RuntimeService. The other two callsites to get the client won't execute unless CompileScriptRunnable successfully creates the client.
#   
# ==============================================================================

diff -r 4e76e9b8d9e5 -r 1bdbc884e289 dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Wed Jul 15 04:40:08 2020 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Thu Jul 09 07:25:16 2020 +0000
@@ -1371,7 +1371,7 @@
   auto data = mWorkerThreadAccessible.Access();
   MOZ_ASSERT(data->mScope);
   if (mLoadInfo.mCSPInfo) {
-    data->mScope->GetClientSource()->SetCspInfo(*mLoadInfo.mCSPInfo);
+    data->mScope->MutableClientSourceRef().SetCspInfo(*mLoadInfo.mCSPInfo);
   }
 }
 
@@ -3229,10 +3229,7 @@
     }
   }
 
-  MOZ_ASSERT(data->mScope);
-  auto& clientSource = data->mScope->GetClientSource();
-  MOZ_DIAGNOSTIC_ASSERT(clientSource);
-  clientSource->WorkerExecutionReady(this);
+  data->mScope->MutableClientSourceRef().WorkerExecutionReady(this);
 }
 
 void WorkerPrivate::InitializeGCTimers() {
@@ -3594,14 +3591,13 @@
 
 bool WorkerPrivate::FreezeInternal() {
   auto data = mWorkerThreadAccessible.Access();
-  MOZ_ASSERT(data->mScope);
   NS_ASSERTION(!data->mFrozen, "Already frozen!");
 
   AutoYieldJSThreadExecution yield;
 
-  auto& clientSource = data->mScope->GetClientSource();
-  if (clientSource) {
-    clientSource->Freeze();
+  // The worker can freeze even if it failed to run (and doesn't have a global).
+  if (data->mScope) {
+    data->mScope->MutableClientSourceRef().Freeze();
   }
 
   data->mFrozen = true;
@@ -3615,7 +3611,6 @@
 
 bool WorkerPrivate::ThawInternal() {
   auto data = mWorkerThreadAccessible.Access();
-  MOZ_ASSERT(data->mScope);
   NS_ASSERTION(data->mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < data->mChildWorkers.Length(); index++) {
@@ -3624,9 +3619,9 @@
 
   data->mFrozen = false;
 
-  auto& clientSource = data->mScope->GetClientSource();
-  if (clientSource) {
-    clientSource->Thaw();
+  // The worker can thaw even if it failed to run (and doesn't have a global).
+  if (data->mScope) {
+    data->mScope->MutableClientSourceRef().Thaw();
   }
 
   return true;