# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: 2fd61eb5c69c
# Full Hash: 2fd61eb5c69ce9ac806048a35c7a7a88bf4b9652
# Author: Perry Jiang <perry@mozilla.com>
# Date: 2020-04-21 09:42:20
# Regressor Bug: 1618546
# File Overlap Count: 2
# Description:
#   Bug 1618546 - give worker debugger globals their own clients r=asuth,webidl,smaug
#   
#   - Worker debugger globals gets a client with a null principal
#   - Ensure globals are created before script loads
#   - Introduce WorkerGlobalScopeBase to share code
# ==============================================================================

diff -r 9ccf9f680b64 -r 2fd61eb5c69c dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Tue Apr 21 06:09:28 2020 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Tue Apr 21 06:50:53 2020 +0000
@@ -19,10 +19,8 @@
 #include "mozilla/ScopeExit.h"
 #include "mozilla/StaticPrefs_browser.h"
 #include "mozilla/StaticPrefs_dom.h"
-#include "mozilla/dom/BlobURLProtocolHandler.h"
 #include "mozilla/dom/CallbackDebuggerNotification.h"
 #include "mozilla/dom/ClientManager.h"
-#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/DOMTypes.h"
@@ -53,6 +51,7 @@
 #include "nsNetUtil.h"
 #include "nsIMemoryReporter.h"
 #include "nsIPermissionManager.h"
+#include "nsIProtocolHandler.h"
 #include "nsIScriptError.h"
 #include "nsIURI.h"
 #include "nsIURL.h"
@@ -77,7 +76,6 @@
 #include "WorkerNavigator.h"
 #include "WorkerRef.h"
 #include "WorkerRunnable.h"
-#include "WorkerScope.h"
 #include "WorkerThread.h"
 
 #include "nsThreadManager.h"
@@ -333,7 +331,9 @@
                          WorkerPrivate* aWorkerPrivate) override {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
-    if (NS_WARN_IF(!aWorkerPrivate->EnsureClientSource())) {
+    WorkerGlobalScope* globalScope =
+        aWorkerPrivate->GetOrCreateGlobalScope(aCx);
+    if (NS_WARN_IF(!globalScope)) {
       return false;
     }
 
@@ -354,15 +354,6 @@
       return false;
     }
 
-    WorkerGlobalScope* globalScope = aWorkerPrivate->GlobalScope();
-    if (NS_WARN_IF(!globalScope)) {
-      // We never got as far as calling GetOrCreateGlobalScope, or it failed.
-      // We have no way to enter a compartment, hence no sane way to report this
-      // error.  :(
-      rv.SuppressException();
-      return false;
-    }
-
     // Make sure to propagate exceptions from rv onto aCx, so that they will get
     // reported after we return.  We want to propagate just JS exceptions,
     // because all the other errors are handled when the script is loaded.
@@ -1377,8 +1368,9 @@
 
 void WorkerPrivate::StoreCSPOnClient() {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-  if (data->mClientSource && mLoadInfo.mCSPInfo) {
-    data->mClientSource->SetCspInfo(*mLoadInfo.mCSPInfo.get());
+  MOZ_ASSERT(data->mScope);
+  if (mLoadInfo.mCSPInfo) {
+    data->mScope->GetClientSource()->SetCspInfo(*mLoadInfo.mCSPInfo);
   }
 }
 
@@ -2545,7 +2537,7 @@
     loadInfo.mOriginAttributes = aParent->GetOriginAttributes();
     loadInfo.mServiceWorkersTestingInWindow =
         aParent->ServiceWorkersTestingInWindow();
-    loadInfo.mParentController = aParent->GetController();
+    loadInfo.mParentController = aParent->GlobalScope()->GetController();
     loadInfo.mWatchedByDevtools = aParent->IsWatchedByDevtools();
   } else {
     AssertIsOnMainThread();
@@ -2893,10 +2885,6 @@
 
       // If we're supposed to die then we should exit the loop.
       if (currentStatus == Killing) {
-        // The ClientSource should be cleared in NotifyInternal() when we reach
-        // or pass Canceling.
-        MOZ_DIAGNOSTIC_ASSERT(!data->mClientSource);
-
         // Flush uncaught rejections immediately, without
         // waiting for a next tick.
         PromiseDebugging::FlushUncaughtRejections();
@@ -3060,36 +3048,31 @@
   return mWorkerHybridEventTarget;
 }
 
-bool WorkerPrivate::EnsureClientSource() {
-  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-
-  if (data->mClientSource) {
-    return true;
-  }
-
-  ClientType type;
+ClientType WorkerPrivate::GetClientType() const {
   switch (Type()) {
     case WorkerTypeDedicated:
-      type = ClientType::Worker;
-      break;
+      return ClientType::Worker;
     case WorkerTypeShared:
-      type = ClientType::Sharedworker;
-      break;
+      return ClientType::Sharedworker;
     case WorkerTypeService:
-      type = ClientType::Serviceworker;
-      break;
+      return ClientType::Serviceworker;
     default:
       MOZ_CRASH("unknown worker type!");
   }
-
-  data->mClientSource = ClientManager::CreateSource(
-      type, mWorkerHybridEventTarget, GetPrincipalInfo());
-  MOZ_DIAGNOSTIC_ASSERT(data->mClientSource);
-
-  data->mClientSource->SetAgentClusterId(mAgentClusterId);
+}
+
+UniquePtr<ClientSource> WorkerPrivate::CreateClientSource() {
+  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
+  MOZ_ASSERT(!data->mScope, "Client should be created before the global");
+
+  auto clientSource = ClientManager::CreateSource(
+      GetClientType(), mWorkerHybridEventTarget, GetPrincipalInfo());
+  MOZ_DIAGNOSTIC_ASSERT(clientSource);
+
+  clientSource->SetAgentClusterId(mAgentClusterId);
 
   if (data->mFrozen) {
-    data->mClientSource->Freeze();
+    clientSource->Freeze();
   }
 
   // Shortly after the client is reserved we will try loading the main script
@@ -3112,10 +3095,10 @@
   // service worker.  So avoid the sync overhead here if we are starting a
   // service worker or a chrome worker.
   if (Type() != WorkerTypeService && !IsChromeWorker()) {
-    data->mClientSource->WorkerSyncPing(this);
-  }
-
-  return true;
+    clientSource->WorkerSyncPing(this);
+  }
+
+  return clientSource;
 }
 
 bool WorkerPrivate::EnsureCSPEventListener() {
@@ -3141,31 +3124,6 @@
   }
 }
 
-Maybe<ClientInfo> WorkerPrivate::GetClientInfo() const {
-  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-  Maybe<ClientInfo> clientInfo;
-  if (!data->mClientSource) {
-    MOZ_DIAGNOSTIC_ASSERT(mStatus >= Canceling);
-    return clientInfo;
-  }
-  clientInfo.emplace(data->mClientSource->Info());
-  return clientInfo;
-}
-
-const ClientState WorkerPrivate::GetClientState() const {
-  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-  MOZ_DIAGNOSTIC_ASSERT(data->mClientSource);
-  Result<ClientState, ErrorResult> res = data->mClientSource->SnapshotState();
-  if (res.isOk()) {
-    return res.unwrap();
-  }
-
-  // XXXbz Why is it OK to just ignore errors and return a default-initialized
-  // state here?
-  res.unwrapErr().SuppressException();
-  return ClientState();
-}
-
 bool WorkerPrivate::GetExecutionGranted() const {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
   return data->mJSThreadExecutionGranted;
@@ -3209,41 +3167,6 @@
   data->mExecutionManager = aManager;
 }
 
-const Maybe<ServiceWorkerDescriptor> WorkerPrivate::GetController() {
-  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-  {
-    MutexAutoLock lock(mMutex);
-    if (mStatus >= Canceling) {
-      return Maybe<ServiceWorkerDescriptor>();
-    }
-  }
-  MOZ_DIAGNOSTIC_ASSERT(data->mClientSource);
-  return data->mClientSource->GetController();
-}
-
-void WorkerPrivate::Control(const ServiceWorkerDescriptor& aServiceWorker) {
-  MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-  MOZ_DIAGNOSTIC_ASSERT(!IsChromeWorker());
-  MOZ_DIAGNOSTIC_ASSERT(Type() != WorkerTypeService);
-  {
-    MutexAutoLock lock(mMutex);
-    if (mStatus >= Canceling) {
-      return;
-    }
-  }
-  MOZ_DIAGNOSTIC_ASSERT(data->mClientSource);
-
-  if (IsBlobURI(mLoadInfo.mBaseURI)) {
-    // Blob URL workers can only become controlled by inheriting from
-    // their parent.  Make sure to note this properly.
-    data->mClientSource->InheritController(aServiceWorker);
-  } else {
-    // Otherwise this is a normal interception and we simply record the
-    // controller locally.
-    data->mClientSource->SetController(aServiceWorker);
-  }
-}
-
 void WorkerPrivate::ExecutionReady() {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
   {
@@ -3252,8 +3175,11 @@
       return;
     }
   }
-  MOZ_DIAGNOSTIC_ASSERT(data->mClientSource);
-  data->mClientSource->WorkerExecutionReady(this);
+
+  MOZ_ASSERT(data->mScope);
+  auto& clientSource = data->mScope->GetClientSource();
+  MOZ_DIAGNOSTIC_ASSERT(clientSource);
+  clientSource->WorkerExecutionReady(this);
 }
 
 void WorkerPrivate::InitializeGCTimers() {
@@ -3613,12 +3539,14 @@
 
 bool WorkerPrivate::FreezeInternal() {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
+  MOZ_ASSERT(data->mScope);
   NS_ASSERTION(!data->mFrozen, "Already frozen!");
 
   AutoYieldJSThreadExecution yield;
 
-  if (data->mClientSource) {
-    data->mClientSource->Freeze();
+  auto& clientSource = data->mScope->GetClientSource();
+  if (clientSource) {
+    clientSource->Freeze();
   }
 
   data->mFrozen = true;
@@ -3632,7 +3560,7 @@
 
 bool WorkerPrivate::ThawInternal() {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-
+  MOZ_ASSERT(data->mScope);
   NS_ASSERTION(data->mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < data->mChildWorkers.Length(); index++) {
@@ -3641,8 +3569,9 @@
 
   data->mFrozen = false;
 
-  if (data->mClientSource) {
-    data->mClientSource->Thaw();
+  auto& clientSource = data->mScope->GetClientSource();
+  if (clientSource) {
+    clientSource->Thaw();
   }
 
   return true;
@@ -4343,7 +4272,6 @@
 
     if (aStatus >= Canceling) {
       MutexAutoUnlock unlock(mMutex);
-      data->mClientSource.reset();
       if (data->mScope) {
         data->mScope->NoteTerminating();
       }
@@ -5080,33 +5008,33 @@
 WorkerGlobalScope* WorkerPrivate::GetOrCreateGlobalScope(JSContext* aCx) {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
 
-  if (!data->mScope) {
-    RefPtr<WorkerGlobalScope> globalScope;
-    if (IsSharedWorker()) {
-      globalScope = new SharedWorkerGlobalScope(this, WorkerName());
-    } else if (IsServiceWorker()) {
-      globalScope = new ServiceWorkerGlobalScope(
-          this, GetServiceWorkerRegistrationDescriptor());
-    } else {
-      globalScope = new DedicatedWorkerGlobalScope(this, WorkerName());
-    }
-
-    JS::Rooted<JSObject*> global(aCx);
-    NS_ENSURE_TRUE(globalScope->WrapGlobalObject(aCx, &global), nullptr);
-
-    JSAutoRealm ar(aCx, global);
-
-    // RegisterBindings() can spin a nested event loop so we have to set mScope
-    // before calling it, and we have to make sure to unset mScope if it fails.
-    data->mScope = std::move(globalScope);
-
-    if (!RegisterBindings(aCx, global)) {
-      data->mScope = nullptr;
-      return nullptr;
-    }
-
-    JS_FireOnNewGlobalObject(aCx, global);
-  }
+  if (data->mScope) {
+    return data->mScope;
+  }
+
+  if (IsSharedWorker()) {
+    data->mScope = new SharedWorkerGlobalScope(
+        WrapNotNull(this), CreateClientSource(), WorkerName());
+  } else if (IsServiceWorker()) {
+    data->mScope =
+        new ServiceWorkerGlobalScope(WrapNotNull(this), CreateClientSource(),
+                                     GetServiceWorkerRegistrationDescriptor());
+  } else {
+    data->mScope = new DedicatedWorkerGlobalScope(
+        WrapNotNull(this), CreateClientSource(), WorkerName());
+  }
+
+  JS::Rooted<JSObject*> global(aCx);
+  NS_ENSURE_TRUE(data->mScope->WrapGlobalObject(aCx, &global), nullptr);
+
+  JSAutoRealm ar(aCx, global);
+
+  if (!RegisterBindings(aCx, global)) {
+    data->mScope = nullptr;
+    return nullptr;
+  }
+
+  JS_FireOnNewGlobalObject(aCx, global);
 
   return data->mScope;
 }
@@ -5114,22 +5042,21 @@
 WorkerDebuggerGlobalScope* WorkerPrivate::CreateDebuggerGlobalScope(
     JSContext* aCx) {
   MOZ_ACCESS_THREAD_BOUND(mWorkerThreadAccessible, data);
-
   MOZ_ASSERT(!data->mDebuggerScope);
 
-  RefPtr<WorkerDebuggerGlobalScope> globalScope =
-      new WorkerDebuggerGlobalScope(this);
+  // The debugger global gets a dummy client, not the "real" client used by the
+  // debugee worker.
+  auto clientSource = ClientManager::CreateSource(
+      GetClientType(), HybridEventTarget(), NullPrincipalInfo());
+
+  data->mDebuggerScope =
+      new WorkerDebuggerGlobalScope(WrapNotNull(this), std::move(clientSource));
 
   JS::Rooted<JSObject*> global(aCx);
-  NS_ENSURE_TRUE(globalScope->WrapGlobalObject(aCx, &global), nullptr);
+  NS_ENSURE_TRUE(data->mDebuggerScope->WrapGlobalObject(aCx, &global), nullptr);
 
   JSAutoRealm ar(aCx, global);
 
-  // RegisterDebuggerBindings() can spin a nested event loop so we have to set
-  // mDebuggerScope before calling it, and we have to make sure to unset
-  // mDebuggerScope if it fails.
-  data->mDebuggerScope = std::move(globalScope);
-
   if (!RegisterDebuggerBindings(aCx, global)) {
     data->mDebuggerScope = nullptr;
     return nullptr;