# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerScope.cpp
# Commit: 2fd61eb5c69c
# Full Hash: 2fd61eb5c69ce9ac806048a35c7a7a88bf4b9652
# Author: Perry Jiang <perry@mozilla.com>
# Date: 2020-04-21 09:42:20
# Regressor Bug: 1618546
# File Overlap Count: 2
# Description:
#   Bug 1618546 - give worker debugger globals their own clients r=asuth,webidl,smaug
#   
#   - Worker debugger globals gets a client with a null principal
#   - Ensure globals are created before script loads
#   - Introduce WorkerGlobalScopeBase to share code
# ==============================================================================

diff -r 9ccf9f680b64 -r 2fd61eb5c69c dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp	Tue Apr 21 06:09:28 2020 +0000
+++ b/dom/workers/WorkerScope.cpp	Tue Apr 21 06:50:53 2020 +0000
@@ -6,58 +6,52 @@
 
 #include "WorkerScope.h"
 
+#include <utility>
+
+#include "Crypto.h"
+#include "Principal.h"
 #include "jsapi.h"
 #include "jsfriendapi.h"
-#include "mozilla/EventListenerManager.h"
+#include "mozilla/CycleCollectedJSContext.h"
+#include "mozilla/MozPromise.h"
+#include "mozilla/StorageAccess.h"
 #include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/BlobURLProtocolHandler.h"
+#include "mozilla/dom/CSPEvalChecker.h"
 #include "mozilla/dom/Clients.h"
-#include "mozilla/dom/ClientState.h"
-#include "mozilla/dom/Console.h"
-#include "mozilla/dom/CSPEvalChecker.h"
 #include "mozilla/dom/DOMMozPromiseRequestHolder.h"
 #include "mozilla/dom/DebuggerNotification.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/Fetch.h"
-#include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IDBFactory.h"
 #include "mozilla/dom/ImageBitmap.h"
-#include "mozilla/dom/ImageBitmapBinding.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
+#include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerRegistration.h"
 #include "mozilla/dom/ServiceWorkerUtils.h"
 #include "mozilla/dom/SharedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/SimpleGlobalObject.h"
-#include "mozilla/dom/TimeoutHandler.h"
+#include "mozilla/dom/WorkerCommon.h"
 #include "mozilla/dom/WorkerDebuggerGlobalScopeBinding.h"
-#include "mozilla/dom/JSExecutionManager.h"
 #include "mozilla/dom/WorkerGlobalScopeBinding.h"
 #include "mozilla/dom/WorkerLocation.h"
 #include "mozilla/dom/WorkerNavigator.h"
+#include "mozilla/dom/WorkerRunnable.h"
 #include "mozilla/dom/cache/CacheStorage.h"
-#include "mozilla/StorageAccess.h"
-#include "GeckoProfiler.h"
-#include "nsContentUtils.h"
+#include "nsAtom.h"
+#include "nsDebug.h"
+#include "nsISerialEventTarget.h"
 #include "nsJSUtils.h"
-#include "nsServiceManagerUtils.h"
-
-#include "mozilla/dom/Document.h"
-#include "nsIScriptError.h"
+#include "xpcpublic.h"
 
 #ifdef ANDROID
 #  include <android/log.h>
 #endif
 
-#include "Crypto.h"
-#include "Principal.h"
-#include "RuntimeService.h"
-#include "ScriptLoader.h"
-#include "WorkerPrivate.h"
-#include "WorkerRunnable.h"
-#include "mozilla/dom/ServiceWorkerManager.h"
-#include "mozilla/dom/ServiceWorkerRegistration.h"
-
 #ifdef XP_WIN
 #  undef PostMessage
 #endif
@@ -66,6 +60,7 @@
 namespace dom {
 
 using mozilla::dom::cache::CacheStorage;
+using mozilla::dom::workerinternals::NamedWorkerGlobalScopeMixin;
 using mozilla::ipc::PrincipalInfo;
 
 class WorkerScriptTimeoutHandler final : public ScriptTimeoutHandler {
@@ -114,78 +109,113 @@
   return true;
 };
 
-WorkerGlobalScope::WorkerGlobalScope(WorkerPrivate* aWorkerPrivate)
-    : mSerialEventTarget(aWorkerPrivate->HybridEventTarget()),
-      mWindowInteractionsAllowed(0),
-      mWorkerPrivate(aWorkerPrivate) {
+NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerGlobalScopeBase)
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(WorkerGlobalScopeBase,
+                                                  DOMEventTargetHelper)
+  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mConsole)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSerialEventTarget)
+  tmp->TraverseObjectsInGlobal(cb);
+  tmp->mWorkerPrivate->TraverseTimeouts(cb);
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(WorkerGlobalScopeBase,
+                                                DOMEventTargetHelper)
+  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mConsole)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSerialEventTarget)
+  tmp->UnlinkObjectsInGlobal();
+  tmp->mWorkerPrivate->UnlinkTimeouts();
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+
+NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(WorkerGlobalScopeBase,
+                                               DOMEventTargetHelper)
+  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
+NS_IMPL_CYCLE_COLLECTION_TRACE_END
+
+NS_IMPL_ADDREF_INHERITED(WorkerGlobalScopeBase, DOMEventTargetHelper)
+NS_IMPL_RELEASE_INHERITED(WorkerGlobalScopeBase, DOMEventTargetHelper)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WorkerGlobalScopeBase)
+  NS_INTERFACE_MAP_ENTRY(nsIGlobalObject)
+NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
+
+WorkerGlobalScopeBase::WorkerGlobalScopeBase(
+    NotNull<WorkerPrivate*> aWorkerPrivate,
+    UniquePtr<ClientSource> aClientSource)
+    : mWorkerPrivate(aWorkerPrivate),
+      mClientSource(std::move(aClientSource)),
+      mSerialEventTarget(aWorkerPrivate->HybridEventTarget()) {
   mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(mClientSource);
 
-  // We should always have an event target when the global is created.
-  MOZ_DIAGNOSTIC_ASSERT(mSerialEventTarget);
+  MOZ_DIAGNOSTIC_ASSERT(
+      mSerialEventTarget,
+      "There should be an event target when a worker global is created.");
 
   // In workers, each DETH must have an owner. Because the global scope doesn't
   // have one, let's set it as owner of itself.
   BindToOwner(static_cast<nsIGlobalObject*>(this));
 }
 
-WorkerGlobalScope::~WorkerGlobalScope() {
+JSObject* WorkerGlobalScopeBase::GetGlobalJSObject() {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  return GetWrapper();
+}
+
+JSObject* WorkerGlobalScopeBase::GetGlobalJSObjectPreserveColor() const {
   mWorkerPrivate->AssertIsOnWorkerThread();
+  return GetWrapperPreserveColor();
+}
+
+bool WorkerGlobalScopeBase::IsSharedMemoryAllowed() const {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  return mWorkerPrivate->IsSharedMemoryAllowed();
 }
 
-NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerGlobalScope)
-
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(WorkerGlobalScope,
-                                                  DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mConsole)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCrypto)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPerformance)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLocation)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mNavigator)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIndexedDB)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCacheStorage)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDebuggerNotificationManager)
-  tmp->TraverseObjectsInGlobal(cb);
-  tmp->mWorkerPrivate->TraverseTimeouts(cb);
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+void WorkerGlobalScopeBase::Control(
+    const ServiceWorkerDescriptor& aServiceWorker) {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(!mWorkerPrivate->IsChromeWorker());
+  MOZ_DIAGNOSTIC_ASSERT(mWorkerPrivate->Type() != WorkerTypeService);
 
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(WorkerGlobalScope,
-                                                DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mConsole)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCrypto)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mPerformance)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mLocation)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mNavigator)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mIndexedDB)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCacheStorage)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDebuggerNotificationManager)
-  tmp->UnlinkObjectsInGlobal();
-  tmp->mWorkerPrivate->UnlinkTimeouts();
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-
-NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(WorkerGlobalScope,
-                                               DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-NS_IMPL_CYCLE_COLLECTION_TRACE_END
-
-NS_IMPL_ADDREF_INHERITED(WorkerGlobalScope, DOMEventTargetHelper)
-NS_IMPL_RELEASE_INHERITED(WorkerGlobalScope, DOMEventTargetHelper)
-
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WorkerGlobalScope)
-  NS_INTERFACE_MAP_ENTRY(nsIGlobalObject)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
-NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
-
-JSObject* WorkerGlobalScope::WrapObject(JSContext* aCx,
-                                        JS::Handle<JSObject*> aGivenProto) {
-  MOZ_CRASH("We should never get here!");
+  if (IsBlobURI(mWorkerPrivate->GetBaseURI())) {
+    // Blob URL workers can only become controlled by inheriting from
+    // their parent.  Make sure to note this properly.
+    mClientSource->InheritController(aServiceWorker);
+  } else {
+    // Otherwise this is a normal interception and we simply record the
+    // controller locally.
+    mClientSource->SetController(aServiceWorker);
+  }
 }
 
-void WorkerGlobalScope::NoteTerminating() { StartDying(); }
+nsresult WorkerGlobalScopeBase::Dispatch(
+    TaskCategory aCategory, already_AddRefed<nsIRunnable>&& aRunnable) {
+  return EventTargetFor(aCategory)->Dispatch(std::move(aRunnable),
+                                             NS_DISPATCH_NORMAL);
+}
+
+nsISerialEventTarget* WorkerGlobalScopeBase::EventTargetFor(
+    TaskCategory) const {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  return mSerialEventTarget;
+}
 
-already_AddRefed<Console> WorkerGlobalScope::GetConsole(ErrorResult& aRv) {
+void WorkerGlobalScopeBase::Atob(const nsAString& aAtob, nsAString& aOut,
+                                 ErrorResult& aRv) const {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  aRv = nsContentUtils::Atob(aAtob, aOut);
+}
+
+void WorkerGlobalScopeBase::Btoa(const nsAString& aBtoa, nsAString& aOut,
+                                 ErrorResult& aRv) const {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  aRv = nsContentUtils::Btoa(aBtoa, aOut);
+}
+
+already_AddRefed<Console> WorkerGlobalScopeBase::GetConsole(ErrorResult& aRv) {
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   if (!mConsole) {
@@ -199,6 +229,39 @@
   return console.forget();
 }
 
+uint64_t WorkerGlobalScopeBase::WindowID() const {
+  return mWorkerPrivate->WindowID();
+}
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerGlobalScope)
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(WorkerGlobalScope,
+                                                  WorkerGlobalScopeBase)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCrypto)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPerformance)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLocation)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mNavigator)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIndexedDB)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCacheStorage)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDebuggerNotificationManager)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(WorkerGlobalScope,
+                                                WorkerGlobalScopeBase)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCrypto)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mPerformance)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mLocation)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mNavigator)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mIndexedDB)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCacheStorage)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDebuggerNotificationManager)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+
+NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED(WorkerGlobalScope,
+                                             WorkerGlobalScopeBase,
+                                             nsISupportsWeakReference)
+
 Crypto* WorkerGlobalScope::GetCrypto(ErrorResult& aError) {
   mWorkerPrivate->AssertIsOnWorkerThread();
 
@@ -211,7 +274,6 @@
 
 already_AddRefed<CacheStorage> WorkerGlobalScope::GetCaches(ErrorResult& aRv) {
   if (!mCacheStorage) {
-    MOZ_ASSERT(mWorkerPrivate);
     mCacheStorage = CacheStorage::CreateOnWorker(cache::DEFAULT_NAMESPACE, this,
                                                  mWorkerPrivate, aRv);
   }
@@ -231,9 +293,7 @@
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   if (!mLocation) {
-    WorkerPrivate::LocationInfo& info = mWorkerPrivate->GetLocationInfo();
-
-    mLocation = WorkerLocation::Create(info);
+    mLocation = WorkerLocation::Create(mWorkerPrivate->GetLocationInfo());
     MOZ_ASSERT(mLocation);
   }
 
@@ -407,18 +467,6 @@
   return mWorkerPrivate->CrossOriginIsolated();
 }
 
-void WorkerGlobalScope::Atob(const nsAString& aAtob, nsAString& aOutput,
-                             ErrorResult& aRv) const {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-  aRv = nsContentUtils::Atob(aAtob, aOutput);
-}
-
-void WorkerGlobalScope::Btoa(const nsAString& aBtoa, nsAString& aOutput,
-                             ErrorResult& aRv) const {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-  aRv = nsContentUtils::Btoa(aBtoa, aOutput);
-}
-
 void WorkerGlobalScope::Dump(const Optional<nsAString>& aString) const {
   mWorkerPrivate->AssertIsOnWorkerThread();
 
@@ -524,22 +572,6 @@
                              Some(gfx::IntRect(aSx, aSy, aSw, aSh)), aRv);
 }
 
-nsresult WorkerGlobalScope::Dispatch(
-    TaskCategory aCategory, already_AddRefed<nsIRunnable>&& aRunnable) {
-  return EventTargetFor(aCategory)->Dispatch(std::move(aRunnable),
-                                             NS_DISPATCH_NORMAL);
-}
-
-nsISerialEventTarget* WorkerGlobalScope::EventTargetFor(
-    TaskCategory aCategory) const {
-  return mSerialEventTarget;
-}
-
-AbstractThread* WorkerGlobalScope::AbstractMainThreadFor(
-    TaskCategory aCategory) {
-  MOZ_CRASH("AbstractMainThreadFor not supported for workers.");
-}
-
 mozilla::dom::DebuggerNotificationManager*
 WorkerGlobalScope::GetOrCreateDebuggerNotificationManager() {
   if (!mDebuggerNotificationManager) {
@@ -554,25 +586,7 @@
   return mDebuggerNotificationManager;
 }
 
-bool WorkerGlobalScope::IsSharedMemoryAllowed() const {
-  return mWorkerPrivate->IsSharedMemoryAllowed();
-}
-
-Maybe<ClientInfo> WorkerGlobalScope::GetClientInfo() const {
-  return mWorkerPrivate->GetClientInfo();
-}
-
-Maybe<ClientState> WorkerGlobalScope::GetClientState() const {
-  Maybe<ClientState> state;
-  state.emplace(mWorkerPrivate->GetClientState());
-  return state;
-}
-
-Maybe<ServiceWorkerDescriptor> WorkerGlobalScope::GetController() const {
-  return mWorkerPrivate->GetController();
-}
-
-RefPtr<mozilla::dom::ServiceWorkerRegistration>
+RefPtr<ServiceWorkerRegistration>
 WorkerGlobalScope::GetServiceWorkerRegistration(
     const ServiceWorkerRegistrationDescriptor& aDescriptor) const {
   mWorkerPrivate->AssertIsOnWorkerThread();
@@ -602,10 +616,6 @@
   return ref;
 }
 
-uint64_t WorkerGlobalScope::WindowID() const {
-  return mWorkerPrivate->WindowID();
-}
-
 void WorkerGlobalScope::FirstPartyStorageAccessGranted() {
   // Reset the IndexedDB factory.
   mIndexedDB = nullptr;
@@ -614,9 +624,27 @@
   mCacheStorage = nullptr;
 }
 
+bool WorkerGlobalScope::WindowInteractionAllowed() const {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  return mWindowInteractionsAllowed > 0;
+}
+
+void WorkerGlobalScope::AllowWindowInteraction() {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  mWindowInteractionsAllowed++;
+}
+
+void WorkerGlobalScope::ConsumeWindowInteraction() {
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(mWindowInteractionsAllowed);
+  mWindowInteractionsAllowed--;
+}
+
 DedicatedWorkerGlobalScope::DedicatedWorkerGlobalScope(
-    WorkerPrivate* aWorkerPrivate, const nsString& aName)
-    : WorkerGlobalScope(aWorkerPrivate), mName(aName) {}
+    NotNull<WorkerPrivate*> aWorkerPrivate,
+    UniquePtr<ClientSource> aClientSource, const nsString& aName)
+    : WorkerGlobalScope(aWorkerPrivate, std::move(aClientSource)),
+      NamedWorkerGlobalScopeMixin(aName) {}
 
 bool DedicatedWorkerGlobalScope::WrapGlobalObject(
     JSContext* aCx, JS::MutableHandle<JSObject*> aReflector) {
@@ -665,9 +693,11 @@
   mWorkerPrivate->CloseInternal();
 }
 
-SharedWorkerGlobalScope::SharedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate,
-                                                 const nsString& aName)
-    : WorkerGlobalScope(aWorkerPrivate), mName(aName) {}
+SharedWorkerGlobalScope::SharedWorkerGlobalScope(
+    NotNull<WorkerPrivate*> aWorkerPrivate,
+    UniquePtr<ClientSource> aClientSource, const nsString& aName)
+    : WorkerGlobalScope(aWorkerPrivate, std::move(aClientSource)),
+      NamedWorkerGlobalScopeMixin(aName) {}
 
 bool SharedWorkerGlobalScope::WrapGlobalObject(
     JSContext* aCx, JS::MutableHandle<JSObject*> aReflector) {
@@ -698,20 +728,19 @@
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerGlobalScope, WorkerGlobalScope)
 
 ServiceWorkerGlobalScope::ServiceWorkerGlobalScope(
-    WorkerPrivate* aWorkerPrivate,
+    NotNull<WorkerPrivate*> aWorkerPrivate,
+    UniquePtr<ClientSource> aClientSource,
     const ServiceWorkerRegistrationDescriptor& aRegistrationDescriptor)
-    : WorkerGlobalScope(aWorkerPrivate),
+    : WorkerGlobalScope(aWorkerPrivate, std::move(aClientSource)),
       mScope(NS_ConvertUTF8toUTF16(aRegistrationDescriptor.Scope()))
 
-      // Eagerly create the registration because we will need to receive updates
-      // about the state of the registration.  We can't wait until first access
-      // to start receiving these.
+      // Eagerly create the registration because we will need to receive
+      // updates about the state of the registration.  We can't wait until
+      // first access to start receiving these.
       ,
       mRegistration(
           GetOrCreateServiceWorkerRegistration(aRegistrationDescriptor)) {}
 
-ServiceWorkerGlobalScope::~ServiceWorkerGlobalScope() = default;
-
 bool ServiceWorkerGlobalScope::WrapGlobalObject(
     JSContext* aCx, JS::MutableHandle<JSObject*> aReflector) {
   mWorkerPrivate->AssertIsOnWorkerThread();
@@ -741,7 +770,6 @@
 }
 
 EventHandlerNonNull* ServiceWorkerGlobalScope::GetOnfetch() {
-  MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   return GetEventHandler(nsGkAtoms::onfetch);
@@ -782,35 +810,30 @@
 
 }  // anonymous namespace
 
+void ServiceWorkerGlobalScope::NoteFetchHandlerWasAdded() const {
+  if (mWorkerPrivate->WorkerScriptExecutedSuccessfully()) {
+    RefPtr<Runnable> r = new ReportFetchListenerWarningRunnable(mScope);
+    mWorkerPrivate->DispatchToMainThreadForMessaging(r.forget());
+  }
+  mWorkerPrivate->SetFetchHandlerWasAdded();
+}
+
 void ServiceWorkerGlobalScope::SetOnfetch(
     mozilla::dom::EventHandlerNonNull* aCallback) {
-  MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   if (aCallback) {
-    if (mWorkerPrivate->WorkerScriptExecutedSuccessfully()) {
-      RefPtr<Runnable> r = new ReportFetchListenerWarningRunnable(mScope);
-      mWorkerPrivate->DispatchToMainThreadForMessaging(r.forget());
-    }
-    mWorkerPrivate->SetFetchHandlerWasAdded();
+    NoteFetchHandlerWasAdded();
   }
   SetEventHandler(nsGkAtoms::onfetch, aCallback);
 }
 
 void ServiceWorkerGlobalScope::EventListenerAdded(nsAtom* aType) {
-  MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
 
-  if (aType != nsGkAtoms::onfetch) {
-    return;
+  if (aType == nsGkAtoms::onfetch) {
+    NoteFetchHandlerWasAdded();
   }
-
-  if (mWorkerPrivate->WorkerScriptExecutedSuccessfully()) {
-    RefPtr<Runnable> r = new ReportFetchListenerWarningRunnable(mScope);
-    mWorkerPrivate->DispatchToMainThreadForMessaging(r.forget());
-  }
-
-  mWorkerPrivate->SetFetchHandlerWasAdded();
 }
 
 namespace {
@@ -924,50 +947,6 @@
   return promise.forget();
 }
 
-WorkerDebuggerGlobalScope::WorkerDebuggerGlobalScope(
-    WorkerPrivate* aWorkerPrivate)
-    : mWorkerPrivate(aWorkerPrivate),
-      mSerialEventTarget(aWorkerPrivate->HybridEventTarget()) {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-
-  // We should always have an event target when the global is created.
-  MOZ_DIAGNOSTIC_ASSERT(mSerialEventTarget);
-
-  // In workers, each DETH must have an owner. Because the global scope doesn't
-  // have an owner, let's set it as owner of itself.
-  BindToOwner(static_cast<nsIGlobalObject*>(this));
-}
-
-WorkerDebuggerGlobalScope::~WorkerDebuggerGlobalScope() {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-}
-
-NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerDebuggerGlobalScope)
-
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(WorkerDebuggerGlobalScope,
-                                                  DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mConsole)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
-
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(WorkerDebuggerGlobalScope,
-                                                DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mConsole)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-
-NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(WorkerDebuggerGlobalScope,
-                                               DOMEventTargetHelper)
-  tmp->mWorkerPrivate->AssertIsOnWorkerThread();
-NS_IMPL_CYCLE_COLLECTION_TRACE_END
-
-NS_IMPL_ADDREF_INHERITED(WorkerDebuggerGlobalScope, DOMEventTargetHelper)
-NS_IMPL_RELEASE_INHERITED(WorkerDebuggerGlobalScope, DOMEventTargetHelper)
-
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WorkerDebuggerGlobalScope)
-  NS_INTERFACE_MAP_ENTRY(nsIGlobalObject)
-NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
-
 bool WorkerDebuggerGlobalScope::WrapGlobalObject(
     JSContext* aCx, JS::MutableHandle<JSObject*> aReflector) {
   mWorkerPrivate->AssertIsOnWorkerThread();
@@ -1108,22 +1087,6 @@
   console->SetConsoleEventHandler(aHandler);
 }
 
-already_AddRefed<Console> WorkerDebuggerGlobalScope::GetConsole(
-    ErrorResult& aRv) {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-
-  // Debugger console has its own console object.
-  if (!mConsole) {
-    mConsole = Console::Create(mWorkerPrivate->GetJSContext(), nullptr, aRv);
-    if (NS_WARN_IF(aRv.Failed())) {
-      return nullptr;
-    }
-  }
-
-  RefPtr<Console> console = mConsole;
-  return console.forget();
-}
-
 void WorkerDebuggerGlobalScope::Dump(JSContext* aCx,
                                      const Optional<nsAString>& aString) const {
   WorkerGlobalScope* scope = mWorkerPrivate->GetOrCreateGlobalScope(aCx);
@@ -1132,34 +1095,6 @@
   }
 }
 
-void WorkerDebuggerGlobalScope::Atob(const nsAString& aAtob, nsAString& aOutput,
-                                     ErrorResult& aRv) const {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-  aRv = nsContentUtils::Atob(aAtob, aOutput);
-}
-
-void WorkerDebuggerGlobalScope::Btoa(const nsAString& aBtoa, nsAString& aOutput,
-                                     ErrorResult& aRv) const {
-  mWorkerPrivate->AssertIsOnWorkerThread();
-  aRv = nsContentUtils::Btoa(aBtoa, aOutput);
-}
-
-nsresult WorkerDebuggerGlobalScope::Dispatch(
-    TaskCategory aCategory, already_AddRefed<nsIRunnable>&& aRunnable) {
-  return EventTargetFor(aCategory)->Dispatch(std::move(aRunnable),
-                                             NS_DISPATCH_NORMAL);
-}
-
-nsISerialEventTarget* WorkerDebuggerGlobalScope::EventTargetFor(
-    TaskCategory aCategory) const {
-  return mSerialEventTarget;
-}
-
-AbstractThread* WorkerDebuggerGlobalScope::AbstractMainThreadFor(
-    TaskCategory aCategory) {
-  MOZ_CRASH("AbstractMainThreadFor not supported for workers.");
-}
-
 bool IsWorkerGlobal(JSObject* object) {
   return IS_INSTANCE_OF(WorkerGlobalScope, object);
 }