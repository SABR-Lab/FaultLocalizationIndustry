# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/antitracking/ContentBlocking.cpp
# Commit: 414a605d677a
# Full Hash: 414a605d677a35d49a6c581bfe18921c694bd823
# Author: Dimi Lee <dlee@mozilla.com>
# Date: 2020-04-23 21:43:09
# Regressor Bug: 1616775
# File Overlap Count: 1
# Description:
#   Bug 1616775 - P2. Support getting principal and tracking origin by BrowsingContext. r=timhuang,baku
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D71011
# ==============================================================================

diff -r ae01b3db6250 -r 414a605d677a toolkit/components/antitracking/ContentBlocking.cpp
--- a/toolkit/components/antitracking/ContentBlocking.cpp	Thu Apr 23 14:24:56 2020 +0000
+++ b/toolkit/components/antitracking/ContentBlocking.cpp	Thu Apr 23 14:25:06 2020 +0000
@@ -57,44 +57,6 @@
   return aTopLevelInnerWindowId != 0;
 }
 
-bool GetParentPrincipalAndTrackingOrigin(
-    nsGlobalWindowInner* a3rdPartyTrackingWindow, uint32_t aBehavior,
-    nsIPrincipal** aTopLevelStoragePrincipal, nsACString& aTrackingOrigin,
-    nsIPrincipal** aTrackingPrincipal) {
-  // Now we need the principal and the origin of the parent window.
-  nsCOMPtr<nsIPrincipal> topLevelStoragePrincipal =
-      // Use the "top-level storage area principal" behaviour in reject tracker
-      // mode only.
-      (aBehavior == nsICookieService::BEHAVIOR_REJECT_TRACKER)
-          ? a3rdPartyTrackingWindow->GetTopLevelStorageAreaPrincipal()
-          : a3rdPartyTrackingWindow->GetTopLevelAntiTrackingPrincipal();
-  if (!topLevelStoragePrincipal) {
-    LOG(("No top-level storage area principal at hand"));
-    return false;
-  }
-
-  // Let's take the principal and the origin of the tracker.
-  nsCOMPtr<nsIPrincipal> trackingPrincipal =
-      a3rdPartyTrackingWindow->GetPrincipal();
-  if (NS_WARN_IF(!trackingPrincipal)) {
-    return false;
-  }
-
-  nsresult rv = trackingPrincipal->GetOriginNoSuffix(aTrackingOrigin);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return false;
-  }
-
-  if (aTopLevelStoragePrincipal) {
-    topLevelStoragePrincipal.forget(aTopLevelStoragePrincipal);
-  }
-
-  if (aTrackingPrincipal) {
-    trackingPrincipal.forget(aTrackingPrincipal);
-  }
-  return true;
-};
-
 bool GetTrackingOrigin(nsGlobalWindowInner* a3rdPartyTrackingWindow,
                        nsACString& aTrackingOrigin) {
   nsCOMPtr<nsIPrincipal> trackingPrincipal =
@@ -319,23 +281,28 @@
       return StorageAccessGrantPromise::CreateAndReject(false, __func__);
     }
 
-    if (!GetTopLevelWindowId(aParentContext, nsICookieService::BEHAVIOR_ACCEPT,
+    if (!GetTopLevelWindowId(aParentContext,
+                             // Don't request the ETP specific behaviour of
+                             // allowing only singly-nested iframes here,
+                             // because we are recording an allow permission.
+                             nsICookieService::BEHAVIOR_ACCEPT,
                              topLevelWindowId)) {
       LOG(("Error while retrieving the parent window id, bailing out early"));
       return StorageAccessGrantPromise::CreateAndReject(false, __func__);
     }
 
-    if (!GetParentPrincipalAndTrackingOrigin(
-            nsGlobalWindowInner::Cast(parentInnerWindow),
-            // Don't request the ETP specific behaviour of allowing only
-            // singly-nested iframes here, because we are recording an allow
-            // permission.
-            nsICookieService::BEHAVIOR_ACCEPT, nullptr, trackingOrigin,
-            getter_AddRefs(trackingPrincipal))) {
-      LOG(
-          ("Error while computing the parent principal and tracking origin, "
-           "bailing out early"));
-      return StorageAccessGrantPromise::CreateAndReject(false, __func__);
+    // TODO: This is not yet fission-compatible because when we are not
+    //       in-process, we can't get the principal and tracking origin.
+    //       This will be addressed in another patch.
+    if (aParentContext->IsInProcess()) {
+      if (!AntiTrackingUtils::GetPrincipalAndTrackingOrigin(
+              aParentContext, getter_AddRefs(trackingPrincipal),
+              trackingOrigin)) {
+        LOG(
+            ("Error while computing the parent principal and tracking origin, "
+             "bailing out early"));
+        return StorageAccessGrantPromise::CreateAndReject(false, __func__);
+      }
     }
   }
 
