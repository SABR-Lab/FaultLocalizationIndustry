# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/BrowsingContext.h
# Commit: 0a44c410b59b
# Full Hash: 0a44c410b59bbc54bfd80ce598562e4362961d7e
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-24 09:51:27
# Regressor Bug: 1580565
# File Overlap Count: 3
# Description:
#   Bug 1580565 - Part 4: Use WindowContext to manage BrowsingContext cached status, r=farre
#   
#   The existing infrastructure which stored cached BrowsingContexts on the
#   BrowsingContextGroup was added before WindowContexts were added, and can cause
#   racing issues with partially discarded trees during process switches.
# ==============================================================================

diff -r 20dbcfc9eacc -r 0a44c410b59b docshell/base/BrowsingContext.h
--- a/docshell/base/BrowsingContext.h	Thu Apr 23 21:52:44 2020 +0000
+++ b/docshell/base/BrowsingContext.h	Thu Apr 23 21:52:47 2020 +0000
@@ -11,6 +11,7 @@
 #include "mozilla/LinkedList.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/RefPtr.h"
+#include "mozilla/Span.h"
 #include "mozilla/Tuple.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingDeclarations.h"
@@ -32,6 +33,7 @@
 #include "nsILoadContext.h"
 
 class nsDocShellLoadState;
+class nsGlobalWindowInner;
 class nsGlobalWindowOuter;
 class nsILoadInfo;
 class nsIPrincipal;
@@ -149,8 +151,6 @@
  public:
   enum class Type { Chrome, Content };
 
-  using Children = nsTArray<RefPtr<BrowsingContext>>;
-
   static void Init();
   static LogModule* GetLog();
   static void CleanupContexts(uint64_t aProcessId);
@@ -186,7 +186,7 @@
   // `EnsureAttached()` must be called before the BrowsingContext is used for a
   // DocShell, BrowserParent, or BrowserBridgeChild.
   static already_AddRefed<BrowsingContext> CreateDetached(
-      BrowsingContext* aParent, BrowsingContext* aOpener,
+      nsGlobalWindowInner* aParent, BrowsingContext* aOpener,
       const nsAString& aName, Type aType);
 
   void EnsureAttached();
@@ -253,13 +253,6 @@
   // Prepare this BrowsingContext to leave the current process.
   void PrepareForProcessChange();
 
-  // Remove all children from the current BrowsingContext and cache
-  // them to allow them to be attached again.
-  void CacheChildren(bool aFromIPC = false);
-
-  // Restore cached browsing contexts.
-  void RestoreChildren(Children&& aChildren, bool aFromIPC = false);
-
   // Triggers a load in the process which currently owns this BrowsingContext.
   nsresult LoadURI(nsDocShellLoadState* aLoadState, bool aSetNavigating = false);
 
@@ -273,8 +266,7 @@
 
   void DisplayLoadError(const nsAString& aURI);
 
-  // Determine if the current BrowsingContext was 'cached' by the logic in
-  // CacheChildren.
+  // Determine if the current BrowsingContext is in the BFCache.
   bool IsCached();
 
   // Check that this browsing context is targetable for navigations (i.e. that
@@ -302,6 +294,10 @@
   }
   BrowsingContext* Top();
 
+  // NOTE: Unlike `GetEmbedderWindowGlobal`, `GetParentWindow` does not cross
+  // toplevel content browser boundaries.
+  WindowContext* GetParentWindow() const { return mParentWindow; }
+
   already_AddRefed<BrowsingContext> GetOpener() const {
     RefPtr<BrowsingContext> opener(Get(GetOpenerId()));
     if (!mIsDiscarded && opener && !opener->mIsDiscarded) {
@@ -342,8 +338,12 @@
 
   uint32_t SandboxFlags() { return GetSandboxFlags(); }
 
-  void GetChildren(Children& aChildren);
+  Span<RefPtr<BrowsingContext>> Children() const;
+  void GetChildren(nsTArray<RefPtr<BrowsingContext>>& aChildren);
 
+  const nsTArray<RefPtr<WindowContext>>& GetWindowContexts() {
+    return mWindowContexts;
+  }
   void GetWindowContexts(nsTArray<RefPtr<WindowContext>>& aWindows);
 
   void RegisterWindowContext(WindowContext* aWindow);
@@ -454,22 +454,17 @@
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(BrowsingContext)
   NS_DECL_NSILOADCONTEXT
 
-  const Children& GetChildren() { return mChildren; }
-  const nsTArray<RefPtr<WindowContext>>& GetWindowContexts() {
-    return mWindowContexts;
-  }
-
   // Perform a pre-order walk of this BrowsingContext subtree.
   void PreOrderWalk(const std::function<void(BrowsingContext*)>& aCallback) {
     aCallback(this);
-    for (auto& child : GetChildren()) {
+    for (auto& child : Children()) {
       child->PreOrderWalk(aCallback);
     }
   }
 
   // Perform an post-order walk of this BrowsingContext subtree.
   void PostOrderWalk(const std::function<void(BrowsingContext*)>& aCallback) {
-    for (auto& child : GetChildren()) {
+    for (auto& child : Children()) {
       child->PostOrderWalk(aCallback);
     }
 
@@ -486,7 +481,7 @@
   void Focus(CallerType aCallerType, ErrorResult& aError);
   void Blur(ErrorResult& aError);
   WindowProxyHolder GetFrames(ErrorResult& aError);
-  int32_t Length() const { return mChildren.Length(); }
+  int32_t Length() const { return Children().Length(); }
   Nullable<WindowProxyHolder> GetTop(ErrorResult& aError);
   void GetOpener(JSContext* aCx, JS::MutableHandle<JS::Value> aOpener,
                  ErrorResult& aError) const;
@@ -527,18 +522,26 @@
     // deserialized before other BrowsingContext in the BrowsingContextGroup
     // have been initialized.
     uint64_t mParentId = 0;
-    already_AddRefed<BrowsingContext> GetParent();
+    already_AddRefed<WindowContext> GetParent();
     already_AddRefed<BrowsingContext> GetOpener();
 
     uint64_t GetOpenerId() const { return mozilla::Get<IDX_OpenerId>(mFields); }
 
-    bool mCached = false;
     bool mWindowless = false;
     bool mUseRemoteTabs = false;
     bool mUseRemoteSubframes = false;
     OriginAttributes mOriginAttributes;
 
     FieldTuple mFields;
+
+    bool operator==(const IPCInitializer& aOther) const {
+      return mId == aOther.mId && mParentId == aOther.mParentId &&
+             mWindowless == aOther.mWindowless &&
+             mUseRemoteTabs == aOther.mUseRemoteTabs &&
+             mUseRemoteSubframes == aOther.mUseRemoteSubframes &&
+             mOriginAttributes == aOther.mOriginAttributes &&
+             mFields == aOther.mFields;
+    }
   };
 
   // Create an IPCInitializer object for this BrowsingContext.
@@ -569,7 +572,7 @@
 
  protected:
   virtual ~BrowsingContext();
-  BrowsingContext(BrowsingContext* aParent, BrowsingContextGroup* aGroup,
+  BrowsingContext(WindowContext* aParentWindow, BrowsingContextGroup* aGroup,
                   uint64_t aBrowsingContextId, Type aType,
                   FieldTuple&& aFields);
 
@@ -720,10 +723,11 @@
   const uint64_t mBrowsingContextId;
 
   RefPtr<BrowsingContextGroup> mGroup;
+  RefPtr<WindowContext> mParentWindow;
+  // NOTE: `mParent` must be the same as `mParentWindow->GetBrowsingContext()`
+  // at all times.
+  // FIXME: Consider removing this field?
   RefPtr<BrowsingContext> mParent;
-  // Note: BrowsingContext_Binding::ClearCachedChildrenValue must be called any
-  // time this array is mutated to keep the JS-exposed reflection in sync.
-  Children mChildren;
   nsCOMPtr<nsIDocShell> mDocShell;
 
   RefPtr<Element> mEmbedderElement;
@@ -832,7 +836,6 @@
 
 using BrowsingContextTransaction = BrowsingContext::BaseTransaction;
 using BrowsingContextInitializer = BrowsingContext::IPCInitializer;
-using BrowsingContextChildren = BrowsingContext::Children;
 using MaybeDiscardedBrowsingContext = MaybeDiscarded<BrowsingContext>;
 
 // Specialize the transaction object for every translation unit it's used in.