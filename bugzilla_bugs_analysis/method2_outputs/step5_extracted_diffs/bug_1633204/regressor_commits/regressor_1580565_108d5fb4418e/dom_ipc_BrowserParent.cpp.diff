# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/BrowserParent.cpp
# Commit: 108d5fb4418e
# Full Hash: 108d5fb4418e78e4dca0a746863e5784c6d80371
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-23 09:52:48
# Regressor Bug: 1580565
# File Overlap Count: 3
# Description:
#   Bug 1580565 - Part 4: Use WindowContext to manage BrowsingContext cached status, r=farre
#   
#   The existing infrastructure which stored cached BrowsingContexts on the
#   BrowsingContextGroup was added before WindowContexts were added, and can cause
#   racing issues with partially discarded trees during process switches.
# ==============================================================================

diff -r d8dea951a032 -r 108d5fb4418e dom/ipc/BrowserParent.cpp
--- a/dom/ipc/BrowserParent.cpp	Wed Apr 22 15:48:20 2020 +0000
+++ b/dom/ipc/BrowserParent.cpp	Wed Apr 22 15:48:17 2020 +0000
@@ -4066,56 +4066,19 @@
   if (mBrowsingContext->IsDiscarded()) {
     return;
   }
-
-  auto processId = Manager()->ChildID();
-  BrowsingContext* parent = mBrowsingContext->GetParent();
-  ContentParent* embedderProcess = parent->Canonical()->GetContentParent();
-  if (!embedderProcess) {
+  BrowserBridgeParent* bridge = GetBrowserBridgeParent();
+  if (!bridge || !bridge->CanSend()) {
     return;
   }
 
-  ContentParent* manager = Manager();
-  // Set the owner process of a browsing context belonging to a
-  // crashed process to the parent context's process, since
-  // we'll be showing the crashed page in that process.
-  mBrowsingContext->SetOwnerProcessId(embedderProcess->ChildID());
-
-  // Find all same process sub tree nodes and detach them, cache all
-  // other nodes in the sub tree.
-  mBrowsingContext->PostOrderWalk([&](auto* aContext) {
-    // By iterating in reverse we can deal with detach removing the child that
-    // we're currently on
-    for (auto it = aContext->GetChildren().rbegin();
-         it != aContext->GetChildren().rend(); it++) {
-      RefPtr<BrowsingContext> context = *it;
-      if (context->Canonical()->IsOwnedByProcess(processId)) {
-        // Hold a reference to `context` until the response comes back to
-        // ensure it doesn't die while messages relating to this context are
-        // in-flight.
-        auto resolve = [context](bool) {};
-        auto reject = [context](ResponseRejectReason) {};
-        context->Group()->EachOtherParent(manager, [&](auto* aParent) {
-          aParent->SendDetachBrowsingContext(context->Id(), resolve, reject);
-        });
-
-        context->Detach(/* aFromIPC */ true);
-      }
-    }
-
-    // Cache all the children not owned by crashing process. Note that
-    // all remaining children are out of process, which makes it ok to
-    // just cache.
-    aContext->Group()->EachOtherParent(manager, [&](auto* aParent) {
-      Unused << aParent->SendCacheBrowsingContextChildren(aContext);
-    });
-    aContext->CacheChildren(/* aFromIPC */ true);
-  });
-
-  MOZ_DIAGNOSTIC_ASSERT(!mBrowsingContext->GetChildren().Length());
+  // Set the owner process of the root context belonging to a crashed process to
+  // the embedding process, since we'll be showing the crashed page in that
+  // process.
+  mBrowsingContext->SetOwnerProcessId(bridge->Manager()->Manager()->ChildID());
+  mBrowsingContext->SetCurrentInnerWindowId(0);
+
   // Tell the browser bridge to show the subframe crashed page.
-  if (GetBrowserBridgeParent()) {
-    Unused << GetBrowserBridgeParent()->SendSubFrameCrashed(mBrowsingContext);
-  }
+  Unused << bridge->SendSubFrameCrashed(mBrowsingContext);
 }
 
 mozilla::ipc::IPCResult BrowserParent::RecvIsWindowSupportingProtectedMedia(