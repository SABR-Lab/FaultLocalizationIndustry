# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/ContentParent.cpp
# Commit: 593544f437fa
# Full Hash: 593544f437fa3ba3291c405aa28ab3589d21fb23
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-25 09:49:23
# Regressor Bug: 1580565
# File Overlap Count: 2
# Description:
#   Bug 1580565 - Part 6: Add a unique ID to each BrowsingContextGroup, r=kmag
#   
#   This allows us to explicitly specify BrowsingContextGroups when synchronizing
#   them. A major advantage of this is that it means we can handle an attempt to
#   create a BrowsingContext with a parent which the content process is unaware of,
# ==============================================================================

diff -r 68150e4a45af -r 593544f437fa dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp	Fri Apr 24 18:33:06 2020 +0000
+++ b/dom/ipc/ContentParent.cpp	Fri Apr 24 18:33:09 2020 +0000
@@ -586,8 +586,6 @@
 UniquePtr<SandboxBrokerPolicyFactory>
     ContentParent::sSandboxBrokerPolicyFactory;
 #endif
-StaticAutoPtr<nsTArray<RefPtr<BrowsingContextGroup>>>
-    ContentParent::sBrowsingContextGroupHolder;
 #if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
 StaticAutoPtr<std::vector<std::string>> ContentParent::sMacSandboxParams;
 #endif
@@ -646,9 +644,6 @@
   // child process
   sCanLaunchSubprocesses = true;
 
-  sBrowsingContextGroupHolder = new nsTArray<RefPtr<BrowsingContextGroup>>();
-  ClearOnShutdown(&sBrowsingContextGroupHolder);
-
   if (!XRE_IsParentProcess()) {
     return;
   }
@@ -5928,56 +5923,54 @@
   return IPC_OK();
 }
 
-mozilla::ipc::IPCResult ContentParent::RecvAttachBrowsingContext(
-    BrowsingContext::IPCInitializer&& aInit) {
+mozilla::ipc::IPCResult ContentParent::RecvCreateBrowsingContext(
+    uint64_t aGroupId, BrowsingContext::IPCInitializer&& aInit) {
   RefPtr<WindowGlobalParent> parent;
   if (aInit.mParentId != 0) {
     parent = WindowGlobalParent::GetByInnerWindowId(aInit.mParentId);
-    MOZ_RELEASE_ASSERT(parent, "Parent doesn't exist in parent process");
+    if (!parent) {
+      return IPC_FAIL(this, "Parent doesn't exist in parent process");
+    }
   }
 
   if (parent && parent->GetContentParent() != this) {
     // We're trying attach a child BrowsingContext to a parent
-    // BrowsingContext in another process. This is illegal since the
-    // only thing that could create that child BrowsingContext is a
-    // parent docshell in the same process as that BrowsingContext.
-    MOZ_DIAGNOSTIC_ASSERT(false,
-                          "Trying to attach to out of process parent context");
-
-    MOZ_LOG(BrowsingContext::GetLog(), LogLevel::Warning,
-            ("ParentIPC: Trying to attach to out of process parent context "
-             "0x%08" PRIx64,
-             aInit.mParentId));
-    return IPC_OK();
+    // WindowContext in another process. This is illegal since the
+    // only thing that could create that child BrowsingContext is the parent
+    // window's process.
+    return IPC_FAIL(this,
+                    "Must create BrowsingContext from the parent's process");
+  }
+
+  RefPtr<BrowsingContext> opener;
+  if (aInit.GetOpenerId() != 0) {
+    opener = BrowsingContext::Get(aInit.GetOpenerId());
+    if (!opener) {
+      return IPC_FAIL(this, "Opener doesn't exist in parent process");
+    }
   }
 
   RefPtr<BrowsingContext> child = BrowsingContext::Get(aInit.mId);
-  if (child && !child->IsCached()) {
-    // This is highly suspicious. BrowsingContexts should only be
-    // attached at most once, but finding one indicates that someone
-    // is doing something they shouldn't.
-    MOZ_DIAGNOSTIC_ASSERT(false,
-                          "Trying to attach already attached browsing context");
-
-    MOZ_LOG(BrowsingContext::GetLog(), LogLevel::Warning,
-            ("ParentIPC: Trying to attach already attached 0x%08" PRIx64
-             " to 0x%08" PRIx64,
-             aInit.mId, aInit.mParentId));
-    return IPC_OK();
-  }
-
-  if (!child) {
-    RefPtr<BrowsingContextGroup> group =
-        BrowsingContextGroup::Select(aInit.mParentId, aInit.GetOpenerId());
-    child = BrowsingContext::CreateFromIPC(std::move(aInit), group, this);
-  }
-
-  child->Attach(/* aFromIPC */ true);
-
-  child->Group()->EachOtherParent(this, [&](ContentParent* aParent) {
-    Unused << aParent->SendAttachBrowsingContext(child->GetIPCInitializer());
-  });
-
+  if (child) {
+    // This is highly suspicious. BrowsingContexts should only be created once,
+    // so finding one indicates that someone is doing something they shouldn't.
+    return IPC_FAIL(this, "A BrowsingContext with this ID already exists");
+  }
+
+  // Ensure that the passed-in BrowsingContextGroup is valid.
+  RefPtr<BrowsingContextGroup> group =
+      BrowsingContextGroup::GetOrCreate(aGroupId);
+  if (parent && parent->Group() != group) {
+    return IPC_FAIL(this, "Parent is not in the given group");
+  }
+  if (opener && opener->Group() != group) {
+    return IPC_FAIL(this, "Opener is not in the given group");
+  }
+  if (!parent && !opener && !group->Toplevels().IsEmpty()) {
+    return IPC_FAIL(this, "Unrelated context must be created in a new group");
+  }
+
+  BrowsingContext::CreateFromIPC(std::move(aInit), group, this);
   return IPC_OK();
 }
 
@@ -6007,28 +6000,21 @@
   return true;
 }
 
-mozilla::ipc::IPCResult ContentParent::RecvDetachBrowsingContext(
-    uint64_t aContextId, DetachBrowsingContextResolver&& aResolve) {
-  // NOTE: Immediately resolve the promise, as we've received the message. This
-  // will allow the content process to discard references to this BC.
+mozilla::ipc::IPCResult ContentParent::RecvDiscardBrowsingContext(
+    const MaybeDiscarded<BrowsingContext>& aContext,
+    DiscardBrowsingContextResolver&& aResolve) {
+  if (!aContext.IsNullOrDiscarded()) {
+    RefPtr<CanonicalBrowsingContext> context = aContext.get_canonical();
+    if (!CheckBrowsingContextEmbedder(context, "discard")) {
+      return IPC_FAIL(this, "Illegal Discard attempt");
+    }
+
+    context->Detach(/* aFromIPC */ true);
+  }
+
+  // Resolve the promise, as we've received and handled the message. This will
+  // allow the content process to fully-discard references to this BC.
   aResolve(true);
-
-  // NOTE: It's OK if we don't have this context anymore. It was just already
-  // detached, return.
-  RefPtr<CanonicalBrowsingContext> context =
-      CanonicalBrowsingContext::Get(aContextId);
-  if (!context || context->IsDiscarded()) {
-    MOZ_LOG(BrowsingContext::GetLog(), LogLevel::Debug,
-            ("ParentIPC: Trying to detach already detached"));
-    return IPC_OK();
-  }
-
-  if (!CheckBrowsingContextEmbedder(context, "detach")) {
-    return IPC_FAIL(this, "Illegal Detach() attempt");
-  }
-
-  context->Detach(/* aFromIPC */ true);
-
   return IPC_OK();
 }
 
@@ -6341,18 +6327,6 @@
   return IPC_OK();
 }
 
-/* static */
-void ContentParent::HoldBrowsingContextGroup(BrowsingContextGroup* aBCG) {
-  sBrowsingContextGroupHolder->AppendElement(aBCG);
-}
-
-/* static */
-void ContentParent::ReleaseBrowsingContextGroup(BrowsingContextGroup* aBCG) {
-  if (sBrowsingContextGroupHolder) {
-    sBrowsingContextGroupHolder->RemoveElement(aBCG);
-  }
-}
-
 void ContentParent::OnBrowsingContextGroupSubscribe(
     BrowsingContextGroup* aGroup) {
   MOZ_DIAGNOSTIC_ASSERT(aGroup);