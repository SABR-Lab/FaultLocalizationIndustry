# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/painting/nsImageRenderer.h
# Commit: 451701e88d92
# Full Hash: 451701e88d92935b77385235832865dabe8c2942
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2019-05-03 12:59:14
# Regressor Bug: 1547792
# File Overlap Count: 1
# Description:
#   Bug 1547792 - AspectRatio should be a single ratio, not a size. r=dholbert
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D29244
# ==============================================================================

diff -r 020e530d49b3 -r 451701e88d92 layout/painting/nsImageRenderer.h
--- a/layout/painting/nsImageRenderer.h	Wed Apr 24 19:36:17 2019 +0000
+++ b/layout/painting/nsImageRenderer.h	Thu May 02 23:28:21 2019 +0000
@@ -10,6 +10,7 @@
 #include "nsLayoutUtils.h"
 #include "nsStyleStruct.h"
 #include "Units.h"
+#include "mozilla/AspectRatio.h"
 
 class gfxDrawable;
 namespace mozilla {
@@ -31,20 +32,16 @@
 // of these then we can compute a concrete size, that is a width and height.
 struct CSSSizeOrRatio {
   CSSSizeOrRatio()
-      : mRatio(0, 0),
-        mWidth(0),
-        mHeight(0),
-        mHasWidth(false),
-        mHasHeight(false) {}
+      : mWidth(0), mHeight(0), mHasWidth(false), mHasHeight(false) {}
 
   bool CanComputeConcreteSize() const {
     return mHasWidth + mHasHeight + HasRatio() >= 2;
   }
   bool IsConcrete() const { return mHasWidth && mHasHeight; }
-  bool HasRatio() const { return mRatio.width > 0 && mRatio.height > 0; }
+  bool HasRatio() const { return !!mRatio; }
   bool IsEmpty() const {
     return (mHasWidth && mWidth <= 0) || (mHasHeight && mHeight <= 0) ||
-           mRatio.width <= 0 || mRatio.height <= 0;
+           !mRatio;
   }
 
   // CanComputeConcreteSize must return true when ComputeConcreteSize is
@@ -55,14 +52,14 @@
     mWidth = aWidth;
     mHasWidth = true;
     if (mHasHeight) {
-      mRatio = nsSize(mWidth, mHeight);
+      mRatio = AspectRatio::FromSize(mWidth, mHeight);
     }
   }
   void SetHeight(nscoord aHeight) {
     mHeight = aHeight;
     mHasHeight = true;
     if (mHasWidth) {
-      mRatio = nsSize(mWidth, mHeight);
+      mRatio = AspectRatio::FromSize(mWidth, mHeight);
     }
   }
   void SetSize(const nsSize& aSize) {
@@ -70,16 +67,16 @@
     mHeight = aSize.height;
     mHasWidth = true;
     mHasHeight = true;
-    mRatio = aSize;
+    mRatio = AspectRatio::FromSize(mWidth, mHeight);
   }
-  void SetRatio(const nsSize& aRatio) {
+  void SetRatio(const AspectRatio& aRatio) {
     MOZ_ASSERT(
         !mHasWidth || !mHasHeight,
         "Probably shouldn't be setting a ratio if we have a concrete size");
     mRatio = aRatio;
   }
 
-  nsSize mRatio;
+  AspectRatio mRatio;
   nscoord mWidth;
   nscoord mHeight;
   bool mHasWidth;
@@ -156,12 +153,10 @@
   /**
    * Compute the size of the rendered image using either the 'cover' or
    * 'contain' constraints (aFitType).
-   * aIntrinsicRatio may be an invalid ratio, that is one or both of its
-   * dimensions can be less than or equal to zero.
    */
-  static nsSize ComputeConstrainedSize(const nsSize& aConstrainingSize,
-                                       const nsSize& aIntrinsicRatio,
-                                       FitType aFitType);
+  static nsSize ComputeConstrainedSize(
+      const nsSize& aConstrainingSize,
+      const mozilla::AspectRatio& aIntrinsicRatio, FitType aFitType);
   /**
    * Compute the size of the rendered image (the concrete size) where no cover/
    * contain constraints are given. The 'default algorithm' from the CSS Image