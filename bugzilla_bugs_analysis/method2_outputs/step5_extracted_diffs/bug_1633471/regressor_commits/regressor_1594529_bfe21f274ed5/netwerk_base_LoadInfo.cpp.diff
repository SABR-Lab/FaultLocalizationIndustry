# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/LoadInfo.cpp
# Commit: bfe21f274ed5
# Full Hash: bfe21f274ed5a4630a3503bcb875fed04f90533c
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-04-16 03:00:04
# Regressor Bug: 1594529
# File Overlap Count: 1
# Description:
#   Bug 1594529 - Create LoadInfo for subdocuments directly in parent process with DocumentChannel. r=mattwoodrow,nika
#   
#   Currently, with Fission enabled we are not able to create a proper LoadInfo
#   object when doing a subdocument load because we do not have access to a loading
#   context if the load is happening inside of an OOP frame. To solve this problem,
# ==============================================================================

diff -r 29ff609063c2 -r bfe21f274ed5 netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp	Wed Apr 15 18:53:22 2020 +0000
+++ b/netwerk/base/LoadInfo.cpp	Wed Apr 15 18:53:06 2020 +0000
@@ -22,6 +22,7 @@
 #include "mozilla/StaticPrefs_network.h"
 #include "mozilla/StaticPrefs_security.h"
 #include "mozIThirdPartyUtil.h"
+#include "ThirdPartyUtil.h"
 #include "nsFrameLoader.h"
 #include "nsFrameLoaderOwner.h"
 #include "nsIContentSecurityPolicy.h"
@@ -38,6 +39,7 @@
 #include "nsQueryObject.h"
 #include "nsRedirectHistoryEntry.h"
 #include "nsSandboxFlags.h"
+#include "nsICookieService.h"
 
 using namespace mozilla::dom;
 
@@ -290,7 +292,6 @@
       }
     }
   }
-
   mOriginAttributes = mLoadingPrincipal->OriginAttributesRef();
 
   // We need to do this after inheriting the document's origin attributes
@@ -521,6 +522,195 @@
   mCookieJarSettings = CookieJarSettings::Create();
 }
 
+LoadInfo::LoadInfo(dom::CanonicalBrowsingContext* aBrowsingContext,
+                   nsIPrincipal* aTriggeringPrincipal,
+                   uint64_t aFrameOuterWindowID, nsSecurityFlags aSecurityFlags,
+                   uint32_t aSandboxFlags)
+    : mLoadingPrincipal(nullptr),
+      mTriggeringPrincipal(aTriggeringPrincipal),
+      mPrincipalToInherit(nullptr),
+      mClientInfo(Maybe<mozilla::dom::ClientInfo>()),
+      mController(Maybe<mozilla::dom::ServiceWorkerDescriptor>()),
+      mLoadingContext(nullptr),
+      mContextForTopLevelLoad(nullptr),
+      mSecurityFlags(aSecurityFlags),
+      mSandboxFlags(aSandboxFlags),
+      mTainting(LoadTainting::Basic),
+      mBlockAllMixedContent(false),
+      mUpgradeInsecureRequests(false),
+      mBrowserUpgradeInsecureRequests(false),
+      mBrowserWouldUpgradeInsecureRequests(false),
+      mForceAllowDataURI(false),
+      mAllowInsecureRedirectToDataURI(false),
+      mBypassCORSChecks(false),
+      mSkipContentPolicyCheckForWebRequest(false),
+      mOriginalFrameSrcLoad(false),
+      mForceInheritPrincipalDropped(false),
+      mInnerWindowID(0),
+      mOuterWindowID(0),
+      mParentOuterWindowID(0),
+      mTopOuterWindowID(0),
+      mFrameOuterWindowID(aFrameOuterWindowID),
+      mBrowsingContextID(0),
+      mFrameBrowsingContextID(0),
+      // annyG: we are mimicking the old LoadInfo since it has gone through
+      // security checks in the content and we wouldn't reach this point
+      // if the load got blocked earlier.
+      mInitialSecurityCheckDone(true),
+      mIsThirdPartyContext(false),
+      mIsFormSubmission(false),
+      mSendCSPViolationEvents(true),
+      mRequestBlockingReason(BLOCKING_REASON_NONE),
+      mForcePreflight(false),
+      mIsPreflight(false),
+      mLoadTriggeredFromExternal(false),
+      mServiceWorkerTaintingSynthesized(false),
+      mDocumentHasUserInteracted(false),
+      mDocumentHasLoaded(false),
+      mAllowListFutureDocumentsCreatedFromThisRedirectChain(false),
+      mSkipContentSniffing(false),
+      mHttpsOnlyStatus(nsILoadInfo::HTTPS_ONLY_UNINITIALIZED),
+      mAllowDeprecatedSystemRequests(false),
+      mParserCreatedScript(false),
+      mHasStoragePermission(false),
+      mIsFromProcessingFrameAttributes(false) {
+  RefPtr<WindowGlobalParent> embedderWGP =
+      aBrowsingContext->GetParentWindowGlobal();
+  BrowsingContext* embedderBC = embedderWGP->BrowsingContext();
+  MOZ_ASSERT(embedderBC);
+  nsTArray<nsCOMPtr<nsIPrincipal>> ancestorPrincipals;
+  nsTArray<uint64_t> ancestorOuterWindowIDs;
+  CanonicalBrowsingContext* ancestorBC = embedderBC->Canonical();
+  RefPtr<WindowGlobalParent> topLevelWGP = embedderWGP;
+
+  // Iterate over ancestor WindowGlobalParent's - collect principals and
+  // outer window IDs. Also note the top level WindowGlobalParent.
+  while (RefPtr<WindowGlobalParent> ancestorWGP =
+             ancestorBC->GetParentWindowGlobal()) {
+    nsCOMPtr<nsIPrincipal> parentPrincipal = ancestorWGP->DocumentPrincipal();
+    MOZ_ASSERT(parentPrincipal, "Ancestor principal is null");
+    ancestorPrincipals.AppendElement(parentPrincipal.forget());
+    ancestorOuterWindowIDs.AppendElement(ancestorWGP->OuterWindowId());
+    topLevelWGP = ancestorWGP;
+    ancestorBC = ancestorWGP->BrowsingContext();
+  }
+  mAncestorPrincipals = ancestorPrincipals;
+  mAncestorOuterWindowIDs = ancestorOuterWindowIDs;
+  MOZ_DIAGNOSTIC_ASSERT(mAncestorPrincipals.Length() ==
+                        mAncestorOuterWindowIDs.Length());
+
+  if (RefPtr<WindowGlobalParent> ancestorWGP =
+          embedderWGP->BrowsingContext()->GetParentWindowGlobal()) {
+    mParentOuterWindowID = ancestorWGP->OuterWindowId();
+  } else {
+    mParentOuterWindowID = embedderWGP->OuterWindowId();
+  }
+
+  // if the load is sandboxed, we can not also inherit the principal
+  if (mSandboxFlags & SANDBOXED_ORIGIN) {
+    mForceInheritPrincipalDropped =
+        (mSecurityFlags & nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL);
+    mSecurityFlags &= ~nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL;
+  }
+
+  const auto& maybeEmbedderElementType =
+      aBrowsingContext->GetEmbedderElementType();
+  MOZ_ASSERT(maybeEmbedderElementType.isSome());
+  auto embedderElementType = maybeEmbedderElementType.value();
+
+  // Assign same type as in nsDocShell::DetermineContentType.
+  // N.B. internal content policy type will never be TYPE_DOCUMENT
+  mInternalContentPolicyType = nsIContentPolicy::TYPE_INTERNAL_FRAME;
+  if (embedderElementType.EqualsLiteral("iframe")) {
+    mInternalContentPolicyType = nsIContentPolicy::TYPE_INTERNAL_IFRAME;
+  }
+
+  // Ensure that all network requests for a window client have the ClientInfo
+  // properly set.
+  mClientInfo = embedderWGP->GetClientInfo();
+  mLoadingPrincipal = embedderWGP->DocumentPrincipal();
+  ComputeIsThirdPartyContext(embedderWGP);
+
+  // When the element being loaded is a frame, we choose the frame's window
+  // for the window ID (see mInnerWindowID being set below) and the frame
+  // element's window as the parent window. This is the behavior that Chrome
+  // exposes to add-ons.
+  mOuterWindowID = embedderWGP->OuterWindowId();
+  mTopOuterWindowID = topLevelWGP->OuterWindowId();
+  mBrowsingContextID = embedderBC->Id();
+
+  // Let's inherit the cookie behavior and permission from the embedder
+  // document.
+  mCookieJarSettings = embedderWGP->CookieJarSettings();
+  if (embedderBC->IsContentSubframe()) {
+    mDocumentHasLoaded = false;
+  } else {
+    mDocumentHasLoaded = embedderWGP->DocumentHasLoaded();
+  }
+  if (topLevelWGP->BrowsingContext()->IsTop()) {
+    if (mCookieJarSettings) {
+      bool stopAtOurLevel = mCookieJarSettings->GetCookieBehavior() ==
+                            nsICookieService::BEHAVIOR_REJECT_TRACKER;
+      if (!stopAtOurLevel ||
+          topLevelWGP->OuterWindowId() != embedderWGP->OuterWindowId()) {
+        mTopLevelPrincipal = topLevelWGP->DocumentPrincipal();
+      }
+    }
+    if (embedderBC->IsContentSubframe()) {
+      // For resources within iframes, we actually want the
+      // top-level document's flag, not the iframe document's.
+      mDocumentHasLoaded = topLevelWGP->DocumentHasLoaded();
+    }
+  }
+
+  // The top-level-storage-area-principal is not null only for the first
+  // level of iframes (null for top-level contexts, and null for
+  // sub-iframes). If we are loading a sub-document resource, we must
+  // calculate what the top-level-storage-area-principal will be for the
+  // new context.
+  if (embedderBC->IsTop()) {
+    if (!Document::StorageAccessSandboxed(embedderWGP->SandboxFlags())) {
+      mTopLevelStorageAreaPrincipal = embedderWGP->DocumentPrincipal();
+    }
+
+    // If this is the first level iframe, embedder WindowGlobalParent's document
+    // principal is our top-level principal.
+    if (!mTopLevelPrincipal) {
+      mTopLevelPrincipal = embedderWGP->DocumentPrincipal();
+    }
+  }
+
+  mInnerWindowID = embedderWGP->InnerWindowId();
+  mFrameBrowsingContextID = aBrowsingContext->Id();
+  mDocumentHasUserInteracted = embedderWGP->DocumentHasUserInteracted();
+
+  // if the document forces all mixed content to be blocked, then we
+  // store that bit for all requests on the loadinfo.
+  mBlockAllMixedContent = embedderWGP->GetDocumentBlockAllMixedContent();
+
+  // if the document forces all requests to be upgraded from http to https,
+  // then we should do that for all requests. If it only forces preloads to be
+  // upgraded then we should enforce upgrade insecure requests only for
+  // preloads.
+  mUpgradeInsecureRequests = embedderWGP->GetDocumentUpgradeInsecureRequests();
+  mOriginAttributes = mLoadingPrincipal->OriginAttributesRef();
+
+  // We need to do this after inheriting the document's origin attributes
+  // above, in case the loading principal ends up being the system principal.
+  if (embedderBC->IsContent()) {
+    mOriginAttributes.SyncAttributesWithPrivateBrowsing(
+        embedderBC->UsePrivateBrowsing());
+  }
+
+  // For chrome BC, the mPrivateBrowsingId remains 0 even its
+  // UsePrivateBrowsing() is true, so we only update the mPrivateBrowsingId in
+  // origin attributes if the type of the BC is content.
+  if (embedderBC->IsChrome()) {
+    MOZ_ASSERT(mOriginAttributes.mPrivateBrowsingId == 0,
+               "chrome docshell shouldn't have mPrivateBrowsingId set.");
+  }
+}
+
 LoadInfo::LoadInfo(const LoadInfo& rhs)
     : mLoadingPrincipal(rhs.mLoadingPrincipal),
       mTriggeringPrincipal(rhs.mTriggeringPrincipal),
@@ -719,6 +909,21 @@
   util->IsThirdPartyWindow(aOuterWindow, nullptr, &mIsThirdPartyContext);
 }
 
+void LoadInfo::ComputeIsThirdPartyContext(dom::WindowGlobalParent* aGlobal) {
+  if (nsILoadInfo::GetExternalContentPolicyType() ==
+      nsIContentPolicy::TYPE_DOCUMENT) {
+    // Top-level loads are never third-party.
+    mIsThirdPartyContext = false;
+    return;
+  }
+
+  ThirdPartyUtil* thirdPartyUtil = ThirdPartyUtil::GetInstance();
+  if (!thirdPartyUtil) {
+    return;
+  }
+  thirdPartyUtil->IsThirdPartyGlobal(aGlobal, &mIsThirdPartyContext);
+}
+
 NS_IMPL_ISUPPORTS(LoadInfo, nsILoadInfo)
 
 already_AddRefed<nsILoadInfo> LoadInfo::Clone() const {