# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.cpp
# Commit: fbf55a44d7fb
# Full Hash: fbf55a44d7fb72908eeb5d041b70ce2c503a2532
# Author: Anny Gakhokidze <agakhokidze@mozilla.com>
# Date: 2020-04-15 04:09:17
# Regressor Bug: 1594529
# File Overlap Count: 1
# Description:
#   Bug 1594529 - Create LoadInfo for subdocuments directly in parent process with DocumentChannel. r=mattwoodrow,nika
#   
#   Currently, with Fission enabled we are not able to create a proper LoadInfo
#   object when doing a subdocument load because we do not have access to a loading
#   context if the load is happening inside of an OOP frame. To solve this problem,
# ==============================================================================

diff -r 4ba9a230586a -r fbf55a44d7fb netwerk/ipc/DocumentLoadListener.cpp
--- a/netwerk/ipc/DocumentLoadListener.cpp	Mon Apr 13 22:41:37 2020 +0000
+++ b/netwerk/ipc/DocumentLoadListener.cpp	Mon Apr 13 23:00:43 2020 +0000
@@ -40,6 +40,7 @@
 #include "nsIOService.h"
 #include "mozilla/dom/WindowGlobalParent.h"
 #include "mozilla/StaticPrefs_security.h"
+#include "nsICookieService.h"
 
 #ifdef ANDROID
 #  include "mozilla/widget/nsWindow.h"
@@ -259,9 +260,6 @@
 already_AddRefed<LoadInfo> DocumentLoadListener::CreateLoadInfo(
     CanonicalBrowsingContext* aBrowsingContext, nsDocShellLoadState* aLoadState,
     uint64_t aOuterWindowId) {
-  OriginAttributes attrs;
-  mLoadContext->GetOriginAttributes(attrs);
-
   // TODO: Block copied from nsDocShell::DoURILoad, refactor out somewhere
   bool inheritPrincipal = false;
 
@@ -291,22 +289,22 @@
     securityFlags |= nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL;
   }
 
+  if (aBrowsingContext->GetParent()) {
+    // Build LoadInfo for TYPE_SUBDOCUMENT
+    RefPtr<LoadInfo> loadInfo =
+        new LoadInfo(aBrowsingContext, aLoadState->TriggeringPrincipal(),
+                     aOuterWindowId, securityFlags, sandboxFlags);
+    return loadInfo.forget();
+  }
+  // Build LoadInfo for TYPE_DOCUMENT
+  OriginAttributes attrs;
+  mLoadContext->GetOriginAttributes(attrs);
   RefPtr<LoadInfo> loadInfo =
       new LoadInfo(aBrowsingContext, aLoadState->TriggeringPrincipal(), attrs,
                    aOuterWindowId, securityFlags, sandboxFlags);
   return loadInfo.forget();
 }
 
-already_AddRefed<WindowGlobalParent> GetParentEmbedderWindowGlobal(
-    CanonicalBrowsingContext* aBrowsingContext) {
-  RefPtr<WindowGlobalParent> parent =
-      aBrowsingContext->GetEmbedderWindowGlobal();
-  if (parent && parent->BrowsingContext() == aBrowsingContext->GetParent()) {
-    return parent.forget();
-  }
-  return nullptr;
-}
-
 // parent-process implementation of
 // nsGlobalWindowOuter::GetTopExcludingExtensionAccessibleContentFrames
 already_AddRefed<WindowGlobalParent>
@@ -314,8 +312,7 @@
     CanonicalBrowsingContext* aBrowsingContext, nsIURI* aURIBeingLoaded) {
   CanonicalBrowsingContext* bc = aBrowsingContext;
   RefPtr<WindowGlobalParent> prev;
-  while (RefPtr<WindowGlobalParent> parent =
-             GetParentEmbedderWindowGlobal(bc)) {
+  while (RefPtr<WindowGlobalParent> parent = bc->GetParentWindowGlobal()) {
     CanonicalBrowsingContext* parentBC = parent->BrowsingContext();
 
     nsIPrincipal* parentPrincipal = parent->DocumentPrincipal();
@@ -340,11 +337,10 @@
 }
 
 bool DocumentLoadListener::Open(
-    nsDocShellLoadState* aLoadState, class LoadInfo* aLoadInfo,
-    nsLoadFlags aLoadFlags, uint32_t aCacheKey, const uint64_t& aChannelId,
-    const TimeStamp& aAsyncOpenTime, nsDOMNavigationTiming* aTiming,
-    Maybe<ClientInfo>&& aInfo, uint64_t aOuterWindowId, bool aHasGesture,
-    nsresult* aRv) {
+    nsDocShellLoadState* aLoadState, nsLoadFlags aLoadFlags, uint32_t aCacheKey,
+    const uint64_t& aChannelId, const TimeStamp& aAsyncOpenTime,
+    nsDOMNavigationTiming* aTiming, Maybe<ClientInfo>&& aInfo,
+    uint64_t aOuterWindowId, bool aHasGesture, nsresult* aRv) {
   LOG(("DocumentLoadListener Open [this=%p, uri=%s]", this,
        aLoadState->URI()->GetSpecOrDefault().get()));
   RefPtr<CanonicalBrowsingContext> browsingContext =
@@ -353,19 +349,21 @@
   OriginAttributes attrs;
   mLoadContext->GetOriginAttributes(attrs);
 
+  RefPtr<WindowGlobalParent> embedderWGP =
+      browsingContext->GetParentWindowGlobal();
+  if (browsingContext->GetParent() && !embedderWGP) {
+    // this is a race, bug 1331295
+    NS_WARNING(
+        "We don't have an embedder WindowGlobalParent, probably because of a "
+        "race");
+    return false;
+  }
+
   // If this is a top-level load, then rebuild the LoadInfo from scratch,
   // since the goal is to be able to initiate loads in the parent, where the
   // content process won't have provided us with an existing one.
-  // TODO: Handle TYPE_SUBDOCUMENT LoadInfo construction, and stop passing
-  // aLoadInfo across IPC.
-  RefPtr<LoadInfo> loadInfo = aLoadInfo;
-  if (!browsingContext->GetParent()) {
-    // If we're a top level load, then we should have not got an existing
-    // LoadInfo, or if we did, it should be TYPE_DOCUMENT.
-    MOZ_ASSERT(!aLoadInfo || aLoadInfo->InternalContentPolicyType() ==
-                                 nsIContentPolicy::TYPE_DOCUMENT);
-    loadInfo = CreateLoadInfo(browsingContext, aLoadState, aOuterWindowId);
-  }
+  RefPtr<LoadInfo> loadInfo =
+      CreateLoadInfo(browsingContext, aLoadState, aOuterWindowId);
 
   if (!nsDocShell::CreateAndConfigureRealChannelForLoadState(
           browsingContext, aLoadState, loadInfo, mParentChannelListener,