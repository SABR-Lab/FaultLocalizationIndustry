# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/DeleteNodeTransaction.cpp
# Commit: 876b1031a6ae
# Full Hash: 876b1031a6ae41a87ed146976f279b96bde9c7f6
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-04-03 21:40:10
# Regressor Bug: 1619914
# File Overlap Count: 1
# Description:
#   Bug 1619914 - part 1: Make each transaction class grab their members with local variable before touching the DOM tree r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D69302
# ==============================================================================

diff -r 7f069649d6cf -r 876b1031a6ae editor/libeditor/DeleteNodeTransaction.cpp
--- a/editor/libeditor/DeleteNodeTransaction.cpp	Fri Apr 03 06:03:25 2020 +0300
+++ b/editor/libeditor/DeleteNodeTransaction.cpp	Fri Apr 03 01:38:22 2020 +0000
@@ -14,9 +14,9 @@
 
 // static
 already_AddRefed<DeleteNodeTransaction> DeleteNodeTransaction::MaybeCreate(
-    EditorBase& aEditorBase, nsINode& aNodeToDelete) {
+    EditorBase& aEditorBase, nsIContent& aContentToDelete) {
   RefPtr<DeleteNodeTransaction> transaction =
-      new DeleteNodeTransaction(aEditorBase, aNodeToDelete);
+      new DeleteNodeTransaction(aEditorBase, aContentToDelete);
   if (NS_WARN_IF(!transaction->CanDoIt())) {
     return nullptr;
   }
@@ -24,14 +24,14 @@
 }
 
 DeleteNodeTransaction::DeleteNodeTransaction(EditorBase& aEditorBase,
-                                             nsINode& aNodeToDelete)
+                                             nsIContent& aContentToDelete)
     : mEditorBase(&aEditorBase),
-      mNodeToDelete(&aNodeToDelete),
-      mParentNode(aNodeToDelete.GetParentNode()) {}
+      mContentToDelete(&aContentToDelete),
+      mParentNode(aContentToDelete.GetParentNode()) {}
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(DeleteNodeTransaction, EditTransactionBase,
-                                   mEditorBase, mNodeToDelete, mParentNode,
-                                   mRefNode)
+                                   mEditorBase, mContentToDelete, mParentNode,
+                                   mRefContent)
 
 NS_IMPL_ADDREF_INHERITED(DeleteNodeTransaction, EditTransactionBase)
 NS_IMPL_RELEASE_INHERITED(DeleteNodeTransaction, EditTransactionBase)
@@ -39,8 +39,8 @@
 NS_INTERFACE_MAP_END_INHERITING(EditTransactionBase)
 
 bool DeleteNodeTransaction::CanDoIt() const {
-  if (NS_WARN_IF(!mNodeToDelete) || NS_WARN_IF(!mEditorBase) || !mParentNode ||
-      !mEditorBase->IsModifiableNode(*mParentNode)) {
+  if (NS_WARN_IF(!mContentToDelete) || NS_WARN_IF(!mEditorBase) ||
+      !mParentNode || !mEditorBase->IsModifiableNode(*mParentNode)) {
     return false;
   }
   return true;
@@ -51,24 +51,26 @@
     return NS_OK;
   }
 
-  if (!mEditorBase->AsHTMLEditor() && mNodeToDelete->IsText()) {
-    uint32_t length = mNodeToDelete->AsText()->TextLength();
+  if (!mEditorBase->AsHTMLEditor() && mContentToDelete->IsText()) {
+    uint32_t length = mContentToDelete->AsText()->TextLength();
     if (length > 0) {
       mEditorBase->AsTextEditor()->WillDeleteText(length, 0, length);
     }
   }
 
-  // Remember which child mNodeToDelete was (by remembering which child was
-  // next).  Note that mRefNode can be nullptr.
-  mRefNode = mNodeToDelete->GetNextSibling();
+  // Remember which child mContentToDelete was (by remembering which child was
+  // next).  Note that mRefContent can be nullptr.
+  mRefContent = mContentToDelete->GetNextSibling();
 
   // give range updater a chance.  SelAdjDeleteNode() needs to be called
   // *before* we do the action, unlike some of the other RangeItem update
   // methods.
-  mEditorBase->RangeUpdaterRef().SelAdjDeleteNode(*mNodeToDelete);
+  mEditorBase->RangeUpdaterRef().SelAdjDeleteNode(*mContentToDelete);
 
+  OwningNonNull<nsINode> parentNode = *mParentNode;
+  OwningNonNull<nsIContent> contentToDelete = *mContentToDelete;
   ErrorResult error;
-  mParentNode->RemoveChild(*mNodeToDelete, error);
+  parentNode->RemoveChild(contentToDelete, error);
   NS_WARNING_ASSERTION(!error.Failed(), "nsINode::RemoveChild() failed");
   return error.StealNSResult();
 }
@@ -80,17 +82,19 @@
     return NS_OK;
   }
   ErrorResult error;
-  RefPtr<EditorBase> editorBase = mEditorBase;
-  nsCOMPtr<nsINode> parent = mParentNode;
-  nsCOMPtr<nsINode> nodeToDelete = mNodeToDelete;
-  nsCOMPtr<nsIContent> refNode = mRefNode;
-  parent->InsertBefore(*nodeToDelete, refNode, error);
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
+  OwningNonNull<nsINode> parentNode = *mParentNode;
+  OwningNonNull<nsIContent> contentToDelete = *mContentToDelete;
+  nsCOMPtr<nsIContent> refContent = mRefContent;
+  // XXX Perhaps, we should check `refContent` is a child of `parentNode`,
+  //     and if it's not, we should stop undoing or something.
+  parentNode->InsertBefore(contentToDelete, refContent, error);
   if (error.Failed()) {
     NS_WARNING("nsINode::InsertBefore() failed");
     return error.StealNSResult();
   }
-  if (!editorBase->AsHTMLEditor() && nodeToDelete->IsText()) {
-    uint32_t length = nodeToDelete->AsText()->TextLength();
+  if (!editorBase->AsHTMLEditor() && contentToDelete->IsText()) {
+    uint32_t length = contentToDelete->AsText()->TextLength();
     if (length > 0) {
       nsresult rv = MOZ_KnownLive(editorBase->AsTextEditor())
                         ->DidInsertText(length, 0, length);
@@ -109,17 +113,19 @@
     return NS_OK;
   }
 
-  if (!mEditorBase->AsHTMLEditor() && mNodeToDelete->IsText()) {
-    uint32_t length = mNodeToDelete->AsText()->TextLength();
+  if (!mEditorBase->AsHTMLEditor() && mContentToDelete->IsText()) {
+    uint32_t length = mContentToDelete->AsText()->TextLength();
     if (length > 0) {
       mEditorBase->AsTextEditor()->WillDeleteText(length, 0, length);
     }
   }
 
-  mEditorBase->RangeUpdaterRef().SelAdjDeleteNode(*mNodeToDelete);
+  mEditorBase->RangeUpdaterRef().SelAdjDeleteNode(*mContentToDelete);
 
+  OwningNonNull<nsINode> parentNode = *mParentNode;
+  OwningNonNull<nsIContent> contentToDelete = *mContentToDelete;
   ErrorResult error;
-  mParentNode->RemoveChild(*mNodeToDelete, error);
+  parentNode->RemoveChild(contentToDelete, error);
   NS_WARNING_ASSERTION(!error.Failed(), "nsINode::RemoveChild() failed");
   return error.StealNSResult();
 }