# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/CompositionTransaction.cpp
# Commit: ce2087ddab5c
# Full Hash: ce2087ddab5c2efcbce3b52da02b3363a37d6813
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-04-04 09:29:13
# Regressor Bug: 1619914
# File Overlap Count: 1
# Description:
#   Bug 1619914 - part 1: Make each transaction class grab their members with local variable before touching the DOM tree r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D69302
# ==============================================================================

diff -r 1c8115a9a684 -r ce2087ddab5c editor/libeditor/CompositionTransaction.cpp
--- a/editor/libeditor/CompositionTransaction.cpp	Fri Apr 03 10:21:33 2020 +0000
+++ b/editor/libeditor/CompositionTransaction.cpp	Fri Apr 03 08:30:37 2020 +0000
@@ -81,44 +81,44 @@
 
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP
 CompositionTransaction::DoTransaction() {
-  if (NS_WARN_IF(!mEditorBase)) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mTextNode)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Fail before making any changes if there's no selection controller
   if (NS_WARN_IF(!mEditorBase->GetSelectionController())) {
-    return NS_ERROR_NOT_INITIALIZED;
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
-  RefPtr<EditorBase> editorBase = mEditorBase;
-  RefPtr<Text> textNode = mTextNode;
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
+  OwningNonNull<Text> textNode = *mTextNode;
 
   // Advance caret: This requires the presentation shell to get the selection.
   if (mReplaceLength == 0) {
     ErrorResult error;
-    editorBase->DoInsertText(*textNode, mOffset, mStringToInsert, error);
+    editorBase->DoInsertText(textNode, mOffset, mStringToInsert, error);
     if (error.Failed()) {
       NS_WARNING("EditorBase::DoInsertText() failed");
       return error.StealNSResult();
     }
-    editorBase->RangeUpdaterRef().SelAdjInsertText(*textNode, mOffset,
+    editorBase->RangeUpdaterRef().SelAdjInsertText(textNode, mOffset,
                                                    mStringToInsert);
   } else {
     uint32_t replaceableLength = textNode->TextLength() - mOffset;
     ErrorResult error;
-    editorBase->DoReplaceText(*textNode, mOffset, mReplaceLength,
+    editorBase->DoReplaceText(textNode, mOffset, mReplaceLength,
                               mStringToInsert, error);
     if (error.Failed()) {
       NS_WARNING("EditorBase::DoReplaceText() failed");
       return error.StealNSResult();
     }
     DebugOnly<nsresult> rvIgnored =
-        editorBase->RangeUpdaterRef().SelAdjDeleteText(*textNode, mOffset,
+        editorBase->RangeUpdaterRef().SelAdjDeleteText(textNode, mOffset,
                                                        mReplaceLength);
     NS_WARNING_ASSERTION(
         NS_SUCCEEDED(rvIgnored),
         "RangeUpdater::SelAdjDeleteText() failed, but ignored");
-    editorBase->RangeUpdaterRef().SelAdjInsertText(*textNode, mOffset,
+    editorBase->RangeUpdaterRef().SelAdjInsertText(textNode, mOffset,
                                                    mStringToInsert);
 
     // If IME text node is multiple node, ReplaceData doesn't remove all IME
@@ -127,19 +127,20 @@
     //     in a text node.
     if (replaceableLength < mReplaceLength) {
       int32_t remainLength = mReplaceLength - replaceableLength;
-      nsCOMPtr<nsINode> node = textNode->GetNextSibling();
       IgnoredErrorResult ignoredError;
-      while (node && node->IsText() && remainLength > 0) {
-        RefPtr<Text> textNode = static_cast<Text*>(node.get());
+      for (nsIContent* nextSibling = textNode->GetNextSibling();
+           nextSibling && nextSibling->IsText() && remainLength;
+           nextSibling = nextSibling->GetNextSibling()) {
+        OwningNonNull<Text> textNode = *static_cast<Text*>(nextSibling);
         uint32_t textLength = textNode->TextLength();
-        editorBase->DoDeleteText(*textNode, 0, remainLength, ignoredError);
+        editorBase->DoDeleteText(textNode, 0, remainLength, ignoredError);
         NS_WARNING_ASSERTION(!ignoredError.Failed(),
                              "EditorBase::DoDeleteText() failed, but ignored");
         ignoredError.SuppressException();
-        editorBase->RangeUpdaterRef().SelAdjDeleteText(*textNode, 0,
+        // XXX Needs to check whether the text is deleted as expected.
+        editorBase->RangeUpdaterRef().SelAdjDeleteText(textNode, 0,
                                                        remainLength);
         remainLength -= textLength;
-        node = node->GetNextSibling();
       }
     }
   }
@@ -153,21 +154,21 @@
 
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP
 CompositionTransaction::UndoTransaction() {
-  if (NS_WARN_IF(!mEditorBase)) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mTextNode)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Get the selection first so we'll fail before making any changes if we
   // can't get it
   RefPtr<Selection> selection = mEditorBase->GetSelection();
   if (NS_WARN_IF(!selection)) {
-    return NS_ERROR_NOT_INITIALIZED;
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
-  RefPtr<EditorBase> editorBase = mEditorBase;
-  RefPtr<Text> textNode = mTextNode;
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
+  OwningNonNull<Text> textNode = *mTextNode;
   ErrorResult error;
-  editorBase->DoDeleteText(*textNode, mOffset, mStringToInsert.Length(), error);
+  editorBase->DoDeleteText(textNode, mOffset, mStringToInsert.Length(), error);
   if (error.Failed()) {
     NS_WARNING("EditorBase::DoDeleteText() failed");
     return error.StealNSResult();
@@ -211,11 +212,14 @@
 /* ============ private methods ================== */
 
 nsresult CompositionTransaction::SetSelectionForRanges() {
-  if (NS_WARN_IF(!mEditorBase)) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mTextNode)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
-  nsresult rv = SetIMESelection(*mEditorBase, mTextNode, mOffset,
-                                mStringToInsert.Length(), mRanges);
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
+  OwningNonNull<Text> textNode = *mTextNode;
+  RefPtr<TextRangeArray> ranges = mRanges;
+  nsresult rv = SetIMESelection(editorBase, textNode, mOffset,
+                                mStringToInsert.Length(), ranges);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                        "CompositionTransaction::SetIMESelection() failed");
   return rv;