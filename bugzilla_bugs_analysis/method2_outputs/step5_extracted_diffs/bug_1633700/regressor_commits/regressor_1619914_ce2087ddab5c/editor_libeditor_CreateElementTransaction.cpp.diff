# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/CreateElementTransaction.cpp
# Commit: ce2087ddab5c
# Full Hash: ce2087ddab5c2efcbce3b52da02b3363a37d6813
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-04-04 09:29:13
# Regressor Bug: 1619914
# File Overlap Count: 1
# Description:
#   Bug 1619914 - part 1: Make each transaction class grab their members with local variable before touching the DOM tree r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D69302
# ==============================================================================

diff -r 1c8115a9a684 -r ce2087ddab5c editor/libeditor/CreateElementTransaction.cpp
--- a/editor/libeditor/CreateElementTransaction.cpp	Fri Apr 03 10:21:33 2020 +0000
+++ b/editor/libeditor/CreateElementTransaction.cpp	Fri Apr 03 08:30:37 2020 +0000
@@ -54,11 +54,15 @@
     : EditTransactionBase(),
       mEditorBase(&aEditorBase),
       mTag(&aTag),
-      mPointToInsert(aPointToInsert) {}
+      mPointToInsert(aPointToInsert) {
+  MOZ_ASSERT(!mPointToInsert.IsInDataNode());
+  // We only need the child node at inserting new node.
+  AutoEditorDOMPointOffsetInvalidator lockChild(mPointToInsert);
+}
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(CreateElementTransaction,
                                    EditTransactionBase, mEditorBase,
-                                   mPointToInsert, mNewNode)
+                                   mPointToInsert, mNewElement)
 
 NS_IMPL_ADDREF_INHERITED(CreateElementTransaction, EditTransactionBase)
 NS_IMPL_RELEASE_INHERITED(CreateElementTransaction, EditTransactionBase)
@@ -72,16 +76,16 @@
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-  RefPtr<EditorBase> editorBase(mEditorBase);
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
 
-  mNewNode = editorBase->CreateHTMLContent(mTag);
-  if (!mNewNode) {
+  mNewElement = editorBase->CreateHTMLContent(mTag);
+  if (!mNewElement) {
     NS_WARNING("EditorBase::CreateHTMLContent() failed");
     return NS_ERROR_FAILURE;
   }
 
   // Try to insert formatting whitespace for the new node:
-  OwningNonNull<Element> newElement(*mNewNode);
+  OwningNonNull<Element> newElement = *mNewElement;
   nsresult rv = editorBase->MarkElementDirty(newElement);
   if (NS_WARN_IF(rv == NS_ERROR_EDITOR_DESTROYED)) {
     return EditorBase::ToGenericNSResult(rv);
@@ -108,7 +112,7 @@
     return NS_ERROR_FAILURE;
   }
 
-  EditorRawDOMPoint afterNewNode(EditorRawDOMPoint::After(mNewNode));
+  EditorRawDOMPoint afterNewNode(EditorRawDOMPoint::After(newElement));
   if (NS_WARN_IF(!afterNewNode.IsSet())) {
     // If mutation observer or mutation event listener moved or removed the
     // new node, we hit this case.  Should we use script blocker while we're
@@ -123,56 +127,69 @@
 }
 
 void CreateElementTransaction::InsertNewNode(ErrorResult& aError) {
+  MOZ_ASSERT(mNewElement);
+  MOZ_ASSERT(mPointToInsert.IsSet());
+
   if (mPointToInsert.IsSetAndValid()) {
     if (mPointToInsert.IsEndOfContainer()) {
-      mPointToInsert.GetContainer()->AppendChild(*mNewNode, aError);
+      OwningNonNull<nsINode> container = *mPointToInsert.GetContainer();
+      OwningNonNull<Element> newElement = *mNewElement;
+      container->AppendChild(newElement, aError);
       NS_WARNING_ASSERTION(!aError.Failed(),
                            "nsINode::AppendChild() failed, but ignored");
       return;
     }
-    mPointToInsert.GetContainer()->InsertBefore(
-        *mNewNode, mPointToInsert.GetChild(), aError);
+    MOZ_ASSERT(mPointToInsert.GetChild());
+    OwningNonNull<nsINode> container = *mPointToInsert.GetContainer();
+    OwningNonNull<nsIContent> child = *mPointToInsert.GetChild();
+    OwningNonNull<Element> newElement = *mNewElement;
+    container->InsertBefore(newElement, child, aError);
     NS_WARNING_ASSERTION(!aError.Failed(),
                          "nsINode::InsertBefore() failed, but ignored");
     return;
   }
 
-  if (NS_WARN_IF(mPointToInsert.GetChild() &&
-                 mPointToInsert.GetContainer() !=
-                     mPointToInsert.GetChild()->GetParentNode())) {
+  if (NS_WARN_IF(mPointToInsert.GetContainer() !=
+                 mPointToInsert.GetChild()->GetParentNode())) {
     aError.Throw(NS_ERROR_FAILURE);
     return;
   }
 
   // If mPointToInsert has only offset and it's not valid, we need to treat
   // it as pointing end of the container.
-  mPointToInsert.GetContainer()->AppendChild(*mNewNode, aError);
+  OwningNonNull<nsINode> container = *mPointToInsert.GetContainer();
+  OwningNonNull<Element> newElement = *mNewElement;
+  container->AppendChild(newElement, aError);
   NS_WARNING_ASSERTION(!aError.Failed(),
                        "nsINode::AppendChild() failed, but ignored");
 }
 
 NS_IMETHODIMP CreateElementTransaction::UndoTransaction() {
-  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mPointToInsert.IsSet())) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mPointToInsert.IsSet()) ||
+      NS_WARN_IF(!mNewElement)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
+  OwningNonNull<Element> newElement = *mNewElement;
+  OwningNonNull<nsINode> containerNode = *mPointToInsert.GetContainer();
   ErrorResult error;
-  mPointToInsert.GetContainer()->RemoveChild(*mNewNode, error);
+  containerNode->RemoveChild(newElement, error);
   NS_WARNING_ASSERTION(!error.Failed(), "nsINode::RemoveChild() failed");
   return error.StealNSResult();
 }
 
 NS_IMETHODIMP CreateElementTransaction::RedoTransaction() {
-  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mPointToInsert.IsSet())) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mPointToInsert.IsSet()) ||
+      NS_WARN_IF(!mNewElement)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // First, reset mNewNode so it has no attributes or content
-  // XXX We never actually did this, we only cleared mNewNode's contents if it
-  // was a CharacterData node (which it's not, it's an Element)
+  // First, reset mNewElement so it has no attributes or content
+  // XXX We never actually did this, we only cleared mNewElement's contents if
+  // it was a CharacterData node (which it's not, it's an Element)
   // XXX Don't we need to set selection like DoTransaction()?
 
-  // Now, reinsert mNewNode
+  // Now, reinsert mNewElement
   ErrorResult error;
   InsertNewNode(error);
   NS_WARNING_ASSERTION(!error.Failed(),
@@ -180,8 +197,4 @@
   return error.StealNSResult();
 }
 
-already_AddRefed<Element> CreateElementTransaction::GetNewNode() {
-  return nsCOMPtr<Element>(mNewNode).forget();
-}
-
 }  // namespace mozilla