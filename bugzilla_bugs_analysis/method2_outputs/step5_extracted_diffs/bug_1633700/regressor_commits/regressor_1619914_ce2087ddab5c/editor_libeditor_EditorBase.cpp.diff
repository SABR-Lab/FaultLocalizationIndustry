# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/EditorBase.cpp
# Commit: ce2087ddab5c
# Full Hash: ce2087ddab5c2efcbce3b52da02b3363a37d6813
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-04-04 09:29:13
# Regressor Bug: 1619914
# File Overlap Count: 1
# Description:
#   Bug 1619914 - part 1: Make each transaction class grab their members with local variable before touching the DOM tree r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D69302
# ==============================================================================

diff -r 1c8115a9a684 -r ce2087ddab5c editor/libeditor/EditorBase.cpp
--- a/editor/libeditor/EditorBase.cpp	Fri Apr 03 10:21:33 2020 +0000
+++ b/editor/libeditor/EditorBase.cpp	Fri Apr 03 08:30:37 2020 +0000
@@ -1447,7 +1447,7 @@
         NS_SUCCEEDED(rvIgnored),
         "Rangeupdater::SelAdjCreateNode() failed, but ignored");
   } else {
-    newElement = transaction->GetNewNode();
+    newElement = transaction->GetNewElement();
     MOZ_ASSERT(newElement);
 
     // If we succeeded to create and insert new element, we need to adjust
@@ -1667,32 +1667,33 @@
   NS_WARNING_ASSERTION(!aError.Failed(),
                        "EditorBase::DoTransactionInternal() failed");
 
-  nsCOMPtr<nsIContent> newContent = transaction->GetNewNode();
-  NS_WARNING_ASSERTION(newContent, "Failed to create a new left node");
-
-  if (newContent) {
+  nsCOMPtr<nsIContent> newLeftContent = transaction->GetNewLeftContent();
+  NS_WARNING_ASSERTION(newLeftContent, "Failed to create a new left node");
+
+  if (newLeftContent) {
     // XXX Some other transactions manage range updater by themselves.
     //     Why doesn't SplitNodeTransaction do it?
     DebugOnly<nsresult> rvIgnored = RangeUpdaterRef().SelAdjSplitNode(
-        *aStartOfRightNode.GetContainerAsContent(), *newContent);
+        *aStartOfRightNode.GetContainerAsContent(), *newLeftContent);
     NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
                          "RangeUpdater::SelAdjSplitNode() failed, but ignored");
   }
-  if (AsHTMLEditor() && newContent) {
+  if (AsHTMLEditor() && newLeftContent) {
     TopLevelEditSubActionDataRef().DidSplitContent(
-        *this, *aStartOfRightNode.GetContainerAsContent(), *newContent);
+        *this, *aStartOfRightNode.GetContainerAsContent(), *newLeftContent);
   }
 
   if (mInlineSpellChecker) {
     RefPtr<mozInlineSpellChecker> spellChecker = mInlineSpellChecker;
-    spellChecker->DidSplitNode(aStartOfRightNode.GetContainer(), newContent);
+    spellChecker->DidSplitNode(aStartOfRightNode.GetContainer(),
+                               newLeftContent);
   }
 
   if (!mActionListeners.IsEmpty()) {
     AutoActionListenerArray listeners(mActionListeners);
     for (auto& listener : listeners) {
-      DebugOnly<nsresult> rvIgnored =
-          listener->DidSplitNode(aStartOfRightNode.GetContainer(), newContent);
+      DebugOnly<nsresult> rvIgnored = listener->DidSplitNode(
+          aStartOfRightNode.GetContainer(), newLeftContent);
       NS_WARNING_ASSERTION(
           NS_SUCCEEDED(rvIgnored),
           "nsIEditActionListener::DidSplitNode() failed, but ignored");
@@ -1703,7 +1704,7 @@
     return nullptr;
   }
 
-  return newContent.forget();
+  return newLeftContent.forget();
 }
 
 nsresult EditorBase::JoinNodesWithTransaction(nsINode& aLeftNode,
@@ -1736,8 +1737,8 @@
         *this, *aLeftNode.AsContent(), *aRightNode.AsContent());
   }
 
-  RefPtr<JoinNodeTransaction> transaction =
-      JoinNodeTransaction::MaybeCreate(*this, aLeftNode, aRightNode);
+  RefPtr<JoinNodeTransaction> transaction = JoinNodeTransaction::MaybeCreate(
+      *this, *aLeftNode.AsContent(), *aRightNode.AsContent());
   NS_WARNING_ASSERTION(
       transaction, "JoinNodeTransaction::MaybeCreate() failed, but ignored");
 
@@ -1825,7 +1826,7 @@
   // FYI: DeleteNodeTransaction grabs aNode while it's alive.  So, it's safe
   //      to refer aNode even after calling DoTransaction().
   RefPtr<DeleteNodeTransaction> deleteNodeTransaction =
-      DeleteNodeTransaction::MaybeCreate(*this, aNode);
+      DeleteNodeTransaction::MaybeCreate(*this, *aNode.AsContent());
   NS_WARNING_ASSERTION(deleteNodeTransaction,
                        "DeleteNodeTransaction::MaybeCreate() failed");
   nsresult rv;
@@ -4797,49 +4798,50 @@
 
   // we're either deleting a node or chardata, need to dig into the next/prev
   // node to find out
-  nsCOMPtr<nsINode> selectedNode;
+  nsCOMPtr<nsIContent> selectedContent;
   if (aAction == ePrevious) {
-    selectedNode =
+    selectedContent =
         GetPreviousEditableNode(EditorRawDOMPoint(node, child, offset));
   } else if (aAction == eNext) {
-    selectedNode = GetNextEditableNode(EditorRawDOMPoint(node, child, offset));
-  }
-
-  while (selectedNode && selectedNode->IsCharacterData() &&
-         !selectedNode->Length()) {
+    selectedContent =
+        GetNextEditableNode(EditorRawDOMPoint(node, child, offset));
+  }
+
+  while (selectedContent && selectedContent->IsCharacterData() &&
+         !selectedContent->Length()) {
     // Can't delete an empty chardata node (bug 762183)
     if (aAction == ePrevious) {
-      selectedNode = GetPreviousEditableNode(*selectedNode);
+      selectedContent = GetPreviousEditableNode(*selectedContent);
     } else if (aAction == eNext) {
-      selectedNode = GetNextEditableNode(*selectedNode);
+      selectedContent = GetNextEditableNode(*selectedContent);
     }
   }
 
-  if (NS_WARN_IF(!selectedNode)) {
+  if (NS_WARN_IF(!selectedContent)) {
     return nullptr;
   }
 
-  if (RefPtr<Text> selectedNodeAsText = Text::FromNode(selectedNode)) {
+  if (RefPtr<Text> selectedTextNode = Text::FromNode(selectedContent)) {
     if (NS_WARN_IF(aAction != ePrevious && aAction != eNext)) {
       return nullptr;
     }
     // we are deleting from a chardata node, so do a character deletion
     uint32_t position = 0;
     if (aAction == ePrevious) {
-      position = selectedNode->Length();
+      position = selectedTextNode->Length();
     }
     RefPtr<DeleteTextTransaction> deleteTextTransaction;
     if (aAction == ePrevious) {
       deleteTextTransaction =
           DeleteTextTransaction::MaybeCreateForPreviousCharacter(
-              *this, *selectedNodeAsText, position);
+              *this, *selectedTextNode, position);
       NS_WARNING_ASSERTION(
           deleteTextTransaction,
           "DeleteTextTransaction::MaybeCreateForPreviousCharacter() failed");
     } else {
       deleteTextTransaction =
           DeleteTextTransaction::MaybeCreateForNextCharacter(
-              *this, *selectedNodeAsText, position);
+              *this, *selectedTextNode, position);
       NS_WARNING_ASSERTION(
           deleteTextTransaction,
           "DeleteTextTransaction::MaybeCreateForNextCharacter() failed");
@@ -4849,16 +4851,18 @@
     }
     *aOffset = deleteTextTransaction->Offset();
     *aLength = deleteTextTransaction->LengthToDelete();
-    selectedNode.forget(aRemovingNode);
+    nsCOMPtr<nsINode> removingNode(selectedTextNode);
+    removingNode.forget(aRemovingNode);
     return deleteTextTransaction.forget();
   }
 
   RefPtr<DeleteNodeTransaction> deleteNodeTransaction =
-      DeleteNodeTransaction::MaybeCreate(*this, *selectedNode);
+      DeleteNodeTransaction::MaybeCreate(*this, *selectedContent);
   if (NS_WARN_IF(!deleteNodeTransaction)) {
     return nullptr;
   }
-  selectedNode.forget(aRemovingNode);
+  nsCOMPtr<nsINode> removingNode(selectedContent);
+  removingNode.forget(aRemovingNode);
   return deleteNodeTransaction.forget();
 }
 