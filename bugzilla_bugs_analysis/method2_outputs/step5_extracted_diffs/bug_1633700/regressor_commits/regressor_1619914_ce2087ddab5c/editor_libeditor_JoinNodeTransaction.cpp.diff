# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/JoinNodeTransaction.cpp
# Commit: ce2087ddab5c
# Full Hash: ce2087ddab5c2efcbce3b52da02b3363a37d6813
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2020-04-04 09:29:13
# Regressor Bug: 1619914
# File Overlap Count: 1
# Description:
#   Bug 1619914 - part 1: Make each transaction class grab their members with local variable before touching the DOM tree r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D69302
# ==============================================================================

diff -r 1c8115a9a684 -r ce2087ddab5c editor/libeditor/JoinNodeTransaction.cpp
--- a/editor/libeditor/JoinNodeTransaction.cpp	Fri Apr 03 10:21:33 2020 +0000
+++ b/editor/libeditor/JoinNodeTransaction.cpp	Fri Apr 03 08:30:37 2020 +0000
@@ -19,9 +19,10 @@
 
 // static
 already_AddRefed<JoinNodeTransaction> JoinNodeTransaction::MaybeCreate(
-    EditorBase& aEditorBase, nsINode& aLeftNode, nsINode& aRightNode) {
+    EditorBase& aEditorBase, nsIContent& aLeftContent,
+    nsIContent& aRightContent) {
   RefPtr<JoinNodeTransaction> transaction =
-      new JoinNodeTransaction(aEditorBase, aLeftNode, aRightNode);
+      new JoinNodeTransaction(aEditorBase, aLeftContent, aRightContent);
   if (NS_WARN_IF(!transaction->CanDoIt())) {
     return nullptr;
   }
@@ -29,56 +30,57 @@
 }
 
 JoinNodeTransaction::JoinNodeTransaction(EditorBase& aEditorBase,
-                                         nsINode& aLeftNode,
-                                         nsINode& aRightNode)
+                                         nsIContent& aLeftContent,
+                                         nsIContent& aRightContent)
     : mEditorBase(&aEditorBase),
-      mLeftNode(&aLeftNode),
-      mRightNode(&aRightNode),
+      mLeftContent(&aLeftContent),
+      mRightContent(&aRightContent),
       mOffset(0) {}
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(JoinNodeTransaction, EditTransactionBase,
-                                   mEditorBase, mLeftNode, mRightNode, mParent)
+                                   mEditorBase, mLeftContent, mRightContent,
+                                   mParentNode)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(JoinNodeTransaction)
 NS_INTERFACE_MAP_END_INHERITING(EditTransactionBase)
 
 bool JoinNodeTransaction::CanDoIt() const {
-  if (NS_WARN_IF(!mLeftNode) || NS_WARN_IF(!mRightNode) ||
-      NS_WARN_IF(!mEditorBase) || !mLeftNode->GetParentNode()) {
+  if (NS_WARN_IF(!mLeftContent) || NS_WARN_IF(!mRightContent) ||
+      NS_WARN_IF(!mEditorBase) || !mLeftContent->GetParentNode()) {
     return false;
   }
-  return mEditorBase->IsModifiableNode(*mLeftNode->GetParentNode());
+  return mEditorBase->IsModifiableNode(*mLeftContent->GetParentNode());
 }
 
 // After DoTransaction() and RedoTransaction(), the left node is removed from
 // the content tree and right node remains.
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP JoinNodeTransaction::DoTransaction() {
-  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mLeftNode) ||
-      NS_WARN_IF(!mRightNode)) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mEditorBase) || NS_WARN_IF(!mLeftContent) ||
+      NS_WARN_IF(!mRightContent)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Get the parent node
-  nsCOMPtr<nsINode> leftNodeParent = mLeftNode->GetParentNode();
-  if (NS_WARN_IF(!leftNodeParent)) {
-    return NS_ERROR_FAILURE;
+  nsCOMPtr<nsINode> leftContentParent = mLeftContent->GetParentNode();
+  if (NS_WARN_IF(!leftContentParent)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // Verify that mLeftNode and mRightNode have the same parent
-  if (leftNodeParent != mRightNode->GetParentNode()) {
+  // Verify that mLeftContent and mRightContent have the same parent
+  if (leftContentParent != mRightContent->GetParentNode()) {
     NS_ASSERTION(false, "Nodes do not have same parent");
-    return NS_ERROR_INVALID_ARG;
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // Set this instance's mParent.  Other methods will see a non-null mParent
-  // and know all is well
-  mParent = leftNodeParent;
-  mOffset = mLeftNode->Length();
+  // Set this instance's mParentNode.  Other methods will see a non-null
+  // mParentNode and know all is well
+  mParentNode = leftContentParent;
+  mOffset = mLeftContent->Length();
 
-  RefPtr<EditorBase> editorBase = mEditorBase;
-  nsCOMPtr<nsINode> leftNode = mLeftNode;
-  nsCOMPtr<nsINode> rightNode = mRightNode;
-  nsresult rv = editorBase->DoJoinNodes(rightNode, leftNode, leftNodeParent);
+  OwningNonNull<EditorBase> editorBase = *mEditorBase;
+  OwningNonNull<nsINode> leftNode = *mLeftContent;
+  OwningNonNull<nsINode> rightNode = *mRightContent;
+  nsresult rv = editorBase->DoJoinNodes(rightNode, leftNode, leftContentParent);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "EditorBase::DoJoinNodes() failed");
   return rv;
 }
@@ -87,42 +89,49 @@
 //     mRight and re-inserted mLeft?
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP
 JoinNodeTransaction::UndoTransaction() {
-  if (NS_WARN_IF(!mParent) || NS_WARN_IF(!mLeftNode) ||
-      NS_WARN_IF(!mRightNode) || NS_WARN_IF(!mEditorBase)) {
-    return NS_ERROR_NOT_INITIALIZED;
+  if (NS_WARN_IF(!mParentNode) || NS_WARN_IF(!mLeftContent) ||
+      NS_WARN_IF(!mRightContent) || NS_WARN_IF(!mEditorBase)) {
+    return NS_ERROR_NOT_AVAILABLE;
   }
 
+  OwningNonNull<nsIContent> leftContent = *mLeftContent;
+  OwningNonNull<nsIContent> rightContent = *mRightContent;
+  OwningNonNull<nsINode> parentNode = *mParentNode;
+
   // First, massage the existing node so it is in its post-split state
   ErrorResult error;
-  if (mRightNode->GetAsText()) {
-    RefPtr<EditorBase> editorBase = mEditorBase;
-    RefPtr<Text> rightNodeAsText = mRightNode->GetAsText();
-    editorBase->DoDeleteText(*rightNodeAsText, 0, mOffset, error);
+  if (Text* rightTextNode = rightContent->GetAsText()) {
+    OwningNonNull<EditorBase> editorBase = *mEditorBase;
+    editorBase->DoDeleteText(MOZ_KnownLive(*rightTextNode), 0, mOffset, error);
     if (error.Failed()) {
       NS_WARNING("EditorBase::DoDeleteText() failed");
       return error.StealNSResult();
     }
   } else {
-    nsCOMPtr<nsIContent> child = mRightNode->GetFirstChild();
-    for (uint32_t i = 0; i < mOffset; i++) {
+    AutoTArray<OwningNonNull<nsIContent>, 24> movingChildren;
+    if (nsIContent* child = mRightContent->GetFirstChild()) {
+      movingChildren.AppendElement(*child);
+      for (uint32_t i = 0; i < mOffset; i++) {
+        child = child->GetNextSibling();
+        if (!child) {
+          break;
+        }
+        movingChildren.AppendElement(*child);
+      }
+    }
+    for (OwningNonNull<nsIContent>& child : movingChildren) {
+      leftContent->AppendChild(child, error);
       if (error.Failed()) {
+        NS_WARNING("nsINode::AppendChild() failed");
         return error.StealNSResult();
       }
-      if (!child) {
-        return NS_ERROR_NULL_POINTER;
-      }
-      nsCOMPtr<nsIContent> nextSibling = child->GetNextSibling();
-      mLeftNode->AppendChild(*child, error);
-      NS_WARNING_ASSERTION(!error.Failed(), "nsINode::AppendChild() failed");
-      child = nextSibling;
     }
   }
 
   NS_WARNING_ASSERTION(!error.Failed(), "The previous error was ignored");
 
   // Second, re-insert the left node into the tree
-  nsCOMPtr<nsINode> refNode = mRightNode;
-  mParent->InsertBefore(*mLeftNode, refNode, error);
+  parentNode->InsertBefore(leftContent, rightContent, error);
   NS_WARNING_ASSERTION(!error.Failed(), "nsINode::InsertBefore() failed");
   return error.StealNSResult();
 }