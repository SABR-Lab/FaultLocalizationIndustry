# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/shell/js.cpp
# Commit: 4107b758e7ae
# Full Hash: 4107b758e7aea25d4529511f47bbd54531640dc4
# Author: Denis Palmeiro <dpalmeiro@mozilla.com>
# Date: 2020-05-01 09:42:47
# Regressor Bug: 1501608
# File Overlap Count: 1
# Description:
#   Bug 1501608 - Remove the ELEMENT_SLOT in the ScriptSourceObject and instead use a callback function to return the script element based on the value of the privateValue in the SSO. r=jonco,smaug
#   
#   We can reduce the size of the SSO by removing the element slot entirely, and instead retrieve the element through a callback function.  The callback will take in the value in the private slot of the SSO, which is either a LoadedScript* (from the browser) or a JSObject* (from the shell).  In addition, this removes the requirement of having a script dom element ready when parsing a JS script which can open up new opportunities for performance.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D70417
# ==============================================================================

diff -r d3a637853a36 -r 4107b758e7ae js/src/shell/js.cpp
--- a/js/src/shell/js.cpp	Thu Apr 30 14:32:56 2020 +0000
+++ b/js/src/shell/js.cpp	Thu Apr 30 16:21:23 2020 +0000
@@ -869,9 +869,16 @@
     return false;
   }
 
-  RootedObject infoObject(cx, JS_NewPlainObject(cx));
-  if (!infoObject) {
-    return false;
+  RootedObject infoObject(cx);
+
+  Value val = JS::GetScriptPrivate(script);
+  if (val.isUndefined()) {
+    infoObject = JS_NewPlainObject(cx);
+    if (!infoObject) {
+      return false;
+    }
+  } else {
+    infoObject = val.toObjectOrNull();
   }
 
   RootedValue pathValue(cx, StringValue(path));
@@ -1924,7 +1931,15 @@
     return false;
   }
   if (v.isObject()) {
-    options.setElement(&v.toObject());
+    RootedObject infoObject(cx, JS_NewPlainObject(cx));
+    RootedValue elementValue(cx, v);
+    if (!JS_WrapValue(cx, &elementValue)) {
+      return false;
+    }
+    if (!JS_DefineProperty(cx, infoObject, "element", elementValue, 0)) {
+      return false;
+    }
+    options.setPrivateValue(ObjectValue(*infoObject));
   }
 
   if (!JS_GetProperty(cx, opts, "elementAttributeName", &v)) {
@@ -11034,6 +11049,23 @@
   return true;
 }
 
+JSObject* GetElementCallback(JSContext* cx, JS::HandleValue value) {
+  RootedValue privateValue(cx, value);
+  if (!privateValue.isObject()) {
+    return nullptr;
+  }
+
+  RootedObject infoObject(cx, privateValue.toObjectOrNull());
+  AutoRealm ar(cx, infoObject);
+
+  RootedValue elementValue(cx);
+  if (!JS_GetProperty(cx, infoObject, "element", &elementValue)) {
+    return nullptr;
+  }
+
+  return elementValue.toObjectOrNull();
+}
+
 static int Shell(JSContext* cx, OptionParser* op, char** envp) {
   if (JS::TraceLoggerSupported()) {
     JS::StartTraceLogger(cx);
@@ -11099,6 +11131,7 @@
   }
 
   JSAutoRealm ar(cx, glob);
+  JS::SetGetElementCallback(cx, &GetElementCallback);
 
 #ifdef FUZZING_INTERFACES
   if (fuzzHaveModule) {