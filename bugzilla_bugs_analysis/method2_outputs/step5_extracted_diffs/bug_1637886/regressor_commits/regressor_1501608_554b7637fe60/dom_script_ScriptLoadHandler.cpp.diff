# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/script/ScriptLoadHandler.cpp
# Commit: 554b7637fe60
# Full Hash: 554b7637fe60e8a57e5180b5daaa1441f1bea31b
# Author: Denis Palmeiro <dpalmeiro@mozilla.com>
# Date: 2020-05-13 03:44:05
# Regressor Bug: 1501608
# File Overlap Count: 1
# Description:
#   Bug 1501608 - Remove the ELEMENT_SLOT in the ScriptSourceObject and instead use a callback function to return the script element based on the value of the privateValue in the SSO. r=jonco,smaug
#   
#   We can reduce the size of the SSO by removing the element slot entirely, and instead retrieve the element through a callback function.  The callback will take in the value in the private slot of the SSO, which is either a LoadedScript* (from the browser) or a JSObject* (from the shell).  In addition, this removes the requirement of having a script dom element ready when parsing a JS script which can open up new opportunities for performance.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D70417
# ==============================================================================

diff -r 3470d926c02a -r 554b7637fe60 dom/script/ScriptLoadHandler.cpp
--- a/dom/script/ScriptLoadHandler.cpp	Tue May 12 09:40:48 2020 +0000
+++ b/dom/script/ScriptLoadHandler.cpp	Tue May 12 19:28:15 2020 +0000
@@ -209,7 +209,7 @@
   // request.
   nsAutoString hintCharset;
   if (!mRequest->IsPreload()) {
-    mRequest->Element()->GetScriptCharset(hintCharset);
+    mRequest->GetScriptElement()->GetScriptCharset(hintCharset);
   } else {
     nsTArray<ScriptLoader::PreloadInfo>::index_type i =
         mScriptLoader->mPreloads.IndexOf(
@@ -279,7 +279,7 @@
 
   if (mRequest->IsLoadingSource()) {
     mRequest->SetTextSource();
-    TRACE_FOR_TEST(mRequest->Element(), "scriptloader_load_source");
+    TRACE_FOR_TEST(mRequest->GetScriptElement(), "scriptloader_load_source");
     return NS_OK;
   }
 
@@ -289,7 +289,8 @@
     cic->GetAlternativeDataType(altDataType);
     if (altDataType.Equals(nsContentUtils::JSBytecodeMimeType())) {
       mRequest->SetBytecode();
-      TRACE_FOR_TEST(mRequest->Element(), "scriptloader_load_bytecode");
+      TRACE_FOR_TEST(mRequest->GetScriptElement(),
+                     "scriptloader_load_bytecode");
       return NS_OK;
     }
     MOZ_ASSERT(altDataType.IsEmpty());
@@ -303,7 +304,8 @@
       if (mimeType.LowerCaseEqualsASCII(APPLICATION_JAVASCRIPT_BINAST)) {
         if (mRequest->ShouldAcceptBinASTEncoding()) {
           mRequest->SetBinASTSource();
-          TRACE_FOR_TEST(mRequest->Element(), "scriptloader_load_source");
+          TRACE_FOR_TEST(mRequest->GetScriptElement(),
+                         "scriptloader_load_source");
           return NS_OK;
         }
 
@@ -317,7 +319,7 @@
   }
 
   mRequest->SetTextSource();
-  TRACE_FOR_TEST(mRequest->Element(), "scriptloader_load_source");
+  TRACE_FOR_TEST(mRequest->GetScriptElement(), "scriptloader_load_source");
 
   MOZ_ASSERT(!mRequest->IsUnknownDataType());
   MOZ_ASSERT(mRequest->IsLoading());