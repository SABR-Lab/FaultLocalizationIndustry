# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/shell/js.cpp
# Commit: 554b7637fe60
# Full Hash: 554b7637fe60e8a57e5180b5daaa1441f1bea31b
# Author: Denis Palmeiro <dpalmeiro@mozilla.com>
# Date: 2020-05-13 03:44:05
# Regressor Bug: 1501608
# File Overlap Count: 1
# Description:
#   Bug 1501608 - Remove the ELEMENT_SLOT in the ScriptSourceObject and instead use a callback function to return the script element based on the value of the privateValue in the SSO. r=jonco,smaug
#   
#   We can reduce the size of the SSO by removing the element slot entirely, and instead retrieve the element through a callback function.  The callback will take in the value in the private slot of the SSO, which is either a LoadedScript* (from the browser) or a JSObject* (from the shell).  In addition, this removes the requirement of having a script dom element ready when parsing a JS script which can open up new opportunities for performance.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D70417
# ==============================================================================

diff -r 3470d926c02a -r 554b7637fe60 js/src/shell/js.cpp
--- a/js/src/shell/js.cpp	Tue May 12 09:40:48 2020 +0000
+++ b/js/src/shell/js.cpp	Tue May 12 19:28:15 2020 +0000
@@ -873,9 +873,16 @@
     return false;
   }
 
-  RootedObject infoObject(cx, JS_NewPlainObject(cx));
-  if (!infoObject) {
-    return false;
+  RootedObject infoObject(cx);
+
+  Value val = JS::GetScriptPrivate(script);
+  if (val.isUndefined()) {
+    infoObject = JS_NewPlainObject(cx);
+    if (!infoObject) {
+      return false;
+    }
+  } else {
+    infoObject = val.toObjectOrNull();
   }
 
   RootedValue pathValue(cx, StringValue(path));
@@ -1924,7 +1931,15 @@
     return false;
   }
   if (v.isObject()) {
-    options.setElement(&v.toObject());
+    RootedObject infoObject(cx, JS_NewPlainObject(cx));
+    RootedValue elementValue(cx, v);
+    if (!JS_WrapValue(cx, &elementValue)) {
+      return false;
+    }
+    if (!JS_DefineProperty(cx, infoObject, "element", elementValue, 0)) {
+      return false;
+    }
+    options.setPrivateValue(ObjectValue(*infoObject));
   }
 
   if (!JS_GetProperty(cx, opts, "elementAttributeName", &v)) {
@@ -4124,6 +4139,23 @@
 static void SetWorkerContextOptions(JSContext* cx);
 static bool ShellBuildId(JS::BuildIdCharVector* buildId);
 
+JSObject* GetElementCallback(JSContext* cx, JS::HandleValue value) {
+  RootedValue privateValue(cx, value);
+  if (!privateValue.isObject()) {
+    return nullptr;
+  }
+
+  RootedObject infoObject(cx, privateValue.toObjectOrNull());
+  AutoRealm ar(cx, infoObject);
+
+  RootedValue elementValue(cx);
+  if (!JS_GetProperty(cx, infoObject, "element", &elementValue)) {
+    return nullptr;
+  }
+
+  return elementValue.toObjectOrNull();
+}
+
 static void WorkerMain(WorkerInput* input) {
   MOZ_ASSERT(input->parentRuntime);
 
@@ -4156,6 +4188,7 @@
   js::SetPreserveWrapperCallback(cx, DummyPreserveWrapperCallback);
   JS_InitDestroyPrincipalsCallback(cx, ShellPrincipals::destroy);
   JS_SetDestroyCompartmentCallback(cx, DestroyShellCompartmentPrivate);
+  JS::SetGetElementCallback(cx, &GetElementCallback);
 
   js::SetWindowProxyClass(cx, &ShellWindowProxyClass);
 
@@ -11765,6 +11798,7 @@
   JS_SetSecurityCallbacks(cx, &ShellPrincipals::securityCallbacks);
   JS_InitDestroyPrincipalsCallback(cx, ShellPrincipals::destroy);
   JS_SetDestroyCompartmentCallback(cx, DestroyShellCompartmentPrivate);
+  JS::SetGetElementCallback(cx, &GetElementCallback);
 
   js::SetWindowProxyClass(cx, &ShellWindowProxyClass);
 