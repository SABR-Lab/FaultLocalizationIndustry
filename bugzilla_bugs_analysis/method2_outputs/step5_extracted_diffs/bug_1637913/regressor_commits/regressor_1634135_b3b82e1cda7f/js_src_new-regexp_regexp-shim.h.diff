# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/new-regexp/regexp-shim.h
# Commit: b3b82e1cda7f
# Full Hash: b3b82e1cda7f9f2192ab9d7bf2759b4f4b2b19fa
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2020-05-12 04:04:10
# Regressor Bug: 1634135
# File Overlap Count: 1
# Description:
#   Bug 1634135: Update shim code r=mgaudet
#   
#   There are a few changes here:
#   
#   1. The code that used to be in wrapBody was moved to RegExpCompiler::PreprocessRegExp.
# ==============================================================================

diff -r 9dddfd577a3d -r b3b82e1cda7f js/src/new-regexp/regexp-shim.h
--- a/js/src/new-regexp/regexp-shim.h	Sun May 10 16:00:25 2020 +0000
+++ b/js/src/new-regexp/regexp-shim.h	Sun May 10 16:00:26 2020 +0000
@@ -160,6 +160,19 @@
   return (x >= 0) ? ((x < 255) ? uint8_t(x) : 255) : 0;
 }
 
+// Origin: https://github.com/v8/v8/blob/fc088cdaccadede84886eee881e67af9db53669a/src/base/bounds.h#L14-L28
+// Checks if value is in range [lower_limit, higher_limit] using a single
+// branch.
+template <typename T, typename U>
+inline constexpr bool IsInRange(T value, U lower_limit, U higher_limit) {
+  using unsigned_T = typename std::make_unsigned<T>::type;
+  // Use static_cast to support enum classes.
+  return static_cast<unsigned_T>(static_cast<unsigned_T>(value) -
+                                 static_cast<unsigned_T>(lower_limit)) <=
+         static_cast<unsigned_T>(static_cast<unsigned_T>(higher_limit) -
+                                 static_cast<unsigned_T>(lower_limit));
+}
+
 #define LAZY_INSTANCE_INITIALIZER { mozilla::Nothing() }
 
 template <typename T>
@@ -505,6 +518,8 @@
     return JS::Value::fromRawBits(asBits_);
   }
 
+  inline static Object cast(Object object) { return object; }
+
  protected:
   void setValue(const JS::Value& val) {
     asBits_ = val.asRawBits();
@@ -635,11 +650,6 @@
             typename = std::enable_if_t<std::is_convertible_v<S*, T*>>>
   inline Handle(Handle<S> handle) : location_(handle.location_) {}
 
-  template <typename S>
-  inline static const Handle<T> cast(Handle<S> that) {
-    return Handle<T>(that.location_);
-  }
-
   inline bool is_null() const { return location_ == nullptr; }
 
   inline T operator*() const {
@@ -905,6 +915,13 @@
     return regexp;
   }
 
+  // Each capture (including the match itself) needs two registers.
+  static int RegistersForCaptureCount(int count) { return (count + 1) * 2; }
+
+  inline int MaxRegisterCount() const {
+    return inner()->getMaxRegisters();
+  }
+
   // ******************************
   // Static constants
   // ******************************