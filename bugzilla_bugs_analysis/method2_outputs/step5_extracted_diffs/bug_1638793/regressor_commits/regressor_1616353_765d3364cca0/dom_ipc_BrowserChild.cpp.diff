# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/BrowserChild.cpp
# Commit: 765d3364cca0
# Full Hash: 765d3364cca0a67c614cb4fb5dff413a8c29d834
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-07 03:53:09
# Regressor Bug: 1616353
# File Overlap Count: 1
# Description:
#   Bug 1616353 - Part 7.2: Create and use nsOpenWindowInfo types in nsWindowWatcher logic, r=kmag
#   
#   This patch builds on top of part 7.1 by creating this object within
#   nsWindowWatcher and ContentParent to carry the relevant information through
#   provider interfaces when creating new content windows. The nsOpenWindowInfo
# ==============================================================================

diff -r 8a13355b4ac4 -r 765d3364cca0 dom/ipc/BrowserChild.cpp
--- a/dom/ipc/BrowserChild.cpp	Mon Apr 06 14:29:59 2020 +0000
+++ b/dom/ipc/BrowserChild.cpp	Mon Apr 06 14:30:02 2020 +0000
@@ -116,6 +116,7 @@
 #include "nsIWebProgress.h"
 #include "nsLayoutUtils.h"
 #include "nsNetUtil.h"
+#include "nsIOpenWindowInfo.h"
 #include "nsPIDOMWindow.h"
 #include "nsPIWindowRoot.h"
 #include "nsPointerHashKeys.h"
@@ -877,19 +878,21 @@
 }
 
 NS_IMETHODIMP
-BrowserChild::ProvideWindow(mozIDOMWindowProxy* aParent, uint32_t aChromeFlags,
-                            bool aCalledFromJS, bool aWidthSpecified,
-                            nsIURI* aURI, const nsAString& aName,
-                            const nsACString& aFeatures, bool aForceNoOpener,
-                            bool aForceNoReferrer,
+BrowserChild::ProvideWindow(nsIOpenWindowInfo* aOpenWindowInfo,
+                            uint32_t aChromeFlags, bool aCalledFromJS,
+                            bool aWidthSpecified, nsIURI* aURI,
+                            const nsAString& aName, const nsACString& aFeatures,
+                            bool aForceNoOpener, bool aForceNoReferrer,
                             nsDocShellLoadState* aLoadState, bool* aWindowIsNew,
                             BrowsingContext** aReturn) {
   *aReturn = nullptr;
 
-  // If aParent is inside an <iframe mozbrowser> and this isn't a request to
+  RefPtr<BrowsingContext> parent = aOpenWindowInfo->GetParent();
+
+  // If parent is inside an <iframe mozbrowser> and this isn't a request to
   // open a modal-type window, we're going to create a new <iframe mozbrowser>
   // and return its window here.
-  nsCOMPtr<nsIDocShell> docshell = do_GetInterface(aParent);
+  nsCOMPtr<nsIDocShell> docshell = parent->GetDocShell();
   bool iframeMoz =
       (docshell && docshell->GetIsInMozBrowser() &&
        !(aChromeFlags & (nsIWebBrowserChrome::CHROME_MODAL |
@@ -898,8 +901,7 @@
 
   if (!iframeMoz) {
     int32_t openLocation = nsWindowWatcher::GetWindowOpenLocation(
-        nsPIDOMWindowOuter::From(aParent), aChromeFlags, aCalledFromJS,
-        aWidthSpecified);
+        parent->GetDOMWindow(), aChromeFlags, aCalledFromJS, aWidthSpecified);
 
     // If it turns out we're opening in the current browser, just hand over the
     // current browser's docshell.
@@ -921,7 +923,7 @@
   // open window call was canceled.  It's important that we pass this error
   // code back to our caller.
   ContentChild* cc = ContentChild::GetSingleton();
-  return cc->ProvideWindowCommon(this, aParent, iframeMoz, aChromeFlags,
+  return cc->ProvideWindowCommon(this, aOpenWindowInfo, iframeMoz, aChromeFlags,
                                  aCalledFromJS, aWidthSpecified, aURI, aName,
                                  aFeatures, aForceNoOpener, aForceNoReferrer,
                                  aLoadState, aWindowIsNew, aReturn);