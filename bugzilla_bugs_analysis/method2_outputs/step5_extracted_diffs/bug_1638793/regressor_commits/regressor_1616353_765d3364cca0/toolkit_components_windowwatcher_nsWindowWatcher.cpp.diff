# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/windowwatcher/nsWindowWatcher.cpp
# Commit: 765d3364cca0
# Full Hash: 765d3364cca0a67c614cb4fb5dff413a8c29d834
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-07 03:53:09
# Regressor Bug: 1616353
# File Overlap Count: 1
# Description:
#   Bug 1616353 - Part 7.2: Create and use nsOpenWindowInfo types in nsWindowWatcher logic, r=kmag
#   
#   This patch builds on top of part 7.1 by creating this object within
#   nsWindowWatcher and ContentParent to carry the relevant information through
#   provider interfaces when creating new content windows. The nsOpenWindowInfo
# ==============================================================================

diff -r 8a13355b4ac4 -r 765d3364cca0 toolkit/components/windowwatcher/nsWindowWatcher.cpp
--- a/toolkit/components/windowwatcher/nsWindowWatcher.cpp	Mon Apr 06 14:29:59 2020 +0000
+++ b/toolkit/components/windowwatcher/nsWindowWatcher.cpp	Mon Apr 06 14:30:02 2020 +0000
@@ -49,6 +49,7 @@
 #include "nsIDOMStorageManager.h"
 #include "nsIWidget.h"
 #include "nsFocusManager.h"
+#include "nsOpenWindowInfo.h"
 #include "nsPresContext.h"
 #include "nsContentUtils.h"
 #include "nsIPrefBranch.h"
@@ -410,11 +411,12 @@
 
   return subjectPrincipal->GetUserContextId() == userContextId;
 }
-nsresult nsWindowWatcher::CreateChromeWindow(
-    const nsACString& aFeatures, nsIWebBrowserChrome* aParentChrome,
-    uint32_t aChromeFlags, nsIRemoteTab* aOpeningBrowserParent,
-    mozIDOMWindowProxy* aOpener, uint64_t aNextRemoteTabId,
-    nsIWebBrowserChrome** aResult) {
+
+nsresult nsWindowWatcher::CreateChromeWindow(const nsACString& aFeatures,
+                                             nsIWebBrowserChrome* aParentChrome,
+                                             uint32_t aChromeFlags,
+                                             nsIOpenWindowInfo* aOpenWindowInfo,
+                                             nsIWebBrowserChrome** aResult) {
   if (NS_WARN_IF(!mWindowCreator)) {
     return NS_ERROR_UNEXPECTED;
   }
@@ -422,8 +424,8 @@
   bool cancel = false;
   nsCOMPtr<nsIWebBrowserChrome> newWindowChrome;
   nsresult rv = mWindowCreator->CreateChromeWindow(
-      aParentChrome, aChromeFlags, aOpeningBrowserParent, aOpener,
-      aNextRemoteTabId, &cancel, getter_AddRefs(newWindowChrome));
+      aParentChrome, aChromeFlags, aOpenWindowInfo, &cancel,
+      getter_AddRefs(newWindowChrome));
 
   if (NS_SUCCEEDED(rv) && cancel) {
     newWindowChrome = nullptr;
@@ -463,10 +465,12 @@
 }
 
 NS_IMETHODIMP
-nsWindowWatcher::OpenWindowWithRemoteTab(
-    nsIRemoteTab* aRemoteTab, const nsACString& aFeatures, bool aCalledFromJS,
-    float aOpenerFullZoom, uint64_t aNextRemoteTabId, bool aForceNoOpener,
-    nsIRemoteTab** aResult) {
+nsWindowWatcher::OpenWindowWithRemoteTab(nsIRemoteTab* aRemoteTab,
+                                         const nsACString& aFeatures,
+                                         bool aCalledFromJS,
+                                         float aOpenerFullZoom,
+                                         nsIOpenWindowInfo* aOpenWindowInfo,
+                                         nsIRemoteTab** aResult) {
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(mWindowCreator);
 
@@ -484,20 +488,18 @@
       Preferences::GetBool("browser.privatebrowsing.autostart");
 
   nsCOMPtr<nsPIDOMWindowOuter> parentWindowOuter;
-  if (aRemoteTab) {
-    // We need to examine the window that aRemoteTab belongs to in
-    // order to inform us of what kind of window we're going to open.
-    BrowserHost* openingTab = BrowserHost::GetFrom(aRemoteTab);
-    parentWindowOuter = openingTab->GetParentWindowOuter();
+  RefPtr<BrowsingContext> parentBC = aOpenWindowInfo->GetParent();
+  if (parentBC) {
+    RefPtr<Element> browserElement = parentBC->Top()->GetEmbedderElement();
+    if (browserElement && browserElement->GetOwnerGlobal() &&
+        browserElement->GetOwnerGlobal()->AsInnerWindow()) {
+      parentWindowOuter =
+          browserElement->GetOwnerGlobal()->AsInnerWindow()->GetOuterWindow();
+    }
 
-    // Propagate the privacy & fission status of the parent window, if
-    // available, to the child.
-    nsCOMPtr<nsILoadContext> parentContext = openingTab->GetLoadContext();
-    if (parentContext) {
-      isFissionWindow = parentContext->UseRemoteSubframes();
-      isPrivateBrowsingWindow =
-          isPrivateBrowsingWindow || parentContext->UsePrivateBrowsing();
-    }
+    isFissionWindow = parentBC->UseRemoteSubframes();
+    isPrivateBrowsingWindow =
+        isPrivateBrowsingWindow || parentBC->UsePrivateBrowsing();
   }
 
   if (!parentWindowOuter) {
@@ -542,9 +544,8 @@
   nsCOMPtr<nsIWebBrowserChrome> parentChrome(do_GetInterface(parentTreeOwner));
   nsCOMPtr<nsIWebBrowserChrome> newWindowChrome;
 
-  CreateChromeWindow(aFeatures, parentChrome, chromeFlags,
-                     aForceNoOpener ? nullptr : aRemoteTab, nullptr,
-                     aNextRemoteTabId, getter_AddRefs(newWindowChrome));
+  CreateChromeWindow(aFeatures, parentChrome, chromeFlags, aOpenWindowInfo,
+                     getter_AddRefs(newWindowChrome));
 
   if (NS_WARN_IF(!newWindowChrome)) {
     return NS_ERROR_UNEXPECTED;
@@ -780,6 +781,29 @@
     }
   }
 
+  // Information used when opening new content windows. This object will be
+  // passed through to the inner nsFrameLoader.
+  RefPtr<nsOpenWindowInfo> openWindowInfo;
+  if (!newBC && !windowTypeIsChrome) {
+    openWindowInfo = new nsOpenWindowInfo();
+    openWindowInfo->mForceNoOpener = aForceNoOpener;
+    openWindowInfo->mParent = parentBC;
+
+    // We're going to want the window to be immediately available, meaning we
+    // want it to match the current remoteness.
+    openWindowInfo->mIsRemote = XRE_IsContentProcess();
+
+    // If we have a non-system non-expanded subject principal, we can inherit
+    // our OriginAttributes from it.
+    nsCOMPtr<nsIPrincipal> subjectPrincipal =
+        nsContentUtils::SubjectPrincipalOrSystemIfNativeCaller();
+    if (subjectPrincipal &&
+        !nsContentUtils::IsSystemOrExpandedPrincipal(subjectPrincipal)) {
+      openWindowInfo->mOriginAttributes =
+          subjectPrincipal->OriginAttributesRef();
+    }
+  }
+
   uint32_t activeDocsSandboxFlags = 0;
   if (!newBC) {
     // We're going to either open up a new window ourselves or ask a
@@ -806,6 +830,8 @@
         !(chromeFlags & (nsIWebBrowserChrome::CHROME_MODAL |
                          nsIWebBrowserChrome::CHROME_OPENAS_DIALOG |
                          nsIWebBrowserChrome::CHROME_OPENAS_CHROME))) {
+      MOZ_ASSERT(openWindowInfo);
+
       nsCOMPtr<nsIWindowProvider> provider;
       if (parentTreeOwner) {
         provider = do_GetInterface(parentTreeOwner);
@@ -816,10 +842,11 @@
       }
 
       if (provider) {
-        rv = provider->ProvideWindow(
-            aParent, chromeFlags, aCalledFromJS, sizeSpec.WidthSpecified(),
-            uriToLoad, name, features, aForceNoOpener, aForceNoReferrer,
-            aLoadState, &windowIsNew, getter_AddRefs(newBC));
+        rv = provider->ProvideWindow(openWindowInfo, chromeFlags, aCalledFromJS,
+                                     sizeSpec.WidthSpecified(), uriToLoad, name,
+                                     features, aForceNoOpener, aForceNoReferrer,
+                                     aLoadState, &windowIsNew,
+                                     getter_AddRefs(newBC));
 
         if (NS_SUCCEEDED(rv) && newBC) {
           nsCOMPtr<nsIDocShell> newDocShell = newBC->GetDocShell();
@@ -914,9 +941,8 @@
          completely honest: we clear that indicator if the opener is chrome, so
          that the downstream consumer can treat the indicator to mean simply
          that the new window is subject to popup control. */
-      mozIDOMWindowProxy* openerWindow = aForceNoOpener ? nullptr : aParent;
-      rv = CreateChromeWindow(features, parentChrome, chromeFlags, nullptr,
-                              openerWindow, 0, getter_AddRefs(newChrome));
+      rv = CreateChromeWindow(features, parentChrome, chromeFlags,
+                              openWindowInfo, getter_AddRefs(newChrome));
 
       if (parentTopInnerWindow) {
         parentTopInnerWindow->Resume();