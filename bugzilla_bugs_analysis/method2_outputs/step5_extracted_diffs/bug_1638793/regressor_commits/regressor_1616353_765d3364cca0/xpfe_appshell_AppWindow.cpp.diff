# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpfe/appshell/AppWindow.cpp
# Commit: 765d3364cca0
# Full Hash: 765d3364cca0a67c614cb4fb5dff413a8c29d834
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-04-07 03:53:09
# Regressor Bug: 1616353
# File Overlap Count: 1
# Description:
#   Bug 1616353 - Part 7.2: Create and use nsOpenWindowInfo types in nsWindowWatcher logic, r=kmag
#   
#   This patch builds on top of part 7.1 by creating this object within
#   nsWindowWatcher and ContentParent to carry the relevant information through
#   provider interfaces when creating new content windows. The nsOpenWindowInfo
# ==============================================================================

diff -r 8a13355b4ac4 -r 765d3364cca0 xpfe/appshell/AppWindow.cpp
--- a/xpfe/appshell/AppWindow.cpp	Mon Apr 06 14:29:59 2020 +0000
+++ b/xpfe/appshell/AppWindow.cpp	Mon Apr 06 14:30:02 2020 +0000
@@ -32,6 +32,7 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIIOService.h"
 #include "nsIObserverService.h"
+#include "nsIOpenWindowInfo.h"
 #include "nsIWindowMediator.h"
 #include "nsIScreenManager.h"
 #include "nsIScreen.h"
@@ -126,7 +127,6 @@
       mPersistentAttributesDirty(0),
       mPersistentAttributesMask(0),
       mChromeFlags(aChromeFlags),
-      mNextRemoteTabId(0),
       mSPTimerLock("AppWindow.mSPTimerLock"),
       mWidgetListenerDelegate(this) {}
 
@@ -157,8 +157,7 @@
 
 nsresult AppWindow::Initialize(nsIAppWindow* aParent, nsIAppWindow* aOpener,
                                int32_t aInitialWidth, int32_t aInitialHeight,
-                               bool aIsHiddenWindow, nsIRemoteTab* aOpeningTab,
-                               mozIDOMWindowProxy* aOpenerWindow,
+                               bool aIsHiddenWindow,
                                nsWidgetInitData& widgetInitData) {
   nsresult rv;
   nsCOMPtr<nsIWidget> parentWidget;
@@ -230,22 +229,17 @@
   // since we no longer use content child widgets.
   mWindow->SetBackgroundColor(NS_RGB(255, 255, 255));
 
+  // All Chrome BCs exist within the same BrowsingContextGroup, so we don't need
+  // to pass in the opener window here. The opener is set later, if needed, by
+  // nsWindowWatcher.
+  RefPtr<BrowsingContext> browsingContext =
+      BrowsingContext::Create(/* aParent */ nullptr, /* aOpener */ nullptr,
+                              EmptyString(), BrowsingContext::Type::Chrome);
+
   // Create web shell
-  RefPtr<BrowsingContext> openerContext =
-      aOpenerWindow
-          ? nsPIDOMWindowOuter::From(aOpenerWindow)->GetBrowsingContext()
-          : nullptr;
-  RefPtr<BrowsingContext> browsingContext =
-      BrowsingContext::Create(/* aParent */ nullptr, openerContext,
-                              EmptyString(), BrowsingContext::Type::Chrome);
   mDocShell = nsDocShell::Create(browsingContext);
   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
 
-  // XXX(nika): This is used to handle propagating opener across remote tab
-  // creation. We should come up with a better system for doing this (probably
-  // based on BrowsingContext).
-  mDocShell->SetOpener(aOpeningTab);
-
   // Make sure to set the item type on the docshell _before_ calling
   // Create() so it knows what type it is.
   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(mDocShell);
@@ -268,16 +262,6 @@
                                      nsIWebProgress::NOTIFY_STATE_NETWORK);
   }
 
-#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
-  if (aOpenerWindow) {
-    BrowsingContext* bc = mDocShell->GetBrowsingContext();
-    BrowsingContext* openerBC =
-        nsPIDOMWindowOuter::From(aOpenerWindow)->GetBrowsingContext();
-    MOZ_DIAGNOSTIC_ASSERT(bc->GetOpenerId() == openerBC->Id());
-    MOZ_DIAGNOSTIC_ASSERT(bc->HadOriginalOpener());
-  }
-#endif
-
   return rv;
 }
 
@@ -2105,26 +2089,21 @@
 
 // top-level function to create a new window
 NS_IMETHODIMP AppWindow::CreateNewWindow(int32_t aChromeFlags,
-                                         nsIRemoteTab* aOpeningTab,
-                                         mozIDOMWindowProxy* aOpener,
-                                         uint64_t aNextRemoteTabId,
+                                         nsIOpenWindowInfo* aOpenWindowInfo,
                                          nsIAppWindow** _retval) {
   NS_ENSURE_ARG_POINTER(_retval);
 
   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME) {
     MOZ_RELEASE_ASSERT(
-        aNextRemoteTabId == 0,
-        "Unexpected next remote tab ID, should never have a non-zero "
-        "aNextRemoteTabId when creating a new chrome window");
-    return CreateNewChromeWindow(aChromeFlags, aOpeningTab, aOpener, _retval);
+        !aOpenWindowInfo,
+        "Unexpected nsOpenWindowInfo when creating a new chrome window");
+    return CreateNewChromeWindow(aChromeFlags, _retval);
   }
-  return CreateNewContentWindow(aChromeFlags, aOpeningTab, aOpener,
-                                aNextRemoteTabId, _retval);
+
+  return CreateNewContentWindow(aChromeFlags, aOpenWindowInfo, _retval);
 }
 
 NS_IMETHODIMP AppWindow::CreateNewChromeWindow(int32_t aChromeFlags,
-                                               nsIRemoteTab* aOpeningTab,
-                                               mozIDOMWindowProxy* aOpener,
                                                nsIAppWindow** _retval) {
   nsCOMPtr<nsIAppShellService> appShell(
       do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
@@ -2134,8 +2113,7 @@
   nsCOMPtr<nsIAppWindow> newWindow;
   appShell->CreateTopLevelWindow(
       this, nullptr, aChromeFlags, nsIAppShellService::SIZE_TO_CONTENT,
-      nsIAppShellService::SIZE_TO_CONTENT, aOpeningTab, aOpener,
-      getter_AddRefs(newWindow));
+      nsIAppShellService::SIZE_TO_CONTENT, getter_AddRefs(newWindow));
 
   NS_ENSURE_TRUE(newWindow, NS_ERROR_FAILURE);
 
@@ -2144,11 +2122,9 @@
   return NS_OK;
 }
 
-NS_IMETHODIMP AppWindow::CreateNewContentWindow(int32_t aChromeFlags,
-                                                nsIRemoteTab* aOpeningTab,
-                                                mozIDOMWindowProxy* aOpener,
-                                                uint64_t aNextRemoteTabId,
-                                                nsIAppWindow** _retval) {
+NS_IMETHODIMP AppWindow::CreateNewContentWindow(
+    int32_t aChromeFlags, nsIOpenWindowInfo* aOpenWindowInfo,
+    nsIAppWindow** _retval) {
   nsCOMPtr<nsIAppShellService> appShell(
       do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
@@ -2175,34 +2151,20 @@
   nsCOMPtr<nsIAppWindow> newWindow;
   {
     AutoNoJSAPI nojsapi;
-    // We actually want this toplevel window which we are creating to have a
-    // null opener, as we will be creating the content xul:browser window inside
-    // of it, so we pass nullptr as our aOpener.
     appShell->CreateTopLevelWindow(this, uri, aChromeFlags, 615, 480,
-                                   aOpeningTab, nullptr,
                                    getter_AddRefs(newWindow));
     NS_ENSURE_TRUE(newWindow, NS_ERROR_FAILURE);
   }
 
+  AppWindow* appWin =
+      static_cast<AppWindow*>(static_cast<nsIAppWindow*>(newWindow));
+
+  // Specify which flags should be used by browser.xhtml to create the initial
+  // content browser window.
+  appWin->mInitialOpenWindowInfo = aOpenWindowInfo;
+
   // Specify that we want the window to remain locked until the chrome has
   // loaded.
-  AppWindow* appWin =
-      static_cast<AppWindow*>(static_cast<nsIAppWindow*>(newWindow));
-
-  if (aNextRemoteTabId) {
-    appWin->mNextRemoteTabId = aNextRemoteTabId;
-  }
-
-  if (aOpener) {
-    nsCOMPtr<nsIDocShell> docShell;
-    appWin->GetDocShell(getter_AddRefs(docShell));
-    MOZ_ASSERT(docShell);
-    nsCOMPtr<nsPIDOMWindowOuter> window = docShell->GetWindow();
-    MOZ_ASSERT(window);
-    window->SetOpenerForInitialContentBrowser(
-        nsPIDOMWindowOuter::From(aOpener)->GetBrowsingContext());
-  }
-
   appWin->LockUntilChromeLoad();
 
   {
@@ -2212,7 +2174,8 @@
 
   NS_ENSURE_STATE(appWin->mPrimaryContentShell ||
                   appWin->mPrimaryBrowserParent);
-  MOZ_ASSERT_IF(appWin->mPrimaryContentShell, aNextRemoteTabId == 0);
+  MOZ_ASSERT_IF(appWin->mPrimaryContentShell,
+                aOpenWindowInfo->GetNextRemoteBrowserId() == 0);
 
   newWindow.forget(_retval);
 
@@ -2610,9 +2573,10 @@
   return NS_OK;
 }
 
-nsresult AppWindow::GetNextRemoteTabId(uint64_t* aNextRemoteTabId) {
-  NS_ENSURE_ARG_POINTER(aNextRemoteTabId);
-  *aNextRemoteTabId = mNextRemoteTabId;
+nsresult AppWindow::GetInitialOpenWindowInfo(
+    nsIOpenWindowInfo** aOpenWindowInfo) {
+  NS_ENSURE_ARG_POINTER(aOpenWindowInfo);
+  *aOpenWindowInfo = do_AddRef(mInitialOpenWindowInfo).take();
   return NS_OK;
 }
 