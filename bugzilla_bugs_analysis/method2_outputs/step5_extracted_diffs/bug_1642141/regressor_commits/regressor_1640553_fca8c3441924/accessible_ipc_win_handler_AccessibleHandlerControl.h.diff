# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/win/handler/AccessibleHandlerControl.h
# Commit: fca8c3441924
# Full Hash: fca8c3441924c518a8a748bb2bf28ad7ef59c8c2
# Author: James Teh <jteh@mozilla.com>
# Date: 2020-05-26 15:44:42
# Regressor Bug: 1640553
# File Overlap Count: 2
# Description:
#   Bug 1640553 part 1: Add the ability for AccessibleHandler to cache accessibles by id. r=eeejay
#   
#   This cache is cleared when other AccessibleHandler caches are invalidated; i.e. when an event is fired.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D76665
# ==============================================================================

diff -r 98fd4fe746ea -r fca8c3441924 accessible/ipc/win/handler/AccessibleHandlerControl.h
--- a/accessible/ipc/win/handler/AccessibleHandlerControl.h	Tue May 26 06:43:06 2020 +0300
+++ b/accessible/ipc/win/handler/AccessibleHandlerControl.h	Tue May 26 01:10:26 2020 +0000
@@ -11,6 +11,7 @@
 #ifndef mozilla_a11y_AccessibleHandlerControl_h
 #  define mozilla_a11y_AccessibleHandlerControl_h
 
+#  include <unordered_map>
 #  include "Factory.h"
 #  include "HandlerData.h"
 #  include "IUnknownImpl.h"
@@ -48,6 +49,8 @@
 
 }  // namespace detail
 
+class AccessibleHandler;
+
 class AccessibleHandlerControl final : public IHandlerControl {
  public:
   static HRESULT Create(AccessibleHandlerControl** aOutObject);
@@ -69,6 +72,9 @@
 
   HRESULT Register(NotNull<IGeckoBackChannel*> aGecko);
 
+  void CacheAccessible(long aUniqueId, AccessibleHandler* aAccessible);
+  HRESULT GetCachedAccessible(long aUniqueId, AccessibleHandler** aAccessible);
+
  private:
   AccessibleHandlerControl();
   ~AccessibleHandlerControl() = default;
@@ -78,6 +84,8 @@
   detail::TextChange mTextChange;
   UniquePtr<mscom::RegisteredProxy> mIA2Proxy;
   UniquePtr<mscom::RegisteredProxy> mHandlerProxy;
+  // We can't use Gecko APIs in this dll, hence the use of std::unordered_map.
+  std::unordered_map<long, RefPtr<AccessibleHandler>> mAccessibleCache;
 };
 
 extern mscom::SingletonFactory<AccessibleHandlerControl> gControlFactory;
