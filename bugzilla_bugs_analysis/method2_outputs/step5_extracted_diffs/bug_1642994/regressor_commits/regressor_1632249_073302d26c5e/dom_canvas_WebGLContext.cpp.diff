# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContext.cpp
# Commit: 073302d26c5e
# Full Hash: 073302d26c5e1ac8229fca1b32656de68756e0f2
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 09:34:54
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Create a separate WebGLContext::PresentInto function for WebXR. r=jgilbert
#   
#   - Do not apply mIsCanvasDirty bailout when presenting from a opaque FBO
#   back buffer.
#   - Create a separate WebGLContext::PresentInto with more specific XR
# ==============================================================================

diff -r 7c94d37c446e -r 073302d26c5e dom/canvas/WebGLContext.cpp
--- a/dom/canvas/WebGLContext.cpp	Thu Jun 11 06:37:36 2020 +0000
+++ b/dom/canvas/WebGLContext.cpp	Thu Jun 11 06:37:38 2020 +0000
@@ -942,14 +942,46 @@
   return true;
 }
 
+bool WebGLContext::PresentIntoXR(gl::SwapChain& swapChain,
+                                 const gl::MozFramebuffer& fb) {
+  OnEndOfFrame();
+
+  auto presenter = swapChain.Acquire(fb.mSize);
+  if (!presenter) {
+    GenerateWarning("Swap chain surface creation failed.");
+    LoseContext();
+    return false;
+  }
+
+  const auto destFb = presenter->Fb();
+  gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, destFb);
+
+  BlitBackbufferToCurDriverFB(&fb);
+
+  // https://immersive-web.github.io/webxr/#opaque-framebuffer
+  // Opaque framebuffers will always be cleared regardless of the
+  // associated WebGL contextâ€™s preserveDrawingBuffer value.
+  if (gl->IsSupported(gl::GLFeature::invalidate_framebuffer)) {
+    gl->fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER, fb.mFB);
+    constexpr auto attachments = MakeArray<GLenum>(
+        LOCAL_GL_COLOR_ATTACHMENT0, LOCAL_GL_DEPTH_STENCIL_ATTACHMENT);
+    gl->fInvalidateFramebuffer(LOCAL_GL_READ_FRAMEBUFFER, attachments.size(),
+                               attachments.data());
+  }
+
+  return true;
+}
+
 void WebGLContext::Present(WebGLFramebuffer* const fb,
                            const layers::TextureType consumerType) {
   const FuncScope funcScope(*this, "<Present>");
   if (IsContextLost()) return;
 
   auto swapChain = &mSwapChain;
+  const gl::MozFramebuffer* maybeFB = nullptr;
   if (fb) {
     swapChain = &fb->mOpaqueSwapChain;
+    maybeFB = fb->mOpaque.get();
   } else {
     mResolvedDefaultFB = nullptr;
   }
@@ -966,7 +998,11 @@
   }
   MOZ_ASSERT(swapChain->mFactory);
 
-  (void)PresentInto(*swapChain);
+  if (maybeFB) {
+    (void)PresentIntoXR(*swapChain, *maybeFB);
+  } else {
+    (void)PresentInto(*swapChain);
+  }
 }
 
 Maybe<layers::SurfaceDescriptor> WebGLContext::GetFrontBuffer(