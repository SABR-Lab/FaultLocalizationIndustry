# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/ClientWebGLContext.cpp
# Commit: 16c5dd2cfd60
# Full Hash: 16c5dd2cfd600a62c80ca17cfb35c0868e016056
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-15 21:48:38
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r ca8139d58d58 -r 16c5dd2cfd60 dom/canvas/ClientWebGLContext.cpp
--- a/dom/canvas/ClientWebGLContext.cpp	Fri Jun 12 21:53:14 2020 +0000
+++ b/dom/canvas/ClientWebGLContext.cpp	Mon Jun 15 18:25:55 2020 +0000
@@ -398,82 +398,59 @@
 
 // ------------------------- Composition, etc -------------------------
 
-static uint8_t gWebGLLayerUserData;
-
-class WebGLContextUserData : public LayerUserData {
- public:
-  explicit WebGLContextUserData(HTMLCanvasElement* canvas) : mCanvas(canvas) {}
-
-  /* PreTransactionCallback gets called by the Layers code every time the
-   * WebGL canvas is going to be composited.
-   */
-  static void PreTransactionCallback(void* data) {
-    ClientWebGLContext* webgl = static_cast<ClientWebGLContext*>(data);
-
-    // Prepare the context for composition
-    webgl->BeginComposition();
-  }
-
-  /** DidTransactionCallback gets called by the Layers code everytime the WebGL
-   * canvas gets composite, so it really is the right place to put actions that
-   * have to be performed upon compositing
-   */
-  static void DidTransactionCallback(void* data) {
-    ClientWebGLContext* webgl = static_cast<ClientWebGLContext*>(data);
-
-    // Clean up the context after composition
-    webgl->EndComposition();
-  }
-
- private:
-  RefPtr<HTMLCanvasElement> mCanvas;
-};
-
-void ClientWebGLContext::BeginComposition() {
-  // When running single-process WebGL, Present needs to be called in
-  // BeginComposition so that it is done _before_ the CanvasRenderer to
-  // Update attaches it for composition.
-  // When running cross-process WebGL, Present needs to be called in
-  // EndComposition so that it happens _after_ the OOPCanvasRenderer's
-  // Update tells it what CompositableHost to use,
-  if (!mNotLost) return;
-  if (mNotLost->inProcess) {
-    WEBGL_BRIDGE_LOGI("[%p] Presenting", this);
-    Run<RPROC(Present)>();
-  }
-}
+void ClientWebGLContext::OnBeforePaintTransaction() { Present(); }
 
 void ClientWebGLContext::EndComposition() {
-  if (!mNotLost) return;
-  if (mNotLost->outOfProcess) {
-    WEBGL_BRIDGE_LOGI("[%p] Presenting", this);
-    Run<RPROC(Present)>();
-  }
-
   // Mark ourselves as no longer invalidated.
   MarkContextClean();
 }
 
-void ClientWebGLContext::Present() { Run<RPROC(Present)>(); }
-
-void ClientWebGLContext::ClearVRFrame() const { Run<RPROC(ClearVRFrame)>(); }
-
-RefPtr<layers::SharedSurfaceTextureClient> ClientWebGLContext::GetVRFrame(
-    const WebGLFramebufferJS* fb) const {
-  const auto notLost =
-      mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.
-  if (!notLost) return nullptr;
-  const auto& inProcessContext = notLost->inProcess;
-  if (inProcessContext) {
-    return inProcessContext->GetVRFrame(fb ? fb->mId : 0);
-  }
-  MOZ_ASSERT_UNREACHABLE("TODO: Remote GetVRFrame");
-  return nullptr;
-}
+// -
+
+namespace webgl {
+
+void Present(ClientWebGLContext& webgl) { webgl.Present(); }
+
+Maybe<layers::SurfaceDescriptor> GetFrontBuffer(
+    ClientWebGLContext& webgl, layers::KnowsCompositor* const kc) {
+  auto texType = layers::TextureType::Unknown;
+  if (kc) {
+    texType = layers::PreferredCanvasTextureType(*kc);
+  }
+  return webgl.GetFrontBuffer(texType);
+}
+
+}  // namespace webgl
+
+// -
+
+void ClientWebGLContext::Present() {
+  if (!mIsCanvasDirty) return;
+  mIsCanvasDirty = false;
+  mFrontBufferDesc = nullptr;
+  mFrontBufferSnapshot = nullptr;
+
+  Run<RPROC(Present)>();
+}
+
+Maybe<layers::SurfaceDescriptor> ClientWebGLContext::GetFrontBuffer(
+    const layers::TextureType type) {
+  if (!mFrontBufferDesc) {
+    const auto desc = Run<RPROC(GetFrontBuffer)>(type);
+    if (desc) {
+      mFrontBufferDesc = MakeUnique<layers::SurfaceDescriptor>(*desc);
+    }
+  }
+
+  if (!mFrontBufferDesc) return Nothing();
+  return Some(*mFrontBufferDesc);
+}
+
+// -
 
 already_AddRefed<layers::Layer> ClientWebGLContext::GetCanvasLayer(
     nsDisplayListBuilder* builder, Layer* oldLayer, LayerManager* manager) {
-  if (!mResetLayer && oldLayer && oldLayer->HasUserData(&gWebGLLayerUserData)) {
+  if (!mResetLayer && oldLayer) {
     RefPtr<layers::Layer> ret = oldLayer;
     return ret.forget();
   }
@@ -486,14 +463,7 @@
     return nullptr;
   }
 
-  WebGLContextUserData* userData = nullptr;
-  if (builder->IsPaintingToWindow() && mCanvasElement) {
-    userData = new WebGLContextUserData(mCanvasElement);
-  }
-
-  canvasLayer->SetUserData(&gWebGLLayerUserData, userData);
-
-  CanvasRenderer* canvasRenderer = canvasLayer->CreateOrGetCanvasRenderer();
+  const auto canvasRenderer = canvasLayer->CreateOrGetCanvasRenderer();
   if (!InitializeCanvasRenderer(builder, canvasRenderer)) return nullptr;
 
   uint32_t flags = 0;
@@ -503,7 +473,6 @@
   canvasLayer->SetContentFlags(flags);
 
   mResetLayer = false;
-
   return canvasLayer.forget();
 }
 
@@ -533,54 +502,19 @@
   const FuncScope funcScope(*this, "<InitializeCanvasRenderer>");
   if (IsContextLost()) return false;
 
-  Maybe<ICRData> icrData =
-      Run<RPROC(InitializeCanvasRenderer)>(GetCompositorBackendType());
-
-  if (!icrData) {
-    return false;
-  }
-
-  mSurfaceInfo = *icrData;
-
-  CanvasInitializeData data;
+  CanvasRendererData data;
+  data.mContext = mSharedPtrPtr;
+  data.mOriginPos = gl::OriginPos::BottomLeft;
+
+  const auto& options = *mInitialOptions;
+  const auto& size = DrawingBufferSize();
+  data.mIsOpaque = !options.alpha;
+  data.mIsAlphaPremult = !options.alpha || options.premultipliedAlpha;
+  data.mSize = {size.x, size.y};
+
   if (aBuilder->IsPaintingToWindow() && mCanvasElement) {
-    // Make the layer tell us whenever a transaction finishes (including
-    // the current transaction), so we can clear our invalidation state and
-    // start invalidating again. We need to do this for the layer that is
-    // being painted to a window (there shouldn't be more than one at a time,
-    // and if there is, flushing the invalidation state more often than
-    // necessary is harmless).
-
-    // The layer will be destroyed when we tear down the presentation
-    // (at the latest), at which time this userData will be destroyed,
-    // releasing the reference to the element.
-    // The userData will receive DidTransactionCallbacks, which flush the
-    // the invalidation state to indicate that the canvas is up to date.
-    data.mPreTransCallback = WebGLContextUserData::PreTransactionCallback;
-    data.mPreTransCallbackData = this;
-    data.mDidTransCallback = WebGLContextUserData::DidTransactionCallback;
-    data.mDidTransCallbackData = this;
-  }
-
-  MOZ_ASSERT(mCanvasElement);  // TODO: What to do here?  Is this about
-                               // OffscreenCanvas?
-
-  if (!mNotLost) return false;
-
-  if (mNotLost->outOfProcess) {
-    data.mOOPRenderer = mCanvasElement->GetOOPCanvasRenderer();
-    MOZ_ASSERT(data.mOOPRenderer);
-    MOZ_ASSERT((!data.mOOPRenderer->mContext) ||
-               (data.mOOPRenderer->mContext == this));
-    data.mOOPRenderer->mContext = this;
-  } else {
-    MOZ_ASSERT(mNotLost->inProcess);
-    data.mGLContext = mNotLost->inProcess->GetWebGLContext()->gl;
-  }
-
-  data.mHasAlpha = mSurfaceInfo.hasAlpha;
-  data.mIsGLAlphaPremult = mSurfaceInfo.isPremultAlpha || !data.mHasAlpha;
-  data.mSize = mSurfaceInfo.size;
+    data.mDoPaintCallbacks = true;
+  }
 
   aRenderer->Initialize(data);
   aRenderer->SetDirty();
@@ -672,13 +606,24 @@
   if (!size.y) {
     size.y = 1;
   }
+  const auto prevRequestedSize = mRequestedSize;
+  mRequestedSize = size;
 
   mResetLayer = true;  // Always treat this as resize.
 
   if (mNotLost) {
     auto& state = State();
+
+    auto curSize = prevRequestedSize;
+    if (state.mDrawingBufferSize) {
+      curSize = *state.mDrawingBufferSize;
+    }
+    if (size == curSize) return NS_OK;  // MUST skip no-op resize
+
+    if (mIsCanvasDirty) {
+      Present();
+    }
     state.mDrawingBufferSize = Nothing();
-
     Run<RPROC(Resize)>(size);
 
     MarkCanvasDirty();
@@ -791,6 +736,7 @@
     return false;
   }
   mNotLost = pNotLost;
+  MarkCanvasDirty();
 
   // Init state
   const auto& limits = Limits();
@@ -922,6 +868,67 @@
   const auto notLost =
       mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.
 
+  auto ret = BackBufferSnapshot();
+  if (!ret) return nullptr;
+
+  // -
+
+  const auto& options = mNotLost->info.options;
+
+  auto srcAlphaType = gfxAlphaType::Opaque;
+  if (options.alpha) {
+    if (options.premultipliedAlpha) {
+      srcAlphaType = gfxAlphaType::Premult;
+    } else {
+      srcAlphaType = gfxAlphaType::NonPremult;
+    }
+  }
+
+  if (out_alphaType) {
+    *out_alphaType = srcAlphaType;
+  } else {
+    // Expects Opaque or Premult
+    if (srcAlphaType == gfxAlphaType::NonPremult) {
+      const auto nonPremultSurf = ret;
+      const auto& size = nonPremultSurf->GetSize();
+      const auto format = nonPremultSurf->GetFormat();
+      ret = gfx::Factory::CreateDataSourceSurface(size, format, /*zero=*/false);
+      gfxUtils::PremultiplyDataSurface(nonPremultSurf, ret);
+    }
+  }
+
+  return ret.forget();
+}
+
+RefPtr<gfx::SourceSurface> ClientWebGLContext::GetFrontBufferSnapshot() {
+  const FuncScope funcScope(*this, "<GetSurfaceSnapshot>");
+  if (IsContextLost()) return nullptr;
+  const auto notLost =
+      mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.
+
+  const auto& options = mNotLost->info.options;
+
+  if (!mFrontBufferSnapshot) {
+    mFrontBufferSnapshot = Run<RPROC(GetFrontBufferSnapshot)>();
+    if (!mFrontBufferSnapshot) return nullptr;
+
+    if (options.alpha && !options.premultipliedAlpha) {
+      const auto nonPremultSurf = mFrontBufferSnapshot;
+      const auto& size = nonPremultSurf->GetSize();
+      const auto format = nonPremultSurf->GetFormat();
+      mFrontBufferSnapshot =
+          gfx::Factory::CreateDataSourceSurface(size, format, /*zero=*/false);
+      gfxUtils::PremultiplyDataSurface(nonPremultSurf, mFrontBufferSnapshot);
+    }
+  }
+  return mFrontBufferSnapshot;
+}
+
+RefPtr<gfx::DataSourceSurface> ClientWebGLContext::BackBufferSnapshot() {
+  if (IsContextLost()) return nullptr;
+  const auto notLost =
+      mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.
+
   const auto& options = mNotLost->info.options;
   const auto& state = State();
 
@@ -970,64 +977,31 @@
     MOZ_ASSERT(static_cast<uint32_t>(map.GetStride()) == stride);
 
     const auto desc = webgl::ReadPixelsDesc{{0, 0}, size};
-
     const auto range = Range<uint8_t>(map.GetData(), stride * size.y);
-    auto view = RawBufferView(range);
-
-    const auto notLost =
-        mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.
-    if (!notLost) return nullptr;
-    const auto& inProcessContext = notLost->inProcess;
-    if (inProcessContext) {
-      inProcessContext->ReadPixels(desc, view);
-    } else {
-      MOZ_ASSERT_UNREACHABLE("TODO: Remote GetSurfaceSnapshot");
+    DoReadPixels(desc, range);
+
+    const auto begin = range.begin().get();
+
+    std::vector<uint8_t> temp;
+    temp.resize(stride);
+    for (const auto i : IntegerRange(size.y / 2)) {
+      const auto top = begin + stride * i;
+      const auto bottom = begin + stride * (size.y - 1 - i);
+      memcpy(temp.data(), top, stride);
+      memcpy(top, bottom, stride);
+      gfxUtils::ConvertBGRAtoRGBA(top, stride);
+
+      memcpy(bottom, temp.data(), stride);
+      gfxUtils::ConvertBGRAtoRGBA(bottom, stride);
     }
-    // -
-
-    const auto swapRowRedBlue = [&](uint8_t* const row) {
-      for (const auto x : IntegerRange(size.x)) {
-        std::swap(row[4 * x], row[4 * x + 2]);
-      }
-    };
-
-    std::vector<uint8_t> tempRow(stride);
-    for (const auto srcY : IntegerRange(size.y / 2)) {
-      const auto dstY = size.y - 1 - srcY;
-      const auto srcRow = (range.begin() + (stride * srcY)).get();
-      const auto dstRow = (range.begin() + (stride * dstY)).get();
-      memcpy(tempRow.data(), dstRow, stride);
-      memcpy(dstRow, srcRow, stride);
-      swapRowRedBlue(dstRow);
-      memcpy(srcRow, tempRow.data(), stride);
-      swapRowRedBlue(srcRow);
+
+    if (size.y % 2) {
+      const auto middle = begin + stride * (size.y / 2);
+      gfxUtils::ConvertBGRAtoRGBA(middle, stride);
     }
-    if (size.y & 1) {
-      const auto midY = size.y / 2;  // size.y = 3 => midY = 1
-      const auto midRow = (range.begin() + (stride * midY)).get();
-      swapRowRedBlue(midRow);
-    }
-  }
-
-  gfxAlphaType srcAlphaType;
-  if (!options.alpha) {
-    srcAlphaType = gfxAlphaType::Opaque;
-  } else if (options.premultipliedAlpha) {
-    srcAlphaType = gfxAlphaType::Premult;
-  } else {
-    srcAlphaType = gfxAlphaType::NonPremult;
-  }
-
-  if (out_alphaType) {
-    *out_alphaType = srcAlphaType;
-  } else {
-    // Expects Opaque or Premult
-    if (srcAlphaType == gfxAlphaType::NonPremult) {
-      gfxUtils::PremultiplyDataSurface(surf, surf);
-    }
-  }
-
-  return surf.forget();
+  }
+
+  return surf;
 }
 
 UniquePtr<uint8_t[]> ClientWebGLContext::GetImageBuffer(int32_t* out_format) {
@@ -4093,7 +4067,12 @@
                                           {format, type},
                                           state.mPixelPackState};
   const auto range = Range<uint8_t>(bytes, byteLen);
-  auto view = RawBufferView(range);
+  DoReadPixels(desc, range);
+}
+
+void ClientWebGLContext::DoReadPixels(const webgl::ReadPixelsDesc& desc,
+                                      const Range<uint8_t> dest) const {
+  auto view = RawBufferView(dest);
 
   const auto notLost =
       mNotLost;  // Hold a strong-ref to prevent LoseContext=>UAF.