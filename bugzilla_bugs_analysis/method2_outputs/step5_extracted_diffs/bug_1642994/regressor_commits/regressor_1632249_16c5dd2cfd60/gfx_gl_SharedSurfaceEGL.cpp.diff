# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/SharedSurfaceEGL.cpp
# Commit: 16c5dd2cfd60
# Full Hash: 16c5dd2cfd600a62c80ca17cfb35c0868e016056
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-15 21:48:38
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r ca8139d58d58 -r 16c5dd2cfd60 gfx/gl/SharedSurfaceEGL.cpp
--- a/gfx/gl/SharedSurfaceEGL.cpp	Fri Jun 12 21:53:14 2020 +0000
+++ b/gfx/gl/SharedSurfaceEGL.cpp	Mon Jun 15 18:25:55 2020 +0000
@@ -5,11 +5,13 @@
 
 #include "SharedSurfaceEGL.h"
 
+#include "AndroidNativeWindow.h"
 #include "GLBlitHelper.h"
 #include "GLContextEGL.h"
 #include "GLContextProvider.h"
 #include "GLLibraryEGL.h"
 #include "GLReadTexImageHelper.h"
+#include "MozFramebuffer.h"
 #include "mozilla/layers/LayersSurfaces.h"  // for SurfaceDescriptor, etc
 #include "SharedSurface.h"
 
@@ -20,66 +22,56 @@
 namespace mozilla {
 namespace gl {
 
+static bool HasEglImageExtensions(const GLContextEGL& gl) {
+  const auto& egl = *(gl.mEgl);
+  return egl.HasKHRImageBase() &&
+         egl.IsExtensionSupported(GLLibraryEGL::KHR_gl_texture_2D_image) &&
+         (gl.IsExtensionSupported(GLContext::OES_EGL_image_external) ||
+          gl.IsExtensionSupported(GLContext::OES_EGL_image));
+}
+
+/*static*/
+UniquePtr<SurfaceFactory_EGLImage> SurfaceFactory_EGLImage::Create(
+    GLContext& gl_) {
+  auto& gl = *GLContextEGL::Cast(&gl_);
+  if (!HasEglImageExtensions(gl)) return nullptr;
+
+  const auto partialDesc = PartialSharedSurfaceDesc{
+      &gl, SharedSurfaceType::EGLImageShare, layers::TextureType::EGLImage,
+      false,  // Can't recycle, as mSync changes never update TextureHost.
+  };
+  return AsUnique(new SurfaceFactory_EGLImage(partialDesc));
+}
+
+// -
+
 /*static*/
 UniquePtr<SharedSurface_EGLImage> SharedSurface_EGLImage::Create(
-    GLContext* prodGL, const GLFormats& formats, const gfx::IntSize& size,
-    bool hasAlpha, EGLContext context) {
-  const auto& gle = GLContextEGL::Cast(prodGL);
-  const auto& egl = gle->mEgl;
-  MOZ_ASSERT(egl);
-  MOZ_ASSERT(context);
-
-  UniquePtr<SharedSurface_EGLImage> ret;
-
-  if (!HasExtensions(egl, prodGL)) {
-    return ret;
-  }
+    const SharedSurfaceDesc& desc) {
+  const auto& gle = GLContextEGL::Cast(desc.gl);
+  const auto& context = gle->mContext;
+  const auto& egl = *(gle->mEgl);
 
-  MOZ_ALWAYS_TRUE(prodGL->MakeCurrent());
-  GLuint prodTex = CreateTextureForOffscreen(prodGL, formats, size);
-  if (!prodTex) {
-    return ret;
-  }
+  auto fb = MozFramebuffer::Create(desc.gl, desc.size, 0, false);
+  if (!fb) return nullptr;
 
-  EGLClientBuffer buffer =
-      reinterpret_cast<EGLClientBuffer>(uintptr_t(prodTex));
-  EGLImage image = egl->fCreateImage(egl->Display(), context,
-                                     LOCAL_EGL_GL_TEXTURE_2D, buffer, nullptr);
-  if (!image) {
-    prodGL->fDeleteTextures(1, &prodTex);
-    return ret;
-  }
+  const auto buffer = reinterpret_cast<EGLClientBuffer>(fb->ColorTex());
+  const auto image = egl.fCreateImage(egl.Display(), context,
+                                      LOCAL_EGL_GL_TEXTURE_2D, buffer, nullptr);
+  if (!image) return nullptr;
 
-  ret.reset(new SharedSurface_EGLImage(prodGL, size, hasAlpha, formats, prodTex,
-                                       image));
-  return ret;
+  return AsUnique(new SharedSurface_EGLImage(desc, std::move(fb), image));
 }
 
-bool SharedSurface_EGLImage::HasExtensions(GLLibraryEGL* egl, GLContext* gl) {
-  return egl->HasKHRImageBase() &&
-         egl->IsExtensionSupported(GLLibraryEGL::KHR_gl_texture_2D_image) &&
-         (gl->IsExtensionSupported(GLContext::OES_EGL_image_external) ||
-          gl->IsExtensionSupported(GLContext::OES_EGL_image));
-}
-
-SharedSurface_EGLImage::SharedSurface_EGLImage(GLContext* gl,
-                                               const gfx::IntSize& size,
-                                               bool hasAlpha,
-                                               const GLFormats& formats,
-                                               GLuint prodTex, EGLImage image)
-    : SharedSurface(
-          SharedSurfaceType::EGLImageShare, AttachmentType::GLTexture, gl, size,
-          hasAlpha,
-          false)  // Can't recycle, as mSync changes never update TextureHost.
-      ,
+SharedSurface_EGLImage::SharedSurface_EGLImage(const SharedSurfaceDesc& desc,
+                                               UniquePtr<MozFramebuffer>&& fb,
+                                               const EGLImage image)
+    : SharedSurface(desc, std::move(fb)),
       mMutex("SharedSurface_EGLImage mutex"),
-      mFormats(formats),
-      mProdTex(prodTex),
-      mImage(image),
-      mSync(0) {}
+      mImage(image) {}
 
 SharedSurface_EGLImage::~SharedSurface_EGLImage() {
-  const auto& gle = GLContextEGL::Cast(mGL);
+  const auto& gle = GLContextEGL::Cast(mDesc.gl);
   const auto& egl = gle->mEgl;
   egl->fDestroyImage(egl->Display(), mImage);
 
@@ -89,22 +81,17 @@
     egl->fDestroySync(egl->Display(), mSync);
     mSync = 0;
   }
-
-  if (!mGL || !mGL->MakeCurrent()) return;
-
-  mGL->fDeleteTextures(1, &mProdTex);
-  mProdTex = 0;
 }
 
 void SharedSurface_EGLImage::ProducerReleaseImpl() {
-  const auto& gle = GLContextEGL::Cast(mGL);
-  const auto& egl = gle->mEgl;
+  const auto& gl = GLContextEGL::Cast(mDesc.gl);
+  const auto& egl = gl->mEgl;
 
   MutexAutoLock lock(mMutex);
-  mGL->MakeCurrent();
+  gl->MakeCurrent();
 
   if (egl->IsExtensionSupported(GLLibraryEGL::KHR_fence_sync) &&
-      mGL->IsExtensionSupported(GLContext::OES_EGL_sync)) {
+      gl->IsExtensionSupported(GLContext::OES_EGL_sync)) {
     if (mSync) {
       MOZ_RELEASE_ASSERT(false, "GFX: Non-recycleable should not Fence twice.");
       MOZ_ALWAYS_TRUE(egl->fDestroySync(egl->Display(), mSync));
@@ -113,17 +100,17 @@
 
     mSync = egl->fCreateSync(egl->Display(), LOCAL_EGL_SYNC_FENCE, nullptr);
     if (mSync) {
-      mGL->fFlush();
+      gl->fFlush();
       return;
     }
   }
 
   MOZ_ASSERT(!mSync);
-  mGL->fFinish();
+  gl->fFinish();
 }
 
 void SharedSurface_EGLImage::ProducerReadAcquireImpl() {
-  const auto& gle = GLContextEGL::Cast(mGL);
+  const auto& gle = GLContextEGL::Cast(mDesc.gl);
   const auto& egl = gle->mEgl;
   // Wait on the fence, because presumably we're going to want to read this
   // surface
@@ -132,16 +119,14 @@
   }
 }
 
-bool SharedSurface_EGLImage::ToSurfaceDescriptor(
-    layers::SurfaceDescriptor* const out_descriptor) {
-  *out_descriptor = layers::EGLImageDescriptor(
-      (uintptr_t)mImage, (uintptr_t)mSync, mSize, mHasAlpha);
-  return true;
+Maybe<layers::SurfaceDescriptor> SharedSurface_EGLImage::ToSurfaceDescriptor() {
+  return Some(layers::EGLImageDescriptor((uintptr_t)mImage, (uintptr_t)mSync,
+                                         mDesc.size, true));
 }
 
 bool SharedSurface_EGLImage::ReadbackBySharedHandle(
     gfx::DataSourceSurface* out_surface) {
-  const auto& gle = GLContextEGL::Cast(mGL);
+  const auto& gle = GLContextEGL::Cast(mDesc.gl);
   const auto& egl = gle->mEgl;
   MOZ_ASSERT(out_surface);
   MOZ_ASSERT(NS_IsMainThread());
@@ -150,56 +135,40 @@
 
 ////////////////////////////////////////////////////////////////////////
 
-/*static*/
-UniquePtr<SurfaceFactory_EGLImage> SurfaceFactory_EGLImage::Create(
-    GLContext* prodGL, const SurfaceCaps& caps,
-    const RefPtr<layers::LayersIPCChannel>& allocator,
-    const layers::TextureFlags& flags) {
-  const auto& gle = GLContextEGL::Cast(prodGL);
-  const auto& egl = gle->mEgl;
-  const auto& context = gle->mContext;
-
-  typedef SurfaceFactory_EGLImage ptrT;
-  UniquePtr<ptrT> ret;
-
-  if (SharedSurface_EGLImage::HasExtensions(egl, prodGL)) {
-    ret.reset(new ptrT(prodGL, caps, allocator, flags, context));
-  }
-
-  return ret;
-}
-
-////////////////////////////////////////////////////////////////////////
-
 #ifdef MOZ_WIDGET_ANDROID
 
 /*static*/
 UniquePtr<SharedSurface_SurfaceTexture> SharedSurface_SurfaceTexture::Create(
-    GLContext* prodGL, const GLFormats& formats, const gfx::IntSize& size,
-    bool hasAlpha, java::GeckoSurface::Param surface) {
-  MOZ_ASSERT(surface);
+    const SharedSurfaceDesc& desc) {
+  const auto& size = desc.size;
 
-  UniquePtr<SharedSurface_SurfaceTexture> ret;
+  jni::Object::LocalRef surfaceObj =
+      java::SurfaceAllocator::AcquireSurface(size.width, size.height, true);
+  if (!surfaceObj) {
+    // Try multi-buffer mode
+    surfaceObj =
+        java::SurfaceAllocator::AcquireSurface(size.width, size.height, false);
+  }
+  if (!surfaceObj) {
+    // Give up
+    NS_WARNING("Failed to allocate SurfaceTexture!");
+    return nullptr;
+  }
+  const auto surface = java::GeckoSurface::Ref::From(surfaceObj);
 
   AndroidNativeWindow window(surface);
-  const auto& gle = GLContextEGL::Cast(prodGL);
+  const auto& gle = GLContextEGL::Cast(desc.gl);
   MOZ_ASSERT(gle);
-  EGLSurface eglSurface = gle->CreateCompatibleSurface(window.NativeWindow());
-  if (!eglSurface) {
-    return ret;
-  }
+  const auto eglSurface = gle->CreateCompatibleSurface(window.NativeWindow());
+  if (!eglSurface) return nullptr;
 
-  ret.reset(new SharedSurface_SurfaceTexture(prodGL, size, hasAlpha, formats,
-                                             surface, eglSurface));
-  return ret;
+  return AsUnique(new SharedSurface_SurfaceTexture(desc, surface, eglSurface));
 }
 
 SharedSurface_SurfaceTexture::SharedSurface_SurfaceTexture(
-    GLContext* gl, const gfx::IntSize& size, bool hasAlpha,
-    const GLFormats& formats, java::GeckoSurface::Param surface,
-    EGLSurface eglSurface)
-    : SharedSurface(SharedSurfaceType::AndroidSurfaceTexture,
-                    AttachmentType::Screen, gl, size, hasAlpha, true),
+    const SharedSurfaceDesc& desc, java::GeckoSurface::Param surface,
+    const EGLSurface eglSurface)
+    : SharedSurface(desc, nullptr),
       mSurface(surface),
       mEglSurface(eglSurface) {}
 
@@ -217,7 +186,7 @@
 void SharedSurface_SurfaceTexture::LockProdImpl() {
   MOZ_RELEASE_ASSERT(mSurface->GetAvailable());
 
-  GLContextEGL* gl = GLContextEGL::Cast(mGL);
+  GLContextEGL* gl = GLContextEGL::Cast(mDesc.gl);
   mOrigEglSurface = gl->GetEGLSurfaceOverride();
   gl->SetEGLSurfaceOverride(mEglSurface);
 }
@@ -225,7 +194,7 @@
 void SharedSurface_SurfaceTexture::UnlockProdImpl() {
   MOZ_RELEASE_ASSERT(mSurface->GetAvailable());
 
-  GLContextEGL* gl = GLContextEGL::Cast(mGL);
+  GLContextEGL* gl = GLContextEGL::Cast(mDesc.gl);
   MOZ_ASSERT(gl->GetEGLSurfaceOverride() == mEglSurface);
 
   gl->SetEGLSurfaceOverride(mOrigEglSurface);
@@ -236,7 +205,7 @@
   MOZ_RELEASE_ASSERT(mSurface->GetAvailable());
 
   LockProdImpl();
-  mGL->SwapBuffers();
+  mDesc.gl->SwapBuffers();
   UnlockProdImpl();
   mSurface->SetAvailable(false);
 }
@@ -249,46 +218,16 @@
   return mSurface->GetAvailable();
 }
 
-bool SharedSurface_SurfaceTexture::ToSurfaceDescriptor(
-    layers::SurfaceDescriptor* const out_descriptor) {
-  *out_descriptor = layers::SurfaceTextureDescriptor(
-      mSurface->GetHandle(), mSize, gfx::SurfaceFormat::R8G8B8A8,
-      false /* NOT continuous */, false /* Do not ignore transform */);
-  return true;
-}
-
-////////////////////////////////////////////////////////////////////////
-
-/*static*/
-UniquePtr<SurfaceFactory_SurfaceTexture> SurfaceFactory_SurfaceTexture::Create(
-    GLContext* prodGL, const SurfaceCaps& caps,
-    const RefPtr<layers::LayersIPCChannel>& allocator,
-    const layers::TextureFlags& flags) {
-  UniquePtr<SurfaceFactory_SurfaceTexture> ret(
-      new SurfaceFactory_SurfaceTexture(prodGL, caps, allocator, flags));
-  return ret;
+Maybe<layers::SurfaceDescriptor>
+SharedSurface_SurfaceTexture::ToSurfaceDescriptor() {
+  return Some(layers::SurfaceTextureDescriptor(
+      mSurface->GetHandle(), mDesc.size, gfx::SurfaceFormat::R8G8B8A8,
+      false /* NOT continuous */, false /* Do not ignore transform */));
 }
 
-UniquePtr<SharedSurface> SurfaceFactory_SurfaceTexture::CreateShared(
-    const gfx::IntSize& size) {
-  bool hasAlpha = mReadCaps.alpha;
-
-  jni::Object::LocalRef surface =
-      java::SurfaceAllocator::AcquireSurface(size.width, size.height, true);
-  if (!surface) {
-    // Try multi-buffer mode
-    surface =
-        java::SurfaceAllocator::AcquireSurface(size.width, size.height, false);
-    if (!surface) {
-      // Give up
-      NS_WARNING("Failed to allocate SurfaceTexture!");
-      return nullptr;
-    }
-  }
-
-  return SharedSurface_SurfaceTexture::Create(
-      mGL, mFormats, size, hasAlpha, java::GeckoSurface::Ref::From(surface));
-}
+SurfaceFactory_SurfaceTexture::SurfaceFactory_SurfaceTexture(GLContext& gl)
+    : SurfaceFactory({&gl, SharedSurfaceType::AndroidSurfaceTexture,
+                      layers::TextureType::AndroidNativeWindow, true}) {}
 
 #endif  // MOZ_WIDGET_ANDROID
 