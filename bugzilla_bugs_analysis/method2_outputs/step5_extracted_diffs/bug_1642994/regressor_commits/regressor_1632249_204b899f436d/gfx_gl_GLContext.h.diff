# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/GLContext.h
# Commit: 204b899f436d
# Full Hash: 204b899f436d99f0eae759af3ccfcbaabfbbb428
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 09:34:54
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 3f5baab34b1f -r 204b899f436d gfx/gl/GLContext.h
--- a/gfx/gl/GLContext.h	Thu Jun 11 06:36:55 2020 +0000
+++ b/gfx/gl/GLContext.h	Thu Jun 11 06:37:35 2020 +0000
@@ -61,9 +61,7 @@
 class GLContext;
 class GLLibraryEGL;
 class GLReadTexImageHelper;
-class GLScreenBuffer;
 class SharedSurface;
-struct SurfaceCaps;
 }  // namespace gl
 
 namespace layers {
@@ -196,6 +194,8 @@
   MOZ_DECLARE_WEAKREFERENCE_TYPENAME(GLContext)
   static MOZ_THREAD_LOCAL(uintptr_t) sCurrentContext;
 
+  const GLContextDesc mDesc;
+
   bool mImplicitMakeCurrent = false;
   bool mUseTLSIsCurrent;
 
@@ -318,9 +318,6 @@
    */
   virtual GLuint GetDefaultFramebuffer() { return 0; }
 
- protected:
-  bool mIsOffscreen;
-
   /**
    * mVersion store the OpenGL's version, multiplied by 100. For example, if
    * the context is an OpenGL 2.1 context, mVersion value will be 210.
@@ -790,8 +787,6 @@
     AFTER_GL_CALL;
   }
 
-  void fBindFramebuffer(GLenum target, GLuint framebuffer);
-
   void fInvalidateFramebuffer(GLenum target, GLsizei numAttachments,
                               const GLenum* attachments) {
     BeforeGLDrawCall();
@@ -1177,7 +1172,7 @@
   }
 
  private:
-  void raw_fGetIntegerv(GLenum pname, GLint* params) {
+  void raw_fGetIntegerv(GLenum pname, GLint* params) const {
     BEFORE_GL_CALL;
     mSymbols.fGetIntegerv(pname, params);
     OnSyncCall();
@@ -1185,28 +1180,28 @@
   }
 
  public:
-  void fGetIntegerv(GLenum pname, GLint* params);
-
-  void GetUIntegerv(GLenum pname, GLuint* params) {
+  void fGetIntegerv(GLenum pname, GLint* params) const;
+
+  void GetUIntegerv(GLenum pname, GLuint* params) const {
     fGetIntegerv(pname, reinterpret_cast<GLint*>(params));
   }
 
   template <typename T>
-  T GetIntAs(GLenum pname) {
+  T GetIntAs(GLenum pname) const {
     static_assert(sizeof(T) == sizeof(GLint), "Invalid T.");
     T ret = 0;
     fGetIntegerv(pname, (GLint*)&ret);
     return ret;
   }
 
-  void fGetFloatv(GLenum pname, GLfloat* params) {
+  void fGetFloatv(GLenum pname, GLfloat* params) const {
     BEFORE_GL_CALL;
     mSymbols.fGetFloatv(pname, params);
     OnSyncCall();
     AFTER_GL_CALL;
   }
 
-  void fGetBooleanv(GLenum pname, realGLboolean* params) {
+  void fGetBooleanv(GLenum pname, realGLboolean* params) const {
     BEFORE_GL_CALL;
     mSymbols.fGetBooleanv(pname, params);
     OnSyncCall();
@@ -2010,16 +2005,12 @@
     AFTER_GL_CALL;
   }
 
- private:
-  friend class SharedSurface;
-
-  void raw_fBindFramebuffer(GLenum target, GLuint framebuffer) {
+  void fBindFramebuffer(GLenum target, GLuint framebuffer) {
     BEFORE_GL_CALL;
     mSymbols.fBindFramebuffer(target, framebuffer);
     AFTER_GL_CALL;
   }
 
- public:
   void fBindRenderbuffer(GLenum target, GLuint renderbuffer) {
     BEFORE_GL_CALL;
     mSymbols.fBindRenderbuffer(target, renderbuffer);
@@ -3308,9 +3299,8 @@
   // -----------------------------------------------------------------------------
   // Constructor
  protected:
-  explicit GLContext(CreateContextFlags flags, const SurfaceCaps& caps,
-                     GLContext* sharedContext = nullptr,
-                     bool isOffscreen = false, bool canUseTLSIsCurrent = false);
+  explicit GLContext(const GLContextDesc&, GLContext* sharedContext = nullptr,
+                     bool canUseTLSIsCurrent = false);
 
   // -----------------------------------------------------------------------------
   // Destructor
@@ -3376,28 +3366,6 @@
 
   virtual Maybe<SymbolLoader> GetSymbolLoader() const = 0;
 
-  // Before reads from offscreen texture
-  void GuaranteeResolve();
-
-  /*
-   * Resize the current offscreen buffer.  Returns true on success.
-   * If it returns false, the context should be treated as unusable
-   * and should be recreated.  After the resize, the viewport is not
-   * changed; glViewport should be called as appropriate.
-   *
-   * Only valid if IsOffscreen() returns true.
-   */
-  bool ResizeOffscreen(const gfx::IntSize& size) {
-    return ResizeScreenBuffer(size);
-  }
-
-  /*
-   * Return size of this offscreen context.
-   *
-   * Only valid if IsOffscreen() returns true.
-   */
-  const gfx::IntSize& OffscreenSize() const;
-
   void BindFB(GLuint fb) {
     fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, fb);
     MOZ_GL_ASSERT(this, !fb || fIsFramebuffer(fb));
@@ -3411,11 +3379,23 @@
     fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER_EXT, fb);
   }
 
-  GLuint GetDrawFB();
-
-  GLuint GetReadFB();
-
-  GLuint GetFB();
+  GLuint GetDrawFB() const {
+    return GetIntAs<GLuint>(LOCAL_GL_DRAW_FRAMEBUFFER_BINDING_EXT);
+  }
+
+  GLuint GetReadFB() const {
+    auto bindEnum = LOCAL_GL_READ_FRAMEBUFFER_BINDING_EXT;
+    if (!IsSupported(GLFeature::split_framebuffer)) {
+      bindEnum = LOCAL_GL_FRAMEBUFFER_BINDING;
+    }
+    return GetIntAs<GLuint>(bindEnum);
+  }
+
+  GLuint GetFB() const {
+    const auto ret = GetDrawFB();
+    MOZ_ASSERT(ret == GetReadFB());
+    return ret;
+  }
 
  private:
   void GetShaderPrecisionFormatNonES2(GLenum shadertype, GLenum precisiontype,
@@ -3442,9 +3422,6 @@
   }
 
  public:
-  void ForceDirtyScreen();
-  void CleanDirtyScreen();
-
   virtual GLenum GetPreferredARGB32Format() const { return LOCAL_GL_RGBA; }
 
   virtual GLenum GetPreferredEGLImageTextureTarget() const {
@@ -3464,8 +3441,6 @@
                                const char* extension);
 
  public:
-  std::map<GLuint, SharedSurface*> mFBOMapping;
-
   enum {
     DebugFlagEnabled = 1 << 0,
     DebugFlagTrace = 1 << 1,
@@ -3507,31 +3482,6 @@
     return thisShared == otherShared;
   }
 
-  bool InitOffscreen(const gfx::IntSize& size, const SurfaceCaps& caps);
-
- protected:
-  // Note that it does -not- clear the resized buffers.
-  bool CreateScreenBuffer(const gfx::IntSize& size, const SurfaceCaps& caps) {
-    if (!IsOffscreenSizeAllowed(size)) return false;
-
-    return CreateScreenBufferImpl(size, caps);
-  }
-
-  bool CreateScreenBufferImpl(const gfx::IntSize& size,
-                              const SurfaceCaps& caps);
-
- public:
-  bool ResizeScreenBuffer(const gfx::IntSize& size);
-
- protected:
-  SurfaceCaps mCaps;
-
- public:
-  const SurfaceCaps& Caps() const { return mCaps; }
-
-  // Only varies based on bpp16 and alpha.
-  GLFormats ChooseGLFormats(const SurfaceCaps& caps) const;
-
   bool IsFramebufferComplete(GLuint fb, GLenum* status = nullptr);
 
   // Does not check completeness.
@@ -3545,14 +3495,10 @@
                             GLuint* drawFB, GLuint* readFB);
 
  protected:
-  friend class GLScreenBuffer;
-  UniquePtr<GLScreenBuffer> mScreen;
-
   SharedSurface* mLockedSurface = nullptr;
 
  public:
   void LockSurface(SharedSurface* surf) {
-    MOZ_ASSERT(!mLockedSurface);
     mLockedSurface = surf;
   }
 
@@ -3563,9 +3509,7 @@
 
   SharedSurface* GetLockedSurface() const { return mLockedSurface; }
 
-  bool IsOffscreen() const { return mIsOffscreen; }
-
-  GLScreenBuffer* Screen() const { return mScreen.get(); }
+  bool IsOffscreen() const { return mDesc.isOffscreen; }
 
   bool WorkAroundDriverBugs() const { return mWorkAroundDriverBugs; }
 
@@ -3685,7 +3629,6 @@
   void FlushIfHeavyGLCallsSinceLastFlush();
   static bool ShouldSpew();
   static bool ShouldDumpExts();
-  bool Readback(SharedSurface* src, gfx::DataSourceSurface* dest);
 
   // --
 
@@ -3750,28 +3693,61 @@
   }
 }
 
+// -
+
+class Renderbuffer final {
+ public:
+  const WeakPtr<GLContext> weakGl;
+  const GLuint name;
+
+ private:
+  static GLuint Create(GLContext& gl) {
+    GLuint ret = 0;
+    gl.fGenRenderbuffers(1, &ret);
+    return ret;
+  }
+
+ public:
+  explicit Renderbuffer(GLContext& gl) : weakGl(&gl), name(Create(gl)) {}
+
+  ~Renderbuffer() {
+    const RefPtr<GLContext> gl = weakGl.get();
+    if (!gl->MakeCurrent()) return;
+    gl->fDeleteRenderbuffers(1, &name);
+  }
+};
+
+// -
+
+class Texture final {
+ public:
+  const WeakPtr<GLContext> weakGl;
+  const GLuint name;
+
+ private:
+  static GLuint Create(GLContext& gl) {
+    GLuint ret = 0;
+    gl.fGenTextures(1, &ret);
+    return ret;
+  }
+
+ public:
+  explicit Texture(GLContext& gl) : weakGl(&gl), name(Create(gl)) {}
+
+  ~Texture() {
+    const RefPtr<GLContext> gl = weakGl.get();
+    if (!gl->MakeCurrent()) return;
+    gl->fDeleteTextures(1, &name);
+  }
+};
+
 /**
  * Helper function that creates a 2D texture aSize.width x aSize.height with
  * storage type specified by aFormats. Returns GL texture object id.
  *
  * See mozilla::gl::CreateTexture.
  */
-GLuint CreateTextureForOffscreen(GLContext* aGL, const GLFormats& aFormats,
-                                 const gfx::IntSize& aSize);
-
-/**
- * Helper function that creates a 2D texture aSize.width x aSize.height with
- * storage type aInternalFormat. Returns GL texture object id.
- *
- * Initialize textyre parameters to:
- *    GL_TEXTURE_MIN_FILTER = GL_LINEAR
- *    GL_TEXTURE_MAG_FILTER = GL_LINEAR
- *    GL_TEXTURE_WRAP_S = GL_CLAMP_TO_EDGE
- *    GL_TEXTURE_WRAP_T = GL_CLAMP_TO_EDGE
- */
-GLuint CreateTexture(GLContext* aGL, GLenum aInternalFormat, GLenum aFormat,
-                     GLenum aType, const gfx::IntSize& aSize,
-                     bool linear = true);
+UniquePtr<Texture> CreateTexture(GLContext&, const gfx::IntSize& size);
 
 /**
  * Helper function that calculates the number of bytes required per