# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/GLContextProviderCGL.mm
# Commit: 204b899f436d
# Full Hash: 204b899f436d99f0eae759af3ccfcbaabfbbb428
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 09:34:54
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 3f5baab34b1f -r 204b899f436d gfx/gl/GLContextProviderCGL.mm
--- a/gfx/gl/GLContextProviderCGL.mm	Thu Jun 11 06:36:55 2020 +0000
+++ b/gfx/gl/GLContextProviderCGL.mm	Thu Jun 11 06:37:35 2020 +0000
@@ -55,9 +55,8 @@
 
 CGLLibrary sCGLLibrary;
 
-GLContextCGL::GLContextCGL(CreateContextFlags flags, const SurfaceCaps& caps,
-                           NSOpenGLContext* context, bool isOffscreen)
-    : GLContext(flags, caps, nullptr, isOffscreen), mContext(context) {
+GLContextCGL::GLContextCGL(const GLContextDesc& desc, NSOpenGLContext* context)
+    : GLContext(desc), mContext(context) {
   CGDisplayRegisterReconfigurationCallback(DisplayReconfigurationCallback, this);
 }
 
@@ -241,10 +240,10 @@
     flags |= CreateContextFlags::REQUIRE_COMPAT_PROFILE;
   }
   nsCString failureUnused;
-  return CreateHeadless(flags, &failureUnused);
+  return CreateHeadless({flags}, &failureUnused);
 }
 
-static already_AddRefed<GLContextCGL> CreateOffscreenFBOContext(CreateContextFlags flags) {
+static RefPtr<GLContextCGL> CreateOffscreenFBOContext(GLContextCreateDesc desc) {
   if (!sCGLLibrary.EnsureInitialized()) {
     return nullptr;
   }
@@ -252,6 +251,7 @@
   NSOpenGLContext* context = nullptr;
 
   std::vector<NSOpenGLPixelFormatAttribute> attribs;
+  auto& flags = desc.flags;
 
   if (!StaticPrefs::gl_allow_high_power()) {
     flags &= ~CreateContextFlags::HIGH_POWER;
@@ -285,18 +285,17 @@
     return nullptr;
   }
 
-  RefPtr<GLContextCGL> glContext = new GLContextCGL(flags, SurfaceCaps::Any(), context, true);
+  RefPtr<GLContextCGL> glContext = new GLContextCGL({desc, true}, context);
 
   if (flags & CreateContextFlags::PREFER_MULTITHREADED) {
     CGLEnable(glContext->GetCGLContext(), kCGLCEMPEngine);
   }
-  return glContext.forget();
+  return glContext;
 }
 
-already_AddRefed<GLContext> GLContextProviderCGL::CreateHeadless(CreateContextFlags flags,
+already_AddRefed<GLContext> GLContextProviderCGL::CreateHeadless(const GLContextCreateDesc& desc,
                                                                  nsACString* const out_failureId) {
-  RefPtr<GLContextCGL> gl;
-  gl = CreateOffscreenFBOContext(flags);
+  auto gl = CreateOffscreenFBOContext(desc);
   if (!gl) {
     *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_CGL_FBO");
     return nullptr;
@@ -312,20 +311,9 @@
 }
 
 already_AddRefed<GLContext> GLContextProviderCGL::CreateOffscreen(const IntSize& size,
-                                                                  const SurfaceCaps& minCaps,
-                                                                  CreateContextFlags flags,
+                                                                  const GLContextCreateDesc& desc,
                                                                   nsACString* const out_failureId) {
-  RefPtr<GLContext> gl = CreateHeadless(flags, out_failureId);
-  if (!gl) {
-    return nullptr;
-  }
-
-  if (!gl->InitOffscreen(size, minCaps)) {
-    *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_CGL_INIT");
-    return nullptr;
-  }
-
-  return gl.forget();
+  return CreateHeadless(desc, out_failureId);
 }
 
 static RefPtr<GLContext> gGlobalContext;
@@ -337,7 +325,7 @@
 
     MOZ_RELEASE_ASSERT(!gGlobalContext);
     nsCString discardFailureId;
-    RefPtr<GLContext> temp = CreateHeadless(CreateContextFlags::NONE, &discardFailureId);
+    RefPtr<GLContext> temp = CreateHeadless({}, &discardFailureId);
     gGlobalContext = temp;
 
     if (!gGlobalContext) {