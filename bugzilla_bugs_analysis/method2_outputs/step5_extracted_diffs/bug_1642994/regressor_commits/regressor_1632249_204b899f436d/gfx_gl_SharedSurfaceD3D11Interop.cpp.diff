# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/SharedSurfaceD3D11Interop.cpp
# Commit: 204b899f436d
# Full Hash: 204b899f436d99f0eae759af3ccfcbaabfbbb428
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 09:34:54
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 3f5baab34b1f -r 204b899f436d gfx/gl/SharedSurfaceD3D11Interop.cpp
--- a/gfx/gl/SharedSurfaceD3D11Interop.cpp	Thu Jun 11 06:36:55 2020 +0000
+++ b/gfx/gl/SharedSurfaceD3D11Interop.cpp	Thu Jun 11 06:37:35 2020 +0000
@@ -8,6 +8,7 @@
 #include <d3d11.h>
 #include <d3d11_1.h>
 #include "GLContext.h"
+#include "MozFramebuffer.h"
 #include "WGLLibrary.h"
 #include "nsPrintfCString.h"
 #include "mozilla/gfx/DeviceManagerDx.h"
@@ -309,32 +310,34 @@
 
 /*static*/
 UniquePtr<SharedSurface_D3D11Interop> SharedSurface_D3D11Interop::Create(
-    DXInterop2Device* interop, GLContext* gl, const gfx::IntSize& size,
-    bool hasAlpha) {
+    const SharedSurfaceDesc& desc, DXInterop2Device* interop) {
+  const auto& gl = desc.gl;
+  const auto& size = desc.size;
   const auto& d3d = interop->mD3D;
 
+  auto data = Data{interop};
+
   // Create a texture in case we need to readback.
-  DXGI_FORMAT format =
-      hasAlpha ? DXGI_FORMAT_B8G8R8A8_UNORM : DXGI_FORMAT_B8G8R8X8_UNORM;
-  CD3D11_TEXTURE2D_DESC desc(format, size.width, size.height, 1, 1);
-  desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+  const DXGI_FORMAT format = DXGI_FORMAT_B8G8R8A8_UNORM;
+  CD3D11_TEXTURE2D_DESC texDesc(format, size.width, size.height, 1, 1);
+  texDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
 
-  RefPtr<ID3D11Texture2D> texD3D;
-  auto hr = d3d->CreateTexture2D(&desc, nullptr, getter_AddRefs(texD3D));
+  auto hr =
+      d3d->CreateTexture2D(&texDesc, nullptr, getter_AddRefs(data.texD3D));
   if (FAILED(hr)) {
     NS_WARNING("Failed to create texture for CanvasLayer!");
     return nullptr;
   }
 
   RefPtr<IDXGIResource> texDXGI;
-  hr = texD3D->QueryInterface(__uuidof(IDXGIResource), getter_AddRefs(texDXGI));
+  hr = data.texD3D->QueryInterface(__uuidof(IDXGIResource),
+                                   getter_AddRefs(texDXGI));
   if (FAILED(hr)) {
     NS_WARNING("Failed to open texture for sharing!");
     return nullptr;
   }
 
-  HANDLE dxgiHandle;
-  texDXGI->GetSharedHandle(&dxgiHandle);
+  texDXGI->GetSharedHandle(&data.dxgiHandle);
 
   ////
 
@@ -343,25 +346,25 @@
     return nullptr;
   }
 
-  GLuint interopRB = 0;
-  gl->fGenRenderbuffers(1, &interopRB);
-  const auto lockHandle =
-      interop->RegisterObject(texD3D, interopRB, LOCAL_GL_RENDERBUFFER,
-                              LOCAL_WGL_ACCESS_WRITE_DISCARD_NV);
-  if (!lockHandle) {
+  data.interopRb = MakeUnique<Renderbuffer>(*gl);
+  data.lockHandle = interop->RegisterObject(data.texD3D, data.interopRb->name,
+                                            LOCAL_GL_RENDERBUFFER,
+                                            LOCAL_WGL_ACCESS_WRITE_DISCARD_NV);
+  if (!data.lockHandle) {
     NS_WARNING("Failed to register D3D object with WGL.");
-    gl->fDeleteRenderbuffers(1, &interopRB);
     return nullptr;
   }
 
-  ////
+  auto fbForDrawing = MozFramebuffer::CreateForBacking(
+      gl, size, 0, false, LOCAL_GL_RENDERBUFFER, data.interopRb->name);
+  if (!fbForDrawing) return nullptr;
 
-  GLuint prodTex = 0;
-  GLuint interopFB = 0;
+  // -
+
   {
     GLint samples = 0;
     {
-      const ScopedBindRenderbuffer bindRB(gl, interopRB);
+      const ScopedBindRenderbuffer bindRB(gl, data.interopRb->name);
       gl->fGetRenderbufferParameteriv(LOCAL_GL_RENDERBUFFER,
                                       LOCAL_GL_RENDERBUFFER_SAMPLES, &samples);
     }
@@ -372,104 +375,71 @@
       // https://bugzilla.mozilla.org/show_bug.cgi?id=1325835
 
       // Our ShSurf tex or rb must be single-sampled.
-      gl->fGenTextures(1, &prodTex);
-      const ScopedBindTexture bindTex(gl, prodTex);
-      gl->TexParams_SetClampNoMips();
-
-      const GLenum format = (hasAlpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB);
-      const ScopedBindPBO nullPBO(gl, LOCAL_GL_PIXEL_UNPACK_BUFFER);
-      gl->fTexImage2D(LOCAL_GL_TEXTURE_2D, 0, format, size.width, size.height,
-                      0, format, LOCAL_GL_UNSIGNED_BYTE, nullptr);
-
-      gl->fGenFramebuffers(1, &interopFB);
-      ScopedBindFramebuffer bindFB(gl, interopFB);
-      gl->fFramebufferRenderbuffer(LOCAL_GL_FRAMEBUFFER,
-                                   LOCAL_GL_COLOR_ATTACHMENT0,
-                                   LOCAL_GL_RENDERBUFFER, interopRB);
-      MOZ_ASSERT(gl->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER) ==
-                 LOCAL_GL_FRAMEBUFFER_COMPLETE);
+      data.interopFbIfNeedsIndirect = std::move(fbForDrawing);
+      fbForDrawing = MozFramebuffer::Create(gl, size, 0, false);
     }
   }
 
-  ////
+  // -
 
-  typedef SharedSurface_D3D11Interop ptrT;
-  UniquePtr<ptrT> ret(new ptrT(gl, size, hasAlpha, prodTex, interopFB,
-                               interopRB, interop, lockHandle, texD3D,
-                               dxgiHandle));
-  return ret;
+  return AsUnique(new SharedSurface_D3D11Interop(desc, std::move(fbForDrawing),
+                                                 std::move(data)));
 }
 
 SharedSurface_D3D11Interop::SharedSurface_D3D11Interop(
-    GLContext* gl, const gfx::IntSize& size, bool hasAlpha, GLuint prodTex,
-    GLuint interopFB, GLuint interopRB, DXInterop2Device* interop,
-    HANDLE lockHandle, ID3D11Texture2D* texD3D, HANDLE dxgiHandle)
-    : SharedSurface(
-          SharedSurfaceType::DXGLInterop2,
-          prodTex ? AttachmentType::GLTexture : AttachmentType::GLRenderbuffer,
-          gl, size, hasAlpha, true),
-      mProdTex(prodTex),
-      mInteropFB(interopFB),
-      mInteropRB(interopRB),
-      mInterop(interop),
-      mLockHandle(lockHandle),
-      mTexD3D(texD3D),
-      mDXGIHandle(dxgiHandle),
-      mNeedsFinish(StaticPrefs::webgl_dxgl_needs_finish()),
-      mLockedForGL(false) {
-  MOZ_ASSERT(bool(mProdTex) == bool(mInteropFB));
-}
+    const SharedSurfaceDesc& desc, UniquePtr<MozFramebuffer>&& fbForDrawing,
+    Data&& data)
+    : SharedSurface(desc, std::move(fbForDrawing)),
+      mData(std::move(data)),
+      mNeedsFinish(StaticPrefs::webgl_dxgl_needs_finish()) {}
 
 SharedSurface_D3D11Interop::~SharedSurface_D3D11Interop() {
   MOZ_ASSERT(!IsProducerAcquired());
 
-  if (!mGL || !mGL->MakeCurrent()) return;
+  const auto& gl = mDesc.gl;
+  if (!gl || !gl->MakeCurrent()) return;
 
-  if (!mInterop->UnregisterObject(mLockHandle)) {
+  if (!mData.interop->UnregisterObject(mData.lockHandle)) {
     NS_WARNING("Failed to release mLockHandle, possibly leaking it.");
   }
-
-  mGL->fDeleteTextures(1, &mProdTex);
-  mGL->fDeleteFramebuffers(1, &mInteropFB);
-  mGL->fDeleteRenderbuffers(1, &mInteropRB);
 }
 
 void SharedSurface_D3D11Interop::ProducerAcquireImpl() {
   MOZ_ASSERT(!mLockedForGL);
 
   // Now we have the mutex, we can lock for GL.
-  MOZ_ALWAYS_TRUE(mInterop->LockObject(mLockHandle));
+  MOZ_ALWAYS_TRUE(mData.interop->LockObject(mData.lockHandle));
 
   mLockedForGL = true;
 }
 
 void SharedSurface_D3D11Interop::ProducerReleaseImpl() {
+  const auto& gl = mDesc.gl;
   MOZ_ASSERT(mLockedForGL);
 
-  if (mProdTex) {
-    const ScopedBindFramebuffer bindFB(mGL, mInteropFB);
-    mGL->BlitHelper()->DrawBlitTextureToFramebuffer(mProdTex, mSize, mSize);
+  if (mData.interopFbIfNeedsIndirect) {
+    const ScopedBindFramebuffer bindFB(gl, mData.interopFbIfNeedsIndirect->mFB);
+    gl->BlitHelper()->DrawBlitTextureToFramebuffer(mFb->ColorTex(), mDesc.size,
+                                                   mDesc.size);
   }
 
   if (mNeedsFinish) {
-    mGL->fFinish();
+    gl->fFinish();
   } else {
     // We probably don't even need this.
-    mGL->fFlush();
+    gl->fFlush();
   }
-  MOZ_ALWAYS_TRUE(mInterop->UnlockObject(mLockHandle));
+  MOZ_ALWAYS_TRUE(mData.interop->UnlockObject(mData.lockHandle));
 
   mLockedForGL = false;
 }
 
-bool SharedSurface_D3D11Interop::ToSurfaceDescriptor(
-    layers::SurfaceDescriptor* const out_descriptor) {
-  const auto format =
-      (mHasAlpha ? gfx::SurfaceFormat::B8G8R8A8 : gfx::SurfaceFormat::B8G8R8X8);
-  *out_descriptor = layers::SurfaceDescriptorD3D10(
-      WindowsHandle(mDXGIHandle), format, mSize, gfx::YUVColorSpace::UNKNOWN,
-      gfx::ColorRange::FULL);
-  return true;
+Maybe<layers::SurfaceDescriptor>
+SharedSurface_D3D11Interop::ToSurfaceDescriptor() {
+  const auto format = gfx::SurfaceFormat::B8G8R8A8;
+  return Some(layers::SurfaceDescriptorD3D10(
+      WindowsHandle(mData.dxgiHandle), format, mDesc.size,
+      gfx::YUVColorSpace::UNKNOWN, gfx::ColorRange::FULL));
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -477,30 +447,30 @@
 
 /*static*/
 UniquePtr<SurfaceFactory_D3D11Interop> SurfaceFactory_D3D11Interop::Create(
-    GLContext* gl, const SurfaceCaps& caps, layers::LayersIPCChannel* allocator,
-    const layers::TextureFlags& flags) {
+    GLContext& gl) {
   WGLLibrary* wgl = &sWGLLib;
   if (!wgl || !wgl->HasDXInterop2()) return nullptr;
 
-  const RefPtr<DXInterop2Device> interop = DXInterop2Device::Open(wgl, gl);
+  if (XRE_IsContentProcess()) {
+    gfxPlatform::GetPlatform()->EnsureDevicesInitialized();
+  }
+
+  const RefPtr<DXInterop2Device> interop = DXInterop2Device::Open(wgl, &gl);
   if (!interop) {
     NS_WARNING("Failed to open D3D device for use by WGL.");
     return nullptr;
   }
 
-  typedef SurfaceFactory_D3D11Interop ptrT;
-  UniquePtr<ptrT> ret(new ptrT(gl, caps, allocator, flags, interop));
-  return ret;
+  return AsUnique(new SurfaceFactory_D3D11Interop(
+      {&gl, SharedSurfaceType::DXGLInterop2, layers::TextureType::D3D11, true},
+      interop));
 }
 
 SurfaceFactory_D3D11Interop::SurfaceFactory_D3D11Interop(
-    GLContext* gl, const SurfaceCaps& caps, layers::LayersIPCChannel* allocator,
-    const layers::TextureFlags& flags, DXInterop2Device* interop)
-    : SurfaceFactory(SharedSurfaceType::DXGLInterop2, gl, caps, allocator,
-                     flags),
-      mInterop(interop) {}
+    const PartialSharedSurfaceDesc& desc, DXInterop2Device* interop)
+    : SurfaceFactory(desc), mInterop(interop) {}
 
-SurfaceFactory_D3D11Interop::~SurfaceFactory_D3D11Interop() {}
+SurfaceFactory_D3D11Interop::~SurfaceFactory_D3D11Interop() = default;
 
 }  // namespace gl
 }  // namespace mozilla