# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/GLContextProviderGLX.cpp
# Commit: bbfe23c61add
# Full Hash: bbfe23c61add07377daf80696fd6996c0463f5b6
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-09 09:21:34
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 8fcfac450ecc -r bbfe23c61add gfx/gl/GLContextProviderGLX.cpp
--- a/gfx/gl/GLContextProviderGLX.cpp	Mon Jun 08 20:13:01 2020 +0000
+++ b/gfx/gl/GLContextProviderGLX.cpp	Mon Jun 08 20:34:15 2020 +0000
@@ -461,9 +461,8 @@
 }
 
 already_AddRefed<GLContextGLX> GLContextGLX::CreateGLContext(
-    CreateContextFlags flags, const SurfaceCaps& caps, bool isOffscreen,
-    Display* display, GLXDrawable drawable, GLXFBConfig cfg,
-    bool deleteDrawable, gfxXlibSurface* pixmap) {
+    const GLContextDesc& desc, Display* display, GLXDrawable drawable,
+    GLXFBConfig cfg, bool deleteDrawable, gfxXlibSurface* pixmap) {
   GLXLibrary& glx = sGLXLibrary;
 
   int db = 0;
@@ -503,7 +502,7 @@
         attrib_list.AppendElements(memory_purge_attribs,
                                    MOZ_ARRAY_LENGTH(memory_purge_attribs));
       }
-      if (!(flags & CreateContextFlags::REQUIRE_COMPAT_PROFILE)) {
+      if (!(desc.flags & CreateContextFlags::REQUIRE_COMPAT_PROFILE)) {
         int core_attribs[] = {
             LOCAL_GLX_CONTEXT_MAJOR_VERSION_ARB,
             3,
@@ -525,8 +524,8 @@
     }
 
     if (context) {
-      glContext = new GLContextGLX(flags, caps, isOffscreen, display, drawable,
-                                   context, deleteDrawable, db, pixmap);
+      glContext = new GLContextGLX(desc, display, drawable, context,
+                                   deleteDrawable, db, pixmap);
       if (!glContext->Init()) error = true;
     } else {
       error = true;
@@ -648,12 +647,11 @@
   return mGLX->fMakeCurrent(mDisplay, mDrawable, mContext);
 }
 
-GLContextGLX::GLContextGLX(CreateContextFlags flags, const SurfaceCaps& caps,
-                           bool isOffscreen, Display* aDisplay,
+GLContextGLX::GLContextGLX(const GLContextDesc& desc, Display* aDisplay,
                            GLXDrawable aDrawable, GLXContext aContext,
                            bool aDeleteDrawable, bool aDoubleBuffered,
                            gfxXlibSurface* aPixmap)
-    : GLContext(flags, caps, nullptr, isOffscreen),
+    : GLContext(desc, nullptr),
       mContext(aContext),
       mDisplay(aDisplay),
       mDrawable(aDrawable),
@@ -686,10 +684,8 @@
   }
 
   if (aContext && aSurface) {
-    SurfaceCaps caps = SurfaceCaps::Any();
     RefPtr<GLContextGLX> glContext =
-        new GLContextGLX(CreateContextFlags::NONE, caps,
-                         false,                        // Offscreen
+        new GLContextGLX({},
                          (Display*)DefaultXDisplay(),  // Display
                          (GLXDrawable)aSurface, (GLXContext)aContext,
                          false,  // aDeleteDrawable,
@@ -737,9 +733,8 @@
   } else {
     flags = CreateContextFlags::REQUIRE_COMPAT_PROFILE;
   }
-  return GLContextGLX::CreateGLContext(flags, SurfaceCaps::Any(), false,
-                                       aXDisplay, aXWindow, config, false,
-                                       nullptr);
+  return GLContextGLX::CreateGLContext({{flags}, false}, aXDisplay, aXWindow,
+                                       config, false, nullptr);
 }
 
 already_AddRefed<GLContext> GLContextProviderGLX::CreateForCompositorWidget(
@@ -757,7 +752,6 @@
 }
 
 static bool ChooseConfig(GLXLibrary* glx, Display* display, int screen,
-                         const SurfaceCaps& minCaps,
                          ScopedXFree<GLXFBConfig>* const out_scopedConfigArr,
                          GLXFBConfig* const out_config, int* const out_visid) {
   ScopedXFree<GLXFBConfig>& scopedConfigArr = *out_scopedConfigArr;
@@ -773,11 +767,11 @@
                    LOCAL_GLX_BLUE_SIZE,
                    8,
                    LOCAL_GLX_ALPHA_SIZE,
-                   minCaps.alpha ? 8 : 0,
+                   8,
                    LOCAL_GLX_DEPTH_SIZE,
-                   minCaps.depth ? 16 : 0,
+                   0,
                    LOCAL_GLX_STENCIL_SIZE,
-                   minCaps.stencil ? 8 : 0,
+                   0,
                    0};
 
   int numConfigs = 0;
@@ -967,7 +961,7 @@
 }
 
 static already_AddRefed<GLContextGLX> CreateOffscreenPixmapContext(
-    CreateContextFlags flags, const IntSize& size, const SurfaceCaps& minCaps,
+    const GLContextCreateDesc& desc, const IntSize& size,
     nsACString* const out_failureId) {
   GLXLibrary* glx = &sGLXLibrary;
   if (!glx->EnsureInitialized()) return nullptr;
@@ -978,8 +972,7 @@
   ScopedXFree<GLXFBConfig> scopedConfigArr;
   GLXFBConfig config;
   int visid;
-  if (!ChooseConfig(glx, display, screen, minCaps, &scopedConfigArr, &config,
-                    &visid)) {
+  if (!ChooseConfig(glx, display, screen, &scopedConfigArr, &config, &visid)) {
     NS_WARNING("Failed to find a compatible config.");
     return nullptr;
   }
@@ -1011,33 +1004,24 @@
   bool serverError = xErrorHandler.SyncAndGetError(display);
   if (error || serverError) return nullptr;
 
-  return GLContextGLX::CreateGLContext(flags, minCaps, true, display, pixmap,
-                                       config, true, surface);
+  auto fullDesc = GLContextDesc{desc};
+  fullDesc.isOffscreen = true;
+  return GLContextGLX::CreateGLContext(fullDesc, display, pixmap, config, true,
+                                       surface);
 }
 
 /*static*/
 already_AddRefed<GLContext> GLContextProviderGLX::CreateHeadless(
-    CreateContextFlags flags, nsACString* const out_failureId) {
+    const GLContextCreateDesc& desc, nsACString* const out_failureId) {
   IntSize dummySize = IntSize(16, 16);
-  SurfaceCaps dummyCaps = SurfaceCaps::Any();
-  return CreateOffscreenPixmapContext(flags, dummySize, dummyCaps,
-                                      out_failureId);
+  return CreateOffscreenPixmapContext(desc, dummySize, out_failureId);
 }
 
 /*static*/
 already_AddRefed<GLContext> GLContextProviderGLX::CreateOffscreen(
-    const IntSize& size, const SurfaceCaps& minCaps, CreateContextFlags flags,
+    const IntSize& size, const GLContextCreateDesc& desc,
     nsACString* const out_failureId) {
-  RefPtr<GLContext> gl;
-  gl = CreateOffscreenPixmapContext(flags, size, minCaps, out_failureId);
-  if (!gl) return nullptr;
-
-  if (!gl->InitOffscreen(size, minCaps)) {
-    *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_GLX_INIT");
-    return nullptr;
-  }
-
-  return gl.forget();
+  return CreateOffscreenPixmapContext(desc, size, out_failureId);
 }
 
 /*static*/