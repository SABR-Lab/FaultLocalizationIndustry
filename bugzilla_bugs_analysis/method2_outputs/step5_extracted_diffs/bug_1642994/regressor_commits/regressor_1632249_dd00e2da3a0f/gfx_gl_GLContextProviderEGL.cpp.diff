# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/GLContextProviderEGL.cpp
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f gfx/gl/GLContextProviderEGL.cpp
--- a/gfx/gl/GLContextProviderEGL.cpp	Wed Jun 10 21:57:19 2020 +0000
+++ b/gfx/gl/GLContextProviderEGL.cpp	Wed Jun 10 22:21:02 2020 +0000
@@ -293,9 +293,9 @@
     flags |= CreateContextFlags::REQUIRE_COMPAT_PROFILE;
   }
 
-  SurfaceCaps caps = SurfaceCaps::Any();
+  const auto desc = GLContextDesc{{flags}, false};
   RefPtr<GLContextEGL> gl = GLContextEGL::CreateGLContext(
-      egl, flags, caps, false, config, surface, aUseGles, &discardFailureId);
+      egl, desc, config, surface, aUseGles, &discardFailureId);
   if (!gl) {
     const auto err = egl->fGetError();
     gfxCriticalNote << "Failed to create EGLContext!: " << gfx::hexa(err);
@@ -352,11 +352,10 @@
 }
 #endif
 
-GLContextEGL::GLContextEGL(GLLibraryEGL* const egl, CreateContextFlags flags,
-                           const SurfaceCaps& caps, bool isOffscreen,
+GLContextEGL::GLContextEGL(GLLibraryEGL* const egl, const GLContextDesc& desc,
                            EGLConfig config, EGLSurface surface,
                            EGLContext context)
-    : GLContext(flags, caps, nullptr, isOffscreen, false),
+    : GLContext(desc, nullptr, false),
       mEgl(egl),
       mConfig(config),
       mContext(context),
@@ -590,9 +589,10 @@
 #define LOCAL_EGL_CONTEXT_PROVOKING_VERTEX_DONT_CARE_MOZ 0x6000
 
 already_AddRefed<GLContextEGL> GLContextEGL::CreateGLContext(
-    GLLibraryEGL* const egl, CreateContextFlags flags, const SurfaceCaps& caps,
-    bool isOffscreen, EGLConfig config, EGLSurface surface, const bool useGles,
-    nsACString* const out_failureId) {
+    GLLibraryEGL* const egl, const GLContextDesc& desc, EGLConfig config,
+    EGLSurface surface, const bool useGles, nsACString* const out_failureId) {
+  const auto& flags = desc.flags;
+
   std::vector<EGLint> required_attribs;
 
   if (useGles) {
@@ -715,7 +715,7 @@
   MOZ_ASSERT(context);
 
   RefPtr<GLContextEGL> glContext =
-      new GLContextEGL(egl, flags, caps, isOffscreen, config, surface, context);
+      new GLContextEGL(egl, desc, config, surface, context);
   if (!glContext->Init()) {
     *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_EGL_INIT");
     return nullptr;
@@ -938,11 +938,9 @@
   if (!aContext || !aSurface) return nullptr;
 
   const auto& egl = GLLibraryEGL::Get();
-  SurfaceCaps caps = SurfaceCaps::Any();
   EGLConfig config = EGL_NO_CONFIG;
-  RefPtr<GLContextEGL> gl =
-      new GLContextEGL(egl, CreateContextFlags::NONE, caps, false, config,
-                       (EGLSurface)aSurface, (EGLContext)aContext);
+  RefPtr<GLContextEGL> gl = new GLContextEGL(
+      egl, {}, config, (EGLSurface)aSurface, (EGLContext)aContext);
   gl->SetIsDoubleBuffered(true);
   gl->mOwnsContext = false;
 
@@ -1013,9 +1011,7 @@
 }
 #endif  // defined(ANDROID)
 
-static void FillOffscreenContextAttribs(bool alpha, bool depth, bool stencil,
-                                        bool bpp16, bool es3, bool useGles,
-                                        nsTArray<EGLint>* out) {
+static void FillContextAttribs(bool es3, bool useGles, nsTArray<EGLint>* out) {
   out->AppendElement(LOCAL_EGL_SURFACE_TYPE);
 #if defined(MOZ_WAYLAND)
   if (IS_WAYLAND_DISPLAY()) {
@@ -1039,38 +1035,22 @@
   }
 
   out->AppendElement(LOCAL_EGL_RED_SIZE);
-  if (bpp16) {
-    out->AppendElement(alpha ? 4 : 5);
-  } else {
-    out->AppendElement(8);
-  }
+  out->AppendElement(8);
 
   out->AppendElement(LOCAL_EGL_GREEN_SIZE);
-  if (bpp16) {
-    out->AppendElement(alpha ? 4 : 6);
-  } else {
-    out->AppendElement(8);
-  }
+  out->AppendElement(8);
 
   out->AppendElement(LOCAL_EGL_BLUE_SIZE);
-  if (bpp16) {
-    out->AppendElement(alpha ? 4 : 5);
-  } else {
-    out->AppendElement(8);
-  }
+  out->AppendElement(8);
 
   out->AppendElement(LOCAL_EGL_ALPHA_SIZE);
-  if (alpha) {
-    out->AppendElement(bpp16 ? 4 : 8);
-  } else {
-    out->AppendElement(0);
-  }
+  out->AppendElement(8);
 
   out->AppendElement(LOCAL_EGL_DEPTH_SIZE);
-  out->AppendElement(depth ? 16 : 0);
+  out->AppendElement(0);
 
   out->AppendElement(LOCAL_EGL_STENCIL_SIZE);
-  out->AppendElement(stencil ? 8 : 0);
+  out->AppendElement(0);
 
   // EGL_ATTRIBS_LIST_SAFE_TERMINATION_WORKING_AROUND_BUGS
   out->AppendElement(LOCAL_EGL_NONE);
@@ -1080,6 +1060,8 @@
   out->AppendElement(0);
 }
 
+/*
+/// Useful for debugging, but normally unused.
 static GLint GetAttrib(GLLibraryEGL* egl, EGLConfig config, EGLint attrib) {
   EGLint bits = 0;
   egl->fGetConfigAttrib(egl->Display(), config, attrib, &bits);
@@ -1087,23 +1069,19 @@
 
   return bits;
 }
+*/
 
-static EGLConfig ChooseConfigOffscreen(GLLibraryEGL* egl,
-                                       CreateContextFlags flags,
-                                       const SurfaceCaps& minCaps,
-                                       bool aUseGles,
-                                       SurfaceCaps* const out_configCaps) {
+static EGLConfig ChooseConfig(GLLibraryEGL* const egl,
+                              const GLContextCreateDesc& desc,
+                              const bool useGles) {
   nsTArray<EGLint> configAttribList;
-  FillOffscreenContextAttribs(minCaps.alpha, minCaps.depth, minCaps.stencil,
-                              minCaps.bpp16,
-                              bool(flags & CreateContextFlags::PREFER_ES3),
-                              aUseGles, &configAttribList);
+  FillContextAttribs(bool(desc.flags & CreateContextFlags::PREFER_ES3), useGles,
+                     &configAttribList);
 
   const EGLint* configAttribs = configAttribList.Elements();
 
-  // We're guaranteed to get at least minCaps, and the sorting dictated by the
-  // spec for eglChooseConfig reasonably assures that a reasonable 'best' config
-  // is on top.
+  // The sorting dictated by the spec for eglChooseConfig reasonably assures
+  // that a reasonable 'best' config is on top.
   const EGLint kMaxConfigs = 1;
   EGLConfig configs[kMaxConfigs];
   EGLint foundConfigs = 0;
@@ -1114,34 +1092,22 @@
   }
 
   EGLConfig config = configs[0];
-
-  *out_configCaps = minCaps;  // Pick up any preserve, etc.
-  out_configCaps->color = true;
-  out_configCaps->alpha = bool(GetAttrib(egl, config, LOCAL_EGL_ALPHA_SIZE));
-  out_configCaps->depth = bool(GetAttrib(egl, config, LOCAL_EGL_DEPTH_SIZE));
-  out_configCaps->stencil =
-      bool(GetAttrib(egl, config, LOCAL_EGL_STENCIL_SIZE));
-  out_configCaps->bpp16 = (GetAttrib(egl, config, LOCAL_EGL_RED_SIZE) < 8);
-
   return config;
 }
 
 /*static*/
 already_AddRefed<GLContextEGL>
 GLContextEGL::CreateEGLPBufferOffscreenContextImpl(
-    CreateContextFlags flags, const mozilla::gfx::IntSize& size,
-    const SurfaceCaps& minCaps, bool aUseGles,
-    nsACString* const out_failureId) {
-  bool forceEnableHardware =
-      bool(flags & CreateContextFlags::FORCE_ENABLE_HARDWARE);
+    const GLContextCreateDesc& desc, const mozilla::gfx::IntSize& size,
+    const bool useGles, nsACString* const out_failureId) {
+  const bool forceEnableHardware =
+      bool(desc.flags & CreateContextFlags::FORCE_ENABLE_HARDWARE);
   if (!GLLibraryEGL::EnsureInitialized(forceEnableHardware, out_failureId)) {
     return nullptr;
   }
 
   auto* egl = gl::GLLibraryEGL::Get();
-  SurfaceCaps configCaps;
-  EGLConfig config =
-      ChooseConfigOffscreen(egl, flags, minCaps, aUseGles, &configCaps);
+  const EGLConfig config = ChooseConfig(egl, desc, useGles);
   if (config == EGL_NO_CONFIG) {
     *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_EGL_NO_CONFIG");
     NS_WARNING("Failed to find a compatible config.");
@@ -1169,8 +1135,10 @@
     return nullptr;
   }
 
+  auto fullDesc = GLContextDesc{desc};
+  fullDesc.isOffscreen = true;
   RefPtr<GLContextEGL> gl = GLContextEGL::CreateGLContext(
-      egl, flags, configCaps, true, config, surface, aUseGles, out_failureId);
+      egl, fullDesc, config, surface, useGles, out_failureId);
   if (!gl) {
     NS_WARNING("Failed to create GLContext from PBuffer");
     egl->fDestroySurface(egl->Display(), surface);
@@ -1184,34 +1152,33 @@
 }
 
 already_AddRefed<GLContextEGL> GLContextEGL::CreateEGLPBufferOffscreenContext(
-    CreateContextFlags flags, const mozilla::gfx::IntSize& size,
-    const SurfaceCaps& minCaps, nsACString* const out_failureId) {
+    const GLContextCreateDesc& desc, const mozilla::gfx::IntSize& size,
+    nsACString* const out_failureId) {
   RefPtr<GLContextEGL> gl = CreateEGLPBufferOffscreenContextImpl(
-      flags, size, minCaps, /* aUseGles */ false, out_failureId);
+      desc, size, /* useGles */ false, out_failureId);
   if (!gl) {
-    gl = CreateEGLPBufferOffscreenContextImpl(
-        flags, size, minCaps, /* aUseGles */ true, out_failureId);
+    gl = CreateEGLPBufferOffscreenContextImpl(desc, size, /* useGles */ true,
+                                              out_failureId);
   }
   return gl.forget();
 }
 
 /*static*/
 already_AddRefed<GLContext> GLContextProviderEGL::CreateHeadless(
-    CreateContextFlags flags, nsACString* const out_failureId) {
+    const GLContextCreateDesc& desc, nsACString* const out_failureId) {
   mozilla::gfx::IntSize dummySize = mozilla::gfx::IntSize(16, 16);
-  SurfaceCaps dummyCaps = SurfaceCaps::Any();
-  return GLContextEGL::CreateEGLPBufferOffscreenContext(
-      flags, dummySize, dummyCaps, out_failureId);
+  return GLContextEGL::CreateEGLPBufferOffscreenContext(desc, dummySize,
+                                                        out_failureId);
 }
 
 // Under EGL, on Android, pbuffers are supported fine, though
 // often without the ability to texture from them directly.
 /*static*/
 already_AddRefed<GLContext> GLContextProviderEGL::CreateOffscreen(
-    const mozilla::gfx::IntSize& size, const SurfaceCaps& minCaps,
-    CreateContextFlags flags, nsACString* const out_failureId) {
+    const mozilla::gfx::IntSize& size, const GLContextCreateDesc& desc,
+    nsACString* const out_failureId) {
   bool forceEnableHardware =
-      bool(flags & CreateContextFlags::FORCE_ENABLE_HARDWARE);
+      bool(desc.flags & CreateContextFlags::FORCE_ENABLE_HARDWARE);
   if (!GLLibraryEGL::EnsureInitialized(
           forceEnableHardware, out_failureId)) {  // Needed for IsANGLE().
     return nullptr;
@@ -1225,37 +1192,17 @@
   }
 
 #if defined(MOZ_WIDGET_ANDROID)
-  // Using a headless context loses the SurfaceCaps
-  // which can cause a loss of depth and/or stencil
+  // Using a headless context loses the depth and/or stencil
   canOffscreenUseHeadless = false;
 #endif  //  defined(MOZ_WIDGET_ANDROID)
 
   RefPtr<GLContext> gl;
-  SurfaceCaps minOffscreenCaps = minCaps;
-
   if (canOffscreenUseHeadless) {
-    gl = CreateHeadless(flags, out_failureId);
-    if (!gl) {
-      return nullptr;
-    }
+    gl = CreateHeadless(desc, out_failureId);
   } else {
-    gl = GLContextEGL::CreateEGLPBufferOffscreenContext(
-        flags, size, minOffscreenCaps, out_failureId);
-    if (!gl) return nullptr;
-
-    // Pull the actual resulting caps to ensure that our offscreen matches our
-    // backbuffer.
-    minOffscreenCaps.alpha = gl->Caps().alpha;
-    minOffscreenCaps.depth = gl->Caps().depth;
-    minOffscreenCaps.stencil = gl->Caps().stencil;
+    gl = GLContextEGL::CreateEGLPBufferOffscreenContext(desc, size,
+                                                        out_failureId);
   }
-
-  // Init the offscreen with the updated offscreen caps.
-  if (!gl->InitOffscreen(size, minOffscreenCaps)) {
-    *out_failureId = NS_LITERAL_CSTRING("FEATURE_FAILURE_EGL_OFFSCREEN");
-    return nullptr;
-  }
-
   return gl.forget();
 }
 