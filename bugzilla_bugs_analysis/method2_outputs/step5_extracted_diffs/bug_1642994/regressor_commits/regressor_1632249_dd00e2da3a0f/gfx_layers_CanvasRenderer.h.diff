# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/CanvasRenderer.h
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f gfx/layers/CanvasRenderer.h
--- a/gfx/layers/CanvasRenderer.h	Wed Jun 10 21:57:19 2020 +0000
+++ b/gfx/layers/CanvasRenderer.h	Wed Jun 10 22:21:02 2020 +0000
@@ -7,6 +7,7 @@
 #ifndef GFX_CANVASRENDERER_H
 #define GFX_CANVASRENDERER_H
 
+#include <memory>            // for weak_ptr
 #include <stdint.h>          // for uint32_t
 #include "GLContextTypes.h"  // for GLContext
 #include "gfxContext.h"      // for gfxContext, etc
@@ -17,75 +18,63 @@
 #include "mozilla/RefPtr.h"       // for RefPtr
 #include "mozilla/gfx/2D.h"       // for DrawTarget
 #include "mozilla/mozalloc.h"     // for operator delete, etc
+#include "mozilla/WeakPtr.h"      // for WeakPtr
 #include "nsISupportsImpl.h"      // for MOZ_COUNT_CTOR, etc
 
+class nsICanvasRenderingContextInternal;
+
 namespace mozilla {
 namespace layers {
 
-class AsyncCanvasRenderer;
 class ClientCanvasRenderer;
-class CopyableCanvasRenderer;
-class OOPCanvasRenderer;
 class PersistentBufferProvider;
 class WebRenderCanvasRendererAsync;
 
-struct CanvasInitializeData final {
-  CanvasInitializeData();
-  ~CanvasInitializeData();
+struct CanvasRendererData final {
+  CanvasRendererData();
+  ~CanvasRendererData();
 
-  // One of these four must be specified for Canvas2D, but never more than one
-  RefPtr<PersistentBufferProvider>
-      mBufferProvider;  // A BufferProvider for the Canvas contents
-  RefPtr<mozilla::gl::GLContext> mGLContext;  // or this, for GL.
-  RefPtr<AsyncCanvasRenderer> mRenderer;      // or this, for OffscreenCanvas
-  RefPtr<OOPCanvasRenderer> mOOPRenderer;  // or this, for WebGL in host process
-
-  typedef void (*TransactionCallback)(void* closureData);
-  TransactionCallback mPreTransCallback = nullptr;
-  void* mPreTransCallbackData = nullptr;
-  TransactionCallback mDidTransCallback = nullptr;
-  void* mDidTransCallbackData = nullptr;
+  std::weak_ptr<nsICanvasRenderingContextInternal* const>
+      mContext;  // weak_ptr to ptr (bug 1635644)
 
   // The size of the canvas content
   gfx::IntSize mSize = {0, 0};
 
-  // Whether the canvas drawingbuffer has an alpha channel.
-  bool mHasAlpha = false;
+  bool mDoPaintCallbacks = false;
+  bool mIsOpaque = true;
+  bool mIsAlphaPremult = true;
+
+  gl::OriginPos mOriginPos = gl::OriginPos::TopLeft;
 
-  // Whether mGLContext contains data that is alpha-premultiplied.
-  bool mIsGLAlphaPremult = true;
+  nsICanvasRenderingContextInternal* GetContext() const {
+    const auto ptrToPtr = mContext.lock();
+    if (!ptrToPtr) return nullptr;
+    return *ptrToPtr;
+  }
 };
 
 // Based class which used for canvas rendering. There are many derived classes
 // for different purposes. such as:
 //
-// CopyableCanvasRenderer provides a utility which readback canvas content to a
-// SourceSurface. BasicCanvasLayer uses CopyableCanvasRenderer.
-//
 // ShareableCanvasRenderer provides IPC capabilities that allow sending canvas
 // content over IPC. This is pure virtual class because the IPC handling is
 // different in different LayerManager. So that we have following classes
-// inherite ShareableCanvasRenderer.
+// inherit ShareableCanvasRenderer.
 //
-// ClientCanvasRenderer inherites ShareableCanvasRenderer and be used in
+// ClientCanvasRenderer inherits ShareableCanvasRenderer and be used in
 // ClientCanvasLayer.
-// WebRenderCanvasRenderer inherites ShareableCanvasRenderer and provides all
+// WebRenderCanvasRenderer inherits ShareableCanvasRenderer and provides all
 // functionality that WebRender uses.
-// WebRenderCanvasRendererAsync inherites WebRenderCanvasRenderer and be used in
+// WebRenderCanvasRendererAsync inherits WebRenderCanvasRenderer and be used in
 // layers-free mode of WebRender.
 //
-// class diagram shows below:
+// class diagram:
 //
 //                       +--------------+
 //                       |CanvasRenderer|
 //                       +-------+------+
 //                               ^
 //                               |
-//                   +----------------------+
-//                   |CopyableCanvasRenderer|
-//                   +----------------------+
-//                               ^
-//                               |
 //                   +-----------+-----------+
 //                   |ShareableCanvasRenderer|
 //                   +-----+-----------------+
@@ -100,55 +89,59 @@
 //                           +-------------+--------------+
 //                           |WebRenderCanvasRendererAsync|
 //                           +----------------------------+
-class CanvasRenderer {
+
+class BorrowedSourceSurface final {
  public:
-  CanvasRenderer();
+  PersistentBufferProvider* const mReturnTo;
+  const RefPtr<gfx::SourceSurface> mSurf;  /// non-null
+
+  BorrowedSourceSurface(PersistentBufferProvider*, RefPtr<gfx::SourceSurface>);
+  ~BorrowedSourceSurface();
+};
+
+// -
+
+class CanvasRenderer : public RefCounted<CanvasRenderer> {
+  friend class CanvasRendererSourceSurface;
+
+ public:
+  MOZ_DECLARE_REFCOUNTED_TYPENAME(CanvasRenderer)
+
+ private:
+  bool mDirty = false;
+
+ protected:
+  CanvasRendererData mData;
+
+ public:
+  explicit CanvasRenderer();
   virtual ~CanvasRenderer();
 
  public:
-  virtual void Initialize(const CanvasInitializeData& aData);
-  virtual bool IsDataValid(const CanvasInitializeData& aData) { return true; }
+  virtual void Initialize(const CanvasRendererData&);
+  virtual bool IsDataValid(const CanvasRendererData&) const;
 
   virtual void ClearCachedResources() {}
-  virtual void Destroy() {}
+  virtual void DisconnectClient() {}
 
-  const gfx::IntSize& GetSize() const { return mSize; }
+  const gfx::IntSize& GetSize() const { return mData.mSize; }
+  bool IsOpaque() const { return mData.mIsOpaque; }
+  bool YIsDown() const { return mData.mOriginPos == gl::OriginPos::TopLeft; }
 
   void SetDirty() { mDirty = true; }
   void ResetDirty() { mDirty = false; }
   bool IsDirty() const { return mDirty; }
 
-  virtual CopyableCanvasRenderer* AsCopyableCanvasRenderer() { return nullptr; }
   virtual ClientCanvasRenderer* AsClientCanvasRenderer() { return nullptr; }
   virtual WebRenderCanvasRendererAsync* AsWebRenderCanvasRendererAsync() {
     return nullptr;
   }
 
- protected:
-  void FirePreTransactionCallback() {
-    if (mPreTransCallback) {
-      mPreTransCallback(mPreTransCallbackData);
-    }
-  }
-
-  void FireDidTransactionCallback() {
-    if (mDidTransCallback) {
-      mDidTransCallback(mDidTransCallbackData);
-    }
-  }
+  std::shared_ptr<BorrowedSourceSurface> BorrowSnapshot() const;
 
-  typedef void (*TransactionCallback)(void* closureData);
-  TransactionCallback mPreTransCallback;
-  void* mPreTransCallbackData;
-  TransactionCallback mDidTransCallback;
-  void* mDidTransCallbackData;
-  gfx::IntSize mSize;
-
- private:
-  /**
-   * Set to true in Updated(), cleared during a transaction.
-   */
-  bool mDirty;
+ protected:
+  void FirePreTransactionCallback() const;
+  void FireDidTransactionCallback() const;
 };
 
 }  // namespace layers