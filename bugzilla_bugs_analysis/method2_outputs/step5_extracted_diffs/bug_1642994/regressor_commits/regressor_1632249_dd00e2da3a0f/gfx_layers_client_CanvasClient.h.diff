# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/client/CanvasClient.h
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 3
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f gfx/layers/client/CanvasClient.h
--- a/gfx/layers/client/CanvasClient.h	Wed Jun 10 21:57:19 2020 +0000
+++ b/gfx/layers/client/CanvasClient.h	Wed Jun 10 22:21:02 2020 +0000
@@ -23,196 +23,46 @@
 #include "mozilla/gfx/Point.h"  // for IntSize
 #include "mozilla/gfx/Types.h"  // for SurfaceFormat
 
-class nsICanvasRenderingContextInternal;
-
 namespace mozilla {
 namespace layers {
 
-class AsyncCanvasRenderer;
-class ShareableCanvasRenderer;
 class CompositableForwarder;
-class ShadowableLayer;
-class SharedSurfaceTextureClient;
-class OOPCanvasRenderer;
 
 /**
  * Compositable client for 2d and webgl canvas.
  */
-class CanvasClient : public CompositableClient {
+class CanvasClient final : public CompositableClient {
+  int32_t mFrameID = 0;
+  RefPtr<TextureClient> mFrontBuffer;
+
  public:
-  typedef MaybeOneOf<ShareableCanvasRenderer*, AsyncCanvasRenderer*> Renderer;
-
   /**
    * Creates, configures, and returns a new canvas client. If necessary, a
    * message will be sent to the compositor to create a corresponding image
    * host.
    */
-  enum CanvasClientType {
-    CanvasClientSurface,
-    CanvasClientGLContext,
-    CanvasClientTypeShSurf,
-    CanvasClientAsync,    // webgl on workers
-    CanvasClientTypeOOP,  // webgl in remote process
-  };
-  static already_AddRefed<CanvasClient> CreateCanvasClient(
-      CanvasClientType aType, CompositableForwarder* aFwd, TextureFlags aFlags);
-
-  CanvasClient(CompositableForwarder* aFwd, TextureFlags aFlags)
-      : CompositableClient(aFwd, aFlags), mFrameID(0) {
-    mTextureFlags = aFlags;
-  }
+  CanvasClient(CompositableForwarder* aFwd, const TextureFlags flags)
+      : CompositableClient(aFwd, flags) {}
 
   virtual ~CanvasClient() = default;
 
-  virtual void Clear(){};
-
-  virtual void Update(gfx::IntSize aSize,
-                      ShareableCanvasRenderer* aCanvasRenderer) = 0;
+  void Clear() { mFrontBuffer = nullptr; }
 
   bool AddTextureClient(TextureClient* aTexture) override {
     ++mFrameID;
     return CompositableClient::AddTextureClient(aTexture);
   }
 
-  virtual void UpdateAsync(AsyncCanvasRenderer* aRenderer) {}
-
-  virtual void UpdateFromTexture(TextureClient* aTexture) {}
-
-  virtual void Updated() {}
-
- protected:
-  int32_t mFrameID;
-};
-
-// Used for 2D canvases and WebGL canvas on non-GL systems where readback is
-// requried.
-class CanvasClient2D : public CanvasClient {
- public:
-  CanvasClient2D(CompositableForwarder* aLayerForwarder, TextureFlags aFlags)
-      : CanvasClient(aLayerForwarder, aFlags) {}
-
   TextureInfo GetTextureInfo() const override {
     return TextureInfo(CompositableType::IMAGE, mTextureFlags);
   }
 
-  void Clear() override {
-    mBackBuffer = mFrontBuffer = mBufferProviderTexture = nullptr;
-  }
-
-  void Update(gfx::IntSize aSize,
-              ShareableCanvasRenderer* aCanvasRenderer) override;
-
-  void UpdateFromTexture(TextureClient* aBuffer) override;
-
-  bool AddTextureClient(TextureClient* aTexture) override {
-    return CanvasClient::AddTextureClient(aTexture);
-  }
-
-  void OnDetach() override { mBackBuffer = mFrontBuffer = nullptr; }
-
- private:
-  already_AddRefed<TextureClient> CreateTextureClientForCanvas(
-      gfx::SurfaceFormat aFormat, gfx::IntSize aSize, TextureFlags aFlags,
-      ShareableCanvasRenderer* aCanvasRenderer);
-
-  RefPtr<TextureClient> mBackBuffer;
-  RefPtr<TextureClient> mFrontBuffer;
-  // We store this texture separately to make sure it is not written into
-  // in Update() if for some silly reason we end up alternating between
-  // UpdateFromTexture and Update.
-  // This code is begging for a cleanup. The situation described above should
-  // not be made possible.
-  RefPtr<TextureClient> mBufferProviderTexture;
-};
-
-// Used for GL canvases where we don't need to do any readback, i.e., with a
-// GL backend.
-class CanvasClientSharedSurface : public CanvasClient {
- private:
-  RefPtr<SharedSurfaceTextureClient> mShSurfClient;
-  RefPtr<TextureClient> mReadbackClient;
-  RefPtr<TextureClient> mFront;
-  RefPtr<TextureClient> mNewFront;
-
-  void ClearSurfaces();
-
- public:
-  CanvasClientSharedSurface(CompositableForwarder* aLayerForwarder,
-                            TextureFlags aFlags);
-
-  ~CanvasClientSharedSurface();
-
-  TextureInfo GetTextureInfo() const override {
-    return TextureInfo(CompositableType::IMAGE);
-  }
-
-  void Clear() override { ClearSurfaces(); }
-
-  void Update(gfx::IntSize aSize,
-              ShareableCanvasRenderer* aCanvasRenderer) override;
-  void UpdateRenderer(gfx::IntSize aSize, Renderer& aRenderer);
-
-  void UpdateAsync(AsyncCanvasRenderer* aRenderer) override;
+  void OnDetach() override { Clear(); }
 
-  void Updated() override;
-
-  void OnDetach() override;
-};
-
-/**
- * Used for OMT<canvas> uploads using the image bridge protocol.
- * Actual CanvasClient is on the ImageBridgeChild thread, so we
- * only forward its AsyncID here
- */
-class CanvasClientBridge final : public CanvasClient {
- public:
-  CanvasClientBridge(CompositableForwarder* aLayerForwarder,
-                     TextureFlags aFlags)
-      : CanvasClient(aLayerForwarder, aFlags), mLayer(nullptr) {
-    mIsAsync = true;
-  }
-
-  TextureInfo GetTextureInfo() const override {
-    return TextureInfo(CompositableType::IMAGE);
-  }
-
-  void Update(gfx::IntSize aSize,
-              ShareableCanvasRenderer* aCanvasRenderer) override {}
-
-  void UpdateAsync(AsyncCanvasRenderer* aRenderer) override;
-
-  void SetLayer(ShadowableLayer* aLayer) { mLayer = aLayer; }
-
- protected:
-  CompositableHandle mAsyncHandle;
-  ShadowableLayer* mLayer;
-};
-
-/**
- * Used for WebGL instances that perform all composition in the host process.
- */
-class CanvasClientOOP final : public CanvasClient {
- public:
-  CanvasClientOOP(CompositableForwarder* aLayerForwarder, TextureFlags aFlags);
-  ~CanvasClientOOP();
-
-  TextureInfo GetTextureInfo() const override {
-    return TextureInfo(CompositableType::IMAGE);
-  }
-
-  virtual void Update(gfx::IntSize aSize,
-                      ShareableCanvasRenderer* aCanvasRenderer) override;
-
-  virtual void UpdateAsync(AsyncCanvasRenderer* aRenderer) override {
-    MOZ_ASSERT_UNREACHABLE("Illegal to call UpdateAsync on CanvasClientOOP");
-  }
-
-  void SetLayer(ShadowableLayer* aLayer, OOPCanvasRenderer* aRenderer);
-
- protected:
-  nsICanvasRenderingContextInternal* mCanvasContext = nullptr;
-  ShadowableLayer* mLayer = nullptr;
-  CompositableHandle mHandle;
+  RefPtr<TextureClient> CreateTextureClientForCanvas(gfx::SurfaceFormat,
+                                                     gfx::IntSize,
+                                                     TextureFlags);
+  void UseTexture(TextureClient*);
 };
 
 }  // namespace layers