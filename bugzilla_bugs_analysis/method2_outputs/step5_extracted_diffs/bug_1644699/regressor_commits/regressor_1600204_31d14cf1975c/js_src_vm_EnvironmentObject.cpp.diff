# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/EnvironmentObject.cpp
# Commit: 31d14cf1975c
# Full Hash: 31d14cf1975c1b23ef3db176252f8cc3b31a0772
# Author: Logan Smyth <loganfsmyth@gmail.com>
# Date: 2019-12-09 09:50:39
# Regressor Bug: 1600204
# File Overlap Count: 2
# Description:
#   Bug 1600204 - Part 7: Support .this on suspended generator frames. r=jimb
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D55580
# ==============================================================================

diff -r fa46d8caefde -r 31d14cf1975c js/src/vm/EnvironmentObject.cpp
--- a/js/src/vm/EnvironmentObject.cpp	Sun Dec 08 23:54:15 2019 +0000
+++ b/js/src/vm/EnvironmentObject.cpp	Sun Dec 08 23:54:38 2019 +0000
@@ -3361,17 +3361,10 @@
   return nullptr;
 }
 
-bool js::GetThisValueForDebuggerMaybeOptimizedOut(JSContext* cx,
-                                                  AbstractFramePtr frame,
-                                                  jsbytecode* pc,
-                                                  MutableHandleValue res) {
-  RootedObject scopeChain(cx);
-  RootedScope scope(cx);
-  if (!GetFrameEnvironmentAndScope(cx, frame, pc, &scopeChain, &scope)) {
-    return false;
-  }
-
-  for (EnvironmentIter ei(cx, scopeChain, scope, frame); ei; ei++) {
+static bool GetThisValueForDebuggerEnvironmentIterMaybeOptimizedOut(
+    JSContext* cx, const EnvironmentIter& originalIter, HandleObject scopeChain,
+    const jsbytecode* pc, MutableHandleValue res) {
+  for (EnvironmentIter ei(cx, originalIter); ei; ei++) {
     if (ei.scope().kind() == ScopeKind::Module) {
       res.setUndefined();
       return true;
@@ -3384,40 +3377,45 @@
 
     RootedScript script(cx, ei.scope().as<FunctionScope>().script());
 
-    // Figure out if we executed JSOP_FUNCTIONTHIS and set it.
-    bool executedInitThisOp = false;
-    if (script->functionHasThisBinding()) {
-      for (jsbytecode* it = script->code(); it < script->codeEnd();
-           it = GetNextPc(it)) {
-        if (*it == JSOP_FUNCTIONTHIS) {
-          // The next op after JSOP_FUNCTIONTHIS always sets it.
-          executedInitThisOp = pc > GetNextPc(it);
-          break;
+    if (ei.withinInitialFrame()) {
+      MOZ_ASSERT(pc, "must have PC if there is an initial frame");
+
+      // Figure out if we executed JSOP_FUNCTIONTHIS and set it.
+      bool executedInitThisOp = false;
+      if (script->functionHasThisBinding()) {
+        for (jsbytecode* it = script->code(); it < script->codeEnd();
+             it = GetNextPc(it)) {
+          if (*it == JSOP_FUNCTIONTHIS) {
+            // The next op after JSOP_FUNCTIONTHIS always sets it.
+            executedInitThisOp = pc > GetNextPc(it);
+            break;
+          }
         }
       }
-    }
-
-    if (ei.withinInitialFrame() && !executedInitThisOp) {
-      // Either we're yet to initialize the this-binding
-      // (JSOP_FUNCTIONTHIS), or the script does not have a this-binding
-      // (because it doesn't use |this|).
-
-      // If our this-argument is an object, or we're in strict mode,
-      // the this-binding is always the same as our this-argument.
-      if (frame.thisArgument().isObject() || script->strict()) {
-        res.set(frame.thisArgument());
+
+      if (!executedInitThisOp) {
+        AbstractFramePtr initialFrame = ei.initialFrame();
+        // Either we're yet to initialize the this-binding
+        // (JSOP_FUNCTIONTHIS), or the script does not have a this-binding
+        // (because it doesn't use |this|).
+
+        // If our this-argument is an object, or we're in strict mode,
+        // the this-binding is always the same as our this-argument.
+        if (initialFrame.thisArgument().isObject() || script->strict()) {
+          res.set(initialFrame.thisArgument());
+          return true;
+        }
+
+        // We didn't initialize the this-binding yet. Determine the
+        // correct |this| value for this frame (box primitives if not
+        // in strict mode), and assign it to the this-argument slot so
+        // JSOP_FUNCTIONTHIS will use it and not box a second time.
+        if (!GetFunctionThis(cx, initialFrame, res)) {
+          return false;
+        }
+        initialFrame.thisArgument() = res;
         return true;
       }
-
-      // We didn't initialize the this-binding yet. Determine the
-      // correct |this| value for this frame (box primitives if not
-      // in strict mode), and assign it to the this-argument slot so
-      // JSOP_FUNCTIONTHIS will use it and not box a second time.
-      if (!GetFunctionThis(cx, frame, res)) {
-        return false;
-      }
-      frame.thisArgument() = res;
-      return true;
     }
 
     if (!script->functionHasThisBinding()) {
@@ -3439,7 +3437,7 @@
 
       if (loc.kind() == BindingLocation::Kind::Frame &&
           ei.withinInitialFrame()) {
-        res.set(frame.unaliasedLocal(loc.slot()));
+        res.set(ei.initialFrame().unaliasedLocal(loc.slot()));
       } else {
         res.setMagic(JS_OPTIMIZED_OUT);
       }
@@ -3454,6 +3452,33 @@
   return true;
 }
 
+bool js::GetThisValueForDebuggerFrameMaybeOptimizedOut(JSContext* cx,
+                                                       AbstractFramePtr frame,
+                                                       jsbytecode* pc,
+                                                       MutableHandleValue res) {
+  RootedObject scopeChain(cx);
+  RootedScope scope(cx);
+  if (!GetFrameEnvironmentAndScope(cx, frame, pc, &scopeChain, &scope)) {
+    return false;
+  }
+
+  EnvironmentIter ei(cx, scopeChain, scope, frame);
+  return GetThisValueForDebuggerEnvironmentIterMaybeOptimizedOut(
+      cx, ei, scopeChain, pc, res);
+}
+
+bool js::GetThisValueForDebuggerSuspendedGeneratorMaybeOptimizedOut(
+    JSContext* cx, AbstractGeneratorObject& genObj, JSScript* script,
+    MutableHandleValue res) {
+  RootedObject scopeChain(cx);
+  RootedScope scope(cx);
+  GetSuspendedGeneratorEnvironmentAndScope(genObj, script, &scopeChain, &scope);
+
+  EnvironmentIter ei(cx, scopeChain, scope);
+  return GetThisValueForDebuggerEnvironmentIterMaybeOptimizedOut(
+      cx, ei, scopeChain, nullptr, res);
+}
+
 bool js::CheckLexicalNameConflict(JSContext* cx,
                                   Handle<LexicalEnvironmentObject*> lexicalEnv,
                                   HandleObject varObj,