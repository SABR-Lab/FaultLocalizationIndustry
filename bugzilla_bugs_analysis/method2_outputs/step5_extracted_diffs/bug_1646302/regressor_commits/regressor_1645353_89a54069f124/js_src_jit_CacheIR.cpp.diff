# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/CacheIR.cpp
# Commit: 89a54069f124
# Full Hash: 89a54069f124b175a0069affaaa1f55ff83214de
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2020-06-16 15:49:59
# Regressor Bug: 1645353
# File Overlap Count: 1
# Description:
#   Bug 1645353 part 2 - Use the template object for scripted constructor calls. r=evilpie,iain
#   
#   Also emit the .prototype guard directly in CacheIR. This way we don't need any of
#   the code IonBuilder has for this in Warp. Only do this if WarpBuilder is enabled
#   because Baseline doesn't need it and this way we avoid potential Ion perf
# ==============================================================================

diff -r 83569838f633 -r 89a54069f124 js/src/jit/CacheIR.cpp
--- a/js/src/jit/CacheIR.cpp	Sun Jun 14 10:32:32 2020 +0000
+++ b/js/src/jit/CacheIR.cpp	Mon Jun 15 15:46:48 2020 +0000
@@ -6281,10 +6281,16 @@
     return true;
   }
 
-  // Only attach a stub if the function already has a prototype and
-  // we can look it up without causing side effects.
+  // Only attach a stub if the newTarget is a function that already has a
+  // prototype and we can look it up without causing side effects.
   RootedValue protov(cx_);
   RootedObject newTarget(cx_, &newTarget_.toObject());
+  if (!newTarget->is<JSFunction>() ||
+      !newTarget->as<JSFunction>().hasNonConfigurablePrototypeDataProperty()) {
+    trackAttached(IRGenerator::NotAttached);
+    *skipAttach = true;
+    return true;
+  }
   if (!GetPropertyPure(cx_, newTarget, NameToId(cx_->names().prototype),
                        protov.address())) {
     // Can't purely lookup function prototype
@@ -6384,6 +6390,28 @@
   if (isSpecialized) {
     // Ensure callee matches this stub's callee
     writer.guardSpecificFunction(calleeObjId, calleeFunc);
+    if (templateObj) {
+      // Call metaScriptedTemplateObject before emitting the call, so that Warp
+      // can use this template object before transpiling the call.
+      if (JitOptions.warpBuilder) {
+        // Emit guards to ensure the newTarget's .prototype property is what we
+        // expect. Note that getTemplateObjectForScripted checked newTarget is a
+        // function with a non-configurable .prototype data property.
+        JSFunction* newTarget = &newTarget_.toObject().as<JSFunction>();
+        Shape* shape = newTarget->lookupPure(cx_->names().prototype);
+        MOZ_ASSERT(shape);
+        uint32_t slot = shape->slot();
+        JSObject* prototypeObject = &newTarget->getSlot(slot).toObject();
+
+        ValOperandId newTargetValId = writer.loadArgumentDynamicSlot(
+            ArgumentKind::NewTarget, argcId, flags);
+        ObjOperandId newTargetObjId = writer.guardToObject(newTargetValId);
+        writer.guardShape(newTargetObjId, newTarget->lastProperty());
+        ObjOperandId protoId = writer.loadObject(prototypeObject);
+        writer.guardFunctionPrototype(newTargetObjId, protoId, slot);
+      }
+      writer.metaScriptedTemplateObject(calleeFunc, templateObj);
+    }
   } else {
     // Guard that object is a scripted function
     writer.guardClass(calleeObjId, GuardClassKind::JSFunction);
@@ -6401,11 +6429,6 @@
   writer.callScriptedFunction(calleeObjId, argcId, flags);
   writer.typeMonitorResult();
 
-  if (templateObj) {
-    MOZ_ASSERT(isSpecialized);
-    writer.metaScriptedTemplateObject(calleeFunc, templateObj);
-  }
-
   cacheIRStubKind_ = BaselineCacheIRStubKind::Monitored;
   if (isSpecialized) {
     trackAttached("Call scripted func");