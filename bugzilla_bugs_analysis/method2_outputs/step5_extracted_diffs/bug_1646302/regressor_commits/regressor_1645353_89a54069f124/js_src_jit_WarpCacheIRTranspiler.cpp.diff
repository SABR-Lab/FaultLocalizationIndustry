# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/WarpCacheIRTranspiler.cpp
# Commit: 89a54069f124
# Full Hash: 89a54069f124b175a0069affaaa1f55ff83214de
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2020-06-16 15:49:59
# Regressor Bug: 1645353
# File Overlap Count: 1
# Description:
#   Bug 1645353 part 2 - Use the template object for scripted constructor calls. r=evilpie,iain
#   
#   Also emit the .prototype guard directly in CacheIR. This way we don't need any of
#   the code IonBuilder has for this in Warp. Only do this if WarpBuilder is enabled
#   because Baseline doesn't need it and this way we avoid potential Ion perf
# ==============================================================================

diff -r 83569838f633 -r 89a54069f124 js/src/jit/WarpCacheIRTranspiler.cpp
--- a/js/src/jit/WarpCacheIRTranspiler.cpp	Sun Jun 14 10:32:32 2020 +0000
+++ b/js/src/jit/WarpCacheIRTranspiler.cpp	Mon Jun 15 15:46:48 2020 +0000
@@ -1555,27 +1555,37 @@
   if (callInfo_->constructing()) {
     MOZ_ASSERT(flags.isConstructing());
 
-    callInfo_->thisArg()->setImplicitlyUsedUnchecked();
+    MDefinition* thisArg = callInfo_->thisArg();
 
     if (kind == CallKind::Native) {
-      // We know we are constructing a native function even if we don't know the
-      // actual target.
-
-      // Magic value passed to natives to indicate construction.
-      callInfo_->setThis(constant(MagicValue(JS_IS_CONSTRUCTING)));
-
-      needsThisCheck = false;
+      // Native functions keep the is-constructing MagicValue as |this|.
+      // If one of the arguments uses spread syntax this can be a loop phi with
+      // MIRType::Value.
+      MOZ_ASSERT_IF(!thisArg->isPhi(),
+                    thisArg->type() == MIRType::MagicIsConstructing);
     } else {
       MOZ_ASSERT(kind == CallKind::Scripted);
 
-      // TODO: Optimize |this| creation based on CacheIR.
-      MDefinition* newTarget = callInfo_->getNewTarget();
-      auto* createThis = MCreateThis::New(alloc(), callee, newTarget);
-      add(createThis);
-      callInfo_->setThis(createThis);
+      // TODO: if wrappedTarget->constructorNeedsUninitializedThis(), use an
+      // uninitialized-lexical constant as |this|. To do this we need to either
+      // store a new flag in the GuardSpecificFunction CacheIR/MIR instructions
+      // or we could add a new op similar to MetaTwoByte.
+
+      if (!thisArg->isCreateThisWithTemplate()) {
+        // Note: guard against Value loop phis similar to the Native case above.
+        MOZ_ASSERT_IF(!thisArg->isPhi(),
+                      thisArg->type() == MIRType::MagicIsConstructing);
 
-      wrappedTarget = nullptr;
-      needsThisCheck = true;
+        MDefinition* newTarget = callInfo_->getNewTarget();
+        auto* createThis = MCreateThis::New(alloc(), callee, newTarget);
+        add(createThis);
+
+        thisArg->setImplicitlyUsedUnchecked();
+        callInfo_->setThis(createThis);
+
+        wrappedTarget = nullptr;
+        needsThisCheck = true;
+      }
     }
   }
 
@@ -1617,9 +1627,26 @@
   return emitCallFunction(calleeId, argcId, flags, CallKind::Scripted);
 }
 
+// TODO: rename the MetaTwoByte op when IonBuilder is gone.
 bool WarpCacheIRTranspiler::emitMetaTwoByte(MetaTwoByteKind kind,
                                             uint32_t functionObjectOffset,
                                             uint32_t templateObjectOffset) {
+  if (kind != MetaTwoByteKind::ScriptedTemplateObject) {
+    return true;
+  }
+
+  JSObject* templateObj = objectStubField(templateObjectOffset);
+  MConstant* templateConst = constant(ObjectValue(*templateObj));
+
+  // TODO: support pre-tenuring.
+  gc::InitialHeap heap = gc::DefaultHeap;
+
+  auto* createThis = MCreateThisWithTemplate::New(
+      alloc(), /* constraints = */ nullptr, templateConst, heap);
+  add(createThis);
+
+  callInfo_->thisArg()->setImplicitlyUsedUnchecked();
+  callInfo_->setThis(createThis);
   return true;
 }
 
