# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.cpp
# Commit: d027f301f08c
# Full Hash: d027f301f08c38d8ab3095abfe0a04f2255f6e6c
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-06-16 03:30:48
# Regressor Bug: 1640019
# File Overlap Count: 1
# Description:
#   Bug 1640019 - Part 1: Support toplevel process switches outside of tabbrowser, r=mattwoodrow
#   
#   This new process switching behavior is only enabled for some browser elements,
#   which have specified a specific attribute. Turning this on for all browsers with
#   a `remote` attribute causes breakage in reftests.
# ==============================================================================

diff -r 82becb1f6eae -r d027f301f08c netwerk/ipc/DocumentLoadListener.cpp
--- a/netwerk/ipc/DocumentLoadListener.cpp	Tue Jun 16 02:46:15 2020 +0300
+++ b/netwerk/ipc/DocumentLoadListener.cpp	Mon Jun 15 23:23:43 2020 +0000
@@ -1118,46 +1118,53 @@
     return false;
   }
 
-  // We currently can't switch processes for toplevel loads unless they're
-  // loaded within a browser tab.
-  // FIXME: Ideally we won't do this in the future.
-  nsCOMPtr<nsIBrowser> browser;
+  // Determine what process switching behaviour is being requested by the root
+  // <browser> element.
+  Element* browserElement = browsingContext->Top()->GetEmbedderElement();
+  if (!browserElement) {
+    LOG(("Process Switch Abort: cannot get embedder element"));
+    return false;
+  }
+  nsCOMPtr<nsIBrowser> browser = browserElement->AsBrowser();
+  if (!browser) {
+    LOG(("Process Switch Abort: not loaded within nsIBrowser"));
+    return false;
+  }
+
+  nsIBrowser::ProcessBehavior processBehavior =
+      nsIBrowser::PROCESS_BEHAVIOR_DISABLED;
+  nsresult rv = browser->GetProcessSwitchBehavior(&processBehavior);
+  if (NS_FAILED(rv)) {
+    MOZ_ASSERT_UNREACHABLE(
+        "nsIBrowser::GetProcessSwitchBehavior shouldn't fail");
+    LOG(("Process Switch Abort: failed to get process switch behavior"));
+    return false;
+  }
+
+  // Check if the process switch we're considering is disabled by the
+  // <browser>'s process behavior.
+  if (processBehavior == nsIBrowser::PROCESS_BEHAVIOR_DISABLED) {
+    LOG(("Process Switch Abort: switch disabled by <browser>"));
+    return false;
+  }
+  if (browsingContext->IsTop() &&
+      processBehavior == nsIBrowser::PROCESS_BEHAVIOR_SUBFRAME_ONLY) {
+    LOG(("Process Switch Abort: toplevel switch disabled by <browser>"));
+    return false;
+  }
+
   bool isPreloadSwitch = false;
-  if (!browsingContext->GetParent()) {
-    Element* browserElement = browsingContext->GetEmbedderElement();
-    if (!browserElement) {
-      LOG(("Process Switch Abort: cannot get browser element"));
-      return false;
-    }
-    browser = browserElement->AsBrowser();
-    if (!browser) {
-      LOG(("Process Switch Abort: not loaded within nsIBrowser"));
-      return false;
-    }
-    bool loadedInTab = false;
-    if (NS_FAILED(browser->GetCanPerformProcessSwitch(&loadedInTab)) ||
-        !loadedInTab) {
-      LOG(("Process Switch Abort: browser is not loaded in a tab"));
-      return false;
-    }
-
-    // Leaving about:newtab from a used to be preloaded browser should run the
-    // process selecting algorithm again.
-    nsAutoString isPreloadBrowserStr;
-    if (browserElement->GetAttr(kNameSpaceID_None, nsGkAtoms::preloadedState,
-                                isPreloadBrowserStr)) {
-      if (isPreloadBrowserStr.EqualsLiteral("consumed")) {
-        nsCOMPtr<nsIURI> originalURI;
-        if (NS_SUCCEEDED(
-                mChannel->GetOriginalURI(getter_AddRefs(originalURI)))) {
-          if (!originalURI->GetSpecOrDefault().EqualsLiteral("about:newtab")) {
-            LOG(("Process Switch: leaving preloaded browser"));
-            isPreloadSwitch = true;
-            browserElement->UnsetAttr(kNameSpaceID_None,
-                                      nsGkAtoms::preloadedState, true);
-          }
-        }
-      }
+  nsAutoString isPreloadBrowserStr;
+  if (browserElement->GetAttr(kNameSpaceID_None, nsGkAtoms::preloadedState,
+                              isPreloadBrowserStr) &&
+      isPreloadBrowserStr.EqualsLiteral("consumed")) {
+    nsCOMPtr<nsIURI> originalURI;
+    if (NS_SUCCEEDED(mChannel->GetOriginalURI(getter_AddRefs(originalURI))) &&
+        !originalURI->GetSpecOrDefault().EqualsLiteral("about:newtab")) {
+      LOG(("Process Switch: leaving preloaded browser"));
+      isPreloadSwitch = true;
+      browserElement->UnsetAttr(kNameSpaceID_None, nsGkAtoms::preloadedState,
+                                true);
     }
   }
 
@@ -1173,7 +1180,7 @@
 
   // Get the final principal, used to select which process to load into.
   nsCOMPtr<nsIPrincipal> resultPrincipal;
-  nsresult rv = nsContentUtils::GetSecurityManager()->GetChannelResultPrincipal(
+  rv = nsContentUtils::GetSecurityManager()->GetChannelResultPrincipal(
       mChannel, getter_AddRefs(resultPrincipal));
   if (NS_FAILED(rv)) {
     LOG(("Process Switch Abort: failed to get channel result principal"));
@@ -1267,21 +1274,26 @@
   mDoingProcessSwitch = true;
 
   RefPtr<DocumentLoadListener> self = this;
-  // At this point, we're actually going to perform a process switch, which
-  // involves calling into other logic.
-  if (browsingContext->GetParent()) {
-    LOG(("Process Switch: Calling ChangeFrameRemoteness"));
-    // If we're switching a subframe, ask BrowsingContext to do it for us.
-    MOZ_ASSERT(!isCOOPSwitch);
-    browsingContext
-        ->ChangeFrameRemoteness(remoteType, mCrossProcessRedirectIdentifier)
+
+  // If <browser> has custom process switching behaviour, use that.
+  if (processBehavior == nsIBrowser::PROCESS_BEHAVIOR_CUSTOM &&
+      browsingContext->IsTop()) {
+    LOG(("Process Switch: Calling nsIBrowser::PerformProcessSwitch"));
+    // We're switching a toplevel BrowsingContext's process. This has to be done
+    // using nsIBrowser.
+    RefPtr<dom::Promise> domPromise;
+    browser->PerformProcessSwitch(remoteType, mCrossProcessRedirectIdentifier,
+                                  isCOOPSwitch, getter_AddRefs(domPromise));
+    MOZ_DIAGNOSTIC_ASSERT(domPromise,
+                          "PerformProcessSwitch didn't return a promise");
+
+    MozPromise<uint64_t, nsresult, true>::FromDomPromise(domPromise)
         ->Then(
             GetMainThreadSerialEventTarget(), __func__,
-            [self](BrowserParent* aBrowserParent) {
+            [self](uint64_t aCpId) {
               MOZ_ASSERT(self->mChannel,
                          "Something went wrong, channel got cancelled");
-              self->TriggerRedirectToRealChannel(
-                  Some(aBrowserParent->Manager()->ChildID()));
+              self->TriggerRedirectToRealChannel(Some(aCpId));
             },
             [self](nsresult aStatusCode) {
               MOZ_ASSERT(NS_FAILED(aStatusCode), "Status should be error");
@@ -1290,22 +1302,17 @@
     return true;
   }
 
-  LOG(("Process Switch: Calling nsIBrowser::PerformProcessSwitch"));
-  // We're switching a toplevel BrowsingContext's process. This has to be done
-  // using nsIBrowser.
-  RefPtr<dom::Promise> domPromise;
-  browser->PerformProcessSwitch(remoteType, mCrossProcessRedirectIdentifier,
-                                isCOOPSwitch, getter_AddRefs(domPromise));
-  MOZ_DIAGNOSTIC_ASSERT(domPromise,
-                        "PerformProcessSwitch didn't return a promise");
-
-  MozPromise<uint64_t, nsresult, true>::FromDomPromise(domPromise)
+  LOG(("Process Switch: Calling ChangeRemoteness"));
+  browsingContext
+      ->ChangeRemoteness(remoteType, mCrossProcessRedirectIdentifier,
+                         isCOOPSwitch)
       ->Then(
           GetMainThreadSerialEventTarget(), __func__,
-          [self](uint64_t aCpId) {
+          [self](BrowserParent* aBrowserParent) {
             MOZ_ASSERT(self->mChannel,
                        "Something went wrong, channel got cancelled");
-            self->TriggerRedirectToRealChannel(Some(aCpId));
+            self->TriggerRedirectToRealChannel(
+                Some(aBrowserParent->Manager()->ChildID()));
           },
           [self](nsresult aStatusCode) {
             MOZ_ASSERT(NS_FAILED(aStatusCode), "Status should be error");