# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: image/imgRequest.cpp
# Commit: f4e67ab1b25f
# Full Hash: f4e67ab1b25f03d695505622f66970736f518fdb
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-06-15 21:48:38
# Regressor Bug: 1599160
# File Overlap Count: 1
# Description:
#   Bug 1599160 - Better integration of the shared stylesheet cache with the network cache. r=tnikkel,mayhemer,heycam
#   
#   Make the stylesheet cache respect the same headers as the image cache
#   does. This makes no-cache stylesheets work as they do now, which is
#   useful for developers that want to develop sites locally, and for
# ==============================================================================

diff -r a86e9b4f395f -r f4e67ab1b25f image/imgRequest.cpp
--- a/image/imgRequest.cpp	Fri Jun 12 19:05:56 2020 +0000
+++ b/image/imgRequest.cpp	Fri Jun 12 19:06:04 2020 +0000
@@ -517,53 +517,26 @@
 void imgRequest::SetCacheValidation(imgCacheEntry* aCacheEntry,
                                     nsIRequest* aRequest) {
   /* get the expires info */
-  if (aCacheEntry) {
-    // Expiration time defaults to 0. We set the expiration time on our
-    // entry if it hasn't been set yet.
-    if (aCacheEntry->GetExpiryTime() == 0) {
-      uint32_t expiration = 0;
-      nsCOMPtr<nsICacheInfoChannel> cacheChannel(do_QueryInterface(aRequest));
-      if (cacheChannel) {
-        /* get the expiration time from the caching channel's token */
-        cacheChannel->GetCacheTokenExpirationTime(&expiration);
-      }
-      if (expiration == 0) {
-        // If the channel doesn't support caching, then ensure this expires the
-        // next time it is used.
-        expiration = imgCacheEntry::SecondsFromPRTime(PR_Now()) - 1;
-      }
-      aCacheEntry->SetExpiryTime(expiration);
-    }
+  if (!aCacheEntry || aCacheEntry->GetExpiryTime() != 0) {
+    return;
+  }
 
-    // Determine whether the cache entry must be revalidated when we try to use
-    // it. Currently, only HTTP specifies this information...
-    nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
-    if (httpChannel) {
-      bool bMustRevalidate = false;
+  auto info = nsContentUtils::GetSubresourceCacheValidationInfo(aRequest);
 
-      Unused << httpChannel->IsNoStoreResponse(&bMustRevalidate);
-
-      if (!bMustRevalidate) {
-        Unused << httpChannel->IsNoCacheResponse(&bMustRevalidate);
-      }
-
-      if (!bMustRevalidate) {
-        nsAutoCString cacheHeader;
-
-        Unused << httpChannel->GetResponseHeader(
-            NS_LITERAL_CSTRING("Cache-Control"), cacheHeader);
-        if (PL_strcasestr(cacheHeader.get(), "must-revalidate")) {
-          bMustRevalidate = true;
-        }
-      }
-
-      // Cache entries default to not needing to validate. We ensure that
-      // multiple calls to this function don't override an earlier decision to
-      // validate by making validation a one-way decision.
-      if (bMustRevalidate) {
-        aCacheEntry->SetMustValidate(bMustRevalidate);
-      }
-    }
+  // Expiration time defaults to 0. We set the expiration time on our entry if
+  // it hasn't been set yet.
+  if (!info.mExpirationTime) {
+    // If the channel doesn't support caching, then ensure this expires the
+    // next time it is used.
+    info.mExpirationTime.emplace(nsContentUtils::SecondsFromPRTime(PR_Now()) -
+                                 1);
+  }
+  aCacheEntry->SetExpiryTime(*info.mExpirationTime);
+  // Cache entries default to not needing to validate. We ensure that
+  // multiple calls to this function don't override an earlier decision to
+  // validate by making validation a one-way decision.
+  if (info.mMustRevalidate) {
+    aCacheEntry->SetMustValidate(info.mMustRevalidate);
   }
 }
 