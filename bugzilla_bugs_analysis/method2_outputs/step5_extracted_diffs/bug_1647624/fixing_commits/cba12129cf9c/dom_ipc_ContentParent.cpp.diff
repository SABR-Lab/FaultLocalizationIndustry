# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/ipc/ContentParent.cpp
# Commit: cba12129cf9c
# Full Hash: cba12129cf9c50f2501fca8798be5fb9d142ad05
# Author: Kris Maglione <maglione.k@gmail.com>
# Date: 2020-06-24 09:31:07
# Description:
#   Bug 1647624: Add assertions that we don't return dead processes from process selector. r=nika
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D80705
# ==============================================================================

diff -r 9dfd25c1f542 -r cba12129cf9c dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp	Thu Jun 18 20:42:03 2020 +0000
+++ b/dom/ipc/ContentParent.cpp	Tue Jun 23 19:38:17 2020 +0000
@@ -44,6 +44,7 @@
 #include "URIUtils.h"
 #include "gfxPlatform.h"
 #include "gfxPlatformFontList.h"
+#include "mozilla/AutoRestore.h"
 #include "mozilla/ContentBlocking.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/BenchmarkStorageParent.h"
@@ -612,6 +613,12 @@
 // Set to true when the first content process gets created.
 static bool sCreatedFirstContentProcess = false;
 
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+// True when we're running the process selection code, and do not expect to
+// enter code paths where processes may die.
+static bool sInProcessSelector = false;
+#endif
+
 // The first content child has ID 1, so the chrome process can have ID 0.
 static uint64_t gContentChildID = 1;
 
@@ -861,6 +868,11 @@
     ContentParent* aOpener, const nsAString& aRemoteType,
     nsTArray<ContentParent*>& aContentParents, uint32_t aMaxContentParents,
     bool aPreferUsed) {
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+  AutoRestore ar(sInProcessSelector);
+  sInProcessSelector = true;
+#endif
+
   uint32_t numberOfParents = aContentParents.Length();
   nsTArray<RefPtr<nsIContentProcessInfo>> infos(numberOfParents);
   for (auto* cp : aContentParents) {
@@ -896,6 +908,7 @@
               ("GetUsedProcess: Reused process %p (%u) for %s", retval.get(),
                (unsigned int)retval->ChildID(),
                NS_ConvertUTF16toUTF8(aRemoteType).get()));
+      retval->AssertAlive();
       return retval.forget();
     }
   } else {
@@ -909,6 +922,7 @@
               ("GetUsedProcess: Reused random process %p (%d) for %s",
                random.get(), (unsigned int)random->ChildID(),
                NS_ConvertUTF16toUTF8(aRemoteType).get()));
+      random->AssertAlive();
       return random.forget();
     }
   }
@@ -923,7 +937,7 @@
       !aRemoteType.EqualsLiteral(EXTENSION_REMOTE_TYPE) &&  // Bug 1638119
       (p = PreallocatedProcessManager::Take(aRemoteType)) &&
       !p->mShutdownPending) {
-    MOZ_DIAGNOSTIC_ASSERT(!p->IsDead());
+    p->AssertAlive();
 
     // p may be a preallocated process, or (if not PREALLOC_REMOTE_TYPE)
     // a perviously-used process that's being recycled.  Currently this is
@@ -960,6 +974,7 @@
         cpId.AppendInt(static_cast<uint64_t>(p->ChildID()));
         obs->NotifyObservers(static_cast<nsIObserver*>(p), "process-type-set",
                              cpId.get());
+        p->AssertAlive();
       }
     } else {
       // we only allow "web" to "web" for security reasons
@@ -1005,6 +1020,7 @@
     MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
             ("GetNewOrUsedProcess: Used process %p (launching %d)",
              contentParent.get(), contentParent->IsLaunching()));
+    contentParent->AssertAlive();
     return contentParent.forget();
   }
 
@@ -1032,6 +1048,7 @@
   MOZ_ASSERT(contentParent->IsLaunching());
   MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
           ("GetNewOrUsedProcess: new process %p", contentParent.get()));
+  contentParent->AssertAlive();
   return contentParent.forget();
 }
 
@@ -1638,8 +1655,7 @@
 
 void ContentParent::AddToPool(nsTArray<ContentParent*>& aPool) {
   MOZ_DIAGNOSTIC_ASSERT(!mIsInPool);
-  MOZ_DIAGNOSTIC_ASSERT(!IsDead());
-  MOZ_DIAGNOSTIC_ASSERT(!mShutdownPending);
+  AssertAlive();
   MOZ_DIAGNOSTIC_ASSERT(!mCalledKillHard);
   aPool.AppendElement(this);
   mIsInPool = true;
@@ -1667,6 +1683,11 @@
   }
 }
 
+void ContentParent::AssertAlive() {
+  MOZ_DIAGNOSTIC_ASSERT(!IsDead());
+  MOZ_DIAGNOSTIC_ASSERT(!mShutdownPending);
+}
+
 void ContentParent::RemoveFromList() {
   if (IsForJSPlugin()) {
     if (sJSPluginContentParents) {
@@ -1710,6 +1731,7 @@
 void ContentParent::MarkAsDead() {
   MOZ_LOG(ContentParent::GetLog(), LogLevel::Verbose,
           ("Marking ContentProcess %p as dead", this));
+  MOZ_DIAGNOSTIC_ASSERT(!sInProcessSelector);
   if (!mShutdownPending) {
     RemoveFromList();
   }