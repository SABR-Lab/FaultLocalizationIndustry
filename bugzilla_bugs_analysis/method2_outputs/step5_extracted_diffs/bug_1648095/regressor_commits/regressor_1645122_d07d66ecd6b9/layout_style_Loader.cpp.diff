# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/Loader.cpp
# Commit: d07d66ecd6b9
# Full Hash: d07d66ecd6b9ca685444912826f25e9751ef13b5
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-06-23 21:38:40
# Regressor Bug: 1645122
# File Overlap Count: 3
# Description:
#   Bug 1645122 - Properly block onload when coalescing loads with other documents. r=heycam
#   
#   If two loading documents hit the sheet cache and we coalesce the
#   resource load, there's nothing that prevents the load event on the
#   second document from firing right now, and there should be.
# ==============================================================================

diff -r ce1a126dcf10 -r d07d66ecd6b9 layout/style/Loader.cpp
--- a/layout/style/Loader.cpp	Mon Jun 22 13:24:19 2020 +0000
+++ b/layout/style/Loader.cpp	Tue Jun 23 08:27:54 2020 +0000
@@ -1122,7 +1122,8 @@
  * existing load for this URI and piggyback on it.  Failing all that,
  * a new load is kicked off asynchronously.
  */
-nsresult Loader::LoadSheet(SheetLoadData& aLoadData, SheetState aSheetState) {
+nsresult Loader::LoadSheet(SheetLoadData& aLoadData, SheetState aSheetState,
+                           PendingLoad aPendingLoad) {
   LOG(("css::Loader::LoadSheet"));
   MOZ_ASSERT(aLoadData.mURI, "Need a URI to load");
   MOZ_ASSERT(aLoadData.mSheet, "Need a sheet to load into");
@@ -1132,9 +1133,16 @@
 
   LOG_URI("  Load from: '%s'", aLoadData.mURI);
 
-  ++mOngoingLoadCount;
-  if (aLoadData.mParentData) {
-    ++aLoadData.mParentData->mPendingChildren;
+  // If we're firing a pending load, this load is already accounted for the
+  // first time it went through this function.
+  if (aPendingLoad == PendingLoad::No) {
+    IncrementOngoingLoadCount();
+
+    // We technically never defer non-top-level sheets, so this condition could
+    // be outside the branch, but conceptually it should be here.
+    if (aLoadData.mParentData) {
+      ++aLoadData.mParentData->mPendingChildren;
+    }
   }
 
   nsresult rv = NS_OK;
@@ -1490,16 +1498,15 @@
 
   // This parse does not need to be synchronous. \o/
   //
-  // Note that we need to block onload because there may be no network requests
-  // pending.
-  BlockOnload();
+  // Note that load is already blocked from IncrementOngoingLoadCount(), and
+  // will be unblocked from SheetFinishedParsingAsync which will end up in
+  // NotifyObservers as needed.
   nsCOMPtr<nsISerialEventTarget> target = DispatchTarget();
   sheet->ParseSheet(*this, aBytes, aLoadData)
       ->Then(
           target, __func__,
           [loadData = RefPtr<SheetLoadData>(&aLoadData)](bool aDummy) {
             MOZ_ASSERT(NS_IsMainThread());
-            loadData->mLoader->UnblockOnload(/* aFireSync = */ false);
             loadData->SheetFinishedParsingAsync();
           },
           [] { MOZ_CRASH("rejected parse promise"); });
@@ -1509,9 +1516,11 @@
 void Loader::NotifyObservers(SheetLoadData& aData, nsresult aStatus) {
   RecordUseCountersIfNeeded(mDocument, aData.mUseCounters.get());
   if (aData.mURI) {
-    MOZ_DIAGNOSTIC_ASSERT(mOngoingLoadCount);
-    --mOngoingLoadCount;
     aData.NotifyStop(aStatus);
+    // NOTE(emilio): This needs to happen before notifying observers, as
+    // FontFaceSet for example checks for pending sheet loads from the
+    // StyleSheetLoaded callback.
+    DecrementOngoingLoadCount();
   }
 
   if (aData.mMustNotify) {
@@ -2051,10 +2060,7 @@
     NS_WARNING("failed to dispatch stylesheet load event");
     mPostedEvents.RemoveElement(aLoadData);
   } else {
-    ++mOngoingLoadCount;
-
-    // We'll unblock onload when we handle the event.
-    BlockOnload();
+    IncrementOngoingLoadCount();
 
     // We want to notify the observer for this data.
     aLoadData->mMustNotify = true;
@@ -2080,8 +2086,6 @@
 
   mPostedEvents.RemoveElement(&aEvent);
   SheetComplete(aEvent, NS_OK);
-
-  UnblockOnload(true);
 }
 
 void Loader::Stop() {