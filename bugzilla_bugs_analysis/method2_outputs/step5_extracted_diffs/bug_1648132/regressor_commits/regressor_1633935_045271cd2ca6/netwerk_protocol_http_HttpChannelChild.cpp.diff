# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpChannelChild.cpp
# Commit: 045271cd2ca6
# Full Hash: 045271cd2ca65fd83484574c24cb508e3aaa6579
# Author: Junior Hsu <juhsu@mozilla.com>
# Date: 2020-06-30 10:00:42
# Regressor Bug: 1633935
# File Overlap Count: 1
# Description:
#   Bug 1633935 - P8 suspend event queue in HttpChannelChild which needs listener for redirection, r=mayhemer,necko-reviewers
#   
#   Now OnStartRequest is passed to child process via pBg. Every IPC which is passed thru main thread could become a race.
#   For the redirection flow in child process is:
#   
# ==============================================================================

diff -r b1cdccfb383d -r 045271cd2ca6 netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp	Tue Jun 30 00:33:34 2020 +0000
+++ b/netwerk/protocol/http/HttpChannelChild.cpp	Tue Jun 30 00:33:41 2020 +0000
@@ -190,7 +190,9 @@
       mPostRedirectChannelShouldIntercept(false),
       mPostRedirectChannelShouldUpgrade(false),
       mShouldParentIntercept(false),
-      mSuspendParentAfterSynthesizeResponse(false) {
+      mSuspendParentAfterSynthesizeResponse(false),
+      mIsLastPartOfMultiPart(false),
+      mSuspendForWaitCompleteRedirectSetup(false) {
   LOG(("Creating HttpChannelChild @%p\n", this));
 
   mChannelCreationTime = PR_Now();
@@ -1324,6 +1326,14 @@
 
 mozilla::ipc::IPCResult HttpChannelChild::RecvDeleteSelf() {
   LOG(("HttpChannelChild::RecvDeleteSelf [this=%p]\n", this));
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The redirection is vetoed. No need to suspend the event queue.
+  if (mSuspendForWaitCompleteRedirectSetup) {
+    mSuspendForWaitCompleteRedirectSetup = false;
+    mEventQ->Resume();
+  }
+
   mEventQ->RunOrEnqueue(new NeckoTargetChannelFunctionEvent(
       this,
       [self = UnsafePtr<HttpChannelChild>(this)]() { self->DeleteSelf(); }));
@@ -2020,12 +2030,17 @@
 
   MaybeConnectToSocketProcess();
 
+  // Should wait for CompleteRedirectSetup to set the listener.
+  mEventQ->Suspend();
+  MOZ_ASSERT(!mSuspendForWaitCompleteRedirectSetup);
+  mSuspendForWaitCompleteRedirectSetup = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::CompleteRedirectSetup(nsIStreamListener* aListener) {
-  LOG(("HttpChannelChild::FinishRedirectSetup [this=%p]\n", this));
+  LOG(("HttpChannelChild::CompleteRedirectSetup [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
 
   NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
@@ -2075,6 +2090,11 @@
   // add ourselves to the load group.
   if (mLoadGroup) mLoadGroup->AddRequest(this, nullptr);
 
+  // Resume the suspension in ConnectParent.
+  MOZ_ASSERT(mSuspendForWaitCompleteRedirectSetup);
+  mEventQ->Resume();
+  mSuspendForWaitCompleteRedirectSetup = false;
+
   // We already have an open IPDL connection to the parent. If on-modify-request
   // listeners or load group observers canceled us, let the parent handle it
   // and send it back to us naturally.