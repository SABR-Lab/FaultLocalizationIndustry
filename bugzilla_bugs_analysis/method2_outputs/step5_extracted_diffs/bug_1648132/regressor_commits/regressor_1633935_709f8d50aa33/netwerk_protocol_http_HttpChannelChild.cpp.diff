# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpChannelChild.cpp
# Commit: 709f8d50aa33
# Full Hash: 709f8d50aa33f299e1e72366c59b1c28ad0b547b
# Author: Junior Hsu <juhsu@mozilla.com>
# Date: 2020-06-24 09:31:07
# Regressor Bug: 1633935
# File Overlap Count: 1
# Description:
#   Bug 1633935 - P10 wait PHttpChannel::OnStartRequestSent for permission/cookie update from parent, r=mayhemer,necko-reviewers
#   
#   Depends on D77751
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D77752
# ==============================================================================

diff -r 3b268ac50692 -r 709f8d50aa33 netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp	Tue Jun 23 16:58:33 2020 +0000
+++ b/netwerk/protocol/http/HttpChannelChild.cpp	Tue Jun 23 16:58:36 2020 +0000
@@ -189,7 +189,9 @@
       mShouldParentIntercept(false),
       mSuspendParentAfterSynthesizeResponse(false),
       mIsLastPartOfMultiPart(false),
-      mSuspendForWaitCompleteRedirectSetup(false) {
+      mSuspendForWaitCompleteRedirectSetup(false),
+      mRecvOnStartRequestSentCalled(false),
+      mSuspendedByWaitingForPermissionAndCookie(false) {
   LOG(("Creating HttpChannelChild @%p\n", this));
 
   mChannelCreationTime = PR_Now();
@@ -391,6 +393,20 @@
   mApplicationCache->InitAsHandle(aGroupID, aClientID);
 }
 
+mozilla::ipc::IPCResult HttpChannelChild::RecvOnStartRequestSent() {
+  LOG(("HttpChannelChild::RecvOnStartRequestSent [this=%p]\n", this));
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!mRecvOnStartRequestSentCalled);
+
+  mRecvOnStartRequestSentCalled = true;
+
+  if (mSuspendedByWaitingForPermissionAndCookie) {
+    mSuspendedByWaitingForPermissionAndCookie = false;
+    mEventQ->Resume();
+  }
+  return IPC_OK();
+}
+
 void HttpChannelChild::ProcessOnStartRequest(
     const nsHttpResponseHead& aResponseHead, const bool& aUseResponseHead,
     const nsHttpHeaderArray& aRequestHeaders,
@@ -407,6 +423,7 @@
                              aArgs);
       }));
 }
+
 static void ResourceTimingStructArgsToTimingsStruct(
     const ResourceTimingStructArgs& aArgs, TimingStruct& aTimings) {
   aTimings.domainLookupStart = aArgs.domainLookupStart();
@@ -522,6 +539,20 @@
                                       false);
   }
 
+  if (aArgs.shouldWaitForOnStartRequestSent() &&
+      !mRecvOnStartRequestSentCalled) {
+    LOG(("  > pending DoOnStartRequest until RecvOnStartRequestSent\n"));
+    MOZ_ASSERT(NS_IsMainThread());
+
+    mEventQ->Suspend();
+    mSuspendedByWaitingForPermissionAndCookie = true;
+    mEventQ->PrependEvent(MakeUnique<NeckoTargetChannelFunctionEvent>(
+        this, [self = UnsafePtr<HttpChannelChild>(this)]() {
+          self->DoOnStartRequest(self, nullptr);
+        }));
+    return;
+  }
+
   DoOnStartRequest(this, nullptr);
 }
 