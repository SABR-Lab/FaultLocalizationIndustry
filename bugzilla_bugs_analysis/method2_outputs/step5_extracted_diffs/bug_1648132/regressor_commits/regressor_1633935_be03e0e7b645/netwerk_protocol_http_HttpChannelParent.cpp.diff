# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpChannelParent.cpp
# Commit: be03e0e7b645
# Full Hash: be03e0e7b64568618b834834602b5ba303b32214
# Author: Junior Hsu <juhsu@mozilla.com>
# Date: 2020-06-24 09:31:07
# Regressor Bug: 1633935
# File Overlap Count: 1
# Description:
#   Bug 1633935 - P3 send OS*R and ODA via pHttpChannel for multipart channel, r=mayhemer,necko-reviewers
#   
#   Depends on D76969
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D76970
# ==============================================================================

diff -r df5abc2c0734 -r be03e0e7b645 netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp	Tue Jun 23 16:56:32 2020 +0000
+++ b/netwerk/protocol/http/HttpChannelParent.cpp	Tue Jun 23 16:56:45 2020 +0000
@@ -83,8 +83,7 @@
       mCacheNeedFlowControlInitialized(false),
       mNeedFlowControl(true),
       mSuspendedForFlowControl(false),
-      mAfterOnStartRequestBegun(false),
-      mIsMultiPart(false) {
+      mAfterOnStartRequestBegun(false) {
   LOG(("Creating HttpChannelParent [this=%p]\n", this));
 
   // Ensure gHttpHandler is initialized: we need the atom table up and running.
@@ -1371,13 +1370,14 @@
 
   Maybe<uint32_t> multiPartID;
   bool isLastPartOfMultiPart = false;
+  DebugOnly<bool> isMultiPart = false;
 
   RefPtr<HttpBaseChannel> chan = do_QueryObject(aRequest);
   if (!chan) {
     nsCOMPtr<nsIMultiPartChannel> multiPartChannel =
         do_QueryInterface(aRequest);
     if (multiPartChannel) {
-      mIsMultiPart = true;
+      isMultiPart = true;
       nsCOMPtr<nsIChannel> baseChannel;
       multiPartChannel->GetBaseChannel(getter_AddRefs(baseChannel));
       chan = do_QueryObject(baseChannel);
@@ -1388,7 +1388,7 @@
       multiPartChannel->GetIsLastPart(&isLastPartOfMultiPart);
     }
   }
-  MOZ_ASSERT(multiPartID || !mIsMultiPart, "Changed multi-part state?");
+  MOZ_ASSERT(multiPartID || !isMultiPart, "Changed multi-part state?");
 
   if (!chan) {
     LOG(("  aRequest is not HttpBaseChannel"));
@@ -1531,27 +1531,15 @@
   }
 
   rv = NS_OK;
-  bool ipcResult = false;
-  if (!mIPCClosed) {
-    // TODO: For multipart channel, we would deliever everything across
-    // pBackground as well.
-    if (!mIsMultiPart) {
-      ipcResult = mBgParent->OnStartRequest(
+  if (mIPCClosed ||
+      !mBgParent->OnStartRequest(
           *responseHead, useResponseHead,
           cleanedUpRequest ? cleanedUpRequestHeaders : requestHead->Headers(),
-          args);
-    } else {
-      ipcResult = SendOnStartRequest(
-          *responseHead, useResponseHead,
-          cleanedUpRequest ? cleanedUpRequestHeaders : requestHead->Headers(),
-          args);
-    }
+          args)) {
+    rv = NS_ERROR_UNEXPECTED;
   }
   requestHead->Exit();
 
-  if (mIPCClosed || !ipcResult) {
-    rv = NS_ERROR_UNEXPECTED;
-  }
   return rv;
 }
 
@@ -1585,20 +1573,11 @@
 
   // If we're handling a multi-part stream, then send this directly
   // over PHttpChannel to make synchronization easier.
-  if (!mIPCClosed && mIsMultiPart) {
-    // See the child code for why we do this.
-    TimeStamp lastActTabOpt = nsHttp::GetLastActiveTabLoadOptimizationHit();
-    if (!SendOnStopRequest(
-            aStatusCode, GetTimingAttributes(mChannel), lastActTabOpt,
-            responseTrailer ? *responseTrailer : nsHttpHeaderArray(),
-            consoleReports)) {
-      return NS_ERROR_UNEXPECTED;
-    }
-  } else if (mIPCClosed || !mBgParent ||
-             !mBgParent->OnStopRequest(
-                 aStatusCode, GetTimingAttributes(mChannel),
-                 responseTrailer ? *responseTrailer : nsHttpHeaderArray(),
-                 consoleReports)) {
+  if (mIPCClosed || !mBgParent ||
+      !mBgParent->OnStopRequest(
+          aStatusCode, GetTimingAttributes(mChannel),
+          responseTrailer ? *responseTrailer : nsHttpHeaderArray(),
+          consoleReports)) {
     return NS_ERROR_UNEXPECTED;
   }
 
@@ -1706,16 +1685,9 @@
     // is ready to send OnTransportAndData.
     MOZ_ASSERT(mIPCClosed || mBgParent);
 
-    // If we're handling a multi-part stream, then send this directly
-    // over PHttpChannel to make synchronization easier.
-    if (!mIPCClosed && mIsMultiPart) {
-      if (!SendOnTransportAndData(channelStatus, transportStatus, aOffset,
-                                  toRead, data)) {
-        return NS_ERROR_UNEXPECTED;
-      }
-    } else if (mIPCClosed || !mBgParent ||
-               !mBgParent->OnTransportAndData(channelStatus, transportStatus,
-                                              aOffset, toRead, data)) {
+    if (mIPCClosed || !mBgParent ||
+        !mBgParent->OnTransportAndData(channelStatus, transportStatus, aOffset,
+                                       toRead, data)) {
       return NS_ERROR_UNEXPECTED;
     }
 