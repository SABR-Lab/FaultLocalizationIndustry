# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webspeech/recognition/SpeechRecognition.cpp
# Commit: 48eaa84c206d
# Full Hash: 48eaa84c206dbdda637c57b55ddbd07e975ba103
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-06-23 16:15:06
# Regressor Bug: 1637500
# File Overlap Count: 2
# Description:
#   Bug 1637500 - P2. Rename methods as they are not always dealing with "threads". r=froydnj
#   
#   Before P1, GetCurrentThreadSerialEventTarget would have always returned the same data as NS_GetCurrentThread, making the comment incorrect Now it will properly return the running TaskQueue if any.
#   
#   This change of name more clearly exposes what they are doing, as we aren't always dealing with threads directly; but a nsISerialEventTarget
# ==============================================================================

diff -r 00687d06a8a6 -r 48eaa84c206d dom/media/webspeech/recognition/SpeechRecognition.cpp
--- a/dom/media/webspeech/recognition/SpeechRecognition.cpp	Tue Jun 23 05:02:39 2020 +0000
+++ b/dom/media/webspeech/recognition/SpeechRecognition.cpp	Tue Jun 23 05:05:36 2020 +0000
@@ -511,7 +511,7 @@
   // This will run SoundEnd on the service just before StopRecording begins
   // shutting the encode thread down.
   mSpeechListener->mRemovedPromise->Then(
-      GetCurrentThreadSerialEventTarget(), __func__,
+      GetCurrentSerialEventTarget(), __func__,
       [service = mRecognitionService] { service->SoundEnd(); });
 
   StopRecording();
@@ -580,7 +580,7 @@
       // This will run Abort on the service just before StopRecording begins
       // shutting the encode thread down.
       mSpeechListener->mRemovedPromise->Then(
-          GetCurrentThreadSerialEventTarget(), __func__,
+          GetCurrentSerialEventTarget(), __func__,
           [service = mRecognitionService] { service->Abort(); });
     } else {
       // Recording hasn't started yet. We can just call Abort().
@@ -589,7 +589,7 @@
   }
 
   StopRecording()->Then(
-      GetCurrentThreadSerialEventTarget(), __func__,
+      GetCurrentSerialEventTarget(), __func__,
       [self = RefPtr<SpeechRecognition>(this), this] { ResetAndEnd(); });
 
   SetState(STATE_ABORTING);
@@ -661,7 +661,7 @@
   mStopRecordingPromise =
       mSpeechListener->mRemovedPromise
           ->Then(
-              GetCurrentThreadSerialEventTarget(), __func__,
+              GetCurrentSerialEventTarget(), __func__,
               [self = RefPtr<SpeechRecognition>(this), this] {
                 SR_LOG("Shutting down encoding thread");
                 return mEncodeTaskQueue->BeginShutdown();
@@ -671,7 +671,7 @@
                 return ShutdownPromise::CreateAndResolve(false, __func__);
               })
           ->Then(
-              GetCurrentThreadSerialEventTarget(), __func__,
+              GetCurrentSerialEventTarget(), __func__,
               [self = RefPtr<SpeechRecognition>(this), this] {
                 RefPtr<nsIAsyncShutdownClient> shutdown =
                     media::GetShutdownBarrier();
@@ -817,7 +817,7 @@
     MediaManager::Get()
         ->GetUserMedia(GetOwner(), constraints, aCallerType)
         ->Then(
-            GetCurrentThreadSerialEventTarget(), __func__,
+            GetCurrentSerialEventTarget(), __func__,
             [this, self,
              generation = mStreamGeneration](RefPtr<DOMMediaStream>&& aStream) {
               nsTArray<RefPtr<AudioStreamTrack>> tracks;