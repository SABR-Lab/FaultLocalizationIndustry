# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/Dashboard.cpp
# Commit: 48eaa84c206d
# Full Hash: 48eaa84c206dbdda637c57b55ddbd07e975ba103
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-06-23 16:15:06
# Regressor Bug: 1637500
# File Overlap Count: 2
# Description:
#   Bug 1637500 - P2. Rename methods as they are not always dealing with "threads". r=froydnj
#   
#   Before P1, GetCurrentThreadSerialEventTarget would have always returned the same data as NS_GetCurrentThread, making the comment incorrect Now it will properly return the running TaskQueue if any.
#   
#   This change of name more clearly exposes what they are doing, as we aren't always dealing with threads directly; but a nsISerialEventTarget
# ==============================================================================

diff -r 00687d06a8a6 -r 48eaa84c206d netwerk/base/Dashboard.cpp
--- a/netwerk/base/Dashboard.cpp	Tue Jun 23 05:02:39 2020 +0000
+++ b/netwerk/base/Dashboard.cpp	Tue Jun 23 05:05:36 2020 +0000
@@ -315,7 +315,7 @@
   RefPtr<SocketData> socketData = new SocketData();
   socketData->mCallback = new nsMainThreadPtrHolder<nsINetDashboardCallback>(
       "nsINetDashboardCallback", aCallback, true);
-  socketData->mEventTarget = GetCurrentThreadEventTarget();
+  socketData->mEventTarget = GetCurrentEventTarget();
   gSocketTransportService->Dispatch(
       NewRunnableMethod<RefPtr<SocketData>>(
           "net::Dashboard::GetSocketsDispatch", this,
@@ -381,7 +381,7 @@
   RefPtr<HttpData> httpData = new HttpData();
   httpData->mCallback = new nsMainThreadPtrHolder<nsINetDashboardCallback>(
       "nsINetDashboardCallback", aCallback, true);
-  httpData->mEventTarget = GetCurrentThreadEventTarget();
+  httpData->mEventTarget = GetCurrentEventTarget();
 
   gSocketTransportService->Dispatch(NewRunnableMethod<RefPtr<HttpData>>(
                                         "net::Dashboard::GetHttpDispatch", this,
@@ -546,7 +546,7 @@
   RefPtr<WebSocketRequest> wsRequest = new WebSocketRequest();
   wsRequest->mCallback = new nsMainThreadPtrHolder<nsINetDashboardCallback>(
       "nsINetDashboardCallback", aCallback, true);
-  wsRequest->mEventTarget = GetCurrentThreadEventTarget();
+  wsRequest->mEventTarget = GetCurrentEventTarget();
 
   wsRequest->mEventTarget->Dispatch(
       NewRunnableMethod<RefPtr<WebSocketRequest>>(
@@ -599,7 +599,7 @@
 
   nsresult rv;
   dnsData->mData.Clear();
-  dnsData->mEventTarget = GetCurrentThreadEventTarget();
+  dnsData->mEventTarget = GetCurrentEventTarget();
 
   if (!mDnsService) {
     mDnsService = do_GetService("@mozilla.org/network/dns-service;1", &rv);
@@ -699,7 +699,7 @@
   RefPtr<LookupHelper> helper = new LookupHelper();
   helper->mCallback = new nsMainThreadPtrHolder<nsINetDashboardCallback>(
       "nsINetDashboardCallback", aCallback, true);
-  helper->mEventTarget = GetCurrentThreadEventTarget();
+  helper->mEventTarget = GetCurrentEventTarget();
   OriginAttributes attrs;
   rv = mDnsService->AsyncResolveNative(aHost, 0, helper.get(),
                                        NS_GetCurrentThread(), attrs,
@@ -710,7 +710,7 @@
 NS_IMETHODIMP
 Dashboard::RequestRcwnStats(nsINetDashboardCallback* aCallback) {
   RefPtr<RcwnData> rcwnData = new RcwnData();
-  rcwnData->mEventTarget = GetCurrentThreadEventTarget();
+  rcwnData->mEventTarget = GetCurrentEventTarget();
   rcwnData->mCallback = new nsMainThreadPtrHolder<nsINetDashboardCallback>(
       "nsINetDashboardCallback", aCallback, true);
 
@@ -806,7 +806,7 @@
   connectionData->mCallback =
       new nsMainThreadPtrHolder<nsINetDashboardCallback>(
           "nsINetDashboardCallback", aCallback, true);
-  connectionData->mEventTarget = GetCurrentThreadEventTarget();
+  connectionData->mEventTarget = GetCurrentEventTarget();
 
   rv = TestNewConnection(connectionData);
   if (NS_FAILED(rv)) {
@@ -861,7 +861,7 @@
   }
 
   rv = connectionData->mSocket->SetEventSink(connectionData,
-                                             GetCurrentThreadEventTarget());
+                                             GetCurrentEventTarget());
   if (NS_FAILED(rv)) {
     return rv;
   }