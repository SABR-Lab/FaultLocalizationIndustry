# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/Loader.cpp
# Commit: c7ef05dae614
# Full Hash: c7ef05dae61432443aafb8e78b31fa1ad314d70e
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-06-12 03:05:25
# Regressor Bug: 1599160
# File Overlap Count: 3
# Description:
#   Bug 1599160 - Better integration of the shared stylesheet cache with the network cache. r=tnikkel,mayhemer,heycam
#   
#   Make the stylesheet cache respect the same headers as the image cache
#   does. This makes no-cache stylesheets work as they do now, which is
#   useful for developers that want to develop sites locally, and for
# ==============================================================================

diff -r 466cfd0ad5db -r c7ef05dae614 layout/style/Loader.cpp
--- a/layout/style/Loader.cpp	Thu Jun 11 11:41:59 2020 +0000
+++ b/layout/style/Loader.cpp	Thu Jun 11 11:42:01 2020 +0000
@@ -22,6 +22,7 @@
 #include "mozilla/URLPreloader.h"
 #include "nsIRunnable.h"
 #include "nsITimedChannel.h"
+#include "nsICachingChannel.h"
 #include "nsSyncLoadService.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
@@ -900,7 +901,7 @@
         GetFallbackEncoding(*this, aLinkingContent,
                             aPreloadOrParentDataEncoding),
         aCORSMode, aParsingMode, mCompatMode, sriMetadata, aIsPreload);
-    auto cacheResult = mSheets->Lookup(key, aSyncLoad);
+    auto cacheResult = mSheets->Lookup(*this, key, aSyncLoad);
     if (const auto& [styleSheet, sheetState] = cacheResult; styleSheet) {
       LOG(("  Hit cache with state: %s", gStateStrings[size_t(sheetState)]));
       return cacheResult;
@@ -1410,6 +1411,9 @@
                                      SheetLoadData& aLoadData,
                                      AllowAsyncParse aAllowAsync) {
   LOG(("css::Loader::ParseSheet"));
+  if (aLoadData.mURI) {
+    LOG_URI("  Load succeeded for URI: '%s', parsing", aLoadData.mURI);
+  }
   AUTO_PROFILER_LABEL("css::Loader::ParseSheet", LAYOUT_CSSParsing);
 
   ++mParsedSheetCount;
@@ -2143,6 +2147,22 @@
   return nsContentUtils::GetSystemPrincipal();
 }
 
+bool Loader::ShouldBypassCache() const {
+  if (!mDocument) {
+    return false;
+  }
+  RefPtr<nsILoadGroup> lg = mDocument->GetDocumentLoadGroup();
+  if (!lg) {
+    return false;
+  }
+  nsLoadFlags flags;
+  if (NS_FAILED(lg->GetLoadFlags(&flags))) {
+    return false;
+  }
+  return flags & (nsIRequest::LOAD_BYPASS_CACHE |
+                  nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE);
+}
+
 void Loader::BlockOnload() {
   if (mDocument) {
     mDocument->BlockOnload();