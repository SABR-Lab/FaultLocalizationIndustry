# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/SharedStyleSheetCache.cpp
# Commit: c7ef05dae614
# Full Hash: c7ef05dae61432443aafb8e78b31fa1ad314d70e
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-06-12 03:05:25
# Regressor Bug: 1599160
# File Overlap Count: 3
# Description:
#   Bug 1599160 - Better integration of the shared stylesheet cache with the network cache. r=tnikkel,mayhemer,heycam
#   
#   Make the stylesheet cache respect the same headers as the image cache
#   does. This makes no-cache stylesheets work as they do now, which is
#   useful for developers that want to develop sites locally, and for
# ==============================================================================

diff -r 466cfd0ad5db -r c7ef05dae614 layout/style/SharedStyleSheetCache.cpp
--- a/layout/style/SharedStyleSheetCache.cpp	Thu Jun 11 11:41:59 2020 +0000
+++ b/layout/style/SharedStyleSheetCache.cpp	Thu Jun 11 11:42:01 2020 +0000
@@ -79,9 +79,16 @@
              "CSSOM shouldn't allow access to incomplete sheets");
 }
 
-auto SharedStyleSheetCache::Lookup(SheetLoadDataHashKey& aKey, bool aSyncLoad)
-    -> CacheResult {
+bool SharedStyleSheetCache::CompleteSheet::Expired() const {
+  return mExpirationTime &&
+         mExpirationTime <= nsContentUtils::SecondsFromPRTime(PR_Now());
+}
+
+SharedStyleSheetCache::CacheResult SharedStyleSheetCache::Lookup(
+    css::Loader& aLoader, const SheetLoadDataHashKey& aKey, bool aSyncLoad) {
   nsIURI* uri = aKey.URI();
+  LOG(("SharedStyleSheetCache::Lookup(%s)", uri->GetSpecOrDefault().get()));
+
   // Try to find first in the XUL prototype cache.
   if (dom::IsChromeURI(uri)) {
     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
@@ -100,28 +107,35 @@
           return {CloneSheet(*sheet), SheetState::Complete};
         }
 
-        LOG(
-            ("    Not cloning due to forced unique inner or mismatched "
-             "parsing mode"));
+        LOG(("    Not cloning due to mismatched parsing mode"));
       }
     }
   }
 
   // Now complete sheets.
   if (auto lookup = mCompleteSheets.Lookup(aKey)) {
-    LOG(("  From completed: %p", lookup.Data().get()));
-    AssertComplete(*lookup.Data());
-    MOZ_ASSERT(lookup.Data()->ParsingMode() == aKey.ParsingMode());
+    const CompleteSheet& completeSheet = lookup.Data();
     // We can assert the stylesheet has not been modified, as we clone it on
     // insertion.
-    StyleSheet* cachedSheet = lookup.Data();
-    MOZ_ASSERT(!cachedSheet->HasForcedUniqueInner());
-    MOZ_ASSERT(!cachedSheet->HasModifiedRules());
+    StyleSheet& cachedSheet = *completeSheet.mSheet;
+    LOG(("  From completed: %p", &cachedSheet));
+
+    if ((!aLoader.ShouldBypassCache() && !completeSheet.Expired()) ||
+        aLoader.mLoadsPerformed.Contains(aKey)) {
+      LOG(
+          ("    Not expired yet, or previously loaded already in "
+           "that document"));
 
-    RefPtr<StyleSheet> clone = CloneSheet(*cachedSheet);
-    MOZ_ASSERT(!clone->HasForcedUniqueInner());
-    MOZ_ASSERT(!clone->HasModifiedRules());
-    return {std::move(clone), SheetState::Complete};
+      AssertComplete(cachedSheet);
+      MOZ_ASSERT(cachedSheet.ParsingMode() == aKey.ParsingMode());
+      MOZ_ASSERT(!cachedSheet.HasForcedUniqueInner());
+      MOZ_ASSERT(!cachedSheet.HasModifiedRules());
+
+      RefPtr<StyleSheet> clone = CloneSheet(cachedSheet);
+      MOZ_ASSERT(!clone->HasForcedUniqueInner());
+      MOZ_ASSERT(!clone->HasModifiedRules());
+      return {std::move(clone), SheetState::Complete};
+    }
   }
 
   if (aSyncLoad) {
@@ -189,7 +203,7 @@
 
   n += mCompleteSheets.ShallowSizeOfExcludingThis(aMallocSizeOf);
   for (auto iter = mCompleteSheets.ConstIter(); !iter.Done(); iter.Next()) {
-    n += iter.UserData()->SizeOfIncludingThis(aMallocSizeOf);
+    n += iter.UserData().mSheet->SizeOfIncludingThis(aMallocSizeOf);
   }
 
   // Measurement of the following members may be added later if DMD finds it is
@@ -312,19 +326,30 @@
     SheetLoadData& aData) {
   MOZ_ASSERT(aData.mLoader->GetDocument(),
              "We only cache document-associated sheets");
+  LOG(("SharedStyleSheetCache::InsertIntoCompleteCacheIfNeeded"));
   // If we ever start doing this for failed loads, we'll need to adjust the
   // PostLoadEvent code that thinks anything already complete must have loaded
   // succesfully.
   if (aData.mLoadFailed) {
+    LOG(("  Load failed, bailing"));
+    return;
+  }
+
+  // If this sheet came from the cache already, there's no need to override
+  // anything.
+  if (aData.mSheetAlreadyComplete) {
+    LOG(("  Sheet came from the cache, bailing"));
     return;
   }
 
   if (!aData.mURI) {
+    LOG(("  Inline style sheet, bailing"));
     // Inline sheet caching happens in Loader::mInlineSheets.
     return;
   }
 
   if (aData.mSheet->IsConstructed()) {
+    LOG(("  Constructable style sheet, bailing"));
     // Constructable sheets are not worth caching, they're always unique.
     return;
   }
@@ -352,18 +377,25 @@
       }
     }
   } else {
+    LOG(("  Putting style sheet in shared cache: %s",
+         aData.mURI->GetSpecOrDefault().get()));
     SheetLoadDataHashKey key(aData);
     MOZ_ASSERT(sheet->IsComplete(), "Should only be caching complete sheets");
 
 #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
     for (const auto& entry : mCompleteSheets) {
-      MOZ_DIAGNOSTIC_ASSERT(
-          entry.GetData() != sheet || key.KeyEquals(entry.GetKey()),
-          "Same sheet, different keys?");
+      if (!key.KeyEquals(entry.GetKey())) {
+        MOZ_DIAGNOSTIC_ASSERT(entry.GetData().mSheet != sheet,
+                              "Same sheet, different keys?");
+      } else {
+        MOZ_DIAGNOSTIC_ASSERT(
+            entry.GetData().Expired() || aData.mLoader->ShouldBypassCache(),
+            "Overriding existing complete entry?");
+      }
     }
 #endif
 
-    mCompleteSheets.Put(key, std::move(sheet));
+    mCompleteSheets.Put(key, {aData.mExpirationTime, std::move(sheet)});
   }
 }
 