# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: xpcom/build/Omnijar.cpp
# Commit: 70fe46e4a0b3
# Full Hash: 70fe46e4a0b378ebc8880344a39c6ee8ed99cbda
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-14 21:47:02
# Description:
#   Bug 1652140 - Check for null data from zip before trying to cache it r=froydnj
#   
#   We're crashing occasionally here due to an assertion in Span.h. We would
#   also likely have problems down the road if we tried to cache nullptrs in
#   the startup cache. I think this is all we need to handle this as gracefully
# ==============================================================================

diff -r a23787eb4292 -r 70fe46e4a0b3 xpcom/build/Omnijar.cpp
--- a/xpcom/build/Omnijar.cpp	Tue Jul 14 15:53:31 2020 +0000
+++ b/xpcom/build/Omnijar.cpp	Tue Jul 14 15:36:09 2020 +0000
@@ -265,6 +265,9 @@
   }
 
   const uint8_t* zipItemData = mZip->GetData(aItem);
+  if (!zipItemData) {
+    return nullptr;
+  }
 
   // If the data is compressed, it is somewhat silly to store it in the startup
   // cache, as the startup cache will try to double compress it.
@@ -293,6 +296,10 @@
     return nullptr;
   }
   const uint8_t* zipItemData = mZip->GetData(zipItem);
+  if (!zipItemData) {
+    return nullptr;
+  }
+
   *aResultSize = zipItem->Size();
 
   // If the data is compressed, it is somewhat silly to store it in the startup
@@ -346,6 +353,10 @@
     buf = cursor.Read(aBytesRead);
   }
 
+  if (!buf) {
+    return nullptr;
+  }
+
   if (!cacheKey.IsEmpty() && *aBytesRead == mItem->RealSize()) {
     CacheAwareZipReader::PutBufferIntoCache(cacheKey, buf, *aBytesRead);
   }
@@ -385,7 +396,10 @@
   if (!aHandle->mDeferredCachingKey.IsEmpty() &&
       aItem->Compression() == STORED) {
     MOZ_ASSERT(aItem->RealSize() == aItem->Size());
-    aHandle->mDataToCache = MakeSpan(mZip->GetData(aItem), aItem->Size());
+    const uint8_t* data = mZip->GetData(aItem);
+    if (data) {
+      aHandle->mDataToCache = MakeSpan(data, aItem->Size());
+    }
   }
 
   return NS_OK;
