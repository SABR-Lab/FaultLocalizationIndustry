# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/build/Omnijar.cpp
# Commit: 2cb021a493d8
# Full Hash: 2cb021a493d83f8d4fea988cad492dd879bf5cf4
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-07 21:31:11
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1627075 - Allow lazily initializing nsZipArchives r=froydnj
#   
#   Opening our Omnijars can be expensive, and it should be deferrable until after
#   startup is completed, provided we have a startup cache. In a previous patch in this
#   stack, we implemented caching of the zip central directory for omnijars, but we
# ==============================================================================

diff -r 920398d1c3d3 -r 2cb021a493d8 xpcom/build/Omnijar.cpp
--- a/xpcom/build/Omnijar.cpp	Tue Jul 07 04:34:07 2020 +0000
+++ b/xpcom/build/Omnijar.cpp	Tue Jul 07 04:34:19 2020 +0000
@@ -93,20 +93,30 @@
       centralBufLength = 0;
     }
   }
-  if (NS_FAILED(zipReader->OpenArchive(file, centralBuf, centralBufLength))) {
+  if (NS_FAILED(zipReader->OpenArchive(
+          file, MakeSpan(centralBuf, centralBufLength)))) {
     return;
   }
 
-  if (cache && !centralBuf) {
-    size_t bufSize;
-
-    // Annoyingly, nsZipArchive and the startupcache use different types to
-    // represent bytes (uint8_t vs char), so we have to do a little dance to
-    // convert the UniquePtr over.
-    UniquePtr<char[]> centralBuf(reinterpret_cast<char*>(
-        zipReader->CopyCentralDirectoryBuffer(&bufSize).release()));
-    if (centralBuf) {
-      cache->PutBuffer(startupCacheKey.get(), std::move(centralBuf), bufSize);
+  if (!centralBuf) {
+    if (NS_FAILED(zipReader->OpenArchive(file))) {
+      return;
+    }
+    if (cache) {
+      size_t bufSize;
+      // Annoyingly, nsZipArchive and the startupcache use different types to
+      // represent bytes (uint8_t vs char), so we have to do a little dance to
+      // convert the UniquePtr over.
+      UniquePtr<char[]> centralBuf(reinterpret_cast<char*>(
+          zipReader->CopyCentralDirectoryBuffer(&bufSize).release()));
+      if (centralBuf) {
+        cache->PutBuffer(startupCacheKey.get(), std::move(centralBuf), bufSize);
+      }
+    }
+  } else {
+    if (NS_FAILED(zipReader->LazyOpenArchive(
+            file, MakeSpan(centralBuf, centralBufLength)))) {
+      return;
     }
   }
 
