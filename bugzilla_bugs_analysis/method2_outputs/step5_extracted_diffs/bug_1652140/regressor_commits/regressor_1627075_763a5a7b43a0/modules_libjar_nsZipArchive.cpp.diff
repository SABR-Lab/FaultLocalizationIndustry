# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsZipArchive.cpp
# Commit: 763a5a7b43a0
# Full Hash: 763a5a7b43a0125ecba3f22a5ef8928aa7eecfe4
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-02 03:58:28
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1627075 - Build Omnijar file list from startup cache r=froydnj
#   
#   We would like to be able to defer opening the omnijar files until after startup
#   if the StartupCache has already been populated. Opening the omnijar files takes
#   a nontrivial time, at least on Windows, and almost everything in the omnijar
# ==============================================================================

diff -r 16ab6f47724d -r 763a5a7b43a0 modules/libjar/nsZipArchive.cpp
--- a/modules/libjar/nsZipArchive.cpp	Wed Jul 01 18:00:35 2020 +0000
+++ b/modules/libjar/nsZipArchive.cpp	Wed Jul 01 17:07:17 2020 +0000
@@ -341,11 +341,19 @@
 //---------------------------------------------
 //  nsZipArchive::OpenArchive
 //---------------------------------------------
-nsresult nsZipArchive::OpenArchive(nsZipHandle* aZipHandle, PRFileDesc* aFd) {
+nsresult nsZipArchive::OpenArchive(nsZipHandle* aZipHandle, PRFileDesc* aFd,
+                                   const uint8_t* aCachedCentral,
+                                   size_t aCachedCentralSize) {
   mFd = aZipHandle;
 
   //-- get table of contents for archive
-  nsresult rv = BuildFileList(aFd);
+  nsresult rv;
+  if (aCachedCentral) {
+    rv = BuildFileListFromBuffer(aCachedCentral,
+                                 aCachedCentral + aCachedCentralSize);
+  } else {
+    rv = BuildFileList(aFd);
+  }
   if (NS_SUCCEEDED(rv)) {
     if (aZipHandle->mFile && XRE_IsParentProcess()) {
       static char* env = PR_GetEnv("MOZ_JAR_LOG_FILE");
@@ -399,7 +407,9 @@
   return rv;
 }
 
-nsresult nsZipArchive::OpenArchive(nsIFile* aFile) {
+nsresult nsZipArchive::OpenArchive(nsIFile* aFile,
+                                   const uint8_t* aCachedCentral,
+                                   size_t aCachedCentralSize) {
   RefPtr<nsZipHandle> handle;
 #if defined(XP_WIN)
   mozilla::AutoFDClose fd;
@@ -410,9 +420,9 @@
   if (NS_FAILED(rv)) return rv;
 
 #if defined(XP_WIN)
-  return OpenArchive(handle, fd.get());
+  return OpenArchive(handle, fd.get(), aCachedCentral, aCachedCentralSize);
 #else
-  return OpenArchive(handle);
+  return OpenArchive(handle, nullptr, aCachedCentral, aCachedCentralSize);
 #endif
 }
 
@@ -653,6 +663,8 @@
   const uint8_t* buf;
   const uint8_t* startp = mFd->mFileData;
   const uint8_t* endp = startp + mFd->mLen;
+
+  nsresult rv;
   MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
   uint32_t centralOffset = 4;
   // Only perform readahead in the parent process. Children processes
@@ -677,20 +689,62 @@
     return NS_ERROR_FILE_CORRUPTED;
   }
 
-  buf = startp + centralOffset;
-
-  // avoid overflow of startp + centralOffset.
-  if (buf < startp) {
+  uintptr_t startpInt = (uintptr_t)startp;
+  if (startpInt + centralOffset < startpInt || centralOffset > mFd->mLen) {
     return NS_ERROR_FILE_CORRUPTED;
   }
 
+  buf = startp + centralOffset;
+
+  mZipCentralOffset = centralOffset;
+  rv = BuildFileListFromBuffer(buf, endp);
+
+  MMAP_FAULT_HANDLER_CATCH(NS_ERROR_FAILURE)
+  return rv;
+}
+
+UniquePtr<uint8_t[]> nsZipArchive::CopyCentralDirectoryBuffer(size_t* aSize) {
+  *aSize = 0;
+
+  // mZipCentralOffset could in theory be 0. In practice though, we likely
+  // won't ever see this. If the end result is that we can't cache the buffer
+  // in these cases, that's fine.
+  if (!mZipCentralOffset || !mZipCentralSize) {
+    return nullptr;
+  }
+
+  const uint8_t* buf;
+  const uint8_t* startp = mFd->mFileData;
+  buf = startp + mZipCentralOffset;
+
+  // Just a sanity check to make sure these values haven't overflowed the
+  // buffer mapped to our file. Technically the pointer could overflow the max
+  // pointer value, but that could only happen with this check succeeding if
+  // mFd->mLen is incorrect, which we will here assume is impossible.
+  if (mZipCentralOffset + mZipCentralSize > mFd->mLen) {
+    return nullptr;
+  }
+
+  auto resultBuf = MakeUnique<uint8_t[]>(mZipCentralSize);
+
+  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
+  memcpy(resultBuf.get(), buf, mZipCentralSize);
+  MMAP_FAULT_HANDLER_CATCH(nullptr)
+
+  *aSize = mZipCentralSize;
+  return resultBuf;
+}
+
+nsresult nsZipArchive::BuildFileListFromBuffer(const uint8_t* aBuf,
+                                               const uint8_t* aEnd) {
+  const uint8_t* buf = aBuf;
   //-- Read the central directory headers
   uint32_t sig = 0;
   while ((buf + int32_t(sizeof(uint32_t)) > buf) &&
-         (buf + int32_t(sizeof(uint32_t)) <= endp) &&
+         (buf + int32_t(sizeof(uint32_t)) <= aEnd) &&
          ((sig = xtolong(buf)) == CENTRALSIG)) {
     // Make sure there is enough data available.
-    if ((buf > endp) || (endp - buf < ZIPCENTRAL_SIZE)) {
+    if ((buf > aEnd) || (aEnd - buf < ZIPCENTRAL_SIZE)) {
       return NS_ERROR_FILE_CORRUPTED;
     }
 
@@ -708,7 +762,7 @@
       return NS_ERROR_FILE_CORRUPTED;
     }
     if (buf >= buf + diff ||  // No overflow
-        buf >= endp - diff) {
+        buf >= aEnd - diff) {
       return NS_ERROR_FILE_CORRUPTED;
     }
 
@@ -735,18 +789,18 @@
   }
 
   // Make the comment available for consumers.
-  if ((endp >= buf) && (endp - buf >= ZIPEND_SIZE)) {
+  if ((aEnd >= buf) && (aEnd - buf >= ZIPEND_SIZE)) {
     ZipEnd* zipend = (ZipEnd*)buf;
 
     buf += ZIPEND_SIZE;
     uint16_t commentlen = xtoint(zipend->commentfield_len);
-    if (endp - buf >= commentlen) {
-      mCommentPtr = (const char*)buf;
+    if (aEnd - buf >= commentlen) {
+      mCommentPtr = (const char*)aBuf;
       mCommentLen = commentlen;
     }
   }
 
-  MMAP_FAULT_HANDLER_CATCH(NS_ERROR_FAILURE)
+  mZipCentralSize = buf - aBuf;
   return NS_OK;
 }
 
@@ -889,6 +943,8 @@
 nsZipArchive::nsZipArchive()
     : mRefCnt(0),
       mCommentPtr(nullptr),
+      mZipCentralOffset(0),
+      mZipCentralSize(0),
       mCommentLen(0),
       mBuiltSynthetics(false),
       mUseZipLog(false) {