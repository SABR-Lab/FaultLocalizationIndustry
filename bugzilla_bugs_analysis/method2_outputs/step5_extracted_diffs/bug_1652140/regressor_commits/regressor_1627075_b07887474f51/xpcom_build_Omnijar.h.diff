# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/build/Omnijar.h
# Commit: b07887474f51
# Full Hash: b07887474f51c5d5e01cb0188c18c8618c77be57
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-02 03:58:28
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1627075 - Route Omnijar requests through StartupCache r=froydnj
#   
#   This should be a relatively straightforward patch. Essentially, we implement
#   a wrapper class (and friends) around nsZipArchive (and friends), which transparently
#   caches entries from the underlying zip archive in the StartupCache. This will break
# ==============================================================================

diff -r 65c0e6790a33 -r b07887474f51 xpcom/build/Omnijar.h
--- a/xpcom/build/Omnijar.h	Wed Jul 01 17:55:38 2020 +0000
+++ b/xpcom/build/Omnijar.h	Wed Jul 01 17:09:53 2020 +0000
@@ -13,10 +13,14 @@
 #include "nsIFile.h"
 #include "nsZipArchive.h"
 
+#include "mozilla/Span.h"
 #include "mozilla/StaticPtr.h"
+#include "mozilla/UniquePtr.h"
 
 namespace mozilla {
 
+class CacheAwareZipReader;
+
 class Omnijar {
  private:
   /**
@@ -28,15 +32,15 @@
   static StaticRefPtr<nsIFile> sPath[2];
 
   /**
-   * Cached nsZipArchives for the corresponding sPath
+   * Cached CacheAwareZipReaders for the corresponding sPath
    */
-  static StaticRefPtr<nsZipArchive> sReader[2];
+  static StaticRefPtr<CacheAwareZipReader> sReader[2];
 
   /**
-   * Cached nsZipArchives for the outer jar, when using nested jars.
+   * Cached CacheAwareZipReaders for the outer jar, when using nested jars.
    * Otherwise nullptr.
    */
-  static StaticRefPtr<nsZipArchive> sOuterReader[2];
+  static StaticRefPtr<CacheAwareZipReader> sOuterReader[2];
 
   /**
    * Has Omnijar::Init() been called?
@@ -61,13 +65,14 @@
   }
 
   /**
-   * Returns a nsZipArchive pointer for the outer jar file when using nested
-   * jars. Returns nullptr in the same cases GetPath() would, or if not using
-   * nested jars.
+   * Returns an CacheAwareZipReader pointer for the outer jar file when using
+   * nested jars. Returns nullptr in the same cases GetPath() would, or if not
+   * using nested jars.
    */
-  static inline already_AddRefed<nsZipArchive> GetOuterReader(Type aType) {
+  static inline already_AddRefed<CacheAwareZipReader> GetOuterReader(
+      Type aType) {
     MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
-    RefPtr<nsZipArchive> reader = sOuterReader[aType].get();
+    RefPtr<CacheAwareZipReader> reader = sOuterReader[aType].get();
     return reader.forget();
   }
 
@@ -113,20 +118,20 @@
   }
 
   /**
-   * Returns a nsZipArchive pointer for the omni.jar file for GRE or
+   * Returns an CacheAwareZipReader pointer for the omni.jar file for GRE or
    * APP. Returns nullptr in the same cases GetPath() would.
    */
-  static inline already_AddRefed<nsZipArchive> GetReader(Type aType) {
+  static inline already_AddRefed<CacheAwareZipReader> GetReader(Type aType) {
     MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
-    RefPtr<nsZipArchive> reader = sReader[aType].get();
+    RefPtr<CacheAwareZipReader> reader = sReader[aType].get();
     return reader.forget();
   }
 
   /**
-   * Returns a nsZipArchive pointer for the given path IAOI the given
+   * Returns an CacheAwareZipReader pointer for the given path IAOI the given
    * path is the omni.jar for either GRE or APP.
    */
-  static already_AddRefed<nsZipArchive> GetReader(nsIFile* aPath);
+  static already_AddRefed<CacheAwareZipReader> GetReader(nsIFile* aPath);
 
   /**
    * In the case of a nested omnijar, this returns the inner reader for the
@@ -136,7 +141,7 @@
    * GetReader("path/to.apk") returns the outer reader and GetInnerReader(
    * "path/to.apk", "assets/omni.ja") returns the inner reader.
    */
-  static already_AddRefed<nsZipArchive> GetInnerReader(
+  static already_AddRefed<CacheAwareZipReader> GetInnerReader(
       nsIFile* aPath, const nsACString& aEntry);
 
   /**
@@ -156,6 +161,132 @@
   static void CleanUpOne(Type aType);
 }; /* class Omnijar */
 
+class CacheAwareZipCursor {
+ public:
+  CacheAwareZipCursor(nsZipItem* aItem, CacheAwareZipReader* aReader,
+                      uint8_t* aBuf = nullptr, uint32_t aBufSize = 0,
+                      bool aDoCRC = false);
+
+  uint8_t* Read(uint32_t* aBytesRead) { return ReadOrCopy(aBytesRead, false); }
+  uint8_t* Copy(uint32_t* aBytesRead) { return ReadOrCopy(aBytesRead, true); }
+
+ private:
+  /* Actual implementation for both Read and Copy above */
+  uint8_t* ReadOrCopy(uint32_t* aBytesRead, bool aCopy);
+
+  nsZipItem* mItem;
+  CacheAwareZipReader* mReader;
+
+  uint8_t* mBuf;
+  uint32_t mBufSize;
+
+  bool mDoCRC;
+};
+
+// This class wraps an nsZipHandle, which may be null, if the data is
+// cached
+class CacheAwareZipHandle {
+  friend class CacheAwareZipReader;
+
+ public:
+  CacheAwareZipHandle() : mFd(nullptr), mDataIsCached(false) {}
+  ~CacheAwareZipHandle() { ReleaseHandle(); }
+
+  nsZipHandle* UnderlyingFD() { return mFd; }
+  void ReleaseHandle();
+
+  explicit operator bool() const { return mDataIsCached || mFd; }
+
+ private:
+  RefPtr<nsZipHandle> mFd;
+  nsCString mDeferredCachingKey;
+  Span<const uint8_t> mDataToCache;
+  bool mDataIsCached;
+};
+
+class CacheAwareZipReader {
+  friend class CacheAwareZipCursor;
+  friend class CacheAwareZipHandle;
+
+ public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(CacheAwareZipReader)
+
+  enum Caching {
+    Default,
+    DeferCaching,
+  };
+
+  // Constructor for CacheAwareZipReader. aCacheKeyPrefix will be a prefix
+  // which the wrapper will prepend to any requested entries prior to
+  // requesting the entry from the StartupCache. However, if aCacheKeyPrefix
+  // is null, we will simply pass through to the underlying zip archive
+  // without caching.
+  explicit CacheAwareZipReader(nsZipArchive* aZip, const char* aCacheKeyPrefix);
+
+  // The default constructor should be used for an nsZipArchive which doesn't
+  // want to cache any entries. Consumers will need to call `OpenArchive`
+  // explicitly after constructing.
+  CacheAwareZipReader() : mZip(new nsZipArchive()) {}
+
+  nsresult OpenArchive(nsIFile* aFile) { return mZip->OpenArchive(aFile); }
+  nsresult OpenArchive(nsZipHandle* aHandle) {
+    return mZip->OpenArchive(aHandle);
+  }
+
+  const uint8_t* GetData(const char* aEntryName, uint32_t* aResultSize,
+                         Caching aCaching = Default);
+  const uint8_t* GetData(nsZipItem* aItem, Caching aCaching = Default);
+
+  nsresult GetPersistentHandle(nsZipItem* aItem, CacheAwareZipHandle* aHandle,
+                               Caching aCaching);
+
+  already_AddRefed<nsIFile> GetBaseFile() { return mZip->GetBaseFile(); }
+
+  void GetURIString(nsACString& result) { mZip->GetURIString(result); }
+
+  nsZipArchive* GetZipArchive() { return mZip; }
+
+  nsresult FindInit(const char* aPattern, nsZipFind** aFind);
+  bool IsForZip(nsZipArchive* aArchive) { return aArchive == mZip; }
+  nsZipItem* GetItem(const char* aEntryName);
+
+  nsresult CloseArchive();
+
+  nsresult Test(const char* aEntryName) { return mZip->Test(aEntryName); }
+
+  nsresult ExtractFile(nsZipItem* zipEntry, nsIFile* outFile,
+                       PRFileDesc* outFD) {
+    return mZip->ExtractFile(zipEntry, outFile, outFD);
+  }
+
+  static void PushSuspendStartupCacheWrites();
+  static void PopSuspendStartupCacheWrites();
+
+ protected:
+  ~CacheAwareZipReader() = default;
+
+ private:
+  const uint8_t* GetCachedBuffer(const char* aEntryName,
+                                 uint32_t aEntryNameLength,
+                                 uint32_t* aResultSize, nsCString& aCacheKey);
+  static void PutBufferIntoCache(const nsCString& aCacheKey,
+                                 const uint8_t* aBuffer, uint32_t aSize);
+
+  RefPtr<nsZipArchive> mZip;
+  nsCString mCacheKeyPrefix;
+};
+
+class MOZ_RAII AutoSuspendStartupCacheWrites {
+ public:
+  AutoSuspendStartupCacheWrites() {
+    CacheAwareZipReader::PushSuspendStartupCacheWrites();
+  }
+
+  ~AutoSuspendStartupCacheWrites() {
+    CacheAwareZipReader::PopSuspendStartupCacheWrites();
+  }
+};
+
 } /* namespace mozilla */
 
 #endif /* mozilla_Omnijar_h */