# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsParent.cpp
# Commit: 223990c25952
# Full Hash: 223990c25952ba0f9e55351fe6618205c4efd712
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2020-07-13 21:48:13
# Description:
#   Bug 1652409 - Ensure that a corrupted file encountered during ReadCompressedNumber does not cause an assertion failure. r=dom-workers-and-storage-reviewers,janv
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D83300
# ==============================================================================

diff -r 1a69fcdf7bd9 -r 223990c25952 dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp	Mon Jul 13 19:22:21 2020 +0300
+++ b/dom/indexedDB/ActorsParent.cpp	Mon Jul 13 12:32:06 2020 +0000
@@ -637,8 +637,8 @@
              CompressedByteCountForNumber(originalNumber));
 }
 
-std::pair<uint64_t, mozilla::Span<const uint8_t>> ReadCompressedNumber(
-    const Span<const uint8_t> aSpan) {
+Result<std::pair<uint64_t, mozilla::Span<const uint8_t>>, nsresult>
+ReadCompressedNumber(const Span<const uint8_t> aSpan) {
   uint8_t shiftCounter = 0;
   uint64_t result = 0;
 
@@ -656,10 +656,11 @@
 
   if (NS_WARN_IF(newPos == end)) {
     MOZ_ASSERT(false);
-    // XXX Shouldn't we return an error in this case?
-  }
-
-  return {result, Span{newPos + 1, end}};
+    IDB_REPORT_INTERNAL_ERR();
+    return Err(NS_ERROR_FILE_CORRUPTED);
+  }
+
+  return std::pair{result, Span{newPos + 1, end}};
 }
 
 void WriteCompressedIndexId(IndexOrObjectStoreId aIndexId, bool aUnique,
@@ -674,8 +675,14 @@
   WriteCompressedNumber(indexId, aIterator);
 }
 
-auto ReadCompressedIndexId(const Span<const uint8_t> aData) {
-  const auto [indexId, remainder] = ReadCompressedNumber(aData);
+Result<std::tuple<IndexOrObjectStoreId, bool, Span<const uint8_t>>, nsresult>
+ReadCompressedIndexId(const Span<const uint8_t> aData) {
+  auto readNumberOrErr = ReadCompressedNumber(aData);
+  if (NS_WARN_IF(readNumberOrErr.isErr())) {
+    return readNumberOrErr.propagateErr();
+  }
+
+  const auto [indexId, remainder] = readNumberOrErr.unwrap();
 
   MOZ_ASSERT(UINT64_MAX / 2 >= uint64_t(indexId), "Bad index id!");
 
@@ -786,8 +793,13 @@
   }
 
   for (auto remainder = aBlobData; !remainder.IsEmpty();) {
+    auto readIndexIdOrErr = ReadCompressedIndexId(remainder);
+    if (NS_WARN_IF(readIndexIdOrErr.isErr())) {
+      return readIndexIdOrErr.unwrapErr();
+    }
+
     const auto [indexId, unique, remainderAfterIndexId] =
-        ReadCompressedIndexId(remainder);
+        readIndexIdOrErr.unwrap();
 
     if (NS_WARN_IF(remainderAfterIndexId.IsEmpty())) {
       IDB_REPORT_INTERNAL_ERR();
@@ -795,15 +807,17 @@
     }
 
     // Read key buffer length.
+    auto readNumberOrErr = ReadCompressedNumber(remainderAfterIndexId);
+    if (NS_WARN_IF(readNumberOrErr.isErr())) {
+      return readNumberOrErr.unwrapErr();
+    }
+
     const auto [keyBufferLength, remainderAfterKeyBufferLength] =
-        ReadCompressedNumber(remainderAfterIndexId);
+        readNumberOrErr.unwrap();
 
     if (NS_WARN_IF(remainderAfterKeyBufferLength.IsEmpty()) ||
         NS_WARN_IF(keyBufferLength > uint64_t(UINT32_MAX)) ||
-        NS_WARN_IF(keyBufferLength > remainderAfterKeyBufferLength.Length())
-        // XXX Does this sub-condition make any sense?
-        // || NS_WARN_IF(keyBufferLength > uintptr_t(blobDataEnd))
-    ) {
+        NS_WARN_IF(keyBufferLength > remainderAfterKeyBufferLength.Length())) {
       IDB_REPORT_INTERNAL_ERR();
       return NS_ERROR_FILE_CORRUPTED;
     }
@@ -814,17 +828,19 @@
         IndexDataValue{indexId, unique, Key{nsCString{AsChars(keyBuffer)}}};
 
     // Read sort key buffer length.
+    readNumberOrErr = ReadCompressedNumber(remainderAfterKeyBuffer);
+    if (NS_WARN_IF(readNumberOrErr.isErr())) {
+      return readNumberOrErr.unwrapErr();
+    }
+
     const auto [sortKeyBufferLength, remainderAfterSortKeyBufferLength] =
-        ReadCompressedNumber(remainderAfterKeyBuffer);
+        readNumberOrErr.unwrap();
 
     remainder = remainderAfterSortKeyBufferLength;
     if (sortKeyBufferLength > 0) {
       if (NS_WARN_IF(remainder.IsEmpty()) ||
           NS_WARN_IF(sortKeyBufferLength > uint64_t(UINT32_MAX)) ||
-          NS_WARN_IF(sortKeyBufferLength > remainder.Length())
-          // XXX Does this sub-condition make any sense?
-          // || NS_WARN_IF(sortKeyBufferLength > uintptr_t(blobDataEnd))
-      ) {
+          NS_WARN_IF(sortKeyBufferLength > remainder.Length())) {
         IDB_REPORT_INTERNAL_ERR();
         return NS_ERROR_FILE_CORRUPTED;
       }
@@ -3460,7 +3476,12 @@
   IndexDataValuesArray result;
   for (auto remainder = aBlobData; !remainder.IsEmpty();) {
     if (!nextIndexIdAlreadyRead) {
-      std::tie(indexId, unique, remainder) = ReadCompressedIndexId(remainder);
+      auto readNumberOrErr = ReadCompressedIndexId(remainder);
+      if (NS_WARN_IF(readNumberOrErr.isErr())) {
+        return readNumberOrErr.propagateErr();
+      }
+
+      std::tie(indexId, unique, remainder) = readNumberOrErr.unwrap();
     }
     nextIndexIdAlreadyRead = false;
 
@@ -3470,8 +3491,13 @@
     }
 
     // Read key buffer length.
+    auto readNumberOrErr = ReadCompressedNumber(remainder);
+    if (NS_WARN_IF(readNumberOrErr.isErr())) {
+      return readNumberOrErr.propagateErr();
+    }
+
     const auto [keyBufferLength, remainderAfterKeyBufferLength] =
-        ReadCompressedNumber(remainder);
+        readNumberOrErr.unwrap();
 
     if (NS_WARN_IF(remainderAfterKeyBufferLength.IsEmpty()) ||
         NS_WARN_IF(keyBufferLength > uint64_t(UINT32_MAX)) ||
@@ -3491,8 +3517,13 @@
     remainder = remainderAfterKeyBuffer;
     if (!remainder.IsEmpty()) {
       // Read either a sort key buffer length or an index id.
+      auto readNumberOrErr = ReadCompressedNumber(remainder);
+      if (NS_WARN_IF(readNumberOrErr.isErr())) {
+        return readNumberOrErr.propagateErr();
+      }
+
       const auto [maybeIndexId, remainderAfterIndexId] =
-          ReadCompressedNumber(remainder);
+          readNumberOrErr.unwrap();
 
       // Locale-aware indexes haven't been around long enough to have any users,
       // we can safely assume all sort key buffer lengths will be zero.
