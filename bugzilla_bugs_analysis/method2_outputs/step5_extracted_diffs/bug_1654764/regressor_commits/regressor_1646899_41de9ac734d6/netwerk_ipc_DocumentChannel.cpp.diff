# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentChannel.cpp
# Commit: 41de9ac734d6
# Full Hash: 41de9ac734d69d754ea3f13db6933343b62ea1b8
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-21 09:42:41
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r 64e118a38c1d -r 41de9ac734d6 netwerk/ipc/DocumentChannel.cpp
--- a/netwerk/ipc/DocumentChannel.cpp	Tue Jul 21 01:01:03 2020 +0000
+++ b/netwerk/ipc/DocumentChannel.cpp	Tue Jul 21 01:01:05 2020 +0000
@@ -97,16 +97,22 @@
   mIsPending = false;
 
   listener = mListener;  // it might have changed!
-  if (listener) {
-    listener->OnStopRequest(this, aStatusCode);
-  }
+  nsCOMPtr<nsILoadGroup> loadGroup = mLoadGroup;
+
   mListener = nullptr;
+  mLoadGroup = nullptr;
   mCallbacks = nullptr;
 
-  if (mLoadGroup) {
-    mLoadGroup->RemoveRequest(this, nullptr, aStatusCode);
-    mLoadGroup = nullptr;
-  }
+  NS_DispatchToMainThread(NS_NewRunnableFunction(
+      "DocumentChannel::ShutdownListeners", [=, self = RefPtr{this}] {
+        if (listener) {
+          listener->OnStopRequest(self, aStatusCode);
+        }
+
+        if (loadGroup) {
+          loadGroup->RemoveRequest(self, nullptr, aStatusCode);
+        }
+      }));
 
   DeleteIPDL();
 }
@@ -171,7 +177,7 @@
 }
 
 /* static */
-already_AddRefed<DocumentChannel> DocumentChannel::CreateDocumentChannel(
+already_AddRefed<DocumentChannel> DocumentChannel::CreateForDocument(
     nsDocShellLoadState* aLoadState, class LoadInfo* aLoadInfo,
     nsLoadFlags aLoadFlags, nsIInterfaceRequestor* aNotificationCallbacks,
     uint32_t aCacheKey, bool aUriModified, bool aIsXFOError) {
@@ -188,6 +194,14 @@
   return channel.forget();
 }
 
+/* static */
+already_AddRefed<DocumentChannel> DocumentChannel::CreateForObject(
+    nsDocShellLoadState* aLoadState, class LoadInfo* aLoadInfo,
+    nsLoadFlags aLoadFlags, nsIInterfaceRequestor* aNotificationCallbacks) {
+  return CreateForDocument(aLoadState, aLoadInfo, aLoadFlags,
+                           aNotificationCallbacks, 0, false, false);
+}
+
 //-----------------------------------------------------------------------------
 // DocumentChannel::nsITraceableChannel
 //-----------------------------------------------------------------------------
@@ -290,9 +304,17 @@
 }
 
 NS_IMETHODIMP DocumentChannel::SetLoadFlags(nsLoadFlags aLoadFlags) {
-  NS_ERROR(
-      "DocumentChannel::SetLoadFlags: "
-      "Don't set flags after creation");
+  auto contentPolicy = mLoadInfo->GetExternalContentPolicyType();
+  // Setting load flags for TYPE_OBJECT is permissible before channel to parent
+  // is opened.
+  if (contentPolicy != nsIContentPolicy::TYPE_OBJECT || mWasOpened) {
+    MOZ_CRASH("DocumentChannel::SetLoadFlags: Don't set flags after creation");
+    NS_ERROR(
+        "DocumentChannel::SetLoadFlags: "
+        "Don't set flags after creation");
+  } else {
+    mLoadFlags = aLoadFlags;
+  }
   return NS_OK;
 }
 
@@ -432,6 +454,23 @@
   return NS_OK;
 }
 
+//-----------------------------------------------------------------------------
+// Helpers
+//-----------------------------------------------------------------------------
+
+uint64_t InnerWindowIDForExtantDoc(nsDocShell* docShell) {
+  if (!docShell) {
+    return 0;
+  }
+
+  Document* doc = docShell->GetExtantDocument();
+  if (!doc) {
+    return 0;
+  }
+
+  return doc->InnerWindowID();
+}
+
 }  // namespace net
 }  // namespace mozilla
 