# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentChannelParent.cpp
# Commit: 41de9ac734d6
# Full Hash: 41de9ac734d69d754ea3f13db6933343b62ea1b8
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-21 09:42:41
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r 64e118a38c1d -r 41de9ac734d6 netwerk/ipc/DocumentChannelParent.cpp
--- a/netwerk/ipc/DocumentChannelParent.cpp	Tue Jul 21 01:01:03 2020 +0000
+++ b/netwerk/ipc/DocumentChannelParent.cpp	Tue Jul 21 01:01:05 2020 +0000
@@ -11,6 +11,7 @@
 #include "mozilla/dom/CanonicalBrowsingContext.h"
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ContentParent.h"
+#include "nsDocShellLoadState.h"
 
 extern mozilla::LazyLogModule gDocumentChannelLog;
 #define LOG(fmt) MOZ_LOG(gDocumentChannelLog, mozilla::LogLevel::Verbose, fmt)
@@ -43,7 +44,10 @@
       return false;
     }
   } else {
-    mDocumentLoadListener = new DocumentLoadListener(aContext);
+    bool isDocumentLoad =
+        aArgs.elementCreationArgs().type() ==
+        DocumentChannelElementCreationArgs::TDocumentCreationArgs;
+    mDocumentLoadListener = new DocumentLoadListener(aContext, isDocumentLoad);
 
     Maybe<ClientInfo> clientInfo;
     if (aArgs.initialClientInfo().isSome()) {
@@ -51,12 +55,28 @@
     }
 
     nsresult rv = NS_ERROR_UNEXPECTED;
-    promise = mDocumentLoadListener->Open(
-        loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
-        aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
-        std::move(clientInfo), aArgs.outerWindowId(),
-        aArgs.hasValidTransientUserAction(), Some(aArgs.uriModified()),
-        Some(aArgs.isXFOError()), IProtocol::OtherPid(), &rv);
+
+    if (isDocumentLoad) {
+      const DocumentCreationArgs& docArgs = aArgs.elementCreationArgs();
+
+      promise = mDocumentLoadListener->OpenDocument(
+          loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
+          aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
+          std::move(clientInfo), aArgs.hasValidTransientUserAction(),
+          Some(docArgs.uriModified()), Some(docArgs.isXFOError()),
+          IProtocol::OtherPid(), &rv);
+    } else {
+      const ObjectCreationArgs& objectArgs = aArgs.elementCreationArgs();
+
+      promise = mDocumentLoadListener->OpenObject(
+          loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
+          aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
+          std::move(clientInfo), objectArgs.embedderInnerWindowId(),
+          objectArgs.loadFlags(), objectArgs.contentPolicyType(),
+          aArgs.hasValidTransientUserAction(), objectArgs.isUrgentStart(),
+          IProtocol::OtherPid(), &rv);
+    }
+
     if (NS_FAILED(rv)) {
       MOZ_ASSERT(!promise);
       return SendFailedAsyncOpen(rv);