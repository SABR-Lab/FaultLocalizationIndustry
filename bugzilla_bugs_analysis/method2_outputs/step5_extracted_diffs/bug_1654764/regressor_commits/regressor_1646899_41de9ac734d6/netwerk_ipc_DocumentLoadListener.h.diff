# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.h
# Commit: 41de9ac734d6
# Full Hash: 41de9ac734d69d754ea3f13db6933343b62ea1b8
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-21 09:42:41
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r 64e118a38c1d -r 41de9ac734d6 netwerk/ipc/DocumentLoadListener.h
--- a/netwerk/ipc/DocumentLoadListener.h	Tue Jul 21 01:01:03 2020 +0000
+++ b/netwerk/ipc/DocumentLoadListener.h	Tue Jul 21 01:01:05 2020 +0000
@@ -94,8 +94,10 @@
                              public nsIMultiPartChannelListener,
                              public nsIProgressEventSink {
  public:
-  explicit DocumentLoadListener(
-      dom::CanonicalBrowsingContext* aBrowsingContext);
+  // See the comment on GetLoadingBrowsingContext for explanation of
+  // aLoadingBrowsingContext.
+  DocumentLoadListener(dom::CanonicalBrowsingContext* aLoadingBrowsingContext,
+                       bool aIsDocumentLoad);
 
   struct OpenPromiseSucceededType {
     nsTArray<ipc::Endpoint<extensions::PStreamFilterParent>>
@@ -117,6 +119,7 @@
                      true /* isExclusive */>
       OpenPromise;
 
+ private:
   // Creates the channel, and then calls AsyncOpen on it.
   // The DocumentLoadListener will require additional process from the consumer
   // in order to complete the redirect to the end channel. This is done by
@@ -125,14 +128,30 @@
   // Once that promise is resolved; the consumer no longer needs to hold a
   // reference to the DocumentLoadListener nor will the consumer required to be
   // used again.
-  RefPtr<OpenPromise> Open(nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+  RefPtr<OpenPromise> Open(nsDocShellLoadState* aLoadState, LoadInfo* aLoadInfo,
+                           nsLoadFlags aLoadFlags, uint32_t aCacheKey,
                            const Maybe<uint64_t>& aChannelId,
                            const TimeStamp& aAsyncOpenTime,
                            nsDOMNavigationTiming* aTiming,
-                           Maybe<dom::ClientInfo>&& aInfo,
-                           uint64_t aOuterWindowId, bool aHasGesture,
-                           Maybe<bool> aUriModified, Maybe<bool> aIsXFOError,
-                           base::ProcessId aPid, nsresult* aRv);
+                           Maybe<dom::ClientInfo>&& aInfo, bool aHasGesture,
+                           bool aUrgentStart, base::ProcessId aPid,
+                           nsresult* aRv);
+
+ public:
+  RefPtr<OpenPromise> OpenDocument(
+      nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+      const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
+      nsDOMNavigationTiming* aTiming, Maybe<dom::ClientInfo>&& aInfo,
+      bool aHasGesture, Maybe<bool> aUriModified, Maybe<bool> aIsXFOError,
+      base::ProcessId aPid, nsresult* aRv);
+
+  RefPtr<OpenPromise> OpenObject(
+      nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+      const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
+      nsDOMNavigationTiming* aTiming, Maybe<dom::ClientInfo>&& aInfo,
+      uint64_t aInnerWindowId, nsLoadFlags aLoadFlags,
+      nsContentPolicyType aContentPolicyType, bool aHasGesture,
+      bool aUrgentStart, base::ProcessId aPid, nsresult* aRv);
 
   // Creates a DocumentLoadListener entirely in the parent process and opens it,
   // and never needs a DocumentChannel to connect to an existing docshell.
@@ -140,7 +159,7 @@
   // process and docshell, and delivers the response there directly.
   static bool LoadInParent(dom::CanonicalBrowsingContext* aBrowsingContext,
                            nsDocShellLoadState* aLoadState,
-                           uint64_t aOuterWindowId, bool aSetNavigating);
+                           bool aSetNavigating);
 
   // Creates a DocumentLoadListener directly in the parent process and opens it,
   // without needing an existing DocumentChannel.
@@ -149,7 +168,7 @@
   // and clean up.
   static bool SpeculativeLoadInParent(
       dom::CanonicalBrowsingContext* aBrowsingContext,
-      nsDocShellLoadState* aLoadState, uint64_t aOuterWindowId);
+      nsDocShellLoadState* aLoadState);
 
   // Ensures that a load identifier allocated by OpenFromParent has
   // been deregistered if it hasn't already been claimed.
@@ -185,7 +204,7 @@
   NS_DECLARE_STATIC_IID_ACCESSOR(DOCUMENT_LOAD_LISTENER_IID)
 
   // Called by the DocumentChannel if cancelled.
-  void Cancel(const nsresult& status);
+  void Cancel(const nsresult& aStatusCode);
 
   nsIChannel* GetChannel() const { return mChannel; }
 
@@ -237,8 +256,6 @@
                              dom::ContentParent* aParent) const;
 
   uint64_t GetLoadIdentifier() const { return mLoadIdentifier; }
-  dom::CanonicalBrowsingContext* GetBrowsingContext() const;
-
   uint32_t GetLoadType() const { return mLoadStateLoadType; }
 
  protected:
@@ -246,7 +263,6 @@
 
  private:
   RefPtr<OpenPromise> OpenInParent(nsDocShellLoadState* aLoadState,
-                                   uint64_t aOuterWindowId,
                                    bool aSupportsRedirectToRealChannel);
 
   friend class ParentProcessDocumentOpenInfo;
@@ -295,10 +311,15 @@
   RefPtr<PDocumentChannelParent::RedirectToRealChannelPromise>
   RedirectToParentProcess(uint32_t aRedirectFlags, uint32_t aLoadFlags);
 
-  // Construct a LoadInfo object to use for the internal channel.
-  already_AddRefed<LoadInfo> CreateLoadInfo(
-      dom::CanonicalBrowsingContext* aBrowsingContext,
-      nsDocShellLoadState* aLoadState);
+  // Return the Browsing Context that is performing the load.
+  // For document loads, the BC is the one that the (sub)doc
+  // will load into. For <object>/<embed>, it's the embedder document's BC.
+  dom::CanonicalBrowsingContext* GetLoadingBrowsingContext() const;
+
+  // Return the Browsing Context that document is being loaded into. For
+  // non-document loads, this will return nullptr.
+  dom::CanonicalBrowsingContext* GetDocumentBrowsingContext() const;
+  dom::CanonicalBrowsingContext* GetTopBrowsingContext() const;
 
   void AddURIVisit(nsIChannel* aChannel, uint32_t aLoadFlags);
   bool HasCrossOriginOpenerPolicyMismatch() const;
@@ -314,6 +335,8 @@
   // Returns false if the docshell will ignore the load entirely.
   bool DocShellWillDisplayContent(nsresult aStatus);
 
+  void FireStateChange(uint32_t aStateFlags, nsresult aStatus);
+
   // Returns true if this is a failed load, where we have successfully
   // created a fixed URI to attempt loading instead.
   // If successful, this calls DisconnectListeners to completely finish
@@ -495,6 +518,8 @@
   }
   RefPtr<OpenPromise::Private> mOpenPromise;
   bool mOpenPromiseResolved = false;
+
+  const bool mIsDocumentLoad;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(DocumentLoadListener, DOCUMENT_LOAD_LISTENER_IID)