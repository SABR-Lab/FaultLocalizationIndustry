# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/ParentProcessDocumentChannel.cpp
# Commit: 41de9ac734d6
# Full Hash: 41de9ac734d69d754ea3f13db6933343b62ea1b8
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-21 09:42:41
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r 64e118a38c1d -r 41de9ac734d6 netwerk/ipc/ParentProcessDocumentChannel.cpp
--- a/netwerk/ipc/ParentProcessDocumentChannel.cpp	Tue Jul 21 01:01:03 2020 +0000
+++ b/netwerk/ipc/ParentProcessDocumentChannel.cpp	Tue Jul 21 01:01:05 2020 +0000
@@ -129,8 +129,14 @@
 NS_IMETHODIMP ParentProcessDocumentChannel::AsyncOpen(
     nsIStreamListener* aListener) {
   LOG(("ParentProcessDocumentChannel AsyncOpen [this=%p]", this));
-  mDocumentLoadListener = new DocumentLoadListener(
-      GetDocShell()->GetBrowsingContext()->Canonical());
+  auto docShell = RefPtr<nsDocShell>(GetDocShell());
+  MOZ_ASSERT(docShell);
+
+  bool isDocumentLoad = mLoadInfo->GetExternalContentPolicyType() !=
+                        nsIContentPolicy::TYPE_OBJECT;
+
+  mDocumentLoadListener = MakeRefPtr<DocumentLoadListener>(
+      docShell->GetBrowsingContext()->Canonical(), isDocumentLoad);
   LOG(("Created PPDocumentChannel with listener=%p",
        mDocumentLoadListener.get()));
 
@@ -144,18 +150,32 @@
 
   gHttpHandler->OnOpeningDocumentRequest(this);
 
-  GetDocShell()->GetBrowsingContext()->SetCurrentLoadIdentifier(
-      Some(mLoadState->GetLoadIdentifier()));
+  if (isDocumentLoad) {
+    GetDocShell()->GetBrowsingContext()->SetCurrentLoadIdentifier(
+        Some(mLoadState->GetLoadIdentifier()));
+  }
 
   nsresult rv = NS_OK;
   Maybe<dom::ClientInfo> initialClientInfo = mInitialClientInfo;
-  auto promise = mDocumentLoadListener->Open(
-      mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
-      std::move(initialClientInfo), GetDocShell()->GetOuterWindowID(),
-      GetDocShell()
-          ->GetBrowsingContext()
-          ->HasValidTransientUserGestureActivation(),
-      Some(mUriModified), Some(mIsXFOError), 0 /* ProcessId */, &rv);
+
+  const bool hasValidTransientUserGestureActivation =
+      docShell->GetBrowsingContext()->HasValidTransientUserGestureActivation();
+
+  RefPtr<DocumentLoadListener::OpenPromise> promise;
+  if (isDocumentLoad) {
+    promise = mDocumentLoadListener->OpenDocument(
+        mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
+        std::move(initialClientInfo), hasValidTransientUserGestureActivation,
+        Some(mUriModified), Some(mIsXFOError), 0 /* ProcessId */, &rv);
+  } else {
+    promise = mDocumentLoadListener->OpenObject(
+        mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
+        std::move(initialClientInfo), InnerWindowIDForExtantDoc(docShell),
+        mLoadFlags, mLoadInfo->InternalContentPolicyType(),
+        hasValidTransientUserGestureActivation,
+        UserActivation::IsHandlingUserInput(), 0 /* ProcessId */, &rv);
+  }
+
   if (NS_FAILED(rv)) {
     MOZ_ASSERT(!promise);
     mDocumentLoadListener = nullptr;
