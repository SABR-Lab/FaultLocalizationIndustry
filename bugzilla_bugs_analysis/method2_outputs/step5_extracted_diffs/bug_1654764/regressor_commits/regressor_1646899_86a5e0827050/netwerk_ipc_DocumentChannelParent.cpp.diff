# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentChannelParent.cpp
# Commit: 86a5e0827050
# Full Hash: 86a5e0827050e262bb713d6910a8c1d6e6ec3738
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-13 09:51:22
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r d2fd0f955e24 -r 86a5e0827050 netwerk/ipc/DocumentChannelParent.cpp
--- a/netwerk/ipc/DocumentChannelParent.cpp	Mon Jul 13 00:48:54 2020 +0000
+++ b/netwerk/ipc/DocumentChannelParent.cpp	Mon Jul 13 00:48:57 2020 +0000
@@ -11,6 +11,7 @@
 #include "mozilla/dom/CanonicalBrowsingContext.h"
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ContentParent.h"
+#include "nsDocShellLoadState.h"
 
 extern mozilla::LazyLogModule gDocumentChannelLog;
 #define LOG(fmt) MOZ_LOG(gDocumentChannelLog, mozilla::LogLevel::Verbose, fmt)
@@ -51,12 +52,30 @@
     }
 
     nsresult rv = NS_ERROR_UNEXPECTED;
-    promise = mDocumentLoadListener->Open(
-        loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
-        aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
-        std::move(clientInfo), aArgs.outerWindowId(),
-        aArgs.hasValidTransientUserAction(), Some(aArgs.uriModified()),
-        Some(aArgs.isXFOError()), IProtocol::OtherPid(), &rv);
+
+    if (aArgs.elementCreationArgs().type() ==
+        DocumentChannelElementCreationArgs::TDocumentCreationArgs) {
+      const DocumentCreationArgs& docArgs = aArgs.elementCreationArgs();
+
+      promise = mDocumentLoadListener->OpenDocument(
+          loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
+          aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
+          std::move(clientInfo), docArgs.outerWindowId(),
+          aArgs.hasValidTransientUserAction(), Some(docArgs.uriModified()),
+          Some(docArgs.isXFOError()), IProtocol::OtherPid(), &rv);
+
+    } else {
+      const ObjectCreationArgs& objectArgs = aArgs.elementCreationArgs();
+
+      promise = mDocumentLoadListener->OpenObject(
+          loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
+          aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
+          std::move(clientInfo), objectArgs.embedderInnerWindowId(),
+          objectArgs.loadFlags(), objectArgs.contentPolicyType(),
+          aArgs.hasValidTransientUserAction(), objectArgs.isUrgentStart(),
+          IProtocol::OtherPid(), &rv);
+    }
+
     if (NS_FAILED(rv)) {
       MOZ_ASSERT(!promise);
       return SendFailedAsyncOpen(rv);