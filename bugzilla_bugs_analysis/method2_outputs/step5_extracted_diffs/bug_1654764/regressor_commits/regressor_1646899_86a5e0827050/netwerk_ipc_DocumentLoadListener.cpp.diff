# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.cpp
# Commit: 86a5e0827050
# Full Hash: 86a5e0827050e262bb713d6910a8c1d6e6ec3738
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-13 09:51:22
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r d2fd0f955e24 -r 86a5e0827050 netwerk/ipc/DocumentLoadListener.cpp
--- a/netwerk/ipc/DocumentLoadListener.cpp	Mon Jul 13 00:48:54 2020 +0000
+++ b/netwerk/ipc/DocumentLoadListener.cpp	Mon Jul 13 00:48:57 2020 +0000
@@ -42,10 +42,13 @@
 #include "nsIViewSourceChannel.h"
 #include "nsImportModule.h"
 #include "nsMimeTypes.h"
+#include "nsQueryObject.h"
 #include "nsRedirectHistoryEntry.h"
 #include "nsSandboxFlags.h"
+#include "nsStringStream.h"
 #include "nsURILoader.h"
 #include "nsWebNavigationInfo.h"
+#include "mozilla/dom/BrowserParent.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/nsHTTPSOnlyUtils.h"
 #include "mozilla/dom/RemoteWebProgress.h"
@@ -76,6 +79,94 @@
                            aNeedToAddURIVisit);
 }
 
+static auto SecurityFlagsForLoadInfo(nsDocShellLoadState* aLoadState)
+    -> nsSecurityFlags {
+  // TODO: Block copied from nsDocShell::DoURILoad, refactor out somewhere
+  nsSecurityFlags securityFlags =
+      nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
+
+  if (aLoadState->LoadType() == LOAD_ERROR_PAGE) {
+    securityFlags |= nsILoadInfo::SEC_LOAD_ERROR_PAGE;
+  }
+
+  if (aLoadState->PrincipalToInherit()) {
+    bool isSrcdoc =
+        aLoadState->HasLoadFlags(nsDocShell::INTERNAL_LOAD_FLAGS_IS_SRCDOC);
+    bool inheritAttrs = nsContentUtils::ChannelShouldInheritPrincipal(
+        aLoadState->PrincipalToInherit(), aLoadState->URI(),
+        true,  // aInheritForAboutBlank
+        isSrcdoc);
+
+    bool isURIUniqueOrigin =
+        StaticPrefs::security_data_uri_unique_opaque_origin() &&
+        SchemeIsData(aLoadState->URI());
+    if (inheritAttrs && !isURIUniqueOrigin) {
+      securityFlags |= nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL;
+    }
+  }
+
+  return securityFlags;
+}
+
+// Construct a LoadInfo object to use when creating the internal channel for a
+// Document/SubDocument load.
+static auto CreateDocumentLoadInfo(CanonicalBrowsingContext* aBrowsingContext,
+                                   nsDocShellLoadState* aLoadState,
+                                   uint64_t aOuterWindowId)
+    -> already_AddRefed<LoadInfo> {
+  uint32_t sandboxFlags = aBrowsingContext->GetSandboxFlags();
+  RefPtr<LoadInfo> loadInfo;
+
+  auto securityFlags = SecurityFlagsForLoadInfo(aLoadState);
+
+  if (aBrowsingContext->GetParent()) {
+    loadInfo = LoadInfo::CreateForFrame(
+        aBrowsingContext, aLoadState->TriggeringPrincipal(), aOuterWindowId,
+        securityFlags, sandboxFlags);
+  } else {
+    OriginAttributes attrs;
+    aBrowsingContext->GetOriginAttributes(attrs);
+    loadInfo = LoadInfo::CreateForDocument(
+        aBrowsingContext, aLoadState->TriggeringPrincipal(), attrs,
+        aOuterWindowId, securityFlags, sandboxFlags);
+  }
+
+  loadInfo->SetHasValidUserGestureActivation(
+      aLoadState->HasValidUserGestureActivation());
+
+  return loadInfo.forget();
+}
+
+// Construct a LoadInfo object to use when creating the internal channel for an
+// Object/Embed load.
+static auto CreateObjectLoadInfo(nsDocShellLoadState* aLoadState,
+                                 uint64_t aInnerWindowId,
+                                 nsContentPolicyType aContentPolicyType,
+                                 uint32_t aSandboxFlags)
+    -> already_AddRefed<LoadInfo> {
+  RefPtr<WindowGlobalParent> wgp =
+      WindowGlobalParent::GetByInnerWindowId(aInnerWindowId);
+  MOZ_RELEASE_ASSERT(wgp);
+
+  auto securityFlags = SecurityFlagsForLoadInfo(aLoadState);
+
+  RefPtr<LoadInfo> loadInfo = LoadInfo::CreateForNonDocument(
+      wgp, wgp->DocumentPrincipal(), 0, aContentPolicyType, securityFlags,
+      aSandboxFlags);
+
+  loadInfo->SetHasValidUserGestureActivation(
+      aLoadState->HasValidUserGestureActivation());
+
+  return loadInfo.forget();
+}
+
+static auto WebProgressForBrowsingContext(
+    CanonicalBrowsingContext* aBrowsingContext)
+    -> already_AddRefed<BrowsingContextWebProgress> {
+  return RefPtr<BrowsingContextWebProgress>(aBrowsingContext->GetWebProgress())
+      .forget();
+}
+
 /**
  * An extension to nsDocumentOpenInfo that we run in the parent process, so
  * that we can make the decision to retarget to content handlers or the external
@@ -94,10 +185,12 @@
  public:
   ParentProcessDocumentOpenInfo(ParentChannelListener* aListener,
                                 uint32_t aFlags,
-                                mozilla::dom::BrowsingContext* aBrowsingContext)
+                                mozilla::dom::BrowsingContext* aBrowsingContext,
+                                nsContentPolicyType aExternalContentPolicyType)
       : nsDocumentOpenInfo(aFlags, false),
         mBrowsingContext(aBrowsingContext),
-        mListener(aListener) {
+        mListener(aListener),
+        mExternalContentPolicyType(aExternalContentPolicyType) {
     LOG(("ParentProcessDocumentOpenInfo ctor [this=%p]", this));
   }
 
@@ -169,12 +262,13 @@
 
   nsDocumentOpenInfo* Clone() override {
     mCloned = true;
-    return new ParentProcessDocumentOpenInfo(mListener, mFlags,
-                                             mBrowsingContext);
+    return new ParentProcessDocumentOpenInfo(
+        mListener, mFlags, mBrowsingContext, mExternalContentPolicyType);
   }
 
-  NS_IMETHOD OnStartRequest(nsIRequest* request) override {
-    LOG(("ParentProcessDocumentOpenInfo OnStartRequest [this=%p]", this));
+  nsresult OnDocumentStartRequest(nsIRequest* request) {
+    LOG(("ParentProcessDocumentOpenInfo OnDocumentStartRequest [this=%p]",
+         this));
 
     nsresult rv = nsDocumentOpenInfo::OnStartRequest(request);
 
@@ -213,6 +307,32 @@
     return rv;
   }
 
+  nsresult OnObjectStartRequest(nsIRequest* request) {
+    LOG(("ParentProcessDocumentOpenInfo OnObjectStartRequest [this=%p]", this));
+    // Just redirect to the nsObjectLoadingContent in the content process.
+    m_targetStreamListener = mListener;
+    return m_targetStreamListener->OnStartRequest(request);
+  }
+
+  NS_IMETHOD OnStartRequest(nsIRequest* request) override {
+    LOG(("ParentProcessDocumentOpenInfo OnStartRequest [this=%p]", this));
+
+    switch (mExternalContentPolicyType) {
+      case nsIContentPolicy::TYPE_DOCUMENT:
+      case nsIContentPolicy::TYPE_SUBDOCUMENT:
+        return OnDocumentStartRequest(request);
+        break;
+
+      case nsIContentPolicy::TYPE_OBJECT:
+        return OnObjectStartRequest(request);
+        break;
+
+      default:
+        MOZ_CRASH("Unexpect external content policy type.");
+        return NS_BINDING_FAILED;
+    }
+  }
+
   NS_IMETHOD OnAfterLastPart(nsresult aStatus) override {
     mListener->OnAfterLastPart(aStatus);
     return NS_OK;
@@ -236,6 +356,7 @@
 
   RefPtr<mozilla::dom::BrowsingContext> mBrowsingContext;
   RefPtr<ParentChannelListener> mListener;
+  nsContentPolicyType mExternalContentPolicyType;
 
   /**
    * Set to true if we got cloned to create a chained listener.
@@ -267,10 +388,11 @@
 NS_INTERFACE_MAP_END
 
 DocumentLoadListener::DocumentLoadListener(
-    CanonicalBrowsingContext* aBrowsingContext) {
+    CanonicalBrowsingContext* aLoadingBrowsingContext) {
   LOG(("DocumentLoadListener ctor [this=%p]", this));
-  mParentChannelListener = new ParentChannelListener(
-      this, aBrowsingContext, aBrowsingContext->UsePrivateBrowsing());
+  mParentChannelListener =
+      new ParentChannelListener(this, aLoadingBrowsingContext,
+                                aLoadingBrowsingContext->UsePrivateBrowsing());
 }
 
 DocumentLoadListener::~DocumentLoadListener() {
@@ -304,7 +426,7 @@
   }
 
   RefPtr<CanonicalBrowsingContext> browsingContext =
-      mParentChannelListener->GetBrowsingContext();
+      GetDocumentBrowsingContext();
   nsCOMPtr<nsIWidget> widget =
       browsingContext->GetParentProcessWidgetContaining();
 
@@ -313,97 +435,49 @@
                                   mLoadStateLoadType);
 }
 
-already_AddRefed<LoadInfo> DocumentLoadListener::CreateLoadInfo(
-    CanonicalBrowsingContext* aBrowsingContext, nsDocShellLoadState* aLoadState,
-    uint64_t aOuterWindowId) {
-  // TODO: Block copied from nsDocShell::DoURILoad, refactor out somewhere
-  bool inheritPrincipal = false;
-
-  if (aLoadState->PrincipalToInherit()) {
-    bool isSrcdoc =
-        aLoadState->HasLoadFlags(nsDocShell::INTERNAL_LOAD_FLAGS_IS_SRCDOC);
-    bool inheritAttrs = nsContentUtils::ChannelShouldInheritPrincipal(
-        aLoadState->PrincipalToInherit(), aLoadState->URI(),
-        true,  // aInheritForAboutBlank
-        isSrcdoc);
+CanonicalBrowsingContext* DocumentLoadListener::GetLoadingBrowsingContext()
+    const {
+  return mParentChannelListener ? mParentChannelListener->GetBrowsingContext()
+                                : nullptr;
+}
 
-    bool isURIUniqueOrigin =
-        StaticPrefs::security_data_uri_unique_opaque_origin() &&
-        SchemeIsData(aLoadState->URI());
-    inheritPrincipal = inheritAttrs && !isURIUniqueOrigin;
-  }
-
-  nsSecurityFlags securityFlags =
-      nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
-  uint32_t sandboxFlags = aBrowsingContext->GetSandboxFlags();
-
-  if (aLoadState->LoadType() == LOAD_ERROR_PAGE) {
-    securityFlags |= nsILoadInfo::SEC_LOAD_ERROR_PAGE;
-  }
-
-  if (inheritPrincipal) {
-    securityFlags |= nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL;
+CanonicalBrowsingContext* DocumentLoadListener::GetDocumentBrowsingContext()
+    const {
+  if (mExternalContentPolicyType == nsIContentPolicy::TYPE_OBJECT) {
+    return nullptr;
   }
 
-  RefPtr<LoadInfo> loadInfo;
-  if (aBrowsingContext->GetParent()) {
-    // Build LoadInfo for TYPE_SUBDOCUMENT
-    loadInfo = LoadInfo::CreateForFrame(
-        aBrowsingContext, aLoadState->TriggeringPrincipal(), aOuterWindowId,
-        securityFlags, sandboxFlags);
-  } else {
-    // Build LoadInfo for TYPE_DOCUMENT
-    OriginAttributes attrs;
-    aBrowsingContext->GetOriginAttributes(attrs);
-    loadInfo = LoadInfo::CreateForDocument(
-        aBrowsingContext, aLoadState->TriggeringPrincipal(), attrs,
-        aOuterWindowId, securityFlags, sandboxFlags);
-  }
-
-  loadInfo->SetHasValidUserGestureActivation(
-      aLoadState->HasValidUserGestureActivation());
-
-  return loadInfo.forget();
+  return GetLoadingBrowsingContext();
 }
 
-CanonicalBrowsingContext* DocumentLoadListener::GetBrowsingContext() const {
-  if (!mParentChannelListener) {
-    return nullptr;
-  }
-  return mParentChannelListener->GetBrowsingContext();
+CanonicalBrowsingContext* DocumentLoadListener::GetTopBrowsingContext() const {
+  auto* loadingContext = GetLoadingBrowsingContext();
+  return loadingContext ? loadingContext->Top() : nullptr;
 }
 
-auto DocumentLoadListener::Open(
-    nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
-    const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
-    nsDOMNavigationTiming* aTiming, Maybe<ClientInfo>&& aInfo,
-    uint64_t aOuterWindowId, bool aHasGesture, Maybe<bool> aUriModified,
-    Maybe<bool> aIsXFOError, base::ProcessId aPid, nsresult* aRv)
-    -> RefPtr<OpenPromise> {
-  LOG(("DocumentLoadListener Open [this=%p, uri=%s]", this,
-       aLoadState->URI()->GetSpecOrDefault().get()));
-  RefPtr<CanonicalBrowsingContext> browsingContext =
-      mParentChannelListener->GetBrowsingContext();
+auto DocumentLoadListener::Open(nsDocShellLoadState* aLoadState,
+                                LoadInfo* aLoadInfo, nsLoadFlags aLoadFlags,
+                                uint32_t aCacheKey,
+                                const Maybe<uint64_t>& aChannelId,
+                                const TimeStamp& aAsyncOpenTime,
+                                nsDOMNavigationTiming* aTiming,
+                                Maybe<ClientInfo>&& aInfo, bool aHasGesture,
+                                bool aUrgentStart, base::ProcessId aPid,
+                                nsresult* aRv) -> RefPtr<OpenPromise> {
+  auto* loadingContext = GetLoadingBrowsingContext();
+
+  MOZ_DIAGNOSTIC_ASSERT_IF(loadingContext->GetParent(),
+                           loadingContext->GetParentWindowContext());
 
   OriginAttributes attrs;
-  browsingContext->GetOriginAttributes(attrs);
+  loadingContext->GetOriginAttributes(attrs);
 
   mLoadIdentifier = aLoadState->GetLoadIdentifier();
-  MOZ_DIAGNOSTIC_ASSERT_IF(browsingContext->GetParent(),
-                           browsingContext->GetParentWindowContext());
-
-  // If this is a top-level load, then rebuild the LoadInfo from scratch,
-  // since the goal is to be able to initiate loads in the parent, where the
-  // content process won't have provided us with an existing one.
-  RefPtr<LoadInfo> loadInfo =
-      CreateLoadInfo(browsingContext, aLoadState, aOuterWindowId);
-
-  nsLoadFlags loadFlags = aLoadState->CalculateChannelLoadFlags(
-      browsingContext, std::move(aUriModified), std::move(aIsXFOError));
+  mExternalContentPolicyType = aLoadInfo->GetExternalContentPolicyType();
 
   if (!nsDocShell::CreateAndConfigureRealChannelForLoadState(
-          browsingContext, aLoadState, loadInfo, mParentChannelListener,
-          nullptr, attrs, loadFlags, aCacheKey, *aRv,
+          loadingContext, aLoadState, aLoadInfo, mParentChannelListener,
+          nullptr, attrs, aLoadFlags, aCacheKey, *aRv,
           getter_AddRefs(mChannel))) {
     LOG(("DocumentLoadListener::Open failed to create channel [this=%p]",
          this));
@@ -411,19 +485,20 @@
     return nullptr;
   }
 
-  nsCOMPtr<nsIURI> uriBeingLoaded =
-      AntiTrackingUtils::MaybeGetDocumentURIBeingLoaded(mChannel);
+  nsCOMPtr<nsIURI> uriBeingLoaded;
+  Unused << NS_WARN_IF(
+      NS_FAILED(mChannel->GetURI(getter_AddRefs(uriBeingLoaded))));
 
   RefPtr<HttpBaseChannel> httpBaseChannel = do_QueryObject(mChannel, aRv);
-  if (httpBaseChannel) {
+  if (uriBeingLoaded && httpBaseChannel) {
     nsCOMPtr<nsIURI> topWindowURI;
-    if (browsingContext->IsTop()) {
+    if (loadingContext->IsTop()) {
       // If this is for the top level loading, the top window URI should be the
       // URI which we are loading.
       topWindowURI = uriBeingLoaded;
     } else if (RefPtr<WindowGlobalParent> topWindow = AntiTrackingUtils::
                    GetTopWindowExcludingExtensionAccessibleContentFrames(
-                       browsingContext, uriBeingLoaded)) {
+                       loadingContext, uriBeingLoaded)) {
       nsCOMPtr<nsIPrincipal> topWindowPrincipal =
           topWindow->DocumentPrincipal();
       if (topWindowPrincipal && !topWindowPrincipal->GetIsNullPrincipal()) {
@@ -451,7 +526,12 @@
 
   if (nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel)) {
     Unused << httpChannel->SetRequestContextID(
-        browsingContext->GetRequestContextId());
+        loadingContext->GetRequestContextId());
+
+    nsCOMPtr<nsIClassOfService> cos(do_QueryInterface(httpChannel));
+    if (cos && aUrgentStart) {
+      cos->AddClassFlags(nsIClassOfService::UrgentStart);
+    }
   }
 
   // nsViewSourceChannel normally replaces the nsIRequest passed to
@@ -467,7 +547,8 @@
   // across any serviceworker related data between channels as needed.
   AddClientChannelHelperInParent(mChannel, std::move(aInfo));
 
-  if (!browsingContext->StartDocumentLoad(this)) {
+  auto* documentContext = GetDocumentBrowsingContext();
+  if (documentContext && !documentContext->StartDocumentLoad(this)) {
     LOG(("DocumentLoadListener::Open failed StartDocumentLoad [this=%p]",
          this));
     *aRv = NS_BINDING_ABORTED;
@@ -480,29 +561,30 @@
   // NOTE: The only case not handled here to mirror Content process is
   // redirecting to re-use the channel.
   MOZ_ASSERT(!aLoadState->GetPendingRedirectedChannel());
-  uint32_t openFlags = nsDocShell::ComputeURILoaderFlags(
-      browsingContext, aLoadState->LoadType());
+  uint32_t openFlags =
+      nsDocShell::ComputeURILoaderFlags(loadingContext, aLoadState->LoadType());
 
   RefPtr<ParentProcessDocumentOpenInfo> openInfo =
       new ParentProcessDocumentOpenInfo(mParentChannelListener, openFlags,
-                                        browsingContext);
+                                        loadingContext,
+                                        mExternalContentPolicyType);
   openInfo->Prepare();
 
 #ifdef ANDROID
   RefPtr<MozPromise<bool, bool, false>> promise;
-  if (aLoadState->LoadType() != LOAD_ERROR_PAGE &&
+  if (documentContext && aLoadState->LoadType() != LOAD_ERROR_PAGE &&
       !(aLoadState->HasLoadFlags(
           nsDocShell::INTERNAL_LOAD_FLAGS_BYPASS_LOAD_URI_DELEGATE)) &&
       !(aLoadState->LoadType() & LOAD_HISTORY)) {
     nsCOMPtr<nsIWidget> widget =
-        browsingContext->GetParentProcessWidgetContaining();
+        documentContext->GetParentProcessWidgetContaining();
     RefPtr<nsWindow> window = nsWindow::From(widget);
 
     if (window) {
       promise = window->OnLoadRequest(
           aLoadState->URI(), nsIBrowserDOMWindow::OPEN_CURRENTWINDOW,
           aLoadState->LoadFlags(), aLoadState->TriggeringPrincipal(),
-          aHasGesture, browsingContext->IsTopContent());
+          aHasGesture, documentContext->IsTopContent());
     }
   }
 
@@ -533,7 +615,9 @@
       LOG(("DocumentLoadListener::Open failed AsyncOpen [this=%p rv=%" PRIx32
            "]",
            this, static_cast<uint32_t>(*aRv)));
-      browsingContext->EndDocumentLoad(false);
+      if (documentContext) {
+        documentContext->EndDocumentLoad(false);
+      }
       mParentChannelListener = nullptr;
       return nullptr;
     }
@@ -548,9 +632,9 @@
   mBaseURI = aLoadState->BaseURI();
   mOriginalUriString = aLoadState->GetOriginalURIString();
   if (StaticPrefs::fission_sessionHistoryInParent() &&
-      browsingContext->GetSessionHistory()) {
+      documentContext->GetSessionHistory()) {
     mSessionHistoryInfo =
-        browsingContext->CreateSessionHistoryEntryForLoad(aLoadState, mChannel);
+        documentContext->CreateSessionHistoryEntryForLoad(aLoadState, mChannel);
   }
 
   *aRv = NS_OK;
@@ -561,14 +645,72 @@
   return mOpenPromise;
 }
 
+auto DocumentLoadListener::OpenDocument(
+    nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+    const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
+    nsDOMNavigationTiming* aTiming, Maybe<dom::ClientInfo>&& aInfo,
+    uint64_t aOuterWindowId, bool aHasGesture, Maybe<bool> aUriModified,
+    Maybe<bool> aIsXFOError, base::ProcessId aPid, nsresult* aRv)
+    -> RefPtr<OpenPromise> {
+  LOG(("DocumentLoadListener [%p] OpenDocument [uri=%s]", this,
+       aLoadState->URI()->GetSpecOrDefault().get()));
+
+  RefPtr<CanonicalBrowsingContext> browsingContext =
+      GetDocumentBrowsingContext();
+
+  // If this is a top-level load, then rebuild the LoadInfo from scratch,
+  // since the goal is to be able to initiate loads in the parent, where the
+  // content process won't have provided us with an existing one.
+  RefPtr<LoadInfo> loadInfo =
+      CreateDocumentLoadInfo(browsingContext, aLoadState, aOuterWindowId);
+
+  MOZ_ASSERT_IF(!browsingContext->GetParent(),
+                loadInfo->GetExternalContentPolicyType() ==
+                    nsIContentPolicy::TYPE_DOCUMENT);
+  MOZ_ASSERT_IF(browsingContext->GetParent(),
+                loadInfo->GetExternalContentPolicyType() ==
+                    nsIContentPolicy::TYPE_SUBDOCUMENT);
+
+  nsLoadFlags loadFlags = aLoadState->CalculateChannelLoadFlags(
+      browsingContext, std::move(aUriModified), std::move(aIsXFOError));
+
+  return Open(aLoadState, loadInfo, loadFlags, aCacheKey, aChannelId,
+              aAsyncOpenTime, aTiming, std::move(aInfo), aHasGesture, false,
+              aPid, aRv);
+}
+
+auto DocumentLoadListener::OpenObject(
+    nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+    const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
+    nsDOMNavigationTiming* aTiming, Maybe<dom::ClientInfo>&& aInfo,
+    uint64_t aInnerWindowId, nsLoadFlags aLoadFlags,
+    nsContentPolicyType aContentPolicyType, bool aHasGesture, bool aUrgentStart,
+    base::ProcessId aPid, nsresult* aRv) -> RefPtr<OpenPromise> {
+  LOG(("DocumentLoadListener [%p] OpenObject [uri=%s]", this,
+       aLoadState->URI()->GetSpecOrDefault().get()));
+
+  auto sandboxFlags = GetLoadingBrowsingContext()->GetSandboxFlags();
+
+  RefPtr<LoadInfo> loadInfo = CreateObjectLoadInfo(
+      aLoadState, aInnerWindowId, aContentPolicyType, sandboxFlags);
+
+  MOZ_ASSERT(loadInfo->GetExternalContentPolicyType() ==
+             nsIContentPolicy::TYPE_OBJECT);
+
+  return Open(aLoadState, loadInfo, aLoadFlags, aCacheKey, aChannelId,
+              aAsyncOpenTime, aTiming, std::move(aInfo), aHasGesture,
+              aUrgentStart, aPid, aRv);
+}
+
 auto DocumentLoadListener::OpenInParent(nsDocShellLoadState* aLoadState,
                                         uint64_t aOuterWindowId,
                                         bool aSupportsRedirectToRealChannel)
     -> RefPtr<OpenPromise> {
   // We currently only support passing nullptr for aLoadInfo for
   // top level browsing contexts.
-  if (!GetBrowsingContext()->IsTopContent() ||
-      !GetBrowsingContext()->GetContentParent()) {
+  auto* browsingContext = GetDocumentBrowsingContext();
+  if (!browsingContext->IsTopContent() ||
+      !browsingContext->GetContentParent()) {
     LOG(("DocumentLoadListener::OpenInParent failed because of subdoc"));
     return nullptr;
   }
@@ -607,7 +749,7 @@
 
   RefPtr<nsDOMNavigationTiming> timing = new nsDOMNavigationTiming(nullptr);
   timing->NotifyNavigationStart(
-      GetBrowsingContext()->GetIsActive()
+      browsingContext->GetIsActive()
           ? nsDOMNavigationTiming::DocShellState::eActive
           : nsDOMNavigationTiming::DocShellState::eInactive);
 
@@ -625,27 +767,44 @@
 
   mSupportsRedirectToRealChannel = aSupportsRedirectToRealChannel;
 
+  // This is a top-level load, so rebuild the LoadInfo from scratch,
+  // since in the parent the
+  // content process won't have provided us with an existing one.
+  RefPtr<LoadInfo> loadInfo =
+      CreateDocumentLoadInfo(browsingContext, aLoadState, aOuterWindowId);
+
+  MOZ_ASSERT_IF(!browsingContext->GetParent(),
+                loadInfo->GetExternalContentPolicyType() ==
+                    nsIContentPolicy::TYPE_DOCUMENT);
+  MOZ_ASSERT_IF(browsingContext->GetParent(),
+                loadInfo->GetExternalContentPolicyType() ==
+                    nsIContentPolicy::TYPE_SUBDOCUMENT);
+
+  nsLoadFlags loadFlags = loadState->CalculateChannelLoadFlags(
+      browsingContext, Nothing(), Nothing());
+
   nsresult rv;
-  return Open(loadState, cacheKey, channelId, TimeStamp::Now(), timing,
-              std::move(initialClientInfo), aOuterWindowId, false, Nothing(),
-              Nothing(), GetBrowsingContext()->GetContentParent()->OtherPid(),
-              &rv);
+  return Open(loadState, loadInfo, loadFlags, cacheKey, channelId,
+              TimeStamp::Now(), timing, std::move(initialClientInfo), false,
+              false, browsingContext->GetContentParent()->OtherPid(), &rv);
 }
 
-static void FireStateChange(DocumentLoadListener* aLoad, uint32_t aStateFlags,
-                            nsresult aStatus) {
-  nsCOMPtr<nsIChannel> request = aLoad->GetChannel();
+void DocumentLoadListener::FireStateChange(uint32_t aStateFlags,
+                                           nsresult aStatus) {
+  nsCOMPtr<nsIChannel> request = GetChannel();
   nsCOMPtr<nsIWebProgress> webProgress =
-      new RemoteWebProgress(aLoad->GetLoadType(), true, true);
+      new RemoteWebProgress(GetLoadType(), true, true);
 
-  RefPtr<CanonicalBrowsingContext> ctx = aLoad->GetBrowsingContext();
-  NS_DispatchToMainThread(
-      NS_NewRunnableFunction("DocumentLoadListener::FireStateChange", [=]() {
-        if (ctx && ctx->GetWebProgress()) {
-          ctx->GetWebProgress()->OnStateChange(webProgress, request,
-                                               aStateFlags, aStatus);
-        }
-      }));
+  RefPtr<BrowsingContextWebProgress> loadingWebProgress =
+      WebProgressForBrowsingContext(GetLoadingBrowsingContext());
+
+  if (loadingWebProgress) {
+    NS_DispatchToMainThread(
+        NS_NewRunnableFunction("DocumentLoadListener::FireStateChange", [=]() {
+          loadingWebProgress->OnStateChange(webProgress, request, aStateFlags,
+                                            aStatus);
+        }));
+  }
 }
 
 static void SetNavigating(CanonicalBrowsingContext* aBrowsingContext,
@@ -691,21 +850,19 @@
           // finished (and failed), and we should fire a state change to notify
           // observers. Normally the docshell would fire this, and it would get
           // filtered out by BrowserParent if needed.
-          FireStateChange(load,
-                          nsIWebProgressListener::STATE_STOP |
-                              nsIWebProgressListener::STATE_IS_WINDOW |
-                              nsIWebProgressListener::STATE_IS_NETWORK,
-                          rejectValue.mStatus);
+          load->FireStateChange(nsIWebProgressListener::STATE_STOP |
+                                    nsIWebProgressListener::STATE_IS_WINDOW |
+                                    nsIWebProgressListener::STATE_IS_NETWORK,
+                                rejectValue.mStatus);
         }
       });
 
-  FireStateChange(load,
-                  nsIWebProgressListener::STATE_START |
-                      nsIWebProgressListener::STATE_IS_DOCUMENT |
-                      nsIWebProgressListener::STATE_IS_REQUEST |
-                      nsIWebProgressListener::STATE_IS_WINDOW |
-                      nsIWebProgressListener::STATE_IS_NETWORK,
-                  NS_OK);
+  load->FireStateChange(nsIWebProgressListener::STATE_START |
+                            nsIWebProgressListener::STATE_IS_DOCUMENT |
+                            nsIWebProgressListener::STATE_IS_REQUEST |
+                            nsIWebProgressListener::STATE_IS_WINDOW |
+                            nsIWebProgressListener::STATE_IS_NETWORK,
+                        NS_OK);
   SetNavigating(aBrowsingContext, false);
   return true;
 }
@@ -793,7 +950,7 @@
     httpChannelImpl->SetWarningReporter(nullptr);
   }
 
-  if (auto* ctx = GetBrowsingContext()) {
+  if (auto* ctx = GetDocumentBrowsingContext()) {
     ctx->EndDocumentLoad(mDoingProcessSwitch);
   }
 }
@@ -887,7 +1044,7 @@
        this, int(aResult)));
 
   auto endDocumentLoad = MakeScopeExit([&]() {
-    if (auto* ctx = GetBrowsingContext()) {
+    if (auto* ctx = GetDocumentBrowsingContext()) {
       ctx->EndDocumentLoad(false);
     }
   });
@@ -1068,7 +1225,7 @@
 
   mChannel->Resume();
 
-  if (auto* ctx = GetBrowsingContext()) {
+  if (auto* ctx = GetDocumentBrowsingContext()) {
     ctx->EndDocumentLoad(mDoingProcessSwitch);
   }
 
@@ -1295,6 +1452,12 @@
 
   LOG(("DocumentLoadListener MaybeTriggerProcessSwitch [this=%p]", this));
 
+  // Don't switch process for <object>/<embed> loads.
+  if (mExternalContentPolicyType == nsIContentPolicy::TYPE_OBJECT) {
+    LOG(("Process Switch Abort: non-document load"));
+    return false;
+  }
+
   // Get the BrowsingContext which will be switching processes.
   RefPtr<CanonicalBrowsingContext> browsingContext =
       mParentChannelListener->GetBrowsingContext();
@@ -1550,14 +1713,24 @@
        "aRedirectFlags=%" PRIx32 ", aLoadFlags=%" PRIx32,
        this, aRedirectFlags, aLoadFlags));
 
-  // TODO(djg): Add the last URI visit to history if success. Is there a better
-  // place to handle this? Need access to the updated aLoadFlags.
-  nsresult status = NS_OK;
-  mChannel->GetStatus(&status);
-  bool updateGHistory =
-      nsDocShell::ShouldUpdateGlobalHistory(mLoadStateLoadType);
-  if (NS_SUCCEEDED(status) && updateGHistory && !net::ChannelIsPost(mChannel)) {
-    AddURIVisit(mChannel, aLoadFlags);
+  switch (mExternalContentPolicyType) {
+    case nsIContentPolicy::TYPE_DOCUMENT:
+    case nsIContentPolicy::TYPE_SUBDOCUMENT: {
+      // TODO(djg): Add the last URI visit to history if success. Is there a
+      // better place to handle this? Need access to the updated aLoadFlags.
+      nsresult status = NS_OK;
+      mChannel->GetStatus(&status);
+      bool updateGHistory =
+          nsDocShell::ShouldUpdateGlobalHistory(mLoadStateLoadType);
+      if (NS_SUCCEEDED(status) && updateGHistory &&
+          !net::ChannelIsPost(mChannel)) {
+        AddURIVisit(mChannel, aLoadFlags);
+      }
+      break;
+    }
+
+    default:
+      break;
   }
 
   // Register the new channel and obtain id for it
@@ -1703,7 +1876,9 @@
   MOZ_ALWAYS_SUCCEEDS(mChannel->GetLoadFlags(&newLoadFlags));
   // We're pulling our flags from the inner channel, which may not have this
   // flag set on it. This is the case when loading a 'view-source' channel.
-  newLoadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
+  if (mExternalContentPolicyType != nsIContentPolicy::TYPE_OBJECT) {
+    newLoadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
+  }
   if (!aDestinationProcess) {
     newLoadFlags |= nsIChannel::LOAD_REPLACE;
   }
@@ -1742,7 +1917,8 @@
 }
 
 void DocumentLoadListener::MaybeReportBlockedByURLClassifier(nsresult aStatus) {
-  if (!GetBrowsingContext() || GetBrowsingContext()->IsTop() ||
+  auto* browsingContext = GetDocumentBrowsingContext();
+  if (!browsingContext || browsingContext->IsTop() ||
       !StaticPrefs::privacy_trackingprotection_testing_report_blocked_node()) {
     return;
   }
@@ -1751,10 +1927,10 @@
     return;
   }
 
-  RefPtr<WindowGlobalParent> parent =
-      GetBrowsingContext()->GetParentWindowContext();
+  RefPtr<WindowGlobalParent> parent = browsingContext->GetParentWindowContext();
   if (parent) {
-    Unused << parent->SendAddBlockedFrameNodeByClassifier(GetBrowsingContext());
+    Unused << parent->SendAddBlockedFrameNodeByClassifier(
+        GetLoadingBrowsingContext());
   }
 }
 
@@ -1768,15 +1944,17 @@
   // succeed with fixup, so we don't need to check for it
   // here.
 
+  auto* loadingContext = GetLoadingBrowsingContext();
+
   bool isInitialDocument = true;
   if (WindowGlobalParent* currentWindow =
-          GetBrowsingContext()->GetCurrentWindowGlobal()) {
+          loadingContext->GetCurrentWindowGlobal()) {
     isInitialDocument = currentWindow->IsInitialDocument();
   }
 
   nsresult rv = nsDocShell::FilterStatusForErrorPage(
-      aStatus, mChannel, mLoadStateLoadType, GetBrowsingContext()->IsTop(),
-      GetBrowsingContext()->GetUseErrorPages(), isInitialDocument, nullptr);
+      aStatus, mChannel, mLoadStateLoadType, loadingContext->IsTop(),
+      loadingContext->GetUseErrorPages(), isInitialDocument, nullptr);
 
   // If filtering returned a failure code, then an error page will
   // be display for that code, so return true;
@@ -1784,14 +1962,17 @@
 }
 
 bool DocumentLoadListener::MaybeHandleLoadErrorWithURIFixup(nsresult aStatus) {
+  auto* bc = GetDocumentBrowsingContext();
+  if (!bc) {
+    return false;
+  }
+
   nsCOMPtr<nsIInputStream> newPostData;
   nsCOMPtr<nsIURI> newURI = nsDocShell::AttemptURIFixup(
-      mChannel, aStatus, mOriginalUriString, mLoadStateLoadType,
-      GetBrowsingContext()->IsTop(),
+      mChannel, aStatus, mOriginalUriString, mLoadStateLoadType, bc->IsTop(),
       mLoadStateLoadFlags &
           nsDocShell::INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP,
-      GetBrowsingContext()->UsePrivateBrowsing(), true,
-      getter_AddRefs(newPostData));
+      bc->UsePrivateBrowsing(), true, getter_AddRefs(newPostData));
   if (!newURI) {
     return false;
   }
@@ -1812,7 +1993,7 @@
 
   loadState->SetPostDataStream(newPostData);
 
-  GetBrowsingContext()->LoadURI(loadState, false);
+  bc->LoadURI(loadState, false);
   return true;
 }
 
@@ -1834,7 +2015,8 @@
   // might cancel the channel.
   nsContentSecurityUtils::PerformCSPFrameAncestorAndXFOCheck(mChannel);
 
-  if (!GetBrowsingContext() || GetBrowsingContext()->IsDiscarded()) {
+  auto* loadingContext = GetLoadingBrowsingContext();
+  if (!loadingContext || loadingContext->IsDiscarded()) {
     DisconnectListeners(NS_ERROR_UNEXPECTED, NS_ERROR_UNEXPECTED);
     return NS_ERROR_UNEXPECTED;
   }
@@ -1893,10 +2075,10 @@
 
       // If we're not going to process switch, then we must have an existing
       // window global, right?
-      MOZ_ASSERT(GetBrowsingContext()->GetCurrentWindowGlobal());
+      MOZ_ASSERT(loadingContext->GetCurrentWindowGlobal());
 
       RefPtr<BrowserParent> browserParent =
-          GetBrowsingContext()->GetCurrentWindowGlobal()->GetBrowserParent();
+          loadingContext->GetCurrentWindowGlobal()->GetBrowserParent();
 
       // This load has already started, so we want to suspend the start progress
       // events from the docshell from reaching the parent.
@@ -1908,14 +2090,13 @@
 
       // Use the current process ID to run the 'process switch' path and connect
       // the channel into the current process.
-      TriggerRedirectToRealChannel(
-          Some(GetBrowsingContext()->OwnerProcessId()));
+      TriggerRedirectToRealChannel(Some(loadingContext->OwnerProcessId()));
     } else {
       TriggerRedirectToRealChannel(Nothing());
     }
 
     // If we're not switching, then check if we're currently remote.
-    if (GetBrowsingContext() && GetBrowsingContext()->GetContentParent()) {
+    if (auto* bc = GetDocumentBrowsingContext(); bc && bc->GetContentParent()) {
       willBeRemote = true;
     }
   }
@@ -2006,7 +2187,7 @@
 NS_IMETHODIMP
 DocumentLoadListener::GetInterface(const nsIID& aIID, void** result) {
   RefPtr<CanonicalBrowsingContext> browsingContext =
-      mParentChannelListener->GetBrowsingContext();
+      GetDocumentBrowsingContext();
   if (aIID.Equals(NS_GET_IID(nsILoadContext)) && browsingContext) {
     browsingContext.forget(result);
     return NS_OK;
@@ -2080,7 +2261,8 @@
 
 NS_IMETHODIMP
 DocumentLoadListener::GetRemoteType(nsACString& aRemoteType) {
-  RefPtr<CanonicalBrowsingContext> browsingContext = GetBrowsingContext();
+  RefPtr<CanonicalBrowsingContext> browsingContext =
+      GetDocumentBrowsingContext();
   if (!browsingContext) {
     return NS_ERROR_UNEXPECTED;
   }
@@ -2160,7 +2342,7 @@
     return NS_OK;
   }
 
-  if (!net::ChannelIsPost(aOldChannel)) {
+  if (GetDocumentBrowsingContext() && !net::ChannelIsPost(aOldChannel)) {
     AddURIVisit(aOldChannel, 0);
 
     nsCOMPtr<nsIURI> oldURI;
@@ -2207,7 +2389,8 @@
       AntiTrackingUtils::MaybeGetDocumentURIBeingLoaded(mChannel);
 
   RefPtr<MozPromise<bool, bool, false>> promise;
-  nsCOMPtr<nsIWidget> widget = bc->GetParentProcessWidgetContaining();
+  nsCOMPtr<nsIWidget> widget =
+      bc ? bc->GetParentProcessWidgetContaining() : nullptr;
   RefPtr<nsWindow> window = nsWindow::From(widget);
 
   if (window) {
@@ -2283,16 +2466,17 @@
   nsCOMPtr<nsIWebProgress> webProgress =
       new RemoteWebProgress(mLoadStateLoadType, true, true);
 
-  RefPtr<CanonicalBrowsingContext> ctx = GetBrowsingContext();
+  RefPtr<BrowsingContextWebProgress> topWebProgress =
+      WebProgressForBrowsingContext(GetTopBrowsingContext());
   const nsString message(aStatusArg);
 
-  NS_DispatchToMainThread(
-      NS_NewRunnableFunction("DocumentLoadListener::FireStateChange", [=]() {
-        if (ctx && ctx->Top()->GetWebProgress()) {
-          ctx->Top()->GetWebProgress()->OnStatusChange(webProgress, channel,
-                                                       aStatus, message.get());
-        }
-      }));
+  if (topWebProgress) {
+    NS_DispatchToMainThread(
+        NS_NewRunnableFunction("DocumentLoadListener::OnStatus", [=]() {
+          topWebProgress->OnStatusChange(webProgress, channel, aStatus,
+                                         message.get());
+        }));
+  }
   return NS_OK;
 }
 