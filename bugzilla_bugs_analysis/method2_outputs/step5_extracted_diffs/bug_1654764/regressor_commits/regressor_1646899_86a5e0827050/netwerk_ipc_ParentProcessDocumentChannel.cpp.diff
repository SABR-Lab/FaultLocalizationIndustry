# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/ParentProcessDocumentChannel.cpp
# Commit: 86a5e0827050
# Full Hash: 86a5e0827050e262bb713d6910a8c1d6e6ec3738
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-07-13 09:51:22
# Regressor Bug: 1646899
# File Overlap Count: 1
# Description:
#   Bug 1646899 - P4: Handle object & embed via DocumentChannel. r=mattwoodrow,jya
#   
#   Pass internal content policy type to DLL and switch behavior depending on type
#   being loaded. This implementation immediately redirects channel back to the
#   content process for further handling.
# ==============================================================================

diff -r d2fd0f955e24 -r 86a5e0827050 netwerk/ipc/ParentProcessDocumentChannel.cpp
--- a/netwerk/ipc/ParentProcessDocumentChannel.cpp	Mon Jul 13 00:48:54 2020 +0000
+++ b/netwerk/ipc/ParentProcessDocumentChannel.cpp	Mon Jul 13 00:48:57 2020 +0000
@@ -129,8 +129,10 @@
 NS_IMETHODIMP ParentProcessDocumentChannel::AsyncOpen(
     nsIStreamListener* aListener) {
   LOG(("ParentProcessDocumentChannel AsyncOpen [this=%p]", this));
-  mDocumentLoadListener = new DocumentLoadListener(
-      GetDocShell()->GetBrowsingContext()->Canonical());
+  auto docShell = RefPtr<nsDocShell>(GetDocShell());
+  MOZ_ASSERT(docShell);
+  mDocumentLoadListener = MakeRefPtr<DocumentLoadListener>(
+      docShell->GetBrowsingContext()->Canonical());
   LOG(("Created PPDocumentChannel with listener=%p",
        mDocumentLoadListener.get()));
 
@@ -144,18 +146,47 @@
 
   gHttpHandler->OnOpeningDocumentRequest(this);
 
-  GetDocShell()->GetBrowsingContext()->SetCurrentLoadIdentifier(
-      Some(mLoadState->GetLoadIdentifier()));
+  switch (mLoadInfo->GetExternalContentPolicyType()) {
+    case nsIContentPolicy::TYPE_DOCUMENT:
+    case nsIContentPolicy::TYPE_SUBDOCUMENT:
+      GetDocShell()->GetBrowsingContext()->SetCurrentLoadIdentifier(
+          Some(mLoadState->GetLoadIdentifier()));
+      break;
+
+    default:
+      break;
+  }
 
   nsresult rv = NS_OK;
   Maybe<dom::ClientInfo> initialClientInfo = mInitialClientInfo;
-  auto promise = mDocumentLoadListener->Open(
-      mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
-      std::move(initialClientInfo), GetDocShell()->GetOuterWindowID(),
-      GetDocShell()
-          ->GetBrowsingContext()
-          ->HasValidTransientUserGestureActivation(),
-      Some(mUriModified), Some(mIsXFOError), 0 /* ProcessId */, &rv);
+
+  const bool hasValidTransientUserGestureActivation =
+      docShell->GetBrowsingContext()->HasValidTransientUserGestureActivation();
+
+  RefPtr<DocumentLoadListener::OpenPromise> promise;
+  switch (mLoadInfo->GetExternalContentPolicyType()) {
+    case nsIContentPolicy::TYPE_DOCUMENT:
+    case nsIContentPolicy::TYPE_SUBDOCUMENT:
+      promise = mDocumentLoadListener->OpenDocument(
+          mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
+          std::move(initialClientInfo), docShell->GetOuterWindowID(),
+          hasValidTransientUserGestureActivation, Some(mUriModified),
+          Some(mIsXFOError), 0 /* ProcessId */, &rv);
+      break;
+
+    case nsIContentPolicy::TYPE_OBJECT:
+      promise = mDocumentLoadListener->OpenObject(
+          mLoadState, mCacheKey, Some(mChannelId), mAsyncOpenTime, mTiming,
+          std::move(initialClientInfo), InnerWindowIDForExtantDoc(docShell),
+          mLoadFlags, mLoadInfo->InternalContentPolicyType(),
+          hasValidTransientUserGestureActivation,
+          UserActivation::IsHandlingUserInput(), 0 /* ProcessId */, &rv);
+      break;
+
+    default:
+      MOZ_CRASH("Unhandled content policy type.");
+  }
+
   if (NS_FAILED(rv)) {
     MOZ_ASSERT(!promise);
     mDocumentLoadListener = nullptr;
