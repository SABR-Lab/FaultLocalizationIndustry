# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/batch.rs
# Commit: c19d6d676868
# Full Hash: c19d6d6768688fb627256cf2b871052f6dd7e9e2
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2020-07-17 09:39:07
# Regressor Bug: 1647918
# File Overlap Count: 1
# Description:
#   Bug 1647918 - Refactor the clip task assignment logic in WR r=gw
#   
#   There were cases where the clip task generation considered a primitive
#   to be invisible, while the rest of the code proceeded with an assumption
#   that the clip task was created.
# ==============================================================================

diff -r 3baa645a131c -r c19d6d676868 gfx/wr/webrender/src/batch.rs
--- a/gfx/wr/webrender/src/batch.rs	Thu Jul 16 22:31:29 2020 +0000
+++ b/gfx/wr/webrender/src/batch.rs	Sun Jul 12 20:33:01 2020 +0000
@@ -27,7 +27,7 @@
 use crate::render_task::RenderTaskAddress;
 use crate::renderer::{BlendMode, ImageBufferKind, ShaderColorMode};
 use crate::renderer::{BLOCKS_PER_UV_RECT, MAX_VERTEX_TEXTURE_WIDTH};
-use crate::resource_cache::{CacheItem, GlyphFetchResult, ImageRequest, ResourceCache};
+use crate::resource_cache::{CacheItem, GlyphFetchResult, ImageProperties, ImageRequest, ResourceCache};
 use crate::space::SpaceMapper;
 use crate::visibility::{PrimitiveVisibilityIndex, PrimitiveVisibilityMask, PrimitiveVisibility, PrimitiveVisibilityFlags};
 use smallvec::SmallVec;
@@ -879,6 +879,9 @@
         #[cfg(debug_assertions)] //TODO: why is this needed?
         debug_assert_eq!(prim_instance.prepared_frame_id, render_tasks.frame_id());
 
+        assert_ne!(prim_instance.visibility_info, PrimitiveVisibilityIndex::INVALID,
+            "Invisible primitive {:?} shouldn't be added to the batch", prim_instance);
+
         let is_chased = prim_instance.is_chased();
 
         let transform_id = transforms
@@ -2292,6 +2295,13 @@
                 }.encode();
 
                 if image_instance.visible_tiles.is_empty() {
+                    if cfg!(debug_assertions) {
+                        match ctx.resource_cache.get_image_properties(request.key) {
+                            Some(ImageProperties { tiling: None, .. }) => (),
+                            other => panic!("Non-tiled image with no visible images detected! Properties {:?}", other),
+                        }
+                    }
+
                     let cache_item = match image_data.source {
                         ImageSource::Default => {
                             resolve_image(