# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/printing/nsPrintJob.cpp
# Commit: 136eaa3a0068
# Full Hash: 136eaa3a0068bedf81db704fa077a9fc65f46279
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-07-23 03:20:25
# Regressor Bug: 1648064
# File Overlap Count: 1
# Description:
#   Bug 1648064 - Make print preview documents wait properly for the document to be loaded. r=smaug
#   
#   Otherwise my test fails intermittently on CI. We need to block on all
#   the load blockers because stuff like responsive images doesn't fire the
#   load directly but they do that as a micro task (blocking the load
# ==============================================================================

diff -r b38b31524349 -r 136eaa3a0068 layout/printing/nsPrintJob.cpp
--- a/layout/printing/nsPrintJob.cpp	Wed Jul 22 20:29:08 2020 +0000
+++ b/layout/printing/nsPrintJob.cpp	Wed Jul 22 20:29:16 2020 +0000
@@ -6,6 +6,7 @@
 
 #include "nsPrintJob.h"
 
+#include "nsDebug.h"
 #include "nsDocShell.h"
 #include "nsReadableUtils.h"
 #include "nsCRT.h"
@@ -16,6 +17,7 @@
 #include "mozilla/dom/BrowsingContext.h"
 #include "mozilla/dom/Selection.h"
 #include "mozilla/dom/CustomEvent.h"
+#include "mozilla/dom/HTMLCanvasElement.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/StaticPrefs_print.h"
 #include "mozilla/Telemetry.h"
@@ -24,6 +26,8 @@
 #include "nsIScriptGlobalObject.h"
 #include "nsIStringBundle.h"
 #include "nsPIDOMWindow.h"
+#include "nsPrintData.h"
+#include "nsPrintObject.h"
 #include "nsIDocShell.h"
 #include "nsIURI.h"
 #include "nsITextToSubURI.h"
@@ -910,14 +914,13 @@
   }
 
   // Attach progressListener to catch network requests.
+  mDidLoadDataForPrinting = false;
+
   nsCOMPtr<nsIWebProgress> webProgress =
       do_QueryInterface(printData->mPrintObject->mDocShell);
   webProgress->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
                                    nsIWebProgress::NOTIFY_STATE_REQUEST);
 
-  mLoadCounter = 0;
-  mDidLoadDataForPrinting = false;
-
   if (mIsCreatingPrintPreview) {
     bool notifyOnInit = false;
     ShowPrintProgress(false, notifyOnInit);
@@ -1681,18 +1684,33 @@
   // Guarantee that mPrt->mPrintObject won't be deleted.  It's owned by mPrt.
   // So, we should grab it with local variable.
   RefPtr<nsPrintData> printData = mPrt;
+
   rv = ReflowDocList(printData->mPrintObject, DoSetPixelScale());
   NS_ENSURE_SUCCESS(rv, rv);
 
   FirePrintPreviewUpdateEvent();
 
-  if (mLoadCounter == 0) {
-    ResumePrintAfterResourcesLoaded(aHandleError);
-  }
+  MaybeResumePrintAfterResourcesLoaded(aHandleError);
   return rv;
 }
 
-nsresult nsPrintJob::ResumePrintAfterResourcesLoaded(bool aCleanupOnError) {
+bool nsPrintJob::ShouldResumePrint() const {
+  Document* doc = mPrt->mPrintObject->mDocument;
+  MOZ_ASSERT(doc);
+  NS_ENSURE_TRUE(doc, true);
+  nsCOMPtr<nsILoadGroup> lg = doc->GetDocumentLoadGroup();
+  NS_ENSURE_TRUE(lg, true);
+  bool pending = false;
+  nsresult rv = lg->IsPending(&pending);
+  NS_ENSURE_SUCCESS(rv, true);
+  return !pending;
+}
+
+nsresult nsPrintJob::MaybeResumePrintAfterResourcesLoaded(bool aCleanupOnError) {
+  if (!ShouldResumePrint()) {
+    mDidLoadDataForPrinting = true;
+    return NS_OK;
+  }
   // If Destroy() has already been called, mPtr is nullptr.  Then, the instance
   // needs to do nothing anymore in this method.
   // Note: it shouldn't be possible for mPrt->mPrintObject to be null; we
@@ -1733,22 +1751,9 @@
 MOZ_CAN_RUN_SCRIPT_BOUNDARY NS_IMETHODIMP
 nsPrintJob::OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
                           uint32_t aStateFlags, nsresult aStatus) {
-  nsAutoCString name;
-  aRequest->GetName(name);
-  if (name.EqualsLiteral("about:document-onload-blocker")) {
-    return NS_OK;
-  }
-  if (aStateFlags & STATE_START) {
-    ++mLoadCounter;
-  } else if (aStateFlags & STATE_STOP) {
-    mDidLoadDataForPrinting = true;
-    --mLoadCounter;
-
-    // If all resources are loaded, then do a small timeout and if there
-    // are still no new requests, then another reflow.
-    if (mLoadCounter == 0) {
-      ResumePrintAfterResourcesLoaded(/* aCleanupOnError */ true);
-    }
+  if (aStateFlags & STATE_STOP) {
+    // If all resources are loaded, then finish and reflow.
+    MaybeResumePrintAfterResourcesLoaded(/* aCleanupOnError */ true);
   }
   return NS_OK;
 }