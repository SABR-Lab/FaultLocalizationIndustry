# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentChannelParent.cpp
# Commit: 28bca5c5b8b4
# Full Hash: 28bca5c5b8b4d5a4f8e6ecaf621738ad955c3121
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-06-09 15:16:49
# Regressor Bug: 1641737
# File Overlap Count: 2
# Description:
#   Bug 1641737 - P2. Use MozPromise with DocumentLoadListener and remove cycle. r=mattwoodrow.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D78179
# ==============================================================================

diff -r 0296d0f6c1d1 -r 28bca5c5b8b4 netwerk/ipc/DocumentChannelParent.cpp
--- a/netwerk/ipc/DocumentChannelParent.cpp	Tue Jun 09 07:23:29 2020 +0000
+++ b/netwerk/ipc/DocumentChannelParent.cpp	Tue Jun 09 10:11:11 2020 +0000
@@ -6,6 +6,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "DocumentChannelParent.h"
+
 #include "mozilla/dom/BrowserParent.h"
 #include "mozilla/dom/CanonicalBrowsingContext.h"
 #include "mozilla/dom/ClientInfo.h"
@@ -34,28 +35,58 @@
   LOG(("DocumentChannelParent Init [this=%p, uri=%s]", this,
        loadState->URI()->GetSpecOrDefault().get()));
 
+  RefPtr<DocumentLoadListener::OpenPromise> promise;
   if (loadState->GetLoadIdentifier()) {
-    mParent = DocumentLoadListener::ClaimParentLoad(
-        loadState->GetLoadIdentifier(), this);
-    return !!mParent;
+    promise = DocumentLoadListener::ClaimParentLoad(
+        getter_AddRefs(mDocumentLoadListener), loadState->GetLoadIdentifier());
+    if (!promise) {
+      return false;
+    }
+  } else {
+    mDocumentLoadListener = new DocumentLoadListener(aContext);
+
+    Maybe<ClientInfo> clientInfo;
+    if (aArgs.initialClientInfo().isSome()) {
+      clientInfo.emplace(ClientInfo(aArgs.initialClientInfo().ref()));
+    }
+
+    nsresult rv = NS_ERROR_UNEXPECTED;
+    promise = mDocumentLoadListener->Open(
+        loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
+        aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
+        std::move(clientInfo), aArgs.outerWindowId(),
+        aArgs.hasValidTransientUserAction(), Some(aArgs.uriModified()),
+        Some(aArgs.isXFOError()), IProtocol::OtherPid(), &rv);
+    if (NS_FAILED(rv)) {
+      MOZ_ASSERT(!promise);
+      return SendFailedAsyncOpen(rv);
+    }
   }
 
-  mParent = new DocumentLoadListener(aContext, this);
-
-  Maybe<ClientInfo> clientInfo;
-  if (aArgs.initialClientInfo().isSome()) {
-    clientInfo.emplace(ClientInfo(aArgs.initialClientInfo().ref()));
-  }
-
-  nsresult rv = NS_ERROR_UNEXPECTED;
-  if (!mParent->Open(loadState, aArgs.cacheKey(), Some(aArgs.channelId()),
-                     aArgs.asyncOpenTime(), aArgs.timing().refOr(nullptr),
-                     std::move(clientInfo), aArgs.outerWindowId(),
-                     aArgs.hasValidTransientUserAction(),
-                     Some(aArgs.uriModified()), Some(aArgs.isXFOError()),
-                     &rv)) {
-    return SendFailedAsyncOpen(rv);
-  }
+  RefPtr<DocumentChannelParent> self = this;
+  promise->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
+      [self](DocumentLoadListener::OpenPromiseSucceededType&& aResolveValue) {
+        // The DLL is waiting for us to resolve the
+        // PDocumentChannel::RedirectToRealChannelPromise given as parameter.
+        auto promise = self->RedirectToRealChannel(
+            std::move(aResolveValue.mStreamFilterEndpoints),
+            aResolveValue.mRedirectFlags, aResolveValue.mLoadFlags);
+        // We chain the promise the DLL is waiting on to the one returned by
+        // RedirectToRealChannel. As soon as the promise returned is resolved
+        // or rejected, so will the DLL's promise.
+        promise->ChainTo(aResolveValue.mPromise.forget(), __func__);
+        self->mDocumentLoadListener = nullptr;
+      },
+      [self](DocumentLoadListener::OpenPromiseFailedType&& aRejectValue) {
+        if (aRejectValue.mStatus == NS_ERROR_DOCSHELL_DYING) {
+          Unused << self->SendDeleteSelf();
+          return;
+        }
+        Unused << self->SendDisconnectChildListeners(
+            aRejectValue.mStatus, aRejectValue.mLoadGroupStatus);
+        self->mDocumentLoadListener = nullptr;
+      });
 
   return true;
 }
@@ -65,12 +96,12 @@
     nsTArray<ipc::Endpoint<extensions::PStreamFilterParent>>&&
         aStreamFilterEndpoints,
     uint32_t aRedirectFlags, uint32_t aLoadFlags) {
-  if (!CanSend() || !mParent) {
+  if (!CanSend()) {
     return PDocumentChannelParent::RedirectToRealChannelPromise::
         CreateAndReject(ResponseRejectReason::ChannelClosed, __func__);
   }
   RedirectToRealChannelArgs args;
-  mParent->SerializeRedirectData(
+  mDocumentLoadListener->SerializeRedirectData(
       args, false, aRedirectFlags, aLoadFlags,
       static_cast<ContentParent*>(Manager()->Manager()));
   return SendRedirectToRealChannel(args, std::move(aStreamFilterEndpoints));