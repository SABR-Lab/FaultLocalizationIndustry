# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.h
# Commit: 28bca5c5b8b4
# Full Hash: 28bca5c5b8b4d5a4f8e6ecaf621738ad955c3121
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-06-09 15:16:49
# Regressor Bug: 1641737
# File Overlap Count: 2
# Description:
#   Bug 1641737 - P2. Use MozPromise with DocumentLoadListener and remove cycle. r=mattwoodrow.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D78179
# ==============================================================================

diff -r 0296d0f6c1d1 -r 28bca5c5b8b4 netwerk/ipc/DocumentLoadListener.h
--- a/netwerk/ipc/DocumentLoadListener.h	Tue Jun 09 07:23:29 2020 +0000
+++ b/netwerk/ipc/DocumentLoadListener.h	Tue Jun 09 10:11:11 2020 +0000
@@ -9,18 +9,17 @@
 
 #include "mozilla/MozPromise.h"
 #include "mozilla/Variant.h"
+#include "mozilla/dom/SessionHistoryEntry.h"
 #include "mozilla/net/NeckoCommon.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/net/PDocumentChannelParent.h"
 #include "mozilla/net/ParentChannelListener.h"
-#include "mozilla/net/ADocumentChannelBridge.h"
-#include "mozilla/dom/SessionHistoryEntry.h"
 #include "nsDOMNavigationTiming.h"
 #include "nsIInterfaceRequestor.h"
+#include "nsIMultiPartChannel.h"
 #include "nsIParentChannel.h"
 #include "nsIParentRedirectingChannel.h"
 #include "nsIRedirectResultListener.h"
-#include "nsIMultiPartChannel.h"
 
 #define DOCUMENT_LOAD_LISTENER_IID                   \
   {                                                  \
@@ -91,21 +90,48 @@
                              public HttpChannelSecurityWarningReporter,
                              public nsIMultiPartChannelListener {
  public:
-  explicit DocumentLoadListener(dom::CanonicalBrowsingContext* aBrowsingContext,
-                                ADocumentChannelBridge* aBridge);
+  explicit DocumentLoadListener(
+      dom::CanonicalBrowsingContext* aBrowsingContext);
+
+  struct OpenPromiseSucceededType {
+    nsTArray<ipc::Endpoint<extensions::PStreamFilterParent>>
+        mStreamFilterEndpoints;
+    uint32_t mRedirectFlags;
+    uint32_t mLoadFlags;
+    RefPtr<PDocumentChannelParent::RedirectToRealChannelPromise::Private>
+        mPromise;
+  };
+  struct OpenPromiseFailedType {
+    nsresult mStatus;
+    nsresult mLoadGroupStatus;
+  };
+
+  typedef MozPromise<OpenPromiseSucceededType, OpenPromiseFailedType,
+                     true /* isExclusive */>
+      OpenPromise;
 
   // Creates the channel, and then calls AsyncOpen on it.
-  bool Open(nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
-            const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
-            nsDOMNavigationTiming* aTiming, Maybe<dom::ClientInfo>&& aInfo,
-            uint64_t aOuterWindowId, bool aHasGesture, Maybe<bool> aUriModified,
-            Maybe<bool> aIsXFOError, nsresult* aRv);
+  // The DocumentLoadListener will require additional process from the consumer
+  // in order to complete the redirect to the end channel. This is done by
+  // returning a RedirectToRealChannelPromise and then waiting for it to be
+  // resolved or rejected accordingly.
+  // Once that promise is resolved; the consumer no longer needs to hold a
+  // reference to the DocumentLoadListener nor will the consumer required to be
+  // used again.
+  RefPtr<OpenPromise> Open(nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
+                           const Maybe<uint64_t>& aChannelId,
+                           const TimeStamp& aAsyncOpenTime,
+                           nsDOMNavigationTiming* aTiming,
+                           Maybe<dom::ClientInfo>&& aInfo,
+                           uint64_t aOuterWindowId, bool aHasGesture,
+                           Maybe<bool> aUriModified, Maybe<bool> aIsXFOError,
+                           base::ProcessId aPid, nsresult* aRv);
 
   // Creates a DocumentLoadListener directly in the parent process without
   // an associated DocumentChannelBridge.
   // If successful it registers a unique identifier (return in aOutIdent) to
-  // keep it alive until a future bridge can attach to it, or we fail and clean
-  // up.
+  // keep it alive until a future bridge can attach to it, or we fail and
+  // clean up.
   static bool OpenFromParent(dom::CanonicalBrowsingContext* aBrowsingContext,
                              nsDocShellLoadState* aLoadState,
                              uint64_t aOuterWindowId, uint32_t* aOutIdent);
@@ -116,9 +142,12 @@
   static void CleanupParentLoadAttempt(uint32_t aLoadIdent);
 
   // Looks up aLoadIdent to find the associated, cleans up the registration
-  // and attaches aBridge as the listener.
-  static already_AddRefed<DocumentLoadListener> ClaimParentLoad(
-      uint32_t aLoadIdent, ADocumentChannelBridge* aBridge);
+  static RefPtr<OpenPromise> ClaimParentLoad(DocumentLoadListener** aListener,
+                                             uint32_t aLoadIdent);
+
+  // Called by the DocumentChannelParent if actor got destroyed or the parent
+  // channel got deleted.
+  void Abort();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIREQUESTOBSERVER
@@ -139,6 +168,7 @@
 
   NS_DECLARE_STATIC_IID_ACCESSOR(DOCUMENT_LOAD_LISTENER_IID)
 
+  // Called by the DocumentChannel if cancelled.
   void Cancel(const nsresult& status);
 
   nsIChannel* GetChannel() const { return mChannel; }
@@ -176,27 +206,16 @@
     return NS_OK;
   }
 
-  // Called by the bridge when it disconnects, so that we can drop
-  // our reference to it.
-  void DocumentChannelBridgeDisconnected();
-
-  void DisconnectChildListeners(nsresult aStatus, nsresult aLoadGroupStatus);
-
   base::ProcessId OtherPid() const {
-    if (mDocumentChannelBridge) {
-      return mDocumentChannelBridge->OtherPid();
-    }
     if (mPendingDocumentChannelBridgeProcess) {
       return *mPendingDocumentChannelBridgeProcess;
     }
-    return 0;
+    return mOtherPid;
   }
 
   [[nodiscard]] RefPtr<ChildEndpointPromise> AttachStreamFilter(
       base::ProcessId aChildProcessId);
 
-  using ParentEndpoint = ipc::Endpoint<extensions::PStreamFilterParent>;
-
   // Serializes all data needed to setup the new replacement channel
   // in the content process into the RedirectToRealChannelArgs struct.
   void SerializeRedirectData(RedirectToRealChannelArgs& aArgs,
@@ -209,9 +228,13 @@
                        base::ProcessId aPendingBridgeProcess);
   virtual ~DocumentLoadListener();
 
+ private:
+  friend class ParentProcessDocumentOpenInfo;
+  // Will reject the promise to notify the DLL consumer that we are done.
+  void DisconnectListeners(nsresult aStatus, nsresult aLoadGroupStatus);
   // Called when we were created without a document channel bridge,
   // and now it has been created and attached.
-  void NotifyBridgeConnected(ADocumentChannelBridge* aBridge);
+  void NotifyBridgeConnected();
 
   // Called when we were created without a document channel bridge,
   // and creation has failed, and won't ever be attached.
@@ -221,9 +244,7 @@
   // waiting for a pending one if necessary.
   // If we've failed to create a bridge, or a bridge has already been
   // detached then rejects.
-  typedef MozPromise<RefPtr<ADocumentChannelBridge>, bool, false>
-      EnsureBridgePromise;
-  RefPtr<EnsureBridgePromise> EnsureBridge();
+  RefPtr<GenericPromise> EnsureBridge();
 
   // Initiates the switch from DocumentChannel to the real protocol-specific
   // channel, and ensures that RedirectToRealChannelFinished is called when
@@ -252,6 +273,7 @@
   // A helper for TriggerRedirectToRealChannel that abstracts over
   // the same-process and cross-process switch cases and returns
   // a single promise to wait on.
+  using ParentEndpoint = ipc::Endpoint<extensions::PStreamFilterParent>;
   RefPtr<PDocumentChannelParent::RedirectToRealChannelPromise>
   RedirectToRealChannel(uint32_t aRedirectFlags, uint32_t aLoadFlags,
                         const Maybe<uint64_t>& aDestinationProcess,
@@ -268,6 +290,8 @@
   bool HasCrossOriginOpenerPolicyMismatch() const;
   void ApplyPendingFunctions(nsISupports* aChannel) const;
 
+  void Disconnect();
+
   // This defines a variant that describes all the attribute setters (and their
   // parameters) from nsIParentChannel
   //
@@ -366,12 +390,6 @@
   // replaces us.
   RefPtr<ParentChannelListener> mParentChannelListener;
 
-  // The bridge to the nsIChannel in the originating docshell.
-  // This reference forms a cycle with the bridge, and we expect
-  // the bridge to call DisonnectDocumentChannelBridge when it
-  // shuts down to break this.
-  RefPtr<ADocumentChannelBridge> mDocumentChannelBridge;
-
   // If we were created without a bridge, then this is set
   // to Some() with the process id of the content process
   // that will be creating our bridge soon.
@@ -379,7 +397,7 @@
 
   // Holds a promise for callers that want to wait on the document
   // channel bridge becoming available.
-  MozPromiseHolder<EnsureBridgePromise> mBridgePromise;
+  MozPromiseHolder<GenericPromise> mBridgePromise;
 
   // The original URI of the current channel. If there are redirects,
   // then the value on the channel gets overwritten with the original
@@ -439,6 +457,17 @@
 
   // True if cancelled.
   bool mCancelled = false;
+
+  // The process id of the content process that we are being called from
+  // or 0 initiated from a parent process load.
+  base::ProcessId mOtherPid = 0;
+
+  void RejectOpenPromiseIfExists(nsresult aStatus, nsresult aLoadGroupStatus,
+                                 const char* aLocation) {
+    mOpenPromise.RejectIfExists(
+        OpenPromiseFailedType({aStatus, aLoadGroupStatus}), aLocation);
+  }
+  MozPromiseHolder<OpenPromise> mOpenPromise;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(DocumentLoadListener, DOCUMENT_LOAD_LISTENER_IID)