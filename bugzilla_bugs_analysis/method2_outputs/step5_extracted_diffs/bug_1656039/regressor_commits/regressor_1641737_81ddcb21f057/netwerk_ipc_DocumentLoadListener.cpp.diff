# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.cpp
# Commit: 81ddcb21f057
# Full Hash: 81ddcb21f05754f2b3b4e581e5d4295fada1cc2c
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-06-12 14:56:55
# Regressor Bug: 1641737
# File Overlap Count: 2
# Description:
#   Bug 1641737 - P2. Use MozPromise with DocumentLoadListener and remove cycle. r=mattwoodrow.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D78179
# ==============================================================================

diff -r 02f45f660107 -r 81ddcb21f057 netwerk/ipc/DocumentLoadListener.cpp
--- a/netwerk/ipc/DocumentLoadListener.cpp	Fri Jun 12 05:56:26 2020 +0000
+++ b/netwerk/ipc/DocumentLoadListener.cpp	Fri Jun 12 05:56:28 2020 +0000
@@ -30,9 +30,9 @@
 #include "nsDocShellLoadTypes.h"
 #include "nsExternalHelperAppService.h"
 #include "nsHttpChannel.h"
-#include "nsIHttpChannelInternal.h"
 #include "nsIBrowser.h"
 #include "nsIE10SUtils.h"
+#include "nsIHttpChannelInternal.h"
 #include "nsIStreamConverterService.h"
 #include "nsIViewSourceChannel.h"
 #include "nsImportModule.h"
@@ -221,7 +221,7 @@
     // reference cycle.
     RefPtr<DocumentLoadListener> doc = do_GetInterface(ToSupports(mListener));
     MOZ_ASSERT(doc);
-    doc->DisconnectChildListeners(NS_BINDING_RETARGETED, NS_OK);
+    doc->DisconnectListeners(NS_BINDING_RETARGETED, NS_OK);
     mListener->SetListenerAfterRedirect(nullptr);
   }
 
@@ -258,9 +258,7 @@
 NS_INTERFACE_MAP_END
 
 DocumentLoadListener::DocumentLoadListener(
-    CanonicalBrowsingContext* aBrowsingContext, ADocumentChannelBridge* aBridge)
-    : mDocumentChannelBridge(aBridge) {
-  MOZ_ASSERT(aBridge);
+    CanonicalBrowsingContext* aBrowsingContext) {
   LOG(("DocumentLoadListener ctor [this=%p]", this));
   mParentChannelListener = new ParentChannelListener(
       this, aBrowsingContext, aBrowsingContext->UsePrivateBrowsing());
@@ -373,12 +371,13 @@
   return mParentChannelListener->GetBrowsingContext();
 }
 
-bool DocumentLoadListener::Open(
+auto DocumentLoadListener::Open(
     nsDocShellLoadState* aLoadState, uint32_t aCacheKey,
     const Maybe<uint64_t>& aChannelId, const TimeStamp& aAsyncOpenTime,
     nsDOMNavigationTiming* aTiming, Maybe<ClientInfo>&& aInfo,
     uint64_t aOuterWindowId, bool aHasGesture, Maybe<bool> aUriModified,
-    Maybe<bool> aIsXFOError, nsresult* aRv) {
+    Maybe<bool> aIsXFOError, base::ProcessId aPid, nsresult* aRv)
+    -> RefPtr<OpenPromise> {
   LOG(("DocumentLoadListener Open [this=%p, uri=%s]", this,
        aLoadState->URI()->GetSpecOrDefault().get()));
   RefPtr<CanonicalBrowsingContext> browsingContext =
@@ -404,7 +403,7 @@
           nullptr, attrs, loadFlags, aCacheKey, *aRv,
           getter_AddRefs(mChannel))) {
     mParentChannelListener = nullptr;
-    return false;
+    return nullptr;
   }
 
   nsCOMPtr<nsIURI> uriBeingLoaded =
@@ -455,7 +454,7 @@
   // we want the original request so that we get different ones for
   // each part of a multipart channel.
   nsCOMPtr<nsIViewSourceChannel> viewSourceChannel;
-  if (OtherPid() && (viewSourceChannel = do_QueryInterface(mChannel))) {
+  if (aPid && (viewSourceChannel = do_QueryInterface(mChannel))) {
     viewSourceChannel->SetReplaceRequest(false);
   }
 
@@ -501,12 +500,12 @@
           if (aValue.IsResolve()) {
             bool handled = aValue.ResolveValue();
             if (handled) {
-              self->DisconnectChildListeners(NS_ERROR_ABORT, NS_ERROR_ABORT);
+              self->DisconnectListeners(NS_ERROR_ABORT, NS_ERROR_ABORT);
               mParentChannelListener = nullptr;
             } else {
               nsresult rv = mChannel->AsyncOpen(openInfo);
               if (NS_FAILED(rv)) {
-                self->DisconnectChildListeners(rv, rv);
+                self->DisconnectListeners(rv, rv);
                 mParentChannelListener = nullptr;
               }
             }
@@ -518,10 +517,11 @@
     *aRv = mChannel->AsyncOpen(openInfo);
     if (NS_FAILED(*aRv)) {
       mParentChannelListener = nullptr;
-      return false;
+      return nullptr;
     }
   }
 
+  mOtherPid = aPid;
   mChannelCreationURI = aLoadState->URI();
   mLoadStateLoadFlags = aLoadState->LoadFlags();
   mLoadStateLoadType = aLoadState->LoadType();
@@ -537,7 +537,9 @@
   if (auto* ctx = GetBrowsingContext()) {
     ctx->StartDocumentLoad(this);
   }
-  return true;
+
+  *aRv = NS_OK;
+  return mOpenPromise.Ensure(__func__);
 }
 
 /* static */
@@ -609,11 +611,12 @@
       aBrowsingContext, aBrowsingContext->GetContentParent()->OtherPid());
 
   nsresult rv;
-  bool result =
+  auto promise =
       listener->Open(loadState, cacheKey, channelId, TimeStamp::Now(), timing,
                      std::move(initialClientInfo), aOuterWindowId, false,
-                     Nothing(), Nothing(), &rv);
-  if (result) {
+                     Nothing(), Nothing(), 0, &rv);
+  if (promise) {
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
     // Create an entry in the redirect channel registrar to
     // allocate an identifier for this load.
     nsCOMPtr<nsIRedirectChannelRegistrar> registrar =
@@ -624,7 +627,7 @@
     rv = registrar->LinkChannels(*aOutIdent, listener, nullptr);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
-  return result;
+  return !!promise;
 }
 
 void DocumentLoadListener::CleanupParentLoadAttempt(uint32_t aLoadIdent) {
@@ -644,8 +647,9 @@
   registrar->DeregisterChannels(aLoadIdent);
 }
 
-already_AddRefed<DocumentLoadListener> DocumentLoadListener::ClaimParentLoad(
-    uint32_t aLoadIdent, ADocumentChannelBridge* aBridge) {
+auto DocumentLoadListener::ClaimParentLoad(DocumentLoadListener** aListener,
+                                           uint32_t aLoadIdent)
+    -> RefPtr<OpenPromise> {
   nsCOMPtr<nsIRedirectChannelRegistrar> registrar =
       RedirectChannelRegistrar::GetOrCreate();
 
@@ -654,46 +658,44 @@
   RefPtr<DocumentLoadListener> loadListener = do_QueryObject(parentChannel);
   registrar->DeregisterChannels(aLoadIdent);
 
-  MOZ_ASSERT(loadListener);
+  MOZ_ASSERT(loadListener && !loadListener->mOpenPromise.IsEmpty());
   if (loadListener) {
-    loadListener->NotifyBridgeConnected(aBridge);
+    loadListener->NotifyBridgeConnected();
   }
-  return loadListener.forget();
+
+  RefPtr<OpenPromise> p = loadListener->mOpenPromise.Ensure(__func__);
+  loadListener.forget(aListener);
+
+  return p;
 }
 
-void DocumentLoadListener::NotifyBridgeConnected(
-    ADocumentChannelBridge* aBridge) {
+void DocumentLoadListener::NotifyBridgeConnected() {
   LOG(("DocumentLoadListener NotifyBridgeConnected [this=%p]", this));
-  MOZ_ASSERT(!mDocumentChannelBridge);
   MOZ_ASSERT(mPendingDocumentChannelBridgeProcess);
-  MOZ_ASSERT(aBridge->OtherPid() == *mPendingDocumentChannelBridgeProcess);
 
-  mDocumentChannelBridge = aBridge;
+  mOtherPid = *mPendingDocumentChannelBridgeProcess;
   mPendingDocumentChannelBridgeProcess.reset();
-  mBridgePromise.ResolveIfExists(aBridge, __func__);
+  mBridgePromise.ResolveIfExists(true, __func__);
 }
 
 void DocumentLoadListener::NotifyBridgeFailed() {
   LOG(("DocumentLoadListener NotifyBridgeFailed [this=%p]", this));
-  MOZ_ASSERT(!mDocumentChannelBridge);
   MOZ_ASSERT(mPendingDocumentChannelBridgeProcess);
   mPendingDocumentChannelBridgeProcess.reset();
 
   Cancel(NS_BINDING_ABORTED);
 
-  mBridgePromise.RejectIfExists(false, __func__);
+  mBridgePromise.RejectIfExists(NS_BINDING_ABORTED, __func__);
 }
 
-void DocumentLoadListener::DocumentChannelBridgeDisconnected() {
-  LOG(("DocumentLoadListener DocumentChannelBridgeDisconnected [this=%p]",
-       this));
+void DocumentLoadListener::Disconnect() {
+  LOG(("DocumentLoadListener Disconnect [this=%p]", this));
   // The nsHttpChannel may have a reference to this parent, release it
   // to avoid circular references.
   RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
   if (httpChannelImpl) {
     httpChannelImpl->SetWarningReporter(nullptr);
   }
-  mDocumentChannelBridge = nullptr;
 
   if (auto* ctx = GetBrowsingContext()) {
     ctx->EndDocumentLoad(this);
@@ -718,32 +720,31 @@
     mChannel->Cancel(aStatusCode);
   }
 
-  DisconnectChildListeners(aStatusCode, aStatusCode);
+  DisconnectListeners(aStatusCode, aStatusCode);
 }
 
-void DocumentLoadListener::DisconnectChildListeners(nsresult aStatus,
-                                                    nsresult aLoadGroupStatus) {
+void DocumentLoadListener::DisconnectListeners(nsresult aStatus,
+                                               nsresult aLoadGroupStatus) {
   LOG(
-      ("DocumentLoadListener DisconnectChildListener [this=%p, "
+      ("DocumentLoadListener DisconnectListener [this=%p, "
        "aStatus=%" PRIx32 " aLoadGroupStatus=%" PRIx32 " ]",
        this, static_cast<uint32_t>(aStatus),
        static_cast<uint32_t>(aLoadGroupStatus)));
-  RefPtr<DocumentLoadListener> keepAlive(this);
-  if (mDocumentChannelBridge) {
-    // This will drop the bridge's reference to us, so we use keepAlive to
-    // make sure we don't get deleted until we exit the function.
-    mDocumentChannelBridge->DisconnectChildListeners(aStatus, aLoadGroupStatus);
-  } else if (mPendingDocumentChannelBridgeProcess) {
+  if (mPendingDocumentChannelBridgeProcess) {
+    RefPtr<DocumentLoadListener> self = this;
     EnsureBridge()->Then(
         GetCurrentThreadSerialEventTarget(), __func__,
-        [keepAlive, aStatus,
-         aLoadGroupStatus](ADocumentChannelBridge* aBridge) {
-          aBridge->DisconnectChildListeners(aStatus, aLoadGroupStatus);
-          keepAlive->mDocumentChannelBridge = nullptr;
+        [self, aStatus, aLoadGroupStatus](bool aDummy) {
+          self->RejectOpenPromiseIfExists(aStatus, aLoadGroupStatus, __func__);
         },
-        [](bool aDummy) {});
+        [self](nsresult aError) {
+          self->RejectOpenPromiseIfExists(aError, aError, __func__);
+        });
+  } else {
+    RejectOpenPromiseIfExists(aStatus, aLoadGroupStatus, __func__);
   }
-  DocumentChannelBridgeDisconnected();
+
+  Disconnect();
 
   // If we're not going to send anything else to the content process, and
   // we haven't yet consumed a stream filter promise, then we're never going
@@ -801,20 +802,25 @@
        "aResult=%x]",
        this, int(aResult)));
 
+  bool disconnected = false;
   if (mDoingProcessSwitch) {
-    DisconnectChildListeners(NS_BINDING_ABORTED, NS_BINDING_ABORTED);
+    DisconnectListeners(NS_BINDING_ABORTED, NS_BINDING_ABORTED);
+    disconnected = true;
   }
 
   if (!mRedirectChannelId) {
     if (NS_FAILED(aResult)) {
       mChannel->Cancel(aResult);
       mChannel->Resume();
-      DisconnectChildListeners(aResult, aResult);
+      if (!disconnected) {
+        DisconnectListeners(aResult, aResult);
+      }
       return;
     }
     ApplyPendingFunctions(mChannel);
-    // ResumeSuspendedChannel will be called later as RedirectToRealChannel
-    // continues, so we can return early.
+
+    // The channel has already been resumed by the ParentProcessDocumentChannel
+    // so we can return early.
     return;
   }
 
@@ -859,7 +865,6 @@
   MOZ_ASSERT(
       !SameCOMIdentity(redirectChannel, static_cast<nsIParentChannel*>(this)));
 
-  Delete();
   redirectChannel->SetParentListener(mParentChannelListener);
 
   ApplyPendingFunctions(redirectChannel);
@@ -1370,7 +1375,7 @@
   LOG(("Process Switch: Calling nsIBrowser::PerformProcessSwitch"));
   // We're switching a toplevel BrowsingContext's process. This has to be done
   // using nsIBrowser.
-  RefPtr<Promise> domPromise;
+  RefPtr<dom::Promise> domPromise;
   browser->PerformProcessSwitch(remoteType, mCrossProcessRedirectIdentifier,
                                 isCOOPSwitch, getter_AddRefs(domPromise));
   MOZ_DIAGNOSTIC_ASSERT(domPromise,
@@ -1391,12 +1396,10 @@
   return true;
 }
 
-auto DocumentLoadListener::EnsureBridge() -> RefPtr<EnsureBridgePromise> {
-  MOZ_ASSERT(mDocumentChannelBridge || mPendingDocumentChannelBridgeProcess);
-  if (mDocumentChannelBridge) {
+RefPtr<GenericPromise> DocumentLoadListener::EnsureBridge() {
+  if (!mPendingDocumentChannelBridgeProcess) {
     MOZ_ASSERT(mBridgePromise.IsEmpty());
-    return EnsureBridgePromise::CreateAndResolve(mDocumentChannelBridge,
-                                                 __func__);
+    return GenericPromise::CreateAndResolve(true, __func__);
   }
 
   return mBridgePromise.Ensure(__func__);
@@ -1472,15 +1475,24 @@
       GetCurrentThreadSerialEventTarget(), __func__,
       [self = RefPtr<DocumentLoadListener>(this),
        endpoints = std::move(aStreamFilterEndpoints), aRedirectFlags,
-       aLoadFlags](ADocumentChannelBridge* aBridge) mutable {
-        if (self->mCancelled) {
+       aLoadFlags](bool aDummy) mutable
+      -> RefPtr<PDocumentChannelParent::RedirectToRealChannelPromise> {
+        if (self->mCancelled || self->mOpenPromise.IsEmpty()) {
           return PDocumentChannelParent::RedirectToRealChannelPromise::
               CreateAndResolve(NS_BINDING_ABORTED, __func__);
         }
-        return aBridge->RedirectToRealChannel(std::move(endpoints),
-                                              aRedirectFlags, aLoadFlags);
+        // This promise will be passed on the promise listener which will
+        // resolve this promise for us.
+        auto promise = MakeRefPtr<
+            PDocumentChannelParent::RedirectToRealChannelPromise::Private>(
+            __func__);
+        self->mOpenPromise.Resolve(
+            OpenPromiseSucceededType(
+                {std::move(endpoints), aRedirectFlags, aLoadFlags, promise}),
+            __func__);
+        return promise;
       },
-      [](bool aDummy) {
+      [](nsresult aDummy) {
         return PDocumentChannelParent::RedirectToRealChannelPromise::
             CreateAndReject(ipc::ResponseRejectReason::ActorDestroyed,
                             __func__);
@@ -1584,6 +1596,7 @@
 NS_IMETHODIMP
 DocumentLoadListener::OnStartRequest(nsIRequest* aRequest) {
   LOG(("DocumentLoadListener OnStartRequest [this=%p]", this));
+
   nsCOMPtr<nsIMultiPartChannel> multiPartChannel = do_QueryInterface(aRequest);
   if (multiPartChannel) {
     multiPartChannel->GetBaseChannel(getter_AddRefs(mChannel));
@@ -1591,12 +1604,9 @@
     mChannel = do_QueryInterface(aRequest);
   }
   MOZ_DIAGNOSTIC_ASSERT(mChannel);
+
   RefPtr<nsHttpChannel> httpChannel = do_QueryObject(mChannel);
 
-  if (!mDocumentChannelBridge && !mPendingDocumentChannelBridgeProcess) {
-    return NS_ERROR_UNEXPECTED;
-  }
-
   // Enforce CSP frame-ancestors and x-frame-options checks which
   // might cancel the channel.
   nsContentSecurityUtils::PerformCSPFrameAncestorAndXFOCheck(mChannel);
@@ -1610,21 +1620,23 @@
   nsresult status = NS_OK;
   aRequest->GetStatus(&status);
   if (status == NS_ERROR_NO_CONTENT) {
-    DisconnectChildListeners(status, status);
+    DisconnectListeners(status, status);
     return NS_OK;
   }
 
   mStreamListenerFunctions.AppendElement(StreamListenerFunction{
       VariantIndex<0>{}, OnStartRequestParams{aRequest}});
 
-  if (!mInitiatedRedirectToRealChannel) {
-    mChannel->Suspend();
-  } else {
-    // This can be called multiple time if we have a multipart
-    // decoder. Since we've already added the reqest to
-    // mStreamListenerFunctions, we don't need to do anything else.
+  if (mOpenPromise.IsEmpty() || mInitiatedRedirectToRealChannel) {
+    // I we have already resolved the promise, there's no point to continue
+    // attempting a process switch or redirecting to the real channel.
+    // We can also have multiple calls to OnStartRequest when dealing with
+    // multi-part content, but only want to redirect once.
     return NS_OK;
   }
+
+  mChannel->Suspend();
+
   mInitiatedRedirectToRealChannel = true;
 
   // Determine if a new process needs to be spawned. If it does, this will
@@ -1715,7 +1727,7 @@
     // channel, then it means we never got OnStartRequest (maybe a problem?)
     // and we retargeted everything.
     LOG(("DocumentLoadListener Disconnecting child"));
-    DisconnectChildListeners(NS_BINDING_RETARGETED, NS_OK);
+    DisconnectListeners(NS_BINDING_RETARGETED, NS_OK);
     return NS_OK;
   }
   mStreamListenerFunctions.AppendElement(StreamListenerFunction{
@@ -1725,13 +1737,6 @@
 }
 
 NS_IMETHODIMP
-DocumentLoadListener::SetParentListener(
-    mozilla::net::ParentChannelListener* listener) {
-  // We don't need this (do we?)
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 DocumentLoadListener::GetInterface(const nsIID& aIID, void** result) {
   RefPtr<CanonicalBrowsingContext> browsingContext =
       mParentChannelListener->GetBrowsingContext();
@@ -1743,6 +1748,17 @@
   return QueryInterface(aIID, result);
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// nsIParentChannel
+////////////////////////////////////////////////////////////////////////////////
+
+NS_IMETHODIMP
+DocumentLoadListener::SetParentListener(
+    mozilla::net::ParentChannelListener* listener) {
+  // We don't need this (do we?)
+  return NS_OK;
+}
+
 // Rather than forwarding all these nsIParentChannel functions to the child,
 // we cache a list of them, and then ask the 'real' channel to forward them
 // for us after it's created.
@@ -1791,12 +1807,14 @@
 
 NS_IMETHODIMP
 DocumentLoadListener::Delete() {
-  if (mDocumentChannelBridge) {
-    mDocumentChannelBridge->Delete();
-  }
+  MOZ_ASSERT_UNREACHABLE("This method is unused");
   return NS_OK;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// nsIChannelEventSink
+////////////////////////////////////////////////////////////////////////////////
+
 NS_IMETHODIMP
 DocumentLoadListener::AsyncOnChannelRedirect(
     nsIChannel* aOldChannel, nsIChannel* aNewChannel, uint32_t aFlags,