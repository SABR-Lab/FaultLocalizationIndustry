# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/CookieServiceParent.cpp
# Commit: c8bfef0a3dd3
# Full Hash: c8bfef0a3dd356d4ed84089b179684aa42d687ff
# Author: Andrea Marchesini <amarchesini@mozilla.com>
# Date: 2020-04-06 21:47:50
# Regressor Bug: 1562868
# File Overlap Count: 1
# Description:
#   Bug 1562868 - Limit the amount of data shared between processes when document.cookie is set, r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D68179
# ==============================================================================

diff -r 68475f12d4f1 -r c8bfef0a3dd3 netwerk/cookie/CookieServiceParent.cpp
--- a/netwerk/cookie/CookieServiceParent.cpp	Mon Apr 06 13:09:19 2020 +0000
+++ b/netwerk/cookie/CookieServiceParent.cpp	Mon Apr 06 14:03:59 2020 +0000
@@ -5,10 +5,8 @@
 
 #include "mozilla/net/CookieService.h"
 #include "mozilla/net/CookieServiceParent.h"
-#include "mozilla/dom/PContentParent.h"
 #include "mozilla/net/NeckoParent.h"
 
-#include "mozilla/BasePrincipal.h"
 #include "mozilla/ipc/URIUtils.h"
 #include "mozilla/StoragePrincipalHelper.h"
 #include "mozIThirdPartyUtil.h"
@@ -17,26 +15,6 @@
 #include "nsNetCID.h"
 
 using namespace mozilla::ipc;
-using mozilla::OriginAttributes;
-
-namespace {
-
-// Ignore failures from this function, as they only affect whether we do or
-// don't show a dialog box in private browsing mode if the user sets a pref.
-nsresult CreateDummyChannel(nsIURI* aHostURI, nsILoadInfo* aLoadInfo,
-                            nsIChannel** aChannel) {
-  nsCOMPtr<nsIChannel> dummyChannel;
-  nsresult rv =
-      NS_NewChannelInternal(getter_AddRefs(dummyChannel), aHostURI, aLoadInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  dummyChannel.forget(aChannel);
-  return NS_OK;
-}
-
-}  // namespace
 
 namespace mozilla {
 namespace net {
@@ -173,14 +151,10 @@
   // non-refcounted class.
 }
 
-IPCResult CookieServiceParent::RecvSetCookieString(
-    const URIParams& aHost, const Maybe<URIParams>& aChannelURI,
-    const Maybe<LoadInfoArgs>& aLoadInfoArgs, const bool& aIsForeign,
-    const bool& aIsThirdPartyTrackingResource,
-    const bool& aIsThirdPartySocialTrackingResource,
-    const bool& aFirstPartyStorageAccessGranted,
-    const uint32_t& aRejectedReason, const OriginAttributes& aAttrs,
-    const nsCString& aCookieString, const bool& aFromHttp) {
+IPCResult CookieServiceParent::RecvSetCookies(
+    const nsCString& aBaseDomain, const OriginAttributes& aOriginAttributes,
+    const URIParams& aHost, bool aFromHttp,
+    const nsTArray<CookieStruct>& aCookies) {
   if (!mCookieService) {
     return IPC_OK();
   }
@@ -192,39 +166,15 @@
     return IPC_FAIL_NO_REASON(this);
   }
 
-  nsCOMPtr<nsIURI> channelURI = DeserializeURI(aChannelURI);
-
-  nsCOMPtr<nsILoadInfo> loadInfo;
-  Unused << NS_WARN_IF(NS_FAILED(
-      LoadInfoArgsToLoadInfo(aLoadInfoArgs, getter_AddRefs(loadInfo))));
-
-  // This is a gross hack. We've already computed everything we need to know
-  // for whether to set this cookie or not, but we need to communicate all of
-  // this information through to nsICookiePermission, which indirectly
-  // computes the information from the channel. We only care about the
-  // aIsPrivate argument as CookieService::SetCookieStringInternal deals
-  // with aIsForeign before we have to worry about CookiePermission trying
-  // to use the channel to inspect it.
-  nsCOMPtr<nsIChannel> dummyChannel;
-  nsresult rv =
-      CreateDummyChannel(channelURI, loadInfo, getter_AddRefs(dummyChannel));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    // No reason to kill the content process.
-    return IPC_OK();
-  }
-
-  // NB: dummyChannel could be null if something failed in CreateDummyChannel.
-  nsDependentCString cookieString(aCookieString, 0);
-
   // We set this to true while processing this cookie update, to make sure
   // we don't send it back to the same content process.
   mProcessingCookie = true;
-  mCookieService->SetCookieStringInternal(
-      hostURI, aIsForeign, aIsThirdPartyTrackingResource,
-      aIsThirdPartySocialTrackingResource, aFirstPartyStorageAccessGranted,
-      aRejectedReason, cookieString, aFromHttp, aAttrs, dummyChannel);
+
+  bool ok = mCookieService->SetCookiesFromIPC(aBaseDomain, aOriginAttributes,
+                                              hostURI, aFromHttp, aCookies);
+
   mProcessingCookie = false;
-  return IPC_OK();
+  return ok ? IPC_OK() : IPC_FAIL(this, "Invalid cookie received.");
 }
 
 }  // namespace net