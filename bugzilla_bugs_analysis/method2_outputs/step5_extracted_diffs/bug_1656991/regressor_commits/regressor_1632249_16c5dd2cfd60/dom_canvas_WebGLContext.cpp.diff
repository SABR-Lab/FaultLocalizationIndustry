# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContext.cpp
# Commit: 16c5dd2cfd60
# Full Hash: 16c5dd2cfd600a62c80ca17cfb35c0868e016056
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-15 21:48:38
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r ca8139d58d58 -r 16c5dd2cfd60 dom/canvas/WebGLContext.cpp
--- a/dom/canvas/WebGLContext.cpp	Fri Jun 12 21:53:14 2020 +0000
+++ b/dom/canvas/WebGLContext.cpp	Mon Jun 15 18:25:55 2020 +0000
@@ -202,9 +202,6 @@
   mDefaultVertexArray = nullptr;
   mBoundTransformFeedback = nullptr;
   mDefaultTransformFeedback = nullptr;
-#if defined(MOZ_WIDGET_ANDROID)
-  mVRScreen = nullptr;
-#endif
 
   mQuerySlot_SamplesPassed = nullptr;
   mQuerySlot_TFPrimsWritten = nullptr;
@@ -250,16 +247,16 @@
   MOZ_ASSERT(!gl);
 }
 
-void ClientWebGLContext::Invalidate() {
+void ClientWebGLContext::MarkCanvasDirty() {
+  if (mIsCanvasDirty) return;
+  mIsCanvasDirty = true;
+
   if (!mCanvasElement) return;
 
   mCapturedFrameInvalidated = true;
 
-  if (mInvalidated) return;
-
   SVGObserverUtils::InvalidateDirectRenderingObservers(mCanvasElement);
 
-  mInvalidated = true;
   mCanvasElement->InvalidateCanvasContent(nullptr);
 }
 
@@ -397,19 +394,6 @@
 
   // --
 
-  const auto surfaceCaps = [&]() {
-    auto ret = gl::SurfaceCaps::ForRGBA();
-    ret.premultAlpha = mOptions.premultipliedAlpha;
-    ret.preserve = mOptions.preserveDrawingBuffer;
-
-    if (!mOptions.alpha) {
-      ret.premultAlpha = true;
-    }
-    return ret;
-  }();
-
-  // --
-
   const bool useEGL = PR_GetEnv("MOZ_WEBGL_FORCE_EGL");
 
 #ifdef XP_WIN
@@ -447,14 +431,11 @@
 
   // --
 
-  typedef decltype(
-      gl::GLContextProviderEGL::CreateOffscreen) fnCreateOffscreenT;
-  const auto fnCreate = [&](fnCreateOffscreenT* const pfnCreateOffscreen,
+  typedef decltype(gl::GLContextProviderEGL::CreateHeadless) fnCreateT;
+  const auto fnCreate = [&](fnCreateT* const pfnCreate,
                             const char* const info) {
-    const gfx::IntSize dummySize(1, 1);
     nsCString failureId;
-    const RefPtr<gl::GLContext> gl =
-        pfnCreateOffscreen(dummySize, surfaceCaps, flags, &failureId);
+    const RefPtr<gl::GLContext> gl = pfnCreate({flags}, &failureId);
     if (!gl) {
       out_failReasons->push_back(WebGLContext::FailureReason(failureId, info));
     }
@@ -464,18 +445,15 @@
   const auto newGL = [&]() -> RefPtr<gl::GLContext> {
     if (tryNativeGL) {
       if (useEGL)
-        return fnCreate(&gl::GLContextProviderEGL::CreateOffscreen, "useEGL");
+        return fnCreate(&gl::GLContextProviderEGL::CreateHeadless, "useEGL");
 
       const auto ret =
-          fnCreate(&gl::GLContextProvider::CreateOffscreen, "tryNativeGL");
+          fnCreate(&gl::GLContextProvider::CreateHeadless, "tryNativeGL");
       if (ret) return ret;
     }
 
     if (tryANGLE) {
-      // Force enable alpha channel to make sure ANGLE use correct framebuffer
-      // format
-      MOZ_ASSERT(surfaceCaps.alpha);
-      return fnCreate(&gl::GLContextProviderEGL::CreateOffscreen, "tryANGLE");
+      return fnCreate(&gl::GLContextProviderEGL::CreateHeadless, "tryANGLE");
     }
     return nullptr;
   }();
@@ -567,18 +545,6 @@
     requestedSize.y = 1;
   }
 
-  // WebGL 1 spec:
-  //   WebGL presents its drawing buffer to the HTML page compositor immediately
-  //   before a compositing operation, but only if at least one of the following
-  //   has occurred since the previous compositing operation:
-  //
-  //   * Context creation
-  //   * Canvas resize
-  //   * clear, drawArrays, or drawElements has been called while the drawing
-  //     buffer is the currently bound framebuffer
-  mShouldPresent = true;
-  if (requestedSize == mRequestedSize) return;
-
   // Kill our current default fb(s), for later lazy allocation.
   mRequestedSize = requestedSize;
   mDefaultFB = nullptr;
@@ -882,6 +848,8 @@
   mDataAllocGLCallCount = 0;
   gl->ResetSyncCallCount("WebGLContext PresentScreenBuffer");
 
+  mDrawCallsSinceLastFlush = 0;
+
   BumpLru();
 }
 
@@ -920,53 +888,6 @@
   }
 }
 
-// TODO: (JG) I think this should be removed, the Client should manage
-// TextureClients, and imperitively tell the Host what to render to.
-Maybe<ICRData> WebGLContext::InitializeCanvasRenderer(
-    layers::LayersBackend backend) {
-  if (!gl) {
-    return Nothing();
-  }
-
-  ICRData ret;
-  ret.size = {DrawingBufferSize().x, DrawingBufferSize().y};
-  ret.hasAlpha = mOptions.alpha;
-  ret.isPremultAlpha = IsPremultAlpha();
-
-  auto flags = layers::TextureFlags::ORIGIN_BOTTOM_LEFT;
-  if ((!IsPremultAlpha()) && mOptions.alpha) {
-    flags |= layers::TextureFlags::NON_PREMULTIPLIED;
-  }
-
-  // NB: This is weak.  Creating TextureClient objects in the host-side
-  // WebGLContext class... but these are different concepts of host/client.
-  // Host/ClientWebGLContext represent cross-process communication but
-  // TextureHost/Client represent synchronous texture access, which can
-  // be uniprocess and, for us, is.  Also note that TextureClient couldn't
-  // be in the content process like ClientWebGLContext since TextureClient
-  // uses a GL context.
-  UniquePtr<gl::SurfaceFactory> factory = gl::GLScreenBuffer::CreateFactory(
-      gl, gl->Caps(), nullptr, backend, gl->IsANGLE(), flags);
-  mBackend = backend;
-
-  if (!factory) {
-    // Absolutely must have a factory here, so create a basic one
-    factory = MakeUnique<gl::SurfaceFactory_Basic>(gl, gl->Caps(), flags);
-    mBackend = layers::LayersBackend::LAYERS_BASIC;
-  }
-
-  gl->Screen()->Morph(std::move(factory));
-
-#if defined(MOZ_WIDGET_ANDROID)
-  // On Android we are using a different GLScreenBuffer for WebVR, so we need
-  // a resize here because PresentScreenBuffer() may not be called for the
-  // gl->Screen() after we set the new factory.
-  mForceResizeOnPresent = true;
-#endif
-  mVRReady = true;
-  return Some(ret);
-}
-
 // -
 
 template <typename T, typename... Args>
@@ -978,105 +899,155 @@
 
 // For an overview of how WebGL compositing works, see:
 // https://wiki.mozilla.org/Platform/GFX/WebGL/Compositing
-bool WebGLContext::PresentScreenBuffer(gl::GLScreenBuffer* const targetScreen) {
-  const FuncScope funcScope(*this, "<PresentScreenBuffer>");
-  if (IsContextLost()) return false;
-
-  mDrawCallsSinceLastFlush = 0;
-
-  if (!mShouldPresent) return false;
+bool WebGLContext::PresentInto(gl::SwapChain& swapChain) {
+  OnEndOfFrame();
 
   if (!ValidateAndInitFB(nullptr)) return false;
 
-  const auto& screen = targetScreen ? targetScreen : gl->Screen();
-  bool needsResize = mForceResizeOnPresent;
-  needsResize |=
-      !screen->IsReadBufferReady() || (screen->Size() != mDefaultFB->mSize);
-  if (needsResize && !screen->Resize(mDefaultFB->mSize)) {
-    GenerateWarning("screen->Resize failed. Losing context.");
-    LoseContext();
-    return false;
-  }
-  mForceResizeOnPresent = false;
+  {
+    auto presenter = swapChain.Acquire(mDefaultFB->mSize);
+    if (!presenter) {
+      GenerateWarning("Swap chain surface creation failed.");
+      LoseContext();
+      return false;
+    }
+
+    const auto destFb = presenter->Fb();
+    gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, destFb);
 
-  gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
-  BlitBackbufferToCurDriverFB();
+    BlitBackbufferToCurDriverFB();
+
+    if (!mOptions.preserveDrawingBuffer) {
+      if (gl->IsSupported(gl::GLFeature::invalidate_framebuffer)) {
+        gl->fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER, mDefaultFB->mFB);
+        constexpr auto attachments = MakeArray<GLenum>(
+            LOCAL_GL_COLOR_ATTACHMENT0, LOCAL_GL_DEPTH_STENCIL_ATTACHMENT);
+        gl->fInvalidateFramebuffer(LOCAL_GL_READ_FRAMEBUFFER,
+                                   attachments.size(), attachments.data());
+      }
+      mDefaultFB_IsInvalid = true;
+    }
 
 #ifdef DEBUG
-  if (!mOptions.alpha) {
-    gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
-    uint32_t pixel = 3;
-    gl->fReadPixels(0, 0, 1, 1, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, &pixel);
-    MOZ_ASSERT((pixel & 0xff000000) == 0xff000000);
-  }
+    if (!mOptions.alpha) {
+      gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, destFb);
+      uint32_t pixel = 0xffbadbad;
+      gl->fReadPixels(0, 0, 1, 1, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE,
+                      &pixel);
+      MOZ_ASSERT((pixel & 0xff000000) == 0xff000000);
+    }
 #endif
-
-  if (!screen->PublishFrame(screen->Size())) {
-    GenerateWarning("PublishFrame failed. Losing context.");
-    LoseContext();
-    return false;
   }
 
-  if (!mOptions.preserveDrawingBuffer) {
-    if (gl->IsSupported(gl::GLFeature::invalidate_framebuffer)) {
-      gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mDefaultFB->mFB);
-      constexpr auto attachments = MakeArray<GLenum>(
-          LOCAL_GL_COLOR_ATTACHMENT0, LOCAL_GL_DEPTH_STENCIL_ATTACHMENT);
-      gl->fInvalidateFramebuffer(LOCAL_GL_FRAMEBUFFER, attachments.size(),
-                                 attachments.data());
-    }
-    mDefaultFB_IsInvalid = true;
-  }
-  mResolvedDefaultFB = nullptr;
-
-  mShouldPresent = false;
-  OnEndOfFrame();
-
   return true;
 }
 
-bool WebGLContext::PresentScreenBufferVR(
-    gl::GLScreenBuffer* const aTargetScreen,
-    const gl::MozFramebuffer* const fb) {
-  const FuncScope funcScope(*this, "<PresentScreenBufferVR>");
-  if (IsContextLost()) {
-    return false;
-  }
-
-  if (!fb) {
-    // WebVR fallback
-    return PresentScreenBuffer(aTargetScreen);
-  }
-
-  mDrawCallsSinceLastFlush = 0;
-
-  const auto& screen = aTargetScreen ? aTargetScreen : gl->Screen();
-  bool needsResize = mForceResizeOnPresent;
-  needsResize |= !screen->IsReadBufferReady() || (screen->Size() != fb->mSize);
-  if (needsResize && !screen->Resize(fb->mSize)) {
-    GenerateWarning("screen->Resize failed. Losing context.");
-    LoseContext();
-    return false;
-  }
-
-  mForceResizeOnPresent = false;
-
-  gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, 0);
-  BlitBackbufferToCurDriverFB(fb);
-
-  if (!screen->PublishFrame(screen->Size())) {
-    GenerateWarning("PublishFrame failed. Losing context.");
-    LoseContext();
-    return false;
-  }
+void WebGLContext::Present() {
+  const FuncScope funcScope(*this, "<Present>");
+  if (IsContextLost()) return;
 
   mResolvedDefaultFB = nullptr;
 
-  OnEndOfFrame();
+  if (!mSwapChain.mFactory) {
+    NS_WARNING("Failed to make an ideal SurfaceFactory.");
+    mSwapChain.mFactory = MakeUnique<gl::SurfaceFactory_Basic>(*gl);
+  }
+  MOZ_ASSERT(mSwapChain.mFactory);
+
+  (void)PresentInto(mSwapChain);
+}
+
+Maybe<layers::SurfaceDescriptor> WebGLContext::GetFrontBuffer(
+    const layers::TextureType consumerType) {
+  if (mSwapChain.mFactory &&
+      mSwapChain.mFactory->mDesc.consumerType != consumerType) {
+    auto typedFactory = gl::SurfaceFactory::Create(gl, consumerType);
+    if (typedFactory) {
+      mSwapChain.mFactory = std::move(typedFactory);
+    }
+  }
+
+  const auto& front = mSwapChain.FrontBuffer();
+  if (!front) return {};
+
+  return front->ToSurfaceDescriptor();
+}
+
+RefPtr<gfx::DataSourceSurface> WebGLContext::GetFrontBufferSnapshot() {
+  const auto& front = mSwapChain.FrontBuffer();
+  if (!front) return nullptr;
+
+  // -
+
+  front->LockProd();
+  front->ProducerReadAcquire();
+  auto reset = MakeScopeExit([&] {
+    front->ProducerReadRelease();
+    front->UnlockProd();
+  });
+
+  // -
+
+  gl->fPixelStorei(LOCAL_GL_PACK_ALIGNMENT, 1);
+  if (IsWebGL2()) {
+    gl->fPixelStorei(LOCAL_GL_PACK_ROW_LENGTH, 0);
+    gl->fPixelStorei(LOCAL_GL_PACK_SKIP_PIXELS, 0);
+    gl->fPixelStorei(LOCAL_GL_PACK_SKIP_ROWS, 0);
+  }
+
+  // -
 
-  return true;
+  const auto readFbWas = mBoundReadFramebuffer;
+  const auto pboWas = mBoundPixelPackBuffer;
+
+  GLenum fbTarget = LOCAL_GL_READ_FRAMEBUFFER;
+  if (!IsWebGL2()) {
+    fbTarget = LOCAL_GL_FRAMEBUFFER;
+  }
+
+  gl->fBindFramebuffer(fbTarget, front->mFb ? front->mFb->mFB : 0);
+  if (pboWas) {
+    BindBuffer(LOCAL_GL_PIXEL_PACK_BUFFER, nullptr);
+  }
+
+  auto reset2 = MakeScopeExit([&] {
+    DoBindFB(readFbWas, fbTarget);
+    if (pboWas) {
+      BindBuffer(LOCAL_GL_PIXEL_PACK_BUFFER, pboWas);
+    }
+  });
+
+  const auto& size = front->mDesc.size;
+  const auto surfFormat = mOptions.alpha ? gfx::SurfaceFormat::B8G8R8A8
+                                         : gfx::SurfaceFormat::B8G8R8X8;
+  const auto stride = size.width * 4;
+  RefPtr<gfx::DataSourceSurface> surf =
+      gfx::Factory::CreateDataSourceSurfaceWithStride(size, surfFormat, stride,
+                                                      /*zero=*/true);
+  MOZ_ASSERT(surf);
+  if (NS_WARN_IF(!surf)) return nullptr;
+
+  // -
+
+  {
+    const gfx::DataSourceSurface::ScopedMap map(
+        surf, gfx::DataSourceSurface::READ_WRITE);
+    if (!map.IsMapped()) {
+      MOZ_ASSERT(false);
+      return nullptr;
+    }
+    MOZ_ASSERT(map.GetStride() == stride);
+
+    gl->fReadPixels(0, 0, size.width, size.height, LOCAL_GL_RGBA,
+                    LOCAL_GL_UNSIGNED_BYTE, map.GetData());
+    gfxUtils::ConvertBGRAtoRGBA(map.GetData(), stride * size.height);
+  }
+
+  return surf;
 }
 
+// ------------------------
+
 RefPtr<gfx::DataSourceSurface> GetTempSurface(const gfx::IntSize& aSize,
                                               gfx::SurfaceFormat& aFormat) {
   uint32_t stride =
@@ -1085,90 +1056,6 @@
                                                          stride);
 }
 
-void WriteFrontToFile(gl::GLContext* gl, gl::GLScreenBuffer* screen,
-                      const char* fname, bool needsPremult) {
-  auto frontbuffer = screen->Front()->Surf();
-  const auto& readSize = frontbuffer->mSize;
-  auto format = frontbuffer->mHasAlpha ? gfx::SurfaceFormat::B8G8R8A8
-                                       : gfx::SurfaceFormat::B8G8R8X8;
-  RefPtr<gfx::DataSourceSurface> resultSurf = GetTempSurface(readSize, format);
-  if (NS_WARN_IF(!resultSurf)) {
-    MOZ_ASSERT_UNREACHABLE("FAIL");
-    return;
-  }
-
-  if (!gl->Readback(frontbuffer, resultSurf)) {
-    NS_WARNING("Failed to read back canvas surface.");
-    MOZ_ASSERT_UNREACHABLE("FAIL");
-    return;
-  }
-  if (needsPremult) {
-    gfxUtils::PremultiplyDataSurface(resultSurf, resultSurf);
-  }
-  MOZ_ASSERT(resultSurf);
-  gfxUtils::WriteAsPNG(resultSurf, fname);
-}
-
-bool WebGLContext::Present() {
-  if (!PresentScreenBuffer()) {
-    return false;
-  }
-
-  if (XRE_IsContentProcess()) {
-    // That's all!
-    return true;
-  }
-
-  // Set the CompositableHost to use the front buffer as the display,
-  auto flags = layers::TextureFlags::ORIGIN_BOTTOM_LEFT;
-  if ((!IsPremultAlpha()) && mOptions.alpha) {
-    flags |= layers::TextureFlags::NON_PREMULTIPLIED;
-  }
-
-  const auto& screen = gl->Screen();
-  if (!screen->Front()->Surf()) {
-    GenerateWarning(
-        "Present failed due to missing front buffer. Losing context.");
-    LoseContext();
-    return false;
-  }
-
-  if (mBackend == layers::LayersBackend::LAYERS_NONE) {
-    GenerateWarning(
-        "Present was not given a valid compositor layer type. Losing context.");
-    LoseContext();
-    return false;
-  }
-
-  // TODO: I probably need to hold onto screen->Front()->Surf() somehow
-  layers::SurfaceDescriptor surfaceDescriptor;
-  screen->Front()->Surf()->ToSurfaceDescriptor(&surfaceDescriptor);
-
-  if (!mCompositableHost) {
-    return false;
-  }
-
-  wr::MaybeExternalImageId noExternalImageId = Nothing();
-  RefPtr<layers::TextureHost> host = layers::TextureHost::Create(
-      surfaceDescriptor, null_t(), nullptr, mBackend, flags, noExternalImageId);
-
-  if (!host) {
-    GenerateWarning("Present failed to create TextuteHost. Losing context.");
-    LoseContext();
-    return false;
-  }
-
-  AutoTArray<layers::CompositableHost::TimedTexture, 1> textures;
-  const auto t = textures.AppendElement();
-  t->mTexture = host;
-  t->mTimeStamp = TimeStamp::Now();
-  t->mPictureRect = nsIntRect(nsIntPoint(0, 0), nsIntSize(host->GetSize()));
-  t->mFrameID = 0;
-  t->mProducerID = 0;
-  mCompositableHost->UseTextureHost(textures);
-  return true;
-}
-
 void WebGLContext::DummyReadFramebufferOperation() {
   if (!mBoundReadFramebuffer) return;  // Infallible.
 
@@ -1640,119 +1527,6 @@
   return totalBytes;
 }
 
-void WebGLContext::ClearVRFrame() {
-#if defined(MOZ_WIDGET_ANDROID)
-  mVRScreen = nullptr;
-#endif
-}
-
-RefPtr<layers::SharedSurfaceTextureClient> WebGLContext::GetVRFrame(
-    WebGLFramebuffer* fb) {
-  if (!gl) return nullptr;
-
-  EnsureVRReady();
-  const gl::MozFramebuffer* maybeFB = nullptr;
-  if (fb) {
-    maybeFB = fb->mOpaque.get();
-    MOZ_ASSERT(maybeFB);
-  }
-
-  UniquePtr<gl::GLScreenBuffer>* maybeVrScreen = nullptr;
-#if defined(MOZ_WIDGET_ANDROID)
-  maybeVrScreen = &mVRScreen;
-#endif
-  RefPtr<layers::SharedSurfaceTextureClient> sharedSurface;
-
-  if (maybeVrScreen) {
-    auto& vrScreen = *maybeVrScreen;
-    // Create a custom GLScreenBuffer for VR.
-    if (!vrScreen) {
-      auto caps = gl->Screen()->mCaps;
-      vrScreen = gl::GLScreenBuffer::Create(gl, gfx::IntSize(1, 1), caps);
-      RefPtr<layers::ImageBridgeChild> imageBridge =
-          layers::ImageBridgeChild::GetSingleton();
-      if (imageBridge) {
-        layers::TextureFlags flags = layers::TextureFlags::ORIGIN_BOTTOM_LEFT;
-        UniquePtr<gl::SurfaceFactory> factory =
-            gl::GLScreenBuffer::CreateFactory(gl, caps, imageBridge.get(),
-                                              flags);
-        vrScreen->Morph(std::move(factory));
-      }
-    }
-    MOZ_ASSERT(vrScreen);
-
-    // Swap buffers as though composition has occurred.
-    // We will then share the resulting front buffer to be submitted to the VR
-    // compositor.
-    PresentScreenBufferVR(vrScreen.get(), maybeFB);
-
-    if (IsContextLost()) return nullptr;
-
-    sharedSurface = vrScreen->Front();
-    if (!sharedSurface || !sharedSurface->Surf() ||
-        !sharedSurface->Surf()->IsBufferAvailable())
-      return nullptr;
-
-    // Make sure that the WebGL buffer is committed to the attached
-    // SurfaceTexture on Android.
-    sharedSurface->Surf()->ProducerAcquire();
-    sharedSurface->Surf()->Commit();
-    sharedSurface->Surf()->ProducerRelease();
-  } else {
-    /**
-     * Swap buffers as though composition has occurred.
-     * We will then share the resulting front buffer to be submitted to the VR
-     * compositor.
-     */
-    PresentScreenBufferVR(nullptr, maybeFB);
-
-    gl::GLScreenBuffer* screen = gl->Screen();
-    if (!screen) return nullptr;
-
-    sharedSurface = screen->Front();
-    if (!sharedSurface) return nullptr;
-  }
-  return sharedSurface;
-}
-
-void WebGLContext::EnsureVRReady() {
-  if (mVRReady) {
-    return;
-  }
-
-  // Make not composited canvases work with WebVR. See bug #1492554
-  // WebGLContext::InitializeCanvasRenderer is only called when the 2D
-  // compositor renders a WebGL canvas for the first time. This causes canvases
-  // not added to the DOM not to work properly with WebVR. Here we mimic what
-  // InitializeCanvasRenderer does internally as a workaround.
-  const auto caps = gl->Screen()->mCaps;
-  auto flags = layers::TextureFlags::ORIGIN_BOTTOM_LEFT;
-  if (!IsPremultAlpha() && mOptions.alpha) {
-    flags |= layers::TextureFlags::NON_PREMULTIPLIED;
-  }
-  RefPtr<layers::ImageBridgeChild> imageBridge =
-      layers::ImageBridgeChild::GetSingleton();
-  if (!imageBridge) {
-    return;
-  }
-  auto factory =
-      gl::GLScreenBuffer::CreateFactory(gl, caps, imageBridge.get(), flags);
-  gl->Screen()->Morph(std::move(factory));
-
-  bool needsResize = false;
-#if defined(MOZ_WIDGET_ANDROID)
-  // On Android we are using a different GLScreenBuffer for WebVR, so we need
-  // a resize here because PresentScreenBuffer() may not be called for the
-  // gl->Screen() after we set the new factory.
-  needsResize = true;
-#endif
-  if (needsResize) {
-    const auto& size = DrawingBufferSize();
-    gl->Screen()->Resize({size.x, size.y});
-  }
-  mVRReady = true;
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 
 const char* WebGLContext::FuncName() const {