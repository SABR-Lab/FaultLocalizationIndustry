# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/SharedSurfaceIO.cpp
# Commit: bbfe23c61add
# Full Hash: bbfe23c61add07377daf80696fd6996c0463f5b6
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-09 09:21:34
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 8fcfac450ecc -r bbfe23c61add gfx/gl/SharedSurfaceIO.cpp
--- a/gfx/gl/SharedSurfaceIO.cpp	Mon Jun 08 20:13:01 2020 +0000
+++ b/gfx/gl/SharedSurfaceIO.cpp	Mon Jun 08 20:34:15 2020 +0000
@@ -6,6 +6,7 @@
 #include "SharedSurfaceIO.h"
 
 #include "GLContextCGL.h"
+#include "MozFramebuffer.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/gfx/MacIOSurface.h"
 #include "mozilla/layers/LayersSurfaces.h"  // for SurfaceDescriptor, etc
@@ -14,107 +15,20 @@
 namespace mozilla {
 namespace gl {
 
-/*static*/
-UniquePtr<SharedSurface_IOSurface> SharedSurface_IOSurface::Create(
-    const RefPtr<MacIOSurface>& ioSurf, GLContext* gl, bool hasAlpha) {
-  MOZ_ASSERT(ioSurf);
-  MOZ_ASSERT(gl);
-
-  auto size = gfx::IntSize::Truncate(ioSurf->GetWidth(), ioSurf->GetHeight());
-
-  typedef SharedSurface_IOSurface ptrT;
-  UniquePtr<ptrT> ret(new ptrT(ioSurf, gl, size, hasAlpha));
-  return ret;
-}
-
-void SharedSurface_IOSurface::ProducerReleaseImpl() {
-  mGL->MakeCurrent();
-  mGL->fFlush();
-}
-
-bool SharedSurface_IOSurface::CopyTexImage2D(GLenum target, GLint level,
-                                             GLenum internalformat, GLint x,
-                                             GLint y, GLsizei width,
-                                             GLsizei height, GLint border) {
-  /* Bug 896693 - OpenGL framebuffers that are backed by IOSurface on OSX expose
-   * a bug in glCopyTexImage2D --- internalformats GL_ALPHA, GL_LUMINANCE,
-   * GL_LUMINANCE_ALPHA return the wrong results. To work around, copy
-   * framebuffer to a temporary texture using GL_RGBA (which works), attach as
-   * read framebuffer and glCopyTexImage2D instead.
-   */
-
-  // https://www.opengl.org/sdk/docs/man3/xhtml/glCopyTexImage2D.xml says that
-  // width or height set to 0 results in a NULL texture. Lets not do any work
-  // and punt to original glCopyTexImage2D, since the FBO below will fail when
-  // trying to attach a texture of 0 width or height.
-  if (width == 0 || height == 0) return false;
-
-  switch (internalformat) {
-    case LOCAL_GL_ALPHA:
-    case LOCAL_GL_LUMINANCE:
-    case LOCAL_GL_LUMINANCE_ALPHA:
-      break;
-
-    default:
-      return false;
-  }
-
-  MOZ_ASSERT(mGL->IsCurrent());
+// -
+// Factory
 
-  ScopedTexture destTex(mGL);
-  {
-    ScopedBindTexture bindTex(mGL, destTex.Texture());
-    mGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER,
-                        LOCAL_GL_NEAREST);
-    mGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER,
-                        LOCAL_GL_NEAREST);
-    mGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S,
-                        LOCAL_GL_CLAMP_TO_EDGE);
-    mGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T,
-                        LOCAL_GL_CLAMP_TO_EDGE);
-    mGL->raw_fCopyTexImage2D(LOCAL_GL_TEXTURE_2D, 0, LOCAL_GL_RGBA, x, y, width,
-                             height, 0);
-  }
-
-  ScopedFramebufferForTexture tmpFB(mGL, destTex.Texture(),
-                                    LOCAL_GL_TEXTURE_2D);
-  ScopedBindFramebuffer bindFB(mGL, tmpFB.FB());
-  mGL->raw_fCopyTexImage2D(target, level, internalformat, x, y, width, height,
-                           border);
-
-  return true;
-}
+SurfaceFactory_IOSurface::SurfaceFactory_IOSurface(GLContext& gl)
+    : SurfaceFactory({&gl, SharedSurfaceType::IOSurface,
+                      layers::TextureType::MacIOSurface, true}),
+      mMaxDims(gfx::IntSize::Truncate(MacIOSurface::GetMaxWidth(),
+                                      MacIOSurface::GetMaxHeight())) {}
 
-bool SharedSurface_IOSurface::ReadPixels(GLint x, GLint y, GLsizei width,
-                                         GLsizei height, GLenum format,
-                                         GLenum type, GLvoid* pixels) {
-  // Calling glReadPixels when an IOSurface is bound to the current framebuffer
-  // can cause corruption in following glReadPixel calls (even if they aren't
-  // reading from an IOSurface).
-  // We workaround this by copying to a temporary texture, and doing the
-  // readback from that.
-  MOZ_ASSERT(mGL->IsCurrent());
-
-  ScopedTexture destTex(mGL);
-  {
-    ScopedFramebufferForTexture srcFB(mGL, ProdTexture(), ProdTextureTarget());
+// -
+// Surface
 
-    ScopedBindFramebuffer bindFB(mGL, srcFB.FB());
-    ScopedBindTexture bindTex(mGL, destTex.Texture());
-    mGL->raw_fCopyTexImage2D(LOCAL_GL_TEXTURE_2D, 0,
-                             mHasAlpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB, x, y,
-                             width, height, 0);
-  }
-
-  ScopedFramebufferForTexture destFB(mGL, destTex.Texture());
-
-  ScopedBindFramebuffer bindFB(mGL, destFB.FB());
-  mGL->raw_fReadPixels(0, 0, width, height, format, type, pixels);
-  return true;
-}
-
-static void BackTextureWithIOSurf(GLContext* gl, GLuint tex,
-                                  MacIOSurface* ioSurf) {
+static void BackTextureWithIOSurf(GLContext* const gl, const GLuint tex,
+                                  MacIOSurface* const ioSurf) {
   MOZ_ASSERT(gl->IsCurrent());
 
   ScopedBindTexture texture(gl, tex, LOCAL_GL_TEXTURE_RECTANGLE_ARB);
@@ -134,31 +48,51 @@
   ioSurf->CGLTexImageIOSurface2D(gl, cgl, 0);
 }
 
-SharedSurface_IOSurface::SharedSurface_IOSurface(
-    const RefPtr<MacIOSurface>& ioSurf, GLContext* gl, const gfx::IntSize& size,
-    bool hasAlpha)
-    : SharedSurface(SharedSurfaceType::IOSurface, AttachmentType::GLTexture, gl,
-                    size, hasAlpha, true),
-      mIOSurf(ioSurf) {
-  gl->MakeCurrent();
-  mProdTex = 0;
-  gl->fGenTextures(1, &mProdTex);
-  BackTextureWithIOSurf(gl, mProdTex, mIOSurf);
+/*static*/
+UniquePtr<SharedSurface_IOSurface> SharedSurface_IOSurface::Create(
+    const SharedSurfaceDesc& desc) {
+  const auto& size = desc.size;
+  const RefPtr<MacIOSurface> ioSurf =
+      MacIOSurface::CreateIOSurface(size.width, size.height, 1.0, true);
+  if (!ioSurf) {
+    NS_WARNING("Failed to create MacIOSurface.");
+    return nullptr;
+  }
+
+  auto tex = MakeUnique<Texture>(*desc.gl);
+  BackTextureWithIOSurf(desc.gl, tex->name, ioSurf);
+
+  const GLenum target = LOCAL_GL_TEXTURE_RECTANGLE;
+  auto fb = MozFramebuffer::CreateForBacking(desc.gl, desc.size, 0, false,
+                                             target, tex->name);
+  if (!fb) return nullptr;
+
+  return AsUnique(
+      new SharedSurface_IOSurface(desc, std::move(fb), std::move(tex), ioSurf));
 }
 
-SharedSurface_IOSurface::~SharedSurface_IOSurface() {
-  if (!mGL || !mGL->MakeCurrent()) return;
+SharedSurface_IOSurface::SharedSurface_IOSurface(
+    const SharedSurfaceDesc& desc, UniquePtr<MozFramebuffer> fb,
+    UniquePtr<Texture> tex, const RefPtr<MacIOSurface>& ioSurf)
+    : SharedSurface(desc, std::move(fb)),
+      mTex(std::move(tex)),
+      mIOSurf(ioSurf) {}
 
-  mGL->fDeleteTextures(1, &mProdTex);
+SharedSurface_IOSurface::~SharedSurface_IOSurface() = default;
+
+void SharedSurface_IOSurface::ProducerReleaseImpl() {
+  const auto& gl = mDesc.gl;
+  if (!gl) return;
+  gl->MakeCurrent();
+  gl->fFlush();
 }
 
-bool SharedSurface_IOSurface::ToSurfaceDescriptor(
-    layers::SurfaceDescriptor* const out_descriptor) {
-  bool isOpaque = !mHasAlpha;
-  *out_descriptor = layers::SurfaceDescriptorMacIOSurface(
+Maybe<layers::SurfaceDescriptor>
+SharedSurface_IOSurface::ToSurfaceDescriptor() {
+  const bool isOpaque = false;  // RGBA
+  return Some(layers::SurfaceDescriptorMacIOSurface(
       mIOSurf->GetIOSurfaceID(), mIOSurf->GetContentsScaleFactor(), isOpaque,
-      mIOSurf->GetYUVColorSpace());
-  return true;
+      mIOSurf->GetYUVColorSpace()));
 }
 
 bool SharedSurface_IOSurface::ReadbackBySharedHandle(
@@ -186,40 +120,5 @@
   return true;
 }
 
-////////////////////////////////////////////////////////////////////////
-// SurfaceFactory_IOSurface
-
-/*static*/
-UniquePtr<SurfaceFactory_IOSurface> SurfaceFactory_IOSurface::Create(
-    GLContext* gl, const SurfaceCaps& caps,
-    const RefPtr<layers::LayersIPCChannel>& allocator,
-    const layers::TextureFlags& flags) {
-  auto maxDims = gfx::IntSize::Truncate(MacIOSurface::GetMaxWidth(),
-                                        MacIOSurface::GetMaxHeight());
-
-  typedef SurfaceFactory_IOSurface ptrT;
-  UniquePtr<ptrT> ret(new ptrT(gl, caps, allocator, flags, maxDims));
-  return ret;
-}
-
-UniquePtr<SharedSurface> SurfaceFactory_IOSurface::CreateShared(
-    const gfx::IntSize& size) {
-  if (size.width > mMaxDims.width || size.height > mMaxDims.height) {
-    return nullptr;
-  }
-
-  bool hasAlpha = mReadCaps.alpha;
-  RefPtr<MacIOSurface> ioSurf;
-  ioSurf =
-      MacIOSurface::CreateIOSurface(size.width, size.height, 1.0, hasAlpha);
-
-  if (!ioSurf) {
-    NS_WARNING("Failed to create MacIOSurface.");
-    return nullptr;
-  }
-
-  return SharedSurface_IOSurface::Create(ioSurf, mGL, hasAlpha);
-}
-
 }  // namespace gl
 }  // namespace mozilla