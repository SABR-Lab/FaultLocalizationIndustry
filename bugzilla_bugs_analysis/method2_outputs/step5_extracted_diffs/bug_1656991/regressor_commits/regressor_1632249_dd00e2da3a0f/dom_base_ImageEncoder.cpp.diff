# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ImageEncoder.cpp
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f dom/base/ImageEncoder.cpp
--- a/dom/base/ImageEncoder.cpp	Wed Jun 10 21:57:19 2020 +0000
+++ b/dom/base/ImageEncoder.cpp	Wed Jun 10 22:21:02 2020 +0000
@@ -11,7 +11,7 @@
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/DataSurfaceHelpers.h"
-#include "mozilla/layers/AsyncCanvasRenderer.h"
+#include "mozilla/layers/CanvasRenderer.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/SyncRunnable.h"
 #include "mozilla/Unused.h"
@@ -217,7 +217,7 @@
 nsresult ImageEncoder::ExtractData(nsAString& aType, const nsAString& aOptions,
                                    const nsIntSize aSize, bool aUsePlaceholder,
                                    nsICanvasRenderingContextInternal* aContext,
-                                   layers::AsyncCanvasRenderer* aRenderer,
+                                   layers::CanvasRenderer* aRenderer,
                                    nsIInputStream** aStream) {
   nsCOMPtr<imgIEncoder> encoder = ImageEncoder::GetImageEncoder(aType);
   if (!encoder) {
@@ -290,7 +290,7 @@
     const nsAString& aType, const nsAString& aOptions, uint8_t* aImageBuffer,
     int32_t aFormat, const nsIntSize aSize, bool aUsePlaceholder,
     layers::Image* aImage, nsICanvasRenderingContextInternal* aContext,
-    layers::AsyncCanvasRenderer* aRenderer, nsIInputStream** aStream,
+    layers::CanvasRenderer* aRenderer, nsIInputStream** aStream,
     imgIEncoder* aEncoder) {
   if (aSize.IsEmpty()) {
     return NS_ERROR_INVALID_ARG;
@@ -313,9 +313,32 @@
     rv = aContext->GetInputStream(encoderType.get(), aOptions,
                                   getter_AddRefs(imgStream));
   } else if (aRenderer && !aUsePlaceholder) {
-    NS_ConvertUTF16toUTF8 encoderType(aType);
-    rv = aRenderer->GetInputStream(encoderType.get(), aOptions,
-                                   getter_AddRefs(imgStream));
+    MOZ_CRASH("unused?");
+    const NS_ConvertUTF16toUTF8 encoderType(aType);
+    if (BufferSizeFromDimensions(aSize.width, aSize.height, 4) == 0) {
+      return NS_ERROR_INVALID_ARG;
+    }
+
+    const auto snapshot = aRenderer->BorrowSnapshot();
+    if (!snapshot) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    const RefPtr<DataSourceSurface> data = snapshot->mSurf->GetDataSurface();
+    if (!data) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    {
+      DataSourceSurface::MappedSurface map;
+      if (!data->Map(gfx::DataSourceSurface::MapType::READ, &map)) {
+        return NS_ERROR_INVALID_ARG;
+      }
+      rv = aEncoder->InitFromData(map.mData, aSize.width * aSize.height * 4,
+                                  aSize.width, aSize.height, aSize.width * 4,
+                                  imgIEncoder::INPUT_FORMAT_HOSTARGB, aOptions);
+      data->Unmap();
+    }
   } else if (aImage && !aUsePlaceholder) {
     // It is safe to convert PlanarYCbCr format from YUV to RGB off-main-thread.
     // Other image formats could have problem to convert format off-main-thread.