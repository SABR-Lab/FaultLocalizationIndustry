# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/SharedSurfaceGLX.cpp
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f gfx/gl/SharedSurfaceGLX.cpp
--- a/gfx/gl/SharedSurfaceGLX.cpp	Wed Jun 10 21:57:19 2020 +0000
+++ b/gfx/gl/SharedSurfaceGLX.cpp	Wed Jun 10 22:21:02 2020 +0000
@@ -9,6 +9,7 @@
 #include "GLContextProvider.h"
 #include "GLContextGLX.h"
 #include "GLScreenBuffer.h"
+#include "MozFramebuffer.h"
 #include "mozilla/gfx/SourceSurfaceCairo.h"
 #include "mozilla/layers/LayersSurfaces.h"
 #include "mozilla/layers/ShadowLayerUtilsX11.h"
@@ -18,50 +19,50 @@
 
 namespace mozilla::gl {
 
+UniquePtr<SharedSurface> SurfaceFactory_GLXDrawable::CreateSharedImpl(
+    const SharedSurfaceDesc& desc) {
+  return SharedSurface_GLXDrawable::Create(desc);
+}
+
 /* static */
 UniquePtr<SharedSurface_GLXDrawable> SharedSurface_GLXDrawable::Create(
-    GLContext* prodGL, const SurfaceCaps& caps, const gfx::IntSize& size,
-    bool deallocateClient, bool inSameProcess) {
-  UniquePtr<SharedSurface_GLXDrawable> ret;
+    const SharedSurfaceDesc& desc) {
   Display* display = DefaultXDisplay();
   Screen* screen = XDefaultScreenOfDisplay(display);
   Visual* visual =
       gfxXlibSurface::FindVisual(screen, gfx::SurfaceFormat::A8R8G8B8_UINT32);
 
-  RefPtr<gfxXlibSurface> surf = gfxXlibSurface::Create(screen, visual, size);
-  if (!deallocateClient) surf->ReleasePixmap();
+  const RefPtr<gfxXlibSurface> surf =
+      gfxXlibSurface::Create(screen, visual, desc.size);
+  surf->ReleasePixmap();
 
-  ret.reset(new SharedSurface_GLXDrawable(prodGL, size, inSameProcess, surf));
-  return ret;
+  return AsUnique(new SharedSurface_GLXDrawable(desc, surf));
 }
 
 SharedSurface_GLXDrawable::SharedSurface_GLXDrawable(
-    GLContext* gl, const gfx::IntSize& size, bool inSameProcess,
-    const RefPtr<gfxXlibSurface>& xlibSurface)
-    : SharedSurface(SharedSurfaceType::GLXDrawable, AttachmentType::Screen, gl,
-                    size, true, true),
-      mXlibSurface(xlibSurface),
-      mInSameProcess(inSameProcess) {}
+    const SharedSurfaceDesc& desc, const RefPtr<gfxXlibSurface>& xlibSurface)
+    : SharedSurface(desc, nullptr), mXlibSurface(xlibSurface) {}
+
+SharedSurface_GLXDrawable::~SharedSurface_GLXDrawable() = default;
 
 void SharedSurface_GLXDrawable::ProducerReleaseImpl() {
-  mGL->MakeCurrent();
-  mGL->fFlush();
+  mDesc.gl->MakeCurrent();
+  mDesc.gl->fFlush();
 }
 
 void SharedSurface_GLXDrawable::LockProdImpl() {
-  GLContextGLX::Cast(mGL)->OverrideDrawable(mXlibSurface->GetGLXPixmap());
+  GLContextGLX::Cast(mDesc.gl)->OverrideDrawable(mXlibSurface->GetGLXPixmap());
 }
 
 void SharedSurface_GLXDrawable::UnlockProdImpl() {
-  GLContextGLX::Cast(mGL)->RestoreDrawable();
+  GLContextGLX::Cast(mDesc.gl)->RestoreDrawable();
 }
 
-bool SharedSurface_GLXDrawable::ToSurfaceDescriptor(
-    layers::SurfaceDescriptor* const out_descriptor) {
-  if (!mXlibSurface) return false;
-
-  *out_descriptor = layers::SurfaceDescriptorX11(mXlibSurface, mInSameProcess);
-  return true;
+Maybe<layers::SurfaceDescriptor>
+SharedSurface_GLXDrawable::ToSurfaceDescriptor() {
+  if (!mXlibSurface) return {};
+  const bool sameProcess = false;
+  return Some(layers::SurfaceDescriptorX11(mXlibSurface, sameProcess));
 }
 
 bool SharedSurface_GLXDrawable::ReadbackBySharedHandle(
@@ -96,25 +97,8 @@
   return true;
 }
 
-/* static */
-UniquePtr<SurfaceFactory_GLXDrawable> SurfaceFactory_GLXDrawable::Create(
-    GLContext* prodGL, const SurfaceCaps& caps,
-    const RefPtr<layers::LayersIPCChannel>& allocator,
-    const layers::TextureFlags& flags) {
-  MOZ_ASSERT(caps.alpha, "GLX surfaces require an alpha channel!");
-
-  typedef SurfaceFactory_GLXDrawable ptrT;
-  UniquePtr<ptrT> ret(
-      new ptrT(prodGL, caps, allocator,
-               flags & ~layers::TextureFlags::ORIGIN_BOTTOM_LEFT));
-  return ret;
-}
-
-UniquePtr<SharedSurface> SurfaceFactory_GLXDrawable::CreateShared(
-    const gfx::IntSize& size) {
-  bool deallocateClient = !!(mFlags & layers::TextureFlags::DEALLOCATE_CLIENT);
-  return SharedSurface_GLXDrawable::Create(mGL, mCaps, size, deallocateClient,
-                                           mAllocator->IsSameProcess());
-}
+SurfaceFactory_GLXDrawable::SurfaceFactory_GLXDrawable(GLContext& gl)
+    : SurfaceFactory({&gl, SharedSurfaceType::GLXDrawable,
+                      layers::TextureType::X11, true}) {}
 
 }  // namespace mozilla::gl