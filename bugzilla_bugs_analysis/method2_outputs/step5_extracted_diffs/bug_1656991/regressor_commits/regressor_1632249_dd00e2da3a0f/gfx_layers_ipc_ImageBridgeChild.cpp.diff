# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/ImageBridgeChild.cpp
# Commit: dd00e2da3a0f
# Full Hash: dd00e2da3a0f11a7cc0af9e5ece21a339f4393eb
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2020-06-11 04:04:33
# Regressor Bug: 1632249
# File Overlap Count: 1
# Description:
#   Bug 1632249 - Support compositing out-of-process WebGL. r=handyman,lsalzman,nical,geckoview-reviewers,agi,imanol
#   
#   * Majorly simplity CanvasRenderer
#   * Replace GLScreenBuffer with trivial GLSwapChain
#   * Use descriptor structs so that future SharedSurface changes aren't so painful
# ==============================================================================

diff -r 69cc1de6f754 -r dd00e2da3a0f gfx/layers/ipc/ImageBridgeChild.cpp
--- a/gfx/layers/ipc/ImageBridgeChild.cpp	Wed Jun 10 21:57:19 2020 +0000
+++ b/gfx/layers/ipc/ImageBridgeChild.cpp	Wed Jun 10 22:21:02 2020 +0000
@@ -21,7 +21,6 @@
 #include "mozilla/ipc/Transport.h"       // for Transport
 #include "mozilla/gfx/gfxVars.h"
 #include "mozilla/gfx/Point.h"  // for IntSize
-#include "mozilla/layers/AsyncCanvasRenderer.h"
 #include "mozilla/media/MediaSystemResourceManager.h"  // for MediaSystemResourceManager
 #include "mozilla/media/MediaSystemResourceManagerChild.h"  // for MediaSystemResourceManagerChild
 #include "mozilla/layers/CompositableClient.h"  // for CompositableChild, etc
@@ -233,14 +232,6 @@
   *result = CreateImageClientNow(aType, aImageContainer);
 }
 
-// dispatched function
-void ImageBridgeChild::CreateCanvasClientSync(
-    SynchronousTask* aTask, CanvasClient::CanvasClientType aType,
-    TextureFlags aFlags, RefPtr<CanvasClient>* const outResult) {
-  AutoCompleteTask complete(aTask);
-  *outResult = CreateCanvasClientNow(aType, aFlags);
-}
-
 ImageBridgeChild::ImageBridgeChild(uint32_t aNamespace)
     : mNamespace(aNamespace),
       mCanSend(false),
@@ -333,45 +324,6 @@
   EndTransaction();
 }
 
-void ImageBridgeChild::UpdateAsyncCanvasRendererSync(
-    SynchronousTask* aTask, AsyncCanvasRenderer* aWrapper) {
-  AutoCompleteTask complete(aTask);
-
-  UpdateAsyncCanvasRendererNow(aWrapper);
-}
-
-void ImageBridgeChild::UpdateAsyncCanvasRenderer(
-    AsyncCanvasRenderer* aWrapper) {
-  aWrapper->GetCanvasClient()->UpdateAsync(aWrapper);
-
-  if (InImageBridgeChildThread()) {
-    UpdateAsyncCanvasRendererNow(aWrapper);
-    return;
-  }
-
-  SynchronousTask task("UpdateAsyncCanvasRenderer Lock");
-
-  RefPtr<Runnable> runnable = WrapRunnable(
-      RefPtr<ImageBridgeChild>(this),
-      &ImageBridgeChild::UpdateAsyncCanvasRendererSync, &task, aWrapper);
-  GetThread()->Dispatch(runnable.forget());
-
-  task.Wait();
-}
-
-void ImageBridgeChild::UpdateAsyncCanvasRendererNow(
-    AsyncCanvasRenderer* aWrapper) {
-  MOZ_ASSERT(aWrapper);
-
-  if (!CanSend()) {
-    return;
-  }
-
-  BeginTransaction();
-  aWrapper->GetCanvasClient()->Updated();
-  EndTransaction();
-}
-
 void ImageBridgeChild::FlushAllImagesSync(SynchronousTask* aTask,
                                           ImageClient* aClient,
                                           ImageContainer* aContainer) {
@@ -718,37 +670,6 @@
   return client;
 }
 
-already_AddRefed<CanvasClient> ImageBridgeChild::CreateCanvasClient(
-    CanvasClient::CanvasClientType aType, TextureFlags aFlag) {
-  if (InImageBridgeChildThread()) {
-    return CreateCanvasClientNow(aType, aFlag);
-  }
-
-  SynchronousTask task("CreateCanvasClient Lock");
-
-  // RefPtrs on arguments are not needed since this dispatches synchronously.
-  RefPtr<CanvasClient> result = nullptr;
-  RefPtr<Runnable> runnable = WrapRunnable(
-      RefPtr<ImageBridgeChild>(this), &ImageBridgeChild::CreateCanvasClientSync,
-      &task, aType, aFlag, &result);
-  GetThread()->Dispatch(runnable.forget());
-
-  task.Wait();
-
-  return result.forget();
-}
-
-already_AddRefed<CanvasClient> ImageBridgeChild::CreateCanvasClientNow(
-    CanvasClient::CanvasClientType aType, TextureFlags aFlag) {
-  RefPtr<CanvasClient> client =
-      CanvasClient::CreateCanvasClient(aType, this, aFlag);
-  MOZ_ASSERT(client, "failed to create CanvasClient");
-  if (client) {
-    client->Connect();
-  }
-  return client.forget();
-}
-
 bool ImageBridgeChild::AllocUnsafeShmem(
     size_t aSize, ipc::SharedMemory::SharedMemoryType aType,
     ipc::Shmem* aShmem) {