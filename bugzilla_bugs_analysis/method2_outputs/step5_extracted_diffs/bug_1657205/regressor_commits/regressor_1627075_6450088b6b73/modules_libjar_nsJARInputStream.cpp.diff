# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsJARInputStream.cpp
# Commit: 6450088b6b73
# Full Hash: 6450088b6b73ffc17c79cd7097b1bfe30d00e207
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-09-14 21:29:41
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1656261 - Back out all recent StartupCache work r=RyanVM
#   
#   This backs out all work from bug 1627075 as well as all of its
#   descendents. There were a few conflicts when backing this out but
#   overall it was pretty clean, so I would say it's a fairly mild
# ==============================================================================

diff -r b0fabcd60430 -r 6450088b6b73 modules/libjar/nsJARInputStream.cpp
--- a/modules/libjar/nsJARInputStream.cpp	Mon Sep 14 17:32:40 2020 +0000
+++ b/modules/libjar/nsJARInputStream.cpp	Mon Sep 14 17:00:53 2020 +0000
@@ -67,15 +67,8 @@
 
   // Must keep handle to filepointer and mmap structure as long as we need
   // access to the mmapped data
-  rv = aJar->mZip->GetPersistentHandle(item, &mItemHandle,
-                                       CacheAwareZipReader::DeferCaching);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  mZs.next_in =
-      (Bytef*)aJar->mZip->GetData(item, CacheAwareZipReader::DeferCaching);
-
+  mFd = aJar->mZip->GetFD();
+  mZs.next_in = (Bytef*)aJar->mZip->GetData(item);
   if (!mZs.next_in) {
     return NS_ERROR_FILE_CORRUPTED;
   }
@@ -199,7 +192,7 @@
   *aBytesRead = 0;
 
   nsresult rv = NS_OK;
-  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mItemHandle.UnderlyingFD())
+  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
   switch (mMode) {
     case MODE_NOTINITED:
       return NS_OK;
@@ -218,15 +211,15 @@
         rv = ContinueInflate(aBuffer, aCount, aBytesRead);
       }
       // be aggressive about releasing the file!
-      // note that sometimes, we will release mItemHandle before we've finished
+      // note that sometimes, we will release  mFd before we've finished
       // deflating - this is because zlib buffers the input
       if (mZs.avail_in == 0) {
-        mItemHandle.ReleaseHandle();
+        mFd = nullptr;
       }
       break;
 
     case MODE_COPY:
-      if (mItemHandle) {
+      if (mFd) {
         uint32_t count = std::min(aCount, mOutSize - uint32_t(mZs.total_out));
         if (count) {
           memcpy(aBuffer, mZs.next_in + mZs.total_out, count);
@@ -235,10 +228,9 @@
         *aBytesRead = count;
       }
       // be aggressive about releasing the file!
-      // note that sometimes, we will release mItemHandle before we've finished
-      // copying.
+      // note that sometimes, we will release mFd before we've finished copying.
       if (mZs.total_out >= mOutSize) {
-        mItemHandle.ReleaseHandle();
+        mFd = nullptr;
       }
       break;
   }
@@ -270,7 +262,7 @@
   }
 #endif
   mMode = MODE_CLOSED;
-  mItemHandle.ReleaseHandle();
+  mFd = nullptr;
   return NS_OK;
 }
 