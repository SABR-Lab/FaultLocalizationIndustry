# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsZipArchive.cpp
# Commit: 6450088b6b73
# Full Hash: 6450088b6b73ffc17c79cd7097b1bfe30d00e207
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-09-14 21:29:41
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1656261 - Back out all recent StartupCache work r=RyanVM
#   
#   This backs out all work from bug 1627075 as well as all of its
#   descendents. There were a few conflicts when backing this out but
#   overall it was pretty clean, so I would say it's a fairly mild
# ==============================================================================

diff -r b0fabcd60430 -r 6450088b6b73 modules/libjar/nsZipArchive.cpp
--- a/modules/libjar/nsZipArchive.cpp	Mon Sep 14 17:32:40 2020 +0000
+++ b/modules/libjar/nsZipArchive.cpp	Mon Sep 14 17:00:53 2020 +0000
@@ -341,21 +341,11 @@
 //---------------------------------------------
 //  nsZipArchive::OpenArchive
 //---------------------------------------------
-nsresult nsZipArchive::OpenArchive(nsZipHandle* aZipHandle, PRFileDesc* aFd,
-                                   Span<const uint8_t> aCachedCentral) {
+nsresult nsZipArchive::OpenArchive(nsZipHandle* aZipHandle, PRFileDesc* aFd) {
   mFd = aZipHandle;
 
   //-- get table of contents for archive
-  nsresult rv = NS_OK;
-  if (!mBuiltFileList) {
-    if (!aCachedCentral.IsEmpty()) {
-      auto* start = aCachedCentral.Elements();
-      auto* end = start + aCachedCentral.Length();
-      rv = BuildFileListFromBuffer(start, end);
-    } else {
-      rv = BuildFileList(aFd);
-    }
-  }
+  nsresult rv = BuildFileList(aFd);
   if (NS_SUCCEEDED(rv)) {
     if (aZipHandle->mFile && XRE_IsParentProcess()) {
       static char* env = PR_GetEnv("MOZ_JAR_LOG_FILE");
@@ -409,8 +399,7 @@
   return rv;
 }
 
-nsresult nsZipArchive::OpenArchive(nsIFile* aFile,
-                                   Span<const uint8_t> aCachedCentral) {
+nsresult nsZipArchive::OpenArchive(nsIFile* aFile) {
   RefPtr<nsZipHandle> handle;
 #if defined(XP_WIN)
   mozilla::AutoFDClose fd;
@@ -421,9 +410,9 @@
   if (NS_FAILED(rv)) return rv;
 
 #if defined(XP_WIN)
-  return OpenArchive(handle, fd.get(), aCachedCentral);
+  return OpenArchive(handle, fd.get());
 #else
-  return OpenArchive(handle, nullptr, aCachedCentral);
+  return OpenArchive(handle);
 #endif
 }
 
@@ -473,75 +462,13 @@
   // Let us also cleanup the mFiles table for re-use on the next 'open' call
   memset(mFiles, 0, sizeof(mFiles));
   mBuiltSynthetics = false;
-
-  AutoWriteLock lock(mLazyOpenLock);
-  mLazyOpenParams = Nothing();
-
   return NS_OK;
 }
 
-nsresult nsZipArchive::EnsureArchiveOpenedOnDisk() {
-  {
-    AutoReadLock lock(mLazyOpenLock);
-    if (!mLazyOpenParams) {
-      return NS_OK;
-    }
-  }
-
-  AutoWriteLock lock(mLazyOpenLock);
-  if (!mLazyOpenParams) {
-    // Another thread beat us to opening the archive while we were waiting on
-    // the mutex.
-    return NS_OK;
-  }
-
-  nsresult rv = OpenArchive(mLazyOpenParams->mFile);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return NS_ERROR_UNEXPECTED;
-  }
-  mLazyOpenParams = Nothing();
-
-  return NS_OK;
-}
-
-nsresult nsZipArchive::EnsureFileListBuilt() {
-  {
-    AutoReadLock lock(mLazyOpenLock);
-    if (!mLazyOpenParams || mBuiltFileList) {
-      return NS_OK;
-    }
-  }
-
-  AutoWriteLock lock(mLazyOpenLock);
-  if (!mLazyOpenParams || mBuiltFileList) {
-    // Another thread beat us to building the file list while we were waiting
-    // on the mutex.
-    return NS_OK;
-  }
-
-  nsresult rv;
-  if (!mLazyOpenParams->mCachedCentral.IsEmpty()) {
-    auto* start = mLazyOpenParams->mCachedCentral.Elements();
-    auto* end = start + mLazyOpenParams->mCachedCentral.Length();
-    rv = BuildFileListFromBuffer(start, end);
-  } else {
-    rv = OpenArchive(mLazyOpenParams->mFile);
-    mLazyOpenParams = Nothing();
-  }
-
-  return rv;
-}
-
 //---------------------------------------------
 // nsZipArchive::GetItem
 //---------------------------------------------
 nsZipItem* nsZipArchive::GetItem(const char* aEntryName) {
-  nsresult rv = EnsureFileListBuilt();
-
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return nullptr;
-  }
-
   if (aEntryName) {
     uint32_t len = strlen(aEntryName);
     //-- If the request is for a directory, make sure that synthetic entries
@@ -625,12 +552,6 @@
 nsresult nsZipArchive::FindInit(const char* aPattern, nsZipFind** aFind) {
   if (!aFind) return NS_ERROR_ILLEGAL_VALUE;
 
-  nsresult rv = EnsureFileListBuilt();
-
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return NS_ERROR_UNEXPECTED;
-  }
-
   // null out param in case an error happens
   *aFind = nullptr;
 
@@ -638,7 +559,7 @@
   char* pattern = 0;
 
   // Create synthetic directory entries on demand
-  rv = BuildSynthetics();
+  nsresult rv = BuildSynthetics();
   if (rv != NS_OK) return rv;
 
   // validate the pattern
@@ -682,12 +603,7 @@
 
   *aResult = 0;
   *aNameLen = 0;
-
-  // NOTE: don't use GetFD here. if mFd is not null, then we need to have this
-  // fault handler, as we may be reading from the memory mapped file. However
-  // if it is null, then we can guarantee that we're reading here from a cached
-  // buffer, which we assume is not mapped to a file.
-  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mArchive->mFd)
+  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mArchive->GetFD())
   // we start from last match, look for next
   while (mSlot < ZIP_TABSIZE) {
     // move to next in current chain, or move to new slot
@@ -733,13 +649,10 @@
 //  nsZipArchive::BuildFileList
 //---------------------------------------------
 nsresult nsZipArchive::BuildFileList(PRFileDesc* aFd) {
-  mBuiltFileList = true;
   // Get archive size using end pos
   const uint8_t* buf;
   const uint8_t* startp = mFd->mFileData;
   const uint8_t* endp = startp + mFd->mLen;
-
-  nsresult rv;
   MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
   uint32_t centralOffset = 4;
   // Only perform readahead in the parent process. Children processes
@@ -764,63 +677,20 @@
     return NS_ERROR_FILE_CORRUPTED;
   }
 
-  uintptr_t startpInt = reinterpret_cast<uintptr_t>(startp);
-  if (startpInt + centralOffset < startpInt || centralOffset > mFd->mLen) {
+  buf = startp + centralOffset;
+
+  // avoid overflow of startp + centralOffset.
+  if (buf < startp) {
     return NS_ERROR_FILE_CORRUPTED;
   }
 
-  buf = startp + centralOffset;
-
-  mZipCentralOffset = centralOffset;
-  rv = BuildFileListFromBuffer(buf, endp);
-
-  MMAP_FAULT_HANDLER_CATCH(NS_ERROR_FAILURE)
-  return rv;
-}
-
-UniquePtr<uint8_t[]> nsZipArchive::CopyCentralDirectoryBuffer(size_t* aSize) {
-  *aSize = 0;
-
-  // mZipCentralOffset could in theory be 0. In practice though, we likely
-  // won't ever see this. If the end result is that we can't cache the buffer
-  // in these cases, that's fine.
-  if (!mZipCentralOffset || !mZipCentralSize) {
-    return nullptr;
-  }
-
-  const uint8_t* buf;
-  const uint8_t* startp = mFd->mFileData;
-  buf = startp + mZipCentralOffset;
-
-  // Just a sanity check to make sure these values haven't overflowed the
-  // buffer mapped to our file. Technically the pointer could overflow the max
-  // pointer value, but that could only happen with this check succeeding if
-  // mFd->mLen is incorrect, which we will here assume is impossible.
-  if (mZipCentralOffset + mZipCentralSize > mFd->mLen) {
-    return nullptr;
-  }
-
-  auto resultBuf = MakeUnique<uint8_t[]>(mZipCentralSize);
-
-  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
-  memcpy(resultBuf.get(), buf, mZipCentralSize);
-  MMAP_FAULT_HANDLER_CATCH(nullptr)
-
-  *aSize = mZipCentralSize;
-  return resultBuf;
-}
-
-nsresult nsZipArchive::BuildFileListFromBuffer(const uint8_t* aBuf,
-                                               const uint8_t* aEnd) {
-  mBuiltFileList = true;
-  const uint8_t* buf = aBuf;
   //-- Read the central directory headers
   uint32_t sig = 0;
   while ((buf + int32_t(sizeof(uint32_t)) > buf) &&
-         (buf + int32_t(sizeof(uint32_t)) <= aEnd) &&
+         (buf + int32_t(sizeof(uint32_t)) <= endp) &&
          ((sig = xtolong(buf)) == CENTRALSIG)) {
     // Make sure there is enough data available.
-    if ((buf > aEnd) || (aEnd - buf < ZIPCENTRAL_SIZE)) {
+    if ((buf > endp) || (endp - buf < ZIPCENTRAL_SIZE)) {
       return NS_ERROR_FILE_CORRUPTED;
     }
 
@@ -838,7 +708,7 @@
       return NS_ERROR_FILE_CORRUPTED;
     }
     if (buf >= buf + diff ||  // No overflow
-        buf >= aEnd - diff) {
+        buf >= endp - diff) {
       return NS_ERROR_FILE_CORRUPTED;
     }
 
@@ -865,18 +735,18 @@
   }
 
   // Make the comment available for consumers.
-  if ((aEnd >= buf) && (aEnd - buf >= ZIPEND_SIZE)) {
+  if ((endp >= buf) && (endp - buf >= ZIPEND_SIZE)) {
     ZipEnd* zipend = (ZipEnd*)buf;
 
     buf += ZIPEND_SIZE;
     uint16_t commentlen = xtoint(zipend->commentfield_len);
-    if (aEnd - buf >= commentlen) {
-      mCommentPtr = (const char*)aBuf;
+    if (endp - buf >= commentlen) {
+      mCommentPtr = (const char*)buf;
       mCommentLen = commentlen;
     }
   }
 
-  mZipCentralSize = buf - aBuf;
+  MMAP_FAULT_HANDLER_CATCH(NS_ERROR_FAILURE)
   return NS_OK;
 }
 
@@ -946,64 +816,15 @@
 }
 
 nsZipHandle* nsZipArchive::GetFD() {
-  nsresult rv = EnsureArchiveOpenedOnDisk();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return nullptr;
-  }
+  if (!mFd) return nullptr;
   return mFd.get();
 }
 
-void nsZipArchive::GetURIString(nsACString& result) {
-  {
-    AutoReadLock lock(mLazyOpenLock);
-    if (!mLazyOpenParams) {
-      mFd->mFile.GetURIString(result);
-      return;
-    }
-  }
-  AutoReadLock lock(mLazyOpenLock);
-  if (!mLazyOpenParams) {
-    // Another thread consumed mLazyOpenParams while we were waiting.
-    mFd->mFile.GetURIString(result);
-    return;
-  }
-
-  // This is a bit tricky - typically, we could just
-  // NS_GetURLSpecFromActualFile from mLazyOpenParams->mFile or from
-  // mFd->mFile.GetBaseFile(), depending on which we currently have. However,
-  // this won't actually be correct if this zip archive is nested inside
-  // another archive. However, at present, we know that mLazyOpenParams can
-  // only be here if we were opened from a real underlying file, so we assume
-  // that we're safe to do this. Any future code that breaks this assumption
-  // will need to update things here.
-  NS_GetURLSpecFromActualFile(mLazyOpenParams->mFile, result);
-}
-
-already_AddRefed<nsIFile> nsZipArchive::GetBaseFile() {
-  {
-    AutoReadLock lock(mLazyOpenLock);
-    if (!mLazyOpenParams) {
-      return mFd->mFile.GetBaseFile();
-    }
-  }
-  AutoReadLock lock(mLazyOpenLock);
-  if (!mLazyOpenParams) {
-    // Another thread consumed mLazyOpenParams while we were waiting.
-    return mFd->mFile.GetBaseFile();
-  }
-
-  nsCOMPtr<nsIFile> file = mLazyOpenParams->mFile;
-  return file.forget();
-}
-
 //---------------------------------------------
 // nsZipArchive::GetDataOffset
 //---------------------------------------------
 uint32_t nsZipArchive::GetDataOffset(nsZipItem* aItem) {
   MOZ_ASSERT(aItem);
-  nsresult rv = EnsureArchiveOpenedOnDisk();
-  MOZ_RELEASE_ASSERT(!NS_FAILED(rv),
-                     "Should have been able to open the zip archive");
 
   uint32_t offset;
   MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
@@ -1034,10 +855,6 @@
 //---------------------------------------------
 const uint8_t* nsZipArchive::GetData(nsZipItem* aItem) {
   MOZ_ASSERT(aItem);
-  nsresult rv = EnsureArchiveOpenedOnDisk();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return nullptr;
-  }
   uint32_t offset = GetDataOffset(aItem);
 
   MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
@@ -1072,12 +889,8 @@
 nsZipArchive::nsZipArchive()
     : mRefCnt(0),
       mCommentPtr(nullptr),
-      mZipCentralOffset(0),
-      mZipCentralSize(0),
       mCommentLen(0),
       mBuiltSynthetics(false),
-      mBuiltFileList(false),
-      mLazyOpenLock("nsZipArchive::mLazyOpenLock"),
       mUseZipLog(false) {
   // initialize the table to nullptr
   memset(mFiles, 0, sizeof(mFiles));
@@ -1385,14 +1198,12 @@
 nsZipItemPtr_base::nsZipItemPtr_base(nsZipArchive* aZip, const char* aEntryName,
                                      bool doCRC)
     : mReturnBuf(nullptr), mReadlen(0) {
-  nsZipItem* item = aZip->GetItem(aEntryName);
-  if (!item) {
-    return;
-  }
-
   // make sure the ziparchive hangs around
   mZipHandle = aZip->GetFD();
 
+  nsZipItem* item = aZip->GetItem(aEntryName);
+  if (!item) return;
+
   uint32_t size = 0;
   bool compressed = (item->Compression() == DEFLATED);
 #ifdef MOZ_JAR_BROTLI