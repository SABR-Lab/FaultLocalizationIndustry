# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/build/FileLocation.cpp
# Commit: 6450088b6b73
# Full Hash: 6450088b6b73ffc17c79cd7097b1bfe30d00e207
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-09-14 21:29:41
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1656261 - Back out all recent StartupCache work r=RyanVM
#   
#   This backs out all work from bug 1627075 as well as all of its
#   descendents. There were a few conflicts when backing this out but
#   overall it was pretty clean, so I would say it's a fairly mild
# ==============================================================================

diff -r b0fabcd60430 -r 6450088b6b73 xpcom/build/FileLocation.cpp
--- a/xpcom/build/FileLocation.cpp	Mon Sep 14 17:32:40 2020 +0000
+++ b/xpcom/build/FileLocation.cpp	Mon Sep 14 17:00:53 2020 +0000
@@ -7,7 +7,6 @@
 #include "FileLocation.h"
 #include "nsZipArchive.h"
 #include "nsURLHelper.h"
-#include "mozilla/Omnijar.h"
 
 namespace mozilla {
 
@@ -17,12 +16,12 @@
 
 FileLocation::FileLocation(nsIFile* aFile) { Init(aFile); }
 
-FileLocation::FileLocation(CacheAwareZipReader* aZip, const char* aPath) {
-  Init(aZip, aPath);
+FileLocation::FileLocation(nsIFile* aFile, const char* aPath) {
+  Init(aFile, aPath);
 }
 
 FileLocation::FileLocation(nsZipArchive* aZip, const char* aPath) {
-  Init(new CacheAwareZipReader(aZip, nullptr), aPath);
+  Init(aZip, aPath);
 }
 
 FileLocation::FileLocation(const FileLocation& aOther)
@@ -89,23 +88,18 @@
   mPath = aPath;
 }
 
-void FileLocation::Init(CacheAwareZipReader* aZip, const char* aPath) {
+void FileLocation::Init(nsZipArchive* aZip, const char* aPath) {
   mBaseZip = aZip;
   mBaseFile = nullptr;
   mPath = aPath;
 }
 
-void FileLocation::Init(nsZipArchive* aZip, const char* aPath) {
-  mBaseZip = new CacheAwareZipReader(aZip, nullptr);
-  mBaseFile = nullptr;
-  mPath = aPath;
-}
-
 void FileLocation::GetURIString(nsACString& aResult) const {
   if (mBaseFile) {
     net_GetURLSpecFromActualFile(mBaseFile, aResult);
   } else if (mBaseZip) {
-    mBaseZip->GetURIString(aResult);
+    RefPtr<nsZipHandle> handler = mBaseZip->GetFD();
+    handler->mFile.GetURIString(aResult);
   }
   if (IsZip()) {
     aResult.InsertLiteral("jar:", 0);
@@ -116,7 +110,11 @@
 
 already_AddRefed<nsIFile> FileLocation::GetBaseFile() {
   if (IsZip() && mBaseZip) {
-    return mBaseZip->GetBaseFile();
+    RefPtr<nsZipHandle> handler = mBaseZip->GetFD();
+    if (handler) {
+      return handler->mFile.GetBaseFile();
+    }
+    return nullptr;
   }
 
   nsCOMPtr<nsIFile> file = mBaseFile;
@@ -128,17 +126,23 @@
     return false;
   }
 
-  nsCOMPtr<nsIFile> a = mBaseFile;
-  nsCOMPtr<nsIFile> b = aFile.mBaseFile;
-  if (!mBaseFile && mBaseZip) {
-    a = mBaseZip->GetBaseFile();
-  }
-  if (!aFile.mBaseFile && aFile.mBaseZip) {
-    b = mBaseZip->GetBaseFile();
+  if (mBaseFile && aFile.mBaseFile) {
+    bool eq;
+    return NS_SUCCEEDED(mBaseFile->Equals(aFile.mBaseFile, &eq)) && eq;
   }
 
-  bool eq;
-  return NS_SUCCEEDED(a->Equals(b, &eq)) && eq;
+  const FileLocation* a = this;
+  const FileLocation* b = &aFile;
+  if (a->mBaseZip) {
+    RefPtr<nsZipHandle> handler = a->mBaseZip->GetFD();
+    a = &handler->mFile;
+  }
+  if (b->mBaseZip) {
+    RefPtr<nsZipHandle> handler = b->mBaseZip->GetFD();
+    b = &handler->mFile;
+  }
+
+  return a->Equals(*b);
 }
 
 nsresult FileLocation::GetData(Data& aData) {
@@ -147,7 +151,7 @@
   }
   aData.mZip = mBaseZip;
   if (!aData.mZip) {
-    aData.mZip = new CacheAwareZipReader();
+    aData.mZip = new nsZipArchive();
     aData.mZip->OpenArchive(mBaseFile);
   }
   aData.mItem = aData.mZip->GetItem(mPath.get());
@@ -191,8 +195,8 @@
     return NS_OK;
   }
   if (mItem) {
-    CacheAwareZipCursor cursor(mItem, mZip, reinterpret_cast<uint8_t*>(aBuf),
-                               aLen, true);
+    nsZipCursor cursor(mItem, mZip, reinterpret_cast<uint8_t*>(aBuf), aLen,
+                       true);
     uint32_t readLen;
     cursor.Copy(&readLen);
     if (readLen != aLen) {