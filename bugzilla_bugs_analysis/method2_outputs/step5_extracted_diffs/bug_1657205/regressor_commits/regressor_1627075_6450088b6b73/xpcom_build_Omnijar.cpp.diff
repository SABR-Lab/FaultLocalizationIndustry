# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/build/Omnijar.cpp
# Commit: 6450088b6b73
# Full Hash: 6450088b6b73ffc17c79cd7097b1bfe30d00e207
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-09-14 21:29:41
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1656261 - Back out all recent StartupCache work r=RyanVM
#   
#   This backs out all work from bug 1627075 as well as all of its
#   descendents. There were a few conflicts when backing this out but
#   overall it was pretty clean, so I would say it's a fairly mild
# ==============================================================================

diff -r b0fabcd60430 -r 6450088b6b73 xpcom/build/Omnijar.cpp
--- a/xpcom/build/Omnijar.cpp	Mon Sep 14 17:32:40 2020 +0000
+++ b/xpcom/build/Omnijar.cpp	Mon Sep 14 17:00:53 2020 +0000
@@ -1,5 +1,4 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- */
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -12,29 +11,16 @@
 #include "nsIFile.h"
 #include "nsZipArchive.h"
 #include "nsNetUtil.h"
-#include "mozilla/scache/StartupCache.h"
-#include "mozilla/MmapFaultHandler.h"
-#include "mozilla/UniquePtrExtensions.h"
 
 namespace mozilla {
 
 StaticRefPtr<nsIFile> Omnijar::sPath[2];
-StaticRefPtr<CacheAwareZipReader> Omnijar::sReader[2];
-StaticRefPtr<CacheAwareZipReader> Omnijar::sOuterReader[2];
+StaticRefPtr<nsZipArchive> Omnijar::sReader[2];
+StaticRefPtr<nsZipArchive> Omnijar::sOuterReader[2];
 bool Omnijar::sInitialized = false;
 bool Omnijar::sIsUnified = false;
 
-static MOZ_THREAD_LOCAL(int) tlsSuspendStartupCacheWrites;
-
-bool SuspendingStartupCacheWritesForCurrentThread() {
-  if (!tlsSuspendStartupCacheWrites.init()) {
-    return true;
-  }
-  return tlsSuspendStartupCacheWrites.get() > 0;
-}
-
 static const char* sProp[2] = {NS_GRE_DIR, NS_XPCOM_CURRENT_PROCESS_DIR};
-static const char* sCachePrefixes[2] = {"GreOmnijar:", "AppOmnijar:"};
 
 #define SPROP(Type) ((Type == mozilla::Omnijar::GRE) ? sProp[GRE] : sProp[APP])
 
@@ -108,9 +94,8 @@
   }
 
   CleanUpOne(aType);
-  sReader[aType] = new CacheAwareZipReader(zipReader, sCachePrefixes[aType]);
-  sOuterReader[aType] =
-      outerReader ? new CacheAwareZipReader(outerReader, nullptr) : nullptr;
+  sReader[aType] = zipReader;
+  sOuterReader[aType] = outerReader;
   sPath[aType] = file;
 }
 
@@ -126,7 +111,7 @@
   sInitialized = false;
 }
 
-already_AddRefed<CacheAwareZipReader> Omnijar::GetReader(nsIFile* aPath) {
+already_AddRefed<nsZipArchive> Omnijar::GetReader(nsIFile* aPath) {
   MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
 
   bool equals;
@@ -147,7 +132,7 @@
   return nullptr;
 }
 
-already_AddRefed<CacheAwareZipReader> Omnijar::GetInnerReader(
+already_AddRefed<nsZipArchive> Omnijar::GetInnerReader(
     nsIFile* aPath, const nsACString& aEntry) {
   MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
 
@@ -212,242 +197,4 @@
   return NS_OK;
 }
 
-CacheAwareZipReader::CacheAwareZipReader(nsZipArchive* aZip,
-                                         const char* aCacheKeyPrefix)
-    : mZip(aZip), mCacheKeyPrefix(aCacheKeyPrefix) {}
-
-nsresult CacheAwareZipReader::FindInit(const char* aPattern,
-                                       nsZipFind** aFind) {
-  return mZip->FindInit(aPattern, aFind);
-}
-
-const uint8_t* CacheAwareZipReader::GetData(
-    nsZipItem* aItem, CacheAwareZipReader::Caching aCaching) {
-  nsAutoCString cacheKey;
-  uint32_t size;
-  const uint8_t* cached =
-      GetCachedBuffer(aItem->Name(), aItem->nameLength, &size, cacheKey);
-  if (cached) {
-    MOZ_ASSERT(size == aItem->RealSize());
-    return cached;
-  }
-
-  const uint8_t* zipItemData = mZip->GetData(aItem);
-  if (!zipItemData) {
-    return nullptr;
-  }
-
-  // If the data is compressed, it is somewhat silly to store it in the startup
-  // cache, as the startup cache will try to double compress it.
-  if (aCaching == Default && aItem->Compression() == STORED &&
-      !cacheKey.IsEmpty()) {
-    MOZ_ASSERT(aItem->RealSize() == aItem->Size());
-    PutBufferIntoCache(cacheKey, zipItemData, aItem->Size());
-  }
-
-  return zipItemData;
-}
-
-const uint8_t* CacheAwareZipReader::GetData(
-    const char* aEntryName, uint32_t* aResultSize,
-    CacheAwareZipReader::Caching aCaching) {
-  nsAutoCString cacheKey;
-  const uint8_t* cached =
-      GetCachedBuffer(aEntryName, strlen(aEntryName), aResultSize, cacheKey);
-  if (cached) {
-    return cached;
-  }
-
-  nsZipItem* zipItem = mZip->GetItem(aEntryName);
-  if (!zipItem) {
-    *aResultSize = 0;
-    return nullptr;
-  }
-  const uint8_t* zipItemData = mZip->GetData(zipItem);
-  if (!zipItemData) {
-    return nullptr;
-  }
-
-  *aResultSize = zipItem->Size();
-
-  // If the data is compressed, it is somewhat silly to store it in the startup
-  // cache, as the startup cache will try to double compress it.
-  if (aCaching == Default && zipItem->Compression() == STORED &&
-      !cacheKey.IsEmpty()) {
-    MOZ_ASSERT(zipItem->RealSize() == *aResultSize);
-    PutBufferIntoCache(cacheKey, zipItemData, *aResultSize);
-  }
-
-  return zipItemData;
-}
-
-nsZipItem* CacheAwareZipReader::GetItem(const char* aEntryName) {
-  return mZip->GetItem(aEntryName);
-}
-
-nsresult CacheAwareZipReader::CloseArchive() { return mZip->CloseArchive(); }
-
-CacheAwareZipCursor::CacheAwareZipCursor(nsZipItem* aItem,
-                                         CacheAwareZipReader* aReader,
-                                         uint8_t* aBuf, uint32_t aBufSize,
-                                         bool aDoCRC)
-    : mItem(aItem),
-      mReader(aReader),
-      mBuf(aBuf),
-      mBufSize(aBufSize),
-      mDoCRC(aDoCRC) {}
-
-uint8_t* CacheAwareZipCursor::ReadOrCopy(uint32_t* aBytesRead, bool aCopy) {
-  nsCString cacheKey;
-  const uint8_t* cached = mReader->GetCachedBuffer(
-      mItem->Name(), mItem->nameLength, aBytesRead, cacheKey);
-  if (cached && *aBytesRead <= mBufSize) {
-    if (aCopy) {
-      memcpy(mBuf, cached, *aBytesRead);
-      return mBuf;
-    }
-
-    // The const cast is unfortunate, but it matches existing consumers'
-    // uses. We ought to file a bug to make Read return a const uint8_t*
-    return const_cast<uint8_t*>(cached);
-  }
-
-  nsZipCursor cursor(mItem, mReader->mZip, mBuf, mBufSize, mDoCRC);
-  uint8_t* buf = nullptr;
-  if (aCopy) {
-    cursor.Copy(aBytesRead);
-    buf = mBuf;
-  } else {
-    buf = cursor.Read(aBytesRead);
-  }
-
-  if (!buf) {
-    return nullptr;
-  }
-
-  if (!cacheKey.IsEmpty() && *aBytesRead == mItem->RealSize()) {
-    CacheAwareZipReader::PutBufferIntoCache(cacheKey, buf, *aBytesRead);
-  }
-
-  return buf;
-}
-
-nsresult CacheAwareZipReader::GetPersistentHandle(
-    nsZipItem* aItem, CacheAwareZipHandle* aHandle,
-    CacheAwareZipReader::Caching aCaching) {
-  nsCString cacheKey;
-  if (!mCacheKeyPrefix.IsEmpty() && aItem->Compression() == STORED) {
-    auto* cache = scache::StartupCache::GetSingleton();
-    if (cache) {
-      cacheKey.Append(mCacheKeyPrefix);
-      cacheKey.Append(aItem->Name(), aItem->nameLength);
-
-      if (cache->HasEntry(cacheKey.get())) {
-        aHandle->mDataIsCached = true;
-        aHandle->mFd = nullptr;
-        return NS_OK;
-      }
-      if (aCaching == DeferCaching) {
-        aHandle->mDeferredCachingKey = std::move(cacheKey);
-      }
-    }
-  }
-
-  nsresult rv = mZip->EnsureArchiveOpenedOnDisk();
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  aHandle->mDataIsCached = false;
-  aHandle->mFd = mZip->GetFD();
-
-  if (!aHandle->mDeferredCachingKey.IsEmpty() &&
-      aItem->Compression() == STORED) {
-    MOZ_ASSERT(aItem->RealSize() == aItem->Size());
-    const uint8_t* data = mZip->GetData(aItem);
-    if (data) {
-      aHandle->mDataToCache = Span(data, aItem->Size());
-    }
-  }
-
-  return NS_OK;
-}
-
-const uint8_t* CacheAwareZipReader::GetCachedBuffer(const char* aEntryName,
-                                                    uint32_t aEntryNameLength,
-                                                    uint32_t* aResultSize,
-                                                    nsCString& aCacheKey) {
-  *aResultSize = 0;
-  if (mCacheKeyPrefix.IsEmpty()) {
-    return nullptr;
-  }
-  auto* cache = scache::StartupCache::GetSingleton();
-  if (!cache) {
-    return nullptr;
-  }
-
-  aCacheKey.Append(mCacheKeyPrefix);
-  aCacheKey.Append(aEntryName, aEntryNameLength);
-
-  const char* cached;
-  nsresult rv = cache->GetBuffer(aCacheKey.get(), &cached, aResultSize);
-  if (NS_FAILED(rv)) {
-    return nullptr;
-  }
-
-  return reinterpret_cast<const uint8_t*>(cached);
-}
-
-void CacheAwareZipReader::PutBufferIntoCache(const nsCString& aCacheKey,
-                                             const uint8_t* aBuffer,
-                                             uint32_t aSize) {
-  if (SuspendingStartupCacheWritesForCurrentThread() || aSize == 0) {
-    return;
-  }
-
-  auto* cache = scache::StartupCache::GetSingleton();
-  auto dataCopy = MakeUniqueFallible<char[]>(aSize);
-
-  if (dataCopy) {
-    MMAP_FAULT_HANDLER_BEGIN_BUFFER(aBuffer, aSize)
-    memcpy(dataCopy.get(), aBuffer, aSize);
-    MMAP_FAULT_HANDLER_CATCH()
-    Unused << cache->PutBuffer(aCacheKey.get(), std::move(dataCopy), aSize);
-  }
-}
-
-void CacheAwareZipReader::PushSuspendStartupCacheWrites() {
-  if (!tlsSuspendStartupCacheWrites.init()) {
-    return;
-  }
-  tlsSuspendStartupCacheWrites.set(tlsSuspendStartupCacheWrites.get() + 1);
-}
-
-void CacheAwareZipReader::PopSuspendStartupCacheWrites() {
-  if (!tlsSuspendStartupCacheWrites.init()) {
-    return;
-  }
-  int current = tlsSuspendStartupCacheWrites.get();
-  MOZ_ASSERT(current > 0);
-  tlsSuspendStartupCacheWrites.set(current - 1);
-}
-
-void CacheAwareZipHandle::ReleaseHandle() {
-  if (!mDataToCache.IsEmpty()) {
-    MOZ_ASSERT(mFd);
-    MOZ_ASSERT(!mDeferredCachingKey.IsEmpty());
-    MOZ_ASSERT(!mDataIsCached);
-
-    auto* cache = scache::StartupCache::GetSingleton();
-    MOZ_ASSERT(cache);
-    if (cache) {
-      CacheAwareZipReader::PutBufferIntoCache(
-          mDeferredCachingKey, mDataToCache.Elements(), mDataToCache.Length());
-      mDataToCache = Span<const uint8_t>();
-    }
-  }
-
-  mFd = nullptr;
-}
-
 } /* namespace mozilla */