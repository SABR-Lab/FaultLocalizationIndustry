# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsJARInputStream.cpp
# Commit: a345e05df151
# Full Hash: a345e05df151563625fe05ec63094b3dae2c9379
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-07 21:31:11
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1627075 - Route Omnijar requests through StartupCache r=froydnj
#   
#   This should be a relatively straightforward patch. Essentially, we implement
#   a wrapper class (and friends) around nsZipArchive (and friends), which transparently
#   caches entries from the underlying zip archive in the StartupCache. This will break
# ==============================================================================

diff -r 288a67aed661 -r a345e05df151 modules/libjar/nsJARInputStream.cpp
--- a/modules/libjar/nsJARInputStream.cpp	Tue Jul 07 04:35:08 2020 +0000
+++ b/modules/libjar/nsJARInputStream.cpp	Tue Jul 07 04:36:27 2020 +0000
@@ -67,8 +67,15 @@
 
   // Must keep handle to filepointer and mmap structure as long as we need
   // access to the mmapped data
-  mFd = aJar->mZip->GetFD();
-  mZs.next_in = (Bytef*)aJar->mZip->GetData(item);
+  rv = aJar->mZip->GetPersistentHandle(item, &mItemHandle,
+                                       CacheAwareZipReader::DeferCaching);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  mZs.next_in =
+      (Bytef*)aJar->mZip->GetData(item, CacheAwareZipReader::DeferCaching);
+
   if (!mZs.next_in) {
     return NS_ERROR_FILE_CORRUPTED;
   }
@@ -192,7 +199,7 @@
   *aBytesRead = 0;
 
   nsresult rv = NS_OK;
-  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mFd)
+  MMAP_FAULT_HANDLER_BEGIN_HANDLE(mItemHandle.UnderlyingFD())
   switch (mMode) {
     case MODE_NOTINITED:
       return NS_OK;
@@ -211,15 +218,15 @@
         rv = ContinueInflate(aBuffer, aCount, aBytesRead);
       }
       // be aggressive about releasing the file!
-      // note that sometimes, we will release  mFd before we've finished
+      // note that sometimes, we will release mItemHandle before we've finished
       // deflating - this is because zlib buffers the input
       if (mZs.avail_in == 0) {
-        mFd = nullptr;
+        mItemHandle.ReleaseHandle();
       }
       break;
 
     case MODE_COPY:
-      if (mFd) {
+      if (mItemHandle) {
         uint32_t count = std::min(aCount, mOutSize - uint32_t(mZs.total_out));
         if (count) {
           memcpy(aBuffer, mZs.next_in + mZs.total_out, count);
@@ -228,9 +235,10 @@
         *aBytesRead = count;
       }
       // be aggressive about releasing the file!
-      // note that sometimes, we will release mFd before we've finished copying.
+      // note that sometimes, we will release mItemHandle before we've finished
+      // copying.
       if (mZs.total_out >= mOutSize) {
-        mFd = nullptr;
+        mItemHandle.ReleaseHandle();
       }
       break;
   }
@@ -262,7 +270,7 @@
   }
 #endif
   mMode = MODE_CLOSED;
-  mFd = nullptr;
+  mItemHandle.ReleaseHandle();
   return NS_OK;
 }
 