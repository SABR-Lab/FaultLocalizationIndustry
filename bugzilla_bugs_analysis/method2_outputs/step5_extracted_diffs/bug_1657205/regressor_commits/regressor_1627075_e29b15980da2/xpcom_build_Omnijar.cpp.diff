# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/build/Omnijar.cpp
# Commit: e29b15980da2
# Full Hash: e29b15980da270931b3c798b583687f56a6506a6
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2020-07-08 09:42:17
# Regressor Bug: 1627075
# File Overlap Count: 1
# Description:
#   Bug 1627075 - Route Omnijar requests through StartupCache r=froydnj
#   
#   This should be a relatively straightforward patch. Essentially, we implement
#   a wrapper class (and friends) around nsZipArchive (and friends), which transparently
#   caches entries from the underlying zip archive in the StartupCache. This will break
# ==============================================================================

diff -r eb5265addd5e -r e29b15980da2 xpcom/build/Omnijar.cpp
--- a/xpcom/build/Omnijar.cpp	Tue Jul 07 17:03:28 2020 +0000
+++ b/xpcom/build/Omnijar.cpp	Tue Jul 07 17:04:27 2020 +0000
@@ -1,4 +1,5 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -12,15 +13,25 @@
 #include "nsZipArchive.h"
 #include "nsNetUtil.h"
 #include "mozilla/scache/StartupCache.h"
+#include "mozilla/MmapFaultHandler.h"
 
 namespace mozilla {
 
 StaticRefPtr<nsIFile> Omnijar::sPath[2];
-StaticRefPtr<nsZipArchive> Omnijar::sReader[2];
-StaticRefPtr<nsZipArchive> Omnijar::sOuterReader[2];
+StaticRefPtr<CacheAwareZipReader> Omnijar::sReader[2];
+StaticRefPtr<CacheAwareZipReader> Omnijar::sOuterReader[2];
 bool Omnijar::sInitialized = false;
 bool Omnijar::sIsUnified = false;
 
+static MOZ_THREAD_LOCAL(int) tlsSuspendStartupCacheWrites;
+
+bool SuspendingStartupCacheWritesForCurrentThread() {
+  if (!tlsSuspendStartupCacheWrites.init()) {
+    return true;
+  }
+  return tlsSuspendStartupCacheWrites.get() > 0;
+}
+
 static const char* sProp[2] = {NS_GRE_DIR, NS_XPCOM_CURRENT_PROCESS_DIR};
 static const char* sCachePrefixes[2] = {"GreOmnijar:", "AppOmnijar:"};
 
@@ -83,7 +94,8 @@
   auto* cache = scache::StartupCache::GetSingleton();
   const uint8_t* centralBuf = nullptr;
   uint32_t centralBufLength = 0;
-  nsPrintfCString startupCacheKey("::%s:OmnijarCentral", sCachePrefixes[aType]);
+  nsCString startupCacheKey =
+      nsPrintfCString("::%s:OmnijarCentral", sCachePrefixes[aType]);
   if (cache) {
     nsresult rv = cache->GetBuffer(startupCacheKey.get(),
                                    reinterpret_cast<const char**>(&centralBuf),
@@ -93,10 +105,6 @@
       centralBufLength = 0;
     }
   }
-  if (NS_FAILED(zipReader->OpenArchive(
-          file, MakeSpan(centralBuf, centralBufLength)))) {
-    return;
-  }
 
   if (!centralBuf) {
     if (NS_FAILED(zipReader->OpenArchive(file))) {
@@ -132,8 +140,9 @@
   }
 
   CleanUpOne(aType);
-  sReader[aType] = zipReader;
-  sOuterReader[aType] = outerReader;
+  sReader[aType] = new CacheAwareZipReader(zipReader, sCachePrefixes[aType]);
+  sOuterReader[aType] =
+      outerReader ? new CacheAwareZipReader(outerReader, nullptr) : nullptr;
   sPath[aType] = file;
 }
 
@@ -149,7 +158,7 @@
   sInitialized = false;
 }
 
-already_AddRefed<nsZipArchive> Omnijar::GetReader(nsIFile* aPath) {
+already_AddRefed<CacheAwareZipReader> Omnijar::GetReader(nsIFile* aPath) {
   MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
 
   bool equals;
@@ -170,7 +179,7 @@
   return nullptr;
 }
 
-already_AddRefed<nsZipArchive> Omnijar::GetInnerReader(
+already_AddRefed<CacheAwareZipReader> Omnijar::GetInnerReader(
     nsIFile* aPath, const nsACString& aEntry) {
   MOZ_ASSERT(IsInitialized(), "Omnijar not initialized");
 
@@ -235,4 +244,226 @@
   return NS_OK;
 }
 
+CacheAwareZipReader::CacheAwareZipReader(nsZipArchive* aZip,
+                                         const char* aCacheKeyPrefix)
+    : mZip(aZip), mCacheKeyPrefix(aCacheKeyPrefix) {}
+
+nsresult CacheAwareZipReader::FindInit(const char* aPattern,
+                                       nsZipFind** aFind) {
+  return mZip->FindInit(aPattern, aFind);
+}
+
+const uint8_t* CacheAwareZipReader::GetData(
+    nsZipItem* aItem, CacheAwareZipReader::Caching aCaching) {
+  nsAutoCString cacheKey;
+  uint32_t size;
+  const uint8_t* cached =
+      GetCachedBuffer(aItem->Name(), aItem->nameLength, &size, cacheKey);
+  if (cached) {
+    MOZ_ASSERT(size == aItem->RealSize());
+    return cached;
+  }
+
+  const uint8_t* zipItemData = mZip->GetData(aItem);
+
+  // If the data is compressed, it is somewhat silly to store it in the startup
+  // cache, as the startup cache will try to double compress it.
+  if (aCaching == Default && aItem->Compression() == STORED &&
+      !cacheKey.IsEmpty()) {
+    MOZ_ASSERT(aItem->RealSize() == aItem->Size());
+    PutBufferIntoCache(cacheKey, zipItemData, aItem->Size());
+  }
+
+  return zipItemData;
+}
+
+const uint8_t* CacheAwareZipReader::GetData(
+    const char* aEntryName, uint32_t* aResultSize,
+    CacheAwareZipReader::Caching aCaching) {
+  nsAutoCString cacheKey;
+  const uint8_t* cached =
+      GetCachedBuffer(aEntryName, strlen(aEntryName), aResultSize, cacheKey);
+  if (cached) {
+    return cached;
+  }
+
+  nsZipItem* zipItem = mZip->GetItem(aEntryName);
+  if (!zipItem) {
+    *aResultSize = 0;
+    return nullptr;
+  }
+  const uint8_t* zipItemData = mZip->GetData(zipItem);
+  *aResultSize = zipItem->Size();
+
+  // If the data is compressed, it is somewhat silly to store it in the startup
+  // cache, as the startup cache will try to double compress it.
+  if (aCaching == Default && zipItem->Compression() == STORED &&
+      !cacheKey.IsEmpty()) {
+    MOZ_ASSERT(zipItem->RealSize() == *aResultSize);
+    PutBufferIntoCache(cacheKey, zipItemData, *aResultSize);
+  }
+
+  return zipItemData;
+}
+
+nsZipItem* CacheAwareZipReader::GetItem(const char* aEntryName) {
+  return mZip->GetItem(aEntryName);
+}
+
+nsresult CacheAwareZipReader::CloseArchive() { return mZip->CloseArchive(); }
+
+CacheAwareZipCursor::CacheAwareZipCursor(nsZipItem* aItem,
+                                         CacheAwareZipReader* aReader,
+                                         uint8_t* aBuf, uint32_t aBufSize,
+                                         bool aDoCRC)
+    : mItem(aItem),
+      mReader(aReader),
+      mBuf(aBuf),
+      mBufSize(aBufSize),
+      mDoCRC(aDoCRC) {}
+
+uint8_t* CacheAwareZipCursor::ReadOrCopy(uint32_t* aBytesRead, bool aCopy) {
+  nsCString cacheKey;
+  const uint8_t* cached = mReader->GetCachedBuffer(
+      mItem->Name(), mItem->nameLength, aBytesRead, cacheKey);
+  if (cached && *aBytesRead <= mBufSize) {
+    if (aCopy) {
+      memcpy(mBuf, cached, *aBytesRead);
+      return mBuf;
+    }
+
+    // The const cast is unfortunate, but it matches existing consumers'
+    // uses. We ought to file a bug to make Read return a const uint8_t*
+    return const_cast<uint8_t*>(cached);
+  }
+
+  nsZipCursor cursor(mItem, mReader->mZip, mBuf, mBufSize, mDoCRC);
+  uint8_t* buf = nullptr;
+  if (aCopy) {
+    cursor.Copy(aBytesRead);
+    buf = mBuf;
+  } else {
+    buf = cursor.Read(aBytesRead);
+  }
+
+  if (!cacheKey.IsEmpty() && *aBytesRead == mItem->RealSize()) {
+    CacheAwareZipReader::PutBufferIntoCache(cacheKey, buf, *aBytesRead);
+  }
+
+  return buf;
+}
+
+nsresult CacheAwareZipReader::GetPersistentHandle(
+    nsZipItem* aItem, CacheAwareZipHandle* aHandle,
+    CacheAwareZipReader::Caching aCaching) {
+  nsCString cacheKey;
+  if (!mCacheKeyPrefix.IsEmpty() && aItem->Compression() == STORED) {
+    auto* cache = scache::StartupCache::GetSingleton();
+    if (cache) {
+      cacheKey.Append(mCacheKeyPrefix);
+      cacheKey.Append(aItem->Name(), aItem->nameLength);
+
+      if (cache->HasEntry(cacheKey.get())) {
+        aHandle->mDataIsCached = true;
+        aHandle->mFd = nullptr;
+        return NS_OK;
+      }
+      if (aCaching == DeferCaching) {
+        aHandle->mDeferredCachingKey = std::move(cacheKey);
+      }
+    }
+  }
+
+  nsresult rv = mZip->EnsureArchiveOpenedOnDisk();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  aHandle->mDataIsCached = false;
+  aHandle->mFd = mZip->GetFD();
+
+  if (!aHandle->mDeferredCachingKey.IsEmpty() &&
+      aItem->Compression() == STORED) {
+    MOZ_ASSERT(aItem->RealSize() == aItem->Size());
+    aHandle->mDataToCache = MakeSpan(mZip->GetData(aItem), aItem->Size());
+  }
+
+  return NS_OK;
+}
+
+const uint8_t* CacheAwareZipReader::GetCachedBuffer(const char* aEntryName,
+                                                    uint32_t aEntryNameLength,
+                                                    uint32_t* aResultSize,
+                                                    nsCString& aCacheKey) {
+  *aResultSize = 0;
+  if (mCacheKeyPrefix.IsEmpty()) {
+    return nullptr;
+  }
+  auto* cache = scache::StartupCache::GetSingleton();
+  if (!cache) {
+    return nullptr;
+  }
+
+  aCacheKey.Append(mCacheKeyPrefix);
+  aCacheKey.Append(aEntryName, aEntryNameLength);
+
+  const char* cached;
+  nsresult rv = cache->GetBuffer(aCacheKey.get(), &cached, aResultSize);
+  if (NS_FAILED(rv)) {
+    return nullptr;
+  }
+
+  return reinterpret_cast<const uint8_t*>(cached);
+}
+
+void CacheAwareZipReader::PutBufferIntoCache(const nsCString& aCacheKey,
+                                             const uint8_t* aBuffer,
+                                             uint32_t aSize) {
+  if (SuspendingStartupCacheWritesForCurrentThread() || aSize == 0) {
+    return;
+  }
+
+  auto* cache = scache::StartupCache::GetSingleton();
+  auto dataCopy = MakeUnique<char[]>(aSize);
+
+  MMAP_FAULT_HANDLER_BEGIN_BUFFER(aBuffer, aSize)
+  memcpy(dataCopy.get(), aBuffer, aSize);
+  MMAP_FAULT_HANDLER_CATCH()
+  Unused << cache->PutBuffer(aCacheKey.get(), std::move(dataCopy), aSize);
+}
+
+void CacheAwareZipReader::PushSuspendStartupCacheWrites() {
+  if (!tlsSuspendStartupCacheWrites.init()) {
+    return;
+  }
+  tlsSuspendStartupCacheWrites.set(tlsSuspendStartupCacheWrites.get() + 1);
+}
+
+void CacheAwareZipReader::PopSuspendStartupCacheWrites() {
+  if (!tlsSuspendStartupCacheWrites.init()) {
+    return;
+  }
+  int current = tlsSuspendStartupCacheWrites.get();
+  MOZ_ASSERT(current > 0);
+  tlsSuspendStartupCacheWrites.set(current - 1);
+}
+
+void CacheAwareZipHandle::ReleaseHandle() {
+  if (!mDataToCache.IsEmpty()) {
+    MOZ_ASSERT(mFd);
+    MOZ_ASSERT(!mDeferredCachingKey.IsEmpty());
+    MOZ_ASSERT(!mDataIsCached);
+
+    auto* cache = scache::StartupCache::GetSingleton();
+    MOZ_ASSERT(cache);
+    if (cache) {
+      CacheAwareZipReader::PutBufferIntoCache(
+          mDeferredCachingKey, mDataToCache.Elements(), mDataToCache.Length());
+      mDataToCache = Span<const uint8_t>();
+    }
+  }
+
+  mFd = nullptr;
+}
+
 } /* namespace mozilla */