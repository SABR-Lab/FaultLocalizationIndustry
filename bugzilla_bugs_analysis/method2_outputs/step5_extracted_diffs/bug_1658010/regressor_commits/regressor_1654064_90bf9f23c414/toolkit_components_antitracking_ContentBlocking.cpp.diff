# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/antitracking/ContentBlocking.cpp
# Commit: 90bf9f23c414
# Full Hash: 90bf9f23c414f11c17ef9a15c6038c2785d00f03
# Author: Dimi Lee <dlee@mozilla.com>
# Date: 2020-08-06 03:34:56
# Regressor Bug: 1654064
# File Overlap Count: 1
# Description:
#   Bug 1654064 - P1. Use first-party check instead of top-level check while applying storage access heuristic r=baku
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D85826
# ==============================================================================

diff -r ffe62f1ef5dd -r 90bf9f23c414 toolkit/components/antitracking/ContentBlocking.cpp
--- a/toolkit/components/antitracking/ContentBlocking.cpp	Wed Aug 05 19:43:55 2020 +0000
+++ b/toolkit/components/antitracking/ContentBlocking.cpp	Wed Aug 05 20:58:04 2020 +0000
@@ -212,25 +212,24 @@
                                                                  __func__);
   }
 
-  bool isParentTopLevel = aParentContext->IsTopContent();
-
   // Make sure storage access isn't disabled
-  if (!isParentTopLevel &&
+  if (!aParentContext->IsTopContent() &&
       Document::StorageAccessSandboxed(aParentContext->GetSandboxFlags())) {
     LOG(("Our document is sandboxed"));
     return StorageAccessPermissionGrantPromise::CreateAndReject(false,
                                                                 __func__);
   }
 
+  bool isParentThirdParty = parentWindowContext->GetIsThirdPartyWindow();
   uint64_t topLevelWindowId;
   nsAutoCString trackingOrigin;
   nsCOMPtr<nsIPrincipal> trackingPrincipal;
 
   LOG(("The current resource is %s-party",
-       isParentTopLevel ? "first" : "third"));
+       isParentThirdParty ? "third" : "first"));
 
   // We are a first party resource.
-  if (isParentTopLevel) {
+  if (!isParentThirdParty) {
     nsAutoCString origin;
     nsresult rv = aPrincipal->GetAsciiOrigin(origin);
     if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -259,7 +258,7 @@
     if ((CookieJarSettings::IsRejectThirdPartyWithExceptions(behavior) ||
          behavior ==
              nsICookieService::BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN) &&
-        !parentWindowContext->GetIsThirdPartyWindow()) {
+        !isParentThirdParty) {
       LOG(("Our window isn't a third-party window"));
       return StorageAccessPermissionGrantPromise::CreateAndReject(false,
                                                                   __func__);
@@ -791,12 +790,18 @@
   // agent-cluster.
   for (const auto& topContext : aParentContext->Group()->Toplevels()) {
     if (topContext == aParentContext->Top()) {
-      // We don't have to update same-origin frames in the same tab unless
-      // when we are in fission mode and the storage permission granted is
-      // called by a first-party window and we are in fission mode.
+      // In non-fission mode, storage permission is stored in the top-level,
+      // don't need to propagtes it to tracker frames.
       bool useRemoteSubframes;
       aParentContext->GetUseRemoteSubframes(&useRemoteSubframes);
-      if (!useRemoteSubframes || !aParentContext->IsTop()) {
+      if (!useRemoteSubframes) {
+        continue;
+      }
+      // If parent context is third-party, we already propagate permission
+      // in the child process, skip propagating here.
+      RefPtr<dom::WindowContext> ctx =
+          aParentContext->GetCurrentWindowContext();
+      if (ctx && ctx->GetIsThirdPartyWindow()) {
         continue;
       }
     } else {
