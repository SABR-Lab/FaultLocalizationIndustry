# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/jsactor/JSActor.cpp
# Commit: 4ac5156712d7
# Full Hash: 4ac5156712d7aac5ae9c7c479131720bb928fae1
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-08-17 21:46:02
# Regressor Bug: 1658827
# File Overlap Count: 1
# Description:
#   Bug 1658827 - Clear exceptions before returning from JSActor promise handlers, r=kmag
#   
#   There must be no pending exceptions on the JSContext when returning from a
#   native promise handler. We were not successfully clearing exceptions in all
#   cases in JSActor logic, meaning that query replies with unserializable data
# ==============================================================================

diff -r 98fddfef58ce -r 4ac5156712d7 dom/ipc/jsactor/JSActor.cpp
--- a/dom/ipc/jsactor/JSActor.cpp	Mon Aug 17 15:19:34 2020 +0000
+++ b/dom/ipc/jsactor/JSActor.cpp	Mon Aug 17 15:50:04 2020 +0000
@@ -8,6 +8,7 @@
 #include "mozilla/dom/JSActorBinding.h"
 
 #include "mozilla/Attributes.h"
+#include "mozilla/FunctionRef.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/dom/ClonedErrorHolder.h"
 #include "mozilla/dom/ClonedErrorHolderBinding.h"
@@ -169,22 +170,33 @@
   mName = aName;
 }
 
+static ipc::StructuredCloneData CloneOrUndefined(
+    JSContext* aCx, JS::Handle<JS::Value> aValue,
+    FunctionRef<void()> aOnError = nullptr) {
+  ipc::StructuredCloneData data;
+
+  // Try to directly serialize the passed-in data, and return it to our caller.
+  IgnoredErrorResult rv;
+  data.Write(aCx, aValue, rv);
+  if (rv.Failed()) {
+    rv.SuppressException();
+    JS_ClearPendingException(aCx);
+    if (aOnError) {
+      aOnError();
+    }
+
+    // If the serialization failed, write out `undefined` instead.
+    data = ipc::StructuredCloneData();
+    data.Write(aCx, JS::UndefinedHandleValue, rv);
+    MOZ_RELEASE_ASSERT(!rv.Failed(), "OOM while serializing 'undefined'");
+  }
+  return data;
+}
+
 static ipc::StructuredCloneData CloneJSStack(JSContext* aCx,
                                              JS::Handle<JSObject*> aStack) {
   JS::Rooted<JS::Value> stackVal(aCx, JS::ObjectOrNullValue(aStack));
-
-  {
-    IgnoredErrorResult rv;
-    ipc::StructuredCloneData data;
-    data.Write(aCx, stackVal, rv);
-    if (!rv.Failed()) {
-      return data;
-    }
-  }
-  ErrorResult rv;
-  ipc::StructuredCloneData data;
-  data.Write(aCx, JS::NullHandleValue, rv);
-  return data;
+  return CloneOrUndefined(aCx, stackVal);
 }
 
 static ipc::StructuredCloneData CaptureJSStack(JSContext* aCx) {
@@ -378,7 +390,9 @@
                                              JS::Handle<JS::Value> aValue) {
   if (!mActor) {
     // Make sure that this rejection is reported. See comment below.
-    Unused << JS::CallOriginalPromiseReject(aCx, aValue);
+    if (!JS::CallOriginalPromiseReject(aCx, aValue)) {
+      JS_ClearPendingException(aCx);
+    }
     return;
   }
 
@@ -400,23 +414,17 @@
     }
   }
 
-  Maybe<ipc::StructuredCloneData> data;
-  data.emplace();
-  IgnoredErrorResult rv;
-  data->Write(aCx, value, rv);
-  if (rv.Failed()) {
-    // Failed to clone the rejection value. Make sure that this rejection is
-    // reported, despite being "handled". This is done by creating a new
-    // promise in the rejected state, and throwing it away. This will be
-    // reported as an unhandled rejected promise.
-    Unused << JS::CallOriginalPromiseReject(aCx, aValue);
-
-    data.reset();
-    data.emplace();
-    data->Write(aCx, JS::UndefinedHandleValue, rv);
-  }
-
-  SendReply(aCx, JSActorMessageKind::QueryReject, std::move(*data));
+  auto onerror = [&]() {
+    // Failed to clone the rejection value. Make sure that this
+    // rejection is reported, despite being "handled". This is done by
+    // creating a new promise in the rejected state, and throwing it
+    // away. This will be reported as an unhandled rejected promise.
+    if (!JS::CallOriginalPromiseReject(aCx, aValue)) {
+      JS_ClearPendingException(aCx);
+    }
+  };
+  SendReply(aCx, JSActorMessageKind::QueryReject,
+            CloneOrUndefined(aCx, value, onerror));
 }
 
 void JSActor::QueryHandler::ResolvedCallback(JSContext* aCx,
@@ -431,6 +439,8 @@
   IgnoredErrorResult error;
   data.Write(aCx, aValue, error);
   if (NS_WARN_IF(error.Failed())) {
+    JS_ClearPendingException(aCx);
+
     nsAutoCString msg;
     msg.Append(mActor->Name());
     msg.Append(':');
@@ -443,6 +453,8 @@
     JS::Rooted<JS::Value> val(aCx);
     if (ToJSValue(aCx, exc, &val)) {
       RejectedCallback(aCx, val);
+    } else {
+      JS_ClearPendingException(aCx);
     }
     return;
   }