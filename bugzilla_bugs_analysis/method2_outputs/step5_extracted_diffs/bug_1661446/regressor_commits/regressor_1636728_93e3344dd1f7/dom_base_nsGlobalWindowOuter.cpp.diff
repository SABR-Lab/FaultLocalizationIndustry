# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsGlobalWindowOuter.cpp
# Commit: 93e3344dd1f7
# Full Hash: 93e3344dd1f7454dc46c1553dd05e5e3bc78c349
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-08-26 03:24:37
# Regressor Bug: 1636728
# File Overlap Count: 1
# Description:
#   Bug 1636728 - Centralize printing entry points in nsGlobalWindowOuter, and move cloning out of nsPrintJob. r=jwatt,geckoview-reviewers,smaug,agi
#   
#   This centralizes our print and preview setup in nsGlobalWindowOuter so
#   that we never re-clone a clone, and so that we reuse the window.open()
#   codepath to create the browsing context to clone into.
# ==============================================================================

diff -r 2969f3de028f -r 93e3344dd1f7 dom/base/nsGlobalWindowOuter.cpp
--- a/dom/base/nsGlobalWindowOuter.cpp	Tue Aug 25 02:58:57 2020 +0000
+++ b/dom/base/nsGlobalWindowOuter.cpp	Tue Aug 25 17:45:12 2020 +0000
@@ -4,6 +4,8 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "mozilla/Assertions.h"
+#include "mozilla/ScopeExit.h"
 #include "nsGlobalWindow.h"
 
 #include <algorithm>
@@ -183,6 +185,7 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Selection.h"
 #include "nsFrameLoader.h"
+#include "nsFrameLoaderOwner.h"
 #include "nsXPCOMCID.h"
 #include "mozilla/Logging.h"
 #include "prenv.h"
@@ -2745,6 +2748,10 @@
 }
 
 bool nsGlobalWindowOuter::ShouldPromptToBlockDialogs() {
+  if (!nsContentUtils::GetCurrentJSContext()) {
+    return false;  // non-scripted caller.
+  }
+
   nsGlobalWindowOuter* topWindowOuter = GetInProcessScriptableTopInternal();
   if (!topWindowOuter) {
     NS_ASSERTION(!mDocShell,
@@ -5172,56 +5179,219 @@
   }
 }
 
+static CallState CollectDocuments(Document& aDoc,
+                                  nsTArray<nsCOMPtr<Document>>& aDocs) {
+  aDocs.AppendElement(&aDoc);
+  auto recurse = [&aDocs](Document& aSubDoc) {
+    return CollectDocuments(aSubDoc, aDocs);
+  };
+  aDoc.EnumerateSubDocuments(recurse);
+  return CallState::Continue;
+}
+
+static void DispatchPrintEventToWindowTree(
+    Document& aDoc, const nsAString& aEvent) {
+  if (aDoc.IsStaticDocument()) {
+    return;
+  }
+
+  nsTArray<nsCOMPtr<Document>> targets;
+  CollectDocuments(aDoc, targets);
+  for (nsCOMPtr<Document>& doc : targets) {
+    nsContentUtils::DispatchTrustedEvent(doc, doc->GetWindow(), aEvent,
+                                         CanBubble::eNo, Cancelable::eNo,
+                                         nullptr);
+  }
+}
+
 void nsGlobalWindowOuter::PrintOuter(ErrorResult& aError) {
-#ifdef NS_PRINTING
   if (!AreDialogsEnabled()) {
     // We probably want to keep throwing here; silently doing nothing is a bit
     // weird given the typical use cases of print().
-    aError.Throw(NS_ERROR_NOT_AVAILABLE);
-    return;
+    return aError.ThrowNotSupportedError("Dialogs not enabled for this window");
   }
 
   if (ShouldPromptToBlockDialogs() && !ConfirmDialogIfNeeded()) {
-    aError.Throw(NS_ERROR_NOT_AVAILABLE);
-    return;
-  }
-
-  RefPtr kungFuDeathGrip = this;
-  nsAutoSyncOperation sync(mDoc);
+    return aError.ThrowNotAllowedError("Prompt was canceled by the user");
+  }
+
+  const bool isPreview = StaticPrefs::print_tab_modal_enabled() &&
+                         !StaticPrefs::print_always_print_silent();
+  Print(nullptr, nullptr, nullptr, isPreview, aError);
+}
+
+Nullable<WindowProxyHolder> nsGlobalWindowOuter::Print(
+    nsIPrintSettings* aPrintSettings, nsIWebProgressListener* aListener,
+    nsIDocShell* aDocShellToCloneInto, bool aIsPreview, ErrorResult& aError) {
+#ifdef NS_PRINTING
+  nsCOMPtr<nsIPrintSettingsService> printSettingsService =
+      do_GetService("@mozilla.org/gfx/printsettings-service;1");
+  if (!printSettingsService) {
+    // we currently return here in headless mode - should we?
+    aError.ThrowNotSupportedError("No print settings service");
+    return nullptr;
+  }
+
+  RefPtr<Document> docToPrint = mDoc;
+  MOZ_DIAGNOSTIC_ASSERT(docToPrint,
+                        "This gets forwarded from the inner when "
+                        "we have an active window, so there should "
+                        "be a document");
+  if (!docToPrint) {
+    aError.ThrowNotSupportedError("Document is gone");
+    return nullptr;
+  }
+
+  RefPtr<BrowsingContext> sourceBC = docToPrint->GetBrowsingContext();
+  MOZ_DIAGNOSTIC_ASSERT(sourceBC);
+  if (!sourceBC) {
+    aError.ThrowNotSupportedError("No browsing context");
+    return nullptr;
+  }
+
+  nsAutoSyncOperation sync(docToPrint);
   EnterModalState();
-  auto leave = MakeScopeExit([&] { LeaveModalState(); });
-
-  if (StaticPrefs::print_tab_modal_enabled()) {
-    RefPtr<BrowsingContext> bc = GetBrowsingContext();
-    if (!bc || bc->IsDiscarded()) {
-      return;
-    }
-
-    if (bc->IsAwaitingPrint()) {
-      // Already printing.
-      return;
-    }
-
-    MOZ_ALWAYS_SUCCEEDS(bc->SetIsAwaitingPrint(true));
-    SpinEventLoopUntil(
-        [&] { return bc->IsDiscarded() || !bc->IsAwaitingPrint(); });
+  auto exitModal = MakeScopeExit([&] { LeaveModalState(); });
+
+  nsCOMPtr<nsIContentViewer> cv;
+  RefPtr<BrowsingContext> bc;
+  if (docToPrint->IsStaticDocument() && aIsPreview) {
+    // We're already a print preview window, just reuse our browsing context /
+    // content viewer.
+    //
+    // TODO(emilio): When the old print preview UI is gone and the new print UI
+    // auto-closes when printing (bug 1659624), we can remove the aIsPreview
+    // condition and just reuse the document for printing as well.
+    bc = sourceBC;
+    nsCOMPtr<nsIDocShell> docShell = bc->GetDocShell();
+    if (!docShell) {
+      aError.ThrowNotSupportedError("No docshell");
+      return nullptr;
+    }
+    // We could handle this if needed.
+    if (aDocShellToCloneInto && aDocShellToCloneInto != docShell) {
+      aError.ThrowNotSupportedError(
+          "We don't handle cloning a print preview doc into a different "
+          "docshell");
+      return nullptr;
+    }
+    docShell->GetContentViewer(getter_AddRefs(cv));
+    MOZ_DIAGNOSTIC_ASSERT(cv);
   } else {
-    nsCOMPtr<nsIPrintSettingsService> printSettingsService =
-        do_GetService("@mozilla.org/gfx/printsettings-service;1");
-    if (!printSettingsService) {
-      // we currently return here in headless mode - should we?
-      aError.Throw(NS_ERROR_NOT_AVAILABLE);
-      return;
-    }
-
-    nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint =
-        do_GetInterface(static_cast<nsIInterfaceRequestor*>(this));
-    if (!webBrowserPrint) {
-      aError.Throw(NS_ERROR_NOT_AVAILABLE);
-      return;
-    }
-    webBrowserPrint->Print(nullptr, nullptr);
-  }
+    if (aDocShellToCloneInto) {
+      bc = aDocShellToCloneInto->GetBrowsingContext();
+    } else {
+      AutoNoJSAPI nojsapi;
+      auto printKind = aIsPreview ? PrintKind::PrintPreview : PrintKind::Print;
+      aError = OpenInternal(EmptyString(), EmptyString(), EmptyString(),
+                            false,             // aDialog
+                            false,             // aContentModal
+                            true,              // aCalledNoScript
+                            false,             // aDoJSFixups
+                            true,              // aNavigate
+                            nullptr, nullptr,  // No args
+                            nullptr,           // aLoadState
+                            false,             // aForceNoOpener
+                            printKind, getter_AddRefs(bc));
+      if (NS_WARN_IF(aError.Failed())) {
+        return nullptr;
+      }
+    }
+    if (!bc) {
+      aError.ThrowNotAllowedError("No browsing context");
+      return nullptr;
+    }
+    nsCOMPtr<nsIDocShell> cloneDocShell = bc->GetDocShell();
+    MOZ_DIAGNOSTIC_ASSERT(cloneDocShell);
+    cloneDocShell->GetContentViewer(getter_AddRefs(cv));
+    MOZ_DIAGNOSTIC_ASSERT(cv);
+    if (!cv) {
+      aError.ThrowNotSupportedError("Didn't end up with a content viewer");
+      return nullptr;
+    }
+
+    if (bc != sourceBC) {
+      MOZ_ASSERT(bc->IsTopContent());
+      // If we are cloning from a document in a different BrowsingContext, we
+      // need to make sure to copy over our opener policy information from that
+      // BrowsingContext. In the case where the source is an iframe, this
+      // information needs to be copied from the toplevel source
+      // BrowsingContext, as we may be making a static clone of a single
+      // subframe.
+      MOZ_ALWAYS_SUCCEEDS(
+          bc->SetOpenerPolicy(sourceBC->Top()->GetOpenerPolicy()));
+    }
+
+    if (RefPtr<Document> doc = cv->GetDocument()) {
+      if (doc->IsShowing()) {
+        // We're going to drop this document on the floor, in the SetDocument
+        // call below. Make sure to run OnPageHide() to keep state consistent
+        // and avoids assertions in the document destructor.
+        doc->OnPageHide(false, nullptr);
+      }
+    }
+
+    // TODO(emilio): Should dispatch this to OOP iframes too.
+    DispatchPrintEventToWindowTree(*docToPrint, u"beforeprint"_ns);
+    auto dispatchAfterPrint = MakeScopeExit(
+        [&] { DispatchPrintEventToWindowTree(*docToPrint, u"afterprint"_ns); });
+
+    RefPtr<Document> clone;
+    {
+      nsAutoScriptBlocker blockScripts;
+      clone = docToPrint->CreateStaticClone(cloneDocShell);
+      if (!clone) {
+        aError.ThrowNotSupportedError("Clone operation for printing failed");
+        return nullptr;
+      }
+
+      // Do this now so that we get a script handling object, and thus can
+      // create our clones.
+      aError = cv->SetDocument(clone);
+      if (aError.Failed()) {
+        return nullptr;
+      }
+
+      auto pendingFrameClones = clone->TakePendingFrameStaticClones();
+      for (const auto& clone : pendingFrameClones) {
+        RefPtr<Element> element = do_QueryObject(clone.mElement);
+        RefPtr<nsFrameLoader> frameLoader =
+            nsFrameLoader::Create(element, /* aNetworkCreated */ false);
+
+        if (NS_WARN_IF(!frameLoader)) {
+          continue;
+        }
+
+        clone.mElement->SetFrameLoader(frameLoader);
+
+        nsCOMPtr<nsIDocShell> docshell;
+        RefPtr<Document> doc;
+        nsresult rv = frameLoader->FinishStaticClone(clone.mStaticCloneOf,
+                                                     getter_AddRefs(docshell),
+                                                     getter_AddRefs(doc));
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          continue;
+        }
+      }
+    }
+  }
+
+  nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint = do_QueryInterface(cv);
+  if (!webBrowserPrint) {
+    aError.ThrowNotSupportedError(
+        "Content viewer didn't implement nsIWebBrowserPrint");
+    return nullptr;
+  }
+
+  if (aIsPreview) {
+    aError = webBrowserPrint->PrintPreview(aPrintSettings, aListener);
+  } else {
+    // Historically we've eaten this error.
+    webBrowserPrint->Print(aPrintSettings, aListener);
+  }
+  return WindowProxyHolder(std::move(bc));
+#else
+  return nullptr;
 #endif  // NS_PRINTING
 }
 
@@ -5634,7 +5804,7 @@
                       false,             // aDoJSFixups
                       true,              // aNavigate
                       nullptr, nullptr,  // No args
-                      aLoadState, aForceNoOpener, _retval);
+                      aLoadState, aForceNoOpener, PrintKind::None, _retval);
 }
 
 nsresult nsGlobalWindowOuter::OpenJS(const nsAString& aUrl,
@@ -5650,7 +5820,7 @@
                       nullptr, nullptr,  // No args
                       nullptr,           // aLoadState
                       false,             // aForceNoOpener
-                      _retval);
+                      PrintKind::None, _retval);
 }
 
 // like Open, but attaches to the new window any extra parameters past
@@ -5669,7 +5839,7 @@
                       nullptr, aExtraArgument,  // Arguments
                       nullptr,                  // aLoadState
                       false,                    // aForceNoOpener
-                      _retval);
+                      PrintKind::None, _retval);
 }
 
 // Like Open, but passes aNavigate=false.
@@ -5687,7 +5857,7 @@
                       nullptr, nullptr,  // No args
                       nullptr,           // aLoadState
                       false,             // aForceNoOpener
-                      _retval);
+                      PrintKind::None, _retval);
 }
 
 Nullable<WindowProxyHolder> nsGlobalWindowOuter::OpenDialogOuter(
@@ -5712,7 +5882,7 @@
                         argvArray, nullptr,  // Arguments
                         nullptr,             // aLoadState
                         false,               // aForceNoOpener
-                        getter_AddRefs(dialog));
+                        PrintKind::None, getter_AddRefs(dialog));
   if (!dialog) {
     return nullptr;
   }
@@ -6900,7 +7070,7 @@
     const nsAString& aUrl, const nsAString& aName, const nsAString& aOptions,
     bool aDialog, bool aContentModal, bool aCalledNoScript, bool aDoJSFixups,
     bool aNavigate, nsIArray* argv, nsISupports* aExtraArgument,
-    nsDocShellLoadState* aLoadState, bool aForceNoOpener,
+    nsDocShellLoadState* aLoadState, bool aForceNoOpener, PrintKind aPrintKind,
     BrowsingContext** aReturn) {
 #ifdef DEBUG
   uint32_t argc = 0;
@@ -7051,6 +7221,19 @@
   bool isPopupSpamWindow =
       checkForPopup && (abuseLevel >= PopupBlocker::openControlled);
 
+  const auto wwPrintKind = [&] {
+    switch (aPrintKind) {
+      case PrintKind::None:
+        return nsPIWindowWatcher::PRINT_NONE;
+      case PrintKind::Print:
+        return nsPIWindowWatcher::PRINT_REGULAR;
+      case PrintKind::PrintPreview:
+        return nsPIWindowWatcher::PRINT_PREVIEW;
+    }
+    MOZ_ASSERT_UNREACHABLE("Wat");
+    return nsPIWindowWatcher::PRINT_NONE;
+  }();
+
   {
     // Reset popup state while opening a window to prevent the
     // current state from being active the whole time a modal
@@ -7063,8 +7246,8 @@
       rv = pwwatch->OpenWindow2(this, url, name, options,
                                 /* aCalledFromScript = */ true, aDialog,
                                 aNavigate, argv, isPopupSpamWindow,
-                                forceNoOpener, forceNoReferrer, aLoadState,
-                                getter_AddRefs(domReturn));
+                                forceNoOpener, forceNoReferrer, wwPrintKind,
+                                aLoadState, getter_AddRefs(domReturn));
     } else {
       // Force a system caller here so that the window watcher won't screw us
       // up.  We do NOT want this case looking at the JS context on the stack
@@ -7083,8 +7266,8 @@
       rv = pwwatch->OpenWindow2(this, url, name, options,
                                 /* aCalledFromScript = */ false, aDialog,
                                 aNavigate, aExtraArgument, isPopupSpamWindow,
-                                forceNoOpener, forceNoReferrer, aLoadState,
-                                getter_AddRefs(domReturn));
+                                forceNoOpener, forceNoReferrer, wwPrintKind,
+                                aLoadState, getter_AddRefs(domReturn));
     }
   }
 