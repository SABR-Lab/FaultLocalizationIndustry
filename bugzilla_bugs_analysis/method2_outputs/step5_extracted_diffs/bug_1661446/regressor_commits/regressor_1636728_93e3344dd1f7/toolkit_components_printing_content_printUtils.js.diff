# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/printing/content/printUtils.js
# Commit: 93e3344dd1f7
# Full Hash: 93e3344dd1f7454dc46c1553dd05e5e3bc78c349
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2020-08-26 03:24:37
# Regressor Bug: 1636728
# File Overlap Count: 1
# Description:
#   Bug 1636728 - Centralize printing entry points in nsGlobalWindowOuter, and move cloning out of nsPrintJob. r=jwatt,geckoview-reviewers,smaug,agi
#   
#   This centralizes our print and preview setup in nsGlobalWindowOuter so
#   that we never re-clone a clone, and so that we reuse the window.open()
#   codepath to create the browsing context to clone into.
# ==============================================================================

diff -r 2969f3de028f -r 93e3344dd1f7 toolkit/components/printing/content/printUtils.js
--- a/toolkit/components/printing/content/printUtils.js	Tue Aug 25 02:58:57 2020 +0000
+++ b/toolkit/components/printing/content/printUtils.js	Tue Aug 25 17:45:12 2020 +0000
@@ -72,6 +72,12 @@
   false
 );
 
+ChromeUtils.defineModuleGetter(
+  this,
+  "PromptUtils",
+  "resource://gre/modules/SharedPromptUtils.jsm"
+);
+
 var gFocusedElement = null;
 
 var PrintUtils = {
@@ -138,22 +144,33 @@
    *
    * @param aBrowsingContext
    *        The BrowsingContext of the window to print.
+   * @param aExistingPreviewBrowser
+   *        An existing browser created for printing from window.print().
    */
-  async _openTabModalPrint(aBrowsingContext) {
-    let sourceBrowser = aBrowsingContext.embedderElement;
+  _openTabModalPrint(aBrowsingContext, aExistingPreviewBrowser) {
+    let sourceBrowser = aBrowsingContext.top.embedderElement;
     let previewBrowser = this.getPreviewBrowser(sourceBrowser);
-
     if (previewBrowser) {
       // Don't open another dialog if we're already printing.
-      aBrowsingContext.isAwaitingPrint = false;
+      //
+      // XXX This can be racy can't it? getPreviewBrowser looks at browser that
+      // we set up after opening the dialog. But I guess worst case we just
+      // open two dialogs so...
+      if (aExistingPreviewBrowser) {
+        aExistingPreviewBrowser.remove();
+      }
       return;
     }
 
+    // Create a preview browser.
+    let args = PromptUtils.objectToPropBag({
+      previewBrowser: aExistingPreviewBrowser,
+    });
     let dialogBox = gBrowser.getTabDialogBox(sourceBrowser);
     dialogBox.open(
       `chrome://global/content/print.html?browsingContextId=${aBrowsingContext.id}`,
       "resizable=no",
-      null,
+      args,
       { sizeTo: "available" }
     );
   },
@@ -166,13 +183,51 @@
    *        The BrowsingContext of the window to print.
    *        Note that the browsing context could belong to a subframe of the
    *        tab that called window.print, or similar shenanigans.
+   * @param aOpenWindowInfo
+   *        Non-null if this call comes from window.print(). This is the
+   *        nsIOpenWindowInfo object that has to be passed down to
+   *        createBrowser in order for the child process to clone into it.
    */
-  startPrintWindow(aBrowsingContext) {
-    if (PRINT_TAB_MODAL && !PRINT_ALWAYS_SILENT) {
-      this._openTabModalPrint(aBrowsingContext);
-    } else {
-      this.printWindow(aBrowsingContext);
+  startPrintWindow(aBrowsingContext, aOpenWindowInfo) {
+    let browser = null;
+    if (aOpenWindowInfo) {
+      browser = gBrowser.createBrowser({
+        remoteType: aBrowsingContext.currentRemoteType,
+        openWindowInfo: aOpenWindowInfo,
+        skipLoad: false,
+      });
+      // When the print process finishes, we get closed by
+      // nsDocumentViewer::OnDonePrinting, or by the print preview code.
+      //
+      // When that happens, we should remove us from the DOM if connected.
+      browser.addEventListener("DOMWindowClose", function(e) {
+        if (browser.isConnected) {
+          browser.remove();
+        }
+        e.stopPropagation();
+        e.preventDefault();
+      });
+      browser.style.visibility = "collapse";
+      document.documentElement.appendChild(browser);
     }
+
+    if (
+      PRINT_TAB_MODAL &&
+      !PRINT_ALWAYS_SILENT &&
+      (!aOpenWindowInfo || aOpenWindowInfo.isForPrintPreview)
+    ) {
+      this._openTabModalPrint(aBrowsingContext, browser);
+      return browser;
+    }
+
+    if (browser) {
+      // Legacy print dialog or silent printing, the content process will print
+      // in this <browser>.
+      return browser;
+    }
+
+    this.printWindow(aBrowsingContext, null);
+    return null;
   },
 
   /**