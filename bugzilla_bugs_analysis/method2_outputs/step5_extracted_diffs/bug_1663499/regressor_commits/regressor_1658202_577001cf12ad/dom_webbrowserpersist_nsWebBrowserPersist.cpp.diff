# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webbrowserpersist/nsWebBrowserPersist.cpp
# Commit: 577001cf12ad
# Full Hash: 577001cf12adbb122a6618988616ef12ccb354d9
# Author: Gijs Kruitbosch <gijskruitbosch@gmail.com>
# Date: 2020-09-02 03:31:14
# Regressor Bug: 1658202
# File Overlap Count: 2
# Description:
#   Bug 1658202 - move flushes caused by closing the stream away from the main thread, r=valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D88731
# ==============================================================================

diff -r bc244bc15836 -r 577001cf12ad dom/webbrowserpersist/nsWebBrowserPersist.cpp
--- a/dom/webbrowserpersist/nsWebBrowserPersist.cpp	Tue Sep 01 07:18:38 2020 +0000
+++ b/dom/webbrowserpersist/nsWebBrowserPersist.cpp	Tue Sep 01 00:14:26 2020 +0000
@@ -889,8 +889,30 @@
       SendErrorStatusChange(true, status, request, data->mFile);
     }
 
+    // If there is a stream ref, close it away from the main thread.
+    {
+      MutexAutoLock lock(data->mStreamMutex);
+      if (data->mStream) {
+        if (!mBackgroundQueue) {
+          nsresult rv = NS_CreateBackgroundTaskQueue(
+              "WebBrowserPersist", getter_AddRefs(mBackgroundQueue));
+          if (NS_FAILED(rv)) {
+            return rv;
+          }
+        }
+        // Now steal the stream ref and close it away from the main thread,
+        // keeping the promise around so we don't finish before all files
+        // are flushed and closed.
+        mFileClosePromises.AppendElement(InvokeAsync(
+            mBackgroundQueue, __func__, [stream = std::move(data->mStream)]() {
+              nsresult rv = stream->Close();
+              // We don't care if closing failed; we don't care in the
+              // destructor either...
+              return ClosePromise::CreateAndResolve(rv, __func__);
+            }));
+      }
+    }
     MutexAutoLock lock(mOutputMapMutex);
-    // This will automatically close the output stream
     mOutputMap.Remove(keyPtr);
   } else {
     // if we didn't find the data in mOutputMap, try mUploadList
@@ -2275,7 +2297,14 @@
   if (NS_SUCCEEDED(mPersistResult) && NS_FAILED(aResult)) {
     mPersistResult = aResult;
   }
-
+  ClosePromise::All(GetCurrentSerialEventTarget(), mFileClosePromises)
+      ->Then(GetCurrentSerialEventTarget(), __func__,
+             [self = RefPtr{this}, aResult]() {
+               self->EndDownloadInternal(aResult);
+             });
+}
+
+void nsWebBrowserPersist::EndDownloadInternal(nsresult aResult) {
   // mCompleted needs to be set before issuing the stop notification.
   // (Bug 1224437)
   mCompleted = true;