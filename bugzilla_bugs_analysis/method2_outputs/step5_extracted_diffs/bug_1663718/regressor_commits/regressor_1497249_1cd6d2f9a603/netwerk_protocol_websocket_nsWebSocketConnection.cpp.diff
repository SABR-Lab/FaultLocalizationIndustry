# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/websocket/nsWebSocketConnection.cpp
# Commit: 1cd6d2f9a603
# Full Hash: 1cd6d2f9a603ad02a533b12c4602612e90f7da5a
# Author: Kershaw Chang <kershaw@mozilla.com>
# Date: 2020-08-05 21:44:54
# Regressor Bug: 1497249
# File Overlap Count: 2
# Description:
#   Bug 1497249 - Don't release WebSocketChannel in nsWebSocketConnection::Close, r=michal,necko-reviewers
#   
#   Depends on D30624
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D85735
# ==============================================================================

diff -r 2502449c2e24 -r 1cd6d2f9a603 netwerk/protocol/websocket/nsWebSocketConnection.cpp
--- a/netwerk/protocol/websocket/nsWebSocketConnection.cpp	Wed Aug 05 15:17:38 2020 +0000
+++ b/netwerk/protocol/websocket/nsWebSocketConnection.cpp	Mon Aug 03 11:33:23 2020 +0000
@@ -20,7 +20,13 @@
       mSocketIn(aInputStream),
       mSocketOut(aOutputStream),
       mWriteOffset(0),
-      mStartReadingCalled(false) {}
+      mStartReadingCalled(false) {
+  LOG(("nsWebSocketConnection ctor %p\n", this));
+}
+
+nsWebSocketConnection::~nsWebSocketConnection() {
+  LOG(("nsWebSocketConnection dtor %p\n", this));
+}
 
 NS_IMETHODIMP
 nsWebSocketConnection::Init(nsIWebSocketConnectionListener* aListener,
@@ -47,6 +53,7 @@
 
 NS_IMETHODIMP
 nsWebSocketConnection::Close() {
+  LOG(("nsWebSocketConnection::Close %p\n", this));
   if (mTransport) {
     mTransport->SetSecurityCallbacks(nullptr);
     mTransport->SetEventSink(nullptr, nullptr);
@@ -66,7 +73,6 @@
     mSocketOut = nullptr;
   }
 
-  mListener = nullptr;
   return NS_OK;
 }
 
@@ -157,11 +163,12 @@
 nsWebSocketConnection::OnInputStreamReady(nsIAsyncInputStream* aStream) {
   LOG(("nsWebSocketConnection::OnInputStreamReady() %p\n", this));
   MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
+  MOZ_ASSERT(mListener);
 
-  if (!mSocketIn)  // did we we clean up the socket after scheduling InputReady?
+  // did we we clean up the socket after scheduling InputReady?
+  if (!mSocketIn) {
     return NS_OK;
-
-  if (!mListener) return NS_OK;
+  }
 
   // this is after the http upgrade - so we are speaking websockets
   uint8_t buffer[2048];
@@ -202,8 +209,11 @@
 nsWebSocketConnection::OnOutputStreamReady(nsIAsyncOutputStream* aStream) {
   LOG(("nsWebSocketConnection::OnOutputStreamReady() %p\n", this));
   MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
+  MOZ_ASSERT(mListener);
 
-  if (!mListener) return NS_OK;
+  if (!mSocketOut) {
+    return NS_OK;
+  }
 
   while (!mOutputQueue.empty()) {
     const OutputData& data = mOutputQueue.front();
@@ -215,6 +225,9 @@
 
     uint32_t wrote = 0;
     nsresult rv = mSocketOut->Write(buffer, toWrite, &wrote);
+    LOG(("nsWebSocketConnection::OnOutputStreamReady: write %u rv %" PRIx32,
+         wrote, static_cast<uint32_t>(rv)));
+
     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
       mSocketOut->AsyncWait(this, 0, 0, mEventTarget);
       return NS_OK;