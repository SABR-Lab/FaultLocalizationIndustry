# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/websocket/nsWebSocketConnection.cpp
# Commit: f7b6aac1b58b
# Full Hash: f7b6aac1b58bc959e431136e1b23231abe55d0b1
# Author: Kershaw Chang <kershaw@mozilla.com>
# Date: 2020-07-16 21:27:37
# Regressor Bug: 1497249
# File Overlap Count: 4
# Description:
#   Bug 1497249 - P2: ipdl for nsIWebSocketConnection r=michal
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D30624
# ==============================================================================

diff -r 74bb3c2ab767 -r f7b6aac1b58b netwerk/protocol/websocket/nsWebSocketConnection.cpp
--- a/netwerk/protocol/websocket/nsWebSocketConnection.cpp	Thu Jul 16 12:59:23 2020 +0000
+++ b/netwerk/protocol/websocket/nsWebSocketConnection.cpp	Thu Jul 16 13:34:58 2020 +0000
@@ -9,7 +9,6 @@
 #include "WebSocketLog.h"
 #include "nsIOService.h"
 #include "nsISocketTransport.h"
-#include "nsSocketTransportService2.h"
 
 NS_IMPL_ISUPPORTS(nsWebSocketConnection, nsIWebSocketConnection,
                   nsIInputStreamCallback, nsIOutputStreamCallback)
@@ -29,9 +28,6 @@
   NS_ENSURE_ARG_POINTER(aListener);
   NS_ENSURE_ARG_POINTER(aEventTarget);
 
-  MOZ_ASSERT_IF(nsIOService::UseSocketProcess(), XRE_IsSocketProcess());
-  MOZ_ASSERT_IF(!nsIOService::UseSocketProcess(), XRE_IsParentProcess());
-
   mListener = aListener;
   mEventTarget = aEventTarget;
 
@@ -43,7 +39,7 @@
     nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryInterface(mListener);
     mTransport->SetSecurityCallbacks(callbacks);
   } else {
-    // TODO: deal with security callbacks in bug 1512479
+    // NOTE: we don't use security callbacks in socket process.
     mTransport->SetSecurityCallbacks(nullptr);
   }
   return mTransport->SetEventSink(nullptr, nullptr);
@@ -74,24 +70,32 @@
   return NS_OK;
 }
 
+nsresult nsWebSocketConnection::EnqueueOutputData(
+    nsTArray<uint8_t>&& aHeader, nsTArray<uint8_t>&& aPayload) {
+  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
+
+  mOutputQueue.emplace_back(std::move(aHeader));
+  mOutputQueue.emplace_back(std::move(aPayload));
+
+  if (mSocketOut) {
+    mSocketOut->AsyncWait(this, 0, 0, mEventTarget);
+  }
+
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsWebSocketConnection::EnqueueOutputData(const uint8_t* aHdrBuf,
                                          uint32_t aHdrBufLength,
                                          const uint8_t* aPayloadBuf,
                                          uint32_t aPayloadBufLength) {
   LOG(("nsWebSocketConnection::EnqueueOutputData %p\n", this));
-  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
-  nsTArray<uint8_t> data;
-  data.AppendElements(aHdrBuf, aHdrBufLength);
-  data.AppendElements(aPayloadBuf, aPayloadBufLength);
-  mOutputQueue.emplace_back(std::move(data));
-
-  if (mSocketOut) {
-    mSocketOut->AsyncWait(this, 0, 0, mEventTarget);
-  }
-
-  return NS_OK;
+  nsTArray<uint8_t> header;
+  header.AppendElements(aHdrBuf, aHdrBufLength);
+  nsTArray<uint8_t> payload;
+  payload.AppendElements(aPayloadBuf, aPayloadBufLength);
+  return EnqueueOutputData(std::move(header), std::move(payload));
 }
 
 NS_IMETHODIMP
@@ -107,7 +111,7 @@
 
 NS_IMETHODIMP
 nsWebSocketConnection::DrainSocketData() {
-  MOZ_ASSERT(OnSocketThread());
+  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
 
   if (!mSocketIn || !mListener) {
     return NS_ERROR_NOT_AVAILABLE;
@@ -148,7 +152,7 @@
 NS_IMETHODIMP
 nsWebSocketConnection::OnInputStreamReady(nsIAsyncInputStream* aStream) {
   LOG(("nsWebSocketConnection::OnInputStreamReady() %p\n", this));
-  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
 
   if (!mSocketIn)  // did we we clean up the socket after scheduling InputReady?
     return NS_OK;
@@ -193,7 +197,7 @@
 NS_IMETHODIMP
 nsWebSocketConnection::OnOutputStreamReady(nsIAsyncOutputStream* aStream) {
   LOG(("nsWebSocketConnection::OnOutputStreamReady() %p\n", this));
-  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
+  MOZ_ASSERT(mEventTarget->IsOnCurrentThread());
 
   if (!mListener) return NS_OK;
 