# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmValidate.h
# Commit: 008f196ed172
# Full Hash: 008f196ed1720c98f2a1ce1ff442d5371ca33742
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2020-08-19 10:01:16
# Regressor Bug: 1561521
# File Overlap Count: 1
# Description:
#   Bug 1561521 - Refine ref.null decoding to decode heaptype instead of reftype. r=lth
#   
#   ref.null takes a heaptype immediate. This is backwards compatible for
#   reference-types, but is a breaking change for the GC proposal. This commit
#   implements decoding for this refinement.
# ==============================================================================

diff -r 546d74acfb81 -r 008f196ed172 js/src/wasm/WasmValidate.h
--- a/js/src/wasm/WasmValidate.h	Tue Aug 18 16:58:59 2020 +0000
+++ b/js/src/wasm/WasmValidate.h	Tue Aug 18 16:59:06 2020 +0000
@@ -731,33 +731,11 @@
           return fail("(ref T) types not enabled");
         }
         bool nullable = code == uint8_t(TypeCode::NullableRef);
-
-        uint8_t nextByte;
-        if (!peekByte(&nextByte)) {
-          return fail("unable to read heap type");
+        RefType refType;
+        if (!readHeapType(numTypes, true, nullable, &refType)) {
+          return false;
         }
-
-        if ((nextByte & SLEB128SignMask) == SLEB128SignBit) {
-          uint8_t code;
-          if (!readFixedU8(&code)) {
-            return false;
-          }
-
-          switch (code) {
-            case uint8_t(TypeCode::FuncRef):
-            case uint8_t(TypeCode::ExternRef):
-              *type = RefType::fromTypeCode(TypeCode(code), nullable);
-              return true;
-            default:
-              return fail("invalid heap type");
-          }
-        }
-
-        int32_t x;
-        if (!readVarS32(&x) || x < 0 || uint32_t(x) >= numTypes) {
-          return fail("invalid heap type index");
-        }
-        *type = RefType::fromTypeIndex(x, nullable);
+        *type = refType;
         return true;
       }
 #  endif
@@ -779,6 +757,55 @@
     }
     return true;
   }
+  MOZ_MUST_USE bool readHeapType(uint32_t numTypes, bool gcTypesEnabled,
+                                 bool nullable, RefType* type) {
+    uint8_t nextByte;
+    if (!peekByte(&nextByte)) {
+      return fail("expected heap type code");
+    }
+
+    if ((nextByte & SLEB128SignMask) == SLEB128SignBit) {
+      uint8_t code;
+      if (!readFixedU8(&code)) {
+        return false;
+      }
+
+      switch (code) {
+        case uint8_t(TypeCode::FuncRef):
+        case uint8_t(TypeCode::ExternRef):
+          *type = RefType::fromTypeCode(TypeCode(code), nullable);
+          return true;
+        default:
+          return fail("invalid heap type");
+      }
+    }
+
+#ifndef ENABLE_WASM_GC
+    return fail("invalid heap type");
+#else
+    if (!gcTypesEnabled) {
+      return fail("(ref T) types not enabled");
+    }
+
+    int32_t x;
+    if (!readVarS32(&x) || x < 0 || uint32_t(x) >= numTypes) {
+      return fail("invalid heap type index");
+    }
+    *type = RefType::fromTypeIndex(x, nullable);
+    return true;
+#endif
+  }
+  MOZ_MUST_USE bool readHeapType(const TypeDefVector& types,
+                                 bool gcTypesEnabled, bool nullable,
+                                 RefType* type) {
+    if (!readHeapType(types.length(), gcTypesEnabled, nullable, type)) {
+      return false;
+    }
+    if (type->isTypeIndex() && !types[type->typeIndex()].isStructType()) {
+      return fail("type index does not reference a struct type");
+    }
+    return true;
+  }
   MOZ_MUST_USE bool readRefType(uint32_t numTypes, bool gcTypesEnabled,
                                 RefType* type) {
     ValType valType;
