# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmValidate.cpp
# Commit: 8ce9bbcd26e3
# Full Hash: 8ce9bbcd26e343a8d845a817cea33fd875805541
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2020-08-19 10:01:16
# Regressor Bug: 1561521
# File Overlap Count: 2
# Description:
#   Bug 1561521 - Generalize table/element code for future reference-types. r=lth
#   
#   wasm::Table uses wasm::TableKind to determine the element type of the table,
#   which makes it difficult to extend tables to support more reference types. This
#   commit drops TableKind in favor of directly storing the element RefType, along
# ==============================================================================

diff -r 7805ddfe2bfa -r 8ce9bbcd26e3 js/src/wasm/WasmValidate.cpp
--- a/js/src/wasm/WasmValidate.cpp	Tue Aug 18 16:58:32 2020 +0000
+++ b/js/src/wasm/WasmValidate.cpp	Tue Aug 18 16:58:48 2020 +0000
@@ -1883,28 +1883,15 @@
 }
 
 static bool DecodeTableTypeAndLimits(Decoder& d, bool refTypesEnabled,
+                                     bool gcTypesEnabled,
+                                     const TypeDefVector& types,
                                      TableDescVector* tables) {
-  uint8_t elementType;
-  if (!d.readFixedU8(&elementType)) {
-    return d.fail("expected table element type");
+  RefType tableElemType;
+  if (!d.readRefType(types, gcTypesEnabled, &tableElemType)) {
+    return false;
   }
-
-  TableKind tableKind;
-  if (elementType == uint8_t(TypeCode::FuncRef)) {
-    tableKind = TableKind::FuncRef;
-#ifdef ENABLE_WASM_REFTYPES
-  } else if (elementType == uint8_t(TypeCode::ExternRef)) {
-    if (!refTypesEnabled) {
-      return d.fail("expected 'funcref' element type");
-    }
-    tableKind = TableKind::AnyRef;
-#endif
-  } else {
-#ifdef ENABLE_WASM_REFTYPES
-    return d.fail("expected reference element type");
-#else
+  if (!refTypesEnabled && !tableElemType.isFunc()) {
     return d.fail("expected 'funcref' element type");
-#endif
   }
 
   Limits limits;
@@ -1933,7 +1920,7 @@
     maximumLength = Some(uint32_t(*limits.maximum));
   }
 
-  return tables->emplaceBack(tableKind, initialLength, maximumLength);
+  return tables->emplaceBack(tableElemType, initialLength, maximumLength, /* isAsmJS */ false);
 }
 
 static bool GlobalIsJSCompatible(Decoder& d, ValType type) {
@@ -2066,7 +2053,9 @@
       break;
     }
     case DefinitionKind::Table: {
-      if (!DecodeTableTypeAndLimits(d, env->refTypesEnabled(), &env->tables)) {
+      if (!DecodeTableTypeAndLimits(d, env->refTypesEnabled(),
+                                    env->gcTypesEnabled(), env->types,
+                                    &env->tables)) {
         return false;
       }
       env->tables.back().importedOrExported = true;
@@ -2192,7 +2181,9 @@
   }
 
   for (uint32_t i = 0; i < numTables; ++i) {
-    if (!DecodeTableTypeAndLimits(d, env->refTypesEnabled(), &env->tables)) {
+    if (!DecodeTableTypeAndLimits(d, env->refTypesEnabled(),
+                                  env->gcTypesEnabled(), env->types,
+                                  &env->tables)) {
       return false;
     }
   }
@@ -2291,7 +2282,7 @@
         return false;
       }
       if (!expected.isReference() ||
-          !env->isRefSubtypeOf(ValType(initType), ValType(expected))) {
+          !env->isRefSubtypeOf(initType, expected.refType())) {
         return d.fail(
             "type mismatch: initializer type and expected type don't match");
       }
@@ -2338,7 +2329,8 @@
                     env->isStructType(globals[i].type())) &&
                    !env->gcTypesEnabled()) {
           fail = true;
-        } else if (!env->isRefSubtypeOf(globals[i].type(), expected)) {
+        } else if (!env->isRefSubtypeOf(globals[i].type().refType(),
+                                        expected.refType())) {
           fail = true;
         }
         if (fail) {
@@ -2670,7 +2662,7 @@
     }
 
     ElemSegmentPayload payload = flags->payload();
-    ValType elemType;
+    RefType elemType;
 
     // `ActiveWithTableIndex`, `Declared`, and `Passive` element segments encode
     // the type or definition kind of the payload. `Active` element segments are
@@ -2678,28 +2670,19 @@
     if (kind == ElemSegmentKind::Active) {
       elemType = RefType::func();
     } else {
-      uint8_t form;
-      if (!d.readFixedU8(&form)) {
-        return d.fail("expected type or extern kind");
-      }
-
       switch (payload) {
         case ElemSegmentPayload::ElemExpression: {
-          switch (form) {
-            case uint8_t(TypeCode::FuncRef):
-              elemType = RefType::func();
-              break;
-            case uint8_t(TypeCode::ExternRef):
-              elemType = RefType::extern_();
-              break;
-            default:
-              return d.fail(
-                  "segments with element expressions can only contain "
-                  "references");
+          if (!d.readRefType(env->types, env->gcTypesEnabled(), &elemType)) {
+            return false;
           }
           break;
         }
         case ElemSegmentPayload::ExternIndex: {
+          uint8_t form;
+          if (!d.readFixedU8(&form)) {
+            return d.fail("expected type or extern kind");
+          }
+
           if (form != uint8_t(DefinitionKind::Function)) {
             return d.fail(
                 "segments with extern indices can only contain function "
@@ -2714,10 +2697,8 @@
     switch (kind) {
       case ElemSegmentKind::Active:
       case ElemSegmentKind::ActiveWithTableIndex: {
-        ValType tblElemType = ToElemValType(env->tables[seg->tableIndex].kind);
-        if (!(elemType == tblElemType ||
-              (elemType.isReference() && tblElemType.isReference() &&
-               env->isRefSubtypeOf(elemType, tblElemType)))) {
+        RefType tblElemType = env->tables[seg->tableIndex].elemType;
+        if (!env->isRefSubtypeOf(elemType, tblElemType)) {
           return d.fail(
               "segment's element type must be subtype of table's element type");
         }
@@ -2725,12 +2706,12 @@
       }
       case ElemSegmentKind::Declared:
       case ElemSegmentKind::Passive: {
-        // By construction, above.
-        MOZ_ASSERT(elemType.isReference());
+        // Passive segment element types are checked when used with a
+        // `table.init` instruction.
         break;
       }
     }
-    seg->elementType = elemType;
+    seg->elemType = elemType;
 
     uint32_t numElems;
     if (!d.readVarU32(&numElems)) {
@@ -2782,7 +2763,7 @@
           default:
             return d.fail("failed to read initializer operation");
         }
-        if (!env->isRefSubtypeOf(ValType(initType), ValType(elemType))) {
+        if (!env->isRefSubtypeOf(initType, elemType)) {
           return d.fail("initializer type must be subtype of element type");
         }
       }