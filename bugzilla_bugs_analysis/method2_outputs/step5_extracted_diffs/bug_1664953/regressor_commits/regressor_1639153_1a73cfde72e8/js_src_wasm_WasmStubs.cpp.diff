# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmStubs.cpp
# Commit: 1a73cfde72e8
# Full Hash: 1a73cfde72e8f4d19bdcfdbffa9fbc78bba01e24
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2021-09-28 09:54:33
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Introduce indirect stubs to optimize call_indirect. r=lth
#   
#   This patch introduces indirect stubs.
#   An indirect stub is a stub that takes care of any switching activities needed for call_indirect.
#   Before this patch, we have to conservatively assume that any call_indirect's target can be from a foreign instance,
# ==============================================================================

diff -r da3c5d8492db -r 1a73cfde72e8 js/src/wasm/WasmStubs.cpp
--- a/js/src/wasm/WasmStubs.cpp	Tue Sep 28 05:16:23 2021 +0000
+++ b/js/src/wasm/WasmStubs.cpp	Tue Sep 28 05:24:15 2021 +0000
@@ -1979,7 +1979,7 @@
   }
 
   // Call the import exit stub.
-  CallSiteDesc desc(CallSiteDesc::Dynamic);
+  CallSiteDesc desc(CallSiteDesc::Import);
   MoveSPForJitABI(masm);
   masm.wasmCallImport(desc, CalleeDesc::import(fi.tlsDataOffset()));
 
@@ -2568,6 +2568,167 @@
   }
 };
 
+static void PushFrame(MacroAssembler& masm) {
+#if defined(JS_CODEGEN_MIPS32) || defined(JS_CODEGEN_MIPS64)
+  masm.subFromStackPtr(Imm32(sizeof(Frame)));
+  masm.storePtr(ra, Address(StackPointer, Frame::returnAddressOffset()));
+  masm.storePtr(FramePointer, Address(StackPointer, Frame::callerFPOffset()));
+#elif defined(JS_CODEGEN_ARM64)
+  {
+    AutoForbidPoolsAndNops afp(&masm,
+                               /* number of instructions in scope = */ 3);
+    masm.Sub(sp, sp, sizeof(Frame));
+    masm.Str(ARMRegister(lr, 64), MemOperand(sp, Frame::returnAddressOffset()));
+    masm.Str(ARMRegister(FramePointer, 64),
+             MemOperand(sp, Frame::callerFPOffset()));
+  }
+#elif defined(JS_CODEGEN_ARM) || defined(JS_CODEGEN_X64) || \
+    defined(JS_CODEGEN_X86)
+  {
+#  if defined(JS_CODEGEN_ARM)
+    AutoForbidPoolsAndNops afp(&masm,
+                               /* number of instructions in scope = */ 3);
+    masm.push(lr);
+#  endif
+    masm.push(FramePointer);
+  }
+#else
+  MOZ_CRASH("Unknown architecture");
+#endif
+}
+
+static void PopFrame(MacroAssembler& masm) {
+#if defined(JS_CODEGEN_MIPS32) || defined(JS_CODEGEN_MIPS64)
+  masm.loadPtr(Address(StackPointer, Frame::callerFPOffset()), FramePointer);
+  masm.loadPtr(Address(StackPointer, Frame::returnAddressOffset()), ra);
+  masm.addToStackPtr(Imm32(sizeof(Frame)));
+#elif defined(JS_CODEGEN_ARM64)
+  {
+    AutoForbidPoolsAndNops afp(&masm,
+                               /* number of instructions in scope = */ 3);
+
+    masm.Ldr(ARMRegister(FramePointer, 64),
+             MemOperand(sp, Frame::callerFPOffset()));
+    masm.Ldr(ARMRegister(lr, 64), MemOperand(sp, Frame::returnAddressOffset()));
+    masm.Add(sp, sp, sizeof(Frame));
+  }
+#elif defined(JS_CODEGEN_ARM)
+  {
+    AutoForbidPoolsAndNops afp(&masm,
+                               /* number of instructions in scope = */ 3);
+    masm.pop(FramePointer);
+    masm.pop(lr);
+  }
+#elif defined(JS_CODEGEN_X64) || defined(JS_CODEGEN_X86)
+  masm.pop(FramePointer);
+#else
+  MOZ_CRASH("Unknown architecture");
+#endif
+}
+
+static void AllocateStackBytes(MacroAssembler& masm, const uint32_t bytes) {
+  if (!bytes) {
+    return;
+  }
+
+#if defined(JS_CODEGEN_ARM64)
+  masm.Sub(sp, sp, bytes);
+#else
+  masm.subPtr(Imm32(static_cast<int32_t>(bytes)), masm.getStackPointer());
+#endif
+}
+
+static void DeallocateStackBytes(MacroAssembler& masm, const uint32_t bytes) {
+  if (!bytes) {
+    return;
+  }
+
+#if defined(JS_CODEGEN_ARM64)
+  masm.Add(sp, sp, bytes);
+#else
+  masm.addPtr(Imm32(static_cast<int32_t>(bytes)), masm.getStackPointer());
+#endif
+}
+
+bool wasm::GenerateIndirectStub(MacroAssembler& masm,
+                                uint8_t* calleeCheckedEntry, TlsData* tlsPtr,
+                                Offsets* offsets) {
+#if defined(JS_CODEGEN_ARM64)
+  // See comment in |GenerateCallablePrologue|.
+  // Revisit after resolution of the
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=1709853.
+  const vixl::Register stashedSPreg = masm.GetStackPointer64();
+  masm.SetStackPointer64(vixl::sp);
+#endif
+
+  ImmWord tlsPtrImm(reinterpret_cast<uintptr_t>(tlsPtr));
+  Label sameInstanceCase;
+
+  masm.haltingAlign(CodeAlignment);
+  offsets->begin = masm.currentOffset();
+  masm.setFramePushed(0);
+
+  masm.movePtr(tlsPtrImm, WasmTableCallScratchReg0);
+  masm.branchPtr(Assembler::Condition::Equal, WasmTlsReg,
+                 WasmTableCallScratchReg0, &sameInstanceCase);
+
+  // Preserve caller's TLS and callee's TLS.
+  masm.storePtr(WasmTlsReg,
+                Address(masm.getStackPointer(), WasmCallerTLSOffsetAfterCall));
+  masm.movePtr(WasmTableCallScratchReg0, WasmTlsReg);
+  masm.storePtr(WasmTableCallScratchReg0,
+                Address(masm.getStackPointer(), WasmCalleeTLSOffsetAfterCall));
+  masm.loadWasmPinnedRegsFromTls();
+  masm.switchToWasmTlsRealm(WasmTableCallIndexReg, WasmTableCallScratchReg1);
+
+  // Setup the frame for this stub and tag caller FP so runtime can recongize
+  // it during stack walking.
+  PushFrame(masm);
+  masm.moveStackPtrTo(FramePointer);
+  masm.addPtr(Imm32(wasm::TrampolineFpTag), Address(FramePointer, 0));
+
+  Label prepareFrameOnCalleeBehalfAndJumpCallee;
+
+  AllocateStackBytes(masm, IndirectStubAdditionalAlignment);
+  masm.call(&prepareFrameOnCalleeBehalfAndJumpCallee);
+  DeallocateStackBytes(masm, IndirectStubAdditionalAlignment);
+
+  // Restore the caller state and return.
+  PopFrame(masm);
+  masm.subPtr(Imm32(wasm::TrampolineFpTag), FramePointer);
+  masm.loadPtr(Address(masm.getStackPointer(), WasmCallerTLSOffsetAfterCall),
+               WasmTlsReg);
+  masm.loadWasmPinnedRegsFromTls();
+  masm.switchToWasmTlsRealm(WasmTableCallIndexReg, WasmTableCallScratchReg1);
+
+#if defined(JS_CODEGEN_MIPS32) || defined(JS_CODEGEN_MIPS64)
+  masm.as_jr(ra);
+#elif defined(JS_CODEGEN_ARM64)
+  // See comment in |GenerateCallablePrologue|.
+  masm.Mov(PseudoStackPointer64, vixl::sp);
+  masm.Ret(ARMRegister(lr, 64));
+  masm.SetStackPointer64(stashedSPreg);
+#elif defined(JS_CODEGEN_ARM)
+  masm.branch(lr);
+#elif defined(JS_CODEGEN_X64) || defined(JS_CODEGEN_X86)
+  masm.ret();
+#else
+  MOZ_CRASH("Unknown architecture");
+#endif
+
+  masm.bind(&prepareFrameOnCalleeBehalfAndJumpCallee);
+  PushFrame(masm);
+  ImmPtr calleeTailEntry(calleeCheckedEntry + WasmCheckedTailEntryOffset,
+                         ImmPtr::NoCheckToken());
+  masm.jump(calleeTailEntry);
+
+  masm.bind(&sameInstanceCase);
+  ImmPtr calleeCheckedCallEntry(calleeCheckedEntry, ImmPtr::NoCheckToken());
+  masm.jump(calleeCheckedCallEntry);
+
+  return FinishOffsets(masm, offsets);
+}
+
 bool wasm::GenerateBuiltinThunk(MacroAssembler& masm, ABIFunctionType abiType,
                                 ExitReason exitReason, void* funcPtr,
                                 CallableOffsets* offsets) {