# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/Lowering.cpp
# Commit: 81e645d5ccfd
# Full Hash: 81e645d5ccfd6f46772be9864a388087210bd5c2
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-10-02 04:10:47
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.5: Add tls dependency for WasmModD. r=lth
#   
#   We generate builtin call for Mod operation for Double types, so we need
#   to add a tls dependency. In this patch I've added it.
#   
# ==============================================================================

diff -r e2105a52bcdd -r 81e645d5ccfd js/src/jit/Lowering.cpp
--- a/js/src/jit/Lowering.cpp	Thu Oct 01 07:52:46 2020 +0000
+++ b/js/src/jit/Lowering.cpp	Thu Oct 01 07:53:01 2020 +0000
@@ -1887,6 +1887,14 @@
   lowerWasmBuiltinTruncateToInt64(ins);
 }
 
+void LIRGenerator::visitWasmBuiltinModD(MWasmBuiltinModD* ins) {
+  MOZ_ASSERT(gen->compilingWasm());
+  LWasmBuiltinModD* lir = new (alloc()) LWasmBuiltinModD(
+      useRegisterAtStart(ins->lhs()), useRegisterAtStart(ins->rhs()),
+      useFixedAtStart(ins->tls(), WasmTlsReg));
+  defineReturn(lir, ins);
+}
+
 void LIRGenerator::visitMod(MMod* ins) {
   MOZ_ASSERT(ins->lhs()->type() == ins->rhs()->type());
   MOZ_ASSERT(IsNumberType(ins->type()));
@@ -1910,13 +1918,13 @@
     MOZ_ASSERT(ins->lhs()->type() == MIRType::Double);
     MOZ_ASSERT(ins->rhs()->type() == MIRType::Double);
 
-    // Ion does an unaligned ABI call and thus needs a temp register. Wasm
-    // doesn't.
-    LDefinition maybeTemp = gen->compilingWasm() ? LDefinition::BogusTemp()
-                                                 : tempFixed(CallTempReg0);
-
-    LModD* lir = new (alloc()) LModD(useRegisterAtStart(ins->lhs()),
-                                     useRegisterAtStart(ins->rhs()), maybeTemp);
+    MOZ_ASSERT(!gen->compilingWasm());
+
+    // Ion does an unaligned ABI call and thus needs a temp register.
+    // Note: useRegisterAtStart is safe here, the temp is not a FP register.
+    LModD* lir = new (alloc())
+        LModD(useRegisterAtStart(ins->lhs()), useRegisterAtStart(ins->rhs()),
+              tempFixed(CallTempReg0));
     defineReturn(lir, ins);
     return;
   }