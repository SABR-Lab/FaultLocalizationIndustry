# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/x86/LIR-x86.h
# Commit: c5ef1152da2b
# Full Hash: c5ef1152da2bd1de3d98b51daa635ac42ff0a153
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-10-02 04:10:47
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.2: Establish dependency from tls for x86 callWithABI div/mod i64. r=lth
#   
#   x86 has few register so to do div/mod for i64 it call the runtime
#   and clobber almost all gp registers including WasmTlsReg.
#   To be able to call c++ runtime via Builtin thunk we need to set up WasmTlsReg.
# ==============================================================================

diff -r f0f44cfd6a07 -r c5ef1152da2b js/src/jit/x86/LIR-x86.h
--- a/js/src/jit/x86/LIR-x86.h	Thu Oct 01 07:52:07 2020 +0000
+++ b/js/src/jit/x86/LIR-x86.h	Thu Oct 01 07:52:24 2020 +0000
@@ -86,87 +86,87 @@
 };
 
 class LDivOrModI64
-    : public LCallInstructionHelper<INT64_PIECES, INT64_PIECES * 2, 1> {
+    : public LCallInstructionHelper<INT64_PIECES, INT64_PIECES * 2 + 1, 0> {
  public:
   LIR_HEADER(DivOrModI64)
 
   static const size_t Lhs = 0;
   static const size_t Rhs = INT64_PIECES;
+  static const size_t Tls = 2 * INT64_PIECES;
 
   LDivOrModI64(const LInt64Allocation& lhs, const LInt64Allocation& rhs,
-               const LDefinition& temp)
+               const LAllocation& tls)
       : LCallInstructionHelper(classOpcode) {
     setInt64Operand(Lhs, lhs);
     setInt64Operand(Rhs, rhs);
-    setTemp(0, temp);
+    setOperand(Tls, tls);
   }
 
-  MBinaryArithInstruction* mir() const {
-    MOZ_ASSERT(mir_->isDiv() || mir_->isMod());
-    return static_cast<MBinaryArithInstruction*>(mir_);
+  MDefinition* mir() const {
+    MOZ_ASSERT(mir_->isWasmBuiltinDivI64() || mir_->isWasmBuiltinModI64());
+    return mir_;
   }
   bool canBeDivideByZero() const {
-    if (mir_->isMod()) {
-      return mir_->toMod()->canBeDivideByZero();
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->canBeDivideByZero();
     }
-    return mir_->toDiv()->canBeDivideByZero();
+    return mir_->toWasmBuiltinDivI64()->canBeDivideByZero();
   }
   bool canBeNegativeOverflow() const {
-    if (mir_->isMod()) {
-      return mir_->toMod()->canBeNegativeDividend();
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->canBeNegativeDividend();
     }
-    return mir_->toDiv()->canBeNegativeOverflow();
+    return mir_->toWasmBuiltinDivI64()->canBeNegativeOverflow();
   }
   wasm::BytecodeOffset bytecodeOffset() const {
-    MOZ_ASSERT(mir_->isDiv() || mir_->isMod());
-    if (mir_->isMod()) {
-      return mir_->toMod()->bytecodeOffset();
+    MOZ_ASSERT(mir_->isWasmBuiltinDivI64() || mir_->isWasmBuiltinModI64());
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->bytecodeOffset();
     }
-    return mir_->toDiv()->bytecodeOffset();
+    return mir_->toWasmBuiltinDivI64()->bytecodeOffset();
   }
-  const LDefinition* temp() { return getTemp(0); }
 };
 
 class LUDivOrModI64
-    : public LCallInstructionHelper<INT64_PIECES, INT64_PIECES * 2, 1> {
+    : public LCallInstructionHelper<INT64_PIECES, INT64_PIECES * 2 + 1, 0> {
  public:
   LIR_HEADER(UDivOrModI64)
 
   static const size_t Lhs = 0;
   static const size_t Rhs = INT64_PIECES;
+  static const size_t Tls = 2 * INT64_PIECES;
 
   LUDivOrModI64(const LInt64Allocation& lhs, const LInt64Allocation& rhs,
-                const LDefinition& temp)
+                const LAllocation& tls)
       : LCallInstructionHelper(classOpcode) {
     setInt64Operand(Lhs, lhs);
     setInt64Operand(Rhs, rhs);
-    setTemp(0, temp);
+    setOperand(Tls, tls);
   }
 
-  MBinaryArithInstruction* mir() const {
-    MOZ_ASSERT(mir_->isDiv() || mir_->isMod());
-    return static_cast<MBinaryArithInstruction*>(mir_);
+  MDefinition* mir() const {
+    MOZ_ASSERT(mir_->isWasmBuiltinDivI64() || mir_->isWasmBuiltinModI64());
+    return mir_;
   }
   bool canBeDivideByZero() const {
-    if (mir_->isMod()) {
-      return mir_->toMod()->canBeDivideByZero();
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->canBeDivideByZero();
     }
-    return mir_->toDiv()->canBeDivideByZero();
+    return mir_->toWasmBuiltinDivI64()->canBeDivideByZero();
   }
   bool canBeNegativeOverflow() const {
-    if (mir_->isMod()) {
-      return mir_->toMod()->canBeNegativeDividend();
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->canBeNegativeDividend();
     }
-    return mir_->toDiv()->canBeNegativeOverflow();
+    return mir_->toWasmBuiltinDivI64()->canBeNegativeOverflow();
   }
   wasm::BytecodeOffset bytecodeOffset() const {
-    MOZ_ASSERT(mir_->isDiv() || mir_->isMod());
-    if (mir_->isMod()) {
-      return mir_->toMod()->bytecodeOffset();
+    MOZ_ASSERT(mir_->isWasmBuiltinDivI64() || mir_->isWasmBuiltinModI64());
+    if (mir_->isWasmBuiltinModI64()) {
+      return mir_->toWasmBuiltinModI64()->bytecodeOffset();
     }
-    return mir_->toDiv()->bytecodeOffset();
+    return mir_->toWasmBuiltinDivI64()->bytecodeOffset();
   }
-  const LDefinition* temp() { return getTemp(0); }
 };
 
 class LWasmTruncateToInt64 : public LInstructionHelper<INT64_PIECES, 1, 1> {