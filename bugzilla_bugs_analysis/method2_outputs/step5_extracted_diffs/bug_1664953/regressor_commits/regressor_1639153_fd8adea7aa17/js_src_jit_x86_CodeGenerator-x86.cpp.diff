# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/x86/CodeGenerator-x86.cpp
# Commit: fd8adea7aa17
# Full Hash: fd8adea7aa17b82a6d48c72836823b11ae4c7c66
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-09-11 09:30:56
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.2: Establish dependency from tls for x86 callWithABI div/mod i64. r=lth
#   
#   x86 has few register so to do div/mod for i64 it call the runtime
#   and clobber almost all gp registers including WasmTlsReg.
#   To be able to call c++ runtime via Builtin thunk we need to set up WasmTlsReg.
# ==============================================================================

diff -r 6d91f5b4cc32 -r fd8adea7aa17 js/src/jit/x86/CodeGenerator-x86.cpp
--- a/js/src/jit/x86/CodeGenerator-x86.cpp	Fri Sep 11 08:32:46 2020 +0300
+++ b/js/src/jit/x86/CodeGenerator-x86.cpp	Fri Sep 11 05:40:14 2020 +0000
@@ -803,9 +803,14 @@
 }
 
 void CodeGenerator::visitDivOrModI64(LDivOrModI64* lir) {
+  MOZ_ASSERT(gen->compilingWasm());
+  MOZ_ASSERT(ToRegister(lir->getOperand(LDivOrModI64::Tls)) == WasmTlsReg);
+
+  masm.Push(WasmTlsReg);
+  int32_t framePushedAfterTls = masm.framePushed();
+
   Register64 lhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Lhs));
   Register64 rhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Rhs));
-  Register temp = ToRegister(lir->temp());
   Register64 output = ToOutRegister64(lir);
 
   MOZ_ASSERT(output == ReturnReg64);
@@ -815,7 +820,8 @@
   // Handle divide by zero.
   if (lir->canBeDivideByZero()) {
     Label nonZero;
-    masm.branchTest64(Assembler::NonZero, rhs, rhs, temp, &nonZero);
+    // We can use WasmTlsReg as temp register because we preserved it before.
+    masm.branchTest64(Assembler::NonZero, rhs, rhs, WasmTlsReg, &nonZero);
     masm.wasmTrap(wasm::Trap::IntegerDivideByZero, lir->bytecodeOffset());
     masm.bind(&nonZero);
   }
@@ -827,7 +833,7 @@
     Label notOverflow;
     masm.branch64(Assembler::NotEqual, lhs, Imm64(INT64_MIN), &notOverflow);
     masm.branch64(Assembler::NotEqual, rhs, Imm64(-1), &notOverflow);
-    if (mir->isMod()) {
+    if (mir->isWasmBuiltinModI64()) {
       masm.xor64(output, output);
     } else {
       masm.wasmTrap(wasm::Trap::IntegerOverflow, lir->bytecodeOffset());
@@ -842,13 +848,13 @@
   masm.passABIArg(rhs.high);
   masm.passABIArg(rhs.low);
 
-  MOZ_ASSERT(gen->compilingWasm());
-  if (mir->isMod()) {
+  int32_t tlsOffset = masm.framePushed() - framePushedAfterTls;
+  if (mir->isWasmBuiltinModI64()) {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::ModI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   } else {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::DivI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   }
 
   // output in edx:eax, move to output register.
@@ -856,12 +862,18 @@
   MOZ_ASSERT(eax == output.low);
 
   masm.bind(&done);
+  masm.Pop(WasmTlsReg);
 }
 
 void CodeGenerator::visitUDivOrModI64(LUDivOrModI64* lir) {
+  MOZ_ASSERT(gen->compilingWasm());
+  MOZ_ASSERT(ToRegister(lir->getOperand(LDivOrModI64::Tls)) == WasmTlsReg);
+
+  masm.Push(WasmTlsReg);
+  int32_t framePushedAfterTls = masm.framePushed();
+
   Register64 lhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Lhs));
   Register64 rhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Rhs));
-  Register temp = ToRegister(lir->temp());
   Register64 output = ToOutRegister64(lir);
 
   MOZ_ASSERT(output == ReturnReg64);
@@ -869,7 +881,8 @@
   // Prevent divide by zero.
   if (lir->canBeDivideByZero()) {
     Label nonZero;
-    masm.branchTest64(Assembler::NonZero, rhs, rhs, temp, &nonZero);
+    // We can use WasmTlsReg as temp register because we preserved it before.
+    masm.branchTest64(Assembler::NonZero, rhs, rhs, WasmTlsReg, &nonZero);
     masm.wasmTrap(wasm::Trap::IntegerDivideByZero, lir->bytecodeOffset());
     masm.bind(&nonZero);
   }
@@ -880,19 +893,21 @@
   masm.passABIArg(rhs.high);
   masm.passABIArg(rhs.low);
 
-  MOZ_ASSERT(gen->compilingWasm());
   MDefinition* mir = lir->mir();
-  if (mir->isMod()) {
+  int32_t tlsOffset = masm.framePushed() - framePushedAfterTls;
+  if (mir->isWasmBuiltinModI64()) {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::UModI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   } else {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::UDivI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   }
 
   // output in edx:eax, move to output register.
   masm.movl(edx, output.high);
   MOZ_ASSERT(eax == output.low);
+
+  masm.Pop(WasmTlsReg);
 }
 
 void CodeGenerator::visitWasmSelectI64(LWasmSelectI64* lir) {