# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmFrameIter.cpp
# Commit: 1a73cfde72e8
# Full Hash: 1a73cfde72e8f4d19bdcfdbffa9fbc78bba01e24
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2021-09-28 09:54:33
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Introduce indirect stubs to optimize call_indirect. r=lth
#   
#   This patch introduces indirect stubs.
#   An indirect stub is a stub that takes care of any switching activities needed for call_indirect.
#   Before this patch, we have to conservatively assume that any call_indirect's target can be from a foreign instance,
# ==============================================================================

diff -r da3c5d8492db -r 1a73cfde72e8 js/src/wasm/WasmFrameIter.cpp
--- a/js/src/wasm/WasmFrameIter.cpp	Tue Sep 28 05:16:23 2021 +0000
+++ b/js/src/wasm/WasmFrameIter.cpp	Tue Sep 28 05:24:15 2021 +0000
@@ -150,7 +150,11 @@
   }
 
   Frame* prevFP = fp_;
-  fp_ = fp_->wasmCaller();
+  if (fp_->callerIsTrampolineFP()) {
+    fp_ = fp_->trampolineCaller();
+  } else {
+    fp_ = fp_->wasmCaller();
+  }
   resumePCinCurrentFrame_ = prevFP->returnAddress();
 
   if (!fp_) {
@@ -206,7 +210,9 @@
   const CallSite* callsite = code_->lookupCallSite(returnAddress);
   MOZ_ASSERT(callsite);
 
-  if (callsite->mightBeCrossInstance()) {
+  if (callsite->isImportCall()) {
+    tls_ = ExtractCallerTlsFromFrameWithTls(prevFP);
+  } else if (callsite->isIndirectCall() && prevFP->callerIsTrampolineFP()) {
     tls_ = ExtractCallerTlsFromFrameWithTls(prevFP);
   }
 
@@ -921,6 +927,7 @@
       callerFP_ = fp->rawCaller();
       AssertMatchesCallSite(callerPC_, callerFP_);
       break;
+    case CodeRange::IndirectStub:
     case CodeRange::ImportJitExit:
     case CodeRange::ImportInterpExit:
     case CodeRange::BuiltinThunk:
@@ -952,6 +959,10 @@
 
 const TlsData* js::wasm::GetNearestEffectiveTls(const Frame* fp) {
   while (true) {
+    if (fp->callerIsTrampolineFP()) {
+      return ExtractCalleeTlsFromFrameWithTls(fp);
+    }
+
     if (fp->callerIsExitOrJitEntryFP()) {
       // It is a direct call from JIT.
       MOZ_ASSERT(!LookupCode(fp->returnAddress()));
@@ -967,10 +978,14 @@
       return ExtractCalleeTlsFromFrameWithTls(fp);
     }
 
+    if (codeRange->isIndirectStub()) {
+      return ExtractCalleeTlsFromFrameWithTls(fp->wasmCaller());
+    }
+
     MOZ_ASSERT(codeRange->kind() == CodeRange::Function);
     MOZ_ASSERT(code);
     const CallSite* callsite = code->lookupCallSite(returnAddress);
-    if (callsite->mightBeCrossInstance()) {
+    if (callsite->isImportCall()) {
       return ExtractCalleeTlsFromFrameWithTls(fp);
     }
 
@@ -1157,7 +1172,9 @@
         if (isSignatureCheckFail(offsetInCode, codeRange)) {
           // Frame have been pushed and FP has been set.
           const auto* frame = Frame::fromUntaggedWasmExitFP(fp);
-          fixedFP = frame->rawCaller();
+          fixedFP = frame->callerIsTrampolineFP()
+                        ? reinterpret_cast<uint8_t*>(frame->trampolineCaller())
+                        : reinterpret_cast<uint8_t*>(frame->wasmCaller());
           fixedPC = frame->returnAddress();
           AssertMatchesCallSite(fixedPC, fixedFP);
           break;
@@ -1187,6 +1204,16 @@
       // entry trampoline also doesn't GeneratePrologue/Epilogue so we can't
       // use the general unwinding logic above.
       break;
+    case CodeRange::IndirectStub: {
+      // IndirectStub is used now as a trivial proxy into the function
+      // so we aren't in the prologue/epilogue.
+      fixedPC = pc;
+      fixedFP = fp;
+      *unwoundCaller = false;
+      AssertMatchesCallSite(Frame::fromUntaggedWasmExitFP(fp)->returnAddress(),
+                            Frame::fromUntaggedWasmExitFP(fp)->rawCaller());
+      break;
+    }
     case CodeRange::JitEntry:
       // There's a jit frame above the current one; we don't care about pc
       // since the Jit entry frame is a jit frame which can be considered as
@@ -1367,6 +1394,8 @@
     }
     case CodeRange::InterpEntry:
       MOZ_CRASH("should have had null caller fp");
+    case CodeRange::IndirectStub:
+      MOZ_CRASH("we can't profile indirect stub");
     case CodeRange::JitEntry:
       MOZ_CRASH("should have been guarded above");
     case CodeRange::Throw:
@@ -1588,6 +1617,8 @@
       return code_->profilingLabel(codeRange_->funcIndex());
     case CodeRange::InterpEntry:
       MOZ_CRASH("should be an ExitReason");
+    case CodeRange::IndirectStub:
+      return "indirect stub";
     case CodeRange::JitEntry:
       return "fast entry trampoline (in wasm)";
     case CodeRange::ImportJitExit: