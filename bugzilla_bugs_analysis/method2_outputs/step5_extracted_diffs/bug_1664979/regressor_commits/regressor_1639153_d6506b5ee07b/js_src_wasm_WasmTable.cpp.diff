# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmTable.cpp
# Commit: d6506b5ee07b
# Full Hash: d6506b5ee07b5c65f889ce7c2214b0172f205898
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2021-09-16 09:43:03
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Introduce indirect stubs to optimize call_indirect. r=lth
#   
#   This patch introduces indirect stubs.
#   An indirect stub is a stub that takes care of any switching activities needed for call_indirect.
#   Before this patch, we have to conservatively assume that any call_indirect's target can be from a foreign instance,
# ==============================================================================

diff -r 80a164c1054e -r d6506b5ee07b js/src/wasm/WasmTable.cpp
--- a/js/src/wasm/WasmTable.cpp	Wed Sep 15 11:02:57 2021 +0000
+++ b/js/src/wasm/WasmTable.cpp	Wed Sep 15 11:10:15 2021 +0000
@@ -38,6 +38,7 @@
       functions_(std::move(functions)),
       elemType_(desc.elemType),
       isAsmJS_(desc.isAsmJS),
+      importedOrExported(desc.importedOrExported),
       length_(desc.initialLength),
       maximum_(desc.maximumLength) {
   MOZ_ASSERT(repr() == TableRepr::Func);
@@ -50,6 +51,7 @@
       objects_(std::move(objects)),
       elemType_(desc.elemType),
       isAsmJS_(desc.isAsmJS),
+      importedOrExported(desc.importedOrExported),
       length_(desc.initialLength),
       maximum_(desc.maximumLength) {
   MOZ_ASSERT(repr() == TableRepr::Ref);
@@ -150,17 +152,38 @@
   MOZ_ASSERT(isFunction());
 
   const FunctionTableElem& elem = getFuncRef(index);
-  if (!elem.code) {
+  if (!elem.tls) {
     fun.set(nullptr);
     return true;
   }
 
   Instance& instance = *elem.tls->instance;
-  const CodeRange& codeRange = *instance.code().lookupFuncRange(elem.code);
+  const CodeRange* codeRange =
+      instance.code().lookupIndirectStubRange(elem.code);
+  if (!codeRange) {
+    codeRange = instance.code().lookupFuncRange(elem.code);
+  }
+  MOZ_ASSERT(codeRange);
 
-  RootedWasmInstanceObject instanceObj(cx, instance.object());
-  return instanceObj->getExportedFunction(cx, instanceObj,
-                                          codeRange.funcIndex(), fun);
+  // If the element is a wasm function imported from another
+  // instance then to preserve the === function identity required by
+  // the JS embedding spec, we must set the element to the
+  // imported function's underlying CodeRange.funcCheckedCallEntry and
+  // Instance so that future Table.get()s produce the same
+  // function object as was imported.
+  JSFunction* callee = nullptr;
+  Instance* calleeInstance =
+      instance.getOriginalInstanceAndFunction(codeRange->funcIndex(), &callee);
+  RootedWasmInstanceObject calleeInstanceObj(cx, calleeInstance->object());
+  uint32_t calleeFunctionIndex = codeRange->funcIndex();
+  if (callee && (calleeInstance != &instance)) {
+    const Tier calleeTier = calleeInstance->code().bestTier();
+    calleeFunctionIndex =
+        calleeInstanceObj->getExportedFunctionCodeRange(callee, calleeTier)
+            .funcIndex();
+  }
+  return WasmInstanceObject::getExportedFunction(cx, calleeInstanceObj,
+                                                 calleeFunctionIndex, fun);
 }
 
 void Table::setFuncRef(uint32_t index, void* code, const Instance* instance) {
@@ -182,7 +205,7 @@
   }
 }
 
-void Table::fillFuncRef(uint32_t index, uint32_t fillCount, FuncRef ref,
+bool Table::fillFuncRef(uint32_t index, uint32_t fillCount, FuncRef ref,
                         JSContext* cx) {
   MOZ_ASSERT(isFunction());
 
@@ -190,7 +213,7 @@
     for (uint32_t i = index, end = index + fillCount; i != end; i++) {
       setNull(i);
     }
-    return;
+    return true;
   }
 
   RootedFunction fun(cx, ref.asJSFunction());
@@ -207,14 +230,16 @@
 #endif
 
   Instance& instance = instanceObj->instance();
-  Tier tier = instance.code().bestTier();
-  const MetadataTier& metadata = instance.metadata(tier);
-  const CodeRange& codeRange =
-      metadata.codeRange(metadata.lookupFuncExport(funcIndex));
-  void* code = instance.codeBase(tier) + codeRange.funcCheckedCallEntry();
+  void* code = instance.createIndirectStub(funcIndex, instance.tlsData());
+  if (!code) {
+    return false;
+  }
+
   for (uint32_t i = index, end = index + fillCount; i != end; i++) {
     setFuncRef(i, code, &instance);
   }
+
+  return true;
 }
 
 AnyRef Table::getAnyRef(uint32_t index) const {