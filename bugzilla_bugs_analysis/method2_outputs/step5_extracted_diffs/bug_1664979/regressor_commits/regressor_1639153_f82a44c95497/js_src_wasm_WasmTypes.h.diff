# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmTypes.h
# Commit: f82a44c95497
# Full Hash: f82a44c95497c4821a758ba031078945a188bc21
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-06-16 15:49:59
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Refactor wasm::Frame to reduce number of gnarly casts. r=lth,wingo
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D79072
# ==============================================================================

diff -r af6b36a497e8 -r f82a44c95497 js/src/wasm/WasmTypes.h
--- a/js/src/wasm/WasmTypes.h	Tue Jun 16 08:54:41 2020 +0000
+++ b/js/src/wasm/WasmTypes.h	Tue Jun 16 09:26:20 2020 +0000
@@ -124,6 +124,19 @@
 typedef Vector<Instance*, 0, SystemAllocPolicy> InstanceVector;
 typedef Vector<UniqueChars, 0, SystemAllocPolicy> UniqueCharsVector;
 
+// Bit set as the lowest bit of a frame pointer, used in two different mutually
+// exclusive situations:
+// - either it's a low bit tag in a FramePointer value read from the
+// Frame::callerFP of an inner wasm frame. This indicates the previous call
+// frame has been set up by a JIT caller that directly called into a wasm
+// function's body. This is only stored in Frame::callerFP for a wasm frame
+// called from JIT code, and thus it can not appear in a JitActivation's
+// exitFP.
+// - or it's the low big tag set when exiting wasm code in JitActivation's
+// exitFP.
+
+constexpr uintptr_t ExitOrJitEntryFPTag = 0x1;
+
 // To call Vector::shrinkStorageToFit , a type must specialize mozilla::IsPod
 // which is pretty verbose to do within js::wasm, so factor that process out
 // into a macro.
@@ -3188,14 +3201,16 @@
 // are counted by masm.framePushed. Thus, the stack alignment at any point in
 // time is (sizeof(wasm::Frame) + masm.framePushed) % WasmStackAlignment.
 
-struct Frame {
-  // The caller's Frame*. See GenerateCallableEpilogue for why this must be
+class Frame {
+  // See GenerateCallableEpilogue for why this must be
   // the first field of wasm::Frame (in a downward-growing stack).
-  Frame* callerFP;
+  // It's either the caller's Frame*, for wasm callers, or the JIT caller frame
+  // plus a tag otherwise.
+  uint8_t* callerFP_;
 
   // The saved value of WasmTlsReg on entry to the function. This is
   // effectively the callee's instance.
-  TlsData* tls;
+  TlsData* tls_;
 
 #if defined(JS_CODEGEN_MIPS32) || defined(JS_CODEGEN_ARM64)
   // Double word aligned frame ensures:
@@ -3203,20 +3218,74 @@
   //   stack alignment to be more than word size.
   // - correct stack alignment on architectures that require the SP alignment
   //   to be more than word size.
+ protected:  // suppress -Wunused-private-field
   uintptr_t padding_;
+
+ private:
 #endif
 
   // The return address pushed by the call (in the case of ARM/MIPS the return
   // address is pushed by the first instruction of the prologue).
-  void* returnAddress;
-
-  // Helper functions:
-
-  Instance* instance() const { return tls->instance; }
+  void* returnAddress_;
+
+ public:
+  static constexpr uint32_t tlsOffset() { return offsetof(Frame, tls_); }
+  static constexpr uint32_t callerFPOffset() {
+    return offsetof(Frame, callerFP_);
+  }
+  static constexpr uint32_t returnAddressOffset() {
+    return offsetof(Frame, returnAddress_);
+  }
+
+  uint8_t* returnAddress() const {
+    return reinterpret_cast<uint8_t*>(returnAddress_);
+  }
+
+  void** addressOfReturnAddress() {
+    return reinterpret_cast<void**>(&returnAddress_);
+  }
+
+  uint8_t* rawCaller() const { return callerFP_; }
+  TlsData* tls() const { return tls_; }
+  Instance* instance() const { return tls()->instance; }
+
+  Frame* wasmCaller() const {
+    MOZ_ASSERT(!callerIsExitOrJitEntryFP());
+    return reinterpret_cast<Frame*>(callerFP_);
+  }
+
+  bool callerIsExitOrJitEntryFP() const {
+    return isExitOrJitEntryFP(callerFP_);
+  }
+
+  uint8_t* jitEntryCaller() const { return toJitEntryCaller(callerFP_); }
+
+  static const Frame* fromUntaggedWasmExitFP(const void* savedFP) {
+    MOZ_ASSERT(!isExitOrJitEntryFP(savedFP));
+    return reinterpret_cast<const Frame*>(savedFP);
+  }
+
+  static bool isExitOrJitEntryFP(const void* fp) {
+    return reinterpret_cast<uintptr_t>(fp) & ExitOrJitEntryFPTag;
+  }
+
+  static uint8_t* toJitEntryCaller(const void* fp) {
+    MOZ_ASSERT(isExitOrJitEntryFP(fp));
+    return reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(fp) &
+                                      ~ExitOrJitEntryFPTag);
+  }
+
+  static uint8_t* addExitOrJitEntryFPTag(const Frame* fp) {
+    MOZ_ASSERT(!isExitOrJitEntryFP(fp));
+    return reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(fp) |
+                                      ExitOrJitEntryFPTag);
+  }
 };
 
+static_assert(!std::is_polymorphic_v<Frame>, "Frame doesn't need a vtable.");
+
 #if defined(JS_CODEGEN_ARM64)
-static_assert(sizeof(Frame) % 16 == 0, "frame size");
+static_assert(sizeof(Frame) % 16 == 0, "frame is aligned");
 #endif
 
 // A DebugFrame is a Frame with additional fields that are added after the
