# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BaselineIC.cpp
# Commit: 62a055d16919
# Full Hash: 62a055d16919bb982f8d1a03b525b88fedd50e54
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2020-07-07 09:47:47
# Regressor Bug: 1646378
# File Overlap Count: 2
# Description:
#   Bug 1646378: Get stubspace from ICScript in AttachBaselineCacheIRStub r=jandem
#   
#   My current plan for stub allocation is as follows. A JitScript contains a fallbackStubSpace, which is used for all of its own stubs. When we decide to do trial inlining for a JitScript, we create an InliningRoot, which is owned by the JitScript. The InliningRoot contains an array of unique pointers to inlined ICScripts and has a single fallbackStubSpace which is shared by all those ICScripts.
#   
#   I wrote this code when I was thinking that we would throw the InliningRoot away after Warp compilation. If we intend to keep it around indefinitely, it might be better to reuse the stubspace in the root JitScript, in which case we don't need this patch.
# ==============================================================================

diff -r 88d8782f9cab -r 62a055d16919 js/src/jit/BaselineIC.cpp
--- a/js/src/jit/BaselineIC.cpp	Thu Jul 02 22:58:05 2020 +0000
+++ b/js/src/jit/BaselineIC.cpp	Thu Jul 02 22:30:45 2020 +0000
@@ -777,6 +777,7 @@
 
   if (stub->state().canAttachStub()) {
     RootedScript script(cx, frame->script());
+    ICScript* icScript = frame->icScript();
     jsbytecode* pc = stub->icEntry()->pc(script);
 
     bool attached = false;
@@ -786,7 +787,7 @@
       case AttachDecision::Attach: {
         ICStub* newStub =
             AttachBaselineCacheIRStub(cx, gen.writerRef(), gen.cacheKind(),
-                                      kind, script, stub, &attached);
+                                      kind, script, icScript, stub, &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached %s CacheIR stub", name);
         }
@@ -970,9 +971,11 @@
 
 /* static */
 ICStubSpace* ICStubCompiler::StubSpaceForStub(bool makesGCCalls,
-                                              JSScript* script) {
+                                              JSScript* script,
+                                              ICScript* icScript) {
   if (makesGCCalls) {
-    return script->jitScript()->fallbackStubSpace();
+    return icScript ? icScript->fallbackStubSpace()
+                    : script->jitScript()->fallbackStubSpace();
   }
   return script->zone()->jitZone()->optimizedStubSpace();
 }
@@ -1850,15 +1853,17 @@
 
   if (stub->state().canAttachStub()) {
     RootedScript script(cx, frame->script());
+    ICScript* icScript = frame->icScript();
     jsbytecode* pc = stub->icEntry()->pc(script);
 
     GetPropIRGenerator gen(cx, script, pc, stub->state().mode(), kind, val,
                            idVal, receiver, GetPropertyResultFlags::All);
     switch (gen.tryAttachStub()) {
       case AttachDecision::Attach: {
-        ICStub* newStub = AttachBaselineCacheIRStub(
-            cx, gen.writerRef(), gen.cacheKind(),
-            BaselineCacheIRStubKind::Monitored, script, stub, &attached);
+        ICStub* newStub =
+            AttachBaselineCacheIRStub(cx, gen.writerRef(), gen.cacheKind(),
+                                      BaselineCacheIRStubKind::Monitored,
+                                      script, icScript, stub, &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached %s CacheIR stub", name);
           if (gen.shouldNotePreliminaryObjectStub()) {
@@ -2129,13 +2134,15 @@
   }
 
   if (stub->state().canAttachStub()) {
+    ICScript* icScript = frame->icScript();
     SetPropIRGenerator gen(cx, script, pc, CacheKind::SetElem,
                            stub->state().mode(), objv, index, rhs);
     switch (gen.tryAttachStub()) {
       case AttachDecision::Attach: {
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(),
-            BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
+            BaselineCacheIRStubKind::Updated, frame->script(), icScript, stub,
+            &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached SetElem CacheIR stub");
 
@@ -2219,9 +2226,11 @@
 
     switch (decision) {
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(),
-            BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
+            BaselineCacheIRStubKind::Updated, frame->script(), icScript, stub,
+            &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached SetElem CacheIR stub");
 
@@ -2722,9 +2731,11 @@
                            stub->state().mode(), lhs, idVal, rhs);
     switch (gen.tryAttachStub()) {
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(),
-            BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
+            BaselineCacheIRStubKind::Updated, frame->script(), icScript, stub,
+            &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached SetProp CacheIR stub");
 
@@ -2805,9 +2816,11 @@
 
     switch (decision) {
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(),
-            BaselineCacheIRStubKind::Updated, frame->script(), stub, &attached);
+            BaselineCacheIRStubKind::Updated, frame->script(), icScript, stub,
+            &attached);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached SetElem CacheIR stub");
 
@@ -2930,9 +2943,10 @@
       case AttachDecision::NoAction:
         break;
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(), gen.cacheIRStubKind(), script,
-            stub, &handled);
+            icScript, stub, &handled);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached Call CacheIR stub");
 
@@ -2995,9 +3009,10 @@
                         callArgs.thisv(), newTarget, args);
     switch (gen.tryAttachDeferredStub(res)) {
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(), gen.cacheIRStubKind(), script,
-            stub, &handled);
+            icScript, stub, &handled);
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached Call CacheIR stub");
 
@@ -3063,9 +3078,10 @@
       case AttachDecision::NoAction:
         break;
       case AttachDecision::Attach: {
+        ICScript* icScript = frame->icScript();
         ICStub* newStub = AttachBaselineCacheIRStub(
             cx, gen.writerRef(), gen.cacheKind(), gen.cacheIRStubKind(), script,
-            stub, &handled);
+            icScript, stub, &handled);
 
         if (newStub) {
           JitSpew(JitSpew_BaselineIC, "  Attached Spread Call CacheIR stub");