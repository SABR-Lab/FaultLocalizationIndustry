# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/WarpCacheIRTranspiler.cpp
# Commit: 27cbb7b4106c
# Full Hash: 27cbb7b4106c901018e49465d38eea9554a7e04b
# Author: caroline <ccullen@mozilla.com>
# Date: 2020-07-11 09:22:23
# Regressor Bug: 1648820
# File Overlap Count: 1
# Description:
#   Bug 1648820 - Part 3: Transpile Math.hypot in Warp. r=iain
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D83023
# ==============================================================================

diff -r ea8e1a9ab3a0 -r 27cbb7b4106c js/src/jit/WarpCacheIRTranspiler.cpp
--- a/js/src/jit/WarpCacheIRTranspiler.cpp	Fri Jul 10 21:49:04 2020 +0000
+++ b/js/src/jit/WarpCacheIRTranspiler.cpp	Fri Jul 10 21:49:11 2020 +0000
@@ -1254,6 +1254,62 @@
   return emitCompareResult(op, lhsId, rhsId, MCompare::Compare_String);
 }
 
+bool WarpCacheIRTranspiler::emitMathHypot2NumberResult(
+    NumberOperandId firstId, NumberOperandId secondId) {
+  MDefinitionVector vector(alloc());
+  if (!vector.reserve(2)) {
+    return false;
+  }
+
+  vector.infallibleAppend(getOperand(firstId));
+  vector.infallibleAppend(getOperand(secondId));
+
+  auto* ins = MHypot::New(alloc(), vector);
+  add(ins);
+
+  pushResult(ins);
+  return true;
+}
+
+bool WarpCacheIRTranspiler::emitMathHypot3NumberResult(
+    NumberOperandId firstId, NumberOperandId secondId,
+    NumberOperandId thirdId) {
+  MDefinitionVector vector(alloc());
+  if (!vector.reserve(3)) {
+    return false;
+  }
+
+  vector.infallibleAppend(getOperand(firstId));
+  vector.infallibleAppend(getOperand(secondId));
+  vector.infallibleAppend(getOperand(thirdId));
+
+  auto* ins = MHypot::New(alloc(), vector);
+  add(ins);
+
+  pushResult(ins);
+  return true;
+}
+
+bool WarpCacheIRTranspiler::emitMathHypot4NumberResult(
+    NumberOperandId firstId, NumberOperandId secondId, NumberOperandId thirdId,
+    NumberOperandId fourthId) {
+  MDefinitionVector vector(alloc());
+  if (!vector.reserve(4)) {
+    return false;
+  }
+
+  vector.infallibleAppend(getOperand(firstId));
+  vector.infallibleAppend(getOperand(secondId));
+  vector.infallibleAppend(getOperand(thirdId));
+  vector.infallibleAppend(getOperand(fourthId));
+
+  auto* ins = MHypot::New(alloc(), vector);
+  add(ins);
+
+  pushResult(ins);
+  return true;
+}
+
 bool WarpCacheIRTranspiler::emitMathRandomResult(uint32_t rngOffset) {
 #ifdef DEBUG
   // CodeGenerator uses CompileRealm::addressOfRandomNumberGenerator. Assert it
