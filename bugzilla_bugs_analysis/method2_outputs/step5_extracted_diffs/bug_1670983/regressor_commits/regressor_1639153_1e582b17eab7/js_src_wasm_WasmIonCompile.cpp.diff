# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmIonCompile.cpp
# Commit: 1e582b17eab7
# Full Hash: 1e582b17eab7abf3958e46bc52ea3eeafa764eeb
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-09-11 09:30:56
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.6: Add tls dependency for truncate i32. r=lth
#   
#   We generate builtin call for MTruncateToInt32 operation for floating points types,
#   so we need to add a tls dependency.
#   I inserted NYI for arm64 because Ion doesn't support arm64.
# ==============================================================================

diff -r a309060018a8 -r 1e582b17eab7 js/src/wasm/WasmIonCompile.cpp
--- a/js/src/wasm/WasmIonCompile.cpp	Wed Sep 09 06:37:59 2020 +0000
+++ b/js/src/wasm/WasmIonCompile.cpp	Wed Sep 09 08:59:55 2020 +0000
@@ -450,13 +450,13 @@
       // Do this for Int32 only since Int64 is not subject to the same
       // issues.
       //
-      // Note the offsets passed to MTruncateToInt32 are wrong here, but
-      // it doesn't matter: they're not codegen'd to calls since inputs
+      // Note the offsets passed to MWasmBuiltinTruncateToInt32 are wrong here,
+      // but it doesn't matter: they're not codegen'd to calls since inputs
       // already are int32.
-      auto* lhs2 = MTruncateToInt32::New(alloc(), lhs);
+      auto* lhs2 = createTruncateToInt32(lhs);
       curBlock_->add(lhs2);
       lhs = lhs2;
-      auto* rhs2 = MTruncateToInt32::New(alloc(), rhs);
+      auto* rhs2 = createTruncateToInt32(rhs);
       curBlock_->add(rhs2);
       rhs = rhs2;
     }
@@ -479,6 +479,14 @@
     return ins;
   }
 
+  MInstruction* createTruncateToInt32(MDefinition* op) {
+    if (op->type() == MIRType::Double || op->type() == MIRType::Float32) {
+      return MWasmBuiltinTruncateToInt32::New(alloc(), op, tlsPointer_);
+    }
+
+    return MTruncateToInt32::New(alloc(), op);
+  }
+
   MDefinition* mod(MDefinition* lhs, MDefinition* rhs, MIRType type,
                    bool unsignd) {
     if (inDeadCode()) {
@@ -487,10 +495,10 @@
     bool trapOnError = !env().isAsmJS();
     if (!unsignd && type == MIRType::Int32) {
       // See block comment in div().
-      auto* lhs2 = MTruncateToInt32::New(alloc(), lhs);
+      auto* lhs2 = createTruncateToInt32(lhs);
       curBlock_->add(lhs2);
       lhs = lhs2;
-      auto* rhs2 = MTruncateToInt32::New(alloc(), rhs);
+      auto* rhs2 = createTruncateToInt32(rhs);
       curBlock_->add(rhs2);
       rhs = rhs2;
     }
@@ -2208,11 +2216,13 @@
 }
 
 template <>
-MDefinition* FunctionCompiler::unary<MTruncateToInt32>(MDefinition* op) {
+MDefinition* FunctionCompiler::unary<MWasmBuiltinTruncateToInt32>(
+    MDefinition* op) {
   if (inDeadCode()) {
     return nullptr;
   }
-  auto* ins = MTruncateToInt32::New(alloc(), op, bytecodeOffset());
+  auto* ins = MWasmBuiltinTruncateToInt32::New(alloc(), op, tlsPointer_,
+                                               bytecodeOffset());
   curBlock_->add(ins);
   return ins;
 }
@@ -2778,7 +2788,12 @@
   }
   if (resultType == ValType::I32) {
     if (f.env().isAsmJS()) {
-      f.iter().setResult(f.unary<MTruncateToInt32>(input));
+      if (input->type() == MIRType::Double ||
+          input->type() == MIRType::Float32) {
+        f.iter().setResult(f.unary<MWasmBuiltinTruncateToInt32>(input));
+      } else {
+        f.iter().setResult(f.unary<MTruncateToInt32>(input));
+      }
     } else {
       f.iter().setResult(f.truncate<MWasmTruncateToInt32>(input, flags));
     }
