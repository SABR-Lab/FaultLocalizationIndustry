# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBaselineCompile.cpp
# Commit: 93f3b8aa5bc5
# Full Hash: 93f3b8aa5bc50a2e4d4e61c7ba0e839b681518a2
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-09-09 16:10:02
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.1: Untie callWithAbi from Frame::tls for Baseline. r=lth
#   
#   We have a tls dependency in callWithABI for wasm because we call builtins via BuiltinThunk.
#   Last one requires that tls to be loaded. In this patch I gradually extend callWithABI interface to
#   pass offset to tls. This allows us to preserve tls and load it by offset in callWithABI and frees us from
# ==============================================================================

diff -r 372f140d5b96 -r 93f3b8aa5bc5 js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp	Wed Sep 09 12:34:23 2020 +0000
+++ b/js/src/wasm/WasmBaselineCompile.cpp	Wed Sep 09 09:22:39 2020 +0000
@@ -1887,6 +1887,8 @@
     masm.storePtr(tls, Address(sp_, stackOffset(tlsPointerOffset_)));
   }
 
+  int32_t getTlsPtrOffset() { return stackOffset(tlsPointerOffset_); }
+
   // An outgoing stack result area pointer is for stack results of callees of
   // the function being compiled.
   void computeOutgoingStackResultAreaPtr(const StackResultsLoc& results,
@@ -10312,7 +10314,8 @@
   masm.passABIArg(srcDest.low);
   masm.passABIArg(rhs.high);
   masm.passABIArg(rhs.low);
-  CodeOffset raOffset = masm.callWithABI(bytecodeOffset(), callee);
+  CodeOffset raOffset = masm.callWithABI(bytecodeOffset(), callee,
+                                         mozilla::Some(fr.getTlsPtrOffset()));
   if (!createStackMap("emitDivOrModI64Bui[..]", raOffset)) {
     return false;
   }
@@ -10343,7 +10346,7 @@
   masm.passABIArg(input.low);
 #  endif
   CodeOffset raOffset = masm.callWithABI(
-      bytecodeOffset(), callee,
+      bytecodeOffset(), callee, mozilla::Some(fr.getTlsPtrOffset()),
       resultType == ValType::F32 ? MoveOp::FLOAT32 : MoveOp::DOUBLE);
   if (!createStackMap("emitConvertInt64To[..]", raOffset)) {
     return false;
@@ -10387,7 +10390,8 @@
 
   masm.setupWasmABICall();
   masm.passABIArg(doubleInput, MoveOp::DOUBLE);
-  CodeOffset raOffset = masm.callWithABI(bytecodeOffset(), callee);
+  CodeOffset raOffset = masm.callWithABI(bytecodeOffset(), callee,
+                                         mozilla::Some(fr.getTlsPtrOffset()));
   if (!createStackMap("emitConvertFloatin[..]", raOffset)) {
     return false;
   }
