# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/arm/CodeGenerator-arm.cpp
# Commit: bba9e8259714
# Full Hash: bba9e82597147f0a5b9a6a6a8fc6525ff87fc914
# Author: Dmitry Bezhetskov <dbezhetskov@igalia.com>
# Date: 2020-10-02 04:10:47
# Regressor Bug: 1639153
# File Overlap Count: 1
# Description:
#   Bug 1639153 - Part 6.3: Establish dependency from tls for arm callWithABI div/mod i64. r=lth
#   
#   To be able to call c++ runtime via Builtin thunk we need to set up WasmTlsReg.
#   In this patch I create dependencies from MIR level to Codegen to be sure that WasmTlsReg is alive
#   when we call runtime in div/mod i64 for arm.
# ==============================================================================

diff -r c5ef1152da2b -r bba9e8259714 js/src/jit/arm/CodeGenerator-arm.cpp
--- a/js/src/jit/arm/CodeGenerator-arm.cpp	Thu Oct 01 07:52:24 2020 +0000
+++ b/js/src/jit/arm/CodeGenerator-arm.cpp	Thu Oct 01 07:52:37 2020 +0000
@@ -2540,26 +2540,12 @@
   masm.ma_asr(Imm32(31), output.low, output.high);
 }
 
-static Register WasmGetTemporaryForDivOrMod(Register64 lhs, Register64 rhs) {
-  MOZ_ASSERT(IsCompilingWasm());
-
-  // All inputs are useAtStart for a call instruction. As a result we cannot
-  // ask the register allocator for a non-aliasing temp.
-  AllocatableGeneralRegisterSet regs(GeneralRegisterSet::All());
-  regs.take(lhs.low);
-  regs.take(lhs.high);
-
-  // The FramePointer shouldn't be clobbered for profiling.
-  regs.take(FramePointer);
-
-  if (lhs != rhs) {
-    regs.take(rhs.low);
-    regs.take(rhs.high);
-  }
-  return regs.takeAny();
-}
-
 void CodeGenerator::visitDivOrModI64(LDivOrModI64* lir) {
+  MOZ_ASSERT(gen->compilingWasm());
+  MOZ_ASSERT(ToRegister(lir->getOperand(LDivOrModI64::Tls)) == WasmTlsReg);
+  masm.Push(WasmTlsReg);
+  int32_t framePushedAfterTls = masm.framePushed();
+
   Register64 lhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Lhs));
   Register64 rhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Rhs));
   Register64 output = ToOutRegister64(lir);
@@ -2570,9 +2556,9 @@
 
   // Handle divide by zero.
   if (lir->canBeDivideByZero()) {
-    Register temp = WasmGetTemporaryForDivOrMod(lhs, rhs);
     Label nonZero;
-    masm.branchTest64(Assembler::NonZero, rhs, rhs, temp, &nonZero);
+    // We can use WasmTlsReg as temp register because we preserved it before.
+    masm.branchTest64(Assembler::NonZero, rhs, rhs, WasmTlsReg, &nonZero);
     masm.wasmTrap(wasm::Trap::IntegerDivideByZero, lir->bytecodeOffset());
     masm.bind(&nonZero);
   }
@@ -2584,7 +2570,7 @@
     Label notmin;
     masm.branch64(Assembler::NotEqual, lhs, Imm64(INT64_MIN), &notmin);
     masm.branch64(Assembler::NotEqual, rhs, Imm64(-1), &notmin);
-    if (mir->isMod()) {
+    if (mir->isWasmBuiltinModI64()) {
       masm.xor64(output, output);
     } else {
       masm.wasmTrap(wasm::Trap::IntegerOverflow, lir->bytecodeOffset());
@@ -2599,20 +2585,27 @@
   masm.passABIArg(rhs.high);
   masm.passABIArg(rhs.low);
 
-  if (mir->isMod()) {
+  int32_t tlsOffset = masm.framePushed() - framePushedAfterTls;
+  if (mir->isWasmBuiltinModI64()) {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::ModI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   } else {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::DivI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   }
 
   MOZ_ASSERT(ReturnReg64 == output);
 
   masm.bind(&done);
+  masm.Pop(WasmTlsReg);
 }
 
 void CodeGenerator::visitUDivOrModI64(LUDivOrModI64* lir) {
+  MOZ_ASSERT(gen->compilingWasm());
+  MOZ_ASSERT(ToRegister(lir->getOperand(LDivOrModI64::Tls)) == WasmTlsReg);
+  masm.Push(WasmTlsReg);
+  int32_t framePushedAfterTls = masm.framePushed();
+
   Register64 lhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Lhs));
   Register64 rhs = ToRegister64(lir->getInt64Operand(LDivOrModI64::Rhs));
 
@@ -2620,9 +2613,9 @@
 
   // Prevent divide by zero.
   if (lir->canBeDivideByZero()) {
-    Register temp = WasmGetTemporaryForDivOrMod(lhs, rhs);
     Label nonZero;
-    masm.branchTest64(Assembler::NonZero, rhs, rhs, temp, &nonZero);
+    // We can use WasmTlsReg as temp register because we preserved it before.
+    masm.branchTest64(Assembler::NonZero, rhs, rhs, WasmTlsReg, &nonZero);
     masm.wasmTrap(wasm::Trap::IntegerDivideByZero, lir->bytecodeOffset());
     masm.bind(&nonZero);
   }
@@ -2633,15 +2626,16 @@
   masm.passABIArg(rhs.high);
   masm.passABIArg(rhs.low);
 
-  MOZ_ASSERT(gen->compilingWasm());
   MDefinition* mir = lir->mir();
-  if (mir->isMod()) {
+  int32_t tlsOffset = masm.framePushed() - framePushedAfterTls;
+  if (mir->isWasmBuiltinModI64()) {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::UModI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   } else {
     masm.callWithABI(lir->bytecodeOffset(), wasm::SymbolicAddress::UDivI64,
-                     mozilla::Nothing());
+                     mozilla::Some(tlsOffset));
   }
+  masm.Pop(WasmTlsReg);
 }
 
 void CodeGenerator::visitCompareI64(LCompareI64* lir) {