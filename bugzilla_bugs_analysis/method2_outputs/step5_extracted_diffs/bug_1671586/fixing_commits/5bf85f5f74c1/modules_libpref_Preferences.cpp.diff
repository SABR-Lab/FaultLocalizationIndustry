# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: modules/libpref/Preferences.cpp
# Commit: 5bf85f5f74c1
# Full Hash: 5bf85f5f74c1262d2dad3283b111b2e388e9c2ca
# Author: Kris Wright <kwright@mozilla.com>
# Date: 2020-11-21 09:27:54
# Description:
#   Bug 1671586 - Let GetPrefValue() fail when updating a mirror. r=sg
#   
#   In bug 1642727 we assumed this method was now essentially infallible because we do not delete mirror prefs. However, users can input some pref values that cause the value casts in `GetValue` to fail, which causes a crash. This commit reverts this behavior back to what it originally does (fail silently) to prevent crashing. We need to fix the underlying issue (bug 1672265) but we also need to ensure this doesn't crash, and any unexpected behavior caused by incorrect pref entry will return to its original behavior before this change, which relies on the individual components' handling of bad pref values rather than `UpdateMirror`.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D94195
# ==============================================================================

diff -r d57553438d94 -r 5bf85f5f74c1 modules/libpref/Preferences.cpp
--- a/modules/libpref/Preferences.cpp	Fri Nov 20 19:13:34 2020 +0000
+++ b/modules/libpref/Preferences.cpp	Fri Nov 20 14:00:06 2020 +0000
@@ -4386,10 +4386,21 @@
   template <typename T>
   static void UpdateMirror(const char* aPref, void* aMirror) {
     StripAtomic<T> value;
-    // We disallow the deletion of mirrored prefs.
-    // This assertion is the only place where we enforce this.
-    MOZ_ALWAYS_SUCCEEDS(GetPrefValue(aPref, &value, PrefValueKind::User));
-    *static_cast<T*>(aMirror) = value;
+
+    nsresult rv = GetPrefValue(aPref, &value, PrefValueKind::User);
+    if (NS_SUCCEEDED(rv)) {
+      *static_cast<T*>(aMirror) = value;
+    } else {
+      // GetPrefValue() can fail if the update is caused by the pref being
+      // deleted or if it fails to make a cast. This assertion is the only place
+      // where we safeguard these. In this case the mirror variable will be
+      // untouched, thus keeping the value it had prior to the change.
+      // (Note that this case won't happen for a deletion via DeleteBranch()
+      // unless bug 343600 is fixed, but it will happen for a deletion via
+      // ClearUserPref().)
+      NS_WARNING(nsPrintfCString("Pref changed failure: %s\n", aPref).get());
+      MOZ_ASSERT(false);
+    }
   }
 
   template <typename T>
