# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/ipc/RemoteDecoderManagerChild.cpp
# Commit: 3f08ccb1f141
# Full Hash: 3f08ccb1f141069bfd90474d6023413303307ec4
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-11-04 09:55:18
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1674043 - P6. Remove sync PDecoderMananger::Supports API. r=mattwoodrow,bryce,mjf,ipc-reviewers,nika
#   
#   In bug 1595994 we attempted to streamline the ability to determine which decoder was available regardless of the process they would be running in. This was subsequently done via the PDMFactory.
#   
#   As there are several JS API that can query which codec are supported, it requires a synchronous mechanism.
# ==============================================================================

diff -r 33563a16a5c3 -r 3f08ccb1f141 dom/media/ipc/RemoteDecoderManagerChild.cpp
--- a/dom/media/ipc/RemoteDecoderManagerChild.cpp	Mon Nov 02 15:32:59 2020 +0000
+++ b/dom/media/ipc/RemoteDecoderManagerChild.cpp	Wed Nov 04 02:22:33 2020 +0000
@@ -64,13 +64,6 @@
 
 StaticRefPtr<ShutdownObserver> sObserver;
 
-static Maybe<layers::TextureFactoryIdentifier> MaybeTextureFactoryIdentifier(
-    const SupportDecoderParams& aParams) {
-  return aParams.mKnowsCompositor
-             ? Some(aParams.mKnowsCompositor->GetTextureFactoryIdentifier())
-             : Nothing();
-}
-
 /* static */
 void RemoteDecoderManagerChild::Init() {
   MOZ_ASSERT(NS_IsMainThread());
@@ -186,41 +179,18 @@
 bool RemoteDecoderManagerChild::Supports(
     RemoteDecodeIn aLocation, const SupportDecoderParams& aParams,
     DecoderDoctorDiagnostics* aDiagnostics) {
-  bool supports = false;
-  DecoderDoctorDiagnostics diagnostics;
-
-  nsCOMPtr<nsISerialEventTarget> managerThread = GetManagerThread();
-  if (managerThread) {
-    RefPtr<Runnable> task =
-        NS_NewRunnableFunction("RemoteDecoderManager::Supports", [&]() {
-          auto* rdm = GetSingleton(aLocation);
-          if (!rdm) {
-            // The RDD process failed to launch. Fail for now.
-            // Creation will be attempted again later.
-            return;
-          }
-          const auto& trackInfo = aParams.mConfig;
-          if (trackInfo.GetAsVideoInfo()) {
-            VideoDecoderInfoIPDL info(*trackInfo.GetAsVideoInfo(),
-                                      aParams.mRate.mValue);
-            Unused << rdm->SendSupports(info,
-                                        MaybeTextureFactoryIdentifier(aParams),
-                                        &supports, &diagnostics);
-          } else if (trackInfo.GetAsAudioInfo()) {
-            Unused << rdm->SendSupports(*trackInfo.GetAsAudioInfo(), Nothing(),
-                                        &supports, &diagnostics);
-          }
-        });
-    // If we've already got shutdown, the dispatch will fail and SyncRunnable
-    // will immediately return.
-    SyncRunnable::DispatchToThread(managerThread, task);
+  RefPtr<PDMFactory> pdm;
+  switch (aLocation) {
+    case RemoteDecodeIn::RddProcess:
+      pdm = PDMFactory::PDMFactoryForRdd();
+      break;
+    case RemoteDecodeIn::GpuProcess:
+      pdm = PDMFactory::PDMFactoryForGpu();
+      break;
+    default:
+      return false;
   }
-
-  if (aDiagnostics) {
-    *aDiagnostics = diagnostics;
-  }
-
-  return supports;
+  return pdm->Supports(aParams, aDiagnostics);
 }
 
 /* static */