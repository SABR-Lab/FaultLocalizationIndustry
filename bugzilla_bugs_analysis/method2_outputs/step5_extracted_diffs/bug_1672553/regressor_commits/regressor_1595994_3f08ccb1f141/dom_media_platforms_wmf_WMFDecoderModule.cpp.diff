# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/wmf/WMFDecoderModule.cpp
# Commit: 3f08ccb1f141
# Full Hash: 3f08ccb1f141069bfd90474d6023413303307ec4
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-11-04 09:55:18
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1674043 - P6. Remove sync PDecoderMananger::Supports API. r=mattwoodrow,bryce,mjf,ipc-reviewers,nika
#   
#   In bug 1595994 we attempted to streamline the ability to determine which decoder was available regardless of the process they would be running in. This was subsequently done via the PDMFactory.
#   
#   As there are several JS API that can query which codec are supported, it requires a synchronous mechanism.
# ==============================================================================

diff -r 33563a16a5c3 -r 3f08ccb1f141 dom/media/platforms/wmf/WMFDecoderModule.cpp
--- a/dom/media/platforms/wmf/WMFDecoderModule.cpp	Mon Nov 02 15:32:59 2020 +0000
+++ b/dom/media/platforms/wmf/WMFDecoderModule.cpp	Wed Nov 04 02:22:33 2020 +0000
@@ -14,6 +14,7 @@
 #include "MFTDecoder.h"
 #include "MP4Decoder.h"
 #include "MediaInfo.h"
+#include "PDMFactory.h"
 #include "VPXDecoder.h"
 #include "WMF.h"
 #include "WMFAudioMFTManager.h"
@@ -28,6 +29,7 @@
 #include "mozilla/mscom/EnsureMTA.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIXULRuntime.h"
+#include "nsIXULRuntime.h"  // for BrowserTabsRemoteAutostart
 #include "nsServiceManagerUtils.h"
 #include "nsWindowsHelpers.h"
 #include "prsystem.h"
@@ -94,26 +96,21 @@
 /* static */
 void WMFDecoderModule::Init() {
   MOZ_DIAGNOSTIC_ASSERT(NS_IsMainThread());
-  bool testForVPx;
   if (XRE_IsContentProcess()) {
     // If we're in the content process and the UseGPUDecoder pref is set, it
     // means that we've given up on the GPU process (it's been crashing) so we
     // should disable DXVA
     sDXVAEnabled = !StaticPrefs::media_gpu_process_decoder();
-    // We need to test for VPX in the content process as the GPUDecoderModule
-    // directly calls WMFDecoderModule::Supports in the content process.
-    // This unnecessary requirement will be fixed in bug 1534815.
-    testForVPx = true;
   } else if (XRE_IsGPUProcess() || XRE_IsRDDProcess()) {
     // Always allow DXVA in the GPU or RDD process.
-    testForVPx = sDXVAEnabled = true;
+    sDXVAEnabled = true;
   } else {
     // Only allow DXVA in the UI process if we aren't in e10s Firefox
-    testForVPx = sDXVAEnabled = !mozilla::BrowserTabsRemoteAutostart();
+    sDXVAEnabled = !mozilla::BrowserTabsRemoteAutostart();
   }
 
   sDXVAEnabled = sDXVAEnabled && gfx::gfxVars::CanUseHardwareVideoDecoding();
-  testForVPx = testForVPx && gfx::gfxVars::CanUseHardwareVideoDecoding();
+  bool testForVPx = gfx::gfxVars::CanUseHardwareVideoDecoding();
   if (testForVPx && StaticPrefs::media_wmf_vp9_enabled_AtStartup()) {
     gfx::WMFVPXVideoCrashGuard guard;
     if (!guard.Crashed()) {
@@ -214,14 +211,44 @@
 
 /* static */
 bool WMFDecoderModule::HasH264() {
+  if (XRE_IsContentProcess()) {
+    return PDMFactory::Supported().contains(PDMFactory::MediaCodecs::H264);
+  }
   return CanCreateWMFDecoder<CLSID_CMSH264DecoderMFT>();
 }
 
 /* static */
+bool WMFDecoderModule::HasVP8() {
+  if (XRE_IsContentProcess()) {
+    return PDMFactory::Supported().contains(PDMFactory::MediaCodecs::VP8);
+  }
+  return sUsableVPXMFT && CanCreateWMFDecoder<CLSID_WebmMfVpxDec>();
+}
+
+/* static */
+bool WMFDecoderModule::HasVP9() {
+  if (XRE_IsContentProcess()) {
+    return PDMFactory::Supported().contains(PDMFactory::MediaCodecs::VP9);
+  }
+  return sUsableVPXMFT && CanCreateWMFDecoder<CLSID_WebmMfVpxDec>();
+}
+
+/* static */
 bool WMFDecoderModule::HasAAC() {
+  if (XRE_IsContentProcess()) {
+    return PDMFactory::Supported().contains(PDMFactory::MediaCodecs::AAC);
+  }
   return CanCreateWMFDecoder<CLSID_CMSAACDecMFT>();
 }
 
+/* static */
+bool WMFDecoderModule::HasMP3() {
+  if (XRE_IsContentProcess()) {
+    return PDMFactory::Supported().contains(PDMFactory::MediaCodecs::MP3);
+  }
+  return CanCreateWMFDecoder<CLSID_CMP3DecMediaObject>();
+}
+
 bool WMFDecoderModule::SupportsMimeType(
     const nsACString& aMimeType, DecoderDoctorDiagnostics* aDiagnostics) const {
   UniquePtr<TrackInfo> trackInfo = CreateTrackInfoWithMIMEType(aMimeType);
@@ -269,17 +296,16 @@
     return true;
   }
   if (trackInfo.mMimeType.EqualsLiteral("audio/mpeg") &&
-      !StaticPrefs::media_ffvpx_mp3_enabled() &&
-      CanCreateWMFDecoder<CLSID_CMP3DecMediaObject>()) {
+      !StaticPrefs::media_ffvpx_mp3_enabled() && WMFDecoderModule::HasMP3()) {
     return true;
   }
-  if (sUsableVPXMFT) {
-    static const uint32_t VP8_USABLE_BUILD = 16287;
-    if ((VPXDecoder::IsVP8(trackInfo.mMimeType) &&
-         IsWindowsBuildOrLater(VP8_USABLE_BUILD)) ||
-        VPXDecoder::IsVP9(trackInfo.mMimeType)) {
-      return CanCreateWMFDecoder<CLSID_WebmMfVpxDec>();
-    }
+  static const uint32_t VP8_USABLE_BUILD = 16287;
+  if (VPXDecoder::IsVP8(trackInfo.mMimeType) &&
+      IsWindowsBuildOrLater(VP8_USABLE_BUILD) && WMFDecoderModule::HasVP8()) {
+    return true;
+  }
+  if (VPXDecoder::IsVP9(trackInfo.mMimeType) && WMFDecoderModule::HasVP9()) {
+    return true;
   }
 
   // Some unsupported codec.