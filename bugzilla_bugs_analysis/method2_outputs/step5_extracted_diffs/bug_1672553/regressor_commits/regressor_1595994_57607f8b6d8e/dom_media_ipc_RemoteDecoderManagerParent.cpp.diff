# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/ipc/RemoteDecoderManagerParent.cpp
# Commit: 57607f8b6d8e
# Full Hash: 57607f8b6d8e1619b5c488494fd57547944c47b1
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-10-21 09:51:28
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1595994 - P7: Add Supports messages to PRemoteDecoderManager. r=kamidphish,nika,ipc-reviewers
#   
#   Add a synchronous Supports message to the IPDL PRemoteDecoderManager protocol so
#   decoder modules can query for playback support in the actual process that will
#   attempt to do the decoding.
# ==============================================================================

diff -r 1932f2f34993 -r 57607f8b6d8e dom/media/ipc/RemoteDecoderManagerParent.cpp
--- a/dom/media/ipc/RemoteDecoderManagerParent.cpp	Tue Oct 20 23:26:25 2020 +0000
+++ b/dom/media/ipc/RemoteDecoderManagerParent.cpp	Tue Oct 20 23:26:27 2020 +0000
@@ -196,7 +196,9 @@
         this, decoderInfo.videoInfo(), decoderInfo.framerate(), aOptions,
         aIdentifier, sRemoteDecoderManagerParentThread, decodeTaskQueue,
         aSuccess, aErrorDescription);
-  } else if (aRemoteDecoderInfo.type() == RemoteDecoderInfoIPDL::TAudioInfo) {
+  }
+
+  if (aRemoteDecoderInfo.type() == RemoteDecoderInfoIPDL::TAudioInfo) {
     return new RemoteAudioDecoderParent(
         this, aRemoteDecoderInfo.get_AudioInfo(), aOptions,
         sRemoteDecoderManagerParentThread, decodeTaskQueue, aSuccess,
@@ -225,6 +227,40 @@
 
 void RemoteDecoderManagerParent::ActorDealloc() { Release(); }
 
+mozilla::ipc::IPCResult RemoteDecoderManagerParent::RecvSupports(
+    const RemoteDecoderInfoIPDL& aInfo,
+    const Maybe<layers::TextureFactoryIdentifier>& aIdentifier, bool* aSuccess,
+    DecoderDoctorDiagnostics* aDiagnostics) {
+  auto& factory = EnsurePDMFactory();
+  MediaResult error(NS_OK);
+
+  // It's important to initialize aSuccess because it is passed uninitialized
+  // which will cause an assert on the receiving side.
+  *aSuccess = false;
+  if (aInfo.type() == RemoteDecoderInfoIPDL::TAudioInfo) {
+    SupportDecoderParams params(aInfo.get_AudioInfo(), &error);
+    *aSuccess = factory.Supports(params, aDiagnostics);
+  } else if (aInfo.type() == RemoteDecoderInfoIPDL::TVideoDecoderInfoIPDL) {
+    RefPtr<KnowsCompositorVideo> knowsCompositor;
+    if (aIdentifier) {
+      // Check to see if we have a direct PVideoBridge connection to the
+      // destination process specified in aIdentifier, and create a
+      // KnowsCompositor representing that connection if so. If this fails, then
+      // we fall back to returning the decoded frames directly via Output().
+      knowsCompositor =
+          KnowsCompositorVideo::TryCreateForIdentifier(*aIdentifier);
+    }
+
+    const VideoDecoderInfoIPDL& info = aInfo.get_VideoDecoderInfoIPDL();
+    SupportDecoderParams params(info.videoInfo(), knowsCompositor,
+                                media::VideoFrameRate(info.framerate()),
+                                &error);
+    *aSuccess = factory.Supports(params, aDiagnostics);
+  }
+
+  return IPC_OK();
+}
+
 mozilla::ipc::IPCResult RemoteDecoderManagerParent::RecvReadback(
     const SurfaceDescriptorGPUVideo& aSD, SurfaceDescriptor* aResult) {
   const SurfaceDescriptorRemoteDecoder& sd = aSD;