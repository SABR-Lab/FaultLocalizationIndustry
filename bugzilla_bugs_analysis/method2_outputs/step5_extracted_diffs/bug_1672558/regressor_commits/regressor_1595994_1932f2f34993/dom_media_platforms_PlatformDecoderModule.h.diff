# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/PlatformDecoderModule.h
# Commit: 1932f2f34993
# Full Hash: 1932f2f3499302f712bb680096d51478e53c99ed
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-10-21 09:51:28
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1595994 - P6: Change Supports to take SupportDecoderParams. r=kamidphish
#   
#   This is a subset of the parameters passed via CreateDecoderParams and is so
#   Supports() calls have access to KnowsCompositor and Options when determining
#   if decoding is supported.
# ==============================================================================

diff -r 0606794a9e8c -r 1932f2f34993 dom/media/platforms/PlatformDecoderModule.h
--- a/dom/media/platforms/PlatformDecoderModule.h	Tue Oct 20 23:24:48 2020 +0000
+++ b/dom/media/platforms/PlatformDecoderModule.h	Tue Oct 20 23:26:25 2020 +0000
@@ -41,44 +41,53 @@
 
 static LazyLogModule sPDMLog("PlatformDecoderModule");
 
-struct MOZ_STACK_CLASS CreateDecoderParams final {
-  explicit CreateDecoderParams(const TrackInfo& aConfig) : mConfig(aConfig) {}
+namespace media {
 
-  enum class Option {
-    Default,
-    LowLatency,
-    HardwareDecoderNotAllowed,
-    FullH264Parsing,
-    ErrorIfNoInitializationData,  // By default frames delivered before
-                                  // initialization data are dropped. Pass this
-                                  // option to raise an error if frames are
-                                  // delivered before initialization data.
-    DefaultPlaybackDeviceMono,    // Currently only used by Opus on RDD to avoid
-                                  // initialization of audio backends on RDD
+enum class Option {
+  Default,
+  LowLatency,
+  HardwareDecoderNotAllowed,
+  FullH264Parsing,
+  ErrorIfNoInitializationData,  // By default frames delivered before
+                                // initialization data are dropped. Pass this
+                                // option to raise an error if frames are
+                                // delivered before initialization data.
+  DefaultPlaybackDeviceMono,    // Currently only used by Opus on RDD to avoid
+                                // initialization of audio backends on RDD
 
-    SENTINEL  // one past the last valid value
-  };
-  using OptionSet = EnumSet<Option>;
+  SENTINEL  // one past the last valid value
+};
+using OptionSet = EnumSet<Option>;
+
+struct UseNullDecoder {
+  UseNullDecoder() = default;
+  explicit UseNullDecoder(bool aUseNullDecoder) : mUse(aUseNullDecoder) {}
+  bool mUse = false;
+};
 
-  struct UseNullDecoder {
-    UseNullDecoder() = default;
-    explicit UseNullDecoder(bool aUseNullDecoder) : mUse(aUseNullDecoder) {}
-    bool mUse = false;
-  };
+// Do not wrap H264 decoder in a H264Converter.
+struct NoWrapper {
+  NoWrapper() = default;
+  explicit NoWrapper(bool aDontUseWrapper) : mDontUseWrapper(aDontUseWrapper) {}
+  bool mDontUseWrapper = false;
+};
 
-  // Do not wrap decoder in a MediaChangeMonitor.
-  struct NoWrapper {
-    NoWrapper() = default;
-    explicit NoWrapper(bool aDontUseWrapper)
-        : mDontUseWrapper(aDontUseWrapper) {}
-    bool mDontUseWrapper = false;
-  };
+struct VideoFrameRate {
+  VideoFrameRate() = default;
+  explicit VideoFrameRate(float aFramerate) : mValue(aFramerate) {}
+  float mValue = 0.0f;
+};
+
+}  // namespace media
 
-  struct VideoFrameRate {
-    VideoFrameRate() = default;
-    explicit VideoFrameRate(float aFramerate) : mValue(aFramerate) {}
-    float mValue = 0.0f;
-  };
+struct MOZ_STACK_CLASS CreateDecoderParams final {
+  using Option = media::Option;
+  using OptionSet = media::OptionSet;
+  using UseNullDecoder = media::UseNullDecoder;
+  using NoWrapper = media::NoWrapper;
+  using VideoFrameRate = media::VideoFrameRate;
+
+  explicit CreateDecoderParams(const TrackInfo& aConfig) : mConfig(aConfig) {}
 
   template <typename T1, typename... Ts>
   CreateDecoderParams(const TrackInfo& aConfig, T1&& a1, Ts&&... args)
@@ -115,12 +124,12 @@
   MediaResult* mError = nullptr;
   RefPtr<layers::KnowsCompositor> mKnowsCompositor;
   RefPtr<GMPCrashHelper> mCrashHelper;
-  UseNullDecoder mUseNullDecoder;
-  NoWrapper mNoWrapper;
+  media::UseNullDecoder mUseNullDecoder;
+  media::NoWrapper mNoWrapper;
   TrackInfo::TrackType mType = TrackInfo::kUndefinedTrack;
   MediaEventProducer<TrackInfo::TrackType>* mOnWaitingForKeyEvent = nullptr;
   OptionSet mOptions = OptionSet(Option::Default);
-  VideoFrameRate mRate;
+  media::VideoFrameRate mRate;
 
  private:
   void Set(DecoderDoctorDiagnostics* aDiagnostics) {
@@ -154,6 +163,67 @@
   }
 };
 
+struct MOZ_STACK_CLASS SupportDecoderParams final {
+  using Option = media::Option;
+  using OptionSet = media::OptionSet;
+  using UseNullDecoder = media::UseNullDecoder;
+  using NoWrapper = media::NoWrapper;
+  using VideoFrameRate = media::VideoFrameRate;
+
+  explicit SupportDecoderParams(const TrackInfo& aConfig) : mConfig(aConfig) {}
+
+  explicit SupportDecoderParams(const CreateDecoderParams& aParams)
+      : mConfig(aParams.mConfig),
+        mDiagnostics(aParams.mDiagnostics),
+        mError(aParams.mError),
+        mKnowsCompositor(aParams.mKnowsCompositor),
+        mUseNullDecoder(aParams.mUseNullDecoder),
+        mNoWrapper(aParams.mNoWrapper),
+        mOptions(aParams.mOptions),
+        mRate(aParams.mRate) {}
+
+  template <typename T1, typename... Ts>
+  SupportDecoderParams(const TrackInfo& aConfig, T1&& a1, Ts&&... args)
+      : mConfig(aConfig) {
+    Set(std::forward<T1>(a1), std::forward<Ts>(args)...);
+  }
+
+  const nsCString& MimeType() const { return mConfig.mMimeType; }
+
+  const TrackInfo& mConfig;
+  DecoderDoctorDiagnostics* mDiagnostics = nullptr;
+  MediaResult* mError = nullptr;
+  RefPtr<layers::KnowsCompositor> mKnowsCompositor;
+  UseNullDecoder mUseNullDecoder;
+  NoWrapper mNoWrapper;
+  OptionSet mOptions = OptionSet(Option::Default);
+  VideoFrameRate mRate;
+
+ private:
+  void Set(DecoderDoctorDiagnostics* aDiagnostics) {
+    mDiagnostics = aDiagnostics;
+  }
+  void Set(MediaResult* aError) { mError = aError; }
+  void Set(media::UseNullDecoder aUseNullDecoder) {
+    mUseNullDecoder = aUseNullDecoder;
+  }
+  void Set(media::NoWrapper aNoWrapper) { mNoWrapper = aNoWrapper; }
+  void Set(media::OptionSet aOptions) { mOptions = aOptions; }
+  void Set(media::VideoFrameRate aRate) { mRate = aRate; }
+  void Set(layers::KnowsCompositor* aKnowsCompositor) {
+    if (aKnowsCompositor) {
+      mKnowsCompositor = aKnowsCompositor;
+      MOZ_ASSERT(aKnowsCompositor->IsThreadSafe());
+    }
+  }
+
+  template <typename T1, typename T2, typename... Ts>
+  void Set(T1&& a1, T2&& a2, Ts&&... args) {
+    Set(std::forward<T1>(a1));
+    Set(std::forward<T2>(a2), std::forward<Ts>(args)...);
+  }
+};
+
 // Used for IPDL serialization.
 // The 'value' have to be the biggest enum from CreateDecoderParams::Option.
 template <>
@@ -189,12 +259,13 @@
       const nsACString& aMimeType,
       DecoderDoctorDiagnostics* aDiagnostics) const = 0;
 
-  virtual bool Supports(const TrackInfo& aTrackInfo,
+  virtual bool Supports(const SupportDecoderParams& aParams,
                         DecoderDoctorDiagnostics* aDiagnostics) const {
-    if (!SupportsMimeType(aTrackInfo.mMimeType, aDiagnostics)) {
+    const TrackInfo& trackInfo = aParams.mConfig;
+    if (!SupportsMimeType(trackInfo.mMimeType, aDiagnostics)) {
       return false;
     }
-    const auto videoInfo = aTrackInfo.GetAsVideoInfo();
+    const auto* videoInfo = trackInfo.GetAsVideoInfo();
     return !videoInfo ||
            SupportsColorDepth(videoInfo->mColorDepth, aDiagnostics);
   }