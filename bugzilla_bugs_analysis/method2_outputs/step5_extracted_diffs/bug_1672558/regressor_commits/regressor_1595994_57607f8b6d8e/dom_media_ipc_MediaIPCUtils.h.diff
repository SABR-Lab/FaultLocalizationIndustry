# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/ipc/MediaIPCUtils.h
# Commit: 57607f8b6d8e
# Full Hash: 57607f8b6d8e1619b5c488494fd57547944c47b1
# Author: Dan Glastonbury <dan.glastonbury@gmail.com>
# Date: 2020-10-21 09:51:28
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1595994 - P7: Add Supports messages to PRemoteDecoderManager. r=kamidphish,nika,ipc-reviewers
#   
#   Add a synchronous Supports message to the IPDL PRemoteDecoderManager protocol so
#   decoder modules can query for playback support in the actual process that will
#   attempt to do the decoding.
# ==============================================================================

diff -r 1932f2f34993 -r 57607f8b6d8e dom/media/ipc/MediaIPCUtils.h
--- a/dom/media/ipc/MediaIPCUtils.h	Tue Oct 20 23:26:25 2020 +0000
+++ b/dom/media/ipc/MediaIPCUtils.h	Tue Oct 20 23:26:27 2020 +0000
@@ -7,8 +7,10 @@
 #ifndef mozilla_dom_media_MediaIPCUtils_h
 #define mozilla_dom_media_MediaIPCUtils_h
 
+#include "DecoderDoctorDiagnostics.h"
 #include "PlatformDecoderModule.h"
 #include "ipc/IPCMessageUtils.h"
+#include "mozilla/EnumSet.h"
 #include "mozilla/GfxMessageUtils.h"
 #include "mozilla/gfx/Rect.h"
 
@@ -191,6 +193,59 @@
   };
 };
 
+template <>
+struct ParamTraits<mozilla::DecoderDoctorDiagnostics> {
+  typedef mozilla::DecoderDoctorDiagnostics paramType;
+
+  static void Write(Message* aMsg, const paramType& aParam) {
+    WriteParam(aMsg, aParam.mDiagnosticsType);
+    WriteParam(aMsg, aParam.mFormat);
+    WriteParam(aMsg, aParam.mFlags);
+    WriteParam(aMsg, aParam.mEvent);
+  }
+
+  static bool Read(const Message* aMsg, PickleIterator* aIter,
+                   paramType* aResult) {
+    if (ReadParam(aMsg, aIter, &aResult->mDiagnosticsType) &&
+        ReadParam(aMsg, aIter, &aResult->mFormat) &&
+        ReadParam(aMsg, aIter, &aResult->mFlags) &&
+        ReadParam(aMsg, aIter, &aResult->mEvent)) {
+      return true;
+    }
+    return false;
+  };
+};
+
+template <>
+struct ParamTraits<mozilla::DecoderDoctorDiagnostics::DiagnosticsType>
+    : public ContiguousEnumSerializerInclusive<
+          mozilla::DecoderDoctorDiagnostics::DiagnosticsType,
+          mozilla::DecoderDoctorDiagnostics::DiagnosticsType::eUnsaved,
+          mozilla::DecoderDoctorDiagnostics::DiagnosticsType::eDecodeWarning> {
+};
+
+template <>
+struct ParamTraits<mozilla::DecoderDoctorEvent> {
+  typedef mozilla::DecoderDoctorEvent paramType;
+
+  static void Write(Message* aMsg, const paramType& aParam) {
+    int domain = aParam.mDomain;
+    WriteParam(aMsg, domain);
+    WriteParam(aMsg, aParam.mResult);
+  }
+
+  static bool Read(const Message* aMsg, PickleIterator* aIter,
+                   paramType* aResult) {
+    int domain = 0;
+    if (ReadParam(aMsg, aIter, &domain) &&
+        ReadParam(aMsg, aIter, &aResult->mResult)) {
+      aResult->mDomain = paramType::Domain(domain);
+      return true;
+    }
+    return false;
+  };
+};
+
 }  // namespace IPC
 
 #endif  // mozilla_dom_media_MediaIPCUtils_h