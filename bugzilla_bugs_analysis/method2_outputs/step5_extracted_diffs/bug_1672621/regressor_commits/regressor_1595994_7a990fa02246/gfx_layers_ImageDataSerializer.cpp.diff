# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ImageDataSerializer.cpp
# Commit: 7a990fa02246
# Full Hash: 7a990fa022462c702adacfac907a0fc178940b9d
# Author: Jean-Yves Avenard <jyavenard@mozilla.com>
# Date: 2020-10-21 09:51:28
# Regressor Bug: 1595994
# File Overlap Count: 1
# Description:
#   Bug 1595994 - P1D. Properly serialize display size when sending image over IPC. r=mattwoodrow
#   
#   The code always assumed that the size of the image with the Y plane dimensions, which, while often the case, isn't correct.
#   We remove the assertions that the display offset was always (0,0) and properly carry the actual data over IPC.
#   
# ==============================================================================

diff -r 4c7f671c7b69 -r 7a990fa02246 gfx/layers/ImageDataSerializer.cpp
--- a/gfx/layers/ImageDataSerializer.cpp	Tue Oct 20 23:29:30 2020 +0000
+++ b/gfx/layers/ImageDataSerializer.cpp	Tue Oct 20 23:30:04 2020 +0000
@@ -5,15 +5,15 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ImageDataSerializer.h"
+
+#include "YCbCrUtils.h"           // for YCbCr conversions
 #include "gfx2DGlue.h"            // for SurfaceFormatToImageFormat
-#include "mozilla/gfx/Point.h"    // for IntSize
 #include "mozilla/Assertions.h"   // for MOZ_ASSERT, etc
 #include "mozilla/gfx/2D.h"       // for DataSourceSurface, Factory
 #include "mozilla/gfx/Logging.h"  // for gfxDebug
 #include "mozilla/gfx/Tools.h"    // for GetAlignedStride, etc
 #include "mozilla/gfx/Types.h"
 #include "mozilla/mozalloc.h"  // for operator delete, etc
-#include "YCbCrUtils.h"        // for YCbCr conversions
 
 namespace mozilla {
 namespace layers {
@@ -139,13 +139,27 @@
   switch (aDescriptor.type()) {
     case BufferDescriptor::TRGBDescriptor:
       return aDescriptor.get_RGBDescriptor().size();
-    case BufferDescriptor::TYCbCrDescriptor:
-      return aDescriptor.get_YCbCrDescriptor().ySize();
+    case BufferDescriptor::TYCbCrDescriptor: {
+      return aDescriptor.get_YCbCrDescriptor().display().Size();
+    }
     default:
       MOZ_CRASH("GFX: SizeFromBufferDescriptor");
   }
 }
 
+gfx::IntRect RectFromBufferDescriptor(const BufferDescriptor& aDescriptor) {
+  switch (aDescriptor.type()) {
+    case BufferDescriptor::TRGBDescriptor: {
+      auto size = aDescriptor.get_RGBDescriptor().size();
+      return gfx::IntRect(0, 0, size.Width(), size.Height());
+    }
+    case BufferDescriptor::TYCbCrDescriptor:
+      return aDescriptor.get_YCbCrDescriptor().display();
+    default:
+      MOZ_CRASH("GFX: RectFromBufferDescriptor");
+  }
+}
+
 Maybe<gfx::IntSize> CbCrSizeFromBufferDescriptor(
     const BufferDescriptor& aDescriptor) {
   switch (aDescriptor.type()) {
@@ -245,13 +259,13 @@
 already_AddRefed<DataSourceSurface> DataSourceSurfaceFromYCbCrDescriptor(
     uint8_t* aBuffer, const YCbCrDescriptor& aDescriptor,
     gfx::DataSourceSurface* aSurface) {
-  gfx::IntSize ySize = aDescriptor.ySize();
-
+  const gfx::IntRect display = aDescriptor.display();
+  const gfx::IntSize size = display.Size();
   RefPtr<DataSourceSurface> result;
   if (aSurface) {
-    MOZ_ASSERT(aSurface->GetSize() == ySize);
+    MOZ_ASSERT(aSurface->GetSize() == size);
     MOZ_ASSERT(aSurface->GetFormat() == gfx::SurfaceFormat::B8G8R8X8);
-    if (aSurface->GetSize() == ySize &&
+    if (aSurface->GetSize() == size &&
         aSurface->GetFormat() == gfx::SurfaceFormat::B8G8R8X8) {
       result = aSurface;
     }
@@ -259,7 +273,7 @@
 
   if (!result) {
     result =
-        Factory::CreateDataSourceSurface(ySize, gfx::SurfaceFormat::B8G8R8X8);
+        Factory::CreateDataSourceSurface(size, gfx::SurfaceFormat::B8G8R8X8);
   }
   if (NS_WARN_IF(!result)) {
     return nullptr;
@@ -273,16 +287,18 @@
   layers::PlanarYCbCrData ycbcrData;
   ycbcrData.mYChannel = GetYChannel(aBuffer, aDescriptor);
   ycbcrData.mYStride = aDescriptor.yStride();
-  ycbcrData.mYSize = ySize;
+  ycbcrData.mYSize = aDescriptor.ySize();
   ycbcrData.mCbChannel = GetCbChannel(aBuffer, aDescriptor);
   ycbcrData.mCrChannel = GetCrChannel(aBuffer, aDescriptor);
   ycbcrData.mCbCrStride = aDescriptor.cbCrStride();
   ycbcrData.mCbCrSize = aDescriptor.cbCrSize();
-  ycbcrData.mPicSize = ySize;
+  ycbcrData.mPicSize = size;
+  ycbcrData.mPicX = display.X();
+  ycbcrData.mPicY = display.Y();
   ycbcrData.mYUVColorSpace = aDescriptor.yUVColorSpace();
   ycbcrData.mColorDepth = aDescriptor.colorDepth();
 
-  gfx::ConvertYCbCrToRGB(ycbcrData, gfx::SurfaceFormat::B8G8R8X8, ySize,
+  gfx::ConvertYCbCrToRGB(ycbcrData, gfx::SurfaceFormat::B8G8R8X8, size,
                          map.mData, map.mStride);
 
   result->Unmap();
@@ -297,16 +313,19 @@
                                         int32_t aStride) {
   MOZ_ASSERT(aBuffer);
 
+  const gfx::IntRect display = aDescriptor.display();
+
   layers::PlanarYCbCrData ycbcrData;
   ycbcrData.mYChannel = GetYChannel(aBuffer, aDescriptor);
   ycbcrData.mYStride = aDescriptor.yStride();
-  ;
   ycbcrData.mYSize = aDescriptor.ySize();
   ycbcrData.mCbChannel = GetCbChannel(aBuffer, aDescriptor);
   ycbcrData.mCrChannel = GetCrChannel(aBuffer, aDescriptor);
   ycbcrData.mCbCrStride = aDescriptor.cbCrStride();
   ycbcrData.mCbCrSize = aDescriptor.cbCrSize();
-  ycbcrData.mPicSize = aDescriptor.ySize();
+  ycbcrData.mPicSize = display.Size();
+  ycbcrData.mPicX = display.X();
+  ycbcrData.mPicY = display.Y();
   ycbcrData.mYUVColorSpace = aDescriptor.yUVColorSpace();
   ycbcrData.mColorDepth = aDescriptor.colorDepth();
 