# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasession/MediaSession.cpp
# Commit: 3e345c20dc2e
# Full Hash: 3e345c20dc2e78637775ce241c3dd521f036f191
# Author: alwu <alwu@mozilla.com>
# Date: 2020-09-24 09:34:15
# Regressor Bug: 1665527
# File Overlap Count: 1
# Description:
#   Bug 1665527 - part2 : notify media session status based on its document's activity state. r=chunmin
#   
#   Because of D90771, we need media session to notifty its status correctly in order to deactivate the controller. Therefore, when its document becomes inactive (in bfcahce), we should treat media session as inactive and notify it to `MediaStatusManager` in order to clear the active media session if needed.
#   
#   In addition, add some assertions to ensure we won't modify or set any attributes on media session when its document is inactive.
# ==============================================================================

diff -r 5a035588b98d -r 3e345c20dc2e dom/media/mediasession/MediaSession.cpp
--- a/dom/media/mediasession/MediaSession.cpp	Wed Sep 23 12:12:08 2020 +0000
+++ b/dom/media/mediasession/MediaSession.cpp	Wed Sep 23 19:43:46 2020 +0000
@@ -20,19 +20,65 @@
 namespace mozilla {
 namespace dom {
 
-// Only needed for refcounted objects.
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(MediaSession, mParent, mMediaMetadata,
-                                      mActionHandlers)
+// We don't use NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE because we need to
+// unregister MediaSession from document's activity listeners.
+NS_IMPL_CYCLE_COLLECTION_CLASS(MediaSession)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(MediaSession)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mParent)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mMediaMetadata)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mActionHandlers)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDoc)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(MediaSession)
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(MediaSession)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mParent)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mMediaMetadata)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mActionHandlers)
+  if (tmp->mDoc) {
+    tmp->mDoc->UnregisterActivityObserver(tmp);
+  }
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDoc)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTING_ADDREF(MediaSession)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(MediaSession)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(MediaSession)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsIDocumentActivity)
 NS_INTERFACE_MAP_END
 
-MediaSession::MediaSession(nsPIDOMWindowInner* aParent) : mParent(aParent) {
+MediaSession::MediaSession(nsPIDOMWindowInner* aParent)
+    : mParent(aParent), mDoc(mParent->GetExtantDoc()) {
   MOZ_ASSERT(mParent);
-  NotifyMediaSessionStatus(SessionStatus::eCreated);
+  MOZ_ASSERT(mDoc);
+  mDoc->RegisterActivityObserver(this);
+  if (mDoc->IsCurrentActiveDocument()) {
+    SetMediaSessionDocStatus(SessionDocStatus::eActive);
+  }
+}
+
+void MediaSession::Shutdown() {
+  mDoc->UnregisterActivityObserver(this);
+  SetMediaSessionDocStatus(SessionDocStatus::eInactive);
+}
+
+void MediaSession::NotifyOwnerDocumentActivityChanged() {
+  const bool isDocActive = mDoc->IsCurrentActiveDocument();
+  LOG("Document activity changed, isActive=%d", isDocActive);
+  if (isDocActive) {
+    SetMediaSessionDocStatus(SessionDocStatus::eActive);
+  } else {
+    SetMediaSessionDocStatus(SessionDocStatus::eInactive);
+  }
+}
+
+void MediaSession::SetMediaSessionDocStatus(SessionDocStatus aState) {
+  if (mSessionDocState == aState) {
+    return;
+  }
+  mSessionDocState = aState;
+  NotifyMediaSessionDocStatus(mSessionDocState);
 }
 
 nsPIDOMWindowInner* MediaSession::GetParentObject() const { return mParent; }
@@ -45,12 +91,14 @@
 MediaMetadata* MediaSession::GetMetadata() const { return mMediaMetadata; }
 
 void MediaSession::SetMetadata(MediaMetadata* aMetadata) {
+  MOZ_ASSERT(mSessionDocState == SessionDocStatus::eActive);
   mMediaMetadata = aMetadata;
   NotifyMetadataUpdated();
 }
 
 void MediaSession::SetPlaybackState(
     const MediaSessionPlaybackState& aPlaybackState) {
+  MOZ_ASSERT(mSessionDocState == SessionDocStatus::eActive);
   if (mDeclaredPlaybackState == aPlaybackState) {
     return;
   }
@@ -70,6 +118,7 @@
 
 void MediaSession::SetActionHandler(MediaSessionAction aAction,
                                     MediaSessionActionHandler* aHandler) {
+  MOZ_ASSERT(mSessionDocState == SessionDocStatus::eActive);
   MOZ_ASSERT(size_t(aAction) < ArrayLength(mActionHandlers));
   // If the media session changes its supported action, then we would propagate
   // this information to the chrome process in order to run the media session
@@ -92,6 +141,7 @@
 
 void MediaSession::SetPositionState(const MediaPositionState& aState,
                                     ErrorResult& aRv) {
+  MOZ_ASSERT(mSessionDocState == SessionDocStatus::eActive);
   // https://w3c.github.io/mediasession/#dom-mediasession-setpositionstate
   // If the state is an empty dictionary then clear the position state.
   if (!aState.IsAnyMemberPresent()) {
@@ -190,11 +240,7 @@
   return *activeSessionContextId == currentBC->Id();
 }
 
-void MediaSession::Shutdown() {
-  NotifyMediaSessionStatus(SessionStatus::eDestroyed);
-}
-
-void MediaSession::NotifyMediaSessionStatus(SessionStatus aState) {
+void MediaSession::NotifyMediaSessionDocStatus(SessionDocStatus aState) {
   RefPtr<BrowsingContext> currentBC = GetParentObject()->GetBrowsingContext();
   MOZ_ASSERT(currentBC, "Update session status after context destroyed!");
 
@@ -202,7 +248,7 @@
   if (!updater) {
     return;
   }
-  if (aState == SessionStatus::eCreated) {
+  if (aState == SessionDocStatus::eActive) {
     updater->NotifySessionCreated(currentBC->Id());
   } else {
     updater->NotifySessionDestroyed(currentBC->Id());