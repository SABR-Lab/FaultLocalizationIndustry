# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsWindow.cpp
# Commit: 70c8e33b5710
# Full Hash: 70c8e33b57103e6814f23f0379c4ab7cd38bfa77
# Author: Daniel <wekerbugs@protonmail.com>
# Date: 2020-06-13 21:41:37
# Regressor Bug: 1628749
# File Overlap Count: 1
# Description:
#   Bug 1628749 - Disable workspaceID fetching and moving of window on i3 and BSPWM Window Managers. r=stransky
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D78129
# ==============================================================================

diff -r 94b71d010701 -r 70c8e33b5710 widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	Sat Jun 13 13:17:29 2020 +0000
+++ b/widget/gtk/nsWindow.cpp	Sat Jun 13 12:38:02 2020 +0000
@@ -1798,10 +1798,77 @@
   mSizeState = mSizeMode;
 }
 
+static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
+  if (!gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+    return false;
+  }
+
+  Display* xdisplay = gdk_x11_get_default_xdisplay();
+  GdkScreen* screen = gdk_window_get_screen(gdk_window);
+  Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
+
+  int actual_format_return;
+  Atom actual_type_return;
+  unsigned long nitems_return;
+  unsigned long bytes_after_return;
+  unsigned char* prop_return = nullptr;
+  auto releaseXProperty = MakeScopeExit([&] {
+    if (prop_return) {
+      XFree(prop_return);
+    }
+  });
+
+  Atom property = XInternAtom(xdisplay, "_NET_SUPPORTING_WM_CHECK", true);
+  Atom req_type = XInternAtom(xdisplay, "WINDOW", true);
+  int result =
+      XGetWindowProperty(xdisplay, root_win, property,
+                         0L,                  // offset
+                         sizeof(Window) / 4,  // length
+                         false,               // delete
+                         req_type, &actual_type_return, &actual_format_return,
+                         &nitems_return, &bytes_after_return, &prop_return);
+
+  if (result != Success || bytes_after_return != 0 || nitems_return != 1) {
+    return false;
+  }
+
+  Window wmWindow = reinterpret_cast<Window*>(prop_return)[0];
+  XFree(prop_return);
+  prop_return = nullptr;
+
+  property = XInternAtom(xdisplay, "_NET_WM_NAME", true);
+  req_type = XInternAtom(xdisplay, "UTF8_STRING", true);
+  result =
+      XGetWindowProperty(xdisplay, wmWindow, property,
+                         0L,         // offset
+                         INT32_MAX,  // length
+                         false,      // delete
+                         req_type, &actual_type_return, &actual_format_return,
+                         &nitems_return, &bytes_after_return, &prop_return);
+
+  if (result != Success || bytes_after_return != 0) {
+    return false;
+  }
+
+  wmName = reinterpret_cast<const char*>(prop_return);
+  return true;
+}
+
 #define kDesktopMutterSchema "org.gnome.mutter"
 #define kDesktopDynamicWorkspacesKey "dynamic-workspaces"
 
-static bool DesktopUsesDynamicWorkspaces() {
+static bool DesktopUsesDynamicWorkspaces(GdkWindow* gdk_window) {
+  nsAutoCString wmName;
+  if (GetWindowManagerName(gdk_window, wmName)) {
+    if (wmName.EqualsLiteral("bspwm")) {
+      return true;
+    }
+
+    if (wmName.EqualsLiteral("i3")) {
+      return true;
+    }
+  }
+
   static const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
   if (!currentDesktop || !strstr(currentDesktop, "GNOME")) {
     return false;
@@ -1822,6 +1889,7 @@
       }
     }
   }
+
   return false;
 }
 
@@ -1837,7 +1905,7 @@
     return;
   }
 
-  if (DesktopUsesDynamicWorkspaces()) {
+  if (DesktopUsesDynamicWorkspaces(gdk_window)) {
     return;
   }
 
