# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/Http3Stream.cpp
# Commit: 058e2449bbac
# Full Hash: 058e2449bbac40dcaa8cf1ade7464abd3b5217b0
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2020-11-05 21:37:48
# Regressor Bug: 1674922
# File Overlap Count: 1
# Description:
#   Bug 1674922 - Cleanup ReadSegments: r=necko-reviewers,kershaw
#   
#   - Move looping while calling mTransaction->ReadSegments into Http3Stream and call mTransaction->ReadSegmentsAgain. We use to loop in Http3Session which was not easy because it is not easy to find out when to leave the loop. The original code was working, but this is a better way to do this.
#   - Remove mReadyForWriteButBlocked it is not necessary, it was used only as a double check and can only be a source of bugs.
#   - Remove mContentBytesWritten, because it is not used.
# ==============================================================================

diff -r d9b078999ebc -r 058e2449bbac netwerk/protocol/http/Http3Stream.cpp
--- a/netwerk/protocol/http/Http3Stream.cpp	Thu Nov 05 11:04:20 2020 +0000
+++ b/netwerk/protocol/http/Http3Stream.cpp	Thu Nov 05 11:37:39 2020 +0000
@@ -25,7 +25,6 @@
       mSession(session),
       mTransaction(httpTransaction),
       mQueued(false),
-      mRequestBlockedOnRead(false),
       mDataReceived(false),
       mResetRecv(false),
       mRequestBodyLenRemaining(0),
@@ -231,10 +230,9 @@
       break;
   }
 
-  if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
-    mRequestBlockedOnRead = true;
-  }
-  return rv;
+  mSocketOutCondition = rv;
+
+  return mSocketOutCondition;
 }
 
 void Http3Stream::SetResponseHeaders(nsTArray<uint8_t>& aResponseHeaders,
@@ -326,12 +324,9 @@
   return rv;
 }
 
-nsresult Http3Stream::ReadSegments(nsAHttpSegmentReader* reader, uint32_t count,
-                                   uint32_t* countRead) {
+nsresult Http3Stream::ReadSegments(nsAHttpSegmentReader* reader) {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
 
-  mRequestBlockedOnRead = false;
-
   if (mRecvState == RECV_DONE) {
     // Don't transmit any request frames if the peer cannot respond or respone
     // is already done.
@@ -343,46 +338,69 @@
   }
 
   nsresult rv = NS_OK;
-  switch (mSendState) {
-    case WAITING_TO_ACTIVATE: {
-      *countRead = 0;
-      // A transaction that had already generated its headers before it was
-      // queued at the session level (due to concurrency concerns) may not call
-      // onReadSegment off the ReadSegments() stack above.
-      LOG3(("Http3Stream %p ReadSegments forcing OnReadSegment call\n", this));
-      uint32_t wasted = 0;
-      nsresult rv2 = OnReadSegment("", 0, &wasted);
-      LOG3(("  OnReadSegment returned 0x%08" PRIx32,
-            static_cast<uint32_t>(rv2)));
-      if (mSendState != SENDING_BODY) {
+  uint32_t transactionBytes;
+  bool again = true;
+  do {
+    transactionBytes = 0;
+    rv = mSocketOutCondition = NS_OK;
+    LOG(("Http3Stream::ReadSegments state=%d [this=%p]", mSendState, this));
+    switch (mSendState) {
+      case WAITING_TO_ACTIVATE: {
+        // A transaction that had already generated its headers before it was
+        // queued at the session level (due to concurrency concerns) may not
+        // call onReadSegment off the ReadSegments() stack above.
+        LOG3(
+            ("Http3Stream %p ReadSegments forcing OnReadSegment call\n", this));
+        uint32_t wasted = 0;
+        nsresult rv2 = OnReadSegment("", 0, &wasted);
+        LOG3(("  OnReadSegment returned 0x%08" PRIx32,
+              static_cast<uint32_t>(rv2)));
+        if (mSendState != SENDING_BODY) {
+          break;
+        }
+      }
+        // If we are in state SENDING_BODY we can continue sending data.
+        [[fallthrough]];
+      case PREPARING_HEADERS:
+      case SENDING_BODY: {
+        rv = mTransaction->ReadSegmentsAgain(
+            this, nsIOService::gDefaultSegmentSize, &transactionBytes, &again);
+      } break;
+      default:
+        transactionBytes = 0;
+        rv = NS_OK;
         break;
-      }
     }
-      // If we are in state SENDING_BODY we can continue sending data.
-      [[fallthrough]];
-    case PREPARING_HEADERS:
-    case SENDING_BODY: {
-      rv = mTransaction->ReadSegments(this, count, countRead);
-      LOG(("Http3Stream::ReadSegments rv=0x%" PRIx32 " [this=%p]",
-           static_cast<uint32_t>(rv), this));
+
+    LOG(("Http3Stream::ReadSegments rv=0x%" PRIx32 " read=%u sock-cond=%" PRIx32
+         " again=%d [this=%p]",
+         static_cast<uint32_t>(rv), transactionBytes,
+         static_cast<uint32_t>(mSocketOutCondition), again, this));
 
+    // XXX some streams return NS_BASE_STREAM_CLOSED to indicate EOF.
+    if (rv == NS_BASE_STREAM_CLOSED && !mTransaction->IsDone()) {
+      rv = NS_OK;
+      transactionBytes = 0;
+    }
+
+    if (NS_FAILED(rv)) {
+      // if the transaction didn't want to write any more data, then
+      // wait for the transaction to call ResumeSend.
       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
-        mRequestBlockedOnRead = true;
+        rv = NS_OK;
       }
-      if (NS_SUCCEEDED(rv) && mRequestBlockedOnRead) {
-        // We've got NS_BASE_STREAM_WOULD_BLOCK in Http3Stream::OnReadSegment()
-        // but the error code was lost in nsBufferedInputStream::ReadSegments().
-        // Restore it here.
-        rv = NS_BASE_STREAM_WOULD_BLOCK;
+      again = false;
+    } else if (NS_FAILED(mSocketOutCondition)) {
+      if (mSocketOutCondition != NS_BASE_STREAM_WOULD_BLOCK) {
+        rv = mSocketOutCondition;
       }
-    } break;
-    default:
-      *countRead = 0;
+      again = false;
+    } else if (!transactionBytes) {
       rv = NS_OK;
-      break;
-  }
-  LOG(("Http3Stream::ReadSegments rv=0x%" PRIx32 " [this=%p]",
-       static_cast<uint32_t>(rv), this));
+      again = false;
+    }
+    // write more to the socket until error or end-of-request...
+  } while (again && gHttpHandler->Active());
   return rv;
 }
 
@@ -451,7 +469,6 @@
     mRecvState = BEFORE_HEADERS;
     mStreamId = UINT64_MAX;
     mQueued = false;
-    mRequestBlockedOnRead = false;
     mDataReceived = false;
     mResetRecv = false;
     mRequestBodyLenRemaining = 0;