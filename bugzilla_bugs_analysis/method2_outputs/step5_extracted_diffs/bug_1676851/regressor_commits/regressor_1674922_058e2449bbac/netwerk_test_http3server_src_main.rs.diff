# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/test/http3server/src/main.rs
# Commit: 058e2449bbac
# Full Hash: 058e2449bbac40dcaa8cf1ade7464abd3b5217b0
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2020-11-05 21:37:48
# Regressor Bug: 1674922
# File Overlap Count: 1
# Description:
#   Bug 1674922 - Cleanup ReadSegments: r=necko-reviewers,kershaw
#   
#   - Move looping while calling mTransaction->ReadSegments into Http3Stream and call mTransaction->ReadSegmentsAgain. We use to loop in Http3Session which was not easy because it is not easy to find out when to leave the loop. The original code was working, but this is a better way to do this.
#   - Remove mReadyForWriteButBlocked it is not necessary, it was used only as a double check and can only be a source of bugs.
#   - Remove mContentBytesWritten, because it is not used.
# ==============================================================================

diff -r d9b078999ebc -r 058e2449bbac netwerk/test/http3server/src/main.rs
--- a/netwerk/test/http3server/src/main.rs	Thu Nov 05 11:04:20 2020 +0000
+++ b/netwerk/test/http3server/src/main.rs	Thu Nov 05 11:37:39 2020 +0000
@@ -47,13 +47,35 @@
     fn process_events(&mut self);
 }
 
-impl HttpServer for Http3Server {
+struct Http3TestServer {
+    server: Http3Server,
+    // This a map from a post request to amount of data ithas been received on the request.
+    // The respons will carry the amount of data received.
+    posts: HashMap<String, usize>,
+}
+
+impl ::std::fmt::Display for Http3TestServer {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
+        write!(f, "{}", self.server)
+    }
+}
+
+impl Http3TestServer {
+    pub fn new(server: Http3Server) -> Self {
+        Self {
+            server,
+            posts: HashMap::new(),
+        }
+    }
+}
+
+impl HttpServer for Http3TestServer {
     fn process(&mut self, dgram: Option<Datagram>) -> Output {
-        self.process(dgram, Instant::now())
+        self.server.process(dgram, Instant::now())
     }
 
     fn process_events(&mut self) {
-        while let Some(event) = self.next_event() {
+        while let Some(event) = self.server.next_event() {
             qtrace!("Event: {:?}", event);
             match event {
                 Http3ServerEvent::Headers {
@@ -185,6 +207,9 @@
                                         &vec![b'a'; 8000],
                                     )
                                     .unwrap();
+                            } else if path == "/post" {
+                                // Read all data before responding.
+                                self.posts.insert(format!("{}", request), 0);
                             } else {
                                 match path.trim_matches(|p| p == '/').parse::<usize>() {
                                     Ok(v) => request
@@ -213,6 +238,37 @@
                         }
                     }
                 }
+                Http3ServerEvent::Data {
+                    mut request,
+                    data,
+                    fin,
+                } => {
+                    if let Some(r) = self.posts.get_mut(&format!("{}", request)) {
+                        *r += data.len();
+                    }
+                    if fin {
+                        if let Some(r) = self.posts.remove(&format!("{}", request)) {
+                          let default_ret = b"Hello World".to_vec();
+                          request
+                              .set_response(
+                                  &[
+                                       (String::from(":status"), String::from("200")),
+                                       (
+                                           String::from("Cache-Control"),
+                                           String::from("no-cache"),
+                                       ),
+                                       (String::from("x-data-received-length"), r.to_string()),
+                                       (
+                                           String::from("content-length"),
+                                           default_ret.len().to_string(),
+                                       ),
+                                   ],
+                                   &default_ret,
+                              )
+                              .unwrap();
+                        }
+                    }
+                }
                 _ => {}
             }
         }
@@ -391,19 +447,20 @@
 
         if http3 {
             Box::new(
-                Http3Server::new(
-                    Instant::now(),
-                    &[" HTTP2 Test Cert"],
-                    PROTOCOLS,
-                    anti_replay,
-                    cid_mgr,
-                    QpackSettings {
-                        max_table_size_encoder: MAX_TABLE_SIZE,
-                        max_table_size_decoder: MAX_TABLE_SIZE,
-                        max_blocked_streams: MAX_BLOCKED_STREAMS,
-                    },
+                Http3TestServer::new(
+                    Http3Server::new(
+                        Instant::now(),
+                        &[" HTTP2 Test Cert"],
+                        PROTOCOLS,
+                        anti_replay,
+                        cid_mgr,
+                        QpackSettings {
+                            max_table_size_encoder: MAX_TABLE_SIZE,
+                            max_table_size_decoder: MAX_TABLE_SIZE,
+                            max_blocked_streams: MAX_BLOCKED_STREAMS,
+                        },
+                    ).expect("We cannot make a server!")
                 )
-                .expect("We cannot make a server!"),
             )
         } else {
             Box::new(