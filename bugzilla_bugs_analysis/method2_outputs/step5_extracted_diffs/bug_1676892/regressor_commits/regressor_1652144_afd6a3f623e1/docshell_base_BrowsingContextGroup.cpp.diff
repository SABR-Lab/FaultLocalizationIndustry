# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/BrowsingContextGroup.cpp
# Commit: afd6a3f623e1
# Full Hash: afd6a3f623e1b0d9de616c1dfa6f2806e4a587af
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-07-31 04:11:13
# Regressor Bug: 1652144
# File Overlap Count: 1
# Description:
#   Bug 1652144 - Part 2: Consider current BrowsingContextGroup for process selection, r=farre
#   
#   This requires keeping track of the current process used to host documents with a
#   particular remote type loaded in each BrowsingContextGroup. Due to lifecycle
#   oddities, this set is kept separate from the existing subscribers set on
# ==============================================================================

diff -r 3d58dcc5e59f -r afd6a3f623e1 docshell/base/BrowsingContextGroup.cpp
--- a/docshell/base/BrowsingContextGroup.cpp	Thu Jul 30 20:27:34 2020 +0000
+++ b/docshell/base/BrowsingContextGroup.cpp	Thu Jul 30 20:27:37 2020 +0000
@@ -72,29 +72,36 @@
   }
 }
 
-void BrowsingContextGroup::Subscribe(ContentParent* aOriginProcess) {
-  MOZ_DIAGNOSTIC_ASSERT(aOriginProcess);
-  mSubscribers.PutEntry(aOriginProcess);
-  aOriginProcess->OnBrowsingContextGroupSubscribe(this);
+void BrowsingContextGroup::EnsureHostProcess(ContentParent* aProcess) {
+  MOZ_DIAGNOSTIC_ASSERT(this != sChromeGroup,
+                        "cannot have content host for chrome group");
+  MOZ_DIAGNOSTIC_ASSERT(aProcess->GetRemoteType() != PREALLOC_REMOTE_TYPE,
+                        "cannot use preallocated process as host");
+  MOZ_DIAGNOSTIC_ASSERT(!aProcess->GetRemoteType().IsEmpty(),
+                        "host process must have remote type");
+
+  if (!aProcess->IsDead()) {
+    auto entry = mHosts.LookupForAdd(aProcess->GetRemoteType());
+    if (entry) {
+      MOZ_DIAGNOSTIC_ASSERT(
+          entry.Data() == aProcess,
+          "There's already another host process for this remote type");
+      return;
+    }
+
+    // This process wasn't already marked as our host, so insert it, and begin
+    // subscribing, unless the process is still launching.
+    entry.OrInsert([&] { return do_AddRef(aProcess); });
+  }
+
+  aProcess->AddBrowsingContextGroup(this);
 }
 
-void BrowsingContextGroup::Unsubscribe(ContentParent* aOriginProcess) {
-  MOZ_DIAGNOSTIC_ASSERT(aOriginProcess);
-  mSubscribers.RemoveEntry(aOriginProcess);
-  aOriginProcess->OnBrowsingContextGroupUnsubscribe(this);
-
-  // If this origin process embeds any non-discarded windowless
-  // BrowsingContexts, make sure to discard them, as this process is going away.
-  // Nested subframes will be discarded by WindowGlobalParent when it is
-  // destroyed by IPC.
-  nsTArray<RefPtr<BrowsingContext>> toDiscard;
-  for (auto& context : mToplevels) {
-    if (context->Canonical()->IsEmbeddedInProcess(aOriginProcess->ChildID())) {
-      toDiscard.AppendElement(context);
-    }
-  }
-  for (auto& context : toDiscard) {
-    context->Detach(/* aFromIPC */ true);
+void BrowsingContextGroup::RemoveHostProcess(ContentParent* aProcess) {
+  MOZ_DIAGNOSTIC_ASSERT(aProcess);
+  auto entry = mHosts.Lookup(aProcess->GetRemoteType());
+  if (entry && entry.Data() == aProcess) {
+    entry.Remove();
   }
 }
 
@@ -113,13 +120,19 @@
   }
 }
 
-void BrowsingContextGroup::EnsureSubscribed(ContentParent* aProcess) {
-  MOZ_DIAGNOSTIC_ASSERT(aProcess);
-  if (mSubscribers.Contains(aProcess)) {
+void BrowsingContextGroup::Subscribe(ContentParent* aProcess) {
+  MOZ_DIAGNOSTIC_ASSERT(aProcess && !aProcess->IsLaunching());
+
+  // Check if we're already subscribed to this process.
+  if (!mSubscribers.EnsureInserted(aProcess)) {
     return;
   }
 
-  Subscribe(aProcess);
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+  auto hostEntry = mHosts.Lookup(aProcess->GetRemoteType());
+  MOZ_DIAGNOSTIC_ASSERT(hostEntry && hostEntry.Data() == aProcess,
+                        "Cannot subscribe a non-host process");
+#endif
 
   // FIXME: This won't send non-discarded children of discarded BCs, but those
   // BCs will be in the process of being destroyed anyway.
@@ -148,6 +161,37 @@
   }
 }
 
+void BrowsingContextGroup::Unsubscribe(ContentParent* aProcess) {
+  MOZ_DIAGNOSTIC_ASSERT(aProcess);
+  mSubscribers.RemoveEntry(aProcess);
+  aProcess->RemoveBrowsingContextGroup(this);
+
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+  auto hostEntry = mHosts.Lookup(aProcess->GetRemoteType());
+  MOZ_DIAGNOSTIC_ASSERT(!hostEntry || hostEntry.Data() != aProcess,
+                        "Unsubscribing existing host entry");
+#endif
+
+  // If this origin process embeds any non-discarded windowless
+  // BrowsingContexts, make sure to discard them, as this process is going away.
+  // Nested subframes will be discarded by WindowGlobalParent when it is
+  // destroyed by IPC.
+  nsTArray<RefPtr<BrowsingContext>> toDiscard;
+  for (auto& context : mToplevels) {
+    if (context->Canonical()->IsEmbeddedInProcess(aProcess->ChildID())) {
+      toDiscard.AppendElement(context);
+    }
+  }
+  for (auto& context : toDiscard) {
+    context->Detach(/* aFromIPC */ true);
+  }
+}
+
+ContentParent* BrowsingContextGroup::GetHostProcess(
+    const nsACString& aRemoteType) {
+  return mHosts.GetWeak(aRemoteType);
+}
+
 void BrowsingContextGroup::SetToplevelsSuspended(bool aSuspended) {
   for (const auto& context : mToplevels) {
     nsPIDOMWindowOuter* outer = context->GetDOMWindow();
@@ -173,15 +217,15 @@
 }
 
 void BrowsingContextGroup::UnsubscribeAllContentParents() {
+  mHosts.Clear();
+  for (auto& entry : mSubscribers) {
+    entry.GetKey()->RemoveBrowsingContextGroup(this);
+  }
+  mSubscribers.Clear();
+
   if (sBrowsingContextGroups) {
     sBrowsingContextGroups->Remove(Id());
   }
-
-  for (auto iter = mSubscribers.Iter(); !iter.Done(); iter.Next()) {
-    nsRefPtrHashKey<ContentParent>* entry = iter.Get();
-    entry->GetKey()->OnBrowsingContextGroupUnsubscribe(this);
-  }
-  mSubscribers.Clear();
 }
 
 nsISupports* BrowsingContextGroup::GetParentObject() const {
@@ -303,7 +347,7 @@
 }
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(BrowsingContextGroup, mContexts,
-                                      mToplevels, mSubscribers,
+                                      mToplevels, mHosts, mSubscribers,
                                       mTimerEventQueue, mWorkerEventQueue)
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(BrowsingContextGroup, AddRef)