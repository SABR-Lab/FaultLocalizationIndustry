# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/BrowsingContextGroup.h
# Commit: afd6a3f623e1
# Full Hash: afd6a3f623e1b0d9de616c1dfa6f2806e4a587af
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-07-31 04:11:13
# Regressor Bug: 1652144
# File Overlap Count: 1
# Description:
#   Bug 1652144 - Part 2: Consider current BrowsingContextGroup for process selection, r=farre
#   
#   This requires keeping track of the current process used to host documents with a
#   particular remote type loaded in each BrowsingContextGroup. Due to lifecycle
#   oddities, this set is kept separate from the existing subscribers set on
# ==============================================================================

diff -r 3d58dcc5e59f -r afd6a3f623e1 docshell/base/BrowsingContextGroup.h
--- a/docshell/base/BrowsingContextGroup.h	Thu Jul 30 20:27:34 2020 +0000
+++ b/docshell/base/BrowsingContextGroup.h	Thu Jul 30 20:27:37 2020 +0000
@@ -8,6 +8,7 @@
 #define mozilla_dom_BrowsingContextGroup_h
 
 #include "mozilla/dom/BrowsingContext.h"
+#include "mozilla/FunctionRef.h"
 #include "nsRefPtrHashtable.h"
 #include "nsHashKeys.h"
 #include "nsTArray.h"
@@ -35,19 +36,39 @@
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(BrowsingContextGroup)
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS(BrowsingContextGroup)
 
-  typedef nsTHashtable<nsRefPtrHashKey<ContentParent>> ContentParents;
-
   // Interact with the list of synced contexts. This controls the lifecycle of
   // the BrowsingContextGroup and contexts loaded within them.
   void Register(nsISupports* aContext);
   void Unregister(nsISupports* aContext);
 
-  // Interact with the list of ContentParents
-  void Subscribe(ContentParent* aOriginProcess);
-  void Unsubscribe(ContentParent* aOriginProcess);
+  // Control which processes will be used to host documents loaded in this
+  // BrowsingContextGroup. There should only ever be one host process per remote
+  // type.
+  //
+  // A new host process will be subscribed to the BrowsingContextGroup unless it
+  // is still launching, in which case it will subscribe itself when it is done
+  // launching.
+  void EnsureHostProcess(ContentParent* aProcess);
+
+  // A removed host process will no longer be used to host documents loaded in
+  // this BrowsingContextGroup.
+  void RemoveHostProcess(ContentParent* aProcess);
 
-  // Force the given ContentParent to subscribe to our BrowsingContextGroup.
-  void EnsureSubscribed(ContentParent* aProcess);
+  // Synchronize the current BrowsingContextGroup state down to the given
+  // content process, and continue updating it.
+  //
+  // You rarely need to call this directy, as it's automatically called by
+  // |EnsureHostProcess| as needed.
+  void Subscribe(ContentParent* aProcess);
+
+  // Stop synchromizing the current BrowsingContextGroup state down to a given
+  // content process. The content process must no longer be a host process.
+  void Unsubscribe(ContentParent* aProcess);
+
+  // Look up the process which should be used to host documents with this
+  // RemoteType. This will be a non-dead process associated with this
+  // BrowsingContextGroup, if possible.
+  ContentParent* GetHostProcess(const nsACString& aRemoteType);
 
   bool GetToplevelsSuspended() { return mToplevelsSuspended; }
   void SetToplevelsSuspended(bool aSuspended);
@@ -152,7 +173,15 @@
   // removed from here.
   nsRefPtrHashtable<nsCStringHashKey, DocGroup> mDocGroups;
 
-  ContentParents mSubscribers;
+  // The content process which will host documents in this BrowsingContextGroup
+  // which need to be loaded with a given remote type.
+  //
+  // A non-launching host process must also be a subscriber, though a launching
+  // host process may not yet be subscribed, and a subscriber need not be a host
+  // process.
+  nsRefPtrHashtable<nsCStringHashKey, ContentParent> mHosts;
+
+  nsTHashtable<nsRefPtrHashKey<ContentParent>> mSubscribers;
 
   // A queue to store postMessage events during page load, the queue will be
   // flushed once the page is loaded