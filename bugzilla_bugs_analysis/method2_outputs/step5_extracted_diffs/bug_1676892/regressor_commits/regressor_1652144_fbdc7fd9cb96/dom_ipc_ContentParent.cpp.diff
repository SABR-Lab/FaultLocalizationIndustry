# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/ContentParent.cpp
# Commit: fbdc7fd9cb96
# Full Hash: fbdc7fd9cb96f26850f979b6f23b13f7bbaf727c
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2020-07-25 09:40:10
# Regressor Bug: 1652144
# File Overlap Count: 1
# Description:
#   Bug 1652144 - Part 2: Consider current BrowsingContextGroup for process selection, r=farre
#   
#   This requires keeping track of the current process used to host documents with a
#   particular remote type loaded in each BrowsingContextGroup. Due to lifecycle
#   oddities, this set is kept separate from the existing subscribers set on
# ==============================================================================

diff -r 920a06a52b8b -r fbdc7fd9cb96 dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp	Fri Jul 24 20:24:33 2020 +0000
+++ b/dom/ipc/ContentParent.cpp	Fri Jul 24 20:24:36 2020 +0000
@@ -979,11 +979,27 @@
 /*static*/
 already_AddRefed<ContentParent>
 ContentParent::GetNewOrUsedLaunchingBrowserProcess(
-    const nsACString& aRemoteType, ProcessPriority aPriority,
-    bool aPreferUsed) {
+    const nsACString& aRemoteType, BrowsingContextGroup* aGroup,
+    ProcessPriority aPriority, bool aPreferUsed) {
   MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
           ("GetNewOrUsedProcess for type %s",
            PromiseFlatCString(aRemoteType).get()));
+
+  // If we have an existing host process attached to this BrowsingContextGroup,
+  // always return it, as we can never have multiple host processes within a
+  // single BrowsingContextGroup.
+  RefPtr<ContentParent> contentParent;
+  if (aGroup) {
+    contentParent = aGroup->GetHostProcess(aRemoteType);
+    if (contentParent) {
+      MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
+              ("GetNewOrUsedProcess: Existing host process %p (launching %d)",
+               contentParent.get(), contentParent->IsLaunching()));
+      contentParent->AssertAlive();
+      return contentParent.forget();
+    }
+  }
+
   nsTArray<ContentParent*>& contentParents = GetOrCreatePool(aRemoteType);
   uint32_t maxContentParents = GetMaxProcessCount(aRemoteType);
   // We never want to re-use Large-Allocation processes.
@@ -991,13 +1007,14 @@
       contentParents.Length() >= maxContentParents) {
     MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
             ("GetNewOrUsedProcess: returning Large Used process"));
-    return GetNewOrUsedLaunchingBrowserProcess(DEFAULT_REMOTE_TYPE, aPriority,
+    return GetNewOrUsedLaunchingBrowserProcess(DEFAULT_REMOTE_TYPE, aGroup,
+                                               aPriority,
                                                /*aPreferUsed =*/false);
   }
 
   // Let's try and reuse an existing process.
-  RefPtr<ContentParent> contentParent = GetUsedBrowserProcess(
-      aRemoteType, contentParents, maxContentParents, aPreferUsed);
+  contentParent = GetUsedBrowserProcess(aRemoteType, contentParents,
+                                        maxContentParents, aPreferUsed);
 
   if (contentParent) {
     // We have located a process. It may not have finished initializing,
@@ -1006,6 +1023,9 @@
             ("GetNewOrUsedProcess: Used process %p (launching %d)",
              contentParent.get(), contentParent->IsLaunching()));
     contentParent->AssertAlive();
+    if (aGroup) {
+      aGroup->EnsureHostProcess(contentParent);
+    }
     return contentParent.forget();
   }
 
@@ -1034,17 +1054,21 @@
   MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
           ("GetNewOrUsedProcess: new process %p", contentParent.get()));
   contentParent->AssertAlive();
+  if (aGroup) {
+    aGroup->EnsureHostProcess(contentParent);
+  }
   return contentParent.forget();
 }
 
 /*static*/
 RefPtr<ContentParent::LaunchPromise>
 ContentParent::GetNewOrUsedBrowserProcessAsync(const nsACString& aRemoteType,
+                                               BrowsingContextGroup* aGroup,
                                                ProcessPriority aPriority,
                                                bool aPreferUsed) {
   // Obtain a `ContentParent` launched asynchronously.
-  RefPtr<ContentParent> contentParent =
-      GetNewOrUsedLaunchingBrowserProcess(aRemoteType, aPriority, aPreferUsed);
+  RefPtr<ContentParent> contentParent = GetNewOrUsedLaunchingBrowserProcess(
+      aRemoteType, aGroup, aPriority, aPreferUsed);
   if (!contentParent) {
     // In case of launch error, stop here.
     return LaunchPromise::CreateAndReject(LaunchError(), __func__);
@@ -1054,10 +1078,10 @@
 
 /*static*/
 already_AddRefed<ContentParent> ContentParent::GetNewOrUsedBrowserProcess(
-    const nsACString& aRemoteType, ProcessPriority aPriority,
-    bool aPreferUsed) {
-  RefPtr<ContentParent> contentParent =
-      GetNewOrUsedLaunchingBrowserProcess(aRemoteType, aPriority, aPreferUsed);
+    const nsACString& aRemoteType, BrowsingContextGroup* aGroup,
+    ProcessPriority aPriority, bool aPreferUsed) {
+  RefPtr<ContentParent> contentParent = GetNewOrUsedLaunchingBrowserProcess(
+      aRemoteType, aGroup, aPriority, aPreferUsed);
   if (!contentParent || !contentParent->WaitForLaunchSync(aPriority)) {
     // In case of launch error, stop here.
     return nullptr;
@@ -1324,7 +1348,8 @@
           aContext.JSPluginId(), PROCESS_PRIORITY_FOREGROUND);
     } else {
       constructorSender = GetNewOrUsedBrowserProcess(
-          remoteType, PROCESS_PRIORITY_FOREGROUND, isPreloadBrowser);
+          remoteType, aBrowsingContext->Group(), PROCESS_PRIORITY_FOREGROUND,
+          isPreloadBrowser);
     }
     if (!constructorSender) {
       return nullptr;
@@ -1333,9 +1358,9 @@
 
   aBrowsingContext->SetEmbedderElement(aFrameElement);
 
-  // Ensure that our content process is subscribed to our newly created
-  // BrowsingContextGroup.
-  aBrowsingContext->Group()->EnsureSubscribed(constructorSender);
+  // Ensure that the process which we're using to launch is set as the host
+  // process for this BrowsingContextGroup.
+  aBrowsingContext->Group()->EnsureHostProcess(constructorSender);
 
   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
   docShell->GetTreeOwner(getter_AddRefs(treeOwner));
@@ -1676,6 +1701,13 @@
     return;
   }
 
+  // Ensure that this BrowsingContextGroup is no longer used to host new
+  // documents from any associated BrowsingContextGroups. It may become a host
+  // again in the future, if it is restored to the pool.
+  for (auto& group : mGroups) {
+    group.GetKey()->RemoveHostProcess(this);
+  }
+
   if (sBrowserContentParents) {
     if (auto entry = sBrowserContentParents->Lookup(mRemoteType)) {
       const auto& contentParents = entry.Data();
@@ -1897,13 +1929,13 @@
   a11y::AccessibleWrap::ReleaseContentProcessIdFor(ChildID());
 #endif
 
+  // As this process is going away, ensure that every BrowsingContextGroup has
+  // been fully unsubscribed.
   nsTHashtable<nsRefPtrHashKey<BrowsingContextGroup>> groups;
   mGroups.SwapElements(groups);
-
-  for (auto iter = groups.Iter(); !iter.Done(); iter.Next()) {
-    iter.Get()->GetKey()->Unsubscribe(this);
-  }
-
+  for (auto& group : groups) {
+    group.GetKey()->Unsubscribe(this);
+  }
   MOZ_DIAGNOSTIC_ASSERT(mGroups.IsEmpty());
 }
 
@@ -2881,6 +2913,12 @@
     Unused << SendInitJSActorInfos(contentInfos, windowInfos);
   }
 
+  // Begin subscribing to any BrowsingContextGroups which were hosted by this
+  // process before it finished launching.
+  for (auto& group : mGroups) {
+    group.GetKey()->Subscribe(this);
+  }
+
   // Start up nsPluginHost and run FindPlugins to cache the plugin list.
   // If this isn't our first content process, just send over cached list.
   RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
@@ -6728,15 +6766,20 @@
   return IPC_OK();
 }
 
-void ContentParent::OnBrowsingContextGroupSubscribe(
-    BrowsingContextGroup* aGroup) {
+void ContentParent::AddBrowsingContextGroup(BrowsingContextGroup* aGroup) {
   MOZ_DIAGNOSTIC_ASSERT(aGroup);
-  mGroups.PutEntry(aGroup);
-}
-
-void ContentParent::OnBrowsingContextGroupUnsubscribe(
-    BrowsingContextGroup* aGroup) {
+  // Ensure that the group has been inserted, and if we're not launching
+  // anymore, also begin subscribing. Launching processes will be subscribed if
+  // they finish launching in `LaunchSubprocessResolve`.
+  if (mGroups.EnsureInserted(aGroup) && !IsLaunching()) {
+    aGroup->Subscribe(this);
+  }
+}
+
+void ContentParent::RemoveBrowsingContextGroup(BrowsingContextGroup* aGroup) {
   MOZ_DIAGNOSTIC_ASSERT(aGroup);
+  // Remove the group from our list. This is called from the
+  // BrowisngContextGroup when unsubscribing, so we don't need to do it here.
   mGroups.RemoveEntry(aGroup);
 }
 