# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/ModuleObject.cpp
# Commit: cb0e58368cd4
# Full Hash: cb0e58368cd4d8e1f79b193b7ccae9586cc2ab50
# Author: Tooru Fujisawa <arai_a@mac.com>
# Date: 2020-11-14 09:46:25
# Regressor Bug: 1675241
# File Overlap Count: 1
# Description:
#   Bug 1675241 - Part 10: Use TaggedParserAtomIndex in StencilModuleEntry. r=tcampbell
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D96917
# ==============================================================================

diff -r 73cc5fa0e0bd -r cb0e58368cd4 js/src/builtin/ModuleObject.cpp
--- a/js/src/builtin/ModuleObject.cpp	Sat Nov 14 00:03:20 2020 +0000
+++ b/js/src/builtin/ModuleObject.cpp	Sat Nov 14 00:03:28 2020 +0000
@@ -1239,12 +1239,14 @@
           return false;
         }
       } else {
-        if (importEntry->importName == cx_->parserNames().star) {
+        if (importEntry->importName ==
+            frontend::TaggedParserAtomIndex::star()) {
           if (!metadata.localExportEntries.append(exp)) {
             js::ReportOutOfMemory(cx_);
             return false;
           }
         } else {
+          // All names should have already been marked as used-by-stencil.
           auto entry = frontend::StencilModuleEntry::exportFromEntry(
               importEntry->specifier, importEntry->importName, exp.exportName,
               exp.lineno, exp.column);
@@ -1254,7 +1256,8 @@
           }
         }
       }
-    } else if (exp.importName == cx_->parserNames().star && !exp.exportName) {
+    } else if (exp.importName == frontend::TaggedParserAtomIndex::star() &&
+               !exp.exportName) {
       if (!metadata.starExportEntries.append(exp)) {
         js::ReportOutOfMemory(cx_);
         return false;
@@ -1303,22 +1306,22 @@
     const frontend::StencilModuleEntry& entry = vector[i];
 
     if (entry.specifier) {
-      specifier = entry.specifier->toExistingJSAtom(cx, atomCache);
+      specifier = atomCache.getExistingAtomAt(cx, entry.specifier);
       MOZ_ASSERT(specifier);
     }
 
     if (entry.localName) {
-      localName = entry.localName->toExistingJSAtom(cx, atomCache);
+      localName = atomCache.getExistingAtomAt(cx, entry.localName);
       MOZ_ASSERT(localName);
     }
 
     if (entry.importName) {
-      importName = entry.importName->toExistingJSAtom(cx, atomCache);
+      importName = atomCache.getExistingAtomAt(cx, entry.importName);
       MOZ_ASSERT(importName);
     }
 
     if (entry.exportName) {
-      exportName = entry.exportName->toExistingJSAtom(cx, atomCache);
+      exportName = atomCache.getExistingAtomAt(cx, entry.exportName);
       MOZ_ASSERT(exportName);
     }
 
@@ -1441,9 +1444,13 @@
     eitherParser_.computeLineAndColumn(importNameNode->pn_pos.begin, &line,
                                        &column);
 
+    module->markUsedByStencil();
+    localName->markUsedByStencil();
+    importName->markUsedByStencil();
     auto entry = frontend::StencilModuleEntry::importEntry(
-        module, localName, importName, line, column);
-    if (!importEntries_.put(localName, entry)) {
+        module->toIndex(), localName->toIndex(), importName->toIndex(), line,
+        column);
+    if (!importEntries_.put(localName->toIndex(), entry)) {
       return false;
     }
   }
@@ -1669,7 +1676,7 @@
 }
 
 frontend::StencilModuleEntry* ModuleBuilder::importEntryFor(
-    const frontend::ParserAtom* localName) const {
+    frontend::TaggedParserAtomIndex localName) const {
   MOZ_ASSERT(localName);
   auto ptr = importEntries_.lookup(localName);
   if (!ptr) {
@@ -1693,8 +1700,10 @@
     eitherParser_.computeLineAndColumn(node->pn_pos.begin, &line, &column);
   }
 
+  localName->markUsedByStencil();
+  exportName->markUsedByStencil();
   auto entry = frontend::StencilModuleEntry::exportAsEntry(
-      localName, exportName, line, column);
+      localName->toIndex(), exportName->toIndex(), line, column);
   if (!exportEntries_.append(entry)) {
     return false;
   }
@@ -1716,8 +1725,16 @@
   uint32_t column;
   eitherParser_.computeLineAndColumn(node->pn_pos.begin, &line, &column);
 
+  moduleRequest->markUsedByStencil();
+  importName->markUsedByStencil();
+  if (exportName) {
+    exportName->markUsedByStencil();
+  }
   auto entry = frontend::StencilModuleEntry::exportFromEntry(
-      moduleRequest, importName, exportName, line, column);
+      moduleRequest->toIndex(), importName->toIndex(),
+      exportName ? exportName->toIndex()
+                 : frontend::TaggedParserAtomIndex::null(),
+      line, column);
   if (!exportEntries_.append(entry)) {
     return false;
   }
@@ -1735,8 +1752,9 @@
   uint32_t column;
   eitherParser_.computeLineAndColumn(node->pn_pos.begin, &line, &column);
 
-  auto entry =
-      frontend::StencilModuleEntry::moduleRequest(specifier, line, column);
+  specifier->markUsedByStencil();
+  auto entry = frontend::StencilModuleEntry::moduleRequest(specifier->toIndex(),
+                                                           line, column);
   if (!requestedModules_.append(entry)) {
     js::ReportOutOfMemory(cx_);
     return false;