# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/mac/GeckoTextMarker.mm
# Commit: bb7606e92697
# Full Hash: bb7606e92697cbf94bd0b7fe0710acd53041cfa5
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2020-11-21 21:37:46
# Regressor Bug: 1672700
# File Overlap Count: 1
# Description:
#   Bug 1672700 - Make mozTextAccessible attribute getters use GeckoTextMarker. r=morgan
#   
#   This allows `contenteditable` textboxes to work correctly with flattened text values.
#   
#   The attribute setters, aside from AXValue, don't work in Chrome or Safari with aria textboxes,
# ==============================================================================

diff -r 1ad690f5f41a -r bb7606e92697 accessible/mac/GeckoTextMarker.mm
--- a/accessible/mac/GeckoTextMarker.mm	Sat Nov 21 04:13:43 2020 +0000
+++ b/accessible/mac/GeckoTextMarker.mm	Sat Nov 21 04:13:45 2020 +0000
@@ -277,7 +277,7 @@
   return false;
 }
 
-uint32_t GeckoTextMarker::CharacterCount(const AccessibleOrProxy& aContainer) {
+static uint32_t CharacterCount(const AccessibleOrProxy& aContainer) {
   if (aContainer.IsProxy()) {
     return aContainer.AsProxy()->CharacterCount();
   }
@@ -335,7 +335,8 @@
 
 GeckoTextMarkerRange::GeckoTextMarkerRange(
     AccessibleOrProxy aDoc, AXTextMarkerRangeRef aTextMarkerRange) {
-  if (CFGetTypeID(aTextMarkerRange) != AXTextMarkerRangeGetTypeID()) {
+  if (!aTextMarkerRange ||
+      CFGetTypeID(aTextMarkerRange) != AXTextMarkerRangeGetTypeID()) {
     return;
   }
 
@@ -441,5 +442,29 @@
     htWrap->SelectRange(mStart.mOffset, end, mEnd.mOffset);
   }
 }
+
+bool GeckoTextMarkerRange::Crop(const AccessibleOrProxy& aContainer) {
+  GeckoTextMarker containerStart(aContainer, 0);
+  GeckoTextMarker containerEnd(aContainer, CharacterCount(aContainer));
+
+  if (mEnd < containerStart || containerEnd < mStart) {
+    // The range ends before the container, or starts after it.
+    return false;
+  }
+
+  if (mStart < containerStart) {
+    // If range start is before container start, adjust range start to
+    // start of container.
+    mStart = containerStart;
+  }
+
+  if (containerEnd < mEnd) {
+    // If range end is after container end, adjust range end to end of
+    // container.
+    mEnd = containerEnd;
+  }
+
+  return true;
 }
 }
+}