# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/gamepad/ipc/GamepadTestChannelParent.cpp
# Commit: ec6a64b639a8
# Full Hash: ec6a64b639a82e957376c09a71aef7ce62b3a5aa
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-12-03 09:47:26
# Regressor Bug: 1657404
# File Overlap Count: 1
# Description:
#   Bug 1657404 - Implement a strongly-typed, service-dependent gamepad handle r=handyman,aklotz
#   
#   Currently, the gamepad code uses a uint32_t as a handle and does some trickery
#   with it by trying to create a unique ID and adding an offset to it for VR code.
#   
# ==============================================================================

diff -r 6792f28b99bd -r ec6a64b639a8 dom/gamepad/ipc/GamepadTestChannelParent.cpp
--- a/dom/gamepad/ipc/GamepadTestChannelParent.cpp	Wed Dec 02 22:36:35 2020 +0000
+++ b/dom/gamepad/ipc/GamepadTestChannelParent.cpp	Wed Dec 02 23:06:05 2020 +0000
@@ -38,12 +38,12 @@
   const GamepadAdded& a = aGamepadAdded;
   nsCString gamepadID;
   LossyCopyUTF16toASCII(a.id(), gamepadID);
-  uint32_t index = service->AddGamepad(
+  GamepadHandle handle = service->AddGamepad(
       gamepadID.get(), static_cast<GamepadMappingType>(a.mapping()), a.hand(),
       a.num_buttons(), a.num_axes(), a.num_haptics(), a.num_lights(),
       a.num_touches());
 
-  Unused << SendReplyGamepadIndex(aPromiseId, index);
+  Unused << SendReplyGamepadHandle(aPromiseId, handle);
 }
 
 void GamepadTestChannelParent::OnMonitoringStateChanged(bool aNewState) {
@@ -85,31 +85,31 @@
     return IPC_FAIL(this, "Simulated message received while not monitoring");
   }
 
-  const uint32_t index = aEvent.index();
+  GamepadHandle handle = aEvent.handle();
 
   if (body.type() == GamepadChangeEventBody::TGamepadRemoved) {
-    service->RemoveGamepad(index);
+    service->RemoveGamepad(handle);
     return IPC_OK();
   }
   if (body.type() == GamepadChangeEventBody::TGamepadButtonInformation) {
     const GamepadButtonInformation& a = body.get_GamepadButtonInformation();
-    service->NewButtonEvent(index, a.button(), a.pressed(), a.touched(),
+    service->NewButtonEvent(handle, a.button(), a.pressed(), a.touched(),
                             a.value());
     return IPC_OK();
   }
   if (body.type() == GamepadChangeEventBody::TGamepadAxisInformation) {
     const GamepadAxisInformation& a = body.get_GamepadAxisInformation();
-    service->NewAxisMoveEvent(index, a.axis(), a.value());
+    service->NewAxisMoveEvent(handle, a.axis(), a.value());
     return IPC_OK();
   }
   if (body.type() == GamepadChangeEventBody::TGamepadPoseInformation) {
     const GamepadPoseInformation& a = body.get_GamepadPoseInformation();
-    service->NewPoseEvent(index, a.pose_state());
+    service->NewPoseEvent(handle, a.pose_state());
     return IPC_OK();
   }
   if (body.type() == GamepadChangeEventBody::TGamepadTouchInformation) {
     const GamepadTouchInformation& a = body.get_GamepadTouchInformation();
-    service->NewMultiTouchEvent(index, a.index(), a.touch_state());
+    service->NewMultiTouchEvent(handle, a.index(), a.touch_state());
     return IPC_OK();
   }
 