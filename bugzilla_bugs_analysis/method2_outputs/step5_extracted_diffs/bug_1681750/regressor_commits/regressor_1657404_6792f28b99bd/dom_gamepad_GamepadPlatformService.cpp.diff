# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/gamepad/GamepadPlatformService.cpp
# Commit: 6792f28b99bd
# Full Hash: 6792f28b99bdd9a218d3cac9b07db5a1c70c83ea
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-12-03 09:47:26
# Regressor Bug: 1657404
# File Overlap Count: 2
# Description:
#   Bug 1657404 - Refactor GamepadPlatformService r=handyman
#   
#   A substantial refactor of GamepadPlatformService:
#   1. Easier to understand lifetime
#   2. Correct usage of mutexes to protect shared state
# ==============================================================================

diff -r 349854c5ad56 -r 6792f28b99bd dom/gamepad/GamepadPlatformService.cpp
--- a/dom/gamepad/GamepadPlatformService.cpp	Wed Dec 02 22:32:30 2020 +0000
+++ b/dom/gamepad/GamepadPlatformService.cpp	Wed Dec 02 22:36:35 2020 +0000
@@ -24,7 +24,7 @@
 
 // This is the singleton instance of GamepadPlatformService, can be called
 // by both background and monitor thread.
-StaticRefPtr<GamepadPlatformService> gGamepadPlatformServiceSingleton;
+static StaticRefPtr<GamepadPlatformService> gGamepadPlatformServiceSingleton;
 
 }  // namespace
 
@@ -79,42 +79,48 @@
   }
 }
 
-GamepadPlatformService::GamepadPlatformService()
-    : mGamepadIndex(0), mMutex("mozilla::dom::GamepadPlatformService") {}
+// This class is created to service one-or-more event channels
+// This implies an invariant - There is always at-least one event channel while
+// this class is alive. It should be created with a channel, and it should be
+// destroyed when the last channel is to be removed.
+GamepadPlatformService::GamepadPlatformService(
+    RefPtr<GamepadEventChannelParent> aParent)
+    : mNextGamepadServiceId(1), mMutex("mozilla::dom::GamepadPlatformService") {
+  AssertIsOnBackgroundThread();
+  mChannelParents.AppendElement(std::move(aParent));
+  MOZ_ASSERT(mChannelParents.Length() == 1);
+}
 
-GamepadPlatformService::~GamepadPlatformService() { Cleanup(); }
+GamepadPlatformService::~GamepadPlatformService() {
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mChannelParents.Length() == 1);
+}
 
 // static
 already_AddRefed<GamepadPlatformService>
 GamepadPlatformService::GetParentService() {
   // GamepadPlatformService can only be accessed in parent process
   MOZ_ASSERT(XRE_IsParentProcess());
-  if (!gGamepadPlatformServiceSingleton) {
-    // Only Background Thread can create new GamepadPlatformService instance.
-    if (IsOnBackgroundThread()) {
-      gGamepadPlatformServiceSingleton = new GamepadPlatformService();
-    } else {
-      return nullptr;
-    }
-  }
-  RefPtr<GamepadPlatformService> service(gGamepadPlatformServiceSingleton);
-  return service.forget();
+
+  MOZ_RELEASE_ASSERT(
+      gGamepadPlatformServiceSingleton,
+      "Impossible for monitor thread to be running with no platform service");
+
+  return RefPtr<GamepadPlatformService>(gGamepadPlatformServiceSingleton)
+      .forget();
 }
 
 template <class T>
-void GamepadPlatformService::NotifyGamepadChange(uint32_t aIndex,
-                                                 const T& aInfo) {
+void GamepadPlatformService::NotifyGamepadChange(
+    uint32_t aServiceId, const T& aInfo, const MutexAutoLock& aProofOfLock) {
   // This method is called by monitor populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
+  aProofOfLock.AssertOwns(mMutex);
 
   GamepadChangeEventBody body(aInfo);
-  GamepadChangeEvent e(aIndex, GamepadServiceType::Standard, body);
-
-  // mChannelParents may be accessed by background thread in the
-  // same time, we use mutex to prevent possible race condtion
-  MutexAutoLock autoLock(mMutex);
+  GamepadChangeEvent e(aServiceId, GamepadServiceType::Standard, body);
 
   for (uint32_t i = 0; i < mChannelParents.Length(); ++i) {
     mChannelParents[i]->DispatchUpdateEvent(e);
@@ -130,101 +136,118 @@
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
 
-  uint32_t index = ++mGamepadIndex;
+  uint32_t serviceId = mNextGamepadServiceId++;
 
   // Only VR controllers has displayID, we give 0 to the general gamepads.
   GamepadAdded a(NS_ConvertUTF8toUTF16(nsDependentCString(aID)), aMapping,
                  aHand, 0, aNumButtons, aNumAxes, aHaptics, aNumLightIndicator,
                  aNumTouchEvents);
 
-  mGamepadAdded.emplace(index, a);
-  NotifyGamepadChange<GamepadAdded>(index, a);
-  return index;
+  MutexAutoLock autoLock(mMutex);
+  mGamepadAdded.emplace(serviceId, a);
+  NotifyGamepadChange<GamepadAdded>(serviceId, a, autoLock);
+
+  return serviceId;
 }
 
-void GamepadPlatformService::RemoveGamepad(uint32_t aIndex) {
+void GamepadPlatformService::RemoveGamepad(uint32_t aServiceId) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   GamepadRemoved a;
-  NotifyGamepadChange<GamepadRemoved>(aIndex, a);
-  mGamepadAdded.erase(aIndex);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadRemoved>(aServiceId, a, autoLock);
+  mGamepadAdded.erase(aServiceId);
 }
 
-void GamepadPlatformService::NewButtonEvent(uint32_t aIndex, uint32_t aButton,
-                                            bool aPressed, bool aTouched,
-                                            double aValue) {
+void GamepadPlatformService::NewButtonEvent(uint32_t aServiceId,
+                                            uint32_t aButton, bool aPressed,
+                                            bool aTouched, double aValue) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   GamepadButtonInformation a(aButton, aValue, aPressed, aTouched);
-  NotifyGamepadChange<GamepadButtonInformation>(aIndex, a);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadButtonInformation>(aServiceId, a, autoLock);
 }
 
-void GamepadPlatformService::NewButtonEvent(uint32_t aIndex, uint32_t aButton,
-                                            bool aPressed, double aValue) {
+void GamepadPlatformService::NewButtonEvent(uint32_t aServiceId,
+                                            uint32_t aButton, bool aPressed,
+                                            double aValue) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   // When only a digital button is available the value will be synthesized.
-  NewButtonEvent(aIndex, aButton, aPressed, aPressed, aValue);
+  NewButtonEvent(aServiceId, aButton, aPressed, aPressed, aValue);
 }
 
-void GamepadPlatformService::NewButtonEvent(uint32_t aIndex, uint32_t aButton,
-                                            bool aPressed, bool aTouched) {
+void GamepadPlatformService::NewButtonEvent(uint32_t aServiceId,
+                                            uint32_t aButton, bool aPressed,
+                                            bool aTouched) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   // When only a digital button is available the value will be synthesized.
-  NewButtonEvent(aIndex, aButton, aPressed, aTouched, aPressed ? 1.0L : 0.0L);
+  NewButtonEvent(aServiceId, aButton, aPressed, aTouched,
+                 aPressed ? 1.0L : 0.0L);
 }
 
-void GamepadPlatformService::NewButtonEvent(uint32_t aIndex, uint32_t aButton,
-                                            bool aPressed) {
+void GamepadPlatformService::NewButtonEvent(uint32_t aServiceId,
+                                            uint32_t aButton, bool aPressed) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   // When only a digital button is available the value will be synthesized.
-  NewButtonEvent(aIndex, aButton, aPressed, aPressed, aPressed ? 1.0L : 0.0L);
+  NewButtonEvent(aServiceId, aButton, aPressed, aPressed,
+                 aPressed ? 1.0L : 0.0L);
 }
 
-void GamepadPlatformService::NewAxisMoveEvent(uint32_t aIndex, uint32_t aAxis,
-                                              double aValue) {
+void GamepadPlatformService::NewAxisMoveEvent(uint32_t aServiceId,
+                                              uint32_t aAxis, double aValue) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   GamepadAxisInformation a(aAxis, aValue);
-  NotifyGamepadChange<GamepadAxisInformation>(aIndex, a);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadAxisInformation>(aServiceId, a, autoLock);
 }
 
 void GamepadPlatformService::NewLightIndicatorTypeEvent(
-    uint32_t aIndex, uint32_t aLight, GamepadLightIndicatorType aType) {
+    uint32_t aServiceId, uint32_t aLight, GamepadLightIndicatorType aType) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   GamepadLightIndicatorTypeInformation a(aLight, aType);
-  NotifyGamepadChange<GamepadLightIndicatorTypeInformation>(aIndex, a);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadLightIndicatorTypeInformation>(aServiceId, a,
+                                                            autoLock);
 }
 
-void GamepadPlatformService::NewPoseEvent(uint32_t aIndex,
+void GamepadPlatformService::NewPoseEvent(uint32_t aServiceId,
                                           const GamepadPoseState& aState) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
   MOZ_ASSERT(XRE_IsParentProcess());
   MOZ_ASSERT(!NS_IsMainThread());
   GamepadPoseInformation a(aState);
-  NotifyGamepadChange<GamepadPoseInformation>(aIndex, a);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadPoseInformation>(aServiceId, a, autoLock);
 }
 
 void GamepadPlatformService::NewMultiTouchEvent(
-    uint32_t aIndex, uint32_t aTouchArrayIndex,
+    uint32_t aServiceId, uint32_t aTouchArrayIndex,
     const GamepadTouchState& aState) {
   // This method is called by monitor thread populated in
   // platform-dependent backends
@@ -232,101 +255,85 @@
   MOZ_ASSERT(!NS_IsMainThread());
 
   GamepadTouchInformation a(aTouchArrayIndex, aState);
-  NotifyGamepadChange<GamepadTouchInformation>(aIndex, a);
+
+  MutexAutoLock autoLock(mMutex);
+  NotifyGamepadChange<GamepadTouchInformation>(aServiceId, a, autoLock);
+}
+
+void GamepadPlatformService::AddChannelParentInternal(
+    const RefPtr<GamepadEventChannelParent>& aParent) {
+  MutexAutoLock autoLock(mMutex);
+
+  MOZ_ASSERT(!mChannelParents.Contains(aParent));
+  mChannelParents.AppendElement(aParent);
+
+  // Inform the new channel of all the gamepads that have already been added
+  for (const auto& evt : mGamepadAdded) {
+    GamepadChangeEventBody body(evt.second);
+    GamepadChangeEvent e(evt.first, GamepadServiceType::Standard, body);
+    aParent->DispatchUpdateEvent(e);
+  }
 }
 
-void GamepadPlatformService::ResetGamepadIndexes() {
-  // This method is called by monitor thread populated in
-  // platform-dependent backends
-  MOZ_ASSERT(XRE_IsParentProcess());
-  MOZ_ASSERT(!NS_IsMainThread());
-  mGamepadIndex = 0;
+bool GamepadPlatformService::RemoveChannelParentInternal(
+    GamepadEventChannelParent* aParent) {
+  MutexAutoLock autoLock(mMutex);
+
+  MOZ_ASSERT(mChannelParents.Contains(aParent));
+
+  // If there is only one channel left, we destroy the singleton instead of
+  // unregistering the channel
+  if (mChannelParents.Length() == 1) {
+    return false;
+  }
+
+  mChannelParents.RemoveElement(aParent);
+  return true;
 }
 
+// static
 void GamepadPlatformService::AddChannelParent(
-    GamepadEventChannelParent* aParent) {
+    const RefPtr<GamepadEventChannelParent>& aParent) {
   // mChannelParents can only be modified once GamepadEventChannelParent
   // is created or removed in Background thread
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aParent);
-  MOZ_ASSERT(!mChannelParents.Contains(aParent));
 
-  // We use mutex here to prevent race condition with monitor thread
-  {
-    MutexAutoLock autoLock(mMutex);
-    mChannelParents.AppendElement(aParent);
-
-    // For a new GamepadEventChannel, we have to send the exising GamepadAdded
-    // to it to make it can have the same amount of gamepads with others.
-    if (mChannelParents.Length() > 1) {
-      for (const auto& evt : mGamepadAdded) {
-        GamepadChangeEventBody body(evt.second);
-        GamepadChangeEvent e(evt.first, GamepadServiceType::Standard, body);
-        aParent->DispatchUpdateEvent(e);
-      }
-    }
+  if (gGamepadPlatformServiceSingleton) {
+    gGamepadPlatformServiceSingleton->AddChannelParentInternal(aParent);
+    return;
   }
 
+  gGamepadPlatformServiceSingleton =
+      RefPtr<GamepadPlatformService>(new GamepadPlatformService{aParent});
+
   StartGamepadMonitoring();
-
   GamepadMonitoringState::GetSingleton().Set(true);
 }
 
+// static
 void GamepadPlatformService::RemoveChannelParent(
     GamepadEventChannelParent* aParent) {
   // mChannelParents can only be modified once GamepadEventChannelParent
   // is created or removed in Background thread
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aParent);
-  MOZ_ASSERT(mChannelParents.Contains(aParent));
+  MOZ_ASSERT(gGamepadPlatformServiceSingleton);
 
-  // We use mutex here to prevent race condition with monitor thread
-  {
-    MutexAutoLock autoLock(mMutex);
-    mChannelParents.RemoveElement(aParent);
-    if (!mChannelParents.IsEmpty()) {
-      return;
-    }
+  // RemoveChannelParentInternal will refuse to remove the last channel
+  // In that case, we should destroy the singleton
+  if (gGamepadPlatformServiceSingleton->RemoveChannelParentInternal(aParent)) {
+    return;
   }
 
   GamepadMonitoringState::GetSingleton().Set(false);
-
   StopGamepadMonitoring();
-  ResetGamepadIndexes();
-  MaybeShutdown();
-}
-
-void GamepadPlatformService::MaybeShutdown() {
-  // This method is invoked in MaybeStopGamepadMonitoring when
-  // an IPDL channel is going to be destroyed
-  AssertIsOnBackgroundThread();
-
-  // We have to release gGamepadPlatformServiceSingleton ouside
-  // the mutex as well as making upcoming GetParentService() call
-  // recreate new singleton, so we use this RefPtr to temporarily
-  // hold the reference, postponing the release process until this
-  // method ends.
-  RefPtr<GamepadPlatformService> kungFuDeathGrip;
 
-  bool isChannelParentEmpty;
-  {
-    MutexAutoLock autoLock(mMutex);
-    isChannelParentEmpty = mChannelParents.IsEmpty();
-    if (isChannelParentEmpty) {
-      kungFuDeathGrip = gGamepadPlatformServiceSingleton;
-      gGamepadPlatformServiceSingleton = nullptr;
-      mGamepadAdded.clear();
-    }
-  }
-}
+  // At this point, any monitor threads should be stopped and the only
+  // reference to the singleton should be the global one
+  MOZ_RELEASE_ASSERT(gGamepadPlatformServiceSingleton->mRefCnt.get() == 1);
 
-void GamepadPlatformService::Cleanup() {
-  // This method is called when GamepadPlatformService is
-  // successfully distructed in background thread
-  AssertIsOnBackgroundThread();
-
-  MutexAutoLock autoLock(mMutex);
-  mChannelParents.Clear();
+  gGamepadPlatformServiceSingleton = nullptr;
 }
 
 }  // namespace mozilla::dom