# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/gamepad/cocoa/CocoaGamepad.cpp
# Commit: ec6a64b639a8
# Full Hash: ec6a64b639a82e957376c09a71aef7ce62b3a5aa
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-12-03 09:47:26
# Regressor Bug: 1657404
# File Overlap Count: 3
# Description:
#   Bug 1657404 - Implement a strongly-typed, service-dependent gamepad handle r=handyman,aklotz
#   
#   Currently, the gamepad code uses a uint32_t as a handle and does some trickery
#   with it by trying to create a unique ID and adding an offset to it for VR code.
#   
# ==============================================================================

diff -r 6792f28b99bd -r ec6a64b639a8 dom/gamepad/cocoa/CocoaGamepad.cpp
--- a/dom/gamepad/cocoa/CocoaGamepad.cpp	Wed Dec 02 22:36:35 2020 +0000
+++ b/dom/gamepad/cocoa/CocoaGamepad.cpp	Wed Dec 02 23:06:05 2020 +0000
@@ -7,6 +7,7 @@
 // mostly derived from the Allegro source code at:
 // http://alleg.svn.sourceforge.net/viewvc/alleg/allegro/branches/4.9/src/macosx/hidjoy.m?revision=13760&view=markup
 
+#include "mozilla/dom/GamepadHandle.h"
 #include "mozilla/dom/GamepadPlatformService.h"
 #include "mozilla/ArrayUtils.h"
 #include "nsITimer.h"
@@ -82,7 +83,7 @@
   nsTArray<Axis> axes;
 
  public:
-  Gamepad() : mDevice(nullptr), mSuperIndex(-1) {}
+  Gamepad() : mDevice(nullptr) {}
 
   bool operator==(IOHIDDeviceRef device) const { return mDevice == device; }
   bool empty() const { return mDevice == nullptr; }
@@ -90,7 +91,7 @@
     mDevice = nullptr;
     buttons.Clear();
     axes.Clear();
-    mSuperIndex = -1;
+    mHandle = GamepadHandle{};
   }
   void init(IOHIDDeviceRef device, bool defaultRemapper);
   void ReportChanged(uint8_t* report, CFIndex report_length);
@@ -113,8 +114,7 @@
     return nullptr;
   }
 
-  // Index given by our superclass.
-  uint32_t mSuperIndex;
+  GamepadHandle mHandle;
   RefPtr<GamepadRemapper> mRemapper;
   std::vector<uint8_t> mInputReport;
 };
@@ -207,7 +207,7 @@
 
   void Startup();
   void Shutdown();
-  void SetLightIndicatorColor(const Tainted<uint32_t>& aControllerIdx,
+  void SetLightIndicatorColor(const Tainted<GamepadHandle>& aGamepadHandle,
                               const Tainted<uint32_t>& aLightColorIndex,
                               const Tainted<uint8_t>& aRed,
                               const Tainted<uint8_t>& aGreen,
@@ -304,7 +304,7 @@
   remapper->SetAxisCount(mGamepads[slot].numAxes());
   remapper->SetButtonCount(mGamepads[slot].numButtons());
 
-  uint32_t index = service->AddGamepad(
+  GamepadHandle handle = service->AddGamepad(
       buffer, remapper->GetMappingType(), mozilla::dom::GamepadHand::_empty,
       remapper->GetButtonCount(), remapper->GetAxisCount(),
       0,  // TODO: Bug 680289, implement gamepad haptics for cocoa.
@@ -314,11 +314,11 @@
   remapper->GetLightIndicators(lightTypes);
   for (uint32_t i = 0; i < lightTypes.Length(); ++i) {
     if (lightTypes[i] != GamepadLightIndicator::DefaultType()) {
-      service->NewLightIndicatorTypeEvent(index, i, lightTypes[i]);
+      service->NewLightIndicatorTypeEvent(handle, i, lightTypes[i]);
     }
   }
 
-  mGamepads[slot].mSuperIndex = index;
+  mGamepads[slot].mHandle = handle;
   mGamepads[slot].mInputReport.resize(remapper->GetMaxInputReportLength());
   mGamepads[slot].mRemapper = remapper.forget();
 
@@ -339,7 +339,7 @@
       IOHIDDeviceRegisterInputReportCallback(
           device, mGamepads[i].mInputReport.data(), 0, NULL, &mGamepads[i]);
 
-      service->RemoveGamepad(mGamepads[i].mSuperIndex);
+      service->RemoveGamepad(mGamepads[i].mHandle);
       mGamepads[i].clear();
       return;
     }
@@ -357,7 +357,7 @@
 
 void Gamepad::ReportChanged(uint8_t* report, CFIndex report_len) {
   MOZ_RELEASE_ASSERT(report_len <= mRemapper->GetMaxInputReportLength());
-  mRemapper->ProcessTouchData(mSuperIndex, report);
+  mRemapper->ProcessTouchData(mHandle, report);
 }
 
 size_t Gamepad::WriteOutputReport(const std::vector<uint8_t>& aReport) const {
@@ -394,15 +394,14 @@
         const double v =
             2.0f * (d - axis->min) / (double)(axis->max - axis->min) - 1.0f;
         if (axis->value != v) {
-          gamepad.mRemapper->RemapAxisMoveEvent(gamepad.mSuperIndex, axis->id,
-                                                v);
+          gamepad.mRemapper->RemapAxisMoveEvent(gamepad.mHandle, axis->id, v);
           axis->value = v;
         }
       } else if (Button* button = gamepad.lookupButton(element)) {
         const int iv = IOHIDValueGetIntegerValue(value);
         const bool pressed = iv != 0;
         if (button->pressed != pressed) {
-          gamepad.mRemapper->RemapButtonEvent(gamepad.mSuperIndex, button->id,
+          gamepad.mRemapper->RemapButtonEvent(gamepad.mHandle, button->id,
                                               pressed);
           button->pressed = pressed;
         }
@@ -569,13 +568,13 @@
 }
 
 void DarwinGamepadService::SetLightIndicatorColor(
-    const Tainted<uint32_t>& aControllerIdx,
+    const Tainted<GamepadHandle>& aGamepadHandle,
     const Tainted<uint32_t>& aLightColorIndex, const Tainted<uint8_t>& aRed,
     const Tainted<uint8_t>& aGreen, const Tainted<uint8_t>& aBlue) {
   // We get aControllerIdx from GamepadPlatformService::AddGamepad(),
   // It begins from 1 and is stored at Gamepad.id.
   const Gamepad* gamepad = MOZ_FIND_AND_VALIDATE(
-      aControllerIdx, list_item.mSuperIndex == aControllerIdx, mGamepads);
+      aGamepadHandle, list_item.mHandle == aGamepadHandle, mGamepads);
   if (!gamepad) {
     MOZ_ASSERT(false);
     return;
@@ -625,7 +624,7 @@
   gService->Shutdown();
 }
 
-void SetGamepadLightIndicatorColor(const Tainted<uint32_t>& aControllerIdx,
+void SetGamepadLightIndicatorColor(const Tainted<GamepadHandle>& aGamepadHandle,
                                    const Tainted<uint32_t>& aLightColorIndex,
                                    const Tainted<uint8_t>& aRed,
                                    const Tainted<uint8_t>& aGreen,
@@ -634,7 +633,7 @@
   if (!gService) {
     return;
   }
-  gService->SetLightIndicatorColor(aControllerIdx, aLightColorIndex, aRed,
+  gService->SetLightIndicatorColor(aGamepadHandle, aLightColorIndex, aRed,
                                    aGreen, aBlue);
 }
 