# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/gamepad/windows/WindowsGamepad.cpp
# Commit: ec6a64b639a8
# Full Hash: ec6a64b639a82e957376c09a71aef7ce62b3a5aa
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-12-03 09:47:26
# Regressor Bug: 1657404
# File Overlap Count: 3
# Description:
#   Bug 1657404 - Implement a strongly-typed, service-dependent gamepad handle r=handyman,aklotz
#   
#   Currently, the gamepad code uses a uint32_t as a handle and does some trickery
#   with it by trying to create a unique ID and adding an offset to it for VR code.
#   
# ==============================================================================

diff -r 6792f28b99bd -r ec6a64b639a8 dom/gamepad/windows/WindowsGamepad.cpp
--- a/dom/gamepad/windows/WindowsGamepad.cpp	Wed Dec 02 22:36:35 2020 +0000
+++ b/dom/gamepad/windows/WindowsGamepad.cpp	Wed Dec 02 23:06:05 2020 +0000
@@ -116,9 +116,8 @@
   // Last-known state of the controller.
   XINPUT_STATE state;
 
-  // ID from the GamepadService, also used as the index into
-  // WindowsGamepadService::mGamepads.
-  int id;
+  // Handle from the GamepadService
+  GamepadHandle gamepadHandle;
 
   // Information about the physical device.
   unsigned numAxes;
@@ -334,7 +333,7 @@
   void Shutdown();
   // Parse gamepad input from a WM_INPUT message.
   bool HandleRawInput(HRAWINPUT handle);
-  void SetLightIndicatorColor(const Tainted<uint32_t>& aControllerIdx,
+  void SetLightIndicatorColor(const Tainted<GamepadHandle>& aGamepadHandle,
                               const Tainted<uint32_t>& aLightColorIndex,
                               const Tainted<uint8_t>& aRed,
                               const Tainted<uint8_t>& aGreen,
@@ -457,7 +456,7 @@
                     kXInputGamepad);
     gamepad.userIndex = i;
     gamepad.state = state;
-    gamepad.id = service->AddGamepad(
+    gamepad.gamepadHandle = service->AddGamepad(
         "xinput", GamepadMappingType::Standard, GamepadHand::_empty,
         kStandardGamepadButtons, kStandardGamepadAxes, 0, 0,
         0);  // TODO: Bug 680289, implement gamepad haptics for Windows.
@@ -496,7 +495,7 @@
   // Look for devices that are no longer present and remove them.
   for (int i = mGamepads.Length() - 1; i >= 0; i--) {
     if (!mGamepads[i].present) {
-      service->RemoveGamepad(mGamepads[i].id);
+      service->RemoveGamepad(mGamepads[i].gamepadHandle);
       mGamepads.RemoveElementAt(i);
     }
   }
@@ -533,11 +532,13 @@
     if (state.Gamepad.wButtons & kXIButtonMap[b].button &&
         !(gamepad.state.Gamepad.wButtons & kXIButtonMap[b].button)) {
       // Button pressed
-      service->NewButtonEvent(gamepad.id, kXIButtonMap[b].mapped, true);
+      service->NewButtonEvent(gamepad.gamepadHandle, kXIButtonMap[b].mapped,
+                              true);
     } else if (!(state.Gamepad.wButtons & kXIButtonMap[b].button) &&
                gamepad.state.Gamepad.wButtons & kXIButtonMap[b].button) {
       // Button released
-      service->NewButtonEvent(gamepad.id, kXIButtonMap[b].mapped, false);
+      service->NewButtonEvent(gamepad.gamepadHandle, kXIButtonMap[b].mapped,
+                              false);
     }
   }
 
@@ -545,13 +546,13 @@
   if (state.Gamepad.bLeftTrigger != gamepad.state.Gamepad.bLeftTrigger) {
     const bool pressed =
         state.Gamepad.bLeftTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD;
-    service->NewButtonEvent(gamepad.id, kButtonLeftTrigger, pressed,
+    service->NewButtonEvent(gamepad.gamepadHandle, kButtonLeftTrigger, pressed,
                             state.Gamepad.bLeftTrigger / 255.0);
   }
   if (state.Gamepad.bRightTrigger != gamepad.state.Gamepad.bRightTrigger) {
     const bool pressed =
         state.Gamepad.bRightTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD;
-    service->NewButtonEvent(gamepad.id, kButtonRightTrigger, pressed,
+    service->NewButtonEvent(gamepad.gamepadHandle, kButtonRightTrigger, pressed,
                             state.Gamepad.bRightTrigger / 255.0);
   }
 
@@ -559,22 +560,22 @@
   // TODO: bug 1001955 - Support deadzones.
   if (state.Gamepad.sThumbLX != gamepad.state.Gamepad.sThumbLX) {
     const float div = state.Gamepad.sThumbLX > 0 ? 32767.0 : 32768.0;
-    service->NewAxisMoveEvent(gamepad.id, kLeftStickXAxis,
+    service->NewAxisMoveEvent(gamepad.gamepadHandle, kLeftStickXAxis,
                               state.Gamepad.sThumbLX / div);
   }
   if (state.Gamepad.sThumbLY != gamepad.state.Gamepad.sThumbLY) {
     const float div = state.Gamepad.sThumbLY > 0 ? 32767.0 : 32768.0;
-    service->NewAxisMoveEvent(gamepad.id, kLeftStickYAxis,
+    service->NewAxisMoveEvent(gamepad.gamepadHandle, kLeftStickYAxis,
                               -1.0 * state.Gamepad.sThumbLY / div);
   }
   if (state.Gamepad.sThumbRX != gamepad.state.Gamepad.sThumbRX) {
     const float div = state.Gamepad.sThumbRX > 0 ? 32767.0 : 32768.0;
-    service->NewAxisMoveEvent(gamepad.id, kRightStickXAxis,
+    service->NewAxisMoveEvent(gamepad.gamepadHandle, kRightStickXAxis,
                               state.Gamepad.sThumbRX / div);
   }
   if (state.Gamepad.sThumbRY != gamepad.state.Gamepad.sThumbRY) {
     const float div = state.Gamepad.sThumbRY > 0 ? 32767.0 : 32768.0;
-    service->NewAxisMoveEvent(gamepad.id, kRightStickYAxis,
+    service->NewAxisMoveEvent(gamepad.gamepadHandle, kRightStickYAxis,
                               -1.0 * state.Gamepad.sThumbRY / div);
   }
   gamepad.state = state;
@@ -753,7 +754,7 @@
 
   gamepad.remapper = remapper.forget();
   // TODO: Bug 680289, implement gamepad haptics for Windows.
-  gamepad.id = service->AddGamepad(
+  gamepad.gamepadHandle = service->AddGamepad(
       gamepad_id, gamepad.remapper->GetMappingType(), GamepadHand::_empty,
       gamepad.remapper->GetButtonCount(), gamepad.remapper->GetAxisCount(), 0,
       gamepad.remapper->GetLightIndicatorCount(),
@@ -763,7 +764,8 @@
   gamepad.remapper->GetLightIndicators(lightTypes);
   for (uint32_t i = 0; i < lightTypes.Length(); ++i) {
     if (lightTypes[i] != GamepadLightIndicator::DefaultType()) {
-      service->NewLightIndicatorTypeEvent(gamepad.id, i, lightTypes[i]);
+      service->NewLightIndicatorTypeEvent(gamepad.gamepadHandle, i,
+                                          lightTypes[i]);
     }
   }
 
@@ -842,7 +844,8 @@
 
   for (unsigned i = 0; i < gamepad->numButtons; i++) {
     if (gamepad->buttons[i] != buttons[i]) {
-      gamepad->remapper->RemapButtonEvent(gamepad->id, i, buttons[i]);
+      gamepad->remapper->RemapButtonEvent(gamepad->gamepadHandle, i,
+                                          buttons[i]);
       gamepad->buttons[i] = buttons[i];
     }
   }
@@ -875,25 +878,26 @@
                             gamepad->axes[i].caps.LogicalMax);
     }
     if (gamepad->axes[i].value != new_value) {
-      gamepad->remapper->RemapAxisMoveEvent(gamepad->id, i, new_value);
+      gamepad->remapper->RemapAxisMoveEvent(gamepad->gamepadHandle, i,
+                                            new_value);
       gamepad->axes[i].value = new_value;
     }
   }
 
   BYTE* rawData = raw->data.hid.bRawData;
-  gamepad->remapper->ProcessTouchData(gamepad->id, rawData);
+  gamepad->remapper->ProcessTouchData(gamepad->gamepadHandle, rawData);
 
   return true;
 }
 
 void WindowsGamepadService::SetLightIndicatorColor(
-    const Tainted<uint32_t>& aControllerIdx,
+    const Tainted<GamepadHandle>& aGamepadHandle,
     const Tainted<uint32_t>& aLightColorIndex, const Tainted<uint8_t>& aRed,
     const Tainted<uint8_t>& aGreen, const Tainted<uint8_t>& aBlue) {
   // We get aControllerIdx from GamepadPlatformService::AddGamepad(),
   // It begins from 1 and is stored at Gamepad.id.
   const Gamepad* gamepad = (MOZ_FIND_AND_VALIDATE(
-      aControllerIdx, list_item.id == aControllerIdx, mGamepads));
+      aGamepadHandle, list_item.gamepadHandle == aGamepadHandle, mGamepads));
   if (!gamepad) {
     MOZ_ASSERT(false);
     return;
@@ -1124,7 +1128,7 @@
   gMonitorThread = nullptr;
 }
 
-void SetGamepadLightIndicatorColor(const Tainted<uint32_t>& aControllerIdx,
+void SetGamepadLightIndicatorColor(const Tainted<GamepadHandle>& aGamepadHandle,
                                    const Tainted<uint32_t>& aLightColorIndex,
                                    const Tainted<uint8_t>& aRed,
                                    const Tainted<uint8_t>& aGreen,
@@ -1133,7 +1137,7 @@
   if (!gService) {
     return;
   }
-  gService->SetLightIndicatorColor(aControllerIdx, aLightColorIndex, aRed,
+  gService->SetLightIndicatorColor(aGamepadHandle, aLightColorIndex, aRed,
                                    aGreen, aBlue);
 }
 