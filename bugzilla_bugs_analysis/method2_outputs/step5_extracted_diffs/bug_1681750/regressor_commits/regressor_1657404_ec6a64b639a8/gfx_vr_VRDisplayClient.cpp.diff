# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/vr/VRDisplayClient.cpp
# Commit: ec6a64b639a8
# Full Hash: ec6a64b639a82e957376c09a71aef7ce62b3a5aa
# Author: Chris Martin <cmartin@mozilla.com>
# Date: 2020-12-03 09:47:26
# Regressor Bug: 1657404
# File Overlap Count: 3
# Description:
#   Bug 1657404 - Implement a strongly-typed, service-dependent gamepad handle r=handyman,aklotz
#   
#   Currently, the gamepad code uses a uint32_t as a handle and does some trickery
#   with it by trying to create a unique ID and adding an offset to it for VR code.
#   
# ==============================================================================

diff -r 6792f28b99bd -r ec6a64b639a8 gfx/vr/VRDisplayClient.cpp
--- a/gfx/vr/VRDisplayClient.cpp	Wed Dec 02 22:36:35 2020 +0000
+++ b/gfx/vr/VRDisplayClient.cpp	Wed Dec 02 23:06:05 2020 +0000
@@ -12,6 +12,7 @@
 #include "nsIGlobalObject.h"
 #include "nsRefPtrHashtable.h"
 #include "nsString.h"
+#include "mozilla/dom/GamepadHandle.h"
 #include "mozilla/dom/GamepadManager.h"
 #include "mozilla/dom/Gamepad.h"
 #include "mozilla/dom/XRSession.h"
@@ -35,6 +36,9 @@
 using namespace mozilla;
 using namespace mozilla::gfx;
 
+using mozilla::dom::GamepadHandle;
+using mozilla::dom::GamepadHandleKind;
+
 VRDisplayClient::VRDisplayClient(const VRDisplayInfo& aDisplayInfo)
     : mDisplayInfo(aDisplayInfo),
       bLastEventWasMounted(false),
@@ -449,8 +453,11 @@
     GamepadMappingForWebVR(state);
     GamepadMappingForWebVR(lastState);
 
-    uint32_t gamepadId =
+    uint32_t gamepadHandleValue =
         mDisplayInfo.mDisplayID * kVRControllerMaxCount + stateIndex;
+
+    GamepadHandle gamepadHandle{gamepadHandleValue, GamepadHandleKind::VR};
+
     bool bIsNew = false;
 
     // Send events to notify that controllers are removed
@@ -460,8 +467,7 @@
         // Controller has been removed
         dom::GamepadRemoved info;
         dom::GamepadChangeEventBody body(info);
-        dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                      body);
+        dom::GamepadChangeEvent event(gamepadHandle, body);
         gamepadManager->Update(event);
       }
       // Do not process any further events for removed controllers
@@ -469,8 +475,7 @@
     }
 
     // Send events to notify that new controllers are added
-    RefPtr<dom::Gamepad> existing =
-        gamepadManager->GetGamepad(gamepadId, dom::GamepadServiceType::VR);
+    RefPtr<dom::Gamepad> existing = gamepadManager->GetGamepad(gamepadHandle);
     // ControllerState in OpenVR action-based API gets delay to query btn and
     // axis count. So, we need to check if they are more than zero.
     if ((lastState.controllerName[0] == '\0' || !existing) &&
@@ -480,8 +485,7 @@
                              mDisplayInfo.mDisplayID, state.numButtons,
                              state.numAxes, state.numHaptics, 0, 0);
       dom::GamepadChangeEventBody body(info);
-      dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                    body);
+      dom::GamepadChangeEvent event(gamepadHandle, body);
       gamepadManager->Update(event);
       bIsNew = true;
     }
@@ -490,8 +494,7 @@
     if (state.hand != lastState.hand) {
       dom::GamepadHandInformation info(state.hand);
       dom::GamepadChangeEventBody body(info);
-      dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                    body);
+      dom::GamepadChangeEvent event(gamepadHandle, body);
       gamepadManager->Update(event);
     }
 
@@ -500,8 +503,7 @@
       if (state.axisValue[axisIndex] != lastState.axisValue[axisIndex]) {
         dom::GamepadAxisInformation info(axisIndex, state.axisValue[axisIndex]);
         dom::GamepadChangeEventBody body(info);
-        dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                      body);
+        dom::GamepadChangeEvent event(gamepadHandle, body);
         gamepadManager->Update(event);
       }
     }
@@ -525,8 +527,7 @@
           dom::GamepadButtonInformation info(
               buttonIndex, state.triggerValue[buttonIndex], bPressed, bTouched);
           dom::GamepadChangeEventBody body(info);
-          dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                        body);
+          dom::GamepadChangeEvent event(gamepadHandle, body);
           gamepadManager->Update(event);
         }
       }
@@ -571,8 +572,7 @@
       // Send the event
       dom::GamepadPoseInformation info(poseState);
       dom::GamepadChangeEventBody body(info);
-      dom::GamepadChangeEvent event(gamepadId, dom::GamepadServiceType::VR,
-                                    body);
+      dom::GamepadChangeEvent event(gamepadHandle, body);
       gamepadManager->Update(event);
     }
   }