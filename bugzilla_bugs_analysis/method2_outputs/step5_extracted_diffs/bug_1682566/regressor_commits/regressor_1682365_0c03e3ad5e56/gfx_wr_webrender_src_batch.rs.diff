# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/batch.rs
# Commit: 0c03e3ad5e56
# Full Hash: 0c03e3ad5e56201e35437734b0ae1d34faa52005
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2020-12-15 09:29:54
# Regressor Bug: 1682365
# File Overlap Count: 1
# Description:
#   Bug 1682365 - Pt 1 - Remove PrevPassAlpha and PrevPassColor r=nical
#   
#   Remove usage of the implicit prev pass alpha and color texture
#   samplers from batching / renderer / shader code. They are replaced
#   by explicit references to the texture ID for the source task.
# ==============================================================================

diff -r 4e0ba157c016 -r 0c03e3ad5e56 gfx/wr/webrender/src/batch.rs
--- a/gfx/wr/webrender/src/batch.rs	Sat Dec 12 22:13:43 2020 +0000
+++ b/gfx/wr/webrender/src/batch.rs	Mon Dec 14 19:38:48 2020 +0000
@@ -107,16 +107,6 @@
         }
     }
 
-    fn render_target_cache() -> Self {
-        TextureSet {
-            colors: [
-                TextureSource::PrevPassColor,
-                TextureSource::PrevPassAlpha,
-                TextureSource::Invalid,
-            ],
-        }
-    }
-
     fn is_compatible_with(&self, other: &TextureSet) -> bool {
         self.colors[0].is_compatible(&other.colors[0]) &&
         self.colors[1].is_compatible(&other.colors[1]) &&
@@ -145,23 +135,6 @@
 }
 
 impl BatchTextures {
-    /// Construct a batch texture set referencing render target cache
-    // TODO(gw): Remove me once all tasks reference texture id directly!
-    pub fn render_target_cache(
-        clip_mask: TextureSource,
-    ) -> Self {
-        BatchTextures {
-            input: TextureSet {
-                colors: [
-                    TextureSource::PrevPassColor,
-                    TextureSource::PrevPassAlpha,
-                    TextureSource::Invalid,
-                ],
-            },
-            clip_mask,
-        }
-    }
-
     /// An empty batch textures (no binding slots set)
     pub fn empty() -> BatchTextures {
         BatchTextures {
@@ -1697,10 +1670,19 @@
                                             )
                                         };
 
+                                        // Retrieve the UV rect addresses for shadow/content.
+                                        let cache_task_id = surface_task
+                                            .expect("bug: surface must be allocated by now");
+                                        let (shadow_uv_rect_address, shadow_textures) = render_tasks.resolve_surface(
+                                            cache_task_id,
+                                            clip_mask_texture_id,
+                                            gpu_cache,
+                                        );
+                                        let content_uv_rect_address = render_tasks[secondary_id]
+                                            .get_texture_address(gpu_cache)
+                                            .as_int();
+
                                         // Build BatchTextures for shadow/content
-                                        let shadow_textures = BatchTextures::render_target_cache(
-                                            clip_mask_texture_id,
-                                        );
                                         let content_textures = BatchTextures::prim_textured(
                                             content_source,
                                             clip_mask_texture_id,
@@ -1710,16 +1692,6 @@
                                         let shadow_key = BatchKey::new(kind, non_segmented_blend_mode, shadow_textures);
                                         let content_key = BatchKey::new(kind, non_segmented_blend_mode, content_textures);
 
-                                        // Retrieve the UV rect addresses for shadow/content.
-                                        let cache_task_id = surface_task
-                                            .expect("bug: surface must be allocated by now");
-                                        let shadow_uv_rect_address = render_tasks[cache_task_id]
-                                            .get_texture_address(gpu_cache)
-                                            .as_int();
-                                        let content_uv_rect_address = render_tasks[secondary_id]
-                                            .get_texture_address(gpu_cache)
-                                            .as_int();
-
                                         for (shadow, shadow_gpu_data) in shadows.iter().zip(picture.extra_gpu_data_handles.iter()) {
                                             // Get the GPU cache address of the extra data handle.
                                             let shadow_prim_address = gpu_cache.get_address(shadow_gpu_data);
@@ -1753,7 +1725,7 @@
                                                 clip_task_address,
                                                 brush_flags,
                                                 shadow_prim_header_index,
-                                                shadow_uv_rect_address,
+                                                shadow_uv_rect_address.as_int(),
                                                 prim_vis_mask,
                                             );
                                         }
@@ -2015,6 +1987,9 @@
                                 //           only a single batcher present.
                                 assert_eq!(self.batchers.len(), 1);
 
+                                let color0 = render_tasks[backdrop_id].get_target_texture();
+                                let color1 = render_tasks[cache_task_id].get_target_texture();
+
                                 let key = BatchKey::new(
                                     BatchKind::Brush(
                                         BrushBatchKind::MixBlend {
@@ -2024,7 +1999,24 @@
                                         },
                                     ),
                                     BlendMode::PremultipliedAlpha,
-                                    BatchTextures::prim_untextured(clip_mask_texture_id),
+                                    BatchTextures {
+                                        input: TextureSet {
+                                            colors: [
+                                                TextureSource::TextureCache(
+                                                    color0,
+                                                    ImageBufferKind::Texture2DArray,
+                                                    Swizzle::default(),
+                                                ),
+                                                TextureSource::TextureCache(
+                                                    color1,
+                                                    ImageBufferKind::Texture2DArray,
+                                                    Swizzle::default(),
+                                                ),
+                                                TextureSource::Invalid,
+                                            ],
+                                        },
+                                        clip_mask: clip_mask_texture_id,
+                                    },
                                 );
                                 let backdrop_task_address: RenderTaskAddress = backdrop_id.into();
                                 let source_task_address: RenderTaskAddress = cache_task_id.into();
@@ -2055,21 +2047,17 @@
                                     .get_texture_address(gpu_cache)
                                     .as_int();
                                 let cache_render_task = &render_tasks[cache_task_id];
-                                let textures = if cache_render_task.save_target {
-                                    let texture_id = cache_render_task.get_target_texture();
-                                    TextureSet {
-                                        colors: [
-                                            TextureSource::TextureCache(
-                                                texture_id,
-                                                ImageBufferKind::Texture2DArray,
-                                                Swizzle::default(),
-                                            ),
-                                            TextureSource::PrevPassAlpha,
-                                            TextureSource::Invalid,
-                                        ],
-                                    }
-                                } else {
-                                    TextureSet::render_target_cache()
+                                let texture_id = cache_render_task.get_target_texture();
+                                let textures = TextureSet {
+                                    colors: [
+                                        TextureSource::TextureCache(
+                                            texture_id,
+                                            ImageBufferKind::Texture2DArray,
+                                            Swizzle::default(),
+                                        ),
+                                        TextureSource::Invalid,
+                                        TextureSource::Invalid,
+                                    ],
                                 };
                                 let batch_params = BrushBatchParameters::shared(
                                     BrushBatchKind::Image(ImageBufferKind::Texture2DArray),
@@ -2988,11 +2976,12 @@
                     .expect("backdrop task not available")
                     .root;
 
-                let backdrop_uv_rect_address = render_tasks[backdrop_task_id]
-                    .get_texture_address(gpu_cache)
-                    .as_int();
-
-                let textures = BatchTextures::render_target_cache(TextureSource::Invalid);
+                let (backdrop_uv_rect_address, textures) = render_tasks.resolve_surface(
+                    backdrop_task_id,
+                    TextureSource::Invalid,
+                    gpu_cache,
+                );
+
                 let batch_key = BatchKey::new(
                     BatchKind::Brush(BrushBatchKind::Image(ImageBufferKind::Texture2DArray)),
                     BlendMode::PremultipliedAlpha,
@@ -3029,7 +3018,7 @@
                     OPAQUE_TASK_ADDRESS,
                     BrushFlags::empty(),
                     prim_header_index,
-                    backdrop_uv_rect_address,
+                    backdrop_uv_rect_address.as_int(),
                     prim_vis_mask,
                 );
             }
@@ -3349,9 +3338,18 @@
         clip_mask: TextureSource,
         gpu_cache: &GpuCache,
     ) -> (GpuCacheAddress, BatchTextures) {
+        let task = &self[task_id];
+
         (
-            self[task_id].get_texture_address(gpu_cache),
-            BatchTextures::render_target_cache(clip_mask),
+            task.get_texture_address(gpu_cache),
+            BatchTextures::prim_textured(
+                TextureSource::TextureCache(
+                    task.get_target_texture(),
+                    ImageBufferKind::Texture2DArray,
+                    Swizzle::default(),
+                ),
+                clip_mask,
+            ),
         )
     }
 }