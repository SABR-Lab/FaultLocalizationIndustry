# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/render_target.rs
# Commit: 0edb6b6f17b2
# Full Hash: 0edb6b6f17b24c737d053df19730e9c9e61e17ca
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2020-12-18 04:07:40
# Regressor Bug: 1682365
# File Overlap Count: 1
# Description:
#   Bug 1682365 - Pt 2 - Remove texture array usage from render task graph. r=nical
#   
#   With this change, all color/alpha intermediate surfaces are individual
#   textures, rather than texture arrays.
#   
# ==============================================================================

diff -r ee0de0eac18d -r 0edb6b6f17b2 gfx/wr/webrender/src/render_target.rs
--- a/gfx/wr/webrender/src/render_target.rs	Thu Dec 17 22:26:08 2020 +0000
+++ b/gfx/wr/webrender/src/render_target.rs	Thu Dec 17 22:26:10 2020 +0000
@@ -4,13 +4,12 @@
 
 
 use api::units::*;
-use api::{ColorF, PremultipliedColorF, ImageFormat, LineOrientation, BorderStyle, ImageBufferKind};
+use api::{ColorF, PremultipliedColorF, ImageFormat, LineOrientation, BorderStyle};
 use crate::batch::{AlphaBatchBuilder, AlphaBatchContainer, BatchTextures, resolve_image};
 use crate::batch::{ClipBatcher, BatchBuilder};
 use crate::spatial_tree::{SpatialTree, ROOT_SPATIAL_NODE_INDEX};
 use crate::clip::ClipStore;
 use crate::composite::CompositeState;
-use crate::device::Texture;
 use crate::frame_builder::{FrameGlobalResources};
 use crate::gpu_cache::{GpuCache, GpuCacheAddress};
 use crate::gpu_types::{BorderInstance, SvgFilterInstance, BlurDirection, BlurInstance, PrimitiveHeaders, ScalingInstance};
@@ -24,9 +23,9 @@
 use crate::render_task::{RenderTask, ScalingTask, SvgFilterInfo};
 use crate::render_task_graph::{RenderTaskGraph, RenderTaskId};
 use crate::resource_cache::ResourceCache;
-use crate::guillotine_allocator::{GuillotineAllocator, FreeRectSlice};
+use crate::guillotine_allocator::{GuillotineAllocator};
 use crate::visibility::PrimitiveVisibilityMask;
-use std::{cmp, mem};
+use std::{mem};
 
 
 const STYLE_SOLID: i32 = ((BorderStyle::Solid as i32) << 8) | ((BorderStyle::Solid as i32) << 16);
@@ -37,9 +36,6 @@
 /// we try to avoid it. This can go away when proper tiling support lands,
 /// since we can then split large primitives across multiple textures.
 const IDEAL_MAX_TEXTURE_DIMENSION: i32 = 2048;
-/// If we ever need a larger texture than the ideal, we better round it up to a
-/// reasonable number in order to have a bit of leeway in placing things inside.
-const TEXTURE_DIMENSION_MASK: i32 = 0xFF;
 
 /// A tag used to identify the output format of a `RenderTarget`.
 #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
@@ -89,6 +85,8 @@
 pub trait RenderTarget {
     /// Creates a new RenderTarget of the given type.
     fn new(
+        texture_id: CacheTextureId,
+        target_size: DeviceIntSize,
         screen_size: DeviceIntSize,
         gpu_supports_fast_clears: bool,
     ) -> Self;
@@ -132,6 +130,13 @@
 
     fn used_rect(&self) -> DeviceIntRect;
     fn add_used(&mut self, rect: DeviceIntRect);
+    fn texture_id(&self) -> CacheTextureId;
+    fn save_target(&self) -> bool;
+
+    fn allocate(
+        &mut self,
+        size: DeviceIntSize,
+    ) -> Option<(CacheTextureId, DeviceIntPoint)>;
 }
 
 /// A series of `RenderTarget` instances, serving as the high-level container
@@ -164,17 +169,9 @@
 pub struct RenderTargetList<T> {
     screen_size: DeviceIntSize,
     pub format: ImageFormat,
-    /// The maximum width and height of any single primitive we've encountered
-    /// that will be drawn to a dynamic location.
-    ///
-    /// We initially create our per-slice allocators with a width and height of
-    /// IDEAL_MAX_TEXTURE_DIMENSION. If we encounter a larger primitive, the
-    /// allocation will fail, but we'll bump max_dynamic_size, which will cause the
-    /// allocator for the next slice to be just large enough to accomodate it.
-    pub max_dynamic_size: DeviceIntSize,
     pub targets: Vec<T>,
-    pub alloc_tracker: GuillotineAllocator,
-    pub texture_id: Option<CacheTextureId>,
+    // pub alloc_tracker: GuillotineAllocator,
+    // pub texture_id: Option<CacheTextureId>,
     gpu_supports_fast_clears: bool,
 }
 
@@ -187,10 +184,7 @@
         RenderTargetList {
             screen_size,
             format,
-            max_dynamic_size: DeviceIntSize::new(0, 0),
             targets: Vec::new(),
-            alloc_tracker: GuillotineAllocator::new(None),
-            texture_id: None,
             gpu_supports_fast_clears,
         }
     }
@@ -210,12 +204,6 @@
             return;
         }
 
-        // Get a bounding rect of all the layers, and round it up to a multiple
-        // of 256. This improves render target reuse when resizing the window,
-        // since we don't need to create a new render target for each slightly-
-        // larger frame.
-        let mut bounding_rect = DeviceIntRect::zero();
-
         for target in &mut self.targets {
             target.build(
                 ctx,
@@ -227,83 +215,62 @@
                 z_generator,
                 composite_state,
             );
-
-            bounding_rect = target.used_rect().union(&bounding_rect);
         }
-
-        debug_assert_eq!(bounding_rect.origin, DeviceIntPoint::zero());
-        let dimensions = DeviceIntSize::new(
-            (bounding_rect.size.width + 255) & !255,
-            (bounding_rect.size.height + 255) & !255,
-        );
-
-        let texture_id = ctx.resource_cache.get_or_create_render_target_from_pool(
-            dimensions,
-            self.targets.len(),
-            self.format,
-        );
-
-        assert!(self.texture_id.is_none());
-        self.texture_id = Some(texture_id);
     }
 
     pub fn allocate(
         &mut self,
-        alloc_size: DeviceIntSize,
-    ) -> (RenderTargetIndex, DeviceIntPoint) {
-        let (free_rect_slice, origin) = match self.alloc_tracker.allocate(&alloc_size) {
-            Some(allocation) => allocation,
-            None => {
-                // Have the allocator restrict slice sizes to our max ideal
-                // dimensions, unless we've already gone bigger on a previous
-                // slice.
-                let rounded_dimensions = DeviceIntSize::new(
-                    (self.max_dynamic_size.width + TEXTURE_DIMENSION_MASK) & !TEXTURE_DIMENSION_MASK,
-                    (self.max_dynamic_size.height + TEXTURE_DIMENSION_MASK) & !TEXTURE_DIMENSION_MASK,
-                );
-                let allocator_dimensions = DeviceIntSize::new(
-                    cmp::max(IDEAL_MAX_TEXTURE_DIMENSION, rounded_dimensions.width),
-                    cmp::max(IDEAL_MAX_TEXTURE_DIMENSION, rounded_dimensions.height),
-                );
+        requested_size: DeviceIntSize,
+        resource_cache: &mut ResourceCache,
+    ) -> (usize, CacheTextureId, DeviceIntPoint) {
+        let is_standalone =
+            requested_size.width > IDEAL_MAX_TEXTURE_DIMENSION ||
+            requested_size.height > IDEAL_MAX_TEXTURE_DIMENSION;
 
-                assert!(alloc_size.width <= allocator_dimensions.width &&
-                    alloc_size.height <= allocator_dimensions.height);
-                let slice = FreeRectSlice(self.targets.len() as u32);
-                self.targets.push(T::new(self.screen_size, self.gpu_supports_fast_clears));
-
-                self.alloc_tracker.extend(
-                    slice,
-                    allocator_dimensions,
-                    alloc_size,
-                );
-
-                (slice, DeviceIntPoint::zero())
-            }
+        let target_size = if is_standalone {
+            requested_size
+        } else {
+            DeviceIntSize::new(
+                IDEAL_MAX_TEXTURE_DIMENSION,
+                IDEAL_MAX_TEXTURE_DIMENSION,
+            )
         };
 
-        if alloc_size.is_empty() && self.targets.is_empty() {
-            // push an unused target here, only if we don't have any
-            self.targets.push(T::new(self.screen_size, self.gpu_supports_fast_clears));
+        for (target_index, target) in self.targets.iter_mut().enumerate() {
+            if let Some((texture_id, origin)) = target.allocate(requested_size) {
+                // TODO(gw): Move `add_used` into `allocate` when adding the
+                //           full graph functionality.
+                target.add_used(DeviceIntRect::new(origin, requested_size));
+                return (target_index, texture_id, origin);
+            }
         }
 
-        self.targets[free_rect_slice.0 as usize]
-            .add_used(DeviceIntRect::new(origin, alloc_size));
+        let texture_id = resource_cache.get_or_create_render_target_from_pool(
+            target_size,
+            self.format,
+        );
 
-        (RenderTargetIndex(free_rect_slice.0 as usize), origin)
+        let mut target = T::new(
+            texture_id,
+            target_size,
+            self.screen_size,
+            self.gpu_supports_fast_clears,
+        );
+
+        let (texture_id, origin) = target.allocate(requested_size).expect("bug: unable to alloc");
+
+        target.add_used(DeviceIntRect::new(origin, requested_size));
+
+        let target_index = self.targets.len();
+
+        self.targets.push(target);
+
+        (target_index, texture_id, origin)
     }
 
     pub fn needs_depth(&self) -> bool {
         self.targets.iter().any(|target| target.needs_depth())
     }
-
-    pub fn check_ready(&self, t: &Texture) {
-        let dimensions = t.get_dimensions();
-        assert!(dimensions.width >= self.max_dynamic_size.width);
-        assert!(dimensions.height >= self.max_dynamic_size.height);
-        assert_eq!(t.get_format(), self.format);
-        assert_eq!(t.get_layer_count() as usize, self.targets.len());
-        assert!(t.supports_depth() >= self.needs_depth());
-    }
 }
 
 
@@ -327,10 +294,15 @@
     // we can set a scissor rect and only clear to the
     // used portion of the target as an optimization.
     pub used_rect: DeviceIntRect,
+    allocator: GuillotineAllocator,
+    pub texture_id: CacheTextureId,
+    save_target: bool,
 }
 
 impl RenderTarget for ColorRenderTarget {
     fn new(
+        texture_id: CacheTextureId,
+        target_size: DeviceIntSize,
         screen_size: DeviceIntSize,
         _: bool,
     ) -> Self {
@@ -344,9 +316,23 @@
             alpha_tasks: Vec::new(),
             screen_size,
             used_rect: DeviceIntRect::zero(),
+            allocator: GuillotineAllocator::new(Some(target_size)),
+            texture_id,
+            save_target: false,
         }
     }
 
+    fn allocate(
+        &mut self,
+        size: DeviceIntSize,
+    ) -> Option<(CacheTextureId, DeviceIntPoint)> {
+        self.allocator
+            .allocate(&size)
+            .map(|(_, origin)| {
+                (self.texture_id, origin)
+            })
+    }
+
     fn build(
         &mut self,
         ctx: &mut RenderTargetContext,
@@ -455,6 +441,14 @@
         }
     }
 
+    fn texture_id(&self) -> CacheTextureId {
+        self.texture_id
+    }
+
+    fn save_target(&self) -> bool {
+        self.save_target
+    }
+
     fn add_task(
         &mut self,
         task_id: RenderTaskId,
@@ -468,6 +462,8 @@
         profile_scope!("add_task");
         let task = &render_tasks[task_id];
 
+        self.save_target |= task.save_target;
+
         match task.kind {
             RenderTaskKind::VerticalBlur(..) => {
                 add_blur_instances(
@@ -602,10 +598,15 @@
     // we can set a scissor rect and only clear to the
     // used portion of the target as an optimization.
     pub used_rect: DeviceIntRect,
+    allocator: GuillotineAllocator,
+    pub texture_id: CacheTextureId,
+    save_target: bool,
 }
 
 impl RenderTarget for AlphaRenderTarget {
     fn new(
+        texture_id: CacheTextureId,
+        target_size: DeviceIntSize,
         _: DeviceIntSize,
         gpu_supports_fast_clears: bool,
     ) -> Self {
@@ -617,9 +618,31 @@
             zero_clears: Vec::new(),
             one_clears: Vec::new(),
             used_rect: DeviceIntRect::zero(),
+            allocator: GuillotineAllocator::new(Some(target_size)),
+            texture_id,
+            save_target: false,
         }
     }
 
+    fn allocate(
+        &mut self,
+        size: DeviceIntSize,
+    ) -> Option<(CacheTextureId, DeviceIntPoint)> {
+        self.allocator
+            .allocate(&size)
+            .map(|(_, origin)| {
+                (self.texture_id, origin)
+            })
+    }
+
+    fn texture_id(&self) -> CacheTextureId {
+        self.texture_id
+    }
+
+    fn save_target(&self) -> bool {
+        self.save_target
+    }
+
     fn add_task(
         &mut self,
         task_id: RenderTaskId,
@@ -634,6 +657,8 @@
         let task = &render_tasks[task_id];
         let (target_rect, _) = task.get_target_rect();
 
+        self.save_target |= task.save_target;
+
         match task.kind {
             RenderTaskKind::Readback |
             RenderTaskKind::Picture(..) |
@@ -881,7 +906,6 @@
 ) {
     let source = TextureSource::TextureCache(
         render_tasks[src_task_id].get_target_texture(),
-        ImageBufferKind::Texture2DArray,
         Swizzle::default(),
     );
 
@@ -945,7 +969,6 @@
             (
                 TextureSource::TextureCache(
                     source_task.unwrap().get_target_texture(),
-                    ImageBufferKind::Texture2DArray,
                     Swizzle::default(),
                 ),
                 source_task.unwrap().location.to_source_rect(),
@@ -979,7 +1002,6 @@
 
         textures.input.colors[0] = TextureSource::TextureCache(
             task.get_target_texture(),
-            ImageBufferKind::Texture2DArray,
             Swizzle::default(),
         );
     }
@@ -989,7 +1011,6 @@
 
         textures.input.colors[1] = TextureSource::TextureCache(
             task.get_target_texture(),
-            ImageBufferKind::Texture2DArray,
             Swizzle::default(),
         );
     }