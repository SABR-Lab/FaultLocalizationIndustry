# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/renderer.rs
# Commit: 15da94c6a7b1
# Full Hash: 15da94c6a7b19f971d3dffaa4cab8edb8e41cb62
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2020-12-15 09:29:54
# Regressor Bug: 1682365
# File Overlap Count: 1
# Description:
#   Bug 1682365 - Pt 2 - Remove texture array usage from render task graph. r=nical
#   
#   With this change, all color/alpha intermediate surfaces are individual
#   textures, rather than texture arrays.
#   
# ==============================================================================

diff -r 72ddac486037 -r 15da94c6a7b1 gfx/wr/webrender/src/renderer.rs
--- a/gfx/wr/webrender/src/renderer.rs	Tue Dec 15 01:46:51 2020 +0200
+++ b/gfx/wr/webrender/src/renderer.rs	Mon Dec 14 21:48:41 2020 +0000
@@ -1170,7 +1170,7 @@
     fn new(device: &mut Device) -> TextureResolver {
         let dummy_cache_texture = device
             .create_texture(
-                ImageBufferKind::Texture2DArray,
+                ImageBufferKind::Texture2D,
                 ImageFormat::RGBA8,
                 1,
                 1,
@@ -1233,7 +1233,7 @@
                 device.bind_external_texture(sampler, texture);
                 Swizzle::default()
             }
-            TextureSource::TextureCache(index, _, swizzle) => {
+            TextureSource::TextureCache(index, swizzle) => {
                 let texture = &self.texture_cache_map[&index];
                 device.bind_texture(sampler, texture, swizzle);
                 swizzle
@@ -1253,7 +1253,7 @@
             TextureSource::External(..) => {
                 panic!("BUG: External textures cannot be resolved, they can only be bound.");
             }
-            TextureSource::TextureCache(index, _, swizzle) => {
+            TextureSource::TextureCache(index, swizzle) => {
                 Some((&self.texture_cache_map[&index], swizzle))
             }
         }
@@ -4117,7 +4117,6 @@
 
         let texture_source = TextureSource::TextureCache(
             readback.get_target_texture(),
-            ImageBufferKind::Texture2DArray,
             Swizzle::default(),
         );
         let (cache_texture, _) = self.texture_resolver
@@ -4210,7 +4209,6 @@
                     let (source_rect, layer) = source.get_target_rect();
                     let source_texture = TextureSource::TextureCache(
                         source.get_target_texture(),
-                        ImageBufferKind::Texture2DArray,
                         Swizzle::default(),
                     );
                     (source_texture, layer.0, source_rect)
@@ -6027,13 +6025,10 @@
                 }
             }
 
-            for (target_index, target) in pass.alpha.targets.iter().enumerate() {
+            for target in &pass.alpha.targets {
                 results.stats.alpha_target_count += 1;
 
-                let texture_id = pass
-                    .alpha
-                    .texture_id
-                    .expect("bug: no surface for pass");
+                let texture_id = target.texture_id();
 
                 let alpha_tex = self.texture_resolver
                     .texture_cache_map
@@ -6042,7 +6037,7 @@
 
                 let draw_target = DrawTarget::from_texture(
                     alpha_tex,
-                    target_index,
+                    0,
                     false,
                 );
 
@@ -6066,13 +6061,10 @@
 
             let color_rt_info = RenderTargetInfo { has_depth: pass.color.needs_depth() };
 
-            for (target_index, target) in pass.color.targets.iter().enumerate() {
+            for target in &pass.color.targets {
                 results.stats.color_target_count += 1;
 
-                let texture_id = pass
-                    .color
-                    .texture_id
-                    .expect("bug: no surface for pass");
+                let texture_id = target.texture_id();
 
                 let color_tex = self.texture_resolver
                     .texture_cache_map
@@ -6086,7 +6078,7 @@
 
                 let draw_target = DrawTarget::from_texture(
                     color_tex,
-                    target_index,
+                    0,
                     target.needs_depth(),
                 );
 
@@ -7090,6 +7082,7 @@
     format: ImageFormat,
     filter: TextureFilter,
     has_depth: bool,
+    is_array: bool,
 }
 
 
@@ -7197,6 +7190,7 @@
             format: texture.get_format(),
             filter: texture.get_filter(),
             has_depth: texture.supports_depth(),
+            is_array: texture.is_array(),
         }
     }
 
@@ -7435,6 +7429,7 @@
                             format: descriptor.format,
                             filter,
                             has_depth: false,
+                            is_array: false,
                         };
                         let t = Self::load_texture(
                             target,
@@ -7464,8 +7459,13 @@
             }
             for (id, texture) in renderer.textures {
                 info!("\t{}", texture.data);
+                let target = if texture.is_array {
+                    ImageBufferKind::Texture2DArray
+                } else {
+                    ImageBufferKind::Texture2D
+                };
                 let t = Self::load_texture(
-                    ImageBufferKind::Texture2DArray,
+                    target,
                     &texture,
                     Some(RenderTargetInfo { has_depth: texture.has_depth }),
                     &root,