# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/renderer.rs
# Commit: ee0de0eac18d
# Full Hash: ee0de0eac18d1ba825467f6629ded5e613c56627
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2020-12-18 04:07:40
# Regressor Bug: 1682365
# File Overlap Count: 1
# Description:
#   Bug 1682365 - Pt 1 - Remove PrevPassAlpha and PrevPassColor r=nical
#   
#   Remove usage of the implicit prev pass alpha and color texture
#   samplers from batching / renderer / shader code. They are replaced
#   by explicit references to the texture ID for the source task.
# ==============================================================================

diff -r ecf2ab52eb03 -r ee0de0eac18d gfx/wr/webrender/src/renderer.rs
--- a/gfx/wr/webrender/src/renderer.rs	Thu Dec 17 22:10:02 2020 +0000
+++ b/gfx/wr/webrender/src/renderer.rs	Thu Dec 17 22:26:08 2020 +0000
@@ -73,7 +73,7 @@
 use crate::gpu_cache::{GpuBlockData, GpuCacheUpdate, GpuCacheUpdateList};
 use crate::gpu_cache::{GpuCacheDebugChunk, GpuCacheDebugCmd};
 use crate::gpu_types::{PrimitiveHeaderI, PrimitiveHeaderF, PrimitiveInstanceData, ScalingInstance, SvgFilterInstance};
-use crate::gpu_types::{ClearInstance, CompositeInstance, TransformData, ZBufferId};
+use crate::gpu_types::{ClearInstance, CompositeInstance, TransformData, ZBufferId, BlurInstance};
 use crate::internal_types::{TextureSource, ResourceCacheError};
 use crate::internal_types::{CacheTextureId, DebugOutput, FastHashMap, FastHashSet, LayerIndex, RenderedDocument, ResultMsg};
 use crate::internal_types::{TextureCacheAllocationKind, TextureCacheUpdate, TextureUpdateList, TextureUpdateSource};
@@ -359,8 +359,6 @@
     Color0,
     Color1,
     Color2,
-    PrevPassAlpha,
-    PrevPassColor,
     GpuCache,
     TransformPalette,
     RenderTasks,
@@ -389,15 +387,13 @@
             TextureSampler::Color0 => TextureSlot(0),
             TextureSampler::Color1 => TextureSlot(1),
             TextureSampler::Color2 => TextureSlot(2),
-            TextureSampler::PrevPassAlpha => TextureSlot(3),
-            TextureSampler::PrevPassColor => TextureSlot(4),
-            TextureSampler::GpuCache => TextureSlot(5),
-            TextureSampler::TransformPalette => TextureSlot(6),
-            TextureSampler::RenderTasks => TextureSlot(7),
-            TextureSampler::Dither => TextureSlot(8),
-            TextureSampler::PrimitiveHeadersF => TextureSlot(9),
-            TextureSampler::PrimitiveHeadersI => TextureSlot(10),
-            TextureSampler::ClipMask => TextureSlot(11),
+            TextureSampler::GpuCache => TextureSlot(3),
+            TextureSampler::TransformPalette => TextureSlot(4),
+            TextureSampler::RenderTasks => TextureSlot(5),
+            TextureSampler::Dither => TextureSlot(6),
+            TextureSampler::PrimitiveHeadersF => TextureSlot(7),
+            TextureSampler::PrimitiveHeadersI => TextureSlot(8),
+            TextureSampler::ClipMask => TextureSlot(9),
         }
     }
 }
@@ -1169,10 +1165,6 @@
     /// the output of the previous pass but are actually running in the first
     /// pass.
     dummy_cache_texture: Texture,
-
-    /// The outputs of the previous pass, if applicable.
-    prev_pass_color: Option<CacheTextureId>,
-    prev_pass_alpha: Option<CacheTextureId>,
 }
 
 impl TextureResolver {
@@ -1196,8 +1188,6 @@
             texture_cache_map: FastHashMap::default(),
             external_images: FastHashMap::default(),
             dummy_cache_texture,
-            prev_pass_alpha: None,
-            prev_pass_color: None,
         }
     }
 
@@ -1210,16 +1200,12 @@
     }
 
     fn begin_frame(&mut self) {
-        assert!(self.prev_pass_color.is_none());
-        assert!(self.prev_pass_alpha.is_none());
     }
 
     fn end_pass(
         &mut self,
         device: &mut Device,
         textures_to_invalidate: &[CacheTextureId],
-        a8_texture: Option<CacheTextureId>,
-        rgba8_texture: Option<CacheTextureId>,
     ) {
         // For any texture that is no longer needed, immediately
         // invalidate it so that tiled GPUs don't need to resolve it
@@ -1228,11 +1214,6 @@
             let render_target = &self.texture_cache_map[texture_id];
             device.invalidate_render_target(render_target);
         }
-
-        // We have another pass to process, make these textures available
-        // as inputs to the next pass.
-        self.prev_pass_color = rgba8_texture;
-        self.prev_pass_alpha = a8_texture;
     }
 
     // Bind a source texture to the device.
@@ -1246,24 +1227,6 @@
                 device.bind_texture(sampler, &self.dummy_cache_texture, swizzle);
                 swizzle
             }
-            TextureSource::PrevPassAlpha => {
-                let texture = match self.prev_pass_alpha {
-                    Some(ref id) => &self.texture_cache_map[id],
-                    None => &self.dummy_cache_texture,
-                };
-                let swizzle = Swizzle::default();
-                device.bind_texture(sampler, texture, swizzle);
-                swizzle
-            }
-            TextureSource::PrevPassColor => {
-                let texture = match self.prev_pass_color {
-                    Some(ref id) => &self.texture_cache_map[id],
-                    None => &self.dummy_cache_texture,
-                };
-                let swizzle = Swizzle::default();
-                device.bind_texture(sampler, texture, swizzle);
-                swizzle
-            }
             TextureSource::External(ref index, _) => {
                 let texture = self.external_images
                     .get(index)
@@ -1288,20 +1251,6 @@
             TextureSource::Dummy => {
                 Some((&self.dummy_cache_texture, Swizzle::default()))
             }
-            TextureSource::PrevPassAlpha => Some((
-                match self.prev_pass_alpha {
-                    Some(ref id) => &self.texture_cache_map[id],
-                    None => &self.dummy_cache_texture,
-                },
-                Swizzle::default(),
-            )),
-            TextureSource::PrevPassColor => Some((
-                match self.prev_pass_color {
-                    Some(ref id) => &self.texture_cache_map[id],
-                    None => &self.dummy_cache_texture,
-                },
-                Swizzle::default(),
-            )),
             TextureSource::External(..) => {
                 panic!("BUG: External textures cannot be resolved, they can only be bound.");
             }
@@ -4168,9 +4117,13 @@
             self.device.disable_scissor();
         }
 
+        let texture_source = TextureSource::TextureCache(
+            readback.get_target_texture(),
+            ImageBufferKind::Texture2DArray,
+            Swizzle::default(),
+        );
         let (cache_texture, _) = self.texture_resolver
-            .resolve(&TextureSource::PrevPassColor)
-            .unwrap();
+            .resolve(&texture_source).expect("bug: no source texture");
 
         // Before submitting the composite batch, do the
         // framebuffer readbacks that are needed for each
@@ -4257,7 +4210,12 @@
                     //           creating mips for alpha masks.
                     let source = &render_tasks[task_id];
                     let (source_rect, layer) = source.get_target_rect();
-                    (TextureSource::PrevPassColor, layer.0, source_rect)
+                    let source_texture = TextureSource::TextureCache(
+                        source.get_target_texture(),
+                        ImageBufferKind::Texture2DArray,
+                        Swizzle::default(),
+                    );
+                    (source_texture, layer.0, source_rect)
                 }
             };
 
@@ -5188,19 +5146,15 @@
                 .bind(&mut self.device, projection, &mut self.renderer_errors);
 
             if !target.vertical_blurs.is_empty() {
-                self.draw_instanced_batch(
+                self.draw_blurs(
                     &target.vertical_blurs,
-                    VertexArrayKind::Blur,
-                    &BatchTextures::empty(),
                     stats,
                 );
             }
 
             if !target.horizontal_blurs.is_empty() {
-                self.draw_instanced_batch(
+                self.draw_blurs(
                     &target.horizontal_blurs,
-                    VertexArrayKind::Blur,
-                    &BatchTextures::empty(),
                     stats,
                 );
             }
@@ -5237,6 +5191,25 @@
         }
     }
 
+    fn draw_blurs(
+        &mut self,
+        blurs: &FastHashMap<TextureSource, Vec<BlurInstance>>,
+        stats: &mut RendererStats,
+    ) {
+        for (texture, blurs) in blurs {
+            let textures = BatchTextures::composite_rgb(
+                *texture,
+            );
+
+            self.draw_instanced_batch(
+                blurs,
+                VertexArrayKind::Blur,
+                &textures,
+                stats,
+            );
+        }
+    }
+
     /// Draw all the instances in a clip batcher list to the current target.
     fn draw_clip_batch_list(
         &mut self,
@@ -5368,19 +5341,15 @@
                 .bind(&mut self.device, projection, &mut self.renderer_errors);
 
             if !target.vertical_blurs.is_empty() {
-                self.draw_instanced_batch(
+                self.draw_blurs(
                     &target.vertical_blurs,
-                    VertexArrayKind::Blur,
-                    &BatchTextures::empty(),
                     stats,
                 );
             }
 
             if !target.horizontal_blurs.is_empty() {
-                self.draw_instanced_batch(
+                self.draw_blurs(
                     &target.horizontal_blurs,
-                    VertexArrayKind::Blur,
-                    &BatchTextures::empty(),
                     stats,
                 );
             }
@@ -5602,10 +5571,8 @@
                 }.bind(&mut self.device, &projection, &mut self.renderer_errors);
             }
 
-            self.draw_instanced_batch(
+            self.draw_blurs(
                 &target.horizontal_blurs,
-                VertexArrayKind::Blur,
-                &BatchTextures::empty(),
                 stats,
             );
         }
@@ -5837,9 +5804,6 @@
         );
         self.current_vertex_data_textures =
             (self.current_vertex_data_textures + 1) % VERTEX_DATA_TEXTURE_COUNT;
-
-        debug_assert!(self.texture_resolver.prev_pass_alpha.is_none());
-        debug_assert!(self.texture_resolver.prev_pass_color.is_none());
     }
 
     fn update_native_surfaces(&mut self) {
@@ -5974,17 +5938,6 @@
             #[cfg(not(target_os = "android"))]
             let _gm = self.gpu_profiler.start_marker(&format!("pass {}", _pass_index));
 
-            self.texture_resolver.bind(
-                &TextureSource::PrevPassAlpha,
-                TextureSampler::PrevPassAlpha,
-                &mut self.device,
-            );
-            self.texture_resolver.bind(
-                &TextureSource::PrevPassColor,
-                TextureSampler::PrevPassColor,
-                &mut self.device,
-            );
-
             profile_scope!("offscreen target");
 
             // If this frame has already been drawn, then any texture
@@ -6173,8 +6126,6 @@
             self.texture_resolver.end_pass(
                 &mut self.device,
                 &pass.textures_to_invalidate,
-                pass.alpha.texture_id,
-                pass.color.texture_id,
             );
             {
                 profile_scope!("gl.flush");