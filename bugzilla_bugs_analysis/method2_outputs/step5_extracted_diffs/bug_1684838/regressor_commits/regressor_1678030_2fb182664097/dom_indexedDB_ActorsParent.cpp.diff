# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/indexedDB/ActorsParent.cpp
# Commit: 2fb182664097
# Full Hash: 2fb182664097f1b22021eec844d0d1adbffc40dc
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2020-12-05 09:38:58
# Regressor Bug: 1678030
# File Overlap Count: 1
# Description:
#   Bug 1678030 - Support multiple variants of hasResult expectations in CreateAndExecuteSingleStepStatement. r=dom-workers-and-storage-reviewers,ttung
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D97461
# ==============================================================================

diff -r 2ed5e139d784 -r 2fb182664097 dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp	Fri Dec 04 14:56:18 2020 +0000
+++ b/dom/indexedDB/ActorsParent.cpp	Fri Dec 04 15:10:07 2020 +0000
@@ -707,7 +707,7 @@
 
   IDB_TRY_INSPECT(
       const auto& journalMode,
-      MOZ_TO_RESULT_INVOKE_TYPED(nsCString, stmt, GetUTF8String, 0));
+      MOZ_TO_RESULT_INVOKE_TYPED(nsCString, *stmt, GetUTF8String, 0));
 
   if (journalMode.Equals(journalModeWAL)) {
     // WAL mode successfully enabled. Maybe set limits on its size here.
@@ -982,13 +982,13 @@
 #ifdef DEBUG
     if (!newDatabase) {
       // Re-enable foreign key support after doing a foreign key check.
-      nsCOMPtr<mozIStorageStatement> checkStmt;
-      MOZ_ALWAYS_SUCCEEDS(connection->CreateStatement(
-          "PRAGMA foreign_key_check;"_ns, getter_AddRefs(checkStmt)));
-
-      bool hasResult;
-      MOZ_ALWAYS_SUCCEEDS(checkStmt->ExecuteStep(&hasResult));
-      MOZ_ASSERT(!hasResult, "Database has inconsisistent foreign keys!");
+      IDB_TRY_INSPECT(const bool& foreignKeyError,
+                      CreateAndExecuteSingleStepStatement<
+                          SingleStepResult::ReturnNullIfNoResult>(
+                          *connection, "PRAGMA foreign_key_check;"_ns),
+                      QM_ASSERT_UNREACHABLE);
+
+      MOZ_ASSERT(!foreignKeyError, "Database has inconsisistent foreign keys!");
 
       MOZ_ALWAYS_SUCCEEDS(
           connection->ExecuteSimpleSQL("PRAGMA foreign_keys = OFF;"_ns));
@@ -1001,7 +1001,7 @@
                           *connection, "PRAGMA page_size;"_ns));
 
       IDB_TRY_INSPECT(const int32_t& pageSize,
-                      MOZ_TO_RESULT_INVOKE(stmt, GetInt32, 0));
+                      MOZ_TO_RESULT_INVOKE(*stmt, GetInt32, 0));
       MOZ_ASSERT(pageSize >= 512 && pageSize <= 65536);
 
       if (kSQLitePageSizeOverride != uint32_t(pageSize)) {
@@ -1015,7 +1015,7 @@
 
         IDB_TRY_INSPECT(
             const auto& journalMode,
-            MOZ_TO_RESULT_INVOKE_TYPED(nsCString, stmt, GetUTF8String, 0));
+            MOZ_TO_RESULT_INVOKE_TYPED(nsCString, *stmt, GetUTF8String, 0));
 
         if (journalMode.EqualsLiteral("delete")) {
           // Successfully set to rollback journal mode so changing the page size
@@ -14329,7 +14329,7 @@
                         aConnection, "PRAGMA integrity_check(1);"_ns));
 
     IDB_TRY_INSPECT(const auto& result,
-                    MOZ_TO_RESULT_INVOKE_TYPED(nsString, stmt, GetString, 0));
+                    MOZ_TO_RESULT_INVOKE_TYPED(nsString, *stmt, GetString, 0));
 
     IDB_TRY(OkIf(result.EqualsLiteral("ok")), NS_OK,
             [&aOk](const auto) { *aOk = false; });
@@ -14344,7 +14344,7 @@
                           CreateAndExecuteSingleStepStatement(
                               aConnection, "PRAGMA foreign_keys;"_ns));
 
-                      IDB_TRY_RETURN(MOZ_TO_RESULT_INVOKE(stmt, GetInt32, 0));
+                      IDB_TRY_RETURN(MOZ_TO_RESULT_INVOKE(*stmt, GetInt32, 0));
                     }()));
 
     if (!foreignKeysWereEnabled) {
@@ -14352,15 +14352,9 @@
     }
 
     IDB_TRY_INSPECT(const bool& foreignKeyError,
-                    ([&aConnection]() -> Result<bool, nsresult> {
-                      IDB_TRY_INSPECT(
-                          const auto& stmt,
-                          MOZ_TO_RESULT_INVOKE_TYPED(
-                              nsCOMPtr<mozIStorageStatement>, aConnection,
-                              CreateStatement, "PRAGMA foreign_key_check;"_ns));
-
-                      IDB_TRY_RETURN(MOZ_TO_RESULT_INVOKE(stmt, ExecuteStep));
-                    }()));
+                    CreateAndExecuteSingleStepStatement<
+                        SingleStepResult::ReturnNullIfNoResult>(
+                        aConnection, "PRAGMA foreign_key_check;"_ns));
 
     if (!foreignKeysWereEnabled) {
       IDB_TRY(aConnection.ExecuteSimpleSQL("PRAGMA foreign_keys = OFF;"_ns));
@@ -14413,10 +14407,10 @@
                       "FROM database;"_ns));
 
   IDB_TRY_INSPECT(const PRTime& lastVacuumTime,
-                  MOZ_TO_RESULT_INVOKE(stmt, GetInt64, 0));
+                  MOZ_TO_RESULT_INVOKE(*stmt, GetInt64, 0));
 
   IDB_TRY_INSPECT(const int64_t& lastVacuumSize,
-                  MOZ_TO_RESULT_INVOKE(stmt, GetInt64, 1));
+                  MOZ_TO_RESULT_INVOKE(*stmt, GetInt64, 1));
 
   NS_ASSERTION(lastVacuumSize > 0,
                "Thy last vacuum size shall be greater than zero, less than "
@@ -14457,7 +14451,7 @@
             "AND __ts1__.rowid = __ts2__.rowid + 1;"_ns));
 
     IDB_TRY_INSPECT(const int32_t& percentUnordered,
-                    MOZ_TO_RESULT_INVOKE(stmt, GetInt32, 0));
+                    MOZ_TO_RESULT_INVOKE(*stmt, GetInt32, 0));
 
     MOZ_ASSERT(percentUnordered >= 0);
     MOZ_ASSERT(percentUnordered <= 100);
@@ -14485,7 +14479,7 @@
                         aConnection, "PRAGMA freelist_count;"_ns));
 
     IDB_TRY_INSPECT(const int32_t& freelistCount,
-                    MOZ_TO_RESULT_INVOKE(stmt, GetInt32, 0));
+                    MOZ_TO_RESULT_INVOKE(*stmt, GetInt32, 0));
 
     MOZ_ASSERT(freelistCount >= 0);
 
@@ -14506,7 +14500,7 @@
             "SELECT SUM(unused) * 100.0 / SUM(pgsize) FROM __temp_stats__;"_ns));
 
     IDB_TRY_INSPECT(const int32_t& percentUnused,
-                    MOZ_TO_RESULT_INVOKE(stmt, GetInt32, 0));
+                    MOZ_TO_RESULT_INVOKE(*stmt, GetInt32, 0));
 
     MOZ_ASSERT(percentUnused >= 0);
     MOZ_ASSERT(percentUnused <= 100);
@@ -16450,14 +16444,11 @@
     // Load version information.
     IDB_TRY_INSPECT(
         const auto& stmt,
-        MOZ_TO_RESULT_INVOKE_TYPED(
-            nsCOMPtr<mozIStorageStatement>, aConnection, CreateStatement,
-            "SELECT name, origin, version FROM database"_ns));
-
-    IDB_TRY_INSPECT(const bool& hasResult,
-                    MOZ_TO_RESULT_INVOKE(stmt, ExecuteStep));
-
-    IDB_TRY(OkIf(hasResult), NS_ERROR_FILE_CORRUPTED);
+        CreateAndExecuteSingleStepStatement<
+            SingleStepResult::ReturnNullIfNoResult>(
+            aConnection, "SELECT name, origin, version FROM database"_ns));
+
+    IDB_TRY(OkIf(stmt), NS_ERROR_FILE_CORRUPTED);
 
     IDB_TRY_INSPECT(const auto& databaseName,
                     MOZ_TO_RESULT_INVOKE_TYPED(nsString, stmt, GetString, 0));
@@ -17391,18 +17382,13 @@
 
 #ifdef DEBUG
   {
-    nsCOMPtr<mozIStorageStatement> stmt;
-    rv = connection->CreateStatement("SELECT name FROM database"_ns,
-                                     getter_AddRefs(stmt));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
-    }
-
-    IDB_TRY_INSPECT(const bool& hasResult,
-                    MOZ_TO_RESULT_INVOKE(stmt, ExecuteStep), QM_VOID);
-    if (NS_WARN_IF(!hasResult)) {
-      return;
-    }
+    IDB_TRY_INSPECT(const auto& stmt,
+                    CreateAndExecuteSingleStepStatement<
+                        SingleStepResult::ReturnNullIfNoResult>(
+                        *connection, "SELECT name FROM database"_ns),
+                    QM_VOID);
+
+    IDB_TRY(OkIf(stmt), QM_VOID);
 
     nsString databaseName;
     rv = stmt->GetString(0, databaseName);
@@ -17414,19 +17400,13 @@
   }
 #endif
 
-  nsCOMPtr<mozIStorageStatement> stmt;
-  rv = connection->CreateStatement("SELECT version FROM database"_ns,
-                                   getter_AddRefs(stmt));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  IDB_TRY_INSPECT(const bool& hasResult,
-                  MOZ_TO_RESULT_INVOKE(stmt, ExecuteStep), QM_VOID);
-
-  if (NS_WARN_IF(!hasResult)) {
-    return;
-  }
+  IDB_TRY_INSPECT(const auto& stmt,
+                  CreateAndExecuteSingleStepStatement<
+                      SingleStepResult::ReturnNullIfNoResult>(
+                      *connection, "SELECT version FROM database"_ns),
+                  QM_VOID);
+
+  IDB_TRY(OkIf(stmt), QM_VOID);
 
   int64_t version;
   rv = stmt->GetInt64(0, &version);
@@ -18132,14 +18112,10 @@
   {
     IDB_TRY_INSPECT(
         const auto& pragmaStmt,
-        aConnection->BorrowCachedStatement("PRAGMA foreign_keys;"_ns),
+        CreateAndExecuteSingleStepStatement(
+            aConnection->MutableStorageConnection(), "PRAGMA foreign_keys;"_ns),
         QM_ASSERT_UNREACHABLE_VOID);
 
-    bool hasResult;
-    MOZ_ALWAYS_SUCCEEDS(pragmaStmt->ExecuteStep(&hasResult));
-
-    MOZ_ASSERT(hasResult);
-
     int32_t foreignKeysEnabled;
     MOZ_ALWAYS_SUCCEEDS(pragmaStmt->GetInt32(0, &foreignKeysEnabled));
 
@@ -18148,15 +18124,14 @@
   }
 
   {
-    IDB_TRY_INSPECT(
-        const auto& checkStmt,
-        aConnection->BorrowCachedStatement("PRAGMA foreign_key_check;"_ns),
-        QM_ASSERT_UNREACHABLE_VOID);
-
-    bool hasResult;
-    MOZ_ALWAYS_SUCCEEDS(checkStmt->ExecuteStep(&hasResult));
-
-    MOZ_ASSERT(!hasResult, "Database has inconsisistent foreign keys!");
+    IDB_TRY_INSPECT(const bool& foreignKeyError,
+                    CreateAndExecuteSingleStepStatement<
+                        SingleStepResult::ReturnNullIfNoResult>(
+                        aConnection->MutableStorageConnection(),
+                        "PRAGMA foreign_key_check;"_ns),
+                    QM_ASSERT_UNREACHABLE_VOID);
+
+    MOZ_ASSERT(!foreignKeyError, "Database has inconsisistent foreign keys!");
   }
 }
 