# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLContext.cpp
# Commit: 6149f5b15c5e
# Full Hash: 6149f5b15c5e278ef15ea36fa896fa8c146ebdca
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2021-01-14 08:32:45
# Regressor Bug: 1640607
# File Overlap Count: 1
# Description:
#   Bug 1640607 - Send SurfaceDescriptors for GPU blitting for video-to-webgl. r=lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101061
# ==============================================================================

diff -r 29fd3a6a7e27 -r 6149f5b15c5e dom/canvas/WebGLContext.cpp
--- a/dom/canvas/WebGLContext.cpp	Wed Jan 13 20:14:54 2021 +0000
+++ b/dom/canvas/WebGLContext.cpp	Wed Jan 13 21:49:40 2021 +0000
@@ -588,8 +588,25 @@
     printf_stderr("--- WebGL context created: %p\n", webgl.get());
   }
 
+  // -
+
+  const auto UploadableSdTypes = [&]() {
+    webgl::EnumMask<layers::SurfaceDescriptor::Type> types;
+    if (webgl->gl->IsANGLE()) {
+      types[layers::SurfaceDescriptor::TSurfaceDescriptorD3D10] = true;
+      types[layers::SurfaceDescriptor::TSurfaceDescriptorDXGIYCbCr] = true;
+    }
+    if (kIsMacOS) {
+      types[layers::SurfaceDescriptor::TSurfaceDescriptorMacIOSurface] = true;
+    }
+    return types;
+  };
+
+  // -
+
   out->options = webgl->mOptions;
   out->limits = *webgl->mLimits;
+  out->uploadableSdTypes = UploadableSdTypes();
 
   return webgl;
 }
@@ -1398,8 +1415,8 @@
   if (MOZ_LIKELY(mFuncScope)) {
     ret = mFuncScope->mFuncName;
   } else {
-    MOZ_ASSERT(false, "FuncScope not on stack!");
-    ret = "<funcName unknown>";
+    NS_WARNING("FuncScope not on stack!");
+    ret = "<unknown function>";
   }
   return ret;
 }
@@ -1504,12 +1521,20 @@
 
 // -
 
-void WebGLContext::GenerateErrorImpl(const GLenum err,
+void WebGLContext::GenerateErrorImpl(const GLenum errOrWarning,
                                      const std::string& text) const {
-  if (mFuncScope && mFuncScope->mBindFailureGuard) {
+  auto err = errOrWarning;
+  bool isPerfWarning = false;
+  if (err == webgl::kErrorPerfWarning) {
+    err = 0;
+    isPerfWarning = true;
+  }
+
+  if (err && mFuncScope && mFuncScope->mBindFailureGuard) {
     gfxCriticalError() << "mBindFailureGuard failure: Generating error "
                        << EnumString(err) << ": " << text;
   }
+
   /* ES2 section 2.5 "GL Errors" states that implementations can have
    * multiple 'flags', as errors might be caught in different parts of
    * a distributed implementation.
@@ -1520,18 +1545,39 @@
 
   if (!mHost) return;  // Impossible?
 
-  if (!ShouldGenerateWarnings()) return;
+  // -
 
-  mHost->JsWarning(text);
-  mWarningCount += 1;
+  const auto ShouldWarn = [&]() {
+    if (isPerfWarning) {
+      return ShouldGeneratePerfWarnings();
+    }
+    return ShouldGenerateWarnings();
+  };
+  if (!ShouldWarn()) return;
+
+  // -
 
-  if (!ShouldGenerateWarnings()) {
-    auto info = std::string(
-        "WebGL: No further warnings will be reported for this WebGL "
-        "context. (already reported ");
-    info += std::to_string(mWarningCount);
-    info += " warnings)";
-    mHost->JsWarning(info);
+  auto* pNumWarnings = &mWarningCount;
+  const char* warningsType = "warnings";
+  if (isPerfWarning) {
+    pNumWarnings = &mNumPerfWarnings;
+    warningsType = "perf warnings";
+  }
+
+  if (isPerfWarning) {
+    const auto perfText = std::string("WebGL perf warning: ") + text;
+    mHost->JsWarning(perfText);
+  } else {
+    mHost->JsWarning(text);
+  }
+  *pNumWarnings += 1;
+
+  if (!ShouldWarn()) {
+    const auto& msg = nsPrintfCString(
+        "After reporting %i, no further %s will be reported for this WebGL "
+        "context.",
+        int(*pNumWarnings), warningsType);
+    mHost->JsWarning(ToString(msg));
   }
 }
 