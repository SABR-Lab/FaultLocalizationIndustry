# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/WebGLTypes.h
# Commit: 6149f5b15c5e
# Full Hash: 6149f5b15c5e278ef15ea36fa896fa8c146ebdca
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2021-01-14 08:32:45
# Regressor Bug: 1640607
# File Overlap Count: 1
# Description:
#   Bug 1640607 - Send SurfaceDescriptors for GPU blitting for video-to-webgl. r=lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101061
# ==============================================================================

diff -r 29fd3a6a7e27 -r 6149f5b15c5e dom/canvas/WebGLTypes.h
--- a/dom/canvas/WebGLTypes.h	Wed Jan 13 20:14:54 2021 +0000
+++ b/dom/canvas/WebGLTypes.h	Wed Jan 13 21:49:40 2021 +0000
@@ -24,6 +24,7 @@
 #include "mozilla/gfx/Point.h"
 #include "mozilla/gfx/Rect.h"
 #include "mozilla/ipc/Shmem.h"
+#include "mozilla/layers/LayersSurfaces.h"
 #include "gfxTypes.h"
 
 #include "nsTArray.h"
@@ -298,6 +299,8 @@
 namespace webgl {
 struct FormatUsageInfo;
 
+static constexpr GLenum kErrorPerfWarning = 0x10001;
+
 struct SampleableInfo final {
   const char* incompleteReason = nullptr;
   uint32_t levels = 0;
@@ -536,11 +539,16 @@
   PixelPackState packState;
 };
 
-class ExtensionBits final {
+// -
+
+template <typename E>
+class EnumMask {
+ public:
   uint64_t mBits = 0;
 
+ private:
   struct BitRef final {
-    ExtensionBits& bits;
+    EnumMask& bits;
     const uint64_t mask;
 
     explicit operator bool() const { return bits.mBits & mask; }
@@ -555,15 +563,17 @@
     }
   };
 
-  uint64_t Mask(const WebGLExtensionID i) const {
+  uint64_t Mask(const E i) const {
     return uint64_t{1} << static_cast<uint64_t>(i);
   }
 
  public:
-  BitRef operator[](const WebGLExtensionID i) { return {*this, Mask(i)}; }
-  bool operator[](const WebGLExtensionID i) const { return mBits & Mask(i); }
+  BitRef operator[](const E i) { return {*this, Mask(i)}; }
+  bool operator[](const E i) const { return mBits & Mask(i); }
 };
 
+class ExtensionBits : public EnumMask<WebGLExtensionID> {};
+
 // -
 
 enum class ContextLossReason : uint8_t {
@@ -622,6 +632,7 @@
   std::string error;
   WebGLContextOptions options;
   webgl::Limits limits;
+  EnumMask<layers::SurfaceDescriptor::Type> uploadableSdTypes;
 };
 
 // -
@@ -970,9 +981,8 @@
   void Apply(gl::GLContext&, bool isWebgl2, const uvec3& uploadSize) const;
   bool AssertCurrent(gl::GLContext&, bool isWebgl2) const;
 
-  WebGLPixelStore ForUseWith(
-      const GLenum target, const uvec3& uploadSize,
-      const Maybe<gfx::IntSize>& structuredSrcSize) const {
+  WebGLPixelStore ForUseWith(const GLenum target, const uvec3& uploadSize,
+                             const Maybe<uvec2>& structuredSrcSize) const {
     auto ret = *this;
 
     if (!IsTexTarget3D(target)) {
@@ -981,7 +991,7 @@
     }
 
     if (structuredSrcSize) {
-      ret.mUnpackRowLength = structuredSrcSize->width;
+      ret.mUnpackRowLength = structuredSrcSize->x;
     }
 
     if (!ret.mUnpackRowLength) {
@@ -1043,8 +1053,11 @@
 
   Maybe<RawBuffer<>> cpuData;
   Maybe<uint64_t> pboOffset;
+
+  uvec2 imageSize;
   RefPtr<layers::Image> image;
-  RefPtr<gfx::DataSourceSurface> surf;
+  Maybe<layers::SurfaceDescriptor> sd;
+  RefPtr<gfx::DataSourceSurface> dataSurf;
 
   WebGLPixelStore unpacking;
 