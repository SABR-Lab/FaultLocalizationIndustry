# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/TexUnpackBlob.cpp
# Commit: 6149f5b15c5e
# Full Hash: 6149f5b15c5e278ef15ea36fa896fa8c146ebdca
# Author: Jeff Gilbert <jgilbert@mozilla.com>
# Date: 2021-01-14 08:32:45
# Regressor Bug: 1640607
# File Overlap Count: 1
# Description:
#   Bug 1640607 - Send SurfaceDescriptors for GPU blitting for video-to-webgl. r=lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101061
# ==============================================================================

diff -r 29fd3a6a7e27 -r 6149f5b15c5e dom/canvas/TexUnpackBlob.cpp
--- a/dom/canvas/TexUnpackBlob.cpp	Wed Jan 13 20:14:54 2021 +0000
+++ b/dom/canvas/TexUnpackBlob.cpp	Wed Jan 13 21:49:40 2021 +0000
@@ -358,10 +358,10 @@
         return nullptr;
     }
 
-    if (desc.image) {
+    if (desc.sd) {
       return new TexUnpackImage(desc);
     }
-    if (desc.surf) {
+    if (desc.dataSurf) {
       return new TexUnpackSurface(desc);
     }
 
@@ -675,10 +675,59 @@
                               const webgl::PackingInfo& pi) {
   if (!ValidatePIForDOM(webgl, pi)) return false;
 
-  const auto fullRows = mDesc.image->GetSize().height;
+  const auto fullRows = mDesc.imageSize.y;
   return ValidateUnpackPixels(webgl, fullRows, 0, this);
 }
 
+Maybe<std::string> BlitPreventReason(const int32_t level, const ivec3& offset,
+                                     const webgl::PackingInfo& pi,
+                                     const TexUnpackBlobDesc& desc) {
+  const auto& size = desc.size;
+  const auto& unpacking = desc.unpacking;
+
+  const auto ret = [&]() -> const char* {
+    if (size.z != 1) {
+      return "depth is not 1";
+    }
+    if (offset.x != 0 || offset.y != 0 || offset.z != 0) {
+      return "x/y/zOffset is not 0";
+    }
+
+    if (unpacking.mUnpackSkipPixels || unpacking.mUnpackSkipRows ||
+        unpacking.mUnpackSkipImages) {
+      return "non-zero UNPACK_SKIP_* not yet supported";
+    }
+
+    const auto premultReason = [&]() -> const char* {
+      if (desc.srcAlphaType == gfxAlphaType::Opaque) return nullptr;
+
+      const bool srcIsPremult = (desc.srcAlphaType == gfxAlphaType::Premult);
+      const auto& dstIsPremult = unpacking.mPremultiplyAlpha;
+      if (srcIsPremult == dstIsPremult) return nullptr;
+
+      if (dstIsPremult) {
+        return "UNPACK_PREMULTIPLY_ALPHA_WEBGL is not true";
+      } else {
+        return "UNPACK_PREMULTIPLY_ALPHA_WEBGL is not false";
+      }
+    }();
+    if (premultReason) return premultReason;
+
+    if (pi.format != LOCAL_GL_RGBA) {
+      return "`format` is not RGBA";
+    }
+
+    if (pi.type != LOCAL_GL_UNSIGNED_BYTE) {
+      return "`type` is not UNSIGNED_BYTE";
+    }
+    return nullptr;
+  }();
+  if (ret) {
+    return Some(std::string(ret));
+  }
+  return {};
+}
+
 bool TexUnpackImage::TexOrSubImage(bool isSubImage, bool needsRespec,
                                    WebGLTexture* tex, GLint level,
                                    const webgl::DriverUnpackInfo* dui,
@@ -690,11 +739,25 @@
   const auto& webgl = tex->mContext;
   const auto& target = mDesc.imageTarget;
   const auto& size = mDesc.size;
-  const auto& image = mDesc.image;
+  const auto& sd = *(mDesc.sd);
   const auto& unpacking = mDesc.unpacking;
 
   const auto& gl = webgl->GL();
 
+  // -
+
+  const auto reason =
+      BlitPreventReason(level, {xOffset, yOffset, zOffset}, pi, mDesc);
+  if (reason) {
+    webgl->GeneratePerfWarning(
+        "Failed to hit GPU-copy fast-path."
+        " (%s) Falling back to CPU upload.",
+        reason->c_str());
+    return false;
+  }
+
+  // -
+
   if (needsRespec) {
     *out_error =
         DoTexOrSubImage(isSubImage, gl, target, level, dui, xOffset, yOffset,
@@ -702,50 +765,7 @@
     if (*out_error) return true;
   }
 
-  const char* fallbackReason;
-  do {
-    if (size.z != 1) {
-      fallbackReason = "depth is not 1";
-      break;
-    }
-    if (xOffset != 0 || yOffset != 0 || zOffset != 0) {
-      fallbackReason = "x/y/zOffset is not 0";
-      break;
-    }
-
-    if (unpacking.mUnpackSkipPixels || unpacking.mUnpackSkipRows ||
-        unpacking.mUnpackSkipImages) {
-      fallbackReason = "non-zero UNPACK_SKIP_* not yet supported";
-      break;
-    }
-
-    const auto fnHasPremultMismatch = [&]() {
-      if (mDesc.srcAlphaType == gfxAlphaType::Opaque) return false;
-
-      const bool srcIsPremult = (mDesc.srcAlphaType == gfxAlphaType::Premult);
-      const auto& dstIsPremult = unpacking.mPremultiplyAlpha;
-      if (srcIsPremult == dstIsPremult) return false;
-
-      if (dstIsPremult) {
-        fallbackReason = "UNPACK_PREMULTIPLY_ALPHA_WEBGL is not true";
-      } else {
-        fallbackReason = "UNPACK_PREMULTIPLY_ALPHA_WEBGL is not false";
-      }
-      return true;
-    };
-    if (fnHasPremultMismatch()) break;
-
-    if (dui->unpackFormat != LOCAL_GL_RGB &&
-        dui->unpackFormat != LOCAL_GL_RGBA) {
-      fallbackReason = "`format` is not RGB or RGBA";
-      break;
-    }
-
-    if (dui->unpackType != LOCAL_GL_UNSIGNED_BYTE) {
-      fallbackReason = "`type` is not UNSIGNED_BYTE";
-      break;
-    }
-
+  {
     gl::ScopedFramebuffer scopedFB(gl);
     gl::ScopedBindFramebuffer bindFB(gl, scopedFB.FB());
 
@@ -756,62 +776,24 @@
                                 LOCAL_GL_COLOR_ATTACHMENT0, target,
                                 tex->mGLName, level);
 
-      if (errorScope.GetError()) {
-        fallbackReason = "bug: failed to attach to FB for blit";
-        break;
-      }
+      const auto err = errorScope.GetError();
+      MOZ_ALWAYS_TRUE(!err);
     }
 
     const GLenum status = gl->fCheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER);
-    if (status != LOCAL_GL_FRAMEBUFFER_COMPLETE) {
-      fallbackReason = "bug: failed to confirm FB for blit";
-      break;
-    }
+    MOZ_ALWAYS_TRUE(status == LOCAL_GL_FRAMEBUFFER_COMPLETE);
 
     const auto dstOrigin =
         (unpacking.mFlipY ? gl::OriginPos::TopLeft : gl::OriginPos::BottomLeft);
-    if (!gl->BlitHelper()->BlitImageToFramebuffer(image, {size.x, size.y},
-                                                  dstOrigin)) {
-      fallbackReason = "likely bug: failed to blit";
-      break;
+    if (!gl->BlitHelper()->BlitSdToFramebuffer(sd, {size.x, size.y},
+                                               dstOrigin)) {
+      webgl->ErrorImplementationBug("BlitSdToFramebuffer failed for type %i.",
+                                    int(sd.type()));
+      return false;
     }
-
-    // Blitting was successful, so we're done!
-    *out_error = 0;
-    return true;
-  } while (false);
-
-  const nsPrintfCString perfMsg(
-      "Failed to hit GPU-copy fast-path: %s (src type %u)", fallbackReason,
-      uint32_t(image->GetFormat()));
-
-  if (unpacking.mRequireFastPath) {
-    webgl->ErrorInvalidOperation("%s", perfMsg.BeginReading());
-    return false;
   }
 
-  webgl->GeneratePerfWarning("%s Falling back to CPU upload.",
-                             perfMsg.BeginReading());
-
-  const RefPtr<gfx::SourceSurface> surf = image->GetAsSourceSurface();
-
-  RefPtr<gfx::DataSourceSurface> dataSurf;
-  if (surf) {
-    // WARNING: OSX can lose our MakeCurrent here.
-    dataSurf = surf->GetDataSurface();
-  }
-  if (!dataSurf) {
-    webgl->ErrorOutOfMemory(
-        "GetAsSourceSurface or GetDataSurface failed after"
-        " blit failed for TexUnpackImage.");
-    return false;
-  }
-
-  const TexUnpackBlobDesc newDesc = {
-      target, size, mDesc.srcAlphaType, {}, {}, {}, dataSurf, unpacking};
-  const TexUnpackSurface surfBlob(newDesc);
-  return surfBlob.TexOrSubImage(isSubImage, needsRespec, tex, level, dui,
-                                xOffset, yOffset, zOffset, pi, out_error);
+  return true;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -875,7 +857,7 @@
                                 const webgl::PackingInfo& pi) {
   if (!ValidatePIForDOM(webgl, pi)) return false;
 
-  const auto fullRows = mDesc.surf->GetSize().height;
+  const auto fullRows = mDesc.dataSurf->GetSize().height;
   return ValidateUnpackPixels(webgl, fullRows, 0, this);
 }
 
@@ -888,7 +870,7 @@
                                      GLenum* const out_error) const {
   const auto& webgl = tex->mContext;
   const auto& size = mDesc.size;
-  auto& surf = *(mDesc.surf);
+  auto& surf = *(mDesc.dataSurf);
 
   ////
 