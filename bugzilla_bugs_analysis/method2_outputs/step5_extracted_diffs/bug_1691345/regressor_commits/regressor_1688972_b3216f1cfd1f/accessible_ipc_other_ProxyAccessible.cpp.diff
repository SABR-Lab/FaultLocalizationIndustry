# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/other/ProxyAccessible.cpp
# Commit: b3216f1cfd1f
# Full Hash: b3216f1cfd1f295a707bb089132f86c1e0770c8d
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2021-02-02 03:35:00
# Regressor Bug: 1688972
# File Overlap Count: 1
# Description:
#   Bug 1688972 - Make FocusedChild work across document/process boundaries. r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D103102
# ==============================================================================

diff -r 0a6d78effab1 -r b3216f1cfd1f accessible/ipc/other/ProxyAccessible.cpp
--- a/accessible/ipc/other/ProxyAccessible.cpp	Mon Feb 01 20:09:55 2021 +0100
+++ b/accessible/ipc/other/ProxyAccessible.cpp	Mon Feb 01 17:54:23 2021 +0000
@@ -762,10 +762,40 @@
 void ProxyAccessible::TakeFocus() { Unused << mDoc->SendTakeFocus(mID); }
 
 ProxyAccessible* ProxyAccessible::FocusedChild() {
-  uint64_t childID = 0;
-  bool ok = false;
-  Unused << mDoc->SendFocusedChild(mID, &childID, &ok);
-  return ok ? mDoc->GetAccessible(childID) : nullptr;
+  if (mOuterDoc) {
+    // If FocusedChild was called on an outer doc, it should behave
+    // like a non-doc accessible and return its focused child, or null.
+    // If the inner doc is OOP (fission), calling FocusedChild on the outer
+    // doc would return null.
+    MOZ_ASSERT(ChildrenCount() == 1);
+    ProxyAccessible* child = FirstChild();
+    MOZ_ASSERT(child->IsDoc());
+    return (child->State() & states::FOCUSED) ? child : nullptr;
+  }
+
+  auto* doc = mDoc;
+  uint64_t id = mID;
+  if (IsDoc()) {
+    // If this is a doc we should return the focused descendant, not just the
+    // direct child. In order to do that, we need to get a doc that is in
+    // the same process as the focused accessible. So we need the focused doc.
+    if (dom::BrowserParent* browser = dom::BrowserParent::GetFocused()) {
+      if (auto* focusedDoc = browser->GetTopLevelDocAccessible()) {
+        if (!focusedDoc->IsTopLevel()) {
+          // Redirect SendFocusedChild to OOP iframe doc.
+          doc = focusedDoc;
+        }
+      }
+    }
+  }
+
+  PDocAccessibleParent* resultDoc = nullptr;
+  uint64_t resultID = 0;
+  Unused << doc->SendFocusedChild(id, &resultDoc, &resultID);
+
+  auto* useDoc = static_cast<DocAccessibleParent*>(resultDoc);
+  // If useDoc is null, this means there is no focused child.
+  return useDoc ? useDoc->GetAccessible(resultID) : nullptr;
 }
 
 ProxyAccessible* ProxyAccessible::ChildAtPoint(