# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/other/ProxyAccessible.cpp
# Commit: 4572c1ba670a
# Full Hash: 4572c1ba670a3ddb159cf37ba9684fb6055f260e
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2021-01-30 05:43:48
# Regressor Bug: 1688972
# File Overlap Count: 1
# Description:
#   Bug 1688972 - Make FocusedChild work across document/process boundaries. r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D103102
# ==============================================================================

diff -r f262a5526f6c -r 4572c1ba670a accessible/ipc/other/ProxyAccessible.cpp
--- a/accessible/ipc/other/ProxyAccessible.cpp	Fri Jan 29 22:44:30 2021 +0200
+++ b/accessible/ipc/other/ProxyAccessible.cpp	Fri Jan 29 20:57:30 2021 +0000
@@ -762,10 +762,37 @@
 void ProxyAccessible::TakeFocus() { Unused << mDoc->SendTakeFocus(mID); }
 
 ProxyAccessible* ProxyAccessible::FocusedChild() {
-  uint64_t childID = 0;
-  bool ok = false;
-  Unused << mDoc->SendFocusedChild(mID, &childID, &ok);
-  return ok ? mDoc->GetAccessible(childID) : nullptr;
+  if (mOuterDoc) {
+    // If FocusedChild was called on an outer doc, it should behave
+    // like a non-doc accessible and return its focused child, or null.
+    // If the inner doc is OOP (fission), calling FocusedChild on the outer
+    // doc would return null.
+    MOZ_ASSERT(ChildrenCount() == 1);
+    ProxyAccessible* child = FirstChild();
+    MOZ_ASSERT(child->IsDoc());
+    return (child->State() & states::FOCUSED) ? child : nullptr;
+  }
+
+  auto* doc = mDoc;
+  uint64_t id = mID;
+  if (IsDoc()) {
+    // If this is a doc we should return the focused descendant, not just the
+    // direct child. In order to do that, we get the focused parent doc,
+    // which may be an OOP iframe.
+    if (dom::BrowserParent* browser = dom::BrowserParent::GetFocused()) {
+      if (auto* focusedDoc = browser->GetTopLevelDocAccessible()) {
+        doc = focusedDoc;
+      }
+    }
+  }
+
+  PDocAccessibleParent* resultDoc = nullptr;
+  uint64_t resultID = 0;
+  Unused << doc->SendFocusedChild(id, &resultDoc, &resultID);
+
+  auto* useDoc = static_cast<DocAccessibleParent*>(resultDoc);
+  // If useDoc is null, this means there is no focused child.
+  return useDoc ? useDoc->GetAccessible(resultID) : nullptr;
 }
 
 ProxyAccessible* ProxyAccessible::ChildAtPoint(