# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/GraphDriver.cpp
# Commit: 0ae30eae800d
# Full Hash: 0ae30eae800dcad73d997f9f12bb56eb537ef86c
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2020-11-06 04:14:34
# Regressor Bug: 1651745
# File Overlap Count: 1
# Description:
#   Bug 1651745 - Don't buffer more than necessary in AudioInputProcessing. r=padenot
#   
#   When opening a second input track, there will already be some data from its
#   first instantiation in the driver's scratch buffer. If we ignore this data, we
#   end up buffering too much in AudioInputProcessing::Pull and tripping an assert.
# ==============================================================================

diff -r a00ad7266f54 -r 0ae30eae800d dom/media/GraphDriver.cpp
--- a/dom/media/GraphDriver.cpp	Thu Nov 05 16:43:24 2020 +0000
+++ b/dom/media/GraphDriver.cpp	Thu Nov 05 16:44:00 2020 +0000
@@ -391,7 +391,8 @@
     MOZ_CRASH("Unexpected NotifyInputStopped from fallback SystemClockDriver");
   }
   void NotifyInputData(const AudioDataValue* aBuffer, size_t aFrames,
-                       TrackRate aRate, uint32_t aChannels) override {
+                       TrackRate aRate, uint32_t aChannels,
+                       uint32_t aAlreadyBuffered) override {
     MOZ_CRASH("Unexpected NotifyInputData from fallback SystemClockDriver");
   }
   void DeviceChanged() override {
@@ -906,7 +907,7 @@
   mBuffer.SetBuffer(aOutputBuffer, aFrames);
   // fill part or all with leftover data from last iteration (since we
   // align to Audio blocks)
-  mScratchBuffer.Empty(mBuffer);
+  uint32_t alreadyBuffered = mScratchBuffer.Empty(mBuffer);
 
   // State computed time is decided by the audio callback's buffer length. We
   // compute the iteration start and end from there, trying to keep the amount
@@ -945,7 +946,7 @@
   // Process mic data if any/needed
   if (aInputBuffer && mInputChannelCount > 0) {
     Graph()->NotifyInputData(aInputBuffer, static_cast<size_t>(aFrames),
-                             mSampleRate, mInputChannelCount);
+                             mSampleRate, mInputChannelCount, alreadyBuffered);
   }
 
   bool iterate = mBuffer.Available();