# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/gtest/TestAudioTrackGraph.cpp
# Commit: 605d00735b78
# Full Hash: 605d00735b78e13abd06eea9ece5ded79818801d
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2020-11-06 04:14:34
# Regressor Bug: 1651745
# File Overlap Count: 1
# Description:
#   Bug 1651745 - Use a dedicate ProcessedMediaTrack subclass for feeding microphone capture. r=padenot
#   
#   This was mainly driven by the need of querying this track for its channel count,
#   but it also moves us one usage away from SourceMediaTrack, which is a
#   longer-term goal (because of SourceMediaTrack::mMutex).
# ==============================================================================

diff -r eb376fd954e1 -r 605d00735b78 dom/media/gtest/TestAudioTrackGraph.cpp
--- a/dom/media/gtest/TestAudioTrackGraph.cpp	Thu Nov 05 16:42:07 2020 +0000
+++ b/dom/media/gtest/TestAudioTrackGraph.cpp	Thu Nov 05 16:42:20 2020 +0000
@@ -105,11 +105,15 @@
  * Common ControlMessages
  */
 class StartInputProcessing : public ControlMessage {
+  RefPtr<AudioInputTrack> mInputTrack;
   RefPtr<AudioInputProcessing> mInputProcessing;
 
  public:
-  explicit StartInputProcessing(AudioInputProcessing* aInputProcessing)
-      : ControlMessage(nullptr), mInputProcessing(aInputProcessing) {}
+  StartInputProcessing(AudioInputTrack* aTrack,
+                       AudioInputProcessing* aInputProcessing)
+      : ControlMessage(aTrack),
+        mInputTrack(aTrack),
+        mInputProcessing(aInputProcessing) {}
   void Run() override { mInputProcessing->Start(); }
 };
 
@@ -267,27 +271,24 @@
 
   // Dummy track to make graph rolling. Add it and remove it to remove the
   // graph from the global hash table and let it shutdown.
-  RefPtr<SourceMediaTrack> sourceTrack;
+  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioInputProcessing> listener;
   Unused << WaitFor(Invoke([&] {
-    sourceTrack = graph->CreateSourceTrack(MediaSegment::AUDIO);
-    return graph->NotifyWhenDeviceStarted(sourceTrack);
+    inputTrack = AudioInputTrack::Create(graph);
+    listener = new AudioInputProcessing(2, PRINCIPAL_HANDLE_NONE);
+    listener->SetPassThrough(true);
+    inputTrack->SetInputProcessing(listener);
+    inputTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(inputTrack, listener));
+    return graph->NotifyWhenDeviceStarted(inputTrack);
   }));
 
   // We open an input through this track so that there's something triggering
   // EnsureNextIteration on the fallback driver after the callback driver has
   // gotten the error.
-  RefPtr<AudioInputProcessing> listener;
-  RefPtr<AudioInputProcessingPullListener> pullListener;
   auto started = Invoke([&] {
-    listener = new AudioInputProcessing(2, sourceTrack, PRINCIPAL_HANDLE_NONE);
-    listener->SetPassThrough(true);
-    pullListener = new AudioInputProcessingPullListener(listener);
-    sourceTrack->AddListener(pullListener);
-    sourceTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(listener));
-    sourceTrack->SetPullingEnabled(true);
-    sourceTrack->OpenAudioInput((void*)1, listener);
-    return graph->NotifyWhenDeviceStarted(sourceTrack);
+    inputTrack->OpenAudioInput((void*)1, listener);
+    return graph->NotifyWhenDeviceStarted(inputTrack);
   });
 
   MockCubebStream* stream = WaitFor(cubeb->StreamInitEvent());
@@ -310,19 +311,17 @@
 
   // Clean up.
   DispatchFunction([&] {
-    sourceTrack->GraphImpl()->AppendMessage(
+    inputTrack->GraphImpl()->AppendMessage(
         MakeUnique<StopInputProcessing>(listener));
-    sourceTrack->RemoveListener(pullListener);
-    sourceTrack->SetPullingEnabled(false);
     Maybe<CubebUtils::AudioDeviceID> id =
         Some(reinterpret_cast<CubebUtils::AudioDeviceID>(1));
-    sourceTrack->CloseAudioInput(id);
-    sourceTrack->Destroy();
+    inputTrack->CloseAudioInput(id);
+    inputTrack->Destroy();
   });
   WaitFor(cubeb->StreamDestroyEvent());
 }
 
-TEST(TestAudioTrackGraph, SourceTrack)
+TEST(TestAudioTrackGraph, AudioInputTrack)
 {
   MockCubeb* cubeb = new MockCubeb();
   CubebUtils::ForceSetCubebContext(cubeb->AsCubebContext());
@@ -331,38 +330,31 @@
       MediaTrackGraph::AUDIO_THREAD_DRIVER, /*window*/ nullptr,
       MediaTrackGraph::REQUEST_DEFAULT_SAMPLE_RATE, nullptr);
 
-  RefPtr<SourceMediaTrack> sourceTrack;
+  RefPtr<AudioInputTrack> inputTrack;
   RefPtr<ProcessedMediaTrack> outputTrack;
   RefPtr<MediaInputPort> port;
+  RefPtr<AudioInputProcessing> listener;
   Unused << WaitFor(Invoke([&] {
-    sourceTrack = graph->CreateSourceTrack(MediaSegment::AUDIO);
+    inputTrack = AudioInputTrack::Create(graph);
     outputTrack = graph->CreateForwardedInputTrack(MediaSegment::AUDIO);
-    port = outputTrack->AllocateInputPort(sourceTrack);
-
+    outputTrack->QueueSetAutoend(false);
     outputTrack->AddAudioOutput(reinterpret_cast<void*>(1));
-
-    return graph->NotifyWhenDeviceStarted(sourceTrack);
+    port = outputTrack->AllocateInputPort(inputTrack);
+    /* Primary graph: Open Audio Input through SourceMediaTrack */
+    listener = new AudioInputProcessing(2, PRINCIPAL_HANDLE_NONE);
+    listener->SetPassThrough(true);
+    inputTrack->SetInputProcessing(listener);
+    inputTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(inputTrack, listener));
+    return graph->NotifyWhenDeviceStarted(inputTrack);
   }));
 
-  RefPtr<AudioInputProcessing> listener;
-  RefPtr<AudioInputProcessingPullListener> pullListener;
   DispatchFunction([&] {
-    /* Primary graph: Open Audio Input through SourceMediaTrack */
-    listener = new AudioInputProcessing(2, sourceTrack, PRINCIPAL_HANDLE_NONE);
-    listener->SetPassThrough(true);
-
-    pullListener = new AudioInputProcessingPullListener(listener);
-
-    sourceTrack->AddListener(pullListener);
-
-    sourceTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(listener));
-    sourceTrack->SetPullingEnabled(true);
     // Device id does not matter. Ignore.
-    sourceTrack->OpenAudioInput((void*)1, listener);
+    inputTrack->OpenAudioInput((void*)1, listener);
   });
 
-  auto p = Invoke([&] { return graph->NotifyWhenDeviceStarted(sourceTrack); });
+  auto p = Invoke([&] { return graph->NotifyWhenDeviceStarted(inputTrack); });
   MockCubebStream* stream = WaitFor(cubeb->StreamInitEvent());
   EXPECT_TRUE(stream->mHasInput);
   Unused << WaitFor(p);
@@ -372,7 +364,7 @@
   // Otherwise the audio driver might be going very fast while the fallback
   // system clock driver is still in an iteration.
   DispatchFunction([&] {
-    sourceTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   uint32_t totalFrames = 0;
   WaitUntil(stream->FramesProcessedEvent(), [&](uint32_t aFrames) {
@@ -386,14 +378,12 @@
     outputTrack->RemoveAudioOutput((void*)1);
     outputTrack->Destroy();
     port->Destroy();
-    sourceTrack->GraphImpl()->AppendMessage(
+    inputTrack->GraphImpl()->AppendMessage(
         MakeUnique<StopInputProcessing>(listener));
-    sourceTrack->RemoveListener(pullListener);
-    sourceTrack->SetPullingEnabled(false);
     Maybe<CubebUtils::AudioDeviceID> id =
         Some(reinterpret_cast<CubebUtils::AudioDeviceID>(1));
-    sourceTrack->CloseAudioInput(id);
-    sourceTrack->Destroy();
+    inputTrack->CloseAudioInput(id);
+    inputTrack->Destroy();
   });
 
   uint32_t inputRate = stream->InputSampleRate();
@@ -434,9 +424,16 @@
       MediaTrackGraph::GetInstance(MediaTrackGraph::AUDIO_THREAD_DRIVER,
                                    /*window*/ nullptr, aInputRate, nullptr);
 
-  RefPtr<SourceMediaTrack> sourceTrack;
-  DispatchFunction(
-      [&] { sourceTrack = primary->CreateSourceTrack(MediaSegment::AUDIO); });
+  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioInputProcessing> listener;
+  DispatchFunction([&] {
+    inputTrack = AudioInputTrack::Create(primary);
+    listener = new AudioInputProcessing(2, PRINCIPAL_HANDLE_NONE);
+    listener->SetPassThrough(true);
+    inputTrack->SetInputProcessing(listener);
+    inputTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(inputTrack, listener));
+  });
   WaitFor(cubeb->StreamInitEvent());
 
   /* Partner graph: Create graph and the CrossGraphReceiver. */
@@ -447,32 +444,20 @@
   RefPtr<CrossGraphReceiver> receiver;
   RefPtr<CrossGraphTransmitter> transmitter;
   RefPtr<MediaInputPort> port;
-  RefPtr<AudioInputProcessing> listener;
-  RefPtr<AudioInputProcessingPullListener> pullListener;
   DispatchFunction([&] {
     receiver = partner->CreateCrossGraphReceiver(primary->GraphRate());
 
     /* Primary graph: Create CrossGraphTransmitter */
     transmitter = primary->CreateCrossGraphTransmitter(receiver);
 
-    /* How the source track connects to another ProcessedMediaTrack.
+    /* How the input track connects to another ProcessedMediaTrack.
      * Check in MediaManager how it is connected to AudioStreamTrack. */
-    port = transmitter->AllocateInputPort(sourceTrack);
+    port = transmitter->AllocateInputPort(inputTrack);
     receiver->AddAudioOutput((void*)1);
 
     /* Primary graph: Open Audio Input through SourceMediaTrack */
-    listener = new AudioInputProcessing(2, sourceTrack, PRINCIPAL_HANDLE_NONE);
-    listener->SetPassThrough(true);
-
-    pullListener = new AudioInputProcessingPullListener(listener);
-
-    sourceTrack->AddListener(pullListener);
-
-    sourceTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(listener));
-    sourceTrack->SetPullingEnabled(true);
     // Device id does not matter. Ignore.
-    sourceTrack->OpenAudioInput((void*)1, listener);
+    inputTrack->OpenAudioInput((void*)1, listener);
   });
 
   MockCubebStream* inputStream = nullptr;
@@ -495,7 +480,7 @@
   // system clock driver is still in an iteration.
   // Wait for 3s worth of audio data on the receiver stream.
   DispatchFunction([&] {
-    sourceTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   uint32_t totalFrames = 0;
   WaitUntil(partnerStream->FramesProcessedEvent(), [&](uint32_t aFrames) {
@@ -510,14 +495,12 @@
     receiver->Destroy();
     transmitter->Destroy();
     port->Destroy();
-    sourceTrack->GraphImpl()->AppendMessage(
+    inputTrack->GraphImpl()->AppendMessage(
         MakeUnique<StopInputProcessing>(listener));
-    sourceTrack->RemoveListener(pullListener);
-    sourceTrack->SetPullingEnabled(false);
     Maybe<CubebUtils::AudioDeviceID> id =
         Some(reinterpret_cast<CubebUtils::AudioDeviceID>(1));
-    sourceTrack->CloseAudioInput(id);
-    sourceTrack->Destroy();
+    inputTrack->CloseAudioInput(id);
+    inputTrack->Destroy();
   });
 
   uint32_t inputFrequency = inputStream->InputFrequency();