# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/MediaEngineWebRTCAudio.h
# Commit: 605d00735b78
# Full Hash: 605d00735b78e13abd06eea9ece5ded79818801d
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2020-11-06 04:14:34
# Regressor Bug: 1651745
# File Overlap Count: 1
# Description:
#   Bug 1651745 - Use a dedicate ProcessedMediaTrack subclass for feeding microphone capture. r=padenot
#   
#   This was mainly driven by the need of querying this track for its channel count,
#   but it also moves us one usage away from SourceMediaTrack, which is a
#   longer-term goal (because of SourceMediaTrack::mMutex).
# ==============================================================================

diff -r eb376fd954e1 -r 605d00735b78 dom/media/webrtc/MediaEngineWebRTCAudio.h
--- a/dom/media/webrtc/MediaEngineWebRTCAudio.h	Thu Nov 05 16:42:07 2020 +0000
+++ b/dom/media/webrtc/MediaEngineWebRTCAudio.h	Thu Nov 05 16:42:20 2020 +0000
@@ -16,7 +16,7 @@
 namespace mozilla {
 
 class AudioInputProcessing;
-class AudioInputProcessingPullListener;
+class AudioInputTrack;
 
 // This class is created and used exclusively on the Media Manager thread, with
 // exactly two exceptions:
@@ -123,19 +123,12 @@
   // The current preferences for the APM's various processing stages.
   MediaEnginePrefs mCurrentPrefs;
 
-  // The SourecMediaTrack on which to append data for this microphone. Set in
+  // The AudioInputTrack used to inteface with the MediaTrackGraph. Set in
   // SetTrack as part of the initialization, and nulled in ::Deallocate.
-  RefPtr<SourceMediaTrack> mTrack;
+  RefPtr<AudioInputTrack> mTrack;
 
   // See note at the top of this class.
   RefPtr<AudioInputProcessing> mInputProcessing;
-
-  // The class receiving NotifyPull() from the MediaTrackGraph, and forwarding
-  // them on the graph thread. This is separated from AudioInputProcessing since
-  // both AudioDataListener (base class of AudioInputProcessing) and
-  // MediaTrackListener (base class of AudioInputProcessingPullListener)
-  // implement refcounting.
-  RefPtr<AudioInputProcessingPullListener> mPullListener;
 };
 
 // This class is created on the MediaManager thread, and then exclusively used
@@ -144,10 +137,10 @@
 class AudioInputProcessing : public AudioDataListener {
  public:
   AudioInputProcessing(uint32_t aMaxChannelCount,
-                       RefPtr<SourceMediaTrack> aTrack,
                        const PrincipalHandle& aPrincipalHandle);
 
-  void Pull(TrackTime aEndOfAppendedData, TrackTime aDesiredTime);
+  void Pull(MediaTrackGraphImpl* aGraph, GraphTime aFrom, GraphTime aTo,
+            GraphTime aTrackEnd, AudioSegment* aSegment, bool* aEnded);
 
   void NotifyOutputData(MediaTrackGraphImpl* aGraph, AudioDataValue* aBuffer,
                         size_t aFrames, TrackRate aRate,
@@ -168,22 +161,24 @@
 
   void DeviceChanged(MediaTrackGraphImpl* aGraph) override;
 
-  uint32_t RequestedInputChannelCount(MediaTrackGraphImpl* aGraph) override {
-    return GetRequestedInputChannelCount(aGraph);
+  uint32_t RequestedInputChannelCount(MediaTrackGraphImpl*) override {
+    return GetRequestedInputChannelCount();
   }
 
   void Disconnect(MediaTrackGraphImpl* aGraph) override;
 
   template <typename T>
-  void InsertInGraph(const T* aBuffer, size_t aFrames, uint32_t aChannels);
+  void InsertInGraph(MediaTrackGraphImpl* aGraph, const T* aBuffer,
+                     size_t aFrames, uint32_t aChannels);
 
   void PacketizeAndProcess(MediaTrackGraphImpl* aGraph,
                            const AudioDataValue* aBuffer, size_t aFrames,
                            TrackRate aRate, uint32_t aChannels);
 
   void SetPassThrough(bool aPassThrough);
-  uint32_t GetRequestedInputChannelCount(MediaTrackGraphImpl* aGraphImpl);
-  void SetRequestedInputChannelCount(uint32_t aRequestedInputChannelCount);
+  uint32_t GetRequestedInputChannelCount();
+  void SetRequestedInputChannelCount(MediaTrackGraphImpl* aGraph,
+                                     uint32_t aRequestedInputChannelCount);
   // This is true when all processing is disabled, we can skip
   // packetization, resampling and other processing passes.
   bool PassThrough(MediaTrackGraphImpl* aGraphImpl) const;
@@ -202,7 +197,6 @@
 
  private:
   ~AudioInputProcessing() = default;
-  const RefPtr<SourceMediaTrack> mTrack;
   // This implements the processing algoritm to apply to the input (e.g. a
   // microphone). If all algorithms are disabled, this class in not used. This
   // class only accepts audio chunks of 10ms. It has two inputs and one output:
@@ -232,6 +226,8 @@
   AlignedFloatBuffer mDeinterleavedBuffer;
   // Stores the mixed down input audio
   AlignedFloatBuffer mInputDownmixBuffer;
+  // Stores data waiting to be pulled.
+  AudioSegment mSegment;
 #ifdef DEBUG
   // The MTGImpl::IterationEnd() of the last time we appended data from an
   // audio callback.
@@ -249,30 +245,55 @@
   // operates in "pull" mode, and we append silence only, releasing the audio
   // input track.
   bool mEnabled;
-  // Whether or not we've ended and removed the track in the SourceMediaTrack
+  // Whether or not we've ended and removed the AudioInputTrack.
   bool mEnded;
 };
 
-// This class is created on the media thread, as part of Start(), then entirely
-// self-sustained until destruction, just forwarding calls to Pull().
-class AudioInputProcessingPullListener : public MediaTrackListener {
+// MediaTrack subclass tailored for MediaEngineWebRTCMicrophoneSource.
+class AudioInputTrack : public ProcessedMediaTrack {
+  // Only accessed on the graph thread.
+  RefPtr<AudioInputProcessing> mInputProcessing;
+
+  // Only accessed on the main thread. Used for bookkeeping on main thread, such
+  // that CloseAudioInput can be idempotent.
+  // XXX Should really be a CubebUtils::AudioDeviceID, but they aren't
+  // copyable (opaque pointers)
+  RefPtr<AudioDataListener> mInputListener;
+
+  explicit AudioInputTrack(TrackRate aSampleRate)
+      : ProcessedMediaTrack(aSampleRate, MediaSegment::AUDIO,
+                            new AudioSegment()) {}
+
+  ~AudioInputTrack() = default;
+
  public:
-  explicit AudioInputProcessingPullListener(
-      RefPtr<AudioInputProcessing> aInputProcessing)
-      : mInputProcessing(std::move(aInputProcessing)) {
-    MOZ_COUNT_CTOR(AudioInputProcessingPullListener);
+  // Main Thread API
+  // Users of audio inputs go through the track so it can track when the
+  // last track referencing an input goes away, so it can close the cubeb
+  // input. Main thread only.
+  nsresult OpenAudioInput(CubebUtils::AudioDeviceID aId,
+                          AudioDataListener* aListener);
+  void CloseAudioInput(Maybe<CubebUtils::AudioDeviceID>& aId);
+  void Destroy() override;
+  void SetInputProcessing(RefPtr<AudioInputProcessing> aInputProcessing);
+  static AudioInputTrack* Create(MediaTrackGraph* aGraph);
+
+  // Graph Thread API
+  void DestroyImpl() override;
+  void ProcessInput(GraphTime aFrom, GraphTime aTo, uint32_t aFlags) override;
+  uint32_t NumberOfChannels() const override {
+    MOZ_DIAGNOSTIC_ASSERT(
+        mInputProcessing,
+        "Must set mInputProcessing before exposing to content");
+    return mInputProcessing->GetRequestedInputChannelCount();
   }
 
-  ~AudioInputProcessingPullListener() {
-    MOZ_COUNT_DTOR(AudioInputProcessingPullListener);
-  }
+  // Any thread
+  AudioInputTrack* AsAudioInputTrack() override { return this; }
 
-  void NotifyPull(MediaTrackGraph* aGraph, TrackTime aEndOfAppendedData,
-                  TrackTime aDesiredTime) override {
-    mInputProcessing->Pull(aEndOfAppendedData, aDesiredTime);
-  }
-
-  const RefPtr<AudioInputProcessing> mInputProcessing;
+ private:
+  // Graph thread API
+  void SetInputProcessingImpl(RefPtr<AudioInputProcessing> aInputProcessing);
 };
 
 class MediaEngineWebRTCAudioCaptureSource : public MediaEngineSource {
