# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCSSFrameConstructor.cpp
# Commit: 867abe6c80a3
# Full Hash: 867abe6c80a36d66fec92f276c3a7d7c315637bf
# Author: Mats Palmgren <mats@mozilla.com>
# Date: 2021-03-01 09:36:12
# Description:
#   Bug 1694459 - Deal with 'display:contents' style changes on <fieldset> descendants better where it affects which <legend> is the rendered legend.  r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D106566
# ==============================================================================

diff -r 77247863a2ea -r 867abe6c80a3 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Mon Mar 01 01:16:36 2021 +0000
+++ b/layout/base/nsCSSFrameConstructor.cpp	Mon Mar 01 03:42:41 2021 +0000
@@ -3288,15 +3288,15 @@
 #define COMPLEX_TAG_CREATE(_tag, _func) \
   { nsGkAtoms::_tag, FULL_CTOR_FCDATA(0, _func) }
 
-static bool IsFrameForFieldSet(nsIFrame* aFrame) {
+static nsFieldSetFrame* GetFieldSetFrameFor(nsIFrame* aFrame) {
   auto pseudo = aFrame->Style()->GetPseudoType();
   if (pseudo == PseudoStyleType::fieldsetContent ||
       pseudo == PseudoStyleType::scrolledContent ||
       pseudo == PseudoStyleType::columnSet ||
       pseudo == PseudoStyleType::columnContent) {
-    return IsFrameForFieldSet(aFrame->GetParent());
-  }
-  return aFrame->IsFieldSetFrame();
+    return GetFieldSetFrameFor(aFrame->GetParent());
+  }
+  return do_QueryFrame(aFrame);
 }
 
 /* static */
@@ -5306,12 +5306,14 @@
     return;
   }
 
-  if (aContent->IsHTMLElement(nsGkAtoms::legend) && aParentFrame &&
-      IsFrameForFieldSet(aParentFrame) && !aState.mHasRenderedLegend &&
-      !aComputedStyle->StyleDisplay()->IsFloatingStyle() &&
-      !aComputedStyle->StyleDisplay()->IsAbsolutelyPositionedStyle()) {
-    aState.mHasRenderedLegend = true;
-    aFlags += ItemFlag::IsForRenderedLegend;
+  if (aContent->IsHTMLElement(nsGkAtoms::legend) && aParentFrame) {
+    const nsFieldSetFrame* fs = GetFieldSetFrameFor(aParentFrame);
+    if (fs && !fs->GetLegend() && !aState.mHasRenderedLegend &&
+        !aComputedStyle->StyleDisplay()->IsFloatingStyle() &&
+        !aComputedStyle->StyleDisplay()->IsAbsolutelyPositionedStyle()) {
+      aState.mHasRenderedLegend = true;
+      aFlags += ItemFlag::IsForRenderedLegend;
+    }
   }
 
   const FrameConstructionData* data =
@@ -6922,7 +6924,14 @@
   // fieldsets have multiple insertion points.
   NS_ASSERTION(isSingleInsert || frameType != LayoutFrameType::FieldSet,
                "Unexpected parent");
-  if (IsFrameForFieldSet(insertion.mParentFrame) &&
+  // Note that this check is insufficient if aStartChild is not a legend with
+  // display::contents that contains a legend.  We'll catch that case in
+  // WipeContainingBlock. (That code would also catch this case, but handling
+  // this early is slightly faster.)
+  // XXXmats we should be able to optimize this when the fieldset doesn't
+  // currently have a rendered legend.  ContentRangeInserted needs to be fixed
+  // to use the inner frame as the content insertion frame in that case.
+  if (GetFieldSetFrameFor(insertion.mParentFrame) &&
       aStartChild->NodeInfo()->NameAtom() == nsGkAtoms::legend) {
     // Just reframe the parent, since figuring out whether this
     // should be the new legend and then handling it is too complex.
@@ -9303,17 +9312,15 @@
       if (iter.item().mIsRenderedLegend) {
         // This makes the rendered legend the first frame in the fieldset child
         // list which makes keyboard traversal follow the visual order.
-        nsContainerFrame* fieldSetFrame = aParentFrame->GetParent();
-        while (!fieldSetFrame->IsFieldSetFrame()) {
-          fieldSetFrame = fieldSetFrame->GetParent();
-        }
+        nsFieldSetFrame* fieldSetFrame = GetFieldSetFrameFor(aParentFrame);
         nsFrameList renderedLegend;
         ConstructFramesFromItem(aState, iter, fieldSetFrame, renderedLegend);
         MOZ_ASSERT(
             renderedLegend.FirstChild() &&
                 renderedLegend.FirstChild() == renderedLegend.LastChild(),
             "a rendered legend should have exactly one frame");
-        fieldSetFrame->SetInitialChildList(kPrincipalList, renderedLegend);
+        fieldSetFrame->InsertFrames(kPrincipalList, nullptr, nullptr,
+                                    renderedLegend);
         FCItemIterator next = iter;
         next.Next();
         iter.DeleteItemsTo(this, next);
@@ -11371,6 +11378,30 @@
     // that is not part of an {ib} split, but should become an {ib} split.
   }
 
+  // A <fieldset> may need to pick up a new rendered legend from aItems.
+  // We currently can't handle this case without recreating frames for
+  // the fieldset.
+  // XXXmats we should be able to optimize this when the fieldset doesn't
+  // currently have a rendered legend.  ContentRangeInserted needs to be fixed
+  // to use the inner frame as the content insertion frame in that case.
+  if (const auto* fieldset = GetFieldSetFrameFor(aFrame)) {
+    // Check if any item is eligible to be a rendered legend.
+    for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
+      const auto& item = iter.item();
+      if (!item.mContent->IsHTMLElement(nsGkAtoms::legend)) {
+        continue;
+      }
+      const auto* display = item.mComputedStyle->StyleDisplay();
+      if (display->IsFloatingStyle() ||
+          display->IsAbsolutelyPositionedStyle()) {
+        continue;
+      }
+      TRACE("Fieldset with rendered legend");
+      RecreateFramesForContent(fieldset->GetContent(), InsertionKind::Async);
+      return true;
+    }
+  }
+
   // Now we have several cases involving {ib} splits.  Put them all in a
   // do/while with breaks to take us to the "go and reconstruct" code.
   do {