# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCSSFrameConstructor.cpp
# Commit: 6141de941e71
# Full Hash: 6141de941e717cdb5485e1aa1ca00ffcd74f8a81
# Author: Mats Palmgren <mats@mozilla.com>
# Date: 2021-01-30 19:41:15
# Regressor Bug: 1683748
# File Overlap Count: 3
# Description:
#   Bug 1683748 - Support Grid/Flex/Table/Column layout for the rendered legend of a fieldset.  r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101555
# ==============================================================================

diff -r 3cf752580f1b -r 6141de941e71 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Fri Jan 29 19:20:24 2021 +0000
+++ b/layout/base/nsCSSFrameConstructor.cpp	Sat Jan 30 13:47:10 2021 +0000
@@ -702,6 +702,10 @@
   // mode).
   bool mCreatingExtraFrames;
 
+  // This keeps track of whether we have found a "rendered legend" for
+  // the current FieldSetFrame.
+  bool mHasRenderedLegend;
+
   nsTArray<RefPtr<nsIContent>> mGeneratedContentWithInitializer;
 
   // Constructor
@@ -851,7 +855,8 @@
       // frames.
       mFixedPosIsAbsPos(aFixedContainingBlock == aAbsoluteContainingBlock),
       mHavePendingPopupgroup(false),
-      mCreatingExtraFrames(false) {
+      mCreatingExtraFrames(false),
+      mHasRenderedLegend(false) {
 #ifdef MOZ_XUL
   nsIPopupContainer* popupContainer =
       nsIPopupContainer::GetPopupContainer(aPresShell);
@@ -3048,35 +3053,16 @@
                                        absoluteSaveState);
   }
 
-  ProcessChildren(aState, content, computedStyle, contentFrame, true, childList,
-                  true);
-
+  {
+    AutoRestore<bool> savedHasRenderedLegend(aState.mHasRenderedLegend);
+    aState.mHasRenderedLegend = false;
+    ProcessChildren(aState, content, computedStyle, contentFrame, true,
+                    childList, true);
+  }
   nsFrameList fieldsetKids;
   fieldsetKids.AppendFrame(nullptr,
                            scrollFrame ? scrollFrame : contentFrameTop);
 
-  for (nsFrameList::Enumerator e(childList); !e.AtEnd(); e.Next()) {
-    nsIFrame* child = e.get();
-    nsContainerFrame* cif = child->GetContentInsertionFrame();
-    if (cif && cif->IsLegendFrame()) {
-      // We want the legend to be the first frame in the fieldset child list.
-      // That way the EventStateManager will do the right thing when tabbing
-      // from a selection point within the legend (bug 236071), which is
-      // used for implementing legend access keys (bug 81481).
-      // GetAdjustedParentFrame() below depends on this frame order.
-      childList.RemoveFrame(child);
-      // Make sure to reparent the legend so it has the fieldset as the parent.
-      fieldsetKids.InsertFrame(fieldsetFrame, nullptr, child);
-      // Legend is no longer in the multicol container. Remove the bit.
-      child->RemoveStateBits(NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR);
-      if (scrollFrame) {
-        StickyScrollContainer::NotifyReparentedFrameAcrossScrollFrameBoundary(
-            child, contentFrame);
-      }
-      break;
-    }
-  }
-
   if (!MayNeedToCreateColumnSpanSiblings(contentFrame, childList)) {
     // Set the inner frame's initial child lists.
     contentFrame->SetInitialChildList(kPrincipalList, childList);
@@ -3102,10 +3088,10 @@
     FinishBuildingScrollFrame(scrollFrame, contentFrameTop);
   }
 
-  // Set the outer frame's initial child list
-  fieldsetFrame->SetInitialChildList(kPrincipalList, fieldsetKids);
-
-  // Our new frame returned is the outer frame, which is the fieldset frame.
+  // We use AppendFrames here because the rendered legend will already
+  // be present in the principal child list if it exists.
+  fieldsetFrame->AppendFrames(nsIFrame::kNoReflowPrincipalList, fieldsetKids);
+
   return fieldsetFrame;
 }
 
@@ -3329,25 +3315,11 @@
                                     nsIFrame* aParentFrame,
                                     ComputedStyle& aStyle) {
   MOZ_ASSERT(aElement.IsHTMLElement());
-
-  nsAtom* tag = aElement.NodeInfo()->NameAtom();
   NS_ASSERTION(!aParentFrame ||
                    aParentFrame->Style()->GetPseudoType() !=
                        PseudoStyleType::fieldsetContent ||
                    aParentFrame->GetParent()->IsFieldSetFrame(),
                "Unexpected parent for fieldset content anon box");
-  if (tag == nsGkAtoms::legend &&
-      (!aParentFrame || !IsFrameForFieldSet(aParentFrame) ||
-       aStyle.StyleDisplay()->IsFloatingStyle() ||
-       aStyle.StyleDisplay()->IsAbsolutelyPositionedStyle())) {
-    // <legend> is only special inside fieldset, we only check the frame tree
-    // parent because the content tree parent may not be a <fieldset> due to
-    // display:contents, or Shadow DOM. For floated or absolutely positioned
-    // legends we want to construct by display type and not do special legend
-    // stuff.
-    return nullptr;
-  }
-
   static const FrameConstructionDataByTag sHTMLData[] = {
       SIMPLE_TAG_CHAIN(img, nsCSSFrameConstructor::FindImgData),
       SIMPLE_TAG_CHAIN(mozgeneratedcontentimage,
@@ -3363,9 +3335,6 @@
       SIMPLE_TAG_CHAIN(embed, nsCSSFrameConstructor::FindObjectData),
       COMPLEX_TAG_CREATE(fieldset,
                          &nsCSSFrameConstructor::ConstructFieldSetFrame),
-      {nsGkAtoms::legend,
-       FCDATA_DECL(FCDATA_ALLOW_BLOCK_STYLES | FCDATA_MAY_NEED_SCROLLFRAME,
-                   NS_NewLegendFrame)},
       SIMPLE_TAG_CREATE(frameset, NS_NewHTMLFramesetFrame),
       SIMPLE_TAG_CREATE(iframe, NS_NewSubDocumentFrame),
       {nsGkAtoms::button,
@@ -5248,6 +5217,17 @@
     return &sImgData;
   }
 
+  if (aFlags.contains(ItemFlag::IsForRenderedLegend) &&
+      !aStyle.StyleDisplay()->IsBlockOutsideStyle()) {
+    // Make a temp copy of StyleDisplay and blockify its mDisplay value.
+    auto display = *aStyle.StyleDisplay();
+    bool isRootElement = false;
+    uint16_t rawDisplayValue =
+        Servo_ComputedValues_BlockifiedDisplay(&aStyle, isRootElement);
+    display.mDisplay = StyleDisplay(rawDisplayValue);
+    return FindDisplayData(display, aElement);
+  }
+
   const auto& display = *aStyle.StyleDisplay();
   return FindDisplayData(display, aElement);
 }
@@ -5359,6 +5339,14 @@
     return;
   }
 
+  if (aContent->IsHTMLElement(nsGkAtoms::legend) && aParentFrame &&
+      IsFrameForFieldSet(aParentFrame) && !aState.mHasRenderedLegend &&
+      !aComputedStyle->StyleDisplay()->IsFloatingStyle() &&
+      !aComputedStyle->StyleDisplay()->IsAbsolutelyPositionedStyle()) {
+    aState.mHasRenderedLegend = true;
+    aFlags += ItemFlag::IsForRenderedLegend;
+  }
+
   const FrameConstructionData* data =
       FindDataForContent(*aContent, *aComputedStyle, aParentFrame, aFlags);
   if (!data || data->mBits & FCDATA_SUPPRESS_FRAME) {
@@ -5411,6 +5399,9 @@
   if (!item) {
     item = aItems.AppendItem(this, data, aContent, do_AddRef(aComputedStyle),
                              aSuppressWhiteSpaceOptimizations);
+    if (aFlags.contains(ItemFlag::IsForRenderedLegend)) {
+      item->mIsRenderedLegend = true;
+    }
   }
   item->mIsText = !aContent->IsElement();
   item->mIsGeneratedContent = isGeneratedContent;
@@ -5969,20 +5960,6 @@
     // below.
   }
 
-  if (IsFrameForFieldSet(parentFrame)) {
-    // Legends can be sibling of legends but not of other content in the
-    // fieldset
-    if (nsContainerFrame* cif = aSibling->GetContentInsertionFrame()) {
-      aSibling = cif;
-    }
-    LayoutFrameType sibType = aSibling->Type();
-    bool legendContent = aContent->IsHTMLElement(nsGkAtoms::legend);
-
-    if ((legendContent && (LayoutFrameType::Legend != sibType)) ||
-        (!legendContent && (LayoutFrameType::Legend == sibType)))
-      return false;
-  }
-
   return true;
 }
 
@@ -6070,6 +6047,10 @@
     return nullptr;
   }
 
+  if (aSibling->IsRenderedLegend()) {
+    return nullptr;
+  }
+
   if (aSibling->HasAnyStateBits(NS_FRAME_OUT_OF_FLOW)) {
     aSibling = aSibling->GetPlaceholderFrame();
     MOZ_ASSERT(aSibling);
@@ -7984,9 +7965,6 @@
   } else if (LayoutFrameType::FieldSet == frameType) {
     newFrame = NS_NewFieldSetFrame(mPresShell, computedStyle);
     newFrame->Init(content, aParentFrame, aFrame);
-  } else if (LayoutFrameType::Legend == frameType) {
-    newFrame = NS_NewLegendFrame(mPresShell, computedStyle);
-    newFrame->Init(content, aParentFrame, aFrame);
   } else if (LayoutFrameType::FlexContainer == frameType) {
     newFrame = NS_NewFlexContainerFrame(mPresShell, computedStyle);
     newFrame->Init(content, aParentFrame, aFrame);
@@ -8245,12 +8223,9 @@
     return true;
   }
 
-  nsContainerFrame* insertionFrame = aFrame->GetContentInsertionFrame();
-  if (insertionFrame && insertionFrame->IsLegendFrame() &&
-      aFrame->GetParent()->IsFieldSetFrame()) {
+  if (inFlowFrame->IsRenderedLegend()) {
     TRACE("Fieldset / Legend");
-    RecreateFramesForContent(aFrame->GetParent()->GetContent(),
-                             InsertionKind::Async);
+    RecreateFramesForContent(parent->GetContent(), InsertionKind::Async);
     return true;
   }
 
@@ -9355,6 +9330,34 @@
   // that information offhand in many cases.
   MOZ_ASSERT(ParentIsWrapperAnonBox(aParentFrame) == aParentIsWrapperAnonBox);
 
+  if (!aParentIsWrapperAnonBox && aState.mHasRenderedLegend &&
+      aParentFrame->GetContent()->IsHTMLElement(nsGkAtoms::fieldset)) {
+    DebugOnly<bool> found = false;
+    for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
+      if (iter.item().mIsRenderedLegend) {
+        // This makes the rendered legend the first frame in the fieldset child
+        // list which makes keyboard traversal follow the visual order.
+        nsContainerFrame* fieldSetFrame = aParentFrame->GetParent();
+        while (!fieldSetFrame->IsFieldSetFrame()) {
+          fieldSetFrame = fieldSetFrame->GetParent();
+        }
+        nsFrameList renderedLegend;
+        ConstructFramesFromItem(aState, iter, fieldSetFrame, renderedLegend);
+        MOZ_ASSERT(
+            renderedLegend.FirstChild() &&
+                renderedLegend.FirstChild() == renderedLegend.LastChild(),
+            "a rendered legend should have exactly one frame");
+        fieldSetFrame->SetInitialChildList(kPrincipalList, renderedLegend);
+        FCItemIterator next = iter;
+        next.Next();
+        iter.DeleteItemsTo(this, next);
+        found = true;
+        break;
+      }
+    }
+    MOZ_ASSERT(found, "should have found our rendered legend");
+  }
+
   CreateNeededPseudoContainers(aState, aItems, aParentFrame);
   CreateNeededAnonFlexOrGridItems(aState, aItems, aParentFrame);
   CreateNeededPseudoInternalRubyBoxes(aState, aItems, aParentFrame);
@@ -9362,6 +9365,9 @@
 
   bool listItemListIsDirty = false;
   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
+    MOZ_ASSERT(!iter.item().mIsRenderedLegend,
+               "Only one item can be the rendered legend, "
+               "and it should've been handled above");
     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
                  "Needed pseudos didn't get created; expect bad things");
     // display:list-item boxes affects the start value of the "list-item"