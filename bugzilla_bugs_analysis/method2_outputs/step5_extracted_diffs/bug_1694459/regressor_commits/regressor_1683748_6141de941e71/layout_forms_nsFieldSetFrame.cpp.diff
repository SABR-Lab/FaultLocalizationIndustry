# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/forms/nsFieldSetFrame.cpp
# Commit: 6141de941e71
# Full Hash: 6141de941e717cdb5485e1aa1ca00ffcd74f8a81
# Author: Mats Palmgren <mats@mozilla.com>
# Date: 2021-01-30 19:41:15
# Regressor Bug: 1683748
# File Overlap Count: 3
# Description:
#   Bug 1683748 - Support Grid/Flex/Table/Column layout for the rendered legend of a fieldset.  r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101555
# ==============================================================================

diff -r 3cf752580f1b -r 6141de941e71 layout/forms/nsFieldSetFrame.cpp
--- a/layout/forms/nsFieldSetFrame.cpp	Fri Jan 29 19:20:24 2021 +0000
+++ b/layout/forms/nsFieldSetFrame.cpp	Sat Jan 30 13:47:10 2021 +0000
@@ -14,6 +14,7 @@
 #include "mozilla/PresShell.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/webrender/WebRenderAPI.h"
+#include "nsBlockFrame.h"
 #include "nsCSSAnonBoxes.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsCSSRendering.h"
@@ -21,7 +22,6 @@
 #include "nsGkAtoms.h"
 #include "nsIFrameInlines.h"
 #include "nsLayoutUtils.h"
-#include "nsLegendFrame.h"
 #include "nsStyleConsts.h"
 
 using namespace mozilla;
@@ -445,8 +445,15 @@
   if (legend) {
     const auto legendWM = legend->GetWritingMode();
     LogicalSize legendAvailSize = availSize.ConvertTo(legendWM, wm);
+    ComputeSizeFlags sizeFlags;
+    if (legend->StylePosition()->ISize(wm).IsAuto()) {
+      sizeFlags = ComputeSizeFlag::ShrinkWrap;
+    }
+    ReflowInput::InitFlags initFlags;  // intentionally empty
+    StyleSizeOverrides sizeOverrides;  // intentionally empty
     legendReflowInput.emplace(aPresContext, aReflowInput, legend,
-                              legendAvailSize);
+                              legendAvailSize, Nothing(), initFlags,
+                              sizeOverrides, sizeFlags);
   }
   const bool avoidBreakInside = ShouldAvoidBreakInside(aReflowInput);
   if (reflowLegend) {
@@ -675,11 +682,10 @@
     if (innerContentRect.ISize(wm) > mLegendRect.ISize(wm)) {
       // NOTE legend @align values are: left/right/center
       // GetLogicalAlign converts left/right to start/end for the given WM.
-      // @see HTMLLegendElement::ParseAttribute, nsLegendFrame::GetLogicalAlign
-      LegendAlignValue align =
-          static_cast<nsLegendFrame*>(legend->GetContentInsertionFrame())
-              ->GetLogicalAlign(wm);
-      switch (align) {
+      // @see HTMLLegendElement::ParseAttribute/LogicalAlign
+      auto* legendElement =
+          dom::HTMLLegendElement::FromNode(legend->GetContent());
+      switch (legendElement->LogicalAlign(wm)) {
         case LegendAlignValue::InlineEnd:
           mLegendRect.IStart(wm) =
               innerContentRect.IEnd(wm) - mLegendRect.ISize(wm);
@@ -789,18 +795,29 @@
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize);
 }
 
-#ifdef DEBUG
 void nsFieldSetFrame::SetInitialChildList(ChildListID aListID,
                                           nsFrameList& aChildList) {
   nsContainerFrame::SetInitialChildList(aListID, aChildList);
-  MOZ_ASSERT(aListID != kPrincipalList || GetInner(),
-             "Setting principal child list should populate our inner frame");
+  if (nsBlockFrame* legend = do_QueryFrame(GetLegend())) {
+    // A rendered legend always establish a new formatting context.
+    // https://html.spec.whatwg.org/multipage/rendering.html#rendered-legend
+    legend->AddStateBits(NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS);
+  }
+  MOZ_ASSERT(aListID != kPrincipalList || GetInner() || GetLegend(),
+             "Setting principal child list should populate our inner frame "
+             "or our rendered legend");
 }
 void nsFieldSetFrame::AppendFrames(ChildListID aListID,
                                    nsFrameList& aFrameList) {
-  MOZ_CRASH("nsFieldSetFrame::AppendFrames not supported");
+  MOZ_ASSERT(aListID == kNoReflowPrincipalList &&
+                 HasAnyStateBits(NS_FRAME_FIRST_REFLOW),
+             "AppendFrames should only be used from "
+             "nsCSSFrameConstructor::ConstructFieldSetFrame");
+  nsContainerFrame::AppendFrames(aListID, aFrameList);
+  MOZ_ASSERT(GetInner(), "at this point we should have an inner frame");
 }
 
+#ifdef DEBUG
 void nsFieldSetFrame::InsertFrames(ChildListID aListID, nsIFrame* aPrevFrame,
                                    const nsLineList::iterator* aPrevFrameLine,
                                    nsFrameList& aFrameList) {