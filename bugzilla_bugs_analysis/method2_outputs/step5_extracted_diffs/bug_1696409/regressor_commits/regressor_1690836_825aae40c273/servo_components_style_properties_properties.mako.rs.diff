# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/properties/properties.mako.rs
# Commit: 825aae40c273
# Full Hash: 825aae40c2739c92716b7447a0449e61f15b1d48
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2021-02-17 09:45:59
# Regressor Bug: 1690836
# File Overlap Count: 1
# Description:
#   Bug 1690836 - Reduce the amount of code generated by UnparsedValues::substitute_variables. r=boris
#   
#   This reduces the amount of assembly instructions generated by this
#   function from 18k+ to ~800.
#   
# ==============================================================================

diff -r ef1676ed357b -r 825aae40c273 servo/components/style/properties/properties.mako.rs
--- a/servo/components/style/properties/properties.mako.rs	Wed Feb 17 00:21:36 2021 +0000
+++ b/servo/components/style/properties/properties.mako.rs	Wed Feb 17 00:21:36 2021 +0000
@@ -1194,20 +1194,18 @@
         }
     }
 
-    // TODO(emilio): Should we use a function table like CASCADE_PROPERTY does
-    // to avoid blowing up code-size here?
     fn parse_value<'i, 't>(
         &self,
         context: &ParserContext,
         input: &mut Parser<'i, 't>,
     ) -> Result<PropertyDeclaration, ParseError<'i>> {
-        match *self {
-            % for property in data.longhands:
-                LonghandId::${property.camel_case} => {
-                    longhands::${property.ident}::parse_declared(context, input)
-                }
-            % endfor
-        }
+        type ParsePropertyFn = for<'i, 't> fn(context: &ParserContext, input: &mut Parser<'i, 't>) -> Result<PropertyDeclaration, ParseError<'i>>;
+        static PARSE_PROPERTY: [ParsePropertyFn; ${len(data.longhands)}] = [
+        % for property in data.longhands:
+            longhands::${property.ident}::parse_declared,
+        % endfor
+        ];
+        (PARSE_PROPERTY[*self as usize])(context, input)
     }
 
     /// Returns whether this property is animatable.
@@ -1596,15 +1594,36 @@
         context: &ParserContext,
         input: &mut Parser<'i, 't>,
     ) -> Result<(), ParseError<'i>> {
-        match *self {
-            % for shorthand in data.shorthands_except_all():
-                ShorthandId::${shorthand.camel_case} => {
-                    shorthands::${shorthand.ident}::parse_into(declarations, context, input)
-                }
+        type ParseIntoFn = for<'i, 't> fn(
+            declarations: &mut SourcePropertyDeclaration,
+            context: &ParserContext,
+            input: &mut Parser<'i, 't>,
+        ) -> Result<(), ParseError<'i>>;
+
+        fn unreachable<'i, 't>(
+            _: &mut SourcePropertyDeclaration,
+            _: &ParserContext,
+            _: &mut Parser<'i, 't>
+        ) -> Result<(), ParseError<'i>> {
+            unreachable!()
+        }
+
+        // 'all' accepts no value other than CSS-wide keywords
+        if *self == ShorthandId::All {
+            return Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError));
+        }
+
+        static PARSE_INTO: [ParseIntoFn; ${len(data.shorthands)}] = [
+            % for shorthand in data.shorthands:
+            % if shorthand.ident == "all":
+            unreachable,
+            % else:
+            shorthands::${shorthand.ident}::parse_into,
+            % endif
             % endfor
-            // 'all' accepts no value other than CSS-wide keywords
-            ShorthandId::All => Err(input.new_custom_error(StyleParseErrorKind::UnspecifiedError))
-        }
+        ];
+
+        (PARSE_INTO[*self as usize])(declarations, context, input)
     }
 }
 
@@ -1647,6 +1666,7 @@
     fn substitute_variables<'cache>(
         &self,
         longhand_id: LonghandId,
+        writing_mode: WritingMode,
         custom_properties: Option<<&Arc<crate::custom_properties::CustomPropertiesMap>>,
         quirks_mode: QuirksMode,
         device: &Device,
@@ -1719,43 +1739,18 @@
             Some(shorthand) => shorthand,
         };
 
-        match shorthand {
-            ShorthandId::All => {
-                // No need to parse the 'all' shorthand as anything other
-                // than a CSS-wide keyword, after variable substitution.
-                return invalid_at_computed_value_time();
+        let mut decls = SourcePropertyDeclaration::new();
+        // parse_into takes care of doing `parse_entirely` for us.
+        if shorthand.parse_into(&mut decls, &context, &mut input).is_err() {
+            return invalid_at_computed_value_time();
+        }
+
+        for declaration in decls.declarations.drain(..) {
+            let longhand = declaration.id().as_longhand().unwrap();
+            if longhand.is_logical() {
+                shorthand_cache.insert((shorthand, longhand.to_physical(writing_mode)), declaration.clone());
             }
-            % for shorthand in data.shorthands_except_all():
-            ShorthandId::${shorthand.camel_case} => {
-                let longhands = match input.parse_entirely(|input| shorthands::${shorthand.ident}::parse_value(&context, input)) {
-                    Ok(l) => l,
-                    _ => return invalid_at_computed_value_time(),
-                };
-
-                <% seen = set() %>
-                % for property in shorthand.sub_properties:
-                // When animating logical properties, we end up
-                // physicalizing the value during the animation, but the
-                // value still comes from the logical shorthand.
-                //
-                // So we need to handle the physical properties too.
-                % for prop in property.all_physical_mapped_properties(data) + [property]:
-                % if prop.ident not in seen:
-                    shorthand_cache.insert(
-                        (shorthand, LonghandId::${prop.camel_case}),
-                        PropertyDeclaration::${prop.camel_case}(
-                            longhands.${property.ident}
-                            % if prop.ident != property.ident:
-                            .clone()
-                            % endif
-                        )
-                    );
-                % endif
-                <% seen.add(prop.ident) %>
-                % endfor
-                % endfor
-            }
-            % endfor
+            shorthand_cache.insert((shorthand, longhand), declaration);
         }
 
         Cow::Borrowed(&shorthand_cache[&(shorthand, longhand_id)])
@@ -2469,7 +2464,7 @@
                             id,
                             value: Arc::new(UnparsedValue {
                                 css: css.into_owned(),
-                                first_token_type: first_token_type,
+                                first_token_type,
                                 url_data: context.url_data.clone(),
                                 from_shorthand: None,
                             }),
@@ -2506,7 +2501,7 @@
                             crate::custom_properties::parse_non_custom_with_var(input)?;
                         let unparsed = Arc::new(UnparsedValue {
                             css: css.into_owned(),
-                            first_token_type: first_token_type,
+                            first_token_type,
                             url_data: context.url_data.clone(),
                             from_shorthand: Some(id),
                         });
