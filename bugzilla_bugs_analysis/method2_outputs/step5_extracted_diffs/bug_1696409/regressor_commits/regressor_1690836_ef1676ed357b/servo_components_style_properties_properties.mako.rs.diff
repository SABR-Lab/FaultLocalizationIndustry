# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/properties/properties.mako.rs
# Commit: ef1676ed357b
# Full Hash: ef1676ed357b4434d17a71e40e0b04753bdbff0b
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2021-02-17 09:45:59
# Regressor Bug: 1690836
# File Overlap Count: 1
# Description:
#   Bug 1690836 - Cache substituted values from shorthand properties during the cascade. r=xidorn
#   
#   This brings the time down to 1.6ms from 4.8ms on the test-case in the
#   bug. This should be improvable too, but I think this is a nice
#   improvement for regular styling as well.
# ==============================================================================

diff -r be5f469a4424 -r ef1676ed357b servo/components/style/properties/properties.mako.rs
--- a/servo/components/style/properties/properties.mako.rs	Wed Feb 17 00:21:35 2021 +0000
+++ b/servo/components/style/properties/properties.mako.rs	Wed Feb 17 00:21:36 2021 +0000
@@ -29,11 +29,11 @@
 use crate::logical_geometry::WritingMode;
 use malloc_size_of::{MallocSizeOf, MallocSizeOfOps};
 use crate::computed_value_flags::*;
+use crate::hash::FxHashMap;
 use crate::media_queries::Device;
 use crate::parser::ParserContext;
 use crate::properties::longhands::system_font::SystemFont;
 use crate::selector_parser::PseudoElement;
-use selectors::parser::SelectorParseErrorKind;
 #[cfg(feature = "servo")] use servo_config::prefs;
 use style_traits::{CssWriter, KeywordsCollectFn, ParseError, ParsingMode};
 use style_traits::{SpecifiedValueInfo, StyleParseErrorKind, ToCss};
@@ -1634,23 +1634,44 @@
     }
 }
 
+/// A simple cache for properties that come from a shorthand and have variable
+/// references.
+///
+/// This cache works because of the fact that you can't have competing values
+/// for a given longhand coming from the same shorthand (but note that this is
+/// why the shorthand needs to be part of the cache key).
+pub type ShorthandsWithPropertyReferencesCache =
+    FxHashMap<(ShorthandId, LonghandId), PropertyDeclaration>;
+
 impl UnparsedValue {
-    fn substitute_variables(
+    fn substitute_variables<'cache>(
         &self,
         longhand_id: LonghandId,
         custom_properties: Option<<&Arc<crate::custom_properties::CustomPropertiesMap>>,
         quirks_mode: QuirksMode,
         device: &Device,
-    ) -> PropertyDeclaration {
+        shorthand_cache: &'cache mut ShorthandsWithPropertyReferencesCache,
+    ) -> Cow<'cache, PropertyDeclaration> {
         let invalid_at_computed_value_time = || {
             let keyword = if longhand_id.inherited() {
                 CSSWideKeyword::Inherit
             } else {
                 CSSWideKeyword::Initial
             };
-            PropertyDeclaration::css_wide_keyword(longhand_id, keyword)
+            Cow::Owned(PropertyDeclaration::css_wide_keyword(longhand_id, keyword))
         };
 
+        if let Some(shorthand_id) = self.from_shorthand {
+            let key = (shorthand_id, longhand_id);
+            if shorthand_cache.contains_key(&key) {
+                // FIXME: This double lookup should be avoidable, but rustc
+                // doesn't like that, see:
+                //
+                // https://github.com/rust-lang/rust/issues/82146
+                return Cow::Borrowed(&shorthand_cache[&key]);
+            }
+        }
+
         let css = match crate::custom_properties::substitute(
             &self.css,
             self.first_token_type,
@@ -1685,53 +1706,59 @@
         let mut input = Parser::new(&mut input);
         input.skip_whitespace();  // Unnecessary for correctness, but may help try() rewind less.
         if let Ok(keyword) = input.try_parse(CSSWideKeyword::parse) {
-            return PropertyDeclaration::css_wide_keyword(longhand_id, keyword);
+            return Cow::Owned(PropertyDeclaration::css_wide_keyword(longhand_id, keyword));
         }
 
-        let declaration = input.parse_entirely(|input| {
-            match self.from_shorthand {
-                None => longhand_id.parse_value(&context, input),
-                Some(ShorthandId::All) => {
-                    // No need to parse the 'all' shorthand as anything other
-                    // than a CSS-wide keyword, after variable substitution.
-                    Err(input.new_custom_error(SelectorParseErrorKind::UnexpectedIdent("all".into())))
+        let shorthand = match self.from_shorthand {
+            None => {
+                return match input.parse_entirely(|input| longhand_id.parse_value(&context, input)) {
+                    Ok(decl) => Cow::Owned(decl),
+                    Err(..) => invalid_at_computed_value_time(),
                 }
-                % for shorthand in data.shorthands_except_all():
-                Some(ShorthandId::${shorthand.camel_case}) => {
-                    shorthands::${shorthand.ident}::parse_value(&context, input)
-                    .map(|longhands| {
-                        match longhand_id {
-                            <% seen = set() %>
-                            % for property in shorthand.sub_properties:
-                            // When animating logical properties, we end up
-                            // physicalizing the value during the animation, but
-                            // the value still comes from the logical shorthand.
-                            //
-                            // So we need to handle the physical properties too.
-                            % for prop in [property] + property.all_physical_mapped_properties(data):
-                            % if prop.camel_case not in seen:
-                            LonghandId::${prop.camel_case} => {
-                                PropertyDeclaration::${prop.camel_case}(
-                                    longhands.${property.ident}
-                                )
-                            }
-                            <% seen.add(prop.camel_case) %>
+            },
+            Some(shorthand) => shorthand,
+        };
+
+        match shorthand {
+            ShorthandId::All => {
+                // No need to parse the 'all' shorthand as anything other
+                // than a CSS-wide keyword, after variable substitution.
+                return invalid_at_computed_value_time();
+            }
+            % for shorthand in data.shorthands_except_all():
+            ShorthandId::${shorthand.camel_case} => {
+                let longhands = match input.parse_entirely(|input| shorthands::${shorthand.ident}::parse_value(&context, input)) {
+                    Ok(l) => l,
+                    _ => return invalid_at_computed_value_time(),
+                };
+
+                <% seen = set() %>
+                % for property in shorthand.sub_properties:
+                // When animating logical properties, we end up
+                // physicalizing the value during the animation, but the
+                // value still comes from the logical shorthand.
+                //
+                // So we need to handle the physical properties too.
+                % for prop in property.all_physical_mapped_properties(data) + [property]:
+                % if prop.ident not in seen:
+                    shorthand_cache.insert(
+                        (shorthand, LonghandId::${prop.camel_case}),
+                        PropertyDeclaration::${prop.camel_case}(
+                            longhands.${property.ident}
+                            % if prop.ident != property.ident:
+                            .clone()
                             % endif
-                            % endfor
-                            % endfor
-                            <% del seen %>
-                            _ => unreachable!()
-                        }
-                    })
-                }
+                        )
+                    );
+                % endif
+                <% seen.add(prop.ident) %>
+                % endfor
                 % endfor
             }
-        });
-
-        match declaration {
-            Ok(decl) => decl,
-            Err(..) => invalid_at_computed_value_time(),
+            % endfor
         }
+
+        Cow::Borrowed(&shorthand_cache[&(shorthand, longhand_id)])
     }
 }
 
