# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Cell.h
# Commit: fabb8df993fb
# Full Hash: fabb8df993fb044dbf52c3c74f6d679cd42c7f73
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2021-03-17 21:25:27
# Regressor Bug: 1698543
# File Overlap Count: 4
# Description:
#   Bug 1698543 - Rework handling of interaction between incremental barriers and rope flattening r=sfink
#   
#   Currently we have a special path for performing barriers during rope flattening to take account of the fact that this overwrites the cell header word of ropes temporarily, making these cells untraceable.
#   
#   The problem is that a rope can already be in the barrier buffer before flattening starts and so we need to check for this when processing the buffer.
# ==============================================================================

diff -r 181aeda5c83a -r fabb8df993fb js/src/gc/Cell.h
--- a/js/src/gc/Cell.h	Wed Mar 17 08:50:18 2021 +0000
+++ b/js/src/gc/Cell.h	Wed Mar 17 09:01:16 2021 +0000
@@ -55,7 +55,6 @@
 class TenuredCell;
 
 extern void PerformIncrementalBarrier(TenuredCell* cell);
-extern void PerformIncrementalBarrierDuringFlattening(JSString* str);
 extern void UnmarkGrayGCThingRecursively(TenuredCell* cell);
 
 // Like gc::MarkColor but allows the possibility of the cell being unmarked.
@@ -142,9 +141,17 @@
   // compacting GC and is now a RelocationOverlay.
   static constexpr uintptr_t FORWARD_BIT = Bit(0);
 
-  // Bits 1 and 2 are currently unused.
+  // Indicates whether the cell header has been temporarily replaced by calling
+  // setTemporaryGCUnsafeData(). This is currently only used during rope
+  // flattening.
+  static constexpr uintptr_t TEMP_DATA_BIT = Bit(1);
+
+  // For use by derived cell classes. This is currently only used during rope
+  // flattening.
+  static constexpr uintptr_t USER_BIT = Bit(2);
 
   bool isForwarded() const { return header_ & FORWARD_BIT; }
+  bool hasTempHeaderData() const { return header_ & TEMP_DATA_BIT; }
   uintptr_t flags() const { return header_ & RESERVED_MASK; }
 
   MOZ_ALWAYS_INLINE bool isTenured() const { return !IsInsideNursery(this); }
@@ -641,17 +648,21 @@
 #endif
   }
 
-  // Sub classes can store temporary data in the flags word. This is not GC safe
+  // Subclasses can store temporary data in the flags word. This is not GC safe
   // and users must ensure flags/length are never checked (including by asserts)
   // while this data is stored. Use of this method is strongly discouraged!
-  void setTemporaryGCUnsafeData(uintptr_t data) { header_ = data; }
+  void setTemporaryGCUnsafeData(uintptr_t data) {
+    MOZ_ASSERT((data & TEMP_DATA_BIT) == 0);
+    header_ = data | TEMP_DATA_BIT;
+  }
 
-  // To get back the data, values to safely re-initialize clobbered flags
-  // must be provided.
+  // To get back the data, values to safely re-initialize clobbered length and
+  // flags must be provided.
   uintptr_t unsetTemporaryGCUnsafeData(uint32_t len, uint32_t flags) {
+    MOZ_ASSERT(hasTempHeaderData());
     uintptr_t data = header_;
     setHeaderLengthAndFlags(len, flags);
-    return data;
+    return data & ~TEMP_DATA_BIT;
   }
 
  public: