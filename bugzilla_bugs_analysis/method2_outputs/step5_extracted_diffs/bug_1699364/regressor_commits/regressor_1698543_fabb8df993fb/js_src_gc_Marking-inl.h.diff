# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Marking-inl.h
# Commit: fabb8df993fb
# Full Hash: fabb8df993fb044dbf52c3c74f6d679cd42c7f73
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2021-03-17 21:25:27
# Regressor Bug: 1698543
# File Overlap Count: 4
# Description:
#   Bug 1698543 - Rework handling of interaction between incremental barriers and rope flattening r=sfink
#   
#   Currently we have a special path for performing barriers during rope flattening to take account of the fact that this overwrites the cell header word of ropes temporarily, making these cells untraceable.
#   
#   The problem is that a rope can already be in the barrier buffer before flattening starts and so we need to check for this when processing the buffer.
# ==============================================================================

diff -r 181aeda5c83a -r fabb8df993fb js/src/gc/Marking-inl.h
--- a/js/src/gc/Marking-inl.h	Wed Mar 17 08:50:18 2021 +0000
+++ b/js/src/gc/Marking-inl.h	Wed Mar 17 09:01:16 2021 +0000
@@ -138,27 +138,6 @@
   return !Nursery::getForwardedPointer(cellp);
 }
 
-// Special case pre-write barrier for strings used during rope flattening. This
-// is a work around as buffering these strings is problematic as they may have
-// their cell headers overwritten with temporary GC data.
-inline void PreWriteBarrierDuringFlattening(JSString* str) {
-  MOZ_ASSERT(str);
-  MOZ_ASSERT(!JS::RuntimeHeapIsMajorCollecting());
-
-  if (IsInsideNursery(str) || str->isPermanentAndMayBeShared()) {
-    return;
-  }
-
-  auto* cell = reinterpret_cast<TenuredCell*>(str);
-  JS::shadow::Zone* zone = cell->shadowZoneFromAnyThread();
-
-  MOZ_ASSERT(CurrentThreadCanAccessRuntime(zone->runtimeFromAnyThread()));
-
-  if (zone->needsIncrementalBarrier()) {
-    PerformIncrementalBarrierDuringFlattening(str);
-  }
-}
-
 #ifdef JSGC_HASH_TABLE_CHECKS
 
 template <typename T>