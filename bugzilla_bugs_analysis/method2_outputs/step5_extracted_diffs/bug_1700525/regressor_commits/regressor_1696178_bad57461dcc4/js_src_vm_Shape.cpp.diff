# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Shape.cpp
# Commit: bad57461dcc4
# Full Hash: bad57461dcc4c6c52064bf985ee737d8abbc183b
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-23 21:43:59
# Regressor Bug: 1696178
# File Overlap Count: 1
# Description:
#   Bug 1696178 part 5 - Add ObjectFlag::HasNonWritableOrAccessorExcludingProto. r=jonco
#   
#   This will be used by the next patch to optimize Object.assign.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D108407
# ==============================================================================

diff -r 12574c8b209d -r bad57461dcc4 js/src/vm/Shape.cpp
--- a/js/src/vm/Shape.cpp	Tue Mar 23 12:43:56 2021 +0000
+++ b/js/src/vm/Shape.cpp	Tue Mar 23 12:43:57 2021 +0000
@@ -531,15 +531,26 @@
   return obj->lastProperty()->entryCount() >= PropertyTree::MAX_HEIGHT;
 }
 
-static MOZ_ALWAYS_INLINE ObjectFlags GetObjectFlagsForNewShape(Shape* last,
-                                                               jsid id) {
+enum class IsAccessor : bool { No, Yes };
+
+template <IsAccessor isAccessor>
+static MOZ_ALWAYS_INLINE ObjectFlags
+GetObjectFlagsForNewShape(Shape* last, jsid id, unsigned attrs, JSContext* cx) {
   ObjectFlags flags = last->objectFlags();
+
   uint32_t index;
   if (IdIsIndex(id, &index)) {
     flags.setFlag(ObjectFlag::Indexed);
   } else if (JSID_IS_SYMBOL(id) && JSID_TO_SYMBOL(id)->isInterestingSymbol()) {
     flags.setFlag(ObjectFlag::HasInterestingSymbol);
   }
+
+  if ((isAccessor == IsAccessor::Yes || (attrs & JSPROP_READONLY)) &&
+      last->getObjectClass() == &PlainObject::class_ &&
+      !JSID_IS_ATOM(id, cx->names().proto)) {
+    flags.setFlag(ObjectFlag::HasNonWritableOrAccessorPropExclProto);
+  }
+
   return flags;
 }
 
@@ -643,7 +654,8 @@
   RootedShape shape(cx);
   {
     RootedShape last(cx, obj->lastProperty());
-    ObjectFlags objectFlags = GetObjectFlagsForNewShape(last, id);
+    ObjectFlags objectFlags =
+        GetObjectFlagsForNewShape<IsAccessor::Yes>(last, id, attrs, cx);
 
     Rooted<StackShape> child(cx, StackShape(last->base(), objectFlags, id,
                                             SHAPE_INVALID_SLOT, attrs));
@@ -685,7 +697,8 @@
   RootedShape shape(cx);
   {
     RootedShape last(cx, obj->lastProperty());
-    ObjectFlags objectFlags = GetObjectFlagsForNewShape(last, id);
+    ObjectFlags objectFlags =
+        GetObjectFlagsForNewShape<IsAccessor::No>(last, id, attrs, cx);
 
     Rooted<StackShape> child(
         cx, StackShape(last->base(), objectFlags, id, slot, attrs));
@@ -740,7 +753,9 @@
 
   AutoCheckShapeConsistency check(obj);
 
-  ObjectFlags objectFlags = GetObjectFlagsForNewShape(obj->lastProperty(), id);
+  constexpr unsigned attrs = JSPROP_ENUMERATE;
+  ObjectFlags objectFlags = GetObjectFlagsForNewShape<IsAccessor::No>(
+      obj->lastProperty(), id, attrs, cx);
 
   // Fast path for non-dictionary shapes with a single child.
   do {
@@ -760,7 +775,7 @@
     MOZ_ASSERT(!child->inDictionary());
 
     if (child->propidRaw() != id || child->objectFlags() != objectFlags ||
-        child->isAccessorShape() || child->attributes() != JSPROP_ENUMERATE ||
+        child->isAccessorShape() || child->attributes() != attrs ||
         child->base() != lastProperty->base()) {
       break;
     }
@@ -956,17 +971,13 @@
   uint32_t oldSlot = shape->maybeSlot();
   uint32_t slot = hadSlot ? oldSlot : SHAPE_INVALID_SLOT;
 
-#ifdef DEBUG
-  // Property |id| already exists, so object flags should already be set.
-  ObjectFlags objectFlags = GetObjectFlagsForNewShape(obj->lastProperty(), id);
-  MOZ_ASSERT(objectFlags == obj->lastProperty()->objectFlags());
-#endif
+  ObjectFlags objectFlags = GetObjectFlagsForNewShape<IsAccessor::No>(
+      obj->lastProperty(), id, attrs, cx);
 
   // Now that we've possibly preserved slot, check whether all members match.
   // If so, this is a redundant "put" and we can return without more work.
-  if (shape->matchesParamsAfterId(obj->lastProperty()->base(),
-                                  obj->lastProperty()->objectFlags(), slot,
-                                  attrs, nullptr, nullptr)) {
+  if (shape->matchesParamsAfterId(obj->lastProperty()->base(), objectFlags,
+                                  slot, attrs, nullptr, nullptr)) {
     return shape;
   }
 
@@ -999,6 +1010,7 @@
     }
 
     shape->setBase(obj->lastProperty()->base());
+    shape->setObjectFlags(objectFlags);
     shape->setSlot(slot);
     shape->attrs = uint8_t(attrs);
     shape->immutableFlags &= ~Shape::ACCESSOR_SHAPE;
@@ -1010,9 +1022,8 @@
     MOZ_ASSERT(shape == obj->lastProperty());
 
     // Find or create a property tree node labeled by our arguments.
-    Rooted<StackShape> child(
-        cx, StackShape(obj->lastProperty()->base(),
-                       obj->lastProperty()->objectFlags(), id, slot, attrs));
+    Rooted<StackShape> child(cx, StackShape(obj->lastProperty()->base(),
+                                            objectFlags, id, slot, attrs));
     RootedShape parent(cx, shape->parent);
     shape = getChildDataProperty(cx, obj, parent, &child);
     if (!shape) {
@@ -1065,16 +1076,12 @@
   bool hadSlot = shape->isDataProperty();
   uint32_t oldSlot = shape->maybeSlot();
 
-#ifdef DEBUG
-  // Property |id| already exists, so object flags should already be set.
-  ObjectFlags objectFlags = GetObjectFlagsForNewShape(obj->lastProperty(), id);
-  MOZ_ASSERT(objectFlags == obj->lastProperty()->objectFlags());
-#endif
+  ObjectFlags objectFlags = GetObjectFlagsForNewShape<IsAccessor::Yes>(
+      obj->lastProperty(), id, attrs, cx);
 
   // Check whether all members match. If so, this is a redundant "put" and we
   // can return without more work.
-  if (shape->matchesParamsAfterId(obj->lastProperty()->base(),
-                                  obj->lastProperty()->objectFlags(),
+  if (shape->matchesParamsAfterId(obj->lastProperty()->base(), objectFlags,
                                   SHAPE_INVALID_SLOT, attrs, getter, setter)) {
     return shape;
   }
@@ -1100,6 +1107,7 @@
     }
 
     shape->setBase(obj->lastProperty()->base());
+    shape->setObjectFlags(objectFlags);
     shape->setSlot(SHAPE_INVALID_SLOT);
     shape->attrs = uint8_t(attrs);
     shape->immutableFlags |= Shape::IN_DICTIONARY | Shape::ACCESSOR_SHAPE;
@@ -1116,9 +1124,9 @@
     MOZ_ASSERT(shape == obj->lastProperty());
 
     // Find or create a property tree node labeled by our arguments.
-    Rooted<StackShape> child(cx, StackShape(obj->lastProperty()->base(),
-                                            obj->lastProperty()->objectFlags(),
-                                            id, SHAPE_INVALID_SLOT, attrs));
+    Rooted<StackShape> child(
+        cx, StackShape(obj->lastProperty()->base(), objectFlags, id,
+                       SHAPE_INVALID_SLOT, attrs));
     child.updateGetterSetter(getter, setter);
     RootedShape parent(cx, shape->parent);
     shape = getChildAccessorProperty(cx, obj, parent, &child);