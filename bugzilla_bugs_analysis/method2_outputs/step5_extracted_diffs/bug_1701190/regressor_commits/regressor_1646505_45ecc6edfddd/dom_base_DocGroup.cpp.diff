# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DocGroup.cpp
# Commit: 45ecc6edfddd
# Full Hash: 45ecc6edfddd1091dd8496db5b6061b29ec6daea
# Author: Andreas Farre <farre@mozilla.com>
# Date: 2020-12-12 09:23:03
# Regressor Bug: 1646505
# File Overlap Count: 1
# Description:
#   Bug 1646505 - Fix about:performance for Fission. r=tarek
#   
#   With fission it's not possible to use
#   nsPIDOMWindowOuter::GetInProcessTop and expect to find the top-level
#   window, since it might be in another process. Instead we use
# ==============================================================================

diff -r 5642ac1f250f -r 45ecc6edfddd dom/base/DocGroup.cpp
--- a/dom/base/DocGroup.cpp	Fri Dec 11 16:03:18 2020 +0000
+++ b/dom/base/DocGroup.cpp	Fri Dec 11 15:56:23 2020 +0000
@@ -12,9 +12,11 @@
 #include "mozilla/StaticPrefs_dom.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/ThrottledEventQueue.h"
+#include "mozilla/dom/BrowsingContext.h"
 #include "mozilla/dom/CustomElementRegistry.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/JSExecutionManager.h"
+#include "mozilla/dom/WindowContext.h"
 #include "nsDOMMutationObserver.h"
 #include "nsIDirectTaskDispatcher.h"
 #include "nsProxyRelease.h"
@@ -220,38 +222,35 @@
   uint64_t windowID = 0;
   uint16_t count = 0;
   uint64_t duration = 0;
+  nsCString host;
   bool isTopLevel = false;
-  nsCString host;
-  nsCOMPtr<nsPIDOMWindowOuter> top;
-  RefPtr<AbstractThread> mainThread;
+  RefPtr<BrowsingContext> top;
+  RefPtr<AbstractThread> mainThread =
+      AbstractMainThreadFor(TaskCategory::Performance);
 
-  // iterating on documents until we find the top window
   for (const auto& document : *this) {
-    nsCOMPtr<Document> doc = document;
-    MOZ_ASSERT(doc);
-    nsCOMPtr<nsIURI> docURI = doc->GetDocumentURI();
-    if (!docURI) {
+    if (host.IsEmpty()) {
+      nsCOMPtr<nsIURI> docURI = document->GetDocumentURI();
+      if (!docURI) {
+        continue;
+      }
+
+      docURI->GetHost(host);
+      if (host.IsEmpty()) {
+        host = docURI->GetSpecOrDefault();
+      }
+    }
+
+    BrowsingContext* context = document->GetBrowsingContext();
+    if (!context) {
       continue;
     }
-    docURI->GetHost(host);
-    // If the host is empty, using the url
-    if (host.IsEmpty()) {
-      host = docURI->GetSpecOrDefault();
-    }
-    // looking for the top level document URI
-    nsPIDOMWindowOuter* win = doc->GetWindow();
-    if (!win) {
-      continue;
-    }
-    top = win->GetInProcessTop();
-    if (!top) {
-      continue;
-    }
-    windowID = top->WindowID();
-    isTopLevel = win->GetBrowsingContext()->IsTop();
-    mainThread = AbstractMainThreadFor(TaskCategory::Performance);
+
+    top = context->Top();
+    isTopLevel = context->IsTop();
+    windowID = top->GetCurrentWindowContext()->OuterWindowId();
     break;
-  }
+  };
 
   MOZ_ASSERT(!host.IsEmpty());
   duration = mPerformanceCounter->GetExecutionDuration();
@@ -268,7 +267,7 @@
     }
   }
 
-  if (!isTopLevel) {
+  if (!isTopLevel && top && top->IsInProcess()) {
     return PerformanceInfoPromise::CreateAndResolve(
         PerformanceInfo(host, pid, windowID, duration,
                         mPerformanceCounter->GetID(), false, isTopLevel,
@@ -279,8 +278,8 @@
 
   MOZ_ASSERT(mainThread);
   RefPtr<DocGroup> self = this;
-
-  return CollectMemoryInfo(top, mainThread)
+  return (isTopLevel ? CollectMemoryInfo(top, mainThread)
+                     : CollectMemoryInfo(self, mainThread))
       ->Then(
           mainThread, __func__,
           [self, host, pid, windowID, duration, isTopLevel,