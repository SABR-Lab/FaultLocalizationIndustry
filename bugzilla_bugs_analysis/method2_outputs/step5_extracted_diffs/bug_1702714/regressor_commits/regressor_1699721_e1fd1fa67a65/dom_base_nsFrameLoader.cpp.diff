# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsFrameLoader.cpp
# Commit: e1fd1fa67a65
# Full Hash: e1fd1fa67a6554ae8dc206a6fed9e5405a0bf778
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2021-04-01 03:12:48
# Regressor Bug: 1699721
# File Overlap Count: 1
# Description:
#   Bug 1699721 - Part 2: Track BrowserParent lifecycles during process switches, r=kmag
#   
#   This patch contains a large number of changes around the process switching
#   mechanism in order to avoid issues which are caused by a mismatched
#   understanding of the state of the process switch between processes in the
# ==============================================================================

diff -r 2b3a6042d48e -r e1fd1fa67a65 dom/base/nsFrameLoader.cpp
--- a/dom/base/nsFrameLoader.cpp	Wed Mar 31 16:51:58 2021 +0000
+++ b/dom/base/nsFrameLoader.cpp	Wed Mar 31 16:51:58 2021 +0000
@@ -3745,34 +3745,16 @@
   mWillChangeProcess = true;
 
   if (IsRemoteFrame()) {
-    // OOP Browser - Go directly over Browser Parent
     if (auto* browserParent = GetBrowserParent()) {
-      // We're going to be synchronously changing the owner of the
-      // BrowsingContext in the parent process while the current owner may still
-      // have in-flight requests which only the owner is allowed to make. Those
-      // requests will typically trigger assertions if they come from a child
-      // other than the owner.
-      //
-      // To work around this, we record the previous owner at the start of the
-      // process switch, and clear it when we've received a reply from the
-      // child, treating ownership mismatches as warnings in the interim.
-      //
-      // In the future, this sort of issue will probably need to be handled
-      // using ownership epochs, which should be more both flexible and
-      // resilient. For the moment, though, the surrounding process switch code
-      // is enough in flux that we're better off with a workable interim
-      // solution.
-      MOZ_DIAGNOSTIC_ASSERT(mPendingBrowsingContext == GetBrowsingContext());
-      RefPtr<CanonicalBrowsingContext> bc(mPendingBrowsingContext->Canonical());
-      uint64_t targetProcessId = browserParent->Manager()->ChildID();
-      bc->SetInFlightProcessId(targetProcessId);
-      auto callback = [bc, targetProcessId](auto) {
-        bc->ClearInFlightProcessId(targetProcessId);
-      };
-      browserParent->SendWillChangeProcess(callback, callback);
-    }
-    // OOP IFrame - Through Browser Bridge Parent, set on browser child
-    else if (auto* browserBridgeChild = GetBrowserBridgeChild()) {
+      if (auto* bc = CanonicalBrowsingContext::Cast(mPendingBrowsingContext);
+          bc && bc->EverAttached()) {
+        bc->StartUnloadingHost(browserParent->Manager()->ChildID());
+        bc->SetCurrentBrowserParent(nullptr);
+      }
+      // OOP Browser - Go directly over Browser Parent
+      Unused << browserParent->SendWillChangeProcess();
+    } else if (auto* browserBridgeChild = GetBrowserBridgeChild()) {
+      // OOP IFrame - Through Browser Bridge Parent, set on browser child
       Unused << browserBridgeChild->SendWillChangeProcess();
     }
     return;