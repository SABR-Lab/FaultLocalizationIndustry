# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Shape.cpp
# Commit: 1ae4c30bb931
# Full Hash: 1ae4c30bb931a8ba0361ac1a49a2de71340a2ed8
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-06 09:33:16
# Regressor Bug: 1689413
# File Overlap Count: 1
# Description:
#   Bug 1689413 part 1 - Move ShapeCachePtr from BaseShape to Shape. r=jonco
#   
#   This adds a pointer to Shape, but it lets us remove owned BaseShapes in the next patch.
#   
#   Accessing the ShapeTable/ShapeIC is now a bit more efficient because it removes a
# ==============================================================================

diff -r 14445d08a3a4 -r 1ae4c30bb931 js/src/vm/Shape.cpp
--- a/js/src/vm/Shape.cpp	Sat Mar 06 00:15:47 2021 +0000
+++ b/js/src/vm/Shape.cpp	Sat Mar 06 01:05:19 2021 +0000
@@ -148,24 +148,20 @@
     return;
   }
 
-  MOZ_ASSERT(base()->isOwned() && !shape->base()->isOwned());
-
-  BaseShape* nbase = base();
+  ShapeTable* table = cache_.getTablePointer();
+  shape->setTable(table);
+  cache_ = ShapeCachePtr();
 
-  setBase(nbase->baseUnowned());
-  nbase->adoptUnowned(shape->base()->toUnowned());
-
-  shape->setBase(nbase);
+  // Note: for shape tables only sizeof(ShapeTable) is tracked. See the TODO in
+  // Shape::hashify.
+  RemoveCellMemory(this, sizeof(ShapeTable), MemoryUse::ShapeCache);
+  AddCellMemory(shape, sizeof(ShapeTable), MemoryUse::ShapeCache);
 }
 
 /* static */
 bool Shape::hashify(JSContext* cx, Shape* shape) {
   MOZ_ASSERT(!shape->hasTable());
 
-  if (!shape->ensureOwnBaseShape(cx)) {
-    return false;
-  }
-
   UniquePtr<ShapeTable> table =
       cx->make_unique<ShapeTable>(shape->entryCount());
   if (!table) {
@@ -176,24 +172,23 @@
     return false;
   }
 
-  BaseShape* base = shape->base();
-  base->maybePurgeCache(cx->defaultFreeOp());
-  base->setTable(table.release());
+  shape->maybePurgeCache(cx->defaultFreeOp());
+  shape->setTable(table.release());
   // TODO: The contents of ShapeTable is not currently tracked, only the object
   // itself.
-  AddCellMemory(base, sizeof(ShapeTable), MemoryUse::ShapeCache);
+  AddCellMemory(shape, sizeof(ShapeTable), MemoryUse::ShapeCache);
   return true;
 }
 
-void ShapeCachePtr::maybePurgeCache(JSFreeOp* fop, BaseShape* base) {
+void ShapeCachePtr::maybePurgeCache(JSFreeOp* fop, Shape* shape) {
   if (isTable()) {
     ShapeTable* table = getTablePointer();
     if (table->freeList() == SHAPE_INVALID_SLOT) {
-      fop->delete_(base, getTablePointer(), MemoryUse::ShapeCache);
+      fop->delete_(shape, getTablePointer(), MemoryUse::ShapeCache);
       p = 0;
     }
   } else if (isIC()) {
-    fop->delete_<ShapeIC>(base, getICPointer(), MemoryUse::ShapeCache);
+    fop->delete_<ShapeIC>(shape, getICPointer(), MemoryUse::ShapeCache);
     p = 0;
   }
 }
@@ -202,10 +197,6 @@
 bool Shape::cachify(JSContext* cx, Shape* shape) {
   MOZ_ASSERT(!shape->hasTable() && !shape->hasIC());
 
-  if (!shape->ensureOwnBaseShape(cx)) {
-    return false;
-  }
-
   UniquePtr<ShapeIC> ic = cx->make_unique<ShapeIC>();
   if (!ic) {
     return false;
@@ -215,8 +206,8 @@
     return false;
   }
 
-  shape->base()->setIC(ic.release());
-  AddCellMemory(shape->base(), sizeof(ShapeIC), MemoryUse::ShapeCache);
+  shape->setIC(ic.release());
+  AddCellMemory(shape, sizeof(ShapeIC), MemoryUse::ShapeCache);
   return true;
 }
 
@@ -309,11 +300,11 @@
   }
 }
 
-inline void ShapeCachePtr::destroy(JSFreeOp* fop, BaseShape* base) {
+inline void ShapeCachePtr::destroy(JSFreeOp* fop, Shape* shape) {
   if (isTable()) {
-    fop->delete_(base, getTablePointer(), MemoryUse::ShapeCache);
+    fop->delete_(shape, getTablePointer(), MemoryUse::ShapeCache);
   } else if (isIC()) {
-    fop->delete_(base, getICPointer(), MemoryUse::ShapeCache);
+    fop->delete_(shape, getICPointer(), MemoryUse::ShapeCache);
   }
   p = 0;
 }
@@ -1034,11 +1025,8 @@
       }
     }
 
-    if (updateLast) {
-      shape->base()->adoptUnowned(nbase);
-    } else {
-      shape->setBase(nbase);
-    }
+    MOZ_ASSERT(!shape->base()->isOwned());
+    shape->setBase(nbase);
 
     shape->setSlot(slot);
     shape->attrs = uint8_t(attrs);
@@ -1140,11 +1128,8 @@
       return nullptr;
     }
 
-    if (updateLast) {
-      shape->base()->adoptUnowned(nbase);
-    } else {
-      shape->setBase(nbase);
-    }
+    MOZ_ASSERT(!shape->base()->isOwned());
+    shape->setBase(nbase);
 
     shape->setSlot(SHAPE_INVALID_SLOT);
     shape->attrs = uint8_t(attrs);
@@ -1430,7 +1415,8 @@
       return false;
     }
 
-    obj->as<NativeObject>().lastProperty()->base()->adoptUnowned(nbase);
+    MOZ_ASSERT(!obj->as<NativeObject>().lastProperty()->base()->isOwned());
+    obj->as<NativeObject>().lastProperty()->setBase(nbase);
     return true;
   }
 
@@ -1462,7 +1448,8 @@
     return false;
   }
 
-  obj->lastProperty()->base()->adoptUnowned(nbase);
+  MOZ_ASSERT(!obj->lastProperty()->base()->isOwned());
+  obj->lastProperty()->setBase(nbase);
   return true;
 }
 
@@ -1536,25 +1523,13 @@
 }
 
 void BaseShape::traceChildren(JSTracer* trc) {
-  traceChildrenSkipShapeCache(trc);
-  traceShapeCache(trc);
-}
-
-void BaseShape::traceChildrenSkipShapeCache(JSTracer* trc) {
   if (isOwned()) {
     TraceEdge(trc, &unowned_, "base");
   }
-
-  assertConsistency();
-}
-
-void BaseShape::traceShapeCache(JSTracer* trc) {
-  AutoCheckCannotGC nogc;
-  cache_.trace(trc);
 }
 
 #ifdef DEBUG
-bool BaseShape::canSkipMarkingShapeCache(Shape* lastShape) {
+bool Shape::canSkipMarkingShapeCache() {
   // Check that every shape in the shape table will be marked by marking
   // |lastShape|.
   AutoCheckCannotGC nogc;
@@ -1564,7 +1539,7 @@
   }
 
   uint32_t count = 0;
-  for (Shape::Range<NoGC> r(lastShape); !r.empty(); r.popFront()) {
+  for (Shape::Range<NoGC> r(this); !r.empty(); r.popFront()) {
     Shape* shape = &r.front();
     ShapeTable::Entry& entry =
         cache.getTablePointer()->search<MaybeAdding::NotAdding>(shape->propid(),
@@ -1592,12 +1567,6 @@
 
 #endif  // JSGC_HASH_TABLE_CHECKS
 
-void BaseShape::finalize(JSFreeOp* fop) {
-  if (cache_.isInitialized()) {
-    cache_.destroy(fop, this);
-  }
-}
-
 inline InitialShapeEntry::InitialShapeEntry() : shape(nullptr), proto() {}
 
 inline InitialShapeEntry::InitialShapeEntry(Shape* shape,
@@ -1822,6 +1791,9 @@
   if (!inDictionary() && children.isShapeSet()) {
     fop->delete_(this, children.toShapeSet(), MemoryUse::ShapeChildren);
   }
+  if (cache_.isInitialized()) {
+    cache_.destroy(fop, this);
+  }
 }
 
 void Shape::fixupDictionaryShapeAfterMovingGC() {