# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Shape.h
# Commit: 1ae4c30bb931
# Full Hash: 1ae4c30bb931a8ba0361ac1a49a2de71340a2ed8
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-06 09:33:16
# Regressor Bug: 1689413
# File Overlap Count: 1
# Description:
#   Bug 1689413 part 1 - Move ShapeCachePtr from BaseShape to Shape. r=jonco
#   
#   This adds a pointer to Shape, but it lets us remove owned BaseShapes in the next patch.
#   
#   Accessing the ShapeTable/ShapeIC is now a bit more efficient because it removes a
# ==============================================================================

diff -r 14445d08a3a4 -r 1ae4c30bb931 js/src/vm/Shape.h
--- a/js/src/vm/Shape.h	Sat Mar 06 00:15:47 2021 +0000
+++ b/js/src/vm/Shape.h	Sat Mar 06 01:05:19 2021 +0000
@@ -573,9 +573,9 @@
     p = icptr;
   }
 
-  void destroy(JSFreeOp* fop, BaseShape* base);
+  void destroy(JSFreeOp* fop, Shape* shape);
 
-  void maybePurgeCache(JSFreeOp* fop, BaseShape* base);
+  void maybePurgeCache(JSFreeOp* fop, Shape* shape);
 
   void trace(JSTracer* trc);
 
@@ -706,14 +706,11 @@
   /* For owned BaseShapes, the canonical unowned BaseShape. */
   GCPtrUnownedBaseShape unowned_;
 
-  /* For owned BaseShapes, the shape's shape table. */
-  ShapeCachePtr cache_;
-
   BaseShape(const BaseShape& base) = delete;
   BaseShape& operator=(const BaseShape& other) = delete;
 
  public:
-  void finalize(JSFreeOp* fop);
+  void finalize(JSFreeOp* fop) {}
 
   explicit inline BaseShape(const StackBaseShape& base);
 
@@ -732,58 +729,6 @@
 
   ObjectFlags objectFlags() const { return flags; }
 
-  bool hasTable() const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return cache_.isTable();
-  }
-
-  bool hasIC() const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return cache_.isIC();
-  }
-
-  void setTable(ShapeTable* table) {
-    MOZ_ASSERT(isOwned());
-    cache_.initializeTable(table);
-  }
-
-  void setIC(ShapeIC* ic) {
-    MOZ_ASSERT(isOwned());
-    cache_.initializeIC(ic);
-  }
-
-  ShapeCachePtr getCache(const AutoKeepShapeCaches&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return cache_;
-  }
-
-  ShapeCachePtr getCache(const JS::AutoCheckCannotGC&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return cache_;
-  }
-
-  ShapeTable* maybeTable(const AutoKeepShapeCaches&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return (cache_.isTable()) ? cache_.getTablePointer() : nullptr;
-  }
-
-  ShapeTable* maybeTable(const JS::AutoCheckCannotGC&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return (cache_.isTable()) ? cache_.getTablePointer() : nullptr;
-  }
-
-  ShapeIC* maybeIC(const AutoKeepShapeCaches&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return (cache_.isIC()) ? cache_.getICPointer() : nullptr;
-  }
-
-  ShapeIC* maybeIC(const JS::AutoCheckCannotGC&) const {
-    MOZ_ASSERT_IF(cache_.isInitialized(), isOwned());
-    return (cache_.isIC()) ? cache_.getICPointer() : nullptr;
-  }
-
-  void maybePurgeCache(JSFreeOp* fop) { cache_.maybePurgeCache(fop, this); }
-
   /*
    * Lookup base shapes from the zone's baseShapes table, adding if not
    * already found.
@@ -808,11 +753,6 @@
   static const JS::TraceKind TraceKind = JS::TraceKind::BaseShape;
 
   void traceChildren(JSTracer* trc);
-  void traceChildrenSkipShapeCache(JSTracer* trc);
-
-#ifdef DEBUG
-  bool canSkipMarkingShapeCache(Shape* lastShape);
-#endif
 
  private:
   static void staticAsserts() {
@@ -822,8 +762,6 @@
                   "Things inheriting from gc::Cell must have a size that's "
                   "a multiple of gc::CellAlignBytes");
   }
-
-  void traceShapeCache(JSTracer* trc);
 };
 
 class UnownedBaseShape : public BaseShape {};
@@ -978,6 +916,9 @@
   GCPtrShape parent; /* parent node, reverse for..in order */
   friend class DictionaryShapeLink;
 
+  // The shape's ShapeTable or ShapeIC.
+  ShapeCachePtr cache_;
+
   union {
     // Valid when !inDictionary().
     ShapeChildren children;
@@ -1047,28 +988,36 @@
                                                const AutoKeepShapeCaches& keep);
 
  public:
-  bool hasTable() const { return base()->hasTable(); }
-  bool hasIC() const { return base()->hasIC(); }
+  bool hasTable() const { return cache_.isTable(); }
+
+  bool hasIC() const { return cache_.isIC(); }
+
+  void setTable(ShapeTable* table) { cache_.initializeTable(table); }
 
-  ShapeIC* maybeIC(const AutoKeepShapeCaches& keep) const {
-    return base()->maybeIC(keep);
-  }
-  ShapeIC* maybeIC(const JS::AutoCheckCannotGC& check) const {
-    return base()->maybeIC(check);
+  void setIC(ShapeIC* ic) { cache_.initializeIC(ic); }
+
+  ShapeCachePtr getCache(const AutoKeepShapeCaches&) const { return cache_; }
+
+  ShapeCachePtr getCache(const JS::AutoCheckCannotGC&) const { return cache_; }
+
+  ShapeTable* maybeTable(const AutoKeepShapeCaches&) const {
+    return cache_.isTable() ? cache_.getTablePointer() : nullptr;
   }
-  ShapeTable* maybeTable(const AutoKeepShapeCaches& keep) const {
-    return base()->maybeTable(keep);
-  }
-  ShapeTable* maybeTable(const JS::AutoCheckCannotGC& check) const {
-    return base()->maybeTable(check);
+
+  ShapeTable* maybeTable(const JS::AutoCheckCannotGC&) const {
+    return cache_.isTable() ? cache_.getTablePointer() : nullptr;
   }
-  ShapeCachePtr getCache(const AutoKeepShapeCaches& keep) const {
-    return base()->getCache(keep);
+
+  ShapeIC* maybeIC(const AutoKeepShapeCaches&) const {
+    return cache_.isIC() ? cache_.getICPointer() : nullptr;
   }
-  ShapeCachePtr getCache(const JS::AutoCheckCannotGC& check) const {
-    return base()->getCache(check);
+
+  ShapeIC* maybeIC(const JS::AutoCheckCannotGC&) const {
+    return cache_.isIC() ? cache_.getICPointer() : nullptr;
   }
 
+  void maybePurgeCache(JSFreeOp* fop) { cache_.maybePurgeCache(fop, this); }
+
   bool appendShapeToIC(jsid id, Shape* shape,
                        const JS::AutoCheckCannotGC& check) {
     MOZ_ASSERT(hasIC());
@@ -1398,6 +1347,10 @@
 
   void traceChildren(JSTracer* trc);
 
+#ifdef DEBUG
+  bool canSkipMarkingShapeCache();
+#endif
+
   MOZ_ALWAYS_INLINE Shape* search(JSContext* cx, jsid id);
   MOZ_ALWAYS_INLINE Shape* searchLinear(jsid id);
 
