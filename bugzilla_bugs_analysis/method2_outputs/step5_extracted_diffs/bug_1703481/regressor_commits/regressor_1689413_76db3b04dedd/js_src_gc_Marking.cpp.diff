# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Marking.cpp
# Commit: 76db3b04dedd
# Full Hash: 76db3b04deddfd76d1c3a386b9d9c12c85ff238d
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-06 09:33:16
# Regressor Bug: 1689413
# File Overlap Count: 1
# Description:
#   Bug 1689413 part 1 - Move ShapeCachePtr from BaseShape to Shape. r=jonco
#   
#   This adds a pointer to Shape, but it lets us remove owned BaseShapes in the next patch.
#   
#   Accessing the ShapeTable/ShapeIC is now a bit more efficient because it removes a
# ==============================================================================

diff -r 95b6c826ad97 -r 76db3b04dedd js/src/gc/Marking.cpp
--- a/js/src/gc/Marking.cpp	Fri Mar 05 17:42:48 2021 +0000
+++ b/js/src/gc/Marking.cpp	Fri Mar 05 19:10:04 2021 +0000
@@ -1249,6 +1249,8 @@
     }
   }
 
+  cache_.trace(trc);
+
   if (hasGetterObject()) {
     TraceManuallyBarrieredEdge(trc, &asAccessorShape().getterObj, "getter");
   }
@@ -1260,14 +1262,10 @@
   MOZ_ASSERT(shape->isMarked(markColor()));
 
   do {
-    // Special case: if a base shape has a shape table then all its pointers
-    // must point to this shape or an anscestor.  Since these pointers will
-    // be traced by this loop they do not need to be traced here as well.
     BaseShape* base = shape->base();
     checkTraversedEdge(shape, base);
     if (mark(base)) {
-      MOZ_ASSERT(base->canSkipMarkingShapeCache(shape));
-      base->traceChildrenSkipShapeCache(this);
+      base->traceChildren(this);
     }
 
     markAndTraverseEdge(shape, shape->propidRef().get());
@@ -1279,6 +1277,11 @@
       markAndTraverseEdge(shape, shape->dictNext.toObject());
     }
 
+    // Special case: if a shape has a shape table then all its pointers
+    // must point to this shape or an anscestor.  Since these pointers will
+    // be traced by this loop they do not need to be traced here as well.
+    MOZ_ASSERT(shape->canSkipMarkingShapeCache());
+
     // When triggered between slices on behalf of a barrier, these
     // objects may reside in the nursery, so require an extra check.
     // FIXME: Bug 1157967 - remove the isTenured checks.