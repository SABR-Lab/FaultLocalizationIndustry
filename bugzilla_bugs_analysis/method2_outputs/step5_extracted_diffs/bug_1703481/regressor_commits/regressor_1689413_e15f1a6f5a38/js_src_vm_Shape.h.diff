# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Shape.h
# Commit: e15f1a6f5a38
# Full Hash: e15f1a6f5a38b276216c77f2827945b6f5ec4ea9
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-06 09:33:16
# Regressor Bug: 1689413
# File Overlap Count: 1
# Description:
#   Bug 1689413 part 9 - Move proto from ObjectGroup to BaseShape. r=jonco
#   
#   The ObjectGroup still stores the proto as well but we don't really use it anymore.
#   This is simpler than removing the group's proto now because that would result in
#   "empty" groups and the group table then doesn't make sense anymore.
# ==============================================================================

diff -r 95fa0ec36f7a -r e15f1a6f5a38 js/src/vm/Shape.h
--- a/js/src/vm/Shape.h	Fri Mar 05 19:10:08 2021 +0000
+++ b/js/src/vm/Shape.h	Fri Mar 05 19:10:08 2021 +0000
@@ -626,18 +626,13 @@
  * whose entries are all owned by that dictionary. Unowned Shapes are all in
  * the property tree.
  *
- * BaseShapes compactly store information common to many shapes. In a given zone
- * there is a single BaseShape for each combination of BaseShape information.
- *
- * BaseShapes additionally encode some information about the referring object
- * itself. This includes the object's class and various flags that may be set
- * for the object. Except for the class, this information is mutable and may
- * change when the object has an established property lineage. On such changes
- * the entire property lineage is not updated, but rather only the last property
- * (and its base shape). This works because only the object's last property is
- * used to query information about the object. Care must be taken to call
- * JSObject::canRemoveLastProperty when unwinding an object to an earlier
- * property, however.
+ * BaseShapes store the object's class, realm and prototype. The prototype is
+ * mutable and may change when the object has an established property lineage.
+ * On such changes the entire property lineage is not updated, but rather only
+ * the last property (and its base shape). This works because only the object's
+ * last property is used to query information about the object. Care must be
+ * taken to call JSObject::canRemoveLastProperty when unwinding an object to an
+ * earlier property, however.
  */
 
 class AccessorShape;
@@ -677,10 +672,7 @@
 
  private:
   JS::Realm* realm_;
-#ifndef JS_64BIT
-  // Temporary padding to respect MinCellSize.
-  uint64_t padding_ = 0;
-#endif
+  GCPtr<TaggedProto> proto_;
 
   BaseShape(const BaseShape& base) = delete;
   BaseShape& operator=(const BaseShape& other) = delete;
@@ -699,13 +691,16 @@
   }
   JS::Compartment* maybeCompartment() const { return compartment(); }
 
+  TaggedProto proto() const { return proto_; }
+
   void setRealmForMergeRealms(JS::Realm* realm) { realm_ = realm; }
+  void setProtoForMergeRealms(TaggedProto proto) { proto_ = proto; }
 
   /*
    * Lookup base shapes from the zone's baseShapes table, adding if not
    * already found.
    */
-  static BaseShape* get(JSContext* cx, StackBaseShape& base);
+  static BaseShape* get(JSContext* cx, Handle<StackBaseShape> base);
 
   static const JS::TraceKind TraceKind = JS::TraceKind::BaseShape;
 
@@ -717,6 +712,10 @@
     return offsetof(BaseShape, realm_);
   }
 
+  static constexpr size_t offsetOfProto() {
+    return offsetof(BaseShape, proto_);
+  }
+
  private:
   static void staticAsserts() {
     static_assert(offsetOfClasp() == offsetof(JS::shadow::BaseShape, clasp));
@@ -731,30 +730,42 @@
 struct StackBaseShape : public DefaultHasher<WeakHeapPtr<BaseShape*>> {
   const JSClass* clasp;
   JS::Realm* realm;
+  TaggedProto proto;
 
-  inline StackBaseShape(const JSClass* clasp, JS::Realm* realm);
+  inline StackBaseShape(const JSClass* clasp, JS::Realm* realm,
+                        TaggedProto proto);
 
   struct Lookup {
     const JSClass* clasp;
     JS::Realm* realm;
+    TaggedProto proto;
 
     MOZ_IMPLICIT Lookup(const StackBaseShape& base)
-        : clasp(base.clasp), realm(base.realm) {}
+        : clasp(base.clasp), realm(base.realm), proto(base.proto) {}
 
     MOZ_IMPLICIT Lookup(BaseShape* base)
-        : clasp(base->clasp()), realm(base->realm()) {}
+        : clasp(base->clasp()), realm(base->realm()), proto(base->proto()) {}
   };
 
   static HashNumber hash(const Lookup& lookup) {
-    return mozilla::HashGeneric(lookup.clasp, lookup.realm);
+    HashNumber hash = MovableCellHasher<TaggedProto>::hash(lookup.proto);
+    return mozilla::AddToHash(hash,
+                              mozilla::HashGeneric(lookup.clasp, lookup.realm));
   }
   static inline bool match(const WeakHeapPtr<BaseShape*>& key,
                            const Lookup& lookup) {
     return key.unbarrieredGet()->clasp() == lookup.clasp &&
-           key.unbarrieredGet()->realm() == lookup.realm;
+           key.unbarrieredGet()->realm() == lookup.realm &&
+           key.unbarrieredGet()->proto() == lookup.proto;
   }
+
+  // StructGCPolicy implementation.
+  void trace(JSTracer* trc);
 };
 
+template <typename Wrapper>
+class WrappedPtrOperations<StackBaseShape, Wrapper> {};
+
 static MOZ_ALWAYS_INLINE js::HashNumber HashId(jsid id) {
   // HashGeneric alone would work, but bits of atom and symbol addresses
   // could then be recovered from the hash code. See bug 1330769.
@@ -1038,8 +1049,10 @@
     return base()->maybeCompartment();
   }
 
-  static Shape* setObjectFlag(JSContext* cx, ObjectFlag flag, TaggedProto proto,
-                              Shape* last);
+  TaggedProto proto() const { return base()->proto(); }
+
+  static Shape* setObjectFlag(JSContext* cx, ObjectFlag flag, Shape* last);
+  static Shape* setProto(JSContext* cx, TaggedProto proto, Shape* last);
 
   ObjectFlags objectFlags() const { return objectFlags_; }
   bool hasObjectFlag(ObjectFlag flag) const {
@@ -1422,12 +1435,6 @@
    */
   WeakHeapPtr<Shape*> shape;
 
-  /*
-   * Matching prototype for the entry. The shape of an object determines its
-   * prototype, but the prototype cannot be determined from the shape itself.
-   */
-  WeakHeapPtr<TaggedProto> proto;
-
   /* State used to determine a match on an initial shape. */
   struct Lookup {
     const JSClass* clasp;
@@ -1446,7 +1453,7 @@
   };
 
   inline InitialShapeEntry();
-  inline InitialShapeEntry(Shape* shape, const TaggedProto& proto);
+  inline explicit InitialShapeEntry(Shape* shape);
 
   static HashNumber hash(const Lookup& lookup) {
     HashNumber hash = MovableCellHasher<TaggedProto>::hash(lookup.proto);
@@ -1460,7 +1467,7 @@
            lookup.realm == shape->realm() &&
            lookup.nfixed == shape->numFixedSlots() &&
            lookup.objectFlags == shape->objectFlags() &&
-           key.proto.unbarrieredGet() == lookup.proto;
+           lookup.proto == shape->proto();
   }
   static void rekey(InitialShapeEntry& k, const InitialShapeEntry& newKey) {
     k = newKey;
@@ -1468,15 +1475,11 @@
 
   bool needsSweep() {
     Shape* ushape = shape.unbarrieredGet();
-    TaggedProto uproto = proto.unbarrieredGet();
-    JSObject* protoObj = uproto.raw();
-    return (
-        gc::IsAboutToBeFinalizedUnbarriered(&ushape) ||
-        (uproto.isObject() && gc::IsAboutToBeFinalizedUnbarriered(&protoObj)));
+    return gc::IsAboutToBeFinalizedUnbarriered(&ushape);
   }
 
   bool operator==(const InitialShapeEntry& other) const {
-    return shape == other.shape && proto == other.proto;
+    return shape == other.shape;
   }
 };
 
