# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Shape.h
# Commit: e9c2f256240a
# Full Hash: e9c2f256240a1f9bb09b10ac641bbd141eedb809
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-03-06 09:33:16
# Regressor Bug: 1689413
# File Overlap Count: 1
# Description:
#   Bug 1689413 part 2 - Remove owned BaseShapes. r=jonco
#   
#   At this point all BaseShapes are unowned (= immutable, shared) so we can remove the
#   UnownedBaseShape type and the `BaseShape::unowned_` field.
#   
# ==============================================================================

diff -r 1ae4c30bb931 -r e9c2f256240a js/src/vm/Shape.h
--- a/js/src/vm/Shape.h	Sat Mar 06 01:05:19 2021 +0000
+++ b/js/src/vm/Shape.h	Sat Mar 06 01:05:19 2021 +0000
@@ -619,39 +619,15 @@
 /*
  * Shapes encode information about both a property lineage *and* a particular
  * property. This information is split across the Shape and the BaseShape
- * at shape->base(). Both Shape and BaseShape can be either owned or unowned
- * by, respectively, the Object or Shape referring to them.
+ * at shape->base(). Shapes can be either owned or unowned by the object
+ * referring to them. BaseShapes are always unowned and immutable.
  *
  * Owned Shapes are used in dictionary objects, and form a doubly linked list
  * whose entries are all owned by that dictionary. Unowned Shapes are all in
  * the property tree.
  *
- * Owned BaseShapes are used for shapes which have shape tables, including the
- * last properties in all dictionaries. Unowned BaseShapes compactly store
- * information common to many shapes. In a given zone there is a single
- * BaseShape for each combination of BaseShape information. This information is
- * cloned in owned BaseShapes so that information can be quickly looked up for a
- * given object or shape without regard to whether the base shape is owned or
- * not.
- *
- * All combinations of owned/unowned Shapes/BaseShapes are possible:
- *
- * Owned Shape, Owned BaseShape:
- *
- *     Last property in a dictionary object. The BaseShape is transferred from
- *     property to property as the object's last property changes.
- *
- * Owned Shape, Unowned BaseShape:
- *
- *     Property in a dictionary object other than the last one.
- *
- * Unowned Shape, Owned BaseShape:
- *
- *     Property in the property tree which has a shape table.
- *
- * Unowned Shape, Unowned BaseShape:
- *
- *     Property in the property tree which does not have a shape table.
+ * BaseShapes compactly store information common to many shapes. In a given zone
+ * there is a single BaseShape for each combination of BaseShape information.
  *
  * BaseShapes additionally encode some information about the referring object
  * itself. This includes the object's class and various flags that may be set
@@ -666,7 +642,6 @@
 
 class AccessorShape;
 class Shape;
-class UnownedBaseShape;
 struct StackBaseShape;
 
 // Flags set on the Shape which describe the referring object. Once set these
@@ -703,8 +678,10 @@
 
   ObjectFlags flags;
 
-  /* For owned BaseShapes, the canonical unowned BaseShape. */
-  GCPtrUnownedBaseShape unowned_;
+#ifndef JS_64BIT
+  // Temporary padding to respect MinCellSize.
+  uint64_t padding_ = 0;
+#endif
 
   BaseShape(const BaseShape& base) = delete;
   BaseShape& operator=(const BaseShape& other) = delete;
@@ -715,17 +692,7 @@
   explicit inline BaseShape(const StackBaseShape& base);
 
   /* Not defined: BaseShapes must not be stack allocated. */
-  ~BaseShape();
-
-  bool isOwned() const { return unowned_ != nullptr; }
-
-  static void copyFromUnowned(BaseShape& dest, UnownedBaseShape& src);
-  inline void adoptUnowned(UnownedBaseShape* other);
-
-  void setOwned(UnownedBaseShape* unowned) {
-    MOZ_ASSERT(unowned);
-    unowned_ = unowned;
-  }
+  ~BaseShape() = delete;
 
   ObjectFlags objectFlags() const { return flags; }
 
@@ -733,19 +700,7 @@
    * Lookup base shapes from the zone's baseShapes table, adding if not
    * already found.
    */
-  static UnownedBaseShape* getUnowned(JSContext* cx, StackBaseShape& base);
-
-  /* Get the canonical base shape. */
-  inline UnownedBaseShape* unowned();
-
-  /* Get the canonical base shape for an owned one. */
-  inline UnownedBaseShape* baseUnowned();
-
-  /* Get the canonical base shape for an unowned one (i.e. identity). */
-  inline UnownedBaseShape* toUnowned();
-
-  /* Check that an owned base shape is consistent with its unowned base. */
-  void assertConsistency();
+  static BaseShape* get(JSContext* cx, StackBaseShape& base);
 
   /* For JIT usage */
   static inline size_t offsetOfFlags() { return offsetof(BaseShape, flags); }
@@ -764,24 +719,8 @@
   }
 };
 
-class UnownedBaseShape : public BaseShape {};
-
-UnownedBaseShape* BaseShape::unowned() {
-  return isOwned() ? baseUnowned() : toUnowned();
-}
-
-UnownedBaseShape* BaseShape::toUnowned() {
-  MOZ_ASSERT(!isOwned() && !unowned_);
-  return static_cast<UnownedBaseShape*>(this);
-}
-
-UnownedBaseShape* BaseShape::baseUnowned() {
-  MOZ_ASSERT(isOwned() && unowned_);
-  return unowned_;
-}
-
-/* Entries for the per-zone baseShapes set of unowned base shapes. */
-struct StackBaseShape : public DefaultHasher<WeakHeapPtr<UnownedBaseShape*>> {
+/* Entries for the per-zone baseShapes set. */
+struct StackBaseShape : public DefaultHasher<WeakHeapPtr<BaseShape*>> {
   ObjectFlags flags;
   const JSClass* clasp;
 
@@ -798,22 +737,18 @@
     MOZ_IMPLICIT Lookup(const StackBaseShape& base)
         : flags(base.flags), clasp(base.clasp) {}
 
-    MOZ_IMPLICIT Lookup(UnownedBaseShape* base)
-        : flags(base->objectFlags()), clasp(base->clasp()) {
-      MOZ_ASSERT(!base->isOwned());
-    }
+    MOZ_IMPLICIT Lookup(BaseShape* base)
+        : flags(base->objectFlags()), clasp(base->clasp()) {}
 
-    explicit Lookup(const WeakHeapPtr<UnownedBaseShape*>& base)
+    explicit Lookup(const WeakHeapPtr<BaseShape*>& base)
         : flags(base.unbarrieredGet()->objectFlags()),
-          clasp(base.unbarrieredGet()->clasp()) {
-      MOZ_ASSERT(!base.unbarrieredGet()->isOwned());
-    }
+          clasp(base.unbarrieredGet()->clasp()) {}
   };
 
   static HashNumber hash(const Lookup& lookup) {
     return mozilla::HashGeneric(lookup.flags.toRaw(), lookup.clasp);
   }
-  static inline bool match(const WeakHeapPtr<UnownedBaseShape*>& key,
+  static inline bool match(const WeakHeapPtr<BaseShape*>& key,
                            const Lookup& lookup) {
     return key.unbarrieredGet()->flags == lookup.flags &&
            key.unbarrieredGet()->clasp() == lookup.clasp;
@@ -847,9 +782,8 @@
 
 namespace js {
 
-using BaseShapeSet =
-    JS::WeakCache<JS::GCHashSet<WeakHeapPtr<UnownedBaseShape*>, StackBaseShape,
-                                SystemAllocPolicy>>;
+using BaseShapeSet = JS::WeakCache<
+    JS::GCHashSet<WeakHeapPtr<BaseShape*>, StackBaseShape, SystemAllocPolicy>>;
 
 class Shape : public gc::CellWithTenuredGCPointer<gc::TenuredCell, BaseShape> {
   friend class ::JSObject;
@@ -972,15 +906,6 @@
     parent = p;
   }
 
-  bool ensureOwnBaseShape(JSContext* cx) {
-    if (base()->isOwned()) {
-      return true;
-    }
-    return makeOwnBaseShape(cx);
-  }
-
-  bool makeOwnBaseShape(JSContext* cx);
-
   [[nodiscard]] MOZ_ALWAYS_INLINE bool maybeCreateCacheForLookup(JSContext* cx);
 
   MOZ_ALWAYS_INLINE void updateDictionaryTable(ShapeTable* table,
@@ -1113,7 +1038,7 @@
   inline Shape(const StackShape& other, uint32_t nfixed);
 
   /* Used by EmptyShape (see jsscopeinlines.h). */
-  inline Shape(UnownedBaseShape* base, uint32_t nfixed);
+  inline Shape(BaseShape* base, uint32_t nfixed);
 
   /* Copy constructor disabled, to avoid misuse of the above form. */
   Shape(const Shape& other) = delete;
@@ -1190,8 +1115,8 @@
 
   bool matchesParamsAfterId(BaseShape* base, uint32_t aslot, unsigned aattrs,
                             GetterOp rawGetter, SetterOp rawSetter) const {
-    return base->unowned() == this->base()->unowned() && maybeSlot() == aslot &&
-           attrs == aattrs && getter() == rawGetter && setter() == rawSetter;
+    return base == this->base() && maybeSlot() == aslot && attrs == aattrs &&
+           getter() == rawGetter && setter() == rawSetter;
   }
 
   static bool isDataProperty(unsigned attrs, GetterOp getter, SetterOp setter) {
@@ -1292,6 +1217,7 @@
  private:
   void setBase(BaseShape* base) {
     MOZ_ASSERT(base);
+    MOZ_ASSERT(inDictionary());
     setHeaderPtr(base);
   }
 
@@ -1427,11 +1353,9 @@
 };
 
 struct EmptyShape : public js::Shape {
-  EmptyShape(UnownedBaseShape* base, uint32_t nfixed)
-      : js::Shape(base, nfixed) {}
+  EmptyShape(BaseShape* base, uint32_t nfixed) : js::Shape(base, nfixed) {}
 
-  static Shape* new_(JSContext* cx, Handle<UnownedBaseShape*> base,
-                     uint32_t nfixed);
+  static Shape* new_(JSContext* cx, Handle<BaseShape*> base, uint32_t nfixed);
 
   /*
    * Lookup an initial shape matching the given parameters, creating an empty
@@ -1537,7 +1461,7 @@
 
 struct StackShape {
   /* For performance, StackShape only roots when absolutely necessary. */
-  UnownedBaseShape* base;
+  BaseShape* base;
   jsid propid;
   GetterOp rawGetter;
   SetterOp rawSetter;
@@ -1545,7 +1469,7 @@
   uint8_t attrs;
   uint8_t mutableFlags;
 
-  explicit StackShape(UnownedBaseShape* base, jsid propid, uint32_t slot,
+  explicit StackShape(BaseShape* base, jsid propid, uint32_t slot,
                       unsigned attrs)
       : base(base),
         propid(propid),
@@ -1560,7 +1484,7 @@
   }
 
   explicit StackShape(Shape* shape)
-      : base(shape->base()->unowned()),
+      : base(shape->base()),
         propid(shape->propidRef()),
         rawGetter(shape->getter()),
         rawSetter(shape->setter()),
@@ -1637,7 +1561,7 @@
     ss().updateGetterSetter(rawGetter, rawSetter);
   }
   void setSlot(uint32_t slot) { ss().setSlot(slot); }
-  void setBase(UnownedBaseShape* base) { ss().base = base; }
+  void setBase(BaseShape* base) { ss().base = base; }
   void setAttrs(uint8_t attrs) { ss().attrs = attrs; }
 };
 
@@ -1673,7 +1597,7 @@
   void trace(JSTracer* trc) override;
 };
 
-inline Shape::Shape(UnownedBaseShape* base, uint32_t nfixed)
+inline Shape::Shape(BaseShape* base, uint32_t nfixed)
     : CellWithTenuredGCPointer(base),
       propid_(JSID_EMPTY),
       immutableFlags(SHAPE_INVALID_SLOT | (nfixed << FIXED_SLOTS_SHIFT)),
