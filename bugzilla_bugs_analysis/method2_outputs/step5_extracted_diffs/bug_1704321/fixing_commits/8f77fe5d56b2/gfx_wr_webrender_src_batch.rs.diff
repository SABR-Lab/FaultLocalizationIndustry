# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/batch.rs
# Commit: 8f77fe5d56b2
# Full Hash: 8f77fe5d56b270ccadf6c361e40412a12e56d4b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2021-04-13 03:56:47
# Description:
#   Bug 1704321 - Handle non-invertible clip transforms for image clip masks. r=gfx-reviewers,bradwerth
#   
#   Not all transforms we encounter for image clip masks are invertible. When the unmap of the
#   world rect back to the local rect fails, we can safely fall back to using a scissor rect.
#   Skipping the scissor rect is an optimization and is not needed for correctness.
# ==============================================================================

diff -r c82840a55458 -r 8f77fe5d56b2 gfx/wr/webrender/src/batch.rs
--- a/gfx/wr/webrender/src/batch.rs	Mon Apr 12 18:46:07 2021 +0000
+++ b/gfx/wr/webrender/src/batch.rs	Mon Apr 12 18:58:20 2021 +0000
@@ -3649,25 +3649,23 @@
                         // by clipping the local clip rect with the backwards transformed target bounds.
                         // If it is not axis-aligned, then we pass the local clip rect through unmodified
                         // to the shader and also set up a scissor rect for the overall target bounds to
-                        // ensure nothing is drawn outside the target.
-                        let (local_rect, scissor_rect) =
-                            if prim_transform_id.transform_kind() == TransformedRectKind::AxisAligned {
-                                let world_rect =
-                                    sub_rect.translate(actual_rect.origin.to_vector()) / global_device_pixel_scale;
-                                (map_local_to_world
-                                    .unmap(&world_rect)
-                                    .expect("bug: should always map as axis-aligned")
-                                    .intersection(&rect)
-                                    .unwrap_or_default(),
-                                 None)
-                            } else {
+                        // ensure nothing is drawn outside the target. If for some reason we can't map the
+                        // rect back to local space, we also fall back to just using a scissor rectangle.
+                        let world_rect =
+                            sub_rect.translate(actual_rect.origin.to_vector()) / global_device_pixel_scale;
+                        let (local_rect, scissor_rect) = match map_local_to_world.unmap(&world_rect) {
+                            Some(local_rect)
+                                if prim_transform_id.transform_kind() == TransformedRectKind::AxisAligned => {
+                                (local_rect.intersection(&rect).unwrap_or_default(), None)
+                            }
+                            _ => {
                                 (rect,
                                  Some(common.sub_rect
                                     .translate(task_origin.to_vector())
                                     .round_out()
                                     .to_i32()))
-                            };
-
+                            }
+                        };
 
                         self.get_batch_list(is_first_clip)
                             .images
