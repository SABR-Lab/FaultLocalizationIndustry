# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/res/cs_clip_image.glsl
# Commit: b641b7f90108
# Full Hash: b641b7f90108a2e6b57186139b450d9ccb80c96c
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2021-04-10 03:36:58
# Regressor Bug: 1682195
# File Overlap Count: 1
# Description:
#   Bug 1682195 - Use scissoring to restrict cs_clip_image rather than discard. r=gw
#   
#   cs_clip_image renders the entire target-space sub-rect, and then uses discard against
#   the local-space bounds to ensure the primitive gets trimmed down to its actual footprint
#   within the larger target-space sub-rect. This can be fairly wasteful and slow.
# ==============================================================================

diff -r 7534ee1e1078 -r b641b7f90108 gfx/wr/webrender/res/cs_clip_image.glsl
--- a/gfx/wr/webrender/res/cs_clip_image.glsl	Fri Apr 09 22:40:49 2021 +0000
+++ b/gfx/wr/webrender/res/cs_clip_image.glsl	Fri Apr 09 22:55:33 2021 +0000
@@ -4,10 +4,9 @@
 
 #include shared,clip_shared
 
-varying vec4 vLocalPos;
+varying vec2 vLocalPos;
 varying vec2 vClipMaskImageUv;
 
-flat varying vec4 vClipMaskUvRect;
 flat varying vec4 vClipMaskUvInnerRect;
 
 #ifdef WR_VERTEX_SHADER
@@ -35,13 +34,48 @@
     return cmi;
 }
 
+struct ClipImageVertexInfo {
+    vec2 local_pos;
+    vec4 world_pos;
+};
+
+// This differs from write_clip_tile_vertex in that we forward transform the
+// primitive's local-space tile rect into the target space. We use scissoring
+// to ensure that the primitive does not draw outside the target bounds.
+ClipImageVertexInfo write_clip_image_vertex(RectWithSize tile_rect,
+                                            RectWithSize local_clip_rect,
+                                            Transform prim_transform,
+                                            Transform clip_transform,
+                                            RectWithSize sub_rect,
+                                            vec2 task_origin,
+                                            vec2 screen_origin,
+                                            float device_pixel_scale) {
+    vec2 local_pos = clamp_rect(tile_rect.p0 + aPosition.xy * tile_rect.size, local_clip_rect);
+    vec4 world_pos = prim_transform.m * vec4(local_pos, 0.0, 1.0);
+    vec4 final_pos = vec4(
+        world_pos.xy * device_pixel_scale + (task_origin - screen_origin) * world_pos.w,
+        0.0,
+        world_pos.w
+    );
+    gl_Position = uTransform * final_pos;
+
+    init_transform_vs(
+        prim_transform.is_axis_aligned
+            ? vec4(vec2(-1.0e16), vec2(1.0e16))
+            : vec4(local_clip_rect.p0, local_clip_rect.p0 + local_clip_rect.size));
+
+    ClipImageVertexInfo vi = ClipImageVertexInfo(local_pos, world_pos);
+    return vi;
+}
+
 void main(void) {
     ClipMaskInstanceImage cmi = fetch_clip_item();
     Transform clip_transform = fetch_transform(cmi.base.clip_transform_id);
     Transform prim_transform = fetch_transform(cmi.base.prim_transform_id);
     ImageSource res = fetch_image_source_direct(cmi.resource_address);
 
-    ClipVertexInfo vi = write_clip_tile_vertex(
+    ClipImageVertexInfo vi = write_clip_image_vertex(
+        cmi.tile_rect,
         cmi.local_rect,
         prim_transform,
         clip_transform,
@@ -51,33 +85,33 @@
         cmi.base.device_pixel_scale
     );
     vLocalPos = vi.local_pos;
-    vClipMaskImageUv = (vi.local_pos.xy - cmi.tile_rect.p0 * vi.local_pos.w) / cmi.tile_rect.size;
+    vec2 uv = (vi.local_pos - cmi.tile_rect.p0) / cmi.tile_rect.size;
 
     vec2 texture_size = vec2(TEX_SIZE(sColor0));
-    vClipMaskUvRect = vec4(res.uv_rect.p0, res.uv_rect.p1 - res.uv_rect.p0) / texture_size.xyxy;
+    vec4 uv_rect = vec4(res.uv_rect.p0, res.uv_rect.p1);
+    vClipMaskImageUv = mix(uv_rect.xy, uv_rect.zw, uv) / texture_size;
+
     // applying a half-texel offset to the UV boundaries to prevent linear samples from the outside
-    vec4 inner_rect = vec4(res.uv_rect.p0, res.uv_rect.p1);
-    vClipMaskUvInnerRect = (inner_rect + vec4(0.5, 0.5, -0.5, -0.5)) / texture_size.xyxy;
+    vClipMaskUvInnerRect = (uv_rect + vec4(0.5, 0.5, -0.5, -0.5)) / texture_size.xyxy;
 }
 #endif
 
 #ifdef WR_FRAGMENT_SHADER
 void main(void) {
-    vec2 local_pos = vLocalPos.xy / vLocalPos.w;
-    float alpha = vLocalPos.w > 0.0 ? init_transform_fs(local_pos) : 0.0;
-
-    // TODO: Handle repeating masks?
-    vec2 clamped_mask_uv = clamp(vClipMaskImageUv, vec2(0.0, 0.0), vLocalPos.ww);
-
-    // Ensure we don't draw outside of our tile.
-    // FIXME(emilio): Can we do this earlier?
-    if (clamped_mask_uv != vClipMaskImageUv)
-        discard;
-
-    vec2 source_uv = clamp(
-        clamped_mask_uv / vLocalPos.w * vClipMaskUvRect.zw + vClipMaskUvRect.xy,
-        vClipMaskUvInnerRect.xy, vClipMaskUvInnerRect.zw);
+    float alpha = init_transform_fs(vLocalPos);
+    vec2 source_uv = clamp(vClipMaskImageUv, vClipMaskUvInnerRect.xy, vClipMaskUvInnerRect.zw);
     float clip_alpha = texture(sColor0, source_uv).r; //careful: texture has type A8
     oFragColor = vec4(alpha * clip_alpha, 1.0, 1.0, 1.0);
 }
+
+#ifdef SWGL_DRAW_SPAN
+void swgl_drawSpanR8() {
+    if (has_valid_transform_bounds()) {
+        return;
+    }
+
+    swgl_commitTextureLinearR8(sColor0, vClipMaskImageUv, vClipMaskUvInnerRect);
+}
 #endif
+
+#endif