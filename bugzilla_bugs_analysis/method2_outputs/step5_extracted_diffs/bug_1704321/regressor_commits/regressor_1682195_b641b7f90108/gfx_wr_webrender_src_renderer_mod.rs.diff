# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/renderer/mod.rs
# Commit: b641b7f90108
# Full Hash: b641b7f90108a2e6b57186139b450d9ccb80c96c
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2021-04-10 03:36:58
# Regressor Bug: 1682195
# File Overlap Count: 1
# Description:
#   Bug 1682195 - Use scissoring to restrict cs_clip_image rather than discard. r=gw
#   
#   cs_clip_image renders the entire target-space sub-rect, and then uses discard against
#   the local-space bounds to ensure the primitive gets trimmed down to its actual footprint
#   within the larger target-space sub-rect. This can be fairly wasteful and slow.
# ==============================================================================

diff -r 7534ee1e1078 -r b641b7f90108 gfx/wr/webrender/src/renderer/mod.rs
--- a/gfx/wr/webrender/src/renderer/mod.rs	Fri Apr 09 22:40:49 2021 +0000
+++ b/gfx/wr/webrender/src/renderer/mod.rs	Fri Apr 09 22:55:33 2021 +0000
@@ -3749,6 +3749,7 @@
     fn draw_clip_batch_list(
         &mut self,
         list: &ClipBatchList,
+        draw_target: &DrawTarget,
         projection: &default::Transform3D<f32>,
         stats: &mut RendererStats,
     ) {
@@ -3803,8 +3804,27 @@
         }
 
         // draw image masks
-        for (mask_texture_id, items) in list.images.iter() {
+        let mut using_scissor = false;
+        for ((mask_texture_id, clip_rect), items) in list.images.iter() {
             let _gm2 = self.gpu_profiler.start_marker("clip images");
+            // Some image masks may require scissoring to ensure they don't draw
+            // outside their task's target bounds. Axis-aligned primitives will
+            // be clamped inside the shader and should not require scissoring.
+            // TODO: We currently assume scissor state is off by default for
+            // alpha targets here, but in the future we may want to track the
+            // current scissor state so that this can be properly saved and
+            // restored here.
+            if let Some(clip_rect) = clip_rect {
+                if !using_scissor {
+                    self.device.enable_scissor();
+                    using_scissor = true;
+                }
+                let scissor_rect = draw_target.build_scissor_rect(Some(*clip_rect));
+                self.device.set_scissor_rect(scissor_rect);
+            } else if using_scissor {
+                self.device.disable_scissor();
+                using_scissor = false;
+            }
             let textures = BatchTextures::composite_rgb(*mask_texture_id);
             self.shaders.borrow_mut().cs_clip_image
                 .bind(&mut self.device, projection, None, &mut self.renderer_errors);
@@ -3815,6 +3835,9 @@
                 stats,
             );
         }
+        if using_scissor {
+            self.device.disable_scissor();
+        }
     }
 
     fn draw_alpha_target(
@@ -3958,6 +3981,7 @@
             self.set_blend(false, FramebufferKind::Other);
             self.draw_clip_batch_list(
                 &target.clip_batcher.primary_clips,
+                &draw_target,
                 projection,
                 stats,
             );
@@ -3968,6 +3992,7 @@
             self.set_blend_mode_multiply(FramebufferKind::Other);
             self.draw_clip_batch_list(
                 &target.clip_batcher.secondary_clips,
+                &draw_target,
                 projection,
                 stats,
             );