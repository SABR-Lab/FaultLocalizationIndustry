# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/batch.rs
# Commit: f3b8d237e29a
# Full Hash: f3b8d237e29af262b2042809e13ce6043b75c922
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2021-04-10 03:36:58
# Regressor Bug: 1682195
# File Overlap Count: 1
# Description:
#   Bug 1682195 - Ensure that area outside image mask is cleared if it is first clip. r=gw
#   
#   This fixes a previous bug in the image mask code that the tile rect caused cs_clip_image
#   to use discard on a first clip, the outside area would be left to whatever the initial value
#   of the texture from texture cache was. Since we need to support trimming down to the tile
# ==============================================================================

diff -r b641b7f90108 -r f3b8d237e29a gfx/wr/webrender/src/batch.rs
--- a/gfx/wr/webrender/src/batch.rs	Fri Apr 09 22:55:33 2021 +0000
+++ b/gfx/wr/webrender/src/batch.rs	Fri Apr 09 22:55:34 2021 +0000
@@ -3573,8 +3573,9 @@
         global_device_pixel_scale: DevicePixelScale,
         task_origin: DevicePoint,
         screen_origin: DevicePoint,
-    ) {
+    ) -> bool {
         let mut is_first_clip = true;
+        let mut clear_to_one = false;
 
         for i in 0 .. clip_node_range.count {
             let clip_instance = clip_store.get_instance_from_range(&clip_node_range, i);
@@ -3683,10 +3684,11 @@
                             });
                     };
 
+                    let clip_spatial_node = &spatial_tree.spatial_nodes[clip_instance.spatial_node_index.0 as usize];
+                    let clip_is_axis_aligned = clip_spatial_node.coordinate_system_id == CoordinateSystemId::root();
+
                     match clip_instance.visible_tiles {
                         Some(ref tiles) => {
-                            let clip_spatial_node = &spatial_tree.spatial_nodes[clip_instance.spatial_node_index.0 as usize];
-                            let clip_is_axis_aligned = clip_spatial_node.coordinate_system_id == CoordinateSystemId::root();
                             let sub_rect_bounds = actual_rect.size.into();
 
                             for tile in tiles {
@@ -3718,6 +3720,15 @@
                         }
                     }
 
+                    // If this is the first clip and either there is a transform or the image rect
+                    // doesn't cover the entire task, then request a clear so that pixels outside
+                    // the image boundaries will be properly initialized.
+                    if is_first_clip &&
+                        (!clip_is_axis_aligned ||
+                         !(map_local_to_world.map(&rect).expect("bug: should always map as axis-aligned")
+                            * global_device_pixel_scale).contains_rect(&actual_rect)) {
+                        clear_to_one = true;
+                    }
                     true
                 }
                 ClipItemKind::BoxShadow { ref source }  => {
@@ -3759,7 +3770,7 @@
                     if clip_instance.flags.contains(ClipNodeFlags::SAME_COORD_SYSTEM) {
                         false
                     } else {
-                        if !self.add_tiled_clip_mask(
+                        if self.add_tiled_clip_mask(
                             actual_rect,
                             rect,
                             clip_instance.spatial_node_index,
@@ -3769,6 +3780,8 @@
                             &common,
                             is_first_clip,
                         ) {
+                            clear_to_one |= is_first_clip;
+                        } else {
                             self.get_batch_list(is_first_clip)
                                 .slow_rectangles
                                 .push(ClipMaskInstanceRect {
@@ -3800,6 +3813,8 @@
 
             is_first_clip &= !added_clip;
         }
+
+        clear_to_one
     }
 }
 