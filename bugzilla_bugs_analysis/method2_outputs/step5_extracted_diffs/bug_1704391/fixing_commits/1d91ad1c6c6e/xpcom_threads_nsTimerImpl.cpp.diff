# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/nsTimerImpl.cpp
# Commit: 1d91ad1c6c6e
# Full Hash: 1d91ad1c6c6ec1d817f264bd97b094c15e43735d
# Author: kriswright <kwright@mozilla.com>
# Date: 2021-04-30 09:28:29
# Description:
#   Bug 1704391 - Address timers cancelled after timer shutdown. r=xpcom-reviewers,nika
#   
#   There is a chance that a timer will be cancelled by its holder after the timer thread and all of the timers have been cleaned up. Doing this can result in a hang on the mutex lock, likely because the mutex is now pointing to something else. I'm not completely familiar with the inner workings of our timers so I'm not sure what the best fix is here. I decided to follow a pattern in our threading shutdown routines and flag the timer shutdown so the timers can't attempt to cancel past a certain point where they would be shutdown anyway. This is tricky because there are timers created during XPCOM shutdown all the way up until we shutdown the timer thread. Checking for the timer thread outside of the lock could also result in a race with timer shutdown. This value is an attempt to address this without breaking timers shutdown.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D113448
# ==============================================================================

diff -r 07b727f23e70 -r 1d91ad1c6c6e xpcom/threads/nsTimerImpl.cpp
--- a/xpcom/threads/nsTimerImpl.cpp	Fri Apr 30 00:43:40 2021 +0000
+++ b/xpcom/threads/nsTimerImpl.cpp	Fri Apr 30 00:58:42 2021 +0000
@@ -394,6 +394,13 @@
 }
 
 void nsTimerImpl::CancelImpl(bool aClearITimer) {
+  if (gXPCOMTimersShutDown) {
+    // Some timers are created during XPCOM shutdown. But if we have already
+    // undergone timer thread shutdown, we will not have a timer to cancel here.
+    MOZ_ASSERT_UNREACHABLE(
+        "Tried to cancel a timer after timers have been freed.");
+    return;
+  }
   Callback cbTrash;
   RefPtr<nsITimer> timerTrash;
 
