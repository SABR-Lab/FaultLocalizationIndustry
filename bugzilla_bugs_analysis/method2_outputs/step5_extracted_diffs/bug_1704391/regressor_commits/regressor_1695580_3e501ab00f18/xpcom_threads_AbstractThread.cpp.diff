# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/AbstractThread.cpp
# Commit: 3e501ab00f18
# Full Hash: 3e501ab00f1855046db1f8db6be58fb35f7c6adc
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-04-07 03:19:44
# Regressor Bug: 1695580
# File Overlap Count: 1
# Description:
#   Bug 1695580 - In xpcom, cancel pending DelayedRunnable timers on shutdown. r=KrisWright
#   
#   Because DelayedRunnables are fire-and-forget, there is no way for a targeted
#   EventTarget to clean them up on shutdown. Thus if a timer fires after
#   EventTarget shutdown it will fail to dispatch the timer event, and avoid
# ==============================================================================

diff -r 2a88ea548a86 -r 3e501ab00f18 xpcom/threads/AbstractThread.cpp
--- a/xpcom/threads/AbstractThread.cpp	Tue Apr 06 20:15:10 2021 +0000
+++ b/xpcom/threads/AbstractThread.cpp	Tue Apr 06 20:15:11 2021 +0000
@@ -31,12 +31,14 @@
 
 class XPCOMThreadWrapper final : public AbstractThread,
                                  public nsIThreadObserver,
-                                 public nsIDirectTaskDispatcher {
+                                 public nsIDirectTaskDispatcher,
+                                 public nsIDelayedRunnableObserver {
  public:
   XPCOMThreadWrapper(nsIThreadInternal* aThread, bool aRequireTailDispatch,
                      bool aOnThread)
       : AbstractThread(aRequireTailDispatch),
         mThread(aThread),
+        mDelayedRunnableObserver(do_QueryInterface(mThread)),
         mDirectTaskDispatcher(do_QueryInterface(aThread)),
         mOnThread(aOnThread) {
     MOZ_DIAGNOSTIC_ASSERT(mThread && mDirectTaskDispatcher);
@@ -158,8 +160,22 @@
     return mDirectTaskDispatcher->HaveDirectTasks(aResult);
   }
 
+  //-----------------------------------------------------------------------------
+  // nsIDelayedRunnableObserver
+  //-----------------------------------------------------------------------------
+  void OnDelayedRunnableCreated(DelayedRunnable* aRunnable) override {
+    mDelayedRunnableObserver->OnDelayedRunnableCreated(aRunnable);
+  }
+  void OnDelayedRunnableScheduled(DelayedRunnable* aRunnable) override {
+    mDelayedRunnableObserver->OnDelayedRunnableScheduled(aRunnable);
+  }
+  void OnDelayedRunnableRan(DelayedRunnable* aRunnable) override {
+    mDelayedRunnableObserver->OnDelayedRunnableRan(aRunnable);
+  }
+
  private:
   const RefPtr<nsIThreadInternal> mThread;
+  const nsCOMPtr<nsIDelayedRunnableObserver> mDelayedRunnableObserver;
   const nsCOMPtr<nsIDirectTaskDispatcher> mDirectTaskDispatcher;
   Maybe<AutoTaskDispatcher> mTailDispatcher;
   const bool mOnThread;
@@ -215,8 +231,16 @@
     const RefPtr<nsIRunnable> mRunnable;
   };
 };
-NS_IMPL_ISUPPORTS_INHERITED(XPCOMThreadWrapper, AbstractThread,
-                            nsIThreadObserver, nsIDirectTaskDispatcher);
+
+NS_INTERFACE_MAP_BEGIN(XPCOMThreadWrapper)
+  NS_INTERFACE_MAP_ENTRY(nsIThreadObserver)
+  NS_INTERFACE_MAP_ENTRY(nsIDirectTaskDispatcher)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIDelayedRunnableObserver,
+                                     mDelayedRunnableObserver)
+NS_INTERFACE_MAP_END_INHERITING(AbstractThread)
+
+NS_IMPL_ADDREF_INHERITED(XPCOMThreadWrapper, AbstractThread)
+NS_IMPL_RELEASE_INHERITED(XPCOMThreadWrapper, AbstractThread)
 
 NS_IMPL_ISUPPORTS(AbstractThread, nsIEventTarget, nsISerialEventTarget)
 