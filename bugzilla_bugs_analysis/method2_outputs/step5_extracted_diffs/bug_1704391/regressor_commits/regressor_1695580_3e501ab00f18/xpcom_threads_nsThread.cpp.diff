# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/nsThread.cpp
# Commit: 3e501ab00f18
# Full Hash: 3e501ab00f1855046db1f8db6be58fb35f7c6adc
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-04-07 03:19:44
# Regressor Bug: 1695580
# File Overlap Count: 1
# Description:
#   Bug 1695580 - In xpcom, cancel pending DelayedRunnable timers on shutdown. r=KrisWright
#   
#   Because DelayedRunnables are fire-and-forget, there is no way for a targeted
#   EventTarget to clean them up on shutdown. Thus if a timer fires after
#   EventTarget shutdown it will fail to dispatch the timer event, and avoid
# ==============================================================================

diff -r 2a88ea548a86 -r 3e501ab00f18 xpcom/threads/nsThread.cpp
--- a/xpcom/threads/nsThread.cpp	Tue Apr 06 20:15:10 2021 +0000
+++ b/xpcom/threads/nsThread.cpp	Tue Apr 06 20:15:11 2021 +0000
@@ -186,6 +186,7 @@
   NS_INTERFACE_MAP_ENTRY(nsIEventTarget)
   NS_INTERFACE_MAP_ENTRY(nsISerialEventTarget)
   NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIDelayedRunnableObserver, mEventTarget)
   NS_INTERFACE_MAP_ENTRY(nsIDirectTaskDispatcher)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIThread)
   if (aIID.Equals(NS_GET_IID(nsIClassInfo))) {
@@ -236,6 +237,9 @@
         mShutdownContext(aCtx) {}
   NS_IMETHOD Run() override {
     mThread->mShutdownContext = mShutdownContext;
+    if (mThread->mEventTarget) {
+      mThread->mEventTarget->NotifyShutdown();
+    }
     MessageLoop::current()->Quit();
     return NS_OK;
   }
@@ -1387,6 +1391,18 @@
 
 nsISerialEventTarget* nsThread::SerialEventTarget() { return this; }
 
+void nsThread::OnDelayedRunnableCreated(mozilla::DelayedRunnable* aRunnable) {
+  mEventTarget->OnDelayedRunnableCreated(aRunnable);
+}
+
+void nsThread::OnDelayedRunnableScheduled(mozilla::DelayedRunnable* aRunnable) {
+  mEventTarget->OnDelayedRunnableScheduled(aRunnable);
+}
+
+void nsThread::OnDelayedRunnableRan(mozilla::DelayedRunnable* aRunnable) {
+  mEventTarget->OnDelayedRunnableRan(aRunnable);
+}
+
 nsLocalExecutionRecord nsThread::EnterLocalExecution() {
   MOZ_RELEASE_ASSERT(!mIsInLocalExecutionMode);
   MOZ_ASSERT(IsOnCurrentThread());