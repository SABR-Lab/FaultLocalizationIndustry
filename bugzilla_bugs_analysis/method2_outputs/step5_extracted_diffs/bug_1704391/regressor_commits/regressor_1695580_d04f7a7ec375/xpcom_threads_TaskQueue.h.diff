# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/TaskQueue.h
# Commit: d04f7a7ec375
# Full Hash: d04f7a7ec375bc4bf08b39875f86608a8920691e
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-04-07 03:19:44
# Regressor Bug: 1695580
# File Overlap Count: 1
# Description:
#   Bug 1695580 - In xpcom, cancel pending DelayedRunnable timers on shutdown. r=KrisWright
#   
#   Because DelayedRunnables are fire-and-forget, there is no way for a targeted
#   EventTarget to clean them up on shutdown. Thus if a timer fires after
#   EventTarget shutdown it will fail to dispatch the timer event, and avoid
# ==============================================================================

diff -r 2103cd9e58b7 -r d04f7a7ec375 xpcom/threads/TaskQueue.h
--- a/xpcom/threads/TaskQueue.h	Tue Apr 06 12:16:11 2021 +0000
+++ b/xpcom/threads/TaskQueue.h	Tue Apr 06 12:16:11 2021 +0000
@@ -15,6 +15,7 @@
 #include "mozilla/MozPromise.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/TaskDispatcher.h"
+#include "nsIDelayedRunnableObserver.h"
 #include "nsIDirectTaskDispatcher.h"
 #include "nsThreadUtils.h"
 
@@ -47,7 +48,9 @@
 // A TaskQueue does not require explicit shutdown, however it provides a
 // BeginShutdown() method that places TaskQueue in a shut down state and returns
 // a promise that gets resolved once all pending tasks have completed
-class TaskQueue : public AbstractThread, public nsIDirectTaskDispatcher {
+class TaskQueue : public AbstractThread,
+                  public nsIDirectTaskDispatcher,
+                  public nsIDelayedRunnableObserver {
   class EventTargetWrapper;
 
  public:
@@ -93,6 +96,18 @@
   // So we can access nsIEventTarget::Dispatch(nsIRunnable*, uint32_t aFlags)
   using nsIEventTarget::Dispatch;
 
+  // nsIDelayedRunnableObserver
+  void OnDelayedRunnableCreated(DelayedRunnable* aRunnable) override;
+  void OnDelayedRunnableScheduled(DelayedRunnable* aRunnable) override;
+  void OnDelayedRunnableRan(DelayedRunnable* aRunnable) override;
+
+  using CancelPromise = MozPromise<bool, bool, false>;
+
+  // Dispatches a task to cancel any pending DelayedRunnables. Idempotent. Only
+  // dispatches the task on the first call. Creating DelayedRunnables after this
+  // is called will result in assertion failures.
+  RefPtr<CancelPromise> CancelDelayedRunnables();
+
   // Puts the queue in a shutdown state and returns immediately. The queue will
   // remain alive at least until all the events are drained, because the Runners
   // hold a strong reference to the task queue, and one of them is always held
@@ -126,6 +141,11 @@
   nsresult DispatchLocked(nsCOMPtr<nsIRunnable>& aRunnable, uint32_t aFlags,
                           DispatchReason aReason = NormalDispatch);
 
+  RefPtr<CancelPromise> CancelDelayedRunnablesLocked();
+
+  // Cancels any scheduled DelayedRunnables on this TaskQueue.
+  void CancelDelayedRunnablesImpl();
+
   void MaybeResolveShutdown() {
     mQueueMonitor.AssertCurrentThreadOwns();
     if (mIsShutdown && !mIsRunning) {
@@ -136,7 +156,8 @@
 
   nsCOMPtr<nsIEventTarget> mTarget;
 
-  // Monitor that protects the queue and mIsRunning;
+  // Monitor that protects the queue, mIsRunning and
+  // mDelayedRunnablesCancelPromise;
   Monitor mQueueMonitor;
 
   typedef struct TaskStruct {
@@ -147,6 +168,18 @@
   // Queue of tasks to run.
   std::queue<TaskStruct> mTasks;
 
+  // DelayedRunnables (from DelayedDispatch) that are managed by their
+  // respective timers, but have not yet run. Accessed only on this
+  // TaskQueue.
+  nsTArray<RefPtr<DelayedRunnable>> mScheduledDelayedRunnables;
+
+  // Manages resolving mDelayedRunnablesCancelPromise.
+  MozPromiseHolder<CancelPromise> mDelayedRunnablesCancelHolder;
+
+  // Set once the task to cancel all pending DelayedRunnables has been
+  // dispatched. Guarded by mQueueMonitor.
+  RefPtr<CancelPromise> mDelayedRunnablesCancelPromise;
+
   // The thread currently running the task queue. We store a reference
   // to this so that IsCurrentThreadIn() can tell if the current thread
   // is the thread currently running in the task queue.