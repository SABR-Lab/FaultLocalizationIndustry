# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/ThreadEventTarget.cpp
# Commit: d04f7a7ec375
# Full Hash: d04f7a7ec375bc4bf08b39875f86608a8920691e
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-04-07 03:19:44
# Regressor Bug: 1695580
# File Overlap Count: 1
# Description:
#   Bug 1695580 - In xpcom, cancel pending DelayedRunnable timers on shutdown. r=KrisWright
#   
#   Because DelayedRunnables are fire-and-forget, there is no way for a targeted
#   EventTarget to clean them up on shutdown. Thus if a timer fires after
#   EventTarget shutdown it will fail to dispatch the timer event, and avoid
# ==============================================================================

diff -r 2103cd9e58b7 -r d04f7a7ec375 xpcom/threads/ThreadEventTarget.cpp
--- a/xpcom/threads/ThreadEventTarget.cpp	Tue Apr 06 12:16:11 2021 +0000
+++ b/xpcom/threads/ThreadEventTarget.cpp	Tue Apr 06 12:16:11 2021 +0000
@@ -33,13 +33,18 @@
   mThread = PR_GetCurrentThread();
 }
 
+ThreadEventTarget::~ThreadEventTarget() {
+  MOZ_ASSERT(mScheduledDelayedRunnables.IsEmpty());
+}
+
 void ThreadEventTarget::SetCurrentThread(PRThread* aThread) {
   mThread = aThread;
 }
 
 void ThreadEventTarget::ClearCurrentThread() { mThread = nullptr; }
 
-NS_IMPL_ISUPPORTS(ThreadEventTarget, nsIEventTarget, nsISerialEventTarget)
+NS_IMPL_ISUPPORTS(ThreadEventTarget, nsIEventTarget, nsISerialEventTarget,
+                  nsIDelayedRunnableObserver)
 
 NS_IMETHODIMP
 ThreadEventTarget::DispatchFromScript(nsIRunnable* aRunnable, uint32_t aFlags) {
@@ -136,3 +141,23 @@
   // we are called, we can never be on this thread.
   return false;
 }
+
+void ThreadEventTarget::OnDelayedRunnableCreated(DelayedRunnable* aRunnable) {}
+
+void ThreadEventTarget::OnDelayedRunnableScheduled(DelayedRunnable* aRunnable) {
+  MOZ_ASSERT(IsOnCurrentThread());
+  mScheduledDelayedRunnables.AppendElement(aRunnable);
+}
+
+void ThreadEventTarget::OnDelayedRunnableRan(DelayedRunnable* aRunnable) {
+  MOZ_ASSERT(IsOnCurrentThread());
+  MOZ_ALWAYS_TRUE(mScheduledDelayedRunnables.RemoveElement(aRunnable));
+}
+
+void ThreadEventTarget::NotifyShutdown() {
+  MOZ_ASSERT(IsOnCurrentThread());
+  for (const auto& runnable : mScheduledDelayedRunnables) {
+    runnable->CancelTimer();
+  }
+  mScheduledDelayedRunnables.Clear();
+}