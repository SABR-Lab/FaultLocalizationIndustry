# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/script/ScriptLoader.cpp
# Commit: 540c9159c3c6
# Full Hash: 540c9159c3c6dd350ac5343f9f9c977e4cdc53df
# Author: yulia <ystartsev@mozilla.com>
# Date: 2020-12-18 21:38:02
# Regressor Bug: 1681664
# File Overlap Count: 2
# Description:
#   Bug 1681664 - Allow Top-level await modules which fail to evaluate due to user action to fail without crashing. r=jonco,mconley
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D99809
# ==============================================================================

diff -r 02e1e9b5931a -r 540c9159c3c6 dom/script/ScriptLoader.cpp
--- a/dom/script/ScriptLoader.cpp	Fri Dec 18 15:30:33 2020 +0000
+++ b/dom/script/ScriptLoader.cpp	Fri Dec 18 12:37:36 2020 +0000
@@ -3021,7 +3021,13 @@
       JS::Rooted<JS::Value> rval(cx);
 
       rv = nsJSUtils::ModuleEvaluate(cx, module, &rval);
-      MOZ_ASSERT(NS_FAILED(rv) == aes.HasException());
+
+      if (NS_SUCCEEDED(rv)) {
+        // If we have an infinite loop in a module, which is stopped by the
+        // user, the module evaluation will fail, but we will not have an
+        // AutoEntryScript exception.
+        MOZ_ASSERT(!aes.HasException());
+      }
 
       if (NS_FAILED(rv)) {
         LOG(("ScriptLoadRequest (%p):   evaluation failed", aRequest));
@@ -3036,14 +3042,22 @@
         }
       } else {
         // Path for when Top Level Await is enabled
-        JS::Rooted<JSObject*> aEvaluationPromise(cx, &rval.toObject());
+        JS::Rooted<JSObject*> aEvaluationPromise(cx);
+        if (NS_SUCCEEDED(rv)) {
+          // If the user cancels the evaluation on an infinite loop, we need
+          // to skip this step. In that case, ModuleEvaluate will not return a
+          // promise, rval will be undefined. We should treat it as a failed
+          // evaluation, and reject appropriately.
+          aEvaluationPromise.set(&rval.toObject());
+        }
         if (request->IsDynamicImport()) {
           FinishDynamicImport(cx, request, rv, aEvaluationPromise);
         } else {
           // If this is not a dynamic import, and if the promise is rejected,
           // the value is unwrapped from the promise value.
           if (!JS::ThrowOnModuleEvaluationFailure(cx, aEvaluationPromise)) {
-            LOG(("ScriptLoadRequest (%p):   evaluation failed", aRequest));
+            LOG(("ScriptLoadRequest (%p):   evaluation failed on throw",
+                 aRequest));
             // For a dynamic import, the promise is rejected.  Otherwise an
             // error is either reported by AutoEntryScript.
             rv = NS_OK;