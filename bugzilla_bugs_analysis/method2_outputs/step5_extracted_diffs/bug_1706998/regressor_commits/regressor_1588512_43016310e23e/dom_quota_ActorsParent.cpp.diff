# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/ActorsParent.cpp
# Commit: 43016310e23e
# Full Hash: 43016310e23eefdeeda7e060b0192b675bb28cec
# Author: Simon Giesecke <sgiesecke@mozilla.com>
# Date: 2021-01-05 21:56:58
# Regressor Bug: 1588512
# File Overlap Count: 2
# Description:
#   Bug 1588512 - Avoid blocking progress during a clear operation on failure to remove a directory. r=dom-workers-and-storage-reviewers,janv
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D100093
# ==============================================================================

diff -r 936591fa4a69 -r 43016310e23e dom/quota/ActorsParent.cpp
--- a/dom/quota/ActorsParent.cpp	Tue Jan 05 09:48:24 2021 +0000
+++ b/dom/quota/ActorsParent.cpp	Tue Jan 05 10:13:14 2021 +0000
@@ -4074,9 +4074,21 @@
 
 void QuotaManager::MaybeRecordShutdownStep(const Client::Type aClientType,
                                            const nsACString& aStepDescription) {
-  AssertIsOnBackgroundThread();
-
-  if (!mShutdownStartedAt) {
+  // Callable on any thread.
+
+  MaybeRecordShutdownStep(Some(aClientType), aStepDescription);
+}
+
+void QuotaManager::MaybeRecordQuotaManagerShutdownStep(
+    const nsACString& aStepDescription) {
+  // Callable on any thread.
+
+  MaybeRecordShutdownStep(Nothing{}, aStepDescription);
+}
+
+void QuotaManager::MaybeRecordShutdownStep(
+    const Maybe<Client::Type> aClientType, const nsACString& aStepDescription) {
+  if (!mShutdownStarted) {
     // We are not shutting down yet, we intentionally ignore this here to avoid
     // that every caller has to make a distinction for shutdown vs. non-shutdown
     // situations.
@@ -4090,14 +4102,24 @@
       nsPrintfCString("%fs: %s", elapsedSinceShutdownStart.ToSeconds(),
                       nsPromiseFlatCString(aStepDescription).get());
 
-  mShutdownSteps[aClientType].Append(stepString + "\n"_ns);
+  if (aClientType) {
+    AssertIsOnBackgroundThread();
+
+    mShutdownSteps[*aClientType].Append(stepString + "\n"_ns);
+  } else {
+    // Callable on any thread.
+    MutexAutoLock lock(mQuotaMutex);
+
+    mQuotaManagerShutdownSteps.Append(stepString + "\n"_ns);
+  }
 
 #ifdef DEBUG
   // XXX Probably this isn't the mechanism that should be used here.
 
   NS_DebugBreak(
       NS_DEBUG_WARNING,
-      nsAutoCString(Client::TypeToText(aClientType) + " shutdown step"_ns)
+      nsAutoCString(aClientType ? Client::TypeToText(*aClientType)
+                                : "quota manager"_ns + " shutdown step"_ns)
           .get(),
       stepString.get(), __FILE__, __LINE__);
 #endif
@@ -4105,6 +4127,7 @@
 
 void QuotaManager::Shutdown() {
   AssertIsOnOwningThread();
+  MOZ_ASSERT(!mShutdownStarted);
 
   // Setting this flag prevents the service from being recreated and prevents
   // further storagess from being created.
@@ -4115,6 +4138,7 @@
   StopIdleMaintenance();
 
   mShutdownStartedAt.init(TimeStamp::NowLoRes());
+  mShutdownStarted = true;
 
   const auto& allClientTypes = AllClientTypes();
 
@@ -4147,23 +4171,30 @@
 
                 nsCString annotation;
 
-                for (Client::Type type : quotaManager->AllClientTypes()) {
-                  auto& quotaClient = *quotaManager->mClients[type];
-
-                  if (!quotaClient.IsShutdownCompleted()) {
+                {
+                  for (Client::Type type : quotaManager->AllClientTypes()) {
+                    auto& quotaClient = *quotaManager->mClients[type];
+
+                    if (!quotaClient.IsShutdownCompleted()) {
+                      annotation.AppendPrintf(
+                          "%s: %s\nIntermediate steps:\n%s\n\n",
+                          Client::TypeToText(type).get(),
+                          quotaClient.GetShutdownStatus().get(),
+                          quotaManager->mShutdownSteps[type].get());
+                    }
+                  }
+
+                  if (gNormalOriginOps) {
+                    MutexAutoLock lock(quotaManager->mQuotaMutex);
+
                     annotation.AppendPrintf(
-                        "%s: %s\nIntermediate steps:\n%s\n\n",
-                        Client::TypeToText(type).get(),
-                        quotaClient.GetShutdownStatus().get(),
-                        quotaManager->mShutdownSteps[type].get());
+                        "QM: %zu normal origin ops pending\nIntermediate "
+                        "steps:\n%s\n",
+                        gNormalOriginOps->Length(),
+                        quotaManager->mQuotaManagerShutdownSteps.get());
                   }
                 }
 
-                if (gNormalOriginOps) {
-                  annotation.AppendPrintf("QM: %zu normal origin ops pending\n",
-                                          gNormalOriginOps->Length());
-                }
-
                 // We expect that at least one quota client didn't complete its
                 // shutdown.
                 MOZ_DIAGNOSTIC_ASSERT(!annotation.IsEmpty());
@@ -9606,6 +9637,11 @@
       const auto& directory,
       QM_NewLocalFile(aQuotaManager.GetStoragePath(aPersistenceType)), QM_VOID);
 
+  nsTArray<nsCOMPtr<nsIFile>> directoriesForRemovalRetry;
+
+  aQuotaManager.MaybeRecordQuotaManagerShutdownStep(
+      "ClearRequestBase: Starting deleting files"_ns);
+
   QM_TRY(
       CollectEachFile(
           *directory,
@@ -9624,8 +9660,8 @@
                  }
                  return originScope;
                }(),
-           aPersistenceType, &aQuotaManager, this](
-              const nsCOMPtr<nsIFile>& file) -> mozilla::Result<Ok, nsresult> {
+           aPersistenceType, &aQuotaManager, &directoriesForRemovalRetry,
+           this](nsCOMPtr<nsIFile>&& file) -> mozilla::Result<Ok, nsresult> {
             QM_TRY_INSPECT(const bool& isDirectory,
                            MOZ_TO_RESULT_INVOKE(file, IsDirectory));
 
@@ -9672,25 +9708,12 @@
               }
             }
 
-            {
-              nsresult rv;
-              for (uint32_t index = 0; index < 10; index++) {
-                // We can't guarantee that this will always succeed on
-                // Windows...
-                if (NS_SUCCEEDED((rv = file->Remove(true)))) {
-                  break;
-                }
-
-                NS_WARNING(
-                    "Failed to remove directory, retrying after a short "
-                    "delay.");
-
-                PR_Sleep(PR_MillisecondsToInterval(200));
-              }
-
-              if (NS_FAILED(rv)) {
-                NS_WARNING("Failed to remove directory, giving up!");
-              }
+            // We can't guarantee that this will always succeed on
+            // Windows...
+            if (NS_FAILED((file->Remove(true)))) {
+              NS_WARNING("Failed to remove directory, retrying later.");
+
+              directoriesForRemovalRetry.AppendElement(std::move(file));
             }
 
             const bool initialized =
@@ -9719,6 +9742,37 @@
             return Ok{};
           }),
       QM_VOID);
+
+  // Retry removing any directories that failed to be removed earlier now.
+  //
+  // XXX This will still block this operation. We might instead dispatch a
+  // runnable to our own thread for each retry round with a timer. We must
+  // ensure that the directory lock is upheld until we complete or give up
+  // though.
+  for (uint32_t index = 0; index < 10; index++) {
+    aQuotaManager.MaybeRecordQuotaManagerShutdownStep(
+        "ClearRequestBase: Retrying directory removal"_ns);
+
+    for (auto&& file : std::exchange(directoriesForRemovalRetry,
+                                     nsTArray<nsCOMPtr<nsIFile>>{})) {
+      if (NS_FAILED((file->Remove(true)))) {
+        directoriesForRemovalRetry.AppendElement(std::move(file));
+      }
+    }
+
+    if (directoriesForRemovalRetry.IsEmpty()) {
+      break;
+    }
+
+    PR_Sleep(PR_MillisecondsToInterval(200));
+  }
+
+  if (!directoriesForRemovalRetry.IsEmpty()) {
+    NS_WARNING("Failed to remove one or more directories, giving up!");
+  }
+
+  aQuotaManager.MaybeRecordQuotaManagerShutdownStep(
+      "ClearRequestBase: Completed deleting files"_ns);
 }
 
 nsresult ClearRequestBase::DoDirectoryWork(QuotaManager& aQuotaManager) {