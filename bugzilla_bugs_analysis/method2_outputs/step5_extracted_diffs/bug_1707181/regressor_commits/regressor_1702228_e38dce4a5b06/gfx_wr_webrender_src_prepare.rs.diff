# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/prepare.rs
# Commit: e38dce4a5b06
# Full Hash: e38dce4a5b06869dd4a4d753f41f7594a8cddfb6
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2021-04-22 21:31:57
# Regressor Bug: 1702228
# File Overlap Count: 2
# Description:
#   Bug 1702228 - Cache linear gradients by default. r=gw
#   
#   This patch breaks linear gradients into two primitives:
#    - LinearGradient is always rendered via the brush shader. It is only used with SWGL.
#    - CachedLinearGradient is always rendered via a cached render task and the brush image shader. Its implementation is very similar to conic and radial gradients, with the addition of a fast-path for axis aligned gradients with two stops.
# ==============================================================================

diff -r b3f8befa510f -r e38dce4a5b06 gfx/wr/webrender/src/prepare.rs
--- a/gfx/wr/webrender/src/prepare.rs	Thu Apr 22 10:34:54 2021 +0000
+++ b/gfx/wr/webrender/src/prepare.rs	Thu Apr 22 10:34:54 2021 +0000
@@ -6,12 +6,11 @@
 //!
 //! TODO: document this!
 
-use std::{cmp, u32};
-use api::{PremultipliedColorF, PropertyBinding, GradientStop, ExtendMode};
-use api::{BoxShadowClipMode, LineOrientation, BorderStyle, ClipMode};
+use std::cmp;
+use api::{PremultipliedColorF, PropertyBinding};
+use api::{BoxShadowClipMode, BorderStyle, ClipMode};
 use api::units::*;
 use euclid::Scale;
-use euclid::approxeq::ApproxEq;
 use smallvec::SmallVec;
 use crate::image_tiling::{self, Repetition};
 use crate::border::{get_max_scale_for_border, build_border_instances};
@@ -24,8 +23,6 @@
 use crate::internal_types::{FastHashMap, PlaneSplitAnchor};
 use crate::picture::{PicturePrimitive, SliceId, TileCacheLogger, ClusterFlags, SurfaceRenderTasks};
 use crate::picture::{PrimitiveList, PrimitiveCluster, SurfaceIndex, TileCacheInstance, SubpixelMode};
-use crate::prim_store::gradient::{GRADIENT_FP_STOPS, FastLinearGradientCacheKey, GradientStopKey, CachedGradientSegment};
-use crate::prim_store::gradient::LinearGradientPrimitive;
 use crate::prim_store::line_dec::MAX_LINE_DECORATION_RESOLUTION;
 use crate::prim_store::*;
 use crate::render_backend::DataStores;
@@ -35,7 +32,6 @@
 use crate::render_task::{RenderTaskKind, RenderTask};
 use crate::segment::SegmentBuilder;
 use crate::space::SpaceMapper;
-use crate::texture_cache::TEXTURE_REGION_DIMENSIONS;
 use crate::util::{clamp_to_scale_factor, pack_as_float, raster_rect_to_device_pixels};
 use crate::visibility::{compute_conservative_visible_rect, PrimitiveVisibility, VisibilityState};
 
@@ -625,14 +621,13 @@
                 },
             );
         }
-        PrimitiveInstanceKind::LinearGradient { data_handle, gradient_index, .. } => {
+        PrimitiveInstanceKind::LinearGradient { data_handle, ref mut visible_tiles_range, .. } => {
             profile_scope!("LinearGradient");
             let prim_data = &mut data_stores.linear_grad[*data_handle];
-            let gradient = &mut store.linear_gradients[*gradient_index];
 
             // Update the template this instane references, which may refresh the GPU
             // cache with any shared template data.
-            prim_data.update(frame_state);
+            prim_data.update(frame_state, pic_context.surface_index);
 
             if prim_data.stretch_size.width >= prim_data.common.prim_rect.size.width &&
                 prim_data.stretch_size.height >= prim_data.common.prim_rect.size.height {
@@ -640,295 +635,12 @@
                 prim_data.common.may_need_repetition = false;
             }
 
-            // We disable cached gradients with the software fallback because in this
-            // configuration rendering the gradient directly into a picture is faster
-            // than reading from the texture cache.
-            if prim_data.supports_caching && !frame_context.fb_config.is_software {
-                let gradient_size = (prim_data.end_point - prim_data.start_point).to_size();
-
-                // Calculate what the range of the gradient is that covers this
-                // primitive. These values are included in the cache key. The
-                // size of the gradient task is the length of a texture cache
-                // region, for maximum accuracy, and a minimal size on the
-                // axis that doesn't matter.
-                let (size, orientation, prim_start_offset, prim_end_offset) =
-                    if prim_data.start_point.x.approx_eq(&prim_data.end_point.x) {
-                        let prim_start_offset = -prim_data.start_point.y / gradient_size.height;
-                        let prim_end_offset = (prim_data.common.prim_rect.size.height - prim_data.start_point.y)
-                                                / gradient_size.height;
-                        let size = DeviceIntSize::new(16, TEXTURE_REGION_DIMENSIONS);
-                        (size, LineOrientation::Vertical, prim_start_offset, prim_end_offset)
-                    } else {
-                        let prim_start_offset = -prim_data.start_point.x / gradient_size.width;
-                        let prim_end_offset = (prim_data.common.prim_rect.size.width - prim_data.start_point.x)
-                                                / gradient_size.width;
-                        let size = DeviceIntSize::new(TEXTURE_REGION_DIMENSIONS, 16);
-                        (size, LineOrientation::Horizontal, prim_start_offset, prim_end_offset)
-                    };
-
-                // Build the cache key, including information about the stops.
-                let mut stops = vec![GradientStopKey::empty(); prim_data.stops.len()];
-
-                // Reverse the stops as required, same as the gradient builder does
-                // for the slow path.
-                if prim_data.reverse_stops {
-                    for (src, dest) in prim_data.stops.iter().rev().zip(stops.iter_mut()) {
-                        let stop = GradientStop {
-                            offset: 1.0 - src.offset,
-                            color: src.color,
-                        };
-                        *dest = stop.into();
-                    }
-                } else {
-                    for (src, dest) in prim_data.stops.iter().zip(stops.iter_mut()) {
-                        *dest = (*src).into();
-                    }
-                }
-
-                gradient.cache_segments.clear();
-
-                // emit render task caches and image rectangles to draw a gradient
-                // with offsets from start_offset to end_offset.
-                //
-                // the primitive is covered by a gradient that ranges from
-                // prim_start_offset to prim_end_offset.
-                //
-                // when clamping, these two pairs of offsets will always be the same.
-                // when repeating, however, we march across the primitive, blitting
-                // copies of the gradient along the way.  each copy has a range from
-                // 0.0 to 1.0 (assuming it's fully visible), but where it appears on
-                // the primitive changes as we go.  this position is also expressed
-                // as an offset: gradient_offset_base.  that is, in terms of stops,
-                // we draw a gradient from start_offset to end_offset.  its actual
-                // location on the primitive is at start_offset + gradient_offset_base.
-                //
-                // either way, we need a while-loop to draw the gradient as well
-                // because it might have more than 4 stops (the maximum of a cached
-                // segment) and/or hard stops. so we have a walk-within-the-walk from
-                // start_offset to end_offset caching up to GRADIENT_FP_STOPS stops at a
-                // time.
-                fn emit_segments(start_offset: f32, // start and end offset together are
-                                 end_offset: f32,   // always a subrange of 0..1
-                                 gradient_offset_base: f32,
-                                 prim_start_offset: f32, // the offsets of the entire gradient as it
-                                 prim_end_offset: f32,   // covers the entire primitive.
-                                 prim_origin_in: LayoutPoint,
-                                 prim_size_in: LayoutSize,
-                                 task_size: DeviceIntSize,
-                                 is_opaque: bool,
-                                 stops: &[GradientStopKey],
-                                 orientation: LineOrientation,
-                                 frame_state: &mut FrameBuildingState,
-                                 gradient: &mut LinearGradientPrimitive,
-                                 parent_surface_index: SurfaceIndex,
-                ) {
-                    // these prints are used to generate documentation examples, so
-                    // leaving them in but commented out:
-                    //println!("emit_segments call:");
-                    //println!("\tstart_offset: {}, end_offset: {}", start_offset, end_offset);
-                    //println!("\tprim_start_offset: {}, prim_end_offset: {}", prim_start_offset, prim_end_offset);
-                    //println!("\tgradient_offset_base: {}", gradient_offset_base);
-                    let mut first_stop = 0;
-                    // look for an inclusive range of stops [first_stop, last_stop].
-                    // once first_stop points at (or past) the last stop, we're done.
-                    while first_stop < stops.len()-1 {
-
-                        // if the entire sub-gradient starts at an offset that's past the
-                        // segment's end offset, we're done.
-                        if stops[first_stop].offset > end_offset {
-                            return;
-                        }
-
-                        // accumulate stops until we have GRADIENT_FP_STOPS of them, or we hit
-                        // a hard stop:
-                        let mut last_stop = first_stop;
-                        let mut hard_stop = false;   // did we stop on a hard stop?
-                        while last_stop < stops.len()-1 &&
-                              last_stop - first_stop + 1 < GRADIENT_FP_STOPS
-                        {
-                            if stops[last_stop+1].offset == stops[last_stop].offset {
-                                hard_stop = true;
-                                break;
-                            }
-
-                            last_stop = last_stop + 1;
-                        }
-
-                        let num_stops = last_stop - first_stop + 1;
-
-                        // repeated hard stops at the same offset, skip
-                        if num_stops == 0 {
-                            first_stop = last_stop + 1;
-                            continue;
-                        }
-
-                        // if the last_stop offset is before start_offset, the segment's not visible:
-                        if stops[last_stop].offset < start_offset {
-                            first_stop = if hard_stop { last_stop+1 } else { last_stop };
-                            continue;
-                        }
-
-                        let segment_start_point = start_offset.max(stops[first_stop].offset);
-                        let segment_end_point   = end_offset  .min(stops[last_stop ].offset);
-
-                        let mut segment_stops = [GradientStopKey::empty(); GRADIENT_FP_STOPS];
-                        for i in 0..num_stops {
-                            segment_stops[i] = stops[first_stop + i];
-                        }
-
-                        let cache_key = FastLinearGradientCacheKey {
-                            orientation,
-                            start_stop_point: VectorKey {
-                                x: segment_start_point,
-                                y: segment_end_point,
-                            },
-                            stops: segment_stops,
-                        };
-
-                        let mut prim_origin = prim_origin_in;
-                        let mut prim_size   = prim_size_in;
-
-                        // the primitive is covered by a segment from overall_start to
-                        // overall_end; scale and shift based on the length of the actual
-                        // segment that we're drawing:
-                        let inv_length = 1.0 / ( prim_end_offset - prim_start_offset );
-                        if orientation == LineOrientation::Horizontal {
-                            prim_origin.x    += ( segment_start_point + gradient_offset_base - prim_start_offset )
-                                                * inv_length * prim_size.width;
-                            prim_size.width  *= ( segment_end_point - segment_start_point )
-                                                * inv_length; // 2 gradient_offset_bases cancel out
-                        } else {
-                            prim_origin.y    += ( segment_start_point + gradient_offset_base - prim_start_offset )
-                                                * inv_length * prim_size.height;
-                            prim_size.height *= ( segment_end_point - segment_start_point )
-                                                * inv_length; // 2 gradient_offset_bases cancel out
-                        }
-
-                        // <= 0 can happen if a hardstop lands exactly on an edge
-                        if prim_size.area() > 0.0 {
-                            let local_rect = LayoutRect::new( prim_origin, prim_size );
-
-                            // documentation example traces:
-                            //println!("\t\tcaching from offset {} to {}", segment_start_point, segment_end_point);
-                            //println!("\t\tand blitting to {:?}", local_rect);
-
-                            // Request the render task each frame.
-                            gradient.cache_segments.push(
-                                CachedGradientSegment {
-                                    render_task: frame_state.resource_cache.request_render_task(
-                                        RenderTaskCacheKey {
-                                            size: task_size,
-                                            kind: RenderTaskCacheKeyKind::FastLinearGradient(cache_key),
-                                        },
-                                        frame_state.gpu_cache,
-                                        frame_state.rg_builder,
-                                        None,
-                                        is_opaque,
-                                        RenderTaskParent::Surface(parent_surface_index),
-                                        frame_state.surfaces,
-                                        |rg_builder| {
-                                            rg_builder.add().init(RenderTask::new_dynamic(
-                                                task_size,
-                                                RenderTaskKind::new_gradient(
-                                                    segment_stops,
-                                                    orientation,
-                                                    segment_start_point,
-                                                    segment_end_point,
-                                                ),
-                                            ))
-                                        }),
-                                    local_rect: local_rect,
-                                }
-                            );
-                        }
-
-                        // if ending on a hardstop, skip past it for the start of the next run:
-                        first_stop = if hard_stop { last_stop + 1 } else { last_stop };
-                    }
-                }
-
-                if prim_data.extend_mode == ExtendMode::Clamp ||
-                   ( prim_start_offset >= 0.0 && prim_end_offset <= 1.0 )  // repeat doesn't matter
-                {
-                    // To support clamping, we need to make sure that quads are emitted for the
-                    // segments before and after the 0.0...1.0 range of offsets.  emit_segments
-                    // can handle that by duplicating the first and last point if necessary:
-                    if prim_start_offset < 0.0 {
-                        stops.insert(0, GradientStopKey {
-                            offset: prim_start_offset,
-                            color : stops[0].color
-                        });
-                    }
-
-                    if prim_end_offset > 1.0 {
-                        stops.push( GradientStopKey {
-                            offset: prim_end_offset,
-                            color : stops[stops.len()-1].color
-                        });
-                    }
-
-                    emit_segments(prim_start_offset, prim_end_offset,
-                                  0.0,
-                                  prim_start_offset, prim_end_offset,
-                                  prim_data.common.prim_rect.origin,
-                                  prim_data.common.prim_rect.size,
-                                  size,
-                                  prim_data.stops_opacity.is_opaque,
-                                  &stops,
-                                  orientation,
-                                  frame_state,
-                                  gradient,
-                                  pic_context.surface_index,
-                    );
-                }
-                else
-                {
-                    let mut prev_segment_start_point = None;
-                    let mut segment_start_point = prim_start_offset;
-                    while segment_start_point < prim_end_offset {
-
-                        // gradient stops are expressed in the range 0.0 ... 1.0, so to blit
-                        // a copy of the gradient, snap to the integer just before the offset
-                        // we want ...
-                        let gradient_offset_base = segment_start_point.floor();
-                        // .. and then draw from a start offset in range 0 to 1 ...
-                        let repeat_start = segment_start_point - gradient_offset_base;
-                        // .. up to the next integer, but clamped to the primitive's real
-                        // end offset:
-                        let repeat_end = (gradient_offset_base + 1.0).min(prim_end_offset) - gradient_offset_base;
-
-                        emit_segments(repeat_start, repeat_end,
-                                      gradient_offset_base,
-                                      prim_start_offset, prim_end_offset,
-                                      prim_data.common.prim_rect.origin,
-                                      prim_data.common.prim_rect.size,
-                                      size,
-                                      prim_data.stops_opacity.is_opaque,
-                                      &stops,
-                                      orientation,
-                                      frame_state,
-                                      gradient,
-                                      pic_context.surface_index,
-                        );
-
-                        segment_start_point = repeat_end + gradient_offset_base;
-
-                        // Break out of the loop if we aren't making progress
-                        if prev_segment_start_point == Some(segment_start_point) {
-                            debug_assert!(segment_start_point.approx_eq(&prim_end_offset));
-                            break;
-                        }
-                        prev_segment_start_point = Some(segment_start_point)
-                    }
-                }
-            }
-
             if prim_data.tile_spacing != LayoutSize::zero() {
                 // We are performing the decomposition on the CPU here, no need to
                 // have it in the shader.
                 prim_data.common.may_need_repetition = false;
 
-                gradient.visible_tiles_range = decompose_repeated_gradient(
+                *visible_tiles_range = decompose_repeated_gradient(
                     &prim_instance.vis,
                     &prim_data.common.prim_rect,
                     prim_spatial_node_index,
@@ -950,10 +662,10 @@
                             prim_data.stretch_size.height,
                             0.0,
                         ]);
-                    })
+                    }),
                 );
 
-                if gradient.visible_tiles_range.is_empty() {
+                if visible_tiles_range.is_empty() {
                     prim_instance.clear_visibility();
                 }
             }
@@ -961,6 +673,36 @@
             // TODO(gw): Consider whether it's worth doing segment building
             //           for gradient primitives.
         }
+        PrimitiveInstanceKind::CachedLinearGradient { data_handle, ref mut visible_tiles_range, .. } => {
+            profile_scope!("CachedLinearGradient");
+            let prim_data = &mut data_stores.linear_grad[*data_handle];
+            prim_data.common.may_need_repetition = prim_data.stretch_size.width < prim_data.common.prim_rect.size.width
+                || prim_data.stretch_size.height < prim_data.common.prim_rect.size.height;
+
+            // Update the template this instance references, which may refresh the GPU
+            // cache with any shared template data.
+            prim_data.update(frame_state, pic_context.surface_index);
+
+            if prim_data.tile_spacing != LayoutSize::zero() {
+                prim_data.common.may_need_repetition = false;
+
+                *visible_tiles_range = decompose_repeated_gradient(
+                    &prim_instance.vis,
+                    &prim_data.common.prim_rect,
+                    prim_spatial_node_index,
+                    &prim_data.stretch_size,
+                    &prim_data.tile_spacing,
+                    frame_state,
+                    &mut scratch.gradient_tiles,
+                    &frame_context.spatial_tree,
+                    None,
+                );
+
+                if visible_tiles_range.is_empty() {
+                    prim_instance.clear_visibility();
+                }
+            }
+        }
         PrimitiveInstanceKind::RadialGradient { data_handle, ref mut visible_tiles_range, .. } => {
             profile_scope!("RadialGradient");
             let prim_data = &mut data_stores.radial_grad[*data_handle];
@@ -1289,7 +1031,8 @@
             //       can change this to be a tuple match on (instance, template)
             border_data.brush_segments.as_slice()
         }
-        PrimitiveInstanceKind::LinearGradient { data_handle, .. } => {
+        PrimitiveInstanceKind::LinearGradient { data_handle, .. }
+        | PrimitiveInstanceKind::CachedLinearGradient { data_handle, .. } => {
             let prim_data = &data_stores.linear_grad[data_handle];
 
             // TODO: This is quite messy - once we remove legacy primitives we
@@ -1735,6 +1478,7 @@
         PrimitiveInstanceKind::ImageBorder { .. } |
         PrimitiveInstanceKind::Clear { .. } |
         PrimitiveInstanceKind::LinearGradient { .. } |
+        PrimitiveInstanceKind::CachedLinearGradient { .. } |
         PrimitiveInstanceKind::RadialGradient { .. } |
         PrimitiveInstanceKind::ConicGradient { .. } |
         PrimitiveInstanceKind::LineDecoration { .. } |