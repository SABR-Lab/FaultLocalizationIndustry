# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/prim_store/gradient/linear.rs
# Commit: 6fc108de5c8f
# Full Hash: 6fc108de5c8fd527d0f5b6ae7b91604cc22e7d62
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2021-05-03 15:32:34
# Description:
#   Bug 1707744 - Avoid far gradient endpoints causing large gradient segments. r=gfx-reviewers,lsalzman
#   
#   Large segment bounds trip an assertion when casting coordinates to integers. Clipping early also reduces the amount of cached pixels.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D113819
# ==============================================================================

diff -r 5d436e803f68 -r 6fc108de5c8f gfx/wr/webrender/src/prim_store/gradient/linear.rs
--- a/gfx/wr/webrender/src/prim_store/gradient/linear.rs	Mon May 03 09:12:42 2021 +0000
+++ b/gfx/wr/webrender/src/prim_store/gradient/linear.rs	Mon May 03 09:12:42 2021 +0000
@@ -118,8 +118,8 @@
     end: &mut LayoutPoint,
     extend_mode: ExtendMode,
     stops: &mut [GradientStopKey],
-    // Callback called for each fast-path segment (rect, clip, start end, stops).
-    callback: &mut dyn FnMut(&LayoutRect, &LayoutRect, LayoutPoint, LayoutPoint, &[GradientStopKey])
+    // Callback called for each fast-path segment (rect, start end, stops).
+    callback: &mut dyn FnMut(&LayoutRect, LayoutPoint, LayoutPoint, &[GradientStopKey])
 ) -> bool {
     let offset = apply_gradient_local_clip(
         prim_rect,
@@ -264,13 +264,25 @@
         let mut start = point2(0.0, 0.0);
         let mut end = point2(segment_length, 0.0);
 
-        adjust_rect(&mut segment_rect);
         adjust_point(&mut start);
         adjust_point(&mut end);
+        adjust_rect(&mut segment_rect);
+
+        let origin_before_clip = segment_rect.origin;
+        segment_rect = match segment_rect.intersection(&clip_rect) {
+            Some(rect) => rect,
+            None => {
+                continue;
+            }
+        };
+        let offset = segment_rect.origin - origin_before_clip;
+
+        // Account for the clipping since start and end are relative to the origin.
+        start -= offset;
+        end -= offset;
 
         callback(
             &segment_rect,
-            &clip_rect,
             start,
             end,
             &[