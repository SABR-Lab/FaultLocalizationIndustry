# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/batch.rs
# Commit: e38dce4a5b06
# Full Hash: e38dce4a5b06869dd4a4d753f41f7594a8cddfb6
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2021-04-22 21:31:57
# Regressor Bug: 1702228
# File Overlap Count: 2
# Description:
#   Bug 1702228 - Cache linear gradients by default. r=gw
#   
#   This patch breaks linear gradients into two primitives:
#    - LinearGradient is always rendered via the brush shader. It is only used with SWGL.
#    - CachedLinearGradient is always rendered via a cached render task and the brush image shader. Its implementation is very similar to conic and radial gradients, with the addition of a fast-path for axis aligned gradients with two stops.
# ==============================================================================

diff -r b3f8befa510f -r e38dce4a5b06 gfx/wr/webrender/src/batch.rs
--- a/gfx/wr/webrender/src/batch.rs	Thu Apr 22 10:34:54 2021 +0000
+++ b/gfx/wr/webrender/src/batch.rs	Thu Apr 22 10:34:54 2021 +0000
@@ -9,7 +9,7 @@
 use crate::spatial_tree::{SpatialTree, ROOT_SPATIAL_NODE_INDEX, SpatialNodeIndex, CoordinateSystemId};
 use crate::composite::{CompositeState};
 use crate::glyph_rasterizer::{GlyphFormat, SubpixelDirection};
-use crate::gpu_cache::{GpuBlockData, GpuCache, GpuCacheHandle, GpuCacheAddress};
+use crate::gpu_cache::{GpuBlockData, GpuCache, GpuCacheAddress};
 use crate::gpu_types::{BrushFlags, BrushInstance, PrimitiveHeaders, ZBufferId, ZBufferIdGenerator};
 use crate::gpu_types::{SplitCompositeInstance};
 use crate::gpu_types::{PrimitiveInstanceData, RasterizationSpace, GlyphInstance};
@@ -19,7 +19,7 @@
 use crate::internal_types::{FastHashMap, Swizzle, TextureSource, Filter};
 use crate::picture::{ClusterFlags, Picture3DContext, PictureCompositeMode, PicturePrimitive, SubSliceIndex};
 use crate::prim_store::{DeferredResolve, PrimitiveInstanceKind, ClipData};
-use crate::prim_store::{VisibleGradientTile, PrimitiveInstance, PrimitiveOpacity, SegmentInstanceIndex};
+use crate::prim_store::{PrimitiveInstance, PrimitiveOpacity, SegmentInstanceIndex};
 use crate::prim_store::{BrushSegment, ClipMaskKind, ClipTaskIndex};
 use crate::prim_store::VECS_PER_SEGMENT;
 use crate::render_target::RenderTargetContext;
@@ -2584,8 +2584,7 @@
                     }
                 }
             }
-            PrimitiveInstanceKind::LinearGradient { data_handle, gradient_index, .. } => {
-                let gradient = &ctx.prim_store.linear_gradients[gradient_index];
+            PrimitiveInstanceKind::LinearGradient { data_handle, ref visible_tiles_range, .. } => {
                 let prim_data = &ctx.data_stores.linear_grad[data_handle];
                 let specified_blend_mode = BlendMode::PremultipliedAlpha;
 
@@ -2605,99 +2604,19 @@
                     BlendMode::None
                 };
 
-                if !gradient.cache_segments.is_empty() {
-
-                    for segment in &gradient.cache_segments {
-                        let (uv_rect_address, texture) = match render_tasks.resolve_location(
-                            segment.render_task,
-                            gpu_cache
-                        ) {
-                            Some(resolved) => resolved,
-                            None => {
-                                return;
-                            }
-                        };
-
-                        let (clip_task_address, clip_mask_texture_id) = ctx.get_prim_clip_task_and_texture(
-                            prim_info.clip_task_index,
-                            render_tasks,
-                        ).unwrap();
-
-                        let textures = BatchTextures::prim_textured(
-                            texture,
-                            clip_mask_texture_id,
-                        );
-                        let batch_kind = BrushBatchKind::Image(
-                            texture.image_buffer_kind()
-                        );
-                        let prim_user_data = ImageBrushData {
-                            color_mode: ShaderColorMode::Image,
-                            alpha_type: AlphaType::PremultipliedAlpha,
-                            raster_space: RasterizationSpace::Local,
-                            opacity: 1.0,
-                        }.encode();
-
-                        let specific_resource_address = uv_rect_address.as_int();
-                        prim_header.specific_prim_address = gpu_cache.get_address(&ctx.globals.default_image_handle);
-
-                        let segment_local_clip_rect = match prim_header.local_clip_rect.intersection(&segment.local_rect) {
-                            Some(rect) => rect,
-                            None => { continue; }
-                        };
-
-                        let segment_prim_header = PrimitiveHeader {
-                            local_rect: segment.local_rect,
-                            local_clip_rect: segment_local_clip_rect,
-                            specific_prim_address: prim_header.specific_prim_address,
-                            transform_id: prim_header.transform_id,
-                        };
-
-                        let prim_header_index = prim_headers.push(
-                            &segment_prim_header,
-                            z_id,
-                            prim_user_data,
-                        );
-
-                        let batch_key = BatchKey {
-                            blend_mode: non_segmented_blend_mode,
-                            kind: BatchKind::Brush(batch_kind),
-                            textures,
-                        };
-
-                        self.add_brush_instance_to_batches(
-                            batch_key,
-                            batch_features,
-                            bounding_rect,
-                            z_id,
-                            INVALID_SEGMENT_INDEX,
-                            EdgeAaSegmentMask::all(),
-                            clip_task_address,
-                            BrushFlags::PERSPECTIVE_INTERPOLATION,
-                            prim_header_index,
-                            specific_resource_address,
-                            &batch_filter,
-                        );
-                    }
-                } else if gradient.visible_tiles_range.is_empty() {
+                let user_data = [prim_data.stops_handle.as_int(gpu_cache), 0, 0, 0];
+
+                if visible_tiles_range.is_empty() {
                     let batch_params = BrushBatchParameters::shared(
                         BrushBatchKind::LinearGradient,
                         TextureSet::UNTEXTURED,
-                        [
-                            prim_data.stops_handle.as_int(gpu_cache),
-                            0,
-                            0,
-                            0,
-                        ],
+                        user_data,
                         0,
                     );
 
                     prim_header.specific_prim_address = gpu_cache.get_address(&prim_data.gpu_cache_handle);
 
-                    let prim_header_index = prim_headers.push(
-                        &prim_header,
-                        z_id,
-                        batch_params.prim_user_data,
-                    );
+                    let prim_header_index = prim_headers.push(&prim_header, z_id, user_data);
 
                     let segments = if prim_data.brush_segments.is_empty() {
                         None
@@ -2722,28 +2641,160 @@
                         render_tasks,
                     );
                 } else {
-                    let visible_tiles = &ctx.scratch.gradient_tiles[gradient.visible_tiles_range];
+                    let visible_tiles = &ctx.scratch.gradient_tiles[*visible_tiles_range];
 
                     let (clip_task_address, clip_mask_texture_id) = ctx.get_prim_clip_task_and_texture(
                         prim_info.clip_task_index,
                         render_tasks,
                     ).unwrap();
 
-                    self.add_gradient_tiles(
-                        visible_tiles,
-                        &prim_data.stops_handle,
-                        BrushBatchKind::LinearGradient,
+                    let key = BatchKey {
+                        blend_mode: specified_blend_mode,
+                        kind: BatchKind::Brush(BrushBatchKind::LinearGradient),
+                        textures: BatchTextures::prim_untextured(clip_mask_texture_id),
+                    };
+
+                    for tile in visible_tiles {
+                        let tile_prim_header = PrimitiveHeader {
+                            specific_prim_address: gpu_cache.get_address(&tile.handle),
+                            local_rect: tile.local_rect,
+                            local_clip_rect: tile.local_clip_rect,
+                            ..prim_header
+                        };
+                        let prim_header_index = prim_headers.push(&tile_prim_header, z_id, user_data);
+
+                        self.add_brush_instance_to_batches(
+                            key,
+                            batch_features,
+                            bounding_rect,
+                            z_id,
+                            INVALID_SEGMENT_INDEX,
+                            EdgeAaSegmentMask::all(),
+                            clip_task_address,
+                            BrushFlags::PERSPECTIVE_INTERPOLATION,
+                            prim_header_index,
+                            0,
+                            &batch_filter,
+                        );
+                    }
+                }
+            }
+            PrimitiveInstanceKind::CachedLinearGradient { data_handle, ref visible_tiles_range, .. } => {
+                let prim_data = &ctx.data_stores.linear_grad[data_handle];
+                let common_data = &prim_data.common;
+                let specified_blend_mode = BlendMode::PremultipliedAlpha;
+
+                let src_color = render_tasks.resolve_location(prim_data.src_color, gpu_cache);
+
+                let (uv_rect_address, texture_source) = match src_color {
+                    Some(src) => src,
+                    None => {
+                        return;
+                    }
+                };
+
+                let textures = TextureSet::prim_textured(texture_source);
+
+                let prim_header = PrimitiveHeader {
+                    local_rect: prim_rect,
+                    local_clip_rect: prim_info.combined_local_clip_rect,
+                    specific_prim_address: gpu_cache.get_address(&common_data.gpu_cache_handle),
+                    transform_id,
+                };
+
+                let prim_user_data = ImageBrushData {
+                    color_mode: ShaderColorMode::Image,
+                    alpha_type: AlphaType::PremultipliedAlpha,
+                    raster_space: RasterizationSpace::Local,
+                    opacity: 1.0,
+                }.encode();
+
+                let non_segmented_blend_mode = if !common_data.opacity.is_opaque ||
+                    prim_info.clip_task_index != ClipTaskIndex::INVALID ||
+                    transform_kind == TransformedRectKind::Complex
+                {
+                    specified_blend_mode
+                } else {
+                    BlendMode::None
+                };
+
+                let batch_kind = BrushBatchKind::Image(texture_source.image_buffer_kind());
+
+                if visible_tiles_range.is_empty() {
+                    let batch_params = BrushBatchParameters::shared(
+                        batch_kind,
+                        textures,
+                        prim_user_data,
+                        uv_rect_address.as_int(),
+                    );
+
+                    let segments = if prim_data.brush_segments.is_empty() {
+                        None
+                    } else {
+                        Some(&prim_data.brush_segments[..])
+                    };
+
+                    let prim_header_index = prim_headers.push(
+                        &prim_header,
+                        z_id,
+                        batch_params.prim_user_data,
+                    );
+
+                    self.add_segmented_prim_to_batch(
+                        segments,
+                        common_data.opacity,
+                        &batch_params,
                         specified_blend_mode,
+                        non_segmented_blend_mode,
                         batch_features,
+                        prim_header_index,
                         bounding_rect,
-                        clip_task_address,
-                        gpu_cache,
-                        &prim_header,
-                        prim_headers,
+                        transform_kind,
                         z_id,
+                        prim_info.clip_task_index,
                         &batch_filter,
-                        clip_mask_texture_id,
+                        ctx,
+                        render_tasks,
                     );
+                } else {
+                    let visible_tiles = &ctx.scratch.gradient_tiles[*visible_tiles_range];
+
+                    let (clip_task_address, clip_mask) = ctx.get_prim_clip_task_and_texture(
+                        prim_info.clip_task_index,
+                        render_tasks,
+                    ).unwrap();
+
+                    let batch_key = BatchKey {
+                        blend_mode: non_segmented_blend_mode,
+                        kind: BatchKind::Brush(batch_kind),
+                        textures: BatchTextures {
+                            input: textures,
+                            clip_mask,
+                        },
+                    };
+
+                    for tile in visible_tiles {
+                        let tile_prim_header = PrimitiveHeader {
+                            local_rect: tile.local_rect,
+                            local_clip_rect: tile.local_clip_rect,
+                            ..prim_header
+                        };
+                        let prim_header_index = prim_headers.push(&tile_prim_header, z_id, prim_user_data);
+
+                        self.add_brush_instance_to_batches(
+                            batch_key,
+                            batch_features,
+                            bounding_rect,
+                            z_id,
+                            INVALID_SEGMENT_INDEX,
+                            EdgeAaSegmentMask::all(),
+                            clip_task_address,
+                            BrushFlags::PERSPECTIVE_INTERPOLATION,
+                            prim_header_index,
+                            uv_rect_address.as_int(),
+                            &batch_filter,
+                        );
+                    }
                 }
             }
             PrimitiveInstanceKind::RadialGradient { data_handle, ref visible_tiles_range, .. } => {
@@ -3218,55 +3269,6 @@
             }
         }
     }
-
-    fn add_gradient_tiles(
-        &mut self,
-        visible_tiles: &[VisibleGradientTile],
-        stops_handle: &GpuCacheHandle,
-        kind: BrushBatchKind,
-        blend_mode: BlendMode,
-        features: BatchFeatures,
-        bounding_rect: &PictureRect,
-        clip_task_address: RenderTaskAddress,
-        gpu_cache: &GpuCache,
-        base_prim_header: &PrimitiveHeader,
-        prim_headers: &mut PrimitiveHeaders,
-        z_id: ZBufferId,
-        batch_filter: &BatchFilter,
-        clip_mask_texture_id: TextureSource,
-    ) {
-        let key = BatchKey {
-            blend_mode,
-            kind: BatchKind::Brush(kind),
-            textures: BatchTextures::prim_untextured(clip_mask_texture_id),
-        };
-
-        let user_data = [stops_handle.as_int(gpu_cache), 0, 0, 0];
-
-        for tile in visible_tiles {
-            let prim_header = PrimitiveHeader {
-                specific_prim_address: gpu_cache.get_address(&tile.handle),
-                local_rect: tile.local_rect,
-                local_clip_rect: tile.local_clip_rect,
-                ..*base_prim_header
-            };
-            let prim_header_index = prim_headers.push(&prim_header, z_id, user_data);
-
-            self.add_brush_instance_to_batches(
-                key,
-                features,
-                bounding_rect,
-                z_id,
-                INVALID_SEGMENT_INDEX,
-                EdgeAaSegmentMask::all(),
-                clip_task_address,
-                BrushFlags::PERSPECTIVE_INTERPOLATION,
-                prim_header_index,
-                0,
-                batch_filter,
-            );
-        }
-    }
 }
 
 /// Either a single texture / user data for all segments,