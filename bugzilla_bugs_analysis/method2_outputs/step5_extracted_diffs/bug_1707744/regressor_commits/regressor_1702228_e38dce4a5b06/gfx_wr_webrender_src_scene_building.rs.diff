# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/scene_building.rs
# Commit: e38dce4a5b06
# Full Hash: e38dce4a5b06869dd4a4d753f41f7594a8cddfb6
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2021-04-22 21:31:57
# Regressor Bug: 1702228
# File Overlap Count: 2
# Description:
#   Bug 1702228 - Cache linear gradients by default. r=gw
#   
#   This patch breaks linear gradients into two primitives:
#    - LinearGradient is always rendered via the brush shader. It is only used with SWGL.
#    - CachedLinearGradient is always rendered via a cached render task and the brush image shader. Its implementation is very similar to conic and radial gradients, with the addition of a fast-path for axis aligned gradients with two stops.
# ==============================================================================

diff -r b3f8befa510f -r e38dce4a5b06 gfx/wr/webrender/src/scene_building.rs
--- a/gfx/wr/webrender/src/scene_building.rs	Thu Apr 22 10:34:54 2021 +0000
+++ b/gfx/wr/webrender/src/scene_building.rs	Thu Apr 22 10:34:54 2021 +0000
@@ -65,6 +65,7 @@
 use crate::prim_store::gradient::{
     GradientStopKey, LinearGradient, RadialGradient, RadialGradientParams, ConicGradient,
     ConicGradientParams, optimize_radial_gradient, apply_gradient_local_clip,
+    optimize_linear_gradient,
 };
 use crate::prim_store::image::{Image, YuvImage};
 use crate::prim_store::line_dec::{LineDecoration, LineDecorationCacheKey, get_line_decoration_size};
@@ -1214,34 +1215,73 @@
             DisplayItem::Gradient(ref info) => {
                 profile_scope!("gradient");
 
-                let (layout, unsnapped_rect, spatial_node_index, clip_chain_id) = self.process_common_properties_with_bounds(
+                let (mut layout, unsnapped_rect, spatial_node_index, clip_chain_id) = self.process_common_properties_with_bounds(
                     &info.common,
                     &info.bounds,
                 );
 
-                let tile_size = process_repeat_size(
+                let mut tile_size = process_repeat_size(
                     &layout.rect,
                     &unsnapped_rect,
                     info.tile_size,
                 );
 
-                if let Some(prim_key_kind) = self.create_linear_gradient_prim(
-                    &layout,
-                    info.gradient.start_point,
-                    info.gradient.end_point,
-                    item.gradient_stops(),
-                    info.gradient.extend_mode,
-                    tile_size,
+                let mut stops = read_gradient_stops(item.gradient_stops());
+                let mut start = info.gradient.start_point;
+                let mut end = info.gradient.end_point;
+                let flags = layout.flags;
+
+                let optimized = optimize_linear_gradient(
+                    &mut layout.rect,
+                    &mut tile_size,
                     info.tile_spacing,
-                    None,
-                ) {
-                    self.add_nonshadowable_primitive(
-                        spatial_node_index,
-                        clip_chain_id,
+                    &layout.clip_rect,
+                    &mut start,
+                    &mut end,
+                    info.gradient.extend_mode,
+                    &mut stops,
+                    &mut |rect, clip, start, end, stops| {
+                        let layout = LayoutPrimitiveInfo { rect: *rect, clip_rect: *clip, flags };
+                        if let Some(prim_key_kind) = self.create_linear_gradient_prim(
+                            &layout,
+                            start,
+                            end,
+                            stops.to_vec(),
+                            ExtendMode::Clamp,
+                            rect.size,
+                            LayoutSize::zero(),
+                            None,
+                        ) {
+                            self.add_nonshadowable_primitive(
+                                spatial_node_index,
+                                clip_chain_id,
+                                &layout,
+                                Vec::new(),
+                                prim_key_kind,
+                            );
+                        }
+                    }
+                );
+
+                if !optimized {
+                    if let Some(prim_key_kind) = self.create_linear_gradient_prim(
                         &layout,
-                        Vec::new(),
-                        prim_key_kind,
-                    );
+                        start,
+                        end,
+                        stops,
+                        info.gradient.extend_mode,
+                        tile_size,
+                        info.tile_spacing,
+                        None,
+                    ) {
+                        self.add_nonshadowable_primitive(
+                            spatial_node_index,
+                            clip_chain_id,
+                            &layout,
+                            Vec::new(),
+                            prim_key_kind,
+                        );
+                    }
                 }
             }
             DisplayItem::RadialGradient(ref info) => {
@@ -2990,7 +3030,7 @@
                             &info,
                             gradient.start_point,
                             gradient.end_point,
-                            gradient_stops,
+                            read_gradient_stops(gradient_stops),
                             gradient.extend_mode,
                             LayoutSize::new(border.height as f32, border.width as f32),
                             LayoutSize::zero(),
@@ -3071,7 +3111,7 @@
         info: &LayoutPrimitiveInfo,
         start_point: LayoutPoint,
         end_point: LayoutPoint,
-        stops: ItemRange<GradientStop>,
+        stops: Vec<GradientStopKey>,
         extend_mode: ExtendMode,
         stretch_size: LayoutSize,
         mut tile_spacing: LayoutSize,
@@ -3080,19 +3120,17 @@
         let mut prim_rect = info.rect;
         simplify_repeated_primitive(&stretch_size, &mut tile_spacing, &mut prim_rect);
 
-        let mut max_alpha: f32 = 0.0;
-
-        let stops = stops.iter().map(|stop| {
-            max_alpha = max_alpha.max(stop.color.a);
-            GradientStopKey {
-                offset: stop.offset,
-                color: stop.color.into(),
+        let mut is_entirely_transparent = true;
+        for stop in &stops {
+            if stop.color.a > 0 {
+                is_entirely_transparent = false;
+                break;
             }
-        }).collect();
+        }
 
         // If all the stops have no alpha, then this
         // gradient can't contribute to the scene.
-        if max_alpha <= 0.0 {
+        if is_entirely_transparent {
             return None;
         }
 
@@ -3114,6 +3152,13 @@
             (start_point, end_point)
         };
 
+        let is_tiled = prim_rect.size.width > stretch_size.width
+         || prim_rect.size.height > stretch_size.height;
+        // SWGL has a fast-path that can render gradients faster than it can sample from the
+        // texture cache so we disable caching in this configuration. Cached gradients are
+        // faster on hardware.
+        let cached = !self.config.is_software || is_tiled;
+
         Some(LinearGradient {
             extend_mode,
             start_point: sp.into(),
@@ -3123,6 +3168,7 @@
             stops,
             reverse_stops,
             nine_patch,
+            cached,
         })
     }
 
@@ -3968,4 +4014,4 @@
             color: stop.color.into(),
         }
     }).collect()
-}
\ No newline at end of file
+}