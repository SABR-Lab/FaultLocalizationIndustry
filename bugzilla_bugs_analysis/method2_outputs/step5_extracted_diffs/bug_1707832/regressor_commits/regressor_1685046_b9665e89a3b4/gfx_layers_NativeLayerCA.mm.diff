# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/NativeLayerCA.mm
# Commit: b9665e89a3b4
# Full Hash: b9665e89a3b433e95db7574f3c06bfc1b641bd46
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2021-01-12 04:33:40
# Regressor Bug: 1685046
# File Overlap Count: 1
# Description:
#   Bug 1685046: Hoist release asserts in RenderCompositorNativeOGL::Bind to crash earlier. r=jrmuizel
#   
#   This change spreads the release asserts to functions that are invoked by other
#   callers, potentially increasing the cases where the assert will fail. This is
#   being done intentionally; we want additional information on the reasons for
# ==============================================================================

diff -r 82d8d42717df -r b9665e89a3b4 gfx/layers/NativeLayerCA.mm
--- a/gfx/layers/NativeLayerCA.mm	Sat Jan 09 02:34:21 2021 +0000
+++ b/gfx/layers/NativeLayerCA.mm	Mon Jan 11 15:49:09 2021 +0000
@@ -618,11 +618,7 @@
 }
 
 bool NativeLayerCA::NextSurface(const MutexAutoLock& aLock) {
-  if (mSize.IsEmpty()) {
-    NSLog(@"NextSurface returning false because of invalid mSize (%d, %d).", mSize.width,
-          mSize.height);
-    return false;
-  }
+  MOZ_RELEASE_ASSERT(!mSize.IsEmpty(), "NextSurface invalid mSize.");
 
   MOZ_RELEASE_ASSERT(
       !mInProgressSurface,
@@ -632,10 +628,7 @@
   Maybe<SurfaceWithInvalidRegion> surf = GetUnusedSurfaceAndCleanUp(aLock);
   if (!surf) {
     CFTypeRefPtr<IOSurfaceRef> newSurf = mSurfacePoolHandle->ObtainSurfaceFromPool(mSize);
-    if (!newSurf) {
-      NSLog(@"NextSurface returning false because IOSurfaceCreate failed to create the surface.");
-      return false;
-    }
+    MOZ_RELEASE_ASSERT(newSurf, "NextSurface IOSurfaceCreate failed to create the surface.");
     surf = Some(SurfaceWithInvalidRegion{newSurf, IntRect({}, mSize)});
   }
 
@@ -710,15 +703,11 @@
                                                       const IntRegion& aUpdateRegion,
                                                       bool aNeedsDepth) {
   MutexAutoLock lock(mMutex);
-  if (!NextSurface(lock)) {
-    return Nothing();
-  }
+  NextSurface(lock);
 
   Maybe<GLuint> fbo =
       mSurfacePoolHandle->GetFramebufferForSurface(mInProgressSurface->mSurface, aNeedsDepth);
-  if (!fbo) {
-    return Nothing();
-  }
+  MOZ_RELEASE_ASSERT(fbo, "GetFramebufferForSurface failed.");
 
   HandlePartialUpdate(
       lock, aDisplayRect, aUpdateRegion,
@@ -727,9 +716,8 @@
         MOZ_RELEASE_ASSERT(mSurfacePoolHandle->gl());
         mSurfacePoolHandle->gl()->MakeCurrent();
         Maybe<GLuint> sourceFBO = mSurfacePoolHandle->GetFramebufferForSurface(validSource, false);
-        if (!sourceFBO) {
-          return;
-        }
+        MOZ_RELEASE_ASSERT(sourceFBO,
+                           "GetFramebufferForSurface failed during HandlePartialUpdate.");
         for (auto iter = copyRegion.RectIter(); !iter.Done(); iter.Next()) {
           gfx::IntRect r = iter.Get();
           if (mSurfaceIsFlipped) {