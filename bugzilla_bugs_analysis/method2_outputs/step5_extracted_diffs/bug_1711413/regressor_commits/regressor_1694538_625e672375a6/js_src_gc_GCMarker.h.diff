# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/GCMarker.h
# Commit: 625e672375a6
# Full Hash: 625e672375a63ec0747a127ebb9b318869d473f6
# Author: Steve Fink <sfink@mozilla.com>
# Date: 2021-03-02 03:46:02
# Regressor Bug: 1694538
# File Overlap Count: 1
# Description:
#   Bug 1694538 - Convert gcWeakKeys from <weakmap, key> tuples that require an extra lookup, to <ptr to color, target> tuples that simplify the code substantially r=jonco
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D106226
# ==============================================================================

diff -r f18f29e5229e -r 625e672375a6 js/src/gc/GCMarker.h
--- a/js/src/gc/GCMarker.h	Mon Mar 01 18:39:22 2021 +0000
+++ b/js/src/gc/GCMarker.h	Mon Mar 01 18:39:28 2021 +0000
@@ -38,7 +38,7 @@
 
 using BarrierBuffer = Vector<JS::GCCellPtr, 0, SystemAllocPolicy>;
 
-struct WeakKeyTableHashPolicy {
+struct EphemeronEdgeTableHashPolicy {
   using Lookup = Cell*;
   static HashNumber hash(const Lookup& v,
                          const mozilla::HashCodeScrambler& hcs) {
@@ -49,22 +49,22 @@
   static void makeEmpty(Cell** vp) { *vp = nullptr; }
 };
 
-struct WeakMarkable {
-  WeakMapBase* weakmap;
-  Cell* key;
+// Ephemeron edges have two source nodes and one target, and mark the target
+// with the minimum (least-marked) color of the sources. Currently, one of
+// those sources will always be a WeakMapBase, so this will refer to its color
+// at the time the edge is traced through. The other source's color will be
+// given by the current mark color of the GCMarker.
+struct EphemeronEdge {
+  CellColor color;
+  Cell* target;
 
-  WeakMarkable(WeakMapBase* weakmapArg, Cell* keyArg)
-      : weakmap(weakmapArg), key(keyArg) {}
-
-  bool operator==(const WeakMarkable& other) const {
-    return weakmap == other.weakmap && key == other.key;
-  }
+  EphemeronEdge(CellColor color_, Cell* cell) : color(color_), target(cell) {}
 };
 
-using WeakEntryVector = Vector<WeakMarkable, 2, js::SystemAllocPolicy>;
+using EphemeronEdgeVector = Vector<EphemeronEdge, 2, js::SystemAllocPolicy>;
 
-using WeakKeyTable =
-    OrderedHashMap<Cell*, WeakEntryVector, WeakKeyTableHashPolicy,
+using EphemeronEdgeTable =
+    OrderedHashMap<Cell*, EphemeronEdgeVector, EphemeronEdgeTableHashPolicy,
                    js::SystemAllocPolicy>;
 
 /*
@@ -244,14 +244,14 @@
   // Have not yet started marking.
   NotActive,
 
-  // Main marking mode. Weakmap marking will be populating the weakKeys tables
-  // but not consulting them. The state will transition to WeakMarking until it
-  // is done, then back to RegularMarking.
+  // Main marking mode. Weakmap marking will be populating the gcEphemeronEdges
+  // tables but not consulting them. The state will transition to WeakMarking
+  // until it is done, then back to RegularMarking.
   RegularMarking,
 
   // Same as RegularMarking except now every marked obj/script is immediately
-  // looked up in the weakKeys table to see if it is a weakmap key, and
-  // therefore might require marking its value. Transitions back to
+  // looked up in the gcEphemeronEdges table to find edges generated by weakmap
+  // keys, and traversing them to their values. Transitions back to
   // RegularMarking when done.
   WeakMarking,
 
@@ -341,13 +341,6 @@
   void delayMarkingChildrenOnOOM(gc::Cell* cell);
   void delayMarkingChildren(gc::Cell* cell);
 
-  // Remove <map,toRemove> from the weak keys table indexed by 'key'.
-  void forgetWeakKey(js::gc::WeakKeyTable& weakKeys, WeakMapBase* map,
-                     gc::Cell* keyOrDelegate, gc::Cell* keyToRemove);
-
-  // Purge all mention of 'map' from the weak keys table.
-  void forgetWeakMap(WeakMapBase* map, Zone* zone);
-
   // 'delegate' is no longer the delegate of 'key'.
   void severWeakDelegate(JSObject* key, JSObject* delegate);
 
@@ -384,7 +377,10 @@
   bool shouldCheckCompartments() { return strictCompartmentChecking; }
 #endif
 
-  void markEphemeronValues(gc::Cell* markedCell, gc::WeakEntryVector& entry);
+  // Mark through edges whose target color depends on the colors of two source
+  // entities (eg a WeakMap and one of its keys), and push the target onto the
+  // mark stack.
+  void markEphemeronEdges(gc::EphemeronEdgeVector& edges);
 
   size_t getMarkCount() const { return markCount; }
   void clearMarkCount() { markCount = 0; }