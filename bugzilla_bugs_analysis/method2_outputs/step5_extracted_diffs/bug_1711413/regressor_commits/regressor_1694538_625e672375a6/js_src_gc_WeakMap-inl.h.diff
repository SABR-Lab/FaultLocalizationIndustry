# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/WeakMap-inl.h
# Commit: 625e672375a6
# Full Hash: 625e672375a63ec0747a127ebb9b318869d473f6
# Author: Steve Fink <sfink@mozilla.com>
# Date: 2021-03-02 03:46:02
# Regressor Bug: 1694538
# File Overlap Count: 1
# Description:
#   Bug 1694538 - Convert gcWeakKeys from <weakmap, key> tuples that require an extra lookup, to <ptr to color, target> tuples that simplify the code substantially r=jonco
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D106226
# ==============================================================================

diff -r f18f29e5229e -r 625e672375a6 js/src/gc/WeakMap-inl.h
--- a/js/src/gc/WeakMap-inl.h	Mon Mar 01 18:39:22 2021 +0000
+++ b/js/src/gc/WeakMap-inl.h	Mon Mar 01 18:39:28 2021 +0000
@@ -133,8 +133,8 @@
   // We should only be processing <weakmap,key> pairs where the key exists in
   // the weakmap. Such pairs are inserted when a weakmap is marked, and are
   // removed by barriers if the key is removed from the weakmap. Failure here
-  // probably means gcWeakKeys is not being properly traced during a minor GC,
-  // or the weakmap keys are not being updated when tenured.
+  // probably means gcEphemeronEdges is not being properly traced during a minor
+  // GC, or the weakmap keys are not being updated when tenured.
   MOZ_ASSERT(p.found());
 
   mozilla::DebugOnly<gc::Cell*> oldKey = gc::ToMarkable(p->key());
@@ -157,15 +157,16 @@
 
   if (delegate) {
     CellColor delegateColor = gc::detail::GetEffectiveColor(rt, delegate);
-    // The key needs to stay alive while both the delegate and map are live.
-    CellColor proxyPreserveColor = std::min(delegateColor, mapColor);
-    if (keyColor < proxyPreserveColor) {
-      gc::AutoSetMarkColor autoColor(*marker, proxyPreserveColor);
+    MOZ_ASSERT(mapColor);
+    // The delegate color should propagate to the key, assuming the map is
+    // potentially alive at all (its color doesn't matter).
+    if (keyColor < delegateColor) {
+      gc::AutoSetMarkColor autoColor(*marker, delegateColor);
       TraceWeakMapKeyEdge(marker, zone(), &key,
                           "proxy-preserved WeakMap entry key");
-      MOZ_ASSERT(key->color() >= proxyPreserveColor);
+      MOZ_ASSERT(key->color() >= delegateColor);
       marked = true;
-      keyColor = proxyPreserveColor;
+      keyColor = delegateColor;
     }
   }
 
@@ -223,45 +224,55 @@
   }
 }
 
-template <class K, class V>
-/* static */ void WeakMap<K, V>::forgetKey(UnbarrieredKey key) {
-  // Remove the key or its delegate from weakKeys.
-  if (zone()->needsIncrementalBarrier()) {
-    JSRuntime* rt = zone()->runtimeFromMainThread();
-    if (JSObject* delegate = js::gc::detail::GetDelegate(key)) {
-      js::gc::WeakKeyTable& weakKeys = delegate->zone()->gcWeakKeys(delegate);
-      rt->gc.marker.forgetWeakKey(weakKeys, this, delegate, key);
-    } else {
-      js::gc::WeakKeyTable& weakKeys = key->zone()->gcWeakKeys(key);
-      rt->gc.marker.forgetWeakKey(weakKeys, this, key, key);
+bool WeakMapBase::addImplicitEdges(gc::Cell* key, gc::Cell* delegate,
+                                   gc::Cell* value) {
+  if (delegate) {
+    auto& edgeTable = delegate->zone()->gcEphemeronEdges(delegate);
+    auto* p = edgeTable.get(delegate);
+
+    gc::EphemeronEdgeVector newVector;
+    gc::EphemeronEdgeVector& edges = p ? p->value : newVector;
+
+    // Add a delegate -> key edge, where the key is marked the color of the
+    // delegate no matter what the weakmap's mark color is. This is implemented
+    // as if it were a regular ephemeron <weakmap, key> -> value edge, where
+    // the value color is the minimum of the two source colors, but in place of
+    // the weakmap we use the constant color Black, which results in the
+    // delegate's color propagating unchanged.
+    gc::EphemeronEdge keyEdge{CellColor::Black, key};
+    if (!edges.append(keyEdge)) {
+      return false;
     }
-  }
-}
 
-template <class K, class V>
-/* static */ void WeakMap<K, V>::clear() {
-  Base::clear();
-  JSRuntime* rt = zone()->runtimeFromMainThread();
-  if (zone()->needsIncrementalBarrier()) {
-    rt->gc.marker.forgetWeakMap(this, zone());
+    if (value) {
+      gc::EphemeronEdge valueEdge{mapColor, value};
+      if (!edges.append(valueEdge)) {
+        return false;
+      }
+    }
+
+    if (!p) {
+      return edgeTable.put(delegate, std::move(newVector));
+    }
+
+    return true;
   }
-}
 
-/* static */ inline void WeakMapBase::addWeakEntry(
-    GCMarker* marker, gc::Cell* key, const gc::WeakMarkable& markable) {
-  auto& weakKeys = key->zone()->gcWeakKeys(key);
-  auto p = weakKeys.get(key);
+  // No delegate. Insert just the key -> value edge.
+
+  if (!value) {
+    return true;
+  }
+
+  auto& edgeTable = key->zone()->gcEphemeronEdges(key);
+  auto* p = edgeTable.get(key);
+  gc::EphemeronEdge valueEdge{mapColor, value};
   if (p) {
-    gc::WeakEntryVector& weakEntries = p->value;
-    if (!weakEntries.append(markable)) {
-      marker->abortLinearWeakMarking();
-    }
+    return p->value.append(valueEdge);
   } else {
-    gc::WeakEntryVector weakEntries;
-    MOZ_ALWAYS_TRUE(weakEntries.append(markable));
-    if (!weakKeys.put(key, std::move(weakEntries))) {
-      marker->abortLinearWeakMarking();
-    }
+    gc::EphemeronEdgeVector edges;
+    MOZ_ALWAYS_TRUE(edges.append(valueEdge));
+    return edgeTable.put(key, std::move(edges));
   }
 }
 
@@ -294,11 +305,11 @@
       // then the lookup key is the delegate (because marking the key will end
       // up marking the delegate and thereby mark the entry.)
       gc::Cell* weakKey = e.front().key();
-      gc::WeakMarkable markable(this, weakKey);
-      if (JSObject* delegate = gc::detail::GetDelegate(e.front().key())) {
-        addWeakEntry(marker, delegate, markable);
-      } else {
-        addWeakEntry(marker, weakKey, markable);
+      gc::Cell* value = gc::ToMarkable(e.front().value());
+      gc::Cell* delegate = gc::detail::GetDelegate(e.front().key());
+
+      if (!addImplicitEdges(weakKey, delegate, value)) {
+        marker->abortLinearWeakMarking();
       }
     }
   }
@@ -307,26 +318,6 @@
 }
 
 template <class K, class V>
-void WeakMap<K, V>::postSeverDelegate(GCMarker* marker, JSObject* key) {
-  if (mapColor) {
-    // We only stored the delegate, not the key, and we're severing the
-    // delegate from the key. So store the key.
-    gc::WeakMarkable markable(this, key);
-    addWeakEntry(marker, key, markable);
-  }
-}
-
-template <class K, class V>
-void WeakMap<K, V>::postRestoreDelegate(GCMarker* marker, JSObject* key,
-                                        JSObject* delegate) {
-  if (mapColor) {
-    // We had the key stored, but are removing it. Store the delegate instead.
-    gc::WeakMarkable markable(this, key);
-    addWeakEntry(marker, delegate, markable);
-  }
-}
-
-template <class K, class V>
 void WeakMap<K, V>::sweep() {
   /* Remove all entries whose keys remain unmarked. */
   for (Enum e(*this); !e.empty(); e.popFront()) {