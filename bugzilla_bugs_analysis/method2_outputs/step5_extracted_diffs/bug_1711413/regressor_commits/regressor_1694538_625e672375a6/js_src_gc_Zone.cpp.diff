# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Zone.cpp
# Commit: 625e672375a6
# Full Hash: 625e672375a63ec0747a127ebb9b318869d473f6
# Author: Steve Fink <sfink@mozilla.com>
# Date: 2021-03-02 03:46:02
# Regressor Bug: 1694538
# File Overlap Count: 1
# Description:
#   Bug 1694538 - Convert gcWeakKeys from <weakmap, key> tuples that require an extra lookup, to <ptr to color, target> tuples that simplify the code substantially r=jonco
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D106226
# ==============================================================================

diff -r f18f29e5229e -r 625e672375a6 js/src/gc/Zone.cpp
--- a/js/src/gc/Zone.cpp	Mon Mar 01 18:39:22 2021 +0000
+++ b/js/src/gc/Zone.cpp	Mon Mar 01 18:39:28 2021 +0000
@@ -164,9 +164,10 @@
       crossZoneStringWrappers_(this),
       gcGrayRoots_(this),
       weakCaches_(this),
-      gcWeakKeys_(this, SystemAllocPolicy(), rt->randomHashCodeScrambler()),
-      gcNurseryWeakKeys_(this, SystemAllocPolicy(),
-                         rt->randomHashCodeScrambler()),
+      gcEphemeronEdges_(this, SystemAllocPolicy(),
+                        rt->randomHashCodeScrambler()),
+      gcNurseryEphemeronEdges_(this, SystemAllocPolicy(),
+                               rt->randomHashCodeScrambler()),
       typeDescrObjects_(this, this),
       markedAtoms_(this),
       atomCache_(this),
@@ -214,7 +215,8 @@
 
 bool Zone::init() {
   regExps_.ref() = make_unique<RegExpZone>(this);
-  return regExps_.ref() && gcWeakKeys().init() && gcNurseryWeakKeys().init();
+  return regExps_.ref() && gcEphemeronEdges().init() &&
+         gcNurseryEphemeronEdges().init();
 }
 
 void Zone::setNeedsIncrementalBarrier(bool needs) {
@@ -241,7 +243,7 @@
 }
 
 template <class Pred>
-static void EraseIf(js::gc::WeakEntryVector& entries, Pred pred) {
+static void EraseIf(js::gc::EphemeronEdgeVector& entries, Pred pred) {
   auto* begin = entries.begin();
   auto* const end = entries.end();
 
@@ -256,29 +258,30 @@
   entries.shrinkBy(removed);
 }
 
-static void SweepWeakEntryVectorWhileMinorSweeping(
-    js::gc::WeakEntryVector& entries) {
-  EraseIf(entries, [](js::gc::WeakMarkable& markable) -> bool {
-    return IsAboutToBeFinalizedDuringMinorSweep(&markable.key);
+static void SweepEphemeronEdgesWhileMinorSweeping(
+    js::gc::EphemeronEdgeVector& entries) {
+  EraseIf(entries, [](js::gc::EphemeronEdge& edge) -> bool {
+    return IsAboutToBeFinalizedDuringMinorSweep(&edge.target);
   });
 }
 
 void Zone::sweepAfterMinorGC(JSTracer* trc) {
-  sweepWeakKeysAfterMinorGC();
+  sweepEphemeronTablesAfterMinorGC();
   crossZoneStringWrappers().sweepAfterMinorGC(trc);
 }
 
-void Zone::sweepWeakKeysAfterMinorGC() {
-  for (WeakKeyTable::Range r = gcNurseryWeakKeys().all(); !r.empty();
-       r.popFront()) {
-    // Sweep gcNurseryWeakKeys to move live (forwarded) keys to gcWeakKeys,
-    // scanning through all the entries for such keys to update them.
+void Zone::sweepEphemeronTablesAfterMinorGC() {
+  for (EphemeronEdgeTable::Range r = gcNurseryEphemeronEdges().all();
+       !r.empty(); r.popFront()) {
+    // Sweep gcNurseryEphemeronEdges to move live (forwarded) keys to
+    // gcEphemeronEdges, scanning through all the entries for such keys to
+    // update them.
     //
     // Forwarded and dead keys may also appear in their delegates' entries,
     // so sweep those too (see below.)
 
     // The tricky case is when the key has a delegate that was already
-    // tenured. Then it will be in its compartment's gcWeakKeys, but we
+    // tenured. Then it will be in its compartment's gcEphemeronEdges, but we
     // still need to update the key (which will be in the entries
     // associated with it.)
     gc::Cell* key = r.front().key;
@@ -290,17 +293,17 @@
 
     // Key been moved. The value is an array of <map,key> pairs; update all
     // keys in that array.
-    WeakEntryVector& entries = r.front().value;
-    SweepWeakEntryVectorWhileMinorSweeping(entries);
+    EphemeronEdgeVector& entries = r.front().value;
+    SweepEphemeronEdgesWhileMinorSweeping(entries);
 
-    // Live (moved) nursery cell. Append entries to gcWeakKeys.
-    auto entry = gcWeakKeys().get(key);
+    // Live (moved) nursery cell. Append entries to gcEphemeronEdges.
+    auto* entry = gcEphemeronEdges().get(key);
     if (!entry) {
-      if (!gcWeakKeys().put(key, gc::WeakEntryVector())) {
+      if (!gcEphemeronEdges().put(key, gc::EphemeronEdgeVector())) {
         AutoEnterOOMUnsafeRegion oomUnsafe;
         oomUnsafe.crash("Failed to tenure weak keys entry");
       }
-      entry = gcWeakKeys().get(key);
+      entry = gcEphemeronEdges().get(key);
     }
 
     for (auto& markable : entries) {
@@ -319,21 +322,21 @@
     }
     MOZ_ASSERT(delegate->isTenured());
 
-    // If delegate was formerly nursery-allocated, we will sweep its
-    // entries when we visit its gcNurseryWeakKeys (if we haven't already).
-    // Note that we don't know the nursery address of the delegate, since
-    // the location it was stored in has already been updated.
+    // If delegate was formerly nursery-allocated, we will sweep its entries
+    // when we visit its gcNurseryEphemeronEdges (if we haven't already). Note
+    // that we don't know the nursery address of the delegate, since the
+    // location it was stored in has already been updated.
     //
-    // Otherwise, it will be in gcWeakKeys and we sweep it here.
-    auto p = delegate->zone()->gcWeakKeys().get(delegate);
+    // Otherwise, it will be in gcEphemeronEdges and we sweep it here.
+    auto* p = delegate->zone()->gcEphemeronEdges().get(delegate);
     if (p) {
-      SweepWeakEntryVectorWhileMinorSweeping(p->value);
+      SweepEphemeronEdgesWhileMinorSweeping(p->value);
     }
   }
 
-  if (!gcNurseryWeakKeys().clear()) {
+  if (!gcNurseryEphemeronEdges().clear()) {
     AutoEnterOOMUnsafeRegion oomUnsafe;
-    oomUnsafe.crash("OOM while clearing gcNurseryWeakKeys.");
+    oomUnsafe.crash("OOM while clearing gcNurseryEphemeronEdges.");
   }
 }
 