# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/thumbnails/PageThumbsWorker.js
# Commit: 5ea572e91652
# Full Hash: 5ea572e916522c6a1a96daef9f37427ab245ed57
# Author: Emma Malysz <emalysz@mozilla.com>
# Date: 2021-05-11 02:09:31
# Regressor Bug: 1649602
# File Overlap Count: 2
# Description:
#   Bug 1649602, remove OS.File from PageThumbs.jsm r=Gijs,barret
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D101066
# ==============================================================================

diff -r a00207a14a8b -r 5ea572e91652 toolkit/components/thumbnails/PageThumbsWorker.js
--- a/toolkit/components/thumbnails/PageThumbsWorker.js	Mon May 10 16:06:34 2021 +0000
+++ b/toolkit/components/thumbnails/PageThumbsWorker.js	Mon May 10 16:18:44 2021 +0000
@@ -6,20 +6,14 @@
 
 /**
  * A worker dedicated for the I/O component of PageThumbs storage.
- *
- * Do not rely on the API of this worker. In a future version, it might be
- * fully replaced by a OS.File global I/O worker.
  */
 
 "use strict";
 
-importScripts("resource://gre/modules/osfile.jsm");
+importScripts("resource://gre/modules/workers/require.js");
 
 var PromiseWorker = require("resource://gre/modules/workers/PromiseWorker.js");
 
-var File = OS.File;
-var Type = OS.Shared.Type;
-
 var worker = new PromiseWorker.AbstractWorker();
 worker.dispatch = function(method, args = []) {
   return Agent[method](...args);
@@ -39,14 +33,14 @@
 var Agent = {
   // Checks if the specified file exists and has an age less than as
   // specifed (in seconds).
-  isFileRecent: function Agent_isFileRecent(path, maxAge) {
+  async isFileRecent(path, maxAge) {
     try {
-      let stat = OS.File.stat(path);
+      let stat = await IOUtils.stat(path);
       let maxDate = new Date();
       maxDate.setSeconds(maxDate.getSeconds() - maxAge);
-      return stat.lastModificationDate > maxDate;
+      return stat.lastModified > maxDate;
     } catch (ex) {
-      if (!(ex instanceof OS.File.Error)) {
+      if (!(ex instanceof DOMException)) {
         throw ex;
       }
       // file doesn't exist (or can't be stat'd) - must be stale.
@@ -54,25 +48,21 @@
     }
   },
 
-  remove: function Agent_removeFile(path) {
+  async remove(path) {
     try {
-      OS.File.remove(path);
+      await IOUtils.remove(path);
       return true;
     } catch (e) {
       return false;
     }
   },
 
-  expireFilesInDirectory: function Agent_expireFilesInDirectory(
-    path,
-    filesToKeep,
-    minChunkSize
-  ) {
-    let entries = this.getFileEntriesInDirectory(path, filesToKeep);
+  async expireFilesInDirectory(path, filesToKeep, minChunkSize) {
+    let entries = await this.getFileEntriesInDirectory(path, filesToKeep);
     let limit = Math.max(minChunkSize, Math.round(entries.length / 2));
 
     for (let entry of entries) {
-      this.remove(entry.path);
+      await this.remove(entry);
 
       // Check if we reached the limit of files to remove.
       if (--limit <= 0) {
@@ -83,59 +73,45 @@
     return true;
   },
 
-  getFileEntriesInDirectory: function Agent_getFileEntriesInDirectory(
-    path,
-    skipFiles
-  ) {
-    let iter = new OS.File.DirectoryIterator(path);
-    try {
-      if (!iter.exists()) {
-        return [];
-      }
+  async getFileEntriesInDirectory(path, skipFiles) {
+    let children = await IOUtils.getChildren(path);
+    let skip = new Set(skipFiles);
 
-      let skip = new Set(skipFiles);
-
-      let entries = [];
-      for (let entry of iter) {
-        if (!entry.isDir && !entry.isSymLink && !skip.has(entry.name)) {
-          entries.push(entry);
-        }
+    let entries = [];
+    for (let entry of children) {
+      let stat = await IOUtils.stat(entry);
+      if (stat.type === "regular" && !skip.has(PathUtils.filename(entry))) {
+        entries.push(entry);
       }
-      return entries;
-    } finally {
-      iter.close();
     }
+    return entries;
   },
 
-  moveOrDeleteAllThumbnails: function Agent_moveOrDeleteAllThumbnails(
-    pathFrom,
-    pathTo
-  ) {
-    OS.File.makeDir(pathTo, { ignoreExisting: true });
+  async moveOrDeleteAllThumbnails(pathFrom, pathTo) {
+    await IOUtils.makeDirectory(pathTo);
     if (pathFrom == pathTo) {
       return true;
     }
-    let iter = new OS.File.DirectoryIterator(pathFrom);
-    if (iter.exists()) {
-      for (let entry of iter) {
-        if (entry.isDir || entry.isSymLink) {
-          continue;
-        }
+    let children = await IOUtils.getChildren(pathFrom);
+    for (let entry of children) {
+      let stat = await IOUtils.stat(entry);
+      if (stat.type !== "regular") {
+        continue;
+      }
 
-        let from = OS.Path.join(pathFrom, entry.name);
-        let to = OS.Path.join(pathTo, entry.name);
+      let fileName = PathUtils.filename(entry);
+      let from = PathUtils.join(pathFrom, fileName);
+      let to = PathUtils.join(pathTo, fileName);
 
-        try {
-          OS.File.move(from, to, { noOverwrite: true, noCopy: true });
-        } catch (e) {
-          OS.File.remove(from);
-        }
+      try {
+        await IOUtils.move(from, to, { noOverwrite: true });
+      } catch (e) {
+        await IOUtils.remove(from);
       }
     }
-    iter.close();
 
     try {
-      OS.File.removeEmptyDir(pathFrom);
+      await IOUtils.remove(pathFrom, { recursive: true });
     } catch (e) {
       // This could fail if there's something in
       // the folder we're not permitted to remove.
@@ -144,40 +120,36 @@
     return true;
   },
 
-  writeAtomic: function Agent_writeAtomic(path, buffer, options) {
-    return File.writeAtomic(path, buffer, options);
+  writeAtomic(path, buffer, options) {
+    return IOUtils.write(path, buffer, options);
   },
 
-  makeDir: function Agent_makeDir(path, options) {
-    return File.makeDir(path, options);
+  makeDir(path, options) {
+    return IOUtils.makeDirectory(path, options);
   },
 
-  copy: function Agent_copy(source, dest, options) {
-    return File.copy(source, dest, options);
+  copy(source, dest, options) {
+    return IOUtils.copy(source, dest, options);
   },
 
-  wipe: function Agent_wipe(path) {
-    let iterator = new File.DirectoryIterator(path);
-    try {
-      for (let entry of iterator) {
-        try {
-          File.remove(entry.path);
-        } catch (ex) {
-          // If a file cannot be removed, we should still continue.
-          // This can happen at least for any of the following reasons:
-          // - access denied;
-          // - file has been removed recently during a previous wipe
-          //  and the file system has not flushed that yet (yes, this
-          //  can happen under Windows);
-          // - file has been removed by the user or another process.
-        }
+  async wipe(path) {
+    let children = await IOUtils.getChildren(path);
+    for (let entry of children) {
+      try {
+        await IOUtils.remove(entry);
+      } catch (ex) {
+        // If a file cannot be removed, we should still continue.
+        // This can happen at least for any of the following reasons:
+        // - access denied;
+        // - file has been removed recently during a previous wipe
+        //  and the file system has not flushed that yet (yes, this
+        //  can happen under Windows);
+        // - file has been removed by the user or another process.
       }
-    } finally {
-      iterator.close();
     }
   },
 
-  exists: function Agent_exists(path) {
-    return File.exists(path);
+  exists(path) {
+    return IOUtils.exists(path);
   },
 };
