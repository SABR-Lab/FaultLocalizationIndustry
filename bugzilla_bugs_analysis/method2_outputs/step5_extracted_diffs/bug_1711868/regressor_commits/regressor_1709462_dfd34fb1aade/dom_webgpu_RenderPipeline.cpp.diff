# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webgpu/RenderPipeline.cpp
# Commit: dfd34fb1aade
# Full Hash: dfd34fb1aade1295579715b1c21f1e51bbfe370e
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-05-18 21:36:28
# Regressor Bug: 1709462
# File Overlap Count: 2
# Description:
#   Bug 1709462 - Fix freeing of WebGPU bind group layouts r=jimb
#   
#   When the pipeline layout is implicit at pipeline creation,
#   we collect the IDs of BGLs, to be able to produce GPUBindGroupLayout
#   object upon user request. However, the produced object didn't know if
# ==============================================================================

diff -r 5c6f0950714d -r dfd34fb1aade dom/webgpu/RenderPipeline.cpp
--- a/dom/webgpu/RenderPipeline.cpp	Tue May 18 16:24:49 2021 +0000
+++ b/dom/webgpu/RenderPipeline.cpp	Tue May 18 16:26:27 2021 +0000
@@ -16,8 +16,10 @@
 GPU_IMPL_JS_WRAP(RenderPipeline)
 
 RenderPipeline::RenderPipeline(Device* const aParent, RawId aId,
+                               RawId aImplicitPipelineLayoutId,
                                nsTArray<RawId>&& aImplicitBindGroupLayoutIds)
     : ChildOf(aParent),
+      mImplicitPipelineLayoutId(aImplicitPipelineLayoutId),
       mImplicitBindGroupLayoutIds(std::move(aImplicitBindGroupLayoutIds)),
       mId(aId) {}
 
@@ -29,6 +31,8 @@
     auto bridge = mParent->GetBridge();
     if (bridge && bridge->IsOpen()) {
       bridge->SendRenderPipelineDestroy(mId);
+      bridge->SendImplicitLayoutDestroy(mImplicitPipelineLayoutId,
+                                        mImplicitBindGroupLayoutIds);
     }
   }
 }
@@ -36,7 +40,7 @@
 already_AddRefed<BindGroupLayout> RenderPipeline::GetBindGroupLayout(
     uint32_t index) const {
   RefPtr<BindGroupLayout> object =
-      new BindGroupLayout(mParent, mImplicitBindGroupLayoutIds[index]);
+      new BindGroupLayout(mParent, mImplicitBindGroupLayoutIds[index], false);
   return object.forget();
 }
 