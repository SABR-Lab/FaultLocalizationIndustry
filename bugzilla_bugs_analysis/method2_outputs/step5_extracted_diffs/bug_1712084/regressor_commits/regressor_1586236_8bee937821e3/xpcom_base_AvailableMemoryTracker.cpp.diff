# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/base/AvailableMemoryTracker.cpp
# Commit: 8bee937821e3
# Full Hash: 8bee937821e3725b922352a0493f53b5e431c3d0
# Author: Toshihito Kikuchi <tkikuchi@mozilla.com>
# Date: 2021-05-25 09:34:31
# Regressor Bug: 1586236
# File Overlap Count: 1
# Description:
#   Bug 1711610 - Should not trigger the memory pressure event if the available commit space is not low.  r=gsvelto
#   
#   After bug 1586236, we use the memory resource notification object to detect a low
#   memory situation on Windows, which is signaled when the available physical memory
#   is low.  If the available physical memory is low, however, it's possible that there
# ==============================================================================

diff -r e24c277bcb6c -r 8bee937821e3 xpcom/base/AvailableMemoryTracker.cpp
--- a/xpcom/base/AvailableMemoryTracker.cpp	Mon May 24 21:07:40 2021 +0000
+++ b/xpcom/base/AvailableMemoryTracker.cpp	Mon May 24 21:29:46 2021 +0000
@@ -7,6 +7,7 @@
 #include "mozilla/AvailableMemoryTracker.h"
 
 #if defined(XP_WIN)
+#  include "mozilla/StaticPrefs_browser.h"
 #  include "mozilla/WindowsVersion.h"
 #  include "nsExceptionHandler.h"
 #  include "nsIMemoryReporter.h"
@@ -89,6 +90,7 @@
   void OnLowMemory(const MutexAutoLock&);
   void OnHighMemory(const MutexAutoLock&);
   bool IsMemoryLow() const;
+  bool IsCommitSpaceLow() const;
   void StartPollingIfUserInteracting();
   void StopPolling();
   void StopPollingIfUserIdle(const MutexAutoLock&);
@@ -216,8 +218,18 @@
   mUnderMemoryPressure = true;
   ::UnregisterWait(mWaitHandle);
   mWaitHandle = nullptr;
-  RecordLowMemoryEvent();
-  NS_DispatchEventualMemoryPressure(MemPressure_New);
+
+  // On Windows, memory allocations fails when the available commit space is
+  // not sufficient.  It's possible that this callback function is invoked
+  // but there is still commit space enough for the application to continue
+  // to run.  In such a case, there is no strong need to trigger the memory
+  // pressure event.  So we trigger the event only when the available commit
+  // space is low.
+  if (IsCommitSpaceLow()) {
+    RecordLowMemoryEvent();
+    NS_DispatchEventualMemoryPressure(MemPressure_New);
+  }
+
   StartPollingIfUserInteracting();
 }
 
@@ -236,6 +248,24 @@
   return false;
 }
 
+bool nsAvailableMemoryWatcher::IsCommitSpaceLow() const {
+  // Other options to get the available page file size:
+  //   - GetPerformanceInfo
+  //     Too slow, don't use it.
+  //   - PdhCollectQueryData and PdhGetRawCounterValue
+  //     Faster than GetPerformanceInfo, but slower than GlobalMemoryStatusEx.
+  //   - NtQuerySystemInformation(SystemMemoryUsageInformation)
+  //     Faster than GlobalMemoryStatusEx, but undocumented.
+  MEMORYSTATUSEX memStatus = {sizeof(memStatus)};
+  if (!::GlobalMemoryStatusEx(&memStatus)) {
+    return false;
+  }
+
+  constexpr size_t kBytesPerMB = 1024 * 1024;
+  return (memStatus.ullAvailPageFile / kBytesPerMB) <
+         StaticPrefs::browser_low_commit_space_threshold_mb();
+}
+
 void nsAvailableMemoryWatcher::StartPollingIfUserInteracting() {
   if (mInteracting && !mPolling) {
     if (NS_SUCCEEDED(
@@ -276,10 +306,13 @@
   MutexAutoLock lock(mMutex);
   StopPollingIfUserIdle(lock);
 
-  if (IsMemoryLow()) {
+  if (!IsMemoryLow()) {
+    OnHighMemory(lock);
+    return NS_OK;
+  }
+
+  if (IsCommitSpaceLow()) {
     NS_DispatchEventualMemoryPressure(MemPressure_Ongoing);
-  } else {
-    OnHighMemory(lock);
   }
 
   return NS_OK;