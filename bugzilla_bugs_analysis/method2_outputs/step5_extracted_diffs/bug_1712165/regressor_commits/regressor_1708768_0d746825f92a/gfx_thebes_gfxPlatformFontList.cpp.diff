# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxPlatformFontList.cpp
# Commit: 0d746825f92a
# Full Hash: 0d746825f92a3039433aa275997c6e7f2ebfaf56
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2021-05-18 21:36:28
# Regressor Bug: 1708768
# File Overlap Count: 2
# Description:
#   Bug 1708768 - Make InitFontList safe to call off-main-thread on macOS, and run font-list initialization on a separate thread during startup. r=lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D115295
# ==============================================================================

diff -r fbe7310ee5f3 -r 0d746825f92a gfx/thebes/gfxPlatformFontList.cpp
--- a/gfx/thebes/gfxPlatformFontList.cpp	Tue May 18 11:10:43 2021 +0000
+++ b/gfx/thebes/gfxPlatformFontList.cpp	Tue May 18 11:10:43 2021 +0000
@@ -14,6 +14,7 @@
 #include "gfxUserFontSet.h"
 #include "SharedFontList-impl.h"
 
+#include "GeckoProfiler.h"
 #include "nsCRT.h"
 #include "nsGkAtoms.h"
 #include "nsServiceManagerUtils.h"
@@ -238,26 +239,50 @@
   return NS_OK;
 }
 
+PRThread* gfxPlatformFontList::sInitFontListThread = nullptr;
+
+static void InitFontListCallback(void* aFontList) {
+  AUTO_PROFILER_REGISTER_THREAD("InitFontList");
+  PR_SetCurrentThreadName("InitFontList");
+
+  if (!static_cast<gfxPlatformFontList*>(aFontList)->InitFontList()) {
+    gfxPlatformFontList::Shutdown();
+  }
+}
+
+/* static */
+bool gfxPlatformFontList::Initialize(gfxPlatformFontList* aList) {
+  sPlatformFontList = aList;
+  if (XRE_IsParentProcess() &&
+      StaticPrefs::gfx_font_list_omt_enabled_AtStartup() &&
+      !gfxPlatform::InSafeMode()) {
+    sInitFontListThread = PR_CreateThread(
+        PR_USER_THREAD, InitFontListCallback, aList, PR_PRIORITY_NORMAL,
+        PR_GLOBAL_THREAD, PR_JOINABLE_THREAD, 0);
+    return true;
+  }
+  if (aList->InitFontList()) {
+    return true;
+  }
+  Shutdown();
+  return false;
+}
+
 gfxPlatformFontList::gfxPlatformFontList(bool aNeedFullnamePostscriptNames)
     : mFontFamiliesMutex("gfxPlatformFontList::mFontFamiliesMutex"),
       mFontFamilies(64),
       mOtherFamilyNames(16),
-      mSharedCmaps(8),
-      mStartIndex(0),
-      mNumFamilies(0),
-      mFontlistInitCount(0),
-      mFontFamilyWhitelistActive(false) {
-  mOtherFamilyNamesInitialized = false;
-
+      mSharedCmaps(8) {
   if (aNeedFullnamePostscriptNames) {
     mExtraNames = MakeUnique<ExtraNames>();
   }
-  mFaceNameListsInitialized = false;
 
   mLangService = nsLanguageAtomService::GetService();
 
   LoadBadUnderlineList();
 
+  gfxFontUtils::GetPrefsFontList(kFontSystemWhitelistPref, mEnabledFontsList);
+
   // pref changes notification setup
   NS_ASSERTION(!gFontListPrefObserver,
                "There has been font list pref observer already");
@@ -313,9 +338,7 @@
 const uint32_t kNumGenerics = 5;
 
 void gfxPlatformFontList::ApplyWhitelist() {
-  nsTArray<nsCString> list;
-  gfxFontUtils::GetPrefsFontList(kFontSystemWhitelistPref, list);
-  uint32_t numFonts = list.Length();
+  uint32_t numFonts = mEnabledFontsList.Length();
   mFontFamilyWhitelistActive = (numFonts > 0);
   if (!mFontFamilyWhitelistActive) {
     return;
@@ -323,7 +346,7 @@
   nsTHashSet<nsCString> familyNamesWhitelist;
   for (uint32_t i = 0; i < numFonts; i++) {
     nsAutoCString key;
-    ToLowerCase(list[i], key);
+    ToLowerCase(mEnabledFontsList[i], key);
     familyNamesWhitelist.Insert(key);
   }
   AutoTArray<RefPtr<gfxFontFamily>, 128> accepted;
@@ -357,14 +380,12 @@
 
 void gfxPlatformFontList::ApplyWhitelist(
     nsTArray<fontlist::Family::InitData>& aFamilies) {
-  nsTArray<nsCString> list;
-  gfxFontUtils::GetPrefsFontList(kFontSystemWhitelistPref, list);
-  mFontFamilyWhitelistActive = !list.IsEmpty();
+  mFontFamilyWhitelistActive = !mEnabledFontsList.IsEmpty();
   if (!mFontFamilyWhitelistActive) {
     return;
   }
   nsTHashSet<nsCString> familyNamesWhitelist;
-  for (const auto& item : list) {
+  for (const auto& item : mEnabledFontsList) {
     nsAutoCString key;
     ToLowerCase(item, key);
     familyNamesWhitelist.Insert(key);
@@ -437,54 +458,76 @@
 }
 
 bool gfxPlatformFontList::InitFontList() {
-  // This shouldn't be called from stylo threads!
-  MOZ_ASSERT(NS_IsMainThread());
-
-  mFontlistInitCount++;
+  MutexAutoLock lock(mFontFamiliesMutex);
 
   if (LOG_FONTINIT_ENABLED()) {
     LOG_FONTINIT(("(fontinit) system fontlist initialization\n"));
   }
 
-  // rebuilding fontlist so clear out font/word caches
-  gfxFontCache* fontCache = gfxFontCache::GetCache();
-  if (fontCache) {
-    fontCache->FlushShapedWordCaches();
-    fontCache->Flush();
-  }
+  if (mFontlistInitCount) {
+    // Font-list reinitialization always occurs on the main thread, in response
+    // to a change notification; it's only the initial creation during startup
+    // that may be on another thread.
+    MOZ_ASSERT(NS_IsMainThread());
+
+    // Rebuilding fontlist so clear out font/word caches.
+    gfxFontCache* fontCache = gfxFontCache::GetCache();
+    if (fontCache) {
+      fontCache->FlushShapedWordCaches();
+      fontCache->Flush();
+    }
+
+    gfxPlatform::PurgeSkiaFontCache();
 
-  gfxPlatform::PurgeSkiaFontCache();
+    if (NS_IsMainThread()) {
+      nsCOMPtr<nsIObserverService> obs =
+          mozilla::services::GetObserverService();
+      if (obs) {
+        // Notify any current presContexts that fonts are being updated, so
+        // existing caches will no longer be valid.
+        obs->NotifyObservers(nullptr, "font-info-updated", nullptr);
+      }
+    } else {
+      NS_DispatchToMainThread(
+          NS_NewRunnableFunction("font-info-updated notification callback", [] {
+            nsCOMPtr<nsIObserverService> obs =
+                mozilla::services::GetObserverService();
+            if (obs) {
+              obs->NotifyObservers(nullptr, "font-info-updated", nullptr);
+            }
+          }));
+    }
 
-  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
-  if (obs) {
-    // Notify any current presContexts that fonts are being updated, so existing
-    // caches will no longer be valid.
-    obs->NotifyObservers(nullptr, "font-info-updated", nullptr);
+    mAliasTable.Clear();
+    mLocalNameTable.Clear();
+
+    CancelLoadCmapsTask();
+    mStartedLoadingCmapsFrom = 0xffffffffu;
+
+    CancelInitOtherFamilyNamesTask();
+    mFontFamilies.Clear();
+    mOtherFamilyNames.Clear();
+    mOtherFamilyNamesInitialized = false;
+
+    if (mExtraNames) {
+      mExtraNames->mFullnames.Clear();
+      mExtraNames->mPostscriptNames.Clear();
+    }
+    mFaceNameListsInitialized = false;
+    ClearLangGroupPrefFonts();
+    CancelLoader();
+
+    gfxFontUtils::GetPrefsFontList(kFontSystemWhitelistPref, mEnabledFontsList);
+
+    // Ensure SetVisibilityLevel will clear the mCodepointsWithNoFonts set.
+    mVisibilityLevel = FontVisibility::Unknown;
   }
 
-  mAliasTable.Clear();
-  mLocalNameTable.Clear();
-
-  CancelLoadCmapsTask();
-  mStartedLoadingCmapsFrom = 0xffffffffu;
-
-  CancelInitOtherFamilyNamesTask();
-  MutexAutoLock lock(mFontFamiliesMutex);
-  mFontFamilies.Clear();
-  mOtherFamilyNames.Clear();
-  mOtherFamilyNamesInitialized = false;
+  SetVisibilityLevel();
 
-  if (mExtraNames) {
-    mExtraNames->mFullnames.Clear();
-    mExtraNames->mPostscriptNames.Clear();
-  }
-  mFaceNameListsInitialized = false;
-  ClearLangGroupPrefFonts();
-  CancelLoader();
-
-  // Ensure that SetVisibilityLevel will clear the mCodepointsWithNoFonts set.
-  mVisibilityLevel = FontVisibility::Unknown;
-  SetVisibilityLevel();
+  // From here, gfxPlatformFontList::IsInitialized will return true,
+  // unless InitFontListForPlatform() fails and we reset it below.
+  mFontlistInitCount++;
 
   // Try to initialize the cross-process shared font list if enabled by prefs,
   // but not if we're running in Safe Mode.
@@ -516,12 +559,19 @@
     }
     if (oldSharedList && XRE_IsParentProcess()) {
       // notify all children of the change
-      dom::ContentParent::NotifyUpdatedFonts(true);
+      if (NS_IsMainThread()) {
+        dom::ContentParent::NotifyUpdatedFonts(true);
+      } else {
+        NS_DispatchToMainThread(NS_NewRunnableFunction(
+            "NotifyUpdatedFonts callback",
+            [] { dom::ContentParent::NotifyUpdatedFonts(true); }));
+      }
     }
   }
 
   if (!SharedFontList()) {
     if (NS_FAILED(InitFontListForPlatform())) {
+      mFontlistInitCount = 0;
       return false;
     }
     ApplyWhitelist();
@@ -779,23 +829,6 @@
   return fe;
 }
 
-void gfxPlatformFontList::PreloadNamesList() {
-  AutoTArray<nsCString, 10> preloadFonts;
-  gfxFontUtils::GetPrefsFontList("font.preload-names-list", preloadFonts);
-
-  uint32_t numFonts = preloadFonts.Length();
-  for (uint32_t i = 0; i < numFonts; i++) {
-    nsAutoCString key;
-    GenerateFontListKey(preloadFonts[i], key);
-
-    // only search canonical names!
-    gfxFontFamily* familyEntry = mFontFamilies.GetWeak(key);
-    if (familyEntry) {
-      familyEntry->ReadOtherFamilyNames(this);
-    }
-  }
-}
-
 void gfxPlatformFontList::LoadBadUnderlineList() {
   gfxFontUtils::GetPrefsFontList("font.blacklist.underline_offset",
                                  mBadUnderlineFamilyNames);
@@ -2401,7 +2434,13 @@
 
 void gfxPlatformFontList::GetPrefsAndStartLoader() {
   uint32_t delay = std::max(1u, StaticPrefs::gfx_font_loader_delay_AtStartup());
-  StartLoader(delay);
+  if (NS_IsMainThread()) {
+    StartLoader(delay);
+  } else {
+    NS_DispatchToMainThread(NS_NewRunnableFunction(
+        "StartLoader callback",
+        [delay, fontList = this] { fontList->StartLoader(delay); }));
+  }
 }
 
 void gfxPlatformFontList::ForceGlobalReflow() {