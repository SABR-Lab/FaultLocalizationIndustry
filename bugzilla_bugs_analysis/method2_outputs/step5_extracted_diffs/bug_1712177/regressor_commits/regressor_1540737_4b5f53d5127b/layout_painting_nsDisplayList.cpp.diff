# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/painting/nsDisplayList.cpp
# Commit: 4b5f53d5127b
# Full Hash: 4b5f53d5127b36ac51eb71c678b1aa126a066c79
# Author: Matt Woodrow <mwoodrow@mozilla.com>
# Date: 2021-05-18 09:45:31
# Regressor Bug: 1540737
# File Overlap Count: 1
# Description:
#   Bug 1540737 - Implement Paint() for all display items, and nsDisplayList so that we can paint without using FrameLayerBuilder. r=miko
#   
#   This creates a new leaf nsDisplayWrapper item for consumers that just want an empty wrapper, with a Paint method that asserts. This lets us leaves Paint pure-virtual on nsDisplayWrapList, and lets the compiler force us to implement it for the other leaf types.
#   
#   It also disables flattening of transform/opacity items. This is because they flatten the items even when used with FlattenedDisplayItemIterator, even though this doesn't add markers to replace them (only FLB does this). We could in theory fix this, but I don't think FLB performance matters much any more.
# ==============================================================================

diff -r a73e041f1f1d -r 4b5f53d5127b layout/painting/nsDisplayList.cpp
--- a/layout/painting/nsDisplayList.cpp	Mon May 17 23:53:44 2021 +0000
+++ b/layout/painting/nsDisplayList.cpp	Mon May 17 23:53:45 2021 +0000
@@ -2431,6 +2431,37 @@
   return layerBuilder;
 }
 
+void nsDisplayList::Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx,
+                          int32_t aAppUnitsPerDevPixel) {
+  FlattenedDisplayListIterator iter(aBuilder, this);
+  while (iter.HasNext()) {
+    nsPaintedDisplayItem* item = iter.GetNextItem()->AsPaintedDisplayItem();
+    if (!item) {
+      continue;
+    }
+
+    nsRegion visible(item->GetClippedBounds(aBuilder));
+    visible.And(visible, item->GetBuildingRect());
+    item->SetPaintRect(visible.GetBounds());
+    if (!item->ComputeVisibility(aBuilder, &visible)) {
+      continue;
+    }
+
+    DisplayItemClip currentClip = item->GetClip();
+    if (currentClip.HasClip()) {
+      aCtx->Save();
+      currentClip.ApplyTo(aCtx, aAppUnitsPerDevPixel);
+    }
+    aCtx->NewPath();
+
+    item->Paint(aBuilder, aCtx);
+
+    if (currentClip.HasClip()) {
+      aCtx->Restore();
+    }
+  }
+}
+
 /**
  * We paint by executing a layer manager transaction, constructing a
  * single layer representing the display list, and then making it the
@@ -2454,19 +2485,28 @@
       widgetTransaction = true;
     }
   }
-  if (!layerManager) {
-    if (!aCtx) {
-      NS_WARNING("Nowhere to paint into");
-      return nullptr;
-    }
-    layerManager = new BasicLayerManager(BasicLayerManager::BLM_OFFSCREEN);
-  }
 
   nsIFrame* frame = aBuilder->RootReferenceFrame();
   nsPresContext* presContext = frame->PresContext();
   PresShell* presShell = presContext->PresShell();
   Document* document = presShell->GetDocument();
 
+  if (!layerManager) {
+    if (!aCtx) {
+      NS_WARNING("Nowhere to paint into");
+      return nullptr;
+    }
+    bool prevIsCompositingCheap = aBuilder->SetIsCompositingCheap(false);
+    Paint(aBuilder, aCtx, presContext->AppUnitsPerDevPixel());
+
+    if (document && document->IsBeingUsedAsImage()) {
+      frame->ClearInvalidationStateBits();
+    }
+
+    aBuilder->SetIsCompositingCheap(prevIsCompositingCheap);
+    return nullptr;
+  }
+
   if (layerManager->GetBackendType() == layers::LayersBackend::LAYERS_WR) {
     if (doBeginTransaction) {
       if (aCtx) {
@@ -5535,7 +5575,8 @@
   // Create a new nsDisplayWrapList using a copy-constructor. This is done
   // to preserve the information about bounds.
   nsDisplayWrapList* wrapper =
-      MakeClone<nsDisplayWrapList>(aBuilder, wrappedItem);
+      new (aBuilder) nsDisplayWrapper(aBuilder, *wrappedItem);
+  wrapper->SetType(nsDisplayWrapper::ItemType());
   MOZ_ASSERT(wrapper);
 
   // Set the display list pointer of the new wrapper item to the display list
@@ -5576,9 +5617,8 @@
   return Nothing();
 }
 
-void nsDisplayWrapList::Paint(nsDisplayListBuilder* aBuilder,
-                              gfxContext* aCtx) {
-  NS_ERROR("nsDisplayWrapList should have been flattened away for painting");
+void nsDisplayWrapper::Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx) {
+  NS_ERROR("nsDisplayWrapper should have been flattened away for painting");
 }
 
 /**
@@ -5655,7 +5695,7 @@
 
 static nsresult WrapDisplayList(nsDisplayListBuilder* aBuilder,
                                 nsIFrame* aFrame, nsDisplayList* aList,
-                                nsDisplayWrapper* aWrapper) {
+                                nsDisplayItemWrapper* aWrapper) {
   if (!aList->GetTop()) {
     return NS_OK;
   }
@@ -5670,7 +5710,7 @@
 
 static nsresult WrapEachDisplayItem(nsDisplayListBuilder* aBuilder,
                                     nsDisplayList* aList,
-                                    nsDisplayWrapper* aWrapper) {
+                                    nsDisplayItemWrapper* aWrapper) {
   nsDisplayList newList;
   nsDisplayItem* item;
   while ((item = aList->RemoveBottom())) {
@@ -5685,10 +5725,10 @@
   return NS_OK;
 }
 
-nsresult nsDisplayWrapper::WrapLists(nsDisplayListBuilder* aBuilder,
-                                     nsIFrame* aFrame,
-                                     const nsDisplayListSet& aIn,
-                                     const nsDisplayListSet& aOut) {
+nsresult nsDisplayItemWrapper::WrapLists(nsDisplayListBuilder* aBuilder,
+                                         nsIFrame* aFrame,
+                                         const nsDisplayListSet& aIn,
+                                         const nsDisplayListSet& aOut) {
   nsresult rv = WrapListsInPlace(aBuilder, aFrame, aIn);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -5704,9 +5744,9 @@
   return NS_OK;
 }
 
-nsresult nsDisplayWrapper::WrapListsInPlace(nsDisplayListBuilder* aBuilder,
-                                            nsIFrame* aFrame,
-                                            const nsDisplayListSet& aLists) {
+nsresult nsDisplayItemWrapper::WrapListsInPlace(
+    nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+    const nsDisplayListSet& aLists) {
   nsresult rv;
   if (WrapBorderBackground()) {
     // Our border-backgrounds are in-flow
@@ -5786,6 +5826,20 @@
   return container.forget();
 }
 
+void nsDisplayOpacity::Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx) {
+  if (GetOpacity() == 0.0f) {
+    return;
+  }
+
+  // TODO: Compute a bounds rect to pass to PushLayer for a smaller
+  // allocation.
+  aCtx->GetDrawTarget()->PushLayer(false, GetOpacity(), nullptr,
+                                   mozilla::gfx::Matrix());
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+  aCtx->GetDrawTarget()->PopLayer();
+}
+
 /**
  * This doesn't take into account layer scaling --- the layer may be
  * rendered at a higher (or lower) resolution, affecting the retained layer
@@ -5988,10 +6042,8 @@
     return true;
   }
 
-  // Return true if we successfully applied opacity to child items, or if
-  // WebRender is not in use. In the latter case, the opacity gets flattened and
-  // applied during layer building.
-  return ApplyToChildren(aBuilder) || usingLayers;
+  // Return true if we successfully applied opacity to child items.
+  return ApplyToChildren(aBuilder);
 }
 
 nsDisplayItem::LayerState nsDisplayOpacity::GetLayerState(
@@ -6148,6 +6200,16 @@
   return container.forget();
 }
 
+void nsDisplayBlendMode::Paint(nsDisplayListBuilder* aBuilder,
+                               gfxContext* aCtx) {
+  aCtx->GetDrawTarget()->PushLayerWithBlend(false, 1.0, nullptr,
+                                            mozilla::gfx::Matrix(), IntRect(),
+                                            false, BlendMode());
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+  aCtx->GetDrawTarget()->PopLayer();
+}
+
 mozilla::gfx::CompositionOp nsDisplayBlendMode::BlendMode() {
   return nsCSSRendering::GetGFXBlendMode(mBlendMode);
 }
@@ -6243,6 +6305,14 @@
                                        GetActiveScrolledRoot());
 }
 
+void nsDisplayBlendContainer::Paint(nsDisplayListBuilder* aBuilder,
+                                    gfxContext* aCtx) {
+  aCtx->GetDrawTarget()->PushLayer(false, 1.0, nullptr, mozilla::gfx::Matrix());
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+  aCtx->GetDrawTarget()->PopLayer();
+}
+
 bool nsDisplayBlendContainer::CreateWebRenderCommands(
     mozilla::wr::DisplayListBuilder& aBuilder,
     mozilla::wr::IpcResourceUpdateQueue& aResources,
@@ -7462,14 +7532,7 @@
 }
 
 bool nsDisplayTransform::ShouldFlattenAway(nsDisplayListBuilder* aBuilder) {
-  if (gfxVars::UseWebRender() ||
-      !StaticPrefs::layout_display_list_flatten_transform()) {
-    return false;
-  }
-
-  MOZ_ASSERT(!mShouldFlatten);
-  mShouldFlatten = GetTransform().Is2D();
-  return mShouldFlatten;
+  return false;
 }
 
 /* Returns the delta specified by the transform-origin property.
@@ -8186,6 +8249,163 @@
   return container.forget();
 }
 
+void nsDisplayTransform::Collect3DTransformLeaves(
+    nsTArray<nsDisplayTransform*>& aLeaves) {
+  if (!IsParticipating3DContext() || IsLeafOf3DContext()) {
+    aLeaves.AppendElement(this);
+    return;
+  }
+
+  for (nsDisplayItem* item : mChildren) {
+    if (item->GetType() == DisplayItemType::TYPE_PERSPECTIVE) {
+      auto* perspective = static_cast<nsDisplayPerspective*>(item);
+      if (!perspective->GetChildren()->GetTop()) {
+        continue;
+      }
+      item = perspective->GetChildren()->GetTop();
+    }
+    MOZ_RELEASE_ASSERT(item->GetType() == DisplayItemType::TYPE_TRANSFORM);
+    static_cast<nsDisplayTransform*>(item)->Collect3DTransformLeaves(aLeaves);
+  }
+}
+
+static RefPtr<gfx::Path> BuildPathFromPolygon(const RefPtr<DrawTarget>& aDT,
+                                              const gfx::Polygon& aPolygon) {
+  MOZ_ASSERT(!aPolygon.IsEmpty());
+
+  RefPtr<PathBuilder> pathBuilder = aDT->CreatePathBuilder();
+  const nsTArray<Point4D>& points = aPolygon.GetPoints();
+
+  pathBuilder->MoveTo(points[0].As2DPoint());
+
+  for (size_t i = 1; i < points.Length(); ++i) {
+    pathBuilder->LineTo(points[i].As2DPoint());
+  }
+
+  pathBuilder->Close();
+  return pathBuilder->Finish();
+}
+
+void nsDisplayTransform::CollectSorted3DTransformLeaves(
+    nsDisplayListBuilder* aBuilder, nsTArray<TransformPolygon>& aLeaves) {
+  std::list<TransformPolygon> inputLayers;
+
+  nsTArray<nsDisplayTransform*> leaves;
+  Collect3DTransformLeaves(leaves);
+  for (nsDisplayTransform* item : leaves) {
+    auto bounds = LayoutDeviceRect::FromAppUnits(
+        item->mChildBounds, item->mFrame->PresContext()->AppUnitsPerDevPixel());
+    Matrix4x4 transform = item->GetAccumulatedPreserved3DTransform(aBuilder);
+
+    if (!IsFrameVisible(item->mFrame, transform)) {
+      continue;
+    }
+    gfx::Polygon polygon =
+        gfx::Polygon::FromRect(gfx::Rect(bounds.ToUnknownRect()));
+
+    polygon.TransformToScreenSpace(transform);
+
+    if (polygon.GetPoints().Length() >= 3) {
+      inputLayers.push_back(TransformPolygon(item, std::move(polygon)));
+    }
+  }
+
+  if (inputLayers.empty()) {
+    return;
+  }
+
+  BSPTree<nsDisplayTransform> tree(inputLayers);
+  nsTArray<TransformPolygon> orderedLayers(tree.GetDrawOrder());
+
+  for (TransformPolygon& polygon : orderedLayers) {
+    Matrix4x4 inverse =
+        polygon.data->GetAccumulatedPreserved3DTransform(aBuilder).Inverse();
+
+    MOZ_ASSERT(polygon.geometry);
+    polygon.geometry->TransformToLayerSpace(inverse);
+  }
+
+  aLeaves = std::move(orderedLayers);
+}
+
+void nsDisplayTransform::Paint(nsDisplayListBuilder* aBuilder,
+                               gfxContext* aCtx) {
+  Paint(aBuilder, aCtx, Nothing());
+}
+
+void nsDisplayTransform::Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx,
+                               const Maybe<gfx::Polygon>& aPolygon) {
+  if (IsParticipating3DContext() && !IsLeafOf3DContext()) {
+    MOZ_ASSERT(!aPolygon);
+    nsTArray<TransformPolygon> leaves;
+    CollectSorted3DTransformLeaves(aBuilder, leaves);
+    for (TransformPolygon& item : leaves) {
+      item.data->Paint(aBuilder, aCtx, item.geometry);
+    }
+    return;
+  }
+
+  gfxContextMatrixAutoSaveRestore saveMatrix(aCtx);
+  Matrix4x4 trans = GetAccumulatedPreserved3DTransform(aBuilder);
+  if (!IsFrameVisible(mFrame, trans)) {
+    return;
+  }
+
+  Matrix trans2d;
+  if (trans.CanDraw2D(&trans2d)) {
+    aCtx->Multiply(ThebesMatrix(trans2d));
+
+    if (aPolygon) {
+      RefPtr<gfx::Path> path =
+          BuildPathFromPolygon(aCtx->GetDrawTarget(), *aPolygon);
+      aCtx->GetDrawTarget()->PushClip(path);
+    }
+
+    GetChildren()->Paint(aBuilder, aCtx,
+                         mFrame->PresContext()->AppUnitsPerDevPixel());
+
+    if (aPolygon) {
+      aCtx->GetDrawTarget()->PopClip();
+    }
+    return;
+  }
+
+  // TODO: Implement 3d transform handling, including plane splitting and
+  // sorting. See BasicCompositor.
+  auto pixelBounds = LayoutDeviceRect::FromAppUnitsToOutside(
+      mChildBounds, mFrame->PresContext()->AppUnitsPerDevPixel());
+  RefPtr<DrawTarget> untransformedDT =
+      gfxPlatform::GetPlatform()->CreateOffscreenContentDrawTarget(
+          IntSize(pixelBounds.Width(), pixelBounds.Height()),
+          SurfaceFormat::B8G8R8A8, true);
+  if (!untransformedDT || !untransformedDT->IsValid()) {
+    return;
+  }
+  untransformedDT->SetTransform(
+      Matrix::Translation(-Point(pixelBounds.X(), pixelBounds.Y())));
+
+  RefPtr<gfxContext> groupTarget =
+      gfxContext::CreatePreservingTransformOrNull(untransformedDT);
+
+  if (aPolygon) {
+    RefPtr<gfx::Path> path =
+        BuildPathFromPolygon(aCtx->GetDrawTarget(), *aPolygon);
+    aCtx->GetDrawTarget()->PushClip(path);
+  }
+
+  GetChildren()->Paint(aBuilder, groupTarget,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+
+  if (aPolygon) {
+    aCtx->GetDrawTarget()->PopClip();
+  }
+
+  RefPtr<SourceSurface> untransformedSurf = untransformedDT->Snapshot();
+
+  trans.PreTranslate(pixelBounds.X(), pixelBounds.Y(), 0);
+  aCtx->GetDrawTarget()->Draw3DTransformedSurface(untransformedSurf, trans);
+}
+
 bool nsDisplayTransform::MayBeAnimated(nsDisplayListBuilder* aBuilder,
                                        bool aEnforceMinimumSize) const {
   // If EffectCompositor::HasAnimationsForCompositor() is true then we can
@@ -8728,6 +8948,14 @@
   return container.forget();
 }
 
+void nsDisplayPerspective::Paint(nsDisplayListBuilder* aBuilder,
+                                 gfxContext* aCtx) {
+  // Just directly recurse into children, since we'll include the persepctive
+  // value in any nsDisplayTransform children.
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+}
+
 LayerState nsDisplayPerspective::GetLayerState(
     nsDisplayListBuilder* aBuilder, LayerManager* aManager,
     const ContainerLayerParameters& aParameters) {
@@ -9487,6 +9715,17 @@
   nsDisplayMasksAndClipPathsGeometry::UpdateDrawResult(this, imgParams.result);
 }
 
+void nsDisplayMasksAndClipPaths::Paint(nsDisplayListBuilder* aBuilder,
+                                       gfxContext* aCtx) {
+  if (!IsValidMask()) {
+    return;
+  }
+  PaintWithContentsPaintCallback(aBuilder, aCtx, [&] {
+    GetChildren()->Paint(aBuilder, aCtx,
+                         mFrame->PresContext()->AppUnitsPerDevPixel());
+  });
+}
+
 static Maybe<wr::WrClipId> CreateSimpleClipRegion(
     const nsDisplayMasksAndClipPaths& aDisplayItem,
     wr::DisplayListBuilder& aBuilder) {
@@ -9756,6 +9995,14 @@
   return container.forget();
 }
 
+void nsDisplayBackdropRootContainer::Paint(nsDisplayListBuilder* aBuilder,
+                                           gfxContext* aCtx) {
+  aCtx->GetDrawTarget()->PushLayer(false, 1.0, nullptr, mozilla::gfx::Matrix());
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+  aCtx->GetDrawTarget()->PopLayer();
+}
+
 LayerState nsDisplayBackdropRootContainer::GetLayerState(
     nsDisplayListBuilder* aBuilder, LayerManager* aManager,
     const ContainerLayerParameters& aParameters) {
@@ -9832,6 +10079,13 @@
   return true;
 }
 
+void nsDisplayBackdropFilters::Paint(nsDisplayListBuilder* aBuilder,
+                                     gfxContext* aCtx) {
+  // TODO: Implement backdrop filters
+  GetChildren()->Paint(aBuilder, aCtx,
+                       mFrame->PresContext()->AppUnitsPerDevPixel());
+}
+
 /* static */
 nsDisplayFilters::nsDisplayFilters(nsDisplayListBuilder* aBuilder,
                                    nsIFrame* aFrame, nsDisplayList* aList)
@@ -9878,6 +10132,13 @@
   return LayerState::LAYER_SVG_EFFECTS;
 }
 
+void nsDisplayFilters::Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx) {
+  PaintWithContentsPaintCallback(aBuilder, aCtx, [&](gfxContext* aContext) {
+    GetChildren()->Paint(aBuilder, aContext,
+                         mFrame->PresContext()->AppUnitsPerDevPixel());
+  });
+}
+
 bool nsDisplayFilters::ComputeVisibility(nsDisplayListBuilder* aBuilder,
                                          nsRegion* aVisibleRegion) {
   nsPoint offset = ToReferenceFrame();