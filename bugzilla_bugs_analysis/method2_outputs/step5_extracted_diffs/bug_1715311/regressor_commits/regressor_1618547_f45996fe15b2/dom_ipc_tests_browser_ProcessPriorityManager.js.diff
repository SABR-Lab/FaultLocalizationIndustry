# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/tests/browser_ProcessPriorityManager.js
# Commit: f45996fe15b2
# Full Hash: f45996fe15b23696c88f85a6b154146d3717fc58
# Author: Andrew McCreight <continuation@gmail.com>
# Date: 2021-05-06 03:49:11
# Regressor Bug: 1618547
# File Overlap Count: 1
# Description:
#   Bug 1618547 - Support Fission in the process priority manager. r=kmag,gsvelto
#   
#   With Fission, there can be multiple BrowserParents in a single tab, so
#   this patch moves the tracking of active tabs onto the top BrowsingContext
#   in a tab. If the priority of a top BC is changed, then the activity
# ==============================================================================

diff -r 0e0f90271853 -r f45996fe15b2 dom/ipc/tests/browser_ProcessPriorityManager.js
--- a/dom/ipc/tests/browser_ProcessPriorityManager.js	Wed May 05 20:07:07 2021 +0000
+++ b/dom/ipc/tests/browser_ProcessPriorityManager.js	Wed May 05 20:29:14 2021 +0000
@@ -15,6 +15,11 @@
 // change before we assume that it's just not happening.
 const WAIT_FOR_CHANGE_TIME_MS = 2000;
 
+// A convenience function for getting the child ID from a browsing context.
+function browsingContextChildID(bc) {
+  return bc.currentWindowGlobal?.domProcess.childID;
+}
+
 /**
  * This class is responsible for watching process priority changes, and
  * mapping them to tabs in a single window.
@@ -39,12 +44,14 @@
         "with a single tab to start."
     );
 
-    this.priorityMap = new WeakMap();
-    this.priorityMap.set(
-      this.tabbrowser.selectedBrowser,
-      PROCESS_PRIORITY_FOREGROUND
-    );
-    this.noChangeBrowsers = new WeakMap();
+    // This maps from childIDs to process priorities.
+    this.priorityMap = new Map();
+
+    // The keys in this map are childIDs we're not expecting to change.
+    // Each value is either null (if no change has been seen) or the
+    // priority that the process changed to.
+    this.noChangeChildIDs = new Map();
+
     Services.obs.addObserver(this, PRIORITY_SET_TOPIC);
   }
 
@@ -55,16 +62,15 @@
    */
   destroy() {
     Services.obs.removeObserver(this, PRIORITY_SET_TOPIC);
-    this.window = null;
   }
 
   /**
-   * Returns a Promise that resolves when a particular <browser>
-   * has its content process reach a particular priority. Will
-   * eventually time out if that priority is never reached.
+   * This returns a Promise that resolves when the process with
+   * the given childID reaches the given priority.
+   * This will eventually time out if that priority is never reached.
    *
-   * @param browser (<browser>)
-   *   The <browser> that we expect to change priority.
+   * @param childID
+   *   The childID of the process to wait on.
    * @param expectedPriority (String)
    *   One of the PROCESS_PRIORITY_ constants defined at the
    *   top of this file.
@@ -72,74 +78,91 @@
    * @resolves undefined
    *   Once the browser reaches the expected priority.
    */
-  async waitForPriorityChange(browser, expectedPriority) {
-    return TestUtils.waitForCondition(() => {
-      let currentPriority = this.priorityMap.get(browser);
+  async waitForPriorityChange(childID, expectedPriority) {
+    await TestUtils.waitForCondition(() => {
+      let currentPriority = this.priorityMap.get(childID);
       if (currentPriority == expectedPriority) {
         Assert.ok(
           true,
-          `Browser at ${browser.currentURI.spec} reached expected ` +
+          `Process with child ID ${childID} reached expected ` +
             `priority: ${currentPriority}`
         );
         return true;
       }
       return false;
-    }, `Waiting for browser at ${browser.currentURI.spec} to reach priority ` + expectedPriority);
+    }, `Waiting for process with child ID ${childID} to reach priority ${expectedPriority}`);
   }
 
   /**
    * Returns a Promise that resolves after a duration of
-   * WAIT_FOR_CHANGE_TIME_MS. During that time, if the passed browser
-   * changes priority, a test failure will be registered.
+   * WAIT_FOR_CHANGE_TIME_MS. During that time, if the process
+   * with the passed in child ID changes priority, a test
+   * failure will be registered.
    *
-   * @param browser (<browser>)
-   *   The <browser> that we expect to change priority.
+   * @param childID
+   *   The childID of the process that we expect to not change priority.
    * @return Promise
    * @resolves undefined
    *   Once the WAIT_FOR_CHANGE_TIME_MS duration has passed.
    */
-  async ensureNoPriorityChange(browser) {
-    this.noChangeBrowsers.set(browser, null);
+  async ensureNoPriorityChange(childID) {
+    this.noChangeChildIDs.set(childID, null);
     // eslint-disable-next-line mozilla/no-arbitrary-setTimeout
     await new Promise(resolve => setTimeout(resolve, WAIT_FOR_CHANGE_TIME_MS));
-    let priority = this.noChangeBrowsers.get(browser);
+    let priority = this.noChangeChildIDs.get(childID);
     Assert.equal(
       priority,
       null,
-      `Should have seen no process priority change for a browser at ${browser.currentURI.spec}`
+      `Should have seen no process priority change for child ID ${childID}`
     );
-    this.noChangeBrowsers.delete(browser);
+    this.noChangeChildIDs.delete(childID);
   }
 
   /**
-   * Makes sure that a particular foreground browser has been
-   * registered in the priority map. This is needed because browsers are
-   * only registered when their priorities change - and if a browser's
-   * priority never changes during a test, then they wouldn't be registered.
-   *
-   * The passed browser must be a foreground browser, since it's assumed that
-   * the associated content process is running with foreground priority.
+   * This returns a Promise that resolves when all of the processes
+   * of the browsing contexts in the browsing context tree
+   * of a particular <browser> have reached a particular priority.
+   * This will eventually time out if that priority is never reached.
    *
-   * @param browser (browser)
-   *   A _foreground_ browser.
+   * @param browser (<browser>)
+   *   The <browser> to get the BC tree from.
+   * @param expectedPriority (String)
+   *   One of the PROCESS_PRIORITY_ constants defined at the
+   *   top of this file.
+   * @return Promise
+   * @resolves undefined
+   *   Once the browser reaches the expected priority.
    */
-  ensureForegroundRegistered(browser) {
-    if (!this.priorityMap.has(browser)) {
-      this.priorityMap.set(browser, PROCESS_PRIORITY_FOREGROUND);
+  async waitForBrowserTreePriority(browser, expectedPriority) {
+    let childIDs = new Set(
+      browser.browsingContext
+        .getAllBrowsingContextsInSubtree()
+        .map(browsingContextChildID)
+    );
+    let promises = [];
+    for (let childID of childIDs) {
+      let currentPriority = this.priorityMap.get(childID);
+
+      promises.push(
+        currentPriority == expectedPriority
+          ? this.ensureNoPriorityChange(childID)
+          : this.waitForPriorityChange(childID, expectedPriority)
+      );
     }
+
+    await Promise.all(promises);
   }
 
   /**
-   * Synchronously returns the priority of a particular browser's
-   * content process.
+   * Synchronously returns the priority of a particular child ID.
    *
-   * @param browser (browser)
-   *   The browser to get the content process priority for.
+   * @param childID
+   *   The childID to get the content process priority for.
    * @return String
-   *   The priority that the browser's content process is at.
+   *   The priority of the child ID's process.
    */
-  currentPriority(browser) {
-    return this.priorityMap.get(browser);
+  currentPriority(childID) {
+    return this.priorityMap.get(childID);
   }
 
   /**
@@ -175,17 +198,10 @@
     }
 
     let { childID, priority } = this.parsePPMData(data);
-    for (let browser of this.tabbrowser.browsers) {
-      if (browser.frameLoader.childID == childID) {
-        info(
-          `Browser at: ${browser.currentURI.spec} transitioning to ${priority}`
-        );
-        if (this.noChangeBrowsers.has(browser)) {
-          this.noChangeBrowsers.set(browser, priority);
-        }
-        this.priorityMap.set(browser, priority);
-      }
+    if (this.noChangeChildIDs.has(childID)) {
+      this.noChangeChildIDs.set(childID, priority);
     }
+    this.priorityMap.set(childID, priority);
   }
 }
 
@@ -255,32 +271,14 @@
     "Tabs should be running in separate processes."
   );
 
-  gTabPriorityWatcher.ensureForegroundRegistered(fromBrowser);
-
-  let fromPromise;
-  if (
-    gTabPriorityWatcher.currentPriority(fromBrowser) == fromTabExpectedPriority
-  ) {
-    fromPromise = gTabPriorityWatcher.ensureNoPriorityChange(fromBrowser);
-  } else {
-    fromPromise = gTabPriorityWatcher.waitForPriorityChange(
-      fromBrowser,
-      fromTabExpectedPriority
-    );
-  }
-
-  let toPromise;
-  if (
-    gTabPriorityWatcher.currentPriority(toBrowser) ==
+  let fromPromise = gTabPriorityWatcher.waitForBrowserTreePriority(
+    fromBrowser,
+    fromTabExpectedPriority
+  );
+  let toPromise = gTabPriorityWatcher.waitForBrowserTreePriority(
+    toBrowser,
     PROCESS_PRIORITY_FOREGROUND
-  ) {
-    toPromise = gTabPriorityWatcher.ensureNoPriorityChange(toBrowser);
-  } else {
-    toPromise = gTabPriorityWatcher.waitForPriorityChange(
-      toBrowser,
-      PROCESS_PRIORITY_FOREGROUND
-    );
-  }
+  );
 
   await BrowserTestUtils.switchTab(gBrowser, toTab);
   await Promise.all([fromPromise, toPromise]);
@@ -294,20 +292,185 @@
 add_task(async function test_normal_background_tab() {
   let originalTab = gBrowser.selectedTab;
 
-  await BrowserTestUtils.withNewTab("http://example.com", async browser => {
-    let tab = gBrowser.getTabForBrowser(browser);
-    await assertPriorityChangeOnBackground({
-      fromTab: tab,
-      toTab: originalTab,
-      fromTabExpectedPriority: PROCESS_PRIORITY_BACKGROUND,
-    });
+  await BrowserTestUtils.withNewTab(
+    "http://example.com/browser/dom/ipc/tests/file_cross_frame.html",
+    async browser => {
+      let tab = gBrowser.getTabForBrowser(browser);
+      await assertPriorityChangeOnBackground({
+        fromTab: tab,
+        toTab: originalTab,
+        fromTabExpectedPriority: PROCESS_PRIORITY_BACKGROUND,
+      });
+
+      await assertPriorityChangeOnBackground({
+        fromTab: originalTab,
+        toTab: tab,
+        fromTabExpectedPriority: PROCESS_PRIORITY_BACKGROUND,
+      });
+    }
+  );
+});
+
+/**
+ * If an iframe in a foreground tab is navigated to a new page for
+ * a different site, then the process of the new iframe page should
+ * have priority PROCESS_PRIORITY_FOREGROUND. Additionally, if Fission
+ * is enabled, then the old iframe page's process's priority should be
+ * lowered to PROCESS_PRIORITY_BACKGROUND.
+ */
+add_task(async function test_iframe_navigate() {
+  // The URI we're going to navigate the iframe to.
+  let iframeURI2 =
+    "http://mochi.test:8888/browser/dom/ipc/tests/file_dummy.html";
+
+  // Load this as a top level tab so that when we later load it as an iframe we
+  // won't be creating a new process, so that we're testing the "load a new page"
+  // part of prioritization and not the "initial process load" part.
+  let newIFrameTab = await BrowserTestUtils.openNewForegroundTab(
+    gBrowser,
+    iframeURI2
+  );
+  let newIFrameTabChildID = browsingContextChildID(
+    gBrowser.selectedBrowser.browsingContext
+  );
+
+  Assert.equal(
+    gTabPriorityWatcher.currentPriority(newIFrameTabChildID),
+    PROCESS_PRIORITY_FOREGROUND,
+    "Loading a new tab should make it prioritized"
+  );
+
+  await BrowserTestUtils.withNewTab(
+    "http://example.com/browser/dom/ipc/tests/file_cross_frame.html",
+    async browser => {
+      Assert.equal(
+        gTabPriorityWatcher.currentPriority(newIFrameTabChildID),
+        PROCESS_PRIORITY_BACKGROUND,
+        "Switching to a new tab should deprioritize the old one"
+      );
+
+      let iframe = browser.browsingContext.children[0];
+      let iframeChildID1 = browsingContextChildID(iframe);
+
+      // Do a cross-origin navigation in the iframe in the foreground tab.
+      let loaded = BrowserTestUtils.browserLoaded(browser, true, iframeURI2);
+      await SpecialPowers.spawn(iframe, [iframeURI2], async function(
+        _iframeURI2
+      ) {
+        content.location = _iframeURI2;
+      });
+      await loaded;
+
+      let iframeChildID2 = browsingContextChildID(iframe);
+      let iframePriority1 = gTabPriorityWatcher.currentPriority(iframeChildID1);
+      let iframePriority2 = gTabPriorityWatcher.currentPriority(iframeChildID2);
 
-    await assertPriorityChangeOnBackground({
-      fromTab: originalTab,
-      toTab: tab,
-      fromTabExpectedPriority: PROCESS_PRIORITY_BACKGROUND,
-    });
-  });
+      if (SpecialPowers.useRemoteSubframes) {
+        Assert.equal(
+          newIFrameTabChildID,
+          iframeChildID2,
+          "The same site should get loaded into the same process"
+        );
+        Assert.notEqual(
+          iframeChildID1,
+          iframeChildID2,
+          "Navigation should have switched processes"
+        );
+        Assert.equal(
+          iframePriority1,
+          PROCESS_PRIORITY_BACKGROUND,
+          "The old iframe process should have been deprioritized"
+        );
+      } else {
+        Assert.equal(
+          iframeChildID1,
+          iframeChildID2,
+          "Navigation should not have switched processes"
+        );
+      }
+
+      Assert.equal(
+        iframePriority2,
+        PROCESS_PRIORITY_FOREGROUND,
+        "The new iframe process should be prioritized"
+      );
+    }
+  );
+
+  await BrowserTestUtils.removeTab(newIFrameTab);
+});
+
+/**
+ * Test that a cross-group navigation properly preserves the process priority.
+ * The goal of this test is to check that the code related to mPriorityActive in
+ * CanonicalBrowsingContext::ReplacedBy works correctly, but in practice the
+ * prioritization code in SetRenderLayers will also make this test pass, though
+ * that prioritization happens slightly later.
+ */
+add_task(async function test_cross_group_navigate() {
+  // This page is same-site with the page we're going to cross-group navigate to.
+  let coopPage =
+    "https://example.com/browser/dom/tests/browser/file_coop_coep.html";
+
+  // Load it as a top level tab so that we don't accidentally get the initial
+  // load prioritization.
+  let backgroundTab = await BrowserTestUtils.openNewForegroundTab(
+    gBrowser,
+    coopPage
+  );
+  let backgroundTabChildID = browsingContextChildID(
+    gBrowser.selectedBrowser.browsingContext
+  );
+
+  Assert.equal(
+    gTabPriorityWatcher.currentPriority(backgroundTabChildID),
+    PROCESS_PRIORITY_FOREGROUND,
+    "Loading a new tab should make it prioritized"
+  );
+
+  await BrowserTestUtils.withNewTab(
+    "http://example.org/browser/dom/ipc/tests/file_cross_frame.html",
+    async browser => {
+      Assert.equal(
+        gTabPriorityWatcher.currentPriority(backgroundTabChildID),
+        PROCESS_PRIORITY_BACKGROUND,
+        "Switching to a new tab should deprioritize the old one"
+      );
+
+      let dotOrgChildID = browsingContextChildID(browser.browsingContext);
+
+      // Do a cross-group navigation.
+      BrowserTestUtils.loadURI(browser, coopPage);
+      await BrowserTestUtils.browserLoaded(browser);
+
+      let coopChildID = browsingContextChildID(browser.browsingContext);
+      let coopPriority = gTabPriorityWatcher.currentPriority(coopChildID);
+      let dotOrgPriority = gTabPriorityWatcher.currentPriority(dotOrgChildID);
+
+      Assert.equal(
+        backgroundTabChildID,
+        coopChildID,
+        "The same site should get loaded into the same process"
+      );
+      Assert.notEqual(
+        dotOrgChildID,
+        coopChildID,
+        "Navigation should have switched processes"
+      );
+      Assert.equal(
+        dotOrgPriority,
+        PROCESS_PRIORITY_BACKGROUND,
+        "The old page process should have been deprioritized"
+      );
+      Assert.equal(
+        coopPriority,
+        PROCESS_PRIORITY_FOREGROUND,
+        "The new page process should be prioritized"
+      );
+    }
+  );
+
+  await BrowserTestUtils.removeTab(backgroundTab);
 });
 
 /**