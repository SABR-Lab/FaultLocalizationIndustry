# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandVsyncSource.cpp
# Commit: 3c74d415fafd
# Full Hash: 3c74d415fafd4bff5576ed0a2256c1a0232b5937
# Author: Robert Mader <robert.mader@posteo.de>
# Date: 2021-06-11 09:42:05
# Regressor Bug: 1711244
# File Overlap Count: 2
# Description:
#   Bug 1711244 - Integrate NativeLayerWayland with WaylandVsyncSource, r=stransky,gfx-reviewers,jrmuizel
#   
#   Make the vsync source request frame callbacks from opaque native
#   layers. This is necessary as opaque layers may occlude the
#   MozContainer surface, which is normally used for frame callbacks.
# ==============================================================================

diff -r bc5ca21bf534 -r 3c74d415fafd widget/gtk/WaylandVsyncSource.cpp
--- a/widget/gtk/WaylandVsyncSource.cpp	Thu Jun 10 14:58:53 2021 +0000
+++ b/widget/gtk/WaylandVsyncSource.cpp	Thu Jun 10 15:12:54 2021 +0000
@@ -17,145 +17,190 @@
 
 namespace mozilla {
 
-static void WaylandVsyncSourceCallbackHandler(void* data,
-                                              struct wl_callback* callback,
-                                              uint32_t time) {
+static void WaylandVsyncSourceCallbackHandler(void* aData,
+                                              struct wl_callback* aCallback,
+                                              uint32_t aTime) {
   WaylandVsyncSource::WaylandDisplay* context =
-      (WaylandVsyncSource::WaylandDisplay*)data;
-  wl_callback_destroy(callback);
-  context->FrameCallback(time);
+      (WaylandVsyncSource::WaylandDisplay*)aData;
+  wl_callback_destroy(aCallback);
+  context->FrameCallback(aTime);
+}
+
+static void WaylandVsyncSourceCallbackHandler(void* aData, uint32_t aTime) {
+  WaylandVsyncSource::WaylandDisplay* context =
+      (WaylandVsyncSource::WaylandDisplay*)aData;
+  context->FrameCallback(aTime);
 }
 
 static const struct wl_callback_listener WaylandVsyncSourceCallbackListener = {
     WaylandVsyncSourceCallbackHandler};
 
-WaylandVsyncSource::WaylandDisplay::WaylandDisplay(MozContainer* container)
-    : mEnabledLock("WaylandVsyncEnabledLock"),
+WaylandVsyncSource::WaylandDisplay::WaylandDisplay()
+    : mMutex("WaylandVsyncSource"),
       mIsShutdown(false),
       mVsyncEnabled(false),
       mMonitorEnabled(false),
-      mCallback(nullptr),
-      mContainer(container),
+      mCallbackRequested(false),
+      mDisplay(WaylandDisplayGetWLDisplay()),
+      mContainer(nullptr),
+      mVsyncRate(TimeDuration::FromMilliseconds(1000.0 / 60.0)),
       mLastVsyncTimeStamp(TimeStamp::Now()) {
   MOZ_ASSERT(NS_IsMainThread());
-
-  // We store the display here so all the frame callbacks won't have to look it
-  // up all the time.
-  mDisplay = WaylandDisplayGetWLDisplay();
-
-  mVsyncRate = TimeDuration::FromMilliseconds(1000.0 / 60.0);
 }
 
-void WaylandVsyncSource::WaylandDisplay::ClearFrameCallback() {
-  if (mCallback) {
-    wl_callback_destroy(mCallback);
-    mCallback = nullptr;
+void WaylandVsyncSource::WaylandDisplay::MaybeUpdateSource(
+    MozContainer* aContainer) {
+  MutexAutoLock lock(mMutex);
+
+  if (aContainer == mContainer) {
+    return;
+  }
+
+  mNativeLayerRoot = nullptr;
+  mContainer = aContainer;
+
+  if (mMonitorEnabled) {
+    mCallbackRequested = false;
+    Refresh();
+  }
+}
+
+void WaylandVsyncSource::WaylandDisplay::MaybeUpdateSource(
+    const RefPtr<NativeLayerRootWayland>& aNativeLayerRoot) {
+  MutexAutoLock lock(mMutex);
+
+  if (aNativeLayerRoot == mNativeLayerRoot) {
+    return;
+  }
+
+  mNativeLayerRoot = aNativeLayerRoot;
+  mContainer = nullptr;
+
+  if (mMonitorEnabled) {
+    mCallbackRequested = false;
+    Refresh();
   }
 }
 
 void WaylandVsyncSource::WaylandDisplay::Refresh() {
-  TimeStamp outputTimestamp;
-  {
-    MutexAutoLock lock(mEnabledLock);
-    if (!mMonitorEnabled || !mVsyncEnabled || mCallback) {
-      // We don't need to do anything because:
-      // * We are unwanted by our widget or monitor, or
-      // * The last frame callback hasn't yet run to see that it had been shut
-      //   down, so we can reuse it after having set mVsyncEnabled to true.
-      return;
-    }
+  mMutex.AssertCurrentThreadOwns();
 
+  if (!(mContainer || mNativeLayerRoot) || !mMonitorEnabled || !mVsyncEnabled ||
+      mCallbackRequested) {
+    // We don't need to do anything because:
+    // * We are unwanted by our widget or monitor, or
+    // * The last frame callback hasn't yet run to see that it had been shut
+    //   down, so we can reuse it after having set mVsyncEnabled to true.
+    return;
+  }
+
+  if (mContainer) {
     struct wl_surface* surface = moz_container_wayland_surface_lock(mContainer);
     if (!surface) {
       // The surface hasn't been created yet. Try again when the surface is
       // ready.
       RefPtr<WaylandVsyncSource::WaylandDisplay> self(this);
       moz_container_wayland_add_initial_draw_callback(
-          mContainer, [self]() -> void { self->Refresh(); });
+          mContainer, [self]() -> void {
+            MutexAutoLock lock(self->mMutex);
+            self->Refresh();
+          });
       return;
     }
     moz_container_wayland_surface_unlock(mContainer, &surface);
+  }
 
-    // Vsync is enabled, but we don't have a callback configured. Set one up so
-    // we can get to work.
-    SetupFrameCallback();
-    mLastVsyncTimeStamp = TimeStamp::Now();
-    outputTimestamp = mLastVsyncTimeStamp + GetVsyncRate();
+  // Vsync is enabled, but we don't have a callback configured. Set one up so
+  // we can get to work.
+  SetupFrameCallback();
+  mLastVsyncTimeStamp = TimeStamp::Now();
+  TimeStamp outputTimestamp = mLastVsyncTimeStamp + GetVsyncRate();
+
+  {
+    MutexAutoUnlock unlock(mMutex);
+    NotifyVsync(mLastVsyncTimeStamp, outputTimestamp);
   }
-  NotifyVsync(mLastVsyncTimeStamp, outputTimestamp);
 }
 
 void WaylandVsyncSource::WaylandDisplay::EnableMonitor() {
-  {
-    MutexAutoLock lock(mEnabledLock);
-    if (mMonitorEnabled) {
-      return;
-    }
-    mMonitorEnabled = true;
+  MutexAutoLock lock(mMutex);
+  if (mMonitorEnabled) {
+    return;
   }
+  mMonitorEnabled = true;
   Refresh();
 }
 
 void WaylandVsyncSource::WaylandDisplay::DisableMonitor() {
-  MutexAutoLock lock(mEnabledLock);
+  MutexAutoLock lock(mMutex);
   if (!mMonitorEnabled) {
     return;
   }
   mMonitorEnabled = false;
-  ClearFrameCallback();
+  mCallbackRequested = false;
 }
 
 void WaylandVsyncSource::WaylandDisplay::SetupFrameCallback() {
-  MOZ_ASSERT(mCallback == nullptr);
-  struct wl_surface* surface = moz_container_wayland_surface_lock(mContainer);
-  if (!surface) {
-    // We don't have a surface, either due to being called before it was made
-    // available in the mozcontainer, or after it was destroyed. We're all done
-    // regardless.
-    ClearFrameCallback();
-    return;
+  mMutex.AssertCurrentThreadOwns();
+  MOZ_ASSERT(!mCallbackRequested);
+
+  if (mNativeLayerRoot) {
+    mNativeLayerRoot->RequestFrameCallback(&WaylandVsyncSourceCallbackHandler,
+                                           this);
+  } else {
+    struct wl_surface* surface = moz_container_wayland_surface_lock(mContainer);
+    if (!surface) {
+      // We don't have a surface, either due to being called before it was made
+      // available in the mozcontainer, or after it was destroyed. We're all
+      // done regardless.
+      mCallbackRequested = false;
+      return;
+    }
+
+    wl_callback* callback = wl_surface_frame(surface);
+    wl_callback_add_listener(callback, &WaylandVsyncSourceCallbackListener,
+                             this);
+    wl_surface_commit(surface);
+    wl_display_flush(mDisplay);
+    moz_container_wayland_surface_unlock(mContainer, &surface);
   }
 
-  mCallback = wl_surface_frame(surface);
-  wl_callback_add_listener(mCallback, &WaylandVsyncSourceCallbackListener,
-                           this);
-  wl_surface_commit(surface);
-  wl_display_flush(mDisplay);
-  moz_container_wayland_surface_unlock(mContainer, &surface);
+  mCallbackRequested = true;
 }
 
 void WaylandVsyncSource::WaylandDisplay::FrameCallback(uint32_t timestampTime) {
-  TimeStamp outputTimestamp;
-  {
-    MutexAutoLock lock(mEnabledLock);
-    mCallback = nullptr;
+  MutexAutoLock lock(mMutex);
+  mCallbackRequested = false;
 
-    if (!mVsyncEnabled || !mMonitorEnabled) {
-      // We are unwanted by either our creator or our consumer, so we just stop
-      // here without setting up a new frame callback.
-      return;
-    }
+  if (!mVsyncEnabled || !mMonitorEnabled) {
+    // We are unwanted by either our creator or our consumer, so we just stop
+    // here without setting up a new frame callback.
+    return;
+  }
 
-    // Configure our next frame callback.
-    SetupFrameCallback();
+  // Configure our next frame callback.
+  SetupFrameCallback();
 
-    int64_t tick =
-        BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
-    TimeStamp callbackTimeStamp = TimeStamp::FromSystemTime(tick);
-    double duration = (TimeStamp::Now() - callbackTimeStamp).ToMilliseconds();
+  int64_t tick =
+      BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
+  TimeStamp callbackTimeStamp = TimeStamp::FromSystemTime(tick);
+  double duration = (TimeStamp::Now() - callbackTimeStamp).ToMilliseconds();
 
-    TimeStamp vsyncTimestamp;
-    if (duration < 50 && duration > -50) {
-      vsyncTimestamp = callbackTimeStamp;
-    } else {
-      vsyncTimestamp = TimeStamp::Now();
-    }
+  TimeStamp vsyncTimestamp;
+  if (duration < 50 && duration > -50) {
+    vsyncTimestamp = callbackTimeStamp;
+  } else {
+    vsyncTimestamp = TimeStamp::Now();
+  }
 
-    CalculateVsyncRate(vsyncTimestamp);
-    mLastVsyncTimeStamp = vsyncTimestamp;
-    outputTimestamp = vsyncTimestamp + GetVsyncRate();
+  CalculateVsyncRate(vsyncTimestamp);
+  mLastVsyncTimeStamp = vsyncTimestamp;
+  TimeStamp outputTimestamp = vsyncTimestamp + GetVsyncRate();
+
+  {
+    MutexAutoUnlock unlock(mMutex);
+    NotifyVsync(mLastVsyncTimeStamp, outputTimestamp);
   }
-  NotifyVsync(mLastVsyncTimeStamp, outputTimestamp);
 }
 
 TimeDuration WaylandVsyncSource::WaylandDisplay::GetVsyncRate() {
@@ -179,33 +224,31 @@
 
 void WaylandVsyncSource::WaylandDisplay::EnableVsync() {
   MOZ_ASSERT(NS_IsMainThread());
-  {
-    MutexAutoLock lock(mEnabledLock);
-    if (mVsyncEnabled || mIsShutdown) {
-      return;
-    }
-    mVsyncEnabled = true;
+  MutexAutoLock lock(mMutex);
+  if (mVsyncEnabled || mIsShutdown) {
+    return;
   }
+  mVsyncEnabled = true;
   Refresh();
 }
 
 void WaylandVsyncSource::WaylandDisplay::DisableVsync() {
-  MutexAutoLock lock(mEnabledLock);
+  MutexAutoLock lock(mMutex);
   mVsyncEnabled = false;
-  ClearFrameCallback();
+  mCallbackRequested = false;
 }
 
 bool WaylandVsyncSource::WaylandDisplay::IsVsyncEnabled() {
-  MutexAutoLock lock(mEnabledLock);
+  MutexAutoLock lock(mMutex);
   return mVsyncEnabled;
 }
 
 void WaylandVsyncSource::WaylandDisplay::Shutdown() {
   MOZ_ASSERT(NS_IsMainThread());
-  MutexAutoLock lock(mEnabledLock);
+  MutexAutoLock lock(mMutex);
   mIsShutdown = true;
   mVsyncEnabled = false;
-  ClearFrameCallback();
+  mCallbackRequested = false;
 }
 
 }  // namespace mozilla