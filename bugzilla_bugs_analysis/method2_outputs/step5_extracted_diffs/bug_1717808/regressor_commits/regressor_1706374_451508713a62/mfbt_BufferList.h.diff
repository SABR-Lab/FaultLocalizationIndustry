# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: mfbt/BufferList.h
# Commit: 451508713a62
# Full Hash: 451508713a625beaaa9fcbbf06c65ca312dc34fb
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2021-06-23 09:53:24
# Regressor Bug: 1706374
# File Overlap Count: 2
# Description:
#   Bug 1706374 - Part 13: Remove the event footer from an IPC::Message when deserializing, r=handyman,glandium
#   
#   This unfortunately requires a new method to be added to BufferList to
#   support truncating the buffer to a particular iterator.
#   
# ==============================================================================

diff -r 878722e87e62 -r 451508713a62 mfbt/BufferList.h
--- a/mfbt/BufferList.h	Tue Jun 22 18:17:23 2021 +0000
+++ b/mfbt/BufferList.h	Tue Jun 22 18:17:23 2021 +0000
@@ -10,6 +10,7 @@
 #include <algorithm>
 #include <cstdint>
 #include <cstring>
+#include <numeric>
 
 #include "mozilla/Assertions.h"
 #include "mozilla/Attributes.h"
@@ -370,6 +371,13 @@
     return aData;
   }
 
+  // Truncate this BufferList at the given iterator location, discarding all
+  // data after this point. After this call, all other iterators will be
+  // invalidated, and the passed-in iterator will be "Done".
+  //
+  // Returns the number of bytes discarded by this truncation.
+  size_t Truncate(IterImpl& aIter);
+
  private:
   explicit BufferList(AllocPolicy aAP)
       : AllocPolicy(aAP), mOwning(false), mSize(0), mStandardCapacity(0) {}
@@ -391,6 +399,16 @@
     return data;
   }
 
+  void AssertConsistentSize() const {
+#ifdef DEBUG
+    size_t realSize = 0;
+    for (const auto& segment : mSegments) {
+      realSize += segment.mSize;
+    }
+    MOZ_ASSERT(realSize == mSize, "cached size value is inconsistent!");
+#endif
+  }
+
   bool mOwning;
   Vector<Segment, 1, AllocPolicy> mSegments;
   size_t mSize;
@@ -634,6 +652,52 @@
   return result;
 }
 
+template <typename AllocPolicy>
+size_t BufferList<AllocPolicy>::Truncate(IterImpl& aIter) {
+  MOZ_ASSERT(aIter.IsIn(*this) || aIter.Done());
+  if (aIter.Done()) {
+    return 0;
+  }
+
+  size_t prevSize = mSize;
+
+  // Remove any segments after the iterator's current segment.
+  while (mSegments.length() > aIter.mSegment + 1) {
+    Segment& toFree = mSegments.back();
+    mSize -= toFree.mSize;
+    if (mOwning) {
+      this->free_(toFree.mData, toFree.mCapacity);
+    }
+    mSegments.popBack();
+  }
+
+  // The last segment is now aIter's current segment. Truncate or remove it.
+  Segment& seg = mSegments.back();
+  MOZ_ASSERT(aIter.mDataEnd == seg.End());
+  mSize -= aIter.RemainingInSegment();
+  seg.mSize -= aIter.RemainingInSegment();
+  if (!seg.mSize) {
+    if (mOwning) {
+      this->free_(seg.mData, seg.mCapacity);
+    }
+    mSegments.popBack();
+  }
+
+  // Correct `aIter` to point to the new end of the BufferList.
+  if (mSegments.empty()) {
+    MOZ_ASSERT(mSize == 0);
+    aIter.mSegment = 0;
+    aIter.mData = aIter.mDataEnd = nullptr;
+  } else {
+    aIter.mSegment = mSegments.length() - 1;
+    aIter.mData = aIter.mDataEnd = mSegments.back().End();
+  }
+  MOZ_ASSERT(aIter.Done());
+
+  AssertConsistentSize();
+  return prevSize - mSize;
+}
+
 }  // namespace mozilla
 
 #endif /* mozilla_BufferList_h */