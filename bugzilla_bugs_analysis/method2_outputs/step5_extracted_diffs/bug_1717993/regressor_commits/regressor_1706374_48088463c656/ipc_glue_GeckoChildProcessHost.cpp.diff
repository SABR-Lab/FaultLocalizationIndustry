# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: ipc/glue/GeckoChildProcessHost.cpp
# Commit: 48088463c656
# Full Hash: 48088463c6568b03a3e6a4ca6417dd9b650ced2a
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2021-06-22 21:29:07
# Regressor Bug: 1706374
# File Overlap Count: 2
# Description:
#   Bug 1706374 - Part 12a: Initialize NodeController when creating IO thread, r=handyman
#   
#   This also consumes the existing channel created when launching a process to
#   create the the conneciton required by NodeController for communicating between
#   processes. In part 12b, consumers of the broken APIs will be adjusted to use
# ==============================================================================

diff -r b09ae4c3a94b -r 48088463c656 ipc/glue/GeckoChildProcessHost.cpp
--- a/ipc/glue/GeckoChildProcessHost.cpp	Mon Jun 21 21:53:10 2021 +0000
+++ b/ipc/glue/GeckoChildProcessHost.cpp	Mon Jun 21 21:53:10 2021 +0000
@@ -46,6 +46,7 @@
 #include "mozilla/Telemetry.h"
 #include "mozilla/ipc/BrowserProcessSubThread.h"
 #include "mozilla/ipc/EnvironmentMap.h"
+#include "mozilla/ipc/NodeController.h"
 #include "mozilla/net/SocketProcessHost.h"
 #include "nsDirectoryService.h"
 #include "nsDirectoryServiceDefs.h"
@@ -836,9 +837,17 @@
   return WaitForProcessHandle();
 }
 
-void GeckoChildProcessHost::InitializeChannel() {
+void GeckoChildProcessHost::InitializeChannel(
+    const std::function<void(IPC::Channel*)>& aChannelReady) {
   CreateChannel();
 
+  aChannelReady(GetChannel());
+
+  if (mProcessType != GeckoProcessType_ForkServer) {
+    RefPtr<NodeController> node = NodeController::GetSingleton();
+    mInitialPort = node->InviteChildProcess(TakeChannel());
+  }
+
   MonitorAutoLock lock(mMonitor);
   mProcessState = CHANNEL_INITIALIZED;
   lock.Notify();
@@ -1792,9 +1801,13 @@
   // data races with the IO thread (where e.g. OnChannelConnected may run
   // concurrently). The pool currently needs access to the channel, which is not
   // great.
-  aHost->InitializeChannel();
-  IPC::Channel* channel = aHost->GetChannel();
-  if (!channel || !SetChannel(channel)) {
+  bool failed = false;
+  aHost->InitializeChannel([&](IPC::Channel* channel) {
+    if (!channel || !SetChannel(channel)) {
+      failed = true;
+    }
+  });
+  if (failed) {
     return ProcessLaunchPromise::CreateAndReject(LaunchError{}, __func__);
   }
   mChannelId = aHost->GetChannelId();