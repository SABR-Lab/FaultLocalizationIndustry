# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: ipc/glue/MessageChannel.h
# Commit: b09ae4c3a94b
# Full Hash: b09ae4c3a94b663279189c50172c1f403d499183
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2021-06-22 21:29:07
# Regressor Bug: 1706374
# File Overlap Count: 1
# Description:
#   Bug 1706374 - Part 11: Add NodeController component bridging IPC and Ports, r=handyman
#   
#   The NodeController and NodeChannel types act as the backbone connecting the
#   existing IPC logic and driving the ports routing code. Individual NodeChannel
#   objects wrap and respond to messages from IPC::Channel, and the NodeController
# ==============================================================================

diff -r 04422175004b -r b09ae4c3a94b ipc/glue/MessageChannel.h
--- a/ipc/glue/MessageChannel.h	Mon Jun 21 21:53:10 2021 +0000
+++ b/ipc/glue/MessageChannel.h	Mon Jun 21 21:53:10 2021 +0000
@@ -24,6 +24,7 @@
 
 #include "MessageLink.h"  // for HasResultCodes
 #include "mozilla/ipc/Transport.h"
+#include "mozilla/ipc/ScopedPort.h"
 
 #ifdef MOZ_GECKO_PROFILER
 #  include "mozilla/BaseProfilerMarkers.h"
@@ -104,6 +105,7 @@
 class MessageChannel : HasResultCodes {
   friend class ProcessLink;
   friend class ThreadLink;
+  friend class PortLink;
 #ifdef FUZZING
   friend class ProtocolFuzzerHelper;
 #endif
@@ -153,12 +155,20 @@
   typedef IPC::Message Message;
   typedef IPC::MessageInfo MessageInfo;
   typedef mozilla::ipc::Transport Transport;
+  using ScopedPort = mozilla::ipc::ScopedPort;
 
   explicit MessageChannel(const char* aName, IToplevelProtocol* aListener);
   ~MessageChannel();
 
   IToplevelProtocol* Listener() const { return mListener; }
 
+  // "Open" a connection using an existing ScopedPort. The ScopedPort must be
+  // valid and connected to a remote.
+  //
+  // The `aEventTarget` parameter must be on the current thread.
+  bool Open(ScopedPort aPort, Side aSide,
+            nsISerialEventTarget* aEventTarget = nullptr);
+
   // "Open" from the perspective of the transport layer; the underlying
   // socketpair/pipe should already be created.
   //
@@ -329,9 +339,10 @@
   }
 
   /**
-   * Does this MessageChannel cross process boundaries?
+   * Does this MessageChannel currently cross process boundaries?
    */
-  bool IsCrossProcess() const { return mIsCrossProcess; }
+  bool IsCrossProcess() const;
+  void SetIsCrossProcess(bool aIsCrossProcess);
 
 #ifdef OS_WIN
   struct MOZ_STACK_CLASS SyncStackFrame {