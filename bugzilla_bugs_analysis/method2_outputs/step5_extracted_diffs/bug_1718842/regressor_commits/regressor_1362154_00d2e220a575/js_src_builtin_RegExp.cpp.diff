# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/RegExp.cpp
# Commit: 00d2e220a575
# Full Hash: 00d2e220a57535825b59e92df5201119109f55e4
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2020-05-22 21:38:53
# Regressor Bug: 1362154
# File Overlap Count: 1
# Description:
#   Bug 1362154: Part 5: Create groups property on result object r=mgaudet
#   
#   When a regexp has named captures, the result object has an extra `groups` property, which is an object that in turn has a string property per named capture. This patch creates the `groups` object and attaches it to the result object.
#   
#   The changes here correspond to this section of the spec proposal, which conveniently highlights the changes: https://tc39.es/proposal-regexp-named-groups/#sec-regexpbuiltinexec
# ==============================================================================

diff -r 1322042730b6 -r 00d2e220a575 js/src/builtin/RegExp.cpp
--- a/js/src/builtin/RegExp.cpp	Wed May 20 21:04:01 2020 +0000
+++ b/js/src/builtin/RegExp.cpp	Wed May 20 21:04:47 2020 +0000
@@ -30,6 +30,7 @@
 #include "vm/JSObject-inl.h"
 #include "vm/NativeObject-inl.h"
 #include "vm/ObjectOperations-inl.h"
+#include "vm/PlainObject-inl.h"
 
 using namespace js;
 
@@ -42,11 +43,11 @@
 using JS::RegExpFlags;
 
 /*
- * ES 2017 draft rev 6a13789aa9e7c6de4e96b7d3e24d9e6eba6584ad 21.2.5.2.2
- * steps 3, 16-25.
+ * ES 2021 draft 21.2.5.2.2: Steps 16-28
+ * https://tc39.es/ecma262/#sec-regexpbuiltinexec
  */
-bool js::CreateRegExpMatchResult(JSContext* cx, HandleString input,
-                                 const MatchPairs& matches,
+bool js::CreateRegExpMatchResult(JSContext* cx, HandleRegExpShared re,
+                                 HandleString input, const MatchPairs& matches,
                                  MutableHandleValue rval) {
   MOZ_ASSERT(input);
 
@@ -58,6 +59,7 @@
    *  1..pairCount-1: paren matches
    *  input:          input string
    *  index:          start index for the match
+   *  groups:         named capture groups for the match
    */
 
   // Get the templateObject that defines the shape and type of the output
@@ -68,17 +70,28 @@
     return false;
   }
 
+  // Step 16
   size_t numPairs = matches.length();
   MOZ_ASSERT(numPairs > 0);
 
-  // Step 17.
+  // Steps 18-19
   RootedArrayObject arr(cx, NewDenseFullyAllocatedArrayWithTemplate(
                                 cx, numPairs, templateObject));
   if (!arr) {
     return false;
   }
 
-  // Steps 22-24.
+#ifdef ENABLE_NEW_REGEXP
+  // Step 24 (reordered)
+  RootedPlainObject groups(cx);
+  if (re->numNamedCaptures() > 0) {
+    RootedPlainObject groupsTemplate(cx, re->getGroupsTemplate());
+    JS_TRY_VAR_OR_RETURN_FALSE(
+        cx, groups, PlainObject::createWithTemplate(cx, groupsTemplate));
+  }
+#endif
+
+  // Steps 22-23 and 27 a-e.
   // Store a Value for each pair.
   for (size_t i = 0; i < numPairs; i++) {
     const MatchPair& pair = matches[i];
@@ -98,6 +111,14 @@
     }
   }
 
+#ifdef ENABLE_NEW_REGEXP
+  // Step 27 f.
+  for (uint32_t i = 0; i < re->numNamedCaptures(); i++) {
+    uint32_t idx = re->getNamedCaptureIndex(i);
+    groups->setSlot(i, arr->getDenseElement(idx));
+  }
+#endif
+
   // Step 20 (reordered).
   // Set the |index| property.
   arr->setSlot(RegExpRealm::MatchResultObjectIndexSlot,
@@ -107,6 +128,13 @@
   // Set the |input| property.
   arr->setSlot(RegExpRealm::MatchResultObjectInputSlot, StringValue(input));
 
+#ifdef ENABLE_NEW_REGEXP
+  // Steps 25-26 (reordered)
+  // Set the |groups| property.
+  arr->setSlot(RegExpRealm::MatchResultObjectGroupsSlot,
+               groups ? ObjectValue(*groups) : UndefinedValue());
+#endif
+
 #ifdef DEBUG
   RootedValue test(cx);
   RootedId id(cx, NameToId(cx->names().index));
@@ -121,7 +149,7 @@
   MOZ_ASSERT(test == arr->getSlot(RegExpRealm::MatchResultObjectInputSlot));
 #endif
 
-  // Step 25.
+  // Step 28.
   rval.setObject(*arr);
   return true;
 }
@@ -188,7 +216,7 @@
     return true;
   }
 
-  return CreateRegExpMatchResult(cx, input, matches, rval);
+  return CreateRegExpMatchResult(cx, shared, input, matches, rval);
 }
 
 static bool CheckPatternSyntaxSlow(JSContext* cx, HandleAtom pattern,
@@ -1047,7 +1075,9 @@
   }
 
   /* Steps 16-25 */
-  return CreateRegExpMatchResult(cx, string, matches, rval);
+  Handle<RegExpObject*> reobj = regexp.as<RegExpObject>();
+  RootedRegExpShared shared(cx, RegExpObject::getShared(cx, reobj));
+  return CreateRegExpMatchResult(cx, shared, string, matches, rval);
 }
 
 /*
@@ -1081,7 +1111,9 @@
   // The MatchPairs will always be passed in, but RegExp execution was
   // successful only if the pairs have actually been filled in.
   if (maybeMatches && maybeMatches->pairsRaw()[0] > MatchPair::NoMatch) {
-    return CreateRegExpMatchResult(cx, input, *maybeMatches, output);
+    Handle<RegExpObject*> reobj = regexp.as<RegExpObject>();
+    RootedRegExpShared shared(cx, RegExpObject::getShared(cx, reobj));
+    return CreateRegExpMatchResult(cx, shared, input, *maybeMatches, output);
   }
 
   // |maybeLastIndex| only contains a valid value when the RegExp execution