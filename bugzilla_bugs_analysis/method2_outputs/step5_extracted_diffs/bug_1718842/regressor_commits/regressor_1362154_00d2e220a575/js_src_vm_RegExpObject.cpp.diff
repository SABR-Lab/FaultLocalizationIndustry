# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/RegExpObject.cpp
# Commit: 00d2e220a575
# Full Hash: 00d2e220a57535825b59e92df5201119109f55e4
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2020-05-22 21:38:53
# Regressor Bug: 1362154
# File Overlap Count: 1
# Description:
#   Bug 1362154: Part 5: Create groups property on result object r=mgaudet
#   
#   When a regexp has named captures, the result object has an extra `groups` property, which is an object that in turn has a string property per named capture. This patch creates the `groups` object and attaches it to the result object.
#   
#   The changes here correspond to this section of the spec proposal, which conveniently highlights the changes: https://tc39.es/proposal-regexp-named-groups/#sec-regexpbuiltinexec
# ==============================================================================

diff -r 1322042730b6 -r 00d2e220a575 js/src/vm/RegExpObject.cpp
--- a/js/src/vm/RegExpObject.cpp	Wed May 20 21:04:01 2020 +0000
+++ b/js/src/vm/RegExpObject.cpp	Wed May 20 21:04:47 2020 +0000
@@ -1459,7 +1459,7 @@
       cx, NewDenseUnallocatedArray(cx, RegExpObject::MaxPairCount, nullptr,
                                    TenuredObject));
   if (!templateObject) {
-    return matchResultTemplateObject_;  // = nullptr
+    return nullptr;
   }
 
   // Create a new group for the template.
@@ -1467,7 +1467,7 @@
   ObjectGroup* group = ObjectGroupRealm::makeGroup(
       cx, templateObject->realm(), templateObject->getClass(), proto);
   if (!group) {
-    return matchResultTemplateObject_;  // = nullptr
+    return nullptr;
   }
   templateObject->setGroup(group);
 
@@ -1475,22 +1475,39 @@
   RootedValue index(cx, Int32Value(0));
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().index, index,
                                 JSPROP_ENUMERATE)) {
-    return matchResultTemplateObject_;  // = nullptr
+    return nullptr;
   }
 
   /* Set dummy input property */
   RootedValue inputVal(cx, StringValue(cx->runtime()->emptyString));
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().input, inputVal,
                                 JSPROP_ENUMERATE)) {
-    return matchResultTemplateObject_;  // = nullptr
+    return nullptr;
   }
 
+#ifdef ENABLE_NEW_REGEXP
+  /* Set dummy groups property */
+  RootedValue groupsVal(cx, UndefinedValue());
+  if (!NativeDefineDataProperty(cx, templateObject, cx->names().groups,
+                                groupsVal, JSPROP_ENUMERATE)) {
+    return nullptr;
+  }
+  AddTypePropertyId(cx, templateObject, NameToId(cx->names().groups),
+                    TypeSet::AnyObjectType());
+
   // Make sure that the properties are in the right slots.
-  DebugOnly<Shape*> shape = templateObject->lastProperty();
-  MOZ_ASSERT(shape->previous()->slot() == MatchResultObjectIndexSlot &&
-             shape->previous()->propidRef() == NameToId(cx->names().index));
-  MOZ_ASSERT(shape->slot() == MatchResultObjectInputSlot &&
-             shape->propidRef() == NameToId(cx->names().input));
+#  ifdef DEBUG
+  Shape* groupsShape = templateObject->lastProperty();
+  MOZ_ASSERT(groupsShape->slot() == MatchResultObjectGroupsSlot &&
+             groupsShape->propidRef() == NameToId(cx->names().groups));
+  Shape* inputShape = groupsShape->previous().get();
+  MOZ_ASSERT(inputShape->slot() == MatchResultObjectInputSlot &&
+             inputShape->propidRef() == NameToId(cx->names().input));
+  Shape* indexShape = inputShape->previous().get();
+  MOZ_ASSERT(indexShape->slot() == MatchResultObjectIndexSlot &&
+             indexShape->propidRef() == NameToId(cx->names().index));
+#  endif
+#endif
 
   // Make sure type information reflects the indexed properties which might
   // be added.