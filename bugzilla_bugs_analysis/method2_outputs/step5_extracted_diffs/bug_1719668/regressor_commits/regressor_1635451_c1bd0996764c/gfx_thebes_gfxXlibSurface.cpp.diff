# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxXlibSurface.cpp
# Commit: c1bd0996764c
# Full Hash: c1bd0996764c49174c9169fe5550905ce5dcef88
# Author: Jed Davis <jld@mozilla.com>
# Date: 2021-07-06 21:42:42
# Regressor Bug: 1635451
# File Overlap Count: 1
# Description:
#   Bug 1635451 - Allow GLX to work in headless content processes. r=jgilbert
#   
#   This follows what we're already doing for EGL: a refcounted object
#   which can own the X connection, where we hold a weak reference from
#   the library object so that multiple contexts opportunistically share
# ==============================================================================

diff -r 2974b1ba2beb -r c1bd0996764c gfx/thebes/gfxXlibSurface.cpp
--- a/gfx/thebes/gfxXlibSurface.cpp	Tue Jul 06 07:42:41 2021 +0000
+++ b/gfx/thebes/gfxXlibSurface.cpp	Tue Jul 06 07:42:42 2021 +0000
@@ -25,7 +25,7 @@
 
 gfxXlibSurface::gfxXlibSurface(Display* dpy, Drawable drawable, Visual* visual)
     : mPixmapTaken(false),
-      mDisplay(dpy),
+      mDisplay(XlibDisplay::Borrow(dpy)),
       mDrawable(drawable),
       mGLXPixmap(X11None) {
   const gfx::IntSize size = DoSizeQuery();
@@ -36,6 +36,11 @@
 
 gfxXlibSurface::gfxXlibSurface(Display* dpy, Drawable drawable, Visual* visual,
                                const gfx::IntSize& size)
+    : gfxXlibSurface(XlibDisplay::Borrow(dpy), drawable, visual, size) {}
+
+gfxXlibSurface::gfxXlibSurface(const std::shared_ptr<XlibDisplay>& dpy,
+                               Drawable drawable, Visual* visual,
+                               const gfx::IntSize& size)
     : mPixmapTaken(false),
       mDisplay(dpy),
       mDrawable(drawable),
@@ -43,8 +48,8 @@
   NS_ASSERTION(Factory::CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
                "Bad size");
 
-  cairo_surface_t* surf =
-      cairo_xlib_surface_create(dpy, drawable, visual, size.width, size.height);
+  cairo_surface_t* surf = cairo_xlib_surface_create(*dpy, drawable, visual,
+                                                    size.width, size.height);
   Init(surf);
 }
 
@@ -52,14 +57,14 @@
                                XRenderPictFormat* format,
                                const gfx::IntSize& size)
     : mPixmapTaken(false),
-      mDisplay(DisplayOfScreen(screen)),
+      mDisplay(XlibDisplay::Borrow(DisplayOfScreen(screen))),
       mDrawable(drawable),
       mGLXPixmap(X11None) {
   NS_ASSERTION(Factory::CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
                "Bad Size");
 
   cairo_surface_t* surf = cairo_xlib_surface_create_with_xrender_format(
-      mDisplay, drawable, screen, format, size.width, size.height);
+      *mDisplay, drawable, screen, format, size.width, size.height);
   Init(surf);
 }
 
@@ -69,7 +74,7 @@
              "Not expecting an error surface");
 
   mDrawable = cairo_xlib_surface_get_drawable(csurf);
-  mDisplay = cairo_xlib_surface_get_display(csurf);
+  mDisplay = XlibDisplay::Borrow(cairo_xlib_surface_get_display(csurf));
 
   Init(csurf, true);
 }
@@ -78,9 +83,9 @@
   // gfxASurface's destructor calls RecordMemoryFreed().
   if (mPixmapTaken) {
     if (mGLXPixmap) {
-      gl::sGLXLibrary.DestroyPixmap(mDisplay, mGLXPixmap);
+      gl::sGLXLibrary.DestroyPixmap(*mDisplay, mGLXPixmap);
     }
-    XFreePixmap(mDisplay, mDrawable);
+    XFreePixmap(*mDisplay, mDrawable);
   }
 }
 
@@ -171,12 +176,22 @@
 already_AddRefed<gfxXlibSurface> gfxXlibSurface::Create(
     Screen* screen, Visual* visual, const gfx::IntSize& size,
     Drawable relatedDrawable) {
+  return Create(XlibDisplay::Borrow(DisplayOfScreen(screen)), screen, visual,
+                size, relatedDrawable);
+};
+
+/* static */
+already_AddRefed<gfxXlibSurface> gfxXlibSurface::Create(
+    const std::shared_ptr<XlibDisplay>& display, Screen* screen, Visual* visual,
+    const gfx::IntSize& size, Drawable relatedDrawable) {
+  MOZ_ASSERT(*display == DisplayOfScreen(screen));
+
   Drawable drawable = CreatePixmap(screen, size, DepthOfVisual(screen, visual),
                                    relatedDrawable);
   if (!drawable) return nullptr;
 
   RefPtr<gfxXlibSurface> result =
-      new gfxXlibSurface(DisplayOfScreen(screen), drawable, visual, size);
+      new gfxXlibSurface(display, drawable, visual, size);
   result->TakePixmap();
 
   if (result->CairoStatus() != 0) return nullptr;
@@ -218,7 +233,7 @@
     static bool force24bpp = GetForce24bppPref();
     if (force24bpp && cairo_xlib_surface_get_depth(CairoSurface()) != 24) {
       XRenderPictFormat* format =
-          XRenderFindStandardFormat(mDisplay, PictStandardRGB24);
+          XRenderFindStandardFormat(*mDisplay, PictStandardRGB24);
       if (format) {
         // Cairo only performs simple self-copies as desired if it
         // knows that this is a Pixmap surface.  It only knows that
@@ -240,7 +255,7 @@
 
 void gfxXlibSurface::Finish() {
   if (mPixmapTaken && mGLXPixmap) {
-    gl::sGLXLibrary.DestroyPixmap(mDisplay, mGLXPixmap);
+    gl::sGLXLibrary.DestroyPixmap(*mDisplay, mGLXPixmap);
     mGLXPixmap = X11None;
   }
   gfxASurface::Finish();
@@ -259,7 +274,7 @@
   int x_ignore, y_ignore;
   unsigned int bwidth_ignore, width, height, depth;
 
-  XGetGeometry(mDisplay, mDrawable, &root_ignore, &x_ignore, &y_ignore, &width,
+  XGetGeometry(*mDisplay, mDrawable, &root_ignore, &x_ignore, &y_ignore, &width,
                &height, &bwidth_ignore, &depth);
 
   return gfx::IntSize(width, height);