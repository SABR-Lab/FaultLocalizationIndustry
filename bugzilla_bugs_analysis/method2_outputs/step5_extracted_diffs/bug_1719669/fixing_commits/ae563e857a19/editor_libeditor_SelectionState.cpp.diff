# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/SelectionState.cpp
# Commit: ae563e857a19
# Full Hash: ae563e857a19a445a09437de8992b407ab1de4e6
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-07-12 21:56:04
# Description:
#   Bug 1719669 - Fix the reverse loop in `SelectionState::SaveSelection()` r=m_kato
#   
#   The crash is caused by the infinite loop to delete unnecessary ranges.
#   The `i` is always equals or larger than `0` due to unsigned.  So, if
#   `Selection::RangeCount()` is `0`, `i` can be `UINT32_MAX`.
# ==============================================================================

diff -r b51ec9e8d124 -r ae563e857a19 editor/libeditor/SelectionState.cpp
--- a/editor/libeditor/SelectionState.cpp	Mon Jul 12 07:13:13 2021 +0000
+++ b/editor/libeditor/SelectionState.cpp	Mon Jul 12 07:52:32 2021 +0000
@@ -39,24 +39,19 @@
 SelectionState::SelectionState() : mDirection(eDirNext) {}
 
 void SelectionState::SaveSelection(Selection& aSelection) {
-  size_t arrayCount = mArray.Length();
-  uint32_t rangeCount = aSelection.RangeCount();
-
   // if we need more items in the array, new them
-  if (arrayCount < rangeCount) {
-    for (uint32_t i = arrayCount; i < rangeCount; i++) {
+  if (mArray.Length() < aSelection.RangeCount()) {
+    for (uint32_t i = mArray.Length(); i < aSelection.RangeCount(); i++) {
       mArray.AppendElement();
       mArray[i] = new RangeItem();
     }
-  } else if (arrayCount > rangeCount) {
+  } else if (mArray.Length() > aSelection.RangeCount()) {
     // else if we have too many, delete them
-    for (uint32_t i = arrayCount - 1; i >= rangeCount; i--) {
-      mArray.RemoveElementAt(i);
-    }
+    mArray.TruncateLength(aSelection.RangeCount());
   }
 
   // now store the selection ranges
-  for (uint32_t i = 0; i < rangeCount; i++) {
+  for (uint32_t i = 0; i < aSelection.RangeCount(); i++) {
     const nsRange* range = aSelection.GetRangeAt(i);
     if (NS_WARN_IF(!range)) {
       continue;
