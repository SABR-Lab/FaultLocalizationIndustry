# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditor.cpp
# Commit: 71670cedaf26
# Full Hash: 71670cedaf26214f3bcb8562a445cf1ef24f4db6
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-06-30 09:36:48
# Regressor Bug: 1714914
# File Overlap Count: 1
# Description:
#   Bug 1714914 - Make editor classes treat offset in parent node as uint32_t r=m_kato
#   
#   It should be treated as `uint32_t` since DOM API does so.  However, there are
#   some exceptions:
#   
# ==============================================================================

diff -r f5dcc2d793d6 -r 71670cedaf26 editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp	Tue Jun 29 22:00:09 2021 +0000
+++ b/editor/libeditor/HTMLEditor.cpp	Wed Jun 30 07:07:28 2021 +0000
@@ -91,8 +91,8 @@
   RefPtr<Selection> mSelection;
   nsCOMPtr<nsINode> mStartContainer;
   nsCOMPtr<nsINode> mEndContainer;
-  int32_t mStartOffset = 0;
-  int32_t mEndOffset = 0;
+  uint32_t mStartOffset = 0;
+  uint32_t mEndOffset = 0;
 };
 
 HTMLEditor::HTMLEditor()
@@ -4401,20 +4401,26 @@
 
     // Split the selection into existing node and new node.
     if (range.mStartContainer == aStartOfRightNode.GetContainer()) {
-      if (static_cast<uint32_t>(range.mStartOffset) <
-          aStartOfRightNode.Offset()) {
+      if (range.mStartOffset < aStartOfRightNode.Offset()) {
         range.mStartContainer = &aNewLeftNode;
+      } else if (range.mStartOffset >= aStartOfRightNode.Offset()) {
+        range.mStartOffset -= aStartOfRightNode.Offset();
       } else {
-        range.mStartOffset -= aStartOfRightNode.Offset();
+        NS_WARNING(
+            "The stored start offset was smaller than the right node offset");
+        range.mStartOffset = 0;
       }
     }
 
     if (range.mEndContainer == aStartOfRightNode.GetContainer()) {
-      if (static_cast<uint32_t>(range.mEndOffset) <
-          aStartOfRightNode.Offset()) {
+      if (range.mEndOffset < aStartOfRightNode.Offset()) {
         range.mEndContainer = &aNewLeftNode;
+      } else if (range.mEndOffset >= aStartOfRightNode.Offset()) {
+        range.mEndOffset -= aStartOfRightNode.Offset();
       } else {
-        range.mEndOffset -= aStartOfRightNode.Offset();
+        NS_WARNING(
+            "The stored end offset was smaller than the right node offset");
+        range.mEndOffset = 0;
       }
     }
 
@@ -4479,6 +4485,9 @@
   // Remember some values; later used for saved selection updating.
   // Find the offset between the nodes to be joined.
   int32_t offset = parent->ComputeIndexOf(&aRightNode);
+  if (NS_WARN_IF(offset < 0)) {
+    return NS_ERROR_FAILURE;
+  }
   // Find the number of children of the lefthand node
   uint32_t oldLeftNodeLen = aLeftNode.Length();
 
@@ -4499,9 +4508,9 @@
 
   // XXX Some other transactions manage range updater by themselves.
   //     Why doesn't JoinNodeTransaction do it?
-  DebugOnly<nsresult> rvIgnored =
-      RangeUpdaterRef().SelAdjJoinNodes(aLeftNode, aRightNode, *parent, offset,
-                                        static_cast<int32_t>(oldLeftNodeLen));
+  DebugOnly<nsresult> rvIgnored = RangeUpdaterRef().SelAdjJoinNodes(
+      aLeftNode, aRightNode, *parent, AssertedCast<uint32_t>(offset),
+      oldLeftNodeLen);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
                        "RangeUpdater::SelAdjJoinNodes() failed, but ignored");
 
@@ -4572,15 +4581,14 @@
       // adjustment logic at end of this method.
       if (range.mStartContainer) {
         if (range.mStartContainer == atNodeToKeep.GetContainer() &&
-            atNodeToJoin.Offset() < static_cast<uint32_t>(range.mStartOffset) &&
-            static_cast<uint32_t>(range.mStartOffset) <=
-                atNodeToKeep.Offset()) {
+            atNodeToJoin.Offset() < range.mStartOffset &&
+            range.mStartOffset <= atNodeToKeep.Offset()) {
           range.mStartContainer = &aContentToJoin;
           range.mStartOffset = firstNodeLength;
         }
         if (range.mEndContainer == atNodeToKeep.GetContainer() &&
-            atNodeToJoin.Offset() < static_cast<uint32_t>(range.mEndOffset) &&
-            static_cast<uint32_t>(range.mEndOffset) <= atNodeToKeep.Offset()) {
+            atNodeToJoin.Offset() < range.mEndOffset &&
+            range.mEndOffset <= atNodeToKeep.Offset()) {
           range.mEndContainer = &aContentToJoin;
           range.mEndOffset = firstNodeLength;
         }
@@ -4711,8 +4719,8 @@
 
   if (allowedTransactionsToChangeSelection) {
     // Editor wants us to set selection at join point.
-    DebugOnly<nsresult> rvIgnored = SelectionRef().CollapseInLimiter(
-        &aContentToKeep, AssertedCast<int32_t>(firstNodeLength));
+    DebugOnly<nsresult> rvIgnored =
+        SelectionRef().CollapseInLimiter(&aContentToKeep, firstNodeLength);
     if (NS_WARN_IF(Destroyed())) {
       return NS_ERROR_EDITOR_DESTROYED;
     }