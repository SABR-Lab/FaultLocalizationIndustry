# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/spellchecker/TextServicesDocument.h
# Commit: 42ff08e8e796
# Full Hash: 42ff08e8e79654998137b990fa34aa6a462a90ed
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-07-13 21:42:32
# Regressor Bug: 1718924
# File Overlap Count: 2
# Description:
#   Bug 1718924 - part 10: Make all `OffsetEntry` instances unique pointers r=m_kato
#   
#   Now, it stores `dom::Text` with `OwningNonNull`.  So, once it's leaked, it
#   wastes a lot of memory spaces.  Therefore, we should make `mOffsetTable`
#   store `UniquePtr<OffsetEntry>` instead of `OffsetEntry*`.
# ==============================================================================

diff -r 3ba594b4b02d -r 42ff08e8e796 editor/spellchecker/TextServicesDocument.h
--- a/editor/spellchecker/TextServicesDocument.h	Tue Jul 13 09:42:34 2021 +0000
+++ b/editor/spellchecker/TextServicesDocument.h	Tue Jul 13 09:55:59 2021 +0000
@@ -7,6 +7,7 @@
 #define mozilla_TextServicesDocument_h
 
 #include "mozilla/Maybe.h"
+#include "mozilla/UniquePtr.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsIEditActionListener.h"
@@ -57,7 +58,7 @@
   RefPtr<FilteredContentIterator> mFilteredIter;
   nsCOMPtr<nsIContent> mPrevTextBlock;
   nsCOMPtr<nsIContent> mNextTextBlock;
-  nsTArray<OffsetEntry*> mOffsetTable;
+  nsTArray<UniquePtr<OffsetEntry>> mOffsetTable;
   RefPtr<nsRange> mExtent;
 
   // TODO: Making the following members manged in a struct must become the code
@@ -72,7 +73,7 @@
   IteratorStatus mIteratorStatus;
 
  protected:
-  virtual ~TextServicesDocument();
+  virtual ~TextServicesDocument() = default;
 
  public:
   TextServicesDocument();
@@ -294,20 +295,19 @@
   bool SelectionIsCollapsed() const;
   bool SelectionIsValid() const;
 
-  static nsresult CreateOffsetTable(nsTArray<OffsetEntry*>* aOffsetTable,
-                                    FilteredContentIterator* aFilteredIter,
-                                    IteratorStatus* aIteratorStatus,
-                                    nsRange* aIterRange, nsAString* aStr);
-  static nsresult ClearOffsetTable(nsTArray<OffsetEntry*>* aOffsetTable);
+  static nsresult CreateOffsetTable(
+      nsTArray<UniquePtr<OffsetEntry>>* aOffsetTable,
+      FilteredContentIterator* aFilteredIter, IteratorStatus* aIteratorStatus,
+      nsRange* aIterRange, nsAString* aStr);
 
-  static nsresult NodeHasOffsetEntry(nsTArray<OffsetEntry*>* aOffsetTable,
-                                     nsINode* aNode, bool* aHasEntry,
-                                     size_t* aEntryIndex);
+  static nsresult NodeHasOffsetEntry(
+      nsTArray<UniquePtr<OffsetEntry>>* aOffsetTable, nsINode* aNode,
+      bool* aHasEntry, size_t* aEntryIndex);
 
   nsresult RemoveInvalidOffsetEntries();
   nsresult SplitOffsetEntry(size_t aTableIndex, uint32_t aOffsetIntoEntry);
 
-  static nsresult FindWordBounds(nsTArray<OffsetEntry*>* aOffsetTable,
+  static nsresult FindWordBounds(nsTArray<UniquePtr<OffsetEntry>>* aOffsetTable,
                                  nsString* aBlockStr, nsINode* aNode,
                                  uint32_t aNodeOffset, nsINode** aWordStartNode,
                                  uint32_t* aWordStartOffset,
