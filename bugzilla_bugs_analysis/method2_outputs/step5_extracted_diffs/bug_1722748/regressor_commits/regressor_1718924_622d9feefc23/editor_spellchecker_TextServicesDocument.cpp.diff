# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/spellchecker/TextServicesDocument.cpp
# Commit: 622d9feefc23
# Full Hash: 622d9feefc23b5cc1536082fbcb99231d1f43a8f
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-07-13 21:42:32
# Regressor Bug: 1718924
# File Overlap Count: 2
# Description:
#   Bug 1718924 - part 12: Move `TextServicesDocument::FindWordBounds()` to `OffsetEntryArray` r=m_kato
#   
#   Depends on D119158
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D119159
# ==============================================================================

diff -r a5c5378612e0 -r 622d9feefc23 editor/spellchecker/TextServicesDocument.cpp
--- a/editor/spellchecker/TextServicesDocument.cpp	Tue Jul 13 10:17:48 2021 +0000
+++ b/editor/spellchecker/TextServicesDocument.cpp	Tue Jul 13 10:19:40 2021 +0000
@@ -311,19 +311,17 @@
     return result.unwrapErr();
   }
 
-  nsCOMPtr<nsINode> wordStartNode, wordEndNode;
-  uint32_t wordStartOffset, wordEndOffset;
-
-  rv = FindWordBounds(&offsetTable, &blockStr, rngStartNode, rngStartOffset,
-                      getter_AddRefs(wordStartNode), &wordStartOffset,
-                      getter_AddRefs(wordEndNode), &wordEndOffset);
+  Result<EditorDOMRangeInTexts, nsresult> maybeWordRange =
+      offsetTable.FindWordRange(
+          blockStr, EditorRawDOMPoint(rngStartNode, rngStartOffset));
   offsetTable.Clear();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+  if (maybeWordRange.isErr()) {
+    NS_WARNING(
+        "TextServicesDocument::OffsetEntryArray::FindWordRange() failed");
+    return maybeWordRange.unwrapErr();
   }
-
-  rngStartNode = wordStartNode;
-  rngStartOffset = wordStartOffset;
+  rngStartNode = maybeWordRange.inspect().StartRef().GetContainerAsText();
+  rngStartOffset = maybeWordRange.inspect().StartRef().Offset();
 
   // Grab all the text in the block containing our
   // last text node.
@@ -339,22 +337,24 @@
     return result.unwrapErr();
   }
 
-  rv = FindWordBounds(&offsetTable, &blockStr, rngEndNode, rngEndOffset,
-                      getter_AddRefs(wordStartNode), &wordStartOffset,
-                      getter_AddRefs(wordEndNode), &wordEndOffset);
+  maybeWordRange = offsetTable.FindWordRange(
+      blockStr, EditorRawDOMPoint(rngEndNode, rngEndOffset));
   offsetTable.Clear();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+  if (maybeWordRange.isErr()) {
+    NS_WARNING(
+        "TextServicesDocument::OffsetEntryArray::FindWordRange() failed");
+    return maybeWordRange.unwrapErr();
   }
 
   // To prevent expanding the range too much, we only change
   // rngEndNode and rngEndOffset if it isn't already at the start of the
   // word and isn't equivalent to rngStartNode and rngStartOffset.
 
-  if (rngEndNode != wordStartNode || rngEndOffset != wordStartOffset ||
+  if (rngEndNode != maybeWordRange.inspect().StartRef().GetContainerAsText() ||
+      rngEndOffset != maybeWordRange.inspect().StartRef().Offset() ||
       (rngEndNode == rngStartNode && rngEndOffset == rngStartOffset)) {
-    rngEndNode = wordEndNode;
-    rngEndOffset = wordEndOffset;
+    rngEndNode = maybeWordRange.inspect().EndRef().GetContainerAsText();
+    rngEndOffset = maybeWordRange.inspect().EndRef().Offset();
   }
 
   // Now adjust the range so that it uses our new end points.
@@ -2629,59 +2629,50 @@
 // Spellchecker code has this. See bug 211343
 #define IS_NBSP_CHAR(c) (((unsigned char)0xa0) == (c))
 
-// static
-nsresult TextServicesDocument::FindWordBounds(
-    nsTArray<UniquePtr<OffsetEntry>>* aOffsetTable, nsString* aBlockStr,
-    nsINode* aNode, uint32_t aNodeOffset, nsINode** aWordStartNode,
-    uint32_t* aWordStartOffset, nsINode** aWordEndNode,
-    uint32_t* aWordEndOffset) {
-  // Initialize return values.
-
-  if (aWordStartNode) {
-    *aWordStartNode = nullptr;
-  }
-  if (aWordStartOffset) {
-    *aWordStartOffset = 0;
-  }
-  if (aWordEndNode) {
-    *aWordEndNode = nullptr;
-  }
-  if (aWordEndOffset) {
-    *aWordEndOffset = 0;
-  }
-
+Result<EditorDOMRangeInTexts, nsresult>
+TextServicesDocument::OffsetEntryArray::FindWordRange(
+    nsAString& aAllTextInBlock, const EditorRawDOMPoint& aStartPointToScan) {
+  MOZ_ASSERT(aStartPointToScan.IsInTextNode());
   // It's assumed that aNode is a text node. The first thing
   // we do is get its index in the offset table so we can
   // calculate the dom point's string offset.
   size_t entryIndex = 0;
   bool hasEntry = false;
-  nsresult rv = NodeHasOffsetEntry(aOffsetTable, aNode, &hasEntry, &entryIndex);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(hasEntry, NS_ERROR_FAILURE);
-
-  // Next we map aNodeOffset into a string offset.
-
-  const UniquePtr<OffsetEntry>& entry = (*aOffsetTable)[entryIndex];
-  uint32_t strOffset =
-      entry->mOffsetInTextInBlock + aNodeOffset - entry->mOffsetInTextNode;
+  nsresult rv = TextServicesDocument::NodeHasOffsetEntry(
+      this, aStartPointToScan.GetContainer(), &hasEntry, &entryIndex);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("TextServicesDocument::NodeHasOffsetEntry() failed");
+    return Err(rv);
+  }
+  if (NS_WARN_IF(!hasEntry)) {
+    NS_WARNING(
+        "TextServicesDocument::NodeHasOffsetEntry() didn't fine entries");
+    return Err(NS_ERROR_FAILURE);
+  }
+
+  // Next we map offset into a string offset.
+
+  const UniquePtr<OffsetEntry>& entry = ElementAt(entryIndex);
+  uint32_t strOffset = entry->mOffsetInTextInBlock +
+                       aStartPointToScan.Offset() - entry->mOffsetInTextNode;
 
   // Now we use the word breaker to find the beginning and end
   // of the word from our calculated string offset.
 
-  const char16_t* str = aBlockStr->get();
-  uint32_t strLen = aBlockStr->Length();
-
-  mozilla::intl::WordBreaker* wordBreaker = nsContentUtils::WordBreaker();
-  mozilla::intl::WordRange res = wordBreaker->FindWord(str, strLen, strOffset);
+  const char16_t* str = aAllTextInBlock.BeginReading();
+  uint32_t strLen = aAllTextInBlock.Length();
+
+  intl::WordBreaker* wordBreaker = nsContentUtils::WordBreaker();
+  intl::WordRange res = wordBreaker->FindWord(str, strLen, strOffset);
   if (res.mBegin > strLen) {
-    return str ? NS_ERROR_ILLEGAL_VALUE : NS_ERROR_NULL_POINTER;
+    return Err(str ? NS_ERROR_ILLEGAL_VALUE : NS_ERROR_NULL_POINTER);
   }
 
   // Strip out the NBSPs at the ends
   while (res.mBegin <= res.mEnd && IS_NBSP_CHAR(str[res.mBegin])) {
     res.mBegin++;
   }
-  if (str[res.mEnd] == (unsigned char)0x20) {
+  if (str[res.mEnd] == static_cast<char16_t>(0x20)) {
     uint32_t realEndWord = res.mEnd - 1;
     while (realEndWord > res.mBegin && IS_NBSP_CHAR(str[realEndWord])) {
       realEndWord--;
@@ -2695,31 +2686,19 @@
   // and end of the word, run through the offset table and
   // convert them back into dom points.
 
-  size_t lastIndex = aOffsetTable->Length() - 1;
+  EditorDOMPointInText wordStart, wordEnd;
+  size_t lastIndex = Length() - 1;
   for (size_t i = 0; i <= lastIndex; i++) {
     // Check to see if res.mBegin is within the range covered
     // by this entry. Note that if res.mBegin is after the last
     // character covered by this entry, we will use the next
     // entry if there is one.
-    const UniquePtr<OffsetEntry>& entry = (*aOffsetTable)[i];
+    const UniquePtr<OffsetEntry>& entry = ElementAt(i);
     if (entry->mOffsetInTextInBlock <= res.mBegin &&
         (res.mBegin < entry->EndOffsetInTextInBlock() ||
          (res.mBegin == entry->EndOffsetInTextInBlock() && i == lastIndex))) {
-      if (aWordStartNode) {
-        *aWordStartNode = entry->mTextNode;
-        NS_IF_ADDREF(*aWordStartNode);
-      }
-
-      if (aWordStartOffset) {
-        *aWordStartOffset =
-            entry->mOffsetInTextNode + res.mBegin - entry->mOffsetInTextInBlock;
-      }
-
-      if (!aWordEndNode && !aWordEndOffset) {
-        // We've found our start entry, but if we're not looking
-        // for end entries, we're done.
-        break;
-      }
+      wordStart.Set(entry->mTextNode, entry->mOffsetInTextNode + res.mBegin -
+                                          entry->mOffsetInTextInBlock);
     }
 
     // Check to see if res.mEnd is within the range covered
@@ -2733,20 +2712,13 @@
         continue;
       }
 
-      if (aWordEndNode) {
-        *aWordEndNode = entry->mTextNode;
-        NS_IF_ADDREF(*aWordEndNode);
-      }
-
-      if (aWordEndOffset) {
-        *aWordEndOffset =
-            entry->mOffsetInTextNode + res.mEnd - entry->mOffsetInTextInBlock;
-      }
+      wordEnd.Set(entry->mTextNode, entry->mOffsetInTextNode + res.mEnd -
+                                        entry->mOffsetInTextInBlock);
       break;
     }
   }
 
-  return NS_OK;
+  return EditorDOMRangeInTexts(wordStart, wordEnd);
 }
 
 /**