# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/spellchecker/TextServicesDocument.cpp
# Commit: 77740303aae0
# Full Hash: 77740303aae0dcdb49e4bbc285810a68e9f05d9e
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-07-13 21:42:32
# Regressor Bug: 1718924
# File Overlap Count: 2
# Description:
#   Bug 1718924 - part 11: Create custom class of `nsTArray<UniquePtr<OffsetEntry>>` r=m_kato
#   
#   There are some methods in `TextServicesDocument` which work only with
#   `TextServicesDocument::mOffsetTable`.  Once we move such methods to custom
#   class of `nsTArray<UniquePtr<OffsetEntry>>`, we can make `TextServicesDocument`
# ==============================================================================

diff -r cce06fb41251 -r 77740303aae0 editor/spellchecker/TextServicesDocument.cpp
--- a/editor/spellchecker/TextServicesDocument.cpp	Tue Jul 13 10:02:12 2021 +0000
+++ b/editor/spellchecker/TextServicesDocument.cpp	Tue Jul 13 10:11:06 2021 +0000
@@ -303,13 +303,12 @@
 
   iterStatus = IteratorStatus::eValid;
 
-  nsTArray<UniquePtr<OffsetEntry>> offsetTable;
+  OffsetEntryArray offsetTable;
   nsAutoString blockStr;
-
-  rv = CreateOffsetTable(&offsetTable, docFilteredIter, &iterStatus, nullptr,
-                         &blockStr);
-  if (NS_FAILED(rv)) {
-    return rv;
+  Result<IteratorStatus, nsresult> result = offsetTable.Init(
+      *docFilteredIter, IteratorStatus::eValid, nullptr, &blockStr);
+  if (result.isErr()) {
+    return result.unwrapErr();
   }
 
   nsCOMPtr<nsINode> wordStartNode, wordEndNode;
@@ -334,12 +333,10 @@
     return rv;
   }
 
-  iterStatus = IteratorStatus::eValid;
-
-  rv = CreateOffsetTable(&offsetTable, docFilteredIter, &iterStatus, nullptr,
-                         &blockStr);
-  if (NS_FAILED(rv)) {
-    return rv;
+  result = offsetTable.Init(*docFilteredIter, IteratorStatus::eValid, nullptr,
+                            &blockStr);
+  if (result.isErr()) {
+    return result.unwrapErr();
   }
 
   rv = FindWordBounds(&offsetTable, &blockStr, rngEndNode, rngEndOffset,
@@ -378,11 +375,13 @@
 
   NS_ENSURE_TRUE(mFilteredIter, NS_ERROR_FAILURE);
 
-  nsresult rv = CreateOffsetTable(&mOffsetTable, mFilteredIter,
-                                  &mIteratorStatus, mExtent, &aStr);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+  Result<IteratorStatus, nsresult> result =
+      mOffsetTable.Init(*mFilteredIter, mIteratorStatus, mExtent, &aStr);
+  if (result.isErr()) {
+    NS_WARNING("OffsetEntryArray::Init() failed");
+    return result.unwrapErr();
   }
+  mIteratorStatus = result.unwrap();
   return NS_OK;
 }
 
@@ -467,13 +466,14 @@
         return rv;
       }
 
-      mIteratorStatus = IteratorStatus::eValid;
-
-      rv = CreateOffsetTable(&mOffsetTable, mFilteredIter, &mIteratorStatus,
-                             mExtent, nullptr);
-      if (NS_FAILED(rv)) {
-        return rv;
+      Result<IteratorStatus, nsresult> result =
+          mOffsetTable.Init(*mFilteredIter, IteratorStatus::eValid, mExtent);
+      if (result.isErr()) {
+        NS_WARNING("OffsetEntryArray::Init() failed");
+        mIteratorStatus = IteratorStatus::eValid;  // XXX
+        return result.unwrapErr();
       }
+      mIteratorStatus = result.unwrap();
 
       rv = GetSelection(aSelStatus, aSelOffset, aSelLength);
       if (NS_FAILED(rv)) {
@@ -532,13 +532,14 @@
         return rv;
       }
 
-      mIteratorStatus = IteratorStatus::eValid;
-
-      rv = CreateOffsetTable(&mOffsetTable, mFilteredIter, &mIteratorStatus,
-                             mExtent, nullptr);
-      if (NS_FAILED(rv)) {
-        return rv;
+      Result<IteratorStatus, nsresult> result = mOffsetTable.Init(
+          *mFilteredIter, IteratorStatus::eValid, mExtent, nullptr);
+      if (result.isErr()) {
+        NS_WARNING("OffsetEntryArray::Init() failed");
+        mIteratorStatus = IteratorStatus::eValid;  // XXX
+        return result.unwrapErr();
       }
+      mIteratorStatus = result.inspect();
 
       rv = GetSelection(aSelStatus, aSelOffset, aSelLength);
       if (NS_FAILED(rv)) {
@@ -601,11 +602,14 @@
 
         mIteratorStatus = IteratorStatus::eValid;
 
-        rv = CreateOffsetTable(&mOffsetTable, mFilteredIter, &mIteratorStatus,
-                               mExtent, nullptr);
-        if (NS_FAILED(rv)) {
-          return rv;
+        Result<IteratorStatus, nsresult> result =
+            mOffsetTable.Init(*mFilteredIter, IteratorStatus::eValid, mExtent);
+        if (result.isErr()) {
+          NS_WARNING("OffsetEntryArray::Init() failed");
+          mIteratorStatus = IteratorStatus::eValid;  // XXX
+          return result.unwrapErr();
         }
+        mIteratorStatus = result.unwrap();
 
         return GetSelection(aSelStatus, aSelOffset, aSelLength);
       }
@@ -663,13 +667,14 @@
         return rv;
       }
 
-      mIteratorStatus = IteratorStatus::eValid;
-
-      rv = CreateOffsetTable(&mOffsetTable, mFilteredIter, &mIteratorStatus,
-                             mExtent, nullptr);
-      if (NS_FAILED(rv)) {
-        return rv;
+      Result<IteratorStatus, nsresult> result =
+          mOffsetTable.Init(*mFilteredIter, IteratorStatus::eValid, mExtent);
+      if (result.isErr()) {
+        NS_WARNING("OffsetEntryArray::Init() failed");
+        mIteratorStatus = IteratorStatus::eValid;  // XXX
+        return result.unwrapErr();
       }
+      mIteratorStatus = result.unwrap();
 
       rv = GetSelection(aSelStatus, aSelOffset, aSelLength);
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
@@ -2424,20 +2429,18 @@
   return mFilteredIter->PositionAt(node);
 }
 
-nsresult TextServicesDocument::CreateOffsetTable(
-    nsTArray<UniquePtr<OffsetEntry>>* aOffsetTable,
-    FilteredContentIterator* aFilteredIter, IteratorStatus* aIteratorStatus,
-    nsRange* aIterRange, nsAString* aStr) {
-  NS_ENSURE_TRUE(aFilteredIter, NS_ERROR_NULL_POINTER);
-
-  aOffsetTable->Clear();
-
-  if (aStr) {
-    aStr->Truncate();
+Result<TextServicesDocument::IteratorStatus, nsresult>
+TextServicesDocument::OffsetEntryArray::Init(
+    FilteredContentIterator& aFilteredIter, IteratorStatus aIteratorStatus,
+    nsRange* aIterRange, nsAString* aAllTextInBlock /* = nullptr */) {
+  Clear();
+
+  if (aAllTextInBlock) {
+    aAllTextInBlock->Truncate();
   }
 
-  if (*aIteratorStatus == IteratorStatus::eDone) {
-    return NS_OK;
+  if (aIteratorStatus == IteratorStatus::eDone) {
+    return IteratorStatus::eDone;
   }
 
   // If we have an aIterRange, retrieve the endpoints so
@@ -2447,32 +2450,38 @@
   nsCOMPtr<nsINode> rngStartNode, rngEndNode;
   uint32_t rngStartOffset = 0, rngEndOffset = 0;
   if (aIterRange) {
-    nsresult rv = GetRangeEndPoints(aIterRange, getter_AddRefs(rngStartNode),
-                                    &rngStartOffset, getter_AddRefs(rngEndNode),
-                                    &rngEndOffset);
-
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsresult rv = TextServicesDocument::GetRangeEndPoints(
+        aIterRange, getter_AddRefs(rngStartNode), &rngStartOffset,
+        getter_AddRefs(rngEndNode), &rngEndOffset);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("TextServicesDocument::GetRangeEndPoints() failed");
+      return Err(rv);
+    }
   }
 
   // The text service could have added text nodes to the beginning
   // of the current block and called this method again. Make sure
   // we really are at the beginning of the current block:
 
-  nsresult rv = FirstTextNodeInCurrentBlock(aFilteredIter);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  ClearDidSkip(aFilteredIter);
+  nsresult rv =
+      TextServicesDocument::FirstTextNodeInCurrentBlock(&aFilteredIter);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("TextServicesDocument::FirstTextNodeInCurrentBlock() failed");
+    return Err(rv);
+  }
+
+  TextServicesDocument::ClearDidSkip(&aFilteredIter);
 
   uint32_t offset = 0;
   RefPtr<Text> firstTextNode, previousTextNode;
-  while (!aFilteredIter->IsDone()) {
+  while (!aFilteredIter.IsDone()) {
     nsCOMPtr<nsIContent> content =
-        aFilteredIter->GetCurrentNode()->IsContent()
-            ? aFilteredIter->GetCurrentNode()->AsContent()
+        aFilteredIter.GetCurrentNode()->IsContent()
+            ? aFilteredIter.GetCurrentNode()->AsContent()
             : nullptr;
     if (content && content->IsText()) {
-      if (previousTextNode &&
-          !HasSameBlockNodeParent(previousTextNode, content->AsText())) {
+      if (previousTextNode && !TextServicesDocument::HasSameBlockNodeParent(
+                                  previousTextNode, content->AsText())) {
         break;
       }
 
@@ -2481,7 +2490,7 @@
 
       // Add an entry for this text node into the offset table:
 
-      UniquePtr<OffsetEntry>& entry = *aOffsetTable->AppendElement(
+      UniquePtr<OffsetEntry>& entry = *AppendElement(
           MakeUnique<OffsetEntry>(*content->AsText(), offset, str.Length()));
 
       // If one or both of the endpoints of the iteration range
@@ -2510,12 +2519,12 @@
 
       offset += str.Length();
 
-      if (aStr) {
+      if (aAllTextInBlock) {
         // Append the text node's string to the output string:
         if (!firstTextNode) {
-          *aStr = str;
+          *aAllTextInBlock = str;
         } else {
-          *aStr += str;
+          *aAllTextInBlock += str;
         }
       }
 
@@ -2527,13 +2536,13 @@
     }
     // XXX This should be checked before content->IsText(), but IsBlockNode()
     //     returns true even if content is a text node.  See bug 1311934.
-    else if (IsBlockNode(content)) {
+    else if (TextServicesDocument::IsBlockNode(content)) {
       break;
     }
 
-    aFilteredIter->Next();
-
-    if (DidSkip(aFilteredIter)) {
+    aFilteredIter.Next();
+
+    if (TextServicesDocument::DidSkip(&aFilteredIter)) {
       break;
     }
   }
@@ -2541,15 +2550,14 @@
   if (firstTextNode) {
     // Always leave the iterator pointing at the first
     // text node of the current block!
-    aFilteredIter->PositionAt(firstTextNode);
-  } else {
-    // If we never ran across a text node, the iterator
-    // might have been pointing to something invalid to
-    // begin with.
-    *aIteratorStatus = IteratorStatus::eDone;
+    aFilteredIter.PositionAt(firstTextNode);
+    return aIteratorStatus;
   }
 
-  return NS_OK;
+  // If we never ran across a text node, the iterator
+  // might have been pointing to something invalid to
+  // begin with.
+  return IteratorStatus::eDone;
 }
 
 nsresult TextServicesDocument::RemoveInvalidOffsetEntries() {