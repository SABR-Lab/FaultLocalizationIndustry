# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
# Commit: af27682c5e7f
# Full Hash: af27682c5e7f86ff17d6ed152c8010e763870bdc
# Author: ssengupta <ssengupta@mozilla.com>
# Date: 2020-05-13 03:44:05
# Regressor Bug: 1635399
# File Overlap Count: 1
# Description:
#   Bug 1635399 - Function PrincipalInfoToPrincipal now returns Result<nsCOMPtr<nsIPrincipal>, nsresult> r=ckerschb
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D73868
# ==============================================================================

diff -r 86b22b1a9f7e -r af27682c5e7f dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp	Tue May 12 23:55:42 2020 +0300
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp	Tue May 12 19:02:05 2020 +0000
@@ -19,6 +19,7 @@
 #include "mozilla/Services.h"
 #include "mozilla/Unused.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsIPrincipal.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "ServiceWorker.h"
@@ -285,8 +286,8 @@
     MOZ_ASSERT(NS_IsMainThread());
     ErrorResult result;
 
-    nsCOMPtr<nsIPrincipal> principal = mDescriptor.GetPrincipal();
-    if (NS_WARN_IF(!principal)) {
+    auto principalOrErr = mDescriptor.GetPrincipal();
+    if (NS_WARN_IF(principalOrErr.isErr())) {
       mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
       return NS_OK;
     }
@@ -297,6 +298,8 @@
       return NS_OK;
     }
 
+    nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
     // This will delay update jobs originating from a service worker thread.
     // We don't currently handle ServiceWorkerRegistration.update() from other
     // worker types. Also, we assume this registration matches self.registration
@@ -445,12 +448,14 @@
   Run() override {
     MOZ_ASSERT(NS_IsMainThread());
 
-    nsCOMPtr<nsIPrincipal> principal = mDescriptor.GetPrincipal();
-    if (!principal) {
+    auto principalOrErr = mDescriptor.GetPrincipal();
+    if (NS_WARN_IF(principalOrErr.isErr())) {
       mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
       return NS_OK;
     }
 
+    nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
     nsCOMPtr<nsIServiceWorkerManager> swm =
         mozilla::services::GetServiceWorkerManager();
     if (!swm) {
@@ -493,12 +498,14 @@
     return;
   }
 
-  nsCOMPtr<nsIPrincipal> principal = mDescriptor.GetPrincipal();
-  if (!principal) {
+  auto principalOrErr = mDescriptor.GetPrincipal();
+  if (NS_WARN_IF(principalOrErr.isErr())) {
     aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
     return;
   }
 
+  nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
   RefPtr<MainThreadUpdateCallback> cb = new MainThreadUpdateCallback();
   UpdateInternal(principal, NS_ConvertUTF16toUTF8(mScope),
                  aNewestWorkerScriptUrl, cb);
@@ -542,12 +549,14 @@
     return;
   }
 
-  nsCOMPtr<nsIPrincipal> principal = mDescriptor.GetPrincipal();
-  if (!principal) {
+  auto principalOrErr = mDescriptor.GetPrincipal();
+  if (NS_WARN_IF(principalOrErr.isErr())) {
     aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
     return;
   }
 
+  nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
   RefPtr<UnregisterCallback> cb = new UnregisterCallback();
 
   nsresult rv = swm->Unregister(principal, cb,