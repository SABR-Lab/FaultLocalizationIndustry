# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/2d/RecordedEventImpl.h
# Commit: a79d9a152a6d
# Full Hash: a79d9a152a6d52a71210d4675d3c86b94615cd1b
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2021-08-04 21:45:54
# Regressor Bug: 1722300
# File Overlap Count: 1
# Description:
#   Bug 1722300 - patch 4 - Implement internal destinations when generating PDF output through cairo. r=mattwoodrow
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D120960
# ==============================================================================

diff -r b11f7f6bff04 -r a79d9a152a6d gfx/2d/RecordedEventImpl.h
--- a/gfx/2d/RecordedEventImpl.h	Wed Aug 04 12:52:37 2021 +0000
+++ b/gfx/2d/RecordedEventImpl.h	Wed Aug 04 12:52:38 2021 +0000
@@ -1553,6 +1553,31 @@
   MOZ_IMPLICIT RecordedLink(S& aStream);
 };
 
+class RecordedDestination : public RecordedDrawingEvent<RecordedDestination> {
+ public:
+  RecordedDestination(DrawTarget* aDT, const char* aDestination,
+                      const Point& aPoint)
+      : RecordedDrawingEvent(DESTINATION, aDT),
+        mDestination(aDestination),
+        mPoint(aPoint) {}
+
+  bool PlayEvent(Translator* aTranslator) const override;
+  template <class S>
+  void Record(S& aStream) const;
+  void OutputSimpleEventInfo(std::stringstream& aStringStream) const override;
+
+  std::string GetName() const override { return "Destination"; }
+
+ private:
+  friend class RecordedEvent;
+
+  std::string mDestination;
+  Point mPoint;
+
+  template <class S>
+  MOZ_IMPLICIT RecordedDestination(S& aStream);
+};
+
 static std::string NameFromBackend(BackendType aType) {
   switch (aType) {
     case BackendType::NONE:
@@ -3923,6 +3948,43 @@
   aStringStream << "Link [" << mDestination << " @ " << mRect << "]";
 }
 
+inline bool RecordedDestination::PlayEvent(Translator* aTranslator) const {
+  DrawTarget* dt = aTranslator->LookupDrawTarget(mDT);
+  if (!dt) {
+    return false;
+  }
+  dt->Destination(mDestination.c_str(), mPoint);
+  return true;
+}
+
+template <class S>
+void RecordedDestination::Record(S& aStream) const {
+  RecordedDrawingEvent::Record(aStream);
+  WriteElement(aStream, mPoint);
+  uint32_t len = mDestination.length();
+  WriteElement(aStream, len);
+  if (len) {
+    aStream.write(mDestination.data(), len);
+  }
+}
+
+template <class S>
+RecordedDestination::RecordedDestination(S& aStream)
+    : RecordedDrawingEvent(DESTINATION, aStream) {
+  ReadElement(aStream, mPoint);
+  uint32_t len;
+  ReadElement(aStream, len);
+  mDestination.resize(size_t(len));
+  if (len && aStream.good()) {
+    aStream.read(&mDestination.front(), len);
+  }
+}
+
+inline void RecordedDestination::OutputSimpleEventInfo(
+    std::stringstream& aStringStream) const {
+  aStringStream << "Destination [" << mDestination << " @ " << mPoint << "]";
+}
+
 #define FOR_EACH_EVENT(f)                                          \
   f(DRAWTARGETCREATION, RecordedDrawTargetCreation);               \
   f(DRAWTARGETDESTRUCTION, RecordedDrawTargetDestruction);         \
@@ -3972,7 +4034,8 @@
   f(FLUSH, RecordedFlush);                                         \
   f(DETACHALLSNAPSHOTS, RecordedDetachAllSnapshots);               \
   f(OPTIMIZESOURCESURFACE, RecordedOptimizeSourceSurface);         \
-  f(LINK, RecordedLink);
+  f(LINK, RecordedLink);                                           \
+  f(DESTINATION, RecordedDestination);
 
 #define DO_WITH_EVENT_TYPE(_typeenum, _class) \
   case _typeenum: {                           \