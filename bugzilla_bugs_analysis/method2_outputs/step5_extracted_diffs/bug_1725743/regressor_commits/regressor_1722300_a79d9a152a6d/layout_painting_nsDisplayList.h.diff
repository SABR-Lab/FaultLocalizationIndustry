# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/painting/nsDisplayList.h
# Commit: a79d9a152a6d
# Full Hash: a79d9a152a6d52a71210d4675d3c86b94615cd1b
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2021-08-04 21:45:54
# Regressor Bug: 1722300
# File Overlap Count: 1
# Description:
#   Bug 1722300 - patch 4 - Implement internal destinations when generating PDF output through cairo. r=mattwoodrow
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D120960
# ==============================================================================

diff -r b11f7f6bff04 -r a79d9a152a6d layout/painting/nsDisplayList.h
--- a/layout/painting/nsDisplayList.h	Wed Aug 04 12:52:37 2021 +0000
+++ b/layout/painting/nsDisplayList.h	Wed Aug 04 12:52:38 2021 +0000
@@ -1787,9 +1787,12 @@
 
   // Helper class to find what link spec (if any) to associate with a frame,
   // recording it in the builder, and generate the corresponding DisplayItem.
+  // This also takes care of generating a named destination for internal links
+  // if the element has an id or name attribute.
   class Linkifier {
    public:
-    Linkifier(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame);
+    Linkifier(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+              nsDisplayList* aList);
 
     ~Linkifier() {
       if (mBuilderToReset) {
@@ -1797,11 +1800,11 @@
       }
     }
 
-    void MaybeAppendLink(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
-                         nsDisplayList* aList);
+    void MaybeAppendLink(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame);
 
    private:
     nsDisplayListBuilder* mBuilderToReset = nullptr;
+    nsDisplayList* mList;
   };
 
  private:
@@ -1984,6 +1987,7 @@
   const ActiveScrolledRoot* mFilterASR;
   std::unordered_set<nsIScrollableFrame*> mScrollFramesToNotify;
   nsCString mLinkSpec;  // Destination of link currently being emitted, if any.
+  nsTHashSet<nsCString> mDestinations;  // Destination names emitted.
   bool mContainsBlendMode;
   bool mIsBuildingScrollbar;
   bool mCurrentScrollbarWillHaveLayer;
@@ -7307,6 +7311,26 @@
   nsRect mRect;
 };
 
+/**
+ * A display item to represent a destination within the document.
+ */
+class nsDisplayDestination : public nsPaintedDisplayItem {
+ public:
+  nsDisplayDestination(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
+                       const char* aDestinationName, const nsPoint& aPosition)
+      : nsPaintedDisplayItem(aBuilder, aFrame),
+        mDestinationName(aDestinationName),
+        mPosition(aPosition) {}
+
+  NS_DISPLAY_DECL_NAME("Destination", TYPE_DESTINATION)
+
+  void Paint(nsDisplayListBuilder* aBuilder, gfxContext* aCtx) override;
+
+ private:
+  nsCString mDestinationName;
+  nsPoint mPosition;
+};
+
 class FlattenedDisplayListIterator {
  public:
   FlattenedDisplayListIterator(nsDisplayListBuilder* aBuilder,
