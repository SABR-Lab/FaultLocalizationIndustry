# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/audioipc-server/src/lib.rs
# Commit: f95a1c5ef0b1
# Full Hash: f95a1c5ef0b1652e911f6ff96c6c38796856e70e
# Author: Matthew Gregan <kinetik@flim.org>
# Date: 2021-08-13 09:27:46
# Regressor Bug: 1724141
# File Overlap Count: 6
# Description:
#   Bug 1724141 - Update audioipc to 8bb1a227.  r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D121826
# ==============================================================================

diff -r c9c0a125e6b2 -r f95a1c5ef0b1 third_party/rust/audioipc-server/src/lib.rs
--- a/third_party/rust/audioipc-server/src/lib.rs	Thu Aug 12 21:12:32 2021 +0000
+++ b/third_party/rust/audioipc-server/src/lib.rs	Thu Aug 12 21:28:03 2021 +0000
@@ -11,7 +11,7 @@
 
 use audio_thread_priority::promote_current_thread_to_real_time;
 use audioipc::core;
-use audioipc::platformhandle_passing::framed_with_platformhandles;
+use audioipc::framing::framed;
 use audioipc::rpc;
 use audioipc::{MessageStream, PlatformHandle, PlatformHandleType};
 use futures::sync::oneshot;
@@ -124,11 +124,14 @@
 }
 
 #[no_mangle]
-pub extern "C" fn audioipc_server_new_client(p: *mut c_void) -> PlatformHandleType {
+pub extern "C" fn audioipc_server_new_client(
+    p: *mut c_void,
+    shm_area_size: usize,
+) -> PlatformHandleType {
     let (wait_tx, wait_rx) = oneshot::channel();
     let wrapper: &ServerWrapper = unsafe { &*(p as *mut _) };
 
-    let core_handle = wrapper.callback_thread.handle();
+    let callback_thread_handle = wrapper.callback_thread.handle();
 
     // We create a connected pair of anonymous IPC endpoints. One side
     // is registered with the reactor core, the other side is returned
@@ -140,13 +143,13 @@
             wrapper
                 .core_thread
                 .handle()
-                .spawn(futures::future::lazy(|| {
+                .spawn(futures::future::lazy(move || {
                     trace!("Incoming connection");
                     let handle = reactor::Handle::default();
                     ipc_server.into_tokio_ipc(&handle)
                     .map(|sock| {
-                        let transport = framed_with_platformhandles(sock, Default::default());
-                        rpc::bind_server(transport, server::CubebServer::new(core_handle));
+                        let transport = framed(sock, Default::default());
+                        rpc::bind_server(transport, server::CubebServer::new(callback_thread_handle, shm_area_size));
                     }).map_err(|_| ())
                     // Notify waiting thread that server has been registered.
                     .and_then(|_| wait_tx.send(()))