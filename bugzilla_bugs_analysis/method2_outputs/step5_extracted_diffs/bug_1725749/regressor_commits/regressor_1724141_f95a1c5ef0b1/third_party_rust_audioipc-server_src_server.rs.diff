# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/audioipc-server/src/server.rs
# Commit: f95a1c5ef0b1
# Full Hash: f95a1c5ef0b1652e911f6ff96c6c38796856e70e
# Author: Matthew Gregan <kinetik@flim.org>
# Date: 2021-08-13 09:27:46
# Regressor Bug: 1724141
# File Overlap Count: 6
# Description:
#   Bug 1724141 - Update audioipc to 8bb1a227.  r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D121826
# ==============================================================================

diff -r c9c0a125e6b2 -r f95a1c5ef0b1 third_party/rust/audioipc-server/src/server.rs
--- a/third_party/rust/audioipc-server/src/server.rs	Thu Aug 12 21:12:32 2021 +0000
+++ b/third_party/rust/audioipc-server/src/server.rs	Thu Aug 12 21:28:03 2021 +0000
@@ -5,16 +5,15 @@
 
 #[cfg(target_os = "linux")]
 use audio_thread_priority::{promote_thread_to_real_time, RtPriorityThreadInfo};
-use audioipc::codec::LengthDelimitedCodec;
-use audioipc::frame::{framed, Framed};
+use audioipc::framing::{framed, Framed};
 use audioipc::messages::{
     CallbackReq, CallbackResp, ClientMessage, Device, DeviceCollectionReq, DeviceCollectionResp,
     DeviceInfo, RegisterDeviceCollectionChanged, ServerMessage, StreamCreate, StreamCreateParams,
     StreamInitParams, StreamParams,
 };
-use audioipc::platformhandle_passing::FramedWithPlatformHandles;
 use audioipc::rpc;
 use audioipc::shm::SharedMem;
+use audioipc::{codec::LengthDelimitedCodec, messages::SerializableHandle};
 use audioipc::{MessageStream, PlatformHandle};
 use cubeb_core as cubeb;
 use cubeb_core::ffi;
@@ -75,7 +74,7 @@
         let mut servers = self.servers.lock().unwrap();
         server.borrow_mut().devtype.remove(devtype);
         if server.borrow().devtype.is_empty() {
-            servers.retain(|s| !Rc::ptr_eq(&s, server));
+            servers.retain(|s| !Rc::ptr_eq(s, server));
         }
         if servers.is_empty() {
             self.internal_register(context, false)?;
@@ -226,10 +225,8 @@
     input_frame_size: u16,
     /// Size of output frame in bytes
     output_frame_size: u16,
-    /// Shared memory buffer for sending input data to client
-    input_shm: Option<SharedMem>,
-    /// Shared memory buffer for receiving output data from client
-    output_shm: Option<SharedMem>,
+    /// Shared memory buffer for transporting audio data to/from client
+    shm: SharedMem,
     /// RPC interface to callback server running in client
     rpc: rpc::ClientProxy<CallbackReq, CallbackResp>,
 }
@@ -244,8 +241,9 @@
         );
 
         unsafe {
-            if let Some(shm) = &mut self.input_shm {
-                shm.get_mut_slice(input.len())
+            if self.input_frame_size != 0 {
+                self.shm
+                    .get_mut_slice(input.len())
                     .unwrap()
                     .copy_from_slice(input);
             }
@@ -266,8 +264,8 @@
                     let nbytes = frames as usize * self.output_frame_size as usize;
                     trace!("Reslice output to {}", nbytes);
                     unsafe {
-                        if let Some(shm) = &self.output_shm {
-                            output[..nbytes].copy_from_slice(shm.get_slice(nbytes).unwrap());
+                        if self.output_frame_size != 0 {
+                            output[..nbytes].copy_from_slice(self.shm.get_slice(nbytes).unwrap());
                         }
                     }
                 }
@@ -323,6 +321,7 @@
 struct ServerStream {
     stream: Option<cubeb::Stream>,
     cbs: Box<ServerStreamCallbacks>,
+    shm_setup: Option<rpc::Response<CallbackResp>>,
 }
 
 impl Drop for ServerStream {
@@ -332,8 +331,6 @@
     }
 }
 
-type StreamSlab = slab::Slab<ServerStream>;
-
 struct CubebServerCallbacks {
     rpc: rpc::ClientProxy<DeviceCollectionReq, DeviceCollectionResp>,
     devtype: cubeb::DeviceType,
@@ -354,21 +351,20 @@
 }
 
 pub struct CubebServer {
-    handle: current_thread::Handle,
-    streams: StreamSlab,
+    callback_thread: current_thread::Handle,
+    streams: slab::Slab<ServerStream>,
     remote_pid: Option<u32>,
     cbs: Option<Rc<RefCell<CubebServerCallbacks>>>,
     devidmap: DevIdMap,
+    shm_area_size: usize,
 }
 
 impl rpc::Server for CubebServer {
     type Request = ServerMessage;
     type Response = ClientMessage;
     type Future = FutureResult<Self::Response, ()>;
-    type Transport = FramedWithPlatformHandles<
-        audioipc::AsyncMessageStream,
-        LengthDelimitedCodec<Self::Response, Self::Request>,
-    >;
+    type Transport =
+        Framed<audioipc::AsyncMessageStream, LengthDelimitedCodec<Self::Response, Self::Request>>;
 
     fn process(&mut self, req: Self::Request) -> Self::Future {
         if let ServerMessage::ClientConnect(pid) = req {
@@ -404,13 +400,14 @@
 }
 
 impl CubebServer {
-    pub fn new(handle: current_thread::Handle) -> Self {
+    pub fn new(callback_thread_handle: current_thread::Handle, shm_area_size: usize) -> Self {
         CubebServer {
-            handle,
-            streams: StreamSlab::new(),
+            callback_thread: callback_thread_handle,
+            streams: slab::Slab::<ServerStream>::new(),
             remote_pid: None,
             cbs: None,
             devidmap: DevIdMap::new(),
+            shm_area_size,
         }
     }
 
@@ -564,7 +561,7 @@
                     // bind_client to the callback RPC handling thread.  This is
                     // done by spawning a future on `handle`.
                     let (tx, rx) = oneshot::channel();
-                    self.handle
+                    self.callback_thread
                         .spawn(futures::future::lazy(move || {
                             let handle = reactor::Handle::default();
                             let stream = ipc_server.into_tokio_ipc(&handle).unwrap();
@@ -575,25 +572,19 @@
                         }))
                         .expect("Failed to spawn DeviceCollectionClient");
 
-                    // TODO: The lowest comms layer expects exactly 3 PlatformHandles, but we only
-                    // need one here.  Send some dummy handles over for the other side to discard.
-                    let (dummy1, dummy2) =
-                        MessageStream::anonymous_ipc_pair().expect("need dummy IPC pair");
                     if let Ok(rpc) = rx.wait() {
                         self.cbs = Some(Rc::new(RefCell::new(CubebServerCallbacks {
                             rpc,
                             devtype: cubeb::DeviceType::empty(),
                         })));
-                        let fds = RegisterDeviceCollectionChanged {
-                            platform_handles: [
+                        let fd = RegisterDeviceCollectionChanged {
+                            platform_handle: SerializableHandle::new(
                                 PlatformHandle::from(ipc_client),
-                                PlatformHandle::from(dummy1),
-                                PlatformHandle::from(dummy2),
-                            ],
-                            target_pid: self.remote_pid.unwrap(),
+                                self.remote_pid.unwrap(),
+                            ),
                         };
 
-                        ClientMessage::ContextSetupDeviceCollectionCallback(fds)
+                        ClientMessage::ContextSetupDeviceCollectionCallback(fd)
                     } else {
                         warn!("Failed to setup RPC client");
                         error(cubeb::Error::error())
@@ -681,18 +672,14 @@
 
         let (ipc_server, ipc_client) = MessageStream::anonymous_ipc_pair()?;
         debug!("Created callback pair: {:?}-{:?}", ipc_server, ipc_client);
-        let shm_id = get_shm_id();
-        let (input_shm, input_file) =
-            SharedMem::new(&format!("{}-input", shm_id), audioipc::SHM_AREA_SIZE)?;
-        let (output_shm, output_file) =
-            SharedMem::new(&format!("{}-output", shm_id), audioipc::SHM_AREA_SIZE)?;
+        let shm = SharedMem::new(&get_shm_id(), self.shm_area_size)?;
 
         // This code is currently running on the Client/Server RPC
         // handling thread.  We need to move the registration of the
         // bind_client to the callback RPC handling thread.  This is
         // done by spawning a future on `handle`.
         let (tx, rx) = oneshot::channel();
-        self.handle
+        self.callback_thread
             .spawn(futures::future::lazy(move || {
                 let handle = reactor::Handle::default();
                 let stream = ipc_server.into_tokio_ipc(&handle).unwrap();
@@ -703,21 +690,21 @@
             }))
             .expect("Failed to spawn CallbackClient");
 
-        let rpc: rpc::ClientProxy<CallbackReq, CallbackResp> = match rx.wait() {
+        let rpc = match rx.wait() {
             Ok(rpc) => rpc,
             Err(_) => bail!("Failed to create callback rpc."),
         };
 
-        // TODO: The lowest comms layer expects exactly 3 PlatformHandles, so we always configure both sides of the shm.
-        // ServerStreamCallbacks only needs the active shm, so drop any unused shm now.
-        let input_shm = params.input_stream_params.and(Some(input_shm));
-        let output_shm = params.output_stream_params.and(Some(output_shm));
+        let shm_handle = unsafe { shm.make_handle().unwrap() };
+        let shm_setup = Some(rpc.call(CallbackReq::SharedMem(
+            SerializableHandle::new(shm_handle, self.remote_pid.unwrap()),
+            self.shm_area_size,
+        )));
 
         let cbs = Box::new(ServerStreamCallbacks {
             input_frame_size,
             output_frame_size,
-            input_shm,
-            output_shm,
+            shm,
             rpc,
         });
 
@@ -725,12 +712,18 @@
         let key = entry.key();
         debug!("Registering stream {:?}", key);
 
-        entry.insert(ServerStream { stream: None, cbs });
+        entry.insert(ServerStream {
+            stream: None,
+            shm_setup,
+            cbs,
+        });
 
         Ok(ClientMessage::StreamCreated(StreamCreate {
             token: key,
-            platform_handles: [PlatformHandle::from(ipc_client), input_file, output_file],
-            target_pid: self.remote_pid.unwrap(),
+            platform_handle: SerializableHandle::new(
+                PlatformHandle::from(ipc_client),
+                self.remote_pid.unwrap(),
+            ),
         }))
     }
 
@@ -765,6 +758,9 @@
         assert!(size_of::<Box<ServerStreamCallbacks>>() == size_of::<usize>());
         let user_ptr = server_stream.cbs.as_ref() as *const ServerStreamCallbacks as *mut c_void;
 
+        // SharedMem setup message should've been processed by client by now.
+        server_stream.shm_setup.take().wait().unwrap();
+
         let stream = unsafe {
             let stream = context.stream_init(
                 stream_name,