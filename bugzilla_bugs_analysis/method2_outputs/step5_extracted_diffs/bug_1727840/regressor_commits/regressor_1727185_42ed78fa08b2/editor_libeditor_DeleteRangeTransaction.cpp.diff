# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/DeleteRangeTransaction.cpp
# Commit: 42ed78fa08b2
# Full Hash: 42ed78fa08b226f3de66ce279740432bcd393a84
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-08-27 09:43:40
# Regressor Bug: 1727185
# File Overlap Count: 1
# Description:
#   Bug 1727185 - part 2: Add removable node checks for more callers of `DeleteNodeTransaction::MaybeCreate()` r=m_kato
#   
#   I just missed some callers of it.  And I also make
#   `EditorBase::DeleteNodeTransaction()` a virtual method and `HTMLEditor` override
#   it.  Then, even if it's called by helper classes, the `HTMLEditor` version is
# ==============================================================================

diff -r f79cc68cd2fe -r 42ed78fa08b2 editor/libeditor/DeleteRangeTransaction.cpp
--- a/editor/libeditor/DeleteRangeTransaction.cpp	Fri Aug 27 00:26:30 2021 +0000
+++ b/editor/libeditor/DeleteRangeTransaction.cpp	Fri Aug 27 00:49:35 2021 +0000
@@ -7,6 +7,8 @@
 
 #include "DeleteNodeTransaction.h"
 #include "DeleteTextTransaction.h"
+#include "EditorUtils.h"
+#include "HTMLEditUtils.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/ContentIterator.h"
@@ -30,6 +32,8 @@
 
 using namespace dom;
 
+using EditorType = EditorUtils::EditorType;
+
 DeleteRangeTransaction::DeleteRangeTransaction(EditorBase& aEditorBase,
                                                const nsRange& aRangeToDelete)
     : mEditorBase(&aEditorBase), mRangeToDelete(aRangeToDelete.CloneRange()) {}
@@ -174,6 +178,12 @@
 
   // see what kind of node we have
   if (Text* textNode = Text::FromNode(aStart.Container())) {
+    if (mEditorBase->IsHTMLEditor() &&
+        NS_WARN_IF(
+            !EditorUtils::IsEditableContent(*textNode, EditorType::HTML))) {
+      // Just ignore to append the transaction for non-editable node.
+      return NS_OK;
+    }
     // if the node is a chardata node, then delete chardata content
     uint32_t textLengthToDelete;
     if (aStart == aEnd) {
@@ -243,12 +253,11 @@
   for (nsIContent* child = aStart.GetChildAtOffset();
        child && child != aEnd.GetChildAtOffset();
        child = child->GetNextSibling()) {
+    if (NS_WARN_IF(!HTMLEditUtils::IsRemovableNode(*child))) {
+      continue;  // Should we abort?
+    }
     RefPtr<DeleteNodeTransaction> deleteNodeTransaction =
         DeleteNodeTransaction::MaybeCreate(*mEditorBase, *child);
-    // XXX This is odd handling.  Even if some children are not editable,
-    //     editor should append transactions because they could be editable
-    //     at undoing/redoing.  Additionally, if the transaction needs to
-    //     delete/restore all nodes, it should at undoing/redoing.
     if (deleteNodeTransaction) {
       DebugOnly<nsresult> rvIgnored = AppendChild(deleteNodeTransaction);
       NS_WARNING_ASSERTION(
@@ -325,20 +334,17 @@
       return NS_ERROR_FAILURE;
     }
 
+    if (NS_WARN_IF(!HTMLEditUtils::IsRemovableNode(*node->AsContent()))) {
+      continue;
+    }
     RefPtr<DeleteNodeTransaction> deleteNodeTransaction =
         DeleteNodeTransaction::MaybeCreate(*mEditorBase, *node->AsContent());
-    // XXX This is odd handling.  Even if some nodes in the range are not
-    //     editable, editor should append transactions because they could
-    //     at undoing/redoing.  Additionally, if the transaction needs to
-    //     delete/restore all nodes, it should at undoing/redoing.
-    if (!deleteNodeTransaction) {
-      NS_WARNING("DeleteNodeTransaction::MaybeCreate() failed");
-      return NS_ERROR_FAILURE;
+    if (deleteNodeTransaction) {
+      DebugOnly<nsresult> rvIgnored = AppendChild(deleteNodeTransaction);
+      NS_WARNING_ASSERTION(
+          NS_SUCCEEDED(rvIgnored),
+          "DeleteRangeTransaction::AppendChild() failed, but ignored");
     }
-    DebugOnly<nsresult> rvIgnored = AppendChild(deleteNodeTransaction);
-    NS_WARNING_ASSERTION(
-        NS_SUCCEEDED(rvIgnored),
-        "DeleteRangeTransaction::AppendChild() failed, but ignored");
   }
   return NS_OK;
 }