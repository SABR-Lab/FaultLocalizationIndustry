# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditorDeleteHandler.cpp
# Commit: 83f3bd0b26e2
# Full Hash: 83f3bd0b26e203bedcae8b14ab5995633b4b3275
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-08-25 09:54:00
# Regressor Bug: 1727185
# File Overlap Count: 1
# Description:
#   Bug 1727185 - Add `MOZ_DIAGNOSTIC_ASSERT` to the constructors of `DeleteNodeTransaction` and `SplitNodeTransaction` and make their users return error before hitting it r=m_kato
#   
#   On Thunderbird, we still have a bug to delete `<html>` and `<body>` elements
#   (bug 1727201).  However, it's hard to know where deletes the unexpected elements
#   from warning messages in the log.  Additionally, it's really serious bug
# ==============================================================================

diff -r 8868fe82dafd -r 83f3bd0b26e2 editor/libeditor/HTMLEditorDeleteHandler.cpp
--- a/editor/libeditor/HTMLEditorDeleteHandler.cpp	Wed Aug 25 00:21:01 2021 +0000
+++ b/editor/libeditor/HTMLEditorDeleteHandler.cpp	Wed Aug 25 00:39:41 2021 +0000
@@ -4843,7 +4843,7 @@
                                      ErrorResult& aError) {
   nsCOMPtr<nsINode> oldContainer = aFirstChild.GetParentNode();
   if (NS_WARN_IF(oldContainer != aLastChild.GetParentNode()) ||
-      NS_WARN_IF(!aPointToInsert.IsSet()) ||
+      NS_WARN_IF(!aPointToInsert.IsInContentNode()) ||
       NS_WARN_IF(!aPointToInsert.CanContainerHaveChildren())) {
     aError.Throw(NS_ERROR_INVALID_ARG);
     return;
@@ -4864,7 +4864,7 @@
     return;
   }
 
-  nsCOMPtr<nsINode> newContainer = aPointToInsert.GetContainer();
+  nsCOMPtr<nsIContent> newContainer = aPointToInsert.ContainerAsContent();
   nsCOMPtr<nsIContent> nextNode = aPointToInsert.GetChild();
   for (size_t i = children.Length(); i > 0; --i) {
     nsCOMPtr<nsIContent>& child = children[i - 1];
@@ -4873,7 +4873,15 @@
       // touch it.
       continue;
     }
+    if (NS_WARN_IF(!HTMLEditUtils::IsRemovableNode(*child))) {
+      aError.Throw(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
+      return;
+    }
     oldContainer->RemoveChild(*child, aError);
+    if (NS_WARN_IF(Destroyed())) {
+      aError.Throw(NS_ERROR_EDITOR_DESTROYED);
+      return;
+    }
     if (aError.Failed()) {
       NS_WARNING("nsINode::RemoveChild() failed");
       return;
@@ -4892,7 +4900,16 @@
         return;
       }
     }
+    if (NS_WARN_IF(
+            !EditorUtils::IsEditableContent(*newContainer, EditorType::HTML))) {
+      aError.Throw(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
+      return;
+    }
     newContainer->InsertBefore(*child, nextNode, aError);
+    if (NS_WARN_IF(Destroyed())) {
+      aError.Throw(NS_ERROR_EDITOR_DESTROYED);
+      return;
+    }
     if (aError.Failed()) {
       NS_WARNING("nsINode::InsertBefore() failed");
       return;