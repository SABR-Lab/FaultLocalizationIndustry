# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: intl/l10n/Localization.cpp
# Commit: 3404fd6725f1
# Full Hash: 3404fd6725f15d1253a7f76e3937185bd353f263
# Author: Zibi Braniecki <zbraniecki@mozilla.com>
# Date: 2021-08-02 21:43:56
# Regressor Bug: 1613705
# File Overlap Count: 1
# Description:
#   Bug 1613705 - [localization] part2: Switch Localization class to use localization-ffi. r=emilio,nika
#   
#   Depends on D104788
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D104789
# ==============================================================================

diff -r c9cfbba15d90 -r 3404fd6725f1 intl/l10n/Localization.cpp
--- a/intl/l10n/Localization.cpp	Mon Aug 02 09:54:07 2021 +0000
+++ b/intl/l10n/Localization.cpp	Mon Aug 02 09:54:07 2021 +0000
@@ -5,162 +5,137 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Localization.h"
-#include "nsImportModule.h"
-#include "nsIObserverService.h"
 #include "nsContentUtils.h"
-#include "mozilla/BasePrincipal.h"
-#include "mozilla/HoldDropJSObjects.h"
-#include "mozilla/Preferences.h"
-#include "mozilla/Services.h"
-#include "js/PropertyAndElement.h"  // JS_GetProperty
 
 #define INTL_APP_LOCALES_CHANGED "intl:app-locales-changed"
 #define L10N_PSEUDO_PREF "intl.l10n.pseudo"
 
+using namespace mozilla;
+using namespace mozilla::dom;
+using namespace mozilla::intl;
+
 static const char* kObservedPrefs[] = {L10N_PSEUDO_PREF, nullptr};
 
-using namespace mozilla::intl;
-using namespace mozilla::dom;
+static nsTArray<ffi::L10nKey> ConvertFromL10nKeys(
+    const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys) {
+  nsTArray<ffi::L10nKey> l10nKeys(aKeys.Length());
+
+  for (const auto& entry : aKeys) {
+    if (entry.IsUTF8String()) {
+      const auto& id = entry.GetAsUTF8String();
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &id;
+    } else {
+      const auto& e = entry.GetAsL10nIdArgs();
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &e.mId;
+      if (!e.mArgs.IsNull()) {
+        FluentBundle::ConvertArgs(e.mArgs.Value(), key->args);
+      }
+    }
+  }
+
+  return l10nKeys;
+}
 
-NS_IMPL_CYCLE_COLLECTION_MULTI_ZONE_JSHOLDER_CLASS(Localization)
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Localization)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mLocalization)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mGlobal)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
-  NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
-  tmp->Destroy();
-  mozilla::DropJSObjects(tmp);
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(Localization)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLocalization)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mGlobal)
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+static FallibleTArray<AttributeNameValue> ConvertToAttributeNameValue(
+    const nsTArray<ffi::L10nAttribute>& aAttributes, OOMReporter& aError) {
+  FallibleTArray<AttributeNameValue> result(aAttributes.Length());
+  for (const auto& attr : aAttributes) {
+    auto cvtAttr = AttributeNameValue();
+    cvtAttr.mName = attr.name;
+    cvtAttr.mValue = attr.value;
+    if (!result.AppendElement(std::move(cvtAttr), fallible)) {
+      result.Clear();
+      aError.ReportOOM();
+      return result;
+    }
+  }
+
+  return result;
+}
+
+static FallibleTArray<Nullable<L10nMessage>> ConvertToL10nMessages(
+    const nsTArray<ffi::OptionalL10nMessage>& aMessages, ErrorResult& aError) {
+  FallibleTArray<Nullable<L10nMessage>> l10nMessages(aMessages.Length());
 
-NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(Localization)
-  NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
-  NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mGenerateBundles)
-  NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mGenerateBundlesSync)
-  NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mBundles)
-NS_IMPL_CYCLE_COLLECTION_TRACE_END
+  for (const auto& entry : aMessages) {
+    Nullable<L10nMessage> msg;
+    if (entry.is_present) {
+      L10nMessage& m = msg.SetValue();
+      if (!entry.message.value.IsVoid()) {
+        m.mValue = entry.message.value;
+      }
+      if (!entry.message.attributes.IsEmpty()) {
+        m.mAttributes.SetValue(
+            ConvertToAttributeNameValue(entry.message.attributes, aError));
+      }
+    }
 
+    if (!l10nMessages.AppendElement(std::move(msg), fallible)) {
+      l10nMessages.Clear();
+      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
+      return l10nMessages;
+    }
+  }
+
+  return l10nMessages;
+}
+
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Localization, mGlobal)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(Localization)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(Localization)
-
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Localization)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
   NS_INTERFACE_MAP_ENTRY(nsIObserver)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 /* static */
 already_AddRefed<Localization> Localization::Create(
-    nsIGlobalObject* aGlobal, const bool aSync,
-    const BundleGenerator& aBundleGenerator) {
-  RefPtr<Localization> loc = new Localization(aGlobal, aSync, aBundleGenerator);
+    const nsTArray<nsCString>& aResourceIds, bool aIsSync) {
+  return MakeAndAddRef<Localization>(aResourceIds, aIsSync);
+}
 
-  loc->Init();
-
-  return loc.forget();
+Localization::Localization(const nsTArray<nsCString>& aResIds, bool aIsSync)
+    : mIsSync(aIsSync) {
+  ffi::localization_new(&aResIds, mIsSync, getter_AddRefs(mRaw));
 }
 
-Localization::Localization(nsIGlobalObject* aGlobal, const bool aSync,
-                           const BundleGenerator& aBundleGenerator)
-    : mGlobal(aGlobal), mIsSync(aSync) {
-  if (aBundleGenerator.mGenerateBundles.WasPassed()) {
-    GenerateBundles& generateBundles =
-        aBundleGenerator.mGenerateBundles.Value();
-    mGenerateBundles.setObject(*generateBundles.CallbackOrNull());
-  }
-  if (aBundleGenerator.mGenerateBundlesSync.WasPassed()) {
-    GenerateBundlesSync& generateBundlesSync =
-        aBundleGenerator.mGenerateBundlesSync.Value();
-    mGenerateBundlesSync.setObject(*generateBundlesSync.CallbackOrNull());
-  }
-  mIsSync = aSync;
+Localization::Localization(nsIGlobalObject* aGlobal,
+                           const nsTArray<nsCString>& aResIds, bool aIsSync)
+    : mGlobal(aGlobal), mIsSync(aIsSync) {
+  ffi::localization_new(&aResIds, mIsSync, getter_AddRefs(mRaw));
 }
 
-bool Localization::Init() {
-  RegisterObservers();
-
-  return true;
+Localization::Localization(nsIGlobalObject* aGlobal, bool aIsSync)
+    : mGlobal(aGlobal), mIsSync(aIsSync) {
+  nsTArray<nsCString> resIds;
+  ffi::localization_new(&resIds, mIsSync, getter_AddRefs(mRaw));
 }
 
-void Localization::Activate(const bool aEager) {
-  mLocalization = do_ImportModule("resource://gre/modules/Localization.jsm",
-                                  "Localization");
-
-  AutoJSContext cx;
-
-  JS::Rooted<JS::Value> generateBundlesJS(cx, mGenerateBundles);
-  JS::Rooted<JS::Value> generateBundlesSyncJS(cx, mGenerateBundlesSync);
-  JS::Rooted<JS::Value> bundlesJS(cx);
-  mLocalization->GenerateBundles(mResourceIds, mIsSync, aEager,
-                                 generateBundlesJS, generateBundlesSyncJS,
-                                 &bundlesJS);
-  mBundles.set(bundlesJS);
-
-  mozilla::HoldJSObjects(this);
+Localization::Localization(nsIGlobalObject* aGlobal)
+    : mGlobal(aGlobal), mIsSync(false) {
+  nsTArray<nsCString> resIds;
+  ffi::localization_new(&resIds, mIsSync, getter_AddRefs(mRaw));
 }
 
 already_AddRefed<Localization> Localization::Constructor(
-    const GlobalObject& aGlobal, const Sequence<nsString>& aResourceIds,
-    const bool aSync, const BundleGenerator& aBundleGenerator,
-    ErrorResult& aRv) {
-  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
-  if (!global) {
-    aRv.Throw(NS_ERROR_FAILURE);
-    return nullptr;
-  }
+    const GlobalObject& aGlobal, const Sequence<nsCString>& aResourceIds,
+    bool aIsSync, ErrorResult& aRv) {
+  nsTArray<nsCString> resIds = ToTArray<nsTArray<nsCString>>(aResourceIds);
 
-  RefPtr<Localization> loc =
-      Localization::Create(global, aSync, aBundleGenerator);
-
-  if (aResourceIds.Length()) {
-    loc->AddResourceIds(aResourceIds);
-  }
+  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
 
-  loc->Activate(true);
-
-  return loc.forget();
+  return do_AddRef(new Localization(global, resIds, aIsSync));
 }
 
-nsIGlobalObject* Localization::GetParentObject() const { return mGlobal; }
-
 JSObject* Localization::WrapObject(JSContext* aCx,
                                    JS::Handle<JSObject*> aGivenProto) {
   return Localization_Binding::Wrap(aCx, this, aGivenProto);
 }
 
-Localization::~Localization() {
-  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
-  if (obs) {
-    obs->RemoveObserver(this, INTL_APP_LOCALES_CHANGED);
-  }
-
-  Preferences::RemoveObservers(this, kObservedPrefs);
-
-  Destroy();
-  mozilla::DropJSObjects(this);
-}
-
-void Localization::Destroy() {
-  mGenerateBundles.setUndefined();
-  mGenerateBundlesSync.setUndefined();
-  mBundles.setUndefined();
-}
-
-/* Protected */
-
-void Localization::RegisterObservers() {
-  DebugOnly<nsresult> rv = Preferences::AddWeakObservers(this, kObservedPrefs);
-  MOZ_ASSERT(NS_SUCCEEDED(rv), "Adding observers failed.");
-
-  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
-  if (obs) {
-    obs->AddObserver(this, INTL_APP_LOCALES_CHANGED, true);
-  }
-}
+Localization::~Localization() = default;
 
 NS_IMETHODIMP
 Localization::Observe(nsISupports* aSubject, const char* aTopic,
@@ -178,260 +153,217 @@
   return NS_OK;
 }
 
-void Localization::OnChange() {
-  if (mLocalization) {
-    AutoJSContext cx;
-    JS::Rooted<JS::Value> generateBundlesJS(cx, mGenerateBundles);
-    JS::Rooted<JS::Value> generateBundlesSyncJS(cx, mGenerateBundlesSync);
-    JS::Rooted<JS::Value> bundlesJS(cx);
-    mLocalization->GenerateBundles(mResourceIds, mIsSync, false,
-                                   generateBundlesJS, generateBundlesSyncJS,
-                                   &bundlesJS);
-    mBundles.set(bundlesJS);
-  }
+void Localization::OnChange() {}
+
+void Localization::SetIsSync(bool aIsSync) {
+  MOZ_ASSERT(!aIsSync, "We should only move from sync to async!");
+  mIsSync = aIsSync;
+  Upgrade();
 }
 
-uint32_t Localization::AddResourceId(const nsAString& aResourceId) {
-  if (!mResourceIds.Contains(aResourceId)) {
-    mResourceIds.AppendElement(aResourceId);
-    Localization::OnChange();
-  }
-  return mResourceIds.Length();
+void Localization::AddResourceId(const nsAString& aResourceId) {
+  NS_ConvertUTF16toUTF8 resId(aResourceId);
+  ffi::localization_add_res_id(mRaw.get(), &resId);
 }
 
 uint32_t Localization::RemoveResourceId(const nsAString& aResourceId) {
-  if (mResourceIds.RemoveElement(aResourceId)) {
-    Localization::OnChange();
-  }
-  return mResourceIds.Length();
+  NS_ConvertUTF16toUTF8 resId(aResourceId);
+  return ffi::localization_remove_res_id(mRaw.get(), &resId);
 }
 
-/**
- * Localization API
- */
-
-uint32_t Localization::AddResourceIds(const nsTArray<nsString>& aResourceIds) {
-  bool added = false;
-
+void Localization::AddResourceIds(const nsTArray<nsString>& aResourceIds) {
+  nsTArray<nsCString> resIds(aResourceIds.Length());
   for (const auto& resId : aResourceIds) {
-    if (!mResourceIds.Contains(resId)) {
-      mResourceIds.AppendElement(resId);
-      added = true;
-    }
+    resIds.AppendElement(NS_ConvertUTF16toUTF8(resId));
   }
-  if (added) {
-    Localization::OnChange();
-  }
-  return mResourceIds.Length();
+  ffi::localization_add_res_ids(mRaw.get(), &resIds);
 }
 
 uint32_t Localization::RemoveResourceIds(
     const nsTArray<nsString>& aResourceIds) {
-  bool removed = false;
-
+  nsTArray<nsCString> resIds(aResourceIds.Length());
   for (const auto& resId : aResourceIds) {
-    if (mResourceIds.RemoveElement(resId)) {
-      removed = true;
-    }
+    resIds.AppendElement(NS_ConvertUTF16toUTF8(resId));
   }
-  if (removed) {
-    Localization::OnChange();
-  }
-  return mResourceIds.Length();
+  return ffi::localization_remove_res_ids(mRaw.get(), &resIds);
 }
 
 already_AddRefed<Promise> Localization::FormatValue(
-    JSContext* aCx, const nsACString& aId, const Optional<L10nArgs>& aArgs,
-    ErrorResult& aRv) {
-  if (!mLocalization) {
-    Activate(false);
-  }
-  JS::Rooted<JS::Value> args(aCx);
+    const nsACString& aId, const Optional<L10nArgs>& aArgs, ErrorResult& aRv) {
+  nsTArray<ffi::L10nArg> l10nArgs;
+  nsTArray<nsCString> errors;
 
   if (aArgs.WasPassed()) {
-    ConvertL10nArgsToJSValue(aCx, aArgs.Value(), &args, aRv);
-    if (NS_WARN_IF(aRv.Failed())) {
-      return nullptr;
-    }
-  } else {
-    args = JS::UndefinedValue();
+    const L10nArgs& args = aArgs.Value();
+    FluentBundle::ConvertArgs(args, l10nArgs);
   }
+  RefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
 
-  RefPtr<Promise> promise;
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  nsresult rv = mLocalization->FormatValue(mResourceIds, bundlesJS, aId, args,
-                                           getter_AddRefs(promise));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
-    return nullptr;
-  }
+  ffi::localization_format_value(
+      mRaw.get(), &aId, &l10nArgs, promise,
+      [](const Promise* aPromise, const nsACString* aValue,
+         const nsTArray<nsCString>* aErrors) {
+        Promise* promise = const_cast<Promise*>(aPromise);
+
+        if (!aErrors->IsEmpty()) {
+          ErrorResult rv;
+          rv.ThrowInvalidStateError(aErrors->ElementAt(0));
+          promise->MaybeReject(std::move(rv));
+        } else {
+          promise->MaybeResolve(aValue);
+        }
+      });
+
   return MaybeWrapPromise(promise);
 }
 
-void Localization::SetIsSync(const bool aIsSync) { mIsSync = aIsSync; }
+already_AddRefed<Promise> Localization::FormatValues(
+    const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys, ErrorResult& aRv) {
+  nsTArray<ffi::L10nKey> l10nKeys = ConvertFromL10nKeys(aKeys);
 
-already_AddRefed<Promise> Localization::FormatValues(
-    JSContext* aCx, const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
-    ErrorResult& aRv) {
-  if (!mLocalization) {
-    Activate(false);
-  }
-  nsTArray<JS::Value> jsKeys;
-  SequenceRooter<JS::Value> rooter(aCx, &jsKeys);
-  for (auto& key : aKeys) {
-    JS::RootedValue jsKey(aCx);
-    if (!ToJSValue(aCx, key, &jsKey)) {
-      aRv.NoteJSContextException(aCx);
-      return nullptr;
-    }
-    jsKeys.AppendElement(jsKey);
+  RefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
-  RefPtr<Promise> promise;
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  aRv = mLocalization->FormatValues(mResourceIds, bundlesJS, jsKeys,
-                                    getter_AddRefs(promise));
-  if (NS_WARN_IF(aRv.Failed())) {
-    return nullptr;
-  }
+  ffi::localization_format_values(
+      mRaw.get(), &l10nKeys, promise,
+      // callback function which will be invoked by the rust code, passing the
+      // promise back in.
+      [](const Promise* aPromise, const nsTArray<nsCString>* aRaw) {
+        Promise* promise = const_cast<Promise*>(aPromise);
+
+        promise->MaybeResolve(*aRaw);
+      });
 
   return MaybeWrapPromise(promise);
 }
 
 already_AddRefed<Promise> Localization::FormatMessages(
-    JSContext* aCx, const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
-    ErrorResult& aRv) {
-  if (!mLocalization) {
-    Activate(false);
-  }
-  nsTArray<JS::Value> jsKeys;
-  SequenceRooter<JS::Value> rooter(aCx, &jsKeys);
-  for (auto& key : aKeys) {
-    JS::RootedValue jsKey(aCx);
-    if (!ToJSValue(aCx, key, &jsKey)) {
-      aRv.NoteJSContextException(aCx);
-      return nullptr;
-    }
-    jsKeys.AppendElement(jsKey);
+    const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys, ErrorResult& aRv) {
+  auto l10nKeys = ConvertFromL10nKeys(aKeys);
+
+  RefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
-  RefPtr<Promise> promise;
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  aRv = mLocalization->FormatMessages(mResourceIds, bundlesJS, jsKeys,
-                                      getter_AddRefs(promise));
-  if (NS_WARN_IF(aRv.Failed())) {
-    return nullptr;
-  }
+  ffi::localization_format_messages(
+      mRaw.get(), &l10nKeys, promise,
+      // callback function which will be invoked by the rust code, passing the
+      // promise back in.
+      [](const Promise* aPromise,
+         const nsTArray<ffi::OptionalL10nMessage>* aRaw,
+         const nsTArray<nsCString>* aErrors) {
+        Promise* promise = const_cast<Promise*>(aPromise);
+
+        if (!aErrors->IsEmpty()) {
+          // XXX: We should consider throwing an array of errors here.
+          promise->MaybeRejectWithInvalidStateError(aErrors->ElementAt(0));
+        } else {
+          ErrorResult rv;
+          FallibleTArray<Nullable<L10nMessage>> messages;
+          if (aRaw) {
+            messages = ConvertToL10nMessages(*aRaw, rv);
+          }
+          if (rv.Failed()) {
+            promise->MaybeReject(std::move(rv));
+          } else {
+            promise->MaybeResolve(messages);
+          }
+        }
+      });
 
   return MaybeWrapPromise(promise);
 }
 
-void Localization::FormatValueSync(JSContext* aCx, const nsACString& aId,
+void Localization::FormatValueSync(const nsACString& aId,
                                    const Optional<L10nArgs>& aArgs,
                                    nsACString& aRetVal, ErrorResult& aRv) {
-  if (!mIsSync) {
-    aRv.ThrowInvalidStateError(
-        "Can't use formatValueSync when state is async.");
-    return;
-  }
-  if (!mLocalization) {
-    Activate(false);
-  }
-  JS::Rooted<JS::Value> args(aCx);
+  nsTArray<ffi::L10nArg> l10nArgs;
+  nsTArray<nsCString> errors;
 
   if (aArgs.WasPassed()) {
-    ConvertL10nArgsToJSValue(aCx, aArgs.Value(), &args, aRv);
-    if (NS_WARN_IF(aRv.Failed())) {
-      return;
-    }
-  } else {
-    args = JS::UndefinedValue();
+    const L10nArgs& args = aArgs.Value();
+    FluentBundle::ConvertArgs(args, l10nArgs);
   }
 
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  aRv = mLocalization->FormatValueSync(mResourceIds, bundlesJS, aId, args,
-                                       aRetVal);
+  ffi::localization_format_value_sync(mRaw.get(), &aId, &l10nArgs, &aRetVal,
+                                      &errors);
+
+  if (!errors.IsEmpty()) {
+    aRv.ThrowInvalidStateError(errors.ElementAt(0));
+  }
 }
 
 void Localization::FormatValuesSync(
-    JSContext* aCx, const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
+    const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
     nsTArray<nsCString>& aRetVal, ErrorResult& aRv) {
-  if (!mIsSync) {
-    aRv.ThrowInvalidStateError(
-        "Can't use formatValuesSync when state is async.");
-    return;
-  }
-  if (!mLocalization) {
-    Activate(false);
-  }
-  nsTArray<JS::Value> jsKeys;
-  SequenceRooter<JS::Value> rooter(aCx, &jsKeys);
-  for (auto& key : aKeys) {
-    JS::RootedValue jsKey(aCx);
-    if (!ToJSValue(aCx, key, &jsKey)) {
-      aRv.NoteJSContextException(aCx);
-      return;
+  nsTArray<ffi::L10nKey> l10nKeys(aKeys.Length());
+  nsTArray<nsCString> errors;
+
+  for (const auto& entry : aKeys) {
+    if (entry.IsUTF8String()) {
+      const auto& id = entry.GetAsUTF8String();
+      nsTArray<ffi::L10nArg> l10nArgs;
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &id;
+    } else {
+      const auto& e = entry.GetAsL10nIdArgs();
+      nsTArray<ffi::L10nArg> l10nArgs;
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &e.mId;
+      if (!e.mArgs.IsNull()) {
+        FluentBundle::ConvertArgs(e.mArgs.Value(), key->args);
+      }
     }
-    jsKeys.AppendElement(jsKey);
   }
 
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  aRv =
-      mLocalization->FormatValuesSync(mResourceIds, bundlesJS, jsKeys, aRetVal);
+  ffi::localization_format_values_sync(mRaw.get(), &l10nKeys, &aRetVal,
+                                       &errors);
+
+  if (!errors.IsEmpty()) {
+    aRv.ThrowInvalidStateError(errors.ElementAt(0));
+  }
 }
 
 void Localization::FormatMessagesSync(
-    JSContext* aCx, const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
+    const Sequence<OwningUTF8StringOrL10nIdArgs>& aKeys,
     nsTArray<Nullable<L10nMessage>>& aRetVal, ErrorResult& aRv) {
-  if (!mIsSync) {
-    aRv.ThrowInvalidStateError(
-        "Can't use formatMessagesSync when state is async.");
-    return;
-  }
-  if (!mLocalization) {
-    Activate(false);
-  }
-  nsTArray<JS::Value> jsKeys;
-  SequenceRooter<JS::Value> rooter(aCx, &jsKeys);
-  for (auto& key : aKeys) {
-    JS::RootedValue jsKey(aCx);
-    if (!ToJSValue(aCx, key, &jsKey)) {
-      aRv.NoteJSContextException(aCx);
-      return;
+  nsTArray<ffi::L10nKey> l10nKeys(aKeys.Length());
+  nsTArray<nsCString> errors;
+
+  for (const auto& entry : aKeys) {
+    if (entry.IsUTF8String()) {
+      const auto& id = entry.GetAsUTF8String();
+      nsTArray<ffi::L10nArg> l10nArgs;
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &id;
+    } else {
+      const auto& e = entry.GetAsL10nIdArgs();
+      nsTArray<ffi::L10nArg> l10nArgs;
+      ffi::L10nKey* key = l10nKeys.AppendElement();
+      key->id = &e.mId;
+      if (!e.mArgs.IsNull()) {
+        FluentBundle::ConvertArgs(e.mArgs.Value(), key->args);
+      }
     }
-    jsKeys.AppendElement(jsKey);
   }
 
-  nsTArray<JS::Value> messages;
+  nsTArray<ffi::OptionalL10nMessage> result(l10nKeys.Length());
 
-  SequenceRooter<JS::Value> messagesRooter(aCx, &messages);
-  JS::Rooted<JS::Value> bundlesJS(aCx, mBundles);
-  aRv = mLocalization->FormatMessagesSync(mResourceIds, bundlesJS, jsKeys,
-                                          messages);
-  if (NS_WARN_IF(aRv.Failed())) {
+  ffi::localization_format_messages_sync(mRaw.get(), &l10nKeys, &result,
+                                         &errors);
+
+  if (!errors.IsEmpty()) {
+    aRv.ThrowInvalidStateError(errors.ElementAt(0));
     return;
   }
 
-  JS::Rooted<JS::Value> rootedMsg(aCx);
-  for (auto& msg : messages) {
-    rootedMsg.set(msg);
-    Nullable<L10nMessage>* slotPtr = aRetVal.AppendElement(mozilla::fallible);
-    if (!slotPtr) {
-      aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
+  aRetVal = ConvertToL10nMessages(result, aRv);
+}
 
-    if (rootedMsg.isNull()) {
-      slotPtr->SetNull();
-    } else {
-      JS_WrapValue(aCx, &rootedMsg);
-      if (!slotPtr->SetValue().Init(aCx, rootedMsg)) {
-        aRv.NoteJSContextException(aCx);
-        return;
-      }
-    }
-  }
-}
+void Localization::Upgrade() { ffi::localization_upgrade(mRaw.get()); }
 
 /**
  * PromiseResolver is a PromiseNativeHandler used
@@ -501,33 +433,3 @@
   aInnerPromise->AppendNativeHandler(resolver);
   return docPromise.forget();
 }
-
-void Localization::ConvertL10nArgsToJSValue(
-    JSContext* aCx, const L10nArgs& aArgs, JS::MutableHandle<JS::Value> aRetVal,
-    ErrorResult& aRv) {
-  // This method uses a temporary dictionary to automate
-  // converting an IDL Record to a JS Value via a dictionary.
-  //
-  // Once we get ToJSValue for Record, we'll switch to that.
-  L10nArgsHelperDict helperDict;
-  for (auto& entry : aArgs.Entries()) {
-    L10nArgs::EntryType* newEntry =
-        helperDict.mArgs.Entries().AppendElement(fallible);
-    if (!newEntry) {
-      aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
-    newEntry->mKey = entry.mKey;
-    newEntry->mValue = entry.mValue;
-  }
-  JS::Rooted<JS::Value> jsVal(aCx);
-  if (!ToJSValue(aCx, helperDict, &jsVal)) {
-    aRv.Throw(NS_ERROR_UNEXPECTED);
-    return;
-  }
-  JS::Rooted<JSObject*> jsObj(aCx, &jsVal.toObject());
-  if (!JS_GetProperty(aCx, jsObj, "args", aRetVal)) {
-    aRv.Throw(NS_ERROR_UNEXPECTED);
-    return;
-  }
-}