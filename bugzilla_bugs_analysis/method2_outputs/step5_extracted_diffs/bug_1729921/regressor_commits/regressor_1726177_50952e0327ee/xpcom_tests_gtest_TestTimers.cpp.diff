# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/tests/gtest/TestTimers.cpp
# Commit: 50952e0327ee
# Full Hash: 50952e0327ee3dfdf413f864cca2d511a4a58694
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2021-09-02 09:24:50
# Regressor Bug: 1726177
# File Overlap Count: 1
# Description:
#   Bug 1726177: Update IDL file to better reflect previous behavior, and cover this behavior in the test-case. r=xpcom-reviewers,nika
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D123813
# ==============================================================================

diff -r ff2a03713c5e -r 50952e0327ee xpcom/tests/gtest/TestTimers.cpp
--- a/xpcom/tests/gtest/TestTimers.cpp	Wed Sep 01 21:34:04 2021 +0000
+++ b/xpcom/tests/gtest/TestTimers.cpp	Wed Sep 01 21:46:48 2021 +0000
@@ -9,13 +9,17 @@
 #include "nsCOMPtr.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
+#include "nsIObserverService.h"
 #include "nsThreadUtils.h"
 #include "prinrval.h"
 #include "prmon.h"
 #include "prthread.h"
 #include "mozilla/Attributes.h"
+#include "mozilla/Services.h"
 
+#include "mozilla/Monitor.h"
 #include "mozilla/ReentrantMonitor.h"
+#include "mozilla/StaticPrefs_timer.h"
 
 #include <list>
 #include <vector>
@@ -94,53 +98,171 @@
 
 NS_IMPL_ISUPPORTS(TimerCallback, nsITimerCallback)
 
-TEST(Timers, TargetedTimers)
-{
-  AutoCreateAndDestroyReentrantMonitor newMon;
-  ASSERT_TRUE(newMon);
+class TimerHelper {
+ public:
+  explicit TimerHelper(nsIEventTarget* aTarget)
+      : mStart(TimeStamp::Now()),
+        mTimer(NS_NewTimer(aTarget)),
+        mMonitor(__func__),
+        mTarget(aTarget) {}
+
+  ~TimerHelper() {
+    MonitorAutoLock lock(mMonitor);
+    mTimer->Cancel();
+  }
+
+  static void ClosureCallback(nsITimer*, void* aClosure) {
+    reinterpret_cast<TimerHelper*>(aClosure)->Notify();
+  }
 
-  AutoTestThread testThread;
-  ASSERT_TRUE(testThread);
+  // We do not use nsITimerCallback, because that results in a circular
+  // reference. One of the properties we want from TimerHelper is for the
+  // timer to be canceled when it goes out of scope.
+  void Notify() {
+    MonitorAutoLock lock(mMonitor);
+    EXPECT_TRUE(mTarget->IsOnCurrentThread());
+    TimeDuration elapsed = TimeStamp::Now() - mStart;
+    mStart = TimeStamp::Now();
+    mLastDelay = Some(elapsed.ToMilliseconds());
+    if (mBlockTime) {
+      PR_Sleep(mBlockTime);
+    }
+    mMonitor.Notify();
+  }
 
-  nsIThread* notifiedThread = nullptr;
+  nsresult SetTimer(uint32_t aDelay, uint8_t aType) {
+    MonitorAutoLock lock(mMonitor);
+    mTimer->Cancel();
+    mStart = TimeStamp::Now();
+    return mTimer->InitWithNamedFuncCallback(
+        ClosureCallback, this, aDelay, aType, "TimerHelper::ClosureCallback");
+  }
+
+  Maybe<uint32_t> Wait(uint32_t aLimitMs) {
+    return WaitAndBlockCallback(aLimitMs, 0);
+  }
 
-  nsCOMPtr<nsITimerCallback> callback =
-      new TimerCallback(&notifiedThread, newMon);
-  ASSERT_TRUE(callback);
+  // Waits for callback, and if it occurs within the limit, causes the callback
+  // to block for the specified time. Useful for testing cases where the
+  // callback takes a long time to return.
+  Maybe<uint32_t> WaitAndBlockCallback(uint32_t aLimitMs, uint32_t aBlockTime) {
+    MonitorAutoLock lock(mMonitor);
+    mBlockTime = aBlockTime;
+    TimeStamp start = TimeStamp::Now();
+    while (!mLastDelay.isSome()) {
+      mMonitor.Wait(TimeDuration::FromMilliseconds(aLimitMs));
+      TimeDuration elapsed = TimeStamp::Now() - start;
+      uint32_t elapsedMs = static_cast<uint32_t>(elapsed.ToMilliseconds());
+      if (elapsedMs >= aLimitMs) {
+        break;
+      }
+      aLimitMs -= elapsedMs;
+      start = TimeStamp::Now();
+    }
+    mBlockTime = 0;
+    return std::move(mLastDelay);
+  }
 
-  nsIEventTarget* target = static_cast<nsIEventTarget*>(testThread);
+ private:
+  TimeStamp mStart;
+  RefPtr<nsITimer> mTimer;
+  mutable Monitor mMonitor;
+  uint32_t mBlockTime = 0;
+  Maybe<uint32_t> mLastDelay;
+  RefPtr<nsIEventTarget> mTarget;
+};
 
-  nsCOMPtr<nsITimer> timer;
-  nsresult rv = NS_NewTimerWithCallback(getter_AddRefs(timer), callback, 2000,
-                                        nsITimer::TYPE_ONE_SHOT, target);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
+class SimpleTimerTest : public ::testing::Test {
+ public:
+  std::unique_ptr<TimerHelper> MakeTimer(uint32_t aDelay, uint8_t aType) {
+    std::unique_ptr<TimerHelper> timer(new TimerHelper(mThread));
+    timer->SetTimer(aDelay, aType);
+    return timer;
+  }
+
+  void PauseTimerThread() {
+    nsCOMPtr<nsIObserverService> observerService =
+        mozilla::services::GetObserverService();
+    observerService->NotifyObservers(nullptr, "sleep_notification", nullptr);
+  }
+
+  void ResumeTimerThread() {
+    nsCOMPtr<nsIObserverService> observerService =
+        mozilla::services::GetObserverService();
+    observerService->NotifyObservers(nullptr, "wake_notification", nullptr);
+  }
 
-  ReentrantMonitorAutoEnter mon(*newMon);
-  while (!notifiedThread) {
-    mon.Wait();
-  }
-  ASSERT_EQ(notifiedThread, testThread);
+ protected:
+  AutoTestThread mThread;
+};
+
+#ifdef XP_MACOSX
+// For some reason, our OS X testers fire timed condition waits _extremely_
+// late (as much as 200ms).
+// See https://bugzilla.mozilla.org/show_bug.cgi?id=1726915
+const unsigned kSlowdownFactor = 50;
+#else
+const unsigned kSlowdownFactor = 1;
+#endif
+
+TEST_F(SimpleTimerTest, OneShot) {
+  auto timer = MakeTimer(100 * kSlowdownFactor, nsITimer::TYPE_ONE_SHOT);
+  auto res = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(res.isSome());
+  ASSERT_LT(*res, 110U * kSlowdownFactor);
+  ASSERT_GT(*res, 95U * kSlowdownFactor);
 }
 
-TEST(Timers, TimerWithStoppedTarget)
-{
-  AutoTestThread testThread;
-  ASSERT_TRUE(testThread);
+TEST_F(SimpleTimerTest, TimerWithStoppedTarget) {
+  mThread->Shutdown();
+  auto timer = MakeTimer(100 * kSlowdownFactor, nsITimer::TYPE_ONE_SHOT);
+  auto res = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_FALSE(res.isSome());
+}
 
-  nsIEventTarget* target = static_cast<nsIEventTarget*>(testThread);
+TEST_F(SimpleTimerTest, SlackRepeating) {
+  auto timer = MakeTimer(100 * kSlowdownFactor, nsITimer::TYPE_REPEATING_SLACK);
+  auto delay =
+      timer->WaitAndBlockCallback(110 * kSlowdownFactor, 50 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
+  // REPEATING_SLACK timers re-schedule with the full duration when the timer
+  // callback completes
+
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 160U * kSlowdownFactor);
+  ASSERT_GT(*delay, 145U * kSlowdownFactor);
+}
 
-  // If this is called, we'll assert
-  nsCOMPtr<nsITimerCallback> callback = new TimerCallback(nullptr, nullptr);
-  ASSERT_TRUE(callback);
+TEST_F(SimpleTimerTest, RepeatingPrecise) {
+  auto timer = MakeTimer(100 * kSlowdownFactor,
+                         nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP);
+  auto delay =
+      timer->WaitAndBlockCallback(110 * kSlowdownFactor, 50 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
 
-  nsCOMPtr<nsITimer> timer;
-  nsresult rv = NS_NewTimerWithCallback(getter_AddRefs(timer), callback, 100,
-                                        nsITimer::TYPE_ONE_SHOT, target);
-  ASSERT_TRUE(NS_SUCCEEDED(rv));
+  // Delays smaller than the timer's period do not effect the period.
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
 
-  testThread->Shutdown();
+  // Delays larger than the timer's period should result in the skipping of
+  // firings, but the cadence should remain the same.
+  delay =
+      timer->WaitAndBlockCallback(110 * kSlowdownFactor, 150 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
 
-  PR_Sleep(400);
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 210U * kSlowdownFactor);
+  ASSERT_GT(*delay, 195U * kSlowdownFactor);
 }
 
 // gtest on 32bit Win7 debug build is unstable and somehow this test
@@ -234,8 +356,7 @@
   }
 };
 
-TEST(Timers, FindExpirationTime)
-{
+TEST_F(SimpleTimerTest, FindExpirationTime) {
   {
     FindExpirationTimeState state;
     // 0 low priority timers
@@ -386,6 +507,97 @@
 
 #endif
 
+// Do these _after_ FindExpirationTime; apparently pausing the timer thread
+// schedules minute-long timers, which FindExpirationTime waits out before
+// starting.
+TEST_F(SimpleTimerTest, SleepWakeOneShot) {
+  if (StaticPrefs::timer_ignore_sleep_wake_notifications()) {
+    return;
+  }
+  auto timer = MakeTimer(100 * kSlowdownFactor, nsITimer::TYPE_ONE_SHOT);
+  PauseTimerThread();
+  auto delay = timer->Wait(200 * kSlowdownFactor);
+  ResumeTimerThread();
+  ASSERT_FALSE(delay.isSome());
+}
+
+TEST_F(SimpleTimerTest, SleepWakeRepeatingSlack) {
+  if (StaticPrefs::timer_ignore_sleep_wake_notifications()) {
+    return;
+  }
+  auto timer = MakeTimer(100 * kSlowdownFactor, nsITimer::TYPE_REPEATING_SLACK);
+  PauseTimerThread();
+  auto delay = timer->Wait(200 * kSlowdownFactor);
+  ResumeTimerThread();
+  ASSERT_FALSE(delay.isSome());
+
+  // Timer thread slept for ~200ms, longer than the duration of the timer, so
+  // it should fire pretty much immediately.
+  delay = timer->Wait(10 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 210 * kSlowdownFactor);
+  ASSERT_GT(*delay, 199 * kSlowdownFactor);
+
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
+
+  PauseTimerThread();
+  delay = timer->Wait(50 * kSlowdownFactor);
+  ResumeTimerThread();
+  ASSERT_FALSE(delay.isSome());
+
+  // Timer thread only slept for ~50 ms, shorter than the duration of the
+  // timer, so there should be no effect on the timing.
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
+}
+
+TEST_F(SimpleTimerTest, SleepWakeRepeatingPrecise) {
+  if (StaticPrefs::timer_ignore_sleep_wake_notifications()) {
+    return;
+  }
+  auto timer = MakeTimer(100 * kSlowdownFactor,
+                         nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP);
+  PauseTimerThread();
+  auto delay = timer->Wait(350 * kSlowdownFactor);
+  ResumeTimerThread();
+  ASSERT_FALSE(delay.isSome());
+
+  // Timer thread slept longer than the duration of the timer, so it should
+  // fire pretty much immediately.
+  delay = timer->Wait(10 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 360U * kSlowdownFactor);
+  ASSERT_GT(*delay, 349U * kSlowdownFactor);
+
+  // After that, we should get back on our original cadence
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 60U * kSlowdownFactor);
+  ASSERT_GT(*delay, 45U * kSlowdownFactor);
+
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
+
+  PauseTimerThread();
+  delay = timer->Wait(50 * kSlowdownFactor);
+  ResumeTimerThread();
+  ASSERT_FALSE(delay.isSome());
+
+  // Timer thread only slept for ~50 ms, shorter than the duration of the
+  // timer, so there should be no effect on the timing.
+  delay = timer->Wait(110 * kSlowdownFactor);
+  ASSERT_TRUE(delay.isSome());
+  ASSERT_LT(*delay, 110U * kSlowdownFactor);
+  ASSERT_GT(*delay, 95U * kSlowdownFactor);
+}
+
 #define FUZZ_MAX_TIMEOUT 9
 class FuzzTestThreadState final : public nsITimerCallback {
  public: