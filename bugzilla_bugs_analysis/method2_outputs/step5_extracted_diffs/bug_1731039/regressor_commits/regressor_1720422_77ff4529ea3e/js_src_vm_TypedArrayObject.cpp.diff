# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/TypedArrayObject.cpp
# Commit: 77ff4529ea3e
# Full Hash: 77ff4529ea3eb01ca0013bd4747979c226fb617f
# Author: Steve Fink <sfink@mozilla.com>
# Date: 2021-08-13 09:27:46
# Regressor Bug: 1720422
# File Overlap Count: 2
# Description:
#   Bug 1720422 - Expose a templatized TypedArray<T> class in JSAPI r=jonco,nbp
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D119853
# ==============================================================================

diff -r 16fa627201d1 -r 77ff4529ea3e js/src/vm/TypedArrayObject.cpp
--- a/js/src/vm/TypedArrayObject.cpp	Thu Aug 12 20:28:53 2021 +0000
+++ b/js/src/vm/TypedArrayObject.cpp	Thu Aug 12 20:44:14 2021 +0000
@@ -995,7 +995,7 @@
   return result.succeed();
 }
 
-#define CREATE_TYPE_FOR_TYPED_ARRAY(T, N) \
+#define CREATE_TYPE_FOR_TYPED_ARRAY(_, T, N) \
   typedef TypedArrayObjectTemplate<T> N##Array;
 JS_FOR_EACH_TYPED_ARRAY(CREATE_TYPE_FOR_TYPED_ARRAY)
 #undef CREATE_TYPE_FOR_TYPED_ARRAY
@@ -1008,7 +1008,7 @@
   TypedArrayObject* tobj = &templateObj->as<TypedArrayObject>();
 
   switch (tobj->type()) {
-#define CREATE_TYPED_ARRAY(T, N)                                             \
+#define CREATE_TYPED_ARRAY(_, T, N)                                          \
   case Scalar::N:                                                            \
     return TypedArrayObjectTemplate<T>::makeTypedArrayWithTemplate(cx, tobj, \
                                                                    len);
@@ -1025,7 +1025,7 @@
   TypedArrayObject* tobj = &templateObj->as<TypedArrayObject>();
 
   switch (tobj->type()) {
-#define CREATE_TYPED_ARRAY(T, N)                                             \
+#define CREATE_TYPED_ARRAY(_, T, N)                                          \
   case Scalar::N:                                                            \
     return TypedArrayObjectTemplate<T>::makeTypedArrayWithTemplate(cx, tobj, \
                                                                    array);
@@ -1043,7 +1043,7 @@
   TypedArrayObject* tobj = &templateObj->as<TypedArrayObject>();
 
   switch (tobj->type()) {
-#define CREATE_TYPED_ARRAY(T, N)                                    \
+#define CREATE_TYPED_ARRAY(_, T, N)                                 \
   case Scalar::N:                                                   \
     return TypedArrayObjectTemplate<T>::makeTypedArrayWithTemplate( \
         cx, tobj, arrayBuffer, byteOffset, length);
@@ -1112,7 +1112,7 @@
     // 1. %ArrayBufferPrototype%.constructor == %ArrayBuffer%, and
     // 2. %ArrayBuffer%[@@species] == ArrayBufferSpecies
     // we don't have to reify the buffer object and can simply return the
-    // default arrray buffer constructor.
+    // default array buffer constructor.
 
     JSObject* proto =
         GlobalObject::getOrCreateArrayBufferPrototype(cx, cx->global());
@@ -1462,7 +1462,7 @@
     JSContext* cx, Native native, const JS::HandleValueArray args,
     MutableHandleObject res) {
   MOZ_ASSERT(!res);
-#define CHECK_TYPED_ARRAY_CONSTRUCTOR(T, N)                        \
+#define CHECK_TYPED_ARRAY_CONSTRUCTOR(_, T, N)                     \
   if (native == &TypedArrayObjectTemplate<T>::class_constructor) { \
     return ::GetTemplateObjectForNative<T>(cx, args, res);         \
   }
@@ -1689,7 +1689,7 @@
 
     // Steps 13-21, 23-28.
     switch (target->type()) {
-#define SET_FROM_TYPED_ARRAY(T, N)                                          \
+#define SET_FROM_TYPED_ARRAY(_, T, N)                                       \
   case Scalar::N:                                                           \
     if (!SetFromTypedArray<T>(target, srcTypedArray, offset)) return false; \
     break;
@@ -1753,7 +1753,7 @@
       }
 
       switch (target->type()) {
-#define SET_FROM_NON_TYPED_ARRAY(T, N)                                \
+#define SET_FROM_NON_TYPED_ARRAY(_, T, N)                             \
   case Scalar::N:                                                     \
     if (!SetFromNonTypedArray<T>(cx, target, src, srcLength, offset)) \
       return false;                                                   \
@@ -2111,8 +2111,8 @@
 bool TypedArrayObject::getElement<CanGC>(JSContext* cx, size_t index,
                                          MutableHandleValue val) {
   switch (type()) {
-#define GET_ELEMENT(T, N) \
-  case Scalar::N:         \
+#define GET_ELEMENT(_, T, N) \
+  case Scalar::N:            \
     return N##Array::getElement(cx, this, index, val);
     JS_FOR_EACH_TYPED_ARRAY(GET_ELEMENT)
 #undef GET_ELEMENT
@@ -2136,8 +2136,8 @@
 
 bool TypedArrayObject::getElementPure(size_t index, Value* vp) {
   switch (type()) {
-#define GET_ELEMENT_PURE(T, N) \
-  case Scalar::N:              \
+#define GET_ELEMENT_PURE(_, T, N) \
+  case Scalar::N:                 \
     return N##Array::getElementPure(this, index, vp);
     JS_FOR_EACH_TYPED_ARRAY(GET_ELEMENT_PURE)
 #undef GET_ELEMENT
@@ -2158,7 +2158,7 @@
   MOZ_ASSERT_IF(length > 0, !tarray->hasDetachedBuffer());
 
   switch (tarray->type()) {
-#define GET_ELEMENTS(T, N)                                                     \
+#define GET_ELEMENTS(_, T, N)                                                  \
   case Scalar::N:                                                              \
     for (size_t i = 0; i < length; ++i, ++vp) {                                \
       if (!N##Array::getElement(cx, tarray, i,                                 \
@@ -2206,7 +2206,7 @@
 
 static const JSPropertySpec
     static_prototype_properties[Scalar::MaxTypedArrayViewType][2] = {
-#define IMPL_TYPED_ARRAY_PROPERTIES(NativeType, Name)               \
+#define IMPL_TYPED_ARRAY_PROPERTIES(ExternalType, NativeType, Name) \
   {JS_INT32_PS("BYTES_PER_ELEMENT", Name##Array::BYTES_PER_ELEMENT, \
                JSPROP_READONLY | JSPROP_PERMANENT),                 \
    JS_PS_END},
@@ -2217,14 +2217,14 @@
 
 static const ClassSpec
     TypedArrayObjectClassSpecs[Scalar::MaxTypedArrayViewType] = {
-#define IMPL_TYPED_ARRAY_CLASS_SPEC(NativeType, Name) \
-  {Name##Array::createConstructor,                    \
-   Name##Array::createPrototype,                      \
-   nullptr,                                           \
-   static_prototype_properties[Scalar::Type::Name],   \
-   nullptr,                                           \
-   static_prototype_properties[Scalar::Type::Name],   \
-   nullptr,                                           \
+#define IMPL_TYPED_ARRAY_CLASS_SPEC(ExternalType, NativeType, Name) \
+  {Name##Array::createConstructor,                                  \
+   Name##Array::createPrototype,                                    \
+   nullptr,                                                         \
+   static_prototype_properties[Scalar::Type::Name],                 \
+   nullptr,                                                         \
+   static_prototype_properties[Scalar::Type::Name],                 \
+   nullptr,                                                         \
    JSProto_TypedArray},
 
         JS_FOR_EACH_TYPED_ARRAY(IMPL_TYPED_ARRAY_CLASS_SPEC)
@@ -2232,13 +2232,13 @@
 };
 
 const JSClass TypedArrayObject::classes[Scalar::MaxTypedArrayViewType] = {
-#define IMPL_TYPED_ARRAY_CLASS(NativeType, Name)                         \
-  {#Name "Array",                                                        \
-   JSCLASS_HAS_RESERVED_SLOTS(TypedArrayObject::RESERVED_SLOTS) |        \
-       JSCLASS_HAS_CACHED_PROTO(JSProto_##Name##Array) |                 \
-       JSCLASS_DELAY_METADATA_BUILDER | JSCLASS_SKIP_NURSERY_FINALIZE |  \
-       JSCLASS_BACKGROUND_FINALIZE,                                      \
-   &TypedArrayClassOps, &TypedArrayObjectClassSpecs[Scalar::Type::Name], \
+#define IMPL_TYPED_ARRAY_CLASS(ExternalType, NativeType, Name)                               \
+  {#Name "Array",                                                              \
+   JSCLASS_HAS_RESERVED_SLOTS(TypedArrayObject::RESERVED_SLOTS) |              \
+       JSCLASS_HAS_CACHED_PROTO(JSProto_##Name##Array) | \
+       JSCLASS_DELAY_METADATA_BUILDER | JSCLASS_SKIP_NURSERY_FINALIZE |        \
+       JSCLASS_BACKGROUND_FINALIZE,                                            \
+   &TypedArrayClassOps, &TypedArrayObjectClassSpecs[Scalar::Type::Name],       \
    &TypedArrayClassExtension},
 
     JS_FOR_EACH_TYPED_ARRAY(IMPL_TYPED_ARRAY_CLASS)
@@ -2259,7 +2259,7 @@
 // above), but it's what we've always done, so keep doing it till we
 // implement @@toStringTag or ES6 changes.
 const JSClass TypedArrayObject::protoClasses[Scalar::MaxTypedArrayViewType] = {
-#define IMPL_TYPED_ARRAY_PROTO_CLASS(NativeType, Name)                       \
+#define IMPL_TYPED_ARRAY_PROTO_CLASS(ExternalType, NativeType, Name)         \
   {#Name "Array.prototype", JSCLASS_HAS_CACHED_PROTO(JSProto_##Name##Array), \
    JS_NULL_CLASS_OPS, &TypedArrayObjectClassSpecs[Scalar::Type::Name]},
 
@@ -2283,7 +2283,7 @@
 }
 
 bool js::IsTypedArrayConstructor(const JSObject* obj) {
-#define CHECK_TYPED_ARRAY_CONSTRUCTOR(T, N)                 \
+#define CHECK_TYPED_ARRAY_CONSTRUCTOR(_, T, N)              \
   if (IsNativeFunction(obj, N##Array::class_constructor)) { \
     return true;                                            \
   }
@@ -2297,9 +2297,9 @@
 }
 
 JSNative js::TypedArrayConstructorNative(Scalar::Type type) {
-#define TYPED_ARRAY_CONSTRUCTOR_NATIVE(T, N) \
-  if (type == Scalar::N) {                   \
-    return N##Array::class_constructor;      \
+#define TYPED_ARRAY_CONSTRUCTOR_NATIVE(_, T, N) \
+  if (type == Scalar::N) {                      \
+    return N##Array::class_constructor;         \
   }
   JS_FOR_EACH_TYPED_ARRAY(TYPED_ARRAY_CONSTRUCTOR_NATIVE)
 #undef TYPED_ARRAY_CONSTRUCTOR_NATIVE
@@ -2539,8 +2539,8 @@
   TypedArrayObject* tobj = &obj->as<TypedArrayObject>();
 
   switch (tobj->type()) {
-#define SET_TYPED_ARRAY_ELEMENT(T, N) \
-  case Scalar::N:                     \
+#define SET_TYPED_ARRAY_ELEMENT(_, T, N) \
+  case Scalar::N:                        \
     return TypedArrayObjectTemplate<T>::setElement(cx, obj, index, v, result);
     JS_FOR_EACH_TYPED_ARRAY(SET_TYPED_ARRAY_ELEMENT)
 #undef SET_TYPED_ARRAY_ELEMENT
@@ -2592,7 +2592,7 @@
   // Step vi.
   if (desc.hasValue()) {
     switch (obj->type()) {
-#define DEFINE_TYPED_ARRAY_ELEMENT(T, N)                           \
+#define DEFINE_TYPED_ARRAY_ELEMENT(_, T, N)                        \
   case Scalar::N:                                                  \
     return TypedArrayObjectTemplate<T>::setElement(cx, obj, index, \
                                                    desc.value(), result);
@@ -2611,19 +2611,9 @@
   return result.succeed();
 }
 
-/* JS Friend API */
-
-template <typename NativeType>
-struct ExternalTypeOf {
-  using Type = NativeType;
-};
-
-template <>
-struct ExternalTypeOf<uint8_clamped> {
-  using Type = uint8_t;
-};
-
-#define IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS(NativeType, Name)                \
+/* JS Public API */
+
+#define IMPL_TYPED_ARRAY_JSAPI_CONSTRUCTORS(ExternalType, NativeType, Name)  \
   JS_PUBLIC_API JSObject* JS_New##Name##Array(JSContext* cx,                 \
                                               size_t nelements) {            \
     return TypedArrayObjectTemplate<NativeType>::fromLength(cx, nelements);  \
@@ -2657,13 +2647,8 @@
     return js::Unwrap##Name##Array(obj) != nullptr;                          \
   }                                                                          \
                                                                              \
-  const JSClass* const js::detail::Name##ArrayClassPtr =                     \
-      &js::TypedArrayObject::classes                                         \
-          [TypedArrayObjectTemplate<NativeType>::ArrayTypeID()];             \
-                                                                             \
   JS_PUBLIC_API JSObject* JS_GetObjectAs##Name##Array(                       \
-      JSObject* obj, size_t* length, bool* isShared,                         \
-      ExternalTypeOf<NativeType>::Type** data) {                             \
+      JSObject* obj, size_t* length, bool* isShared, ExternalType** data) {  \
     obj = js::Unwrap##Name##Array(obj);                                      \
     if (!obj) {                                                              \
       return nullptr;                                                        \
@@ -2671,13 +2656,12 @@
     TypedArrayObject* tarr = &obj->as<TypedArrayObject>();                   \
     *length = tarr->length();                                                \
     *isShared = tarr->isSharedMemory();                                      \
-    *data = static_cast<ExternalTypeOf<NativeType>::Type*>(                  \
-        tarr->dataPointerEither().unwrap(                                    \
-            /*safe - caller sees isShared flag*/));                          \
+    *data = static_cast<ExternalType*>(tarr->dataPointerEither().unwrap(     \
+        /*safe - caller sees isShared flag*/));                              \
     return obj;                                                              \
   }                                                                          \
                                                                              \
-  JS_PUBLIC_API ExternalTypeOf<NativeType>::Type* JS_Get##Name##ArrayData(   \
+  JS_PUBLIC_API ExternalType* JS_Get##Name##ArrayData(                       \
       JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&) {     \
     TypedArrayObject* tarr = obj->maybeUnwrapAs<TypedArrayObject>();         \
     if (!tarr) {                                                             \
@@ -2685,7 +2669,7 @@
     }                                                                        \
     MOZ_ASSERT(tarr->type() == TypeIDOfType<NativeType>::id);                \
     *isSharedMemory = tarr->isSharedMemory();                                \
-    return static_cast<ExternalTypeOf<NativeType>::Type*>(                   \
+    return static_cast<ExternalType*>(                                       \
         tarr->dataPointerEither().unwrap(/*safe - caller sees isShared*/));  \
   }
 
@@ -2746,3 +2730,14 @@
 JS_PUBLIC_API size_t JS_MaxMovableTypedArraySize() {
   return TypedArrayObject::INLINE_BUFFER_LIMIT;
 }
+
+namespace JS {
+
+const JSClass* const TypedArray_base::classes = TypedArrayObject::classes;
+
+#define INSTANTIATE(ExternalType, NativeType, Name) \
+  template class TypedArray<js::Scalar::Name>;
+JS_FOR_EACH_TYPED_ARRAY(INSTANTIATE)
+#undef INSTANTIATE
+
+} /* namespace JS */