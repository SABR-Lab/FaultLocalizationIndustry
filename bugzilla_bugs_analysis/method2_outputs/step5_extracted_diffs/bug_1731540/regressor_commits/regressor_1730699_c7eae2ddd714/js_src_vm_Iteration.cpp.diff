# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Iteration.cpp
# Commit: c7eae2ddd714
# Full Hash: c7eae2ddd71487cbb16eeb32e3d0c347206cdd12
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-09-15 15:26:38
# Regressor Bug: 1730699
# File Overlap Count: 1
# Description:
#   Bug 1730699 part 1 - Treat empty iterators for null/undefined as immutable and unlinked. r=jonco
#   
#   This changes the empty iterator objects we create for for-in with null/undefined
#   to be immutable and unlinked.
#   
# ==============================================================================

diff -r 61c4f93eaf75 -r c7eae2ddd714 js/src/vm/Iteration.cpp
--- a/js/src/vm/Iteration.cpp	Wed Sep 15 08:52:32 2021 +0000
+++ b/js/src/vm/Iteration.cpp	Wed Sep 15 09:20:44 2021 +0000
@@ -641,7 +641,9 @@
 
   ObjectRealm& realm = objBeingIterated ? ObjectRealm::get(objBeingIterated)
                                         : ObjectRealm::get(propIter);
-  RegisterEnumerator(realm, ni);
+  if (!ni->isEmptyIteratorSingleton()) {
+    RegisterEnumerator(realm, ni);
+  }
 
   return propIter;
 }
@@ -1289,19 +1291,26 @@
 }
 
 void js::CloseIterator(JSObject* obj) {
-  if (obj->is<PropertyIteratorObject>()) {
-    /* Remove enumerators from the active list, which is a stack. */
-    NativeIterator* ni = obj->as<PropertyIteratorObject>().getNativeIterator();
+  if (!obj->is<PropertyIteratorObject>()) {
+    return;
+  }
 
-    ni->unlink();
+  // Remove iterator from the active list, which is a stack. The shared iterator
+  // used for for-in with null/undefined is immutable and unlinked.
 
-    MOZ_ASSERT(ni->isActive());
-    ni->markInactive();
+  NativeIterator* ni = obj->as<PropertyIteratorObject>().getNativeIterator();
+  if (ni->isEmptyIteratorSingleton()) {
+    return;
+  }
+
+  ni->unlink();
 
-    // Reset the enumerator; it may still be in the cached iterators for
-    // this thread and can be reused.
-    ni->resetPropertyCursorForReuse();
-  }
+  MOZ_ASSERT(ni->isActive());
+  ni->markInactive();
+
+  // Reset the enumerator; it may still be in the cached iterators for
+  // this thread and can be reused.
+  ni->resetPropertyCursorForReuse();
 }
 
 bool js::IteratorCloseForException(JSContext* cx, HandleObject obj) {