# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/Iteration.h
# Commit: c7eae2ddd714
# Full Hash: c7eae2ddd71487cbb16eeb32e3d0c347206cdd12
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2021-09-15 15:26:38
# Regressor Bug: 1730699
# File Overlap Count: 1
# Description:
#   Bug 1730699 part 1 - Treat empty iterators for null/undefined as immutable and unlinked. r=jonco
#   
#   This changes the empty iterator objects we create for for-in with null/undefined
#   to be immutable and unlinked.
#   
# ==============================================================================

diff -r 61c4f93eaf75 -r c7eae2ddd714 js/src/vm/Iteration.h
--- a/js/src/vm/Iteration.h	Wed Sep 15 08:52:32 2021 +0000
+++ b/js/src/vm/Iteration.h	Wed Sep 15 09:20:44 2021 +0000
@@ -270,7 +270,21 @@
     setFlags(Flags::Initialized);
   }
 
+  bool isUnlinked() const { return !prev_ && !next_; }
+
  public:
+  // Whether this is the shared empty iterator object used for iterating over
+  // null/undefined.
+  bool isEmptyIteratorSingleton() const {
+    // Note: equivalent code is inlined in MacroAssembler::iteratorClose.
+    bool res = objectBeingIterated() == nullptr;
+    MOZ_ASSERT_IF(res, flags() == Flags::Initialized);
+    MOZ_ASSERT_IF(res, initialPropertyCount() == 0);
+    MOZ_ASSERT_IF(res, shapeCount() == 0);
+    MOZ_ASSERT_IF(res, isUnlinked());
+    return res;
+  }
+
   bool isActive() const {
     MOZ_ASSERT(isInitialized());
 
@@ -279,12 +293,14 @@
 
   void markActive() {
     MOZ_ASSERT(isInitialized());
+    MOZ_ASSERT(!isEmptyIteratorSingleton());
 
     flagsAndCount_ |= Flags::Active;
   }
 
   void markInactive() {
     MOZ_ASSERT(isInitialized());
+    MOZ_ASSERT(!isEmptyIteratorSingleton());
 
     flagsAndCount_ &= ~Flags::Active;
   }
@@ -302,6 +318,7 @@
 
   void markHasUnvisitedPropertyDeletion() {
     MOZ_ASSERT(isInitialized());
+    MOZ_ASSERT(!isEmptyIteratorSingleton());
 
     flagsAndCount_ |= Flags::HasUnvisitedPropertyDeletion;
   }
@@ -312,8 +329,12 @@
     // initialized.
     MOZ_ASSERT(isInitialized());
 
-    /* A NativeIterator cannot appear in the enumerator list twice. */
-    MOZ_ASSERT(!next_ && !prev_);
+    // The shared iterator used for for-in with null/undefined is immutable and
+    // shouldn't be linked.
+    MOZ_ASSERT(!isEmptyIteratorSingleton());
+
+    // A NativeIterator cannot appear in the enumerator list twice.
+    MOZ_ASSERT(isUnlinked());
 
     this->next_ = other;
     this->prev_ = other->prev_;
@@ -322,6 +343,7 @@
   }
   void unlink() {
     MOZ_ASSERT(isInitialized());
+    MOZ_ASSERT(!isEmptyIteratorSingleton());
 
     next_->prev_ = prev_;
     prev_->next_ = next_;