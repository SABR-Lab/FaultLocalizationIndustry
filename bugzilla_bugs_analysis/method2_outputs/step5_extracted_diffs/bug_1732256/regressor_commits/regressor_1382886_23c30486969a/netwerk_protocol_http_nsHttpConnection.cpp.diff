# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/nsHttpConnection.cpp
# Commit: 23c30486969a
# Full Hash: 23c30486969a19c46ccc5dba83ddb66121d1d9af
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2021-08-17 16:03:11
# Regressor Bug: 1382886
# File Overlap Count: 1
# Description:
#   Bug 1382886 - Poll for READ during 0RTT r=necko-reviewers,valentin
#   
#   Polling for write will in most cases always return immediately which causes necko to basically busy wait for the handshake to finish. To avoid thiis we will poll for READ and call OnSocketWritable to drive the haandshake.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D122582
# ==============================================================================

diff -r 72ef88010a59 -r 23c30486969a netwerk/protocol/http/nsHttpConnection.cpp
--- a/netwerk/protocol/http/nsHttpConnection.cpp	Tue Aug 17 06:55:08 2021 +0000
+++ b/netwerk/protocol/http/nsHttpConnection.cpp	Tue Aug 17 08:19:15 2021 +0000
@@ -1924,8 +1924,12 @@
     }
 
     if (!again && mWaitingFor0RTTResponse) {
-      // Continue waiting;
-      rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
+      // Continue waiting; In case of 0RTT we want to poll for READ. We need
+      // to poll the socket to be able to drive the handshake, but we do not
+      // want to poll for WRITE because during 0RTT we can write data, but
+      // we do not want to write data.
+      // (see https://bugzilla.mozilla.org/show_bug.cgi?id=1382886#c38)
+      rv = mSocketIn->AsyncWait(this, 0, 0, nullptr);
     }
     if (NS_FAILED(rv)) {
       // if the transaction didn't want to write any more data, then
@@ -1933,8 +1937,12 @@
       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
         rv = NS_OK;
         if (mWaitingFor0RTTResponse) {
-          // Continue waiting;
-          rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
+          // Continue waiting; In case of 0RTT we want to poll for READ. We
+          // need to poll the socket to be able to drive the handshake, but
+          // we do not want to poll for WRITE because during 0RTT we can
+          // write data, but we do not want to write data.
+          // (see https://bugzilla.mozilla.org/show_bug.cgi?id=1382886#c38)
+          rv = mSocketIn->AsyncWait(this, 0, 0, nullptr);
         }
       }
       again = false;
@@ -1955,7 +1963,12 @@
 
       if (mWaitingFor0RTTResponse) {
         // Wait for tls handshake to finish or waiting for connect.
-        rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
+        // In case of 0RTT we want to poll for READ. We need
+        // to poll the socket to be able to drive the handshake, but we do not
+        // want to poll for WRITE because during 0RTT we can write data, but
+        // we do not want to write data.
+        // (see https://bugzilla.mozilla.org/show_bug.cgi?id=1382886#c38)
+        rv = mSocketIn->AsyncWait(this, 0, 0, nullptr);
       } else if (mTransaction) {  // in case the ReadSegments stack called
                                   // CloseTransaction()
         //
@@ -2413,7 +2426,13 @@
     return NS_OK;
   }
 
-  nsresult rv = OnSocketReadable();
+  nsresult rv = NS_OK;
+  if (mWaitingFor0RTTResponse) {
+    // During 0RTT we poll for READ but we want actually to write
+    rv = OnSocketWritable();
+  } else {
+    rv = OnSocketReadable();
+  }
   if (NS_FAILED(rv)) CloseTransaction(mTransaction, rv);
 
   return NS_OK;
