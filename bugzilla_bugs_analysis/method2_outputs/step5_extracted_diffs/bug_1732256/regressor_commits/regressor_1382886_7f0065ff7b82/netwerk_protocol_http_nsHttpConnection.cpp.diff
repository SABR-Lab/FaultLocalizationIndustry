# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/nsHttpConnection.cpp
# Commit: 7f0065ff7b82
# Full Hash: 7f0065ff7b8200c193d0986f1ce2fa3f30d4a99d
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2021-09-22 15:53:06
# Regressor Bug: 1382886
# File Overlap Count: 1
# Description:
#   Bug 1382886 - Fix fuzzing build, also we cannot set SecurityInfo during read r=necko-reviewers,kershaw
#   
#   Before this bug TLS handshake was only driven by forcing writes. SecurtyInfo was set during a write code path. That is not anymore true and the TLS handshake can be driven by reading from a socket. That causes an issue where the SecurtyInfo was not set in case a TLS handshake fails. This bug added the setting of the SecurtyInfo to the read code path, but that causes problems when the transaction is closed due to corrupted response.
#   This patch fixes this by moving the setting of SecurtyInfo to Close() function.
#   
# ==============================================================================

diff -r 4150724f355f -r 7f0065ff7b82 netwerk/protocol/http/nsHttpConnection.cpp
--- a/netwerk/protocol/http/nsHttpConnection.cpp	Wed Sep 22 09:19:32 2021 +0000
+++ b/netwerk/protocol/http/nsHttpConnection.cpp	Wed Sep 22 09:19:32 2021 +0000
@@ -517,7 +517,9 @@
       mTransaction->Close(NS_ERROR_NET_RESET);
     }
     mContentBytesWritten0RTT = 0;
-    Reset0RttForSpdy();
+    if (mDid0RTTSpdy) {
+      Reset0RttForSpdy();
+    }
   }
   mEarlyDataState = EarlyData::DONE;
 
@@ -536,7 +538,7 @@
 }
 
 void nsHttpConnection::Reset0RttForSpdy() {
-   // Reset the work done by Start0RTTSpdy
+  // Reset the work done by Start0RTTSpdy
   mUsingSpdyVersion = SpdyVersion::NONE;
   mTransaction = nullptr;
   mSpdySession = nullptr;
@@ -816,7 +818,7 @@
        static_cast<uint32_t>(reason)));
 
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
-
+  mTlsHandshakeComplitionPending = false;
   // Ensure TCP keepalive timer is stopped.
   if (mTCPKeepaliveTransitionTimer) {
     mTCPKeepaliveTransitionTimer->Cancel();
@@ -2523,8 +2525,10 @@
   NS_DispatchToCurrentThread(NS_NewRunnableFunction(
       "nsHttpConnection::HandshakeDoneInternal",
       [self{std::move(self)}]() {
-        self->HandshakeDoneInternal();
-        self->mTlsHandshakeComplitionPending = false;
+        if (self->mTlsHandshakeComplitionPending) {
+          self->HandshakeDoneInternal();
+          self->mTlsHandshakeComplitionPending = false;
+        }
       }));
   return NS_OK;
 }