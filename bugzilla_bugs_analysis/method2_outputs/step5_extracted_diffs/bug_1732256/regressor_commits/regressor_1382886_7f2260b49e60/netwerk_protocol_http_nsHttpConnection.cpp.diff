# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/nsHttpConnection.cpp
# Commit: 7f2260b49e60
# Full Hash: 7f2260b49e600771c1cbbd6cd1360dd4a328a871
# Author: Dragana Damjanovic <dd.mozilla@gmail.com>
# Date: 2021-09-17 21:50:08
# Regressor Bug: 1382886
# File Overlap Count: 1
# Description:
#   Bug 1382886 - Use HandshakeDone to signal that a handshake is done r=necko-reviewers,keeler,kershaw
#   
#   HandshakeDone will be called after a handshake is finished and also after the certificate verifications are done.
#   The code relies on HandshakeDone to signal that the handshake is done. When early-data is not available HandshakeDone is responsible for setting up a Http2 session if needed. There are 2 outcomes when early-data is used:
#   1) early-data is accepted and transaction continues polling for read,
# ==============================================================================

diff -r 0c049a8ee4a8 -r 7f2260b49e60 netwerk/protocol/http/nsHttpConnection.cpp
--- a/netwerk/protocol/http/nsHttpConnection.cpp	Fri Sep 17 13:19:01 2021 +0000
+++ b/netwerk/protocol/http/nsHttpConnection.cpp	Fri Sep 17 13:19:01 2021 +0000
@@ -436,10 +436,8 @@
   }
 }
 
+// Checks if TLS handshake is needed and it is responsible to move it forward.
 bool nsHttpConnection::EnsureNPNComplete() {
-  // If for some reason the components to check on NPN aren't available,
-  // this function will just return true to continue on and disable SPDY
-
   MOZ_ASSERT(mSocketTransport);
   if (!mSocketTransport) {
     // this cannot happen
@@ -453,22 +451,16 @@
 
   nsresult rv = NS_OK;
   nsCOMPtr<nsISupports> securityInfo;
-  nsCOMPtr<nsITransportSecurityInfo> info;
-  nsCOMPtr<nsISSLSocketControl> ssl;
-  nsAutoCString negotiatedNPN;
-  // This is needed for telemetry
-  bool handshakeSucceeded = false;
-
   GetSecurityInfo(getter_AddRefs(securityInfo));
   if (!securityInfo) {
-    goto npnComplete;
+    FinishNPNSetup(false, false);
+    return true;
   }
 
-  ssl = do_QueryInterface(securityInfo, &rv);
-  if (NS_FAILED(rv)) goto npnComplete;
-
-  info = do_QueryInterface(securityInfo, &rv);
-  if (NS_FAILED(rv)) goto npnComplete;
+  nsCOMPtr<nsISSLSocketControl> ssl = do_QueryInterface(securityInfo, &rv);
+  if (NS_FAILED(rv)) {
+    FinishNPNSetup(false, false);
+  }
 
   if (!m0RTTChecked) {
     // We reuse m0RTTChecked. We want to send this status only once.
@@ -476,92 +468,18 @@
                                     NS_NET_STATUS_TLS_HANDSHAKE_STARTING, 0);
   }
 
-  rv = info->GetNegotiatedNPN(negotiatedNPN);
-  if (rv == NS_ERROR_NOT_CONNECTED) {
-    rv = ssl->DriveHandshake();
-    if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) {
-      goto npnComplete;
-    }
-
-    // Check again, maybe the handshake is done now.
-    rv = info->GetNegotiatedNPN(negotiatedNPN);
-  }
-
-  if (rv == NS_ERROR_NOT_CONNECTED) {
-    Check0RttEnabled(ssl);
-    return mWaitingFor0RTTResponse;
+  LOG(("nsHttpConnection::EnsureNPNComplete [this=%p] drive TLS handshake",
+       this));
+  rv = ssl->DriveHandshake();
+  if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) {
+    FinishNPNSetup(false, true);
   }
 
-  if (NS_SUCCEEDED(rv)) {
-    LOG1(("nsHttpConnection::EnsureNPNComplete %p [%s] negotiated to '%s'%s\n",
-          this, mConnInfo->HashKey().get(), negotiatedNPN.get(),
-          mTLSFilter ? " [Double Tunnel]" : ""));
-
-    handshakeSucceeded = true;
-
-    int16_t tlsVersion;
-    ssl->GetSSLVersionUsed(&tlsVersion);
-    mConnInfo->SetLessThanTls13(
-        (tlsVersion < nsISSLSocketControl::TLS_VERSION_1_3) &&
-        (tlsVersion != nsISSLSocketControl::SSL_VERSION_UNKNOWN));
-
-    bool earlyDataAccepted = false;
-    if (mWaitingFor0RTTResponse) {
-      // Check if early data has been accepted.
-      nsresult rvEarlyData = ssl->GetEarlyDataAccepted(&earlyDataAccepted);
-      LOG(
-          ("nsHttpConnection::EnsureNPNComplete [this=%p] - early data "
-           "that was sent during 0RTT %s been accepted [rv=%" PRIx32 "].",
-           this, earlyDataAccepted ? "has" : "has not",
-           static_cast<uint32_t>(rv)));
-
-      if (NS_FAILED(rvEarlyData) ||
-          NS_FAILED(mTransaction->Finish0RTT(
-              !earlyDataAccepted, negotiatedNPN != mEarlyNegotiatedALPN))) {
-        LOG(
-            ("nsHttpConection::EnsureNPNComplete [this=%p] closing transaction "
-             "%p",
-             this, mTransaction.get()));
-        mTransaction->Close(NS_ERROR_NET_RESET);
-        goto npnComplete;
-      }
-    }
+  Check0RttEnabled(ssl);
+  return false;
+}
 
-    EarlyDataTelemetry(tlsVersion, earlyDataAccepted);
-    mWaitingFor0RTTResponse = false;
-
-    if (!earlyDataAccepted) {
-      LOG(
-          ("nsHttpConnection::EnsureNPNComplete [this=%p] early data not "
-           "accepted",
-           this));
-
-      uint32_t infoIndex;
-      const SpdyInformation* info = gHttpHandler->SpdyInfo();
-      if (NS_SUCCEEDED(info->GetNPNIndex(negotiatedNPN, &infoIndex))) {
-        StartSpdy(ssl, info->Version[infoIndex]);
-      }
-    } else {
-      LOG(("nsHttpConnection::EnsureNPNComplete [this=%p] - %" PRId64 " bytes "
-           "has been sent during 0RTT.",
-           this, mContentBytesWritten0RTT));
-      mContentBytesWritten = mContentBytesWritten0RTT;
-      if (mSpdySession) {
-        // We had already started 0RTT-spdy, now we need to fully set up
-        // spdy, since we know we're sticking with it.
-        LOG(
-            ("nsHttpConnection::EnsureNPNComplete [this=%p] - finishing "
-             "StartSpdy for 0rtt spdy session %p",
-             this, mSpdySession.get()));
-        StartSpdy(ssl, mSpdySession->SpdyVersion());
-      }
-    }
-    Telemetry::Accumulate(Telemetry::SPDY_NPN_CONNECT, UsingSpdy());
-  }
-
-npnComplete:
-  LOG(("nsHttpConnection::EnsureNPNComplete [this=%p] setting complete to true",
-       this));
+void nsHttpConnection::FinishNPNSetup(bool handshakeSucceeded, bool hasSecurityInfo) {
   mNPNComplete = true;
 
   mTransaction->OnTransportStatus(mSocketTransport,
@@ -578,35 +496,23 @@
         mTransaction->QueryNullTransaction()->GetTcpConnectEnd();
   }
 
-  if (securityInfo) {
+  if (hasSecurityInfo) {
     mBootstrappedTimings.connectEnd = TimeStamp::Now();
   }
 
   if (mWaitingFor0RTTResponse) {
     // Didn't get 0RTT OK, back out of the "attempting 0RTT" state
     mWaitingFor0RTTResponse = false;
-    LOG(("nsHttpConnection::EnsureNPNComplete [this=%p] 0rtt failed", this));
+    LOG(("nsHttpConnection::FinishNPNSetup [this=%p] 0rtt failed", this));
     if (NS_FAILED(mTransaction->Finish0RTT(
-            true, negotiatedNPN != mEarlyNegotiatedALPN))) {
+            true, true))) {
       mTransaction->Close(NS_ERROR_NET_RESET);
     }
     mContentBytesWritten0RTT = 0;
+    Reset0RttForSpdy();
   }
 
-  if (mDid0RTTSpdy && negotiatedNPN != mEarlyNegotiatedALPN) {
-    // Reset the work done by Start0RTTSpdy
-    LOG((
-        "nsHttpConnection::EnsureNPNComplete [this=%p] resetting Start0RTTSpdy",
-        this));
-    mUsingSpdyVersion = SpdyVersion::NONE;
-    mTransaction = nullptr;
-    mSpdySession = nullptr;
-    // We have to reset this here, just in case we end up starting spdy again,
-    // so it can actually do everything it needs to do.
-    mDid0RTTSpdy = false;
-  }
-
-  if (ssl) {
+  if (hasSecurityInfo) {
     // Telemetry for tls failure rate with and without esni;
     bool echConfigUsed = false;
     mSocketTransport->GetEchConfigUsed(&echConfigUsed);
@@ -618,12 +524,16 @@
                                   : TlsHandshakeResult::NoEchConfigFailed);
     Telemetry::Accumulate(Telemetry::ECHCONFIG_SUCCESS_RATE, result);
   }
+}
 
-  if (rv == psm::GetXPCOMFromNSSError(
-                mozilla::pkix::MOZILLA_PKIX_ERROR_MITM_DETECTED)) {
-    gSocketTransportService->SetNotTrustedMitmDetected();
-  }
-  return true;
+void nsHttpConnection::Reset0RttForSpdy() {
+   // Reset the work done by Start0RTTSpdy
+  mUsingSpdyVersion = SpdyVersion::NONE;
+  mTransaction = nullptr;
+  mSpdySession = nullptr;
+  // We have to reset this here, just in case we end up starting spdy again,
+  // so it can actually do everything it needs to do.
+  mDid0RTTSpdy = false;
 }
 
 nsresult nsHttpConnection::OnTunnelNudged(TLSFilterTransaction* trans) {
@@ -916,6 +826,16 @@
     }
   }
 
+  nsCOMPtr<nsISupports> securityInfo;
+  GetSecurityInfo(getter_AddRefs(securityInfo));
+  if (securityInfo) {
+    nsresult rv;
+    nsCOMPtr<nsISSLSocketControl> ssl = do_QueryInterface(securityInfo, &rv);
+    if (NS_SUCCEEDED(rv)) {
+      ssl->SetHandshakeCallbackListener(nullptr);
+    }
+  }
+
   if (NS_FAILED(reason)) {
     if (mIdleMonitoring) EndIdleMonitoring();
 
@@ -988,7 +908,8 @@
     }
   }
 
-  if (NS_SUCCEEDED(SetupNPNList(ssl, mTransactionCaps))) {
+  if (NS_SUCCEEDED(SetupNPNList(ssl, mTransactionCaps)) &&
+      NS_SUCCEEDED(ssl->SetHandshakeCallbackListener(this))) {
     LOG(("InitSSLParams Setting up SPDY Negotiation OK"));
     mNPNComplete = false;
   }
@@ -1850,9 +1771,9 @@
     // transaction->readsegments() processing can proceed because we need to
     // know how to format the request differently for http/1, http/2, spdy,
     // etc.. and that is negotiated with NPN/ALPN in the SSL handshake.
-
     if (mConnInfo->UsingHttpsProxy() &&
         !EnsureNPNComplete()) {
+      MOZ_DIAGNOSTIC_ASSERT(!mWaitingFor0RTTResponse);
       mSocketOutCondition = NS_BASE_STREAM_WOULD_BLOCK;
     } else if (mProxyConnectStream) {
       // If we're need an HTTP/1 CONNECT tunnel through a proxy
@@ -1861,7 +1782,7 @@
       rv = mProxyConnectStream->ReadSegments(ReadFromStream, this,
                                              nsIOService::gDefaultSegmentSize,
                                              &transactionBytes);
-    } else if (!EnsureNPNComplete()) {
+    } else if (!EnsureNPNComplete() && !mWaitingFor0RTTResponse) {
       mSocketOutCondition = NS_BASE_STREAM_WOULD_BLOCK;
     } else if (!mTransaction) {
       rv = NS_ERROR_FAILURE;
@@ -1881,6 +1802,11 @@
           this, nsIOService::gDefaultSegmentSize, &transactionBytes, &again);
       if (mWaitingFor0RTTResponse) {
         mContentBytesWritten0RTT += transactionBytes;
+        if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) {
+          // If an error happens while writting 0RTT data, restart
+          // the transactiions without 0RTT.
+          FinishNPNSetup(false, true);
+        }
       } else {
         mContentBytesWritten += transactionBytes;
       }
@@ -1899,19 +1825,11 @@
       transactionBytes = 0;
     }
 
-    if (!again && mWaitingFor0RTTResponse) {
-      // Continue waiting;
-      rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
-    }
     if (NS_FAILED(rv)) {
       // if the transaction didn't want to write any more data, then
       // wait for the transaction to call ResumeSend.
       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
         rv = NS_OK;
-        if (mWaitingFor0RTTResponse) {
-          // Continue waiting;
-          rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
-        }
       }
       again = false;
     } else if (NS_FAILED(mSocketOutCondition)) {
@@ -1929,11 +1847,8 @@
     } else if (!transactionBytes) {
       rv = NS_OK;
 
-      if (mWaitingFor0RTTResponse) {
-        // Wait for tls handshake to finish or waiting for connect.
-        rv = mSocketOut->AsyncWait(this, 0, 0, nullptr);
-      } else if (mTransaction) {  // in case the ReadSegments stack called
-                                  // CloseTransaction()
+      if (mTransaction) {  // in case the ReadSegments stack called
+                           // CloseTransaction()
         //
         // at this point we've written out the entire transaction, and now we
         // must wait for the server's response.  we manufacture a status message
@@ -2020,7 +1935,7 @@
   bool again = true;
 
   do {
-    if (!mProxyConnectInProgress && !mNPNComplete) {
+    if (!mProxyConnectInProgress && !EnsureNPNComplete()) {
       // Unless we are setting up a tunnel via CONNECT, prevent reading
       // from the socket until the results of NPN
       // negotiation are known (which is determined from the write path).
@@ -2032,7 +1947,7 @@
           ("nsHttpConnection::OnSocketReadable %p return due to inactive "
            "tunnel setup but incomplete NPN state\n",
            this));
-      rv = NS_OK;
+      rv = ResumeRecv();
       break;
     }
 
@@ -2582,6 +2497,112 @@
 
 NS_IMETHODIMP
 nsHttpConnection::HandshakeDone() {
+  if (mNPNComplete) {
+    return NS_OK;
+  }
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsISupports> securityInfo;
+  nsCOMPtr<nsITransportSecurityInfo> info;
+  nsCOMPtr<nsISSLSocketControl> ssl;
+  nsAutoCString negotiatedNPN;
+
+  GetSecurityInfo(getter_AddRefs(securityInfo));
+  if (!securityInfo) {
+    FinishNPNSetup(false, false);
+    return NS_OK;
+  }
+
+  ssl = do_QueryInterface(securityInfo, &rv);
+  if (NS_FAILED(rv)) {
+    FinishNPNSetup(false, false);
+    return NS_OK;
+  }
+
+  info = do_QueryInterface(securityInfo, &rv);
+  if (NS_FAILED(rv)) {
+    FinishNPNSetup(false, false);
+    return NS_OK;
+  }
+
+  DebugOnly<nsresult> rvDebug = info->GetNegotiatedNPN(negotiatedNPN);
+  MOZ_ASSERT(NS_SUCCEEDED(rvDebug));
+
+  bool earlyDataAccepted = false;
+  if (mWaitingFor0RTTResponse) {
+    // Check if early data has been accepted.
+    nsresult rvEarlyData = ssl->GetEarlyDataAccepted(&earlyDataAccepted);
+    LOG(
+        ("nsHttpConnection::HandshakeDone [this=%p] - early data "
+         "that was sent during 0RTT %s been accepted [rv=%" PRIx32 "].",
+         this, earlyDataAccepted ? "has" : "has not",
+         static_cast<uint32_t>(rv)));
+
+    if (NS_FAILED(rvEarlyData) ||
+        NS_FAILED(mTransaction->Finish0RTT(
+            !earlyDataAccepted, negotiatedNPN != mEarlyNegotiatedALPN))) {
+      LOG(
+          ("nsHttpConection::HandshakeDone [this=%p] closing transaction "
+           "%p",
+           this, mTransaction.get()));
+      mTransaction->Close(NS_ERROR_NET_RESET);
+      FinishNPNSetup(false, true);
+      return NS_OK;
+    }
+    if (mDid0RTTSpdy && (negotiatedNPN != mEarlyNegotiatedALPN)) {
+      Reset0RttForSpdy();
+    }
+    if (!earlyDataAccepted) {
+      // We need to start from the begining here and start writing
+      // the request again.
+      if (mSocketIn) {
+        mSocketIn->AsyncWait(nullptr, 0, 0, nullptr);
+      }
+      Unused << ResumeSend();
+    }
+  }
+
+  int16_t tlsVersion;
+  ssl->GetSSLVersionUsed(&tlsVersion);
+  mConnInfo->SetLessThanTls13(
+      (tlsVersion < nsISSLSocketControl::TLS_VERSION_1_3) &&
+      (tlsVersion != nsISSLSocketControl::SSL_VERSION_UNKNOWN));
+
+  EarlyDataTelemetry(tlsVersion, earlyDataAccepted);
+
+  if (!earlyDataAccepted) {
+    LOG(
+        ("nsHttpConnection::HandshakeDone [this=%p] early data not "
+         "accepted or early data were not used",
+         this));
+
+    uint32_t infoIndex;
+    const SpdyInformation* info = gHttpHandler->SpdyInfo();
+    if (NS_SUCCEEDED(info->GetNPNIndex(negotiatedNPN, &infoIndex))) {
+      StartSpdy(ssl, info->Version[infoIndex]);
+    }
+  } else {
+    LOG(("nsHttpConnection::HandshakeDone [this=%p] - %" PRId64 " bytes "
+         "has been sent during 0RTT.",
+         this, mContentBytesWritten0RTT));
+    mContentBytesWritten = mContentBytesWritten0RTT;
+
+    if (mSpdySession) {
+      // We had already started 0RTT-spdy, now we need to fully set up
+      // spdy, since we know we're sticking with it.
+      LOG(
+          ("nsHttpConnection::HandshakeDone [this=%p] - finishing "
+           "StartSpdy for 0rtt spdy session %p",
+           this, mSpdySession.get()));
+      StartSpdy(ssl, mSpdySession->SpdyVersion());
+    }
+  }
+
+  Telemetry::Accumulate(Telemetry::SPDY_NPN_CONNECT, UsingSpdy());
+
+  mWaitingFor0RTTResponse = false;
+
+  FinishNPNSetup(true, true);
   return NS_OK;
 }
 