# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/LocalAccessible.cpp
# Commit: 6591f14bbc71
# Full Hash: 6591f14bbc713f11b6316712d931ecc19a443a5c
# Author: Morgan Reschenberg <mreschenberg@mozilla.com>
# Date: 2021-10-05 03:52:32
# Regressor Bug: 1726227
# File Overlap Count: 1
# Description:
#   Bug 1726227: Cache parent-relative accessible bounds, resolution in parent process r=Jamie,eeejay
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D123399
# ==============================================================================

diff -r 06dda9072cb7 -r 6591f14bbc71 accessible/generic/LocalAccessible.cpp
--- a/accessible/generic/LocalAccessible.cpp	Mon Oct 04 19:28:49 2021 +0000
+++ b/accessible/generic/LocalAccessible.cpp	Mon Oct 04 19:46:54 2021 +0000
@@ -115,6 +115,7 @@
       mDoc(aDoc),
       mParent(nullptr),
       mIndexInParent(-1),
+      mBounds(),
       mStateFlags(0),
       mContextFlags(0),
       mReorderEventTarget(false),
@@ -618,6 +619,62 @@
   return accessible;
 }
 
+nsRect LocalAccessible::ParentRelativeBounds() {
+  nsIFrame* boundingFrame = nullptr;
+  nsIFrame* frame = GetFrame();
+  if (frame && mContent) {
+    if (mContent->GetProperty(nsGkAtoms::hitregion) && mContent->IsElement()) {
+      // This is for canvas fallback content
+      // Find a canvas frame the found hit region is relative to.
+      nsIFrame* canvasFrame = frame->GetParent();
+      if (canvasFrame) {
+        canvasFrame = nsLayoutUtils::GetClosestFrameOfType(
+            canvasFrame, LayoutFrameType::HTMLCanvas);
+      }
+
+      if (canvasFrame) {
+        if (auto* canvas =
+                dom::HTMLCanvasElement::FromNode(canvasFrame->GetContent())) {
+          if (auto* context = canvas->GetCurrentContext()) {
+            nsRect bounds;
+            if (context->GetHitRegionRect(mContent->AsElement(), bounds)) {
+              return bounds;
+            }
+          }
+        }
+      }
+    }
+
+    if (mParent) {
+      boundingFrame = mParent->GetFrame();
+    }
+
+    if (!boundingFrame) {
+      // if we can't get the bounding frame, use the pres shell root
+      boundingFrame = nsLayoutUtils::GetContainingBlockForClientRect(frame);
+    }
+
+    nsRect unionRect = nsLayoutUtils::GetAllInFlowRectsUnion(
+        frame, boundingFrame, nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS);
+
+    if (unionRect.IsEmpty()) {
+      // If we end up with a 0x0 rect from above (or one with negative
+      // height/width) we should try using the ink overflow rect instead. If we
+      // use this rect, our relative bounds will match the bounds of what
+      // appears visually. We do this because some web authors (icloud.com for
+      // example) employ things like 0x0 buttons with visual overflow. Without
+      // this, such frames aren't navigable by screen readers.
+      nsRect overflow = frame->InkOverflowRectRelativeToSelf();
+      nsLayoutUtils::TransformRect(frame, boundingFrame, overflow);
+      return overflow;
+    }
+
+    return unionRect;
+  }
+
+  return nsRect();
+}
+
 nsRect LocalAccessible::RelativeBounds(nsIFrame** aBoundingFrame) const {
   nsIFrame* frame = GetFrame();
   if (frame && mContent) {
@@ -3053,6 +3110,23 @@
     fields->SetAttribute(nsGkAtoms::step, Step());
   }
 
+  if (aCacheDomain & CacheDomain::Bounds) {
+    nsRect newBoundsRect = ParentRelativeBounds();
+
+    if (mBounds.isNothing() || !newBoundsRect.IsEqualEdges(mBounds.value())) {
+      mBounds = Some(newBoundsRect);
+
+      nsTArray<int32_t> boundsArray(4);
+
+      boundsArray.AppendElement(newBoundsRect.x);
+      boundsArray.AppendElement(newBoundsRect.y);
+      boundsArray.AppendElement(newBoundsRect.width);
+      boundsArray.AppendElement(newBoundsRect.height);
+
+      fields->SetAttribute(nsGkAtoms::relativeBounds, std::move(boundsArray));
+    }
+  }
+
   return fields.forget();
 }
 