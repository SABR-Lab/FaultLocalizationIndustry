# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/HelperThreads.cpp
# Commit: 2bc5949902ac
# Full Hash: 2bc5949902acc042205fc7e85260bbbc37dbedc7
# Author: Matthew Gaudet <mgaudet@mozilla.com>
# Date: 2021-09-18 09:46:57
# Regressor Bug: 1688788
# File Overlap Count: 1
# Description:
#   Bug 1688788 - Convert ScriptPreloader to manage Stencils, not Scripts. r=kmag,tcampbell
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D113013
# ==============================================================================

diff -r e660e2c3c3d1 -r 2bc5949902ac js/src/vm/HelperThreads.cpp
--- a/js/src/vm/HelperThreads.cpp	Sat Sep 18 01:29:45 2021 +0000
+++ b/js/src/vm/HelperThreads.cpp	Sat Sep 18 01:29:45 2021 +0000
@@ -20,13 +20,15 @@
 #include "gc/GC.h"                        // gc::MergeRealms
 #include "jit/IonCompileTask.h"
 #include "jit/JitRuntime.h"
-#include "js/ContextOptions.h"      // JS::ContextOptions
+#include "js/ContextOptions.h"  // JS::ContextOptions
+#include "js/experimental/JSStencil.h"
 #include "js/friend/StackLimits.h"  // js::ReportOverRecursed
 #include "js/GlobalObject.h"
 #include "js/HelperThreadAPI.h"
 #include "js/OffThreadScriptCompilation.h"  // JS::OffThreadToken, JS::OffThreadCompileCallback
 #include "js/SourceText.h"
 #include "js/Stack.h"
+#include "js/Transcoding.h"
 #include "js/UniquePtr.h"
 #include "js/Utility.h"
 #include "threading/CpuCount.h"
@@ -895,17 +897,16 @@
   }
 }
 
-MultiScriptsDecodeTask::MultiScriptsDecodeTask(
+MultiStencilsDecodeTask::MultiStencilsDecodeTask(
     JSContext* cx, JS::TranscodeSources& sources,
     JS::OffThreadCompileCallback callback, void* callbackData)
-    : ParseTask(ParseTaskKind::MultiScriptsDecode, cx, callback, callbackData),
+    : ParseTask(ParseTaskKind::MultiStencilsDecode, cx, callback, callbackData),
       sources(&sources) {}
 
-void MultiScriptsDecodeTask::parse(JSContext* cx) {
+void MultiStencilsDecodeTask::parse(JSContext* cx) {
   MOZ_ASSERT(cx->isHelperThreadContext());
 
-  if (!scripts.reserve(sources->length()) ||
-      !sourceObjects.reserve(sources->length())) {
+  if (!stencils.reserve(sources->length())) {
     ReportOutOfMemory(cx);  // This sets |outOfMemory|.
     return;
   }
@@ -914,26 +915,14 @@
     CompileOptions opts(cx, options);
     opts.setFileAndLine(source.filename, source.lineno);
 
-    RootedScript resultScript(cx);
-    Rooted<ScriptSourceObject*> sourceObject(cx);
-
-    auto decoder = js::MakeUnique<XDROffThreadDecoder>(
-        cx, &opts, XDROffThreadDecoder::Type::Multi, &sourceObject.get(),
-        source.range);
-    if (!decoder) {
-      ReportOutOfMemory(cx);
-      return;
+    RefPtr<JS::Stencil> stencil;
+    if (JS::DecodeStencil(cx, options, source.range, getter_AddRefs(stencil)) !=
+        JS::TranscodeResult::Ok) {
+      break;
     }
 
-    mozilla::DebugOnly<XDRResult> res = decoder->codeScript(&resultScript);
-    MOZ_ASSERT(bool(resultScript) == static_cast<const XDRResult&>(res).isOk());
-
-    if (sourceObject) {
-      sourceObjects.infallibleAppend(sourceObject);
-    }
-
-    if (resultScript) {
-      scripts.infallibleAppend(resultScript);
+    if (stencil) {
+      stencils.infallibleEmplaceBack(stencil.forget());
     } else {
       // If any decodes fail, don't process the rest. We likely are hitting OOM.
       break;
@@ -1312,25 +1301,17 @@
   return StartOffThreadParseTask(cx, std::move(task), options);
 }
 
-JS::OffThreadToken* js::StartOffThreadDecodeMultiScripts(
+JS::OffThreadToken* js::StartOffThreadDecodeMultiStencils(
     JSContext* cx, const ReadOnlyCompileOptions& options,
     JS::TranscodeSources& sources, JS::OffThreadCompileCallback callback,
     void* callbackData) {
-  auto task = cx->make_unique<MultiScriptsDecodeTask>(cx, sources, callback,
-                                                      callbackData);
+  auto task = cx->make_unique<MultiStencilsDecodeTask>(cx, sources, callback,
+                                                       callbackData);
   if (!task) {
     return nullptr;
   }
 
-  // NOTE: All uses of DecodeMulti are currently generated by non-incremental
-  //       XDR and therefore do not support the stencil format. As a result,
-  //       they must continue to use the off-thread-parse-global in order to
-  //       decode.
-  CompileOptions optionsCopy(cx, options);
-  optionsCopy.useStencilXDR = false;
-  optionsCopy.useOffThreadParseGlobal = true;
-
-  return StartOffThreadParseTask(cx, std::move(task), optionsCopy);
+  return StartOffThreadParseTask(cx, std::move(task), options);
 }
 
 void js::EnqueuePendingParseTasksAfterGC(JSRuntime* rt) {
@@ -2313,46 +2294,35 @@
 
 bool GlobalHelperThreadState::finishMultiParseTask(
     JSContext* cx, ParseTaskKind kind, JS::OffThreadToken* token,
-    MutableHandle<ScriptVector> scripts) {
+    mozilla::Vector<RefPtr<JS::Stencil>>* stencils) {
+  MOZ_ASSERT(stencils);
   Rooted<UniquePtr<ParseTask>> parseTask(
       cx, finishParseTaskCommon(cx, kind, token));
   if (!parseTask) {
     return false;
   }
 
-  MOZ_ASSERT(parseTask->kind == ParseTaskKind::MultiScriptsDecode);
-  auto task = static_cast<MultiScriptsDecodeTask*>(parseTask.get().get());
+  MOZ_ASSERT(parseTask->kind == ParseTaskKind::MultiStencilsDecode);
+  auto task = static_cast<MultiStencilsDecodeTask*>(parseTask.get().get());
   size_t expectedLength = task->sources->length();
 
-  if (!scripts.reserve(parseTask->scripts.length())) {
+  if (!stencils->reserve(parseTask->stencils.length())) {
     ReportOutOfMemory(cx);
     return false;
   }
 
-  for (auto& script : parseTask->scripts) {
-    scripts.infallibleAppend(script);
+  for (auto& stencil : parseTask->stencils) {
+    stencils->infallibleEmplaceBack(stencil.forget());
   }
 
-  if (scripts.length() != expectedLength) {
-    // No error was reported, but fewer scripts produced than expected.
+  if (stencils->length() != expectedLength) {
+    // No error was reported, but fewer stencils produced than expected.
     // Assume we hit out of memory.
-    MOZ_ASSERT(false, "Expected more scripts");
+    MOZ_ASSERT(false, "Expected more stencils");
     ReportOutOfMemory(cx);
     return false;
   }
 
-  // The Debugger only needs to be told about the topmost scripts that were
-  // compiled.
-  if (!parseTask->options.hideFromNewScriptInitial()) {
-    JS::RootedScript rooted(cx);
-    for (auto& script : scripts) {
-      MOZ_ASSERT(script->isGlobalCode());
-
-      rooted = script;
-      DebugAPI::onNewScript(cx, rooted);
-    }
-  }
-
   return true;
 }
 
@@ -2379,11 +2349,11 @@
   return script;
 }
 
-bool GlobalHelperThreadState::finishMultiScriptsDecodeTask(
+bool GlobalHelperThreadState::finishMultiStencilsDecodeTask(
     JSContext* cx, JS::OffThreadToken* token,
-    MutableHandle<ScriptVector> scripts) {
-  return finishMultiParseTask(cx, ParseTaskKind::MultiScriptsDecode, token,
-                              scripts);
+    mozilla::Vector<RefPtr<JS::Stencil>>* stencils) {
+  return finishMultiParseTask(cx, ParseTaskKind::MultiStencilsDecode, token,
+                              stencils);
 }
 
 JSObject* GlobalHelperThreadState::finishModuleParseTask(