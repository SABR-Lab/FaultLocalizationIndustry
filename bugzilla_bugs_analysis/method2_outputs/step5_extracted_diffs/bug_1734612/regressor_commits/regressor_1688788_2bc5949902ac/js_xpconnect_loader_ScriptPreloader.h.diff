# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/loader/ScriptPreloader.h
# Commit: 2bc5949902ac
# Full Hash: 2bc5949902acc042205fc7e85260bbbc37dbedc7
# Author: Matthew Gaudet <mgaudet@mozilla.com>
# Date: 2021-09-18 09:46:57
# Regressor Bug: 1688788
# File Overlap Count: 1
# Description:
#   Bug 1688788 - Convert ScriptPreloader to manage Stencils, not Scripts. r=kmag,tcampbell
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D113013
# ==============================================================================

diff -r e660e2c3c3d1 -r 2bc5949902ac js/xpconnect/loader/ScriptPreloader.h
--- a/js/xpconnect/loader/ScriptPreloader.h	Sat Sep 18 01:29:45 2021 +0000
+++ b/js/xpconnect/loader/ScriptPreloader.h	Sat Sep 18 01:29:45 2021 +0000
@@ -26,6 +26,7 @@
 #include "nsIThread.h"
 #include "nsITimer.h"
 
+#include "js/experimental/JSStencil.h"
 #include "js/GCAnnotations.h"  // for JS_HAZ_NON_GC_POINTER
 #include "js/RootingAPI.h"     // for Handle, Heap
 #include "js/Transcoding.h"  // for TranscodeBuffer, TranscodeRange, TranscodeSources
@@ -89,13 +90,13 @@
 
   // Fill some options that should be consistent across all scripts stored
   // into preloader cache.
-  static void FillCompileOptionsForCachedScript(JS::CompileOptions& options);
+  static void FillCompileOptionsForCachedStencil(JS::CompileOptions& options);
 
-  // Retrieves the script with the given cache key from the script cache.
-  // Returns null if the script is not cached.
-  JSScript* GetCachedScript(JSContext* cx,
-                            const JS::ReadOnlyCompileOptions& options,
-                            const nsCString& path);
+  // Retrieves the stencil with the given cache key from the cache.
+  // Returns null if the stencil is not cached.
+  already_AddRefed<JS::Stencil> GetCachedStencil(
+      JSContext* cx, const JS::ReadOnlyCompileOptions& options,
+      const nsCString& path);
 
   // Notes the execution of a script with the given URL and cache key.
   // Depending on the stage of startup, the script may be serialized and
@@ -104,14 +105,14 @@
   // If isRunOnce is true, this script is expected to run only once per
   // process per browser session. A cached instance will not be kept alive
   // for repeated execution.
-  void NoteScript(const nsCString& url, const nsCString& cachePath,
-                  JS::HandleScript script, bool isRunOnce = false);
+  void NoteStencil(const nsCString& url, const nsCString& cachePath,
+                   JS::Stencil* stencil, bool isRunOnce = false);
 
-  // Notes the IPC arrival of the XDR data of a script compiled by some
+  // Notes the IPC arrival of the XDR data of a stencil compiled by some
   // child process. See ScriptCacheChild::SendScriptsAndFinalize.
-  void NoteScript(const nsCString& url, const nsCString& cachePath,
-                  ProcessType processType, nsTArray<uint8_t>&& xdrData,
-                  TimeStamp loadTime);
+  void NoteStencil(const nsCString& url, const nsCString& cachePath,
+                   ProcessType processType, nsTArray<uint8_t>&& xdrData,
+                   TimeStamp loadTime);
 
   // Initializes the script cache from the startup script cache file.
   Result<Ok, nsresult> InitCache(const nsAString& = u"scriptCache"_ns);
@@ -123,13 +124,11 @@
 
  private:
   Result<Ok, nsresult> InitCacheInternal(JS::HandleObject scope = nullptr);
-  JSScript* GetCachedScriptInternal(JSContext* cx,
-                                    const JS::ReadOnlyCompileOptions& options,
-                                    const nsCString& path);
+  already_AddRefed<JS::Stencil> GetCachedStencilInternal(
+      JSContext* cx, const JS::ReadOnlyCompileOptions& options,
+      const nsCString& path);
 
  public:
-  void Trace(JSTracer* trc);
-
   static ProcessType CurrentProcessType() {
     MOZ_ASSERT(sProcessType != ProcessType::Uninitialized);
     return sProcessType;
@@ -146,46 +145,43 @@
     Saved,
   };
 
-  // Represents a cached JS script, either initially read from the script
-  // cache file, to be added to the next session's script cache file, or
+  // Represents a cached script stencil, either initially read from the
+  // cache file, to be added to the next session's stencil cache file, or
   // both.
   //
-  // A script which was read from the cache file may be in any of the
-  // following states:
-  //
-  //  - Read from the cache, and being compiled off thread. In this case,
+  //  - Read from the cache, and being decoded off thread. In this case,
   //    mReadyToExecute is false, and mToken is null.
-  //  - Off-thread compilation has finished, but the script has not yet been
+  //  - Off-thread decode has finished, but the stencil has not yet been
   //    executed. In this case, mReadyToExecute is true, and mToken has a
   //    non-null value.
   //  - Read from the cache, but too small or needed to immediately to be
   //    compiled off-thread. In this case, mReadyToExecute is true, and both
-  //    mToken and mScript are null.
+  //    mToken and mStencil are null.
   //  - Fully decoded, and ready to be added to the next session's cache
-  //    file. In this case, mReadyToExecute is true, and mScript is non-null.
+  //    file. In this case, mReadyToExecute is true, and mStencil is non-null.
   //
-  // A script to be added to the next session's cache file always has a
-  // non-null mScript value. If it was read from the last session's cache
+  // A stencil to be added to the next session's cache file always has a
+  // non-null mStencil value. If it was read from the last session's cache
   // file, it also has a non-empty mXDRRange range, which will be stored in
   // the next session's cache file. If it was compiled in this session, its
   // mXDRRange will initially be empty, and its mXDRData buffer will be
   // populated just before it is written to the cache file.
-  class CachedScript : public LinkedListElement<CachedScript> {
+  class CachedStencil : public LinkedListElement<CachedStencil> {
    public:
-    CachedScript(CachedScript&&) = delete;
+    CachedStencil(CachedStencil&&) = delete;
 
-    CachedScript(ScriptPreloader& cache, const nsCString& url,
-                 const nsCString& cachePath, JSScript* script)
+    CachedStencil(ScriptPreloader& cache, const nsCString& url,
+                  const nsCString& cachePath, JS::Stencil* stencil)
         : mCache(cache),
           mURL(url),
           mCachePath(cachePath),
-          mScript(script),
+          mStencil(stencil),
           mReadyToExecute(true),
           mIsRunOnce(false) {}
 
-    inline CachedScript(ScriptPreloader& cache, InputBuffer& buf);
+    inline CachedStencil(ScriptPreloader& cache, InputBuffer& buf);
 
-    ~CachedScript() = default;
+    ~CachedStencil() = default;
 
     ScriptStatus Status() const {
       return mProcessTypes.isEmpty() ? ScriptStatus::Restored
@@ -198,69 +194,25 @@
     // earlier are stored earlier, and scripts needed at approximately the
     // same time are stored approximately contiguously.
     struct Comparator {
-      bool Equals(const CachedScript* a, const CachedScript* b) const {
+      bool Equals(const CachedStencil* a, const CachedStencil* b) const {
         return a->mLoadTime == b->mLoadTime;
       }
 
-      bool LessThan(const CachedScript* a, const CachedScript* b) const {
+      bool LessThan(const CachedStencil* a, const CachedStencil* b) const {
         return a->mLoadTime < b->mLoadTime;
       }
     };
 
-    struct StatusMatcher final : public Matcher<CachedScript*> {
+    struct StatusMatcher final : public Matcher<CachedStencil*> {
       explicit StatusMatcher(ScriptStatus status) : mStatus(status) {}
 
-      virtual bool Matches(CachedScript* script) override {
+      virtual bool Matches(CachedStencil* script) override {
         return script->Status() == mStatus;
       }
 
       const ScriptStatus mStatus;
     };
 
-    // The purpose of this helper class is to avoid a race between
-    // ScriptPreloader::WriteCache() and the GC on a JSScript*.
-    // The former checks if the actual JSScript* is null on the save thread
-    // while holding mMonitor. Aside from GC tracing, all places that mutate
-    // the JSScript* either hold mMonitor or don't run at the same time as the
-    // save thread. The GC can move the script, which will cause the value to
-    // change, but this will not change whether it is null or not.
-    //
-    // We can't hold mMonitor while tracing, because we can end running the
-    // GC while the current thread already holds mMonitor. Instead, this class
-    // avoids the race by storing a separate field to indicate if the script is
-    // null or not. To enforce this, the mutation by the GC that cannot affect
-    // the nullness of the script is split out from other mutation.
-    class MOZ_HEAP_CLASS ScriptHolder {
-     public:
-      explicit ScriptHolder(JSScript* script)
-          : mScript(script), mHasScript(script) {}
-      ScriptHolder() : mHasScript(false) {}
-
-      // This should only be called on the main thread (either while holding
-      // the preloader's mMonitor or while the save thread isn't running), or on
-      // the save thread while holding the preloader's mMonitor.
-      explicit operator bool() const { return mHasScript; }
-
-      // This should only be called on the main thread.
-      JSScript* Get() const {
-        MOZ_ASSERT(NS_IsMainThread());
-        return mScript;
-      }
-
-      // This should only be called on the main thread (or from a GC thread
-      // while the main thread is GCing).
-      void Trace(JSTracer* trc);
-
-      // These should only be called on the main thread, either while holding
-      // the preloader's mMonitor or while the save thread isn't running.
-      void Set(JS::HandleScript jsscript);
-      void Clear();
-
-     private:
-      JS::Heap<JSScript*> mScript;
-      bool mHasScript;  // true iff mScript is non-null.
-    };
-
     void FreeData() {
       // If the script data isn't mmapped, we need to release both it
       // and the Range that points to it at the same time.
@@ -284,9 +236,9 @@
     // If this method returns false, callers may set mScript to a cached
     // JSScript instance for this entry. If it returns true, they should
     // not.
-    bool MaybeDropScript() {
+    bool MaybeDropStencil() {
       if (mIsRunOnce && (HasRange() || !mCache.WillWriteScripts())) {
-        mScript.Clear();
+        mStencil = nullptr;
         return true;
       }
       return false;
@@ -331,8 +283,8 @@
 
     bool HasArray() { return mXDRData.constructed<nsTArray<uint8_t>>(); }
 
-    JSScript* GetJSScript(JSContext* cx,
-                          const JS::ReadOnlyCompileOptions& options);
+    already_AddRefed<JS::Stencil> GetStencil(
+        JSContext* cx, const JS::ReadOnlyCompileOptions& options);
 
     size_t HeapSizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) {
       auto size = mallocSizeOf(this);
@@ -341,8 +293,10 @@
         size += Array().ShallowSizeOfExcludingThis(mallocSizeOf);
       } else if (HasBuffer()) {
         size += Buffer().sizeOfExcludingThis(mallocSizeOf);
-      } else {
-        return size;
+      }
+
+      if (mStencil) {
+        size += JS::SizeOfStencil(mStencil, mallocSizeOf);
       }
 
       // Note: mURL and mCachePath use the same string for scripts loaded
@@ -370,7 +324,7 @@
 
     TimeStamp mLoadTime{};
 
-    ScriptHolder mScript;
+    RefPtr<JS::Stencil> mStencil;
 
     // True if this script is ready to be executed. This means that either the
     // off-thread portion of an off-thread decode has finished, or the script
@@ -405,8 +359,8 @@
   } JS_HAZ_NON_GC_POINTER;
 
   template <ScriptStatus status>
-  static Matcher<CachedScript*>* Match() {
-    static CachedScript::StatusMatcher matcher{status};
+  static Matcher<CachedStencil*>* Match() {
+    static CachedStencil::StatusMatcher matcher{status};
     return &matcher;
   }
 
@@ -480,9 +434,9 @@
 
   // Waits for the given cached script to finish compiling off-thread, or
   // decodes it synchronously on the main thread, as appropriate.
-  JSScript* WaitForCachedScript(JSContext* cx,
-                                const JS::ReadOnlyCompileOptions& options,
-                                CachedScript* script);
+  already_AddRefed<JS::Stencil> WaitForCachedStencil(
+      JSContext* cx, const JS::ReadOnlyCompileOptions& options,
+      CachedStencil* script);
 
   void DecodeNextBatch(size_t chunkSize, JS::HandleObject scope = nullptr);
 
@@ -498,7 +452,7 @@
             mallocSizeOf(mSaveThread.get()) + mallocSizeOf(mProfD.get()));
   }
 
-  using ScriptHash = nsClassHashtable<nsCStringHashKey, CachedScript>;
+  using ScriptHash = nsClassHashtable<nsCStringHashKey, CachedStencil>;
 
   template <ScriptStatus status>
   static size_t SizeOfHashEntries(ScriptHash& scripts,
@@ -524,12 +478,12 @@
 
   // The list of scripts that we read from the initial startup cache file,
   // but have yet to initiate a decode task for.
-  LinkedList<CachedScript> mPendingScripts;
+  LinkedList<CachedStencil> mPendingScripts;
 
   // The lists of scripts and their sources that make up the chunk currently
   // being decoded in a background thread.
   JS::TranscodeSources mParsingSources;
-  Vector<CachedScript*> mParsingScripts;
+  Vector<CachedStencil*> mParsingScripts;
 
   // The token for the completed off-thread decode task.
   Atomic<JS::OffThreadToken*, ReleaseAcquire> mToken{nullptr};