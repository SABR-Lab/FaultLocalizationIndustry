# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBaselineCompile.cpp
# Commit: 339e37a04ca1
# Full Hash: 339e37a04ca17a209114f9d346751e6d05f6a37d
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 1
# Description:
#   Bug 1727084 - Memory64 - Preliminaries. r=yury
#   
#   Scaffolding: Add assertions everywhere execution currently depends on
#   a memory being a memory32.  These assertions will disappear by and by.
#   
# ==============================================================================

diff -r 83e52246d0ea -r 339e37a04ca1 js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp	Mon Oct 18 09:58:13 2021 +0000
+++ b/js/src/wasm/WasmBaselineCompile.cpp	Mon Oct 18 09:58:13 2021 +0000
@@ -4919,6 +4919,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   loadCommon(&access, AccessCheck(), type);
   return true;
@@ -4934,6 +4935,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   storeCommon(&access, AccessCheck(), resultType);
   return true;
@@ -5324,6 +5326,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset(),
                           Synchronization::Load());
   atomicLoad(&access, type);
@@ -5357,6 +5360,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset(),
                           Synchronization::Store());
   atomicStore(&access, type);
@@ -5452,6 +5456,7 @@
     return true;
   }
 
+  MOZ_ASSERT(isMem32());
   int32_t signedLength;
   if (peekConst(&signedLength) && signedLength != 0 &&
       uint32_t(signedLength) <= MaxInlineMemoryCopyLength) {
@@ -5481,6 +5486,7 @@
     return true;
   }
 
+  MOZ_ASSERT(isMem32());
   int32_t signedLength;
   int32_t signedValue;
   if (peek2xConst(&signedLength, &signedValue) && signedLength != 0 &&
@@ -5505,6 +5511,7 @@
         Nothing nothing;
         if (iter_.readMemOrTableInit(/*isMem*/ true, segIndex, &dstTableIndex,
                                      &nothing, &nothing, &nothing)) {
+          MOZ_ASSERT(isMem32());
           return true;
         }
         return false;
@@ -7488,6 +7495,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   loadSplat(&access);
   return true;
@@ -7502,6 +7510,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   loadZero(&access);
   return true;
@@ -7515,6 +7524,7 @@
   if (deadCode_) {
     return true;
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(Scalar::Int64, addr.align, addr.offset,
                           bytecodeOffset());
   loadExtend(&access, viewType);
@@ -7548,6 +7558,7 @@
     default:
       MOZ_CRASH("unsupported laneSize");
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   loadLane(&access, laneIndex);
   return true;
@@ -7580,6 +7591,7 @@
     default:
       MOZ_CRASH("unsupported laneSize");
   }
+  MOZ_ASSERT(isMem32());
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
   storeLane(&access, laneIndex);
   return true;
@@ -9713,6 +9725,9 @@
 }
 
 bool BaseCompiler::init() {
+  // We may lift this restriction in the future.
+  MOZ_ASSERT_IF(usesMemory() && isMem64(), !moduleEnv_.hugeMemoryEnabled());
+
   ra.init(this);
 
   if (!SigD_.append(ValType::F64)) {