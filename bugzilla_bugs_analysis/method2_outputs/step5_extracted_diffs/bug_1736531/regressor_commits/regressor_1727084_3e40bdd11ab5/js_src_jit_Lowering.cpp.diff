# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/Lowering.cpp
# Commit: 3e40bdd11ab5
# Full Hash: 3e40bdd11ab5aa13a583162bb8394a234465c3a2
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 6
# Description:
#   Bug 1727084 - Memory64 - Ion operations. r=yury
#   
#   Add memory64 generalizations for Ion for all operations (except bulk
#   memory, done in an earlier patch).
#   
# ==============================================================================

diff -r 44b0c0bed8a6 -r 3e40bdd11ab5 js/src/jit/Lowering.cpp
--- a/js/src/jit/Lowering.cpp	Mon Oct 18 09:58:15 2021 +0000
+++ b/js/src/jit/Lowering.cpp	Mon Oct 18 09:58:16 2021 +0000
@@ -2499,6 +2499,9 @@
 
 void LIRGenerator::visitWasmExtendU32Index(MWasmExtendU32Index* ins) {
 #ifdef JS_64BIT
+  // Technically this produces an Int64 register and I guess we could clean that
+  // up, but it's a 64-bit only operation, so it doesn't actually matter.
+
   MDefinition* input = ins->input();
   MOZ_ASSERT(input->type() == MIRType::Int32);
   MOZ_ASSERT(ins->type() == MIRType::Int64);
@@ -2513,18 +2516,22 @@
 }
 
 void LIRGenerator::visitWasmWrapU32Index(MWasmWrapU32Index* ins) {
-#ifdef JS_64BIT
   MDefinition* input = ins->input();
   MOZ_ASSERT(input->type() == MIRType::Int64);
   MOZ_ASSERT(ins->type() == MIRType::Int32);
 
-  // Input reuse is OK even on ARM64 because this node *must* reuse its input in
-  // order not to generate any code at all, as is the intent.
+  // Tricky: On 64-bit, this just returns its input (except on MIPS64 there may
+  // be a sign/zero extension).  On 32-bit, it returns the low register of the
+  // input, and should generate no code.
+
+  // If this assertion does not hold then using "input" unadorned as an alias
+  // for the low register will not work.
+#if defined(JS_NUNBOX32)
+  static_assert(INT64LOW_INDEX == 0);
+#endif
+
   auto* lir = new (alloc()) LWasmWrapU32Index(useRegisterAtStart(input));
   defineReuseInput(lir, ins, 0);
-#else
-  MOZ_CRASH("64-bit only");
-#endif
 }
 
 void LIRGenerator::visitIntPtrToDouble(MIntPtrToDouble* ins) {
@@ -4797,10 +4804,23 @@
 }
 
 void LIRGenerator::visitWasmAddOffset(MWasmAddOffset* ins) {
-  MOZ_ASSERT(ins->base()->type() == MIRType::Int32);
-  MOZ_ASSERT(ins->type() == MIRType::Int32);
   MOZ_ASSERT(ins->offset());
-  define(new (alloc()) LWasmAddOffset(useRegisterAtStart(ins->base())), ins);
+  if (ins->base()->type() == MIRType::Int32) {
+    MOZ_ASSERT(ins->type() == MIRType::Int32);
+    define(new (alloc()) LWasmAddOffset(useRegisterAtStart(ins->base())), ins);
+  } else {
+    MOZ_ASSERT(ins->type() == MIRType::Int64);
+#ifdef JS_64BIT
+    defineInt64(new (alloc())
+                    LWasmAddOffset64(useInt64RegisterAtStart(ins->base())),
+                ins);
+#else
+    // Avoid situation where the input is (a,b) and the output is (b,a).
+    defineInt64ReuseInput(
+        new (alloc()) LWasmAddOffset64(useInt64RegisterAtStart(ins->base())),
+        ins, 0);
+#endif
+  }
 }
 
 void LIRGenerator::visitWasmLoadTls(MWasmLoadTls* ins) {
@@ -4856,10 +4876,14 @@
 
 void LIRGenerator::visitWasmAlignmentCheck(MWasmAlignmentCheck* ins) {
   MDefinition* index = ins->index();
-  MOZ_ASSERT(index->type() == MIRType::Int32);
-
-  auto* lir = new (alloc()) LWasmAlignmentCheck(useRegisterAtStart(index));
-  add(lir, ins);
+  if (index->type() == MIRType::Int64) {
+    auto* lir =
+        new (alloc()) LWasmAlignmentCheck64(useInt64RegisterAtStart(index));
+    add(lir, ins);
+  } else {
+    auto* lir = new (alloc()) LWasmAlignmentCheck(useRegisterAtStart(index));
+    add(lir, ins);
+  }
 }
 
 void LIRGenerator::visitWasmLoadGlobalVar(MWasmLoadGlobalVar* ins) {