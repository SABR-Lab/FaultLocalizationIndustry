# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MIR.h
# Commit: 3e40bdd11ab5
# Full Hash: 3e40bdd11ab5aa13a583162bb8394a234465c3a2
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 6
# Description:
#   Bug 1727084 - Memory64 - Ion operations. r=yury
#   
#   Add memory64 generalizations for Ion for all operations (except bulk
#   memory, done in an earlier patch).
#   
# ==============================================================================

diff -r 44b0c0bed8a6 -r 3e40bdd11ab5 js/src/jit/MIR.h
--- a/js/src/jit/MIR.h	Mon Oct 18 09:58:15 2021 +0000
+++ b/js/src/jit/MIR.h	Mon Oct 18 09:58:16 2021 +0000
@@ -9006,13 +9006,14 @@
   AliasSet getAliasSet() const override { return aliases_; }
 };
 
-// Bounds check nodes are of type Int32 on 32-bit systems for both wasm and
-// asm.js code, as well as on 64-bit systems for asm.js code and for wasm code
-// that is known to have a bounds check limit that fits into 32 bits.  They are
-// of type Int64 only on 64-bit systems for wasm code with 4GB (or larger)
-// heaps.  There is no way for nodes of both types to be present in the same
-// function.  Should this change, then BCE must be updated to take type into
-// account.
+// For memory32, bounds check nodes are of type Int32 on 32-bit systems for both
+// wasm and asm.js code, as well as on 64-bit systems for asm.js code and for
+// wasm code that is known to have a bounds check limit that fits into 32 bits.
+// They are of type Int64 only on 64-bit systems for wasm code with 4GB heaps.
+// There is no way for nodes of both types to be present in the same function.
+// Should this change, then BCE must be updated to take type into account.
+//
+// For memory64, bounds check nodes are always of type Int64.
 
 class MWasmBoundsCheck : public MBinaryInstruction, public NoTypePolicy::Data {
   wasm::BytecodeOffset bytecodeOffset_;
@@ -9021,6 +9022,8 @@
                             wasm::BytecodeOffset bytecodeOffset)
       : MBinaryInstruction(classOpcode, index, boundsCheckLimit),
         bytecodeOffset_(bytecodeOffset) {
+    MOZ_ASSERT(index->type() == boundsCheckLimit->type());
+
     // Bounds check is effectful: it throws for OOB.
     setGuard();
 
@@ -9053,7 +9056,9 @@
         offset_(offset),
         bytecodeOffset_(bytecodeOffset) {
     setGuard();
-    setResultType(MIRType::Int32);
+    MOZ_ASSERT(base->type() == MIRType::Int32 ||
+               base->type() == MIRType::Int64);
+    setResultType(base->type());
   }
 
  public: