# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/arm/MacroAssembler-arm.cpp
# Commit: 6089b4360edc
# Full Hash: 6089b4360edcfb3a4bda506e37be8ca75a9f15a6
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 6
# Description:
#   Bug 1727084 - Memory64 - Non-atomic-RMW baseline operations. r=yury
#   
#   Implement scalar, SIMD, and atomic loads and stores for the baseline
#   compiler for x64, x86, arm64, and arm32.  Atomic RMW operations and
#   wait/notify are in the next patch.
# ==============================================================================

diff -r b9d32ef0ad83 -r 6089b4360edc js/src/jit/arm/MacroAssembler-arm.cpp
--- a/js/src/jit/arm/MacroAssembler-arm.cpp	Mon Oct 18 07:31:55 2021 +0000
+++ b/js/src/jit/arm/MacroAssembler-arm.cpp	Mon Oct 18 07:31:55 2021 +0000
@@ -4726,27 +4726,44 @@
 }
 
 void MacroAssembler::wasmBoundsCheck32(Condition cond, Register index,
-                                       Register boundsCheckLimit,
-                                       Label* label) {
+                                       Register boundsCheckLimit, Label* ok) {
   as_cmp(index, O2Reg(boundsCheckLimit));
-  as_b(label, cond);
+  as_b(ok, cond);
   if (JitOptions.spectreIndexMasking) {
     ma_mov(boundsCheckLimit, index, LeaveCC, cond);
   }
 }
 
 void MacroAssembler::wasmBoundsCheck32(Condition cond, Register index,
-                                       Address boundsCheckLimit, Label* label) {
+                                       Address boundsCheckLimit, Label* ok) {
   ScratchRegisterScope scratch(*this);
   ma_ldr(DTRAddr(boundsCheckLimit.base, DtrOffImm(boundsCheckLimit.offset)),
          scratch);
   as_cmp(index, O2Reg(scratch));
-  as_b(label, cond);
+  as_b(ok, cond);
   if (JitOptions.spectreIndexMasking) {
     ma_mov(scratch, index, LeaveCC, cond);
   }
 }
 
+void MacroAssembler::wasmBoundsCheck64(Condition cond, Register64 index,
+                                       Register64 boundsCheckLimit, Label* ok) {
+  Label notOk;
+  cmp32(index.high, Imm32(0));
+  j(Assembler::NonZero, &notOk);
+  wasmBoundsCheck32(cond, index.low, boundsCheckLimit.low, ok);
+  bind(&notOk);
+}
+
+void MacroAssembler::wasmBoundsCheck64(Condition cond, Register64 index,
+                                       Address boundsCheckLimit, Label* ok) {
+  Label notOk;
+  cmp32(index.high, Imm32(0));
+  j(Assembler::NonZero, &notOk);
+  wasmBoundsCheck32(cond, index.low, boundsCheckLimit, ok);
+  bind(&notOk);
+}
+
 void MacroAssembler::wasmTruncateDoubleToUInt32(FloatRegister input,
                                                 Register output,
                                                 bool isSaturating,