# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBCMemory.cpp
# Commit: 63ce829d63b4
# Full Hash: 63ce829d63b4d3cb462c23011be830b966cfdf14
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 1
# Description:
#   Bug 1727084 - Memory64 - Preliminaries. r=yury
#   
#   Scaffolding: Add assertions everywhere execution currently depends on
#   a memory being a memory32.  These assertions will disappear by and by.
#   
# ==============================================================================

diff -r 5315e548b651 -r 63ce829d63b4 js/src/wasm/WasmBCMemory.cpp
--- a/js/src/wasm/WasmBCMemory.cpp	Mon Oct 18 07:31:53 2021 +0000
+++ b/js/src/wasm/WasmBCMemory.cpp	Mon Oct 18 07:31:54 2021 +0000
@@ -767,6 +767,7 @@
 
 void BaseCompiler::atomicRMW(MemoryAccessDesc* access, ValType type,
                              AtomicOp op) {
+  MOZ_ASSERT(isMem32());
   Scalar::Type viewType = access->type();
   if (Scalar::byteSize(viewType) <= 4) {
     atomicRMW32(access, type, op);
@@ -1100,6 +1101,7 @@
 // Atomic exchange (also used for atomic store in some cases).
 
 void BaseCompiler::atomicXchg(MemoryAccessDesc* access, ValType type) {
+  MOZ_ASSERT(isMem32());
   Scalar::Type viewType = access->type();
   if (Scalar::byteSize(viewType) <= 4) {
     atomicXchg32(access, type);
@@ -1357,6 +1359,7 @@
 // Atomic compare-exchange.
 
 void BaseCompiler::atomicCmpXchg(MemoryAccessDesc* access, ValType type) {
+  MOZ_ASSERT(isMem32());
   Scalar::Type viewType = access->type();
   if (Scalar::byteSize(viewType) <= 4) {
     atomicCmpXchg32(access, type);
@@ -1660,6 +1663,7 @@
       RegI64 timeout = popI64();
       RegI32 val = popI32();
 
+      MOZ_ASSERT(isMem32());
       computeEffectiveAddress(access);
 
       pushI32(val);
@@ -1674,6 +1678,7 @@
       RegI64 timeout = popI64();
       RegI64 val = popI64();
 
+      MOZ_ASSERT(isMem32());
       computeEffectiveAddress(access);
 
       pushI64(val);
@@ -1695,6 +1700,7 @@
                               uint32_t lineOrBytecode) {
   RegI32 count = popI32();
 
+  MOZ_ASSERT(isMem32());
   computeEffectiveAddress(access);
 
   pushI32(count);