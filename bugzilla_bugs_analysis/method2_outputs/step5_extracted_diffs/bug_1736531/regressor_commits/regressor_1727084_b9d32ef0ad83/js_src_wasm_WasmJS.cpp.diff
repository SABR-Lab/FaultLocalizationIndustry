# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmJS.cpp
# Commit: b9d32ef0ad83
# Full Hash: b9d32ef0ad835c014d1ced7577ed3d4c47a00031
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2021-10-18 16:09:29
# Regressor Bug: 1727084
# File Overlap Count: 1
# Description:
#   Bug 1727084 - Memory64 - Bulk memory operations. r=yury
#   
#   Implement all bulk memory operations on 64-bit memories.  Only
#   out-of-line paths are supported for memory.copy and memory.fill, for
#   now.
# ==============================================================================

diff -r 359e414a1d7f -r b9d32ef0ad83 js/src/wasm/WasmJS.cpp
--- a/js/src/wasm/WasmJS.cpp	Mon Oct 18 07:31:54 2021 +0000
+++ b/js/src/wasm/WasmJS.cpp	Mon Oct 18 07:31:55 2021 +0000
@@ -2884,30 +2884,28 @@
 }
 
 /* static */
-uint32_t WasmMemoryObject::growShared(HandleWasmMemoryObject memory,
-                                      uint32_t delta) {
+uint64_t WasmMemoryObject::growShared(HandleWasmMemoryObject memory,
+                                      uint64_t delta) {
   SharedArrayRawBuffer* rawBuf = memory->sharedArrayRawBuffer();
   SharedArrayRawBuffer::Lock lock(rawBuf);
 
   Pages oldNumPages = rawBuf->volatileWasmPages();
   Pages newPages = oldNumPages;
   if (!newPages.checkedIncrement(Pages(delta))) {
-    return -1;
+    return uint64_t(int64_t(-1));
   }
 
   if (!rawBuf->wasmGrowToPagesInPlace(lock, memory->indexType(), newPages)) {
-    return -1;
+    return uint64_t(int64_t(-1));
   }
   // New buffer objects will be created lazily in all agents (including in
   // this agent) by bufferGetterImpl, above, so no more work to do here.
 
-  // It is safe to cast to uint32_t, as oldNumPages was within our
-  // implementation limits of MaxMemoryPages(), which is within uint32_t.
-  return uint32_t(oldNumPages.value());
+  return oldNumPages.value();
 }
 
 /* static */
-uint32_t WasmMemoryObject::grow(HandleWasmMemoryObject memory, uint32_t delta,
+uint64_t WasmMemoryObject::grow(HandleWasmMemoryObject memory, uint64_t delta,
                                 JSContext* cx) {
   if (memory->isShared()) {
     return growShared(memory, delta);
@@ -2926,7 +2924,7 @@
   Pages oldNumPages = oldBuf->wasmPages();
   Pages newPages = oldNumPages;
   if (!newPages.checkedIncrement(Pages(delta))) {
-    return -1;
+    return uint64_t(int64_t(-1));
   }
 
   RootedArrayBufferObject newBuf(cx);
@@ -2935,11 +2933,11 @@
     MOZ_ASSERT(!memory->isHuge());
     if (!ArrayBufferObject::wasmMovingGrowToPages(memory->indexType(), newPages,
                                                   oldBuf, &newBuf, cx)) {
-      return -1;
+      return uint64_t(int64_t(-1));
     }
   } else if (!ArrayBufferObject::wasmGrowToPagesInPlace(
                  memory->indexType(), newPages, oldBuf, &newBuf, cx)) {
-    return -1;
+    return uint64_t(int64_t(-1));
   }
 
   memory->setReservedSlot(BUFFER_SLOT, ObjectValue(*newBuf));
@@ -2953,9 +2951,7 @@
     }
   }
 
-  // It is safe to cast to uint32_t, as oldNumPages was within our
-  // implementation limits of MaxMemoryPages(), which is within uint32_t.
-  return uint32_t(oldNumPages.value());
+  return oldNumPages.value();
 }
 
 bool js::wasm::IsSharedWasmMemoryObject(JSObject* obj) {