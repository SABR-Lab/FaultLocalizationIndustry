# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/CanvasRenderingContext2D.cpp
# Commit: e3051b96067a
# Full Hash: e3051b96067a480b020bd8c984a54491665c765e
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2021-11-11 15:25:44
# Regressor Bug: 1739448
# File Overlap Count: 1
# Description:
#   Bug 1739448 - Implement a prototype WebGL-backed Canvas2D. r=gfx-reviewers,nical,jrmuizel
#   
#   This mainly provides DrawTargetWebgl, which implements the subset of the DrawTarget
#   API necessary for integration with CanvasRenderingContext2D. It translates them to
#   suitable commands for its internal ClientWebGLContext, which then manages remoting
# ==============================================================================

diff -r 66c30950518d -r e3051b96067a dom/canvas/CanvasRenderingContext2D.cpp
--- a/dom/canvas/CanvasRenderingContext2D.cpp	Thu Nov 11 07:16:57 2021 +0000
+++ b/dom/canvas/CanvasRenderingContext2D.cpp	Thu Nov 11 07:16:58 2021 +0000
@@ -61,6 +61,7 @@
 #include "nsIMemoryReporter.h"
 #include "nsStyleUtil.h"
 #include "CanvasImageCache.h"
+#include "DrawTargetWebgl.h"
 
 #include <algorithm>
 
@@ -1312,7 +1313,8 @@
   RefPtr<DrawTarget> newTarget;
   RefPtr<PersistentBufferProvider> newProvider;
 
-  if (!TrySharedTarget(newTarget, newProvider) &&
+  if (!TryAcceleratedTarget(newTarget, newProvider) &&
+      !TrySharedTarget(newTarget, newProvider) &&
       !TryBasicTarget(newTarget, newProvider)) {
     gfxCriticalError(
         CriticalLog::DefaultOptions(Factory::ReasonableSurfaceSize(GetSize())))
@@ -1423,6 +1425,18 @@
   return nsContentUtils::WindowRendererForDocument(aCanvasElement->OwnerDoc());
 }
 
+bool CanvasRenderingContext2D::TryAcceleratedTarget(
+    RefPtr<gfx::DrawTarget>& aOutDT,
+    RefPtr<layers::PersistentBufferProvider>& aOutProvider) {
+  aOutDT = DrawTargetWebgl::Create(GetSize(), GetSurfaceFormat());
+  if (!aOutDT) {
+    return false;
+  }
+
+  aOutProvider = new PersistentBufferProviderAccelerated(aOutDT);
+  return true;
+}
+
 bool CanvasRenderingContext2D::TrySharedTarget(
     RefPtr<gfx::DrawTarget>& aOutDT,
     RefPtr<layers::PersistentBufferProvider>& aOutProvider) {
@@ -1433,9 +1447,7 @@
     return false;
   }
 
-  if (mBufferProvider &&
-      (mBufferProvider->GetType() == LayersBackend::LAYERS_CLIENT ||
-       mBufferProvider->GetType() == LayersBackend::LAYERS_WR)) {
+  if (mBufferProvider && mBufferProvider->IsShared()) {
     // we are already using a shared buffer provider, we are allocating a new
     // one because the current one failed so let's just fall back to the basic
     // provider.
@@ -1485,6 +1497,13 @@
   return true;
 }
 
+ClientWebGLContext* CanvasRenderingContext2D::AsWebgl() {
+  if (mBufferProvider) {
+    return mBufferProvider->AsWebgl();
+  }
+  return nullptr;
+}
+
 PresShell* CanvasRenderingContext2D::GetPresShell() {
   if (mCanvasElement) {
     return mCanvasElement->OwnerDoc()->GetPresShell();
@@ -4912,9 +4931,7 @@
     }
   }
   if (op == CompositionOp::OP_OVER &&
-      (!mBufferProvider ||
-       (mBufferProvider->GetType() != LayersBackend::LAYERS_CLIENT &&
-        mBufferProvider->GetType() != LayersBackend::LAYERS_WR))) {
+      (!mBufferProvider || !mBufferProvider->IsShared())) {
     thebes = gfxContext::CreateOrNull(mTarget);
     MOZ_ASSERT(thebes);  // already checked the draw target above
                          // (in SupportsAzureContentForDrawTarget)