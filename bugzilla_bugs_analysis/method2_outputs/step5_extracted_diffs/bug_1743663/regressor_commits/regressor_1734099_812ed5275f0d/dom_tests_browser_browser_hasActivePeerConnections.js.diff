# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/tests/browser/browser_hasActivePeerConnections.js
# Commit: 812ed5275f0d
# Full Hash: 812ed5275f0db9f92944955f891df2ab68c9f8e7
# Author: Toshihito Kikuchi <tkikuchi@mozilla.com>
# Date: 2021-11-19 04:11:43
# Regressor Bug: 1734099
# File Overlap Count: 5
# Description:
#   Bug 1734099 - Never unload tabs with active RTCPeerConnection instances.  r=peterv,jesup
#   
#   This patch makes sure the Tab Unloading feature does not unload tabs that have
#   active peer connections not to disrupt browsing experience based on WebRTC peer
#   connections.
# ==============================================================================

diff -r a733d049dbda -r 812ed5275f0d dom/tests/browser/browser_hasActivePeerConnections.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/tests/browser/browser_hasActivePeerConnections.js	Thu Nov 18 22:59:12 2021 +0000
@@ -0,0 +1,134 @@
+const TEST_URI1 =
+  "http://mochi.test:8888/browser/dom/tests/browser/" +
+  "create_webrtc_peer_connection.html";
+
+const TEST_URI2 =
+  "https://example.com/browser/dom/tests/browser/" +
+  "create_webrtc_peer_connection.html";
+
+add_task(async () => {
+  await BrowserTestUtils.withNewTab(TEST_URI1, async browser => {
+    const topWindow = browser.browsingContext.topWindowContext;
+    Assert.ok(topWindow);
+
+    Assert.strictEqual(
+      topWindow.hasActivePeerConnections,
+      false,
+      "No active connections at the beginning"
+    );
+
+    await SpecialPowers.spawn(browser, [], async () => {
+      content.postMessage("push-peer-connection", "*");
+      return new Promise(resolve =>
+        content.addEventListener("message", function onMessage(event) {
+          if (event.data == "ack") {
+            content.removeEventListener(event.type, onMessage);
+            resolve();
+          }
+        })
+      );
+    });
+
+    Assert.strictEqual(
+      topWindow.hasActivePeerConnections,
+      true,
+      "One connection in the top window"
+    );
+
+    await SpecialPowers.spawn(browser, [], async () => {
+      content.postMessage("pop-peer-connection", "*");
+      return new Promise(resolve =>
+        content.addEventListener("message", function onMessage(event) {
+          if (event.data == "ack") {
+            content.removeEventListener(event.type, onMessage);
+            resolve();
+          }
+        })
+      );
+    });
+
+    Assert.strictEqual(
+      topWindow.hasActivePeerConnections,
+      false,
+      "All connections have been closed"
+    );
+
+    await SpecialPowers.spawn(
+      browser,
+      [TEST_URI1, TEST_URI2],
+      async (TEST_URI1, TEST_URI2) => {
+        // Create a promise that is fulfilled when the "ack" message is received
+        // |targetCount| times.
+        const createWaitForAckPromise = (eventTarget, targetCount) => {
+          let counter = 0;
+          return new Promise(resolve => {
+            eventTarget.addEventListener("message", function onMsg(event) {
+              if (event.data == "ack") {
+                ++counter;
+                if (counter == targetCount) {
+                  eventTarget.removeEventListener(event.type, onMsg);
+                  resolve();
+                }
+              }
+            });
+          });
+        };
+
+        const addFrame = (id, url) => {
+          const iframe = content.document.createElement("iframe");
+          iframe.id = id;
+          iframe.src = url;
+          content.document.body.appendChild(iframe);
+          return iframe;
+        };
+
+        // Create two iframes hosting a same-origin page and a cross-origin page
+        const iframe1 = addFrame("iframe-same-origin", TEST_URI1);
+        const iframe2 = addFrame("iframe-cross-origin", TEST_URI2);
+        await ContentTaskUtils.waitForEvent(iframe1, "load");
+        await ContentTaskUtils.waitForEvent(iframe2, "load");
+
+        // Make sure the counter is not messed up after successive push/pop
+        // messages
+        const kLoopCount = 100;
+        for (let i = 0; i < kLoopCount; ++i) {
+          content.postMessage("push-peer-connection", "*");
+          iframe1.contentWindow.postMessage("push-peer-connection", "*");
+          iframe2.contentWindow.postMessage("push-peer-connection", "*");
+          iframe1.contentWindow.postMessage("pop-peer-connection", "*");
+          iframe2.contentWindow.postMessage("pop-peer-connection", "*");
+          content.postMessage("pop-peer-connection", "*");
+        }
+        iframe2.contentWindow.postMessage("push-peer-connection", "*");
+
+        return createWaitForAckPromise(content, kLoopCount * 6 + 1);
+      }
+    );
+
+    Assert.strictEqual(
+      topWindow.hasActivePeerConnections,
+      true,
+      "#iframe-cross-origin still has an active connection"
+    );
+
+    await SpecialPowers.spawn(browser, [], async () => {
+      content.document
+        .getElementById("iframe-cross-origin")
+        .contentWindow.postMessage("pop-peer-connection", "*");
+      return new Promise(resolve =>
+        content.addEventListener("message", function onMessage(event) {
+          if (event.data == "ack") {
+            content.removeEventListener(event.type, onMessage);
+            resolve();
+          }
+        })
+      );
+    });
+
+    Assert.strictEqual(
+      topWindow.hasActivePeerConnections,
+      false,
+      "All connections have been closed"
+    );
+  });
+});