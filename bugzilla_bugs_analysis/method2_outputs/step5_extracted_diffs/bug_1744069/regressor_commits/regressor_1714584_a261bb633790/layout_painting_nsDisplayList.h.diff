# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/painting/nsDisplayList.h
# Commit: a261bb633790
# Full Hash: a261bb633790ddca9cc8ce83adca0a1bb36114a6
# Author: Miko Mynttinen <mikokm@gmail.com>
# Date: 2022-02-23 09:38:00
# Regressor Bug: 1714584
# File Overlap Count: 2
# Description:
#   Bug 1714584 - Part 1: Decouple nsDisplayList internal list from nsDisplayItems r=mstange
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D138152
# ==============================================================================

diff -r 635f402efb1b -r a261bb633790 layout/painting/nsDisplayList.h
--- a/layout/painting/nsDisplayList.h	Tue Feb 22 23:42:08 2022 +0000
+++ b/layout/painting/nsDisplayList.h	Tue Feb 22 23:42:18 2022 +0000
@@ -24,6 +24,7 @@
 #include "gfxContext.h"
 #include "mozilla/ArenaAllocator.h"
 #include "mozilla/Array.h"
+#include "mozilla/ArrayIterator.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/DebugOnly.h"
@@ -257,11 +258,17 @@
   GenerateGlyph,
 };
 
+using ListArenaAllocator = ArenaAllocator<4096, 8>;
+
+class nsDisplayItem;
+class nsPaintedDisplayItem;
 class nsDisplayList;
 class nsDisplayWrapList;
 class nsDisplayTableBackgroundSet;
 class nsDisplayTableItem;
 
+class RetainedDisplayList;
+
 /**
  * This manages a display list and is passed as a parameter to
  * nsIFrame::BuildDisplayList.
@@ -958,7 +965,7 @@
    * display item.
    * The display items in |aMergedItems| have to be mergeable with each other.
    */
-  nsDisplayWrapList* MergeItems(nsTArray<nsDisplayWrapList*>& aItems);
+  nsDisplayWrapList* MergeItems(nsTArray<nsDisplayItem*>& aItems);
 
   /**
    * A helper class used to temporarily set nsDisplayListBuilder properties for
@@ -1723,6 +1730,8 @@
    */
   void ReuseDisplayItem(nsDisplayItem* aItem);
 
+  ListArenaAllocator& GetListAllocator() { return mListPool; }
+
  private:
   bool MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame, nsIFrame* aFrame,
                                     const nsRect& aVisibleRect,
@@ -1921,13 +1930,10 @@
 
   // Stores reusable items collected during display list preprocessing.
   nsTHashSet<nsDisplayItem*> mReuseableItems;
+
+  ArenaAllocator<4096, 8> mListPool;
 };
 
-class nsDisplayItem;
-class nsPaintedDisplayItem;
-class nsDisplayList;
-class RetainedDisplayList;
-
 // All types are defined in nsDisplayItemTypes.h
 #define NS_DISPLAY_DECL_NAME(n, e)                                           \
   const char* Name() const override { return n; }                            \
@@ -2047,23 +2053,6 @@
                                      std::forward<Args>(aArgs)...);
 }
 
-/**
- * nsDisplayItems are put in singly-linked lists rooted in an nsDisplayList.
- * nsDisplayItemLink holds the link. The lists are linked from lowest to
- * highest in z-order.
- */
-class nsDisplayItemLink {
-  // This is never instantiated directly, so no need to count constructors and
-  // destructors.
- protected:
-  nsDisplayItemLink() : mAbove(nullptr) {}
-  nsDisplayItemLink(const nsDisplayItemLink&) : mAbove(nullptr) {}
-  ~nsDisplayItemLink() { MOZ_RELEASE_ASSERT(!mAbove); }
-  nsDisplayItem* mAbove;
-
-  friend class nsDisplayList;
-};
-
 /*
  * nsDisplayItemBase is a base-class for all display items. It is mainly
  * responsible for handling the frame-display item 1:n relationship, as well as
@@ -2077,7 +2066,7 @@
  * Display items belong to a list at all times (except temporarily as they
  * move from one list to another).
  */
-class nsDisplayItem : public nsDisplayItemLink {
+class nsDisplayItem {
  public:
   using Layer = layers::Layer;
   using LayerManager = layers::LayerManager;
@@ -2107,6 +2096,12 @@
   }
 
   /**
+   * Checks if the given display item can be merged with this item.
+   * @return true if the merging is possible, otherwise false.
+   */
+  virtual bool CanMerge(const nsDisplayItem* aItem) const { return false; }
+
+  /**
    * Frees the memory allocated for this display item.
    * The given display list builder must have allocated this display item.
    */
@@ -2706,8 +2701,6 @@
 
   virtual void WriteDebugInfo(std::stringstream& aStream) {}
 
-  nsDisplayItem* GetAbove() { return mAbove; }
-
   /**
    * Returns the result of aBuilder->ToReferenceFrame(GetUnderlyingFrame())
    */
@@ -2989,147 +2982,134 @@
   Maybe<uint16_t> mCacheIndex;
 };
 
+template <typename T>
+struct MOZ_HEAP_CLASS LinkedListNode {
+  explicit LinkedListNode(T aValue) : mNext(nullptr), mValue(aValue) {}
+  LinkedListNode* mNext;
+  T mValue;
+};
+
+template <typename T>
+struct LinkedListIterator {
+  using iterator_category = std::forward_iterator_tag;
+  using difference_type = std::ptrdiff_t;
+  using value_type = T;
+  using pointer = T*;
+  using reference = T&;
+  using Node = LinkedListNode<T>;
+
+  explicit LinkedListIterator(Node* aNode = nullptr) : mNode(aNode) {}
+
+  LinkedListIterator<T>& operator++() {
+    MOZ_ASSERT(mNode);
+    mNode = mNode->mNext;
+    return *this;
+  }
+
+  bool operator==(const LinkedListIterator<T>& aOther) const {
+    return mNode == aOther.mNode;
+  }
+
+  bool operator!=(const LinkedListIterator<T>& aOther) const {
+    return mNode != aOther.mNode;
+  }
+
+  const T operator*() const {
+    MOZ_ASSERT(mNode);
+    return mNode->mValue;
+  }
+
+  T operator*() {
+    MOZ_ASSERT(mNode);
+    return mNode->mValue;
+  }
+
+  Node* mNode;
+};
+
 /**
  * Manages a singly-linked list of display list items.
  *
- * mSentinel is the sentinel list value, the first value in the null-terminated
- * linked list of items. mTop is the last item in the list (whose 'above'
- * pointer is null). This class has no virtual methods. So list objects are just
- * two pointers.
- *
  * Stepping upward through this list is very fast. Stepping downward is very
  * slow so we don't support it. The methods that need to step downward
  * (HitTest()) internally build a temporary array of all
  * the items while they do the downward traversal, so overall they're still
  * linear time. We have optimized for efficient AppendToTop() of both
  * items and lists, with minimal codesize.
+ *
+ * Internal linked list nodes are allocated using arena allocator.
  * */
 class nsDisplayList {
  public:
-  class Iterator {
-   public:
-    constexpr Iterator() : mCurrent(nullptr), mEnd(nullptr) {}
-    ~Iterator() = default;
-    Iterator(const Iterator& aOther) = default;
-    Iterator& operator=(const Iterator& aOther) = default;
-
-    explicit Iterator(const nsDisplayList* aList)
-        : mCurrent(aList->GetBottom()), mEnd(nullptr) {}
-    explicit Iterator(nsDisplayItem* aStart)
-        : mCurrent(aStart), mEnd(nullptr) {}
-
-    Iterator& operator++() {
-      mCurrent = Next();
-      return *this;
-    }
-
-    nsDisplayItem* operator*() {
-      MOZ_ASSERT(mCurrent);
-      return mCurrent;
-    }
-
-    bool operator==(const Iterator& aOther) const {
-      return mCurrent == aOther.mCurrent;
-    }
-
-    bool operator!=(const Iterator& aOther) const {
-      return !operator==(aOther);
-    }
-
-    bool HasNext() const { return mCurrent != nullptr; }
-
-    nsDisplayItem* GetNext() {
-      MOZ_ASSERT(HasNext());
-      auto* next = mCurrent;
-      operator++();
-      return next;
-    }
-
-   protected:
-    Iterator(nsDisplayItem* aStart, nsDisplayItem* aEnd)
-        : mCurrent(aStart), mEnd(aEnd) {}
-
-    nsDisplayItem* Next() const {
-      if (!mCurrent) {
-        return nullptr;
-      }
-
-      auto* next = mCurrent->GetAbove();
-      if (next == mEnd) {
-        return nullptr;
-      }
-
-      return next;
-    }
-
-   private:
-    nsDisplayItem* mCurrent;
-    nsDisplayItem* mEnd;
-  };
-
-  class Range final : public Iterator {
-   public:
-    Range(nsDisplayItem* aStart, nsDisplayItem* aEnd)
-        : Iterator(aStart, aEnd) {}
-  };
-
-  Iterator begin() const { return Iterator(this); }
-  constexpr Iterator end() const { return Iterator(); }
-
-  /**
-   * Create an empty list.
-   */
-  nsDisplayList() : mLength(0), mForceTransparentSurface(false) {
-    mTop = &mSentinel;
-    mSentinel.mAbove = nullptr;
-  }
+  using Node = LinkedListNode<nsDisplayItem*>;
+  using iterator = LinkedListIterator<nsDisplayItem*>;
+  using const_iterator = iterator;
+
+  iterator begin() { return iterator(mBottom); }
+  iterator end() { return iterator(nullptr); }
+  const_iterator begin() const { return iterator(mBottom); }
+  const_iterator end() const { return iterator(nullptr); }
+
+  explicit nsDisplayList(nsDisplayListBuilder* aBuilder)
+      : mPool(aBuilder->GetListAllocator()) {}
+
+  nsDisplayList() = delete;
+  nsDisplayList(const nsDisplayList&) = delete;
+  nsDisplayList& operator=(const nsDisplayList&) = delete;
 
   virtual ~nsDisplayList() {
-    MOZ_RELEASE_ASSERT(!mSentinel.mAbove, "Nonempty list left over?");
-  }
-
-  nsDisplayList(nsDisplayList&& aOther) {
-    mForceTransparentSurface = aOther.mForceTransparentSurface;
-
-    if (aOther.mSentinel.mAbove) {
-      AppendToTop(&aOther);
-    } else {
-      mTop = &mSentinel;
-      mLength = 0;
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+    if (!mAllowNonEmptyDestruction) {
+      MOZ_RELEASE_ASSERT(IsEmpty(), "Nonempty list left over?");
     }
+#endif
+    Clear();
+  }
+
+  nsDisplayList(nsDisplayList&& aOther)
+      : mBottom(aOther.mBottom),
+        mTop(aOther.mTop),
+        mLength(aOther.mLength),
+        mPool(aOther.mPool) {
+    aOther.SetEmpty();
   }
 
   nsDisplayList& operator=(nsDisplayList&& aOther) {
+    MOZ_RELEASE_ASSERT(&mPool == &aOther.mPool);
+
     if (this != &aOther) {
-      if (aOther.mSentinel.mAbove) {
-        nsDisplayList tmp;
-        tmp.AppendToTop(&aOther);
-        aOther.AppendToTop(this);
-        AppendToTop(&tmp);
-      } else {
-        mTop = &mSentinel;
-        mLength = 0;
-      }
-      mForceTransparentSurface = aOther.mForceTransparentSurface;
+      MOZ_RELEASE_ASSERT(IsEmpty());
+      mBottom = std::move(aOther.mBottom);
+      mTop = std::move(aOther.mTop);
+      mLength = std::move(aOther.mLength);
+      aOther.SetEmpty();
     }
     return *this;
   }
 
-  nsDisplayList(const nsDisplayList&) = delete;
-  nsDisplayList& operator=(const nsDisplayList& aOther) = delete;
-
-  /**
-   * Append an item to the top of the list. The item must not currently
-   * be in a list and cannot be null.
-   */
+  /**
+   * Append an item to the top of the list.
+   **/
   void AppendToTop(nsDisplayItem* aItem) {
     if (!aItem) {
       return;
     }
-    MOZ_ASSERT(!aItem->mAbove, "Already in a list!");
-    mTop->mAbove = aItem;
-    mTop = aItem;
+
+    auto* next = Allocate(aItem);
+    MOZ_ASSERT(next);
+
+    if (IsEmpty()) {
+      mBottom = next;
+      mTop = next;
+    } else {
+      mTop->mNext = next;
+      mTop = next;
+    }
+
     mLength++;
+
+    MOZ_ASSERT(mBottom && mTop);
+    MOZ_ASSERT(mTop->mNext == nullptr);
   }
 
   template <typename T, typename F, typename... Args>
@@ -3144,30 +3124,49 @@
                                const uint16_t aIndex, Args&&... aArgs) {
     nsDisplayItem* item = MakeDisplayItemWithIndex<T>(
         aBuilder, aFrame, aIndex, std::forward<Args>(aArgs)...);
-
-    if (item) {
-      AppendToTop(item);
-    }
-  }
-
-  /**
-   * Removes all items from aList and appends them to the top of this list
+    AppendToTop(item);
+  }
+
+  /**
+   * Removes all items from aList and appends them to the top of this list.
    */
   void AppendToTop(nsDisplayList* aList) {
-    if (aList->mSentinel.mAbove) {
-      mTop->mAbove = aList->mSentinel.mAbove;
+    MOZ_ASSERT(aList != this);
+    MOZ_RELEASE_ASSERT(&mPool == &aList->mPool);
+
+    if (aList->IsEmpty()) {
+      return;
+    }
+
+    if (IsEmpty()) {
+      std::swap(mBottom, aList->mBottom);
+      std::swap(mTop, aList->mTop);
+      std::swap(mLength, aList->mLength);
+    } else {
+      MOZ_ASSERT(mTop && mTop->mNext == nullptr);
+      mTop->mNext = aList->mBottom;
       mTop = aList->mTop;
-      aList->mTop = &aList->mSentinel;
-      aList->mSentinel.mAbove = nullptr;
       mLength += aList->mLength;
-      aList->mLength = 0;
+
+      aList->SetEmpty();
     }
   }
 
   /**
-   * Remove an item from the bottom of the list and return it.
-   */
-  nsDisplayItem* RemoveBottom();
+   * Clears the display list.
+   */
+  void Clear() {
+    Node* current = mBottom;
+    Node* next = nullptr;
+
+    while (current) {
+      next = current->mNext;
+      Deallocate(current);
+      current = next;
+    }
+
+    SetEmpty();
+  }
 
   /**
    * Remove all items from the list and call their destructors.
@@ -3175,30 +3174,34 @@
   virtual void DeleteAll(nsDisplayListBuilder* aBuilder);
 
   /**
+   * @return the item at the bottom of the list, or null if the list is empty
+   */
+  nsDisplayItem* GetBottom() const {
+    return mBottom ? mBottom->mValue : nullptr;
+  }
+
+  /**
    * @return the item at the top of the list, or null if the list is empty
    */
-  nsDisplayItem* GetTop() const {
-    return mTop != &mSentinel ? static_cast<nsDisplayItem*>(mTop) : nullptr;
-  }
-  /**
-   * @return the item at the bottom of the list, or null if the list is empty
-   */
-  nsDisplayItem* GetBottom() const { return mSentinel.mAbove; }
-  bool IsEmpty() const { return mTop == &mSentinel; }
+  nsDisplayItem* GetTop() const { return mTop ? mTop->mValue : nullptr; }
+
+  bool IsEmpty() const { return mBottom == nullptr; }
 
   /**
    * @return the number of items in the list
    */
-  uint32_t Count() const { return mLength; }
-  /**
-   * Stable sort the list by the z-order of GetUnderlyingFrame() on
+  size_t Length() const { return mLength; }
+
+  /**
+   * Stable sort the list by the z-order of Frame() on
    * each item. 'auto' is counted as zero.
    * It is assumed that the list is already in content document order.
    */
   void SortByZOrder();
+
   /**
    * Stable sort the list by the tree order of the content of
-   * GetUnderlyingFrame() on each item. z-index is ignored.
+   * Frame() on each item. z-index is ignored.
    * @param aCommonAncestor a common ancestor of all the content elements
    * associated with the display items, for speeding up tree order
    * checks, or nullptr if not known; it's only a hint, if it is not an
@@ -3207,15 +3210,14 @@
   void SortByContentOrder(nsIContent* aCommonAncestor);
 
   /**
-   * Sort the display list using a stable sort. Take care, because some of the
-   * items might be nsDisplayLists themselves.
+   * Sort the display list using a stable sort.
    * aComparator(Item item1, Item item2) should return true if item1 should go
    * before item2.
    * We sort the items into increasing order.
    */
   template <typename Item, typename Comparator>
   void Sort(const Comparator& aComparator) {
-    if (Count() < 2) {
+    if (Length() < 2) {
       // Only sort lists with more than one item.
       return;
     }
@@ -3225,7 +3227,7 @@
     // here.
     AutoTArray<Item, 20> items;
 
-    while (nsDisplayItem* item = RemoveBottom()) {
+    for (nsDisplayItem* item : TakeItems()) {
       items.AppendElement(Item(item));
     }
 
@@ -3236,10 +3238,14 @@
     }
   }
 
-  /**
-   * Returns true if any display item requires the surface to be transparent.
-   */
-  bool NeedsTransparentSurface() const { return mForceTransparentSurface; }
+  nsDisplayList TakeItems() {
+    nsDisplayList list = std::move(*this);
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+    list.mAllowNonEmptyDestruction = true;
+#endif
+    return list;
+  }
+
   /**
    * Paint the list to the rendering context. We assume that (0,0) in aCtx
    * corresponds to the origin of the reference frame. For best results,
@@ -3335,19 +3341,32 @@
    */
   nsRect GetBuildingRect() const;
 
-  void SetNeedsTransparentSurface() { mForceTransparentSurface = true; }
-
-  void RestoreState() { mForceTransparentSurface = false; }
-
  private:
-  nsDisplayItemLink mSentinel;
-  nsDisplayItemLink* mTop;
-
-  uint32_t mLength;
-
-  // This is set to true by FrameLayerBuilder if any display item in this
-  // list needs to force the surface containing this list to be transparent.
-  bool mForceTransparentSurface;
+  inline Node* Allocate(nsDisplayItem* aItem) {
+    void* ptr = mPool.Allocate(sizeof(Node));
+    return new (ptr) Node(aItem);
+  }
+
+  inline void Deallocate(Node* aNode) {
+    aNode->~Node();
+    // Memory remains reserved by the arena allocator.
+  }
+
+  void SetEmpty() {
+    mBottom = nullptr;
+    mTop = nullptr;
+    mLength = 0;
+  }
+
+  Node* mBottom = nullptr;
+  Node* mTop = nullptr;
+  size_t mLength = 0;
+  ListArenaAllocator& mPool;
+
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+  // This checks that the invariant of display lists owning their items is held.
+  bool mAllowNonEmptyDestruction = false;
+#endif
 };
 
 /**
@@ -3453,13 +3472,17 @@
 struct nsDisplayListCollection : public nsDisplayListSet {
   explicit nsDisplayListCollection(nsDisplayListBuilder* aBuilder)
       : nsDisplayListSet(&mLists[0], &mLists[1], &mLists[2], &mLists[3],
-                         &mLists[4], &mLists[5]) {}
-
+                         &mLists[4], &mLists[5]),
+        mLists{nsDisplayList{aBuilder}, nsDisplayList{aBuilder},
+               nsDisplayList{aBuilder}, nsDisplayList{aBuilder},
+               nsDisplayList{aBuilder}, nsDisplayList{aBuilder}} {}
+
+  /*
   explicit nsDisplayListCollection(nsDisplayListBuilder* aBuilder,
                                    nsDisplayList* aBorderBackground)
       : nsDisplayListSet(aBorderBackground, &mLists[1], &mLists[2], &mLists[3],
                          &mLists[4], &mLists[5]) {}
-
+*/
   /**
    * Sort all lists by content order.
    */
@@ -3497,29 +3520,33 @@
  */
 class RetainedDisplayList : public nsDisplayList {
  public:
-  RetainedDisplayList() = default;
-  RetainedDisplayList(RetainedDisplayList&& aOther) {
-    AppendToTop(&aOther);
-    mDAG = std::move(aOther.mDAG);
-  }
+  explicit RetainedDisplayList(nsDisplayListBuilder* aBuilder)
+      : nsDisplayList(aBuilder) {}
+
+  RetainedDisplayList(RetainedDisplayList&& aOther)
+      : nsDisplayList(std::move(aOther)), mDAG(std::move(aOther.mDAG)) {}
+
+  RetainedDisplayList(const RetainedDisplayList&) = delete;
+  RetainedDisplayList& operator=(const RetainedDisplayList&) = delete;
 
   ~RetainedDisplayList() override {
     MOZ_ASSERT(mOldItems.IsEmpty(), "Must empty list before destroying");
   }
 
   RetainedDisplayList& operator=(RetainedDisplayList&& aOther) {
-    MOZ_ASSERT(!Count(), "Can only move into an empty list!");
+    MOZ_ASSERT(IsEmpty(), "Can only move into an empty list!");
     MOZ_ASSERT(mOldItems.IsEmpty(), "Can only move into an empty list!");
-    AppendToTop(&aOther);
+
+    nsDisplayList::operator=(std::move(aOther));
     mDAG = std::move(aOther.mDAG);
     mOldItems = std::move(aOther.mOldItems);
     return *this;
   }
 
   RetainedDisplayList& operator=(nsDisplayList&& aOther) {
-    MOZ_ASSERT(!Count(), "Can only move into an empty list!");
+    MOZ_ASSERT(IsEmpty(), "Can only move into an empty list!");
     MOZ_ASSERT(mOldItems.IsEmpty(), "Can only move into an empty list!");
-    AppendToTop(&aOther);
+    nsDisplayList::operator=(std::move(aOther));
     return *this;
   }
 
@@ -4721,6 +4748,7 @@
 
   nsDisplayWrapList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
       : nsPaintedDisplayItem(aBuilder, aFrame),
+        mList(aBuilder),
         mFrameActiveScrolledRoot(aBuilder->CurrentActiveScrolledRoot()),
         mOverrideZIndex(0),
         mHasZIndexOverride(false) {
@@ -4740,6 +4768,7 @@
   nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
                     const nsDisplayWrapList& aOther)
       : nsPaintedDisplayItem(aBuilder, aOther),
+        mList(aBuilder),
         mListPtr(&mList),
         mFrameActiveScrolledRoot(aOther.mFrameActiveScrolledRoot),
         mMergedFrames(aOther.mMergedFrames.Clone()),
@@ -4814,12 +4843,6 @@
   Maybe<nscolor> IsUniform(nsDisplayListBuilder* aBuilder) const override;
 
   /**
-   * Checks if the given display item can be merged with this item.
-   * @return true if the merging is possible, otherwise false.
-   */
-  virtual bool CanMerge(const nsDisplayItem* aItem) const { return false; }
-
-  /**
    * Try to merge with the other item (which is below us in the display
    * list). This gets used by nsDisplayClip to coalesce clipping operations
    * (optimization), by nsDisplayOpacity to merge rendering for the same
@@ -6390,12 +6413,12 @@
   void CollectSorted3DTransformLeaves(nsDisplayListBuilder* aBuilder,
                                       nsTArray<TransformPolygon>& aLeaves);
 
+  mutable RetainedDisplayList mChildren;
   mutable Maybe<Matrix4x4Flagged> mTransform;
   mutable Maybe<Matrix4x4Flagged> mInverseTransform;
   // Accumulated transform of ancestors on the preserves-3d chain.
   UniquePtr<Matrix4x4> mTransformPreserves3D;
   nsRect mChildrenBuildingRect;
-  mutable RetainedDisplayList mChildren;
 
   // The untransformed bounds of |mChildren|.
   nsRect mChildBounds;
@@ -6693,50 +6716,58 @@
  public:
   FlattenedDisplayListIterator(nsDisplayListBuilder* aBuilder,
                                nsDisplayList* aList)
-      : FlattenedDisplayListIterator(aBuilder, aList, true) {}
-
-  virtual bool HasNext() const { return mNext || !mStack.IsEmpty(); }
+      : mBuilder(aBuilder), mStart(aList->begin()), mEnd(aList->end()) {
+    ResolveFlattening();
+  }
+
+  bool HasNext() const { return !AtEndOfCurrentList(); }
 
   nsDisplayItem* GetNextItem() {
-    if (!mNext) {
-      return nullptr;
-    }
-
-    nsDisplayItem* next = mNext;
-    mNext = next->GetAbove();
-
-    if (mNext && next->HasChildren() && mNext->HasChildren()) {
-      // Since |next| and |mNext| are container items in the same list,
-      // merging them might be possible.
-      next = TryMergingFrom(next);
+    MOZ_ASSERT(HasNext());
+
+    nsDisplayItem* current = NextItem();
+    Advance();
+
+    if (!AtEndOfCurrentList() && current->CanMerge(NextItem())) {
+      // Since we can merge at least two display items, create an array and
+      // collect mergeable display items there.
+      AutoTArray<nsDisplayItem*, 2> willMerge{current};
+
+      auto it = mStart;
+      while (it != mEnd) {
+        nsDisplayItem* next = *it;
+        if (current->CanMerge(next)) {
+          willMerge.AppendElement(next);
+          ++it;
+        } else {
+          break;
+        }
+      }
+      mStart = it;
+
+      current = mBuilder->MergeItems(willMerge);
     }
 
     ResolveFlattening();
-
-    return next;
-  }
-
-  nsDisplayItem* PeekNext() { return mNext; }
+    return current;
+  }
 
  protected:
-  FlattenedDisplayListIterator(nsDisplayListBuilder* aBuilder,
-                               nsDisplayList* aList,
-                               const bool aResolveFlattening)
-      : mBuilder(aBuilder), mNext(aList->GetBottom()) {
-    if (aResolveFlattening) {
-      // This is done conditionally in case subclass overrides
-      // ShouldFlattenNextItem().
-      ResolveFlattening();
-    }
-  }
-
-  virtual void EnterChildList(nsDisplayItem* aContainerItem) {}
-  virtual void ExitChildList() {}
-
-  bool AtEndOfNestedList() const { return !mNext && mStack.Length() > 0; }
-
-  virtual bool ShouldFlattenNextItem() {
-    return mNext && mNext->ShouldFlattenAway(mBuilder);
+  void Advance() { ++mStart; }
+
+  bool AtEndOfNestedList() const {
+    return AtEndOfCurrentList() && mStack.Length() > 0;
+  }
+
+  bool AtEndOfCurrentList() const { return mStart == mEnd; }
+
+  nsDisplayItem* NextItem() {
+    MOZ_ASSERT(HasNext());
+    return *mStart;
+  }
+
+  bool ShouldFlattenNextItem() {
+    return HasNext() && NextItem()->ShouldFlattenAway(mBuilder);
   }
 
   void ResolveFlattening() {
@@ -6745,60 +6776,36 @@
     // item, or the very end of the outer list.
     while (AtEndOfNestedList() || ShouldFlattenNextItem()) {
       if (AtEndOfNestedList()) {
-        ExitChildList();
-
-        // We reached the end of the list, pop the next item from the stack.
-        mNext = mStack.PopLastElement();
+        // We reached the end of the list, pop the next list from the stack.
+        std::tie(mStart, mEnd) = mStack.PopLastElement();
       } else {
-        EnterChildList(mNext);
-
-        // This item wants to be flattened. Store the next item on the stack,
-        // and use the first item in the child list instead.
-        mStack.AppendElement(mNext->GetAbove());
-        mNext = mNext->GetChildren()->GetBottom();
+        // The next item wants to be flattened. This means that we will skip the
+        // flattened item and directly iterate over its sublist.
+        MOZ_ASSERT(ShouldFlattenNextItem());
+
+        nsDisplayList* sublist = NextItem()->GetChildren();
+        MOZ_ASSERT(sublist);
+
+        // Skip the flattened item.
+        Advance();
+
+        // Store the current position on the stack.
+        if (!AtEndOfCurrentList()) {
+          mStack.AppendElement(std::make_pair(mStart, mEnd));
+        }
+
+        // Iterate over the sublist.
+        mStart = sublist->begin();
+        mEnd = sublist->end();
       }
     }
   }
 
-  /**
-   * Tries to merge display items starting from |aCurrent|.
-   * Updates the internal pointer to the next display item.
-   */
-  nsDisplayItem* TryMergingFrom(nsDisplayItem* aCurrent) {
-    MOZ_ASSERT(aCurrent);
-    MOZ_ASSERT(aCurrent->GetAbove());
-
-    nsDisplayWrapList* current = aCurrent->AsDisplayWrapList();
-    nsDisplayWrapList* next = mNext->AsDisplayWrapList();
-
-    if (!current || !next) {
-      // Either the current or the next item do not support merging.
-      return aCurrent;
-    }
-
-    // Attempt to merge |next| with |current|.
-    if (current->CanMerge(next)) {
-      // Merging is possible, collect all the successive mergeable items.
-      AutoTArray<nsDisplayWrapList*, 2> willMerge{current};
-
-      do {
-        willMerge.AppendElement(next);
-        mNext = next->GetAbove();
-        next = mNext ? mNext->AsDisplayWrapList() : nullptr;
-      } while (next && current->CanMerge(next));
-
-      current = mBuilder->MergeItems(willMerge);
-    }
-
-    // Here |mNext| will be either the first item that could not be merged with
-    // |current|, or nullptr.
-    return current;
-  }
-
  private:
   nsDisplayListBuilder* mBuilder;
-  nsDisplayItem* mNext;
-  AutoTArray<nsDisplayItem*, 16> mStack;
+  nsDisplayList::iterator mStart;
+  nsDisplayList::iterator mEnd;
+  nsTArray<std::pair<nsDisplayList::iterator, nsDisplayList::iterator>> mStack;
 };
 
 class PaintTelemetry {