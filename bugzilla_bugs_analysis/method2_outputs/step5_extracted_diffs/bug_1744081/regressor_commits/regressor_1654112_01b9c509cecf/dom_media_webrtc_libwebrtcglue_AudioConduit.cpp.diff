# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
# Commit: 01b9c509cecf
# Full Hash: 01b9c509cecf7b5c0435b5ca063c3b4b492480d7
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 3
# Description:
#   Bug 1654112 - Fix AudioConduit::SendAudioFrame to use the new AudioSendStream API. r=ng
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D102280
# ==============================================================================

diff -r 93367fdd03ec -r 01b9c509cecf dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Fri Jan 29 15:38:10 2021 +0100
+++ b/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Fri Jan 29 15:38:43 2021 +0100
@@ -549,48 +549,31 @@
 }
 
 MediaConduitErrorCode WebrtcAudioConduit::SendAudioFrame(
-    const int16_t audio_data[],
-    int32_t lengthSamples,  // per channel
-    int32_t samplingFreqHz, uint32_t channels, int32_t capture_delay) {
+    std::unique_ptr<webrtc::AudioFrame> frame) {
   CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
   // Following checks need to be performed
-  // 1. Non null audio buffer pointer,
-  // 2. invalid sampling frequency -  less than 0 or unsupported ones
-  // 3. Appropriate Sample Length for 10 ms audio-frame. This represents
-  //    block size the VoiceEngine feeds into encoder for passed in audio-frame
-  //    Ex: for 16000 sampling rate , valid block-length is 160
-  //    Similarly for 32000 sampling rate, valid block length is 320
-  //    We do the check by the verify modular operator below to be zero
+  // 1. Non null audio buffer pointer, and
+  // 2. Valid sample rate, and
+  // 3. Appropriate Sample Length for 10 ms audio-frame. This represents the
+  //    block size used upstream for processing.
+  //    Ex: for 16000 sample rate , valid block-length is 160.
+  //    Similarly for 32000 sample rate, valid block length is 320.
 
-  if (!audio_data || (lengthSamples <= 0) ||
-      (IsSamplingFreqSupported(samplingFreqHz) == false) ||
-      ((lengthSamples % (samplingFreqHz / 100) != 0))) {
+  if (!frame->data() ||
+      (IsSamplingFreqSupported(frame->sample_rate_hz()) == false) ||
+      ((frame->samples_per_channel() % (frame->sample_rate_hz() / 100) != 0))) {
     CSFLogError(LOGTAG, "%s Invalid Parameters ", __FUNCTION__);
     MOZ_ASSERT(PR_FALSE);
     return kMediaConduitMalformedArgument;
   }
 
-  // validate capture time
-  if (capture_delay < 0) {
-    CSFLogError(LOGTAG, "%s Invalid Capture Delay ", __FUNCTION__);
-    MOZ_ASSERT(PR_FALSE);
-    return kMediaConduitMalformedArgument;
-  }
-
   // if transmission is not started .. conduit cannot insert frames
   if (!mEngineTransmitting) {
     CSFLogError(LOGTAG, "%s Engine not transmitting ", __FUNCTION__);
     return kMediaConduitSessionNotInited;
   }
 
-  // Insert the samples
-  /*
-    mPtrVoEBase->audio_transport()->PushCaptureData(
-        mSendChannel, audio_data,
-        sizeof(audio_data[0]) * 8,  // bits
-        samplingFreqHz, channels, lengthSamples);
-  */
-  // we should be good here
+  mSendStream->SendAudioData(std::move(frame));
   return kMediaConduitNoError;
 }
 