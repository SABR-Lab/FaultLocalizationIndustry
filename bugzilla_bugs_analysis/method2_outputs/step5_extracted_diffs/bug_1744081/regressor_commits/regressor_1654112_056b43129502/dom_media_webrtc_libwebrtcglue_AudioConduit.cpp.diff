# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
# Commit: 056b43129502
# Full Hash: 056b43129502d9e831ede85c6d2ccadb71c54d32
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 2
# Description:
#   Bug 1654112 - Fix AudioConduit comments, member naming and other minor things. r=ng
#   
#   These fixes are made to reflect the current state of upstream.
#   
#   Some atomic members are now no longer atomic, since previous patches in the
# ==============================================================================

diff -r a55a718715f6 -r 056b43129502 dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Mon Jan 25 16:54:14 2021 +0100
+++ b/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Fri Jan 29 15:02:58 2021 +0100
@@ -472,7 +472,7 @@
   }
 
   // if transmission is not started .. conduit cannot insert frames
-  if (!mEngineTransmitting) {
+  if (!mSendStreamRunning) {
     CSFLogError(LOGTAG, "%s Engine not transmitting ", __FUNCTION__);
     return kMediaConduitSessionNotInited;
   }
@@ -501,7 +501,7 @@
 
   // Conduit should have reception enabled before we ask for decoded
   // samples
-  if (!mEngineReceiving) {
+  if (!mRecvStreamRunning) {
     CSFLogError(LOGTAG, "%s Engine not Receiving ", __FUNCTION__);
     return kMediaConduitSessionNotInited;
   }
@@ -648,12 +648,12 @@
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
 
-  if (mEngineTransmitting) {
+  if (mSendStreamRunning) {
     MOZ_ASSERT(mSendStream);
     CSFLogDebug(LOGTAG, "%s Engine Already Sending. Attemping to Stop ",
                 __FUNCTION__);
     mSendStream->Stop();
-    mEngineTransmitting = false;
+    mSendStreamRunning = false;
   }
 
   return kMediaConduitNoError;
@@ -663,7 +663,7 @@
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
 
-  if (mEngineTransmitting) {
+  if (mSendStreamRunning) {
     return kMediaConduitNoError;
   }
 
@@ -674,7 +674,7 @@
   mCall->Call()->SignalChannelNetworkState(webrtc::MediaType::AUDIO,
                                            webrtc::kNetworkUp);
   mSendStream->Start();
-  mEngineTransmitting = true;
+  mSendStreamRunning = true;
 
   return kMediaConduitNoError;
 }
@@ -683,10 +683,10 @@
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
 
-  if (mEngineReceiving) {
+  if (mRecvStreamRunning) {
     MOZ_ASSERT(mRecvStream);
     mRecvStream->Stop();
-    mEngineReceiving = false;
+    mRecvStreamRunning = false;
   }
 
   return kMediaConduitNoError;
@@ -696,7 +696,7 @@
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
 
-  if (mEngineReceiving) {
+  if (mRecvStreamRunning) {
     return kMediaConduitNoError;
   }
 
@@ -707,7 +707,7 @@
   mCall->Call()->SignalChannelNetworkState(webrtc::MediaType::AUDIO,
                                            webrtc::kNetworkUp);
   mRecvStream->Start();
-  mEngineReceiving = true;
+  mRecvStreamRunning = true;
 
   return kMediaConduitNoError;
 }
@@ -860,7 +860,7 @@
   mMutex.AssertCurrentThreadOwns();
   if (mSendStream) {
     mSendStream->Stop();
-    mEngineTransmitting = false;
+    mSendStreamRunning = false;
     mCall->Call()->DestroyAudioSendStream(mSendStream);
     mSendStream = nullptr;
   }
@@ -883,7 +883,7 @@
   mMutex.AssertCurrentThreadOwns();
   if (mRecvStream) {
     mRecvStream->Stop();
-    mEngineReceiving = false;
+    mRecvStreamRunning = false;
     mCall->Call()->DestroyAudioReceiveStream(mRecvStream);
     mRecvStream = nullptr;
   }
@@ -904,7 +904,7 @@
 
 bool WebrtcAudioConduit::RecreateSendStreamIfExists() {
   MutexAutoLock lock(mMutex);
-  bool wasTransmitting = mEngineTransmitting;
+  bool wasTransmitting = mSendStreamRunning;
   bool hadSendStream = mSendStream;
   DeleteSendStream();
 
@@ -921,8 +921,9 @@
 }
 
 bool WebrtcAudioConduit::RecreateRecvStreamIfExists() {
+  MOZ_ASSERT(NS_IsMainThread());
   MutexAutoLock lock(mMutex);
-  bool wasReceiving = mEngineReceiving;
+  bool wasReceiving = mRecvStreamRunning;
   bool hadRecvStream = mRecvStream;
   DeleteRecvStream();
 