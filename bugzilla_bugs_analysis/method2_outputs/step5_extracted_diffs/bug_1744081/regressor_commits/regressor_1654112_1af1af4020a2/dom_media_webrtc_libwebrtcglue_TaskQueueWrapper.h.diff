# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/TaskQueueWrapper.h
# Commit: 1af1af4020a2
# Full Hash: 1af1af4020a25da7b80c97ddb7816542bcca28ea
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 3
# Description:
#   Bug 1654112 - Create Call instances using the new Call config. r=ng,bwc
#   
#   This sets up our code for creating Call instances so that it works. A number of
#   things are left to do. Most notable fixing the threading model.
#   
# ==============================================================================

diff -r 23b8f56eec4b -r 1af1af4020a2 dom/media/webrtc/libwebrtcglue/TaskQueueWrapper.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/media/webrtc/libwebrtcglue/TaskQueueWrapper.h	Mon Jan 18 15:46:57 2021 +0100
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef DOM_MEDIA_WEBRTC_LIBWEBRTCGLUE_TASKQUEUEWRAPPER_H_
+#define DOM_MEDIA_WEBRTC_LIBWEBRTCGLUE_TASKQUEUEWRAPPER_H_
+
+#include "api/task_queue/task_queue_factory.h"
+#include "mozilla/DataMutex.h"
+#include "mozilla/TaskQueue.h"
+#include "VideoUtils.h"
+
+namespace mozilla {
+
+/**
+ * A wrapper around Mozilla TaskQueues in the shape of libwebrtc a TaskQueue.
+ *
+ * Allows libwebrtc to use Mozilla threads where tooling, e.g. profiling, is set
+ * up and just works.
+ *
+ * Mozilla APIs like Runnables, MozPromise, etc. can also be used with the
+ * wrapped TaskQueue to run things on the right thread when interacting with
+ * libwebrtc.
+ */
+class TaskQueueWrapper : public webrtc::TaskQueueBase {
+ public:
+  explicit TaskQueueWrapper(RefPtr<TaskQueue> aTaskQueue)
+      : mTaskQueue(std::move(aTaskQueue)) {}
+  ~TaskQueueWrapper() = default;
+
+  void Delete() override {
+    MOZ_ASSERT(NS_IsMainThread());
+    // Must block this thread until shutdown is complete.
+    {
+      auto hasShutdown = mHasShutdown.Lock();
+      *hasShutdown = true;
+      mTaskQueue->BeginShutdown();
+    }
+    mTaskQueue->AwaitIdle();
+    delete this;
+  }
+
+  already_AddRefed<Runnable> CreateTaskRunner(
+      std::unique_ptr<webrtc::QueuedTask> aTask) {
+    return NS_NewRunnableFunction("TaskQueueWrapper::CreateTaskRunner",
+                                  [this, task = std::move(aTask)]() mutable {
+                                    CurrentTaskQueueSetter current(this);
+                                    auto hasShutdown = mHasShutdown.Lock();
+                                    if (*hasShutdown) {
+                                      return;
+                                    }
+                                    bool toDelete = task->Run();
+                                    if (!toDelete) {
+                                      task.release();
+                                    }
+                                  });
+  }
+
+  void PostTask(std::unique_ptr<webrtc::QueuedTask> aTask) override {
+    MOZ_ALWAYS_SUCCEEDS(
+        mTaskQueue->Dispatch(CreateTaskRunner(std::move(aTask))));
+  }
+
+  void PostDelayedTask(std::unique_ptr<webrtc::QueuedTask> aTask,
+                       uint32_t aMilliseconds) override {
+    if (aMilliseconds == 0) {
+      // AbstractThread::DelayedDispatch doesn't support delay 0
+      PostTask(std::move(aTask));
+      return;
+    }
+    MOZ_ALWAYS_SUCCEEDS(mTaskQueue->DelayedDispatch(
+        CreateTaskRunner(std::move(aTask)), aMilliseconds));
+  }
+
+  const RefPtr<TaskQueue> mTaskQueue;
+  DataMutex<bool> mHasShutdown{false, "TaskQueueWrapper::mHasShutdown"};
+};
+
+template <>
+class DefaultDelete<TaskQueueWrapper> : public webrtc::TaskQueueDeleter {
+ public:
+  void operator()(TaskQueueWrapper* aPtr) const {
+    webrtc::TaskQueueDeleter::operator()(aPtr);
+  }
+};
+
+class SharedThreadPoolWebRtcTaskQueueFactory : public webrtc::TaskQueueFactory {
+ public:
+  SharedThreadPoolWebRtcTaskQueueFactory() {}
+
+  std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>
+  CreateTaskQueue(absl::string_view aName, Priority aPriority) const override {
+    // XXX Do something with aPriority
+    nsCString name(aName.data(), aName.size());
+    auto taskQueue = MakeRefPtr<TaskQueue>(
+        GetMediaThreadPool(MediaThreadType::WEBRTC_DECODER), name.get());
+    return std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>(
+        new TaskQueueWrapper(std::move(taskQueue)), webrtc::TaskQueueDeleter());
+  }
+};
+
+}  // namespace mozilla
+
+#endif