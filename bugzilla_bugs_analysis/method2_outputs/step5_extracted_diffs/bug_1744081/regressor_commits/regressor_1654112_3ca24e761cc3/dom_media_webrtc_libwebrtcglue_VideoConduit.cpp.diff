# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
# Commit: 3ca24e761cc3
# Full Hash: 3ca24e761cc31bbb71c659661874a995ef3d3db1
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 6
# Description:
#   Bug 1654112 - Remove WebrtcGmpPCHandleSetter and plumb pc handles explicitly. r=bwc
#   
#   With the libwebrtc update codecs will be created off-main.
#   WebrtcGmpPCHandleSetter not only adds a lot of indirection, it is also
#   main-thread-only. With this patch we can create gmp codecs on any thread.
# ==============================================================================

diff -r 1913c332695e -r 3ca24e761cc3 dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Wed Feb 10 09:58:11 2021 +0100
+++ b/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Wed Feb 10 10:34:14 2021 +0100
@@ -287,8 +287,8 @@
  * Factory Method for VideoConduit
  */
 RefPtr<VideoSessionConduit> VideoSessionConduit::Create(
-    RefPtr<WebRtcCallWrapper> aCall,
-    nsCOMPtr<nsISerialEventTarget> aStsThread) {
+    RefPtr<WebRtcCallWrapper> aCall, nsCOMPtr<nsISerialEventTarget> aStsThread,
+    std::string aPCHandle) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aCall, "missing required parameter: aCall");
   CSFLogVerbose(LOGTAG, "%s", __FUNCTION__);
@@ -297,7 +297,8 @@
     return nullptr;
   }
 
-  auto obj = MakeRefPtr<WebrtcVideoConduit>(aCall, aStsThread);
+  auto obj =
+      MakeRefPtr<WebrtcVideoConduit>(aCall, aStsThread, std::move(aPCHandle));
   if (obj->Init() != kMediaConduitNoError) {
     CSFLogError(LOGTAG, "%s VideoConduit Init Failed ", __FUNCTION__);
     return nullptr;
@@ -307,12 +308,14 @@
 }
 
 WebrtcVideoConduit::WebrtcVideoConduit(
-    RefPtr<WebRtcCallWrapper> aCall, nsCOMPtr<nsISerialEventTarget> aStsThread)
+    RefPtr<WebRtcCallWrapper> aCall, nsCOMPtr<nsISerialEventTarget> aStsThread,
+    std::string aPCHandle)
     : mTransportMonitor("WebrtcVideoConduit"),
       mStsThread(aStsThread),
       mMutex("WebrtcVideoConduit::mMutex"),
-      mDecoderFactory(MakeUnique<WebrtcVideoDecoderFactory>()),
-      mEncoderFactory(MakeUnique<WebrtcVideoEncoderFactory>()),
+      mDecoderFactory(MakeUnique<WebrtcVideoDecoderFactory>(aPCHandle)),
+      mEncoderFactory(
+          MakeUnique<WebrtcVideoEncoderFactory>(std::move(aPCHandle))),
       mVideoAdapter(MakeUnique<cricket::VideoAdapter>()),
       mBufferPool(false, SCALER_BUFFER_POOL_SIZE),
       mEngineTransmitting(false),
@@ -1449,15 +1452,9 @@
 
       // Ensure lamba captures refs
       NS_DispatchToMainThread(NS_NewRunnableFunction(
-          "WebrtcVideoConduit::WebrtcGmpPCHandleSetter",
+          "WebrtcVideoConduit::SetRemoteSSRC",
           [this, self = RefPtr<WebrtcVideoConduit>(this),
            ssrc = header.ssrc]() mutable {
-            // Normally this is done in CreateOrUpdateMediaPipeline() for
-            // initial creation and renegotiation, but here we're rebuilding the
-            // Receive channel at a lower level.  This is needed whenever we're
-            // creating a GMPVideoCodec (in particular, H264) so it can
-            // communicate errors to the PC.
-            WebrtcGmpPCHandleSetter setter(mPCHandle);
             // TODO: This is problematic with rtx enabled, we don't know if
             // new ssrc is for rtx or not. This is fixed in a later patch in
             // this series.