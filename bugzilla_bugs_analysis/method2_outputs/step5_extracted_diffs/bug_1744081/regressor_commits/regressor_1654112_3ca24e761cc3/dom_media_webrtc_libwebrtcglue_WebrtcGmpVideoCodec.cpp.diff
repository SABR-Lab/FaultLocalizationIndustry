# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/WebrtcGmpVideoCodec.cpp
# Commit: 3ca24e761cc3
# Full Hash: 3ca24e761cc31bbb71c659661874a995ef3d3db1
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 6
# Description:
#   Bug 1654112 - Remove WebrtcGmpPCHandleSetter and plumb pc handles explicitly. r=bwc
#   
#   With the libwebrtc update codecs will be created off-main.
#   WebrtcGmpPCHandleSetter not only adds a lot of indirection, it is also
#   main-thread-only. With this patch we can create gmp codecs on any thread.
# ==============================================================================

diff -r 1913c332695e -r 3ca24e761cc3 dom/media/webrtc/libwebrtcglue/WebrtcGmpVideoCodec.cpp
--- a/dom/media/webrtc/libwebrtcglue/WebrtcGmpVideoCodec.cpp	Wed Feb 10 09:58:11 2021 +0100
+++ b/dom/media/webrtc/libwebrtcglue/WebrtcGmpVideoCodec.cpp	Wed Feb 10 10:34:14 2021 +0100
@@ -24,44 +24,16 @@
 
 namespace mozilla {
 
-WebrtcGmpPCHandleSetter::WebrtcGmpPCHandleSetter(const std::string& aPCHandle) {
-  if (!NS_IsMainThread()) {
-    MOZ_ASSERT(false, "WebrtcGmpPCHandleSetter can only be used on main");
-    return;
-  }
-  MOZ_ASSERT(sCurrentHandle.empty());
-  sCurrentHandle = aPCHandle;
-}
-
-WebrtcGmpPCHandleSetter::~WebrtcGmpPCHandleSetter() {
-  if (!NS_IsMainThread()) {
-    MOZ_ASSERT(false, "WebrtcGmpPCHandleSetter can only be used on main");
-    return;
-  }
-
-  sCurrentHandle.clear();
-}
-
-/* static */ std::string WebrtcGmpPCHandleSetter::GetCurrentHandle() {
-  if (!NS_IsMainThread()) {
-    MOZ_ASSERT(false, "WebrtcGmpPCHandleSetter can only be used on main");
-    return "";
-  }
-
-  return sCurrentHandle;
-}
-
-std::string WebrtcGmpPCHandleSetter::sCurrentHandle;
-
 // Encoder.
-WebrtcGmpVideoEncoder::WebrtcGmpVideoEncoder()
+WebrtcGmpVideoEncoder::WebrtcGmpVideoEncoder(std::string aPCHandle)
     : mGMP(nullptr),
       mInitting(false),
       mHost(nullptr),
       mMaxPayloadSize(0),
       mCallbackMutex("WebrtcGmpVideoEncoder encoded callback mutex"),
       mCallback(nullptr),
-      mCachedPluginId(0) {
+      mCachedPluginId(0),
+      mPCHandle(std::move(aPCHandle)) {
   mCodecParams.mGMPApiVersion = 0;
   mCodecParams.mCodecType = kGMPVideoCodecInvalid;
   mCodecParams.mPLType = 0;
@@ -76,9 +48,6 @@
   mCodecParams.mQPMax = 0;
   mCodecParams.mNumberOfSimulcastStreams = 0;
   mCodecParams.mMode = kGMPCodecModeInvalid;
-  if (mPCHandle.empty()) {
-    mPCHandle = WebrtcGmpPCHandleSetter::GetCurrentHandle();
-  }
   MOZ_ASSERT(!mPCHandle.empty());
 }
 
@@ -643,17 +612,15 @@
 }
 
 // Decoder.
-WebrtcGmpVideoDecoder::WebrtcGmpVideoDecoder()
+WebrtcGmpVideoDecoder::WebrtcGmpVideoDecoder(std::string aPCHandle)
     : mGMP(nullptr),
       mInitting(false),
       mHost(nullptr),
       mCallbackMutex("WebrtcGmpVideoDecoder decoded callback mutex"),
       mCallback(nullptr),
       mCachedPluginId(0),
-      mDecoderStatus(GMPNoErr) {
-  if (mPCHandle.empty()) {
-    mPCHandle = WebrtcGmpPCHandleSetter::GetCurrentHandle();
-  }
+      mDecoderStatus(GMPNoErr),
+      mPCHandle(std::move(aPCHandle)) {
   MOZ_ASSERT(!mPCHandle.empty());
 }
 