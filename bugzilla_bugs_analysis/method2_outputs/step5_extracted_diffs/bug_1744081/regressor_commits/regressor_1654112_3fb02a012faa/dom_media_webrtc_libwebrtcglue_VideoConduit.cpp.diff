# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
# Commit: 3fb02a012faa
# Full Hash: 3fb02a012faadb59c6a4ca42bfb50bcbb1037d93
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 5
# Description:
#   Bug 1654112 - Route packets with MediaEvents, and clean up conduits' cross-thread syncing. r=bwc,ng
#   
#   This patch solves some issues with the SSRC switching that can be triggered by
#   both signaling and incoming packets, on different threads. But mainly, because
#   that setup is inherently complex, this patch greatly simplifies the SSRC
# ==============================================================================

diff -r 336f58a54bd8 -r 3fb02a012faa dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Wed Aug 25 20:28:12 2021 +0200
+++ b/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Thu Sep 09 17:42:30 2021 +0200
@@ -22,6 +22,7 @@
 #include "nsIPrefService.h"
 #include "nsServiceManagerUtils.h"
 #include "RtpRtcpConfig.h"
+#include "transport/SrtpFlow.h"  // For SRTP_MAX_EXPANSION
 #include "VideoStreamFactory.h"
 #include "WebrtcCallWrapper.h"
 #include "WebrtcGmpVideoCodec.h"
@@ -373,7 +374,7 @@
 WebrtcVideoConduit::WebrtcVideoConduit(
     RefPtr<WebrtcCallWrapper> aCall, nsCOMPtr<nsISerialEventTarget> aStsThread,
     Options aOptions, std::string aPCHandle)
-    : mTransportMonitor("WebrtcVideoConduit"),
+    : mRendererMonitor("WebrtcVideoConduit::mRendererMonitor"),
       mCallThread(aCall->mCallThread),
       mStsThread(std::move(aStsThread)),
       mControl(aCall->mCallThread),
@@ -398,14 +399,12 @@
       mSpatialLayers(aOptions.mSpatialLayers),
       mTemporalLayers(aOptions.mTemporalLayers),
       mCall(std::move(aCall)),
-      mSendStreamConfig(
-          this)  // 'this' is stored but not dereferenced in the constructor.
-      ,
-      mRecvStreamConfig(
-          this)  // 'this' is stored but not dereferenced in the constructor.
-      ,
-      mRecvSSRC(0),
-      mRemoteSSRC(0) {}
+      mSendTransport(this),
+      mRecvTransport(this),
+      mSendStreamConfig(&mSendTransport),
+      mRecvStreamConfig(&mRecvTransport) {
+  mRecvStreamConfig.rtp.rtcp_event_observer = this;
+}
 
 WebrtcVideoConduit::~WebrtcVideoConduit() {
   CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
@@ -452,12 +451,10 @@
 
   bool encoderReconfigureNeeded = false;
   bool remoteSsrcUpdateNeeded = false;
-  bool isInitialRemoteSsrcUpdate = false;
   bool recvStreamRecreationNeeded = false;
   bool sendStreamRecreationNeeded = false;
 
   if (mControl.mRemoteSsrc.Ref() != mControl.mConfiguredRemoteSsrc) {
-    isInitialRemoteSsrcUpdate = mControl.mConfiguredRemoteSsrc == 0;
     mControl.mConfiguredRemoteSsrc = mControl.mRemoteSsrc;
     recvStreamRecreationNeeded = true;
     remoteSsrcUpdateNeeded = true;
@@ -842,13 +839,6 @@
     SetRemoteSSRCLocked(mControl.mConfiguredRemoteSsrc,
                         mControl.mConfiguredRemoteRtxSsrc);
   }
-  if (isInitialRemoteSsrcUpdate) {
-    mStsThread->Dispatch(NS_NewRunnableFunction(
-        "WebrtcVideoConduit::WaitingForSignaledSsrcNoMore",
-        [this, self = RefPtr<WebrtcVideoConduit>(this)]() mutable {
-          mWaitingForSignaledSsrc = false;
-        }));
-  }
   {
     // Handle un-signalled SSRCs by creating random ones and then when they
     // actually get set, we'll destroy and recreate.
@@ -954,7 +944,6 @@
   }
 
   mRecvStreamConfig.decoder_factory = mDecoderFactory.get();
-  mRecvStreamConfig.rtp.rtcp_event_observer = this;
 
   mRecvStream =
       mCall->Call()->CreateVideoReceiveStream(mRecvStreamConfig.Copy());
@@ -1063,8 +1052,6 @@
     return;
   }
 
-  mRecvStreamConfig.rtp.rtx_ssrc = 0;
-
   const auto& ssrcs = mSendStreamConfig.rtp.ssrcs;
   uint32_t our_ssrc = 0;
   do {
@@ -1081,14 +1068,13 @@
   SetRemoteSSRCLocked(our_ssrc, 0);
 }
 
-bool WebrtcVideoConduit::GetRemoteSSRC(uint32_t* ssrc) const {
-  if (mCallThread->IsOnCurrentThread()) {
-    if (!mRecvStream) {
-      return false;
-    }
+bool WebrtcVideoConduit::GetRemoteSSRC(uint32_t* aSsrc) const {
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
+  if (!mRecvStream) {
+    return false;
   }
   // libwebrtc uses 0 to mean a lack of SSRC. That is not to spec.
-  *ssrc = mRemoteSSRC;
+  *aSsrc = mRecvStreamConfig.rtp.remote_ssrc;
   return true;
 }
 
@@ -1243,7 +1229,7 @@
   // This function is called only from main, so we only need to protect against
   // modifying mRenderer while any webrtc.org code is trying to use it.
   {
-    ReentrantMonitorAutoEnter enter(mTransportMonitor);
+    ReentrantMonitorAutoEnter enter(mRendererMonitor);
     mRenderer = aVideoRenderer;
     // Make sure the renderer knows the resolution
     mRenderer->FrameSizeChange(mReceivingWidth, mReceivingHeight);
@@ -1255,36 +1241,12 @@
 void WebrtcVideoConduit::DetachRenderer() {
   MOZ_ASSERT(NS_IsMainThread());
 
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
+  ReentrantMonitorAutoEnter enter(mRendererMonitor);
   if (mRenderer) {
     mRenderer = nullptr;
   }
 }
 
-MediaConduitErrorCode WebrtcVideoConduit::SetTransmitterTransport(
-    RefPtr<TransportInterface> aTransport) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
-
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
-  // set the transport
-  mTransmitterTransport = aTransport;
-  return kMediaConduitNoError;
-}
-
-MediaConduitErrorCode WebrtcVideoConduit::SetReceiverTransport(
-    RefPtr<TransportInterface> aTransport) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
-
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
-  // set the transport
-  mReceiverTransport = aTransport;
-  return kMediaConduitNoError;
-}
-
 // XXX we need to figure out how to feed back changes in preferred capture
 // resolution to the getUserMedia source.
 void WebrtcVideoConduit::SelectSendResolution(unsigned short width,
@@ -1445,108 +1407,71 @@
 
 void WebrtcVideoConduit::DeliverPacket(rtc::CopyOnWriteBuffer packet,
                                        PacketType type) {
-  ASSERT_ON_THREAD(mStsThread);
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
 
-  MOZ_ALWAYS_SUCCEEDS(mCallThread->Dispatch(NS_NewRunnableFunction(
-      __func__, [this, self = RefPtr<WebrtcVideoConduit>(this),
-                 packet = std::move(packet), type] {
-        if (!mCall->Call()) {
-          return;
-        }
+  if (!mCall->Call()) {
+    return;
+  }
 
-        // Bug 1499796 - we need to get passed the time the packet was received
-        webrtc::PacketReceiver::DeliveryStatus status =
-            mCall->Call()->Receiver()->DeliverPacket(webrtc::MediaType::VIDEO,
-                                                     std::move(packet), -1);
+  // Bug 1499796 - we need to get passed the time the packet was received
+  webrtc::PacketReceiver::DeliveryStatus status =
+      mCall->Call()->Receiver()->DeliverPacket(webrtc::MediaType::VIDEO,
+                                               std::move(packet), -1);
 
-        if (status != webrtc::PacketReceiver::DELIVERY_OK) {
-          CSFLogError(LOGTAG, "%s DeliverPacket Failed for %s packet, %d",
-                      __FUNCTION__, type == PacketType::RTP ? "RTP" : "RTCP",
-                      status);
-        }
-      })));
+  if (status != webrtc::PacketReceiver::DELIVERY_OK) {
+    CSFLogError(LOGTAG, "%s DeliverPacket Failed for %s packet, %d",
+                __FUNCTION__, type == PacketType::RTP ? "RTP" : "RTCP", status);
+  }
 }
 
-void WebrtcVideoConduit::ReceivedRTPPacket(const uint8_t* data, int len,
-                                           webrtc::RTPHeader& header) {
-  ASSERT_ON_THREAD(mStsThread);
+void WebrtcVideoConduit::OnRtpReceived(MediaPacket&& aPacket,
+                                       webrtc::RTPHeader&& aHeader) {
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
+
+  mRemoteSendSSRC = aHeader.ssrc;
 
-  if (mAllowSsrcChange || mWaitingForSignaledSsrc) {
-    // Handle the unknown ssrc (and ssrc-not-signaled case).
-    // We can't just do this here; it has to happen on the Call thread.
-    // We also don't want to drop the packet, nor block this thread, so we hold
-    // the packet (and any following) for inserting once the SSRC is set.
-    if (mRtpPacketQueue.IsQueueActive()) {
-      mRtpPacketQueue.Enqueue(rtc::CopyOnWriteBuffer(data, len));
-      return;
-    }
+  if (mAllowSsrcChange || mRecvStreamConfig.rtp.remote_ssrc == 0) {
+    bool switchRequired = mRecvStreamConfig.rtp.remote_ssrc != aHeader.ssrc;
+    if (switchRequired) {
+      // Handle the unknown ssrc (and ssrc-not-signaled case).
 
-    bool switchRequired = mRecvSSRC != header.ssrc;
-    if (switchRequired) {
       // We need to check that the newly received ssrc is not already
       // associated with ulpfec or rtx. This is how webrtc.org handles
       // things, see https://codereview.webrtc.org/1226093002.
-      MutexAutoLock lock(mMutex);
       const webrtc::VideoReceiveStream::Config::Rtp& rtp =
           mRecvStreamConfig.rtp;
       switchRequired =
-          rtp.rtx_associated_payload_types.find(header.payloadType) ==
+          rtp.rtx_associated_payload_types.find(aHeader.payloadType) ==
               rtp.rtx_associated_payload_types.end() &&
-          rtp.ulpfec_payload_type != header.payloadType;
+          rtp.ulpfec_payload_type != aHeader.payloadType;
     }
 
     if (switchRequired) {
-      // a new switch needs to be done
-      // any queued packets are from a previous switch that hasn't completed
-      // yet; drop them and only process the latest SSRC
-      mRtpPacketQueue.Clear();
-      mRtpPacketQueue.Enqueue(rtc::CopyOnWriteBuffer(data, len));
-
-      CSFLogDebug(LOGTAG, "%s: switching from SSRC %u to %u", __FUNCTION__,
-                  static_cast<uint32_t>(mRecvSSRC), header.ssrc);
-      // we "switch" here immediately, but buffer until the queue is released
-      mRecvSSRC = mRemoteSSRC = header.ssrc;
-
-      InvokeAsync(mCallThread, __func__,
-                  [this, self = RefPtr<WebrtcVideoConduit>(this),
-                   ssrc = header.ssrc]() mutable {
-                    // TODO: This is problematic with rtx
-                    // enabled, we don't know if new ssrc is for
-                    // rtx or not. This will likely re-create the
-                    // VideoReceiveStream
-                    MutexAutoLock lock(mMutex);
-                    SetRemoteSSRCLocked(ssrc, 0);
-                    return GenericPromise::CreateAndResolve(true, __func__);
-                  })
-          ->Then(mStsThread, __func__,
-                 [this, self = RefPtr<WebrtcVideoConduit>(this),
-                  ssrc = header.ssrc]() mutable {
-                   // We want to unblock the queued packets on the original
-                   // thread
-                   if (ssrc != mRecvSSRC) {
-                     // this is an intermediate switch; another is in-flight
-                     return;
-                   }
-                   mRtpPacketQueue.DequeueAll(this);
-                 });
-      return;
+      CSFLogInfo(LOGTAG, "VideoConduit %p: Switching remote SSRC from %u to %u",
+                 this, mRecvStreamConfig.rtp.remote_ssrc, aHeader.ssrc);
+      SetRemoteSSRCLocked(aHeader.ssrc, 0);
     }
   }
 
-  CSFLogVerbose(LOGTAG, "%s: seq# %u, Len %d, SSRC %u (0x%x) ", __FUNCTION__,
-                (uint16_t)ntohs(((uint16_t*)data)[1]), len,
-                (uint32_t)ntohl(((uint32_t*)data)[2]),
-                (uint32_t)ntohl(((uint32_t*)data)[2]));
+  CSFLogVerbose(
+      LOGTAG,
+      "VideoConduit %p: Received RTP packet, seq# %u, len %zu, SSRC %u (0x%x) ",
+      this, (uint16_t)ntohs(((uint16_t*)aPacket.data())[1]), aPacket.len(),
+      (uint32_t)ntohl(((uint32_t*)aPacket.data())[2]),
+      (uint32_t)ntohl(((uint32_t*)aPacket.data())[2]));
 
-  DeliverPacket(rtc::CopyOnWriteBuffer(data, len), PacketType::RTP);
+  DeliverPacket(rtc::CopyOnWriteBuffer(aPacket.data(), aPacket.len()),
+                PacketType::RTP);
 }
 
-void WebrtcVideoConduit::ReceivedRTCPPacket(const uint8_t* data, int len) {
-  ASSERT_ON_THREAD(mStsThread);
+void WebrtcVideoConduit::OnRtcpReceived(MediaPacket&& aPacket) {
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
 
-  CSFLogVerbose(LOGTAG, " %s Len %d ", __FUNCTION__, len);
+  CSFLogVerbose(LOGTAG, "VideoConduit %p: Received RTCP Packet, len %zu ", this,
+                aPacket.len());
 
-  DeliverPacket(rtc::CopyOnWriteBuffer(data, len), PacketType::RTCP);
+  DeliverPacket(rtc::CopyOnWriteBuffer(aPacket.data(), aPacket.len()),
+                PacketType::RTCP);
 
   // TODO(bug 1496533): We will need to keep separate timestamps for each SSRC,
   // and for each SSRC we will need to keep a timestamp for SR and RR.
@@ -1556,7 +1481,7 @@
 // TODO(bug 1496533): We will need to add a type (ie; SR or RR) param here, or
 // perhaps break this function into two functions, one for each type.
 Maybe<DOMHighResTimeStamp> WebrtcVideoConduit::LastRtcpReceived() const {
-  ASSERT_ON_THREAD(mStsThread);
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
   return mLastRtcpReceived;
 }
 
@@ -1653,26 +1578,29 @@
   return kMediaConduitNoError;
 }
 
-// WebRTC::RTP Callback Implementation
-// Called on MTG thread
-bool WebrtcVideoConduit::SendRtp(const uint8_t* packet, size_t length,
-                                 const webrtc::PacketOptions& options) {
-  CSFLogVerbose(LOGTAG, "%s Sent RTP Packet seq %d, len %lu, SSRC %u (0x%x)",
-                __FUNCTION__, (uint16_t)ntohs(*((uint16_t*)&packet[2])),
-                (unsigned long)length,
-                (uint32_t)ntohl(*((uint32_t*)&packet[8])),
-                (uint32_t)ntohl(*((uint32_t*)&packet[8])));
+bool WebrtcVideoConduit::SendRtp(const uint8_t* aData, size_t aLength,
+                                 const webrtc::PacketOptions& aOptions) {
+  CSFLogVerbose(
+      LOGTAG,
+      "VideoConduit %p: Sending RTP Packet seq# %u, len %zu, SSRC %u (0x%x)",
+      this, (uint16_t)ntohs(*((uint16_t*)&aData[2])), aLength,
+      (uint32_t)ntohl(*((uint32_t*)&aData[8])),
+      (uint32_t)ntohl(*((uint32_t*)&aData[8])));
 
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
-  if (!mTransmitterTransport ||
-      NS_FAILED(mTransmitterTransport->SendRtpPacket(packet, length))) {
-    CSFLogError(LOGTAG, "%s RTP Packet Send Failed ", __FUNCTION__);
+  if (!mTransportActive) {
+    CSFLogError(LOGTAG, "VideoConduit %p: RTP Packet Send Failed", this);
     return false;
   }
-  if (options.packet_id >= 0) {
+
+  MediaPacket packet;
+  packet.Copy(aData, aLength, aLength + SRTP_MAX_EXPANSION);
+  packet.SetType(MediaPacket::RTP);
+  mSenderRtpSendEvent.Notify(std::move(packet));
+
+  if (aOptions.packet_id >= 0) {
     int64_t now_ms = PR_Now() / 1000;
     MOZ_ALWAYS_SUCCEEDS(mCallThread->Dispatch(NS_NewRunnableFunction(
-        __func__, [call = mCall, packet_id = options.packet_id, now_ms] {
+        __func__, [call = mCall, packet_id = aOptions.packet_id, now_ms] {
           if (call->Call()) {
             call->Call()->OnSentPacket({packet_id, now_ms});
           }
@@ -1681,41 +1609,64 @@
   return true;
 }
 
-// Called from multiple threads including webrtc Process thread
-bool WebrtcVideoConduit::SendRtcp(const uint8_t* packet, size_t length) {
-  CSFLogVerbose(LOGTAG, "%s : len %lu ", __FUNCTION__, (unsigned long)length);
-  // We come here if we have only one pipeline/conduit setup,
-  // such as for unidirectional streams.
-  // We also end up here if we are receiving
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
-  if (mReceiverTransport &&
-      NS_SUCCEEDED(mReceiverTransport->SendRtcpPacket(packet, length))) {
-    // Might be a sender report, might be a receiver report, we don't know.
-    CSFLogDebug(LOGTAG, "%s Sent RTCP Packet ", __FUNCTION__);
-    return true;
-  }
-  if (mTransmitterTransport &&
-      NS_SUCCEEDED(mTransmitterTransport->SendRtcpPacket(packet, length))) {
-    return true;
+bool WebrtcVideoConduit::SendSenderRtcp(const uint8_t* aData, size_t aLength) {
+  CSFLogVerbose(
+      LOGTAG,
+      "VideoConduit %p: Sending RTCP SR Packet, len %zu, SSRC %u (0x%x)", this,
+      aLength, (uint32_t)ntohl(*((uint32_t*)&aData[4])),
+      (uint32_t)ntohl(*((uint32_t*)&aData[4])));
+
+  if (!mTransportActive) {
+    CSFLogError(LOGTAG, "VideoConduit %p: RTCP SR Packet Send Failed", this);
+    return false;
   }
 
-  CSFLogError(LOGTAG, "%s RTCP Packet Send Failed ", __FUNCTION__);
-  return false;
+  MediaPacket packet;
+  packet.Copy(aData, aLength, aLength + SRTP_MAX_EXPANSION);
+  packet.SetType(MediaPacket::RTCP);
+  mSenderRtcpSendEvent.Notify(std::move(packet));
+  return true;
+}
+
+bool WebrtcVideoConduit::SendReceiverRtcp(const uint8_t* aData,
+                                          size_t aLength) {
+  CSFLogVerbose(
+      LOGTAG,
+      "VideoConduit %p: Sending RTCP RR Packet, len %zu, SSRC %u (0x%x)", this,
+      aLength, (uint32_t)ntohl(*((uint32_t*)&aData[4])),
+      (uint32_t)ntohl(*((uint32_t*)&aData[4])));
+
+  if (!mTransportActive) {
+    CSFLogError(LOGTAG, "VideoConduit %p: RTCP RR Packet Send Failed", this);
+    return false;
+  }
+
+  MediaPacket packet;
+  packet.Copy(aData, aLength, aLength + SRTP_MAX_EXPANSION);
+  packet.SetType(MediaPacket::RTCP);
+  mReceiverRtcpSendEvent.Notify(std::move(packet));
+  return true;
 }
 
 void WebrtcVideoConduit::OnFrame(const webrtc::VideoFrame& video_frame) {
-  CSFLogVerbose(LOGTAG, "%s: recv SSRC %u (0x%x), size %ux%u", __FUNCTION__,
-                static_cast<uint32_t>(mRecvSSRC),
-                static_cast<uint32_t>(mRecvSSRC), video_frame.width(),
-                video_frame.height());
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
+  const uint32_t localRecvSsrc = mRecvSSRC;
+  const uint32_t remoteSendSsrc = mRemoteSendSSRC;
+
+  CSFLogVerbose(
+      LOGTAG,
+      "VideoConduit %p: Rendering frame, Remote SSRC %u (0x%x), size %ux%u",
+      this, static_cast<uint32_t>(remoteSendSsrc),
+      static_cast<uint32_t>(remoteSendSsrc), video_frame.width(),
+      video_frame.height());
+  ReentrantMonitorAutoEnter enter(mRendererMonitor);
 
   if (!mRenderer) {
-    CSFLogError(LOGTAG, "%s Renderer is NULL  ", __FUNCTION__);
+    CSFLogError(LOGTAG, "VideoConduit %p: Cannot render frame, no renderer",
+                this);
     return;
   }
 
-  bool needsNewHistoryElement = !mReceivedFrameHistory.mEntries.Length();
+  bool needsNewHistoryElement = mReceivedFrameHistory.mEntries.IsEmpty();
 
   if (mReceivingWidth != video_frame.width() ||
       mReceivingHeight != video_frame.height()) {
@@ -1725,19 +1676,13 @@
     needsNewHistoryElement = true;
   }
 
-  uint32_t remoteSsrc;
-  if (!GetRemoteSSRC(&remoteSsrc) && needsNewHistoryElement) {
-    // Frame was decoded after the connection ended
-    return;
-  }
-
   if (!needsNewHistoryElement) {
     auto& currentEntry = mReceivedFrameHistory.mEntries.LastElement();
     needsNewHistoryElement =
         currentEntry.mRotationAngle !=
             static_cast<unsigned long>(video_frame.rotation()) ||
-        currentEntry.mLocalSsrc != mRecvSSRC ||
-        currentEntry.mRemoteSsrc != remoteSsrc;
+        currentEntry.mLocalSsrc != localRecvSsrc ||
+        currentEntry.mRemoteSsrc != remoteSendSsrc;
   }
 
   // Record frame history
@@ -1750,8 +1695,8 @@
     frameHistoryElement.mRotationAngle =
         static_cast<unsigned long>(video_frame.rotation());
     frameHistoryElement.mFirstFrameTimestamp = historyNow;
-    frameHistoryElement.mLocalSsrc = mRecvSSRC;
-    frameHistoryElement.mRemoteSsrc = remoteSsrc;
+    frameHistoryElement.mLocalSsrc = localRecvSsrc;
+    frameHistoryElement.mRemoteSsrc = remoteSendSsrc;
     if (!mReceivedFrameHistory.mEntries.AppendElement(frameHistoryElement,
                                                       fallible)) {
       mozalloc_handle_oom(0);
@@ -1782,7 +1727,7 @@
 
 bool WebrtcVideoConduit::AddFrameHistory(
     dom::Sequence<dom::RTCVideoFrameHistoryInternal>* outHistories) const {
-  ReentrantMonitorAutoEnter enter(mTransportMonitor);
+  ReentrantMonitorAutoEnter enter(mRendererMonitor);
   if (!outHistories->AppendElement(mReceivedFrameHistory, fallible)) {
     mozalloc_handle_oom(0);
     return false;
@@ -1804,14 +1749,14 @@
 }
 
 void WebrtcVideoConduit::VideoLatencyUpdate(uint64_t newSample) {
-  mTransportMonitor.AssertCurrentThreadIn();
+  mRendererMonitor.AssertCurrentThreadIn();
 
   mVideoLatencyAvg =
       (sRoundingPadding * newSample + sAlphaNum * mVideoLatencyAvg) / sAlphaDen;
 }
 
 uint64_t WebrtcVideoConduit::MozVideoLatencyAvg() {
-  mTransportMonitor.AssertCurrentThreadIn();
+  mRendererMonitor.AssertCurrentThreadIn();
 
   return mVideoLatencyAvg / sRoundingPadding;
 }