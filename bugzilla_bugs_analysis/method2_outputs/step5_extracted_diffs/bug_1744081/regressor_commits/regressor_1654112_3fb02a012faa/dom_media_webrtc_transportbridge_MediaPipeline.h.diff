# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/transportbridge/MediaPipeline.h
# Commit: 3fb02a012faa
# Full Hash: 3fb02a012faadb59c6a4ca42bfb50bcbb1037d93
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 5
# Description:
#   Bug 1654112 - Route packets with MediaEvents, and clean up conduits' cross-thread syncing. r=bwc,ng
#   
#   This patch solves some issues with the SSRC switching that can be triggered by
#   both signaling and incoming packets, on different threads. But mainly, because
#   that setup is inherently complex, this patch greatly simplifies the SSRC
# ==============================================================================

diff -r 336f58a54bd8 -r 3fb02a012faa dom/media/webrtc/transportbridge/MediaPipeline.h
--- a/dom/media/webrtc/transportbridge/MediaPipeline.h	Wed Aug 25 20:28:12 2021 +0200
+++ b/dom/media/webrtc/transportbridge/MediaPipeline.h	Thu Sep 09 17:42:30 2021 +0200
@@ -17,10 +17,10 @@
 #include "mozilla/ReentrantMonitor.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/StateMirroring.h"
-#include "transport/SrtpFlow.h"  // For SRTP_MAX_EXPANSION
 #include "transport/mediapacket.h"
 #include "transport/runnable_utils.h"
 #include "AudioPacketizer.h"
+#include "MediaEventSource.h"
 #include "MediaPipelineFilter.h"
 #include "MediaSegment.h"
 #include "jsapi/PacketDumper.h"
@@ -159,31 +159,8 @@
   // Thread counting
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaPipeline)
 
-  // Separate class to allow ref counting
-  class PipelineTransport : public TransportInterface {
-   public:
-    // Implement the TransportInterface functions
-    explicit PipelineTransport(RefPtr<nsISerialEventTarget> aStsThread)
-        : mPipeline(nullptr), mStsThread(std::move(aStsThread)) {}
-
-    void Attach(MediaPipeline* pipeline) { mPipeline = pipeline; }
-    void Detach() { mPipeline = nullptr; }
-    MediaPipeline* Pipeline() const { return mPipeline; }
-
-    virtual nsresult SendRtpPacket(const uint8_t* aData, size_t aLen) override;
-    virtual nsresult SendRtcpPacket(const uint8_t* aData, size_t aLen) override;
-
-   private:
-    void SendRtpRtcpPacket_s(MediaPacket&& aPacket);
-
-    // Creates a cycle, which we break with Detach
-    RefPtr<MediaPipeline> mPipeline;
-    const RefPtr<nsISerialEventTarget> mStsThread;
-  };
-
  protected:
   virtual ~MediaPipeline();
-  friend class PipelineTransport;
 
   // The transport is ready
   virtual void TransportReady_s() {}
@@ -238,9 +215,6 @@
   TransportLayer::State mRtcpState = TransportLayer::TS_NONE;
   bool mSignalsConnected = false;
 
-  // Created in c'tor. Referenced by the conduit.
-  const RefPtr<PipelineTransport> mTransport;
-
   // Only safe to access from STS thread.
   int32_t mRtpPacketsSent;
   int32_t mRtcpPacketsSent;
@@ -266,6 +240,14 @@
 
   UniquePtr<PacketDumper> mPacketDumper;
 
+  MediaEventProducerExc<MediaPacket, webrtc::RTPHeader> mRtpReceiveEvent;
+  MediaEventProducerExc<MediaPacket> mSenderRtcpReceiveEvent;
+  MediaEventProducerExc<MediaPacket> mReceiverRtcpReceiveEvent;
+
+  MediaEventListener mRtpSendEventListener;
+  MediaEventListener mSenderRtcpSendEventListener;
+  MediaEventListener mReceiverRtcpSendEventListener;
+
  private:
   bool IsRtp(const unsigned char* aData, size_t aLen) const;
   // Must be called on the STS thread.  Must be called after Shutdown().
