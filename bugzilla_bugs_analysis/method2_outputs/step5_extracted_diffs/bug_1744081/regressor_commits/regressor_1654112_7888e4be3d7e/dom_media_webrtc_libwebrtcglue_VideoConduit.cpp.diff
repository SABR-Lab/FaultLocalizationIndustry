# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
# Commit: 7888e4be3d7e
# Full Hash: 7888e4be3d7e633739cf590e73b0a3af0ef3f9fc
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 5
# Description:
#   Bug 1654112 - Fix remote-inbound-rtp.packetsReceived. r=bwc
#   
#   There are two problems with this stat:
#   - The BaseSeq tracking logic in MediaPipeline doesn't account for multiple ssrcs
#     (rtx)
# ==============================================================================

diff -r 6b3195b0e545 -r 7888e4be3d7e dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Mon Sep 06 16:04:25 2021 +0200
+++ b/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Wed Sep 08 10:34:57 2021 +0200
@@ -904,6 +904,9 @@
   mCall->Call()->DestroyVideoSendStream(mSendStream);
   mEngineTransmitting = false;
   mSendStream = nullptr;
+
+  // Reset base_seqs in case ssrcs get re-used.
+  mRtpSendBaseSeqs.clear();
 }
 
 void WebrtcVideoConduit::CreateSendStream() {
@@ -1506,6 +1509,15 @@
   return mLastRtcpReceived;
 }
 
+Maybe<uint16_t> WebrtcVideoConduit::RtpSendBaseSeqFor(uint32_t aSsrc) const {
+  MOZ_ASSERT(mCallThread->IsOnCurrentThread());
+  auto it = mRtpSendBaseSeqs.find(aSsrc);
+  if (it == mRtpSendBaseSeqs.end()) {
+    return Nothing();
+  }
+  return Some(it->second);
+}
+
 DOMHighResTimeStamp WebrtcVideoConduit::GetNow() const {
   return mCall->GetNow();
 }
@@ -1585,12 +1597,14 @@
 
 bool WebrtcVideoConduit::SendRtp(const uint8_t* aData, size_t aLength,
                                  const webrtc::PacketOptions& aOptions) {
+  MOZ_ASSERT(aLength >= 12);
+  const uint16_t seqno = ntohs(*((uint16_t*)&aData[2]));
+  const uint32_t ssrc = ntohl(*((uint32_t*)&aData[8]));
+
   CSFLogVerbose(
       LOGTAG,
       "VideoConduit %p: Sending RTP Packet seq# %u, len %zu, SSRC %u (0x%x)",
-      this, (uint16_t)ntohs(*((uint16_t*)&aData[2])), aLength,
-      (uint32_t)ntohl(*((uint32_t*)&aData[8])),
-      (uint32_t)ntohl(*((uint32_t*)&aData[8])));
+      this, seqno, aLength, ssrc, ssrc);
 
   if (!mTransportActive) {
     CSFLogError(LOGTAG, "VideoConduit %p: RTP Packet Send Failed", this);
@@ -1602,12 +1616,21 @@
   packet.SetType(MediaPacket::RTP);
   mSenderRtpSendEvent.Notify(std::move(packet));
 
-  if (aOptions.packet_id >= 0) {
+  // Parse the sequence number of the first rtp packet as base_seq.
+  const auto inserted = mRtpSendBaseSeqs_n.insert({ssrc, seqno}).second;
+
+  if (inserted || aOptions.packet_id >= 0) {
     int64_t now_ms = PR_Now() / 1000;
     MOZ_ALWAYS_SUCCEEDS(mCallThread->Dispatch(NS_NewRunnableFunction(
-        __func__, [call = mCall, packet_id = aOptions.packet_id, now_ms] {
-          if (call->Call()) {
-            call->Call()->OnSentPacket({packet_id, now_ms});
+        __func__, [this, self = RefPtr<WebrtcVideoConduit>(this),
+                   packet_id = aOptions.packet_id, now_ms, ssrc, seqno] {
+          mRtpSendBaseSeqs.insert({ssrc, seqno});
+          if (packet_id >= 0) {
+            if (mCall->Call()) {
+              // TODO: This notification should ideally happen after the
+              // transport layer has sent the packet on the wire.
+              mCall->Call()->OnSentPacket({packet_id, now_ms});
+            }
           }
         })));
   }