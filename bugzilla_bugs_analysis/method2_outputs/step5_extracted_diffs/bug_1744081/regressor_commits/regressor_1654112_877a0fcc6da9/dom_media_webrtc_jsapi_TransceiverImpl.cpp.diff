# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/jsapi/TransceiverImpl.cpp
# Commit: 877a0fcc6da9
# Full Hash: 877a0fcc6da9fde4a783cfe30d0aa0b260427ac3
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 9
# Description:
#   Bug 1654112 - Merge conduit controllers into conduits, refactor away setters, and make unittests async. r=bwc,ng
#   
#   The main point of this patch is to harden how conduits handle configuration
#   changes. With conduit controller classes acting in a layer on top of conduits
#   (and their old sync style APIs), for instance
# ==============================================================================

diff -r 970ed33359b5 -r 877a0fcc6da9 dom/media/webrtc/jsapi/TransceiverImpl.cpp
--- a/dom/media/webrtc/jsapi/TransceiverImpl.cpp	Tue Aug 10 14:13:49 2021 +0200
+++ b/dom/media/webrtc/jsapi/TransceiverImpl.cpp	Mon Aug 16 15:57:10 2021 +0200
@@ -304,22 +304,17 @@
 
 void TransceiverImpl::InitConduitControl() {
   MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(mConduit);
   ConduitControlState control(this, mDtmf, mReceiver);
-  auto self = nsMainThreadPtrHandle<TransceiverImpl>(
-      new nsMainThreadPtrHolder<TransceiverImpl>(
-          "TransceiverImpl::InitConduitControl::self", this, false));
   mCallWrapper->mCallThread->Dispatch(NS_NewRunnableFunction(
-      __func__,
-      [conduit = mConduit, control = std::move(control), self]() mutable {
+      __func__, [conduit = mConduit, control = std::move(control)]() mutable {
         conduit->AsVideoSessionConduit().apply(
             [&](VideoSessionConduit* aConduit) {
-              self->mConduitController = new VideoConduitController(
-                  aConduit, self->mCallWrapper->mCallThread, &control);
+              aConduit->InitControl(&control);
             });
         conduit->AsAudioSessionConduit().apply(
             [&](AudioSessionConduit* aConduit) {
-              self->mConduitController = new AudioConduitController(
-                  aConduit, self->mCallWrapper->mCallThread, &control);
+              aConduit->InitControl(&control);
             });
       }));
 }
@@ -392,13 +387,12 @@
     mLocalMid = std::string();
   }
 
+  mReceiving = false;
   mReceiver->Stop();
 
+  mTransmitting = false;
   mTransmitPipeline->Stop();
 
-  mReceiving = false;
-  mTransmitting = false;
-
   // NOTE(pkerr) - the Call API requires the both local_ssrc and remote_ssrc be
   // set to a non-zero value or the CreateVideo...Stream call will fail.
   if (mJsepTransceiver->mSendTrack.GetSsrcs().empty()) {
@@ -424,19 +418,17 @@
     return rv;
   }
 
-  if (mJsepTransceiver->mRecvTrack.GetActive()) {
-    mReceiving = true;
+  if ((mReceiving = mJsepTransceiver->mRecvTrack.GetActive())) {
     mReceiver->Start();
   }
 
-  if (mJsepTransceiver->mSendTrack.GetActive()) {
+  if ((mTransmitting = mJsepTransceiver->mSendTrack.GetActive())) {
     if (!mSendTrack) {
       MOZ_MTLOG(ML_WARNING,
                 mPCHandle << "[" << mLocalMid.Ref() << "]: " << __FUNCTION__
                           << " Starting transmit conduit without send track!");
     }
 
-    mTransmitting = true;
     mTransmitPipeline->Start();
   }
 
@@ -1049,15 +1041,11 @@
     mDtmf->StopPlayout();
   }
 
-  mConduit = nullptr;
-
-  auto self = nsMainThreadPtrHandle<TransceiverImpl>(
-      new nsMainThreadPtrHolder<TransceiverImpl>(
-          "TransceiverImpl::Shutdown_m::self", this, false));
-  mCallWrapper->mCallThread->Dispatch(
-      NS_NewRunnableFunction(__func__, [self = std::move(self)] {
-        self->mConduitController->Shutdown();
-        self->mConduitController = nullptr;
+  mCallWrapper->mCallThread->Dispatch(NS_NewRunnableFunction(
+      __func__, [conduit = std::move(mConduit)]() mutable {
+        if (conduit) {
+          conduit->Shutdown();
+        }
       }));
 }
 