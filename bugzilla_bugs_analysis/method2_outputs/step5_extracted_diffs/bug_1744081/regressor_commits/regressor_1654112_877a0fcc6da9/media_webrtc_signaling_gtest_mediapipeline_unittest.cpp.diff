# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/webrtc/signaling/gtest/mediapipeline_unittest.cpp
# Commit: 877a0fcc6da9
# Full Hash: 877a0fcc6da9fde4a783cfe30d0aa0b260427ac3
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 9
# Description:
#   Bug 1654112 - Merge conduit controllers into conduits, refactor away setters, and make unittests async. r=bwc,ng
#   
#   The main point of this patch is to harden how conduits handle configuration
#   changes. With conduit controller classes acting in a layer on top of conduits
#   (and their old sync style APIs), for instance
# ==============================================================================

diff -r 970ed33359b5 -r 877a0fcc6da9 media/webrtc/signaling/gtest/mediapipeline_unittest.cpp
--- a/media/webrtc/signaling/gtest/mediapipeline_unittest.cpp	Tue Aug 10 14:13:49 2021 +0200
+++ b/media/webrtc/signaling/gtest/mediapipeline_unittest.cpp	Mon Aug 16 15:57:10 2021 +0200
@@ -14,6 +14,7 @@
 #include "call/call.h"
 #include "AudioSegment.h"
 #include "AudioStreamTrack.h"
+#include "ConcreteConduitControl.h"
 #include "modules/audio_device/include/fake_audio_device.h"
 #include "modules/audio_mixer/audio_mixer_impl.h"
 #include "modules/audio_processing/include/audio_processing.h"
@@ -260,13 +261,19 @@
 class TestAgent {
  public:
   explicit TestAgent(const RefPtr<SharedWebrtcState>& aSharedState)
-      : audio_config_(109, "opus", 48000, 2, false),
+      : conduit_control_(aSharedState->mCallWorkerThread),
+        audio_config_(109, "opus", 48000, 2, false),
         call_(WebrtcCallWrapper::Create(mozilla::dom::RTCStatsTimestampMaker(),
                                         nullptr, aSharedState)),
         audio_conduit_(
             AudioSessionConduit::Create(call_, test_utils->sts_target())),
         audio_pipeline_(),
-        transport_(new LoopbackTransport) {}
+        transport_(new LoopbackTransport) {
+    Unused << WaitFor(InvokeAsync(call_->mCallThread, __func__, [&] {
+      audio_conduit_->InitControl(&conduit_control_);
+      return GenericPromise::CreateAndResolve(true, "TestAgent()");
+    }));
+  }
 
   static void Connect(TestAgent* client, TestAgent* server) {
     LoopbackTransport::InitAndConnect(*client->transport_, *server->transport_);
@@ -296,8 +303,10 @@
       audio_pipeline_->Stop();
     }
     if (audio_conduit_) {
-      audio_conduit_->StopTransmitting();
-      audio_conduit_->StopReceiving();
+      conduit_control_.Update([](auto& aControl) {
+        aControl.mTransmitting = false;
+        aControl.mReceiving = false;
+      });
     }
   }
 
@@ -348,9 +357,10 @@
   }
 
  protected:
+  ConcreteConduitControl conduit_control_;
   AudioCodecConfig audio_config_;
   RefPtr<WebrtcCallWrapper> call_;
-  RefPtr<MediaSessionConduit> audio_conduit_;
+  RefPtr<AudioSessionConduit> audio_conduit_;
   RefPtr<FakeAudioTrack> audio_track_;
   // TODO(bcampen@mozilla.com): Right now this does not let us test RTCP in
   // both directions; only the sender's RTCP is sent, but the receiver should
@@ -363,15 +373,9 @@
  public:
   explicit TestAgentSend(const RefPtr<SharedWebrtcState>& aSharedState)
       : TestAgent(aSharedState) {
-    using Promise = MozPromise<MediaConduitErrorCode, bool, true>;
-    auto rv = WaitFor(InvokeAsync(call_->mCallThread, __func__, [&] {
-      return Promise::CreateAndResolve(
-          static_cast<AudioSessionConduit*>(audio_conduit_.get())
-              ->ConfigureSendMediaCodec(audio_config_),
-          "TestAgentSend::ConfigureSendMediaCodec");
-    }));
-    EXPECT_EQ(kMediaConduitNoError, rv.unwrap());
-
+    conduit_control_.Update([&](auto& aControl) {
+      aControl.mAudioSendCodec = Some(audio_config_);
+    });
     audio_track_ = new FakeAudioTrack();
   }
 
@@ -385,7 +389,8 @@
 
     audio_pipeline->SetSendTrackOverride(audio_track_);
     audio_pipeline->Start();
-    audio_conduit_->StartTransmitting();
+    conduit_control_.Update(
+        [](auto& aControl) { aControl.mTransmitting = true; });
 
     audio_pipeline_ = audio_pipeline;
 
@@ -397,17 +402,11 @@
  public:
   explicit TestAgentReceive(const RefPtr<SharedWebrtcState>& aSharedState)
       : TestAgent(aSharedState) {
-    std::vector<AudioCodecConfig> codecs;
-    codecs.push_back(audio_config_);
-
-    using Promise = MozPromise<MediaConduitErrorCode, bool, true>;
-    auto rv = WaitFor(InvokeAsync(call_->mCallThread, __func__, [&] {
-      return Promise::CreateAndResolve(
-          static_cast<AudioSessionConduit*>(audio_conduit_.get())
-              ->ConfigureRecvMediaCodecs(codecs),
-          "TestAgentReceive::ConfigureRecvMediaCodec");
-    }));
-    EXPECT_EQ(kMediaConduitNoError, rv.unwrap());
+    conduit_control_.Update([&](auto& aControl) {
+      std::vector<AudioCodecConfig> codecs;
+      codecs.push_back(audio_config_);
+      aControl.mAudioRecvCodecs = codecs;
+    });
   }
 
   virtual void CreatePipeline(const std::string& aTransportId) {
@@ -420,7 +419,7 @@
         PRINCIPAL_HANDLE_NONE);
 
     audio_pipeline_->Start();
-    audio_conduit_->StartReceiving();
+    conduit_control_.Update([](auto& aControl) { aControl.mReceiving = true; });
 
     audio_pipeline_->UpdateTransport_m(aTransportId, std::move(bundle_filter_));
   }