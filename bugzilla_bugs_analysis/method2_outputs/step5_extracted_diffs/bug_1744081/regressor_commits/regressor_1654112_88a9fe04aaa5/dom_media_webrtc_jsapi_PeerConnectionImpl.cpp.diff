# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/jsapi/PeerConnectionImpl.cpp
# Commit: 88a9fe04aaa5
# Full Hash: 88a9fe04aaa582676a84734d67c9069b68a7f3e1
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 5
# Description:
#   Bug 1654112 - Update Audio- and VideoConduit stats API and integration. r=ng,bwc
#   
#   For AudioConduit this patch:
#   - Uses correct threads per upstream, pending changes due to the threading model
#     update that's coming
# ==============================================================================

diff -r 3eae9f9279f6 -r 88a9fe04aaa5 dom/media/webrtc/jsapi/PeerConnectionImpl.cpp
--- a/dom/media/webrtc/jsapi/PeerConnectionImpl.cpp	Fri Jan 29 15:38:54 2021 +0100
+++ b/dom/media/webrtc/jsapi/PeerConnectionImpl.cpp	Mon Jan 18 15:28:29 2021 +0100
@@ -2558,132 +2558,274 @@
 }
 
 // TODO(bug 1616937): Move this to RTCRtpSender.
-static UniquePtr<dom::RTCStatsCollection> GetSenderStats_s(
-    const RefPtr<MediaPipelineTransmit>& aPipeline,
-    const nsAutoString& aTrackName) {
-  UniquePtr<dom::RTCStatsCollection> report(new dom::RTCStatsCollection);
-
-  // Add bandwidth estimation stats
-  aPipeline->Conduit()->GetBandwidthEstimation().apply([&](auto& bw) {
-    bw.mTrackIdentifier = aTrackName;
-    if (!report->mBandwidthEstimations.AppendElement(bw, fallible)) {
-      mozalloc_handle_oom(0);
-    }
-  });
-
-  auto asVideo = aPipeline->Conduit()->AsVideoSessionConduit();
-
-  nsString kind = asVideo.isNothing() ? u"audio"_ns : u"video"_ns;
-  nsString idstr = kind + u"_"_ns;
-  idstr.AppendInt(static_cast<uint32_t>(aPipeline->Level()));
-
-  // TODO(@@NG):ssrcs handle Conduits having multiple stats at the same level
-  // This is pending spec work
-  // Gather pipeline stats.
-  nsString localId = u"outbound_rtp_"_ns + idstr;
-  nsString remoteId;
-  Maybe<uint32_t> ssrc;
-  std::vector<unsigned int> ssrcvals = aPipeline->Conduit()->GetLocalSSRCs();
-  if (!ssrcvals.empty()) {
-    ssrc = Some(ssrcvals[0]);
+nsTArray<RefPtr<dom::RTCStatsPromise>> PeerConnectionImpl::GetSenderStats(
+    const RefPtr<MediaPipelineTransmit>& aPipeline) {
+  MOZ_ASSERT(NS_IsMainThread());
+  nsTArray<RefPtr<RTCStatsPromise>> promises(2);
+
+  nsAutoString trackName;
+  if (auto track = aPipeline->GetTrack()) {
+    track->GetId(trackName);
   }
+
   {
-    // First, fill in remote stat with rtcp receiver data, if present.
-    // ReceiverReports have less information than SenderReports,
-    // so fill in what we can.
-    uint32_t jitterMs;
-    uint32_t packetsReceived;
-    uint64_t bytesReceived;
-    uint32_t packetsLost;
-    Maybe<double> rtt;
-    Maybe<DOMHighResTimeStamp> timestamp =
-        aPipeline->Conduit()->LastRtcpReceived();
-    if (timestamp.isSome() &&
-        aPipeline->Conduit()->GetRTCPReceiverReport(
-            &jitterMs, &packetsReceived, &bytesReceived, &packetsLost, &rtt)) {
-      remoteId = u"outbound_rtcp_"_ns + idstr;
-      RTCRemoteInboundRtpStreamStats s;
-      s.mTimestamp.Construct(*timestamp);
-      s.mId.Construct(remoteId);
-      s.mType.Construct(RTCStatsType::Remote_inbound_rtp);
-      ssrc.apply([&s](uint32_t aSsrc) { s.mSsrc.Construct(aSsrc); });
-      s.mMediaType.Construct(kind);  // mediaType is the old name for kind.
-      s.mKind.Construct(kind);
-      s.mJitter.Construct(double(jitterMs) / 1000);
-      s.mLocalId.Construct(localId);
-      s.mPacketsReceived.Construct(packetsReceived);
-      s.mBytesReceived.Construct(bytesReceived);
-      s.mPacketsLost.Construct(packetsLost);
-      rtt.apply([&s](auto r) { s.mRoundTripTime.Construct(r); });
-      if (!report->mRemoteInboundRtpStreamStats.AppendElement(s, fallible)) {
-        mozalloc_handle_oom(0);
+    // Add bandwidth estimation stats
+    auto report = MakeUnique<dom::RTCStatsCollection>();
+    if (dom::RTCBandwidthEstimationInternal* bw =
+            report->mBandwidthEstimations.AppendElement(fallible)) {
+      const auto& stats = aPipeline->Conduit()->GetCallStats();
+      bw->mTrackIdentifier = trackName;
+      bw->mSendBandwidthBps.Construct(stats.send_bandwidth_bps / 8);
+      bw->mMaxPaddingBps.Construct(stats.max_padding_bitrate_bps / 8);
+      bw->mReceiveBandwidthBps.Construct(stats.recv_bandwidth_bps / 8);
+      bw->mPacerDelayMs.Construct(stats.pacer_delay_ms);
+      if (stats.rtt_ms >= 0) {
+        bw->mRttMs.Construct(stats.rtt_ms);
       }
+      promises.AppendElement(
+          RTCStatsPromise::CreateAndResolve(std::move(report), __func__));
     }
   }
-  // Then, fill in local side (with cross-link to remote only if present)
-  RTCOutboundRtpStreamStats s;
-  s.mTimestamp.Construct(aPipeline->GetNow());
-  s.mId.Construct(localId);
-  s.mType.Construct(RTCStatsType::Outbound_rtp);
-  ssrc.apply([&s](uint32_t aSsrc) { s.mSsrc.Construct(aSsrc); });
-  s.mMediaType.Construct(kind);  // mediaType is the old name for kind.
-  s.mKind.Construct(kind);
-  if (remoteId.Length()) {
-    s.mRemoteId.Construct(remoteId);
-  }
-  s.mPacketsSent.Construct(aPipeline->RtpPacketsSent());
-  s.mBytesSent.Construct(aPipeline->RtpBytesSent());
-
-  // Fill in packet type statistics
-  webrtc::RtcpPacketTypeCounter counters;
-  if (aPipeline->Conduit()->GetSendPacketTypeStats(&counters)) {
-    s.mNackCount.Construct(counters.nack_packets);
-    // Fill in video only packet type stats
-    if (asVideo) {
-      s.mFirCount.Construct(counters.fir_packets);
-      s.mPliCount.Construct(counters.pli_packets);
-    }
-  }
-
-  // Lastly, fill in video encoder stats, and bandwidth estimation if this is
-  // video
-  asVideo.apply([&s](auto conduit) {
-    double framerateMean;
-    double framerateStdDev;
-    double bitrateMean;
-    double bitrateStdDev;
-    uint32_t droppedFrames;
-    uint32_t framesEncoded;
-    Maybe<uint64_t> qpSum;
-    if (conduit->GetVideoEncoderStats(&framerateMean, &framerateStdDev,
-                                      &bitrateMean, &bitrateStdDev,
-                                      &droppedFrames, &framesEncoded, &qpSum)) {
-      s.mFramerateMean.Construct(framerateMean);
-      s.mFramerateStdDev.Construct(framerateStdDev);
-      s.mBitrateMean.Construct(bitrateMean);
-      s.mBitrateStdDev.Construct(bitrateStdDev);
-      s.mDroppedFrames.Construct(droppedFrames);
-      s.mFramesEncoded.Construct(framesEncoded);
-      qpSum.apply([&s](uint64_t aQp) { s.mQpSum.Construct(aQp); });
-    }
-  });
-  if (!report->mOutboundRtpStreamStats.AppendElement(s, fallible)) {
-    mozalloc_handle_oom(0);
-  }
-  return report;
-}
-
-RefPtr<dom::RTCStatsPromise> PeerConnectionImpl::GetSenderStats(
-    const RefPtr<MediaPipelineTransmit>& aPipeline) {
-  nsAutoString trackName;
-  auto track = aPipeline->GetTrack();
-  if (track) {
-    track->GetId(trackName);
-  }
-  return InvokeAsync(mSTSThread, __func__, [aPipeline, trackName]() {
-    return dom::RTCStatsPromise::CreateAndResolve(
-        GetSenderStats_s(aPipeline, trackName), __func__);
-  });
+
+  using TimeStampPromise = MozPromise<Maybe<DOMHighResTimeStamp>, bool, true>;
+  promises.AppendElement(
+      InvokeAsync(mSTSThread, __func__,
+                  [cond = RefPtr<MediaSessionConduit>(aPipeline->Conduit())] {
+                    return TimeStampPromise::CreateAndResolve(
+                        cond->LastRtcpReceived(), __func__);
+                  })
+          ->Then(
+              GetMainThreadSerialEventTarget(), __func__,
+              [aPipeline](TimeStampPromise::ResolveOrRejectValue&& aValue) {
+                MOZ_ASSERT(aValue.IsResolve());
+                Maybe<DOMHighResTimeStamp> lastRtcpReceivedTimestamp =
+                    aValue.ResolveValue();
+
+                auto report = MakeUnique<dom::RTCStatsCollection>();
+                auto asAudio = aPipeline->Conduit()->AsAudioSessionConduit();
+                auto asVideo = aPipeline->Conduit()->AsVideoSessionConduit();
+
+                nsString kind = asVideo.isNothing() ? u"audio"_ns : u"video"_ns;
+                nsString idstr = kind + u"_"_ns;
+                idstr.AppendInt(static_cast<uint32_t>(aPipeline->Level()));
+
+                // TODO(@@NG):ssrcs handle Conduits having multiple stats at the
+                // same level This is pending spec work Gather pipeline stats.
+                nsString localId = u"outbound_rtp_"_ns + idstr;
+                nsString remoteId;
+                Maybe<uint32_t> ssrc;
+                std::vector<unsigned int> ssrcvals =
+                    aPipeline->Conduit()->GetLocalSSRCs();
+                if (!ssrcvals.empty()) {
+                  ssrc = Some(ssrcvals[0]);
+                }
+
+                auto constructCommonRemoteInboundRtpStats =
+                    [&](RTCRemoteInboundRtpStreamStats& aRemote,
+                        DOMHighResTimeStamp& aTimestamp,
+                        const Maybe<webrtc::ReportBlockData>&
+                            aReportBlockData) {
+                      remoteId = u"outbound_rtcp_"_ns + idstr;
+                      aRemote.mTimestamp.Construct(aTimestamp);
+                      aRemote.mId.Construct(remoteId);
+                      aRemote.mType.Construct(RTCStatsType::Remote_inbound_rtp);
+                      ssrc.apply([&](uint32_t aSsrc) {
+                        aRemote.mSsrc.Construct(aSsrc);
+                      });
+                      aRemote.mMediaType.Construct(
+                          kind);  // mediaType is the old name for kind.
+                      aRemote.mKind.Construct(kind);
+                      aRemote.mLocalId.Construct(localId);
+                      aReportBlockData.apply([&](auto& aData) {
+                        aPipeline->RtpSendBaseSeq().apply(
+                            [&](uint32_t aBaseSeq) {
+                              aRemote.mPacketsReceived.Construct(
+                                  aData.report_block()
+                                      .extended_highest_sequence_number -
+                                  aBaseSeq + 1);
+                            });
+                      });
+                    };
+
+                auto constructCommonOutboundRtpStats =
+                    [&](RTCOutboundRtpStreamStats& aLocal) {
+                      ssrc.apply([&](uint32_t aSsrc) {
+                        aLocal.mSsrc.Construct(aSsrc);
+                      });
+                      aLocal.mTimestamp.Construct(aPipeline->GetNow());
+                      aLocal.mId.Construct(localId);
+                      aLocal.mType.Construct(RTCStatsType::Outbound_rtp);
+                      aLocal.mMediaType.Construct(
+                          kind);  // mediaType is the old name for kind.
+                      aLocal.mKind.Construct(kind);
+                      if (remoteId.Length()) {
+                        aLocal.mRemoteId.Construct(remoteId);
+                      }
+                    };
+
+                asAudio.apply([&](auto& aConduit) {
+                  Maybe<webrtc::AudioSendStream::Stats> audioStats =
+                      aConduit->GetSenderStats();
+                  if (audioStats.isNothing()) {
+                    return;
+                  }
+
+                  // First, fill in remote stat with rtcp receiver data, if
+                  // present. ReceiverReports have less information than
+                  // SenderReports, so fill in what we can.
+                  lastRtcpReceivedTimestamp.apply([&](auto& aTimestamp) {
+                    RTCRemoteInboundRtpStreamStats remote;
+                    Maybe<webrtc::ReportBlockData> reportBlockData;
+                    ssrc.apply([&](uint32_t aLocalSsrc) {
+                      for (auto& data : audioStats->report_block_datas) {
+                        if (data.report_block().source_ssrc == aLocalSsrc) {
+                          reportBlockData.emplace(data);
+                          break;
+                        }
+                      }
+                    });
+                    constructCommonRemoteInboundRtpStats(remote, aTimestamp,
+                                                         reportBlockData);
+                    remote.mJitter.Construct(audioStats->jitter_ms / 1000.0);
+                    remote.mPacketsLost.Construct(audioStats->packets_lost);
+                    if (audioStats->rtt_ms >= 0) {
+                      remote.mRoundTripTime.Construct(audioStats->rtt_ms /
+                                                      1000.0);
+                    }
+                    /*
+                     * Potential new stats that are now available upstream.
+                    remote.mFractionLost.Construct(audioStats->fraction_lost);
+                    remote.mTotalRoundTripTime.Construct(
+                        double(aReportBlockData.sum_rtt_ms()) / 1000);
+                    remote.mRoundTripTimeMeasurements.Construct(aReportBlockData.num_rtts());
+                     */
+                    if (!report->mRemoteInboundRtpStreamStats.AppendElement(
+                            std::move(remote), fallible)) {
+                      mozalloc_handle_oom(0);
+                    }
+                  });
+
+                  // Then, fill in local side (with cross-link to remote only if
+                  // present)
+                  RTCOutboundRtpStreamStats local;
+                  constructCommonOutboundRtpStats(local);
+                  local.mPacketsSent.Construct(audioStats->packets_sent);
+                  local.mBytesSent.Construct(audioStats->payload_bytes_sent);
+                  local.mNackCount.Construct(
+                      audioStats->rtcp_packet_type_counts.nack_packets);
+                  /*
+                   * Potential new stats that are now available upstream.
+                  local.mHeaderBytesSent.Construct(audioStats->header_and_padding_bytes_sent);
+                  local.mRetransmittedPacketsSent.Construct(
+                      audioStats->retransmitted_packets_sent);
+                  local.mRetransmittedBytesSent.Construct(
+                      audioStats->retransmitted_bytes_sent);
+                  local.mTargetBitrate.Construct(audioStats->target_bitrate_bps);
+                   */
+                  if (!report->mOutboundRtpStreamStats.AppendElement(
+                          std::move(local), fallible)) {
+                    mozalloc_handle_oom(0);
+                  }
+                });
+
+                asVideo.apply([&](auto& aConduit) {
+                  Maybe<webrtc::VideoSendStream::Stats> videoStats =
+                      aConduit->GetSenderStats();
+                  if (videoStats.isNothing()) {
+                    return;
+                  }
+
+                  Maybe<webrtc::VideoSendStream::StreamStats> streamStats;
+                  ssrc.apply([&](uint32_t aSsrc) {
+                    auto kv = videoStats->substreams.find(aSsrc);
+                    if (kv != videoStats->substreams.end()) {
+                      streamStats = Some(kv->second);
+                    }
+                  });
+
+                  // First, fill in remote stat with rtcp receiver data, if
+                  // present. ReceiverReports have less information than
+                  // SenderReports, so fill in what we can.
+                  lastRtcpReceivedTimestamp.apply([&](auto& aTimestamp) {
+                    RTCRemoteInboundRtpStreamStats remote;
+                    Maybe<webrtc::ReportBlockData> rtcpReportData;
+                    streamStats.apply([&](auto& aStreamStats) {
+                      remote.mJitter.Construct(
+                          static_cast<double>(aStreamStats.rtcp_stats.jitter) /
+                          webrtc::kVideoPayloadTypeFrequency);
+                      remote.mPacketsLost.Construct(
+                          aStreamStats.rtcp_stats.packets_lost);
+                      if (aStreamStats.report_block_data) {
+                        rtcpReportData = Some(*aStreamStats.report_block_data);
+                        if (aStreamStats.report_block_data->has_rtt()) {
+                          remote.mRoundTripTime.Construct(
+                              aStreamStats.report_block_data->last_rtt_ms() /
+                              1000.0);
+                        }
+                      }
+                    });
+                    constructCommonRemoteInboundRtpStats(remote, aTimestamp,
+                                                         rtcpReportData);
+                    /*
+                     * Potential new stats that are now available upstream.
+                    remote.mTotalRoundTripTime.Construct(
+                        aStreamStats.report_block_data->sum_rtt_ms() /
+                    1000.0); remote.mFractionLost.Construct(
+                        static_cast<float>(aStreamStats.rtcp_stats.fraction_lost)
+                    / (1 << 8));
+                    remote.mRoundTripTimeMeasurements.Construct(
+                        aStreamStats.report_block_data.num_rtts());
+                     */
+                    if (!report->mRemoteInboundRtpStreamStats.AppendElement(
+                            std::move(remote), fallible)) {
+                      mozalloc_handle_oom(0);
+                    }
+                  });
+
+                  // Then, fill in local side (with cross-link to remote only if
+                  // present)
+                  RTCOutboundRtpStreamStats local;
+                  constructCommonOutboundRtpStats(local);
+                  local.mFramesEncoded.Construct(videoStats->frames_encoded);
+                  streamStats.apply([&](auto& aStreamStats) {
+                    local.mPacketsSent.Construct(
+                        aStreamStats.rtp_stats.transmitted.packets);
+                    local.mBytesSent.Construct(
+                        aStreamStats.rtp_stats.transmitted.payload_bytes);
+                    local.mNackCount.Construct(
+                        aStreamStats.rtcp_packet_type_counts.nack_packets);
+                    local.mFirCount.Construct(
+                        aStreamStats.rtcp_packet_type_counts.fir_packets);
+                    local.mPliCount.Construct(
+                        aStreamStats.rtcp_packet_type_counts.pli_packets);
+                    if (aStreamStats.qp_sum) {
+                      local.mQpSum.Construct(*aStreamStats.qp_sum);
+                    }
+                  });
+                  /*
+                   * Potential new stats that are now available upstream.
+                  local.mHeaderBytesSent.Construct(
+                      aStreamStats.rtp_stats.transmitted.header_bytes +
+                      aStreamStats.rtp_stats.transmitted.padding_bytes);
+                  local.mRetransmittedPacketsSent.Construct(
+                      aStreamStats.rtp_stats.retransmitted.packets);
+                  local.mRetransmittedBytesSent.Construct(
+                      aStreamStats.rtp_stats.retransmitted.payload_bytes);
+                  local.mTargetBitrate.Construct(videoStats->target_media_bitrate_bps);
+                  local.mTotalEncodedBytesTarget.Construct(
+                      videoStats->total_encoded_bytes_target);
+
+                   */
+                  if (!report->mOutboundRtpStreamStats.AppendElement(
+                          std::move(local), fallible)) {
+                    mozalloc_handle_oom(0);
+                  }
+                });
+                return RTCStatsPromise::CreateAndResolve(std::move(report),
+                                                         __func__);
+              }));
+
+  return promises;
 }
 
 static UniquePtr<dom::RTCStatsCollection> GetDataChannelStats_s(
@@ -2766,6 +2908,7 @@
 
 RefPtr<dom::RTCStatsReportPromise> PeerConnectionImpl::GetStats(
     dom::MediaStreamTrack* aSelector, bool aInternalStats) {
+  MOZ_ASSERT(NS_IsMainThread());
   nsTArray<RefPtr<dom::RTCStatsPromise>> promises;
   DOMHighResTimeStamp now = mTimestampMaker.GetNow();
 
@@ -2780,21 +2923,21 @@
     }
 
     for (const auto& pipeline : sendPipelines) {
-      promises.AppendElement(GetSenderStats(pipeline));
+      promises.AppendElements(GetSenderStats(pipeline));
     }
 
     for (const auto& transceiver : mMedia->GetTransceivers()) {
       if (transceiver->Receiver()->HasTrack(aSelector)) {
-        // Right now, returns two promises; one for RTP/RTCP stats, and another
-        // for ICE stats.
+        // Right now, returns two promises; one for RTP/RTCP stats, and
+        // another for ICE stats.
         promises.AppendElements(transceiver->Receiver()->GetStatsInternal());
       }
     }
 
     // TODO(bug 1616937): We need to move this is RTCRtpSender, to make
-    // getStats on those objects work properly. It might be worth optimizing the
-    // null selector case, so we don't end up with bunches of copies of the same
-    // transport information in the final report.
+    // getStats on those objects work properly. It might be worth optimizing
+    // the null selector case, so we don't end up with bunches of copies of
+    // the same transport information in the final report.
     if (aSelector) {
       std::string transportId =
           mMedia->GetTransportIdMatchingSendTrack(*aSelector);
@@ -2919,10 +3062,10 @@
                       stats->mVideoFrameHistories, fallible) ||
                   !report->mBandwidthEstimations.AppendElements(
                       stats->mBandwidthEstimations, fallible)) {
-                // XXX(Bug 1632090) Instead of extending the array 1-by-1 (which
-                // might involve multiple reallocations) and potentially
-                // crashing here, SetCapacity could be called outside the loop
-                // once.
+                // XXX(Bug 1632090) Instead of extending the array 1-by-1
+                // (which might involve multiple reallocations) and
+                // potentially crashing here, SetCapacity could be called
+                // outside the loop once.
                 mozalloc_handle_oom(0);
               }
             }
@@ -3028,10 +3171,12 @@
   mCallTelemStarted = true;
 
   // Increment session call counter
-  // If we want to track Loop calls independently here, we need two histograms.
+  // If we want to track Loop calls independently here, we need two
+  // histograms.
   //
   // NOTE: As of bug 1654248 landing we are no longer counting renegotiations
-  // as separate calls. Expect numbers to drop compared to WEBRTC_CALL_COUNT_2.
+  // as separate calls. Expect numbers to drop compared to
+  // WEBRTC_CALL_COUNT_2.
   Telemetry::Accumulate(Telemetry::WEBRTC_CALL_COUNT_3, 1);
 }
 