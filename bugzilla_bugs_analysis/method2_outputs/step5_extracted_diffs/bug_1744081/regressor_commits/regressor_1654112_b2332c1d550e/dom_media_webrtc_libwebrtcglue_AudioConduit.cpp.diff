# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
# Commit: b2332c1d550e
# Full Hash: b2332c1d550ed2d02408150e9979685981d0817f
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 5
# Description:
#   Bug 1654112 - Don't push RtpSource info to main thread on every received frame. r=ng,bwc
#   
#   If js doesn't intend to look at get*Sources, then pushing RtpSource info to main
#   thread constantly is cycles spent in vain. Considering that upstream already
#   updates this info off-main on every received frame it is also to a large extent
# ==============================================================================

diff -r c186df8a088e -r b2332c1d550e dom/media/webrtc/libwebrtcglue/AudioConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Fri Aug 20 13:52:08 2021 +0200
+++ b/dom/media/webrtc/libwebrtcglue/AudioConduit.cpp	Fri Aug 20 14:03:36 2021 +0200
@@ -470,21 +470,6 @@
     return kMediaConduitPlayoutError;
   }
 
-  // Spec says to "queue a task" to update contributing/synchronization source
-  // stats; that's what we're doing here.
-  mCallThread->Dispatch(NS_NewRunnableFunction(
-      __func__, [this, self = RefPtr<WebrtcAudioConduit>(this)] {
-        std::vector<webrtc::RtpSource> sources;
-        if (mRecvStream) {
-          sources = mRecvStream->GetSources();
-        }
-        NS_DispatchToMainThread(NS_NewRunnableFunction(
-            "WebrtcAudioConduit::GetAudioFrame (call thread)",
-            [this, self = std::move(self), sources = std::move(sources)] {
-              UpdateRtpSources(sources);
-            }));
-      }));
-
   CSFLogDebug(LOGTAG, "%s Got %zu channels of %zu samples", __FUNCTION__,
               frame->num_channels(), frame->samples_per_channel());
   return kMediaConduitNoError;
@@ -712,6 +697,19 @@
   return GetNum10msSamplesForFrequency(freq) != 0;
 }
 
+std::vector<webrtc::RtpSource> WebrtcAudioConduit::GetUpstreamRtpSources()
+    const {
+  MOZ_ASSERT(NS_IsMainThread());
+  std::vector<webrtc::RtpSource> sources;
+  {
+    MutexAutoLock lock(mMutex);
+    if (mRecvStream) {
+      sources = mRecvStream->GetSources();
+    }
+  }
+  return sources;
+}
+
 /* Return block-length of 10 ms audio frame in number of samples */
 unsigned int WebrtcAudioConduit::GetNum10msSamplesForFrequency(
     int samplingFreqHz) const {