# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
# Commit: c5502287708e
# Full Hash: c5502287708e8ff072b205bb2308e04037b72bef
# Author: Dan Minor <dminor@mozilla.com>
# Date: 2021-11-01 18:17:33
# Regressor Bug: 1654112
# File Overlap Count: 2
# Description:
#   Bug 1654112 - Enable more VideoConduit code. r=ng
#   
#   This enables more of the VideoConduit code and updates the APIs used.
#   
#   Note that this removes REMB support (upstream has removed the corresponding
# ==============================================================================

diff -r 99e7f86e5cad -r c5502287708e dom/media/webrtc/libwebrtcglue/VideoConduit.cpp
--- a/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Thu Dec 03 07:34:49 2020 -0500
+++ b/dom/media/webrtc/libwebrtcglue/VideoConduit.cpp	Tue Dec 15 13:51:00 2020 -0500
@@ -26,6 +26,7 @@
 
 #include "pk11pub.h"
 
+#include "api/transport/bitrate_settings.h"
 #include "api/video_codecs/sdp_video_format.h"
 #include "api/video_codecs/video_codec.h"
 #include "common_video/include/video_frame_buffer.h"
@@ -647,42 +648,40 @@
 MediaConduitErrorCode WebrtcVideoConduit::CreateSendStream() {
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
-  /*
-    nsAutoString codecName;
-    codecName.AssignASCII(
-        mSendStreamConfig.encoder_settings.payload_name.c_str());
-    Telemetry::ScalarAdd(Telemetry::ScalarID::WEBRTC_VIDEO_SEND_CODEC_USED,
-                         codecName, 1);
+
+  nsAutoString codecName;
+  codecName.AssignASCII(mSendStreamConfig.rtp.payload_name.c_str());
+  Telemetry::ScalarAdd(Telemetry::ScalarID::WEBRTC_VIDEO_SEND_CODEC_USED,
+                       codecName, 1);
 
-    webrtc::VideoCodecType encoder_type =
-        SupportedCodecType(webrtc::PayloadStringToCodecType(
-            mSendStreamConfig.encoder_settings.payload_name));
-    if (encoder_type == webrtc::VideoCodecType::kVideoCodecGeneric) {
-      return kMediaConduitInvalidSendCodec;
-    }
+  webrtc::VideoCodecType encoder_type = SupportedCodecType(
+      webrtc::PayloadStringToCodecType(mSendStreamConfig.rtp.payload_name));
+  if (encoder_type == webrtc::VideoCodecType::kVideoCodecGeneric) {
+    return kMediaConduitInvalidSendCodec;
+  }
 
+  /*
     std::unique_ptr<webrtc::VideoEncoder> encoder(CreateEncoder(encoder_type));
     if (!encoder) {
       return kMediaConduitInvalidSendCodec;
     }
 
     mSendStreamConfig.encoder_settings.encoder = encoder.get();
+  */
 
-    MOZ_ASSERT(
-        mSendStreamConfig.rtp.ssrcs.size() == mEncoderConfig.number_of_streams,
-        "Each video substream must have a corresponding ssrc.");
-
-    mSendStream = mCall->Call()->CreateVideoSendStream(mSendStreamConfig.Copy(),
-                                                       mEncoderConfig.Copy());
+  MOZ_ASSERT(
+      mSendStreamConfig.rtp.ssrcs.size() == mEncoderConfig.number_of_streams,
+      "Each video substream must have a corresponding ssrc.");
 
-    if (!mSendStream) {
-      return kMediaConduitVideoSendStreamError;
-    }
-    mSendStream->SetSource(
-        this, webrtc::DegradationPreference::kBalanced);
+  mSendStream = mCall->Call()->CreateVideoSendStream(mSendStreamConfig.Copy(),
+                                                     mEncoderConfig.Copy());
 
-    mEncoder = std::move(encoder);
-  */
+  if (!mSendStream) {
+    return kMediaConduitVideoSendStreamError;
+  }
+  mSendStream->SetSource(this, webrtc::DegradationPreference::BALANCED);
+
+  //  mEncoder = std::move(encoder);
   mActiveCodecMode = mCodecMode;
 
   return kMediaConduitNoError;
@@ -703,61 +702,61 @@
 MediaConduitErrorCode WebrtcVideoConduit::CreateRecvStream() {
   MOZ_ASSERT(NS_IsMainThread());
   mMutex.AssertCurrentThreadOwns();
-  /*
-    webrtc::VideoReceiveStream::Decoder decoder_desc;
-    std::unique_ptr<webrtc::VideoDecoder> decoder;
-    webrtc::VideoCodecType decoder_type;
-
-    mRecvStreamConfig.decoders.clear();
-    for (auto& config : mRecvCodecList) {
-      nsAutoString codecName;
-      codecName.AssignASCII(config->mName.c_str());
-      Telemetry::ScalarAdd(Telemetry::ScalarID::WEBRTC_VIDEO_RECV_CODEC_USED,
-                           codecName, 1);
-
-      decoder_type =
-          SupportedCodecType(webrtc::PayloadStringToCodecType(config->mName));
-      if (decoder_type == webrtc::VideoCodecType::kVideoCodecGeneric) {
-        CSFLogError(LOGTAG, "%s Unknown decoder type: %s", __FUNCTION__,
-                    config->mName.c_str());
-        continue;
-      }
+  webrtc::VideoReceiveStream::Decoder decoder_desc;
+  std::unique_ptr<webrtc::VideoDecoder> decoder;
+  webrtc::VideoCodecType decoder_type;
 
-      decoder = CreateDecoder(decoder_type);
+  mRecvStreamConfig.decoders.clear();
+  for (auto& config : mRecvCodecList) {
+    nsAutoString codecName;
+    codecName.AssignASCII(config->mName.c_str());
+    Telemetry::ScalarAdd(Telemetry::ScalarID::WEBRTC_VIDEO_RECV_CODEC_USED,
+                         codecName, 1);
 
-      if (!decoder) {
-        // This really should never happen unless something went wrong
-        // in the negotiation code
-        NS_ASSERTION(decoder, "Failed to create video decoder");
-        CSFLogError(LOGTAG, "Failed to create decoder of type %s (%d)",
-                    config->mName.c_str(), decoder_type);
-        // don't stop
-        continue;
-      }
-
-      decoder_desc.decoder = decoder.get();
-      mDecoders.push_back(std::move(decoder));
-      decoder_desc.payload_name = config->mName;
-      decoder_desc.payload_type = config->mType;
-      // XXX Ok, add:
-      // Set decoder_desc.codec_params (fmtp)
-      mRecvStreamConfig.decoders.push_back(decoder_desc);
+    decoder_type =
+        SupportedCodecType(webrtc::PayloadStringToCodecType(config->mName));
+    if (decoder_type == webrtc::VideoCodecType::kVideoCodecGeneric) {
+      CSFLogError(LOGTAG, "%s Unknown decoder type: %s", __FUNCTION__,
+                  config->mName.c_str());
+      continue;
     }
 
-    mRecvStream =
-        mCall->Call()->CreateVideoReceiveStream(mRecvStreamConfig.Copy());
-    if (!mRecvStream) {
-      mDecoders.clear();
-      return kMediaConduitUnknownError;
+    decoder = CreateDecoder(decoder_type);
+
+    if (!decoder) {
+      // This really should never happen unless something went wrong
+      // in the negotiation code
+      NS_ASSERTION(decoder, "Failed to create video decoder");
+      CSFLogError(LOGTAG, "Failed to create decoder of type %s (%d)",
+                  config->mName.c_str(), decoder_type);
+      // don't stop
+      continue;
     }
 
-    // Add RTPPacketSinkInterface for synchronization source tracking
-    mRecvStream->AddSecondarySink(this);
+    // TODO: There seems to be no way to pass in a decoder here anymore, which
+    // problematic since we were using this to pass in GMP and MediaData
+    // decoders. That code may have to move to a factory instance.
+    // decoder_desc.decoder = decoder.get();
+    mDecoders.push_back(std::move(decoder));
+    decoder_desc.payload_type = config->mType;
+    // XXX Ok, add:
+    // Set decoder_desc.codec_params (fmtp)
+    mRecvStreamConfig.decoders.push_back(decoder_desc);
+  }
 
-    CSFLogDebug(LOGTAG, "Created VideoReceiveStream %p for SSRC %u (0x%x)",
-                mRecvStream, mRecvStreamConfig.rtp.remote_ssrc,
-                mRecvStreamConfig.rtp.remote_ssrc);
-  */
+  mRecvStream =
+      mCall->Call()->CreateVideoReceiveStream(mRecvStreamConfig.Copy());
+  if (!mRecvStream) {
+    mDecoders.clear();
+    return kMediaConduitUnknownError;
+  }
+
+  // Add RTPPacketSinkInterface for synchronization source tracking
+  mRecvStream->AddSecondarySink(this);
+
+  CSFLogDebug(LOGTAG, "Created VideoReceiveStream %p for SSRC %u (0x%x)",
+              mRecvStream, mRecvStreamConfig.rtp.remote_ssrc,
+              mRecvStreamConfig.rtp.remote_ssrc);
   return kMediaConduitNoError;
 }
 
@@ -817,7 +816,7 @@
   }
   return nullptr;
 }
-/*
+
 // Compare lists of codecs
 static bool CodecsDifferent(const nsTArray<UniquePtr<VideoCodecConfig>>& a,
                             const nsTArray<UniquePtr<VideoCodecConfig>>& b) {
@@ -838,7 +837,7 @@
 
   return false;
 }
-*/
+
 /**
  * Note: Setting the send-codec on the Video Engine will restart the encoder,
  * sets up new SSRC and reset RTP_RTCP module with the new codec setting.
@@ -865,156 +864,149 @@
   if ((condError = ValidateCodecConfig(codecConfig)) != kMediaConduitNoError) {
     return condError;
   }
-  /*
-    size_t streamCount = std::min(codecConfig->mEncodings.size(),
-                                  (size_t)webrtc::kMaxSimulcastStreams);
-    size_t highestResolutionIndex = 0;
-    for (size_t i = 1; i < streamCount; ++i) {
-      if (codecConfig->mEncodings[i].constraints.scaleDownBy <
-          codecConfig->mEncodings[highestResolutionIndex]
-              .constraints.scaleDownBy) {
-        highestResolutionIndex = i;
-      }
-    }
-
-    MOZ_RELEASE_ASSERT(streamCount >= 1, "streamCount should be at least one");
 
-    CSFLogDebug(LOGTAG, "%s for VideoConduit:%p stream count:%zu", __FUNCTION__,
-                this, streamCount);
-
-    mSendingFramerate = 0;
-    mSendStreamConfig.rtp.rids.clear();
+  size_t streamCount = std::min(codecConfig->mEncodings.size(),
+                                (size_t)webrtc::kMaxSimulcastStreams);
+  size_t highestResolutionIndex = 0;
+  for (size_t i = 1; i < streamCount; ++i) {
+    if (codecConfig->mEncodings[i].constraints.scaleDownBy <
+        codecConfig->mEncodings[highestResolutionIndex]
+            .constraints.scaleDownBy) {
+      highestResolutionIndex = i;
+    }
+  }
 
-    int max_framerate;
-    if (codecConfig->mEncodingConstraints.maxFps > 0) {
-      max_framerate = codecConfig->mEncodingConstraints.maxFps;
-    } else {
-      max_framerate = DEFAULT_VIDEO_MAX_FRAMERATE;
-    }
-    // apply restrictions from maxMbps/etc
-    mSendingFramerate =
-        SelectSendFrameRate(codecConfig, max_framerate, mLastWidth,
-    mLastHeight);
+  MOZ_RELEASE_ASSERT(streamCount >= 1, "streamCount should be at least one");
+
+  CSFLogDebug(LOGTAG, "%s for VideoConduit:%p stream count:%zu", __FUNCTION__,
+              this, streamCount);
+
+  mSendingFramerate = 0;
+  mSendStreamConfig.rtp.rids.clear();
 
-    // So we can comply with b=TIAS/b=AS/maxbr=X when input resolution changes
-    mNegotiatedMaxBitrate = codecConfig->mTias;
+  int max_framerate;
+  if (codecConfig->mEncodingConstraints.maxFps > 0) {
+    max_framerate = codecConfig->mEncodingConstraints.maxFps;
+  } else {
+    max_framerate = DEFAULT_VIDEO_MAX_FRAMERATE;
+  }
+  // apply restrictions from maxMbps/etc
+  mSendingFramerate =
+      SelectSendFrameRate(codecConfig, max_framerate, mLastWidth, mLastHeight);
+
+  // So we can comply with b=TIAS/b=AS/maxbr=X when input resolution changes
+  mNegotiatedMaxBitrate = codecConfig->mTias;
 
-    if (mLastWidth == 0 && mMinBitrateEstimate != 0) {
-      // Only do this at the start; use "have we send a frame" as a reasonable
-      // stand-in. min <= start <= max (which can be -1, note!)
-      webrtc::Call::Config::BitrateConfig config;
-      config.min_bitrate_bps = mMinBitrateEstimate;
-      if (config.start_bitrate_bps < mMinBitrateEstimate) {
-        config.start_bitrate_bps = mMinBitrateEstimate;
-      }
-      if (config.max_bitrate_bps > 0 &&
-          config.max_bitrate_bps < mMinBitrateEstimate) {
-        config.max_bitrate_bps = mMinBitrateEstimate;
-      }
-      mCall->Call()->SetBitrateConfig(config);
-    }
+  if (mLastWidth == 0 && mMinBitrateEstimate != 0) {
+    // Only do this at the start; use "have we send a frame" as a reasonable
+    // stand-in. min <= start <= max (but all three parameters are optional)
+    webrtc::BitrateSettings settings;
+    settings.min_bitrate_bps = mMinBitrateEstimate;
+    settings.start_bitrate_bps = mMinBitrateEstimate;
+    mCall->Call()->SetClientBitratePreferences(settings);
+  }
 
-    mVideoStreamFactory = new rtc::RefCountedObject<VideoStreamFactory>(
-        *codecConfig, mCodecMode, mMinBitrate, mStartBitrate, mPrefMaxBitrate,
-        mNegotiatedMaxBitrate, mSendingFramerate);
-    mEncoderConfig.video_stream_factory = mVideoStreamFactory.get();
+  mVideoStreamFactory = new rtc::RefCountedObject<VideoStreamFactory>(
+      *codecConfig, mCodecMode, mMinBitrate, mStartBitrate, mPrefMaxBitrate,
+      mNegotiatedMaxBitrate, mSendingFramerate);
+  mEncoderConfig.video_stream_factory = mVideoStreamFactory.get();
 
-    // Reset the VideoAdapter. SelectResolution will ensure limits are set.
-    mVideoAdapter = MakeUnique<cricket::VideoAdapter>(
-        streamCount > 1 ? SIMULCAST_RESOLUTION_ALIGNMENT : 1);
-    mVideoAdapter->OnScaleResolutionBy(
-        codecConfig->mEncodings[highestResolutionIndex].constraints.scaleDownBy
-    > 1.0 ?
-    absl::optional<float>(codecConfig->mEncodings[highestResolutionIndex]
-                                       .constraints.scaleDownBy)
-            : absl::optional<float>());
-*/
+  // Reset the VideoAdapter. SelectResolution will ensure limits are set.
+  mVideoAdapter = MakeUnique<cricket::VideoAdapter>(
+      streamCount > 1 ? SIMULCAST_RESOLUTION_ALIGNMENT : 1);
+  mVideoAdapter->OnScaleResolutionBy(
+      codecConfig->mEncodings[highestResolutionIndex].constraints.scaleDownBy >
+              1.0
+          ? absl::optional<float>(
+                codecConfig->mEncodings[highestResolutionIndex]
+                    .constraints.scaleDownBy)
+          : absl::optional<float>());
+
   // XXX parse the encoded SPS/PPS data and set spsData/spsLen/ppsData/ppsLen
   mEncoderConfig.encoder_specific_settings =
       ConfigureVideoEncoderSettings(codecConfig, this);
-  /*
-      mEncoderConfig.content_type =
-          mCodecMode == webrtc::kRealtimeVideo
-              ? webrtc::VideoEncoderConfig::ContentType::kRealtimeVideo
-              : webrtc::VideoEncoderConfig::ContentType::kScreen;
-      // for the GMP H.264 encoder/decoder!!
-      mEncoderConfig.min_transmit_bitrate_bps = 0;
-      // Expected max number of encodings
-      mEncoderConfig.number_of_streams = streamCount;
+
+  mEncoderConfig.content_type =
+      mCodecMode == webrtc::VideoCodecMode::kRealtimeVideo
+          ? webrtc::VideoEncoderConfig::ContentType::kRealtimeVideo
+          : webrtc::VideoEncoderConfig::ContentType::kScreen;
+  // for the GMP H.264 encoder/decoder!!
+  mEncoderConfig.min_transmit_bitrate_bps = 0;
+  // Expected max number of encodings
+  mEncoderConfig.number_of_streams = streamCount;
 
-      // If only encoder stream attibutes have been changed, there is no need to
-      // stop, create a new webrtc::VideoSendStream, and restart. Recreating on
-      // PayloadType change may be overkill, but is safe.
-      if (mSendStream) {
-        if (!RequiresNewSendStream(*codecConfig) &&
-            mActiveCodecMode == mCodecMode) {
-          mCurSendCodecConfig->mEncodingConstraints =
-              codecConfig->mEncodingConstraints;
-          mCurSendCodecConfig->mEncodings = codecConfig->mEncodings;
-          mSendStream->ReconfigureVideoEncoder(mEncoderConfig.Copy());
-          return kMediaConduitNoError;
-        }
+  // If only encoder stream attibutes have been changed, there is no need to
+  // stop, create a new webrtc::VideoSendStream, and restart. Recreating on
+  // PayloadType change may be overkill, but is safe.
+  if (mSendStream) {
+    if (!RequiresNewSendStream(*codecConfig) &&
+        mActiveCodecMode == mCodecMode) {
+      mCurSendCodecConfig->mEncodingConstraints =
+          codecConfig->mEncodingConstraints;
+      mCurSendCodecConfig->mEncodings = codecConfig->mEncodings;
+      mSendStream->ReconfigureVideoEncoder(mEncoderConfig.Copy());
+      return kMediaConduitNoError;
+    }
 
-        condError = StopTransmittingLocked();
-        if (condError != kMediaConduitNoError) {
-          return condError;
-        }
+    condError = StopTransmittingLocked();
+    if (condError != kMediaConduitNoError) {
+      return condError;
+    }
 
-        // This will cause a new encoder to be created by StartTransmitting()
-        DeleteSendStream();
-      }
+    // This will cause a new encoder to be created by StartTransmitting()
+    DeleteSendStream();
+  }
 
-      mSendStreamConfig.encoder_settings.payload_name = codecConfig->mName;
-      mSendStreamConfig.encoder_settings.payload_type = codecConfig->mType;
-      mSendStreamConfig.rtp.rtcp_mode = aRtpRtcpConfig.GetRtcpMode();
-      mSendStreamConfig.rtp.max_packet_size = kVideoMtu;
-      if (codecConfig->RtxPayloadTypeIsSet()) {
-        mSendStreamConfig.rtp.rtx.payload_type = codecConfig->mRTXPayloadType;
-      } else {
-        mSendStreamConfig.rtp.rtx.payload_type = -1;
-        mSendStreamConfig.rtp.rtx.ssrcs.clear();
-      }
+  mSendStreamConfig.rtp.payload_name = codecConfig->mName;
+  mSendStreamConfig.rtp.payload_type = codecConfig->mType;
+  mSendStreamConfig.rtp.rtcp_mode = aRtpRtcpConfig.GetRtcpMode();
+  mSendStreamConfig.rtp.max_packet_size = kVideoMtu;
+  if (codecConfig->RtxPayloadTypeIsSet()) {
+    mSendStreamConfig.rtp.rtx.payload_type = codecConfig->mRTXPayloadType;
+  } else {
+    mSendStreamConfig.rtp.rtx.payload_type = -1;
+    mSendStreamConfig.rtp.rtx.ssrcs.clear();
+  }
 
-      // See Bug 1297058, enabling FEC when basic NACK is to be enabled in H.264
-      is
-      // problematic
-      if (codecConfig->RtcpFbFECIsSet() &&
-          !(codecConfig->mName == "H264" && codecConfig->RtcpFbNackIsSet(""))) {
-        mSendStreamConfig.rtp.ulpfec.ulpfec_payload_type =
-            codecConfig->mULPFECPayloadType;
-        mSendStreamConfig.rtp.ulpfec.red_payload_type =
-            codecConfig->mREDPayloadType;
-        mSendStreamConfig.rtp.ulpfec.red_rtx_payload_type =
-            codecConfig->mREDRTXPayloadType;
-      } else {
-        // Reset to defaults
-        mSendStreamConfig.rtp.ulpfec.ulpfec_payload_type = -1;
-        mSendStreamConfig.rtp.ulpfec.red_payload_type = -1;
-        mSendStreamConfig.rtp.ulpfec.red_rtx_payload_type = -1;
-      }
+  // See Bug 1297058, enabling FEC when basic NACK is to be enabled in H.264
+  // is problematic
+  if (codecConfig->RtcpFbFECIsSet() &&
+      !(codecConfig->mName == "H264" && codecConfig->RtcpFbNackIsSet(""))) {
+    mSendStreamConfig.rtp.ulpfec.ulpfec_payload_type =
+        codecConfig->mULPFECPayloadType;
+    mSendStreamConfig.rtp.ulpfec.red_payload_type =
+        codecConfig->mREDPayloadType;
+    mSendStreamConfig.rtp.ulpfec.red_rtx_payload_type =
+        codecConfig->mREDRTXPayloadType;
+  } else {
+    // Reset to defaults
+    mSendStreamConfig.rtp.ulpfec.ulpfec_payload_type = -1;
+    mSendStreamConfig.rtp.ulpfec.red_payload_type = -1;
+    mSendStreamConfig.rtp.ulpfec.red_rtx_payload_type = -1;
+  }
+
+  mSendStreamConfig.rtp.nack.rtp_history_ms =
+      codecConfig->RtcpFbNackIsSet("") ? 1000 : 0;
 
-      mSendStreamConfig.rtp.nack.rtp_history_ms =
-          codecConfig->RtcpFbNackIsSet("") ? 1000 : 0;
-
-      // Copy the applied config for future reference.
-      mCurSendCodecConfig = MakeUnique<VideoCodecConfig>(*codecConfig);
+  // Copy the applied config for future reference.
+  mCurSendCodecConfig = MakeUnique<VideoCodecConfig>(*codecConfig);
 
-      mSendStreamConfig.rtp.rids.clear();
-      bool has_rid = false;
-      for (size_t idx = 0; idx < streamCount; idx++) {
-        auto& encoding = mCurSendCodecConfig->mEncodings[idx];
-        if (encoding.rid[0]) {
-          has_rid = true;
-          break;
-        }
-      }
-      if (has_rid) {
-        for (size_t idx = streamCount; idx > 0; idx--) {
-          auto& encoding = mCurSendCodecConfig->mEncodings[idx - 1];
-          mSendStreamConfig.rtp.rids.push_back(encoding.rid);
-        }
-      }
-    */
+  mSendStreamConfig.rtp.rids.clear();
+  bool has_rid = false;
+  for (size_t idx = 0; idx < streamCount; idx++) {
+    auto& encoding = mCurSendCodecConfig->mEncodings[idx];
+    if (encoding.rid[0]) {
+      has_rid = true;
+      break;
+    }
+  }
+  if (has_rid) {
+    for (size_t idx = streamCount; idx > 0; idx--) {
+      auto& encoding = mCurSendCodecConfig->mEncodings[idx - 1];
+      mSendStreamConfig.rtp.rids.push_back(encoding.rid);
+    }
+  }
+
   return condError;
 }
 
@@ -1492,180 +1484,162 @@
     const std::vector<UniquePtr<VideoCodecConfig>>& codecConfigList,
     const RtpRtcpConfig& aRtpRtcpConfig) {
   MOZ_ASSERT(NS_IsMainThread());
-  /*
-    CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
-    MediaConduitErrorCode condError = kMediaConduitNoError;
-    std::string payloadName;
+  CSFLogDebug(LOGTAG, "%s ", __FUNCTION__);
+  MediaConduitErrorCode condError = kMediaConduitNoError;
+  std::string payloadName;
 
-    if (codecConfigList.empty()) {
-      CSFLogError(LOGTAG, "%s Zero number of codecs to configure",
-    __FUNCTION__); return kMediaConduitMalformedArgument;
-    }
+  if (codecConfigList.empty()) {
+    CSFLogError(LOGTAG, "%s Zero number of codecs to configure", __FUNCTION__);
+    return kMediaConduitMalformedArgument;
+  }
 
-    webrtc::KeyFrameRequestMethod kf_request_method =
-    webrtc::kKeyFrameReqPliRtcp; bool kf_request_enabled = false; bool
-    use_nack_basic = false; bool use_tmmbr = false; bool use_remb = false; bool
-    use_fec = false; bool use_transport_cc = false; int ulpfec_payload_type =
-    kNullPayloadType; int red_payload_type = kNullPayloadType; bool
-    configuredH264 = false; nsTArray<UniquePtr<VideoCodecConfig>> recv_codecs;
+  bool use_nack_basic = false;
+  bool use_tmmbr = false;
+  bool use_fec = false;
+  bool use_transport_cc = false;
+  int ulpfec_payload_type = kNullPayloadType;
+  int red_payload_type = kNullPayloadType;
+  bool configuredH264 = false;
+  nsTArray<UniquePtr<VideoCodecConfig>> recv_codecs;
 
-    // Try Applying the codecs in the list
-    // we treat as success if at least one codec was applied and reception was
-    // started successfully.
-    std::set<unsigned int> codec_types_seen;
-    for (const auto& codec_config : codecConfigList) {
-      if ((condError = ValidateCodecConfig(codec_config.get())) !=
-          kMediaConduitNoError) {
-        CSFLogError(LOGTAG, "%s Invalid config for %s decoder: %i",
-    __FUNCTION__, codec_config ? codec_config->mName.c_str() : "<null>",
-                    condError);
+  // Try Applying the codecs in the list
+  // we treat as success if at least one codec was applied and reception was
+  // started successfully.
+  std::set<unsigned int> codec_types_seen;
+  for (const auto& codec_config : codecConfigList) {
+    if ((condError = ValidateCodecConfig(codec_config.get())) !=
+        kMediaConduitNoError) {
+      CSFLogError(LOGTAG, "%s Invalid config for %s decoder: %i", __FUNCTION__,
+                  codec_config ? codec_config->mName.c_str() : "<null>",
+                  condError);
+      continue;
+    }
+    if (codec_config->mName == "H264") {
+      // TODO(bug 1200768): We can only handle configuring one recv H264 codec
+      if (configuredH264) {
         continue;
       }
-      if (codec_config->mName == "H264") {
-        // TODO(bug 1200768): We can only handle configuring one recv H264 codec
-        if (configuredH264) {
-          continue;
-        }
-        configuredH264 = true;
-      }
-
-      if (codec_config->mName == kUlpFecPayloadName) {
-        ulpfec_payload_type = codec_config->mType;
-        continue;
-      }
-
-      if (codec_config->mName == kRedPayloadName) {
-        red_payload_type = codec_config->mType;
-        continue;
-      }
-
-      // Check for the keyframe request type: PLI is preferred
-      // over FIR, and FIR is preferred over none.
-      // XXX (See upstream issue
-      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7002): There is no
-      // 'none' option in webrtc.org
-      if (codec_config->RtcpFbNackIsSet("pli")) {
-        kf_request_enabled = true;
-        kf_request_method = webrtc::kKeyFrameReqPliRtcp;
-      } else if (!kf_request_enabled && codec_config->RtcpFbCcmIsSet("fir")) {
-        kf_request_enabled = true;
-        kf_request_method = webrtc::kKeyFrameReqFirRtcp;
-      }
-
-      // What if codec A has Nack and REMB, and codec B has TMMBR, and codec C
-    has
-      // none? In practice, that's not a useful configuration, and
-      // VideoReceiveStream::Config can't represent that, so simply union the
-      // (boolean) settings
-      use_nack_basic |= codec_config->RtcpFbNackIsSet("");
-      use_tmmbr |= codec_config->RtcpFbCcmIsSet("tmmbr");
-      use_remb |= codec_config->RtcpFbRembIsSet();
-      use_fec |= codec_config->RtcpFbFECIsSet();
-      use_transport_cc |= codec_config->RtcpFbTransportCCIsSet();
-
-      recv_codecs.AppendElement(new VideoCodecConfig(*codec_config));
+      configuredH264 = true;
     }
 
-    if (!recv_codecs.Length()) {
-      CSFLogError(LOGTAG, "%s Found no valid receive codecs", __FUNCTION__);
-      return kMediaConduitMalformedArgument;
+    if (codec_config->mName == kUlpFecPayloadName) {
+      ulpfec_payload_type = codec_config->mType;
+      continue;
+    }
+
+    if (codec_config->mName == kRedPayloadName) {
+      red_payload_type = codec_config->mType;
+      continue;
     }
 
-    // Now decide if we need to recreate the receive stream, or can keep it
-    if (!mRecvStream || CodecsDifferent(recv_codecs, mRecvCodecList) ||
-        mRecvStreamConfig.rtp.nack.rtp_history_ms !=
-            (use_nack_basic ? 1000 : 0) ||
-        mRecvStreamConfig.rtp.remb != use_remb ||
-        mRecvStreamConfig.rtp.transport_cc != use_transport_cc ||
-        mRecvStreamConfig.rtp.tmmbr != use_tmmbr ||
-        mRecvStreamConfig.rtp.keyframe_method != kf_request_method ||
-        (use_fec &&
-         (mRecvStreamConfig.rtp.ulpfec_payload_type != ulpfec_payload_type ||
-          mRecvStreamConfig.rtp.red_payload_type != red_payload_type))) {
-      MutexAutoLock lock(mMutex);
+    // What if codec A has Nack and REMB, and codec B has TMMBR, and codec C has
+    // none? In practice, that's not a useful configuration, and
+    // VideoReceiveStream::Config can't represent that, so simply union the
+    // (boolean) settings
+    use_nack_basic |= codec_config->RtcpFbNackIsSet("");
+    use_tmmbr |= codec_config->RtcpFbCcmIsSet("tmmbr");
+    use_fec |= codec_config->RtcpFbFECIsSet();
+    use_transport_cc |= codec_config->RtcpFbTransportCCIsSet();
+
+    recv_codecs.AppendElement(new VideoCodecConfig(*codec_config));
+  }
+
+  if (!recv_codecs.Length()) {
+    CSFLogError(LOGTAG, "%s Found no valid receive codecs", __FUNCTION__);
+    return kMediaConduitMalformedArgument;
+  }
+
+  // Now decide if we need to recreate the receive stream, or can keep it
+  if (!mRecvStream || CodecsDifferent(recv_codecs, mRecvCodecList) ||
+      mRecvStreamConfig.rtp.nack.rtp_history_ms !=
+          (use_nack_basic ? 1000 : 0) ||
+      mRecvStreamConfig.rtp.transport_cc != use_transport_cc ||
+      mRecvStreamConfig.rtp.tmmbr != use_tmmbr ||
+      (use_fec &&
+       (mRecvStreamConfig.rtp.ulpfec_payload_type != ulpfec_payload_type ||
+        mRecvStreamConfig.rtp.red_payload_type != red_payload_type))) {
+    MutexAutoLock lock(mMutex);
 
-      condError = StopReceivingLocked();
-      if (condError != kMediaConduitNoError) {
-        return condError;
+    condError = StopReceivingLocked();
+    if (condError != kMediaConduitNoError) {
+      return condError;
+    }
+
+    // If we fail after here things get ugly
+    mRecvStreamConfig.rtp.rtcp_mode = aRtpRtcpConfig.GetRtcpMode();
+    mRecvStreamConfig.rtp.nack.rtp_history_ms = use_nack_basic ? 1000 : 0;
+    mRecvStreamConfig.rtp.transport_cc = use_transport_cc;
+    mRecvStreamConfig.rtp.tmmbr = use_tmmbr;
+    // mRecvStreamConfig.rtp.keyframe_method = kf_request_method;
+
+    if (use_fec) {
+      mRecvStreamConfig.rtp.ulpfec_payload_type = ulpfec_payload_type;
+      mRecvStreamConfig.rtp.red_payload_type = red_payload_type;
+    } else {
+      // Reset to defaults
+      mRecvStreamConfig.rtp.ulpfec_payload_type = -1;
+      mRecvStreamConfig.rtp.red_payload_type = -1;
+    }
+
+    mRecvStreamConfig.rtp.rtx_associated_payload_types.clear();
+    for (auto& codec : recv_codecs) {
+      if (codec->RtxPayloadTypeIsSet()) {
+        mRecvStreamConfig.rtp
+            .rtx_associated_payload_types[codec->mRTXPayloadType] =
+            codec->mType;
       }
+    }
+    // SetRemoteSSRC should have populated this already
+    mRecvSSRC = mRecvStreamConfig.rtp.remote_ssrc;
 
-      // If we fail after here things get ugly
-      mRecvStreamConfig.rtp.rtcp_mode = aRtpRtcpConfig.GetRtcpMode();
-      mRecvStreamConfig.rtp.nack.rtp_history_ms = use_nack_basic ? 1000 : 0;
-      mRecvStreamConfig.rtp.remb = use_remb;
-      mRecvStreamConfig.rtp.transport_cc = use_transport_cc;
-      mRecvStreamConfig.rtp.tmmbr = use_tmmbr;
-      mRecvStreamConfig.rtp.keyframe_method = kf_request_method;
-
-      if (use_fec) {
-        mRecvStreamConfig.rtp.ulpfec_payload_type = ulpfec_payload_type;
-        mRecvStreamConfig.rtp.red_payload_type = red_payload_type;
-      } else {
-        // Reset to defaults
-        mRecvStreamConfig.rtp.ulpfec_payload_type = -1;
-        mRecvStreamConfig.rtp.red_payload_type = -1;
+    // XXX ugh! same SSRC==0 problem that webrtc.org has
+    if (mRecvSSRC == 0) {
+      // Handle un-signalled SSRCs by creating a random one and then when it
+      // actually gets set, we'll destroy and recreate.  Simpler than trying
+      // to unwind all the logic that assumes the receive stream is created and
+      // started when we ConfigureRecvMediaCodecs()
+      uint32_t ssrc = GenerateRandomSSRC();
+      if (ssrc == 0) {
+        // webrtc.org code has fits if you select an SSRC of 0, so that's how
+        // we signal an error.
+        return kMediaConduitUnknownError;
       }
 
-      mRecvStreamConfig.rtp.rtx_associated_payload_types.clear();
-      for (auto& codec : recv_codecs) {
-        if (codec->RtxPayloadTypeIsSet()) {
-          mRecvStreamConfig.rtp.AddRtxBinding(codec->mRTXPayloadType,
-                                              codec->mType);
-        }
-      }
-      // SetRemoteSSRC should have populated this already
-      mRecvSSRC = mRecvStreamConfig.rtp.remote_ssrc;
+      mRecvStreamConfig.rtp.remote_ssrc = ssrc;
+      mRecvSSRC = ssrc;
+    }
 
-      // XXX ugh! same SSRC==0 problem that webrtc.org has
-      if (mRecvSSRC == 0) {
-        // Handle un-signalled SSRCs by creating a random one and then when it
-        // actually gets set, we'll destroy and recreate.  Simpler than trying
-    to
-        // unwind all the logic that assumes the receive stream is created and
-        // started when we ConfigureRecvMediaCodecs()
-        uint32_t ssrc = GenerateRandomSSRC();
-        if (ssrc == 0) {
-          // webrtc.org code has fits if you select an SSRC of 0, so that's how
-          // we signal an error.
-          return kMediaConduitUnknownError;
-        }
-
-        mRecvStreamConfig.rtp.remote_ssrc = ssrc;
-        mRecvSSRC = ssrc;
-      }
+    // 0 isn't allowed.  Would be best to ask for a random SSRC from the
+    // RTP code.  Would need to call rtp_sender.cc -- GenerateNewSSRC(),
+    // which isn't exposed.  It's called on collision, or when we decide to
+    // send.  it should be called on receiver creation.  Here, we're
+    // generating the SSRC value - but this causes ssrc_forced in set in
+    // rtp_sender, which locks us into the SSRC - even a collision won't
+    // change it!!!
+    MOZ_ASSERT(!mSendStreamConfig.rtp.ssrcs.empty());
+    auto ssrc = mSendStreamConfig.rtp.ssrcs.front();
+    Unused << NS_WARN_IF(ssrc == mRecvStreamConfig.rtp.remote_ssrc);
 
-      // 0 isn't allowed.  Would be best to ask for a random SSRC from the
-      // RTP code.  Would need to call rtp_sender.cc -- GenerateNewSSRC(),
-      // which isn't exposed.  It's called on collision, or when we decide to
-      // send.  it should be called on receiver creation.  Here, we're
-      // generating the SSRC value - but this causes ssrc_forced in set in
-      // rtp_sender, which locks us into the SSRC - even a collision won't
-      // change it!!!
-      MOZ_ASSERT(!mSendStreamConfig.rtp.ssrcs.empty());
-      auto ssrc = mSendStreamConfig.rtp.ssrcs.front();
-      Unused << NS_WARN_IF(ssrc == mRecvStreamConfig.rtp.remote_ssrc);
+    while (ssrc == mRecvStreamConfig.rtp.remote_ssrc) {
+      ssrc = GenerateRandomSSRC();
+      if (ssrc == 0) {
+        return kMediaConduitUnknownError;
+      }
+    }
 
-      while (ssrc == mRecvStreamConfig.rtp.remote_ssrc) {
-        ssrc = GenerateRandomSSRC();
-        if (ssrc == 0) {
-          return kMediaConduitUnknownError;
-        }
-      }
+    mRecvStreamConfig.rtp.local_ssrc = ssrc;
+    CSFLogDebug(LOGTAG,
+                "%s (%p): Local SSRC 0x%08x (of %u), remote SSRC 0x%08x",
+                __FUNCTION__, (void*)this, ssrc,
+                (uint32_t)mSendStreamConfig.rtp.ssrcs.size(),
+                mRecvStreamConfig.rtp.remote_ssrc);
 
-      mRecvStreamConfig.rtp.local_ssrc = ssrc;
-      CSFLogDebug(LOGTAG,
-                  "%s (%p): Local SSRC 0x%08x (of %u), remote SSRC 0x%08x",
-                  __FUNCTION__, (void*)this, ssrc,
-                  (uint32_t)mSendStreamConfig.rtp.ssrcs.size(),
-                  mRecvStreamConfig.rtp.remote_ssrc);
+    // XXX Copy over those that are the same and don't rebuild them
+    mRecvCodecList = std::move(recv_codecs);
 
-      // XXX Copy over those that are the same and don't rebuild them
-      mRecvCodecList = std::move(recv_codecs);
-
-      DeleteRecvStream();
-      return StartReceivingLocked();
-    }
-  */
+    DeleteRecvStream();
+    return StartReceivingLocked();
+  }
   return kMediaConduitNoError;
 }
 
@@ -1835,30 +1809,29 @@
                                               unsigned short height) {
   mMutex.AssertCurrentThreadOwns();
   // XXX This will do bandwidth-resolution adaptation as well - bug 877954
-  /*
-    // Enforce constraints
-    if (mCurSendCodecConfig) {
-      uint16_t max_width = mCurSendCodecConfig->mEncodingConstraints.maxWidth;
-      uint16_t max_height = mCurSendCodecConfig->mEncodingConstraints.maxHeight;
-      if (max_width || max_height) {
-        max_width = max_width ? max_width : UINT16_MAX;
-        max_height = max_height ? max_height : UINT16_MAX;
-        ConstrainPreservingAspectRatio(max_width, max_height, &width, &height);
-      }
+  // Enforce constraints
+  if (mCurSendCodecConfig) {
+    uint16_t max_width = mCurSendCodecConfig->mEncodingConstraints.maxWidth;
+    uint16_t max_height = mCurSendCodecConfig->mEncodingConstraints.maxHeight;
+    if (max_width || max_height) {
+      max_width = max_width ? max_width : UINT16_MAX;
+      max_height = max_height ? max_height : UINT16_MAX;
+      ConstrainPreservingAspectRatio(max_width, max_height, &width, &height);
+    }
 
-      int max_fs = mSinkWantsPixelCount;
-      // Limit resolution to max-fs
-      if (mCurSendCodecConfig->mEncodingConstraints.maxFs) {
-        // max-fs is in macroblocks, convert to pixels
-        max_fs = std::min(
-            max_fs,
-            static_cast<int>(mCurSendCodecConfig->mEncodingConstraints.maxFs *
-                             (16 * 16)));
-      }
-      mVideoAdapter->OnResolutionFramerateRequest(
-          absl::optional<int>(), max_fs, std::numeric_limits<int>::max());
+    int max_fs = mSinkWantsPixelCount;
+    // Limit resolution to max-fs
+    if (mCurSendCodecConfig->mEncodingConstraints.maxFs) {
+      // max-fs is in macroblocks, convert to pixels
+      max_fs = std::min(
+          max_fs,
+          static_cast<int>(mCurSendCodecConfig->mEncodingConstraints.maxFs *
+                           (16 * 16)));
     }
-  */
+    mVideoAdapter->OnOutputFormatRequest(absl::optional<std::pair<int, int>>(),
+                                         max_fs, absl::optional<int>());
+  }
+
   unsigned int framerate = SelectSendFrameRate(
       mCurSendCodecConfig.get(), mSendingFramerate, width, height);
   if (mSendingFramerate != framerate) {