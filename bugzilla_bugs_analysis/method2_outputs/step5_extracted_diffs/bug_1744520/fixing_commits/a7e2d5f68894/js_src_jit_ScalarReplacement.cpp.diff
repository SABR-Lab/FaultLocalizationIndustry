# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ScalarReplacement.cpp
# Commit: a7e2d5f68894
# Full Hash: a7e2d5f68894a40df8e7733b755d174c1fcb911a
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2021-12-08 03:42:13
# Description:
#   Bug 1744520: Fix OOM handling for variadic instructions r=jandem
#   
#   Variadic instructions contain a FixedList of operands which is initialized fallibly in MVariadicT::init. This means MFoo::New is fallible for variadic instructions. A fuzz bug found one unhandled OOM in scalar replacement. I did a quick survey of places where we create new variadic nodes, and found a few more latent bugs that I introduced in my patches to scalar-replace arguments. I fixed those bugs and added a comment on MVariadicInstruction in the hopes of avoiding the same mistake in the future.
#   
#   I'm not adding the fuzz testcase, because OOM tests of Ion internals are incredibly fragile and will stop working as soon as we add or remove one more allocation somewhere.
# ==============================================================================

diff -r 54b37531f2bc -r a7e2d5f68894 js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp	Tue Dec 07 17:25:02 2021 +0000
+++ b/js/src/jit/ScalarReplacement.cpp	Tue Dec 07 17:47:08 2021 +0000
@@ -1451,6 +1451,10 @@
   bool isDOMCall = false;
   auto* call = MakeCall(alloc_, addUndefined, callInfo, needsThisCheck,
                         ins->getSingleTarget(), isDOMCall);
+  if (!call) {
+    oom_ = true;
+    return;
+  }
   if (!ins->maybeCrossRealm()) {
     call->setNotCrossRealm();
   }
@@ -1493,6 +1497,10 @@
   bool isDOMCall = false;
   auto* call = MakeCall(alloc_, addUndefined, callInfo, needsThisCheck,
                         ins->getSingleTarget(), isDOMCall);
+  if (!call) {
+    oom_ = true;
+    return;
+  }
   if (!ins->maybeCrossRealm()) {
     call->setNotCrossRealm();
   }
@@ -1517,6 +1525,8 @@
   MIRGraph& graph_;
   MInstruction* args_;
 
+  bool oom_ = false;
+
   TempAllocator& alloc() { return graph_.alloc(); }
 
   bool isInlinedArguments() const {
@@ -1536,6 +1546,8 @@
   void visitArrayFromArgumentsObject(MArrayFromArgumentsObject* ins);
   void visitLoadFixedSlot(MLoadFixedSlot* ins);
 
+  bool oom() const { return oom_; }
+
  public:
   ArgumentsReplacer(MIRGenerator* mir, MIRGraph& graph, MInstruction* args)
       : mir_(mir), graph_(graph), args_(args) {
@@ -1693,6 +1705,9 @@
         MIR_OPCODE_LIST(MIR_OP)
 #undef MIR_OP
       }
+      if (oom()) {
+        return false;
+      }
     }
   }
 
@@ -1864,6 +1879,10 @@
     }
 
     loadArg = MGetInlinedArgument::New(alloc(), check, actualArgs);
+    if (!loadArg) {
+      oom_ = true;
+      return;
+    }
   } else {
     // Insert bounds check.
     auto* length = MArgumentsLength::New(alloc());
@@ -1905,6 +1924,10 @@
     auto* actualArgs = args_->toCreateInlinedArgumentsObject();
 
     loadArg = MGetInlinedArgumentHole::New(alloc(), index, actualArgs);
+    if (!loadArg) {
+      oom_ = true;
+      return;
+    }
   } else {
     auto* length = MArgumentsLength::New(alloc());
     ins->block()->insertBefore(ins, length);
@@ -1999,6 +2022,10 @@
     bool isDOMCall = false;
     auto* call = MakeCall(alloc(), addUndefined, callInfo, needsThisCheck,
                           ins->getSingleTarget(), isDOMCall);
+    if (!call) {
+      oom_ = true;
+      return;
+    }
     if (!ins->maybeCrossRealm()) {
       call->setNotCrossRealm();
     }