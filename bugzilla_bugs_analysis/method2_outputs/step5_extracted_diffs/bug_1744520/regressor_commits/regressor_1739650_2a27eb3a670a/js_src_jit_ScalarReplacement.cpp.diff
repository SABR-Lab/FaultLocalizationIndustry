# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ScalarReplacement.cpp
# Commit: 2a27eb3a670a
# Full Hash: 2a27eb3a670a7778460c2acdf218c000d6a6f91a
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2021-11-10 09:24:53
# Regressor Bug: 1739650
# File Overlap Count: 1
# Description:
#   Bug 1739650 - Part 2: Support array scalar replacement for MConstructArray. r=iain
#   
#   And also support array scalar replacement for `MConstructArray`.
#   
#   Depends on D130480
# ==============================================================================

diff -r 5806df2b62db -r 2a27eb3a670a js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp	Tue Nov 09 16:30:03 2021 +0000
+++ b/js/src/jit/ScalarReplacement.cpp	Tue Nov 09 16:30:03 2021 +0000
@@ -829,6 +829,15 @@
         }
         break;
 
+      case MDefinition::Opcode::ConstructArray:
+        MOZ_ASSERT(access->toConstructArray()->getElements() == def);
+        if (!IsPackedArray(newArray)) {
+          JitSpewDef(JitSpew_Escape, "is not guaranteed to be packed\n",
+                     access);
+          return true;
+        }
+        break;
+
       default:
         JitSpewDef(JitSpew_Escape, "is escaped by\n", access);
         return true;
@@ -1030,6 +1039,7 @@
   void visitGuardArrayIsPacked(MGuardArrayIsPacked* ins);
   void visitUnbox(MUnbox* ins);
   void visitApplyArray(MApplyArray* ins);
+  void visitConstructArray(MConstructArray* ins);
 };
 
 const char* ArrayMemoryView::phaseName = "Scalar Replacement of Array";
@@ -1422,6 +1432,48 @@
   discardInstruction(ins, elements);
 }
 
+void ArrayMemoryView::visitConstructArray(MConstructArray* ins) {
+  // Skip other array objects.
+  MDefinition* elements = ins->getElements();
+  if (!isArrayStateElements(elements)) {
+    return;
+  }
+
+  uint32_t numElements = state_->numElements();
+
+  CallInfo callInfo(alloc_, /*constructing=*/true, ins->ignoresReturnValue());
+  if (!callInfo.initForConstructArray(ins->getFunction(), ins->getThis(),
+                                      ins->getNewTarget(), numElements)) {
+    oom_ = true;
+    return;
+  }
+
+  for (uint32_t i = 0; i < numElements; i++) {
+    auto* element = state_->getElement(i);
+    MOZ_ASSERT(element->type() != MIRType::MagicHole);
+
+    callInfo.initArg(i, element);
+  }
+
+  auto addUndefined = [this]() { return undefinedVal_; };
+
+  bool needsThisCheck = true;
+  bool isDOMCall = false;
+  auto* call = MakeCall(alloc_, addUndefined, callInfo, needsThisCheck,
+                        ins->getSingleTarget(), isDOMCall);
+  if (!ins->maybeCrossRealm()) {
+    call->setNotCrossRealm();
+  }
+
+  ins->block()->insertBefore(ins, call);
+  ins->replaceAllUsesWith(call);
+
+  call->stealResumePoint(ins);
+
+  // Remove original instruction.
+  discardInstruction(ins, elements);
+}
+
 static inline bool IsOptimizableArgumentsInstruction(MInstruction* ins) {
   return ins->isCreateArgumentsObject() ||
          ins->isCreateInlinedArgumentsObject();