# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ScalarReplacement.cpp
# Commit: 5806df2b62db
# Full Hash: 5806df2b62db0f8f918bab1df43595b3d3b31885
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2021-11-10 09:24:53
# Regressor Bug: 1739650
# File Overlap Count: 1
# Description:
#   Bug 1739650 - Part 1: Support array scalar replacement for MApplyArray. r=iain
#   
#   This follows the approach we use when performing scalar replacement for `arguments`
#   in `MApplyArgsObj`. Scalar replacement is currently restricted to `MNewArrayObject`,
#   because only this instruction is guaranteed to be packed.
# ==============================================================================

diff -r ee898d5997e1 -r 5806df2b62db js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp	Tue Nov 09 16:27:21 2021 +0000
+++ b/js/src/jit/ScalarReplacement.cpp	Tue Nov 09 16:30:03 2021 +0000
@@ -728,10 +728,22 @@
   return true;
 }
 
+static inline bool IsOptimizableArrayInstruction(MInstruction* ins) {
+  return ins->isNewArray() || ins->isNewArrayObject();
+}
+
+// We don't support storing holes when doing scalar replacement, so any
+// optimizable MNewArrayObject instruction is guaranteed to be packed.
+static inline bool IsPackedArray(MInstruction* ins) {
+  return ins->isNewArrayObject();
+}
+
 // Returns False if the elements is not escaped and if it is optimizable by
 // ScalarReplacementOfArray.
-static bool IsElementEscaped(MDefinition* def, uint32_t arraySize) {
+static bool IsElementEscaped(MDefinition* def, MInstruction* newArray,
+                             uint32_t arraySize) {
   MOZ_ASSERT(def->isElements());
+  MOZ_ASSERT(IsOptimizableArrayInstruction(newArray));
 
   JitSpewDef(JitSpew_Escape, "Check elements\n", def);
   JitSpewIndent spewIndent(JitSpew_Escape);
@@ -808,6 +820,15 @@
         MOZ_ASSERT(access->toArrayLength()->elements() == def);
         break;
 
+      case MDefinition::Opcode::ApplyArray:
+        MOZ_ASSERT(access->toApplyArray()->getElements() == def);
+        if (!IsPackedArray(newArray)) {
+          JitSpewDef(JitSpew_Escape, "is not guaranteed to be packed\n",
+                     access);
+          return true;
+        }
+        break;
+
       default:
         JitSpewDef(JitSpew_Escape, "is escaped by\n", access);
         return true;
@@ -817,10 +838,6 @@
   return false;
 }
 
-static inline bool IsOptimizableArrayInstruction(MInstruction* ins) {
-  return ins->isNewArray() || ins->isNewArrayObject();
-}
-
 // Returns False if the array is not escaped and if it is optimizable by
 // ScalarReplacementOfArray.
 //
@@ -872,7 +889,7 @@
       case MDefinition::Opcode::Elements: {
         MElements* elem = def->toElements();
         MOZ_ASSERT(elem->object() == ins);
-        if (IsElementEscaped(elem, length)) {
+        if (IsElementEscaped(elem, newArray, length)) {
           JitSpewDef(JitSpew_Escape, "is indirectly escaped by\n", elem);
           return true;
         }
@@ -908,6 +925,19 @@
         break;
       }
 
+      case MDefinition::Opcode::GuardArrayIsPacked: {
+        auto* guard = def->toGuardArrayIsPacked();
+        if (!IsPackedArray(newArray)) {
+          JitSpewDef(JitSpew_Escape, "is not guaranteed to be packed\n", def);
+          return true;
+        }
+        if (IsArrayEscaped(guard, newArray)) {
+          JitSpewDef(JitSpew_Escape, "is indirectly escaped by\n", def);
+          return true;
+        }
+        break;
+      }
+
       case MDefinition::Opcode::Unbox: {
         if (def->type() != MIRType::Object) {
           JitSpewDef(JitSpew_Escape, "has an invalid unbox\n", def);
@@ -997,7 +1027,9 @@
   void visitPostWriteElementBarrier(MPostWriteElementBarrier* ins);
   void visitGuardShape(MGuardShape* ins);
   void visitGuardToClass(MGuardToClass* ins);
+  void visitGuardArrayIsPacked(MGuardArrayIsPacked* ins);
   void visitUnbox(MUnbox* ins);
+  void visitApplyArray(MApplyArray* ins);
 };
 
 const char* ArrayMemoryView::phaseName = "Scalar Replacement of Array";
@@ -1321,6 +1353,19 @@
   ins->block()->discard(ins);
 }
 
+void ArrayMemoryView::visitGuardArrayIsPacked(MGuardArrayIsPacked* ins) {
+  // Skip guards on other objects.
+  if (ins->array() != arr_) {
+    return;
+  }
+
+  // Replace the guard by its object.
+  ins->replaceAllUsesWith(arr_);
+
+  // Remove original instruction.
+  ins->block()->discard(ins);
+}
+
 void ArrayMemoryView::visitUnbox(MUnbox* ins) {
   // Skip unrelated unboxes.
   if (ins->getOperand(0) != arr_) {
@@ -1335,6 +1380,48 @@
   ins->block()->discard(ins);
 }
 
+void ArrayMemoryView::visitApplyArray(MApplyArray* ins) {
+  // Skip other array objects.
+  MDefinition* elements = ins->getElements();
+  if (!isArrayStateElements(elements)) {
+    return;
+  }
+
+  uint32_t numElements = state_->numElements();
+
+  CallInfo callInfo(alloc_, /*constructing=*/false, ins->ignoresReturnValue());
+  if (!callInfo.initForApplyArray(ins->getFunction(), ins->getThis(),
+                                  numElements)) {
+    oom_ = true;
+    return;
+  }
+
+  for (uint32_t i = 0; i < numElements; i++) {
+    auto* element = state_->getElement(i);
+    MOZ_ASSERT(element->type() != MIRType::MagicHole);
+
+    callInfo.initArg(i, element);
+  }
+
+  auto addUndefined = [this]() { return undefinedVal_; };
+
+  bool needsThisCheck = false;
+  bool isDOMCall = false;
+  auto* call = MakeCall(alloc_, addUndefined, callInfo, needsThisCheck,
+                        ins->getSingleTarget(), isDOMCall);
+  if (!ins->maybeCrossRealm()) {
+    call->setNotCrossRealm();
+  }
+
+  ins->block()->insertBefore(ins, call);
+  ins->replaceAllUsesWith(call);
+
+  call->stealResumePoint(ins);
+
+  // Remove original instruction.
+  discardInstruction(ins, elements);
+}
+
 static inline bool IsOptimizableArgumentsInstruction(MInstruction* ins) {
   return ins->isCreateArgumentsObject() ||
          ins->isCreateInlinedArgumentsObject();