# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: parser/html/nsHtml5TreeOpExecutor.cpp
# Commit: 3dfd3c94a105
# Full Hash: 3dfd3c94a105e095aada0b356f1106370de222d3
# Author: Henri Sivonen <hsivonen@hsivonen.fi>
# Date: 2021-12-07 15:51:17
# Regressor Bug: 1701828
# File Overlap Count: 1
# Description:
#   Bug 1701828 - meta charset rewrite. r=smaug
#   
#   Implements https://github.com/whatwg/html/issues/6962 . Improves performance
#   when <meta charset> occurs in head but after the first kilobyte and aligns
#   behavior better with WebKit and Blink.
# ==============================================================================

diff --git a/parser/html/nsHtml5TreeOpExecutor.cpp b/parser/html/nsHtml5TreeOpExecutor.cpp
--- a/parser/html/nsHtml5TreeOpExecutor.cpp
+++ b/parser/html/nsHtml5TreeOpExecutor.cpp
@@ -113,16 +113,17 @@ class MOZ_RAII nsHtml5AutoFlush final {
 };
 
 static LinkedList<nsHtml5TreeOpExecutor>* gBackgroundFlushList = nullptr;
 StaticRefPtr<IdleTaskRunner> gBackgroundFlushRunner;
 
 nsHtml5TreeOpExecutor::nsHtml5TreeOpExecutor()
     : nsHtml5DocumentBuilder(false),
       mSuppressEOF(false),
+      mPendingEncodingCommitment(false),
       mReadingFromStage(false),
       mStreamParser(nullptr),
       mPreloadedURLs(23),  // Mean # of preloadable resources per page on dmoz
       mStarted(false),
       mRunFlushLoopOnStack(false),
       mCallContinueInterruptedParsingIfEnabled(false),
       mAlreadyComplainedAboutCharset(false),
       mAlreadyComplainedAboutDeepTree(false) {}
@@ -427,34 +428,46 @@ nsresult nsHtml5TreeOpExecutor::MarkAsBr
     }
   }
   return aReason;
 }
 
 static bool BackgroundFlushCallback(TimeStamp /*aDeadline*/) {
   RefPtr<nsHtml5TreeOpExecutor> ex = gBackgroundFlushList->popFirst();
   if (ex) {
-    ex->RunFlushLoop();
+    ex->RunFlushLoopOrCommitToInternalEncoding();
   }
   if (gBackgroundFlushList && gBackgroundFlushList->isEmpty()) {
     delete gBackgroundFlushList;
     gBackgroundFlushList = nullptr;
     gBackgroundFlushRunner->Cancel();
     gBackgroundFlushRunner = nullptr;
     return true;
   }
   return true;
 }
 
 void nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync() {
-  if (!mDocument || !mDocument->IsInBackgroundWindow()) {
-    nsCOMPtr<nsIRunnable> flusher = new nsHtml5ExecutorReflusher(this);
-    if (NS_FAILED(
-            mDocument->Dispatch(TaskCategory::Network, flusher.forget()))) {
-      NS_WARNING("failed to dispatch executor flush event");
+  if (mDocument && !mDocument->IsInBackgroundWindow()) {
+    if (mPendingEncodingCommitment) {
+      // Unlike the general executor flusher, the encoding committer
+      // calls ContinueAfterScriptsOrEncodingCommitment() with the
+      // arguments indicating encoding commitment rather than script
+      // once done. Also, in order to get the correct encoding set
+      // on the document object for speculative load purposes, the
+      // encoding committer doesn't check for throttling.
+      if (mStreamParser) {
+        mStreamParser->PostEncodingCommitter();
+      }
+    } else {
+      nsCOMPtr<nsIRunnable> flusher = new nsHtml5ExecutorReflusher(this);
+      if (NS_FAILED(
+              mDocument->Dispatch(TaskCategory::Network, flusher.forget()))) {
+        NS_WARNING("failed to dispatch executor flush event");
+      }
     }
   } else {
     if (!gBackgroundFlushList) {
       gBackgroundFlushList = new LinkedList<nsHtml5TreeOpExecutor>();
     }
     if (!isInList()) {
       gBackgroundFlushList->insertBack(this);
     }
@@ -795,16 +808,50 @@ nsresult nsHtml5TreeOpExecutor::FlushDoc
 #endif
   } else if (scriptElement) {
     // must be tail call when mFlushState is eNotFlushing
     RunScript(scriptElement);
   }
   return rv;
 }
 
+void nsHtml5TreeOpExecutor::RunFlushLoopOrCommitToInternalEncoding() {
+  if (mPendingEncodingCommitment) {
+    CommitToInternalEncoding();
+  } else {
+    RunFlushLoop();
+  }
+}
+
+void nsHtml5TreeOpExecutor::CommitToInternalEncoding() {
+  if (MOZ_UNLIKELY(!mParser || !mStreamParser)) {
+    // An extension terminated the parser from a HTTP observer.
+    ClearOpQueue();  // clear in order to be able to assert in destructor
+    return;
+  }
+  mPendingEncodingCommitment = false;
+  RunFlushLoop();
+  // The above loop relates to plain text and View Source only. As such,
+  // it never runs content scripts. Unfortunately, the loop may be interrupted
+  // by timer and by extension-injected scripts. In that case, we repost the
+  // runnable and return early. :-(
+  if (!mParser->IsParserEnabled()) {
+    mPendingEncodingCommitment = true;
+    return;
+  }
+  if (!mOpQueue.IsEmpty()) {
+    mStreamParser->PostEncodingCommitter();
+    mPendingEncodingCommitment = true;
+    return;
+  }
+  mStreamParser->ContinueAfterScriptsOrEncodingCommitment(nullptr, nullptr,
+                                                          false);
+  RunFlushLoop();
+}
+
 // copied from HTML content sink
 bool nsHtml5TreeOpExecutor::IsScriptEnabled() {
   // Note that if we have no document or no docshell or no global or whatnot we
   // want to claim script _is_ enabled, so we don't parse the contents of
   // <noscript> tags!
   if (!mDocument || !mDocShell) {
     return true;
   }
@@ -921,67 +968,49 @@ void nsHtml5TreeOpExecutor::NeedsCharset
 
   nsDocShell* docShell = static_cast<nsDocShell*>(mDocShell.get());
 
   if (NS_SUCCEEDED(docShell->CharsetChangeStopDocumentLoad())) {
     docShell->CharsetChangeReloadDocument(aEncoding, aSource);
   }
   // if the charset switch was accepted, mDocShell has called Terminate() on the
   // parser by now
-
   if (!mParser) {
-    // success
-    if (aSource == kCharsetFromMetaTag) {
-      MaybeComplainAboutCharset("EncLateMetaReload", false, aLineNumber);
-    }
     return;
   }
 
-  if (aSource == kCharsetFromMetaTag) {
-    MaybeComplainAboutCharset("EncLateMetaTooLate", true, aLineNumber);
-  }
-
   GetParser()->ContinueAfterFailedCharsetSwitch();
 }
 
 void nsHtml5TreeOpExecutor::MaybeComplainAboutCharset(const char* aMsgId,
                                                       bool aError,
                                                       uint32_t aLineNumber) {
-  if (mAlreadyComplainedAboutCharset) {
-    return;
-  }
-  // The EncNoDeclaration case for advertising iframes is so common that it
-  // would result is way too many errors. The iframe case doesn't matter
-  // when the ad is an image or a Flash animation anyway. When the ad is
-  // textual, a misrendered ad probably isn't a huge loss for users.
-  // Let's suppress the message in this case.
-  // This means that errors about other different-origin iframes in mashups
-  // are lost as well, but generally, the site author isn't in control of
-  // the embedded different-origin pages anyway and can't fix problems even
-  // if alerted about them.
-  if (!strcmp(aMsgId, "EncNoDeclaration") && mDocShell) {
-    dom::BrowsingContext* const bc = mDocShell->GetBrowsingContext();
-    if (bc && bc->GetParent()) {
+  // Encoding errors don't count towards already complaining
+  if (!(!strcmp(aMsgId, "EncError") || !strcmp(aMsgId, "EncErrorFrame") ||
+        !strcmp(aMsgId, "EncErrorFramePlain"))) {
+    if (mAlreadyComplainedAboutCharset) {
       return;
     }
+    mAlreadyComplainedAboutCharset = true;
   }
-  mAlreadyComplainedAboutCharset = true;
   nsContentUtils::ReportToConsole(
       aError ? nsIScriptError::errorFlag : nsIScriptError::warningFlag,
       "HTML parser"_ns, mDocument, nsContentUtils::eHTMLPARSER_PROPERTIES,
       aMsgId, nsTArray<nsString>(), nullptr, u""_ns, aLineNumber);
 }
 
-void nsHtml5TreeOpExecutor::ComplainAboutBogusProtocolCharset(Document* aDoc) {
+void nsHtml5TreeOpExecutor::ComplainAboutBogusProtocolCharset(
+    Document* aDoc, bool aUnrecognized) {
   NS_ASSERTION(!mAlreadyComplainedAboutCharset,
                "How come we already managed to complain?");
   mAlreadyComplainedAboutCharset = true;
-  nsContentUtils::ReportToConsole(nsIScriptError::errorFlag, "HTML parser"_ns,
-                                  aDoc, nsContentUtils::eHTMLPARSER_PROPERTIES,
-                                  "EncProtocolUnsupported");
+  nsContentUtils::ReportToConsole(
+      nsIScriptError::errorFlag, "HTML parser"_ns, aDoc,
+      nsContentUtils::eHTMLPARSER_PROPERTIES,
+      aUnrecognized ? "EncProtocolUnsupported" : "EncProtocolReplacement");
 }
 
 void nsHtml5TreeOpExecutor::MaybeComplainAboutDeepTree(uint32_t aLineNumber) {
   if (mAlreadyComplainedAboutDeepTree) {
     return;
   }
   mAlreadyComplainedAboutDeepTree = true;
   nsContentUtils::ReportToConsole(