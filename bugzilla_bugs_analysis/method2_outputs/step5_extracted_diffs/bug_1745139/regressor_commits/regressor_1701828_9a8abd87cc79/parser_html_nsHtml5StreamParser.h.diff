# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: parser/html/nsHtml5StreamParser.h
# Commit: 9a8abd87cc79
# Full Hash: 9a8abd87cc7935f29b94248c1a6f8203faa14403
# Author: Henri Sivonen <hsivonen@hsivonen.fi>
# Date: 2021-12-08 21:43:06
# Regressor Bug: 1701828
# File Overlap Count: 1
# Description:
#   Bug 1701828 - meta charset rewrite. r=smaug
#   
#   Implements https://github.com/whatwg/html/issues/6962 . Improves performance
#   when <meta charset> occurs in head but after the first kilobyte and aligns
#   behavior better with WebKit and Blink.
# ==============================================================================

diff --git a/parser/html/nsHtml5StreamParser.h b/parser/html/nsHtml5StreamParser.h
--- a/parser/html/nsHtml5StreamParser.h
+++ b/parser/html/nsHtml5StreamParser.h
@@ -1,16 +1,18 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsHtml5StreamParser_h
 #define nsHtml5StreamParser_h
 
+#include <tuple>
+
 #include "MainThreadUtils.h"
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/Encoding.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/NotNull.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/Span.h"
@@ -23,17 +25,16 @@
 #include "nsIRequestObserver.h"
 #include "nsISerialEventTarget.h"
 #include "nsISupports.h"
 #include "nsStringFwd.h"
 #include "nsTArray.h"
 #include "nscore.h"
 
 class nsCycleCollectionTraversalCallback;
-class nsHtml5MetaScanner;
 class nsHtml5OwningUTF16Buffer;
 class nsHtml5Parser;
 class nsHtml5Speculation;
 class nsHtml5String;
 class nsHtml5Tokenizer;
 class nsHtml5TreeBuilder;
 class nsHtml5TreeOpExecutor;
 class nsIChannel;
@@ -177,17 +178,17 @@ enum eHtml5StreamState {
   STREAM_ENDED = 2
 };
 
 class nsHtml5StreamParser final : public nsISupports {
   template <typename T>
   using NotNull = mozilla::NotNull<T>;
   using Encoding = mozilla::Encoding;
 
-  const uint32_t SNIFFING_BUFFER_SIZE = 1024;
+  const uint32_t UNCONDITIONAL_META_SCAN_BOUNDARY = 1024;
   const uint32_t READ_BUFFER_SIZE = 1024;
   const uint32_t LOCAL_FILE_UTF_8_BUFFER_SIZE = 1024 * 1024 * 4;  // 4 MB
 
   friend class nsHtml5RequestStopper;
   friend class nsHtml5DataAvailable;
   friend class nsHtml5StreamParserContinuation;
   friend class nsHtml5TimerKungFu;
   friend class nsHtml5StreamParserPtr;
@@ -209,32 +210,44 @@ class nsHtml5StreamParser final : public
 
   // EncodingDeclarationHandler
   // https://hg.mozilla.org/projects/htmlparser/file/tip/src/nu/validator/htmlparser/common/EncodingDeclarationHandler.java
   /**
    * Tree builder uses this to report a late <meta charset>
    */
   bool internalEncodingDeclaration(nsHtml5String aEncoding);
 
+  bool TemplatePushedOrHeadPopped();
+
+  void RememberGt(int32_t aPos);
+
+  void PostEncodingCommitter();
+
   // Not from an external interface
 
   /**
-   * Pass a buffer to the Japanese or Cyrillic detector as appropriate.
+   * Pass a buffer to chardetng.
    */
-  void FeedDetector(mozilla::Span<const uint8_t> aBuffer, bool aLast);
+  void FeedDetector(mozilla::Span<const uint8_t> aBuffer);
+
+  /**
+   * Report EOF to chardetng.
+   */
+  void DetectorEof();
 
   /**
    *  Call this method once you've created a parser, and want to instruct it
    *  about what charset to load
    *
    *  @param   aEncoding the charset of a document
    *  @param   aCharsetSource the source of the charset
    */
   inline void SetDocumentCharset(NotNull<const Encoding*> aEncoding,
-                                 int32_t aSource, bool aForceAutoDetection) {
+                                 nsCharsetSource aSource,
+                                 bool aForceAutoDetection) {
     MOZ_ASSERT(mStreamState == STREAM_NOT_STARTED,
                "SetDocumentCharset called too late.");
     MOZ_ASSERT(NS_IsMainThread(), "Wrong thread!");
     MOZ_ASSERT(!(aForceAutoDetection && aSource >= kCharsetFromOtherComponent),
                "Can't force with high-ranking source.");
     mEncoding = aEncoding;
     mCharsetSource = aSource;
     mForceAutoDetection = aForceAutoDetection;
@@ -242,19 +255,24 @@ class nsHtml5StreamParser final : public
   }
 
   nsresult GetChannel(nsIChannel** aChannel);
 
   /**
    * The owner parser must call this after script execution
    * when no scripts are executing and the document.written
    * buffer has been exhausted.
+   *
+   * If the first two arguments are nullptr, instead of
+   * continuing after scripts, this method commits to an
+   * internally-discovered encoding.
    */
-  void ContinueAfterScripts(nsHtml5Tokenizer* aTokenizer,
-                            nsHtml5TreeBuilder* aTreeBuilder, bool aLastWasCR);
+  void ContinueAfterScriptsOrEncodingCommitment(
+      nsHtml5Tokenizer* aTokenizer, nsHtml5TreeBuilder* aTreeBuilder,
+      bool aLastWasCR);
 
   /**
    * Continues the stream parser if the charset switch failed.
    */
   void ContinueAfterFailedCharsetSwitch();
 
   void Terminate() {
     mozilla::MutexAutoLock autoLock(mTerminatedMutex);
@@ -299,16 +317,24 @@ class nsHtml5StreamParser final : public
   }
 
   /**
    * Flushes the tree ops from the tree builder and disarms the flush
    * timer.
    */
   void FlushTreeOpsAndDisarmTimer();
 
+  void SwitchDecoderIfAsciiSoFar(NotNull<const Encoding*> aEncoding);
+
+  size_t CountGts();
+
+  void DiscardMetaSpeculation();
+
+  bool ProcessLookingForMetaCharset(bool aEof);
+
   void ParseAvailableData();
 
   void DoStopRequest();
 
   void DoDataAvailableBuffer(mozilla::Buffer<uint8_t>&& aBuffer);
 
   void DoDataAvailable(mozilla::Span<const uint8_t> aBuffer);
 
@@ -328,50 +354,48 @@ class nsHtml5StreamParser final : public
   }
 
   /**
    * True when there is a Unicode decoder already
    */
   inline bool HasDecoder() { return !!mUnicodeDecoder; }
 
   /**
+   * Returns 0 if 1) there aren't at least 2 buffers in mBufferedBytes
+   * or 2) there is no byte '>' in the second buffer.
+   * Otherwise, returns the length of the prefix of the second buffer
+   * that is long enough to contain the first byte '>' in the second
+   * buffer (including the '>' byte).
+   */
+  size_t LengthOfLtContainingPrefixInSecondBuffer();
+
+  /**
    * Push bytes from network when there is no Unicode decoder yet
    */
-  nsresult SniffStreamBytes(mozilla::Span<const uint8_t> aFromSegment);
+  nsresult SniffStreamBytes(mozilla::Span<const uint8_t> aFromSegment,
+                            bool aEof);
 
   /**
    * Push bytes from network when there is a Unicode decoder already
    */
   nsresult WriteStreamBytes(mozilla::Span<const uint8_t> aFromSegment);
 
   /**
-   * Write the start of the stream to detector.
-   */
-  void FinalizeSniffingWithDetector(mozilla::Span<const uint8_t> aFromSegment,
-                                    uint32_t aCountToSniffingLimit, bool aEof);
-
-  /**
-   * <meta charset> scan failed. Try chardet if applicable. After this, the
-   * the parser will have some encoding even if a last resolt fallback.
-   *
-   * @param aFromSegment The current network buffer
-   * @param aCountToSniffingLimit The number of unfilled slots in
-   *                              mSniffingBuffer
-   * @param aEof true iff called upon end of stream
-   */
-  nsresult FinalizeSniffing(mozilla::Span<const uint8_t> aFromSegment,
-                            uint32_t aCountToSniffingLimit, bool aEof);
-
-  /**
    * Set up the Unicode decoder and write the sniffing buffer into it
    * followed by the current network buffer.
    *
+   * @param aPrefix the part of the stream that has already been seen
+   *                prior to aFromSegment. In practice, these are the
+   *                bytes that are baked into the state of the BOM
+   *                and UTF-16 XML declaration-like sniffing state
+   *                machine state.
    * @param aFromSegment The current network buffer
    */
   nsresult SetupDecodingAndWriteSniffingBufferAndCurrentSegment(
+      mozilla::Span<const uint8_t> aPrefix,
       mozilla::Span<const uint8_t> aFromSegment);
 
   /**
    * Initialize the Unicode decoder, mark the BOM as the source and
    * drop the sniffer.
    *
    * @param aDecoderCharsetName The name for the decoder's charset
    *                            (UTF-16BE, UTF-16LE or UTF-8; the BOM has
@@ -390,42 +414,31 @@ class nsHtml5StreamParser final : public
 
   /**
    * When speculatively decoding from file: URL as UTF-8, redecode
    * using fallback and then continue normally with the fallback.
    */
   void ReDecodeLocalFile();
 
   /**
-   * Change a final autodetection source to the corresponding initial one.
-   */
-  int32_t MaybeRollBackSource(int32_t aSource);
-
-  /**
    * Potentially guess the encoding using mozilla::EncodingDetector.
+   * Returns the guessed encoding and a telemetry-appropriate source.
    */
-  void GuessEncoding(bool aEof, bool aInitial);
-
-  inline void DontGuessEncoding() {
-    mFeedChardet = false;
-    mGuessEncoding = false;
-    if (mDecodingLocalFileWithoutTokenizing) {
-      CommitLocalFileToEncoding();
-    }
-  }
+  std::tuple<NotNull<const Encoding*>, nsCharsetSource> GuessEncoding(
+      bool aInitial);
 
   /**
    * Become confident or resolve and encoding name to its preferred form.
    * @param aEncoding the value of an internal encoding decl. Acts as an
    *                  out param, too, when the method returns true.
    * @return true if the parser needs to start using the new value of
    *         aEncoding and false if the parser became confident or if
    *         the encoding name did not specify a usable encoding
    */
-  const Encoding* PreferredForInternalEncodingDecl(const nsACString& aEncoding);
+  const Encoding* PreferredForInternalEncodingDecl(const nsAString& aEncoding);
 
   /**
    * Callback for mFlushTimer.
    */
   static void TimerCallback(nsITimer* aTimer, void* aClosure);
 
   /**
    * Parser thread entry point for (maybe) flushing the ops and posting
@@ -470,86 +483,115 @@ class nsHtml5StreamParser final : public
   nsCString mViewSourceTitle;
 
   /**
    * The Unicode decoder
    */
   mozilla::UniquePtr<mozilla::Decoder> mUnicodeDecoder;
 
   /**
-   * The buffer for sniffing the character encoding
-   */
-  mozilla::UniquePtr<uint8_t[]> mSniffingBuffer;
-
-  /**
-   * The number of meaningful bytes in mSniffingBuffer
-   */
-  uint32_t mSniffingLength;
-
-  /**
    * BOM sniffing state
    */
   eBomState mBomState;
 
-  /**
-   * <meta> prescan implementation
-   */
-  mozilla::UniquePtr<nsHtml5MetaScanner> mMetaScanner;
-
   // encoding-related stuff
   /**
    * The source (confidence) of the character encoding in use
    */
-  int32_t mCharsetSource;
+  nsCharsetSource mCharsetSource;
+
+  nsCharsetSource mEncodingSwitchSource;
 
   /**
    * The character encoding in use
    */
   NotNull<const Encoding*> mEncoding;
 
-  /**
-   * Whether the generic or Japanese detector should still be fed.
-   */
-  bool mFeedChardet;
+  const Encoding* mNeedsEncodingSwitchTo;
+
+  bool mSeenEligibleMetaCharset;
+
+  bool mChardetEof;
 
-  /**
-   * Whether the generic detector should be still queried for its guess.
-   */
-  bool mGuessEncoding;
+#ifdef DEBUG
+
+  bool mStartedFeedingDetector;
+
+  bool mStartedFeedingDevTools;
+
+#endif
 
   /**
    * Whether reparse is forbidden
    */
   bool mReparseForbidden;
 
   /**
    * Whether the Repair Text Encoding menu item was invoked
    */
   bool mForceAutoDetection;
 
   /**
    * Whether there was a valid charset parameter on the HTTP layer.
    */
   bool mChannelHadCharset;
 
+  /**
+   * We are in the process of looking for <meta charset>
+   */
+  bool mLookingForMetaCharset;
+
+  /**
+   * Whether the byte stream started with ASCII <?
+   */
+  bool mStartsWithLtQuestion;
+
+  /**
+   * If we are viewing XML source and are waiting for a '>' form the network.
+   */
+  bool mLookingForXmlDeclarationForXmlViewSource;
+
+  /**
+   * Whether template has been pushed or head popped within the first 1024
+   * bytes.
+   */
+  bool mTemplatePushedOrHeadPopped;
+
   // Portable parser objects
   /**
    * The first buffer in the pending UTF-16 buffer queue
    */
   RefPtr<nsHtml5OwningUTF16Buffer> mFirstBuffer;
 
   /**
+   * Non-owning pointer to the most recent buffer that contains the most recent
+   * remembered greater-than sign. Used only while mLookingForMetaCharset is
+   * true. While mLookingForMetaCharset is true, mFirstBuffer is not changed and
+   * keeps the whole linked list of buffers alive. This pointer is non-owning to
+   * avoid frequent refcounting.
+   */
+  nsHtml5OwningUTF16Buffer* mGtBuffer;
+
+  int32_t mGtPos;
+
+  /**
    * The last buffer in the pending UTF-16 buffer queue
    */
   nsHtml5OwningUTF16Buffer*
       mLastBuffer;  // weak ref; always points to
                     // a buffer of the size
                     // NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE
 
   /**
+   * The first buffer of the document if looking for <meta charset> or
+   * nullptr afterwards.
+   */
+  RefPtr<nsHtml5OwningUTF16Buffer> mFirstBufferOfMetaScan;
+
+  /**
    * The tree operation executor
    */
   nsHtml5TreeOpExecutor* mExecutor;
 
   /**
    * Network event target for mExecutor->mDocument
    */
   nsCOMPtr<nsISerialEventTarget> mNetworkEventTarget;
@@ -610,22 +652,21 @@ class nsHtml5StreamParser final : public
   mozilla::Mutex mSpeculationMutex;
 
   /**
    * Number of times speculation has failed for this parser.
    */
   uint32_t mSpeculationFailureCount;
 
   /**
-   * Number of bytes already buffered into mBufferedLocalFileData.
-   * Never counts above LOCAL_FILE_UTF_8_BUFFER_SIZE.
+   * Number of bytes already buffered into mBufferedBytes.
    */
-  uint32_t mLocalFileBytesBuffered;
+  uint32_t mNumBytesBuffered;
 
-  nsTArray<mozilla::Buffer<uint8_t>> mBufferedLocalFileData;
+  nsTArray<mozilla::Buffer<uint8_t>> mBufferedBytes;
 
   /**
    * True to terminate early; protected by mTerminatedMutex
    */
   bool mTerminated;
   bool mInterrupted;
   mozilla::Mutex mTerminatedMutex;
 
@@ -634,16 +675,24 @@ class nsHtml5StreamParser final : public
    */
   nsCOMPtr<nsISerialEventTarget> mEventTarget;
 
   nsCOMPtr<nsIRunnable> mExecutorFlusher;
 
   nsCOMPtr<nsIRunnable> mLoadFlusher;
 
   /**
+   * This runnable is distinct from the regular flushers to
+   * signal the intent of encoding commitment without having to
+   * protect mPendingEncodingCommitment in the executer with a
+   * mutex.
+   */
+  nsCOMPtr<nsIRunnable> mEncodingCommitter;
+
+  /**
    * The generict detector.
    */
   mozilla::UniquePtr<mozilla::EncodingDetector> mDetector;
 
   /**
    * The TLD we're loading from or empty if unknown.
    */
   nsCString mTLD;
@@ -661,16 +710,21 @@ class nsHtml5StreamParser final : public
 
   /**
    * If true, we are decoding a local file that lacks an encoding
    * declaration and we are not tokenizing yet.
    */
   bool mDecodingLocalFileWithoutTokenizing;
 
   /**
+   * Whether we are keeping the incoming bytes.
+   */
+  bool mBufferingBytes;
+
+  /**
    * Timer for flushing tree ops once in a while when not speculating.
    */
   nsCOMPtr<nsITimer> mFlushTimer;
 
   /**
    * Mutex for protecting access to mFlushTimer (but not for the two
    * mFlushTimerFoo booleans below).
    */