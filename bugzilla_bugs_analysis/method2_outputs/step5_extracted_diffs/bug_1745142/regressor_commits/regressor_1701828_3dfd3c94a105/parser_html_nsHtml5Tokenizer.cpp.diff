# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: parser/html/nsHtml5Tokenizer.cpp
# Commit: 3dfd3c94a105
# Full Hash: 3dfd3c94a105e095aada0b356f1106370de222d3
# Author: Henri Sivonen <hsivonen@hsivonen.fi>
# Date: 2021-12-07 15:51:17
# Regressor Bug: 1701828
# File Overlap Count: 10
# Description:
#   Bug 1701828 - meta charset rewrite. r=smaug
#   
#   Implements https://github.com/whatwg/html/issues/6962 . Improves performance
#   when <meta charset> occurs in head but after the first kilobyte and aligns
#   behavior better with WebKit and Blink.
# ==============================================================================

diff --git a/parser/html/nsHtml5Tokenizer.cpp b/parser/html/nsHtml5Tokenizer.cpp
--- a/parser/html/nsHtml5Tokenizer.cpp
+++ b/parser/html/nsHtml5Tokenizer.cpp
@@ -44,17 +44,16 @@
 #include "nsHtml5String.h"
 #include "nsHtml5TokenizerLoopPolicies.h"
 #include "nsIContent.h"
 #include "nsTraceRefcnt.h"
 
 #include "nsHtml5AttributeName.h"
 #include "nsHtml5ElementName.h"
 #include "nsHtml5TreeBuilder.h"
-#include "nsHtml5MetaScanner.h"
 #include "nsHtml5StackNode.h"
 #include "nsHtml5UTF16Buffer.h"
 #include "nsHtml5StateSnapshot.h"
 #include "nsHtml5Portability.h"
 
 #include "nsHtml5Tokenizer.h"
 
 char16_t nsHtml5Tokenizer::LT_GT[] = {'<', '>'};
@@ -114,16 +113,17 @@ nsHtml5Tokenizer::nsHtml5Tokenizer(nsHtm
       entCol(0),
       firstCharKey(0),
       lo(0),
       hi(0),
       candidate(0),
       charRefBufMark(0),
       value(0),
       seenDigits(false),
+      suspendAfterCurrentNonTextToken(false),
       cstart(0),
       strBufLen(0),
       charRefBuf(jArray<char16_t, int32_t>::newJArray(32)),
       charRefBufLen(0),
       bmpChar(jArray<char16_t, int32_t>::newJArray(1)),
       astralChar(jArray<char16_t, int32_t>::newJArray(2)),
       endTagExpectation(nullptr),
       endTagExpectationAsArray(nullptr),
@@ -273,19 +273,21 @@ void nsHtml5Tokenizer::appendStrBuf(char
       MOZ_CRASH("Unable to recover from buffer reallocation failure");
     }
   }
   nsHtml5ArrayCopy::arraycopy(buffer, offset, strBuf, strBufLen, length);
   strBufLen = newLen;
 }
 
 void nsHtml5Tokenizer::emitComment(int32_t provisionalHyphens, int32_t pos) {
+  RememberGt(pos);
   tokenHandler->comment(strBuf, 0, strBufLen - provisionalHyphens);
   clearStrBufAfterUse();
   cstart = pos + 1;
+  suspendIfRequestedAfterCurrentNonTextToken();
 }
 
 void nsHtml5Tokenizer::flushChars(char16_t* buf, int32_t pos) {
   if (pos > cstart) {
     tokenHandler->characters(buf, cstart, pos - cstart);
   }
   cstart = INT32_MAX;
 }
@@ -314,16 +316,17 @@ void nsHtml5Tokenizer::strBufToElementNa
       tagName = nonInternedTagName;
     }
   }
   containsHyphen = false;
   clearStrBufAfterUse();
 }
 
 int32_t nsHtml5Tokenizer::emitCurrentTagToken(bool selfClosing, int32_t pos) {
+  RememberGt(pos);
   cstart = pos + 1;
   maybeErrSlashInEndTag(selfClosing);
   stateSave = nsHtml5Tokenizer::DATA;
   nsHtml5HtmlAttributes* attrs =
       (!attributes ? nsHtml5HtmlAttributes::EMPTY_ATTRIBUTES : attributes);
   if (endTag) {
     maybeErrAttributesOnEndTag(attrs);
     if (!viewingXmlSource) {
@@ -343,16 +346,17 @@ int32_t nsHtml5Tokenizer::emitCurrentTag
     }
   }
   tagName = nullptr;
   if (newAttributesEachTime) {
     attributes = nullptr;
   } else {
     attributes->clear(0);
   }
+  suspendIfRequestedAfterCurrentNonTextToken();
   return stateSave;
 }
 
 void nsHtml5Tokenizer::attributeNameComplete() {
   attributeName =
       nsHtml5AttributeName::nameByBuffer(strBuf, strBufLen, interner);
   if (!attributeName) {
     nonInternedAttributeName->setNameForNonInterned(
@@ -1265,16 +1269,19 @@ stateloop:
             }
             case '>': {
               if (P::reportErrors) {
                 errPrematureEndOfComment();
               }
               emitComment(0, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '<': {
               appendStrBuf(c);
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::COMMENT_LESSTHAN,
                                     reconsume, pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -1402,16 +1409,19 @@ stateloop:
             NS_HTML5_BREAK(stateloop);
           }
           c = checkChar(buf, pos);
           switch (c) {
             case '>': {
               emitComment(2, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '-': {
               adjustDoubleHyphenAndAppendToStrBufAndErr(
                   c, reportedConsecutiveHyphens);
               reportedConsecutiveHyphens = true;
               continue;
             }
@@ -1462,16 +1472,19 @@ stateloop:
             NS_HTML5_BREAK(stateloop);
           }
           c = checkChar(buf, pos);
           switch (c) {
             case '>': {
               emitComment(3, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '-': {
               appendStrBuf(c);
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::COMMENT_END_DASH,
                                     reconsume, pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -1642,16 +1655,19 @@ stateloop:
           }
           c = checkChar(buf, pos);
           switch (c) {
             case '>': {
               appendStrBuf(c);
               emitComment(3, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '-': {
               if (P::reportErrors) {
                 errNestedComment();
               }
               adjustDoubleHyphenAndAppendToStrBufAndErr(
                   c, reportedConsecutiveHyphens);
@@ -1730,16 +1746,19 @@ stateloop:
           }
           case '>': {
             if (P::reportErrors) {
               errPrematureEndOfComment();
             }
             emitComment(1, pos);
             state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                   reconsume, pos);
+            if (shouldSuspend) {
+              NS_HTML5_BREAK(stateloop);
+            }
             NS_HTML5_CONTINUE(stateloop);
           }
           case '<': {
             appendStrBuf(c);
             state = P::transition(mViewSource.get(),
                                   nsHtml5Tokenizer::COMMENT_LESSTHAN, reconsume,
                                   pos);
             NS_HTML5_CONTINUE(stateloop);
@@ -1876,16 +1895,20 @@ stateloop:
             case ']': {
               tokenHandler->characters(nsHtml5Tokenizer::RSQB_RSQB, 0, 1);
               continue;
             }
             case '>': {
               cstart = pos + 1;
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              suspendIfRequestedAfterCurrentNonTextToken();
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               tokenHandler->characters(nsHtml5Tokenizer::RSQB_RSQB, 0, 2);
               cstart = pos;
               reconsume = true;
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::CDATA_SECTION, reconsume,
@@ -2677,16 +2700,19 @@ stateloop:
             }
             c = checkChar(buf, pos);
           }
           switch (c) {
             case '>': {
               emitComment(0, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '-': {
               appendStrBuf(c);
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_COMMENT_HYPHEN,
                                     reconsume, pos);
               NS_HTML5_BREAK(boguscommentloop);
@@ -2719,16 +2745,19 @@ stateloop:
             NS_HTML5_BREAK(stateloop);
           }
           c = checkChar(buf, pos);
           switch (c) {
             case '>': {
               emitComment(0, pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '-': {
               appendSecondHyphenToBogusComment();
               NS_HTML5_CONTINUE(boguscommenthyphenloop);
             }
             case '\r': {
               appendStrBufCarriageReturn();
@@ -3467,16 +3496,19 @@ stateloop:
             case '>': {
               if (P::reportErrors) {
                 errNamelessDoctype();
               }
               forceQuirks = true;
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\0': {
               c = 0xfffd;
               [[fallthrough]];
             }
             default: {
               if (c >= 'A' && c <= 'Z') {
@@ -3522,16 +3554,19 @@ stateloop:
                                     reconsume, pos);
               NS_HTML5_BREAK(doctypenameloop);
             }
             case '>': {
               strBufToDoctypeName();
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\0': {
               c = 0xfffd;
               [[fallthrough]];
             }
             default: {
               if (c >= 'A' && c <= 'Z') {
@@ -3564,16 +3599,19 @@ stateloop:
             case '\t':
             case '\f': {
               continue;
             }
             case '>': {
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case 'p':
             case 'P': {
               index = 0;
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::DOCTYPE_UBLIC, reconsume,
                                     pos);
@@ -3688,16 +3726,19 @@ stateloop:
             case '>': {
               if (P::reportErrors) {
                 errExpectedPublicId();
               }
               forceQuirks = true;
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               bogusDoctype();
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_DOCTYPE, reconsume,
                                     pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -3746,16 +3787,19 @@ stateloop:
             case '>': {
               if (P::reportErrors) {
                 errExpectedPublicId();
               }
               forceQuirks = true;
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               bogusDoctype();
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_DOCTYPE, reconsume,
                                     pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -3784,16 +3828,19 @@ stateloop:
               if (P::reportErrors) {
                 errGtInPublicId();
               }
               forceQuirks = true;
               publicIdentifier = strBufToString();
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\r': {
               appendStrBufCarriageReturn();
               NS_HTML5_BREAK(stateloop);
             }
             case '\n': {
               appendStrBufLineFeed();
@@ -3841,16 +3888,19 @@ stateloop:
                       BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS,
                   reconsume, pos);
               NS_HTML5_BREAK(afterdoctypepublicidentifierloop);
             }
             case '>': {
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\"': {
               if (P::reportErrors) {
                 errNoSpaceBetweenPublicAndSystemIds();
               }
               clearStrBufBeforeUse();
               state = P::transition(
@@ -3901,16 +3951,19 @@ stateloop:
             case '\t':
             case '\f': {
               continue;
             }
             case '>': {
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\"': {
               clearStrBufBeforeUse();
               state = P::transition(
                   mViewSource.get(),
                   nsHtml5Tokenizer::DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED,
                   reconsume, pos);
@@ -3955,16 +4008,19 @@ stateloop:
               if (P::reportErrors) {
                 errGtInSystemId();
               }
               forceQuirks = true;
               systemIdentifier = strBufToString();
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\r': {
               appendStrBufCarriageReturn();
               NS_HTML5_BREAK(stateloop);
             }
             case '\n': {
               appendStrBufLineFeed();
@@ -4000,16 +4056,19 @@ stateloop:
             case '\t':
             case '\f': {
               continue;
             }
             case '>': {
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               bogusDoctypeWithoutQuirks();
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_DOCTYPE, reconsume,
                                     pos);
               NS_HTML5_BREAK(afterdoctypesystemidentifierloop);
@@ -4029,16 +4088,19 @@ stateloop:
             }
             c = checkChar(buf, pos);
           }
           switch (c) {
             case '>': {
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\r': {
               silentCarriageReturn();
               NS_HTML5_BREAK(stateloop);
             }
             case '\n': {
               silentLineFeed();
@@ -4139,16 +4201,19 @@ stateloop:
             case '>': {
               if (P::reportErrors) {
                 errExpectedPublicId();
               }
               forceQuirks = true;
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               bogusDoctype();
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_DOCTYPE, reconsume,
                                     pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -4197,16 +4262,19 @@ stateloop:
             case '>': {
               if (P::reportErrors) {
                 errExpectedSystemId();
               }
               forceQuirks = true;
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             default: {
               bogusDoctype();
               state = P::transition(mViewSource.get(),
                                     nsHtml5Tokenizer::BOGUS_DOCTYPE, reconsume,
                                     pos);
               NS_HTML5_CONTINUE(stateloop);
@@ -4235,16 +4303,19 @@ stateloop:
               if (P::reportErrors) {
                 errGtInSystemId();
               }
               forceQuirks = true;
               systemIdentifier = strBufToString();
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\r': {
               appendStrBufCarriageReturn();
               NS_HTML5_BREAK(stateloop);
             }
             case '\n': {
               appendStrBufLineFeed();
@@ -4280,16 +4351,19 @@ stateloop:
               if (P::reportErrors) {
                 errGtInPublicId();
               }
               forceQuirks = true;
               publicIdentifier = strBufToString();
               emitDoctypeToken(pos);
               state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                     reconsume, pos);
+              if (shouldSuspend) {
+                NS_HTML5_BREAK(stateloop);
+              }
               NS_HTML5_CONTINUE(stateloop);
             }
             case '\r': {
               appendStrBufCarriageReturn();
               NS_HTML5_BREAK(stateloop);
             }
             case '\n': {
               appendStrBufLineFeed();
@@ -4332,16 +4406,20 @@ stateloop:
         if (++pos == endPos) {
           NS_HTML5_BREAK(stateloop);
         }
         c = checkChar(buf, pos);
         switch (c) {
           case '>': {
             state = P::transition(mViewSource.get(), nsHtml5Tokenizer::DATA,
                                   reconsume, pos);
+            suspendIfRequestedAfterCurrentNonTextToken();
+            if (shouldSuspend) {
+              NS_HTML5_BREAK(stateloop);
+            }
             NS_HTML5_CONTINUE(stateloop);
           }
           default: {
             state = P::transition(mViewSource.get(),
                                   nsHtml5Tokenizer::PROCESSING_INSTRUCTION,
                                   reconsume, pos);
             NS_HTML5_CONTINUE(stateloop);
           }
@@ -4749,24 +4827,135 @@ eofloop:
     }
   }
 eofloop_end:;
   tokenHandler->eof();
   return;
 }
 
 void nsHtml5Tokenizer::emitDoctypeToken(int32_t pos) {
+  RememberGt(pos);
   cstart = pos + 1;
   tokenHandler->doctype(doctypeName, publicIdentifier, systemIdentifier,
                         forceQuirks);
   doctypeName = nullptr;
   publicIdentifier.Release();
   publicIdentifier = nullptr;
   systemIdentifier.Release();
   systemIdentifier = nullptr;
+  suspendIfRequestedAfterCurrentNonTextToken();
+}
+
+void nsHtml5Tokenizer::suspendIfRequestedAfterCurrentNonTextToken() {
+  if (suspendAfterCurrentNonTextToken) {
+    suspendAfterCurrentNonTextToken = false;
+    shouldSuspend = true;
+  }
+}
+
+void nsHtml5Tokenizer::suspendAfterCurrentTokenIfNotInText() {
+  switch (stateSave) {
+    case DATA:
+    case RCDATA:
+    case SCRIPT_DATA:
+    case RAWTEXT:
+    case SCRIPT_DATA_ESCAPED:
+    case PLAINTEXT:
+    case NON_DATA_END_TAG_NAME:
+    case SCRIPT_DATA_LESS_THAN_SIGN:
+    case SCRIPT_DATA_ESCAPE_START:
+    case SCRIPT_DATA_ESCAPE_START_DASH:
+    case SCRIPT_DATA_ESCAPED_DASH:
+    case SCRIPT_DATA_ESCAPED_DASH_DASH:
+    case RAWTEXT_RCDATA_LESS_THAN_SIGN:
+    case SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
+    case SCRIPT_DATA_DOUBLE_ESCAPE_START:
+    case SCRIPT_DATA_DOUBLE_ESCAPED:
+    case SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
+    case SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
+    case SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
+    case SCRIPT_DATA_DOUBLE_ESCAPE_END: {
+      return;
+    }
+    case TAG_NAME:
+    case BEFORE_ATTRIBUTE_NAME:
+    case ATTRIBUTE_NAME:
+    case AFTER_ATTRIBUTE_NAME:
+    case BEFORE_ATTRIBUTE_VALUE:
+    case AFTER_ATTRIBUTE_VALUE_QUOTED:
+    case BOGUS_COMMENT:
+    case MARKUP_DECLARATION_OPEN:
+    case DOCTYPE:
+    case BEFORE_DOCTYPE_NAME:
+    case DOCTYPE_NAME:
+    case AFTER_DOCTYPE_NAME:
+    case BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
+    case DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
+    case DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
+    case AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
+    case BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
+    case DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
+    case DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
+    case AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
+    case BOGUS_DOCTYPE:
+    case COMMENT_START:
+    case COMMENT_START_DASH:
+    case COMMENT:
+    case COMMENT_END_DASH:
+    case COMMENT_END:
+    case COMMENT_END_BANG:
+    case TAG_OPEN:
+    case CLOSE_TAG_OPEN:
+    case MARKUP_DECLARATION_HYPHEN:
+    case MARKUP_DECLARATION_OCTYPE:
+    case DOCTYPE_UBLIC:
+    case DOCTYPE_YSTEM:
+    case AFTER_DOCTYPE_PUBLIC_KEYWORD:
+    case BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
+    case AFTER_DOCTYPE_SYSTEM_KEYWORD:
+    case SELF_CLOSING_START_TAG:
+    case ATTRIBUTE_VALUE_DOUBLE_QUOTED:
+    case ATTRIBUTE_VALUE_SINGLE_QUOTED:
+    case ATTRIBUTE_VALUE_UNQUOTED:
+    case BOGUS_COMMENT_HYPHEN:
+    case COMMENT_LESSTHAN:
+    case COMMENT_LESSTHAN_BANG:
+    case COMMENT_LESSTHAN_BANG_DASH:
+    case COMMENT_LESSTHAN_BANG_DASH_DASH:
+    case CDATA_START:
+    case CDATA_SECTION:
+    case CDATA_RSQB:
+    case CDATA_RSQB_RSQB:
+    case PROCESSING_INSTRUCTION:
+    case PROCESSING_INSTRUCTION_QUESTION_MARK: {
+      break;
+    }
+    case CONSUME_CHARACTER_REFERENCE:
+    case CONSUME_NCR:
+    case CHARACTER_REFERENCE_TAIL:
+    case HEX_NCR_LOOP:
+    case DECIMAL_NRC_LOOP:
+    case HANDLE_NCR_VALUE:
+    case HANDLE_NCR_VALUE_RECONSUME:
+    case CHARACTER_REFERENCE_HILO_LOOKUP: {
+      if (returnStateSave == DATA || returnStateSave == RCDATA) {
+        return;
+      }
+      break;
+    }
+    default: {
+      MOZ_ASSERT(false, "Incomplete switch");
+      return;
+    }
+  }
+  suspendAfterCurrentNonTextToken = true;
+}
+
+bool nsHtml5Tokenizer::suspensionAfterCurrentNonTextTokenPending() {
+  return suspendAfterCurrentNonTextToken;
 }
 
 bool nsHtml5Tokenizer::internalEncodingDeclaration(
     nsHtml5String internalCharset) {
   if (encodingDeclarationHandler) {
     return encodingDeclarationHandler->internalEncodingDeclaration(
         internalCharset);
   }
@@ -4828,16 +5017,17 @@ void nsHtml5Tokenizer::resetToDataState(
   entCol = -1;
   firstCharKey = -1;
   lo = 0;
   hi = 0;
   candidate = -1;
   charRefBufMark = 0;
   value = 0;
   seenDigits = false;
+  suspendAfterCurrentNonTextToken = false;
   endTag = false;
   shouldSuspend = false;
   initDoctypeFields();
   containsHyphen = false;
   tagName = nullptr;
   attributeName = nullptr;
   if (newAttributesEachTime) {
     if (attributes) {
@@ -4868,16 +5058,17 @@ void nsHtml5Tokenizer::loadState(nsHtml5
   lo = other->lo;
   hi = other->hi;
   candidate = other->candidate;
   charRefBufMark = other->charRefBufMark;
   value = other->value;
   seenDigits = other->seenDigits;
   endTag = other->endTag;
   shouldSuspend = false;
+  suspendAfterCurrentNonTextToken = false;
   doctypeName = other->doctypeName;
   systemIdentifier.Release();
   if (!other->systemIdentifier) {
     systemIdentifier = nullptr;
   } else {
     systemIdentifier =
         nsHtml5Portability::newStringFromString(other->systemIdentifier);
   }