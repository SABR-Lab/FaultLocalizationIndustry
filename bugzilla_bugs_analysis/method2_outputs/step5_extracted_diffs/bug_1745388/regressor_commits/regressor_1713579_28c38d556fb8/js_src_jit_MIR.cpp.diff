# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MIR.cpp
# Commit: 28c38d556fb8
# Full Hash: 28c38d556fb86f1a936d9f6a8627705230df895a
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2021-12-09 09:32:28
# Regressor Bug: 1713579
# File Overlap Count: 1
# Description:
#   Bug 1713579: Extract shape-guard folding into separate optimization r=jandem
#   
#   This patch takes the code from `MGuardShape::foldsTo` and splits it out into its own optimization. Besides jitspew, the main change is adding support for MNewPlainObject (which didn't exist when this code was first written.)
#   
#   We use `dependency()` to find the most recent store. It is possible for a node's dependency to be in a dead block. In `ValueNumberer::visitDefinition`, we check for this case; I used the same approach here.
# ==============================================================================

diff -r a09f76aa6703 -r 28c38d556fb8 js/src/jit/MIR.cpp
--- a/js/src/jit/MIR.cpp	Wed Dec 08 21:19:47 2021 +0000
+++ b/js/src/jit/MIR.cpp	Wed Dec 08 21:19:49 2021 +0000
@@ -5707,95 +5707,6 @@
   return AliasSet::Load(AliasSet::ObjectFields);
 }
 
-static MDefinition* SkipObjectGuards(MDefinition* ins) {
-  // These instructions don't modify the object and just guard specific
-  // properties.
-  while (true) {
-    if (ins->isGuardShape()) {
-      ins = ins->toGuardShape()->object();
-      continue;
-    }
-    if (ins->isGuardNullProto()) {
-      ins = ins->toGuardNullProto()->object();
-      continue;
-    }
-    if (ins->isGuardProto()) {
-      ins = ins->toGuardProto()->object();
-      continue;
-    }
-
-    break;
-  }
-
-  return ins;
-}
-
-MDefinition* MGuardShape::foldsTo(TempAllocator& alloc) {
-  MDefinition* ins = dependency();
-  if (!ins) {
-    return this;
-  }
-
-  if (!ins->block()->dominates(block())) {
-    return this;
-  }
-
-  auto AssertShape = [](TempAllocator& alloc, MGuardShape* ins) {
-#ifdef DEBUG
-    auto* assert = MAssertShape::New(alloc, ins->object(),
-                                     const_cast<Shape*>(ins->shape()));
-    ins->block()->insertBefore(ins, assert);
-#endif
-  };
-
-  if (ins->isAddAndStoreSlot()) {
-    auto* add = ins->toAddAndStoreSlot();
-
-    if (SkipObjectGuards(add->object()) != SkipObjectGuards(object()) ||
-        add->shape() != shape()) {
-      return this;
-    }
-
-    AssertShape(alloc, this);
-    return object();
-  }
-
-  if (ins->isAllocateAndStoreSlot()) {
-    auto* allocate = ins->toAllocateAndStoreSlot();
-
-    if (SkipObjectGuards(allocate->object()) != SkipObjectGuards(object()) ||
-        allocate->shape() != shape()) {
-      return this;
-    }
-
-    AssertShape(alloc, this);
-    return object();
-  }
-
-  if (ins->isStart()) {
-    // The guard doesn't depend on any other instruction that is modifying
-    // the object operand, so check it directly.
-    auto* obj = SkipObjectGuards(object());
-    if (!obj->isNewObject()) {
-      return this;
-    }
-
-    JSObject* templateObject = obj->toNewObject()->templateObject();
-    if (!templateObject) {
-      return this;
-    }
-
-    if (templateObject->shape() != shape()) {
-      return this;
-    }
-
-    AssertShape(alloc, this);
-    return object();
-  }
-
-  return this;
-}
-
 MDefinition* MGuardValue::foldsTo(TempAllocator& alloc) {
   if (MConstant* cst = value()->maybeConstantValue()) {
     if (cst->toJSValue() == expected()) {