# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/gl/GLBlitHelper.cpp
# Commit: 3d201ea88341
# Full Hash: 3d201ea8834161911890a06bae578b64d18eefa9
# Author: Kelsey Gilbert <jgilbert@mozilla.com>
# Date: 2021-12-15 09:11:58
# Regressor Bug: 1746111
# File Overlap Count: 1
# Description:
#   Bug 1746111 - (Re)serialize WebRTC frame SurfaceDescriptorBuffers for convert-and-upload on WebGLParent. r=gfx-reviewers,nika,lsalzman
#   
#   Also generally de-inline (WebGLParent::TexImage not DispatchCommand)
#   TexImage(SurfaceDescriptor).
#   
# ==============================================================================

diff -r a87211c8eedd -r 3d201ea88341 gfx/gl/GLBlitHelper.cpp
--- a/gfx/gl/GLBlitHelper.cpp	Wed Dec 15 01:49:11 2021 +0000
+++ b/gfx/gl/GLBlitHelper.cpp	Wed Dec 15 01:54:21 2021 +0000
@@ -697,6 +697,16 @@
                                        const OriginPos destOrigin) {
   const auto sdType = asd.type();
   switch (sdType) {
+    case layers::SurfaceDescriptor::TSurfaceDescriptorBuffer: {
+      const auto& sd = asd.get_SurfaceDescriptorBuffer();
+      const auto yuvData = PlanarYCbCrData::From(sd);
+      if (!yuvData) {
+        gfxCriticalNote << "[GLBlitHelper::BlitSdToFramebuffer] "
+                           "PlanarYCbCrData::From failed";
+        return false;
+      }
+      return BlitPlanarYCbCr(*yuvData, destSize, destOrigin);
+    }
 #ifdef XP_WIN
     case layers::SurfaceDescriptor::TSurfaceDescriptorD3D10: {
       const auto& sd = asd.get_SurfaceDescriptorD3D10();
@@ -729,9 +739,11 @@
                                           const gfx::IntSize& destSize,
                                           const OriginPos destOrigin) {
   switch (srcImage->GetFormat()) {
-    case ImageFormat::PLANAR_YCBCR:
-      return BlitImage(static_cast<PlanarYCbCrImage*>(srcImage), destSize,
-                       destOrigin);
+    case ImageFormat::PLANAR_YCBCR: {
+      const auto srcImage2 = static_cast<PlanarYCbCrImage*>(srcImage);
+      const auto data = srcImage2->GetData();
+      return BlitPlanarYCbCr(*data, destSize, destOrigin);
+    }
 
     case ImageFormat::SURFACE_TEXTURE:
 #ifdef MOZ_WIDGET_ANDROID
@@ -873,9 +885,9 @@
   return true;
 }
 
-bool GLBlitHelper::BlitImage(layers::PlanarYCbCrImage* const yuvImage,
-                             const gfx::IntSize& destSize,
-                             const OriginPos destOrigin) {
+bool GLBlitHelper::BlitPlanarYCbCr(const PlanarYCbCrData& yuvData,
+                                   const gfx::IntSize& destSize,
+                                   const OriginPos destOrigin) {
   const auto& prog = GetDrawBlitProg({kFragHeader_Tex2D, kFragBody_PlanarYUV});
 
   if (!mYuvUploads[0]) {
@@ -890,27 +902,25 @@
 
   // --
 
-  const PlanarYCbCrData* const yuvData = yuvImage->GetData();
-
-  if (yuvData->mYSkip || yuvData->mCbSkip || yuvData->mCrSkip ||
-      yuvData->mYSize.width < 0 || yuvData->mYSize.height < 0 ||
-      yuvData->mCbCrSize.width < 0 || yuvData->mCbCrSize.height < 0 ||
-      yuvData->mYStride < 0 || yuvData->mCbCrStride < 0) {
-    gfxCriticalError() << "Unusual PlanarYCbCrData: " << yuvData->mYSkip << ","
-                       << yuvData->mCbSkip << "," << yuvData->mCrSkip << ", "
-                       << yuvData->mYSize.width << "," << yuvData->mYSize.height
-                       << ", " << yuvData->mCbCrSize.width << ","
-                       << yuvData->mCbCrSize.height << ", " << yuvData->mYStride
-                       << "," << yuvData->mCbCrStride;
+  if (yuvData.mYSkip || yuvData.mCbSkip || yuvData.mCrSkip ||
+      yuvData.mYSize.width < 0 || yuvData.mYSize.height < 0 ||
+      yuvData.mCbCrSize.width < 0 || yuvData.mCbCrSize.height < 0 ||
+      yuvData.mYStride < 0 || yuvData.mCbCrStride < 0) {
+    gfxCriticalError() << "Unusual PlanarYCbCrData: " << yuvData.mYSkip << ","
+                       << yuvData.mCbSkip << "," << yuvData.mCrSkip << ", "
+                       << yuvData.mYSize.width << "," << yuvData.mYSize.height
+                       << ", " << yuvData.mCbCrSize.width << ","
+                       << yuvData.mCbCrSize.height << ", " << yuvData.mYStride
+                       << "," << yuvData.mCbCrStride;
     return false;
   }
 
   gfx::IntSize divisors;
-  if (!GuessDivisors(yuvData->mYSize, yuvData->mCbCrSize, &divisors)) {
-    gfxCriticalError() << "GuessDivisors failed:" << yuvData->mYSize.width
-                       << "," << yuvData->mYSize.height << ", "
-                       << yuvData->mCbCrSize.width << ","
-                       << yuvData->mCbCrSize.height;
+  if (!GuessDivisors(yuvData.mYSize, yuvData.mCbCrSize, &divisors)) {
+    gfxCriticalError() << "GuessDivisors failed:" << yuvData.mYSize.width << ","
+                       << yuvData.mYSize.height << ", "
+                       << yuvData.mCbCrSize.width << ","
+                       << yuvData.mCbCrSize.height;
     return false;
   }
 
@@ -934,8 +944,8 @@
 
   const ScopedSaveMultiTex saveTex(mGL, 3, LOCAL_GL_TEXTURE_2D);
   const ResetUnpackState reset(mGL);
-  const gfx::IntSize yTexSize(yuvData->mYStride, yuvData->mYSize.height);
-  const gfx::IntSize uvTexSize(yuvData->mCbCrStride, yuvData->mCbCrSize.height);
+  const gfx::IntSize yTexSize(yuvData.mYStride, yuvData.mYSize.height);
+  const gfx::IntSize uvTexSize(yuvData.mCbCrStride, yuvData.mCbCrSize.height);
 
   if (yTexSize != mYuvUploads_YSize || uvTexSize != mYuvUploads_UVSize) {
     mYuvUploads_YSize = yTexSize;
@@ -961,28 +971,28 @@
   mGL->fBindTexture(LOCAL_GL_TEXTURE_2D, mYuvUploads[0]);
   mGL->fTexSubImage2D(LOCAL_GL_TEXTURE_2D, 0, 0, 0, yTexSize.width,
                       yTexSize.height, unpackFormat, LOCAL_GL_UNSIGNED_BYTE,
-                      yuvData->mYChannel);
+                      yuvData.mYChannel);
   mGL->fActiveTexture(LOCAL_GL_TEXTURE1);
   mGL->fBindTexture(LOCAL_GL_TEXTURE_2D, mYuvUploads[1]);
   mGL->fTexSubImage2D(LOCAL_GL_TEXTURE_2D, 0, 0, 0, uvTexSize.width,
                       uvTexSize.height, unpackFormat, LOCAL_GL_UNSIGNED_BYTE,
-                      yuvData->mCbChannel);
+                      yuvData.mCbChannel);
   mGL->fActiveTexture(LOCAL_GL_TEXTURE2);
   mGL->fBindTexture(LOCAL_GL_TEXTURE_2D, mYuvUploads[2]);
   mGL->fTexSubImage2D(LOCAL_GL_TEXTURE_2D, 0, 0, 0, uvTexSize.width,
                       uvTexSize.height, unpackFormat, LOCAL_GL_UNSIGNED_BYTE,
-                      yuvData->mCrChannel);
+                      yuvData.mCrChannel);
 
   // --
 
-  const auto& clipRect = yuvData->GetPictureRect();
+  const auto& clipRect = yuvData.GetPictureRect();
   const auto srcOrigin = OriginPos::BottomLeft;
   const bool yFlip = (destOrigin != srcOrigin);
 
   const DrawBlitProg::BaseArgs baseArgs = {SubRectMat3(clipRect, yTexSize),
                                            yFlip, destSize, Nothing()};
   const DrawBlitProg::YUVArgs yuvArgs = {
-      SubRectMat3(clipRect, uvTexSize, divisors), yuvData->mYUVColorSpace};
+      SubRectMat3(clipRect, uvTexSize, divisors), yuvData.mYUVColorSpace};
   prog->Draw(baseArgs, &yuvArgs);
   return true;
 }