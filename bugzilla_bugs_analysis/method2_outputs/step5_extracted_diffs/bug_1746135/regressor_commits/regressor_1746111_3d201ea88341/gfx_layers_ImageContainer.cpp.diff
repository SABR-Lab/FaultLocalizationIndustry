# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ImageContainer.cpp
# Commit: 3d201ea88341
# Full Hash: 3d201ea8834161911890a06bae578b64d18eefa9
# Author: Kelsey Gilbert <jgilbert@mozilla.com>
# Date: 2021-12-15 09:11:58
# Regressor Bug: 1746111
# File Overlap Count: 1
# Description:
#   Bug 1746111 - (Re)serialize WebRTC frame SurfaceDescriptorBuffers for convert-and-upload on WebGLParent. r=gfx-reviewers,nika,lsalzman
#   
#   Also generally de-inline (WebGLParent::TexImage not DispatchCommand)
#   TexImage(SurfaceDescriptor).
#   
# ==============================================================================

diff -r a87211c8eedd -r 3d201ea88341 gfx/layers/ImageContainer.cpp
--- a/gfx/layers/ImageContainer.cpp	Wed Dec 15 01:49:11 2021 +0000
+++ b/gfx/layers/ImageContainer.cpp	Wed Dec 15 01:54:21 2021 +0000
@@ -214,12 +214,12 @@
   }
 }
 
-Maybe<SurfaceDescriptor> Image::GetDesc() { return {}; }
+Maybe<SurfaceDescriptor> Image::GetDesc() { return GetDescFromTexClient(); }
 
 Maybe<SurfaceDescriptor> Image::GetDescFromTexClient(
-    TextureClient* const forTc) {
-  RefPtr<TextureClient> tc = forTc;
-  if (!forTc) {
+    TextureClient* const tcOverride) {
+  RefPtr<TextureClient> tc = tcOverride;
+  if (!tcOverride) {
     tc = GetTextureClient(nullptr);
   }
 
@@ -479,6 +479,86 @@
 }
 #endif
 
+// -
+// https://searchfox.org/mozilla-central/source/dom/media/ipc/RemoteImageHolder.cpp#46
+
+Maybe<PlanarYCbCrData> PlanarYCbCrData::From(
+    const SurfaceDescriptorBuffer& sdb) {
+  if (sdb.desc().type() != BufferDescriptor::TYCbCrDescriptor) {
+    return {};
+  }
+  const YCbCrDescriptor& yuvDesc = sdb.desc().get_YCbCrDescriptor();
+
+  Maybe<Range<uint8_t>> buffer;
+  const MemoryOrShmem& memOrShmem = sdb.data();
+  switch (memOrShmem.type()) {
+    case MemoryOrShmem::Tuintptr_t:
+      gfxCriticalError() << "PlanarYCbCrData::From SurfaceDescriptorBuffer w/uintptr_t unsupported.";
+      break;
+    case MemoryOrShmem::TShmem:
+      buffer.emplace(memOrShmem.get_Shmem().Range<uint8_t>());
+      break;
+    default:
+      MOZ_ASSERT(false, "Unknown MemoryOrShmem type");
+      break;
+  }
+  if (!buffer) {
+    return {};
+  }
+
+  PlanarYCbCrData yuvData;
+  yuvData.mYSize = yuvDesc.ySize();
+  yuvData.mYStride = AssertedCast<int32_t>(yuvDesc.yStride());
+  yuvData.mCbCrSize = yuvDesc.cbCrSize();
+  yuvData.mCbCrStride = AssertedCast<int32_t>(yuvDesc.cbCrStride());
+  // default mYSkip, mCbSkip, mCrSkip because not held in YCbCrDescriptor
+  yuvData.mYSkip = yuvData.mCbSkip = yuvData.mCrSkip = 0;
+  gfx::IntRect display = yuvDesc.display();
+  yuvData.mPicX = display.X();
+  yuvData.mPicY = display.Y();
+  yuvData.mPicSize = display.Size();
+  yuvData.mStereoMode = yuvDesc.stereoMode();
+  yuvData.mColorDepth = yuvDesc.colorDepth();
+  yuvData.mYUVColorSpace = yuvDesc.yUVColorSpace();
+  yuvData.mColorRange = yuvDesc.colorRange();
+
+  const auto GetPlanePtr = [&](const uint32_t beginOffset,
+        const gfx::IntSize size, const int32_t stride) -> uint8_t* {
+    if (size.width > stride) return nullptr;
+    auto bytesNeeded = CheckedInt<uintptr_t>(stride) * size.height; // Don't accept `stride*(h-1)+w`.
+    bytesNeeded += beginOffset;
+    if (!bytesNeeded.isValid() || bytesNeeded.value() > buffer->length()) {
+      gfxCriticalError() << "PlanarYCbCrData::From asked for out-of-bounds plane data.";
+      return nullptr;
+    }
+    return (buffer->begin() + beginOffset).get();
+  };
+  yuvData.mYChannel = GetPlanePtr(yuvDesc.yOffset(), yuvData.mYSize, yuvData.mYStride);
+  yuvData.mCbChannel = GetPlanePtr(yuvDesc.cbOffset(), yuvData.mCbCrSize, yuvData.mCbCrStride);
+  yuvData.mCrChannel = GetPlanePtr(yuvDesc.crOffset(), yuvData.mCbCrSize, yuvData.mCbCrStride);
+
+  if (yuvData.mYSkip || yuvData.mCbSkip || yuvData.mCrSkip ||
+      yuvData.mYSize.width < 0 || yuvData.mYSize.height < 0 ||
+      yuvData.mCbCrSize.width < 0 || yuvData.mCbCrSize.height < 0 ||
+      yuvData.mYStride < 0 || yuvData.mCbCrStride < 0 ||
+      !yuvData.mYChannel || !yuvData.mCbChannel || !yuvData.mCrChannel) {
+    gfxCriticalError() << "Unusual PlanarYCbCrData: " << yuvData.mYSkip << ","
+                       << yuvData.mCbSkip << "," << yuvData.mCrSkip << ", "
+                       << yuvData.mYSize.width << "," << yuvData.mYSize.height
+                       << ", " << yuvData.mCbCrSize.width << ","
+                       << yuvData.mCbCrSize.height << ", " << yuvData.mYStride
+                       << "," << yuvData.mCbCrStride
+                       << ", " << yuvData.mYChannel
+                       << "," << yuvData.mCbChannel
+                       << "," << yuvData.mCrChannel;
+    return {};
+  }
+
+  return Some(yuvData);
+}
+
+// -
+
 PlanarYCbCrImage::PlanarYCbCrImage()
     : Image(nullptr, ImageFormat::PLANAR_YCBCR),
       mOffscreenFormat(SurfaceFormat::UNKNOWN),