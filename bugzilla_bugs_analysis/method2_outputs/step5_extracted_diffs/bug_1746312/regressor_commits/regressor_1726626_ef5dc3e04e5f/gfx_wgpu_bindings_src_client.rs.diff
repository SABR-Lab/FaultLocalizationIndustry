# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu_bindings/src/client.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu_bindings/src/client.rs b/gfx/wgpu_bindings/src/client.rs
--- a/gfx/wgpu_bindings/src/client.rs
+++ b/gfx/wgpu_bindings/src/client.rs
@@ -1,15 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 use crate::{
     cow_label, AdapterInformation, ByteBuf, CommandEncoderAction, DeviceAction, DropAction,
-    ImplicitLayout, QueueWriteAction, RawString, ShaderModuleSource, TextureAction,
+    ImplicitLayout, QueueWriteAction, RawString, TextureAction,
 };
 
 use wgc::{hub::IdentityManager, id};
 use wgt::Backend;
 
 pub use wgc::command::{compute_ffi::*, render_ffi::*};
 
 use parking_lot::Mutex;
@@ -63,17 +63,17 @@ pub struct ComputePipelineDescriptor {
     label: RawString,
     layout: Option<id::PipelineLayoutId>,
     stage: ProgrammableStageDescriptor,
 }
 
 #[repr(C)]
 pub struct VertexBufferLayout {
     array_stride: wgt::BufferAddress,
-    step_mode: wgt::InputStepMode,
+    step_mode: wgt::VertexStepMode,
     attributes: *const wgt::VertexAttribute,
     attributes_length: usize,
 }
 
 #[repr(C)]
 pub struct VertexState {
     stage: ProgrammableStageDescriptor,
     buffers: *const VertexBufferLayout,
@@ -96,17 +96,17 @@ impl VertexState {
         }
     }
 }
 
 #[repr(C)]
 pub struct ColorTargetState<'a> {
     format: wgt::TextureFormat,
     blend: Option<&'a wgt::BlendState>,
-    write_mask: wgt::ColorWrite,
+    write_mask: wgt::ColorWrites,
 }
 
 #[repr(C)]
 pub struct FragmentState<'a> {
     stage: ProgrammableStageDescriptor,
     targets: *const ColorTargetState<'a>,
     targets_length: usize,
 }
@@ -181,17 +181,17 @@ pub enum RawBindingType {
     SampledTexture,
     ReadonlyStorageTexture,
     WriteonlyStorageTexture,
 }
 
 #[repr(C)]
 pub struct BindGroupLayoutEntry<'a> {
     binding: u32,
-    visibility: wgt::ShaderStage,
+    visibility: wgt::ShaderStages,
     ty: RawBindingType,
     has_dynamic_offset: bool,
     min_binding_size: Option<wgt::BufferSize>,
     view_dimension: Option<&'a wgt::TextureViewDimension>,
     texture_sample_type: Option<&'a RawTextureSampleType>,
     multisampled: bool,
     storage_texture_format: Option<&'a wgt::TextureFormat>,
     sampler_filter: bool,
@@ -283,17 +283,17 @@ struct IdentityHub {
     samplers: IdentityManager,
 }
 
 impl ImplicitLayout<'_> {
     fn new(identities: &mut IdentityHub, backend: Backend) -> Self {
         ImplicitLayout {
             pipeline: identities.pipeline_layouts.alloc(backend),
             bind_groups: Cow::Owned(
-                (0..wgc::MAX_BIND_GROUPS)
+                (0..8) // hal::MAX_BIND_GROUPS
                     .map(|_| identities.bind_group_layouts.alloc(backend))
                     .collect(),
             ),
         }
     }
 }
 
 #[derive(Debug, Default)]
@@ -617,17 +617,23 @@ pub extern "C" fn wgpu_client_create_com
 #[no_mangle]
 pub extern "C" fn wgpu_device_create_render_bundle_encoder(
     device_id: id::DeviceId,
     desc: &RenderBundleEncoderDescriptor,
 ) -> *mut wgc::command::RenderBundleEncoder {
     let descriptor = wgc::command::RenderBundleEncoderDescriptor {
         label: cow_label(&desc.label),
         color_formats: Cow::Borrowed(make_slice(desc.color_formats, desc.color_formats_length)),
-        depth_stencil_format: desc.depth_stencil_format.cloned(),
+        depth_stencil: desc
+            .depth_stencil_format
+            .map(|&format| wgt::RenderBundleDepthStencil {
+                format,
+                depth_read_only: false, //TODO: add to `RenderBundleEncoderDescriptor`
+                stencil_read_only: false,
+            }),
         sample_count: desc.sample_count,
     };
     match wgc::command::RenderBundleEncoder::new(&descriptor, device_id, None) {
         Ok(encoder) => Box::into_raw(Box::new(encoder)),
         Err(e) => panic!("Error in Device::create_render_bundle_encoder: {}", e),
     }
 }
 
@@ -902,29 +908,22 @@ pub unsafe extern "C" fn wgpu_client_cre
     let backend = device_id.backend();
     let id = client
         .identities
         .lock()
         .select(backend)
         .shader_modules
         .alloc(backend);
 
-    let source = match cow_label(&desc.wgsl_chars) {
-        Some(code) => ShaderModuleSource::Wgsl(code),
-        None => ShaderModuleSource::SpirV(Cow::Borrowed(make_slice(
-            desc.spirv_words,
-            desc.spirv_words_length,
-        ))),
-    };
+    let code = cow_label(&desc.wgsl_chars).unwrap_or_default();
     let desc = wgc::pipeline::ShaderModuleDescriptor {
         label: cow_label(&desc.label),
-        flags: wgt::ShaderFlags::VALIDATION, // careful here!
     };
 
-    let action = DeviceAction::CreateShaderModule(id, desc, source);
+    let action = DeviceAction::CreateShaderModule(id, desc, code);
     *bb = make_byte_buf(&action);
     id
 }
 
 #[no_mangle]
 pub unsafe extern "C" fn wgpu_client_create_compute_pipeline(
     client: &Client,
     device_id: id::DeviceId,