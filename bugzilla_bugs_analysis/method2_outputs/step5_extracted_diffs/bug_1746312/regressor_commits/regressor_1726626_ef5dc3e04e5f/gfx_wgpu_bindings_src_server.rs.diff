# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu_bindings/src/server.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu_bindings/src/server.rs b/gfx/wgpu_bindings/src/server.rs
--- a/gfx/wgpu_bindings/src/server.rs
+++ b/gfx/wgpu_bindings/src/server.rs
@@ -1,16 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 use crate::{
     cow_label, identity::IdentityRecyclerFactory, AdapterInformation, ByteBuf,
-    CommandEncoderAction, DeviceAction, DropAction, QueueWriteAction, RawString,
-    ShaderModuleSource, TextureAction,
+    CommandEncoderAction, DeviceAction, DropAction, QueueWriteAction, RawString, TextureAction,
 };
 
 use wgc::{gfx_select, id};
 
 use std::{error::Error, os::raw::c_char, ptr, slice};
 
 #[repr(C)]
 pub struct ErrorBuffer {
@@ -58,17 +57,17 @@ impl std::ops::Deref for Global {
 }
 
 #[no_mangle]
 pub extern "C" fn wgpu_server_new(factory: IdentityRecyclerFactory) -> *mut Global {
     log::info!("Initializing WGPU server");
     let global = Global(wgc::hub::Global::new(
         "wgpu",
         factory,
-        wgt::BackendBit::PRIMARY,
+        wgt::Backends::PRIMARY | wgt::Backends::GL,
     ));
     Box::into_raw(Box::new(global))
 }
 
 /// # Safety
 ///
 /// This function is unsafe because improper use may lead to memory
 /// problems. For example, a double-free may occur if the function is called
@@ -226,251 +225,246 @@ pub extern "C" fn wgpu_server_buffer_unm
 }
 
 #[no_mangle]
 pub extern "C" fn wgpu_server_buffer_drop(global: &Global, self_id: id::BufferId) {
     gfx_select!(self_id => global.buffer_drop(self_id, false));
 }
 
 trait GlobalExt {
-    fn device_action<B: wgc::hub::GfxBackend>(
+    fn device_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::DeviceId,
         action: DeviceAction,
         error_buf: ErrorBuffer,
     );
-    fn texture_action<B: wgc::hub::GfxBackend>(
+    fn texture_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::TextureId,
         action: TextureAction,
         error_buf: ErrorBuffer,
     );
-    fn command_encoder_action<B: wgc::hub::GfxBackend>(
+    fn command_encoder_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::CommandEncoderId,
         action: CommandEncoderAction,
         error_buf: ErrorBuffer,
     );
 }
 
 impl GlobalExt for Global {
-    fn device_action<B: wgc::hub::GfxBackend>(
+    fn device_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::DeviceId,
         action: DeviceAction,
         mut error_buf: ErrorBuffer,
     ) {
         match action {
             DeviceAction::CreateBuffer(id, desc) => {
-                let (_, error) = self.device_create_buffer::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_buffer::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateTexture(id, desc) => {
-                let (_, error) = self.device_create_texture::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_texture::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateSampler(id, desc) => {
-                let (_, error) = self.device_create_sampler::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_sampler::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateBindGroupLayout(id, desc) => {
-                let (_, error) = self.device_create_bind_group_layout::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_bind_group_layout::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreatePipelineLayout(id, desc) => {
-                let (_, error) = self.device_create_pipeline_layout::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_pipeline_layout::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateBindGroup(id, desc) => {
-                let (_, error) = self.device_create_bind_group::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_bind_group::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
-            DeviceAction::CreateShaderModule(id, desc, source) => {
-                let source = match source {
-                    ShaderModuleSource::SpirV(data) => {
-                        wgc::pipeline::ShaderModuleSource::SpirV(data)
-                    }
-                    ShaderModuleSource::Wgsl(data) => wgc::pipeline::ShaderModuleSource::Wgsl(data),
-                };
-                let (_, error) = self.device_create_shader_module::<B>(self_id, &desc, source, id);
+            DeviceAction::CreateShaderModule(id, desc, code) => {
+                let source = wgc::pipeline::ShaderModuleSource::Wgsl(code);
+                let (_, error) = self.device_create_shader_module::<A>(self_id, &desc, source, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateComputePipeline(id, desc, implicit) => {
                 let implicit_ids = implicit
                     .as_ref()
                     .map(|imp| wgc::device::ImplicitPipelineIds {
                         root_id: imp.pipeline,
                         group_ids: &imp.bind_groups,
                     });
                 let (_, error) =
-                    self.device_create_compute_pipeline::<B>(self_id, &desc, id, implicit_ids);
+                    self.device_create_compute_pipeline::<A>(self_id, &desc, id, implicit_ids);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateRenderPipeline(id, desc, implicit) => {
                 let implicit_ids = implicit
                     .as_ref()
                     .map(|imp| wgc::device::ImplicitPipelineIds {
                         root_id: imp.pipeline,
                         group_ids: &imp.bind_groups,
                     });
                 let (_, error) =
-                    self.device_create_render_pipeline::<B>(self_id, &desc, id, implicit_ids);
+                    self.device_create_render_pipeline::<A>(self_id, &desc, id, implicit_ids);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateRenderBundle(id, encoder, desc) => {
-                let (_, error) = self.render_bundle_encoder_finish::<B>(encoder, &desc, id);
+                let (_, error) = self.render_bundle_encoder_finish::<A>(encoder, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
             DeviceAction::CreateCommandEncoder(id, desc) => {
-                let (_, error) = self.device_create_command_encoder::<B>(self_id, &desc, id);
+                let (_, error) = self.device_create_command_encoder::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
         }
     }
 
-    fn texture_action<B: wgc::hub::GfxBackend>(
+    fn texture_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::TextureId,
         action: TextureAction,
         mut error_buf: ErrorBuffer,
     ) {
         match action {
             TextureAction::CreateView(id, desc) => {
-                let (_, error) = self.texture_create_view::<B>(self_id, &desc, id);
+                let (_, error) = self.texture_create_view::<A>(self_id, &desc, id);
                 if let Some(err) = error {
                     error_buf.init(err);
                 }
             }
         }
     }
 
-    fn command_encoder_action<B: wgc::hub::GfxBackend>(
+    fn command_encoder_action<A: wgc::hub::HalApi>(
         &self,
         self_id: id::CommandEncoderId,
         action: CommandEncoderAction,
         mut error_buf: ErrorBuffer,
     ) {
         match action {
             CommandEncoderAction::CopyBufferToBuffer {
                 src,
                 src_offset,
                 dst,
                 dst_offset,
                 size,
             } => {
-                if let Err(err) = self.command_encoder_copy_buffer_to_buffer::<B>(
+                if let Err(err) = self.command_encoder_copy_buffer_to_buffer::<A>(
                     self_id, src, src_offset, dst, dst_offset, size,
                 ) {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::CopyBufferToTexture { src, dst, size } => {
                 if let Err(err) =
-                    self.command_encoder_copy_buffer_to_texture::<B>(self_id, &src, &dst, &size)
+                    self.command_encoder_copy_buffer_to_texture::<A>(self_id, &src, &dst, &size)
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::CopyTextureToBuffer { src, dst, size } => {
                 if let Err(err) =
-                    self.command_encoder_copy_texture_to_buffer::<B>(self_id, &src, &dst, &size)
+                    self.command_encoder_copy_texture_to_buffer::<A>(self_id, &src, &dst, &size)
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::CopyTextureToTexture { src, dst, size } => {
                 if let Err(err) =
-                    self.command_encoder_copy_texture_to_texture::<B>(self_id, &src, &dst, &size)
+                    self.command_encoder_copy_texture_to_texture::<A>(self_id, &src, &dst, &size)
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::RunComputePass { base } => {
                 if let Err(err) =
-                    self.command_encoder_run_compute_pass_impl::<B>(self_id, base.as_ref())
+                    self.command_encoder_run_compute_pass_impl::<A>(self_id, base.as_ref())
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::WriteTimestamp {
                 query_set_id,
                 query_index,
             } => {
                 if let Err(err) =
-                    self.command_encoder_write_timestamp::<B>(self_id, query_set_id, query_index)
+                    self.command_encoder_write_timestamp::<A>(self_id, query_set_id, query_index)
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::ResolveQuerySet {
                 query_set_id,
                 start_query,
                 query_count,
                 destination,
                 destination_offset,
             } => {
-                if let Err(err) = self.command_encoder_resolve_query_set::<B>(
+                if let Err(err) = self.command_encoder_resolve_query_set::<A>(
                     self_id,
                     query_set_id,
                     start_query,
                     query_count,
                     destination,
                     destination_offset,
                 ) {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::RunRenderPass {
                 base,
                 target_colors,
                 target_depth_stencil,
             } => {
-                if let Err(err) = self.command_encoder_run_render_pass_impl::<B>(
+                if let Err(err) = self.command_encoder_run_render_pass_impl::<A>(
                     self_id,
                     base.as_ref(),
                     &target_colors,
                     target_depth_stencil.as_ref(),
                 ) {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::ClearBuffer { dst, offset, size } => {
-                if let Err(err) = self.command_encoder_clear_buffer::<B>(self_id, dst, offset, size)
+                if let Err(err) = self.command_encoder_clear_buffer::<A>(self_id, dst, offset, size)
                 {
                     error_buf.init(err);
                 }
             }
             CommandEncoderAction::ClearImage {
                 dst,
                 ref subresource_range,
             } => {
                 if let Err(err) =
-                    self.command_encoder_clear_image::<B>(self_id, dst, subresource_range)
+                    self.command_encoder_clear_image::<A>(self_id, dst, subresource_range)
                 {
                     error_buf.init(err);
                 }
             }
         }
     }
 }
 