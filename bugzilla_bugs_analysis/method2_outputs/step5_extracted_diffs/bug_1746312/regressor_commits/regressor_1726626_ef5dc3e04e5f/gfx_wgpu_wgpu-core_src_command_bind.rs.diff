# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/command/bind.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/command/bind.rs b/third_party/rust/wgpu-core/src/command/bind.rs
rename from gfx/wgpu/wgpu-core/src/command/bind.rs
rename to third_party/rust/wgpu-core/src/command/bind.rs
--- a/gfx/wgpu/wgpu-core/src/command/bind.rs
+++ b/third_party/rust/wgpu-core/src/command/bind.rs
@@ -1,35 +1,31 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 use crate::{
     binding_model::{BindGroup, PipelineLayout},
     device::SHADER_STAGE_COUNT,
-    hub::{GfxBackend, Storage},
+    hub::{HalApi, Storage},
     id::{BindGroupId, BindGroupLayoutId, PipelineLayoutId, Valid},
-    Stored, MAX_BIND_GROUPS,
+    Stored,
 };
 
 use arrayvec::ArrayVec;
 
 type BindGroupMask = u8;
 
 mod compat {
     use std::ops::Range;
 
     #[derive(Debug)]
     struct Entry<T> {
         assigned: Option<T>,
         expected: Option<T>,
     }
     impl<T> Default for Entry<T> {
         fn default() -> Self {
-            Entry {
+            Self {
                 assigned: None,
                 expected: None,
             }
         }
     }
     impl<T: Copy + PartialEq> Entry<T> {
         fn is_active(&self) -> bool {
             self.assigned.is_some() && self.expected.is_some()
@@ -37,22 +33,22 @@ mod compat {
 
         fn is_valid(&self) -> bool {
             self.expected.is_none() || self.expected == self.assigned
         }
     }
 
     #[derive(Debug)]
     pub struct Manager<T> {
-        entries: [Entry<T>; crate::MAX_BIND_GROUPS],
+        entries: [Entry<T>; hal::MAX_BIND_GROUPS],
     }
 
     impl<T: Copy + PartialEq> Manager<T> {
         pub fn new() -> Self {
-            Manager {
+            Self {
                 entries: Default::default(),
             }
         }
 
         fn make_range(&self, start_index: usize) -> Range<usize> {
             // find first incompatible entry
             let end = self
                 .entries
@@ -140,40 +136,40 @@ pub(super) struct EntryPayload {
     pub(super) group_id: Option<Stored<BindGroupId>>,
     pub(super) dynamic_offsets: Vec<wgt::DynamicOffset>,
 }
 
 #[derive(Debug)]
 pub(super) struct Binder {
     pub(super) pipeline_layout_id: Option<Valid<PipelineLayoutId>>, //TODO: strongly `Stored`
     manager: compat::Manager<Valid<BindGroupLayoutId>>,
-    payloads: [EntryPayload; MAX_BIND_GROUPS],
+    payloads: [EntryPayload; hal::MAX_BIND_GROUPS],
 }
 
 impl Binder {
     pub(super) fn new() -> Self {
-        Binder {
+        Self {
             pipeline_layout_id: None,
             manager: compat::Manager::new(),
             payloads: Default::default(),
         }
     }
 
     pub(super) fn reset(&mut self) {
         self.pipeline_layout_id = None;
         self.manager = compat::Manager::new();
         for payload in self.payloads.iter_mut() {
             payload.group_id = None;
             payload.dynamic_offsets.clear();
         }
     }
 
-    pub(super) fn change_pipeline_layout<'a, B: GfxBackend>(
+    pub(super) fn change_pipeline_layout<'a, A: HalApi>(
         &'a mut self,
-        guard: &Storage<PipelineLayout<B>, PipelineLayoutId>,
+        guard: &Storage<PipelineLayout<A>, PipelineLayoutId>,
         new_id: Valid<PipelineLayoutId>,
     ) -> (usize, &'a [EntryPayload]) {
         let old_id_opt = self.pipeline_layout_id.replace(new_id);
         let new = &guard[new_id];
 
         let mut bind_range = self.manager.update_expectations(&new.bind_group_layout_ids);
 
         if let Some(old_id) = old_id_opt {
@@ -182,25 +178,25 @@ impl Binder {
             if old.push_constant_ranges != new.push_constant_ranges {
                 bind_range.start = 0;
             }
         }
 
         (bind_range.start, &self.payloads[bind_range])
     }
 
-    pub(super) fn assign_group<'a, B: GfxBackend>(
+    pub(super) fn assign_group<'a, A: HalApi>(
         &'a mut self,
         index: usize,
         bind_group_id: Valid<BindGroupId>,
-        bind_group: &BindGroup<B>,
+        bind_group: &BindGroup<A>,
         offsets: &[wgt::DynamicOffset],
     ) -> &'a [EntryPayload] {
         log::trace!("\tBinding [{}] = group {:?}", index, bind_group_id);
-        debug_assert_eq!(B::VARIANT, bind_group_id.0.backend());
+        debug_assert_eq!(A::VARIANT, bind_group_id.0.backend());
 
         let payload = &mut self.payloads[index];
         payload.group_id = Some(Stored {
             value: bind_group_id,
             ref_count: bind_group.life_guard.add_ref(),
         });
         payload.dynamic_offsets.clear();
         payload.dynamic_offsets.extend_from_slice(offsets);
@@ -217,50 +213,50 @@ impl Binder {
     }
 
     pub(super) fn invalid_mask(&self) -> BindGroupMask {
         self.manager.invalid_mask()
     }
 }
 
 struct PushConstantChange {
-    stages: wgt::ShaderStage,
+    stages: wgt::ShaderStages,
     offset: u32,
     enable: bool,
 }
 
 /// Break up possibly overlapping push constant ranges into a set of non-overlapping ranges
 /// which contain all the stage flags of the original ranges. This allows us to zero out (or write any value)
 /// to every possible value.
 pub fn compute_nonoverlapping_ranges(
     ranges: &[wgt::PushConstantRange],
-) -> ArrayVec<[wgt::PushConstantRange; SHADER_STAGE_COUNT * 2]> {
+) -> ArrayVec<wgt::PushConstantRange, { SHADER_STAGE_COUNT * 2 }> {
     if ranges.is_empty() {
         return ArrayVec::new();
     }
     debug_assert!(ranges.len() <= SHADER_STAGE_COUNT);
 
-    let mut breaks: ArrayVec<[PushConstantChange; SHADER_STAGE_COUNT * 2]> = ArrayVec::new();
+    let mut breaks: ArrayVec<PushConstantChange, { SHADER_STAGE_COUNT * 2 }> = ArrayVec::new();
     for range in ranges {
         breaks.push(PushConstantChange {
             stages: range.stages,
             offset: range.range.start,
             enable: true,
         });
         breaks.push(PushConstantChange {
             stages: range.stages,
             offset: range.range.end,
             enable: false,
         });
     }
     breaks.sort_unstable_by_key(|change| change.offset);
 
     let mut output_ranges = ArrayVec::new();
     let mut position = 0_u32;
-    let mut stages = wgt::ShaderStage::NONE;
+    let mut stages = wgt::ShaderStages::NONE;
 
     for bk in breaks {
         if bk.offset - position > 0 && !stages.is_empty() {
             output_ranges.push(wgt::PushConstantRange {
                 stages,
                 range: position..bk.offset,
             })
         }