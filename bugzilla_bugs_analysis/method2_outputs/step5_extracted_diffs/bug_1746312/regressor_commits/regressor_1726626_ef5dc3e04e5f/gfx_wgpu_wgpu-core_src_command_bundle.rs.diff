# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/command/bundle.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/command/bundle.rs b/third_party/rust/wgpu-core/src/command/bundle.rs
rename from gfx/wgpu/wgpu-core/src/command/bundle.rs
rename to third_party/rust/wgpu-core/src/command/bundle.rs
--- a/gfx/wgpu/wgpu-core/src/command/bundle.rs
+++ b/third_party/rust/wgpu-core/src/command/bundle.rs
@@ -1,12 +1,8 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 /*! Render Bundles
 
     ## Software implementation
 
     The path from nothing to using a render bundle consists of 3 phases.
 
     ### Initial command encoding
 
@@ -39,126 +35,141 @@
 
 use crate::{
     command::{
         BasePass, DrawError, MapPassErr, PassErrorScope, RenderCommand, RenderCommandError,
         StateChange,
     },
     conv,
     device::{
-        AttachmentData, Device, DeviceError, RenderPassContext, MAX_VERTEX_BUFFERS,
+        AttachmentData, Device, DeviceError, MissingDownlevelFlags, RenderPassContext,
         SHADER_STAGE_COUNT,
     },
-    hub::{GfxBackend, GlobalIdentityHandlerFactory, Hub, Resource, Storage, Token},
+    error::{ErrorFormatter, PrettyError},
+    hub::{GlobalIdentityHandlerFactory, HalApi, Hub, Resource, Storage, Token},
     id,
-    memory_init_tracker::{MemoryInitKind, MemoryInitTrackerAction},
-    resource::BufferUse,
+    init_tracker::{BufferInitTrackerAction, MemoryInitKind},
+    pipeline::PipelineFlags,
     track::{TrackerSet, UsageConflict},
     validation::check_buffer_usage,
-    Label, LabelHelpers, LifeGuard, Stored, MAX_BIND_GROUPS,
+    Label, LabelHelpers, LifeGuard, Stored,
 };
 use arrayvec::ArrayVec;
-use std::{borrow::Cow, iter, mem, ops::Range};
+use std::{borrow::Cow, mem, ops::Range};
 use thiserror::Error;
 
+use hal::CommandEncoder as _;
+
 /// Describes a [`RenderBundleEncoder`].
 #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct RenderBundleEncoderDescriptor<'a> {
     /// Debug label of the render bundle encoder. This will show up in graphics debuggers for easy identification.
     pub label: Label<'a>,
     /// The formats of the color attachments that this render bundle is capable to rendering to. This
     /// must match the formats of the color attachments in the renderpass this render bundle is executed in.
     pub color_formats: Cow<'a, [wgt::TextureFormat]>,
-    /// The formats of the depth attachment that this render bundle is capable to rendering to. This
-    /// must match the formats of the depth attachments in the renderpass this render bundle is executed in.
-    pub depth_stencil_format: Option<wgt::TextureFormat>,
+    /// Information about the depth attachment that this render bundle is capable to rendering to. The format
+    /// must match the format of the depth attachments in the renderpass this render bundle is executed in.
+    pub depth_stencil: Option<wgt::RenderBundleDepthStencil>,
     /// Sample count this render bundle is capable of rendering to. This must match the pipelines and
     /// the renderpasses it is used in.
     pub sample_count: u32,
 }
 
 #[derive(Debug)]
 #[cfg_attr(feature = "serial-pass", derive(serde::Deserialize, serde::Serialize))]
 pub struct RenderBundleEncoder {
     base: BasePass<RenderCommand>,
     parent_id: id::DeviceId,
     pub(crate) context: RenderPassContext,
+    pub(crate) is_ds_read_only: bool,
 }
 
 impl RenderBundleEncoder {
     pub fn new(
         desc: &RenderBundleEncoderDescriptor,
         parent_id: id::DeviceId,
         base: Option<BasePass<RenderCommand>>,
     ) -> Result<Self, CreateRenderBundleError> {
         Ok(Self {
             base: base.unwrap_or_else(|| BasePass::new(&desc.label)),
             parent_id,
             context: RenderPassContext {
                 attachments: AttachmentData {
                     colors: desc.color_formats.iter().cloned().collect(),
                     resolves: ArrayVec::new(),
-                    depth_stencil: desc.depth_stencil_format,
+                    depth_stencil: desc.depth_stencil.map(|ds| ds.format),
                 },
                 sample_count: {
                     let sc = desc.sample_count;
                     if sc == 0 || sc > 32 || !conv::is_power_of_two(sc) {
                         return Err(CreateRenderBundleError::InvalidSampleCount(sc));
                     }
-                    sc as u8
+                    sc
                 },
             },
+            is_ds_read_only: match desc.depth_stencil {
+                Some(ds) => {
+                    let aspects = hal::FormatAspects::from(ds.format);
+                    (!aspects.contains(hal::FormatAspects::DEPTH) || ds.depth_read_only)
+                        && (!aspects.contains(hal::FormatAspects::STENCIL) || ds.stencil_read_only)
+                }
+                None => false,
+            },
         })
     }
 
     pub fn dummy(parent_id: id::DeviceId) -> Self {
         Self {
             base: BasePass::new(&None),
             parent_id,
             context: RenderPassContext {
                 attachments: AttachmentData {
                     colors: ArrayVec::new(),
                     resolves: ArrayVec::new(),
                     depth_stencil: None,
                 },
                 sample_count: 0,
             },
+            is_ds_read_only: false,
         }
     }
 
     #[cfg(feature = "trace")]
     pub(crate) fn to_base_pass(&self) -> BasePass<RenderCommand> {
         BasePass::from_ref(self.base.as_ref())
     }
 
     pub fn parent(&self) -> id::DeviceId {
         self.parent_id
     }
 
-    pub(crate) fn finish<B: hal::Backend, G: GlobalIdentityHandlerFactory>(
+    pub(crate) fn finish<A: hal::Api, G: GlobalIdentityHandlerFactory>(
         self,
         desc: &RenderBundleDescriptor,
-        device: &Device<B>,
-        hub: &Hub<B, G>,
-        token: &mut Token<Device<B>>,
+        device: &Device<A>,
+        hub: &Hub<A, G>,
+        token: &mut Token<Device<A>>,
     ) -> Result<RenderBundle, RenderBundleError> {
         let (pipeline_layout_guard, mut token) = hub.pipeline_layouts.read(token);
         let (bind_group_guard, mut token) = hub.bind_groups.read(&mut token);
         let (pipeline_guard, mut token) = hub.render_pipelines.read(&mut token);
         let (buffer_guard, _) = hub.buffers.read(&mut token);
 
         let mut state = State {
             trackers: TrackerSet::new(self.parent_id.backend()),
             index: IndexState::new(),
-            vertex: (0..MAX_VERTEX_BUFFERS)
+            vertex: (0..hal::MAX_VERTEX_BUFFERS)
                 .map(|_| VertexState::new())
                 .collect(),
-            bind: (0..MAX_BIND_GROUPS).map(|_| BindState::new()).collect(),
+            bind: (0..hal::MAX_BIND_GROUPS)
+                .map(|_| BindState::new())
+                .collect(),
             push_constant_ranges: PushConstantState::new(),
             raw_dynamic_offsets: Vec::new(),
             flat_dynamic_offsets: Vec::new(),
             used_bind_groups: 0,
             pipeline: StateChange::new(),
         };
         let mut commands = Vec::new();
         let mut base = self.base.as_ref();
@@ -209,37 +220,44 @@ impl RenderBundleEncoder {
                         .map_pass_err(scope);
                     }
 
                     buffer_memory_init_actions.extend_from_slice(&bind_group.used_buffer_ranges);
 
                     state.set_bind_group(index, bind_group_id, bind_group.layout_id, offsets);
                     state
                         .trackers
-                        .merge_extend_all(&bind_group.used)
+                        .merge_extend_stateful(&bind_group.used)
                         .map_pass_err(scope)?;
+                    //Note: stateless trackers are not merged: the lifetime reference
+                    // is held to the bind group itself.
                 }
                 RenderCommand::SetPipeline(pipeline_id) => {
                     let scope = PassErrorScope::SetPipelineRender(pipeline_id);
                     if state.pipeline.set_and_check_redundant(pipeline_id) {
                         continue;
                     }
 
                     let pipeline = state
                         .trackers
                         .render_pipes
                         .use_extend(&*pipeline_guard, pipeline_id, (), ())
                         .unwrap();
 
                     self.context
                         .check_compatible(&pipeline.pass_context)
-                        .map_err(RenderCommandError::IncompatiblePipeline)
+                        .map_err(RenderCommandError::IncompatiblePipelineTargets)
                         .map_pass_err(scope)?;
 
-                    //TODO: check read-only depth
+                    if pipeline.flags.contains(PipelineFlags::WRITES_DEPTH_STENCIL)
+                        && self.is_ds_read_only
+                    {
+                        return Err(RenderCommandError::IncompatiblePipelineRods)
+                            .map_pass_err(scope);
+                    }
 
                     let layout = &pipeline_layout_guard[pipeline.layout_id.value];
                     pipeline_layout_id = Some(pipeline.layout_id.value);
 
                     state.set_pipeline(
                         pipeline.strip_index_format,
                         &pipeline.vertex_strides,
                         &layout.bind_group_layout_ids,
@@ -255,57 +273,57 @@ impl RenderBundleEncoder {
                     index_format,
                     offset,
                     size,
                 } => {
                     let scope = PassErrorScope::SetIndexBuffer(buffer_id);
                     let buffer = state
                         .trackers
                         .buffers
-                        .use_extend(&*buffer_guard, buffer_id, (), BufferUse::INDEX)
+                        .use_extend(&*buffer_guard, buffer_id, (), hal::BufferUses::INDEX)
                         .unwrap();
-                    check_buffer_usage(buffer.usage, wgt::BufferUsage::INDEX)
+                    check_buffer_usage(buffer.usage, wgt::BufferUsages::INDEX)
                         .map_pass_err(scope)?;
 
                     let end = match size {
                         Some(s) => offset + s.get(),
                         None => buffer.size,
                     };
-                    buffer_memory_init_actions.push(MemoryInitTrackerAction {
-                        id: buffer_id,
-                        range: offset..end,
-                        kind: MemoryInitKind::NeedsInitializedMemory,
-                    });
+                    buffer_memory_init_actions.extend(buffer.initialization_status.create_action(
+                        buffer_id,
+                        offset..end,
+                        MemoryInitKind::NeedsInitializedMemory,
+                    ));
                     state.index.set_format(index_format);
                     state.index.set_buffer(buffer_id, offset..end);
                 }
                 RenderCommand::SetVertexBuffer {
                     slot,
                     buffer_id,
                     offset,
                     size,
                 } => {
                     let scope = PassErrorScope::SetVertexBuffer(buffer_id);
                     let buffer = state
                         .trackers
                         .buffers
-                        .use_extend(&*buffer_guard, buffer_id, (), BufferUse::VERTEX)
+                        .use_extend(&*buffer_guard, buffer_id, (), hal::BufferUses::VERTEX)
                         .unwrap();
-                    check_buffer_usage(buffer.usage, wgt::BufferUsage::VERTEX)
+                    check_buffer_usage(buffer.usage, wgt::BufferUsages::VERTEX)
                         .map_pass_err(scope)?;
 
                     let end = match size {
                         Some(s) => offset + s.get(),
                         None => buffer.size,
                     };
-                    buffer_memory_init_actions.push(MemoryInitTrackerAction {
-                        id: buffer_id,
-                        range: offset..end,
-                        kind: MemoryInitKind::NeedsInitializedMemory,
-                    });
+                    buffer_memory_init_actions.extend(buffer.initialization_status.create_action(
+                        buffer_id,
+                        offset..end,
+                        MemoryInitKind::NeedsInitializedMemory,
+                    ));
                     state.vertex[slot as usize].set_buffer(buffer_id, offset..end);
                 }
                 RenderCommand::SetPushConstant {
                     stages,
                     offset,
                     size_bytes,
                     values_offset: _,
                 } => {
@@ -400,73 +418,67 @@ impl RenderBundleEncoder {
                     count: None,
                     indexed: false,
                 } => {
                     let scope = PassErrorScope::Draw {
                         indexed: false,
                         indirect: true,
                         pipeline: state.pipeline.last_state,
                     };
+                    device
+                        .require_downlevel_flags(wgt::DownlevelFlags::INDIRECT_EXECUTION)
+                        .map_pass_err(scope)?;
+
                     let buffer = state
                         .trackers
                         .buffers
-                        .use_extend(&*buffer_guard, buffer_id, (), BufferUse::INDIRECT)
+                        .use_extend(&*buffer_guard, buffer_id, (), hal::BufferUses::INDIRECT)
                         .unwrap();
-                    check_buffer_usage(buffer.usage, wgt::BufferUsage::INDIRECT)
+                    check_buffer_usage(buffer.usage, wgt::BufferUsages::INDIRECT)
                         .map_pass_err(scope)?;
 
-                    buffer_memory_init_actions.extend(
-                        buffer
-                            .initialization_status
-                            .check(
-                                offset..(offset + mem::size_of::<wgt::DrawIndirectArgs>() as u64),
-                            )
-                            .map(|range| MemoryInitTrackerAction {
-                                id: buffer_id,
-                                range,
-                                kind: MemoryInitKind::NeedsInitializedMemory,
-                            }),
-                    );
+                    buffer_memory_init_actions.extend(buffer.initialization_status.create_action(
+                        buffer_id,
+                        offset..(offset + mem::size_of::<wgt::DrawIndirectArgs>() as u64),
+                        MemoryInitKind::NeedsInitializedMemory,
+                    ));
 
                     commands.extend(state.flush_vertices());
                     commands.extend(state.flush_binds());
                     commands.push(command);
                 }
                 RenderCommand::MultiDrawIndirect {
                     buffer_id,
                     offset,
                     count: None,
                     indexed: true,
                 } => {
                     let scope = PassErrorScope::Draw {
                         indexed: true,
                         indirect: true,
                         pipeline: state.pipeline.last_state,
                     };
+                    device
+                        .require_downlevel_flags(wgt::DownlevelFlags::INDIRECT_EXECUTION)
+                        .map_pass_err(scope)?;
+
                     let buffer = state
                         .trackers
                         .buffers
-                        .use_extend(&*buffer_guard, buffer_id, (), BufferUse::INDIRECT)
+                        .use_extend(&*buffer_guard, buffer_id, (), hal::BufferUses::INDIRECT)
                         .map_err(|err| RenderCommandError::Buffer(buffer_id, err))
                         .map_pass_err(scope)?;
-                    check_buffer_usage(buffer.usage, wgt::BufferUsage::INDIRECT)
+                    check_buffer_usage(buffer.usage, wgt::BufferUsages::INDIRECT)
                         .map_pass_err(scope)?;
 
-                    buffer_memory_init_actions.extend(
-                        buffer
-                            .initialization_status
-                            .check(
-                                offset..(offset + mem::size_of::<wgt::DrawIndirectArgs>() as u64),
-                            )
-                            .map(|range| MemoryInitTrackerAction {
-                                id: buffer_id,
-                                range,
-                                kind: MemoryInitKind::NeedsInitializedMemory,
-                            }),
-                    );
+                    buffer_memory_init_actions.extend(buffer.initialization_status.create_action(
+                        buffer_id,
+                        offset..(offset + mem::size_of::<wgt::DrawIndirectArgs>() as u64),
+                        MemoryInitKind::NeedsInitializedMemory,
+                    ));
 
                     commands.extend(state.index.flush());
                     commands.extend(state.flush_vertices());
                     commands.extend(state.flush_binds());
                     commands.push(command);
                 }
                 RenderCommand::MultiDrawIndirect { .. }
                 | RenderCommand::MultiDrawIndirectCount { .. } => unimplemented!(),
@@ -487,16 +499,17 @@ impl RenderBundleEncoder {
         Ok(RenderBundle {
             base: BasePass {
                 label: desc.label.as_ref().map(|cow| cow.to_string()),
                 commands,
                 dynamic_offsets: state.flat_dynamic_offsets,
                 string_data: Vec::new(),
                 push_constant_data: Vec::new(),
             },
+            is_ds_read_only: self.is_ds_read_only,
             device_id: Stored {
                 value: id::Valid(self.parent_id),
                 ref_count: device.life_guard.add_ref(),
             },
             used: state.trackers,
             buffer_memory_init_actions,
             context: self.context,
             life_guard: LifeGuard::new(desc.label.borrow_or_default()),
@@ -529,213 +542,217 @@ pub enum CreateRenderBundleError {
 /// Error type returned from `RenderBundleEncoder::new` if the sample count is invalid.
 #[derive(Clone, Debug, Error)]
 pub enum ExecutionError {
     #[error("buffer {0:?} is destroyed")]
     DestroyedBuffer(id::BufferId),
     #[error("using {0} in a render bundle is not implemented")]
     Unimplemented(&'static str),
 }
+impl PrettyError for ExecutionError {
+    fn fmt_pretty(&self, fmt: &mut ErrorFormatter) {
+        fmt.error(self);
+        match *self {
+            Self::DestroyedBuffer(id) => {
+                fmt.buffer_label(&id);
+            }
+            Self::Unimplemented(_reason) => {}
+        };
+    }
+}
 
 pub type RenderBundleDescriptor<'a> = wgt::RenderBundleDescriptor<Label<'a>>;
 
 //Note: here, `RenderBundle` is just wrapping a raw stream of render commands.
 // The plan is to back it by an actual Vulkan secondary buffer, D3D12 Bundle,
 // or Metal indirect command buffer.
 #[derive(Debug)]
 pub struct RenderBundle {
     // Normalized command stream. It can be executed verbatim,
     // without re-binding anything on the pipeline change.
     base: BasePass<RenderCommand>,
+    pub(super) is_ds_read_only: bool,
     pub(crate) device_id: Stored<id::DeviceId>,
     pub(crate) used: TrackerSet,
-    pub(crate) buffer_memory_init_actions: Vec<MemoryInitTrackerAction<id::BufferId>>,
-    pub(crate) context: RenderPassContext,
+    pub(super) buffer_memory_init_actions: Vec<BufferInitTrackerAction>,
+    pub(super) context: RenderPassContext,
     pub(crate) life_guard: LifeGuard,
 }
 
 unsafe impl Send for RenderBundle {}
 unsafe impl Sync for RenderBundle {}
 
 impl RenderBundle {
     /// Actually encode the contents into a native command buffer.
     ///
     /// This is partially duplicating the logic of `command_encoder_run_render_pass`.
     /// However the point of this function is to be lighter, since we already had
     /// a chance to go through the commands in `render_bundle_encoder_finish`.
     ///
     /// Note that the function isn't expected to fail, generally.
     /// All the validation has already been done by this point.
     /// The only failure condition is if some of the used buffers are destroyed.
-    pub(crate) unsafe fn execute<B: GfxBackend>(
+    pub(super) unsafe fn execute<A: HalApi>(
         &self,
-        cmd_buf: &mut B::CommandBuffer,
+        raw: &mut A::CommandEncoder,
         pipeline_layout_guard: &Storage<
-            crate::binding_model::PipelineLayout<B>,
+            crate::binding_model::PipelineLayout<A>,
             id::PipelineLayoutId,
         >,
-        bind_group_guard: &Storage<crate::binding_model::BindGroup<B>, id::BindGroupId>,
-        pipeline_guard: &Storage<crate::pipeline::RenderPipeline<B>, id::RenderPipelineId>,
-        buffer_guard: &Storage<crate::resource::Buffer<B>, id::BufferId>,
+        bind_group_guard: &Storage<crate::binding_model::BindGroup<A>, id::BindGroupId>,
+        pipeline_guard: &Storage<crate::pipeline::RenderPipeline<A>, id::RenderPipelineId>,
+        buffer_guard: &Storage<crate::resource::Buffer<A>, id::BufferId>,
     ) -> Result<(), ExecutionError> {
-        use hal::command::CommandBuffer as _;
-
         let mut offsets = self.base.dynamic_offsets.as_slice();
         let mut pipeline_layout_id = None::<id::Valid<id::PipelineLayoutId>>;
         if let Some(ref label) = self.base.label {
-            cmd_buf.begin_debug_marker(label, 0);
+            raw.begin_debug_marker(label);
         }
 
         for command in self.base.commands.iter() {
             match *command {
                 RenderCommand::SetBindGroup {
                     index,
                     num_dynamic_offsets,
                     bind_group_id,
                 } => {
                     let bind_group = bind_group_guard.get(bind_group_id).unwrap();
-                    cmd_buf.bind_graphics_descriptor_sets(
+                    raw.set_bind_group(
                         &pipeline_layout_guard[pipeline_layout_id.unwrap()].raw,
-                        index as usize,
-                        iter::once(bind_group.raw.raw()),
-                        offsets.iter().take(num_dynamic_offsets as usize).cloned(),
+                        index as u32,
+                        &bind_group.raw,
+                        &offsets[..num_dynamic_offsets as usize],
                     );
                     offsets = &offsets[num_dynamic_offsets as usize..];
                 }
                 RenderCommand::SetPipeline(pipeline_id) => {
                     let pipeline = pipeline_guard.get(pipeline_id).unwrap();
-                    cmd_buf.bind_graphics_pipeline(&pipeline.raw);
+                    raw.set_render_pipeline(&pipeline.raw);
 
                     pipeline_layout_id = Some(pipeline.layout_id.value);
                 }
                 RenderCommand::SetIndexBuffer {
                     buffer_id,
                     index_format,
                     offset,
                     size,
                 } => {
-                    let index_type = conv::map_index_format(index_format);
-
-                    let &(ref buffer, _) = buffer_guard
+                    let buffer = buffer_guard
                         .get(buffer_id)
                         .unwrap()
                         .raw
                         .as_ref()
                         .ok_or(ExecutionError::DestroyedBuffer(buffer_id))?;
-                    let range = hal::buffer::SubRange {
+                    let bb = hal::BufferBinding {
+                        buffer,
                         offset,
-                        size: size.map(|s| s.get()),
+                        size,
                     };
-                    cmd_buf.bind_index_buffer(buffer, range, index_type);
+                    raw.set_index_buffer(bb, index_format);
                 }
                 RenderCommand::SetVertexBuffer {
                     slot,
                     buffer_id,
                     offset,
                     size,
                 } => {
-                    let &(ref buffer, _) = buffer_guard
+                    let buffer = buffer_guard
                         .get(buffer_id)
                         .unwrap()
                         .raw
                         .as_ref()
                         .ok_or(ExecutionError::DestroyedBuffer(buffer_id))?;
-                    let range = hal::buffer::SubRange {
+                    let bb = hal::BufferBinding {
+                        buffer,
                         offset,
-                        size: size.map(|s| s.get()),
+                        size,
                     };
-                    cmd_buf.bind_vertex_buffers(slot, iter::once((buffer, range)));
+                    raw.set_vertex_buffer(slot, bb);
                 }
                 RenderCommand::SetPushConstant {
                     stages,
                     offset,
                     size_bytes,
                     values_offset,
                 } => {
                     let pipeline_layout_id = pipeline_layout_id.unwrap();
                     let pipeline_layout = &pipeline_layout_guard[pipeline_layout_id];
 
                     if let Some(values_offset) = values_offset {
                         let values_end_offset =
                             (values_offset + size_bytes / wgt::PUSH_CONSTANT_ALIGNMENT) as usize;
                         let data_slice = &self.base.push_constant_data
                             [(values_offset as usize)..values_end_offset];
 
-                        cmd_buf.push_graphics_constants(
-                            &pipeline_layout.raw,
-                            conv::map_shader_stage_flags(stages),
-                            offset,
-                            &data_slice,
-                        )
+                        raw.set_push_constants(&pipeline_layout.raw, stages, offset, data_slice)
                     } else {
                         super::push_constant_clear(
                             offset,
                             size_bytes,
                             |clear_offset, clear_data| {
-                                cmd_buf.push_graphics_constants(
+                                raw.set_push_constants(
                                     &pipeline_layout.raw,
-                                    conv::map_shader_stage_flags(stages),
+                                    stages,
                                     clear_offset,
                                     clear_data,
                                 );
                             },
                         );
                     }
                 }
                 RenderCommand::Draw {
                     vertex_count,
                     instance_count,
                     first_vertex,
                     first_instance,
                 } => {
-                    cmd_buf.draw(
-                        first_vertex..first_vertex + vertex_count,
-                        first_instance..first_instance + instance_count,
-                    );
+                    raw.draw(first_vertex, vertex_count, first_instance, instance_count);
                 }
                 RenderCommand::DrawIndexed {
                     index_count,
                     instance_count,
                     first_index,
                     base_vertex,
                     first_instance,
                 } => {
-                    cmd_buf.draw_indexed(
-                        first_index..first_index + index_count,
+                    raw.draw_indexed(
+                        first_index,
+                        index_count,
                         base_vertex,
-                        first_instance..first_instance + instance_count,
+                        first_instance,
+                        instance_count,
                     );
                 }
                 RenderCommand::MultiDrawIndirect {
                     buffer_id,
                     offset,
                     count: None,
                     indexed: false,
                 } => {
-                    let &(ref buffer, _) = buffer_guard
+                    let buffer = buffer_guard
                         .get(buffer_id)
                         .unwrap()
                         .raw
                         .as_ref()
                         .ok_or(ExecutionError::DestroyedBuffer(buffer_id))?;
-                    cmd_buf.draw_indirect(buffer, offset, 1, 0);
+                    raw.draw_indirect(buffer, offset, 1);
                 }
                 RenderCommand::MultiDrawIndirect {
                     buffer_id,
                     offset,
                     count: None,
                     indexed: true,
                 } => {
-                    let &(ref buffer, _) = buffer_guard
+                    let buffer = buffer_guard
                         .get(buffer_id)
                         .unwrap()
                         .raw
                         .as_ref()
                         .ok_or(ExecutionError::DestroyedBuffer(buffer_id))?;
-                    cmd_buf.draw_indexed_indirect(buffer, offset, 1, 0);
+                    raw.draw_indexed_indirect(buffer, offset, 1);
                 }
                 RenderCommand::MultiDrawIndirect { .. }
                 | RenderCommand::MultiDrawIndirectCount { .. } => {
                     return Err(ExecutionError::Unimplemented("multi-draw-indirect"))
                 }
                 RenderCommand::PushDebugGroup { .. }
                 | RenderCommand::InsertDebugMarker { .. }
                 | RenderCommand::PopDebugGroup => {
@@ -750,17 +767,17 @@ impl RenderBundle {
                 | RenderCommand::SetBlendConstant(_)
                 | RenderCommand::SetStencilReference(_)
                 | RenderCommand::SetViewport { .. }
                 | RenderCommand::SetScissor(_) => unreachable!(),
             }
         }
 
         if let Some(_) = self.base.label {
-            cmd_buf.end_debug_marker();
+            raw.end_debug_marker();
         }
 
         Ok(())
     }
 }
 
 impl Resource for RenderBundle {
     const TYPE: &'static str = "RenderBundle";
@@ -827,27 +844,27 @@ impl IndexState {
     }
 }
 
 #[derive(Debug)]
 struct VertexState {
     buffer: Option<id::BufferId>,
     range: Range<wgt::BufferAddress>,
     stride: wgt::BufferAddress,
-    rate: wgt::InputStepMode,
+    rate: wgt::VertexStepMode,
     is_dirty: bool,
 }
 
 impl VertexState {
     fn new() -> Self {
         Self {
             buffer: None,
             range: 0..0,
             stride: 0,
-            rate: wgt::InputStepMode::Vertex,
+            rate: wgt::VertexStepMode::Vertex,
             is_dirty: false,
         }
     }
 
     fn set_buffer(&mut self, buffer_id: id::BufferId, range: Range<wgt::BufferAddress>) {
         self.buffer = Some(buffer_id);
         self.range = range;
         self.is_dirty = true;
@@ -900,17 +917,17 @@ impl BindState {
                 true
             }
         }
     }
 }
 
 #[derive(Debug)]
 struct PushConstantState {
-    ranges: ArrayVec<[wgt::PushConstantRange; SHADER_STAGE_COUNT]>,
+    ranges: ArrayVec<wgt::PushConstantRange, { SHADER_STAGE_COUNT }>,
     is_dirty: bool,
 }
 impl PushConstantState {
     fn new() -> Self {
         Self {
             ranges: ArrayVec::new(),
             is_dirty: false,
         }
@@ -938,18 +955,18 @@ struct VertexLimitState {
     /// Buffer slot which the shortest instance rate vertex buffer is bound to
     instance_limit_slot: u32,
 }
 
 #[derive(Debug)]
 struct State {
     trackers: TrackerSet,
     index: IndexState,
-    vertex: ArrayVec<[VertexState; MAX_VERTEX_BUFFERS]>,
-    bind: ArrayVec<[BindState; MAX_BIND_GROUPS]>,
+    vertex: ArrayVec<VertexState, { hal::MAX_VERTEX_BUFFERS }>,
+    bind: ArrayVec<BindState, { hal::MAX_BIND_GROUPS }>,
     push_constant_ranges: PushConstantState,
     raw_dynamic_offsets: Vec<wgt::DynamicOffset>,
     flat_dynamic_offsets: Vec<wgt::DynamicOffset>,
     used_bind_groups: usize,
     pipeline: StateChange<id::RenderPipelineId>,
 }
 
 impl State {
@@ -961,23 +978,23 @@ impl State {
             instance_limit_slot: 0,
         };
         for (idx, vbs) in self.vertex.iter().enumerate() {
             if vbs.stride == 0 {
                 continue;
             }
             let limit = ((vbs.range.end - vbs.range.start) / vbs.stride) as u32;
             match vbs.rate {
-                wgt::InputStepMode::Vertex => {
+                wgt::VertexStepMode::Vertex => {
                     if limit < vert_state.vertex_limit {
                         vert_state.vertex_limit = limit;
                         vert_state.vertex_limit_slot = idx as _;
                     }
                 }
-                wgt::InputStepMode::Instance => {
+                wgt::VertexStepMode::Instance => {
                     if limit < vert_state.instance_limit {
                         vert_state.instance_limit = limit;
                         vert_state.instance_limit_slot = idx as _;
                     }
                 }
             }
         }
         vert_state
@@ -1007,17 +1024,17 @@ impl State {
             self.invalidate_group_from(slot as usize + 1);
         }
         self.raw_dynamic_offsets.extend(offsets);
     }
 
     fn set_pipeline(
         &mut self,
         index_format: Option<wgt::IndexFormat>,
-        vertex_strides: &[(wgt::BufferAddress, wgt::InputStepMode)],
+        vertex_strides: &[(wgt::BufferAddress, wgt::VertexStepMode)],
         layout_ids: &[id::Valid<id::BindGroupLayoutId>],
         push_constant_layouts: &[wgt::PushConstantRange],
     ) {
         self.index.pipeline_format = index_format;
 
         for (vs, &(stride, step_mode)) in self.vertex.iter_mut().zip(vertex_strides) {
             if vs.stride != stride || vs.rate != step_mode {
                 vs.stride = stride;
@@ -1109,16 +1126,18 @@ pub(super) enum RenderBundleErrorInner {
     #[error(transparent)]
     Device(#[from] DeviceError),
     #[error(transparent)]
     RenderCommand(RenderCommandError),
     #[error(transparent)]
     ResourceUsageConflict(#[from] UsageConflict),
     #[error(transparent)]
     Draw(#[from] DrawError),
+    #[error(transparent)]
+    MissingDownlevelFlags(#[from] MissingDownlevelFlags),
 }
 
 impl<T> From<T> for RenderBundleErrorInner
 where
     T: Into<RenderCommandError>,
 {
     fn from(t: T) -> Self {
         Self::RenderCommand(t.into())
@@ -1135,16 +1154,24 @@ pub struct RenderBundleError {
 }
 
 impl RenderBundleError {
     pub(crate) const INVALID_DEVICE: Self = RenderBundleError {
         scope: PassErrorScope::Bundle,
         inner: RenderBundleErrorInner::Device(DeviceError::Invalid),
     };
 }
+impl PrettyError for RenderBundleError {
+    fn fmt_pretty(&self, fmt: &mut ErrorFormatter) {
+        // This error is wrapper for the inner error,
+        // but the scope has useful labels
+        fmt.error(self);
+        self.scope.fmt_pretty(fmt);
+    }
+}
 
 impl<T, E> MapPassErr<T, RenderBundleError> for Result<T, E>
 where
     E: Into<RenderBundleErrorInner>,
 {
     fn map_pass_err(self, scope: PassErrorScope) -> Result<T, RenderBundleError> {
         self.map_err(|inner| RenderBundleError {
             scope,
@@ -1213,17 +1240,17 @@ pub mod bundle_ffi {
 
     /// # Safety
     ///
     /// This function is unsafe as there is no guarantee that the given pointer is
     /// valid for `data` elements.
     #[no_mangle]
     pub unsafe extern "C" fn wgpu_render_bundle_set_push_constants(
         pass: &mut RenderBundleEncoder,
-        stages: wgt::ShaderStage,
+        stages: wgt::ShaderStages,
         offset: u32,
         size_bytes: u32,
         data: *const u8,
     ) {
         assert_eq!(
             offset & (wgt::PUSH_CONSTANT_ALIGNMENT - 1),
             0,
             "Push constant offset must be aligned to 4 bytes."