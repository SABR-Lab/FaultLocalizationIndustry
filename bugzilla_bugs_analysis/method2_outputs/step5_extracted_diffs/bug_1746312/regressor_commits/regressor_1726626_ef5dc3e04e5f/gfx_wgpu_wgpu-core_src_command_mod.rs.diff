# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/command/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/command/mod.rs b/third_party/rust/wgpu-core/src/command/mod.rs
rename from gfx/wgpu/wgpu-core/src/command/mod.rs
rename to third_party/rust/wgpu-core/src/command/mod.rs
--- a/gfx/wgpu/wgpu-core/src/command/mod.rs
+++ b/third_party/rust/wgpu-core/src/command/mod.rs
@@ -1,77 +1,235 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-mod allocator;
 mod bind;
 mod bundle;
 mod clear;
 mod compute;
 mod draw;
 mod query;
 mod render;
 mod transfer;
 
-pub(crate) use self::allocator::CommandAllocator;
-pub use self::allocator::CommandAllocatorError;
+use std::collections::hash_map::Entry;
+use std::ops::Range;
+
 pub use self::bundle::*;
 pub use self::compute::*;
 pub use self::draw::*;
 pub use self::query::*;
 pub use self::render::*;
 pub use self::transfer::*;
 
+use crate::error::{ErrorFormatter, PrettyError};
+use crate::FastHashMap;
 use crate::{
-    device::{all_buffer_stages, all_image_stages},
-    hub::{GfxBackend, Global, GlobalIdentityHandlerFactory, Storage, Token},
+    hub::{Global, GlobalIdentityHandlerFactory, HalApi, Storage, Token},
     id,
-    memory_init_tracker::MemoryInitTrackerAction,
+    init_tracker::{BufferInitTrackerAction, MemoryInitKind},
     resource::{Buffer, Texture},
     track::{BufferState, ResourceTracker, TextureState, TrackerSet},
-    Label, PrivateFeatures, Stored,
+    Label, Stored,
 };
 
-use hal::command::CommandBuffer as _;
-use smallvec::SmallVec;
+use hal::CommandEncoder as _;
 use thiserror::Error;
 
-use std::thread::ThreadId;
-
 const PUSH_CONSTANT_CLEAR_ARRAY: &[u32] = &[0_u32; 64];
 
 #[derive(Debug)]
 enum CommandEncoderStatus {
     Recording,
     Finished,
     Error,
 }
 
-#[derive(Debug)]
-pub struct CommandBuffer<B: hal::Backend> {
-    pub(crate) raw: Vec<B::CommandBuffer>,
+struct CommandEncoder<A: hal::Api> {
+    raw: A::CommandEncoder,
+    list: Vec<A::CommandBuffer>,
+    is_open: bool,
+    label: Option<String>,
+}
+
+//TODO: handle errors better
+impl<A: hal::Api> CommandEncoder<A> {
+    fn close(&mut self) {
+        if self.is_open {
+            self.is_open = false;
+            let cmd_buf = unsafe { self.raw.end_encoding().unwrap() };
+            self.list.push(cmd_buf);
+        }
+    }
+
+    fn open(&mut self) -> &mut A::CommandEncoder {
+        if !self.is_open {
+            self.is_open = true;
+            let label = self.label.as_deref();
+            unsafe { self.raw.begin_encoding(label).unwrap() };
+        }
+        &mut self.raw
+    }
+}
+
+pub struct BakedCommands<A: hal::Api> {
+    pub(crate) encoder: A::CommandEncoder,
+    pub(crate) list: Vec<A::CommandBuffer>,
+    pub(crate) trackers: TrackerSet,
+    buffer_memory_init_actions: Vec<BufferInitTrackerAction>,
+}
+
+pub(crate) struct DestroyedBufferError(pub id::BufferId);
+
+impl<A: hal::Api> BakedCommands<A> {
+    pub(crate) fn initialize_buffer_memory(
+        &mut self,
+        device_tracker: &mut TrackerSet,
+        buffer_guard: &mut Storage<Buffer<A>, id::BufferId>,
+    ) -> Result<(), DestroyedBufferError> {
+        // Gather init ranges for each buffer so we can collapse them.
+        // It is not possible to do this at an earlier point since previously executed command buffer change the resource init state.
+        let mut uninitialized_ranges_per_buffer = FastHashMap::default();
+        for buffer_use in self.buffer_memory_init_actions.drain(..) {
+            let buffer = buffer_guard
+                .get_mut(buffer_use.id)
+                .map_err(|_| DestroyedBufferError(buffer_use.id))?;
+
+            let uninitialized_ranges = buffer.initialization_status.drain(buffer_use.range.clone());
+            match buffer_use.kind {
+                MemoryInitKind::ImplicitlyInitialized => {
+                    uninitialized_ranges.for_each(drop);
+                }
+                MemoryInitKind::NeedsInitializedMemory => {
+                    match uninitialized_ranges_per_buffer.entry(buffer_use.id) {
+                        Entry::Vacant(e) => {
+                            e.insert(
+                                uninitialized_ranges.collect::<Vec<Range<wgt::BufferAddress>>>(),
+                            );
+                        }
+                        Entry::Occupied(mut e) => {
+                            e.get_mut().extend(uninitialized_ranges);
+                        }
+                    }
+                }
+            }
+        }
+
+        for (buffer_id, mut ranges) in uninitialized_ranges_per_buffer {
+            // Collapse touching ranges.
+            ranges.sort_by(|a, b| a.start.cmp(&b.start));
+            for i in (1..ranges.len()).rev() {
+                assert!(ranges[i - 1].end <= ranges[i].start); // The memory init tracker made sure of this!
+                if ranges[i].start == ranges[i - 1].end {
+                    ranges[i - 1].end = ranges[i].end;
+                    ranges.swap_remove(i); // Ordering not important at this point
+                }
+            }
+
+            // Don't do use_replace since the buffer may already no longer have a ref_count.
+            // However, we *know* that it is currently in use, so the tracker must already know about it.
+            let transition = device_tracker.buffers.change_replace_tracked(
+                id::Valid(buffer_id),
+                (),
+                hal::BufferUses::COPY_DST,
+            );
+
+            let buffer = buffer_guard
+                .get_mut(buffer_id)
+                .map_err(|_| DestroyedBufferError(buffer_id))?;
+            let raw_buf = buffer.raw.as_ref().ok_or(DestroyedBufferError(buffer_id))?;
+
+            unsafe {
+                self.encoder
+                    .transition_buffers(transition.map(|pending| pending.into_hal(buffer)));
+            }
+
+            for range in ranges.iter() {
+                assert!(range.start % 4 == 0, "Buffer {:?} has an uninitialized range with a start not aligned to 4 (start was {})", raw_buf, range.start);
+                assert!(range.end % 4 == 0, "Buffer {:?} has an uninitialized range with an end not aligned to 4 (end was {})", raw_buf, range.end);
+
+                unsafe {
+                    self.encoder.fill_buffer(raw_buf, range.clone(), 0);
+                }
+            }
+        }
+
+        Ok(())
+    }
+}
+
+pub struct CommandBuffer<A: hal::Api> {
+    encoder: CommandEncoder<A>,
     status: CommandEncoderStatus,
-    recorded_thread_id: ThreadId,
     pub(crate) device_id: Stored<id::DeviceId>,
     pub(crate) trackers: TrackerSet,
-    pub(crate) used_swap_chains: SmallVec<[Stored<id::SwapChainId>; 1]>,
-    pub(crate) buffer_memory_init_actions: Vec<MemoryInitTrackerAction<id::BufferId>>,
+    buffer_memory_init_actions: Vec<BufferInitTrackerAction>,
     limits: wgt::Limits,
-    downlevel: wgt::DownlevelProperties,
-    private_features: PrivateFeatures,
     support_fill_buffer_texture: bool,
-    has_labels: bool,
     #[cfg(feature = "trace")]
     pub(crate) commands: Option<Vec<crate::device::trace::Command>>,
-    #[cfg(debug_assertions)]
-    pub(crate) label: String,
 }
 
-impl<B: GfxBackend> CommandBuffer<B> {
+impl<A: HalApi> CommandBuffer<A> {
+    pub(crate) fn new(
+        encoder: A::CommandEncoder,
+        device_id: Stored<id::DeviceId>,
+        limits: wgt::Limits,
+        _downlevel: wgt::DownlevelCapabilities,
+        features: wgt::Features,
+        #[cfg(feature = "trace")] enable_tracing: bool,
+        label: &Label,
+    ) -> Self {
+        CommandBuffer {
+            encoder: CommandEncoder {
+                raw: encoder,
+                is_open: false,
+                list: Vec::new(),
+                label: crate::LabelHelpers::borrow_option(label).map(|s| s.to_string()),
+            },
+            status: CommandEncoderStatus::Recording,
+            device_id,
+            trackers: TrackerSet::new(A::VARIANT),
+            buffer_memory_init_actions: Default::default(),
+            limits,
+            support_fill_buffer_texture: features.contains(wgt::Features::CLEAR_COMMANDS),
+            #[cfg(feature = "trace")]
+            commands: if enable_tracing {
+                Some(Vec::new())
+            } else {
+                None
+            },
+        }
+    }
+
+    pub(crate) fn insert_barriers(
+        raw: &mut A::CommandEncoder,
+        base: &mut TrackerSet,
+        head_buffers: &ResourceTracker<BufferState>,
+        head_textures: &ResourceTracker<TextureState>,
+        buffer_guard: &Storage<Buffer<A>, id::BufferId>,
+        texture_guard: &Storage<Texture<A>, id::TextureId>,
+    ) {
+        profiling::scope!("insert_barriers");
+        debug_assert_eq!(A::VARIANT, base.backend());
+
+        let buffer_barriers = base.buffers.merge_replace(head_buffers).map(|pending| {
+            let buf = &buffer_guard[pending.id];
+            pending.into_hal(buf)
+        });
+        let texture_barriers = base.textures.merge_replace(head_textures).map(|pending| {
+            let tex = &texture_guard[pending.id];
+            pending.into_hal(tex)
+        });
+
+        unsafe {
+            raw.transition_buffers(buffer_barriers);
+            raw.transition_textures(texture_barriers);
+        }
+    }
+}
+
+impl<A: hal::Api> CommandBuffer<A> {
     fn get_encoder_mut(
         storage: &mut Storage<Self, id::CommandEncoderId>,
         id: id::CommandEncoderId,
     ) -> Result<&mut Self, CommandEncoderError> {
         match storage.get_mut(id) {
             Ok(cmd_buf) => match cmd_buf.status {
                 CommandEncoderStatus::Recording => Ok(cmd_buf),
                 CommandEncoderStatus::Finished => Err(CommandEncoderError::NotRecording),
@@ -83,62 +241,35 @@ impl<B: GfxBackend> CommandBuffer<B> {
 
     pub fn is_finished(&self) -> bool {
         match self.status {
             CommandEncoderStatus::Finished => true,
             _ => false,
         }
     }
 
-    pub(crate) fn insert_barriers(
-        raw: &mut B::CommandBuffer,
-        base: &mut TrackerSet,
-        head_buffers: &ResourceTracker<BufferState>,
-        head_textures: &ResourceTracker<TextureState>,
-        buffer_guard: &Storage<Buffer<B>, id::BufferId>,
-        texture_guard: &Storage<Texture<B>, id::TextureId>,
-    ) {
-        use hal::command::CommandBuffer as _;
-
-        profiling::scope!("insert_barriers");
-        debug_assert_eq!(B::VARIANT, base.backend());
-
-        let buffer_barriers = base.buffers.merge_replace(head_buffers).map(|pending| {
-            let buf = &buffer_guard[pending.id];
-            pending.into_hal(buf)
-        });
-        let texture_barriers = base.textures.merge_replace(head_textures).map(|pending| {
-            let tex = &texture_guard[pending.id];
-            pending.into_hal(tex)
-        });
-
-        //TODO: be more deliberate about the stages
-        let stages = all_buffer_stages() | all_image_stages();
-        unsafe {
-            raw.pipeline_barrier(
-                stages..stages,
-                hal::memory::Dependencies::empty(),
-                buffer_barriers.chain(texture_barriers),
-            );
+    pub(crate) fn into_baked(self) -> BakedCommands<A> {
+        BakedCommands {
+            encoder: self.encoder.raw,
+            list: self.encoder.list,
+            trackers: self.trackers,
+            buffer_memory_init_actions: self.buffer_memory_init_actions,
         }
     }
 }
 
-impl<B: hal::Backend> crate::hub::Resource for CommandBuffer<B> {
+impl<A: hal::Api> crate::hub::Resource for CommandBuffer<A> {
     const TYPE: &'static str = "CommandBuffer";
 
     fn life_guard(&self) -> &crate::LifeGuard {
         unreachable!()
     }
 
     fn label(&self) -> &str {
-        #[cfg(debug_assertions)]
-        return &self.label;
-        #[cfg(not(debug_assertions))]
-        return "";
+        self.encoder.label.as_ref().map_or("", |s| s.as_str())
     }
 }
 
 #[derive(Copy, Clone, Debug)]
 pub struct BasePassRef<'a, C> {
     pub label: Option<&'a str>,
     pub commands: &'a [C],
     pub dynamic_offsets: &'a [wgt::DynamicOffset],
@@ -201,101 +332,94 @@ impl<C: Clone> BasePass<C> {
 pub enum CommandEncoderError {
     #[error("command encoder is invalid")]
     Invalid,
     #[error("command encoder must be active")]
     NotRecording,
 }
 
 impl<G: GlobalIdentityHandlerFactory> Global<G> {
-    pub fn command_encoder_finish<B: GfxBackend>(
+    pub fn command_encoder_finish<A: HalApi>(
         &self,
         encoder_id: id::CommandEncoderId,
         _desc: &wgt::CommandBufferDescriptor<Label>,
     ) -> (id::CommandBufferId, Option<CommandEncoderError>) {
         profiling::scope!("finish", "CommandEncoder");
 
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
-        let (swap_chain_guard, mut token) = hub.swap_chains.read(&mut token);
-        //TODO: actually close the last recorded command buffer
         let (mut cmd_buf_guard, _) = hub.command_buffers.write(&mut token);
 
         let error = match CommandBuffer::get_encoder_mut(&mut *cmd_buf_guard, encoder_id) {
             Ok(cmd_buf) => {
+                cmd_buf.encoder.close();
                 cmd_buf.status = CommandEncoderStatus::Finished;
-                // stop tracking the swapchain image, if used
-                for sc_id in cmd_buf.used_swap_chains.iter() {
-                    let view_id = swap_chain_guard[sc_id.value]
-                        .acquired_view_id
-                        .as_ref()
-                        .expect("Used swap chain frame has already presented");
-                    cmd_buf.trackers.views.remove(view_id.value);
-                }
+                //Note: if we want to stop tracking the swapchain texture view,
+                // this is the place to do it.
                 log::trace!("Command buffer {:?} {:#?}", encoder_id, cmd_buf.trackers);
                 None
             }
             Err(e) => Some(e),
         };
 
         (encoder_id, error)
     }
 
-    pub fn command_encoder_push_debug_group<B: GfxBackend>(
+    pub fn command_encoder_push_debug_group<A: HalApi>(
         &self,
         encoder_id: id::CommandEncoderId,
         label: &str,
     ) -> Result<(), CommandEncoderError> {
         profiling::scope!("push_debug_group", "CommandEncoder");
 
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
 
         let (mut cmd_buf_guard, _) = hub.command_buffers.write(&mut token);
         let cmd_buf = CommandBuffer::get_encoder_mut(&mut *cmd_buf_guard, encoder_id)?;
-        let cmd_buf_raw = cmd_buf.raw.last_mut().unwrap();
+        let cmd_buf_raw = cmd_buf.encoder.open();
 
         unsafe {
-            cmd_buf_raw.begin_debug_marker(label, 0);
+            cmd_buf_raw.begin_debug_marker(label);
         }
         Ok(())
     }
 
-    pub fn command_encoder_insert_debug_marker<B: GfxBackend>(
+    pub fn command_encoder_insert_debug_marker<A: HalApi>(
         &self,
         encoder_id: id::CommandEncoderId,
         label: &str,
     ) -> Result<(), CommandEncoderError> {
         profiling::scope!("insert_debug_marker", "CommandEncoder");
 
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
 
         let (mut cmd_buf_guard, _) = hub.command_buffers.write(&mut token);
         let cmd_buf = CommandBuffer::get_encoder_mut(&mut *cmd_buf_guard, encoder_id)?;
-        let cmd_buf_raw = cmd_buf.raw.last_mut().unwrap();
+        let cmd_buf_raw = cmd_buf.encoder.open();
 
         unsafe {
-            cmd_buf_raw.insert_debug_marker(label, 0);
+            cmd_buf_raw.insert_debug_marker(label);
         }
         Ok(())
     }
 
-    pub fn command_encoder_pop_debug_group<B: GfxBackend>(
+    pub fn command_encoder_pop_debug_group<A: HalApi>(
         &self,
         encoder_id: id::CommandEncoderId,
     ) -> Result<(), CommandEncoderError> {
         profiling::scope!("pop_debug_marker", "CommandEncoder");
 
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
 
         let (mut cmd_buf_guard, _) = hub.command_buffers.write(&mut token);
         let cmd_buf = CommandBuffer::get_encoder_mut(&mut *cmd_buf_guard, encoder_id)?;
-        let cmd_buf_raw = cmd_buf.raw.last_mut().unwrap();
+        let cmd_buf_raw = cmd_buf.encoder.open();
 
         unsafe {
             cmd_buf_raw.end_debug_marker();
         }
         Ok(())
     }
 }
 
@@ -386,8 +510,45 @@ pub enum PassErrorScope {
     #[error("In a dispatch command, indirect:{indirect}")]
     Dispatch {
         indirect: bool,
         pipeline: Option<id::ComputePipelineId>,
     },
     #[error("In a pop_debug_group command")]
     PopDebugGroup,
 }
+
+impl PrettyError for PassErrorScope {
+    fn fmt_pretty(&self, fmt: &mut ErrorFormatter) {
+        // This error is not in the error chain, only notes are needed
+        match *self {
+            Self::Pass(id) => {
+                fmt.command_buffer_label(&id);
+            }
+            Self::SetBindGroup(id) => {
+                fmt.bind_group_label(&id);
+            }
+            Self::SetPipelineRender(id) => {
+                fmt.render_pipeline_label(&id);
+            }
+            Self::SetPipelineCompute(id) => {
+                fmt.compute_pipeline_label(&id);
+            }
+            Self::SetVertexBuffer(id) => {
+                fmt.buffer_label(&id);
+            }
+            Self::SetIndexBuffer(id) => {
+                fmt.buffer_label(&id);
+            }
+            Self::Draw {
+                pipeline: Some(id), ..
+            } => {
+                fmt.render_pipeline_label(&id);
+            }
+            Self::Dispatch {
+                pipeline: Some(id), ..
+            } => {
+                fmt.compute_pipeline_label(&id);
+            }
+            _ => {}
+        }
+    }
+}