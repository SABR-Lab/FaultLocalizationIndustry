# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/command/query.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/command/query.rs b/third_party/rust/wgpu-core/src/command/query.rs
rename from gfx/wgpu/wgpu-core/src/command/query.rs
rename to third_party/rust/wgpu-core/src/command/query.rs
--- a/gfx/wgpu/wgpu-core/src/command/query.rs
+++ b/third_party/rust/wgpu-core/src/command/query.rs
@@ -1,62 +1,57 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-use hal::command::CommandBuffer as _;
+use hal::CommandEncoder as _;
 
 #[cfg(feature = "trace")]
 use crate::device::trace::Command as TraceCommand;
 use crate::{
     command::{CommandBuffer, CommandEncoderError},
-    device::all_buffer_stages,
-    hub::{GfxBackend, Global, GlobalIdentityHandlerFactory, Storage, Token},
+    hub::{Global, GlobalIdentityHandlerFactory, HalApi, Storage, Token},
     id::{self, Id, TypedId},
-    memory_init_tracker::{MemoryInitKind, MemoryInitTrackerAction},
-    resource::{BufferUse, QuerySet},
+    init_tracker::MemoryInitKind,
+    resource::QuerySet,
     track::UseExtendError,
     Epoch, FastHashMap, Index,
 };
 use std::{iter, marker::PhantomData};
 use thiserror::Error;
 use wgt::BufferAddress;
 
 #[derive(Debug)]
-pub(super) struct QueryResetMap<B: hal::Backend> {
+pub(super) struct QueryResetMap<A: hal::Api> {
     map: FastHashMap<Index, (Vec<bool>, Epoch)>,
-    _phantom: PhantomData<B>,
+    _phantom: PhantomData<A>,
 }
-impl<B: hal::Backend> QueryResetMap<B> {
+impl<A: hal::Api> QueryResetMap<A> {
     pub fn new() -> Self {
         Self {
             map: FastHashMap::default(),
             _phantom: PhantomData,
         }
     }
 
     pub fn use_query_set(
         &mut self,
         id: id::QuerySetId,
-        query_set: &QuerySet<B>,
+        query_set: &QuerySet<A>,
         query: u32,
     ) -> bool {
         let (index, epoch, _) = id.unzip();
         let vec_pair = self
             .map
             .entry(index)
             .or_insert_with(|| (vec![false; query_set.desc.count as usize], epoch));
 
         std::mem::replace(&mut vec_pair.0[query as usize], true)
     }
 
     pub fn reset_queries(
         self,
-        cmd_buf_raw: &mut B::CommandBuffer,
-        query_set_storage: &Storage<QuerySet<B>, id::QuerySetId>,
+        raw_encoder: &mut A::CommandEncoder,
+        query_set_storage: &Storage<QuerySet<A>, id::QuerySetId>,
         backend: wgt::Backend,
     ) -> Result<(), id::QuerySetId> {
         for (query_set_id, (state, epoch)) in self.map.into_iter() {
             let id = Id::zip(query_set_id, epoch, backend);
             let query_set = query_set_storage.get(id).map_err(|_| id)?;
 
             debug_assert_eq!(state.len(), query_set.desc.count as usize);
 
@@ -66,17 +61,17 @@ impl<B: hal::Backend> QueryResetMap<B> {
             let mut run_start: Option<u32> = None;
             for (idx, value) in state.into_iter().chain(iter::once(false)).enumerate() {
                 match (run_start, value) {
                     // We're inside of a run, do nothing
                     (Some(..), true) => {}
                     // We've hit the end of a run, dispatch a reset
                     (Some(start), false) => {
                         run_start = None;
-                        unsafe { cmd_buf_raw.reset_query_pool(&query_set.raw, start..idx as u32) };
+                        unsafe { raw_encoder.reset_queries(&query_set.raw, start..idx as u32) };
                     }
                     // We're starting a run
                     (None, true) => {
                         run_start = Some(idx as u32);
                     }
                     // We're in a run of falses, do nothing.
                     (None, false) => {}
                 }
@@ -84,22 +79,24 @@ impl<B: hal::Backend> QueryResetMap<B> {
         }
 
         Ok(())
     }
 }
 
 #[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub enum SimplifiedQueryType {
+    Occlusion,
     Timestamp,
     PipelineStatistics,
 }
 impl From<wgt::QueryType> for SimplifiedQueryType {
     fn from(q: wgt::QueryType) -> Self {
         match q {
+            wgt::QueryType::Occlusion => SimplifiedQueryType::Occlusion,
             wgt::QueryType::Timestamp => SimplifiedQueryType::Timestamp,
             wgt::QueryType::PipelineStatistics(..) => SimplifiedQueryType::PipelineStatistics,
         }
     }
 }
 
 /// Error encountered when dealing with queries
 #[derive(Clone, Debug, Error)]
@@ -140,16 +137,18 @@ pub enum QueryUseError {
     },
 }
 
 /// Error encountered while trying to resolve a query.
 #[derive(Clone, Debug, Error)]
 pub enum ResolveError {
     #[error("Queries can only be resolved to buffers that contain the COPY_DST usage")]
     MissingBufferUsage,
+    #[error("Resolve buffer offset has to be aligned to `QUERY_RESOLVE_BUFFER_ALIGNMENT")]
+    BufferOffsetAlignment,
     #[error("Resolving queries {start_query}..{end_query} would overrun the query set of size {query_set_size}")]
     QueryOverrun {
         start_query: u32,
         end_query: u32,
         query_set_size: u32,
     },
     #[error("Resolving queries {start_query}..{end_query} ({stride} byte queries) will end up overrunning the bounds of the destination buffer of size {buffer_size} using offsets {buffer_start_offset}..{buffer_end_offset}")]
     BufferOverrun {
@@ -157,24 +156,24 @@ pub enum ResolveError {
         end_query: u32,
         stride: u32,
         buffer_size: BufferAddress,
         buffer_start_offset: BufferAddress,
         buffer_end_offset: BufferAddress,
     },
 }
 
-impl<B: GfxBackend> QuerySet<B> {
+impl<A: HalApi> QuerySet<A> {
     fn validate_query(
         &self,
         query_set_id: id::QuerySetId,
         query_type: SimplifiedQueryType,
         query_index: u32,
-        reset_state: Option<&mut QueryResetMap<B>>,
-    ) -> Result<hal::query::Query<'_, B>, QueryUseError> {
+        reset_state: Option<&mut QueryResetMap<A>>,
+    ) -> Result<&A::QuerySet, QueryUseError> {
         // We need to defer our resets because we are in a renderpass, add the usage to the reset map.
         if let Some(reset) = reset_state {
             let used = reset.use_query_set(query_set_id, self, query_index);
             if used {
                 return Err(QueryUseError::UsedTwiceInsideRenderpass { query_index });
             }
         }
 
@@ -188,122 +187,112 @@ impl<B: GfxBackend> QuerySet<B> {
 
         if query_index >= self.desc.count {
             return Err(QueryUseError::OutOfBounds {
                 query_index,
                 query_set_size: self.desc.count,
             });
         }
 
-        let hal_query = hal::query::Query::<B> {
-            pool: &self.raw,
-            id: query_index,
-        };
-
-        Ok(hal_query)
+        Ok(&self.raw)
     }
 
     pub(super) fn validate_and_write_timestamp(
         &self,
-        cmd_buf_raw: &mut B::CommandBuffer,
+        raw_encoder: &mut A::CommandEncoder,
         query_set_id: id::QuerySetId,
         query_index: u32,
-        reset_state: Option<&mut QueryResetMap<B>>,
+        reset_state: Option<&mut QueryResetMap<A>>,
     ) -> Result<(), QueryUseError> {
         let needs_reset = reset_state.is_none();
-        let hal_query = self.validate_query(
+        let query_set = self.validate_query(
             query_set_id,
             SimplifiedQueryType::Timestamp,
             query_index,
             reset_state,
         )?;
 
         unsafe {
             // If we don't have a reset state tracker which can defer resets, we must reset now.
             if needs_reset {
-                cmd_buf_raw.reset_query_pool(&self.raw, query_index..(query_index + 1));
+                raw_encoder.reset_queries(&self.raw, query_index..(query_index + 1));
             }
-            cmd_buf_raw.write_timestamp(hal::pso::PipelineStage::BOTTOM_OF_PIPE, hal_query);
+            raw_encoder.write_timestamp(query_set, query_index);
         }
 
         Ok(())
     }
 
     pub(super) fn validate_and_begin_pipeline_statistics_query(
         &self,
-        cmd_buf_raw: &mut B::CommandBuffer,
+        raw_encoder: &mut A::CommandEncoder,
         query_set_id: id::QuerySetId,
         query_index: u32,
-        reset_state: Option<&mut QueryResetMap<B>>,
+        reset_state: Option<&mut QueryResetMap<A>>,
         active_query: &mut Option<(id::QuerySetId, u32)>,
     ) -> Result<(), QueryUseError> {
         let needs_reset = reset_state.is_none();
-        let hal_query = self.validate_query(
+        let query_set = self.validate_query(
             query_set_id,
             SimplifiedQueryType::PipelineStatistics,
             query_index,
             reset_state,
         )?;
 
         if let Some((_old_id, old_idx)) = active_query.replace((query_set_id, query_index)) {
             return Err(QueryUseError::AlreadyStarted {
                 active_query_index: old_idx,
                 new_query_index: query_index,
             });
         }
 
         unsafe {
             // If we don't have a reset state tracker which can defer resets, we must reset now.
             if needs_reset {
-                cmd_buf_raw.reset_query_pool(&self.raw, query_index..(query_index + 1));
+                raw_encoder.reset_queries(&self.raw, query_index..(query_index + 1));
             }
-            cmd_buf_raw.begin_query(hal_query, hal::query::ControlFlags::empty());
+            raw_encoder.begin_query(query_set, query_index);
         }
 
         Ok(())
     }
 }
 
-pub(super) fn end_pipeline_statistics_query<B: GfxBackend>(
-    cmd_buf_raw: &mut B::CommandBuffer,
-    storage: &Storage<QuerySet<B>, id::QuerySetId>,
+pub(super) fn end_pipeline_statistics_query<A: HalApi>(
+    raw_encoder: &mut A::CommandEncoder,
+    storage: &Storage<QuerySet<A>, id::QuerySetId>,
     active_query: &mut Option<(id::QuerySetId, u32)>,
 ) -> Result<(), QueryUseError> {
     if let Some((query_set_id, query_index)) = active_query.take() {
         // We can unwrap here as the validity was validated when the active query was set
         let query_set = storage.get(query_set_id).unwrap();
 
-        let hal_query = hal::query::Query::<B> {
-            pool: &query_set.raw,
-            id: query_index,
-        };
-
-        unsafe { cmd_buf_raw.end_query(hal_query) }
+        unsafe { raw_encoder.end_query(&query_set.raw, query_index) };
 
         Ok(())
     } else {
         Err(QueryUseError::AlreadyStopped)
     }
 }
 
 impl<G: GlobalIdentityHandlerFactory> Global<G> {
-    pub fn command_encoder_write_timestamp<B: GfxBackend>(
+    pub fn command_encoder_write_timestamp<A: HalApi>(
         &self,
         command_encoder_id: id::CommandEncoderId,
         query_set_id: id::QuerySetId,
         query_index: u32,
     ) -> Result<(), QueryError> {
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
 
         let (mut cmd_buf_guard, mut token) = hub.command_buffers.write(&mut token);
         let (query_set_guard, _) = hub.query_sets.read(&mut token);
 
         let cmd_buf = CommandBuffer::get_encoder_mut(&mut cmd_buf_guard, command_encoder_id)?;
-        let cmd_buf_raw = cmd_buf.raw.last_mut().unwrap();
+        let raw_encoder = cmd_buf.encoder.open();
 
         #[cfg(feature = "trace")]
         if let Some(ref mut list) = cmd_buf.commands {
             list.push(TraceCommand::WriteTimestamp {
                 query_set_id,
                 query_index,
             });
         }
@@ -312,82 +301,87 @@ impl<G: GlobalIdentityHandlerFactory> Gl
             .trackers
             .query_sets
             .use_extend(&*query_set_guard, query_set_id, (), ())
             .map_err(|e| match e {
                 UseExtendError::InvalidResource => QueryError::InvalidQuerySet(query_set_id),
                 _ => unreachable!(),
             })?;
 
-        query_set.validate_and_write_timestamp(cmd_buf_raw, query_set_id, query_index, None)?;
+        query_set.validate_and_write_timestamp(raw_encoder, query_set_id, query_index, None)?;
 
         Ok(())
     }
 
-    pub fn command_encoder_resolve_query_set<B: GfxBackend>(
+    pub fn command_encoder_resolve_query_set<A: HalApi>(
         &self,
         command_encoder_id: id::CommandEncoderId,
         query_set_id: id::QuerySetId,
         start_query: u32,
         query_count: u32,
         destination: id::BufferId,
         destination_offset: BufferAddress,
     ) -> Result<(), QueryError> {
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         let mut token = Token::root();
 
         let (mut cmd_buf_guard, mut token) = hub.command_buffers.write(&mut token);
         let (query_set_guard, mut token) = hub.query_sets.read(&mut token);
         let (buffer_guard, _) = hub.buffers.read(&mut token);
 
         let cmd_buf = CommandBuffer::get_encoder_mut(&mut cmd_buf_guard, command_encoder_id)?;
-        let cmd_buf_raw = cmd_buf.raw.last_mut().unwrap();
+        let raw_encoder = cmd_buf.encoder.open();
 
         #[cfg(feature = "trace")]
         if let Some(ref mut list) = cmd_buf.commands {
             list.push(TraceCommand::ResolveQuerySet {
                 query_set_id,
                 start_query,
                 query_count,
                 destination,
                 destination_offset,
             });
         }
 
+        if destination_offset % wgt::QUERY_RESOLVE_BUFFER_ALIGNMENT != 0 {
+            return Err(QueryError::Resolve(ResolveError::BufferOffsetAlignment));
+        }
+
         let query_set = cmd_buf
             .trackers
             .query_sets
             .use_extend(&*query_set_guard, query_set_id, (), ())
             .map_err(|e| match e {
                 UseExtendError::InvalidResource => QueryError::InvalidQuerySet(query_set_id),
                 _ => unreachable!(),
             })?;
 
         let (dst_buffer, dst_pending) = cmd_buf
             .trackers
             .buffers
-            .use_replace(&*buffer_guard, destination, (), BufferUse::COPY_DST)
+            .use_replace(&*buffer_guard, destination, (), hal::BufferUses::COPY_DST)
             .map_err(QueryError::InvalidBuffer)?;
         let dst_barrier = dst_pending.map(|pending| pending.into_hal(dst_buffer));
 
-        if !dst_buffer.usage.contains(wgt::BufferUsage::COPY_DST) {
+        if !dst_buffer.usage.contains(wgt::BufferUsages::COPY_DST) {
             return Err(ResolveError::MissingBufferUsage.into());
         }
 
         let end_query = start_query + query_count;
         if end_query > query_set.desc.count {
             return Err(ResolveError::QueryOverrun {
                 start_query,
                 end_query,
                 query_set_size: query_set.desc.count,
             }
             .into());
         }
 
         let elements_per_query = match query_set.desc.ty {
+            wgt::QueryType::Occlusion => 1,
             wgt::QueryType::PipelineStatistics(ps) => ps.bits().count_ones(),
             wgt::QueryType::Timestamp => 1,
         };
         let stride = elements_per_query * wgt::QUERY_SIZE;
         let bytes_used = (stride * query_count) as BufferAddress;
 
         let buffer_start_offset = destination_offset;
         let buffer_end_offset = buffer_start_offset + bytes_used;
@@ -399,38 +393,30 @@ impl<G: GlobalIdentityHandlerFactory> Gl
                 stride,
                 buffer_size: dst_buffer.size,
                 buffer_start_offset,
                 buffer_end_offset,
             }
             .into());
         }
 
-        cmd_buf.buffer_memory_init_actions.extend(
-            dst_buffer
-                .initialization_status
-                .check(buffer_start_offset..buffer_end_offset)
-                .map(|range| MemoryInitTrackerAction {
-                    id: destination,
-                    range,
-                    kind: MemoryInitKind::ImplicitlyInitialized,
-                }),
-        );
+        cmd_buf
+            .buffer_memory_init_actions
+            .extend(dst_buffer.initialization_status.create_action(
+                destination,
+                buffer_start_offset..buffer_end_offset,
+                MemoryInitKind::ImplicitlyInitialized,
+            ));
 
         unsafe {
-            cmd_buf_raw.pipeline_barrier(
-                all_buffer_stages()..hal::pso::PipelineStage::TRANSFER,
-                hal::memory::Dependencies::empty(),
-                dst_barrier,
-            );
-            cmd_buf_raw.copy_query_pool_results(
+            raw_encoder.transition_buffers(dst_barrier);
+            raw_encoder.copy_query_results(
                 &query_set.raw,
                 start_query..end_query,
-                &dst_buffer.raw.as_ref().unwrap().0,
+                dst_buffer.raw.as_ref().unwrap(),
                 destination_offset,
-                stride,
-                hal::query::ResultFlags::WAIT | hal::query::ResultFlags::BITS_64,
+                wgt::BufferSize::new_unchecked(stride as u64),
             );
         }
 
         Ok(())
     }
 }