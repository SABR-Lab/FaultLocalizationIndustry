# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/hub.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/hub.rs b/third_party/rust/wgpu-core/src/hub.rs
rename from gfx/wgpu/wgpu-core/src/hub.rs
rename to third_party/rust/wgpu-core/src/hub.rs
--- a/gfx/wgpu/wgpu-core/src/hub.rs
+++ b/third_party/rust/wgpu-core/src/hub.rs
@@ -1,37 +1,25 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 use crate::{
-    backend,
     binding_model::{BindGroup, BindGroupLayout, PipelineLayout},
     command::{CommandBuffer, RenderBundle},
     device::Device,
-    id::{
-        AdapterId, BindGroupId, BindGroupLayoutId, BufferId, CommandBufferId, ComputePipelineId,
-        DeviceId, PipelineLayoutId, RenderBundleId, RenderPipelineId, SamplerId, ShaderModuleId,
-        SurfaceId, SwapChainId, TextureId, TextureViewId, TypedId, Valid,
-    },
-    instance::{Adapter, Instance, Surface},
+    id,
+    instance::{Adapter, HalSurface, Instance, Surface},
     pipeline::{ComputePipeline, RenderPipeline, ShaderModule},
-    resource::{Buffer, Sampler, Texture, TextureView},
-    swap_chain::SwapChain,
+    resource::{Buffer, QuerySet, Sampler, Texture, TextureView},
     Epoch, Index,
 };
 
 use parking_lot::{Mutex, RwLock, RwLockReadGuard, RwLockWriteGuard};
 use wgt::Backend;
 
-use crate::id::QuerySetId;
-use crate::resource::QuerySet;
 #[cfg(debug_assertions)]
 use std::cell::Cell;
-use std::{fmt::Debug, marker::PhantomData, ops};
+use std::{fmt::Debug, marker::PhantomData, mem, ops};
 
 /// A simple structure to manage identities of objects.
 #[derive(Debug)]
 pub struct IdentityManager {
     free: Vec<Index>,
     epochs: Vec<Epoch>,
 }
 
@@ -47,29 +35,29 @@ impl Default for IdentityManager {
 impl IdentityManager {
     pub fn from_index(min_index: u32) -> Self {
         Self {
             free: (0..min_index).collect(),
             epochs: vec![1; min_index as usize],
         }
     }
 
-    pub fn alloc<I: TypedId>(&mut self, backend: Backend) -> I {
+    pub fn alloc<I: id::TypedId>(&mut self, backend: Backend) -> I {
         match self.free.pop() {
             Some(index) => I::zip(index, self.epochs[index as usize], backend),
             None => {
                 let epoch = 1;
                 let id = I::zip(self.epochs.len() as Index, epoch, backend);
                 self.epochs.push(epoch);
                 id
             }
         }
     }
 
-    pub fn free<I: TypedId + Debug>(&mut self, id: I) {
+    pub fn free<I: id::TypedId + Debug>(&mut self, id: I) {
         let (index, epoch, _backend) = id.unzip();
         // avoid doing this check in release
         if cfg!(debug_assertions) {
             assert!(!self.free.contains(&index));
         }
         let pe = &mut self.epochs[index as usize];
         assert_eq!(*pe, epoch);
         *pe += 1;
@@ -79,40 +67,54 @@ impl IdentityManager {
 
 #[derive(Debug)]
 enum Element<T> {
     Vacant,
     Occupied(T, Epoch),
     Error(Epoch, String),
 }
 
+#[derive(Clone, Debug, Default)]
+pub struct StorageReport {
+    pub num_occupied: usize,
+    pub num_vacant: usize,
+    pub num_error: usize,
+    pub element_size: usize,
+}
+
+impl StorageReport {
+    pub fn is_empty(&self) -> bool {
+        self.num_occupied + self.num_vacant + self.num_error == 0
+    }
+}
+
 #[derive(Clone, Debug)]
 pub(crate) struct InvalidId;
 
 #[derive(Debug)]
-pub struct Storage<T, I: TypedId> {
+pub struct Storage<T, I: id::TypedId> {
     map: Vec<Element<T>>,
     kind: &'static str,
     _phantom: PhantomData<I>,
 }
 
-impl<T, I: TypedId> ops::Index<Valid<I>> for Storage<T, I> {
+impl<T, I: id::TypedId> ops::Index<id::Valid<I>> for Storage<T, I> {
     type Output = T;
-    fn index(&self, id: Valid<I>) -> &T {
+    fn index(&self, id: id::Valid<I>) -> &T {
         self.get(id.0).unwrap()
     }
 }
 
-impl<T, I: TypedId> ops::IndexMut<Valid<I>> for Storage<T, I> {
-    fn index_mut(&mut self, id: Valid<I>) -> &mut T {
+impl<T, I: id::TypedId> ops::IndexMut<id::Valid<I>> for Storage<T, I> {
+    fn index_mut(&mut self, id: id::Valid<I>) -> &mut T {
         self.get_mut(id.0).unwrap()
     }
 }
 
-impl<T, I: TypedId> Storage<T, I> {
+impl<T, I: id::TypedId> Storage<T, I> {
     pub(crate) fn contains(&self, id: I) -> bool {
         let (index, epoch, _) = id.unzip();
         match self.map[index as usize] {
             Element::Vacant => false,
             Element::Occupied(_, storage_epoch) | Element::Error(storage_epoch, ..) => {
                 epoch == storage_epoch
             }
         }
@@ -193,17 +195,17 @@ impl<T, I: TypedId> Storage<T, I> {
                 Some(value)
             }
             Element::Error(..) => None,
             Element::Vacant => panic!("Cannot remove a vacant resource"),
         }
     }
 
     // Prevents panic on out of range access, allows Vacant elements.
-    pub(crate) fn try_remove(&mut self, id: I) -> Option<T> {
+    pub(crate) fn _try_remove(&mut self, id: I) -> Option<T> {
         let (index, epoch, _) = id.unzip();
         if index as usize >= self.map.len() {
             None
         } else if let Element::Occupied(value, storage_epoch) =
             std::mem::replace(&mut self.map[index as usize], Element::Vacant)
         {
             assert_eq!(epoch, storage_epoch);
             Some(value)
@@ -218,87 +220,99 @@ impl<T, I: TypedId> Storage<T, I> {
             .enumerate()
             .filter_map(move |(index, x)| match *x {
                 Element::Occupied(ref value, storage_epoch) => {
                     Some((I::zip(index as Index, storage_epoch, backend), value))
                 }
                 _ => None,
             })
     }
+
+    fn generate_report(&self) -> StorageReport {
+        let mut report = StorageReport {
+            element_size: mem::size_of::<T>(),
+            ..Default::default()
+        };
+        for element in self.map.iter() {
+            match *element {
+                Element::Occupied(..) => report.num_occupied += 1,
+                Element::Vacant => report.num_vacant += 1,
+                Element::Error(..) => report.num_error += 1,
+            }
+        }
+        report
+    }
 }
 
 /// Type system for enforcing the lock order on shared HUB structures.
-/// If type A implements `Access<B>`, that means we are allowed to proceed
+/// If type A implements `Access<A>`, that means we are allowed to proceed
 /// with locking resource `B` after we lock `A`.
 ///
 /// The implenentations basically describe the edges in a directed graph
 /// of lock transitions. As long as it doesn't have loops, we can have
 /// multiple concurrent paths on this graph (from multiple threads) without
 /// deadlocks, i.e. there is always a path whose next resource is not locked
 /// by some other path, at any time.
-pub trait Access<B> {}
+pub trait Access<A> {}
 
 pub enum Root {}
 //TODO: establish an order instead of declaring all the pairs.
 impl Access<Instance> for Root {}
 impl Access<Surface> for Root {}
 impl Access<Surface> for Instance {}
-impl<B: hal::Backend> Access<Adapter<B>> for Root {}
-impl<B: hal::Backend> Access<Adapter<B>> for Surface {}
-impl<B: hal::Backend> Access<Device<B>> for Root {}
-impl<B: hal::Backend> Access<Device<B>> for Surface {}
-impl<B: hal::Backend> Access<Device<B>> for Adapter<B> {}
-impl<B: hal::Backend> Access<SwapChain<B>> for Root {}
-impl<B: hal::Backend> Access<SwapChain<B>> for Device<B> {}
-impl<B: hal::Backend> Access<PipelineLayout<B>> for Root {}
-impl<B: hal::Backend> Access<PipelineLayout<B>> for Device<B> {}
-impl<B: hal::Backend> Access<PipelineLayout<B>> for RenderBundle {}
-impl<B: hal::Backend> Access<BindGroupLayout<B>> for Root {}
-impl<B: hal::Backend> Access<BindGroupLayout<B>> for Device<B> {}
-impl<B: hal::Backend> Access<BindGroupLayout<B>> for PipelineLayout<B> {}
-impl<B: hal::Backend> Access<BindGroup<B>> for Root {}
-impl<B: hal::Backend> Access<BindGroup<B>> for Device<B> {}
-impl<B: hal::Backend> Access<BindGroup<B>> for BindGroupLayout<B> {}
-impl<B: hal::Backend> Access<BindGroup<B>> for PipelineLayout<B> {}
-impl<B: hal::Backend> Access<BindGroup<B>> for CommandBuffer<B> {}
-impl<B: hal::Backend> Access<CommandBuffer<B>> for Root {}
-impl<B: hal::Backend> Access<CommandBuffer<B>> for Device<B> {}
-impl<B: hal::Backend> Access<CommandBuffer<B>> for SwapChain<B> {}
-impl<B: hal::Backend> Access<RenderBundle> for Device<B> {}
-impl<B: hal::Backend> Access<RenderBundle> for CommandBuffer<B> {}
-impl<B: hal::Backend> Access<ComputePipeline<B>> for Device<B> {}
-impl<B: hal::Backend> Access<ComputePipeline<B>> for BindGroup<B> {}
-impl<B: hal::Backend> Access<RenderPipeline<B>> for Device<B> {}
-impl<B: hal::Backend> Access<RenderPipeline<B>> for BindGroup<B> {}
-impl<B: hal::Backend> Access<RenderPipeline<B>> for ComputePipeline<B> {}
-impl<B: hal::Backend> Access<QuerySet<B>> for Root {}
-impl<B: hal::Backend> Access<QuerySet<B>> for Device<B> {}
-impl<B: hal::Backend> Access<QuerySet<B>> for CommandBuffer<B> {}
-impl<B: hal::Backend> Access<QuerySet<B>> for RenderPipeline<B> {}
-impl<B: hal::Backend> Access<QuerySet<B>> for ComputePipeline<B> {}
-impl<B: hal::Backend> Access<ShaderModule<B>> for Device<B> {}
-impl<B: hal::Backend> Access<ShaderModule<B>> for BindGroupLayout<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for Root {}
-impl<B: hal::Backend> Access<Buffer<B>> for Device<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for BindGroupLayout<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for BindGroup<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for CommandBuffer<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for ComputePipeline<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for RenderPipeline<B> {}
-impl<B: hal::Backend> Access<Buffer<B>> for QuerySet<B> {}
-impl<B: hal::Backend> Access<Texture<B>> for Root {}
-impl<B: hal::Backend> Access<Texture<B>> for Device<B> {}
-impl<B: hal::Backend> Access<Texture<B>> for Buffer<B> {}
-impl<B: hal::Backend> Access<TextureView<B>> for Root {}
-impl<B: hal::Backend> Access<TextureView<B>> for SwapChain<B> {}
-impl<B: hal::Backend> Access<TextureView<B>> for Device<B> {}
-impl<B: hal::Backend> Access<TextureView<B>> for Texture<B> {}
-impl<B: hal::Backend> Access<Sampler<B>> for Root {}
-impl<B: hal::Backend> Access<Sampler<B>> for Device<B> {}
-impl<B: hal::Backend> Access<Sampler<B>> for TextureView<B> {}
+impl<A: hal::Api> Access<Adapter<A>> for Root {}
+impl<A: hal::Api> Access<Adapter<A>> for Surface {}
+impl<A: hal::Api> Access<Device<A>> for Root {}
+impl<A: hal::Api> Access<Device<A>> for Surface {}
+impl<A: hal::Api> Access<Device<A>> for Adapter<A> {}
+impl<A: hal::Api> Access<PipelineLayout<A>> for Root {}
+impl<A: hal::Api> Access<PipelineLayout<A>> for Device<A> {}
+impl<A: hal::Api> Access<PipelineLayout<A>> for RenderBundle {}
+impl<A: hal::Api> Access<BindGroupLayout<A>> for Root {}
+impl<A: hal::Api> Access<BindGroupLayout<A>> for Device<A> {}
+impl<A: hal::Api> Access<BindGroupLayout<A>> for PipelineLayout<A> {}
+impl<A: hal::Api> Access<BindGroup<A>> for Root {}
+impl<A: hal::Api> Access<BindGroup<A>> for Device<A> {}
+impl<A: hal::Api> Access<BindGroup<A>> for BindGroupLayout<A> {}
+impl<A: hal::Api> Access<BindGroup<A>> for PipelineLayout<A> {}
+impl<A: hal::Api> Access<BindGroup<A>> for CommandBuffer<A> {}
+impl<A: hal::Api> Access<CommandBuffer<A>> for Root {}
+impl<A: hal::Api> Access<CommandBuffer<A>> for Device<A> {}
+impl<A: hal::Api> Access<RenderBundle> for Device<A> {}
+impl<A: hal::Api> Access<RenderBundle> for CommandBuffer<A> {}
+impl<A: hal::Api> Access<ComputePipeline<A>> for Device<A> {}
+impl<A: hal::Api> Access<ComputePipeline<A>> for BindGroup<A> {}
+impl<A: hal::Api> Access<RenderPipeline<A>> for Device<A> {}
+impl<A: hal::Api> Access<RenderPipeline<A>> for BindGroup<A> {}
+impl<A: hal::Api> Access<RenderPipeline<A>> for ComputePipeline<A> {}
+impl<A: hal::Api> Access<QuerySet<A>> for Root {}
+impl<A: hal::Api> Access<QuerySet<A>> for Device<A> {}
+impl<A: hal::Api> Access<QuerySet<A>> for CommandBuffer<A> {}
+impl<A: hal::Api> Access<QuerySet<A>> for RenderPipeline<A> {}
+impl<A: hal::Api> Access<QuerySet<A>> for ComputePipeline<A> {}
+impl<A: hal::Api> Access<QuerySet<A>> for Sampler<A> {}
+impl<A: hal::Api> Access<ShaderModule<A>> for Device<A> {}
+impl<A: hal::Api> Access<ShaderModule<A>> for BindGroupLayout<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for Root {}
+impl<A: hal::Api> Access<Buffer<A>> for Device<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for BindGroupLayout<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for BindGroup<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for CommandBuffer<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for ComputePipeline<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for RenderPipeline<A> {}
+impl<A: hal::Api> Access<Buffer<A>> for QuerySet<A> {}
+impl<A: hal::Api> Access<Texture<A>> for Root {}
+impl<A: hal::Api> Access<Texture<A>> for Device<A> {}
+impl<A: hal::Api> Access<Texture<A>> for Buffer<A> {}
+impl<A: hal::Api> Access<TextureView<A>> for Root {}
+impl<A: hal::Api> Access<TextureView<A>> for Device<A> {}
+impl<A: hal::Api> Access<TextureView<A>> for Texture<A> {}
+impl<A: hal::Api> Access<Sampler<A>> for Root {}
+impl<A: hal::Api> Access<Sampler<A>> for Device<A> {}
+impl<A: hal::Api> Access<Sampler<A>> for TextureView<A> {}
 
 #[cfg(debug_assertions)]
 thread_local! {
     static ACTIVE_TOKEN: Cell<u8> = Cell::new(0);
 }
 
 /// A permission token to lock resource `T` or anything after it,
 /// as defined by the `Access` implementations.
@@ -343,17 +357,17 @@ impl<'a, T> Drop for Token<'a, T> {
 }
 
 pub trait IdentityHandler<I>: Debug {
     type Input: Clone + Debug;
     fn process(&self, id: Self::Input, backend: Backend) -> I;
     fn free(&self, id: I);
 }
 
-impl<I: TypedId + Debug> IdentityHandler<I> for Mutex<IdentityManager> {
+impl<I: id::TypedId + Debug> IdentityHandler<I> for Mutex<IdentityManager> {
     type Input = PhantomData<I>;
     fn process(&self, _id: Self::Input, backend: Backend) -> I {
         self.lock().alloc(backend)
     }
     fn free(&self, id: I) {
         self.lock().free(id)
     }
 }
@@ -361,41 +375,40 @@ impl<I: TypedId + Debug> IdentityHandler
 pub trait IdentityHandlerFactory<I> {
     type Filter: IdentityHandler<I>;
     fn spawn(&self, min_index: Index) -> Self::Filter;
 }
 
 #[derive(Debug)]
 pub struct IdentityManagerFactory;
 
-impl<I: TypedId + Debug> IdentityHandlerFactory<I> for IdentityManagerFactory {
+impl<I: id::TypedId + Debug> IdentityHandlerFactory<I> for IdentityManagerFactory {
     type Filter = Mutex<IdentityManager>;
     fn spawn(&self, min_index: Index) -> Self::Filter {
         Mutex::new(IdentityManager::from_index(min_index))
     }
 }
 
 pub trait GlobalIdentityHandlerFactory:
-    IdentityHandlerFactory<AdapterId>
-    + IdentityHandlerFactory<DeviceId>
-    + IdentityHandlerFactory<SwapChainId>
-    + IdentityHandlerFactory<PipelineLayoutId>
-    + IdentityHandlerFactory<ShaderModuleId>
-    + IdentityHandlerFactory<BindGroupLayoutId>
-    + IdentityHandlerFactory<BindGroupId>
-    + IdentityHandlerFactory<CommandBufferId>
-    + IdentityHandlerFactory<RenderBundleId>
-    + IdentityHandlerFactory<RenderPipelineId>
-    + IdentityHandlerFactory<ComputePipelineId>
-    + IdentityHandlerFactory<QuerySetId>
-    + IdentityHandlerFactory<BufferId>
-    + IdentityHandlerFactory<TextureId>
-    + IdentityHandlerFactory<TextureViewId>
-    + IdentityHandlerFactory<SamplerId>
-    + IdentityHandlerFactory<SurfaceId>
+    IdentityHandlerFactory<id::AdapterId>
+    + IdentityHandlerFactory<id::DeviceId>
+    + IdentityHandlerFactory<id::PipelineLayoutId>
+    + IdentityHandlerFactory<id::ShaderModuleId>
+    + IdentityHandlerFactory<id::BindGroupLayoutId>
+    + IdentityHandlerFactory<id::BindGroupId>
+    + IdentityHandlerFactory<id::CommandBufferId>
+    + IdentityHandlerFactory<id::RenderBundleId>
+    + IdentityHandlerFactory<id::RenderPipelineId>
+    + IdentityHandlerFactory<id::ComputePipelineId>
+    + IdentityHandlerFactory<id::QuerySetId>
+    + IdentityHandlerFactory<id::BufferId>
+    + IdentityHandlerFactory<id::TextureId>
+    + IdentityHandlerFactory<id::TextureViewId>
+    + IdentityHandlerFactory<id::SamplerId>
+    + IdentityHandlerFactory<id::SurfaceId>
 {
 }
 
 impl GlobalIdentityHandlerFactory for IdentityManagerFactory {}
 
 pub type Input<G, I> = <<G as IdentityHandlerFactory<I>>::Filter as IdentityHandler<I>>::Input;
 
 pub trait Resource {
@@ -405,23 +418,23 @@ pub trait Resource {
         #[cfg(debug_assertions)]
         return &self.life_guard().label;
         #[cfg(not(debug_assertions))]
         return "";
     }
 }
 
 #[derive(Debug)]
-pub struct Registry<T: Resource, I: TypedId, F: IdentityHandlerFactory<I>> {
+pub struct Registry<T: Resource, I: id::TypedId, F: IdentityHandlerFactory<I>> {
     identity: F::Filter,
     data: RwLock<Storage<T, I>>,
     backend: Backend,
 }
 
-impl<T: Resource, I: TypedId, F: IdentityHandlerFactory<I>> Registry<T, I, F> {
+impl<T: Resource, I: id::TypedId, F: IdentityHandlerFactory<I>> Registry<T, I, F> {
     fn new(backend: Backend, factory: &F) -> Self {
         Self {
             identity: factory.spawn(0),
             data: RwLock::new(Storage {
                 map: Vec::new(),
                 kind: T::TYPE,
                 _phantom: PhantomData,
             }),
@@ -438,43 +451,43 @@ impl<T: Resource, I: TypedId, F: Identit
                 _phantom: PhantomData,
             }),
             backend: Backend::Empty,
         }
     }
 }
 
 #[must_use]
-pub(crate) struct FutureId<'a, I: TypedId, T> {
+pub(crate) struct FutureId<'a, I: id::TypedId, T> {
     id: I,
     data: &'a RwLock<Storage<T, I>>,
 }
 
-impl<I: TypedId + Copy, T> FutureId<'_, I, T> {
+impl<I: id::TypedId + Copy, T> FutureId<'_, I, T> {
     #[cfg(feature = "trace")]
     pub fn id(&self) -> I {
         self.id
     }
 
     pub fn into_id(self) -> I {
         self.id
     }
 
-    pub fn assign<'a, A: Access<T>>(self, value: T, _: &'a mut Token<A>) -> Valid<I> {
+    pub fn assign<'a, A: Access<T>>(self, value: T, _: &'a mut Token<A>) -> id::Valid<I> {
         self.data.write().insert(self.id, value);
-        Valid(self.id)
+        id::Valid(self.id)
     }
 
     pub fn assign_error<'a, A: Access<T>>(self, label: &str, _: &'a mut Token<A>) -> I {
         self.data.write().insert_error(self.id, label);
         self.id
     }
 }
 
-impl<T: Resource, I: TypedId + Copy, F: IdentityHandlerFactory<I>> Registry<T, I, F> {
+impl<T: Resource, I: id::TypedId + Copy, F: IdentityHandlerFactory<I>> Registry<T, I, F> {
     pub(crate) fn prepare(
         &self,
         id_in: <F::Filter as IdentityHandler<I>>::Input,
     ) -> FutureId<I, T> {
         FutureId {
             id: self.identity.process(id_in, self.backend),
             data: &self.data,
         }
@@ -532,138 +545,165 @@ impl<T: Resource, I: TypedId + Copy, F: 
                 type_name,
                 guard.label_for_invalid_id(id)
             ),
         }
     }
 }
 
 #[derive(Debug)]
-pub struct Hub<B: hal::Backend, F: GlobalIdentityHandlerFactory> {
-    pub adapters: Registry<Adapter<B>, AdapterId, F>,
-    pub devices: Registry<Device<B>, DeviceId, F>,
-    pub swap_chains: Registry<SwapChain<B>, SwapChainId, F>,
-    pub pipeline_layouts: Registry<PipelineLayout<B>, PipelineLayoutId, F>,
-    pub shader_modules: Registry<ShaderModule<B>, ShaderModuleId, F>,
-    pub bind_group_layouts: Registry<BindGroupLayout<B>, BindGroupLayoutId, F>,
-    pub bind_groups: Registry<BindGroup<B>, BindGroupId, F>,
-    pub command_buffers: Registry<CommandBuffer<B>, CommandBufferId, F>,
-    pub render_bundles: Registry<RenderBundle, RenderBundleId, F>,
-    pub render_pipelines: Registry<RenderPipeline<B>, RenderPipelineId, F>,
-    pub compute_pipelines: Registry<ComputePipeline<B>, ComputePipelineId, F>,
-    pub query_sets: Registry<QuerySet<B>, QuerySetId, F>,
-    pub buffers: Registry<Buffer<B>, BufferId, F>,
-    pub textures: Registry<Texture<B>, TextureId, F>,
-    pub texture_views: Registry<TextureView<B>, TextureViewId, F>,
-    pub samplers: Registry<Sampler<B>, SamplerId, F>,
+pub struct HubReport {
+    pub adapters: StorageReport,
+    pub devices: StorageReport,
+    pub pipeline_layouts: StorageReport,
+    pub shader_modules: StorageReport,
+    pub bind_group_layouts: StorageReport,
+    pub bind_groups: StorageReport,
+    pub command_buffers: StorageReport,
+    pub render_bundles: StorageReport,
+    pub render_pipelines: StorageReport,
+    pub compute_pipelines: StorageReport,
+    pub query_sets: StorageReport,
+    pub buffers: StorageReport,
+    pub textures: StorageReport,
+    pub texture_views: StorageReport,
+    pub samplers: StorageReport,
 }
 
-impl<B: GfxBackend, F: GlobalIdentityHandlerFactory> Hub<B, F> {
-    fn new(factory: &F) -> Self {
-        Self {
-            adapters: Registry::new(B::VARIANT, factory),
-            devices: Registry::new(B::VARIANT, factory),
-            swap_chains: Registry::new(B::VARIANT, factory),
-            pipeline_layouts: Registry::new(B::VARIANT, factory),
-            shader_modules: Registry::new(B::VARIANT, factory),
-            bind_group_layouts: Registry::new(B::VARIANT, factory),
-            bind_groups: Registry::new(B::VARIANT, factory),
-            command_buffers: Registry::new(B::VARIANT, factory),
-            render_bundles: Registry::new(B::VARIANT, factory),
-            render_pipelines: Registry::new(B::VARIANT, factory),
-            compute_pipelines: Registry::new(B::VARIANT, factory),
-            query_sets: Registry::new(B::VARIANT, factory),
-            buffers: Registry::new(B::VARIANT, factory),
-            textures: Registry::new(B::VARIANT, factory),
-            texture_views: Registry::new(B::VARIANT, factory),
-            samplers: Registry::new(B::VARIANT, factory),
-        }
+impl HubReport {
+    pub fn is_empty(&self) -> bool {
+        self.adapters.is_empty()
     }
 }
 
-impl<B: GfxBackend, F: GlobalIdentityHandlerFactory> Hub<B, F> {
+pub struct Hub<A: hal::Api, F: GlobalIdentityHandlerFactory> {
+    pub adapters: Registry<Adapter<A>, id::AdapterId, F>,
+    pub devices: Registry<Device<A>, id::DeviceId, F>,
+    pub pipeline_layouts: Registry<PipelineLayout<A>, id::PipelineLayoutId, F>,
+    pub shader_modules: Registry<ShaderModule<A>, id::ShaderModuleId, F>,
+    pub bind_group_layouts: Registry<BindGroupLayout<A>, id::BindGroupLayoutId, F>,
+    pub bind_groups: Registry<BindGroup<A>, id::BindGroupId, F>,
+    pub command_buffers: Registry<CommandBuffer<A>, id::CommandBufferId, F>,
+    pub render_bundles: Registry<RenderBundle, id::RenderBundleId, F>,
+    pub render_pipelines: Registry<RenderPipeline<A>, id::RenderPipelineId, F>,
+    pub compute_pipelines: Registry<ComputePipeline<A>, id::ComputePipelineId, F>,
+    pub query_sets: Registry<QuerySet<A>, id::QuerySetId, F>,
+    pub buffers: Registry<Buffer<A>, id::BufferId, F>,
+    pub textures: Registry<Texture<A>, id::TextureId, F>,
+    pub texture_views: Registry<TextureView<A>, id::TextureViewId, F>,
+    pub samplers: Registry<Sampler<A>, id::SamplerId, F>,
+}
+
+impl<A: HalApi, F: GlobalIdentityHandlerFactory> Hub<A, F> {
+    fn new(factory: &F) -> Self {
+        Self {
+            adapters: Registry::new(A::VARIANT, factory),
+            devices: Registry::new(A::VARIANT, factory),
+            pipeline_layouts: Registry::new(A::VARIANT, factory),
+            shader_modules: Registry::new(A::VARIANT, factory),
+            bind_group_layouts: Registry::new(A::VARIANT, factory),
+            bind_groups: Registry::new(A::VARIANT, factory),
+            command_buffers: Registry::new(A::VARIANT, factory),
+            render_bundles: Registry::new(A::VARIANT, factory),
+            render_pipelines: Registry::new(A::VARIANT, factory),
+            compute_pipelines: Registry::new(A::VARIANT, factory),
+            query_sets: Registry::new(A::VARIANT, factory),
+            buffers: Registry::new(A::VARIANT, factory),
+            textures: Registry::new(A::VARIANT, factory),
+            texture_views: Registry::new(A::VARIANT, factory),
+            samplers: Registry::new(A::VARIANT, factory),
+        }
+    }
+
     //TODO: instead of having a hacky `with_adapters` parameter,
     // we should have `clear_device(device_id)` that specifically destroys
     // everything related to a logical device.
-    fn clear(&self, surface_guard: &mut Storage<Surface, SurfaceId>, with_adapters: bool) {
-        use crate::resource::TextureViewInner;
-        use hal::{device::Device as _, window::PresentationSurface as _};
+    fn clear(&self, surface_guard: &mut Storage<Surface, id::SurfaceId>, with_adapters: bool) {
+        use crate::resource::TextureInner;
+        use hal::{Device as _, Surface as _};
 
         let mut devices = self.devices.data.write();
         for element in devices.map.iter_mut() {
             if let Element::Occupied(ref mut device, _) = *element {
                 device.prepare_to_die();
             }
         }
 
+        // destroy command buffers first, since otherwise DX12 isn't happy
+        for element in self.command_buffers.data.write().map.drain(..) {
+            if let Element::Occupied(command_buffer, _) = element {
+                let device = &devices[command_buffer.device_id.value];
+                device.destroy_command_buffer(command_buffer);
+            }
+        }
+
         for element in self.samplers.data.write().map.drain(..) {
             if let Element::Occupied(sampler, _) = element {
                 unsafe {
                     devices[sampler.device_id.value]
                         .raw
                         .destroy_sampler(sampler.raw);
                 }
             }
         }
         {
             let textures = self.textures.data.read();
             for element in self.texture_views.data.write().map.drain(..) {
                 if let Element::Occupied(texture_view, _) = element {
-                    match texture_view.inner {
-                        TextureViewInner::Native { raw, source_id } => {
-                            let device = &devices[textures[source_id.value].device_id.value];
-                            unsafe {
-                                device.raw.destroy_image_view(raw);
-                            }
+                    // the texture should generally be present, unless it's a surface
+                    // texture, and we are in emergency shutdown.
+                    if textures.contains(texture_view.parent_id.value.0) {
+                        let texture = &textures[texture_view.parent_id.value];
+                        let device = &devices[texture.device_id.value];
+                        unsafe {
+                            device.raw.destroy_texture_view(texture_view.raw);
                         }
-                        TextureViewInner::SwapChain { .. } => {} //TODO
                     }
                 }
             }
         }
 
         for element in self.textures.data.write().map.drain(..) {
             if let Element::Occupied(texture, _) = element {
-                devices[texture.device_id.value].destroy_texture(texture);
+                let device = &devices[texture.device_id.value];
+                if let TextureInner::Native { raw: Some(raw) } = texture.inner {
+                    unsafe {
+                        device.raw.destroy_texture(raw);
+                    }
+                }
             }
         }
         for element in self.buffers.data.write().map.drain(..) {
             if let Element::Occupied(buffer, _) = element {
                 //TODO: unmap if needed
                 devices[buffer.device_id.value].destroy_buffer(buffer);
             }
         }
-        for element in self.command_buffers.data.write().map.drain(..) {
-            if let Element::Occupied(command_buffer, _) = element {
-                let device = &devices[command_buffer.device_id.value];
-                device
-                    .cmd_allocator
-                    .after_submit(command_buffer, &device.raw, 0);
-            }
-        }
         for element in self.bind_groups.data.write().map.drain(..) {
             if let Element::Occupied(bind_group, _) = element {
                 let device = &devices[bind_group.device_id.value];
-                device.destroy_bind_group(bind_group);
+                unsafe {
+                    device.raw.destroy_bind_group(bind_group.raw);
+                }
             }
         }
 
         for element in self.shader_modules.data.write().map.drain(..) {
             if let Element::Occupied(module, _) = element {
                 let device = &devices[module.device_id.value];
                 unsafe {
                     device.raw.destroy_shader_module(module.raw);
                 }
             }
         }
         for element in self.bind_group_layouts.data.write().map.drain(..) {
             if let Element::Occupied(bgl, _) = element {
                 let device = &devices[bgl.device_id.value];
                 unsafe {
-                    device.raw.destroy_descriptor_set_layout(bgl.raw);
+                    device.raw.destroy_bind_group_layout(bgl.raw);
                 }
             }
         }
         for element in self.pipeline_layouts.data.write().map.drain(..) {
             if let Element::Occupied(pipeline_layout, _) = element {
                 let device = &devices[pipeline_layout.device_id.value];
                 unsafe {
                     device.raw.destroy_pipeline_layout(pipeline_layout.raw);
@@ -677,71 +717,95 @@ impl<B: GfxBackend, F: GlobalIdentityHan
                     device.raw.destroy_compute_pipeline(pipeline.raw);
                 }
             }
         }
         for element in self.render_pipelines.data.write().map.drain(..) {
             if let Element::Occupied(pipeline, _) = element {
                 let device = &devices[pipeline.device_id.value];
                 unsafe {
-                    device.raw.destroy_graphics_pipeline(pipeline.raw);
+                    device.raw.destroy_render_pipeline(pipeline.raw);
                 }
             }
         }
 
-        for (index, element) in self.swap_chains.data.write().map.drain(..).enumerate() {
-            if let Element::Occupied(swap_chain, epoch) = element {
-                let device = &devices[swap_chain.device_id.value];
-                unsafe {
-                    device.raw.destroy_semaphore(swap_chain.semaphore);
+        for element in surface_guard.map.iter_mut() {
+            if let Element::Occupied(ref mut surface, _epoch) = *element {
+                if surface
+                    .presentation
+                    .as_ref()
+                    .map_or(wgt::Backend::Empty, |p| p.backend())
+                    != A::VARIANT
+                {
+                    continue;
                 }
-                let suf_id = TypedId::zip(index as Index, epoch, B::VARIANT);
-                //TODO: hold the surface alive by the swapchain
-                if surface_guard.contains(suf_id) {
-                    let surface = surface_guard.get_mut(suf_id).unwrap();
-                    let suf = B::get_surface_mut(surface);
+                if let Some(present) = surface.presentation.take() {
+                    let device = &devices[present.device_id.value];
+                    let suf = A::get_surface_mut(surface);
                     unsafe {
-                        suf.unconfigure_swapchain(&device.raw);
+                        suf.raw.unconfigure(&device.raw);
+                        //TODO: we could destroy the surface here
                     }
                 }
             }
         }
 
         for element in self.query_sets.data.write().map.drain(..) {
             if let Element::Occupied(query_set, _) = element {
                 let device = &devices[query_set.device_id.value];
                 unsafe {
-                    device.raw.destroy_query_pool(query_set.raw);
+                    device.raw.destroy_query_set(query_set.raw);
                 }
             }
         }
 
         for element in devices.map.drain(..) {
             if let Element::Occupied(device, _) = element {
                 device.dispose();
             }
         }
+
         if with_adapters {
+            drop(devices);
             self.adapters.data.write().map.clear();
         }
     }
+
+    pub fn generate_report(&self) -> HubReport {
+        HubReport {
+            adapters: self.adapters.data.read().generate_report(),
+            devices: self.devices.data.read().generate_report(),
+            pipeline_layouts: self.pipeline_layouts.data.read().generate_report(),
+            shader_modules: self.shader_modules.data.read().generate_report(),
+            bind_group_layouts: self.bind_group_layouts.data.read().generate_report(),
+            bind_groups: self.bind_groups.data.read().generate_report(),
+            command_buffers: self.command_buffers.data.read().generate_report(),
+            render_bundles: self.render_bundles.data.read().generate_report(),
+            render_pipelines: self.render_pipelines.data.read().generate_report(),
+            compute_pipelines: self.compute_pipelines.data.read().generate_report(),
+            query_sets: self.query_sets.data.read().generate_report(),
+            buffers: self.buffers.data.read().generate_report(),
+            textures: self.textures.data.read().generate_report(),
+            texture_views: self.texture_views.data.read().generate_report(),
+            samplers: self.samplers.data.read().generate_report(),
+        }
+    }
 }
 
-#[derive(Debug)]
 pub struct Hubs<F: GlobalIdentityHandlerFactory> {
     #[cfg(vulkan)]
-    vulkan: Hub<backend::Vulkan, F>,
+    vulkan: Hub<hal::api::Vulkan, F>,
     #[cfg(metal)]
-    metal: Hub<backend::Metal, F>,
+    metal: Hub<hal::api::Metal, F>,
     #[cfg(dx12)]
-    dx12: Hub<backend::Dx12, F>,
+    dx12: Hub<hal::api::Dx12, F>,
     #[cfg(dx11)]
-    dx11: Hub<backend::Dx11, F>,
+    dx11: Hub<hal::api::Dx11, F>,
     #[cfg(gl)]
-    gl: Hub<backend::Gl, F>,
+    gl: Hub<hal::api::Gles, F>,
 }
 
 impl<F: GlobalIdentityHandlerFactory> Hubs<F> {
     fn new(factory: &F) -> Self {
         Self {
             #[cfg(vulkan)]
             vulkan: Hub::new(factory),
             #[cfg(metal)]
@@ -752,38 +816,104 @@ impl<F: GlobalIdentityHandlerFactory> Hu
             dx11: Hub::new(factory),
             #[cfg(gl)]
             gl: Hub::new(factory),
         }
     }
 }
 
 #[derive(Debug)]
+pub struct GlobalReport {
+    pub surfaces: StorageReport,
+    #[cfg(vulkan)]
+    pub vulkan: Option<HubReport>,
+    #[cfg(metal)]
+    pub metal: Option<HubReport>,
+    #[cfg(dx12)]
+    pub dx12: Option<HubReport>,
+    #[cfg(dx11)]
+    pub dx11: Option<HubReport>,
+    #[cfg(gl)]
+    pub gl: Option<HubReport>,
+}
+
 pub struct Global<G: GlobalIdentityHandlerFactory> {
     pub instance: Instance,
-    pub surfaces: Registry<Surface, SurfaceId, G>,
+    pub surfaces: Registry<Surface, id::SurfaceId, G>,
     hubs: Hubs<G>,
 }
 
 impl<G: GlobalIdentityHandlerFactory> Global<G> {
-    pub fn new(name: &str, factory: G, backends: wgt::BackendBit) -> Self {
+    pub fn new(name: &str, factory: G, backends: wgt::Backends) -> Self {
         profiling::scope!("new", "Global");
         Self {
-            instance: Instance::new(name, 1, backends),
+            instance: Instance::new(name, backends),
             surfaces: Registry::without_backend(&factory, "Surface"),
             hubs: Hubs::new(&factory),
         }
     }
 
-    pub fn clear_backend<B: GfxBackend>(&self, _dummy: ()) {
+    /// # Safety
+    ///
+    /// Refer to the creation of wgpu-hal Instance for every backend.
+    pub unsafe fn from_hal_instance<A: HalApi>(
+        name: &str,
+        factory: G,
+        hal_instance: A::Instance,
+    ) -> Self {
+        profiling::scope!("new", "Global");
+        Self {
+            instance: A::create_instance_from_hal(name, hal_instance),
+            surfaces: Registry::without_backend(&factory, "Surface"),
+            hubs: Hubs::new(&factory),
+        }
+    }
+
+    pub fn clear_backend<A: HalApi>(&self, _dummy: ()) {
         let mut surface_guard = self.surfaces.data.write();
-        let hub = B::hub(self);
+        let hub = A::hub(self);
         // this is used for tests, which keep the adapter
         hub.clear(&mut *surface_guard, false);
     }
+
+    pub fn generate_report(&self) -> GlobalReport {
+        GlobalReport {
+            surfaces: self.surfaces.data.read().generate_report(),
+            #[cfg(vulkan)]
+            vulkan: if self.instance.vulkan.is_some() {
+                Some(self.hubs.vulkan.generate_report())
+            } else {
+                None
+            },
+            #[cfg(metal)]
+            metal: if self.instance.metal.is_some() {
+                Some(self.hubs.metal.generate_report())
+            } else {
+                None
+            },
+            #[cfg(dx12)]
+            dx12: if self.instance.dx12.is_some() {
+                Some(self.hubs.dx12.generate_report())
+            } else {
+                None
+            },
+            #[cfg(dx11)]
+            dx11: if self.instance.dx11.is_some() {
+                Some(self.hubs.dx11.generate_report())
+            } else {
+                None
+            },
+            #[cfg(gl)]
+            gl: if self.instance.gl.is_some() {
+                Some(self.hubs.gl.generate_report())
+            } else {
+                None
+            },
+        }
+    }
 }
 
 impl<G: GlobalIdentityHandlerFactory> Drop for Global<G> {
     fn drop(&mut self) {
         profiling::scope!("drop", "Global");
         log::info!("Dropping Global");
         let mut surface_guard = self.surfaces.data.write();
 
@@ -813,73 +943,119 @@ impl<G: GlobalIdentityHandlerFactory> Dr
         for element in surface_guard.map.drain(..) {
             if let Element::Occupied(surface, _) = element {
                 self.instance.destroy_surface(surface);
             }
         }
     }
 }
 
-pub trait GfxBackend: hal::Backend {
+pub trait HalApi: hal::Api {
     const VARIANT: Backend;
+    fn create_instance_from_hal(name: &str, hal_instance: Self::Instance) -> Instance;
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G>;
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface;
+    fn get_surface(surface: &Surface) -> &HalSurface<Self>;
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self>;
 }
 
 #[cfg(vulkan)]
-impl GfxBackend for backend::Vulkan {
+impl HalApi for hal::api::Vulkan {
     const VARIANT: Backend = Backend::Vulkan;
+    fn create_instance_from_hal(name: &str, hal_instance: Self::Instance) -> Instance {
+        Instance {
+            name: name.to_owned(),
+            vulkan: Some(hal_instance),
+            ..Default::default()
+        }
+    }
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G> {
         &global.hubs.vulkan
     }
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface {
+    fn get_surface(surface: &Surface) -> &HalSurface<Self> {
+        surface.vulkan.as_ref().unwrap()
+    }
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self> {
         surface.vulkan.as_mut().unwrap()
     }
 }
 
 #[cfg(metal)]
-impl GfxBackend for backend::Metal {
+impl HalApi for hal::api::Metal {
     const VARIANT: Backend = Backend::Metal;
+    fn create_instance_from_hal(name: &str, hal_instance: Self::Instance) -> Instance {
+        Instance {
+            name: name.to_owned(),
+            metal: Some(hal_instance),
+        }
+    }
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G> {
         &global.hubs.metal
     }
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface {
+    fn get_surface(surface: &Surface) -> &HalSurface<Self> {
+        surface.metal.as_ref().unwrap()
+    }
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self> {
         surface.metal.as_mut().unwrap()
     }
 }
 
 #[cfg(dx12)]
-impl GfxBackend for backend::Dx12 {
+impl HalApi for hal::api::Dx12 {
     const VARIANT: Backend = Backend::Dx12;
+    fn create_instance_from_hal(name: &str, hal_instance: Self::Instance) -> Instance {
+        Instance {
+            name: name.to_owned(),
+            dx12: Some(hal_instance),
+            ..Default::default()
+        }
+    }
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G> {
         &global.hubs.dx12
     }
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface {
+    fn get_surface(surface: &Surface) -> &HalSurface<Self> {
+        surface.dx12.as_ref().unwrap()
+    }
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self> {
         surface.dx12.as_mut().unwrap()
     }
 }
 
+/*
 #[cfg(dx11)]
-impl GfxBackend for backend::Dx11 {
+impl HalApi for hal::api::Dx11 {
     const VARIANT: Backend = Backend::Dx11;
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G> {
         &global.hubs.dx11
     }
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface {
+    fn get_surface(surface: &Surface) -> &HalSurface<Self> {
+        surface.dx11.as_ref().unwrap()
+    }
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self> {
         surface.dx11.as_mut().unwrap()
     }
 }
+*/
 
 #[cfg(gl)]
-impl GfxBackend for backend::Gl {
+impl HalApi for hal::api::Gles {
     const VARIANT: Backend = Backend::Gl;
+    fn create_instance_from_hal(name: &str, hal_instance: Self::Instance) -> Instance {
+        Instance {
+            name: name.to_owned(),
+            gl: Some(hal_instance),
+            ..Default::default()
+        }
+    }
     fn hub<G: GlobalIdentityHandlerFactory>(global: &Global<G>) -> &Hub<Self, G> {
         &global.hubs.gl
     }
-    fn get_surface_mut(surface: &mut Surface) -> &mut Self::Surface {
+    fn get_surface(surface: &Surface) -> &HalSurface<Self> {
+        surface.gl.as_ref().unwrap()
+    }
+    fn get_surface_mut(surface: &mut Surface) -> &mut HalSurface<Self> {
         surface.gl.as_mut().unwrap()
     }
 }
 
 #[cfg(test)]
 fn _test_send_sync(global: &Global<IdentityManagerFactory>) {
     fn test_internal<T: Send + Sync>(_: T) {}
     test_internal(global)