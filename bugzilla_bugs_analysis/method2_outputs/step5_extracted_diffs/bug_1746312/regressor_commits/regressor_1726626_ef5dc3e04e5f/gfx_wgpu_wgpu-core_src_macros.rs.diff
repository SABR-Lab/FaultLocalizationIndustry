# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/macros.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/macros.rs b/third_party/rust/wgpu-core/src/macros.rs
rename from gfx/wgpu/wgpu-core/src/macros.rs
rename to third_party/rust/wgpu-core/src/macros.rs
--- a/gfx/wgpu/wgpu-core/src/macros.rs
+++ b/third_party/rust/wgpu-core/src/macros.rs
@@ -1,12 +1,8 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 macro_rules! backends_map {
     // one let statement per backend with mapped data
     (
         let map = |$backend:pat| $map:block;
         $(
             #[cfg($backend_cfg:meta)] let $pat:pat = map($expr:expr);
         )*
     ) => {
@@ -29,62 +25,45 @@ macro_rules! backends_map {
         $(
             #[cfg($backend_cfg)]
             {
                 let $backend = $expr;
                 $map
             }
         )*
     };
-
-    // a struct constructor with one field per backend with mapped data
-    (
-        let map = |$backend:pat| $map:block;
-        $Struct:ident {
-            $(
-                #[cfg($backend_cfg:meta)] $ident:ident : map($expr:expr),
-            )*
-        }
-    ) => {
-        $Struct {
-            $(
-                #[cfg($backend_cfg)]
-                $ident: {
-                    let $backend = $expr;
-                    $map
-                },
-            )*
-        }
-    };
 }
 
 #[test]
 fn test_backend_macro() {
     struct Foo {
         #[cfg(any(windows, all(unix, not(target_os = "ios"), not(target_os = "macos")),))]
         vulkan: u32,
 
         #[cfg(any(target_os = "ios", target_os = "macos"))]
         metal: u32,
 
-        #[cfg(windows)]
+        #[cfg(dx12)]
         dx12: u32,
 
-        #[cfg(windows)]
+        #[cfg(dx11)]
         dx11: u32,
     }
 
     // test struct construction
-    let test_foo: Foo = backends_map! {
-        let map = |init| { init - 100 };
+    let test_foo: Foo = {
         Foo {
-            #[cfg(vulkan)] vulkan: map(101),
-            #[cfg(metal)] metal: map(102),
-            #[cfg(dx12)] dx12: map(103),
-            #[cfg(dx11)] dx11: map(104),
+            #[cfg(vulkan)]
+            vulkan: 101,
+            #[cfg(metal)]
+            metal: 102,
+            #[cfg(dx12)]
+            dx12: 103,
+            #[cfg(dx11)]
+            dx11: 104,
         }
     };
 
     let mut vec = Vec::new();
 
     // test basic statement-per-backend
     backends_map! {
         let map = |(id, chr)| {
@@ -100,46 +79,46 @@ fn test_backend_macro() {
         #[cfg(dx12)]
         map((test_foo.dx12, 'c')),
 
         #[cfg(dx11)]
         map((test_foo.dx11, 'd')),
     }
 
     #[cfg(any(windows, all(unix, not(target_os = "ios"), not(target_os = "macos")),))]
-    assert!(vec.contains(&(1, 'a')));
+    assert!(vec.contains(&(101, 'a')));
 
     #[cfg(any(target_os = "ios", target_os = "macos"))]
-    assert!(vec.contains(&(2, 'b')));
+    assert!(vec.contains(&(102, 'b')));
 
-    #[cfg(windows)]
-    assert!(vec.contains(&(3, 'c')));
+    #[cfg(dx12)]
+    assert!(vec.contains(&(103, 'c')));
 
-    #[cfg(windows)]
-    assert!(vec.contains(&(4, 'd')));
+    #[cfg(dx11)]
+    assert!(vec.contains(&(104, 'd')));
 
     // test complex statement-per-backend
     backends_map! {
         let map = |(id, pred, code)| {
             if pred(id) {
                 code();
             }
         };
 
         #[cfg(vulkan)]
-        map((test_foo.vulkan, |v| v == 1, || println!("vulkan"))),
+        map((test_foo.vulkan, |v| v == 101, || println!("vulkan"))),
 
         #[cfg(metal)]
-        map((test_foo.metal, |v| v == 2, || println!("metal"))),
+        map((test_foo.metal, |v| v == 102, || println!("metal"))),
 
         #[cfg(dx12)]
-        map((test_foo.dx12, |v| v == 3, || println!("dx12"))),
+        map((test_foo.dx12, |v| v == 103, || println!("dx12"))),
 
         #[cfg(dx11)]
-        map((test_foo.dx11, |v| v == 4, || println!("dx11"))),
+        map((test_foo.dx11, |v| v == 104, || println!("dx11"))),
     }
 
     // test struct construction 2
     let test_foo_2: Foo = Foo {
         #[cfg(vulkan)]
         vulkan: 1,
 
         #[cfg(metal)]
@@ -201,14 +180,14 @@ fn test_backend_macro() {
     }
 
     #[cfg(any(windows, all(unix, not(target_os = "ios"), not(target_os = "macos")),))]
     let _ = var_vulkan;
 
     #[cfg(any(target_os = "ios", target_os = "macos"))]
     let _ = var_metal;
 
-    #[cfg(windows)]
+    #[cfg(dx12)]
     let _ = var_dx12;
 
-    #[cfg(windows)]
+    #[cfg(dx11)]
     let _ = var_dx11;
 }