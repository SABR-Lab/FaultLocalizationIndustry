# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/pipeline.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/pipeline.rs b/third_party/rust/wgpu-core/src/pipeline.rs
rename from gfx/wgpu/wgpu-core/src/pipeline.rs
rename to third_party/rust/wgpu-core/src/pipeline.rs
--- a/gfx/wgpu/wgpu-core/src/pipeline.rs
+++ b/third_party/rust/wgpu-core/src/pipeline.rs
@@ -1,66 +1,73 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 use crate::{
     binding_model::{CreateBindGroupLayoutError, CreatePipelineLayoutError},
-    device::{DeviceError, MissingFeatures, RenderPassContext},
+    device::{DeviceError, MissingDownlevelFlags, MissingFeatures, RenderPassContext},
     hub::Resource,
     id::{DeviceId, PipelineLayoutId, ShaderModuleId},
-    validation, Label, LifeGuard, Stored, DOWNLEVEL_ERROR_WARNING_MESSAGE,
+    validation, Label, LifeGuard, Stored,
 };
 use std::borrow::Cow;
 use thiserror::Error;
 
-#[derive(Debug)]
 pub enum ShaderModuleSource<'a> {
-    SpirV(Cow<'a, [u32]>),
     Wgsl(Cow<'a, str>),
     Naga(naga::Module),
 }
 
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct ShaderModuleDescriptor<'a> {
     pub label: Label<'a>,
-    #[cfg_attr(any(feature = "replay", feature = "trace"), serde(default))]
-    pub flags: wgt::ShaderFlags,
 }
 
 #[derive(Debug)]
-pub struct ShaderModule<B: hal::Backend> {
-    pub(crate) raw: B::ShaderModule,
+pub struct ShaderModule<A: hal::Api> {
+    pub(crate) raw: A::ShaderModule,
     pub(crate) device_id: Stored<DeviceId>,
     pub(crate) interface: Option<validation::Interface>,
     #[cfg(debug_assertions)]
     pub(crate) label: String,
 }
 
-impl<B: hal::Backend> Resource for ShaderModule<B> {
+impl<A: hal::Api> Resource for ShaderModule<A> {
     const TYPE: &'static str = "ShaderModule";
 
     fn life_guard(&self) -> &LifeGuard {
         unreachable!()
     }
 
     fn label(&self) -> &str {
         #[cfg(debug_assertions)]
         return &self.label;
         #[cfg(not(debug_assertions))]
         return "";
     }
 }
 
 #[derive(Clone, Debug, Error)]
+pub struct NagaParseError {
+    pub shader_source: String,
+    pub error: naga::front::wgsl::ParseError,
+}
+impl std::fmt::Display for NagaParseError {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(
+            f,
+            "\nShader error:\n{}",
+            self.error.emit_to_string(&self.shader_source)
+        )
+    }
+}
+
+#[derive(Clone, Debug, Error)]
 pub enum CreateShaderModuleError {
-    #[error("Failed to parse WGSL")]
-    Parsing,
+    #[error("Failed to parse a shader")]
+    Parsing(#[from] NagaParseError),
     #[error("Failed to generate the backend-specific code")]
     Generation,
     #[error(transparent)]
     Device(#[from] DeviceError),
     #[error(transparent)]
     Validation(#[from] naga::valid::ValidationError),
     #[error(transparent)]
     MissingFeatures(#[from] MissingFeatures),
@@ -81,17 +88,17 @@ pub struct ProgrammableStageDescriptor<'
 /// Number of implicit bind groups derived at pipeline creation.
 pub type ImplicitBindGroupCount = u8;
 
 #[derive(Clone, Debug, Error)]
 pub enum ImplicitLayoutError {
     #[error("missing IDs for deriving {0} bind groups")]
     MissingIds(ImplicitBindGroupCount),
     #[error("unable to reflect the shader {0:?} interface")]
-    ReflectionError(wgt::ShaderStage),
+    ReflectionError(wgt::ShaderStages),
     #[error(transparent)]
     BindGroup(#[from] CreateBindGroupLayoutError),
     #[error(transparent)]
     Pipeline(#[from] CreatePipelineLayoutError),
 }
 
 /// Describes a compute pipeline.
 #[derive(Clone, Debug)]
@@ -112,48 +119,45 @@ pub enum CreateComputePipelineError {
     #[error("pipeline layout is invalid")]
     InvalidLayout,
     #[error("unable to derive an implicit layout")]
     Implicit(#[from] ImplicitLayoutError),
     #[error("error matching shader requirements against the pipeline")]
     Stage(#[from] validation::StageError),
     #[error("Internal error: {0}")]
     Internal(String),
-    #[error(
-        "Compute shaders are not supported by the underlying platform. {}",
-        DOWNLEVEL_ERROR_WARNING_MESSAGE
-    )]
-    ComputeShadersUnsupported,
+    #[error(transparent)]
+    MissingDownlevelFlags(#[from] MissingDownlevelFlags),
 }
 
 #[derive(Debug)]
-pub struct ComputePipeline<B: hal::Backend> {
-    pub(crate) raw: B::ComputePipeline,
+pub struct ComputePipeline<A: hal::Api> {
+    pub(crate) raw: A::ComputePipeline,
     pub(crate) layout_id: Stored<PipelineLayoutId>,
     pub(crate) device_id: Stored<DeviceId>,
     pub(crate) life_guard: LifeGuard,
 }
 
-impl<B: hal::Backend> Resource for ComputePipeline<B> {
+impl<A: hal::Api> Resource for ComputePipeline<A> {
     const TYPE: &'static str = "ComputePipeline";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
 /// Describes how the vertex buffer is interpreted.
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct VertexBufferLayout<'a> {
     /// The stride, in bytes, between elements of this buffer.
     pub array_stride: wgt::BufferAddress,
     /// How often this vertex buffer is "stepped" forward.
-    pub step_mode: wgt::InputStepMode,
+    pub step_mode: wgt::VertexStepMode,
     /// The list of attributes which comprise a single vertex.
     pub attributes: Cow<'a, [wgt::VertexAttribute]>,
 }
 
 /// Describes the vertex process in a render pipeline.
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
@@ -261,49 +265,51 @@ pub enum CreateRenderPipelineError {
     StripIndexFormatForNonStripTopology {
         strip_index_format: Option<wgt::IndexFormat>,
         topology: wgt::PrimitiveTopology,
     },
     #[error("Conservative Rasterization is only supported for wgt::PolygonMode::Fill")]
     ConservativeRasterizationNonFillPolygonMode,
     #[error(transparent)]
     MissingFeatures(#[from] MissingFeatures),
+    #[error(transparent)]
+    MissingDownlevelFlags(#[from] MissingDownlevelFlags),
     #[error("error matching {stage:?} shader requirements against the pipeline")]
     Stage {
-        stage: wgt::ShaderStage,
+        stage: wgt::ShaderStages,
         #[source]
         error: validation::StageError,
     },
     #[error("Internal error in {stage:?} shader: {error}")]
     Internal {
-        stage: wgt::ShaderStage,
+        stage: wgt::ShaderStages,
         error: String,
     },
 }
 
 bitflags::bitflags! {
     #[repr(transparent)]
     pub struct PipelineFlags: u32 {
-        const BLEND_CONSTANT = 1;
-        const STENCIL_REFERENCE = 2;
-        const WRITES_DEPTH_STENCIL = 4;
+        const BLEND_CONSTANT = 1 << 0;
+        const STENCIL_REFERENCE = 1 << 1;
+        const WRITES_DEPTH_STENCIL = 1 << 2;
     }
 }
 
 #[derive(Debug)]
-pub struct RenderPipeline<B: hal::Backend> {
-    pub(crate) raw: B::GraphicsPipeline,
+pub struct RenderPipeline<A: hal::Api> {
+    pub(crate) raw: A::RenderPipeline,
     pub(crate) layout_id: Stored<PipelineLayoutId>,
     pub(crate) device_id: Stored<DeviceId>,
     pub(crate) pass_context: RenderPassContext,
     pub(crate) flags: PipelineFlags,
     pub(crate) strip_index_format: Option<wgt::IndexFormat>,
-    pub(crate) vertex_strides: Vec<(wgt::BufferAddress, wgt::InputStepMode)>,
+    pub(crate) vertex_strides: Vec<(wgt::BufferAddress, wgt::VertexStepMode)>,
     pub(crate) life_guard: LifeGuard,
 }
 
-impl<B: hal::Backend> Resource for RenderPipeline<B> {
+impl<A: hal::Api> Resource for RenderPipeline<A> {
     const TYPE: &'static str = "RenderPipeline";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }