# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/resource.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/resource.rs b/third_party/rust/wgpu-core/src/resource.rs
rename from gfx/wgpu/wgpu-core/src/resource.rs
rename to third_party/rust/wgpu-core/src/resource.rs
--- a/gfx/wgpu/wgpu-core/src/resource.rs
+++ b/third_party/rust/wgpu-core/src/resource.rs
@@ -1,109 +1,54 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 use crate::{
-    device::{alloc::MemoryBlock, DeviceError, HostMap, MissingFeatures},
-    hub::Resource,
-    id::{DeviceId, SwapChainId, TextureId},
-    memory_init_tracker::MemoryInitTracker,
+    device::{DeviceError, HostMap, MissingFeatures},
+    hub::{Global, GlobalIdentityHandlerFactory, HalApi, Resource, Token},
+    id::{DeviceId, SurfaceId, TextureId, Valid},
+    init_tracker::BufferInitTracker,
     track::{TextureSelector, DUMMY_SELECTOR},
     validation::MissingBufferUsageError,
     Label, LifeGuard, RefCount, Stored,
 };
 
 use thiserror::Error;
 
 use std::{borrow::Borrow, num::NonZeroU8, ops::Range, ptr::NonNull};
 
-bitflags::bitflags! {
-    /// The internal enum mirrored from `BufferUsage`. The values don't have to match!
-    pub struct BufferUse: u32 {
-        const EMPTY = 0;
-        const MAP_READ = 1;
-        const MAP_WRITE = 2;
-        const COPY_SRC = 4;
-        const COPY_DST = 8;
-        const INDEX = 16;
-        const VERTEX = 32;
-        const UNIFORM = 64;
-        const STORAGE_LOAD = 128;
-        const STORAGE_STORE = 256;
-        const INDIRECT = 512;
-        /// The combination of all read-only usages.
-        const READ_ALL = Self::MAP_READ.bits | Self::COPY_SRC.bits |
-            Self::INDEX.bits | Self::VERTEX.bits | Self::UNIFORM.bits |
-            Self::STORAGE_LOAD.bits | Self::INDIRECT.bits;
-        /// The combination of all write-only and read-write usages.
-        const WRITE_ALL = Self::MAP_WRITE.bits | Self::COPY_DST.bits | Self::STORAGE_STORE.bits;
-        /// The combination of all usages that the are guaranteed to be be ordered by the hardware.
-        /// If a usage is not ordered, then even if it doesn't change between draw calls, there
-        /// still need to be pipeline barriers inserted for synchronization.
-        const ORDERED = Self::READ_ALL.bits | Self::MAP_WRITE.bits | Self::COPY_DST.bits;
-    }
-}
-
-bitflags::bitflags! {
-    /// The internal enum mirrored from `TextureUsage`. The values don't have to match!
-    pub struct TextureUse: u32 {
-        const EMPTY = 0;
-        const COPY_SRC = 1;
-        const COPY_DST = 2;
-        const SAMPLED = 4;
-        const ATTACHMENT_READ = 8;
-        const ATTACHMENT_WRITE = 16;
-        const STORAGE_LOAD = 32;
-        const STORAGE_STORE = 48;
-        /// The combination of all read-only usages.
-        const READ_ALL = Self::COPY_SRC.bits | Self::SAMPLED.bits | Self::ATTACHMENT_READ.bits | Self::STORAGE_LOAD.bits;
-        /// The combination of all write-only and read-write usages.
-        const WRITE_ALL = Self::COPY_DST.bits | Self::ATTACHMENT_WRITE.bits | Self::STORAGE_STORE.bits;
-        /// The combination of all usages that the are guaranteed to be be ordered by the hardware.
-        /// If a usage is not ordered, then even if it doesn't change between draw calls, there
-        /// still need to be pipeline barriers inserted for synchronization.
-        const ORDERED = Self::READ_ALL.bits | Self::COPY_DST.bits | Self::ATTACHMENT_WRITE.bits;
-        const UNINITIALIZED = 0xFFFF;
-    }
-}
-
 #[repr(C)]
 #[derive(Debug)]
 pub enum BufferMapAsyncStatus {
     Success,
     Error,
     Aborted,
     Unknown,
     ContextLost,
 }
 
 #[derive(Debug)]
-pub(crate) enum BufferMapState<B: hal::Backend> {
+pub(crate) enum BufferMapState<A: hal::Api> {
     /// Mapped at creation.
     Init {
         ptr: NonNull<u8>,
-        stage_buffer: B::Buffer,
-        stage_memory: MemoryBlock<B>,
+        stage_buffer: A::Buffer,
         needs_flush: bool,
     },
     /// Waiting for GPU to be done before mapping
     Waiting(BufferPendingMapping),
     /// Mapped
     Active {
         ptr: NonNull<u8>,
-        sub_range: hal::buffer::SubRange,
+        range: hal::MemoryRange,
         host: HostMap,
     },
     /// Not mapped
     Idle,
 }
 
-unsafe impl<B: hal::Backend> Send for BufferMapState<B> {}
-unsafe impl<B: hal::Backend> Sync for BufferMapState<B> {}
+unsafe impl<A: hal::Api> Send for BufferMapState<A> {}
+unsafe impl<A: hal::Api> Sync for BufferMapState<A> {}
 
 pub type BufferMapCallback = unsafe extern "C" fn(status: BufferMapAsyncStatus, userdata: *mut u8);
 
 #[repr(C)]
 #[derive(Debug)]
 pub struct BufferMapOperation {
     pub host: HostMap,
     pub callback: BufferMapCallback,
@@ -165,72 +110,111 @@ pub(crate) struct BufferPendingMapping {
     pub op: BufferMapOperation,
     // hold the parent alive while the mapping is active
     pub parent_ref_count: RefCount,
 }
 
 pub type BufferDescriptor<'a> = wgt::BufferDescriptor<Label<'a>>;
 
 #[derive(Debug)]
-pub struct Buffer<B: hal::Backend> {
-    pub(crate) raw: Option<(B::Buffer, MemoryBlock<B>)>,
+pub struct Buffer<A: hal::Api> {
+    pub(crate) raw: Option<A::Buffer>,
     pub(crate) device_id: Stored<DeviceId>,
-    pub(crate) usage: wgt::BufferUsage,
+    pub(crate) usage: wgt::BufferUsages,
     pub(crate) size: wgt::BufferAddress,
-    pub(crate) initialization_status: MemoryInitTracker,
-    pub(crate) sync_mapped_writes: Option<hal::memory::Segment>,
+    pub(crate) initialization_status: BufferInitTracker,
+    pub(crate) sync_mapped_writes: Option<hal::MemoryRange>,
     pub(crate) life_guard: LifeGuard,
-    pub(crate) map_state: BufferMapState<B>,
+    pub(crate) map_state: BufferMapState<A>,
 }
 
 #[derive(Clone, Debug, Error)]
 pub enum CreateBufferError {
     #[error(transparent)]
     Device(#[from] DeviceError),
     #[error("failed to map buffer while creating: {0}")]
     AccessError(#[from] BufferAccessError),
     #[error("buffers that are mapped at creation have to be aligned to `COPY_BUFFER_ALIGNMENT`")]
     UnalignedSize,
     #[error("Buffers cannot have empty usage flags")]
     EmptyUsage,
     #[error("`MAP` usage can only be combined with the opposite `COPY`, requested {0:?}")]
-    UsageMismatch(wgt::BufferUsage),
+    UsageMismatch(wgt::BufferUsages),
 }
 
-impl<B: hal::Backend> Resource for Buffer<B> {
+impl<A: hal::Api> Resource for Buffer<A> {
     const TYPE: &'static str = "Buffer";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
-impl<B: hal::Backend> Borrow<()> for Buffer<B> {
+impl<A: hal::Api> Borrow<()> for Buffer<A> {
     fn borrow(&self) -> &() {
         &DUMMY_SELECTOR
     }
 }
 
 pub type TextureDescriptor<'a> = wgt::TextureDescriptor<Label<'a>>;
 
 #[derive(Debug)]
-pub struct Texture<B: hal::Backend> {
-    pub(crate) raw: Option<(B::Image, MemoryBlock<B>)>,
+pub(crate) enum TextureInner<A: hal::Api> {
+    Native {
+        raw: Option<A::Texture>,
+    },
+    Surface {
+        raw: A::SurfaceTexture,
+        parent_id: Valid<SurfaceId>,
+        has_work: bool,
+    },
+}
+
+impl<A: hal::Api> TextureInner<A> {
+    pub fn as_raw(&self) -> Option<&A::Texture> {
+        match *self {
+            Self::Native { raw: Some(ref tex) } => Some(tex),
+            Self::Native { raw: None } => None,
+            Self::Surface { ref raw, .. } => Some(raw.borrow()),
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct Texture<A: hal::Api> {
+    pub(crate) inner: TextureInner<A>,
     pub(crate) device_id: Stored<DeviceId>,
-    pub(crate) usage: wgt::TextureUsage,
-    pub(crate) aspects: hal::format::Aspects,
-    pub(crate) dimension: wgt::TextureDimension,
-    pub(crate) kind: hal::image::Kind,
-    pub(crate) format: wgt::TextureFormat,
+    pub(crate) desc: wgt::TextureDescriptor<()>,
+    pub(crate) hal_usage: hal::TextureUses,
     pub(crate) format_features: wgt::TextureFormatFeatures,
-    pub(crate) framebuffer_attachment: hal::image::FramebufferAttachment,
     pub(crate) full_range: TextureSelector,
     pub(crate) life_guard: LifeGuard,
 }
 
+impl<G: GlobalIdentityHandlerFactory> Global<G> {
+    /// # Safety
+    ///
+    /// - The raw texture handle must not be manually destroyed
+    pub unsafe fn texture_as_hal<A: HalApi, F: FnOnce(Option<&A::Texture>)>(
+        &self,
+        id: TextureId,
+        hal_texture_callback: F,
+    ) {
+        profiling::scope!("as_hal", "Texture");
+
+        let hub = A::hub(self);
+        let mut token = Token::root();
+        let (guard, _) = hub.textures.read(&mut token);
+        let texture = guard.get(id).ok();
+        let hal_texture = texture.map(|tex| tex.inner.as_raw().unwrap());
+
+        hal_texture_callback(hal_texture);
+    }
+}
+
 #[derive(Clone, Copy, Debug)]
 pub enum TextureErrorDimension {
     X,
     Y,
     Z,
 }
 
 #[derive(Clone, Debug, Error)]
@@ -255,30 +239,30 @@ pub enum CreateTextureError {
     CannotCopyD24Plus,
     #[error("Textures cannot have empty usage flags")]
     EmptyUsage,
     #[error(transparent)]
     InvalidDimension(#[from] TextureDimensionError),
     #[error("texture descriptor mip level count ({0}) is invalid")]
     InvalidMipLevelCount(u32),
     #[error("The texture usages {0:?} are not allowed on a texture of type {1:?}")]
-    InvalidUsages(wgt::TextureUsage, wgt::TextureFormat),
+    InvalidUsages(wgt::TextureUsages, wgt::TextureFormat),
     #[error("Texture format {0:?} can't be used")]
     MissingFeatures(wgt::TextureFormat, #[source] MissingFeatures),
 }
 
-impl<B: hal::Backend> Resource for Texture<B> {
+impl<A: hal::Api> Resource for Texture<A> {
     const TYPE: &'static str = "Texture";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
-impl<B: hal::Backend> Borrow<TextureSelector> for Texture<B> {
+impl<A: hal::Api> Borrow<TextureSelector> for Texture<A> {
     fn borrow(&self) -> &TextureSelector {
         &self.full_range
     }
 }
 
 /// Describes a [`TextureView`].
 #[derive(Clone, Debug, Default, PartialEq)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
@@ -292,92 +276,93 @@ pub struct TextureViewDescriptor<'a> {
     /// The dimension of the texture view. For 1D textures, this must be `1D`. For 2D textures it must be one of
     /// `D2`, `D2Array`, `Cube`, and `CubeArray`. For 3D textures it must be `3D`
     pub dimension: Option<wgt::TextureViewDimension>,
     /// Range within the texture that is accessible via this view.
     pub range: wgt::ImageSubresourceRange,
 }
 
 #[derive(Debug)]
-pub(crate) enum TextureViewInner<B: hal::Backend> {
-    Native {
-        raw: B::ImageView,
-        source_id: Stored<TextureId>,
-    },
-    SwapChain {
-        image: <B::Surface as hal::window::PresentationSurface<B>>::SwapchainImage,
-        source_id: Stored<SwapChainId>,
-    },
+pub(crate) struct HalTextureViewDescriptor {
+    pub format: wgt::TextureFormat,
+    pub dimension: wgt::TextureViewDimension,
+    pub range: wgt::ImageSubresourceRange,
+}
+
+impl HalTextureViewDescriptor {
+    pub fn aspects(&self) -> hal::FormatAspects {
+        hal::FormatAspects::from(self.format) & hal::FormatAspects::from(self.range.aspect)
+    }
 }
 
 #[derive(Debug)]
-pub struct TextureView<B: hal::Backend> {
-    pub(crate) inner: TextureViewInner<B>,
+pub struct TextureView<A: hal::Api> {
+    pub(crate) raw: A::TextureView,
+    pub(crate) parent_id: Stored<TextureId>,
     //TODO: store device_id for quick access?
-    pub(crate) aspects: hal::format::Aspects,
-    pub(crate) format: wgt::TextureFormat,
+    pub(crate) desc: HalTextureViewDescriptor,
     pub(crate) format_features: wgt::TextureFormatFeatures,
-    pub(crate) dimension: wgt::TextureViewDimension,
     pub(crate) extent: wgt::Extent3d,
-    pub(crate) samples: hal::image::NumSamples,
-    pub(crate) framebuffer_attachment: hal::image::FramebufferAttachment,
+    pub(crate) samples: u32,
     /// Internal use of this texture view when used as `BindingType::Texture`.
-    pub(crate) sampled_internal_use: TextureUse,
+    pub(crate) sampled_internal_use: hal::TextureUses,
     pub(crate) selector: TextureSelector,
     pub(crate) life_guard: LifeGuard,
 }
 
 #[derive(Clone, Debug, Error)]
 pub enum CreateTextureViewError {
     #[error("parent texture is invalid or destroyed")]
     InvalidTexture,
     #[error("not enough memory left")]
     OutOfMemory,
-    #[error("Invalid texture view dimension `{view:?}` with texture of dimension `{image:?}`")]
+    #[error("Invalid texture view dimension `{view:?}` with texture of dimension `{texture:?}`")]
     InvalidTextureViewDimension {
         view: wgt::TextureViewDimension,
-        image: wgt::TextureDimension,
+        texture: wgt::TextureDimension,
     },
     #[error("Invalid texture depth `{depth}` for texture view of dimension `Cubemap`. Cubemap views must use images of size 6.")]
-    InvalidCubemapTextureDepth { depth: u16 },
+    InvalidCubemapTextureDepth { depth: u32 },
     #[error("Invalid texture depth `{depth}` for texture view of dimension `CubemapArray`. Cubemap views must use images with sizes which are a multiple of 6.")]
-    InvalidCubemapArrayTextureDepth { depth: u16 },
+    InvalidCubemapArrayTextureDepth { depth: u32 },
     #[error(
         "TextureView mip level count + base mip level {requested} must be <= Texture mip level count {total}"
     )]
-    TooManyMipLevels { requested: u32, total: u8 },
+    TooManyMipLevels { requested: u32, total: u32 },
     #[error("TextureView array layer count + base array layer {requested} must be <= Texture depth/array layer count {total}")]
-    TooManyArrayLayers { requested: u32, total: u16 },
+    TooManyArrayLayers { requested: u32, total: u32 },
     #[error("Requested array layer count {requested} is not valid for the target view dimension {dim:?}")]
     InvalidArrayLayerCount {
         requested: u32,
         dim: wgt::TextureViewDimension,
     },
-    #[error("Aspect {requested:?} is not in the source texture ({total:?})")]
+    #[error("Aspect {requested_aspect:?} is not in the source texture format {texture_format:?}")]
     InvalidAspect {
-        requested: hal::format::Aspects,
-        total: hal::format::Aspects,
+        texture_format: wgt::TextureFormat,
+        requested_aspect: wgt::TextureAspect,
+    },
+    #[error("Unable to view texture {texture:?} as {view:?}")]
+    FormatReinterpretation {
+        texture: wgt::TextureFormat,
+        view: wgt::TextureFormat,
     },
 }
 
 #[derive(Clone, Debug, Error)]
-pub enum TextureViewDestroyError {
-    #[error("cannot destroy swap chain image")]
-    SwapChainImage,
-}
+pub enum TextureViewDestroyError {}
 
-impl<B: hal::Backend> Resource for TextureView<B> {
+impl<A: hal::Api> Resource for TextureView<A> {
     const TYPE: &'static str = "TextureView";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
-impl<B: hal::Backend> Borrow<()> for TextureView<B> {
+impl<A: hal::Api> Borrow<()> for TextureView<A> {
     fn borrow(&self) -> &() {
         &DUMMY_SELECTOR
     }
 }
 
 /// Describes a [`Sampler`]
 #[derive(Clone, Debug, PartialEq)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
@@ -418,18 +403,18 @@ impl Default for SamplerDescriptor<'_> {
             compare: None,
             anisotropy_clamp: None,
             border_color: None,
         }
     }
 }
 
 #[derive(Debug)]
-pub struct Sampler<B: hal::Backend> {
-    pub(crate) raw: B::Sampler,
+pub struct Sampler<A: hal::Api> {
+    pub(crate) raw: A::Sampler,
     pub(crate) device_id: Stored<DeviceId>,
     pub(crate) life_guard: LifeGuard,
     /// `true` if this is a comparison sampler
     pub(crate) comparison: bool,
     /// `true` if this is a filtering sampler
     pub(crate) filtering: bool,
 }
 
@@ -441,61 +426,60 @@ pub enum CreateSamplerError {
     InvalidClamp(u8),
     #[error("cannot create any more samplers")]
     TooManyObjects,
     /// AddressMode::ClampToBorder requires feature ADDRESS_MODE_CLAMP_TO_BORDER.
     #[error(transparent)]
     MissingFeatures(#[from] MissingFeatures),
 }
 
-impl<B: hal::Backend> Resource for Sampler<B> {
+impl<A: hal::Api> Resource for Sampler<A> {
     const TYPE: &'static str = "Sampler";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
-impl<B: hal::Backend> Borrow<()> for Sampler<B> {
+impl<A: hal::Api> Borrow<()> for Sampler<A> {
     fn borrow(&self) -> &() {
         &DUMMY_SELECTOR
     }
 }
 #[derive(Clone, Debug, Error)]
 pub enum CreateQuerySetError {
     #[error(transparent)]
     Device(#[from] DeviceError),
     #[error("QuerySets cannot be made with zero queries")]
     ZeroCount,
     #[error("{count} is too many queries for a single QuerySet. QuerySets cannot be made more than {maximum} queries.")]
     TooManyQueries { count: u32, maximum: u32 },
     #[error(transparent)]
     MissingFeatures(#[from] MissingFeatures),
 }
 
+pub type QuerySetDescriptor<'a> = wgt::QuerySetDescriptor<Label<'a>>;
+
 #[derive(Debug)]
-pub struct QuerySet<B: hal::Backend> {
-    pub(crate) raw: B::QueryPool,
+pub struct QuerySet<A: hal::Api> {
+    pub(crate) raw: A::QuerySet,
     pub(crate) device_id: Stored<DeviceId>,
     pub(crate) life_guard: LifeGuard,
-    /// Amount of queries in the query set.
-    pub(crate) desc: wgt::QuerySetDescriptor,
-    /// Amount of numbers in each query (i.e. a pipeline statistics query for two attributes will have this number be two)
-    pub(crate) elements: u32,
+    pub(crate) desc: wgt::QuerySetDescriptor<()>,
 }
 
-impl<B: hal::Backend> Resource for QuerySet<B> {
+impl<A: hal::Api> Resource for QuerySet<A> {
     const TYPE: &'static str = "QuerySet";
 
     fn life_guard(&self) -> &LifeGuard {
         &self.life_guard
     }
 }
 
-impl<B: hal::Backend> Borrow<()> for QuerySet<B> {
+impl<A: hal::Api> Borrow<()> for QuerySet<A> {
     fn borrow(&self) -> &() {
         &DUMMY_SELECTOR
     }
 }
 
 #[derive(Clone, Debug, Error)]
 pub enum DestroyError {
     #[error("resource is invalid")]