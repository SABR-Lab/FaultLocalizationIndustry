# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/track/buffer.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/track/buffer.rs b/third_party/rust/wgpu-core/src/track/buffer.rs
rename from gfx/wgpu/wgpu-core/src/track/buffer.rs
rename to third_party/rust/wgpu-core/src/track/buffer.rs
--- a/gfx/wgpu/wgpu-core/src/track/buffer.rs
+++ b/third_party/rust/wgpu-core/src/track/buffer.rs
@@ -1,67 +1,60 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+use super::{PendingTransition, ResourceState, Unit};
+use crate::id::{BufferId, Valid};
+use hal::BufferUses;
 
-use super::{PendingTransition, ResourceState, Unit};
-use crate::{
-    id::{BufferId, Valid},
-    resource::BufferUse,
-};
-
-//TODO: store `hal::buffer::State` here to avoid extra conversions
-pub(crate) type BufferState = Unit<BufferUse>;
+pub(crate) type BufferState = Unit<BufferUses>;
 
 impl PendingTransition<BufferState> {
-    fn collapse(self) -> Result<BufferUse, Self> {
+    fn collapse(self) -> Result<BufferUses, Self> {
         if self.usage.start.is_empty()
             || self.usage.start == self.usage.end
-            || !BufferUse::WRITE_ALL.intersects(self.usage.start | self.usage.end)
+            || !BufferUses::EXCLUSIVE.intersects(self.usage.start | self.usage.end)
         {
             Ok(self.usage.start | self.usage.end)
         } else {
             Err(self)
         }
     }
 }
 
 impl Default for BufferState {
     fn default() -> Self {
         Self {
             first: None,
-            last: BufferUse::empty(),
+            last: BufferUses::empty(),
         }
     }
 }
 
 impl BufferState {
-    pub fn with_usage(usage: BufferUse) -> Self {
+    pub fn with_usage(usage: BufferUses) -> Self {
         Unit::new(usage)
     }
 }
 
 impl ResourceState for BufferState {
     type Id = BufferId;
     type Selector = ();
-    type Usage = BufferUse;
+    type Usage = BufferUses;
 
     fn query(&self, _selector: Self::Selector) -> Option<Self::Usage> {
         Some(self.last)
     }
 
     fn change(
         &mut self,
         id: Valid<Self::Id>,
         _selector: Self::Selector,
         usage: Self::Usage,
         output: Option<&mut Vec<PendingTransition<Self>>>,
     ) -> Result<(), PendingTransition<Self>> {
         let old = self.last;
-        if old != usage || !BufferUse::ORDERED.contains(usage) {
+        if old != usage || !BufferUses::ORDERED.contains(usage) {
             let pending = PendingTransition {
                 id,
                 selector: (),
                 usage: old..usage,
             };
             *self = match output {
                 None => {
                     assert_eq!(
@@ -77,44 +70,25 @@ impl ResourceState for BufferState {
                         last: usage,
                     }
                 }
             };
         }
         Ok(())
     }
 
-    fn prepend(
-        &mut self,
-        id: Valid<Self::Id>,
-        _selector: Self::Selector,
-        usage: Self::Usage,
-    ) -> Result<(), PendingTransition<Self>> {
-        match self.first {
-            Some(old) if old != usage => Err(PendingTransition {
-                id,
-                selector: (),
-                usage: old..usage,
-            }),
-            _ => {
-                self.first = Some(usage);
-                Ok(())
-            }
-        }
-    }
-
     fn merge(
         &mut self,
         id: Valid<Self::Id>,
         other: &Self,
         output: Option<&mut Vec<PendingTransition<Self>>>,
     ) -> Result<(), PendingTransition<Self>> {
         let old = self.last;
         let new = other.port();
-        if old == new && BufferUse::ORDERED.contains(new) {
+        if old == new && BufferUses::ORDERED.contains(new) {
             if output.is_some() && self.first.is_none() {
                 self.first = Some(old);
             }
         } else {
             let pending = PendingTransition {
                 id,
                 selector: (),
                 usage: old..new,
@@ -146,96 +120,70 @@ impl ResourceState for BufferState {
 mod test {
     use super::*;
     use crate::id::Id;
 
     #[test]
     fn change_extend() {
         let mut bs = Unit {
             first: None,
-            last: BufferUse::INDEX,
+            last: BufferUses::INDEX,
         };
         let id = Id::dummy();
         assert_eq!(
-            bs.change(id, (), BufferUse::STORAGE_STORE, None),
+            bs.change(id, (), BufferUses::STORAGE_WRITE, None),
             Err(PendingTransition {
                 id,
                 selector: (),
-                usage: BufferUse::INDEX..BufferUse::STORAGE_STORE,
+                usage: BufferUses::INDEX..BufferUses::STORAGE_WRITE,
             }),
         );
-        bs.change(id, (), BufferUse::VERTEX, None).unwrap();
-        bs.change(id, (), BufferUse::INDEX, None).unwrap();
-        assert_eq!(bs, Unit::new(BufferUse::VERTEX | BufferUse::INDEX));
+        bs.change(id, (), BufferUses::VERTEX, None).unwrap();
+        bs.change(id, (), BufferUses::INDEX, None).unwrap();
+        assert_eq!(bs, Unit::new(BufferUses::VERTEX | BufferUses::INDEX));
     }
 
     #[test]
     fn change_replace() {
         let mut bs = Unit {
             first: None,
-            last: BufferUse::STORAGE_STORE,
+            last: BufferUses::STORAGE_WRITE,
         };
         let id = Id::dummy();
         let mut list = Vec::new();
-        bs.change(id, (), BufferUse::VERTEX, Some(&mut list))
+        bs.change(id, (), BufferUses::VERTEX, Some(&mut list))
             .unwrap();
         assert_eq!(
             &list,
             &[PendingTransition {
                 id,
                 selector: (),
-                usage: BufferUse::STORAGE_STORE..BufferUse::VERTEX,
+                usage: BufferUses::STORAGE_WRITE..BufferUses::VERTEX,
             }],
         );
         assert_eq!(
             bs,
             Unit {
-                first: Some(BufferUse::STORAGE_STORE),
-                last: BufferUse::VERTEX,
+                first: Some(BufferUses::STORAGE_WRITE),
+                last: BufferUses::VERTEX,
             }
         );
 
         list.clear();
-        bs.change(id, (), BufferUse::STORAGE_STORE, Some(&mut list))
+        bs.change(id, (), BufferUses::STORAGE_WRITE, Some(&mut list))
             .unwrap();
         assert_eq!(
             &list,
             &[PendingTransition {
                 id,
                 selector: (),
-                usage: BufferUse::VERTEX..BufferUse::STORAGE_STORE,
+                usage: BufferUses::VERTEX..BufferUses::STORAGE_WRITE,
             }],
         );
         assert_eq!(
             bs,
             Unit {
-                first: Some(BufferUse::STORAGE_STORE),
-                last: BufferUse::STORAGE_STORE,
-            }
-        );
-    }
-
-    #[test]
-    fn prepend() {
-        let mut bs = Unit {
-            first: None,
-            last: BufferUse::VERTEX,
-        };
-        let id = Id::dummy();
-        bs.prepend(id, (), BufferUse::INDEX).unwrap();
-        bs.prepend(id, (), BufferUse::INDEX).unwrap();
-        assert_eq!(
-            bs.prepend(id, (), BufferUse::STORAGE_LOAD),
-            Err(PendingTransition {
-                id,
-                selector: (),
-                usage: BufferUse::INDEX..BufferUse::STORAGE_LOAD,
-            })
-        );
-        assert_eq!(
-            bs,
-            Unit {
-                first: Some(BufferUse::INDEX),
-                last: BufferUse::VERTEX,
+                first: Some(BufferUses::STORAGE_WRITE),
+                last: BufferUses::STORAGE_WRITE,
             }
         );
     }
 }