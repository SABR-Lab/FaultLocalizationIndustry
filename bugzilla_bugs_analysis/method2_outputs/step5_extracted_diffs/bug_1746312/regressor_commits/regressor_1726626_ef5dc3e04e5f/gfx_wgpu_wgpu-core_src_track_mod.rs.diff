# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-core/src/track/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-core/src/track/mod.rs b/third_party/rust/wgpu-core/src/track/mod.rs
rename from gfx/wgpu/wgpu-core/src/track/mod.rs
rename to third_party/rust/wgpu-core/src/track/mod.rs
--- a/gfx/wgpu/wgpu-core/src/track/mod.rs
+++ b/third_party/rust/wgpu-core/src/track/mod.rs
@@ -1,23 +1,21 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 mod buffer;
 mod range;
 mod texture;
 
 use crate::{
-    conv, hub,
+    hub,
     id::{self, TypedId, Valid},
     resource, Epoch, FastHashMap, Index, RefCount,
 };
 
-use std::{collections::hash_map::Entry, fmt, marker::PhantomData, ops, vec::Drain};
+use std::{
+    collections::hash_map::Entry, fmt, marker::PhantomData, num::NonZeroU32, ops, vec::Drain,
+};
 use thiserror::Error;
 
 pub(crate) use buffer::BufferState;
 pub(crate) use texture::{TextureSelector, TextureState};
 
 /// A single unit of state tracking. It keeps an initial
 /// usage as well as the last/current one, similar to `Range`.
 #[derive(Clone, Copy, Debug, PartialEq)]
@@ -73,24 +71,16 @@ pub(crate) trait ResourceState: Clone + 
     fn change(
         &mut self,
         id: Valid<Self::Id>,
         selector: Self::Selector,
         usage: Self::Usage,
         output: Option<&mut Vec<PendingTransition<Self>>>,
     ) -> Result<(), PendingTransition<Self>>;
 
-    /// Sets up the first usage of the selected sub-resources.
-    fn prepend(
-        &mut self,
-        id: Valid<Self::Id>,
-        selector: Self::Selector,
-        usage: Self::Usage,
-    ) -> Result<(), PendingTransition<Self>>;
-
     /// Merge the state of this resource tracked by a different instance
     /// with the current one.
     ///
     /// Same rules for `output` apply as with `change()`: last usage state
     /// is either replaced (when `output` is provided) with a
     /// `PendingTransition` pushed to this vector, or extended with the
     /// other read-only usage, unless there is a usage conflict, and
     /// the error is generated (returning the conflict).
@@ -120,73 +110,71 @@ struct Resource<S> {
 #[derive(Debug, PartialEq)]
 pub(crate) struct PendingTransition<S: ResourceState> {
     pub id: Valid<S::Id>,
     pub selector: S::Selector,
     pub usage: ops::Range<S::Usage>,
 }
 
 impl PendingTransition<BufferState> {
-    /// Produce the gfx-hal barrier corresponding to the transition.
-    pub fn into_hal<'a, B: hal::Backend>(
+    /// Produce the hal barrier corresponding to the transition.
+    pub fn into_hal<'a, A: hal::Api>(
         self,
-        buf: &'a resource::Buffer<B>,
-    ) -> hal::memory::Barrier<'a, B> {
+        buf: &'a resource::Buffer<A>,
+    ) -> hal::BufferBarrier<'a, A> {
         log::trace!("\tbuffer -> {:?}", self);
-        let &(ref target, _) = buf.raw.as_ref().expect("Buffer is destroyed");
-        hal::memory::Barrier::Buffer {
-            states: conv::map_buffer_state(self.usage.start)
-                ..conv::map_buffer_state(self.usage.end),
-            target,
-            range: hal::buffer::SubRange::WHOLE,
-            families: None,
+        let buffer = buf.raw.as_ref().expect("Buffer is destroyed");
+        hal::BufferBarrier {
+            buffer,
+            usage: self.usage,
         }
     }
 }
 
 impl From<PendingTransition<BufferState>> for UsageConflict {
     fn from(e: PendingTransition<BufferState>) -> Self {
         Self::Buffer {
             id: e.id.0,
             combined_use: e.usage.end,
         }
     }
 }
 
 impl PendingTransition<TextureState> {
-    /// Produce the gfx-hal barrier corresponding to the transition.
-    pub fn into_hal<'a, B: hal::Backend>(
+    /// Produce the hal barrier corresponding to the transition.
+    pub fn into_hal<'a, A: hal::Api>(
         self,
-        tex: &'a resource::Texture<B>,
-    ) -> hal::memory::Barrier<'a, B> {
+        tex: &'a resource::Texture<A>,
+    ) -> hal::TextureBarrier<'a, A> {
         log::trace!("\ttexture -> {:?}", self);
-        let &(ref target, _) = tex.raw.as_ref().expect("Texture is destroyed");
-        let aspects = tex.aspects;
-        hal::memory::Barrier::Image {
-            states: conv::map_texture_state(self.usage.start, aspects)
-                ..conv::map_texture_state(self.usage.end, aspects),
-            target,
-            range: hal::image::SubresourceRange {
-                aspects,
-                level_start: self.selector.levels.start,
-                level_count: Some(self.selector.levels.end - self.selector.levels.start),
-                layer_start: self.selector.layers.start,
-                layer_count: Some(self.selector.layers.end - self.selector.layers.start),
+        let texture = tex.inner.as_raw().expect("Texture is destroyed");
+        hal::TextureBarrier {
+            texture,
+            range: wgt::ImageSubresourceRange {
+                aspect: wgt::TextureAspect::All,
+                base_mip_level: self.selector.levels.start,
+                mip_level_count: NonZeroU32::new(
+                    self.selector.levels.end - self.selector.levels.start,
+                ),
+                base_array_layer: self.selector.layers.start,
+                array_layer_count: NonZeroU32::new(
+                    self.selector.layers.end - self.selector.layers.start,
+                ),
             },
-            families: None,
+            usage: self.usage,
         }
     }
 }
 
 impl From<PendingTransition<TextureState>> for UsageConflict {
     fn from(e: PendingTransition<TextureState>) -> Self {
         Self::Texture {
             id: e.id.0,
-            mip_levels: e.selector.levels.start as u32..e.selector.levels.end as u32,
-            array_layers: e.selector.layers.start as u32..e.selector.layers.end as u32,
+            mip_levels: e.selector.levels.start..e.selector.levels.end,
+            array_layers: e.selector.layers.start..e.selector.layers.end,
             combined_use: e.usage.end,
         }
     }
 }
 
 #[derive(Clone, Debug, Error)]
 pub enum UseExtendError<U: fmt::Debug> {
     #[error("resource is invalid")]
@@ -270,18 +258,28 @@ impl<S: ResourceState> ResourceTracker<S
     /// Return an iterator over used resources keys.
     pub fn used<'a>(&'a self) -> impl 'a + Iterator<Item = Valid<S::Id>> {
         let backend = self.backend;
         self.map
             .iter()
             .map(move |(&index, resource)| Valid(S::Id::zip(index, resource.epoch, backend)))
     }
 
+    pub fn get_ref_count(&self, id: Valid<S::Id>) -> &RefCount {
+        let (index, _, _) = id.0.unzip();
+        &self.map[&index].ref_count
+    }
+
+    /// Return true if there is nothing here.
+    pub fn is_empty(&self) -> bool {
+        self.map.is_empty()
+    }
+
     /// Clear the tracked contents.
-    fn clear(&mut self) {
+    pub fn clear(&mut self) {
         self.map.clear();
     }
 
     /// Initialize a resource to be used.
     ///
     /// Returns false if the resource is already registered.
     pub(crate) fn init(
         &mut self,
@@ -303,16 +301,17 @@ impl<S: ResourceState> ResourceTracker<S
             Entry::Occupied(e) => Err(&e.into_mut().state),
         }
     }
 
     /// Query the usage of a resource selector.
     ///
     /// Returns `Some(Usage)` only if this usage is consistent
     /// across the given selector.
+    #[allow(unused)] // TODO: figure out if this needs to be removed
     pub fn query(&self, id: Valid<S::Id>, selector: S::Selector) -> Option<S::Usage> {
         let (index, epoch, backend) = id.0.unzip();
         debug_assert_eq!(backend, self.backend);
         let res = self.map.get(&index)?;
         assert_eq!(res.epoch, epoch);
         res.state.query(selector)
     }
 
@@ -391,31 +390,16 @@ impl<S: ResourceState> ResourceTracker<S
     ) -> Drain<PendingTransition<S>> {
         let res = Self::get(self.backend, &mut self.map, id);
         res.state
             .change(id, selector, usage, Some(&mut self.temp))
             .ok();
         self.temp.drain(..)
     }
 
-    /// Turn the tracking from the "expand" mode into the "replace" one,
-    /// installing the selected usage as the "first".
-    /// This is a special operation only used by the render pass attachments.
-    pub(crate) fn prepend(
-        &mut self,
-        id: Valid<S::Id>,
-        ref_count: &RefCount,
-        selector: S::Selector,
-        usage: S::Usage,
-    ) -> Result<(), PendingTransition<S>> {
-        Self::get_or_insert(self.backend, &mut self.map, id, ref_count)
-            .state
-            .prepend(id, selector, usage)
-    }
-
     /// Merge another tracker into `self` by extending the current states
     /// without any transitions.
     pub(crate) fn merge_extend(&mut self, other: &Self) -> Result<(), PendingTransition<S>> {
         debug_assert_eq!(self.backend, other.backend);
         for (&index, new) in other.map.iter() {
             match self.map.entry(index) {
                 Entry::Vacant(e) => {
                     e.insert(new.clone());
@@ -522,25 +506,16 @@ impl<I: Copy + fmt::Debug + TypedId> Res
         _id: Valid<Self::Id>,
         _selector: Self::Selector,
         _usage: Self::Usage,
         _output: Option<&mut Vec<PendingTransition<Self>>>,
     ) -> Result<(), PendingTransition<Self>> {
         Ok(())
     }
 
-    fn prepend(
-        &mut self,
-        _id: Valid<Self::Id>,
-        _selector: Self::Selector,
-        _usage: Self::Usage,
-    ) -> Result<(), PendingTransition<Self>> {
-        Ok(())
-    }
-
     fn merge(
         &mut self,
         _id: Valid<Self::Id>,
         _other: &Self,
         _output: Option<&mut Vec<PendingTransition<Self>>>,
     ) -> Result<(), PendingTransition<Self>> {
         Ok(())
     }
@@ -552,24 +527,24 @@ pub const DUMMY_SELECTOR: () = ();
 
 #[derive(Clone, Debug, Error)]
 pub enum UsageConflict {
     #[error(
         "Attempted to use buffer {id:?} as a combination of {combined_use:?} within a usage scope."
     )]
     Buffer {
         id: id::BufferId,
-        combined_use: resource::BufferUse,
+        combined_use: hal::BufferUses,
     },
     #[error("Attempted to use texture {id:?} mips {mip_levels:?} layers {array_layers:?} as a combination of {combined_use:?} within a usage scope.")]
     Texture {
         id: id::TextureId,
         mip_levels: ops::Range<u32>,
         array_layers: ops::Range<u32>,
-        combined_use: resource::TextureUse,
+        combined_use: hal::TextureUses,
     },
 }
 
 /// A set of trackers for all relevant resources.
 #[derive(Debug)]
 pub(crate) struct TrackerSet {
     pub buffers: ResourceTracker<BufferState>,
     pub textures: ResourceTracker<TextureState>,
@@ -594,17 +569,17 @@ impl TrackerSet {
             compute_pipes: ResourceTracker::new(backend),
             render_pipes: ResourceTracker::new(backend),
             bundles: ResourceTracker::new(backend),
             query_sets: ResourceTracker::new(backend),
         }
     }
 
     /// Clear all the trackers.
-    pub fn clear(&mut self) {
+    pub fn _clear(&mut self) {
         self.buffers.clear();
         self.textures.clear();
         self.views.clear();
         self.bind_groups.clear();
         self.samplers.clear();
         self.compute_pipes.clear();
         self.render_pipes.clear();
         self.bundles.clear();
@@ -619,39 +594,24 @@ impl TrackerSet {
         self.bind_groups.optimize();
         self.samplers.optimize();
         self.compute_pipes.optimize();
         self.render_pipes.optimize();
         self.bundles.optimize();
         self.query_sets.optimize();
     }
 
-    /// Merge all the trackers of another instance by extending
-    /// the usage. Panics on a stateless conflict, returns a conflict otherwise.
-    pub fn merge_extend_all(&mut self, other: &Self) -> Result<(), UsageConflict> {
+    /// Merge only the stateful trackers of another instance by extending
+    /// the usage. Returns a conflict if any.
+    pub fn merge_extend_stateful(&mut self, other: &Self) -> Result<(), UsageConflict> {
         self.buffers.merge_extend(&other.buffers)?;
         self.textures.merge_extend(&other.textures)?;
-        self.merge_extend_stateless(other);
         Ok(())
     }
 
-    /// Merge all the stateless trackers of another instance by extending
-    /// the usage. Panics on a conflict.
-    pub fn merge_extend_stateless(&mut self, other: &Self) {
-        self.views.merge_extend(&other.views).unwrap();
-        self.bind_groups.merge_extend(&other.bind_groups).unwrap();
-        self.samplers.merge_extend(&other.samplers).unwrap();
-        self.compute_pipes
-            .merge_extend(&other.compute_pipes)
-            .unwrap();
-        self.render_pipes.merge_extend(&other.render_pipes).unwrap();
-        self.bundles.merge_extend(&other.bundles).unwrap();
-        self.query_sets.merge_extend(&other.query_sets).unwrap();
-    }
-
     pub fn backend(&self) -> wgt::Backend {
         self.buffers.backend
     }
 }
 
 #[derive(Debug)]
 pub(crate) struct StatefulTrackerSubset {
     pub buffers: ResourceTracker<BufferState>,