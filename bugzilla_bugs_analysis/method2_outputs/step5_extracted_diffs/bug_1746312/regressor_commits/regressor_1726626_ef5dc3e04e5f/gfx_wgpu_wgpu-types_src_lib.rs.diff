# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu/wgpu-types/src/lib.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/gfx/wgpu/wgpu-types/src/lib.rs b/third_party/rust/wgpu-types/src/lib.rs
rename from gfx/wgpu/wgpu-types/src/lib.rs
rename to third_party/rust/wgpu-types/src/lib.rs
--- a/gfx/wgpu/wgpu-types/src/lib.rs
+++ b/third_party/rust/wgpu-types/src/lib.rs
@@ -1,18 +1,14 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
 /*! This library describes the API surface of WebGPU that is agnostic of the backend.
  *  This API is used for targeting both Web and Native.
  */
 
 #![allow(
-    // The intra doc links to the wgpu crate in this crate actually succesfully link to the types in the wgpu crate, when built from the wgpu crate.
+    // The intra doc links to the wgpu crate in this crate actually successfully link to the types in the wgpu crate, when built from the wgpu crate.
     // However when building from both the wgpu crate or this crate cargo doc will claim all the links cannot be resolved
     // despite the fact that it works fine when it needs to.
     // So we just disable those warnings.
     broken_intra_doc_links,
     // We don't use syntax sugar where it's not necessary.
     clippy::match_like_matches_macro,
 )]
 #![warn(missing_docs)]
@@ -33,16 +29,18 @@ pub type DynamicOffset = u32;
 /// Buffer-Texture copies must have [`bytes_per_row`] aligned to this number.
 ///
 /// This doesn't apply to [`Queue::write_texture`].
 ///
 /// [`bytes_per_row`]: ImageDataLayout::bytes_per_row
 pub const COPY_BYTES_PER_ROW_ALIGNMENT: u32 = 256;
 /// Bound uniform/storage buffer offsets must be aligned to this number.
 pub const BIND_BUFFER_ALIGNMENT: BufferAddress = 256;
+/// An offset into the query resolve buffer has to be aligned to this.
+pub const QUERY_RESOLVE_BUFFER_ALIGNMENT: BufferAddress = 256;
 /// Buffer to buffer copy as well as buffer clear offsets and sizes must be aligned to this number.
 pub const COPY_BUFFER_ALIGNMENT: BufferAddress = 4;
 /// Size to align mappings.
 pub const MAP_ALIGNMENT: BufferAddress = 8;
 /// Vertex buffer strides have to be aligned to this number.
 pub const VERTEX_STRIDE_ALIGNMENT: BufferAddress = 4;
 /// Alignment all push constants need
 pub const PUSH_CONSTANT_ALIGNMENT: u32 = 4;
@@ -73,16 +71,17 @@ pub enum Backend {
     BrowserWebGpu = 6,
 }
 
 /// Power Preference when choosing a physical adapter.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum PowerPreference {
     /// Adapter that uses the least possible power. This is often an integrated GPU.
     LowPower = 0,
     /// Adapter that has the highest performance. This is often a discrete GPU.
     HighPerformance = 1,
 }
 
 impl Default for PowerPreference {
@@ -91,17 +90,17 @@ impl Default for PowerPreference {
     }
 }
 
 bitflags::bitflags! {
     /// Represents the backends that wgpu will use.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
-    pub struct BackendBit: u32 {
+    pub struct Backends: u32 {
         /// Supported on Windows, Linux/Android, and macOS/iOS via Vulkan Portability (with the Vulkan feature enabled)
         const VULKAN = 1 << Backend::Vulkan as u32;
         /// Currently unsupported
         const GL = 1 << Backend::Gl as u32;
         /// Supported on macOS/iOS
         const METAL = 1 << Backend::Metal as u32;
         /// Supported on Windows 10
         const DX12 = 1 << Backend::Dx12 as u32;
@@ -119,17 +118,17 @@ bitflags::bitflags! {
         /// All the apis that wgpu offers second tier of support for. These may
         /// be unsupported/still experimental.
         ///
         /// OpenGL + DX11
         const SECONDARY = Self::GL.bits | Self::DX11.bits;
     }
 }
 
-impl From<Backend> for BackendBit {
+impl From<Backend> for Backends {
     fn from(backend: Backend) -> Self {
         Self::from_bits(1 << backend as u32).unwrap()
     }
 }
 
 /// Options for requesting adapter.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
@@ -147,16 +146,18 @@ impl<S> Default for RequestAdapterOption
     fn default() -> Self {
         Self {
             power_preference: PowerPreference::default(),
             compatible_surface: None,
         }
     }
 }
 
+//TODO: make robust resource access configurable
+
 bitflags::bitflags! {
     /// Features that are not guaranteed to be supported.
     ///
     /// These are either part of the webgpu standard, or are extension features supported by
     /// wgpu when targeting native.
     ///
     /// If you want to use a feature, you need to first verify that the adapter supports
     /// the feature. If the adapter does not support the feature, requesting a device with it enabled
@@ -172,104 +173,152 @@ bitflags::bitflags! {
         /// With this extension, we can force clamping of the polygon depth to 0-1. That allows
         /// shadow map occluders to be rendered into a tighter depth range.
         ///
         /// Supported platforms:
         /// - desktops
         /// - some mobile chips
         ///
         /// This is a web and native feature.
-        const DEPTH_CLAMPING = 0x0000_0000_0000_0001;
+        const DEPTH_CLAMPING = 1 << 0;
         /// Enables BCn family of compressed textures. All BCn textures use 4x4 pixel blocks
         /// with 8 or 16 bytes per block.
         ///
         /// Compressed textures sacrifice some quality in exchange for significantly reduced
         /// bandwidth usage.
         ///
-        /// Support for this feature guarantees availability of [`TextureUsage::COPY_SRC | TextureUsage::COPY_DST | TextureUsage::SAMPLED`] for BCn formats.
+        /// Support for this feature guarantees availability of [`TextureUsages::COPY_SRC | TextureUsages::COPY_DST | TextureUsages::TEXTURE_BINDING`] for BCn formats.
         /// [`Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES`] may enable additional usages.
         ///
         /// Supported Platforms:
         /// - desktops
         ///
         /// This is a web and native feature.
-        const TEXTURE_COMPRESSION_BC = 0x0000_0000_0000_0002;
+        const TEXTURE_COMPRESSION_BC = 1 << 1;
         /// Enables use of Timestamp Queries. These queries tell the current gpu timestamp when
         /// all work before the query is finished. Call [`CommandEncoder::write_timestamp`],
         /// [`RenderPassEncoder::write_timestamp`], or [`ComputePassEncoder::write_timestamp`] to
         /// write out a timestamp.
         ///
         /// They must be resolved using [`CommandEncoder::resolve_query_sets`] into a buffer,
         /// then the result must be multiplied by the timestamp period [`Device::get_timestamp_period`]
         /// to get the timestamp in nanoseconds. Multiple timestamps can then be diffed to get the
         /// time for operations between them to finish.
         ///
         /// Due to gfx-hal limitations, this is only supported on vulkan for now.
         ///
         /// Supported Platforms:
         /// - Vulkan (works)
-        /// - DX12 (future)
+        /// - DX12 (works)
         ///
         /// This is a web and native feature.
-        const TIMESTAMP_QUERY = 0x0000_0000_0000_0004;
+        const TIMESTAMP_QUERY = 1 << 2;
         /// Enables use of Pipeline Statistics Queries. These queries tell the count of various operations
         /// performed between the start and stop call. Call [`RenderPassEncoder::begin_pipeline_statistics_query`] to start
         /// a query, then call [`RenderPassEncoder::end_pipeline_statistics_query`] to stop one.
         ///
         /// They must be resolved using [`CommandEncoder::resolve_query_sets`] into a buffer.
         /// The rules on how these resolve into buffers are detailed in the documentation for [`PipelineStatisticsTypes`].
         ///
         /// Due to gfx-hal limitations, this is only supported on vulkan for now.
         ///
         /// Supported Platforms:
         /// - Vulkan (works)
-        /// - DX12 (future)
+        /// - DX12 (works)
         ///
         /// This is a web and native feature.
-        const PIPELINE_STATISTICS_QUERY = 0x0000_0000_0000_0008;
+        const PIPELINE_STATISTICS_QUERY = 1 << 3;
         /// Webgpu only allows the MAP_READ and MAP_WRITE buffer usage to be matched with
         /// COPY_DST and COPY_SRC respectively. This removes this requirement.
         ///
         /// This is only beneficial on systems that share memory between CPU and GPU. If enabled
         /// on a system that doesn't, this can severely hinder performance. Only use if you understand
         /// the consequences.
         ///
         /// Supported platforms:
         /// - All
         ///
         /// This is a native only feature.
-        const MAPPABLE_PRIMARY_BUFFERS = 0x0000_0000_0001_0000;
-        /// Allows the user to create uniform arrays of sampled textures in shaders:
+        const MAPPABLE_PRIMARY_BUFFERS = 1 << 16;
+        /// Allows the user to create uniform arrays of textures in shaders:
         ///
         /// eg. `uniform texture2D textures[10]`.
         ///
-        /// This capability allows them to exist and to be indexed by compile time constant
+        /// If [`Features::STORAGE_RESOURCE_BINDING_ARRAY`] is supported as well as this, the user
+        /// may also create uniform arrays of storage textures.
+        ///
+        /// eg. `uniform image2D textures[10]`.
+        ///
+        /// This capability allows them to exist and to be indexed by dynamically uniform
         /// values.
         ///
         /// Supported platforms:
         /// - DX12
         /// - Metal (with MSL 2.0+ on macOS 10.13+)
         /// - Vulkan
         ///
         /// This is a native only feature.
-        const SAMPLED_TEXTURE_BINDING_ARRAY = 0x0000_0000_0002_0000;
-        /// Allows shaders to index sampled texture arrays with dynamically uniform values:
+        const TEXTURE_BINDING_ARRAY = 1 << 17;
+        /// Allows the user to create arrays of buffers in shaders:
+        ///
+        /// eg. `uniform myBuffer { .... } buffer_array[10]`.
+        ///
+        /// This capability allows them to exist and to be indexed by dynamically uniform
+        /// values.
+        ///
+        /// If [`Features::STORAGE_RESOURCE_BINDING_ARRAY`] is supported as well as this, the user
+        /// may also create arrays of storage buffers.
+        ///
+        /// eg. `buffer myBuffer { ... } buffer_array[10]`
+        ///
+        /// Supported platforms:
+        /// - DX12
+        /// - Vulkan
+        ///
+        /// This is a native only feature.
+        const BUFFER_BINDING_ARRAY = 1 << 18;
+        /// Allows the user to create uniform arrays of storage buffers or textures in shaders,
+        /// if resp. [`Features::BUFFER_BINDING_ARRAY`] or [`Features::TEXTURE_BINDING_ARRAY`]
+        /// is supported.
         ///
-        /// eg. `texture_array[uniform_value]`
+        /// This capability allows them to exist and to be indexed by dynamically uniform
+        /// values.
+        ///
+        /// Supported platforms:
+        /// - Metal (with MSL 2.2+ on macOS 10.13+)
+        /// - Vulkan
+        ///
+        /// This is a native only feature.
+        const STORAGE_RESOURCE_BINDING_ARRAY = 1 << 19;
+        /// Allows shaders to index sampled texture and storage buffer resource arrays with dynamically non-uniform values:
+        ///
+        /// eg. `texture_array[vertex_data]`
         ///
-        /// This capability means the hardware will also support SAMPLED_TEXTURE_BINDING_ARRAY.
+        /// In order to use this capability, the corresponding GLSL extension must be enabled like so:
+        ///
+        /// `#extension GL_EXT_nonuniform_qualifier : require`
+        ///
+        /// and then used either as `nonuniformEXT` qualifier in variable declaration:
+        ///
+        /// eg. `layout(location = 0) nonuniformEXT flat in int vertex_data;`
+        ///
+        /// or as `nonuniformEXT` constructor:
+        ///
+        /// eg. `texture_array[nonuniformEXT(vertex_data)]`
+        ///
+        /// HLSL does not need any extension.
         ///
         /// Supported platforms:
         /// - DX12
         /// - Metal (with MSL 2.0+ on macOS 10.13+)
-        /// - Vulkan's shaderSampledImageArrayDynamicIndexing feature
+        /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s shaderSampledImageArrayNonUniformIndexing & shaderStorageBufferArrayNonUniformIndexing feature)
         ///
         /// This is a native only feature.
-        const SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING = 0x0000_0000_0004_0000;
-        /// Allows shaders to index sampled texture arrays with dynamically non-uniform values:
+        const SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING = 1 << 20;
+        /// Allows shaders to index uniform buffer and storage texture resource arrays with dynamically non-uniform values:
         ///
         /// eg. `texture_array[vertex_data]`
         ///
         /// In order to use this capability, the corresponding GLSL extension must be enabled like so:
         ///
         /// `#extension GL_EXT_nonuniform_qualifier : require`
         ///
         /// and then used either as `nonuniformEXT` qualifier in variable declaration:
@@ -277,300 +326,257 @@ bitflags::bitflags! {
         /// eg. `layout(location = 0) nonuniformEXT flat in int vertex_data;`
         ///
         /// or as `nonuniformEXT` constructor:
         ///
         /// eg. `texture_array[nonuniformEXT(vertex_data)]`
         ///
         /// HLSL does not need any extension.
         ///
-        /// This capability means the hardware will also support SAMPLED_TEXTURE_ARRAY_DYNAMIC_INDEXING
-        /// and SAMPLED_TEXTURE_BINDING_ARRAY.
-        ///
         /// Supported platforms:
         /// - DX12
         /// - Metal (with MSL 2.0+ on macOS 10.13+)
-        /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s shaderSampledImageArrayNonUniformIndexing feature)
+        /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s shaderUniformBufferArrayNonUniformIndexing & shaderStorageTextureArrayNonUniformIndexing feature)
         ///
         /// This is a native only feature.
-        const SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING = 0x0000_0000_0008_0000;
+        const UNIFORM_BUFFER_AND_STORAGE_TEXTURE_ARRAY_NON_UNIFORM_INDEXING = 1 << 21;
         /// Allows the user to create unsized uniform arrays of bindings:
         ///
         /// eg. `uniform texture2D textures[]`.
         ///
-        /// If this capability is supported, SAMPLED_TEXTURE_ARRAY_NON_UNIFORM_INDEXING is very likely
-        /// to also be supported
-        ///
         /// Supported platforms:
         /// - DX12
         /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s runtimeDescriptorArray feature
         ///
         /// This is a native only feature.
-        const UNSIZED_BINDING_ARRAY = 0x0000_0000_0010_0000;
+        const UNSIZED_BINDING_ARRAY = 1 << 22;
         /// Allows the user to call [`RenderPass::multi_draw_indirect`] and [`RenderPass::multi_draw_indexed_indirect`].
         ///
         /// Allows multiple indirect calls to be dispatched from a single buffer.
         ///
         /// Supported platforms:
         /// - DX12
-        /// - Metal
         /// - Vulkan
         ///
         /// This is a native only feature.
-        const MULTI_DRAW_INDIRECT = 0x0000_0000_0020_0000;
+        const MULTI_DRAW_INDIRECT = 1 << 23;
         /// Allows the user to call [`RenderPass::multi_draw_indirect_count`] and [`RenderPass::multi_draw_indexed_indirect_count`].
         ///
         /// This allows the use of a buffer containing the actual number of draw calls.
         ///
         /// Supported platforms:
         /// - DX12
         /// - Vulkan 1.2+ (or VK_KHR_draw_indirect_count)
         ///
         /// This is a native only feature.
-        const MULTI_DRAW_INDIRECT_COUNT = 0x0000_0000_0040_0000;
+        const MULTI_DRAW_INDIRECT_COUNT = 1 << 24;
         /// Allows the use of push constants: small, fast bits of memory that can be updated
         /// inside a [`RenderPass`].
         ///
         /// Allows the user to call [`RenderPass::set_push_constants`], provide a non-empty array
         /// to [`PipelineLayoutDescriptor`], and provide a non-zero limit to [`Limits::max_push_constant_size`].
         ///
         /// A block of push constants can be declared with `layout(push_constant) uniform Name {..}` in shaders.
         ///
         /// Supported platforms:
         /// - DX12
         /// - Vulkan
         /// - Metal
         /// - DX11 (emulated with uniforms)
         /// - OpenGL (emulated with uniforms)
         ///
         /// This is a native only feature.
-        const PUSH_CONSTANTS = 0x0000_0000_0080_0000;
+        const PUSH_CONSTANTS = 1 << 25;
         /// Allows the use of [`AddressMode::ClampToBorder`].
         ///
         /// Supported platforms:
         /// - DX12
         /// - Vulkan
         /// - Metal (macOS 10.12+ only)
         /// - DX11
         /// - OpenGL
         ///
         /// This is a web and native feature.
-        const ADDRESS_MODE_CLAMP_TO_BORDER = 0x0000_0000_0100_0000;
-        /// Allows the user to set a non-fill polygon mode in [`PrimitiveState::polygon_mode`]
+        const ADDRESS_MODE_CLAMP_TO_BORDER = 1 << 26;
+        /// Allows the user to set [`PolygonMode::Line`] in [`PrimitiveState::polygon_mode`]
+        ///
+        /// This allows drawing polygons/triangles as lines (wireframe) instead of filled
         ///
-        /// This allows drawing polygons/triangles as lines (wireframe) or points instead of filled
+        /// Supported platforms:
+        /// - DX12
+        /// - Vulkan
+        /// - Metal
+        ///
+        /// This is a native only feature.
+        const POLYGON_MODE_LINE= 1 << 27;
+        /// Allows the user to set [`PolygonMode::Point`] in [`PrimitiveState::polygon_mode`]
+        ///
+        /// This allows only drawing the vertices of polygons/triangles instead of filled
         ///
         /// Supported platforms:
         /// - DX12
         /// - Vulkan
         ///
         /// This is a native only feature.
-        const NON_FILL_POLYGON_MODE = 0x0000_0000_0200_0000;
+        const POLYGON_MODE_POINT = 1 << 28;
         /// Enables ETC family of compressed textures. All ETC textures use 4x4 pixel blocks.
         /// ETC2 RGB and RGBA1 are 8 bytes per block. RTC2 RGBA8 and EAC are 16 bytes per block.
         ///
         /// Compressed textures sacrifice some quality in exchange for significantly reduced
         /// bandwidth usage.
         ///
-        /// Support for this feature guarantees availability of [`TextureUsage::COPY_SRC | TextureUsage::COPY_DST | TextureUsage::SAMPLED`] for ETC2 formats.
+        /// Support for this feature guarantees availability of [`TextureUsages::COPY_SRC | TextureUsages::COPY_DST | TextureUsages::TEXTURE_BINDING`] for ETC2 formats.
         /// [`Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES`] may enable additional usages.
         ///
         /// Supported Platforms:
         /// - Intel/Vulkan
         /// - Mobile (some)
         ///
         /// This is a native-only feature.
-        const TEXTURE_COMPRESSION_ETC2 = 0x0000_0000_0400_0000;
+        const TEXTURE_COMPRESSION_ETC2 = 1 << 29;
         /// Enables ASTC family of compressed textures. ASTC textures use pixel blocks varying from 4x4 to 12x12.
         /// Blocks are always 16 bytes.
         ///
         /// Compressed textures sacrifice some quality in exchange for significantly reduced
         /// bandwidth usage.
         ///
-        /// Support for this feature guarantees availability of [`TextureUsage::COPY_SRC | TextureUsage::COPY_DST | TextureUsage::SAMPLED`] for ASTC formats.
+        /// Support for this feature guarantees availability of [`TextureUsages::COPY_SRC | TextureUsages::COPY_DST | TextureUsages::TEXTURE_BINDING`] for ASTC formats.
         /// [`Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES`] may enable additional usages.
         ///
         /// Supported Platforms:
         /// - Intel/Vulkan
         /// - Mobile (some)
         ///
         /// This is a native-only feature.
-        const TEXTURE_COMPRESSION_ASTC_LDR = 0x0000_0000_0800_0000;
+        const TEXTURE_COMPRESSION_ASTC_LDR = 1 << 30;
         /// Enables device specific texture format features.
         ///
         /// See `TextureFormatFeatures` for a listing of the features in question.
         ///
         /// By default only texture format properties as defined by the WebGPU specification are allowed.
         /// Enabling this feature flag extends the features of each format to the ones supported by the current device.
         /// Note that without this flag, read/write storage access is not allowed at all.
         ///
         /// This extension does not enable additional formats.
         ///
         /// This is a native-only feature.
-        const TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES = 0x0000_0000_1000_0000;
+        const TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES = 1 << 31;
         /// Enables 64-bit floating point types in SPIR-V shaders.
         ///
         /// Note: even when supported by GPU hardware, 64-bit floating point operations are
         /// frequently between 16 and 64 _times_ slower than equivalent operations on 32-bit floats.
         ///
         /// Supported Platforms:
         /// - Vulkan
         ///
         /// This is a native-only feature.
-        const SHADER_FLOAT64 = 0x0000_0000_2000_0000;
+        const SHADER_FLOAT64 = 1 << 32;
         /// Enables using 64-bit types for vertex attributes.
         ///
         /// Requires SHADER_FLOAT64.
         ///
         /// Supported Platforms: N/A
         ///
         /// This is a native-only feature.
-        const VERTEX_ATTRIBUTE_64BIT = 0x0000_0000_4000_0000;
+        const VERTEX_ATTRIBUTE_64BIT = 1 << 33;
         /// Allows the user to set a overestimation-conservative-rasterization in [`PrimitiveState::conservative`]
         ///
         /// Processing of degenerate triangles/lines is hardware specific.
         /// Only triangles are supported.
         ///
         /// Supported platforms:
-        /// - DX12
-        /// - Vulkan
-        ///
-        /// This is a native only feature.
-        const CONSERVATIVE_RASTERIZATION = 0x0000_0000_8000_0000;
-        /// Allows the user to create arrays of buffers in shaders:
-        ///
-        /// eg. `uniform myBuffer { .... } buffer_array[10]`.
-        ///
-        /// This capability allows them to exist and to be indexed by compile time constant
-        /// values.
-        ///
-        /// Supported platforms:
-        /// - DX12
         /// - Vulkan
         ///
         /// This is a native only feature.
-        const BUFFER_BINDING_ARRAY = 0x0000_0001_0000_0000;
-        /// Allows shaders to index uniform buffer arrays with dynamically uniform values:
-        ///
-        /// eg. `buffer_array[uniform_value]`
-        ///
-        /// This capability means the hardware will also support BUFFER_BINDING_ARRAY.
-        ///
-        /// Supported platforms:
-        /// - DX12
-        /// - Vulkan's shaderUniformBufferArrayDynamicIndexing feature
-        ///
-        /// This is a native only feature.
-        const UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING = 0x0000_0002_0000_0000;
-        /// Allows shaders to index uniform buffer arrays with dynamically non-uniform values:
-        ///
-        /// eg. `buffer_array[vertex_data]`
-        ///
-        /// In order to use this capability, the corresponding GLSL extension must be enabled like so:
-        ///
-        /// `#extension GL_EXT_nonuniform_qualifier : require`
-        ///
-        /// and then used either as `nonuniformEXT` qualifier in variable declaration:
-        ///
-        /// eg. `layout(location = 0) nonuniformEXT flat in int vertex_data;`
-        ///
-        /// or as `nonuniformEXT` constructor:
-        ///
-        /// eg. `buffer_array[nonuniformEXT(vertex_data)]`
-        ///
-        /// HLSL does not need any extension.
-        ///
-        /// This capability means the hardware will also support UNIFORM_BUFFER_ARRAY_DYNAMIC_INDEXING
-        /// and BUFFER_BINDING_ARRAY.
-        ///
-        /// Supported platforms:
-        /// - DX12
-        /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s shaderUniformBufferArrayNonUniformIndexing feature)
-        ///
-        /// This is a native only feature.
-        const UNIFORM_BUFFER_ARRAY_NON_UNIFORM_INDEXING = 0x0000_0004_0000_0000;
-        /// Allows shaders to index storage buffer arrays with dynamically uniform values:
-        ///
-        /// eg. `buffer_array[uniform_value]`
-        ///
-        /// This capability means the hardware will also support BUFFER_BINDING_ARRAY.
-        ///
-        /// Supported platforms:
-        /// - DX12
-        /// - Vulkan's shaderStorageBufferArrayDynamicIndexing feature
-        ///
-        /// This is a native only feature.
-        const STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING = 0x0000_0008_0000_0000;
-        /// Allows shaders to index storage buffer arrays with dynamically non-uniform values:
-        ///
-        /// eg. `buffer_array[vertex_data]`
-        ///
-        /// In order to use this capability, the corresponding GLSL extension must be enabled like so:
-        ///
-        /// `#extension GL_EXT_nonuniform_qualifier : require`
-        ///
-        /// and then used either as `nonuniformEXT` qualifier in variable declaration:
-        ///
-        /// eg. `layout(location = 0) nonuniformEXT flat in int vertex_data;`
-        ///
-        /// or as `nonuniformEXT` constructor:
-        ///
-        /// eg. `buffer_array[nonuniformEXT(vertex_data)]`
-        ///
-        /// HLSL does not need any extension.
-        ///
-        /// This capability means the hardware will also support STORAGE_BUFFER_ARRAY_DYNAMIC_INDEXING
-        /// and BUFFER_BINDING_ARRAY.
-        ///
-        /// Supported platforms:
-        /// - DX12
-        /// - Vulkan 1.2+ (or VK_EXT_descriptor_indexing)'s shaderStorageBufferArrayNonUniformIndexing feature)
-        ///
-        /// This is a native only feature.
-        const STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING = 0x0000_0010_0000_0000;
+        const CONSERVATIVE_RASTERIZATION = 1 << 34;
         /// Enables bindings of writable storage buffers and textures visible to vertex shaders.
         ///
         /// Note: some (tiled-based) platforms do not support vertex shaders with any side-effects.
         ///
         /// Supported Platforms:
         /// - All
         ///
         /// This is a native-only feature.
-        const VERTEX_WRITABLE_STORAGE = 0x0000_0020_0000_0000;
+        const VERTEX_WRITABLE_STORAGE = 1 << 35;
         /// Enables clear to zero for buffers & images.
         ///
         /// Supported platforms:
         /// - All
         ///
         /// This is a native only feature.
-        const CLEAR_COMMANDS = 0x0000_0001_0000_0000;
+        const CLEAR_COMMANDS = 1 << 36;
+        /// Enables creating shader modules from SPIR-V binary data (unsafe).
+        ///
+        /// SPIR-V data is not parsed or interpreted in any way; you can use
+        /// [`wgpu::make_spirv_raw!`] to check for alignment and magic number when converting from
+        /// raw bytes.
+        ///
+        /// Supported platforms:
+        /// - Vulkan, in case shader's requested capabilities and extensions agree with
+        /// Vulkan implementation.
+        ///
+        /// This is a native only feature.
+        const SPIRV_SHADER_PASSTHROUGH = 1 << 37;
+        /// Enables `builtin(primitive_index)` in fragment shaders.
+        ///
+        /// Note: enables geometry processing for pipelines using the builtin.
+        /// This may come with a significant performance impact on some hardware.
+        /// Other pipelines are not affected.
+        ///
+        /// Supported platforms:
+        /// - Vulkan
+        ///
+        /// This is a native only feature.
+        const SHADER_PRIMITIVE_INDEX = 1 << 38;
+    }
+}
 
-        /// Features which are part of the upstream WebGPU standard.
-        const ALL_WEBGPU = 0x0000_0000_0000_FFFF;
-        /// Features that are only available when targeting native (not web).
-        const ALL_NATIVE = 0xFFFF_FFFF_FFFF_0000;
+impl Features {
+    /// Mask of all features which are part of the upstream WebGPU standard.
+    pub const fn all_webgpu_mask() -> Self {
+        Self::from_bits_truncate(0x0000_0000_0000_FFFF)
+    }
+
+    /// Mask of all features that are only available when targeting native (not web).
+    pub const fn all_native_mask() -> Self {
+        Self::from_bits_truncate(0xFFFF_FFFF_FFFF_0000)
     }
 }
 
 /// Represents the sets of limits an adapter/device supports.
 ///
+/// We provide two different defaults.
+/// - [`Limits::downlevel_defaults()]. This is a set of limits that is guaranteed to
+///   work on all backends, including "downlevel" backends such
+///   as OpenGL and D3D11. For most applications we recommend using these
+///   limits, assuming they are high enough for your application.
+/// - [`Limits::default()`]. This is the set of limits that is guaranteed to
+///   work on all modern backends and is guaranteed to be supported by WebGPU.
+///   Applications needing more modern features can use this as a reasonable set of
+///   limits if they are targeting only desktop and modern mobile devices.
+///
+/// We recommend starting with the most restrictive limits you can and manually
+/// increasing the limits you need boosted. This will let you stay running on
+/// all hardware that supports the limits you need.
+///
 /// Limits "better" than the default must be supported by the adapter and requested when requesting
 /// a device. If limits "better" than the adapter supports are requested, requesting a device will panic.
 /// Once a device is requested, you may only use resources up to the limits requested _even_ if the
 /// adapter supports "better" limits.
 ///
 /// Requesting limits that are "better" than you need may cause performance to decrease because the
 /// implementation needs to support more than is needed. You should ideally only request exactly what
 /// you need.
 ///
 /// See also: <https://gpuweb.github.io/gpuweb/#dictdef-gpulimits>
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct Limits {
     /// Maximum allowed value for the `size.width` of a texture created with `TextureDimension::D1`.
     /// Defaults to 8192. Higher is "better".
     pub max_texture_dimension_1d: u32,
     /// Maximum allowed value for the `size.width` and `size.height` of a texture created with `TextureDimension::D2`.
     /// Defaults to 8192. Higher is "better".
     pub max_texture_dimension_2d: u32,
     /// Maximum allowed value for the `size.width`, `size.height`, and `size.depth_or_array_layers`
@@ -630,80 +636,166 @@ impl Default for Limits {
             max_texture_dimension_2d: 8192,
             max_texture_dimension_3d: 2048,
             max_texture_array_layers: 2048,
             max_bind_groups: 4,
             max_dynamic_uniform_buffers_per_pipeline_layout: 8,
             max_dynamic_storage_buffers_per_pipeline_layout: 4,
             max_sampled_textures_per_shader_stage: 16,
             max_samplers_per_shader_stage: 16,
-            max_storage_buffers_per_shader_stage: 4,
-            max_storage_textures_per_shader_stage: 4,
+            max_storage_buffers_per_shader_stage: 8,
+            max_storage_textures_per_shader_stage: 8,
             max_uniform_buffers_per_shader_stage: 12,
             max_uniform_buffer_binding_size: 16384,
             max_storage_buffer_binding_size: 128 << 20,
             max_vertex_buffers: 8,
             max_vertex_attributes: 16,
             max_vertex_buffer_array_stride: 2048,
             max_push_constant_size: 0,
         }
     }
 }
 
+impl Limits {
+    /// These default limits are guaranteed to be compatible with GLES3, WebGL, and D3D11
+    pub fn downlevel_defaults() -> Self {
+        Self {
+            max_texture_dimension_1d: 2096,
+            max_texture_dimension_2d: 2096,
+            max_texture_dimension_3d: 256,
+            max_texture_array_layers: 256,
+            max_bind_groups: 4,
+            max_dynamic_uniform_buffers_per_pipeline_layout: 8,
+            max_dynamic_storage_buffers_per_pipeline_layout: 4,
+            max_sampled_textures_per_shader_stage: 16,
+            max_samplers_per_shader_stage: 16,
+            max_storage_buffers_per_shader_stage: 4,
+            max_storage_textures_per_shader_stage: 4,
+            max_uniform_buffers_per_shader_stage: 12,
+            max_uniform_buffer_binding_size: 16384,
+            max_storage_buffer_binding_size: 128 << 20,
+            max_vertex_buffers: 8,
+            max_vertex_attributes: 16,
+            max_vertex_buffer_array_stride: 2048,
+            max_push_constant_size: 0,
+        }
+    }
+
+    /// Modify the current limits to use the resolution limits of the other.
+    ///
+    /// This is useful because the swapchain might need to be larger than any other image in the application.
+    ///
+    /// If your application only needs 512x512, you might be running on a 4k display and need extremely high resolution limits.
+    pub fn using_resolution(self, other: Self) -> Self {
+        Self {
+            max_texture_dimension_1d: other.max_texture_dimension_1d,
+            max_texture_dimension_2d: other.max_texture_dimension_2d,
+            max_texture_dimension_3d: other.max_texture_dimension_3d,
+            ..self
+        }
+    }
+}
+
+/// Represents the sets of additional limits on an adapter,
+/// which take place when running on downlevel backends.
+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct DownlevelLimits {}
+
+impl Default for DownlevelLimits {
+    fn default() -> Self {
+        DownlevelLimits {}
+    }
+}
+
 /// Lists various ways the underlying platform does not conform to the WebGPU standard.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
-pub struct DownlevelProperties {
+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct DownlevelCapabilities {
     /// Combined boolean flags.
     pub flags: DownlevelFlags,
+    /// Additional limits
+    pub limits: DownlevelLimits,
     /// Which collections of features shaders support. Defined in terms of D3D's shader models.
     pub shader_model: ShaderModel,
 }
 
-impl Default for DownlevelProperties {
-    // Note, this defaults to all on, as that is the default assumption in wgpu.
-    // gfx-hal's equivalent structure defaults to all off.
+impl Default for DownlevelCapabilities {
     fn default() -> Self {
         Self {
-            flags: DownlevelFlags::COMPLIANT,
+            flags: DownlevelFlags::compliant(),
+            limits: DownlevelLimits::default(),
             shader_model: ShaderModel::Sm5,
         }
     }
 }
 
-impl DownlevelProperties {
+impl DownlevelCapabilities {
     /// Returns true if the underlying platform offers complete support of the baseline WebGPU standard.
     ///
     /// If this returns false, some parts of the API will result in validation errors where they would not normally.
     /// These parts can be determined by the values in this structure.
-    pub fn is_webgpu_compliant(self) -> bool {
-        self == Self::default()
+    pub fn is_webgpu_compliant(&self) -> bool {
+        self.flags.contains(DownlevelFlags::compliant())
+            && self.limits == DownlevelLimits::default()
+            && self.shader_model >= ShaderModel::Sm5
     }
 }
 
 bitflags::bitflags! {
-    /// Binary flags listing various ways the underlying platform does not conform to the WebGPU standard.
+    /// Binary flags listing features that may or may not be present on downlevel adapters.
+    ///
+    /// A downlevel adapter is a GPU adapter that WGPU supports, but with potentially limited
+    /// features, due to the lack of hardware feature support.
+    ///
+    /// Flags that are **not** present for a downlevel adapter or device usually indicates
+    /// non-compliance with the WebGPU specification, but not always.
+    ///
+    /// You can check whether a set of flags is compliant through the
+    /// [`DownlevelCapabilities::is_webgpu_compliant()`] function.
     pub struct DownlevelFlags: u32 {
         /// The device supports compiling and using compute shaders.
-        const COMPUTE_SHADERS = 0x0000_0001;
-        /// Supports creating storage images.
-        const STORAGE_IMAGES = 0x0000_0002;
-        /// Supports reading from a depth/stencil buffer while using as a read-only depth/stencil attachment.
-        const READ_ONLY_DEPTH_STENCIL = 0x0000_0004;
+        const COMPUTE_SHADERS = 1 << 0;
+        /// Supports binding storage buffers and textures to fragment shaders.
+        const FRAGMENT_WRITABLE_STORAGE = 1 << 1;
+        /// Supports indirect drawing and dispatching.
+        const INDIRECT_EXECUTION = 1 << 2;
+        /// Supports non-zero `base_vertex` parameter to indexed draw calls.
+        const BASE_VERTEX = 1 << 3;
+        /// Supports reading from a depth/stencil buffer while using as a read-only depth/stencil
+        /// attachment.
+        const READ_ONLY_DEPTH_STENCIL = 1 << 4;
         /// Supports:
         /// - copy_image_to_image
         /// - copy_buffer_to_image and copy_image_to_buffer with a buffer without a MAP_* usage
-        const DEVICE_LOCAL_IMAGE_COPIES = 0x0000_0008;
+        const DEVICE_LOCAL_IMAGE_COPIES = 1 << 5;
         /// Supports textures with mipmaps which have a non power of two size.
-        const NON_POWER_OF_TWO_MIPMAPPED_TEXTURES = 0x0000_0010;
+        const NON_POWER_OF_TWO_MIPMAPPED_TEXTURES = 1 << 6;
         /// Supports textures that are cube arrays.
-        const CUBE_ARRAY_TEXTURES = 0x0000_0020;
-        /// Supports samplers with anisotropic filtering
-        const ANISOTROPIC_FILTERING = 0x0001_0000;
-        /// All flags are in their compliant state.
-        const COMPLIANT = 0x0000_003F;
+        const CUBE_ARRAY_TEXTURES = 1 << 7;
+        /// Supports comparison samplers.
+        const COMPARISON_SAMPLERS = 1 << 8;
+        /// Supports different blending modes per color target.
+        const INDEPENDENT_BLENDING = 1 << 9;
+        /// Supports storage buffers in vertex shaders.
+        const VERTEX_STORAGE = 1 << 10;
+
+
+        /// Supports samplers with anisotropic filtering. Note this isn't actually required by
+        /// WebGPU, the implementation is allowed to completely ignore aniso clamp. This flag is
+        /// here for native backends so they can comunicate to the user of aniso is enabled.
+        const ANISOTROPIC_FILTERING = 1 << 11;
+    }
+}
+
+impl DownlevelFlags {
+    /// All flags that indicate if the backend is WebGPU compliant
+    pub const fn compliant() -> Self {
+        // We use manual bit twiddling to make this a const fn as `Sub` and `.remove` aren't const
+
+        // WebGPU doesn't actually require aniso
+        Self::from_bits_truncate(Self::all().bits() & !Self::ANISOTROPIC_FILTERING.bits)
     }
 }
 
 /// Collections of shader features a device supports if they support less than WebGPU normally allows.
 // TODO: Fill out the differences between shader models more completely
 #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
 pub enum ShaderModel {
     /// Extremely limited shaders, including a total instruction limit.
@@ -727,16 +819,18 @@ pub enum DeviceType {
     /// Discrete GPU with separate CPU/GPU memory.
     DiscreteGpu,
     /// Virtual / Hosted.
     VirtualGpu,
     /// Cpu / Software Rendering.
     Cpu,
 }
 
+//TODO: convert `vendor` and `device` to `u32`
+
 /// Information about an adapter.
 #[derive(Clone, Debug, PartialEq)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct AdapterInfo {
     /// Adapter name
     pub name: String,
     /// Vendor PCI id of the adapter
@@ -776,97 +870,84 @@ impl<L> DeviceDescriptor<L> {
     }
 }
 
 bitflags::bitflags! {
     /// Describes the shader stages that a binding will be visible from.
     ///
     /// These can be combined so something that is visible from both vertex and fragment shaders can be defined as:
     ///
-    /// `ShaderStage::VERTEX | ShaderStage::FRAGMENT`
+    /// `ShaderStages::VERTEX | ShaderStages::FRAGMENT`
     #[repr(transparent)]
     #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
-    pub struct ShaderStage: u32 {
+    pub struct ShaderStages: u32 {
         /// Binding is not visible from any shader stage.
         const NONE = 0;
         /// Binding is visible from the vertex shader of a render pipeline.
-        const VERTEX = 1;
+        const VERTEX = 1 << 0;
         /// Binding is visible from the fragment shader of a render pipeline.
-        const FRAGMENT = 2;
+        const FRAGMENT = 1 << 1;
+        /// Binding is visible from the compute shader of a compute pipeline.
+        const COMPUTE = 1 << 2;
         /// Binding is visible from the vertex and fragment shaders of a render pipeline.
         const VERTEX_FRAGMENT = Self::VERTEX.bits | Self::FRAGMENT.bits;
-        /// Binding is visible from the compute shader of a compute pipeline.
-        const COMPUTE = 4;
-    }
-}
-
-bitflags::bitflags! {
-    /// Flags controlling the shader processing.
-    ///
-    /// Note: These flags are internal tweaks, they don't affect the API.
-    #[repr(transparent)]
-    #[derive(Default)]
-    #[cfg_attr(feature = "trace", derive(serde::Serialize))]
-    #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
-    pub struct ShaderFlags: u32 {
-        /// If enabled, `wgpu` will parse the shader with `Naga`
-        /// and validate it both internally and with regards to
-        /// the given pipeline interface.
-        const VALIDATION = 1;
-        /// If enabled, `wgpu` will attempt to operate on `Naga`'s internal
-        /// representation of the shader module for both validation and translation
-        /// into the backend shader language, on backends where `gfx-hal` supports this.
-        const EXPERIMENTAL_TRANSLATION = 2;
     }
 }
 
 /// Dimensions of a particular texture view.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub enum TextureViewDimension {
     /// A one dimensional texture. `texture1D` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "1d"))]
     D1,
     /// A two dimensional texture. `texture2D` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "2d"))]
     D2,
     /// A two dimensional array texture. `texture2DArray` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "2d-array"))]
     D2Array,
     /// A cubemap texture. `textureCube` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "cube"))]
     Cube,
     /// A cubemap array texture. `textureCubeArray` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "cube-array"))]
     CubeArray,
     /// A three dimensional texture. `texture3D` in glsl shaders.
+    #[cfg_attr(feature = "serde", serde(rename = "3d"))]
     D3,
 }
 
 impl Default for TextureViewDimension {
     fn default() -> Self {
         Self::D2
     }
 }
 
 impl TextureViewDimension {
-    /// Get the texture dimension required fo this texture view dimension.
+    /// Get the texture dimension required of this texture view dimension.
     pub fn compatible_texture_dimension(self) -> TextureDimension {
         match self {
             Self::D1 => TextureDimension::D1,
             Self::D2 | Self::D2Array | Self::Cube | Self::CubeArray => TextureDimension::D2,
             Self::D3 => TextureDimension::D3,
         }
     }
 }
 
 /// Alpha blend factor.
 ///
 /// Alpha blending is very complicated: see the OpenGL or Vulkan spec for more information.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum BlendFactor {
     /// 0.0
     Zero = 0,
     /// 1.0
     One = 1,
     /// S.component
     Src = 2,
     /// 1.0 - S.component
@@ -893,16 +974,17 @@ pub enum BlendFactor {
 
 /// Alpha blend operation.
 ///
 /// Alpha blending is very complicated: see the OpenGL or Vulkan spec for more information.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum BlendOperation {
     /// Src + Dst
     Add = 0,
     /// Src - Dst
     Subtract = 1,
     /// Dst - Src
     ReverseSubtract = 2,
     /// min(Src, Dst)
@@ -917,16 +999,17 @@ impl Default for BlendOperation {
     }
 }
 
 /// Describes the blend component of a pipeline.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct BlendComponent {
     /// Multiplier for the source, which is produced by the fragment shader.
     pub src_factor: BlendFactor,
     /// Multiplier for the destination, which is stored in the target.
     pub dst_factor: BlendFactor,
     /// The binary operation applied to the source and destination,
     /// multiplied by their respective factors.
     pub operation: BlendOperation,
@@ -968,16 +1051,17 @@ impl Default for BlendComponent {
 
 /// Describe the blend state of a render pipeline.
 ///
 /// See the OpenGL or Vulkan spec for more information.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct BlendState {
     /// Color equation.
     pub color: BlendComponent,
     /// Alpha equation.
     pub alpha: BlendComponent,
 }
 
 impl BlendState {
@@ -1004,43 +1088,45 @@ impl BlendState {
     };
 }
 
 /// Describes the color state of a render pipeline.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct ColorTargetState {
     /// The [`TextureFormat`] of the image that this pipeline will render to. Must match the the format
     /// of the corresponding color attachment in [`CommandEncoder::begin_render_pass`].
     pub format: TextureFormat,
     /// The blending that is used for this pipeline.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    #[cfg_attr(feature = "serde", serde(default))]
     pub blend: Option<BlendState>,
     /// Mask which enables/disables writes to different color/alpha channel.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
-    pub write_mask: ColorWrite,
+    #[cfg_attr(feature = "serde", serde(default))]
+    pub write_mask: ColorWrites,
 }
 
 impl From<TextureFormat> for ColorTargetState {
     fn from(format: TextureFormat) -> Self {
         Self {
             format,
             blend: None,
-            write_mask: ColorWrite::ALL,
+            write_mask: ColorWrites::ALL,
         }
     }
 }
 
 /// Primitive type the input mesh is composed of.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum PrimitiveTopology {
     /// Vertex data is a list of points. Each vertex is a new point.
     PointList = 0,
     /// Vertex data is a list of lines. Each pair of vertices composes a new line.
     ///
     /// Vertices `0 1 2 3` create two lines `0 1` and `2 3`
     LineList = 1,
     /// Vertex data is a strip of lines. Each set of two adjacent vertices form a line.
@@ -1048,31 +1134,42 @@ pub enum PrimitiveTopology {
     /// Vertices `0 1 2 3` create three lines `0 1`, `1 2`, and `2 3`.
     LineStrip = 2,
     /// Vertex data is a list of triangles. Each set of 3 vertices composes a new triangle.
     ///
     /// Vertices `0 1 2 3 4 5` create two triangles `0 1 2` and `3 4 5`
     TriangleList = 3,
     /// Vertex data is a triangle strip. Each set of three adjacent vertices form a triangle.
     ///
-    /// Vertices `0 1 2 3 4 5` creates four triangles `0 1 2`, `2 1 3`, `3 2 4`, and `4 3 5`
+    /// Vertices `0 1 2 3 4 5` creates four triangles `0 1 2`, `2 1 3`, `2 3 4`, and `4 3 5`
     TriangleStrip = 4,
 }
 
 impl Default for PrimitiveTopology {
     fn default() -> Self {
         PrimitiveTopology::TriangleList
     }
 }
 
+impl PrimitiveTopology {
+    /// Returns true for strip topologies.
+    pub fn is_strip(&self) -> bool {
+        match *self {
+            Self::PointList | Self::LineList | Self::TriangleList => false,
+            Self::LineStrip | Self::TriangleStrip => true,
+        }
+    }
+}
+
 /// Winding order which classifies the "front" face.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum FrontFace {
     /// Triangles with vertices in counter clockwise order are considered the front face.
     ///
     /// This is the default with right handed coordinate spaces.
     Ccw = 0,
     /// Triangles with vertices in clockwise order are considered the front face.
     ///
     /// This is the default with left handed coordinate spaces.
@@ -1085,28 +1182,30 @@ impl Default for FrontFace {
     }
 }
 
 /// Face of a vertex.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum Face {
     /// Front face
     Front = 0,
     /// Back face
     Back = 1,
 }
 
 /// Type of drawing mode for polygons
 #[repr(C)]
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum PolygonMode {
     /// Polygons are filled
     Fill = 0,
     /// Polygons are drawn as line segments
     Line = 1,
     /// Polygons are drawn as points
     Point = 2,
 }
@@ -1117,51 +1216,55 @@ impl Default for PolygonMode {
     }
 }
 
 /// Describes the state of primitive assembly and rasterization in a render pipeline.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct PrimitiveState {
     /// The primitive topology used to interpret vertices.
     pub topology: PrimitiveTopology,
     /// When drawing strip topologies with indices, this is the required format for the index buffer.
     /// This has no effect on non-indexed or non-strip draws.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    #[cfg_attr(feature = "serde", serde(default))]
     pub strip_index_format: Option<IndexFormat>,
     /// The face to consider the front for the purpose of culling and stencil operations.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    #[cfg_attr(feature = "serde", serde(default))]
     pub front_face: FrontFace,
     /// The face culling mode.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    #[cfg_attr(feature = "serde", serde(default))]
     pub cull_mode: Option<Face>,
     /// If set to true, the polygon depth is clamped to 0-1 range instead of being clipped.
     ///
     /// Enabling this requires `Features::DEPTH_CLAMPING` to be enabled.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    #[cfg_attr(feature = "serde", serde(default))]
     pub clamp_depth: bool,
     /// Controls the way each polygon is rasterized. Can be either `Fill` (default), `Line` or `Point`
     ///
-    /// Setting this to something other than `Fill` requires `Features::NON_FILL_POLYGON_MODE` to be enabled.
-    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    /// Setting this to `Line` requires `Features::POLYGON_MODE_LINE` to be enabled.
+    ///
+    /// Setting this to `Point` requires `Features::POLYGON_MODE_POINT` to be enabled.
+    #[cfg_attr(feature = "serde", serde(default))]
     pub polygon_mode: PolygonMode,
     /// If set to true, the primitives are rendered with conservative overestimation. I.e. any rastered pixel touched by it is filled.
     /// Only valid for PolygonMode::Fill!
     ///
     /// Enabling this requires `Features::CONSERVATIVE_RASTERIZATION` to be enabled.
     pub conservative: bool,
 }
 
 /// Describes the multi-sampling state of a render pipeline.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct MultisampleState {
     /// The number of samples calculated per pixel (for MSAA). For non-multisampled textures,
     /// this should be `1`
     pub count: u32,
     /// Bitmask that restricts the samples of a pixel modified by this pipeline. All samples
     /// can be enabled using the value `!0`
     pub mask: u64,
     /// When enabled, produces another sample mask per pixel based on the alpha output value, that
@@ -1184,30 +1287,32 @@ impl Default for MultisampleState {
 }
 
 bitflags::bitflags! {
     /// Feature flags for a texture format.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
     pub struct TextureFormatFeatureFlags: u32 {
-        /// When used as a STORAGE texture, then a texture with this format can be bound with `StorageTextureAccess::ReadWrite`.
-        const STORAGE_READ_WRITE = 1;
-        /// When used as a STORAGE texture, then a texture with this format can be written to with atomics. TODO: No access flag exposed as of writing
-        const STORAGE_ATOMICS = 2;
+        /// When used as a STORAGE texture, then a texture with this format can be bound with
+        /// [`StorageTextureAccess::ReadOnly`] or [`StorageTextureAccess::ReadWrite`].
+        const STORAGE_READ_WRITE = 1 << 0;
+        /// When used as a STORAGE texture, then a texture with this format can be written to with atomics.
+        // TODO: No access flag exposed as of writing
+        const STORAGE_ATOMICS = 1 << 1;
     }
 }
 
 /// Features supported by a given texture format
 ///
 /// Features are defined by WebGPU specification unless `Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES` is enabled.
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 pub struct TextureFormatFeatures {
     /// Valid bits for `TextureDescriptor::Usage` provided for format creation.
-    pub allowed_usages: TextureUsage,
+    pub allowed_usages: TextureUsages,
     /// Additional property flags for the format.
     pub flags: TextureFormatFeatureFlags,
     /// If `filterable` is false, the texture can't be sampled with a filtering sampler.
     /// This may overwrite TextureSampleType::Float.filterable
     pub filterable: bool,
 }
 
 /// Information about a texture format.
@@ -1232,391 +1337,448 @@ pub struct TextureFormatInfo {
 /// If there is a conversion in the format (such as srgb -> linear), The conversion listed is for
 /// loading from texture in a shader. When writing to the texture, the opposite conversion takes place.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
 pub enum TextureFormat {
     // Normal 8 bit formats
     /// Red channel only. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
-    R8Unorm = 0,
+    #[cfg_attr(feature = "serde", serde(rename = "r8unorm"))]
+    R8Unorm,
     /// Red channel only. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
-    R8Snorm = 1,
+    #[cfg_attr(feature = "serde", serde(rename = "r8snorm"))]
+    R8Snorm,
     /// Red channel only. 8 bit integer per channel. Unsigned in shader.
-    R8Uint = 2,
+    #[cfg_attr(feature = "serde", serde(rename = "r8uint"))]
+    R8Uint,
     /// Red channel only. 8 bit integer per channel. Signed in shader.
-    R8Sint = 3,
+    #[cfg_attr(feature = "serde", serde(rename = "r8sint"))]
+    R8Sint,
 
     // Normal 16 bit formats
     /// Red channel only. 16 bit integer per channel. Unsigned in shader.
-    R16Uint = 4,
+    #[cfg_attr(feature = "serde", serde(rename = "r16uint"))]
+    R16Uint,
     /// Red channel only. 16 bit integer per channel. Signed in shader.
-    R16Sint = 5,
+    #[cfg_attr(feature = "serde", serde(rename = "r16sint"))]
+    R16Sint,
     /// Red channel only. 16 bit float per channel. Float in shader.
-    R16Float = 6,
+    #[cfg_attr(feature = "serde", serde(rename = "r16float"))]
+    R16Float,
     /// Red and green channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
-    Rg8Unorm = 7,
+    #[cfg_attr(feature = "serde", serde(rename = "rg8unorm"))]
+    Rg8Unorm,
     /// Red and green channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
-    Rg8Snorm = 8,
+    #[cfg_attr(feature = "serde", serde(rename = "rg8snorm"))]
+    Rg8Snorm,
     /// Red and green channels. 8 bit integer per channel. Unsigned in shader.
-    Rg8Uint = 9,
+    #[cfg_attr(feature = "serde", serde(rename = "rg8uint"))]
+    Rg8Uint,
     /// Red and green channel s. 8 bit integer per channel. Signed in shader.
-    Rg8Sint = 10,
+    #[cfg_attr(feature = "serde", serde(rename = "rg8sint"))]
+    Rg8Sint,
 
     // Normal 32 bit formats
     /// Red channel only. 32 bit integer per channel. Unsigned in shader.
-    R32Uint = 11,
+    #[cfg_attr(feature = "serde", serde(rename = "r32uint"))]
+    R32Uint,
     /// Red channel only. 32 bit integer per channel. Signed in shader.
-    R32Sint = 12,
+    #[cfg_attr(feature = "serde", serde(rename = "r32sint"))]
+    R32Sint,
     /// Red channel only. 32 bit float per channel. Float in shader.
-    R32Float = 13,
+    #[cfg_attr(feature = "serde", serde(rename = "r32float"))]
+    R32Float,
     /// Red and green channels. 16 bit integer per channel. Unsigned in shader.
-    Rg16Uint = 14,
+    #[cfg_attr(feature = "serde", serde(rename = "rg16uint"))]
+    Rg16Uint,
     /// Red and green channels. 16 bit integer per channel. Signed in shader.
-    Rg16Sint = 15,
+    #[cfg_attr(feature = "serde", serde(rename = "rg16sint"))]
+    Rg16Sint,
     /// Red and green channels. 16 bit float per channel. Float in shader.
-    Rg16Float = 16,
+    #[cfg_attr(feature = "serde", serde(rename = "rg16float"))]
+    Rg16Float,
     /// Red, green, blue, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
-    Rgba8Unorm = 17,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba8unorm"))]
+    Rgba8Unorm,
     /// Red, green, blue, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
-    Rgba8UnormSrgb = 18,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba8unorm-srgb"))]
+    Rgba8UnormSrgb,
     /// Red, green, blue, and alpha channels. 8 bit integer per channel. [-127, 127] converted to/from float [-1, 1] in shader.
-    Rgba8Snorm = 19,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba8snorm"))]
+    Rgba8Snorm,
     /// Red, green, blue, and alpha channels. 8 bit integer per channel. Unsigned in shader.
-    Rgba8Uint = 20,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba8uint"))]
+    Rgba8Uint,
     /// Red, green, blue, and alpha channels. 8 bit integer per channel. Signed in shader.
-    Rgba8Sint = 21,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba8sint"))]
+    Rgba8Sint,
     /// Blue, green, red, and alpha channels. 8 bit integer per channel. [0, 255] converted to/from float [0, 1] in shader.
-    Bgra8Unorm = 22,
+    #[cfg_attr(feature = "serde", serde(rename = "bgra8unorm"))]
+    Bgra8Unorm,
     /// Blue, green, red, and alpha channels. 8 bit integer per channel. Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
-    Bgra8UnormSrgb = 23,
+    #[cfg_attr(feature = "serde", serde(rename = "bgra8unorm-srgb"))]
+    Bgra8UnormSrgb,
 
     // Packed 32 bit formats
     /// Red, green, blue, and alpha channels. 10 bit integer for RGB channels, 2 bit integer for alpha channel. [0, 1023] ([0, 3] for alpha) converted to/from float [0, 1] in shader.
-    Rgb10a2Unorm = 24,
+    #[cfg_attr(feature = "serde", serde(rename = "rgb10a2unorm"))]
+    Rgb10a2Unorm,
     /// Red, green, and blue channels. 11 bit float with no sign bit for RG channels. 10 bit float with no sign bit for blue channel. Float in shader.
-    Rg11b10Float = 25,
+    #[cfg_attr(feature = "serde", serde(rename = "rg11b10ufloat"))]
+    Rg11b10Float,
 
     // Normal 64 bit formats
     /// Red and green channels. 32 bit integer per channel. Unsigned in shader.
-    Rg32Uint = 26,
+    #[cfg_attr(feature = "serde", serde(rename = "rg32uint"))]
+    Rg32Uint,
     /// Red and green channels. 32 bit integer per channel. Signed in shader.
-    Rg32Sint = 27,
+    #[cfg_attr(feature = "serde", serde(rename = "rg32sint"))]
+    Rg32Sint,
     /// Red and green channels. 32 bit float per channel. Float in shader.
-    Rg32Float = 28,
+    #[cfg_attr(feature = "serde", serde(rename = "rg32float"))]
+    Rg32Float,
     /// Red, green, blue, and alpha channels. 16 bit integer per channel. Unsigned in shader.
-    Rgba16Uint = 29,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba16uint"))]
+    Rgba16Uint,
     /// Red, green, blue, and alpha channels. 16 bit integer per channel. Signed in shader.
-    Rgba16Sint = 30,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba16sint"))]
+    Rgba16Sint,
     /// Red, green, blue, and alpha channels. 16 bit float per channel. Float in shader.
-    Rgba16Float = 31,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba16float"))]
+    Rgba16Float,
 
     // Normal 128 bit formats
     /// Red, green, blue, and alpha channels. 32 bit integer per channel. Unsigned in shader.
-    Rgba32Uint = 32,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba32uint"))]
+    Rgba32Uint,
     /// Red, green, blue, and alpha channels. 32 bit integer per channel. Signed in shader.
-    Rgba32Sint = 33,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba32sint"))]
+    Rgba32Sint,
     /// Red, green, blue, and alpha channels. 32 bit float per channel. Float in shader.
-    Rgba32Float = 34,
+    #[cfg_attr(feature = "serde", serde(rename = "rgba32float"))]
+    Rgba32Float,
 
     // Depth and stencil formats
     /// Special depth format with 32 bit floating point depth.
-    Depth32Float = 35,
+    #[cfg_attr(feature = "serde", serde(rename = "depth32float"))]
+    Depth32Float,
     /// Special depth format with at least 24 bit integer depth.
-    Depth24Plus = 36,
+    #[cfg_attr(feature = "serde", serde(rename = "depth24plus"))]
+    Depth24Plus,
     /// Special depth/stencil format with at least 24 bit integer depth and 8 bits integer stencil.
-    Depth24PlusStencil8 = 37,
+    #[cfg_attr(feature = "serde", serde(rename = "depth24plus-stencil8"))]
+    Depth24PlusStencil8,
+
+    // Packed uncompressed texture formats
+    /// Packed unsigned float with 9 bits mantisa for each RGB component, then a common 5 bits exponent
+    #[cfg_attr(feature = "serde", serde(rename = "rgb9e5ufloat"))]
+    Rgb9e5Ufloat,
 
     // Compressed textures usable with `TEXTURE_COMPRESSION_BC` feature.
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha.
     /// [0, 63] ([0, 1] for alpha) converted to/from float [0, 1] in shader.
     ///
     /// Also known as DXT1.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc1RgbaUnorm = 38,
+    #[cfg_attr(feature = "serde", serde(rename = "bc1-rgba-unorm"))]
+    Bc1RgbaUnorm,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). 4 color + alpha pallet. 5 bit R + 6 bit G + 5 bit B + 1 bit alpha.
-    /// Srgb-color [0, 63] ([0, 15] for alpha) converted to/from linear-color float [0, 1] in shader.
+    /// Srgb-color [0, 63] ([0, 1] for alpha) converted to/from linear-color float [0, 1] in shader.
     ///
     /// Also known as DXT1.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc1RgbaUnormSrgb = 39,
+    #[cfg_attr(feature = "serde", serde(rename = "bc1-rgba-unorm-srgb"))]
+    Bc1RgbaUnormSrgb,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha.
     /// [0, 63] ([0, 15] for alpha) converted to/from float [0, 1] in shader.
     ///
     /// Also known as DXT3.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc2RgbaUnorm = 40,
+    #[cfg_attr(feature = "serde", serde(rename = "bc2-rgba-unorm"))]
+    Bc2RgbaUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet. 5 bit R + 6 bit G + 5 bit B + 4 bit alpha.
     /// Srgb-color [0, 63] ([0, 255] for alpha) converted to/from linear-color float [0, 1] in shader.
     ///
     /// Also known as DXT3.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc2RgbaUnormSrgb = 41,
+    #[cfg_attr(feature = "serde", serde(rename = "bc2-rgba-unorm-srgb"))]
+    Bc2RgbaUnormSrgb,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha.
     /// [0, 63] ([0, 255] for alpha) converted to/from float [0, 1] in shader.
     ///
     /// Also known as DXT5.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc3RgbaUnorm = 42,
+    #[cfg_attr(feature = "serde", serde(rename = "bc3-rgba-unorm"))]
+    Bc3RgbaUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 4 color pallet + 8 alpha pallet. 5 bit R + 6 bit G + 5 bit B + 8 bit alpha.
     /// Srgb-color [0, 63] ([0, 255] for alpha) converted to/from linear-color float [0, 1] in shader.
     ///
     /// Also known as DXT5.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc3RgbaUnormSrgb = 43,
+    #[cfg_attr(feature = "serde", serde(rename = "bc3-rgba-unorm-srgb"))]
+    Bc3RgbaUnormSrgb,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// Also known as RGTC1.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc4RUnorm = 44,
+    #[cfg_attr(feature = "serde", serde(rename = "bc4-r-unorm"))]
+    Bc4RUnorm,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). 8 color pallet. 8 bit R.
     /// [-127, 127] converted to/from float [-1, 1] in shader.
     ///
     /// Also known as RGTC1.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc4RSnorm = 45,
+    #[cfg_attr(feature = "serde", serde(rename = "bc4-r-snorm"))]
+    Bc4RSnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// Also known as RGTC2.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc5RgUnorm = 46,
+    #[cfg_attr(feature = "serde", serde(rename = "bc5-rg-unorm"))]
+    Bc5RgUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). 8 color red pallet + 8 color green pallet. 8 bit RG.
     /// [-127, 127] converted to/from float [-1, 1] in shader.
     ///
     /// Also known as RGTC2.
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc5RgSnorm = 47,
+    #[cfg_attr(feature = "serde", serde(rename = "bc5-rg-snorm"))]
+    Bc5RgSnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit unsigned float RGB. Float in shader.
     ///
     /// Also known as BPTC (float).
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc6hRgbUfloat = 48,
+    #[cfg_attr(feature = "serde", serde(rename = "bc6h-rgb-ufloat"))]
+    Bc6hRgbUfloat,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 16 bit signed float RGB. Float in shader.
     ///
     /// Also known as BPTC (float).
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc6hRgbSfloat = 49,
+    #[cfg_attr(feature = "serde", serde(rename = "bc6h-rgb-float"))]
+    Bc6hRgbSfloat,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// Also known as BPTC (unorm).
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc7RgbaUnorm = 50,
+    #[cfg_attr(feature = "serde", serde(rename = "bc7-rgba-unorm"))]
+    Bc7RgbaUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Variable sized pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// Also known as BPTC (unorm).
     ///
     /// [`Features::TEXTURE_COMPRESSION_BC`] must be enabled to use this texture format.
-    Bc7RgbaUnormSrgb = 51,
+    #[cfg_attr(feature = "serde", serde(rename = "bc7-rgba-unorm-srgb"))]
+    Bc7RgbaUnormSrgb,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbUnorm = 52,
+    Etc2RgbUnorm,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbUnormSrgb = 53,
+    Etc2RgbUnormSrgb,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.
     /// [0, 255] ([0, 1] for alpha) converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbA1Unorm = 54,
+    Etc2RgbA1Unorm,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer RGB + 1 bit alpha.
     /// Srgb-color [0, 255] ([0, 1] for alpha) converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbA1UnormSrgb = 55,
+    Etc2RgbA1UnormSrgb,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbA8Unorm = 56,
+    //Etc2RgbA8Unorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGB + 8 bit alpha.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    Etc2RgbA8UnormSrgb = 57,
+    //Etc2RgbA8UnormSrgb,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer R.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    EacRUnorm = 58,
+    EacRUnorm,
     /// 4x4 block compressed texture. 8 bytes per block (4 bit/px). Complex pallet. 8 bit integer R.
     /// [-127, 127] converted to/from float [-1, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    EacRSnorm = 59,
+    EacRSnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer R + 8 bit integer G.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    EtcRgUnorm = 60,
+    EacRgUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer R + 8 bit integer G.
     /// [-127, 127] converted to/from float [-1, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ETC2`] must be enabled to use this texture format.
-    EtcRgSnorm = 61,
+    EacRgSnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc4x4RgbaUnorm = 62,
+    Astc4x4RgbaUnorm,
     /// 4x4 block compressed texture. 16 bytes per block (8 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc4x4RgbaUnormSrgb = 63,
+    Astc4x4RgbaUnormSrgb,
     /// 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc5x4RgbaUnorm = 64,
+    Astc5x4RgbaUnorm,
     /// 5x4 block compressed texture. 16 bytes per block (6.4 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc5x4RgbaUnormSrgb = 65,
+    Astc5x4RgbaUnormSrgb,
     /// 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc5x5RgbaUnorm = 66,
+    Astc5x5RgbaUnorm,
     /// 5x5 block compressed texture. 16 bytes per block (5.12 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc5x5RgbaUnormSrgb = 67,
+    Astc5x5RgbaUnormSrgb,
     /// 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc6x5RgbaUnorm = 68,
+    Astc6x5RgbaUnorm,
     /// 6x5 block compressed texture. 16 bytes per block (4.27 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc6x5RgbaUnormSrgb = 69,
+    Astc6x5RgbaUnormSrgb,
     /// 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc6x6RgbaUnorm = 70,
+    Astc6x6RgbaUnorm,
     /// 6x6 block compressed texture. 16 bytes per block (3.56 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc6x6RgbaUnormSrgb = 71,
+    Astc6x6RgbaUnormSrgb,
     /// 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x5RgbaUnorm = 72,
+    Astc8x5RgbaUnorm,
     /// 8x5 block compressed texture. 16 bytes per block (3.2 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x5RgbaUnormSrgb = 73,
+    Astc8x5RgbaUnormSrgb,
     /// 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x6RgbaUnorm = 74,
+    Astc8x6RgbaUnorm,
     /// 8x6 block compressed texture. 16 bytes per block (2.67 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x6RgbaUnormSrgb = 75,
+    Astc8x6RgbaUnormSrgb,
     /// 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x5RgbaUnorm = 76,
+    Astc10x5RgbaUnorm,
     /// 10x5 block compressed texture. 16 bytes per block (2.56 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x5RgbaUnormSrgb = 77,
+    Astc10x5RgbaUnormSrgb,
     /// 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x6RgbaUnorm = 78,
+    Astc10x6RgbaUnorm,
     /// 10x6 block compressed texture. 16 bytes per block (2.13 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x6RgbaUnormSrgb = 79,
+    Astc10x6RgbaUnormSrgb,
     /// 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x8RgbaUnorm = 80,
+    Astc8x8RgbaUnorm,
     /// 8x8 block compressed texture. 16 bytes per block (2 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc8x8RgbaUnormSrgb = 81,
+    Astc8x8RgbaUnormSrgb,
     /// 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x8RgbaUnorm = 82,
+    Astc10x8RgbaUnorm,
     /// 10x8 block compressed texture. 16 bytes per block (1.6 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x8RgbaUnormSrgb = 83,
+    Astc10x8RgbaUnormSrgb,
     /// 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x10RgbaUnorm = 84,
+    Astc10x10RgbaUnorm,
     /// 10x10 block compressed texture. 16 bytes per block (1.28 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc10x10RgbaUnormSrgb = 85,
+    Astc10x10RgbaUnormSrgb,
     /// 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc12x10RgbaUnorm = 86,
+    Astc12x10RgbaUnorm,
     /// 12x10 block compressed texture. 16 bytes per block (1.07 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc12x10RgbaUnormSrgb = 87,
+    Astc12x10RgbaUnormSrgb,
     /// 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.
     /// [0, 255] converted to/from float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc12x12RgbaUnorm = 88,
+    Astc12x12RgbaUnorm,
     /// 12x12 block compressed texture. 16 bytes per block (0.89 bit/px). Complex pallet. 8 bit integer RGBA.
     /// Srgb-color [0, 255] converted to/from linear-color float [0, 1] in shader.
     ///
     /// [`Features::TEXTURE_COMPRESSION_ASTC_LDR`] must be enabled to use this texture format.
-    Astc12x12RgbaUnormSrgb = 89,
+    Astc12x12RgbaUnormSrgb,
 }
 
 impl TextureFormat {
     /// Get useful information about the texture format.
     pub fn describe(&self) -> TextureFormatInfo {
         // Features
         let native = Features::empty();
         let bc = Features::TEXTURE_COMPRESSION_BC;
@@ -1630,20 +1792,21 @@ impl TextureFormat {
         let float = TextureSampleType::Float { filterable: true };
         let depth = TextureSampleType::Depth;
 
         // Color spaces
         let linear = false;
         let srgb = true;
 
         // Flags
-        let basic = TextureUsage::COPY_SRC | TextureUsage::COPY_DST | TextureUsage::SAMPLED;
-        let attachment = basic | TextureUsage::RENDER_ATTACHMENT;
-        let storage = basic | TextureUsage::STORAGE;
-        let all_flags = TextureUsage::all();
+        let basic =
+            TextureUsages::COPY_SRC | TextureUsages::COPY_DST | TextureUsages::TEXTURE_BINDING;
+        let attachment = basic | TextureUsages::RENDER_ATTACHMENT;
+        let storage = basic | TextureUsages::STORAGE_BINDING;
+        let all_flags = TextureUsages::all();
 
         // See <https://gpuweb.github.io/gpuweb/#texture-format-caps> for reference
         let (required_features, sample_type, srgb, block_dimensions, block_size, allowed_usages) =
             match self {
                 // Normal 8 bit textures
                 Self::R8Unorm => (native, float, linear, (1, 1), 1, attachment),
                 Self::R8Snorm => (native, float, linear, (1, 1), 1, basic),
                 Self::R8Uint => (native, uint, linear, (1, 1), 1, attachment),
@@ -1690,16 +1853,19 @@ impl TextureFormat {
                 Self::Rgba32Sint => (native, sint, linear, (1, 1), 16, all_flags),
                 Self::Rgba32Float => (native, nearest, linear, (1, 1), 16, all_flags),
 
                 // Depth-stencil textures
                 Self::Depth32Float => (native, depth, linear, (1, 1), 4, attachment),
                 Self::Depth24Plus => (native, depth, linear, (1, 1), 4, attachment),
                 Self::Depth24PlusStencil8 => (native, depth, linear, (1, 1), 4, attachment),
 
+                // Packed uncompressed
+                Self::Rgb9e5Ufloat => (native, float, linear, (1, 1), 4, basic),
+
                 // BCn compressed textures
                 Self::Bc1RgbaUnorm => (bc, float, linear, (4, 4), 8, basic),
                 Self::Bc1RgbaUnormSrgb => (bc, float, srgb, (4, 4), 8, basic),
                 Self::Bc2RgbaUnorm => (bc, float, linear, (4, 4), 16, basic),
                 Self::Bc2RgbaUnormSrgb => (bc, float, srgb, (4, 4), 16, basic),
                 Self::Bc3RgbaUnorm => (bc, float, linear, (4, 4), 16, basic),
                 Self::Bc3RgbaUnormSrgb => (bc, float, srgb, (4, 4), 16, basic),
                 Self::Bc4RUnorm => (bc, float, linear, (4, 4), 8, basic),
@@ -1711,22 +1877,22 @@ impl TextureFormat {
                 Self::Bc7RgbaUnorm => (bc, float, linear, (4, 4), 16, basic),
                 Self::Bc7RgbaUnormSrgb => (bc, float, srgb, (4, 4), 16, basic),
 
                 // ETC compressed textures
                 Self::Etc2RgbUnorm => (etc2, float, linear, (4, 4), 8, basic),
                 Self::Etc2RgbUnormSrgb => (etc2, float, srgb, (4, 4), 8, basic),
                 Self::Etc2RgbA1Unorm => (etc2, float, linear, (4, 4), 8, basic),
                 Self::Etc2RgbA1UnormSrgb => (etc2, float, srgb, (4, 4), 8, basic),
-                Self::Etc2RgbA8Unorm => (etc2, float, linear, (4, 4), 16, basic),
-                Self::Etc2RgbA8UnormSrgb => (etc2, float, srgb, (4, 4), 16, basic),
+                //Self::Etc2RgbA8Unorm => (etc2, float, linear, (4, 4), 16, basic),
+                //Self::Etc2RgbA8UnormSrgb => (etc2, float, srgb, (4, 4), 16, basic),
                 Self::EacRUnorm => (etc2, float, linear, (4, 4), 8, basic),
                 Self::EacRSnorm => (etc2, float, linear, (4, 4), 8, basic),
-                Self::EtcRgUnorm => (etc2, float, linear, (4, 4), 16, basic),
-                Self::EtcRgSnorm => (etc2, float, linear, (4, 4), 16, basic),
+                Self::EacRgUnorm => (etc2, float, linear, (4, 4), 16, basic),
+                Self::EacRgSnorm => (etc2, float, linear, (4, 4), 16, basic),
 
                 // ASTC compressed textures
                 Self::Astc4x4RgbaUnorm => (astc_ldr, float, linear, (4, 4), 16, basic),
                 Self::Astc4x4RgbaUnormSrgb => (astc_ldr, float, srgb, (4, 4), 16, basic),
                 Self::Astc5x4RgbaUnorm => (astc_ldr, float, linear, (5, 4), 16, basic),
                 Self::Astc5x4RgbaUnormSrgb => (astc_ldr, float, srgb, (5, 4), 16, basic),
                 Self::Astc5x5RgbaUnorm => (astc_ldr, float, linear, (5, 5), 16, basic),
                 Self::Astc5x5RgbaUnormSrgb => (astc_ldr, float, srgb, (5, 5), 16, basic),
@@ -1769,33 +1935,33 @@ impl TextureFormat {
     }
 }
 
 bitflags::bitflags! {
     /// Color write mask. Disabled color channels will not be written to.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
-    pub struct ColorWrite: u32 {
+    pub struct ColorWrites: u32 {
         /// Enable red channel writes
-        const RED = 1;
+        const RED = 1 << 0;
         /// Enable green channel writes
-        const GREEN = 2;
+        const GREEN = 1 << 1;
         /// Enable blue channel writes
-        const BLUE = 4;
+        const BLUE = 1 << 2;
         /// Enable alpha channel writes
-        const ALPHA = 8;
+        const ALPHA = 1 << 3;
         /// Enable red, green, and blue channel writes
-        const COLOR = 7;
+        const COLOR = Self::RED.bits | Self::GREEN.bits | Self::BLUE.bits;
         /// Enable writes to all channels.
-        const ALL = 15;
+        const ALL = Self::RED.bits | Self::GREEN.bits | Self::BLUE.bits | Self::ALPHA.bits;
     }
 }
 
-impl Default for ColorWrite {
+impl Default for ColorWrites {
     fn default() -> Self {
         Self::ALL
     }
 }
 
 /// State of the stencil operation (fixed-pipeline stage).
 #[repr(C)]
 #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
@@ -1880,16 +2046,17 @@ impl DepthStencilState {
         !self.depth_write_enabled && self.stencil.is_read_only()
     }
 }
 
 /// Format of indices used with pipeline.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum IndexFormat {
     /// Indices are 16 bit unsigned integers.
     Uint16 = 0,
     /// Indices are 32 bit unsigned integers.
     Uint32 = 1,
 }
 
 impl Default for IndexFormat {
@@ -1898,16 +2065,17 @@ impl Default for IndexFormat {
     }
 }
 
 /// Operation to perform on the stencil value.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum StencilOperation {
     /// Keep stencil value unchanged.
     Keep = 0,
     /// Set stencil value to zero.
     Zero = 1,
     /// Replace stencil value with value provided in most recent call to [`RenderPass::set_stencil_reference`].
     Replace = 2,
     /// Bitwise inverts stencil value.
@@ -1930,16 +2098,17 @@ impl Default for StencilOperation {
 
 /// Describes stencil state in a render pipeline.
 ///
 /// If you are not using stencil state, set this to [`StencilFaceState::IGNORE`].
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct StencilFaceState {
     /// Comparison function that determines if the fail_op or pass_op is used on the stencil buffer.
     pub compare: CompareFunction,
     /// Operation that is preformed when stencil test fails.
     pub fail_op: StencilOperation,
     /// Operation that is performed when depth test fails but stencil test succeeds.
     pub depth_fail_op: StencilOperation,
     /// Operation that is performed when stencil test success.
@@ -1970,16 +2139,17 @@ impl Default for StencilFaceState {
     }
 }
 
 /// Comparison function used for depth and stencil operations.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum CompareFunction {
     /// Function never passes
     Never = 1,
     /// Function passes if new value less than existing value
     Less = 2,
     /// Function passes if new value is equal to existing value
     Equal = 3,
     /// Function passes if new value is less than or equal to existing value
@@ -2004,50 +2174,53 @@ impl CompareFunction {
     }
 }
 
 /// Rate that determines when vertex data is advanced.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
-pub enum InputStepMode {
-    /// Input data is advanced every vertex. This is the standard value for vertex data.
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
+pub enum VertexStepMode {
+    /// Vertex data is advanced every vertex.
     Vertex = 0,
-    /// Input data is advanced every instance.
+    /// Vertex data is advanced every instance.
     Instance = 1,
 }
 
-impl Default for InputStepMode {
+impl Default for VertexStepMode {
     fn default() -> Self {
-        InputStepMode::Vertex
+        VertexStepMode::Vertex
     }
 }
 
 /// Vertex inputs (attributes) to shaders.
 ///
 /// Arrays of these can be made with the [`vertex_attr_array`] macro. Vertex attributes are assumed to be tightly packed.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct VertexAttribute {
     /// Format of the input
     pub format: VertexFormat,
     /// Byte offset of the start of the input
     pub offset: BufferAddress,
     /// Location for this input. Must match the location in the shader.
     pub shader_location: ShaderLocation,
 }
 
 /// Vertex Format for a Vertex Attribute (input).
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "lowercase"))]
 pub enum VertexFormat {
     /// Two unsigned bytes (u8). `uvec2` in shaders.
     Uint8x2 = 0,
     /// Four unsigned bytes (u8). `uvec4` in shaders.
     Uint8x4 = 1,
     /// Two signed bytes (i8). `ivec2` in shaders.
     Sint8x2 = 2,
     /// Four signed bytes (i8). `ivec4` in shaders.
@@ -2151,63 +2324,63 @@ impl VertexFormat {
 bitflags::bitflags! {
     /// Different ways that you can use a buffer.
     ///
     /// The usages determine what kind of memory the buffer is allocated from and what
     /// actions the buffer can partake in.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
-    pub struct BufferUsage: u32 {
+    pub struct BufferUsages: u32 {
         /// Allow a buffer to be mapped for reading using [`Buffer::map_async`] + [`Buffer::get_mapped_range`].
         /// This does not include creating a buffer with [`BufferDescriptor::mapped_at_creation`] set.
         ///
         /// If [`Features::MAPPABLE_PRIMARY_BUFFERS`] isn't enabled, the only other usage a buffer
         /// may have is COPY_DST.
-        const MAP_READ = 1;
+        const MAP_READ = 1 << 0;
         /// Allow a buffer to be mapped for writing using [`Buffer::map_async`] + [`Buffer::get_mapped_range_mut`].
         /// This does not include creating a buffer with `mapped_at_creation` set.
         ///
         /// If [`Features::MAPPABLE_PRIMARY_BUFFERS`] feature isn't enabled, the only other usage a buffer
         /// may have is COPY_SRC.
-        const MAP_WRITE = 2;
+        const MAP_WRITE = 1 << 1;
         /// Allow a buffer to be the source buffer for a [`CommandEncoder::copy_buffer_to_buffer`] or [`CommandEncoder::copy_buffer_to_texture`]
         /// operation.
-        const COPY_SRC = 4;
+        const COPY_SRC = 1 << 2;
         /// Allow a buffer to be the destination buffer for a [`CommandEncoder::copy_buffer_to_buffer`], [`CommandEncoder::copy_texture_to_buffer`],
         /// [`CommandEncoder::fill_buffer`] or [`Queue::write_buffer`] operation.
-        const COPY_DST = 8;
+        const COPY_DST = 1 << 3;
         /// Allow a buffer to be the index buffer in a draw operation.
-        const INDEX = 16;
+        const INDEX = 1 << 4;
         /// Allow a buffer to be the vertex buffer in a draw operation.
-        const VERTEX = 32;
+        const VERTEX = 1 << 5;
         /// Allow a buffer to be a [`BufferBindingType::Uniform`] inside a bind group.
-        const UNIFORM = 64;
+        const UNIFORM = 1 << 6;
         /// Allow a buffer to be a [`BufferBindingType::Storage`] inside a bind group.
-        const STORAGE = 128;
+        const STORAGE = 1 << 7;
         /// Allow a buffer to be the indirect buffer in an indirect draw call.
-        const INDIRECT = 256;
+        const INDIRECT = 1 << 8;
     }
 }
 
 /// Describes a [`Buffer`].
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub struct BufferDescriptor<L> {
     /// Debug label of a buffer. This will show up in graphics debuggers for easy identification.
     pub label: L,
     /// Size of a buffer.
     pub size: BufferAddress,
     /// Usages of a buffer. If the buffer is used in any way that isn't specified here, the operation
     /// will panic.
-    pub usage: BufferUsage,
-    /// Allows a buffer to be mapped immediately after they are made. It does not have to be [`BufferUsage::MAP_READ`] or
-    /// [`BufferUsage::MAP_WRITE`], all buffers are allowed to be mapped at creation.
+    pub usage: BufferUsages,
+    /// Allows a buffer to be mapped immediately after they are made. It does not have to be [`BufferUsages::MAP_READ`] or
+    /// [`BufferUsages::MAP_WRITE`], all buffers are allowed to be mapped at creation.
     pub mapped_at_creation: bool,
 }
 
 impl<L> BufferDescriptor<L> {
     ///
     pub fn map_label<K>(&self, fun: impl FnOnce(&L) -> K) -> BufferDescriptor<K> {
         BufferDescriptor {
             label: fun(&self.label),
@@ -2268,56 +2441,56 @@ pub enum PresentMode {
 bitflags::bitflags! {
     /// Different ways that you can use a texture.
     ///
     /// The usages determine what kind of memory the texture is allocated from and what
     /// actions the texture can partake in.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
-    pub struct TextureUsage: u32 {
+    pub struct TextureUsages: u32 {
         /// Allows a texture to be the source in a [`CommandEncoder::copy_texture_to_buffer`] or
         /// [`CommandEncoder::copy_texture_to_texture`] operation.
-        const COPY_SRC = 1;
-        /// Allows a texture to be the destination in a  [`CommandEncoder::copy_texture_to_buffer`],
+        const COPY_SRC = 1 << 0;
+        /// Allows a texture to be the destination in a  [`CommandEncoder::copy_buffer_to_texture`],
         /// [`CommandEncoder::copy_texture_to_texture`], or [`Queue::write_texture`] operation.
-        const COPY_DST = 2;
+        const COPY_DST = 1 << 1;
         /// Allows a texture to be a [`BindingType::Texture`] in a bind group.
-        const SAMPLED = 4;
+        const TEXTURE_BINDING = 1 << 2;
         /// Allows a texture to be a [`BindingType::StorageTexture`] in a bind group.
-        const STORAGE = 8;
+        const STORAGE_BINDING = 1 << 3;
         /// Allows a texture to be an output attachment of a renderpass.
-        const RENDER_ATTACHMENT = 16;
+        const RENDER_ATTACHMENT = 1 << 4;
     }
 }
 
-/// Describes a [`SwapChain`].
+/// Configures a [`Surface`] for presentation.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
-pub struct SwapChainDescriptor {
+pub struct SurfaceConfiguration {
     /// The usage of the swap chain. The only supported usage is `RENDER_ATTACHMENT`.
-    pub usage: TextureUsage,
+    pub usage: TextureUsages,
     /// The texture format of the swap chain. The only formats that are guaranteed are
     /// `Bgra8Unorm` and `Bgra8UnormSrgb`
     pub format: TextureFormat,
     /// Width of the swap chain. Must be the same size as the surface.
     pub width: u32,
     /// Height of the swap chain. Must be the same size as the surface.
     pub height: u32,
     /// Presentation mode of the swap chain. FIFO is the only guaranteed to be supported, though
     /// other formats will automatically fall back to FIFO.
     pub present_mode: PresentMode,
 }
 
-/// Status of the recieved swapchain image.
+/// Status of the recieved surface image.
 #[repr(C)]
 #[derive(Debug)]
-pub enum SwapChainStatus {
+pub enum SurfaceStatus {
     /// No issues.
     Good,
     /// The swap chain is operational, but it does no longer perfectly
     /// match the surface. A re-configuration is needed.
     Suboptimal,
     /// Unable to get the next frame, timed out.
     Timeout,
     /// The surface under the swap chain has changed.
@@ -2327,16 +2500,17 @@ pub enum SwapChainStatus {
 }
 
 /// RGBA double precision color.
 ///
 /// This is not to be used as a generic color type, only for specific wgpu interfaces.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, Default, PartialEq)]
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct Color {
     ///
     pub r: f64,
     ///
     pub g: f64,
     ///
     pub b: f64,
     ///
@@ -2385,28 +2559,32 @@ impl Color {
 
 /// Dimensionality of a texture.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub enum TextureDimension {
     /// 1D texture
+    #[cfg_attr(feature = "serde", serde(rename = "1d"))]
     D1,
     /// 2D texture
+    #[cfg_attr(feature = "serde", serde(rename = "2d"))]
     D2,
     /// 3D texture
+    #[cfg_attr(feature = "serde", serde(rename = "3d"))]
     D3,
 }
 
 /// Origin of a copy to/from a texture.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct Origin3d {
     ///
     pub x: u32,
     ///
     pub y: u32,
     ///
     pub z: u32,
 }
@@ -2422,16 +2600,17 @@ impl Default for Origin3d {
     }
 }
 
 /// Extent of a texture related operation.
 #[repr(C)]
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
 pub struct Extent3d {
     ///
     pub width: u32,
     ///
     pub height: u32,
     ///
     pub depth_or_array_layers: u32,
 }
@@ -2493,101 +2672,118 @@ impl Extent3d {
     /// for a 2DArray texture, which does not mipmap depth, set depth to 1.
     ///
     /// ```rust
     /// # use wgpu_types as wgpu;
     /// assert_eq!(wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 }.max_mips(), 1);
     /// assert_eq!(wgpu::Extent3d { width: 60, height: 60, depth_or_array_layers: 1 }.max_mips(), 6);
     /// assert_eq!(wgpu::Extent3d { width: 240, height: 1, depth_or_array_layers: 1 }.max_mips(), 8);
     /// ```
-    pub fn max_mips(&self) -> u8 {
+    pub fn max_mips(&self) -> u32 {
         let max_dim = self.width.max(self.height.max(self.depth_or_array_layers));
-        let max_levels = 32 - max_dim.leading_zeros();
-
-        max_levels as u8
-    }
-
-    /// Calculates the extent at a given mip level.
-    ///
-    /// If the given mip level is larger than possible, returns None.
-    ///
-    /// Treats the depth as part of the mipmaps. If calculating
-    /// for a 2DArray texture, which does not mipmap depth, set depth to 1.
-    ///
-    /// ```rust
-    /// # use wgpu_types as wgpu;
-    /// let extent = wgpu::Extent3d { width: 100, height: 60, depth_or_array_layers: 1 };
-    ///
-    /// assert_eq!(extent.at_mip_level(0), Some(wgpu::Extent3d { width: 100, height: 60, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(1), Some(wgpu::Extent3d { width: 50, height: 30, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(2), Some(wgpu::Extent3d { width: 25, height: 15, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(3), Some(wgpu::Extent3d { width: 12, height: 7, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(4), Some(wgpu::Extent3d { width: 6, height: 3, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(5), Some(wgpu::Extent3d { width: 3, height: 1, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(6), Some(wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 }));
-    /// assert_eq!(extent.at_mip_level(7), None);
-    /// ```
-    pub fn at_mip_level(&self, level: u8) -> Option<Self> {
-        let mip_count = self.max_mips();
-
-        if level >= mip_count {
-            return None;
-        }
-
-        Some(Self {
-            width: u32::max(1, self.width >> level as u32),
-            height: u32::max(1, self.height >> level as u32),
-            depth_or_array_layers: u32::max(1, self.depth_or_array_layers >> level as u32),
-        })
+        32 - max_dim.leading_zeros()
     }
 }
 
 /// Describes a [`Texture`].
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub struct TextureDescriptor<L> {
     /// Debug label of the texture. This will show up in graphics debuggers for easy identification.
     pub label: L,
-    /// Size of the texture. For a regular 1D/2D texture, the unused sizes will be 1. For 2DArray textures, Z is the
-    /// number of 2D textures in that array.
+    /// Size of the texture. All components must be greater than zero. For a
+    /// regular 1D/2D texture, the unused sizes will be 1. For 2DArray textures,
+    /// Z is the number of 2D textures in that array.
     pub size: Extent3d,
     /// Mip count of texture. For a texture with no extra mips, this must be 1.
     pub mip_level_count: u32,
     /// Sample count of texture. If this is not 1, texture must have [`BindingType::Texture::multisampled`] set to true.
     pub sample_count: u32,
     /// Dimensions of the texture.
     pub dimension: TextureDimension,
     /// Format of the texture.
     pub format: TextureFormat,
     /// Allowed usages of the texture. If used in other ways, the operation will panic.
-    pub usage: TextureUsage,
+    pub usage: TextureUsages,
 }
 
 impl<L> TextureDescriptor<L> {
     ///
     pub fn map_label<K>(&self, fun: impl FnOnce(&L) -> K) -> TextureDescriptor<K> {
         TextureDescriptor {
             label: fun(&self.label),
             size: self.size,
             mip_level_count: self.mip_level_count,
             sample_count: self.sample_count,
             dimension: self.dimension,
             format: self.format,
             usage: self.usage,
         }
     }
+
+    /// Calculates the extent at a given mip level.
+    ///
+    /// If the given mip level is larger than possible, returns None.
+    ///
+    /// Treats the depth as part of the mipmaps. If calculating
+    /// for a 2DArray texture, which does not mipmap depth, set depth to 1.
+    ///
+    /// ```rust
+    /// # use wgpu_types as wgpu;
+    /// let desc = wgpu::TextureDescriptor {
+    ///   label: (),
+    ///   size: Extent3d { width: 100, height: 60, depth_or_array_layers: 2 },
+    ///   mip_level_count: 7,
+    ///   sample_count: 1,
+    ///   dimension: wgpu::TextureDimension::D3,
+    ///   format: wgpu::TextureFormat::Rgba8Sint,
+    ///   usage: wgpu::TextureUsages::empty(),
+    /// };
+    ///
+    /// assert_eq!(desc.mip_level_size(0), Some(wgpu::Extent3d { width: 100, height: 60, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(1), Some(wgpu::Extent3d { width: 50, height: 30, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(2), Some(wgpu::Extent3d { width: 25, height: 15, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(3), Some(wgpu::Extent3d { width: 12, height: 7, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(4), Some(wgpu::Extent3d { width: 6, height: 3, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(5), Some(wgpu::Extent3d { width: 3, height: 1, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(6), Some(wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 }));
+    /// assert_eq!(desc.mip_level_size(7), None);
+    /// ```
+    pub fn mip_level_size(&self, level: u32) -> Option<Extent3d> {
+        if level >= self.mip_level_count {
+            return None;
+        }
+
+        Some(Extent3d {
+            width: u32::max(1, self.size.width >> level),
+            height: u32::max(1, self.size.height >> level),
+            depth_or_array_layers: match self.dimension {
+                TextureDimension::D1 | TextureDimension::D2 => self.size.depth_or_array_layers,
+                TextureDimension::D3 => u32::max(1, self.size.depth_or_array_layers >> level),
+            },
+        })
+    }
+
+    /// Returns the number of array layers.
+    pub fn array_layer_count(&self) -> u32 {
+        match self.dimension {
+            TextureDimension::D1 | TextureDimension::D2 => self.size.depth_or_array_layers,
+            TextureDimension::D3 => 1,
+        }
+    }
 }
 
 /// Kind of data the texture holds.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum TextureAspect {
     /// Depth, Stencil, and Color.
     All,
     /// Stencil.
     StencilOnly,
     /// Depth.
     DepthOnly,
 }
@@ -2598,16 +2794,17 @@ impl Default for TextureAspect {
     }
 }
 
 /// How edges should be handled in texture addressing.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum AddressMode {
     /// Clamp the value to the edge of the texture
     ///
     /// -0.25 -> 0.0
     /// 1.25  -> 1.0
     ClampToEdge = 0,
     /// Repeat the texture in a tiling fashion
     ///
@@ -2633,16 +2830,17 @@ impl Default for AddressMode {
     }
 }
 
 /// Texel mixing mode when sampling between texels.
 #[repr(C)]
 #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum FilterMode {
     /// Nearest neighbor sampling.
     ///
     /// This creates a pixelated effect when used as a mag filter
     Nearest = 0,
     /// Linear Interpolation
     ///
     /// This makes textures smooth but blurry when used as a mag filter.
@@ -2657,17 +2855,17 @@ impl Default for FilterMode {
 
 /// A range of push constant memory to pass to a shader stage.
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub struct PushConstantRange {
     /// Stage push constant range is visible from. Each stage can only be served by at most one range.
     /// One range can serve multiple stages however.
-    pub stages: ShaderStage,
+    pub stages: ShaderStages,
     /// Range in push constant memory to use for the stage. Must be less than [`Limits::max_push_constant_size`].
     /// Start and end must be aligned to the 4s.
     pub range: Range<u32>,
 }
 
 /// Describes a [`CommandBuffer`].
 #[repr(C)]
 #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
@@ -2682,16 +2880,30 @@ impl<L> CommandBufferDescriptor<L> {
     ///
     pub fn map_label<K>(&self, fun: impl FnOnce(&L) -> K) -> CommandBufferDescriptor<K> {
         CommandBufferDescriptor {
             label: fun(&self.label),
         }
     }
 }
 
+/// Describes the depth/stencil attachment for render bundles.
+#[repr(C)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "trace", derive(serde::Serialize))]
+#[cfg_attr(feature = "replay", derive(serde::Deserialize))]
+pub struct RenderBundleDepthStencil {
+    /// Format of the attachment.
+    pub format: TextureFormat,
+    /// True if the depth aspect is used but not modified.
+    pub depth_read_only: bool,
+    /// True if the stencil aspect is used but not modified.
+    pub stencil_read_only: bool,
+}
+
 /// Describes a [`RenderBundle`].
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub struct RenderBundleDescriptor<L> {
     /// Debug label of the render bundle encoder. This will show up in graphics debuggers for easy identification.
     pub label: L,
@@ -2708,36 +2920,55 @@ impl<L> RenderBundleDescriptor<L> {
 
 impl<T> Default for RenderBundleDescriptor<Option<T>> {
     fn default() -> Self {
         Self { label: None }
     }
 }
 
 /// Layout of a texture in a buffer's memory.
+///
+/// The bytes per row and rows per image can be hard to figure out so here are some examples:
+///
+/// | Resolution | Format | Bytes per block | Pixels per block | Bytes per row                          | Rows per image               |
+/// |------------|--------|-----------------|------------------|----------------------------------------|------------------------------|
+/// | 256x256    | RGBA8  | 4               | 1 * 1 * 1        | 256 * 4 = Some(1024)                   | None                         |
+/// | 32x16x8    | RGBA8  | 4               | 1 * 1 * 1        | 32 * 4 = 128 padded to 256 = Some(256) | None                         |
+/// | 256x256    | BC3    | 16              | 4 * 4 * 1        | 16 * (256 / 4) = 1024 = Some(1024)     | None                         |
+/// | 64x64x8    | BC3    | 16              | 4 * 4 * 1        | 16 * (64 / 4) = 256 = Some(256)        | 64 / 4 = 16 = Some(16)       |
 #[repr(C)]
 #[derive(Clone, Copy, Debug, Default)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct ImageDataLayout {
     /// Offset into the buffer that is the start of the texture. Must be a multiple of texture block size.
     /// For non-compressed textures, this is 1.
     pub offset: BufferAddress,
-    /// Bytes per "row" of the image. This represents one row of pixels in the x direction. Compressed
-    /// textures include multiple rows of pixels in each "row".
-    /// Required if there are multiple rows (i.e. height or depth is more than one pixel or pixel block for compressed textures)
+    /// Bytes per "row" in an image.
+    ///
+    /// A row is one row of pixels or of compressed blocks in the x direction.
     ///
-    /// Must be a multiple of 256 for [`CommandEncoder::copy_buffer_to_texture`] and [`CommandEncoder::copy_texture_to_buffer`].
+    /// This value is required if there are multiple rows (i.e. height or depth is more than one pixel or pixel block for compressed textures)
+    ///
+    /// Must be a multiple of 256 for [`CommandEncoder::copy_buffer_to_texture`] and [`CommandEncoder::copy_texture_to_buffer`]. You must manually pad
+    /// the image such that this is a multiple of 256. It will not affect the image data.
+    ///
     /// [`Queue::write_texture`] does not have this requirement.
     ///
     /// Must be a multiple of the texture block size. For non-compressed textures, this is 1.
     pub bytes_per_row: Option<NonZeroU32>,
-    /// Rows that make up a single "image". Each "image" is one layer in the z direction of a 3D image. May be larger
-    /// than `copy_size.y`.
-    /// Required if there are multiple images (i.e. the depth is more than one)
+    /// "Rows" that make up a single "image".
+    ///
+    /// A row is one row of pixels or of compressed blocks in the x direction.
+    ///
+    /// An image is one layer in the z direction of a 3D image or 2DArray texture.
+    ///
+    /// The amount of rows per image may be larger than the actual amount of rows of data.
+    ///
+    /// Required if there are multiple images (i.e. the depth is more than one).
     pub rows_per_image: Option<NonZeroU32>,
 }
 
 /// Specific type of a buffer binding.
 ///
 /// WebGPU spec: <https://gpuweb.github.io/gpuweb/#enumdef-gpubufferbindingtype>
 #[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
@@ -2834,31 +3065,33 @@ impl Default for TextureSampleType {
 }
 
 /// Specific type of a sample in a texture binding.
 ///
 /// WebGPU spec: <https://gpuweb.github.io/gpuweb/#enumdef-gpustoragetextureaccess>
 #[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
+#[cfg_attr(feature = "serde", serde(rename_all = "kebab-case"))]
 pub enum StorageTextureAccess {
-    /// The texture can only be read in the shader and it must be annotated with `readonly`.
-    ///
-    /// Example GLSL syntax:
-    /// ```cpp,ignore
-    /// layout(set=0, binding=0, r32f) readonly uniform image2D myStorageImage;
-    /// ```
-    ReadOnly,
     /// The texture can only be written in the shader and it must be annotated with `writeonly`.
     ///
     /// Example GLSL syntax:
     /// ```cpp,ignore
     /// layout(set=0, binding=0, r32f) writeonly uniform image2D myStorageImage;
     /// ```
     WriteOnly,
+    /// The texture can only be read in the shader and it must be annotated with `readonly`.
+    /// [`Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES`] must be enabled to use this access mode,
+    ///
+    /// Example GLSL syntax:
+    /// ```cpp,ignore
+    /// layout(set=0, binding=0, r32f) readonly uniform image2D myStorageImage;
+    /// ```
+    ReadOnly,
     /// The texture can be both read and written in the shader.
     /// [`Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES`] must be enabled to use this access mode.
     ///
     /// Example GLSL syntax:
     /// ```cpp,ignore
     /// layout(set=0, binding=0, r32f) uniform image2D myStorageImage;
     /// ```
     ReadWrite,
@@ -2958,22 +3191,22 @@ impl BindingType {
 #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
 #[cfg_attr(feature = "trace", derive(Serialize))]
 #[cfg_attr(feature = "replay", derive(Deserialize))]
 pub struct BindGroupLayoutEntry {
     /// Binding index. Must match shader index and be unique inside a BindGroupLayout. A binding
     /// of index 1, would be described as `layout(set = 0, binding = 1) uniform` in shaders.
     pub binding: u32,
     /// Which shader stages can see this binding.
-    pub visibility: ShaderStage,
+    pub visibility: ShaderStages,
     /// The type of the binding
     pub ty: BindingType,
     /// If this value is Some, indicates this entry is an array. Array size must be 1 or greater.
     ///
-    /// If this value is Some and `ty` is `BindingType::Texture`, [`Features::SAMPLED_TEXTURE_BINDING_ARRAY`] must be supported.
+    /// If this value is Some and `ty` is `BindingType::Texture`, [`Features::TEXTURE_BINDING_ARRAY`] must be supported.
     ///
     /// If this value is Some and `ty` is any other variant, bind group creation will fail.
     #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
     pub count: Option<NonZeroU32>,
 }
 
 /// View of a buffer which can be used to copy to/from a texture.
 #[repr(C)]
@@ -2995,16 +3228,19 @@ pub struct ImageCopyBuffer<B> {
 pub struct ImageCopyTexture<T> {
     /// The texture to be copied to/from.
     pub texture: T,
     /// The target mip level of the texture.
     pub mip_level: u32,
     /// The base texel of the texture in the selected `mip_level`.
     #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
     pub origin: Origin3d,
+    /// The copy aspect.
+    #[cfg_attr(any(feature = "trace", feature = "replay"), serde(default))]
+    pub aspect: TextureAspect,
 }
 
 /// Subresource range within an image
 #[repr(C)]
 #[derive(Clone, Debug, Default, PartialEq)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub struct ImageSubresourceRange {
@@ -3037,29 +3273,44 @@ pub enum SamplerBorderColor {
     /// [1, 1, 1, 1]
     OpaqueWhite,
 }
 
 /// Describes how to create a QuerySet.
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
-pub struct QuerySetDescriptor {
+pub struct QuerySetDescriptor<L> {
+    /// Debug label for the query set.
+    pub label: L,
     /// Kind of query that this query set should contain.
     pub ty: QueryType,
     /// Total count of queries the set contains. Must not be zero.
     /// Must not be greater than [`QUERY_SET_MAX_QUERIES`].
     pub count: u32,
 }
 
+impl<L> QuerySetDescriptor<L> {
+    ///
+    pub fn map_label<'a, K>(&'a self, fun: impl FnOnce(&'a L) -> K) -> QuerySetDescriptor<K> {
+        QuerySetDescriptor {
+            label: fun(&self.label),
+            ty: self.ty,
+            count: self.count,
+        }
+    }
+}
+
 /// Type of query contained in a QuerySet.
 #[derive(Copy, Clone, Debug)]
 #[cfg_attr(feature = "trace", derive(serde::Serialize))]
 #[cfg_attr(feature = "replay", derive(serde::Deserialize))]
 pub enum QueryType {
+    /// Query returns a single 64-bit number, serving as an occlusion boolean.
+    Occlusion,
     /// Query returns up to 5 64-bit numbers based on the given flags.
     ///
     /// See [`PipelineStatisticsTypes`]'s documentation for more information
     /// on how they get resolved.
     ///
     /// [`Features::PIPELINE_STATISTICS_QUERY`] must be enabled to use this query type.
     PipelineStatistics(PipelineStatisticsTypes),
     /// Query returns a 64-bit number indicating the GPU-timestamp
@@ -3087,31 +3338,31 @@ bitflags::bitflags! {
     /// the first 8 bytes being the primitive out value, the last 8
     /// bytes being the compute shader invocation count.
     #[repr(transparent)]
     #[cfg_attr(feature = "trace", derive(Serialize))]
     #[cfg_attr(feature = "replay", derive(Deserialize))]
     pub struct PipelineStatisticsTypes : u8 {
         /// Amount of times the vertex shader is ran. Accounts for
         /// the vertex cache when doing indexed rendering.
-        const VERTEX_SHADER_INVOCATIONS = 0x01;
+        const VERTEX_SHADER_INVOCATIONS = 1 << 0;
         /// Amount of times the clipper is invoked. This
         /// is also the amount of triangles output by the vertex shader.
-        const CLIPPER_INVOCATIONS = 0x02;
+        const CLIPPER_INVOCATIONS = 1 << 1;
         /// Amount of primitives that are not culled by the clipper.
         /// This is the amount of triangles that are actually on screen
         /// and will be rasterized and rendered.
-        const CLIPPER_PRIMITIVES_OUT = 0x04;
+        const CLIPPER_PRIMITIVES_OUT = 1 << 2;
         /// Amount of times the fragment shader is ran. Accounts for
         /// fragment shaders running in 2x2 blocks in order to get
         /// derivatives.
-        const FRAGMENT_SHADER_INVOCATIONS = 0x08;
+        const FRAGMENT_SHADER_INVOCATIONS = 1 << 3;
         /// Amount of times a compute shader is invoked. This will
         /// be equivalent to the dispatch count times the workgroup size.
-        const COMPUTE_SHADER_INVOCATIONS = 0x10;
+        const COMPUTE_SHADER_INVOCATIONS = 1 << 4;
     }
 }
 
 /// Argument buffer layout for draw_indirect commands.
 #[repr(C)]
 #[derive(Clone, Copy, Debug)]
 pub struct DrawIndirectArgs {
     /// The number of vertices to draw.