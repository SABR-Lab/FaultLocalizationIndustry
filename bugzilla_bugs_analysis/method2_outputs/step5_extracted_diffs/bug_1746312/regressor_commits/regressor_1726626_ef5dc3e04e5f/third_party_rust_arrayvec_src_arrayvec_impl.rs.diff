# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/arrayvec/src/arrayvec_impl.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/arrayvec/src/arrayvec_impl.rs b/third_party/rust/arrayvec/src/arrayvec_impl.rs
new file mode 100644
--- /dev/null
+++ b/third_party/rust/arrayvec/src/arrayvec_impl.rs
@@ -0,0 +1,86 @@
+use std::ptr;
+use std::slice;
+
+use crate::CapacityError;
+
+/// Implements basic arrayvec methods - based on a few required methods
+/// for length and element access.
+pub(crate) trait ArrayVecImpl {
+    type Item;
+    const CAPACITY: usize;
+
+    fn len(&self) -> usize;
+
+    unsafe fn set_len(&mut self, new_len: usize);
+
+    /// Return a slice containing all elements of the vector.
+    fn as_slice(&self) -> &[Self::Item] {
+        let len = self.len();
+        unsafe {
+            slice::from_raw_parts(self.as_ptr(), len)
+        }
+    }
+
+    /// Return a mutable slice containing all elements of the vector.
+    fn as_mut_slice(&mut self) -> &mut [Self::Item] {
+        let len = self.len();
+        unsafe {
+            std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
+        }
+    }
+
+    /// Return a raw pointer to the vector's buffer.
+    fn as_ptr(&self) -> *const Self::Item;
+
+    /// Return a raw mutable pointer to the vector's buffer.
+    fn as_mut_ptr(&mut self) -> *mut Self::Item;
+
+    fn push(&mut self, element: Self::Item) {
+        self.try_push(element).unwrap()
+    }
+
+    fn try_push(&mut self, element: Self::Item) -> Result<(), CapacityError<Self::Item>> {
+        if self.len() < Self::CAPACITY {
+            unsafe {
+                self.push_unchecked(element);
+            }
+            Ok(())
+        } else {
+            Err(CapacityError::new(element))
+        }
+    }
+
+    unsafe fn push_unchecked(&mut self, element: Self::Item) {
+        let len = self.len();
+        debug_assert!(len < Self::CAPACITY);
+        ptr::write(self.as_mut_ptr().add(len), element);
+        self.set_len(len + 1);
+    }
+
+    fn pop(&mut self) -> Option<Self::Item> {
+        if self.len() == 0 {
+            return None;
+        }
+        unsafe {
+            let new_len = self.len() - 1;
+            self.set_len(new_len);
+            Some(ptr::read(self.as_ptr().add(new_len)))
+        }
+    }
+
+    fn clear(&mut self) {
+        self.truncate(0)
+    }
+
+    fn truncate(&mut self, new_len: usize) {
+        unsafe {
+            let len = self.len();
+            if new_len < len {
+                self.set_len(new_len);
+                let tail = slice::from_raw_parts_mut(self.as_mut_ptr().add(new_len), len - new_len);
+                ptr::drop_in_place(tail);
+            }
+        }
+    }
+}
+