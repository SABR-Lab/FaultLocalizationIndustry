# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/arrayvec/src/char.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/arrayvec/src/char.rs b/third_party/rust/arrayvec/src/char.rs
--- a/third_party/rust/arrayvec/src/char.rs
+++ b/third_party/rust/arrayvec/src/char.rs
@@ -5,62 +5,55 @@
 // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
 // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
 // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 //
 // Original authors: alexchrichton, bluss
 
-use std::ptr;
-
 // UTF-8 ranges and tags for encoding characters
 const TAG_CONT: u8    = 0b1000_0000;
 const TAG_TWO_B: u8   = 0b1100_0000;
 const TAG_THREE_B: u8 = 0b1110_0000;
 const TAG_FOUR_B: u8  = 0b1111_0000;
 const MAX_ONE_B: u32   =     0x80;
 const MAX_TWO_B: u32   =    0x800;
 const MAX_THREE_B: u32 =  0x10000;
 
 /// Placeholder
 pub struct EncodeUtf8Error;
 
-#[inline]
-unsafe fn write(ptr: *mut u8, index: usize, byte: u8) {
-    ptr::write(ptr.add(index), byte)
-}
-
 /// Encode a char into buf using UTF-8.
 ///
 /// On success, return the byte length of the encoding (1, 2, 3 or 4).<br>
 /// On error, return `EncodeUtf8Error` if the buffer was too short for the char.
 ///
 /// Safety: `ptr` must be writable for `len` bytes.
 #[inline]
 pub unsafe fn encode_utf8(ch: char, ptr: *mut u8, len: usize) -> Result<usize, EncodeUtf8Error>
 {
     let code = ch as u32;
     if code < MAX_ONE_B && len >= 1 {
-        write(ptr, 0, code as u8);
+        ptr.add(0).write(code as u8);
         return Ok(1);
     } else if code < MAX_TWO_B && len >= 2 {
-        write(ptr, 0, (code >> 6 & 0x1F) as u8 | TAG_TWO_B);
-        write(ptr, 1, (code & 0x3F) as u8 | TAG_CONT);
+        ptr.add(0).write((code >> 6 & 0x1F) as u8 | TAG_TWO_B);
+        ptr.add(1).write((code & 0x3F) as u8 | TAG_CONT);
         return Ok(2);
     } else if code < MAX_THREE_B && len >= 3 {
-        write(ptr, 0, (code >> 12 & 0x0F) as u8 | TAG_THREE_B);
-        write(ptr, 1, (code >>  6 & 0x3F) as u8 | TAG_CONT);
-        write(ptr, 2, (code & 0x3F) as u8 | TAG_CONT);
+        ptr.add(0).write((code >> 12 & 0x0F) as u8 | TAG_THREE_B);
+        ptr.add(1).write((code >>  6 & 0x3F) as u8 | TAG_CONT);
+        ptr.add(2).write((code & 0x3F) as u8 | TAG_CONT);
         return Ok(3);
     } else if len >= 4 {
-        write(ptr, 0, (code >> 18 & 0x07) as u8 | TAG_FOUR_B);
-        write(ptr, 1, (code >> 12 & 0x3F) as u8 | TAG_CONT);
-        write(ptr, 2, (code >>  6 & 0x3F) as u8 | TAG_CONT);
-        write(ptr, 3, (code & 0x3F) as u8 | TAG_CONT);
+        ptr.add(0).write((code >> 18 & 0x07) as u8 | TAG_FOUR_B);
+        ptr.add(1).write((code >> 12 & 0x3F) as u8 | TAG_CONT);
+        ptr.add(2).write((code >>  6 & 0x3F) as u8 | TAG_CONT);
+        ptr.add(3).write((code & 0x3F) as u8 | TAG_CONT);
         return Ok(4);
     };
     Err(EncodeUtf8Error)
 }
 
 
 #[test]
 #[cfg_attr(miri, ignore)] // Miri is too slow