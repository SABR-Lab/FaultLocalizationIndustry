# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/ash/src/entry_libloading.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/ash/src/entry_libloading.rs b/third_party/rust/ash/src/entry_libloading.rs
--- a/third_party/rust/ash/src/entry_libloading.rs
+++ b/third_party/rust/ash/src/entry_libloading.rs
@@ -1,9 +1,10 @@
 use crate::entry::EntryCustom;
+use crate::entry::MissingEntryPoint;
 use libloading::Library;
 use std::error::Error;
 use std::ffi::OsStr;
 use std::fmt;
 use std::ptr;
 use std::sync::Arc;
 
 #[cfg(windows)]
@@ -16,68 +17,85 @@ const LIB_PATH: &str = "vulkan-1.dll";
 const LIB_PATH: &str = "libvulkan.so.1";
 
 #[cfg(target_os = "android")]
 const LIB_PATH: &str = "libvulkan.so";
 
 #[cfg(any(target_os = "macos", target_os = "ios"))]
 const LIB_PATH: &str = "libvulkan.dylib";
 
-/// Function loader
-pub type Entry = EntryCustom<Arc<Library>>;
-
 #[derive(Debug)]
-pub struct LoadingError(libloading::Error);
+pub enum LoadingError {
+    LibraryLoadFailure(libloading::Error),
+    MissingEntryPoint(MissingEntryPoint),
+}
 
 impl fmt::Display for LoadingError {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        fmt::Display::fmt(&self.0, f)
+        match self {
+            LoadingError::LibraryLoadFailure(err) => fmt::Display::fmt(err, f),
+            LoadingError::MissingEntryPoint(err) => fmt::Display::fmt(err, f),
+        }
     }
 }
 
 impl Error for LoadingError {
     fn source(&self) -> Option<&(dyn Error + 'static)> {
-        Error::source(&self.0)
+        Some(match self {
+            LoadingError::LibraryLoadFailure(err) => err,
+            LoadingError::MissingEntryPoint(err) => err,
+        })
     }
 }
 
-impl EntryCustom<Arc<Library>> {
+impl From<MissingEntryPoint> for LoadingError {
+    fn from(err: MissingEntryPoint) -> Self {
+        LoadingError::MissingEntryPoint(err)
+    }
+}
+
+/// Default function loader
+pub type Entry = EntryCustom<Arc<Library>>;
+
+impl Entry {
     /// Load default Vulkan library for the current platform
     ///
     /// # Safety
     /// `dlopen`ing native libraries is inherently unsafe. The safety guidelines
     /// for [`Library::new`] and [`Library::get`] apply here.
     ///
-    /// ```rust,no_run
-    /// use ash::{vk, Entry, version::EntryV1_0};
-    /// # fn main() -> Result<(), Box<std::error::Error>> {
-    /// let entry = Entry::new()?;
+    /// ```no_run
+    /// use ash::{vk, Entry};
+    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
+    /// let entry = unsafe { Entry::new() }?;
     /// let app_info = vk::ApplicationInfo {
-    ///     api_version: vk::make_version(1, 0, 0),
+    ///     api_version: vk::make_api_version(0, 1, 0, 0),
     ///     ..Default::default()
     /// };
     /// let create_info = vk::InstanceCreateInfo {
     ///     p_application_info: &app_info,
     ///     ..Default::default()
     /// };
     /// let instance = unsafe { entry.create_instance(&create_info, None)? };
     /// # Ok(()) }
     /// ```
     pub unsafe fn new() -> Result<Entry, LoadingError> {
-        Self::with_library(&LIB_PATH)
+        Self::with_library(LIB_PATH)
     }
 
     /// Load Vulkan library at `path`
     ///
     /// # Safety
     /// `dlopen`ing native libraries is inherently unsafe. The safety guidelines
     /// for [`Library::new`] and [`Library::get`] apply here.
-    pub unsafe fn with_library(path: &impl AsRef<OsStr>) -> Result<Entry, LoadingError> {
-        let lib = Library::new(path).map_err(LoadingError).map(Arc::new)?;
+    pub unsafe fn with_library(path: impl AsRef<OsStr>) -> Result<Entry, LoadingError> {
+        let lib = Library::new(path)
+            .map_err(LoadingError::LibraryLoadFailure)
+            .map(Arc::new)?;
 
         Ok(Self::new_custom(lib, |vk_lib, name| {
             vk_lib
                 .get(name.to_bytes_with_nul())
                 .map(|symbol| *symbol)
                 .unwrap_or(ptr::null_mut())
-        }))
+        })?)
     }
 }