# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/ash/src/vk/definitions.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/ash/src/vk/definitions.rs b/third_party/rust/ash/src/vk/definitions.rs
--- a/third_party/rust/ash/src/vk/definitions.rs
+++ b/third_party/rust/ash/src/vk/definitions.rs
@@ -1,43 +1,85 @@
 use crate::vk::aliases::*;
 use crate::vk::bitflags::*;
 use crate::vk::constants::*;
 use crate::vk::enums::*;
+use crate::vk::native::*;
 use crate::vk::platform_types::*;
 use crate::vk::{ptr_chain_iter, Handle};
 use std::fmt;
 use std::os::raw::*;
-pub const API_VERSION_1_0: u32 = crate::vk::make_version(1, 0, 0);
-pub const API_VERSION_1_1: u32 = crate::vk::make_version(1, 1, 0);
-pub const API_VERSION_1_2: u32 = crate::vk::make_version(1, 2, 0);
-pub const HEADER_VERSION: u32 = 168u32;
-pub const HEADER_VERSION_COMPLETE: u32 = crate::vk::make_version(1, 2, HEADER_VERSION);
+#[deprecated = "This define is deprecated. VK_MAKE_API_VERSION should be used instead."]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_MAKE_VERSION.html>"]
+pub const fn make_version(major: u32, minor: u32, patch: u32) -> u32 {
+    ((major) << 22) | ((minor) << 12) | (patch)
+}
+#[deprecated = "This define is deprecated. VK_API_VERSION_MAJOR should be used instead."]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_VERSION_MAJOR.html>"]
+pub const fn version_major(version: u32) -> u32 {
+    (version) >> 22
+}
+#[deprecated = "This define is deprecated. VK_API_VERSION_MINOR should be used instead."]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_VERSION_MINOR.html>"]
+pub const fn version_minor(version: u32) -> u32 {
+    ((version) >> 12) & 0x3ffu32
+}
+#[deprecated = "This define is deprecated. VK_API_VERSION_PATCH should be used instead."]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_VERSION_PATCH.html>"]
+pub const fn version_patch(version: u32) -> u32 {
+    (version) & 0xfffu32
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_MAKE_API_VERSION.html>"]
+pub const fn make_api_version(variant: u32, major: u32, minor: u32, patch: u32) -> u32 {
+    ((variant) << 29) | ((major) << 22) | ((minor) << 12) | (patch)
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_VARIANT.html>"]
+pub const fn api_version_variant(version: u32) -> u32 {
+    (version) >> 29
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_MAJOR.html>"]
+pub const fn api_version_major(version: u32) -> u32 {
+    ((version) >> 22) & 0x7fu32
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_MINOR.html>"]
+pub const fn api_version_minor(version: u32) -> u32 {
+    ((version) >> 12) & 0x3ffu32
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_PATCH.html>"]
+pub const fn api_version_patch(version: u32) -> u32 {
+    (version) & 0xfffu32
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_1_0.html>"]
+pub const API_VERSION_1_0: u32 = make_api_version(0, 1, 0, 0);
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_1_1.html>"]
+pub const API_VERSION_1_1: u32 = make_api_version(0, 1, 1, 0);
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_API_VERSION_1_2.html>"]
+pub const API_VERSION_1_2: u32 = make_api_version(0, 1, 2, 0);
+pub const HEADER_VERSION: u32 = 186u32;
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_HEADER_VERSION_COMPLETE.html>"]
+pub const HEADER_VERSION_COMPLETE: u32 = make_api_version(0, 1, 2, HEADER_VERSION);
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSampleMask.html>"]
 pub type SampleMask = u32;
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBool32.html>"]
 pub type Bool32 = u32;
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFlags.html>"]
 pub type Flags = u32;
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFlags64.html>"]
+pub type Flags64 = u64;
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceSize.html>"]
 pub type DeviceSize = u64;
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceAddress.html>"]
 pub type DeviceAddress = u64;
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueryPoolCreateFlags.html>"]
 pub struct QueryPoolCreateFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(QueryPoolCreateFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
-#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineLayoutCreateFlags.html>"]
-pub struct PipelineLayoutCreateFlags(pub(crate) Flags);
-vk_bitflags_wrapped!(PipelineLayoutCreateFlags, 0b0, Flags);
-#[repr(transparent)]
-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDepthStencilStateCreateFlags.html>"]
 pub struct PipelineDepthStencilStateCreateFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(PipelineDepthStencilStateCreateFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineDynamicStateCreateFlags.html>"]
 pub struct PipelineDynamicStateCreateFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(PipelineDynamicStateCreateFlags, 0b0, Flags);
@@ -93,36 +135,41 @@ pub struct DeviceCreateFlags(pub(crate) 
 vk_bitflags_wrapped!(DeviceCreateFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreCreateFlags.html>"]
 pub struct SemaphoreCreateFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(SemaphoreCreateFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
-#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkEventCreateFlags.html>"]
-pub struct EventCreateFlags(pub(crate) Flags);
-vk_bitflags_wrapped!(EventCreateFlags, 0b0, Flags);
-#[repr(transparent)]
-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryMapFlags.html>"]
 pub struct MemoryMapFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(MemoryMapFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorPoolResetFlags.html>"]
 pub struct DescriptorPoolResetFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(DescriptorPoolResetFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplateCreateFlags.html>"]
 pub struct DescriptorUpdateTemplateCreateFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(DescriptorUpdateTemplateCreateFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureMotionInfoFlagsNV.html>"]
+pub struct AccelerationStructureMotionInfoFlagsNV(pub(crate) Flags);
+vk_bitflags_wrapped!(AccelerationStructureMotionInfoFlagsNV, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureMotionInstanceFlagsNV.html>"]
+pub struct AccelerationStructureMotionInstanceFlagsNV(pub(crate) Flags);
+vk_bitflags_wrapped!(AccelerationStructureMotionInstanceFlagsNV, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeCreateFlagsKHR.html>"]
 pub struct DisplayModeCreateFlagsKHR(pub(crate) Flags);
 vk_bitflags_wrapped!(DisplayModeCreateFlagsKHR, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplaySurfaceCreateFlagsKHR.html>"]
 pub struct DisplaySurfaceCreateFlagsKHR(pub(crate) Flags);
 vk_bitflags_wrapped!(DisplaySurfaceCreateFlagsKHR, 0b0, Flags);
@@ -188,16 +235,21 @@ pub struct StreamDescriptorSurfaceCreate
 vk_bitflags_wrapped!(StreamDescriptorSurfaceCreateFlagsGGP, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkHeadlessSurfaceCreateFlagsEXT.html>"]
 pub struct HeadlessSurfaceCreateFlagsEXT(pub(crate) Flags);
 vk_bitflags_wrapped!(HeadlessSurfaceCreateFlagsEXT, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkScreenSurfaceCreateFlagsQNX.html>"]
+pub struct ScreenSurfaceCreateFlagsQNX(pub(crate) Flags);
+vk_bitflags_wrapped!(ScreenSurfaceCreateFlagsQNX, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandPoolTrimFlags.html>"]
 pub struct CommandPoolTrimFlags(pub(crate) Flags);
 vk_bitflags_wrapped!(CommandPoolTrimFlags, 0b0, Flags);
 #[repr(transparent)]
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineViewportSwizzleStateCreateFlagsNV.html>"]
 pub struct PipelineViewportSwizzleStateCreateFlagsNV(pub(crate) Flags);
 vk_bitflags_wrapped!(PipelineViewportSwizzleStateCreateFlagsNV, 0b0, Flags);
@@ -259,16 +311,36 @@ vk_bitflags_wrapped!(PipelineRasterizati
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationDepthClipStateCreateFlagsEXT.html>"]
 pub struct PipelineRasterizationDepthClipStateCreateFlagsEXT(pub(crate) Flags);
 vk_bitflags_wrapped!(
     PipelineRasterizationDepthClipStateCreateFlagsEXT,
     0b0,
     Flags
 );
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoBeginCodingFlagsKHR.html>"]
+pub struct VideoBeginCodingFlagsKHR(pub(crate) Flags);
+vk_bitflags_wrapped!(VideoBeginCodingFlagsKHR, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEndCodingFlagsKHR.html>"]
+pub struct VideoEndCodingFlagsKHR(pub(crate) Flags);
+vk_bitflags_wrapped!(VideoEndCodingFlagsKHR, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264CreateFlagsEXT.html>"]
+pub struct VideoDecodeH264CreateFlagsEXT(pub(crate) Flags);
+vk_bitflags_wrapped!(VideoDecodeH264CreateFlagsEXT, 0b0, Flags);
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265CreateFlagsEXT.html>"]
+pub struct VideoDecodeH265CreateFlagsEXT(pub(crate) Flags);
+vk_bitflags_wrapped!(VideoDecodeH265CreateFlagsEXT, 0b0, Flags);
 define_handle!(
     Instance,
     INSTANCE,
     doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkInstance.html>"
 );
 define_handle ! (PhysicalDevice , PHYSICAL_DEVICE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice.html>") ;
 define_handle!(
     Device,
@@ -354,32 +426,36 @@ handle_nondispatchable ! (IndirectComman
 handle_nondispatchable ! (DescriptorUpdateTemplate , DESCRIPTOR_UPDATE_TEMPLATE , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorUpdateTemplate.html>") ;
 handle_nondispatchable ! (SamplerYcbcrConversion , SAMPLER_YCBCR_CONVERSION , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSamplerYcbcrConversion.html>") ;
 handle_nondispatchable ! (ValidationCacheEXT , VALIDATION_CACHE_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkValidationCacheEXT.html>") ;
 handle_nondispatchable ! (AccelerationStructureKHR , ACCELERATION_STRUCTURE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureKHR.html>") ;
 handle_nondispatchable ! (AccelerationStructureNV , ACCELERATION_STRUCTURE_NV , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureNV.html>") ;
 handle_nondispatchable ! (PerformanceConfigurationINTEL , PERFORMANCE_CONFIGURATION_INTEL , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPerformanceConfigurationINTEL.html>") ;
 handle_nondispatchable ! (DeferredOperationKHR , DEFERRED_OPERATION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeferredOperationKHR.html>") ;
 handle_nondispatchable ! (PrivateDataSlotEXT , PRIVATE_DATA_SLOT_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPrivateDataSlotEXT.html>") ;
+handle_nondispatchable ! (CuModuleNVX , CU_MODULE_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCuModuleNVX.html>") ;
+handle_nondispatchable ! (CuFunctionNVX , CU_FUNCTION_NVX , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCuFunctionNVX.html>") ;
 handle_nondispatchable!(
     DisplayKHR,
     DISPLAY_KHR,
     doc =
         "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayKHR.html>"
 );
 handle_nondispatchable ! (DisplayModeKHR , DISPLAY_MODE_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDisplayModeKHR.html>") ;
 handle_nondispatchable!(
     SurfaceKHR,
     SURFACE_KHR,
     doc =
         "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceKHR.html>"
 );
 handle_nondispatchable ! (SwapchainKHR , SWAPCHAIN_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainKHR.html>") ;
 handle_nondispatchable ! (DebugReportCallbackEXT , DEBUG_REPORT_CALLBACK_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDebugReportCallbackEXT.html>") ;
 handle_nondispatchable ! (DebugUtilsMessengerEXT , DEBUG_UTILS_MESSENGER_EXT , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDebugUtilsMessengerEXT.html>") ;
+handle_nondispatchable ! (VideoSessionKHR , VIDEO_SESSION_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoSessionKHR.html>") ;
+handle_nondispatchable ! (VideoSessionParametersKHR , VIDEO_SESSION_PARAMETERS_KHR , doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoSessionParametersKHR.html>") ;
 #[allow(non_camel_case_types)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/PFN_vkInternalAllocationNotification.html>"]
 pub type PFN_vkInternalAllocationNotification = Option<
     unsafe extern "system" fn(
         p_user_data: *mut c_void,
         size: usize,
         allocation_type: InternalAllocationType,
         allocation_scope: SystemAllocationScope,
@@ -512,21 +588,21 @@ impl<'a> ::std::ops::Deref for Offset2DB
     }
 }
 impl<'a> ::std::ops::DerefMut for Offset2DBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Offset2DBuilder<'a> {
-    pub fn x(mut self, x: i32) -> Offset2DBuilder<'a> {
+    pub fn x(mut self, x: i32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: i32) -> Offset2DBuilder<'a> {
+    pub fn y(mut self, y: i32) -> Self {
         self.inner.y = y;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Offset2D {
         self.inner
@@ -560,25 +636,25 @@ impl<'a> ::std::ops::Deref for Offset3DB
     }
 }
 impl<'a> ::std::ops::DerefMut for Offset3DBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Offset3DBuilder<'a> {
-    pub fn x(mut self, x: i32) -> Offset3DBuilder<'a> {
+    pub fn x(mut self, x: i32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: i32) -> Offset3DBuilder<'a> {
+    pub fn y(mut self, y: i32) -> Self {
         self.inner.y = y;
         self
     }
-    pub fn z(mut self, z: i32) -> Offset3DBuilder<'a> {
+    pub fn z(mut self, z: i32) -> Self {
         self.inner.z = z;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Offset3D {
         self.inner
@@ -611,21 +687,21 @@ impl<'a> ::std::ops::Deref for Extent2DB
     }
 }
 impl<'a> ::std::ops::DerefMut for Extent2DBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Extent2DBuilder<'a> {
-    pub fn width(mut self, width: u32) -> Extent2DBuilder<'a> {
+    pub fn width(mut self, width: u32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: u32) -> Extent2DBuilder<'a> {
+    pub fn height(mut self, height: u32) -> Self {
         self.inner.height = height;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Extent2D {
         self.inner
@@ -659,25 +735,25 @@ impl<'a> ::std::ops::Deref for Extent3DB
     }
 }
 impl<'a> ::std::ops::DerefMut for Extent3DBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Extent3DBuilder<'a> {
-    pub fn width(mut self, width: u32) -> Extent3DBuilder<'a> {
+    pub fn width(mut self, width: u32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: u32) -> Extent3DBuilder<'a> {
+    pub fn height(mut self, height: u32) -> Self {
         self.inner.height = height;
         self
     }
-    pub fn depth(mut self, depth: u32) -> Extent3DBuilder<'a> {
+    pub fn depth(mut self, depth: u32) -> Self {
         self.inner.depth = depth;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Extent3D {
         self.inner
@@ -714,37 +790,37 @@ impl<'a> ::std::ops::Deref for ViewportB
     }
 }
 impl<'a> ::std::ops::DerefMut for ViewportBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ViewportBuilder<'a> {
-    pub fn x(mut self, x: f32) -> ViewportBuilder<'a> {
+    pub fn x(mut self, x: f32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: f32) -> ViewportBuilder<'a> {
+    pub fn y(mut self, y: f32) -> Self {
         self.inner.y = y;
         self
     }
-    pub fn width(mut self, width: f32) -> ViewportBuilder<'a> {
+    pub fn width(mut self, width: f32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: f32) -> ViewportBuilder<'a> {
+    pub fn height(mut self, height: f32) -> Self {
         self.inner.height = height;
         self
     }
-    pub fn min_depth(mut self, min_depth: f32) -> ViewportBuilder<'a> {
+    pub fn min_depth(mut self, min_depth: f32) -> Self {
         self.inner.min_depth = min_depth;
         self
     }
-    pub fn max_depth(mut self, max_depth: f32) -> ViewportBuilder<'a> {
+    pub fn max_depth(mut self, max_depth: f32) -> Self {
         self.inner.max_depth = max_depth;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Viewport {
         self.inner
@@ -777,21 +853,21 @@ impl<'a> ::std::ops::Deref for Rect2DBui
     }
 }
 impl<'a> ::std::ops::DerefMut for Rect2DBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Rect2DBuilder<'a> {
-    pub fn offset(mut self, offset: Offset2D) -> Rect2DBuilder<'a> {
+    pub fn offset(mut self, offset: Offset2D) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn extent(mut self, extent: Extent2D) -> Rect2DBuilder<'a> {
+    pub fn extent(mut self, extent: Extent2D) -> Self {
         self.inner.extent = extent;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Rect2D {
         self.inner
@@ -825,25 +901,25 @@ impl<'a> ::std::ops::Deref for ClearRect
     }
 }
 impl<'a> ::std::ops::DerefMut for ClearRectBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ClearRectBuilder<'a> {
-    pub fn rect(mut self, rect: Rect2D) -> ClearRectBuilder<'a> {
+    pub fn rect(mut self, rect: Rect2D) -> Self {
         self.inner.rect = rect;
         self
     }
-    pub fn base_array_layer(mut self, base_array_layer: u32) -> ClearRectBuilder<'a> {
+    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
         self.inner.base_array_layer = base_array_layer;
         self
     }
-    pub fn layer_count(mut self, layer_count: u32) -> ClearRectBuilder<'a> {
+    pub fn layer_count(mut self, layer_count: u32) -> Self {
         self.inner.layer_count = layer_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ClearRect {
         self.inner
@@ -878,29 +954,29 @@ impl<'a> ::std::ops::Deref for Component
     }
 }
 impl<'a> ::std::ops::DerefMut for ComponentMappingBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ComponentMappingBuilder<'a> {
-    pub fn r(mut self, r: ComponentSwizzle) -> ComponentMappingBuilder<'a> {
+    pub fn r(mut self, r: ComponentSwizzle) -> Self {
         self.inner.r = r;
         self
     }
-    pub fn g(mut self, g: ComponentSwizzle) -> ComponentMappingBuilder<'a> {
+    pub fn g(mut self, g: ComponentSwizzle) -> Self {
         self.inner.g = g;
         self
     }
-    pub fn b(mut self, b: ComponentSwizzle) -> ComponentMappingBuilder<'a> {
+    pub fn b(mut self, b: ComponentSwizzle) -> Self {
         self.inner.b = b;
         self
     }
-    pub fn a(mut self, a: ComponentSwizzle) -> ComponentMappingBuilder<'a> {
+    pub fn a(mut self, a: ComponentSwizzle) -> Self {
         self.inner.a = a;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ComponentMapping {
         self.inner
@@ -972,61 +1048,49 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePropertiesBuilder<'a> {
-    pub fn api_version(mut self, api_version: u32) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn api_version(mut self, api_version: u32) -> Self {
         self.inner.api_version = api_version;
         self
     }
-    pub fn driver_version(mut self, driver_version: u32) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn driver_version(mut self, driver_version: u32) -> Self {
         self.inner.driver_version = driver_version;
         self
     }
-    pub fn vendor_id(mut self, vendor_id: u32) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
         self.inner.vendor_id = vendor_id;
         self
     }
-    pub fn device_id(mut self, device_id: u32) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn device_id(mut self, device_id: u32) -> Self {
         self.inner.device_id = device_id;
         self
     }
-    pub fn device_type(
-        mut self,
-        device_type: PhysicalDeviceType,
-    ) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn device_type(mut self, device_type: PhysicalDeviceType) -> Self {
         self.inner.device_type = device_type;
         self
     }
-    pub fn device_name(
-        mut self,
-        device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE],
-    ) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn device_name(mut self, device_name: [c_char; MAX_PHYSICAL_DEVICE_NAME_SIZE]) -> Self {
         self.inner.device_name = device_name;
         self
     }
-    pub fn pipeline_cache_uuid(
-        mut self,
-        pipeline_cache_uuid: [u8; UUID_SIZE],
-    ) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
         self
     }
-    pub fn limits(mut self, limits: PhysicalDeviceLimits) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn limits(mut self, limits: PhysicalDeviceLimits) -> Self {
         self.inner.limits = limits;
         self
     }
-    pub fn sparse_properties(
-        mut self,
-        sparse_properties: PhysicalDeviceSparseProperties,
-    ) -> PhysicalDevicePropertiesBuilder<'a> {
+    pub fn sparse_properties(mut self, sparse_properties: PhysicalDeviceSparseProperties) -> Self {
         self.inner.sparse_properties = sparse_properties;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceProperties {
         self.inner
@@ -1077,24 +1141,21 @@ impl<'a> ::std::ops::Deref for Extension
     }
 }
 impl<'a> ::std::ops::DerefMut for ExtensionPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExtensionPropertiesBuilder<'a> {
-    pub fn extension_name(
-        mut self,
-        extension_name: [c_char; MAX_EXTENSION_NAME_SIZE],
-    ) -> ExtensionPropertiesBuilder<'a> {
+    pub fn extension_name(mut self, extension_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
         self.inner.extension_name = extension_name;
         self
     }
-    pub fn spec_version(mut self, spec_version: u32) -> ExtensionPropertiesBuilder<'a> {
+    pub fn spec_version(mut self, spec_version: u32) -> Self {
         self.inner.spec_version = spec_version;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExtensionProperties {
         self.inner
@@ -1153,38 +1214,29 @@ impl<'a> ::std::ops::Deref for LayerProp
     }
 }
 impl<'a> ::std::ops::DerefMut for LayerPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> LayerPropertiesBuilder<'a> {
-    pub fn layer_name(
-        mut self,
-        layer_name: [c_char; MAX_EXTENSION_NAME_SIZE],
-    ) -> LayerPropertiesBuilder<'a> {
+    pub fn layer_name(mut self, layer_name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
         self.inner.layer_name = layer_name;
         self
     }
-    pub fn spec_version(mut self, spec_version: u32) -> LayerPropertiesBuilder<'a> {
+    pub fn spec_version(mut self, spec_version: u32) -> Self {
         self.inner.spec_version = spec_version;
         self
     }
-    pub fn implementation_version(
-        mut self,
-        implementation_version: u32,
-    ) -> LayerPropertiesBuilder<'a> {
+    pub fn implementation_version(mut self, implementation_version: u32) -> Self {
         self.inner.implementation_version = implementation_version;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> LayerPropertiesBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> LayerProperties {
         self.inner
@@ -1223,69 +1275,48 @@ impl ApplicationInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct ApplicationInfoBuilder<'a> {
     inner: ApplicationInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsApplicationInfo {}
 impl<'a> ::std::ops::Deref for ApplicationInfoBuilder<'a> {
     type Target = ApplicationInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ApplicationInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ApplicationInfoBuilder<'a> {
-    pub fn application_name(
-        mut self,
-        application_name: &'a ::std::ffi::CStr,
-    ) -> ApplicationInfoBuilder<'a> {
+    pub fn application_name(mut self, application_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_application_name = application_name.as_ptr();
         self
     }
-    pub fn application_version(mut self, application_version: u32) -> ApplicationInfoBuilder<'a> {
+    pub fn application_version(mut self, application_version: u32) -> Self {
         self.inner.application_version = application_version;
         self
     }
-    pub fn engine_name(mut self, engine_name: &'a ::std::ffi::CStr) -> ApplicationInfoBuilder<'a> {
+    pub fn engine_name(mut self, engine_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_engine_name = engine_name.as_ptr();
         self
     }
-    pub fn engine_version(mut self, engine_version: u32) -> ApplicationInfoBuilder<'a> {
+    pub fn engine_version(mut self, engine_version: u32) -> Self {
         self.inner.engine_version = engine_version;
         self
     }
-    pub fn api_version(mut self, api_version: u32) -> ApplicationInfoBuilder<'a> {
+    pub fn api_version(mut self, api_version: u32) -> Self {
         self.inner.api_version = api_version;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsApplicationInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> ApplicationInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ApplicationInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -1355,49 +1386,40 @@ impl<'a> ::std::ops::Deref for Allocatio
     }
 }
 impl<'a> ::std::ops::DerefMut for AllocationCallbacksBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AllocationCallbacksBuilder<'a> {
-    pub fn user_data(mut self, user_data: *mut c_void) -> AllocationCallbacksBuilder<'a> {
+    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
         self.inner.p_user_data = user_data;
         self
     }
-    pub fn pfn_allocation(
-        mut self,
-        pfn_allocation: PFN_vkAllocationFunction,
-    ) -> AllocationCallbacksBuilder<'a> {
+    pub fn pfn_allocation(mut self, pfn_allocation: PFN_vkAllocationFunction) -> Self {
         self.inner.pfn_allocation = pfn_allocation;
         self
     }
-    pub fn pfn_reallocation(
-        mut self,
-        pfn_reallocation: PFN_vkReallocationFunction,
-    ) -> AllocationCallbacksBuilder<'a> {
+    pub fn pfn_reallocation(mut self, pfn_reallocation: PFN_vkReallocationFunction) -> Self {
         self.inner.pfn_reallocation = pfn_reallocation;
         self
     }
-    pub fn pfn_free(mut self, pfn_free: PFN_vkFreeFunction) -> AllocationCallbacksBuilder<'a> {
+    pub fn pfn_free(mut self, pfn_free: PFN_vkFreeFunction) -> Self {
         self.inner.pfn_free = pfn_free;
         self
     }
     pub fn pfn_internal_allocation(
         mut self,
         pfn_internal_allocation: PFN_vkInternalAllocationNotification,
-    ) -> AllocationCallbacksBuilder<'a> {
+    ) -> Self {
         self.inner.pfn_internal_allocation = pfn_internal_allocation;
         self
     }
-    pub fn pfn_internal_free(
-        mut self,
-        pfn_internal_free: PFN_vkInternalFreeNotification,
-    ) -> AllocationCallbacksBuilder<'a> {
+    pub fn pfn_internal_free(mut self, pfn_internal_free: PFN_vkInternalFreeNotification) -> Self {
         self.inner.pfn_internal_free = pfn_internal_free;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AllocationCallbacks {
         self.inner
@@ -1447,44 +1469,35 @@ impl<'a> ::std::ops::Deref for DeviceQue
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceQueueCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceQueueCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> DeviceQueueCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn queue_family_index(
-        mut self,
-        queue_family_index: u32,
-    ) -> DeviceQueueCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
         self.inner.queue_family_index = queue_family_index;
         self
     }
-    pub fn queue_priorities(
-        mut self,
-        queue_priorities: &'a [f32],
-    ) -> DeviceQueueCreateInfoBuilder<'a> {
+    pub fn queue_priorities(mut self, queue_priorities: &'a [f32]) -> Self {
         self.inner.queue_count = queue_priorities.len() as _;
         self.inner.p_queue_priorities = queue_priorities.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceQueueCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceQueueCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsDeviceQueueCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -1547,60 +1560,45 @@ impl<'a> ::std::ops::Deref for DeviceCre
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: DeviceCreateFlags) -> DeviceCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn queue_create_infos(
-        mut self,
-        queue_create_infos: &'a [DeviceQueueCreateInfo],
-    ) -> DeviceCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: DeviceCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn queue_create_infos(mut self, queue_create_infos: &'a [DeviceQueueCreateInfo]) -> Self {
         self.inner.queue_create_info_count = queue_create_infos.len() as _;
         self.inner.p_queue_create_infos = queue_create_infos.as_ptr();
         self
     }
-    pub fn enabled_layer_names(
-        mut self,
-        enabled_layer_names: &'a [*const c_char],
-    ) -> DeviceCreateInfoBuilder<'a> {
+    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
         self.inner.enabled_layer_count = enabled_layer_names.len() as _;
         self.inner.pp_enabled_layer_names = enabled_layer_names.as_ptr();
         self
     }
-    pub fn enabled_extension_names(
-        mut self,
-        enabled_extension_names: &'a [*const c_char],
-    ) -> DeviceCreateInfoBuilder<'a> {
+    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
         self.inner.enabled_extension_count = enabled_extension_names.len() as _;
         self.inner.pp_enabled_extension_names = enabled_extension_names.as_ptr();
         self
     }
-    pub fn enabled_features(
-        mut self,
-        enabled_features: &'a PhysicalDeviceFeatures,
-    ) -> DeviceCreateInfoBuilder<'a> {
+    pub fn enabled_features(mut self, enabled_features: &'a PhysicalDeviceFeatures) -> Self {
         self.inner.p_enabled_features = enabled_features;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsDeviceCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -1659,52 +1657,40 @@ impl<'a> ::std::ops::Deref for InstanceC
     }
 }
 impl<'a> ::std::ops::DerefMut for InstanceCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> InstanceCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: InstanceCreateFlags) -> InstanceCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn application_info(
-        mut self,
-        application_info: &'a ApplicationInfo,
-    ) -> InstanceCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: InstanceCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn application_info(mut self, application_info: &'a ApplicationInfo) -> Self {
         self.inner.p_application_info = application_info;
         self
     }
-    pub fn enabled_layer_names(
-        mut self,
-        enabled_layer_names: &'a [*const c_char],
-    ) -> InstanceCreateInfoBuilder<'a> {
+    pub fn enabled_layer_names(mut self, enabled_layer_names: &'a [*const c_char]) -> Self {
         self.inner.enabled_layer_count = enabled_layer_names.len() as _;
         self.inner.pp_enabled_layer_names = enabled_layer_names.as_ptr();
         self
     }
-    pub fn enabled_extension_names(
-        mut self,
-        enabled_extension_names: &'a [*const c_char],
-    ) -> InstanceCreateInfoBuilder<'a> {
+    pub fn enabled_extension_names(mut self, enabled_extension_names: &'a [*const c_char]) -> Self {
         self.inner.enabled_extension_count = enabled_extension_names.len() as _;
         self.inner.pp_enabled_extension_names = enabled_extension_names.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsInstanceCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> InstanceCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsInstanceCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -1744,35 +1730,32 @@ impl<'a> ::std::ops::Deref for QueueFami
     }
 }
 impl<'a> ::std::ops::DerefMut for QueueFamilyPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueueFamilyPropertiesBuilder<'a> {
-    pub fn queue_flags(mut self, queue_flags: QueueFlags) -> QueueFamilyPropertiesBuilder<'a> {
+    pub fn queue_flags(mut self, queue_flags: QueueFlags) -> Self {
         self.inner.queue_flags = queue_flags;
         self
     }
-    pub fn queue_count(mut self, queue_count: u32) -> QueueFamilyPropertiesBuilder<'a> {
+    pub fn queue_count(mut self, queue_count: u32) -> Self {
         self.inner.queue_count = queue_count;
         self
     }
-    pub fn timestamp_valid_bits(
-        mut self,
-        timestamp_valid_bits: u32,
-    ) -> QueueFamilyPropertiesBuilder<'a> {
+    pub fn timestamp_valid_bits(mut self, timestamp_valid_bits: u32) -> Self {
         self.inner.timestamp_valid_bits = timestamp_valid_bits;
         self
     }
     pub fn min_image_transfer_granularity(
         mut self,
         min_image_transfer_granularity: Extent3D,
-    ) -> QueueFamilyPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.min_image_transfer_granularity = min_image_transfer_granularity;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> QueueFamilyProperties {
         self.inner
@@ -1817,41 +1800,29 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMemoryPropertiesBuilder<'a> {
-    pub fn memory_type_count(
-        mut self,
-        memory_type_count: u32,
-    ) -> PhysicalDeviceMemoryPropertiesBuilder<'a> {
+    pub fn memory_type_count(mut self, memory_type_count: u32) -> Self {
         self.inner.memory_type_count = memory_type_count;
         self
     }
-    pub fn memory_types(
-        mut self,
-        memory_types: [MemoryType; MAX_MEMORY_TYPES],
-    ) -> PhysicalDeviceMemoryPropertiesBuilder<'a> {
+    pub fn memory_types(mut self, memory_types: [MemoryType; MAX_MEMORY_TYPES]) -> Self {
         self.inner.memory_types = memory_types;
         self
     }
-    pub fn memory_heap_count(
-        mut self,
-        memory_heap_count: u32,
-    ) -> PhysicalDeviceMemoryPropertiesBuilder<'a> {
+    pub fn memory_heap_count(mut self, memory_heap_count: u32) -> Self {
         self.inner.memory_heap_count = memory_heap_count;
         self
     }
-    pub fn memory_heaps(
-        mut self,
-        memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS],
-    ) -> PhysicalDeviceMemoryPropertiesBuilder<'a> {
+    pub fn memory_heaps(mut self, memory_heaps: [MemoryHeap; MAX_MEMORY_HEAPS]) -> Self {
         self.inner.memory_heaps = memory_heaps;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMemoryProperties {
         self.inner
@@ -1897,33 +1868,30 @@ impl<'a> ::std::ops::Deref for MemoryAll
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryAllocateInfoBuilder<'a> {
-    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> MemoryAllocateInfoBuilder<'a> {
+    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
         self.inner.allocation_size = allocation_size;
         self
     }
-    pub fn memory_type_index(mut self, memory_type_index: u32) -> MemoryAllocateInfoBuilder<'a> {
+    pub fn memory_type_index(mut self, memory_type_index: u32) -> Self {
         self.inner.memory_type_index = memory_type_index;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryAllocateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryAllocateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsMemoryAllocateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -1962,25 +1930,25 @@ impl<'a> ::std::ops::Deref for MemoryReq
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryRequirementsBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryRequirementsBuilder<'a> {
-    pub fn size(mut self, size: DeviceSize) -> MemoryRequirementsBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn alignment(mut self, alignment: DeviceSize) -> MemoryRequirementsBuilder<'a> {
+    pub fn alignment(mut self, alignment: DeviceSize) -> Self {
         self.inner.alignment = alignment;
         self
     }
-    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> MemoryRequirementsBuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
         self.inner.memory_type_bits = memory_type_bits;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryRequirements {
         self.inner
@@ -2014,34 +1982,25 @@ impl<'a> ::std::ops::Deref for SparseIma
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageFormatPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageFormatPropertiesBuilder<'a> {
-    pub fn aspect_mask(
-        mut self,
-        aspect_mask: ImageAspectFlags,
-    ) -> SparseImageFormatPropertiesBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
-    pub fn image_granularity(
-        mut self,
-        image_granularity: Extent3D,
-    ) -> SparseImageFormatPropertiesBuilder<'a> {
+    pub fn image_granularity(mut self, image_granularity: Extent3D) -> Self {
         self.inner.image_granularity = image_granularity;
         self
     }
-    pub fn flags(
-        mut self,
-        flags: SparseImageFormatFlags,
-    ) -> SparseImageFormatPropertiesBuilder<'a> {
+    pub fn flags(mut self, flags: SparseImageFormatFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageFormatProperties {
         self.inner
@@ -2077,48 +2036,33 @@ impl<'a> ::std::ops::Deref for SparseIma
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageMemoryRequirementsBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageMemoryRequirementsBuilder<'a> {
-    pub fn format_properties(
-        mut self,
-        format_properties: SparseImageFormatProperties,
-    ) -> SparseImageMemoryRequirementsBuilder<'a> {
+    pub fn format_properties(mut self, format_properties: SparseImageFormatProperties) -> Self {
         self.inner.format_properties = format_properties;
         self
     }
-    pub fn image_mip_tail_first_lod(
-        mut self,
-        image_mip_tail_first_lod: u32,
-    ) -> SparseImageMemoryRequirementsBuilder<'a> {
+    pub fn image_mip_tail_first_lod(mut self, image_mip_tail_first_lod: u32) -> Self {
         self.inner.image_mip_tail_first_lod = image_mip_tail_first_lod;
         self
     }
-    pub fn image_mip_tail_size(
-        mut self,
-        image_mip_tail_size: DeviceSize,
-    ) -> SparseImageMemoryRequirementsBuilder<'a> {
+    pub fn image_mip_tail_size(mut self, image_mip_tail_size: DeviceSize) -> Self {
         self.inner.image_mip_tail_size = image_mip_tail_size;
         self
     }
-    pub fn image_mip_tail_offset(
-        mut self,
-        image_mip_tail_offset: DeviceSize,
-    ) -> SparseImageMemoryRequirementsBuilder<'a> {
+    pub fn image_mip_tail_offset(mut self, image_mip_tail_offset: DeviceSize) -> Self {
         self.inner.image_mip_tail_offset = image_mip_tail_offset;
         self
     }
-    pub fn image_mip_tail_stride(
-        mut self,
-        image_mip_tail_stride: DeviceSize,
-    ) -> SparseImageMemoryRequirementsBuilder<'a> {
+    pub fn image_mip_tail_stride(mut self, image_mip_tail_stride: DeviceSize) -> Self {
         self.inner.image_mip_tail_stride = image_mip_tail_stride;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageMemoryRequirements {
         self.inner
@@ -2151,21 +2095,21 @@ impl<'a> ::std::ops::Deref for MemoryTyp
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryTypeBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryTypeBuilder<'a> {
-    pub fn property_flags(mut self, property_flags: MemoryPropertyFlags) -> MemoryTypeBuilder<'a> {
+    pub fn property_flags(mut self, property_flags: MemoryPropertyFlags) -> Self {
         self.inner.property_flags = property_flags;
         self
     }
-    pub fn heap_index(mut self, heap_index: u32) -> MemoryTypeBuilder<'a> {
+    pub fn heap_index(mut self, heap_index: u32) -> Self {
         self.inner.heap_index = heap_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryType {
         self.inner
@@ -2198,21 +2142,21 @@ impl<'a> ::std::ops::Deref for MemoryHea
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryHeapBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryHeapBuilder<'a> {
-    pub fn size(mut self, size: DeviceSize) -> MemoryHeapBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn flags(mut self, flags: MemoryHeapFlags) -> MemoryHeapBuilder<'a> {
+    pub fn flags(mut self, flags: MemoryHeapFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryHeap {
         self.inner
@@ -2247,58 +2191,40 @@ impl MappedMemoryRange {
         }
     }
 }
 #[repr(transparent)]
 pub struct MappedMemoryRangeBuilder<'a> {
     inner: MappedMemoryRange,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMappedMemoryRange {}
 impl<'a> ::std::ops::Deref for MappedMemoryRangeBuilder<'a> {
     type Target = MappedMemoryRange;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MappedMemoryRangeBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MappedMemoryRangeBuilder<'a> {
-    pub fn memory(mut self, memory: DeviceMemory) -> MappedMemoryRangeBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> MappedMemoryRangeBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> MappedMemoryRangeBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMappedMemoryRange>(
-        mut self,
-        next: &'a mut T,
-    ) -> MappedMemoryRangeBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MappedMemoryRange {
         self.inner
     }
 }
 #[repr(C)]
@@ -2329,34 +2255,25 @@ impl<'a> ::std::ops::Deref for FormatPro
     }
 }
 impl<'a> ::std::ops::DerefMut for FormatPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FormatPropertiesBuilder<'a> {
-    pub fn linear_tiling_features(
-        mut self,
-        linear_tiling_features: FormatFeatureFlags,
-    ) -> FormatPropertiesBuilder<'a> {
+    pub fn linear_tiling_features(mut self, linear_tiling_features: FormatFeatureFlags) -> Self {
         self.inner.linear_tiling_features = linear_tiling_features;
         self
     }
-    pub fn optimal_tiling_features(
-        mut self,
-        optimal_tiling_features: FormatFeatureFlags,
-    ) -> FormatPropertiesBuilder<'a> {
+    pub fn optimal_tiling_features(mut self, optimal_tiling_features: FormatFeatureFlags) -> Self {
         self.inner.optimal_tiling_features = optimal_tiling_features;
         self
     }
-    pub fn buffer_features(
-        mut self,
-        buffer_features: FormatFeatureFlags,
-    ) -> FormatPropertiesBuilder<'a> {
+    pub fn buffer_features(mut self, buffer_features: FormatFeatureFlags) -> Self {
         self.inner.buffer_features = buffer_features;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FormatProperties {
         self.inner
@@ -2392,39 +2309,33 @@ impl<'a> ::std::ops::Deref for ImageForm
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageFormatPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageFormatPropertiesBuilder<'a> {
-    pub fn max_extent(mut self, max_extent: Extent3D) -> ImageFormatPropertiesBuilder<'a> {
+    pub fn max_extent(mut self, max_extent: Extent3D) -> Self {
         self.inner.max_extent = max_extent;
         self
     }
-    pub fn max_mip_levels(mut self, max_mip_levels: u32) -> ImageFormatPropertiesBuilder<'a> {
+    pub fn max_mip_levels(mut self, max_mip_levels: u32) -> Self {
         self.inner.max_mip_levels = max_mip_levels;
         self
     }
-    pub fn max_array_layers(mut self, max_array_layers: u32) -> ImageFormatPropertiesBuilder<'a> {
+    pub fn max_array_layers(mut self, max_array_layers: u32) -> Self {
         self.inner.max_array_layers = max_array_layers;
         self
     }
-    pub fn sample_counts(
-        mut self,
-        sample_counts: SampleCountFlags,
-    ) -> ImageFormatPropertiesBuilder<'a> {
+    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
         self.inner.sample_counts = sample_counts;
         self
     }
-    pub fn max_resource_size(
-        mut self,
-        max_resource_size: DeviceSize,
-    ) -> ImageFormatPropertiesBuilder<'a> {
+    pub fn max_resource_size(mut self, max_resource_size: DeviceSize) -> Self {
         self.inner.max_resource_size = max_resource_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageFormatProperties {
         self.inner
@@ -2458,25 +2369,25 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorBufferInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorBufferInfoBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> DescriptorBufferInfoBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> DescriptorBufferInfoBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn range(mut self, range: DeviceSize) -> DescriptorBufferInfoBuilder<'a> {
+    pub fn range(mut self, range: DeviceSize) -> Self {
         self.inner.range = range;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorBufferInfo {
         self.inner
@@ -2510,25 +2421,25 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorImageInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorImageInfoBuilder<'a> {
-    pub fn sampler(mut self, sampler: Sampler) -> DescriptorImageInfoBuilder<'a> {
+    pub fn sampler(mut self, sampler: Sampler) -> Self {
         self.inner.sampler = sampler;
         self
     }
-    pub fn image_view(mut self, image_view: ImageView) -> DescriptorImageInfoBuilder<'a> {
+    pub fn image_view(mut self, image_view: ImageView) -> Self {
         self.inner.image_view = image_view;
         self
     }
-    pub fn image_layout(mut self, image_layout: ImageLayout) -> DescriptorImageInfoBuilder<'a> {
+    pub fn image_layout(mut self, image_layout: ImageLayout) -> Self {
         self.inner.image_layout = image_layout;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorImageInfo {
         self.inner
@@ -2586,68 +2497,53 @@ impl<'a> ::std::ops::Deref for WriteDesc
     }
 }
 impl<'a> ::std::ops::DerefMut for WriteDescriptorSetBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> WriteDescriptorSetBuilder<'a> {
-    pub fn dst_set(mut self, dst_set: DescriptorSet) -> WriteDescriptorSetBuilder<'a> {
+    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
         self.inner.dst_set = dst_set;
         self
     }
-    pub fn dst_binding(mut self, dst_binding: u32) -> WriteDescriptorSetBuilder<'a> {
+    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
         self.inner.dst_binding = dst_binding;
         self
     }
-    pub fn dst_array_element(mut self, dst_array_element: u32) -> WriteDescriptorSetBuilder<'a> {
+    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
         self.inner.dst_array_element = dst_array_element;
         self
     }
-    pub fn descriptor_type(
-        mut self,
-        descriptor_type: DescriptorType,
-    ) -> WriteDescriptorSetBuilder<'a> {
+    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
         self.inner.descriptor_type = descriptor_type;
         self
     }
-    pub fn image_info(
-        mut self,
-        image_info: &'a [DescriptorImageInfo],
-    ) -> WriteDescriptorSetBuilder<'a> {
+    pub fn image_info(mut self, image_info: &'a [DescriptorImageInfo]) -> Self {
         self.inner.descriptor_count = image_info.len() as _;
         self.inner.p_image_info = image_info.as_ptr();
         self
     }
-    pub fn buffer_info(
-        mut self,
-        buffer_info: &'a [DescriptorBufferInfo],
-    ) -> WriteDescriptorSetBuilder<'a> {
+    pub fn buffer_info(mut self, buffer_info: &'a [DescriptorBufferInfo]) -> Self {
         self.inner.descriptor_count = buffer_info.len() as _;
         self.inner.p_buffer_info = buffer_info.as_ptr();
         self
     }
-    pub fn texel_buffer_view(
-        mut self,
-        texel_buffer_view: &'a [BufferView],
-    ) -> WriteDescriptorSetBuilder<'a> {
+    pub fn texel_buffer_view(mut self, texel_buffer_view: &'a [BufferView]) -> Self {
         self.inner.descriptor_count = texel_buffer_view.len() as _;
         self.inner.p_texel_buffer_view = texel_buffer_view.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsWriteDescriptorSet>(
-        mut self,
-        next: &'a mut T,
-    ) -> WriteDescriptorSetBuilder<'a> {
+    pub fn push_next<T: ExtendsWriteDescriptorSet>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -2695,74 +2591,56 @@ impl CopyDescriptorSet {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyDescriptorSetBuilder<'a> {
     inner: CopyDescriptorSet,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyDescriptorSet {}
 impl<'a> ::std::ops::Deref for CopyDescriptorSetBuilder<'a> {
     type Target = CopyDescriptorSet;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyDescriptorSetBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyDescriptorSetBuilder<'a> {
-    pub fn src_set(mut self, src_set: DescriptorSet) -> CopyDescriptorSetBuilder<'a> {
+    pub fn src_set(mut self, src_set: DescriptorSet) -> Self {
         self.inner.src_set = src_set;
         self
     }
-    pub fn src_binding(mut self, src_binding: u32) -> CopyDescriptorSetBuilder<'a> {
+    pub fn src_binding(mut self, src_binding: u32) -> Self {
         self.inner.src_binding = src_binding;
         self
     }
-    pub fn src_array_element(mut self, src_array_element: u32) -> CopyDescriptorSetBuilder<'a> {
+    pub fn src_array_element(mut self, src_array_element: u32) -> Self {
         self.inner.src_array_element = src_array_element;
         self
     }
-    pub fn dst_set(mut self, dst_set: DescriptorSet) -> CopyDescriptorSetBuilder<'a> {
+    pub fn dst_set(mut self, dst_set: DescriptorSet) -> Self {
         self.inner.dst_set = dst_set;
         self
     }
-    pub fn dst_binding(mut self, dst_binding: u32) -> CopyDescriptorSetBuilder<'a> {
+    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
         self.inner.dst_binding = dst_binding;
         self
     }
-    pub fn dst_array_element(mut self, dst_array_element: u32) -> CopyDescriptorSetBuilder<'a> {
+    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
         self.inner.dst_array_element = dst_array_element;
         self
     }
-    pub fn descriptor_count(mut self, descriptor_count: u32) -> CopyDescriptorSetBuilder<'a> {
+    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
         self.inner.descriptor_count = descriptor_count;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyDescriptorSet>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyDescriptorSetBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyDescriptorSet {
         self.inner
     }
 }
 #[repr(C)]
@@ -2813,49 +2691,43 @@ impl<'a> ::std::ops::Deref for BufferCre
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: BufferCreateFlags) -> BufferCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn size(mut self, size: DeviceSize) -> BufferCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn usage(mut self, usage: BufferUsageFlags) -> BufferCreateInfoBuilder<'a> {
+    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> BufferCreateInfoBuilder<'a> {
+    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
         self.inner.sharing_mode = sharing_mode;
         self
     }
-    pub fn queue_family_indices(
-        mut self,
-        queue_family_indices: &'a [u32],
-    ) -> BufferCreateInfoBuilder<'a> {
+    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
         self.inner.queue_family_index_count = queue_family_indices.len() as _;
         self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsBufferCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -2899,66 +2771,48 @@ impl BufferViewCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct BufferViewCreateInfoBuilder<'a> {
     inner: BufferViewCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBufferViewCreateInfo {}
 impl<'a> ::std::ops::Deref for BufferViewCreateInfoBuilder<'a> {
     type Target = BufferViewCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferViewCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferViewCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: BufferViewCreateFlags) -> BufferViewCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn buffer(mut self, buffer: Buffer) -> BufferViewCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: BufferViewCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn format(mut self, format: Format) -> BufferViewCreateInfoBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> BufferViewCreateInfoBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn range(mut self, range: DeviceSize) -> BufferViewCreateInfoBuilder<'a> {
+    pub fn range(mut self, range: DeviceSize) -> Self {
         self.inner.range = range;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferViewCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferViewCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferViewCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -2989,25 +2843,25 @@ impl<'a> ::std::ops::Deref for ImageSubr
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageSubresourceBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageSubresourceBuilder<'a> {
-    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
-    pub fn mip_level(mut self, mip_level: u32) -> ImageSubresourceBuilder<'a> {
+    pub fn mip_level(mut self, mip_level: u32) -> Self {
         self.inner.mip_level = mip_level;
         self
     }
-    pub fn array_layer(mut self, array_layer: u32) -> ImageSubresourceBuilder<'a> {
+    pub fn array_layer(mut self, array_layer: u32) -> Self {
         self.inner.array_layer = array_layer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageSubresource {
         self.inner
@@ -3042,32 +2896,29 @@ impl<'a> ::std::ops::Deref for ImageSubr
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageSubresourceLayersBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageSubresourceLayersBuilder<'a> {
-    pub fn aspect_mask(
-        mut self,
-        aspect_mask: ImageAspectFlags,
-    ) -> ImageSubresourceLayersBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
-    pub fn mip_level(mut self, mip_level: u32) -> ImageSubresourceLayersBuilder<'a> {
+    pub fn mip_level(mut self, mip_level: u32) -> Self {
         self.inner.mip_level = mip_level;
         self
     }
-    pub fn base_array_layer(mut self, base_array_layer: u32) -> ImageSubresourceLayersBuilder<'a> {
+    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
         self.inner.base_array_layer = base_array_layer;
         self
     }
-    pub fn layer_count(mut self, layer_count: u32) -> ImageSubresourceLayersBuilder<'a> {
+    pub fn layer_count(mut self, layer_count: u32) -> Self {
         self.inner.layer_count = layer_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageSubresourceLayers {
         self.inner
@@ -3103,36 +2954,33 @@ impl<'a> ::std::ops::Deref for ImageSubr
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageSubresourceRangeBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageSubresourceRangeBuilder<'a> {
-    pub fn aspect_mask(
-        mut self,
-        aspect_mask: ImageAspectFlags,
-    ) -> ImageSubresourceRangeBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
-    pub fn base_mip_level(mut self, base_mip_level: u32) -> ImageSubresourceRangeBuilder<'a> {
+    pub fn base_mip_level(mut self, base_mip_level: u32) -> Self {
         self.inner.base_mip_level = base_mip_level;
         self
     }
-    pub fn level_count(mut self, level_count: u32) -> ImageSubresourceRangeBuilder<'a> {
+    pub fn level_count(mut self, level_count: u32) -> Self {
         self.inner.level_count = level_count;
         self
     }
-    pub fn base_array_layer(mut self, base_array_layer: u32) -> ImageSubresourceRangeBuilder<'a> {
+    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
         self.inner.base_array_layer = base_array_layer;
         self
     }
-    pub fn layer_count(mut self, layer_count: u32) -> ImageSubresourceRangeBuilder<'a> {
+    pub fn layer_count(mut self, layer_count: u32) -> Self {
         self.inner.layer_count = layer_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageSubresourceRange {
         self.inner
@@ -3165,54 +3013,36 @@ impl MemoryBarrier {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryBarrierBuilder<'a> {
     inner: MemoryBarrier,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryBarrier {}
 impl<'a> ::std::ops::Deref for MemoryBarrierBuilder<'a> {
     type Target = MemoryBarrier;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryBarrierBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryBarrierBuilder<'a> {
-    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> MemoryBarrierBuilder<'a> {
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
         self.inner.src_access_mask = src_access_mask;
         self
     }
-    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> MemoryBarrierBuilder<'a> {
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
         self.inner.dst_access_mask = dst_access_mask;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryBarrier>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryBarrierBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryBarrier {
         self.inner
     }
 }
 #[repr(C)]
@@ -3252,86 +3082,56 @@ impl BufferMemoryBarrier {
         }
     }
 }
 #[repr(transparent)]
 pub struct BufferMemoryBarrierBuilder<'a> {
     inner: BufferMemoryBarrier,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBufferMemoryBarrier {}
 impl<'a> ::std::ops::Deref for BufferMemoryBarrierBuilder<'a> {
     type Target = BufferMemoryBarrier;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferMemoryBarrierBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferMemoryBarrierBuilder<'a> {
-    pub fn src_access_mask(
-        mut self,
-        src_access_mask: AccessFlags,
-    ) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
         self.inner.src_access_mask = src_access_mask;
         self
     }
-    pub fn dst_access_mask(
-        mut self,
-        dst_access_mask: AccessFlags,
-    ) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
         self.inner.dst_access_mask = dst_access_mask;
         self
     }
-    pub fn src_queue_family_index(
-        mut self,
-        src_queue_family_index: u32,
-    ) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
         self.inner.src_queue_family_index = src_queue_family_index;
         self
     }
-    pub fn dst_queue_family_index(
-        mut self,
-        dst_queue_family_index: u32,
-    ) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
         self.inner.dst_queue_family_index = dst_queue_family_index;
         self
     }
-    pub fn buffer(mut self, buffer: Buffer) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> BufferMemoryBarrierBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferMemoryBarrier>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferMemoryBarrierBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferMemoryBarrier {
         self.inner
     }
 }
 #[repr(C)]
@@ -3386,72 +3186,54 @@ impl<'a> ::std::ops::Deref for ImageMemo
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageMemoryBarrierBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageMemoryBarrierBuilder<'a> {
-    pub fn src_access_mask(
-        mut self,
-        src_access_mask: AccessFlags,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
         self.inner.src_access_mask = src_access_mask;
         self
     }
-    pub fn dst_access_mask(
-        mut self,
-        dst_access_mask: AccessFlags,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
         self.inner.dst_access_mask = dst_access_mask;
         self
     }
-    pub fn old_layout(mut self, old_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
         self.inner.old_layout = old_layout;
         self
     }
-    pub fn new_layout(mut self, new_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
         self.inner.new_layout = new_layout;
         self
     }
-    pub fn src_queue_family_index(
-        mut self,
-        src_queue_family_index: u32,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
         self.inner.src_queue_family_index = src_queue_family_index;
         self
     }
-    pub fn dst_queue_family_index(
-        mut self,
-        dst_queue_family_index: u32,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
         self.inner.dst_queue_family_index = dst_queue_family_index;
         self
     }
-    pub fn image(mut self, image: Image) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn subresource_range(
-        mut self,
-        subresource_range: ImageSubresourceRange,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
         self.inner.subresource_range = subresource_range;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageMemoryBarrier>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageMemoryBarrierBuilder<'a> {
+    pub fn push_next<T: ExtendsImageMemoryBarrier>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -3524,77 +3306,71 @@ impl<'a> ::std::ops::Deref for ImageCrea
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: ImageCreateFlags) -> ImageCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn image_type(mut self, image_type: ImageType) -> ImageCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn image_type(mut self, image_type: ImageType) -> Self {
         self.inner.image_type = image_type;
         self
     }
-    pub fn format(mut self, format: Format) -> ImageCreateInfoBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> ImageCreateInfoBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
-    pub fn mip_levels(mut self, mip_levels: u32) -> ImageCreateInfoBuilder<'a> {
+    pub fn mip_levels(mut self, mip_levels: u32) -> Self {
         self.inner.mip_levels = mip_levels;
         self
     }
-    pub fn array_layers(mut self, array_layers: u32) -> ImageCreateInfoBuilder<'a> {
+    pub fn array_layers(mut self, array_layers: u32) -> Self {
         self.inner.array_layers = array_layers;
         self
     }
-    pub fn samples(mut self, samples: SampleCountFlags) -> ImageCreateInfoBuilder<'a> {
+    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
         self.inner.samples = samples;
         self
     }
-    pub fn tiling(mut self, tiling: ImageTiling) -> ImageCreateInfoBuilder<'a> {
+    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
         self.inner.tiling = tiling;
         self
     }
-    pub fn usage(mut self, usage: ImageUsageFlags) -> ImageCreateInfoBuilder<'a> {
+    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> ImageCreateInfoBuilder<'a> {
+    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
         self.inner.sharing_mode = sharing_mode;
         self
     }
-    pub fn queue_family_indices(
-        mut self,
-        queue_family_indices: &'a [u32],
-    ) -> ImageCreateInfoBuilder<'a> {
+    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
         self.inner.queue_family_index_count = queue_family_indices.len() as _;
         self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
         self
     }
-    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> ImageCreateInfoBuilder<'a> {
+    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
         self.inner.initial_layout = initial_layout;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsImageCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -3635,33 +3411,33 @@ impl<'a> ::std::ops::Deref for Subresour
     }
 }
 impl<'a> ::std::ops::DerefMut for SubresourceLayoutBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubresourceLayoutBuilder<'a> {
-    pub fn offset(mut self, offset: DeviceSize) -> SubresourceLayoutBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> SubresourceLayoutBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn row_pitch(mut self, row_pitch: DeviceSize) -> SubresourceLayoutBuilder<'a> {
+    pub fn row_pitch(mut self, row_pitch: DeviceSize) -> Self {
         self.inner.row_pitch = row_pitch;
         self
     }
-    pub fn array_pitch(mut self, array_pitch: DeviceSize) -> SubresourceLayoutBuilder<'a> {
+    pub fn array_pitch(mut self, array_pitch: DeviceSize) -> Self {
         self.inner.array_pitch = array_pitch;
         self
     }
-    pub fn depth_pitch(mut self, depth_pitch: DeviceSize) -> SubresourceLayoutBuilder<'a> {
+    pub fn depth_pitch(mut self, depth_pitch: DeviceSize) -> Self {
         self.inner.depth_pitch = depth_pitch;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubresourceLayout {
         self.inner
@@ -3715,52 +3491,46 @@ impl<'a> ::std::ops::Deref for ImageView
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageViewCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageViewCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: ImageViewCreateFlags) -> ImageViewCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn image(mut self, image: Image) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: ImageViewCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn view_type(mut self, view_type: ImageViewType) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn view_type(mut self, view_type: ImageViewType) -> Self {
         self.inner.view_type = view_type;
         self
     }
-    pub fn format(mut self, format: Format) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn components(mut self, components: ComponentMapping) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn components(mut self, components: ComponentMapping) -> Self {
         self.inner.components = components;
         self
     }
-    pub fn subresource_range(
-        mut self,
-        subresource_range: ImageSubresourceRange,
-    ) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
         self.inner.subresource_range = subresource_range;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageViewCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageViewCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsImageViewCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -3799,25 +3569,25 @@ impl<'a> ::std::ops::Deref for BufferCop
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferCopyBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferCopyBuilder<'a> {
-    pub fn src_offset(mut self, src_offset: DeviceSize) -> BufferCopyBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> BufferCopyBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> BufferCopyBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferCopy {
         self.inner
@@ -3853,33 +3623,33 @@ impl<'a> ::std::ops::Deref for SparseMem
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseMemoryBindBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseMemoryBindBuilder<'a> {
-    pub fn resource_offset(mut self, resource_offset: DeviceSize) -> SparseMemoryBindBuilder<'a> {
+    pub fn resource_offset(mut self, resource_offset: DeviceSize) -> Self {
         self.inner.resource_offset = resource_offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> SparseMemoryBindBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn memory(mut self, memory: DeviceMemory) -> SparseMemoryBindBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> SparseMemoryBindBuilder<'a> {
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
         self.inner.memory_offset = memory_offset;
         self
     }
-    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> SparseMemoryBindBuilder<'a> {
+    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseMemoryBind {
         self.inner
@@ -3916,40 +3686,37 @@ impl<'a> ::std::ops::Deref for SparseIma
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageMemoryBindBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageMemoryBindBuilder<'a> {
-    pub fn subresource(
-        mut self,
-        subresource: ImageSubresource,
-    ) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn subresource(mut self, subresource: ImageSubresource) -> Self {
         self.inner.subresource = subresource;
         self
     }
-    pub fn offset(mut self, offset: Offset3D) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn offset(mut self, offset: Offset3D) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
-    pub fn memory(mut self, memory: DeviceMemory) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
         self.inner.memory_offset = memory_offset;
         self
     }
-    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> SparseImageMemoryBindBuilder<'a> {
+    pub fn flags(mut self, flags: SparseMemoryBindFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageMemoryBind {
         self.inner
@@ -3992,21 +3759,21 @@ impl<'a> ::std::ops::Deref for SparseBuf
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseBufferMemoryBindInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseBufferMemoryBindInfoBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> SparseBufferMemoryBindInfoBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> SparseBufferMemoryBindInfoBuilder<'a> {
+    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
         self.inner.bind_count = binds.len() as _;
         self.inner.p_binds = binds.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseBufferMemoryBindInfo {
@@ -4050,24 +3817,21 @@ impl<'a> ::std::ops::Deref for SparseIma
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageOpaqueMemoryBindInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
-    pub fn image(mut self, image: Image) -> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn binds(
-        mut self,
-        binds: &'a [SparseMemoryBind],
-    ) -> SparseImageOpaqueMemoryBindInfoBuilder<'a> {
+    pub fn binds(mut self, binds: &'a [SparseMemoryBind]) -> Self {
         self.inner.bind_count = binds.len() as _;
         self.inner.p_binds = binds.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageOpaqueMemoryBindInfo {
@@ -4111,24 +3875,21 @@ impl<'a> ::std::ops::Deref for SparseIma
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageMemoryBindInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageMemoryBindInfoBuilder<'a> {
-    pub fn image(mut self, image: Image) -> SparseImageMemoryBindInfoBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn binds(
-        mut self,
-        binds: &'a [SparseImageMemoryBind],
-    ) -> SparseImageMemoryBindInfoBuilder<'a> {
+    pub fn binds(mut self, binds: &'a [SparseImageMemoryBind]) -> Self {
         self.inner.bind_count = binds.len() as _;
         self.inner.p_binds = binds.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageMemoryBindInfo {
@@ -4191,65 +3952,50 @@ impl<'a> ::std::ops::Deref for BindSpars
     }
 }
 impl<'a> ::std::ops::DerefMut for BindSparseInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindSparseInfoBuilder<'a> {
-    pub fn wait_semaphores(
-        mut self,
-        wait_semaphores: &'a [Semaphore],
-    ) -> BindSparseInfoBuilder<'a> {
+    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
         self.inner.wait_semaphore_count = wait_semaphores.len() as _;
         self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
         self
     }
-    pub fn buffer_binds(
-        mut self,
-        buffer_binds: &'a [SparseBufferMemoryBindInfo],
-    ) -> BindSparseInfoBuilder<'a> {
+    pub fn buffer_binds(mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo]) -> Self {
         self.inner.buffer_bind_count = buffer_binds.len() as _;
         self.inner.p_buffer_binds = buffer_binds.as_ptr();
         self
     }
     pub fn image_opaque_binds(
         mut self,
         image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo],
-    ) -> BindSparseInfoBuilder<'a> {
+    ) -> Self {
         self.inner.image_opaque_bind_count = image_opaque_binds.len() as _;
         self.inner.p_image_opaque_binds = image_opaque_binds.as_ptr();
         self
     }
-    pub fn image_binds(
-        mut self,
-        image_binds: &'a [SparseImageMemoryBindInfo],
-    ) -> BindSparseInfoBuilder<'a> {
+    pub fn image_binds(mut self, image_binds: &'a [SparseImageMemoryBindInfo]) -> Self {
         self.inner.image_bind_count = image_binds.len() as _;
         self.inner.p_image_binds = image_binds.as_ptr();
         self
     }
-    pub fn signal_semaphores(
-        mut self,
-        signal_semaphores: &'a [Semaphore],
-    ) -> BindSparseInfoBuilder<'a> {
+    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
         self.inner.signal_semaphore_count = signal_semaphores.len() as _;
         self.inner.p_signal_semaphores = signal_semaphores.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBindSparseInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BindSparseInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsBindSparseInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -4290,39 +4036,33 @@ impl<'a> ::std::ops::Deref for ImageCopy
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageCopyBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageCopyBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageCopyBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offset(mut self, src_offset: Offset3D) -> ImageCopyBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageCopyBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: Offset3D) -> ImageCopyBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> ImageCopyBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageCopy {
         self.inner
@@ -4367,35 +4107,29 @@ impl<'a> ::std::ops::Deref for ImageBlit
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageBlitBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageBlitBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageBlitBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> ImageBlitBuilder<'a> {
+    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
         self.inner.src_offsets = src_offsets;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageBlitBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> ImageBlitBuilder<'a> {
+    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
         self.inner.dst_offsets = dst_offsets;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageBlit {
         self.inner
@@ -4432,40 +4166,37 @@ impl<'a> ::std::ops::Deref for BufferIma
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferImageCopyBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferImageCopyBuilder<'a> {
-    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> BufferImageCopyBuilder<'a> {
+    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
         self.inner.buffer_offset = buffer_offset;
         self
     }
-    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> BufferImageCopyBuilder<'a> {
+    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
         self.inner.buffer_row_length = buffer_row_length;
         self
     }
-    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> BufferImageCopyBuilder<'a> {
+    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
         self.inner.buffer_image_height = buffer_image_height;
         self
     }
-    pub fn image_subresource(
-        mut self,
-        image_subresource: ImageSubresourceLayers,
-    ) -> BufferImageCopyBuilder<'a> {
+    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
         self.inner.image_subresource = image_subresource;
         self
     }
-    pub fn image_offset(mut self, image_offset: Offset3D) -> BufferImageCopyBuilder<'a> {
+    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
         self.inner.image_offset = image_offset;
         self
     }
-    pub fn image_extent(mut self, image_extent: Extent3D) -> BufferImageCopyBuilder<'a> {
+    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
         self.inner.image_extent = image_extent;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferImageCopy {
         self.inner
@@ -4501,39 +4232,33 @@ impl<'a> ::std::ops::Deref for ImageReso
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageResolveBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageResolveBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageResolveBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offset(mut self, src_offset: Offset3D) -> ImageResolveBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageResolveBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: Offset3D) -> ImageResolveBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> ImageResolveBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageResolve {
         self.inner
@@ -4581,34 +4306,31 @@ impl<'a> ::std::ops::Deref for ShaderMod
     }
 }
 impl<'a> ::std::ops::DerefMut for ShaderModuleCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ShaderModuleCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: ShaderModuleCreateFlags) -> ShaderModuleCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn code(mut self, code: &'a [u32]) -> ShaderModuleCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: ShaderModuleCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn code(mut self, code: &'a [u32]) -> Self {
         self.inner.code_size = code.len() * 4;
         self.inner.p_code = code.as_ptr() as *const u32;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsShaderModuleCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> ShaderModuleCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsShaderModuleCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -4660,45 +4382,33 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutBindingBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetLayoutBindingBuilder<'a> {
-    pub fn binding(mut self, binding: u32) -> DescriptorSetLayoutBindingBuilder<'a> {
+    pub fn binding(mut self, binding: u32) -> Self {
         self.inner.binding = binding;
         self
     }
-    pub fn descriptor_type(
-        mut self,
-        descriptor_type: DescriptorType,
-    ) -> DescriptorSetLayoutBindingBuilder<'a> {
+    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
         self.inner.descriptor_type = descriptor_type;
         self
     }
-    pub fn descriptor_count(
-        mut self,
-        descriptor_count: u32,
-    ) -> DescriptorSetLayoutBindingBuilder<'a> {
+    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
         self.inner.descriptor_count = descriptor_count;
         self
     }
-    pub fn stage_flags(
-        mut self,
-        stage_flags: ShaderStageFlags,
-    ) -> DescriptorSetLayoutBindingBuilder<'a> {
+    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
         self.inner.stage_flags = stage_flags;
         self
     }
-    pub fn immutable_samplers(
-        mut self,
-        immutable_samplers: &'a [Sampler],
-    ) -> DescriptorSetLayoutBindingBuilder<'a> {
+    pub fn immutable_samplers(mut self, immutable_samplers: &'a [Sampler]) -> Self {
         self.inner.descriptor_count = immutable_samplers.len() as _;
         self.inner.p_immutable_samplers = immutable_samplers.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorSetLayoutBinding {
@@ -4747,40 +4457,31 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetLayoutCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DescriptorSetLayoutCreateFlags,
-    ) -> DescriptorSetLayoutCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn bindings(
-        mut self,
-        bindings: &'a [DescriptorSetLayoutBinding],
-    ) -> DescriptorSetLayoutCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: DescriptorSetLayoutCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn bindings(mut self, bindings: &'a [DescriptorSetLayoutBinding]) -> Self {
         self.inner.binding_count = bindings.len() as _;
         self.inner.p_bindings = bindings.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDescriptorSetLayoutCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DescriptorSetLayoutCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsDescriptorSetLayoutCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -4818,21 +4519,21 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorPoolSizeBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorPoolSizeBuilder<'a> {
-    pub fn ty(mut self, ty: DescriptorType) -> DescriptorPoolSizeBuilder<'a> {
+    pub fn ty(mut self, ty: DescriptorType) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn descriptor_count(mut self, descriptor_count: u32) -> DescriptorPoolSizeBuilder<'a> {
+    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
         self.inner.descriptor_count = descriptor_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorPoolSize {
         self.inner
@@ -4882,44 +4583,35 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorPoolCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorPoolCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DescriptorPoolCreateFlags,
-    ) -> DescriptorPoolCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn max_sets(mut self, max_sets: u32) -> DescriptorPoolCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: DescriptorPoolCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn max_sets(mut self, max_sets: u32) -> Self {
         self.inner.max_sets = max_sets;
         self
     }
-    pub fn pool_sizes(
-        mut self,
-        pool_sizes: &'a [DescriptorPoolSize],
-    ) -> DescriptorPoolCreateInfoBuilder<'a> {
+    pub fn pool_sizes(mut self, pool_sizes: &'a [DescriptorPoolSize]) -> Self {
         self.inner.pool_size_count = pool_sizes.len() as _;
         self.inner.p_pool_sizes = pool_sizes.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDescriptorPoolCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DescriptorPoolCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsDescriptorPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -4972,40 +4664,31 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetAllocateInfoBuilder<'a> {
-    pub fn descriptor_pool(
-        mut self,
-        descriptor_pool: DescriptorPool,
-    ) -> DescriptorSetAllocateInfoBuilder<'a> {
+    pub fn descriptor_pool(mut self, descriptor_pool: DescriptorPool) -> Self {
         self.inner.descriptor_pool = descriptor_pool;
         self
     }
-    pub fn set_layouts(
-        mut self,
-        set_layouts: &'a [DescriptorSetLayout],
-    ) -> DescriptorSetAllocateInfoBuilder<'a> {
+    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
         self.inner.descriptor_set_count = set_layouts.len() as _;
         self.inner.p_set_layouts = set_layouts.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDescriptorSetAllocateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DescriptorSetAllocateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsDescriptorSetAllocateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5044,25 +4727,25 @@ impl<'a> ::std::ops::Deref for Specializ
     }
 }
 impl<'a> ::std::ops::DerefMut for SpecializationMapEntryBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SpecializationMapEntryBuilder<'a> {
-    pub fn constant_id(mut self, constant_id: u32) -> SpecializationMapEntryBuilder<'a> {
+    pub fn constant_id(mut self, constant_id: u32) -> Self {
         self.inner.constant_id = constant_id;
         self
     }
-    pub fn offset(mut self, offset: u32) -> SpecializationMapEntryBuilder<'a> {
+    pub fn offset(mut self, offset: u32) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: usize) -> SpecializationMapEntryBuilder<'a> {
+    pub fn size(mut self, size: usize) -> Self {
         self.inner.size = size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SpecializationMapEntry {
         self.inner
@@ -5107,25 +4790,22 @@ impl<'a> ::std::ops::Deref for Specializ
     }
 }
 impl<'a> ::std::ops::DerefMut for SpecializationInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SpecializationInfoBuilder<'a> {
-    pub fn map_entries(
-        mut self,
-        map_entries: &'a [SpecializationMapEntry],
-    ) -> SpecializationInfoBuilder<'a> {
+    pub fn map_entries(mut self, map_entries: &'a [SpecializationMapEntry]) -> Self {
         self.inner.map_entry_count = map_entries.len() as _;
         self.inner.p_map_entries = map_entries.as_ptr();
         self
     }
-    pub fn data(mut self, data: &'a [u8]) -> SpecializationInfoBuilder<'a> {
+    pub fn data(mut self, data: &'a [u8]) -> Self {
         self.inner.data_size = data.len() as _;
         self.inner.p_data = data.as_ptr() as *const c_void;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SpecializationInfo {
@@ -5178,51 +4858,42 @@ impl<'a> ::std::ops::Deref for PipelineS
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineShaderStageCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineShaderStageCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineShaderStageCreateFlags,
-    ) -> PipelineShaderStageCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stage(mut self, stage: ShaderStageFlags) -> PipelineShaderStageCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineShaderStageCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stage(mut self, stage: ShaderStageFlags) -> Self {
         self.inner.stage = stage;
         self
     }
-    pub fn module(mut self, module: ShaderModule) -> PipelineShaderStageCreateInfoBuilder<'a> {
+    pub fn module(mut self, module: ShaderModule) -> Self {
         self.inner.module = module;
         self
     }
-    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> PipelineShaderStageCreateInfoBuilder<'a> {
+    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_name = name.as_ptr();
         self
     }
-    pub fn specialization_info(
-        mut self,
-        specialization_info: &'a SpecializationInfo,
-    ) -> PipelineShaderStageCreateInfoBuilder<'a> {
+    pub fn specialization_info(mut self, specialization_info: &'a SpecializationInfo) -> Self {
         self.inner.p_specialization_info = specialization_info;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineShaderStageCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineShaderStageCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsPipelineShaderStageCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5279,54 +4950,42 @@ impl<'a> ::std::ops::Deref for ComputePi
     }
 }
 impl<'a> ::std::ops::DerefMut for ComputePipelineCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ComputePipelineCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: PipelineCreateFlags) -> ComputePipelineCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stage(
-        mut self,
-        stage: PipelineShaderStageCreateInfo,
-    ) -> ComputePipelineCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stage(mut self, stage: PipelineShaderStageCreateInfo) -> Self {
         self.inner.stage = stage;
         self
     }
-    pub fn layout(mut self, layout: PipelineLayout) -> ComputePipelineCreateInfoBuilder<'a> {
+    pub fn layout(mut self, layout: PipelineLayout) -> Self {
         self.inner.layout = layout;
         self
     }
-    pub fn base_pipeline_handle(
-        mut self,
-        base_pipeline_handle: Pipeline,
-    ) -> ComputePipelineCreateInfoBuilder<'a> {
+    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
         self.inner.base_pipeline_handle = base_pipeline_handle;
         self
     }
-    pub fn base_pipeline_index(
-        mut self,
-        base_pipeline_index: i32,
-    ) -> ComputePipelineCreateInfoBuilder<'a> {
+    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
         self.inner.base_pipeline_index = base_pipeline_index;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsComputePipelineCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> ComputePipelineCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsComputePipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5365,28 +5024,25 @@ impl<'a> ::std::ops::Deref for VertexInp
     }
 }
 impl<'a> ::std::ops::DerefMut for VertexInputBindingDescriptionBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> VertexInputBindingDescriptionBuilder<'a> {
-    pub fn binding(mut self, binding: u32) -> VertexInputBindingDescriptionBuilder<'a> {
+    pub fn binding(mut self, binding: u32) -> Self {
         self.inner.binding = binding;
         self
     }
-    pub fn stride(mut self, stride: u32) -> VertexInputBindingDescriptionBuilder<'a> {
+    pub fn stride(mut self, stride: u32) -> Self {
         self.inner.stride = stride;
         self
     }
-    pub fn input_rate(
-        mut self,
-        input_rate: VertexInputRate,
-    ) -> VertexInputBindingDescriptionBuilder<'a> {
+    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
         self.inner.input_rate = input_rate;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> VertexInputBindingDescription {
         self.inner
@@ -5421,29 +5077,29 @@ impl<'a> ::std::ops::Deref for VertexInp
     }
 }
 impl<'a> ::std::ops::DerefMut for VertexInputAttributeDescriptionBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> VertexInputAttributeDescriptionBuilder<'a> {
-    pub fn location(mut self, location: u32) -> VertexInputAttributeDescriptionBuilder<'a> {
+    pub fn location(mut self, location: u32) -> Self {
         self.inner.location = location;
         self
     }
-    pub fn binding(mut self, binding: u32) -> VertexInputAttributeDescriptionBuilder<'a> {
+    pub fn binding(mut self, binding: u32) -> Self {
         self.inner.binding = binding;
         self
     }
-    pub fn format(mut self, format: Format) -> VertexInputAttributeDescriptionBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn offset(mut self, offset: u32) -> VertexInputAttributeDescriptionBuilder<'a> {
+    pub fn offset(mut self, offset: u32) -> Self {
         self.inner.offset = offset;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> VertexInputAttributeDescription {
         self.inner
@@ -5495,48 +5151,45 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineVertexInputStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineVertexInputStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineVertexInputStateCreateFlags,
-    ) -> PipelineVertexInputStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineVertexInputStateCreateFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn vertex_binding_descriptions(
         mut self,
         vertex_binding_descriptions: &'a [VertexInputBindingDescription],
-    ) -> PipelineVertexInputStateCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_binding_description_count = vertex_binding_descriptions.len() as _;
         self.inner.p_vertex_binding_descriptions = vertex_binding_descriptions.as_ptr();
         self
     }
     pub fn vertex_attribute_descriptions(
         mut self,
         vertex_attribute_descriptions: &'a [VertexInputAttributeDescription],
-    ) -> PipelineVertexInputStateCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_attribute_description_count = vertex_attribute_descriptions.len() as _;
         self.inner.p_vertex_attribute_descriptions = vertex_attribute_descriptions.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPipelineVertexInputStateCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PipelineVertexInputStateCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5576,67 +5229,40 @@ impl PipelineInputAssemblyStateCreateInf
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineInputAssemblyStateCreateInfoBuilder<'a> {
     inner: PipelineInputAssemblyStateCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineInputAssemblyStateCreateInfo {}
 impl<'a> ::std::ops::Deref for PipelineInputAssemblyStateCreateInfoBuilder<'a> {
     type Target = PipelineInputAssemblyStateCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineInputAssemblyStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineInputAssemblyStateCreateFlags,
-    ) -> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn topology(
-        mut self,
-        topology: PrimitiveTopology,
-    ) -> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn topology(mut self, topology: PrimitiveTopology) -> Self {
         self.inner.topology = topology;
         self
     }
-    pub fn primitive_restart_enable(
-        mut self,
-        primitive_restart_enable: bool,
-    ) -> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
+    pub fn primitive_restart_enable(mut self, primitive_restart_enable: bool) -> Self {
         self.inner.primitive_restart_enable = primitive_restart_enable.into();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineInputAssemblyStateCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineInputAssemblyStateCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineInputAssemblyStateCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -5679,39 +5305,33 @@ impl<'a> ::std::ops::Deref for PipelineT
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineTessellationStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineTessellationStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineTessellationStateCreateFlags,
-    ) -> PipelineTessellationStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn patch_control_points(
-        mut self,
-        patch_control_points: u32,
-    ) -> PipelineTessellationStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineTessellationStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn patch_control_points(mut self, patch_control_points: u32) -> Self {
         self.inner.patch_control_points = patch_control_points;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPipelineTessellationStateCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PipelineTessellationStateCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5768,62 +5388,44 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineViewportStateCreateFlags,
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn viewport_count(
-        mut self,
-        viewport_count: u32,
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineViewportStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn viewport_count(mut self, viewport_count: u32) -> Self {
         self.inner.viewport_count = viewport_count;
         self
     }
-    pub fn viewports(
-        mut self,
-        viewports: &'a [Viewport],
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
+    pub fn viewports(mut self, viewports: &'a [Viewport]) -> Self {
         self.inner.viewport_count = viewports.len() as _;
         self.inner.p_viewports = viewports.as_ptr();
         self
     }
-    pub fn scissor_count(
-        mut self,
-        scissor_count: u32,
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
+    pub fn scissor_count(mut self, scissor_count: u32) -> Self {
         self.inner.scissor_count = scissor_count;
         self
     }
-    pub fn scissors(
-        mut self,
-        scissors: &'a [Rect2D],
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
+    pub fn scissors(mut self, scissors: &'a [Rect2D]) -> Self {
         self.inner.scissor_count = scissors.len() as _;
         self.inner.p_scissors = scissors.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineViewportStateCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineViewportStateCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsPipelineViewportStateCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -5892,102 +5494,69 @@ impl<'a> ::std::ops::Deref for PipelineR
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineRasterizationStateCreateFlags,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn depth_clamp_enable(
-        mut self,
-        depth_clamp_enable: bool,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineRasterizationStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn depth_clamp_enable(mut self, depth_clamp_enable: bool) -> Self {
         self.inner.depth_clamp_enable = depth_clamp_enable.into();
         self
     }
-    pub fn rasterizer_discard_enable(
-        mut self,
-        rasterizer_discard_enable: bool,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn rasterizer_discard_enable(mut self, rasterizer_discard_enable: bool) -> Self {
         self.inner.rasterizer_discard_enable = rasterizer_discard_enable.into();
         self
     }
-    pub fn polygon_mode(
-        mut self,
-        polygon_mode: PolygonMode,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn polygon_mode(mut self, polygon_mode: PolygonMode) -> Self {
         self.inner.polygon_mode = polygon_mode;
         self
     }
-    pub fn cull_mode(
-        mut self,
-        cull_mode: CullModeFlags,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn cull_mode(mut self, cull_mode: CullModeFlags) -> Self {
         self.inner.cull_mode = cull_mode;
         self
     }
-    pub fn front_face(
-        mut self,
-        front_face: FrontFace,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn front_face(mut self, front_face: FrontFace) -> Self {
         self.inner.front_face = front_face;
         self
     }
-    pub fn depth_bias_enable(
-        mut self,
-        depth_bias_enable: bool,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn depth_bias_enable(mut self, depth_bias_enable: bool) -> Self {
         self.inner.depth_bias_enable = depth_bias_enable.into();
         self
     }
-    pub fn depth_bias_constant_factor(
-        mut self,
-        depth_bias_constant_factor: f32,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn depth_bias_constant_factor(mut self, depth_bias_constant_factor: f32) -> Self {
         self.inner.depth_bias_constant_factor = depth_bias_constant_factor;
         self
     }
-    pub fn depth_bias_clamp(
-        mut self,
-        depth_bias_clamp: f32,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn depth_bias_clamp(mut self, depth_bias_clamp: f32) -> Self {
         self.inner.depth_bias_clamp = depth_bias_clamp;
         self
     }
-    pub fn depth_bias_slope_factor(
-        mut self,
-        depth_bias_slope_factor: f32,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn depth_bias_slope_factor(mut self, depth_bias_slope_factor: f32) -> Self {
         self.inner.depth_bias_slope_factor = depth_bias_slope_factor;
         self
     }
-    pub fn line_width(
-        mut self,
-        line_width: f32,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    pub fn line_width(mut self, line_width: f32) -> Self {
         self.inner.line_width = line_width;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPipelineRasterizationStateCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PipelineRasterizationStateCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -6048,74 +5617,62 @@ impl<'a> ::std::ops::Deref for PipelineM
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineMultisampleStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineMultisampleStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineMultisampleStateCreateFlags,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn rasterization_samples(
-        mut self,
-        rasterization_samples: SampleCountFlags,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineMultisampleStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
         self.inner.rasterization_samples = rasterization_samples;
         self
     }
-    pub fn sample_shading_enable(
-        mut self,
-        sample_shading_enable: bool,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    pub fn sample_shading_enable(mut self, sample_shading_enable: bool) -> Self {
         self.inner.sample_shading_enable = sample_shading_enable.into();
         self
     }
-    pub fn min_sample_shading(
-        mut self,
-        min_sample_shading: f32,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    pub fn min_sample_shading(mut self, min_sample_shading: f32) -> Self {
         self.inner.min_sample_shading = min_sample_shading;
         self
     }
-    pub fn sample_mask(
-        mut self,
-        sample_mask: &'a [SampleMask],
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
-        self.inner.p_sample_mask = sample_mask.as_ptr() as *const SampleMask;
-        self
-    }
-    pub fn alpha_to_coverage_enable(
-        mut self,
-        alpha_to_coverage_enable: bool,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    #[doc = r" Sets `p_sample_mask` to `null` if the slice is empty. The mask will"]
+    #[doc = r" be treated as if it has all bits set to `1`."]
+    #[doc = r""]
+    #[doc = r" See <https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineMultisampleStateCreateInfo.html#_description>"]
+    #[doc = r" for more details."]
+    pub fn sample_mask(mut self, sample_mask: &'a [SampleMask]) -> Self {
+        self.inner.p_sample_mask = if sample_mask.is_empty() {
+            std::ptr::null()
+        } else {
+            sample_mask.as_ptr() as *const SampleMask
+        };
+        self
+    }
+    pub fn alpha_to_coverage_enable(mut self, alpha_to_coverage_enable: bool) -> Self {
         self.inner.alpha_to_coverage_enable = alpha_to_coverage_enable.into();
         self
     }
-    pub fn alpha_to_one_enable(
-        mut self,
-        alpha_to_one_enable: bool,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    pub fn alpha_to_one_enable(mut self, alpha_to_one_enable: bool) -> Self {
         self.inner.alpha_to_one_enable = alpha_to_one_enable.into();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPipelineMultisampleStateCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PipelineMultisampleStateCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -6159,69 +5716,45 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineColorBlendAttachmentStateBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineColorBlendAttachmentStateBuilder<'a> {
-    pub fn blend_enable(
-        mut self,
-        blend_enable: bool,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn blend_enable(mut self, blend_enable: bool) -> Self {
         self.inner.blend_enable = blend_enable.into();
         self
     }
-    pub fn src_color_blend_factor(
-        mut self,
-        src_color_blend_factor: BlendFactor,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn src_color_blend_factor(mut self, src_color_blend_factor: BlendFactor) -> Self {
         self.inner.src_color_blend_factor = src_color_blend_factor;
         self
     }
-    pub fn dst_color_blend_factor(
-        mut self,
-        dst_color_blend_factor: BlendFactor,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn dst_color_blend_factor(mut self, dst_color_blend_factor: BlendFactor) -> Self {
         self.inner.dst_color_blend_factor = dst_color_blend_factor;
         self
     }
-    pub fn color_blend_op(
-        mut self,
-        color_blend_op: BlendOp,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn color_blend_op(mut self, color_blend_op: BlendOp) -> Self {
         self.inner.color_blend_op = color_blend_op;
         self
     }
-    pub fn src_alpha_blend_factor(
-        mut self,
-        src_alpha_blend_factor: BlendFactor,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn src_alpha_blend_factor(mut self, src_alpha_blend_factor: BlendFactor) -> Self {
         self.inner.src_alpha_blend_factor = src_alpha_blend_factor;
         self
     }
-    pub fn dst_alpha_blend_factor(
-        mut self,
-        dst_alpha_blend_factor: BlendFactor,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn dst_alpha_blend_factor(mut self, dst_alpha_blend_factor: BlendFactor) -> Self {
         self.inner.dst_alpha_blend_factor = dst_alpha_blend_factor;
         self
     }
-    pub fn alpha_blend_op(
-        mut self,
-        alpha_blend_op: BlendOp,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn alpha_blend_op(mut self, alpha_blend_op: BlendOp) -> Self {
         self.inner.alpha_blend_op = alpha_blend_op;
         self
     }
-    pub fn color_write_mask(
-        mut self,
-        color_write_mask: ColorComponentFlags,
-    ) -> PipelineColorBlendAttachmentStateBuilder<'a> {
+    pub fn color_write_mask(mut self, color_write_mask: ColorComponentFlags) -> Self {
         self.inner.color_write_mask = color_write_mask;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineColorBlendAttachmentState {
         self.inner
@@ -6275,58 +5808,46 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineColorBlendStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineColorBlendStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineColorBlendStateCreateFlags,
-    ) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn logic_op_enable(
-        mut self,
-        logic_op_enable: bool,
-    ) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineColorBlendStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn logic_op_enable(mut self, logic_op_enable: bool) -> Self {
         self.inner.logic_op_enable = logic_op_enable.into();
         self
     }
-    pub fn logic_op(mut self, logic_op: LogicOp) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
+    pub fn logic_op(mut self, logic_op: LogicOp) -> Self {
         self.inner.logic_op = logic_op;
         self
     }
-    pub fn attachments(
-        mut self,
-        attachments: &'a [PipelineColorBlendAttachmentState],
-    ) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
+    pub fn attachments(mut self, attachments: &'a [PipelineColorBlendAttachmentState]) -> Self {
         self.inner.attachment_count = attachments.len() as _;
         self.inner.p_attachments = attachments.as_ptr();
         self
     }
-    pub fn blend_constants(
-        mut self,
-        blend_constants: [f32; 4],
-    ) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
+    pub fn blend_constants(mut self, blend_constants: [f32; 4]) -> Self {
         self.inner.blend_constants = blend_constants;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPipelineColorBlendStateCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PipelineColorBlendStateCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -6366,61 +5887,37 @@ impl PipelineDynamicStateCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineDynamicStateCreateInfoBuilder<'a> {
     inner: PipelineDynamicStateCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineDynamicStateCreateInfo {}
 impl<'a> ::std::ops::Deref for PipelineDynamicStateCreateInfoBuilder<'a> {
     type Target = PipelineDynamicStateCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineDynamicStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineDynamicStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineDynamicStateCreateFlags,
-    ) -> PipelineDynamicStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn dynamic_states(
-        mut self,
-        dynamic_states: &'a [DynamicState],
-    ) -> PipelineDynamicStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineDynamicStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn dynamic_states(mut self, dynamic_states: &'a [DynamicState]) -> Self {
         self.inner.dynamic_state_count = dynamic_states.len() as _;
         self.inner.p_dynamic_states = dynamic_states.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineDynamicStateCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineDynamicStateCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineDynamicStateCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -6455,41 +5952,41 @@ impl<'a> ::std::ops::Deref for StencilOp
     }
 }
 impl<'a> ::std::ops::DerefMut for StencilOpStateBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> StencilOpStateBuilder<'a> {
-    pub fn fail_op(mut self, fail_op: StencilOp) -> StencilOpStateBuilder<'a> {
+    pub fn fail_op(mut self, fail_op: StencilOp) -> Self {
         self.inner.fail_op = fail_op;
         self
     }
-    pub fn pass_op(mut self, pass_op: StencilOp) -> StencilOpStateBuilder<'a> {
+    pub fn pass_op(mut self, pass_op: StencilOp) -> Self {
         self.inner.pass_op = pass_op;
         self
     }
-    pub fn depth_fail_op(mut self, depth_fail_op: StencilOp) -> StencilOpStateBuilder<'a> {
+    pub fn depth_fail_op(mut self, depth_fail_op: StencilOp) -> Self {
         self.inner.depth_fail_op = depth_fail_op;
         self
     }
-    pub fn compare_op(mut self, compare_op: CompareOp) -> StencilOpStateBuilder<'a> {
+    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
         self.inner.compare_op = compare_op;
         self
     }
-    pub fn compare_mask(mut self, compare_mask: u32) -> StencilOpStateBuilder<'a> {
+    pub fn compare_mask(mut self, compare_mask: u32) -> Self {
         self.inner.compare_mask = compare_mask;
         self
     }
-    pub fn write_mask(mut self, write_mask: u32) -> StencilOpStateBuilder<'a> {
+    pub fn write_mask(mut self, write_mask: u32) -> Self {
         self.inner.write_mask = write_mask;
         self
     }
-    pub fn reference(mut self, reference: u32) -> StencilOpStateBuilder<'a> {
+    pub fn reference(mut self, reference: u32) -> Self {
         self.inner.reference = reference;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> StencilOpState {
         self.inner
@@ -6538,113 +6035,68 @@ impl PipelineDepthStencilStateCreateInfo
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineDepthStencilStateCreateInfoBuilder<'a> {
     inner: PipelineDepthStencilStateCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineDepthStencilStateCreateInfo {}
 impl<'a> ::std::ops::Deref for PipelineDepthStencilStateCreateInfoBuilder<'a> {
     type Target = PipelineDepthStencilStateCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineDepthStencilStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineDepthStencilStateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineDepthStencilStateCreateFlags,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn depth_test_enable(
-        mut self,
-        depth_test_enable: bool,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineDepthStencilStateCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn depth_test_enable(mut self, depth_test_enable: bool) -> Self {
         self.inner.depth_test_enable = depth_test_enable.into();
         self
     }
-    pub fn depth_write_enable(
-        mut self,
-        depth_write_enable: bool,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn depth_write_enable(mut self, depth_write_enable: bool) -> Self {
         self.inner.depth_write_enable = depth_write_enable.into();
         self
     }
-    pub fn depth_compare_op(
-        mut self,
-        depth_compare_op: CompareOp,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn depth_compare_op(mut self, depth_compare_op: CompareOp) -> Self {
         self.inner.depth_compare_op = depth_compare_op;
         self
     }
-    pub fn depth_bounds_test_enable(
-        mut self,
-        depth_bounds_test_enable: bool,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn depth_bounds_test_enable(mut self, depth_bounds_test_enable: bool) -> Self {
         self.inner.depth_bounds_test_enable = depth_bounds_test_enable.into();
         self
     }
-    pub fn stencil_test_enable(
-        mut self,
-        stencil_test_enable: bool,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn stencil_test_enable(mut self, stencil_test_enable: bool) -> Self {
         self.inner.stencil_test_enable = stencil_test_enable.into();
         self
     }
-    pub fn front(
-        mut self,
-        front: StencilOpState,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn front(mut self, front: StencilOpState) -> Self {
         self.inner.front = front;
         self
     }
-    pub fn back(mut self, back: StencilOpState) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn back(mut self, back: StencilOpState) -> Self {
         self.inner.back = back;
         self
     }
-    pub fn min_depth_bounds(
-        mut self,
-        min_depth_bounds: f32,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn min_depth_bounds(mut self, min_depth_bounds: f32) -> Self {
         self.inner.min_depth_bounds = min_depth_bounds;
         self
     }
-    pub fn max_depth_bounds(
-        mut self,
-        max_depth_bounds: f32,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
+    pub fn max_depth_bounds(mut self, max_depth_bounds: f32) -> Self {
         self.inner.max_depth_bounds = max_depth_bounds;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineDepthStencilStateCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineDepthStencilStateCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineDepthStencilStateCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -6717,126 +6169,108 @@ impl<'a> ::std::ops::Deref for GraphicsP
     }
 }
 impl<'a> ::std::ops::DerefMut for GraphicsPipelineCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GraphicsPipelineCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: PipelineCreateFlags) -> GraphicsPipelineCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stages(
-        mut self,
-        stages: &'a [PipelineShaderStageCreateInfo],
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
         self.inner.stage_count = stages.len() as _;
         self.inner.p_stages = stages.as_ptr();
         self
     }
     pub fn vertex_input_state(
         mut self,
         vertex_input_state: &'a PipelineVertexInputStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_vertex_input_state = vertex_input_state;
         self
     }
     pub fn input_assembly_state(
         mut self,
         input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_input_assembly_state = input_assembly_state;
         self
     }
     pub fn tessellation_state(
         mut self,
         tessellation_state: &'a PipelineTessellationStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_tessellation_state = tessellation_state;
         self
     }
-    pub fn viewport_state(
-        mut self,
-        viewport_state: &'a PipelineViewportStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn viewport_state(mut self, viewport_state: &'a PipelineViewportStateCreateInfo) -> Self {
         self.inner.p_viewport_state = viewport_state;
         self
     }
     pub fn rasterization_state(
         mut self,
         rasterization_state: &'a PipelineRasterizationStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_rasterization_state = rasterization_state;
         self
     }
     pub fn multisample_state(
         mut self,
         multisample_state: &'a PipelineMultisampleStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_multisample_state = multisample_state;
         self
     }
     pub fn depth_stencil_state(
         mut self,
         depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_depth_stencil_state = depth_stencil_state;
         self
     }
     pub fn color_blend_state(
         mut self,
         color_blend_state: &'a PipelineColorBlendStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.p_color_blend_state = color_blend_state;
         self
     }
-    pub fn dynamic_state(
-        mut self,
-        dynamic_state: &'a PipelineDynamicStateCreateInfo,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> Self {
         self.inner.p_dynamic_state = dynamic_state;
         self
     }
-    pub fn layout(mut self, layout: PipelineLayout) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn layout(mut self, layout: PipelineLayout) -> Self {
         self.inner.layout = layout;
         self
     }
-    pub fn render_pass(mut self, render_pass: RenderPass) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
         self.inner.render_pass = render_pass;
         self
     }
-    pub fn subpass(mut self, subpass: u32) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn subpass(mut self, subpass: u32) -> Self {
         self.inner.subpass = subpass;
         self
     }
-    pub fn base_pipeline_handle(
-        mut self,
-        base_pipeline_handle: Pipeline,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
         self.inner.base_pipeline_handle = base_pipeline_handle;
         self
     }
-    pub fn base_pipeline_index(
-        mut self,
-        base_pipeline_index: i32,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
         self.inner.base_pipeline_index = base_pipeline_index;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGraphicsPipelineCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> GraphicsPipelineCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsGraphicsPipelineCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -6876,63 +6310,118 @@ impl PipelineCacheCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineCacheCreateInfoBuilder<'a> {
     inner: PipelineCacheCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineCacheCreateInfo {}
 impl<'a> ::std::ops::Deref for PipelineCacheCreateInfoBuilder<'a> {
     type Target = PipelineCacheCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineCacheCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCacheCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: PipelineCacheCreateFlags) -> PipelineCacheCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn initial_data(mut self, initial_data: &'a [u8]) -> PipelineCacheCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCacheCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
         self.inner.initial_data_size = initial_data.len() as _;
         self.inner.p_initial_data = initial_data.as_ptr() as *const c_void;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineCacheCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineCacheCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCacheCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineCacheHeaderVersionOne.html>"]
+pub struct PipelineCacheHeaderVersionOne {
+    pub header_size: u32,
+    pub header_version: PipelineCacheHeaderVersion,
+    pub vendor_id: u32,
+    pub device_id: u32,
+    pub pipeline_cache_uuid: [u8; UUID_SIZE],
+}
+impl ::std::default::Default for PipelineCacheHeaderVersionOne {
+    fn default() -> PipelineCacheHeaderVersionOne {
+        PipelineCacheHeaderVersionOne {
+            header_size: u32::default(),
+            header_version: PipelineCacheHeaderVersion::default(),
+            vendor_id: u32::default(),
+            device_id: u32::default(),
+            pipeline_cache_uuid: unsafe { ::std::mem::zeroed() },
+        }
+    }
+}
+impl PipelineCacheHeaderVersionOne {
+    pub fn builder<'a>() -> PipelineCacheHeaderVersionOneBuilder<'a> {
+        PipelineCacheHeaderVersionOneBuilder {
+            inner: PipelineCacheHeaderVersionOne::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PipelineCacheHeaderVersionOneBuilder<'a> {
+    inner: PipelineCacheHeaderVersionOne,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for PipelineCacheHeaderVersionOneBuilder<'a> {
+    type Target = PipelineCacheHeaderVersionOne;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PipelineCacheHeaderVersionOneBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PipelineCacheHeaderVersionOneBuilder<'a> {
+    pub fn header_size(mut self, header_size: u32) -> Self {
+        self.inner.header_size = header_size;
+        self
+    }
+    pub fn header_version(mut self, header_version: PipelineCacheHeaderVersion) -> Self {
+        self.inner.header_version = header_version;
+        self
+    }
+    pub fn vendor_id(mut self, vendor_id: u32) -> Self {
+        self.inner.vendor_id = vendor_id;
+        self
+    }
+    pub fn device_id(mut self, device_id: u32) -> Self {
+        self.inner.device_id = device_id;
+        self
+    }
+    pub fn pipeline_cache_uuid(mut self, pipeline_cache_uuid: [u8; UUID_SIZE]) -> Self {
+        self.inner.pipeline_cache_uuid = pipeline_cache_uuid;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PipelineCacheHeaderVersionOne {
+        self.inner
+    }
+}
+#[repr(C)]
 #[derive(Copy, Clone, Default, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPushConstantRange.html>"]
 pub struct PushConstantRange {
     pub stage_flags: ShaderStageFlags,
     pub offset: u32,
     pub size: u32,
 }
 impl PushConstantRange {
@@ -6955,25 +6444,25 @@ impl<'a> ::std::ops::Deref for PushConst
     }
 }
 impl<'a> ::std::ops::DerefMut for PushConstantRangeBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PushConstantRangeBuilder<'a> {
-    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> PushConstantRangeBuilder<'a> {
+    pub fn stage_flags(mut self, stage_flags: ShaderStageFlags) -> Self {
         self.inner.stage_flags = stage_flags;
         self
     }
-    pub fn offset(mut self, offset: u32) -> PushConstantRangeBuilder<'a> {
+    pub fn offset(mut self, offset: u32) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: u32) -> PushConstantRangeBuilder<'a> {
+    pub fn size(mut self, size: u32) -> Self {
         self.inner.size = size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PushConstantRange {
         self.inner
@@ -7012,69 +6501,42 @@ impl PipelineLayoutCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineLayoutCreateInfoBuilder<'a> {
     inner: PipelineLayoutCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineLayoutCreateInfo {}
 impl<'a> ::std::ops::Deref for PipelineLayoutCreateInfoBuilder<'a> {
     type Target = PipelineLayoutCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineLayoutCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineLayoutCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineLayoutCreateFlags,
-    ) -> PipelineLayoutCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn set_layouts(
-        mut self,
-        set_layouts: &'a [DescriptorSetLayout],
-    ) -> PipelineLayoutCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineLayoutCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn set_layouts(mut self, set_layouts: &'a [DescriptorSetLayout]) -> Self {
         self.inner.set_layout_count = set_layouts.len() as _;
         self.inner.p_set_layouts = set_layouts.as_ptr();
         self
     }
-    pub fn push_constant_ranges(
-        mut self,
-        push_constant_ranges: &'a [PushConstantRange],
-    ) -> PipelineLayoutCreateInfoBuilder<'a> {
+    pub fn push_constant_ranges(mut self, push_constant_ranges: &'a [PushConstantRange]) -> Self {
         self.inner.push_constant_range_count = push_constant_ranges.len() as _;
         self.inner.p_push_constant_ranges = push_constant_ranges.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineLayoutCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineLayoutCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineLayoutCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -7145,101 +6607,86 @@ impl<'a> ::std::ops::Deref for SamplerCr
     }
 }
 impl<'a> ::std::ops::DerefMut for SamplerCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: SamplerCreateFlags) -> SamplerCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn mag_filter(mut self, mag_filter: Filter) -> SamplerCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: SamplerCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn mag_filter(mut self, mag_filter: Filter) -> Self {
         self.inner.mag_filter = mag_filter;
         self
     }
-    pub fn min_filter(mut self, min_filter: Filter) -> SamplerCreateInfoBuilder<'a> {
+    pub fn min_filter(mut self, min_filter: Filter) -> Self {
         self.inner.min_filter = min_filter;
         self
     }
-    pub fn mipmap_mode(mut self, mipmap_mode: SamplerMipmapMode) -> SamplerCreateInfoBuilder<'a> {
+    pub fn mipmap_mode(mut self, mipmap_mode: SamplerMipmapMode) -> Self {
         self.inner.mipmap_mode = mipmap_mode;
         self
     }
-    pub fn address_mode_u(
-        mut self,
-        address_mode_u: SamplerAddressMode,
-    ) -> SamplerCreateInfoBuilder<'a> {
+    pub fn address_mode_u(mut self, address_mode_u: SamplerAddressMode) -> Self {
         self.inner.address_mode_u = address_mode_u;
         self
     }
-    pub fn address_mode_v(
-        mut self,
-        address_mode_v: SamplerAddressMode,
-    ) -> SamplerCreateInfoBuilder<'a> {
+    pub fn address_mode_v(mut self, address_mode_v: SamplerAddressMode) -> Self {
         self.inner.address_mode_v = address_mode_v;
         self
     }
-    pub fn address_mode_w(
-        mut self,
-        address_mode_w: SamplerAddressMode,
-    ) -> SamplerCreateInfoBuilder<'a> {
+    pub fn address_mode_w(mut self, address_mode_w: SamplerAddressMode) -> Self {
         self.inner.address_mode_w = address_mode_w;
         self
     }
-    pub fn mip_lod_bias(mut self, mip_lod_bias: f32) -> SamplerCreateInfoBuilder<'a> {
+    pub fn mip_lod_bias(mut self, mip_lod_bias: f32) -> Self {
         self.inner.mip_lod_bias = mip_lod_bias;
         self
     }
-    pub fn anisotropy_enable(mut self, anisotropy_enable: bool) -> SamplerCreateInfoBuilder<'a> {
+    pub fn anisotropy_enable(mut self, anisotropy_enable: bool) -> Self {
         self.inner.anisotropy_enable = anisotropy_enable.into();
         self
     }
-    pub fn max_anisotropy(mut self, max_anisotropy: f32) -> SamplerCreateInfoBuilder<'a> {
+    pub fn max_anisotropy(mut self, max_anisotropy: f32) -> Self {
         self.inner.max_anisotropy = max_anisotropy;
         self
     }
-    pub fn compare_enable(mut self, compare_enable: bool) -> SamplerCreateInfoBuilder<'a> {
+    pub fn compare_enable(mut self, compare_enable: bool) -> Self {
         self.inner.compare_enable = compare_enable.into();
         self
     }
-    pub fn compare_op(mut self, compare_op: CompareOp) -> SamplerCreateInfoBuilder<'a> {
+    pub fn compare_op(mut self, compare_op: CompareOp) -> Self {
         self.inner.compare_op = compare_op;
         self
     }
-    pub fn min_lod(mut self, min_lod: f32) -> SamplerCreateInfoBuilder<'a> {
+    pub fn min_lod(mut self, min_lod: f32) -> Self {
         self.inner.min_lod = min_lod;
         self
     }
-    pub fn max_lod(mut self, max_lod: f32) -> SamplerCreateInfoBuilder<'a> {
+    pub fn max_lod(mut self, max_lod: f32) -> Self {
         self.inner.max_lod = max_lod;
         self
     }
-    pub fn border_color(mut self, border_color: BorderColor) -> SamplerCreateInfoBuilder<'a> {
+    pub fn border_color(mut self, border_color: BorderColor) -> Self {
         self.inner.border_color = border_color;
         self
     }
-    pub fn unnormalized_coordinates(
-        mut self,
-        unnormalized_coordinates: bool,
-    ) -> SamplerCreateInfoBuilder<'a> {
+    pub fn unnormalized_coordinates(mut self, unnormalized_coordinates: bool) -> Self {
         self.inner.unnormalized_coordinates = unnormalized_coordinates.into();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSamplerCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SamplerCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsSamplerCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -7277,57 +6724,36 @@ impl CommandPoolCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct CommandPoolCreateInfoBuilder<'a> {
     inner: CommandPoolCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCommandPoolCreateInfo {}
 impl<'a> ::std::ops::Deref for CommandPoolCreateInfoBuilder<'a> {
     type Target = CommandPoolCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandPoolCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandPoolCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: CommandPoolCreateFlags) -> CommandPoolCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn queue_family_index(
-        mut self,
-        queue_family_index: u32,
-    ) -> CommandPoolCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: CommandPoolCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
         self.inner.queue_family_index = queue_family_index;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCommandPoolCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> CommandPoolCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CommandPoolCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -7359,64 +6785,40 @@ impl CommandBufferAllocateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct CommandBufferAllocateInfoBuilder<'a> {
     inner: CommandBufferAllocateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCommandBufferAllocateInfo {}
 impl<'a> ::std::ops::Deref for CommandBufferAllocateInfoBuilder<'a> {
     type Target = CommandBufferAllocateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandBufferAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandBufferAllocateInfoBuilder<'a> {
-    pub fn command_pool(
-        mut self,
-        command_pool: CommandPool,
-    ) -> CommandBufferAllocateInfoBuilder<'a> {
+    pub fn command_pool(mut self, command_pool: CommandPool) -> Self {
         self.inner.command_pool = command_pool;
         self
     }
-    pub fn level(mut self, level: CommandBufferLevel) -> CommandBufferAllocateInfoBuilder<'a> {
+    pub fn level(mut self, level: CommandBufferLevel) -> Self {
         self.inner.level = level;
         self
     }
-    pub fn command_buffer_count(
-        mut self,
-        command_buffer_count: u32,
-    ) -> CommandBufferAllocateInfoBuilder<'a> {
+    pub fn command_buffer_count(mut self, command_buffer_count: u32) -> Self {
         self.inner.command_buffer_count = command_buffer_count;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCommandBufferAllocateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> CommandBufferAllocateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CommandBufferAllocateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -7467,64 +6869,46 @@ impl<'a> ::std::ops::Deref for CommandBu
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandBufferInheritanceInfoBuilder<'a> {
-    pub fn render_pass(
-        mut self,
-        render_pass: RenderPass,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
         self.inner.render_pass = render_pass;
         self
     }
-    pub fn subpass(mut self, subpass: u32) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn subpass(mut self, subpass: u32) -> Self {
         self.inner.subpass = subpass;
         self
     }
-    pub fn framebuffer(
-        mut self,
-        framebuffer: Framebuffer,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
         self.inner.framebuffer = framebuffer;
         self
     }
-    pub fn occlusion_query_enable(
-        mut self,
-        occlusion_query_enable: bool,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn occlusion_query_enable(mut self, occlusion_query_enable: bool) -> Self {
         self.inner.occlusion_query_enable = occlusion_query_enable.into();
         self
     }
-    pub fn query_flags(
-        mut self,
-        query_flags: QueryControlFlags,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn query_flags(mut self, query_flags: QueryControlFlags) -> Self {
         self.inner.query_flags = query_flags;
         self
     }
-    pub fn pipeline_statistics(
-        mut self,
-        pipeline_statistics: QueryPipelineStatisticFlags,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
         self.inner.pipeline_statistics = pipeline_statistics;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCommandBufferInheritanceInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> CommandBufferInheritanceInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsCommandBufferInheritanceInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -7575,36 +6959,30 @@ impl<'a> ::std::ops::Deref for CommandBu
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandBufferBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandBufferBeginInfoBuilder<'a> {
-    pub fn flags(mut self, flags: CommandBufferUsageFlags) -> CommandBufferBeginInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn inheritance_info(
-        mut self,
-        inheritance_info: &'a CommandBufferInheritanceInfo,
-    ) -> CommandBufferBeginInfoBuilder<'a> {
+    pub fn flags(mut self, flags: CommandBufferUsageFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn inheritance_info(mut self, inheritance_info: &'a CommandBufferInheritanceInfo) -> Self {
         self.inner.p_inheritance_info = inheritance_info;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCommandBufferBeginInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> CommandBufferBeginInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsCommandBufferBeginInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -7674,45 +7052,39 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassBeginInfoBuilder<'a> {
-    pub fn render_pass(mut self, render_pass: RenderPass) -> RenderPassBeginInfoBuilder<'a> {
+    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
         self.inner.render_pass = render_pass;
         self
     }
-    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> RenderPassBeginInfoBuilder<'a> {
+    pub fn framebuffer(mut self, framebuffer: Framebuffer) -> Self {
         self.inner.framebuffer = framebuffer;
         self
     }
-    pub fn render_area(mut self, render_area: Rect2D) -> RenderPassBeginInfoBuilder<'a> {
+    pub fn render_area(mut self, render_area: Rect2D) -> Self {
         self.inner.render_area = render_area;
         self
     }
-    pub fn clear_values(
-        mut self,
-        clear_values: &'a [ClearValue],
-    ) -> RenderPassBeginInfoBuilder<'a> {
+    pub fn clear_values(mut self, clear_values: &'a [ClearValue]) -> Self {
         self.inner.clear_value_count = clear_values.len() as _;
         self.inner.p_clear_values = clear_values.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRenderPassBeginInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> RenderPassBeginInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsRenderPassBeginInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -7763,21 +7135,21 @@ impl<'a> ::std::ops::Deref for ClearDept
     }
 }
 impl<'a> ::std::ops::DerefMut for ClearDepthStencilValueBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ClearDepthStencilValueBuilder<'a> {
-    pub fn depth(mut self, depth: f32) -> ClearDepthStencilValueBuilder<'a> {
+    pub fn depth(mut self, depth: f32) -> Self {
         self.inner.depth = depth;
         self
     }
-    pub fn stencil(mut self, stencil: u32) -> ClearDepthStencilValueBuilder<'a> {
+    pub fn stencil(mut self, stencil: u32) -> Self {
         self.inner.stencil = stencil;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ClearDepthStencilValue {
         self.inner
@@ -7832,25 +7204,25 @@ impl<'a> ::std::ops::Deref for ClearAtta
     }
 }
 impl<'a> ::std::ops::DerefMut for ClearAttachmentBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ClearAttachmentBuilder<'a> {
-    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> ClearAttachmentBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
-    pub fn color_attachment(mut self, color_attachment: u32) -> ClearAttachmentBuilder<'a> {
+    pub fn color_attachment(mut self, color_attachment: u32) -> Self {
         self.inner.color_attachment = color_attachment;
         self
     }
-    pub fn clear_value(mut self, clear_value: ClearValue) -> ClearAttachmentBuilder<'a> {
+    pub fn clear_value(mut self, clear_value: ClearValue) -> Self {
         self.inner.clear_value = clear_value;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ClearAttachment {
         self.inner
@@ -7890,58 +7262,49 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentDescriptionBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentDescriptionBuilder<'a> {
-    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> AttachmentDescriptionBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn format(mut self, format: Format) -> AttachmentDescriptionBuilder<'a> {
+    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn samples(mut self, samples: SampleCountFlags) -> AttachmentDescriptionBuilder<'a> {
+    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
         self.inner.samples = samples;
         self
     }
-    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> AttachmentDescriptionBuilder<'a> {
+    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
         self.inner.load_op = load_op;
         self
     }
-    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> AttachmentDescriptionBuilder<'a> {
+    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
         self.inner.store_op = store_op;
         self
     }
-    pub fn stencil_load_op(
-        mut self,
-        stencil_load_op: AttachmentLoadOp,
-    ) -> AttachmentDescriptionBuilder<'a> {
+    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
         self.inner.stencil_load_op = stencil_load_op;
         self
     }
-    pub fn stencil_store_op(
-        mut self,
-        stencil_store_op: AttachmentStoreOp,
-    ) -> AttachmentDescriptionBuilder<'a> {
+    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
         self.inner.stencil_store_op = stencil_store_op;
         self
     }
-    pub fn initial_layout(
-        mut self,
-        initial_layout: ImageLayout,
-    ) -> AttachmentDescriptionBuilder<'a> {
+    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
         self.inner.initial_layout = initial_layout;
         self
     }
-    pub fn final_layout(mut self, final_layout: ImageLayout) -> AttachmentDescriptionBuilder<'a> {
+    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
         self.inner.final_layout = final_layout;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AttachmentDescription {
         self.inner
@@ -7974,21 +7337,21 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentReferenceBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentReferenceBuilder<'a> {
-    pub fn attachment(mut self, attachment: u32) -> AttachmentReferenceBuilder<'a> {
+    pub fn attachment(mut self, attachment: u32) -> Self {
         self.inner.attachment = attachment;
         self
     }
-    pub fn layout(mut self, layout: ImageLayout) -> AttachmentReferenceBuilder<'a> {
+    pub fn layout(mut self, layout: ImageLayout) -> Self {
         self.inner.layout = layout;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AttachmentReference {
         self.inner
@@ -8045,62 +7408,47 @@ impl<'a> ::std::ops::Deref for SubpassDe
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassDescriptionBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassDescriptionBuilder<'a> {
-    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> SubpassDescriptionBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> SubpassDescriptionBuilder<'a> {
+    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn input_attachments(
-        mut self,
-        input_attachments: &'a [AttachmentReference],
-    ) -> SubpassDescriptionBuilder<'a> {
+    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference]) -> Self {
         self.inner.input_attachment_count = input_attachments.len() as _;
         self.inner.p_input_attachments = input_attachments.as_ptr();
         self
     }
-    pub fn color_attachments(
-        mut self,
-        color_attachments: &'a [AttachmentReference],
-    ) -> SubpassDescriptionBuilder<'a> {
+    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference]) -> Self {
         self.inner.color_attachment_count = color_attachments.len() as _;
         self.inner.p_color_attachments = color_attachments.as_ptr();
         self
     }
-    pub fn resolve_attachments(
-        mut self,
-        resolve_attachments: &'a [AttachmentReference],
-    ) -> SubpassDescriptionBuilder<'a> {
+    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference]) -> Self {
         self.inner.color_attachment_count = resolve_attachments.len() as _;
         self.inner.p_resolve_attachments = resolve_attachments.as_ptr();
         self
     }
     pub fn depth_stencil_attachment(
         mut self,
         depth_stencil_attachment: &'a AttachmentReference,
-    ) -> SubpassDescriptionBuilder<'a> {
+    ) -> Self {
         self.inner.p_depth_stencil_attachment = depth_stencil_attachment;
         self
     }
-    pub fn preserve_attachments(
-        mut self,
-        preserve_attachments: &'a [u32],
-    ) -> SubpassDescriptionBuilder<'a> {
+    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
         self.inner.preserve_attachment_count = preserve_attachments.len() as _;
         self.inner.p_preserve_attachments = preserve_attachments.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassDescription {
@@ -8139,50 +7487,41 @@ impl<'a> ::std::ops::Deref for SubpassDe
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassDependencyBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassDependencyBuilder<'a> {
-    pub fn src_subpass(mut self, src_subpass: u32) -> SubpassDependencyBuilder<'a> {
+    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
         self.inner.src_subpass = src_subpass;
         self
     }
-    pub fn dst_subpass(mut self, dst_subpass: u32) -> SubpassDependencyBuilder<'a> {
+    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
         self.inner.dst_subpass = dst_subpass;
         self
     }
-    pub fn src_stage_mask(
-        mut self,
-        src_stage_mask: PipelineStageFlags,
-    ) -> SubpassDependencyBuilder<'a> {
+    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
         self.inner.src_stage_mask = src_stage_mask;
         self
     }
-    pub fn dst_stage_mask(
-        mut self,
-        dst_stage_mask: PipelineStageFlags,
-    ) -> SubpassDependencyBuilder<'a> {
+    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
         self.inner.dst_stage_mask = dst_stage_mask;
         self
     }
-    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> SubpassDependencyBuilder<'a> {
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
         self.inner.src_access_mask = src_access_mask;
         self
     }
-    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> SubpassDependencyBuilder<'a> {
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
         self.inner.dst_access_mask = dst_access_mask;
         self
     }
-    pub fn dependency_flags(
-        mut self,
-        dependency_flags: DependencyFlags,
-    ) -> SubpassDependencyBuilder<'a> {
+    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
         self.inner.dependency_flags = dependency_flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassDependency {
         self.inner
@@ -8238,53 +7577,41 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: RenderPassCreateFlags) -> RenderPassCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn attachments(
-        mut self,
-        attachments: &'a [AttachmentDescription],
-    ) -> RenderPassCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn attachments(mut self, attachments: &'a [AttachmentDescription]) -> Self {
         self.inner.attachment_count = attachments.len() as _;
         self.inner.p_attachments = attachments.as_ptr();
         self
     }
-    pub fn subpasses(
-        mut self,
-        subpasses: &'a [SubpassDescription],
-    ) -> RenderPassCreateInfoBuilder<'a> {
+    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription]) -> Self {
         self.inner.subpass_count = subpasses.len() as _;
         self.inner.p_subpasses = subpasses.as_ptr();
         self
     }
-    pub fn dependencies(
-        mut self,
-        dependencies: &'a [SubpassDependency],
-    ) -> RenderPassCreateInfoBuilder<'a> {
+    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency]) -> Self {
         self.inner.dependency_count = dependencies.len() as _;
         self.inner.p_dependencies = dependencies.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRenderPassCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> RenderPassCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsRenderPassCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -8320,48 +7647,30 @@ impl EventCreateInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct EventCreateInfoBuilder<'a> {
     inner: EventCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsEventCreateInfo {}
 impl<'a> ::std::ops::Deref for EventCreateInfoBuilder<'a> {
     type Target = EventCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for EventCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> EventCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: EventCreateFlags) -> EventCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsEventCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> EventCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: EventCreateFlags) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> EventCreateInfo {
         self.inner
     }
@@ -8404,29 +7713,26 @@ impl<'a> ::std::ops::Deref for FenceCrea
     }
 }
 impl<'a> ::std::ops::DerefMut for FenceCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FenceCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: FenceCreateFlags) -> FenceCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFenceCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> FenceCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: FenceCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsFenceCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -8517,361 +7823,271 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFeaturesBuilder<'a> {
-    pub fn robust_buffer_access(
-        mut self,
-        robust_buffer_access: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn robust_buffer_access(mut self, robust_buffer_access: bool) -> Self {
         self.inner.robust_buffer_access = robust_buffer_access.into();
         self
     }
-    pub fn full_draw_index_uint32(
-        mut self,
-        full_draw_index_uint32: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn full_draw_index_uint32(mut self, full_draw_index_uint32: bool) -> Self {
         self.inner.full_draw_index_uint32 = full_draw_index_uint32.into();
         self
     }
-    pub fn image_cube_array(mut self, image_cube_array: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn image_cube_array(mut self, image_cube_array: bool) -> Self {
         self.inner.image_cube_array = image_cube_array.into();
         self
     }
-    pub fn independent_blend(
-        mut self,
-        independent_blend: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn independent_blend(mut self, independent_blend: bool) -> Self {
         self.inner.independent_blend = independent_blend.into();
         self
     }
-    pub fn geometry_shader(mut self, geometry_shader: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn geometry_shader(mut self, geometry_shader: bool) -> Self {
         self.inner.geometry_shader = geometry_shader.into();
         self
     }
-    pub fn tessellation_shader(
-        mut self,
-        tessellation_shader: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn tessellation_shader(mut self, tessellation_shader: bool) -> Self {
         self.inner.tessellation_shader = tessellation_shader.into();
         self
     }
-    pub fn sample_rate_shading(
-        mut self,
-        sample_rate_shading: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sample_rate_shading(mut self, sample_rate_shading: bool) -> Self {
         self.inner.sample_rate_shading = sample_rate_shading.into();
         self
     }
-    pub fn dual_src_blend(mut self, dual_src_blend: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn dual_src_blend(mut self, dual_src_blend: bool) -> Self {
         self.inner.dual_src_blend = dual_src_blend.into();
         self
     }
-    pub fn logic_op(mut self, logic_op: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn logic_op(mut self, logic_op: bool) -> Self {
         self.inner.logic_op = logic_op.into();
         self
     }
-    pub fn multi_draw_indirect(
-        mut self,
-        multi_draw_indirect: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn multi_draw_indirect(mut self, multi_draw_indirect: bool) -> Self {
         self.inner.multi_draw_indirect = multi_draw_indirect.into();
         self
     }
-    pub fn draw_indirect_first_instance(
-        mut self,
-        draw_indirect_first_instance: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn draw_indirect_first_instance(mut self, draw_indirect_first_instance: bool) -> Self {
         self.inner.draw_indirect_first_instance = draw_indirect_first_instance.into();
         self
     }
-    pub fn depth_clamp(mut self, depth_clamp: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn depth_clamp(mut self, depth_clamp: bool) -> Self {
         self.inner.depth_clamp = depth_clamp.into();
         self
     }
-    pub fn depth_bias_clamp(mut self, depth_bias_clamp: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn depth_bias_clamp(mut self, depth_bias_clamp: bool) -> Self {
         self.inner.depth_bias_clamp = depth_bias_clamp.into();
         self
     }
-    pub fn fill_mode_non_solid(
-        mut self,
-        fill_mode_non_solid: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn fill_mode_non_solid(mut self, fill_mode_non_solid: bool) -> Self {
         self.inner.fill_mode_non_solid = fill_mode_non_solid.into();
         self
     }
-    pub fn depth_bounds(mut self, depth_bounds: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn depth_bounds(mut self, depth_bounds: bool) -> Self {
         self.inner.depth_bounds = depth_bounds.into();
         self
     }
-    pub fn wide_lines(mut self, wide_lines: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn wide_lines(mut self, wide_lines: bool) -> Self {
         self.inner.wide_lines = wide_lines.into();
         self
     }
-    pub fn large_points(mut self, large_points: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn large_points(mut self, large_points: bool) -> Self {
         self.inner.large_points = large_points.into();
         self
     }
-    pub fn alpha_to_one(mut self, alpha_to_one: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn alpha_to_one(mut self, alpha_to_one: bool) -> Self {
         self.inner.alpha_to_one = alpha_to_one.into();
         self
     }
-    pub fn multi_viewport(mut self, multi_viewport: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn multi_viewport(mut self, multi_viewport: bool) -> Self {
         self.inner.multi_viewport = multi_viewport.into();
         self
     }
-    pub fn sampler_anisotropy(
-        mut self,
-        sampler_anisotropy: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sampler_anisotropy(mut self, sampler_anisotropy: bool) -> Self {
         self.inner.sampler_anisotropy = sampler_anisotropy.into();
         self
     }
-    pub fn texture_compression_etc2(
-        mut self,
-        texture_compression_etc2: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn texture_compression_etc2(mut self, texture_compression_etc2: bool) -> Self {
         self.inner.texture_compression_etc2 = texture_compression_etc2.into();
         self
     }
-    pub fn texture_compression_astc_ldr(
-        mut self,
-        texture_compression_astc_ldr: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn texture_compression_astc_ldr(mut self, texture_compression_astc_ldr: bool) -> Self {
         self.inner.texture_compression_astc_ldr = texture_compression_astc_ldr.into();
         self
     }
-    pub fn texture_compression_bc(
-        mut self,
-        texture_compression_bc: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn texture_compression_bc(mut self, texture_compression_bc: bool) -> Self {
         self.inner.texture_compression_bc = texture_compression_bc.into();
         self
     }
-    pub fn occlusion_query_precise(
-        mut self,
-        occlusion_query_precise: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn occlusion_query_precise(mut self, occlusion_query_precise: bool) -> Self {
         self.inner.occlusion_query_precise = occlusion_query_precise.into();
         self
     }
-    pub fn pipeline_statistics_query(
-        mut self,
-        pipeline_statistics_query: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn pipeline_statistics_query(mut self, pipeline_statistics_query: bool) -> Self {
         self.inner.pipeline_statistics_query = pipeline_statistics_query.into();
         self
     }
     pub fn vertex_pipeline_stores_and_atomics(
         mut self,
         vertex_pipeline_stores_and_atomics: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_pipeline_stores_and_atomics = vertex_pipeline_stores_and_atomics.into();
         self
     }
-    pub fn fragment_stores_and_atomics(
-        mut self,
-        fragment_stores_and_atomics: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn fragment_stores_and_atomics(mut self, fragment_stores_and_atomics: bool) -> Self {
         self.inner.fragment_stores_and_atomics = fragment_stores_and_atomics.into();
         self
     }
     pub fn shader_tessellation_and_geometry_point_size(
         mut self,
         shader_tessellation_and_geometry_point_size: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_tessellation_and_geometry_point_size =
             shader_tessellation_and_geometry_point_size.into();
         self
     }
-    pub fn shader_image_gather_extended(
-        mut self,
-        shader_image_gather_extended: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_image_gather_extended(mut self, shader_image_gather_extended: bool) -> Self {
         self.inner.shader_image_gather_extended = shader_image_gather_extended.into();
         self
     }
     pub fn shader_storage_image_extended_formats(
         mut self,
         shader_storage_image_extended_formats: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_extended_formats =
             shader_storage_image_extended_formats.into();
         self
     }
     pub fn shader_storage_image_multisample(
         mut self,
         shader_storage_image_multisample: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_multisample = shader_storage_image_multisample.into();
         self
     }
     pub fn shader_storage_image_read_without_format(
         mut self,
         shader_storage_image_read_without_format: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_read_without_format =
             shader_storage_image_read_without_format.into();
         self
     }
     pub fn shader_storage_image_write_without_format(
         mut self,
         shader_storage_image_write_without_format: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_write_without_format =
             shader_storage_image_write_without_format.into();
         self
     }
     pub fn shader_uniform_buffer_array_dynamic_indexing(
         mut self,
         shader_uniform_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_uniform_buffer_array_dynamic_indexing =
             shader_uniform_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_sampled_image_array_dynamic_indexing(
         mut self,
         shader_sampled_image_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_sampled_image_array_dynamic_indexing =
             shader_sampled_image_array_dynamic_indexing.into();
         self
     }
     pub fn shader_storage_buffer_array_dynamic_indexing(
         mut self,
         shader_storage_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_buffer_array_dynamic_indexing =
             shader_storage_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_storage_image_array_dynamic_indexing(
         mut self,
         shader_storage_image_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_array_dynamic_indexing =
             shader_storage_image_array_dynamic_indexing.into();
         self
     }
-    pub fn shader_clip_distance(
-        mut self,
-        shader_clip_distance: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_clip_distance(mut self, shader_clip_distance: bool) -> Self {
         self.inner.shader_clip_distance = shader_clip_distance.into();
         self
     }
-    pub fn shader_cull_distance(
-        mut self,
-        shader_cull_distance: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_cull_distance(mut self, shader_cull_distance: bool) -> Self {
         self.inner.shader_cull_distance = shader_cull_distance.into();
         self
     }
-    pub fn shader_float64(mut self, shader_float64: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_float64(mut self, shader_float64: bool) -> Self {
         self.inner.shader_float64 = shader_float64.into();
         self
     }
-    pub fn shader_int64(mut self, shader_int64: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_int64(mut self, shader_int64: bool) -> Self {
         self.inner.shader_int64 = shader_int64.into();
         self
     }
-    pub fn shader_int16(mut self, shader_int16: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_int16(mut self, shader_int16: bool) -> Self {
         self.inner.shader_int16 = shader_int16.into();
         self
     }
-    pub fn shader_resource_residency(
-        mut self,
-        shader_resource_residency: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_resource_residency(mut self, shader_resource_residency: bool) -> Self {
         self.inner.shader_resource_residency = shader_resource_residency.into();
         self
     }
-    pub fn shader_resource_min_lod(
-        mut self,
-        shader_resource_min_lod: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn shader_resource_min_lod(mut self, shader_resource_min_lod: bool) -> Self {
         self.inner.shader_resource_min_lod = shader_resource_min_lod.into();
         self
     }
-    pub fn sparse_binding(mut self, sparse_binding: bool) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_binding(mut self, sparse_binding: bool) -> Self {
         self.inner.sparse_binding = sparse_binding.into();
         self
     }
-    pub fn sparse_residency_buffer(
-        mut self,
-        sparse_residency_buffer: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency_buffer(mut self, sparse_residency_buffer: bool) -> Self {
         self.inner.sparse_residency_buffer = sparse_residency_buffer.into();
         self
     }
-    pub fn sparse_residency_image2_d(
-        mut self,
-        sparse_residency_image2_d: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency_image2_d(mut self, sparse_residency_image2_d: bool) -> Self {
         self.inner.sparse_residency_image2_d = sparse_residency_image2_d.into();
         self
     }
-    pub fn sparse_residency_image3_d(
-        mut self,
-        sparse_residency_image3_d: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency_image3_d(mut self, sparse_residency_image3_d: bool) -> Self {
         self.inner.sparse_residency_image3_d = sparse_residency_image3_d.into();
         self
     }
-    pub fn sparse_residency2_samples(
-        mut self,
-        sparse_residency2_samples: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency2_samples(mut self, sparse_residency2_samples: bool) -> Self {
         self.inner.sparse_residency2_samples = sparse_residency2_samples.into();
         self
     }
-    pub fn sparse_residency4_samples(
-        mut self,
-        sparse_residency4_samples: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency4_samples(mut self, sparse_residency4_samples: bool) -> Self {
         self.inner.sparse_residency4_samples = sparse_residency4_samples.into();
         self
     }
-    pub fn sparse_residency8_samples(
-        mut self,
-        sparse_residency8_samples: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency8_samples(mut self, sparse_residency8_samples: bool) -> Self {
         self.inner.sparse_residency8_samples = sparse_residency8_samples.into();
         self
     }
-    pub fn sparse_residency16_samples(
-        mut self,
-        sparse_residency16_samples: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency16_samples(mut self, sparse_residency16_samples: bool) -> Self {
         self.inner.sparse_residency16_samples = sparse_residency16_samples.into();
         self
     }
-    pub fn sparse_residency_aliased(
-        mut self,
-        sparse_residency_aliased: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn sparse_residency_aliased(mut self, sparse_residency_aliased: bool) -> Self {
         self.inner.sparse_residency_aliased = sparse_residency_aliased.into();
         self
     }
-    pub fn variable_multisample_rate(
-        mut self,
-        variable_multisample_rate: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn variable_multisample_rate(mut self, variable_multisample_rate: bool) -> Self {
         self.inner.variable_multisample_rate = variable_multisample_rate.into();
         self
     }
-    pub fn inherited_queries(
-        mut self,
-        inherited_queries: bool,
-    ) -> PhysicalDeviceFeaturesBuilder<'a> {
+    pub fn inherited_queries(mut self, inherited_queries: bool) -> Self {
         self.inner.inherited_queries = inherited_queries.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFeatures {
         self.inner
@@ -8910,46 +8126,40 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSparsePropertiesBuilder<'a> {
     pub fn residency_standard2_d_block_shape(
         mut self,
         residency_standard2_d_block_shape: bool,
-    ) -> PhysicalDeviceSparsePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.residency_standard2_d_block_shape = residency_standard2_d_block_shape.into();
         self
     }
     pub fn residency_standard2_d_multisample_block_shape(
         mut self,
         residency_standard2_d_multisample_block_shape: bool,
-    ) -> PhysicalDeviceSparsePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.residency_standard2_d_multisample_block_shape =
             residency_standard2_d_multisample_block_shape.into();
         self
     }
     pub fn residency_standard3_d_block_shape(
         mut self,
         residency_standard3_d_block_shape: bool,
-    ) -> PhysicalDeviceSparsePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.residency_standard3_d_block_shape = residency_standard3_d_block_shape.into();
         self
     }
-    pub fn residency_aligned_mip_size(
-        mut self,
-        residency_aligned_mip_size: bool,
-    ) -> PhysicalDeviceSparsePropertiesBuilder<'a> {
+    pub fn residency_aligned_mip_size(mut self, residency_aligned_mip_size: bool) -> Self {
         self.inner.residency_aligned_mip_size = residency_aligned_mip_size.into();
         self
     }
-    pub fn residency_non_resident_strict(
-        mut self,
-        residency_non_resident_strict: bool,
-    ) -> PhysicalDeviceSparsePropertiesBuilder<'a> {
+    pub fn residency_non_resident_strict(mut self, residency_non_resident_strict: bool) -> Self {
         self.inner.residency_non_resident_strict = residency_non_resident_strict.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSparseProperties {
         self.inner
@@ -9198,758 +8408,578 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceLimitsBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceLimitsBuilder<'a> {
-    pub fn max_image_dimension1_d(
-        mut self,
-        max_image_dimension1_d: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_image_dimension1_d(mut self, max_image_dimension1_d: u32) -> Self {
         self.inner.max_image_dimension1_d = max_image_dimension1_d;
         self
     }
-    pub fn max_image_dimension2_d(
-        mut self,
-        max_image_dimension2_d: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_image_dimension2_d(mut self, max_image_dimension2_d: u32) -> Self {
         self.inner.max_image_dimension2_d = max_image_dimension2_d;
         self
     }
-    pub fn max_image_dimension3_d(
-        mut self,
-        max_image_dimension3_d: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_image_dimension3_d(mut self, max_image_dimension3_d: u32) -> Self {
         self.inner.max_image_dimension3_d = max_image_dimension3_d;
         self
     }
-    pub fn max_image_dimension_cube(
-        mut self,
-        max_image_dimension_cube: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_image_dimension_cube(mut self, max_image_dimension_cube: u32) -> Self {
         self.inner.max_image_dimension_cube = max_image_dimension_cube;
         self
     }
-    pub fn max_image_array_layers(
-        mut self,
-        max_image_array_layers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
         self.inner.max_image_array_layers = max_image_array_layers;
         self
     }
-    pub fn max_texel_buffer_elements(
-        mut self,
-        max_texel_buffer_elements: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_texel_buffer_elements(mut self, max_texel_buffer_elements: u32) -> Self {
         self.inner.max_texel_buffer_elements = max_texel_buffer_elements;
         self
     }
-    pub fn max_uniform_buffer_range(
-        mut self,
-        max_uniform_buffer_range: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_uniform_buffer_range(mut self, max_uniform_buffer_range: u32) -> Self {
         self.inner.max_uniform_buffer_range = max_uniform_buffer_range;
         self
     }
-    pub fn max_storage_buffer_range(
-        mut self,
-        max_storage_buffer_range: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_storage_buffer_range(mut self, max_storage_buffer_range: u32) -> Self {
         self.inner.max_storage_buffer_range = max_storage_buffer_range;
         self
     }
-    pub fn max_push_constants_size(
-        mut self,
-        max_push_constants_size: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_push_constants_size(mut self, max_push_constants_size: u32) -> Self {
         self.inner.max_push_constants_size = max_push_constants_size;
         self
     }
-    pub fn max_memory_allocation_count(
-        mut self,
-        max_memory_allocation_count: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_memory_allocation_count(mut self, max_memory_allocation_count: u32) -> Self {
         self.inner.max_memory_allocation_count = max_memory_allocation_count;
         self
     }
-    pub fn max_sampler_allocation_count(
-        mut self,
-        max_sampler_allocation_count: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_sampler_allocation_count(mut self, max_sampler_allocation_count: u32) -> Self {
         self.inner.max_sampler_allocation_count = max_sampler_allocation_count;
         self
     }
-    pub fn buffer_image_granularity(
-        mut self,
-        buffer_image_granularity: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn buffer_image_granularity(mut self, buffer_image_granularity: DeviceSize) -> Self {
         self.inner.buffer_image_granularity = buffer_image_granularity;
         self
     }
-    pub fn sparse_address_space_size(
-        mut self,
-        sparse_address_space_size: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn sparse_address_space_size(mut self, sparse_address_space_size: DeviceSize) -> Self {
         self.inner.sparse_address_space_size = sparse_address_space_size;
         self
     }
-    pub fn max_bound_descriptor_sets(
-        mut self,
-        max_bound_descriptor_sets: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_bound_descriptor_sets(mut self, max_bound_descriptor_sets: u32) -> Self {
         self.inner.max_bound_descriptor_sets = max_bound_descriptor_sets;
         self
     }
     pub fn max_per_stage_descriptor_samplers(
         mut self,
         max_per_stage_descriptor_samplers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_samplers = max_per_stage_descriptor_samplers;
         self
     }
     pub fn max_per_stage_descriptor_uniform_buffers(
         mut self,
         max_per_stage_descriptor_uniform_buffers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_uniform_buffers =
             max_per_stage_descriptor_uniform_buffers;
         self
     }
     pub fn max_per_stage_descriptor_storage_buffers(
         mut self,
         max_per_stage_descriptor_storage_buffers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_storage_buffers =
             max_per_stage_descriptor_storage_buffers;
         self
     }
     pub fn max_per_stage_descriptor_sampled_images(
         mut self,
         max_per_stage_descriptor_sampled_images: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_sampled_images =
             max_per_stage_descriptor_sampled_images;
         self
     }
     pub fn max_per_stage_descriptor_storage_images(
         mut self,
         max_per_stage_descriptor_storage_images: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_storage_images =
             max_per_stage_descriptor_storage_images;
         self
     }
     pub fn max_per_stage_descriptor_input_attachments(
         mut self,
         max_per_stage_descriptor_input_attachments: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_input_attachments =
             max_per_stage_descriptor_input_attachments;
         self
     }
-    pub fn max_per_stage_resources(
-        mut self,
-        max_per_stage_resources: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_per_stage_resources(mut self, max_per_stage_resources: u32) -> Self {
         self.inner.max_per_stage_resources = max_per_stage_resources;
         self
     }
-    pub fn max_descriptor_set_samplers(
-        mut self,
-        max_descriptor_set_samplers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_descriptor_set_samplers(mut self, max_descriptor_set_samplers: u32) -> Self {
         self.inner.max_descriptor_set_samplers = max_descriptor_set_samplers;
         self
     }
     pub fn max_descriptor_set_uniform_buffers(
         mut self,
         max_descriptor_set_uniform_buffers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_uniform_buffers = max_descriptor_set_uniform_buffers;
         self
     }
     pub fn max_descriptor_set_uniform_buffers_dynamic(
         mut self,
         max_descriptor_set_uniform_buffers_dynamic: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_uniform_buffers_dynamic =
             max_descriptor_set_uniform_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_storage_buffers(
         mut self,
         max_descriptor_set_storage_buffers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_storage_buffers = max_descriptor_set_storage_buffers;
         self
     }
     pub fn max_descriptor_set_storage_buffers_dynamic(
         mut self,
         max_descriptor_set_storage_buffers_dynamic: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_storage_buffers_dynamic =
             max_descriptor_set_storage_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_sampled_images(
         mut self,
         max_descriptor_set_sampled_images: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_sampled_images = max_descriptor_set_sampled_images;
         self
     }
     pub fn max_descriptor_set_storage_images(
         mut self,
         max_descriptor_set_storage_images: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_storage_images = max_descriptor_set_storage_images;
         self
     }
     pub fn max_descriptor_set_input_attachments(
         mut self,
         max_descriptor_set_input_attachments: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_input_attachments = max_descriptor_set_input_attachments;
         self
     }
-    pub fn max_vertex_input_attributes(
-        mut self,
-        max_vertex_input_attributes: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_vertex_input_attributes(mut self, max_vertex_input_attributes: u32) -> Self {
         self.inner.max_vertex_input_attributes = max_vertex_input_attributes;
         self
     }
-    pub fn max_vertex_input_bindings(
-        mut self,
-        max_vertex_input_bindings: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_vertex_input_bindings(mut self, max_vertex_input_bindings: u32) -> Self {
         self.inner.max_vertex_input_bindings = max_vertex_input_bindings;
         self
     }
     pub fn max_vertex_input_attribute_offset(
         mut self,
         max_vertex_input_attribute_offset: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_vertex_input_attribute_offset = max_vertex_input_attribute_offset;
         self
     }
-    pub fn max_vertex_input_binding_stride(
-        mut self,
-        max_vertex_input_binding_stride: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_vertex_input_binding_stride(mut self, max_vertex_input_binding_stride: u32) -> Self {
         self.inner.max_vertex_input_binding_stride = max_vertex_input_binding_stride;
         self
     }
-    pub fn max_vertex_output_components(
-        mut self,
-        max_vertex_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_vertex_output_components(mut self, max_vertex_output_components: u32) -> Self {
         self.inner.max_vertex_output_components = max_vertex_output_components;
         self
     }
     pub fn max_tessellation_generation_level(
         mut self,
         max_tessellation_generation_level: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_tessellation_generation_level = max_tessellation_generation_level;
         self
     }
-    pub fn max_tessellation_patch_size(
-        mut self,
-        max_tessellation_patch_size: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_tessellation_patch_size(mut self, max_tessellation_patch_size: u32) -> Self {
         self.inner.max_tessellation_patch_size = max_tessellation_patch_size;
         self
     }
     pub fn max_tessellation_control_per_vertex_input_components(
         mut self,
         max_tessellation_control_per_vertex_input_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_tessellation_control_per_vertex_input_components =
             max_tessellation_control_per_vertex_input_components;
         self
     }
     pub fn max_tessellation_control_per_vertex_output_components(
         mut self,
         max_tessellation_control_per_vertex_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_tessellation_control_per_vertex_output_components =
             max_tessellation_control_per_vertex_output_components;
         self
     }
     pub fn max_tessellation_control_per_patch_output_components(
         mut self,
         max_tessellation_control_per_patch_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_tessellation_control_per_patch_output_components =
             max_tessellation_control_per_patch_output_components;
         self
     }
     pub fn max_tessellation_control_total_output_components(
         mut self,
         max_tessellation_control_total_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_tessellation_control_total_output_components =
             max_tessellation_control_total_output_components;
         self
     }
     pub fn max_tessellation_evaluation_input_components(
         mut self,
         max_tessellation_evaluation_input_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_tessellation_evaluation_input_components =
             max_tessellation_evaluation_input_components;
         self
     }
     pub fn max_tessellation_evaluation_output_components(
         mut self,
         max_tessellation_evaluation_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_tessellation_evaluation_output_components =
             max_tessellation_evaluation_output_components;
         self
     }
-    pub fn max_geometry_shader_invocations(
-        mut self,
-        max_geometry_shader_invocations: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_geometry_shader_invocations(mut self, max_geometry_shader_invocations: u32) -> Self {
         self.inner.max_geometry_shader_invocations = max_geometry_shader_invocations;
         self
     }
-    pub fn max_geometry_input_components(
-        mut self,
-        max_geometry_input_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_geometry_input_components(mut self, max_geometry_input_components: u32) -> Self {
         self.inner.max_geometry_input_components = max_geometry_input_components;
         self
     }
-    pub fn max_geometry_output_components(
-        mut self,
-        max_geometry_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_geometry_output_components(mut self, max_geometry_output_components: u32) -> Self {
         self.inner.max_geometry_output_components = max_geometry_output_components;
         self
     }
-    pub fn max_geometry_output_vertices(
-        mut self,
-        max_geometry_output_vertices: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_geometry_output_vertices(mut self, max_geometry_output_vertices: u32) -> Self {
         self.inner.max_geometry_output_vertices = max_geometry_output_vertices;
         self
     }
     pub fn max_geometry_total_output_components(
         mut self,
         max_geometry_total_output_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_geometry_total_output_components = max_geometry_total_output_components;
         self
     }
-    pub fn max_fragment_input_components(
-        mut self,
-        max_fragment_input_components: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_fragment_input_components(mut self, max_fragment_input_components: u32) -> Self {
         self.inner.max_fragment_input_components = max_fragment_input_components;
         self
     }
-    pub fn max_fragment_output_attachments(
-        mut self,
-        max_fragment_output_attachments: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_fragment_output_attachments(mut self, max_fragment_output_attachments: u32) -> Self {
         self.inner.max_fragment_output_attachments = max_fragment_output_attachments;
         self
     }
     pub fn max_fragment_dual_src_attachments(
         mut self,
         max_fragment_dual_src_attachments: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_dual_src_attachments = max_fragment_dual_src_attachments;
         self
     }
     pub fn max_fragment_combined_output_resources(
         mut self,
         max_fragment_combined_output_resources: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_combined_output_resources = max_fragment_combined_output_resources;
         self
     }
-    pub fn max_compute_shared_memory_size(
-        mut self,
-        max_compute_shared_memory_size: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_compute_shared_memory_size(mut self, max_compute_shared_memory_size: u32) -> Self {
         self.inner.max_compute_shared_memory_size = max_compute_shared_memory_size;
         self
     }
-    pub fn max_compute_work_group_count(
-        mut self,
-        max_compute_work_group_count: [u32; 3],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_compute_work_group_count(mut self, max_compute_work_group_count: [u32; 3]) -> Self {
         self.inner.max_compute_work_group_count = max_compute_work_group_count;
         self
     }
     pub fn max_compute_work_group_invocations(
         mut self,
         max_compute_work_group_invocations: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_compute_work_group_invocations = max_compute_work_group_invocations;
         self
     }
-    pub fn max_compute_work_group_size(
-        mut self,
-        max_compute_work_group_size: [u32; 3],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_compute_work_group_size(mut self, max_compute_work_group_size: [u32; 3]) -> Self {
         self.inner.max_compute_work_group_size = max_compute_work_group_size;
         self
     }
-    pub fn sub_pixel_precision_bits(
-        mut self,
-        sub_pixel_precision_bits: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn sub_pixel_precision_bits(mut self, sub_pixel_precision_bits: u32) -> Self {
         self.inner.sub_pixel_precision_bits = sub_pixel_precision_bits;
         self
     }
-    pub fn sub_texel_precision_bits(
-        mut self,
-        sub_texel_precision_bits: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn sub_texel_precision_bits(mut self, sub_texel_precision_bits: u32) -> Self {
         self.inner.sub_texel_precision_bits = sub_texel_precision_bits;
         self
     }
-    pub fn mipmap_precision_bits(
-        mut self,
-        mipmap_precision_bits: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn mipmap_precision_bits(mut self, mipmap_precision_bits: u32) -> Self {
         self.inner.mipmap_precision_bits = mipmap_precision_bits;
         self
     }
-    pub fn max_draw_indexed_index_value(
-        mut self,
-        max_draw_indexed_index_value: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_draw_indexed_index_value(mut self, max_draw_indexed_index_value: u32) -> Self {
         self.inner.max_draw_indexed_index_value = max_draw_indexed_index_value;
         self
     }
-    pub fn max_draw_indirect_count(
-        mut self,
-        max_draw_indirect_count: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_draw_indirect_count(mut self, max_draw_indirect_count: u32) -> Self {
         self.inner.max_draw_indirect_count = max_draw_indirect_count;
         self
     }
-    pub fn max_sampler_lod_bias(
-        mut self,
-        max_sampler_lod_bias: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_sampler_lod_bias(mut self, max_sampler_lod_bias: f32) -> Self {
         self.inner.max_sampler_lod_bias = max_sampler_lod_bias;
         self
     }
-    pub fn max_sampler_anisotropy(
-        mut self,
-        max_sampler_anisotropy: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_sampler_anisotropy(mut self, max_sampler_anisotropy: f32) -> Self {
         self.inner.max_sampler_anisotropy = max_sampler_anisotropy;
         self
     }
-    pub fn max_viewports(mut self, max_viewports: u32) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_viewports(mut self, max_viewports: u32) -> Self {
         self.inner.max_viewports = max_viewports;
         self
     }
-    pub fn max_viewport_dimensions(
-        mut self,
-        max_viewport_dimensions: [u32; 2],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_viewport_dimensions(mut self, max_viewport_dimensions: [u32; 2]) -> Self {
         self.inner.max_viewport_dimensions = max_viewport_dimensions;
         self
     }
-    pub fn viewport_bounds_range(
-        mut self,
-        viewport_bounds_range: [f32; 2],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn viewport_bounds_range(mut self, viewport_bounds_range: [f32; 2]) -> Self {
         self.inner.viewport_bounds_range = viewport_bounds_range;
         self
     }
-    pub fn viewport_sub_pixel_bits(
-        mut self,
-        viewport_sub_pixel_bits: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn viewport_sub_pixel_bits(mut self, viewport_sub_pixel_bits: u32) -> Self {
         self.inner.viewport_sub_pixel_bits = viewport_sub_pixel_bits;
         self
     }
-    pub fn min_memory_map_alignment(
-        mut self,
-        min_memory_map_alignment: usize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn min_memory_map_alignment(mut self, min_memory_map_alignment: usize) -> Self {
         self.inner.min_memory_map_alignment = min_memory_map_alignment;
         self
     }
     pub fn min_texel_buffer_offset_alignment(
         mut self,
         min_texel_buffer_offset_alignment: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.min_texel_buffer_offset_alignment = min_texel_buffer_offset_alignment;
         self
     }
     pub fn min_uniform_buffer_offset_alignment(
         mut self,
         min_uniform_buffer_offset_alignment: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.min_uniform_buffer_offset_alignment = min_uniform_buffer_offset_alignment;
         self
     }
     pub fn min_storage_buffer_offset_alignment(
         mut self,
         min_storage_buffer_offset_alignment: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.min_storage_buffer_offset_alignment = min_storage_buffer_offset_alignment;
         self
     }
-    pub fn min_texel_offset(mut self, min_texel_offset: i32) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn min_texel_offset(mut self, min_texel_offset: i32) -> Self {
         self.inner.min_texel_offset = min_texel_offset;
         self
     }
-    pub fn max_texel_offset(mut self, max_texel_offset: u32) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_texel_offset(mut self, max_texel_offset: u32) -> Self {
         self.inner.max_texel_offset = max_texel_offset;
         self
     }
-    pub fn min_texel_gather_offset(
-        mut self,
-        min_texel_gather_offset: i32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn min_texel_gather_offset(mut self, min_texel_gather_offset: i32) -> Self {
         self.inner.min_texel_gather_offset = min_texel_gather_offset;
         self
     }
-    pub fn max_texel_gather_offset(
-        mut self,
-        max_texel_gather_offset: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_texel_gather_offset(mut self, max_texel_gather_offset: u32) -> Self {
         self.inner.max_texel_gather_offset = max_texel_gather_offset;
         self
     }
-    pub fn min_interpolation_offset(
-        mut self,
-        min_interpolation_offset: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn min_interpolation_offset(mut self, min_interpolation_offset: f32) -> Self {
         self.inner.min_interpolation_offset = min_interpolation_offset;
         self
     }
-    pub fn max_interpolation_offset(
-        mut self,
-        max_interpolation_offset: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_interpolation_offset(mut self, max_interpolation_offset: f32) -> Self {
         self.inner.max_interpolation_offset = max_interpolation_offset;
         self
     }
     pub fn sub_pixel_interpolation_offset_bits(
         mut self,
         sub_pixel_interpolation_offset_bits: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.sub_pixel_interpolation_offset_bits = sub_pixel_interpolation_offset_bits;
         self
     }
-    pub fn max_framebuffer_width(
-        mut self,
-        max_framebuffer_width: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_framebuffer_width(mut self, max_framebuffer_width: u32) -> Self {
         self.inner.max_framebuffer_width = max_framebuffer_width;
         self
     }
-    pub fn max_framebuffer_height(
-        mut self,
-        max_framebuffer_height: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_framebuffer_height(mut self, max_framebuffer_height: u32) -> Self {
         self.inner.max_framebuffer_height = max_framebuffer_height;
         self
     }
-    pub fn max_framebuffer_layers(
-        mut self,
-        max_framebuffer_layers: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_framebuffer_layers(mut self, max_framebuffer_layers: u32) -> Self {
         self.inner.max_framebuffer_layers = max_framebuffer_layers;
         self
     }
     pub fn framebuffer_color_sample_counts(
         mut self,
         framebuffer_color_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.framebuffer_color_sample_counts = framebuffer_color_sample_counts;
         self
     }
     pub fn framebuffer_depth_sample_counts(
         mut self,
         framebuffer_depth_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.framebuffer_depth_sample_counts = framebuffer_depth_sample_counts;
         self
     }
     pub fn framebuffer_stencil_sample_counts(
         mut self,
         framebuffer_stencil_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.framebuffer_stencil_sample_counts = framebuffer_stencil_sample_counts;
         self
     }
     pub fn framebuffer_no_attachments_sample_counts(
         mut self,
         framebuffer_no_attachments_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.framebuffer_no_attachments_sample_counts =
             framebuffer_no_attachments_sample_counts;
         self
     }
-    pub fn max_color_attachments(
-        mut self,
-        max_color_attachments: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_color_attachments(mut self, max_color_attachments: u32) -> Self {
         self.inner.max_color_attachments = max_color_attachments;
         self
     }
     pub fn sampled_image_color_sample_counts(
         mut self,
         sampled_image_color_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.sampled_image_color_sample_counts = sampled_image_color_sample_counts;
         self
     }
     pub fn sampled_image_integer_sample_counts(
         mut self,
         sampled_image_integer_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.sampled_image_integer_sample_counts = sampled_image_integer_sample_counts;
         self
     }
     pub fn sampled_image_depth_sample_counts(
         mut self,
         sampled_image_depth_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.sampled_image_depth_sample_counts = sampled_image_depth_sample_counts;
         self
     }
     pub fn sampled_image_stencil_sample_counts(
         mut self,
         sampled_image_stencil_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.sampled_image_stencil_sample_counts = sampled_image_stencil_sample_counts;
         self
     }
     pub fn storage_image_sample_counts(
         mut self,
         storage_image_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.storage_image_sample_counts = storage_image_sample_counts;
         self
     }
-    pub fn max_sample_mask_words(
-        mut self,
-        max_sample_mask_words: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_sample_mask_words(mut self, max_sample_mask_words: u32) -> Self {
         self.inner.max_sample_mask_words = max_sample_mask_words;
         self
     }
-    pub fn timestamp_compute_and_graphics(
-        mut self,
-        timestamp_compute_and_graphics: bool,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn timestamp_compute_and_graphics(mut self, timestamp_compute_and_graphics: bool) -> Self {
         self.inner.timestamp_compute_and_graphics = timestamp_compute_and_graphics.into();
         self
     }
-    pub fn timestamp_period(mut self, timestamp_period: f32) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn timestamp_period(mut self, timestamp_period: f32) -> Self {
         self.inner.timestamp_period = timestamp_period;
         self
     }
-    pub fn max_clip_distances(
-        mut self,
-        max_clip_distances: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_clip_distances(mut self, max_clip_distances: u32) -> Self {
         self.inner.max_clip_distances = max_clip_distances;
         self
     }
-    pub fn max_cull_distances(
-        mut self,
-        max_cull_distances: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn max_cull_distances(mut self, max_cull_distances: u32) -> Self {
         self.inner.max_cull_distances = max_cull_distances;
         self
     }
     pub fn max_combined_clip_and_cull_distances(
         mut self,
         max_combined_clip_and_cull_distances: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.max_combined_clip_and_cull_distances = max_combined_clip_and_cull_distances;
         self
     }
-    pub fn discrete_queue_priorities(
-        mut self,
-        discrete_queue_priorities: u32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn discrete_queue_priorities(mut self, discrete_queue_priorities: u32) -> Self {
         self.inner.discrete_queue_priorities = discrete_queue_priorities;
         self
     }
-    pub fn point_size_range(
-        mut self,
-        point_size_range: [f32; 2],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn point_size_range(mut self, point_size_range: [f32; 2]) -> Self {
         self.inner.point_size_range = point_size_range;
         self
     }
-    pub fn line_width_range(
-        mut self,
-        line_width_range: [f32; 2],
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn line_width_range(mut self, line_width_range: [f32; 2]) -> Self {
         self.inner.line_width_range = line_width_range;
         self
     }
-    pub fn point_size_granularity(
-        mut self,
-        point_size_granularity: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn point_size_granularity(mut self, point_size_granularity: f32) -> Self {
         self.inner.point_size_granularity = point_size_granularity;
         self
     }
-    pub fn line_width_granularity(
-        mut self,
-        line_width_granularity: f32,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn line_width_granularity(mut self, line_width_granularity: f32) -> Self {
         self.inner.line_width_granularity = line_width_granularity;
         self
     }
-    pub fn strict_lines(mut self, strict_lines: bool) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn strict_lines(mut self, strict_lines: bool) -> Self {
         self.inner.strict_lines = strict_lines.into();
         self
     }
-    pub fn standard_sample_locations(
-        mut self,
-        standard_sample_locations: bool,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn standard_sample_locations(mut self, standard_sample_locations: bool) -> Self {
         self.inner.standard_sample_locations = standard_sample_locations.into();
         self
     }
     pub fn optimal_buffer_copy_offset_alignment(
         mut self,
         optimal_buffer_copy_offset_alignment: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.optimal_buffer_copy_offset_alignment = optimal_buffer_copy_offset_alignment;
         self
     }
     pub fn optimal_buffer_copy_row_pitch_alignment(
         mut self,
         optimal_buffer_copy_row_pitch_alignment: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    ) -> Self {
         self.inner.optimal_buffer_copy_row_pitch_alignment =
             optimal_buffer_copy_row_pitch_alignment;
         self
     }
-    pub fn non_coherent_atom_size(
-        mut self,
-        non_coherent_atom_size: DeviceSize,
-    ) -> PhysicalDeviceLimitsBuilder<'a> {
+    pub fn non_coherent_atom_size(mut self, non_coherent_atom_size: DeviceSize) -> Self {
         self.inner.non_coherent_atom_size = non_coherent_atom_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceLimits {
         self.inner
@@ -9993,29 +9023,26 @@ impl<'a> ::std::ops::Deref for Semaphore
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: SemaphoreCreateFlags) -> SemaphoreCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSemaphoreCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SemaphoreCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: SemaphoreCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsSemaphoreCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -10070,44 +9097,38 @@ impl<'a> ::std::ops::Deref for QueryPool
     }
 }
 impl<'a> ::std::ops::DerefMut for QueryPoolCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueryPoolCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: QueryPoolCreateFlags) -> QueryPoolCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn query_type(mut self, query_type: QueryType) -> QueryPoolCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: QueryPoolCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn query_type(mut self, query_type: QueryType) -> Self {
         self.inner.query_type = query_type;
         self
     }
-    pub fn query_count(mut self, query_count: u32) -> QueryPoolCreateInfoBuilder<'a> {
+    pub fn query_count(mut self, query_count: u32) -> Self {
         self.inner.query_count = query_count;
         self
     }
-    pub fn pipeline_statistics(
-        mut self,
-        pipeline_statistics: QueryPipelineStatisticFlags,
-    ) -> QueryPoolCreateInfoBuilder<'a> {
+    pub fn pipeline_statistics(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> Self {
         self.inner.pipeline_statistics = pipeline_statistics;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsQueryPoolCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> QueryPoolCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsQueryPoolCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -10168,50 +9189,47 @@ impl<'a> ::std::ops::Deref for Framebuff
     }
 }
 impl<'a> ::std::ops::DerefMut for FramebufferCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FramebufferCreateInfoBuilder<'a> {
-    pub fn flags(mut self, flags: FramebufferCreateFlags) -> FramebufferCreateInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn render_pass(mut self, render_pass: RenderPass) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: FramebufferCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
         self.inner.render_pass = render_pass;
         self
     }
-    pub fn attachments(mut self, attachments: &'a [ImageView]) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
         self.inner.attachment_count = attachments.len() as _;
         self.inner.p_attachments = attachments.as_ptr();
         self
     }
-    pub fn width(mut self, width: u32) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn width(mut self, width: u32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: u32) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn height(mut self, height: u32) -> Self {
         self.inner.height = height;
         self
     }
-    pub fn layers(mut self, layers: u32) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn layers(mut self, layers: u32) -> Self {
         self.inner.layers = layers;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFramebufferCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> FramebufferCreateInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsFramebufferCreateInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -10251,29 +9269,29 @@ impl<'a> ::std::ops::Deref for DrawIndir
     }
 }
 impl<'a> ::std::ops::DerefMut for DrawIndirectCommandBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DrawIndirectCommandBuilder<'a> {
-    pub fn vertex_count(mut self, vertex_count: u32) -> DrawIndirectCommandBuilder<'a> {
+    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
         self.inner.vertex_count = vertex_count;
         self
     }
-    pub fn instance_count(mut self, instance_count: u32) -> DrawIndirectCommandBuilder<'a> {
+    pub fn instance_count(mut self, instance_count: u32) -> Self {
         self.inner.instance_count = instance_count;
         self
     }
-    pub fn first_vertex(mut self, first_vertex: u32) -> DrawIndirectCommandBuilder<'a> {
+    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
         self.inner.first_vertex = first_vertex;
         self
     }
-    pub fn first_instance(mut self, first_instance: u32) -> DrawIndirectCommandBuilder<'a> {
+    pub fn first_instance(mut self, first_instance: u32) -> Self {
         self.inner.first_instance = first_instance;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DrawIndirectCommand {
         self.inner
@@ -10309,33 +9327,33 @@ impl<'a> ::std::ops::Deref for DrawIndex
     }
 }
 impl<'a> ::std::ops::DerefMut for DrawIndexedIndirectCommandBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DrawIndexedIndirectCommandBuilder<'a> {
-    pub fn index_count(mut self, index_count: u32) -> DrawIndexedIndirectCommandBuilder<'a> {
+    pub fn index_count(mut self, index_count: u32) -> Self {
         self.inner.index_count = index_count;
         self
     }
-    pub fn instance_count(mut self, instance_count: u32) -> DrawIndexedIndirectCommandBuilder<'a> {
+    pub fn instance_count(mut self, instance_count: u32) -> Self {
         self.inner.instance_count = instance_count;
         self
     }
-    pub fn first_index(mut self, first_index: u32) -> DrawIndexedIndirectCommandBuilder<'a> {
+    pub fn first_index(mut self, first_index: u32) -> Self {
         self.inner.first_index = first_index;
         self
     }
-    pub fn vertex_offset(mut self, vertex_offset: i32) -> DrawIndexedIndirectCommandBuilder<'a> {
+    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
         self.inner.vertex_offset = vertex_offset;
         self
     }
-    pub fn first_instance(mut self, first_instance: u32) -> DrawIndexedIndirectCommandBuilder<'a> {
+    pub fn first_instance(mut self, first_instance: u32) -> Self {
         self.inner.first_instance = first_instance;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DrawIndexedIndirectCommand {
         self.inner
@@ -10369,36 +9387,135 @@ impl<'a> ::std::ops::Deref for DispatchI
     }
 }
 impl<'a> ::std::ops::DerefMut for DispatchIndirectCommandBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DispatchIndirectCommandBuilder<'a> {
-    pub fn x(mut self, x: u32) -> DispatchIndirectCommandBuilder<'a> {
+    pub fn x(mut self, x: u32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: u32) -> DispatchIndirectCommandBuilder<'a> {
+    pub fn y(mut self, y: u32) -> Self {
         self.inner.y = y;
         self
     }
-    pub fn z(mut self, z: u32) -> DispatchIndirectCommandBuilder<'a> {
+    pub fn z(mut self, z: u32) -> Self {
         self.inner.z = z;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DispatchIndirectCommand {
         self.inner
     }
 }
 #[repr(C)]
+#[derive(Copy, Clone, Default, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMultiDrawInfoEXT.html>"]
+pub struct MultiDrawInfoEXT {
+    pub first_vertex: u32,
+    pub vertex_count: u32,
+}
+impl MultiDrawInfoEXT {
+    pub fn builder<'a>() -> MultiDrawInfoEXTBuilder<'a> {
+        MultiDrawInfoEXTBuilder {
+            inner: MultiDrawInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MultiDrawInfoEXTBuilder<'a> {
+    inner: MultiDrawInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for MultiDrawInfoEXTBuilder<'a> {
+    type Target = MultiDrawInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MultiDrawInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MultiDrawInfoEXTBuilder<'a> {
+    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
+        self.inner.first_vertex = first_vertex;
+        self
+    }
+    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
+        self.inner.vertex_count = vertex_count;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MultiDrawInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Default, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMultiDrawIndexedInfoEXT.html>"]
+pub struct MultiDrawIndexedInfoEXT {
+    pub first_index: u32,
+    pub index_count: u32,
+    pub vertex_offset: i32,
+}
+impl MultiDrawIndexedInfoEXT {
+    pub fn builder<'a>() -> MultiDrawIndexedInfoEXTBuilder<'a> {
+        MultiDrawIndexedInfoEXTBuilder {
+            inner: MultiDrawIndexedInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MultiDrawIndexedInfoEXTBuilder<'a> {
+    inner: MultiDrawIndexedInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for MultiDrawIndexedInfoEXTBuilder<'a> {
+    type Target = MultiDrawIndexedInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MultiDrawIndexedInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MultiDrawIndexedInfoEXTBuilder<'a> {
+    pub fn first_index(mut self, first_index: u32) -> Self {
+        self.inner.first_index = first_index;
+        self
+    }
+    pub fn index_count(mut self, index_count: u32) -> Self {
+        self.inner.index_count = index_count;
+        self
+    }
+    pub fn vertex_offset(mut self, vertex_offset: i32) -> Self {
+        self.inner.vertex_offset = vertex_offset;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MultiDrawIndexedInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
 #[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubmitInfo.html>"]
 pub struct SubmitInfo {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub wait_semaphore_count: u32,
     pub p_wait_semaphores: *const Semaphore,
     pub p_wait_dst_stage_mask: *const PipelineStageFlags,
@@ -10443,51 +9560,42 @@ impl<'a> ::std::ops::Deref for SubmitInf
     }
 }
 impl<'a> ::std::ops::DerefMut for SubmitInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubmitInfoBuilder<'a> {
-    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> SubmitInfoBuilder<'a> {
+    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
         self.inner.wait_semaphore_count = wait_semaphores.len() as _;
         self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
         self
     }
-    pub fn wait_dst_stage_mask(
-        mut self,
-        wait_dst_stage_mask: &'a [PipelineStageFlags],
-    ) -> SubmitInfoBuilder<'a> {
+    pub fn wait_dst_stage_mask(mut self, wait_dst_stage_mask: &'a [PipelineStageFlags]) -> Self {
         self.inner.wait_semaphore_count = wait_dst_stage_mask.len() as _;
         self.inner.p_wait_dst_stage_mask = wait_dst_stage_mask.as_ptr();
         self
     }
-    pub fn command_buffers(
-        mut self,
-        command_buffers: &'a [CommandBuffer],
-    ) -> SubmitInfoBuilder<'a> {
+    pub fn command_buffers(mut self, command_buffers: &'a [CommandBuffer]) -> Self {
         self.inner.command_buffer_count = command_buffers.len() as _;
         self.inner.p_command_buffers = command_buffers.as_ptr();
         self
     }
-    pub fn signal_semaphores(
-        mut self,
-        signal_semaphores: &'a [Semaphore],
-    ) -> SubmitInfoBuilder<'a> {
+    pub fn signal_semaphores(mut self, signal_semaphores: &'a [Semaphore]) -> Self {
         self.inner.signal_semaphore_count = signal_semaphores.len() as _;
         self.inner.p_signal_semaphores = signal_semaphores.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSubmitInfo>(mut self, next: &'a mut T) -> SubmitInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsSubmitInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -10543,59 +9651,41 @@ impl<'a> ::std::ops::Deref for DisplayPr
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPropertiesKHRBuilder<'a> {
-    pub fn display(mut self, display: DisplayKHR) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn display(mut self, display: DisplayKHR) -> Self {
         self.inner.display = display;
         self
     }
-    pub fn display_name(
-        mut self,
-        display_name: &'a ::std::ffi::CStr,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn display_name(mut self, display_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.display_name = display_name.as_ptr();
         self
     }
-    pub fn physical_dimensions(
-        mut self,
-        physical_dimensions: Extent2D,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn physical_dimensions(mut self, physical_dimensions: Extent2D) -> Self {
         self.inner.physical_dimensions = physical_dimensions;
         self
     }
-    pub fn physical_resolution(
-        mut self,
-        physical_resolution: Extent2D,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn physical_resolution(mut self, physical_resolution: Extent2D) -> Self {
         self.inner.physical_resolution = physical_resolution;
         self
     }
-    pub fn supported_transforms(
-        mut self,
-        supported_transforms: SurfaceTransformFlagsKHR,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
         self.inner.supported_transforms = supported_transforms;
         self
     }
-    pub fn plane_reorder_possible(
-        mut self,
-        plane_reorder_possible: bool,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn plane_reorder_possible(mut self, plane_reorder_possible: bool) -> Self {
         self.inner.plane_reorder_possible = plane_reorder_possible.into();
         self
     }
-    pub fn persistent_content(
-        mut self,
-        persistent_content: bool,
-    ) -> DisplayPropertiesKHRBuilder<'a> {
+    pub fn persistent_content(mut self, persistent_content: bool) -> Self {
         self.inner.persistent_content = persistent_content.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPropertiesKHR {
         self.inner
@@ -10628,27 +9718,21 @@ impl<'a> ::std::ops::Deref for DisplayPl
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPlanePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPlanePropertiesKHRBuilder<'a> {
-    pub fn current_display(
-        mut self,
-        current_display: DisplayKHR,
-    ) -> DisplayPlanePropertiesKHRBuilder<'a> {
+    pub fn current_display(mut self, current_display: DisplayKHR) -> Self {
         self.inner.current_display = current_display;
         self
     }
-    pub fn current_stack_index(
-        mut self,
-        current_stack_index: u32,
-    ) -> DisplayPlanePropertiesKHRBuilder<'a> {
+    pub fn current_stack_index(mut self, current_stack_index: u32) -> Self {
         self.inner.current_stack_index = current_stack_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPlanePropertiesKHR {
         self.inner
@@ -10681,24 +9765,21 @@ impl<'a> ::std::ops::Deref for DisplayMo
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayModeParametersKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayModeParametersKHRBuilder<'a> {
-    pub fn visible_region(
-        mut self,
-        visible_region: Extent2D,
-    ) -> DisplayModeParametersKHRBuilder<'a> {
+    pub fn visible_region(mut self, visible_region: Extent2D) -> Self {
         self.inner.visible_region = visible_region;
         self
     }
-    pub fn refresh_rate(mut self, refresh_rate: u32) -> DisplayModeParametersKHRBuilder<'a> {
+    pub fn refresh_rate(mut self, refresh_rate: u32) -> Self {
         self.inner.refresh_rate = refresh_rate;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayModeParametersKHR {
         self.inner
@@ -10731,27 +9812,21 @@ impl<'a> ::std::ops::Deref for DisplayMo
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayModePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayModePropertiesKHRBuilder<'a> {
-    pub fn display_mode(
-        mut self,
-        display_mode: DisplayModeKHR,
-    ) -> DisplayModePropertiesKHRBuilder<'a> {
+    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
         self.inner.display_mode = display_mode;
         self
     }
-    pub fn parameters(
-        mut self,
-        parameters: DisplayModeParametersKHR,
-    ) -> DisplayModePropertiesKHRBuilder<'a> {
+    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
         self.inner.parameters = parameters;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayModePropertiesKHR {
         self.inner
@@ -10784,60 +9859,36 @@ impl DisplayModeCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayModeCreateInfoKHRBuilder<'a> {
     inner: DisplayModeCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayModeCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for DisplayModeCreateInfoKHRBuilder<'a> {
     type Target = DisplayModeCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayModeCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayModeCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DisplayModeCreateFlagsKHR,
-    ) -> DisplayModeCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn parameters(
-        mut self,
-        parameters: DisplayModeParametersKHR,
-    ) -> DisplayModeCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: DisplayModeCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn parameters(mut self, parameters: DisplayModeParametersKHR) -> Self {
         self.inner.parameters = parameters;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayModeCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayModeCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayModeCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -10874,76 +9925,49 @@ impl<'a> ::std::ops::Deref for DisplayPl
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPlaneCapabilitiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPlaneCapabilitiesKHRBuilder<'a> {
-    pub fn supported_alpha(
-        mut self,
-        supported_alpha: DisplayPlaneAlphaFlagsKHR,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn supported_alpha(mut self, supported_alpha: DisplayPlaneAlphaFlagsKHR) -> Self {
         self.inner.supported_alpha = supported_alpha;
         self
     }
-    pub fn min_src_position(
-        mut self,
-        min_src_position: Offset2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn min_src_position(mut self, min_src_position: Offset2D) -> Self {
         self.inner.min_src_position = min_src_position;
         self
     }
-    pub fn max_src_position(
-        mut self,
-        max_src_position: Offset2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn max_src_position(mut self, max_src_position: Offset2D) -> Self {
         self.inner.max_src_position = max_src_position;
         self
     }
-    pub fn min_src_extent(
-        mut self,
-        min_src_extent: Extent2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn min_src_extent(mut self, min_src_extent: Extent2D) -> Self {
         self.inner.min_src_extent = min_src_extent;
         self
     }
-    pub fn max_src_extent(
-        mut self,
-        max_src_extent: Extent2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn max_src_extent(mut self, max_src_extent: Extent2D) -> Self {
         self.inner.max_src_extent = max_src_extent;
         self
     }
-    pub fn min_dst_position(
-        mut self,
-        min_dst_position: Offset2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn min_dst_position(mut self, min_dst_position: Offset2D) -> Self {
         self.inner.min_dst_position = min_dst_position;
         self
     }
-    pub fn max_dst_position(
-        mut self,
-        max_dst_position: Offset2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn max_dst_position(mut self, max_dst_position: Offset2D) -> Self {
         self.inner.max_dst_position = max_dst_position;
         self
     }
-    pub fn min_dst_extent(
-        mut self,
-        min_dst_extent: Extent2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn min_dst_extent(mut self, min_dst_extent: Extent2D) -> Self {
         self.inner.min_dst_extent = min_dst_extent;
         self
     }
-    pub fn max_dst_extent(
-        mut self,
-        max_dst_extent: Extent2D,
-    ) -> DisplayPlaneCapabilitiesKHRBuilder<'a> {
+    pub fn max_dst_extent(mut self, max_dst_extent: Extent2D) -> Self {
         self.inner.max_dst_extent = max_dst_extent;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPlaneCapabilitiesKHR {
         self.inner
@@ -10988,96 +10012,60 @@ impl DisplaySurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplaySurfaceCreateInfoKHRBuilder<'a> {
     inner: DisplaySurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplaySurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for DisplaySurfaceCreateInfoKHRBuilder<'a> {
     type Target = DisplaySurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplaySurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplaySurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DisplaySurfaceCreateFlagsKHR,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn display_mode(
-        mut self,
-        display_mode: DisplayModeKHR,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: DisplaySurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn display_mode(mut self, display_mode: DisplayModeKHR) -> Self {
         self.inner.display_mode = display_mode;
         self
     }
-    pub fn plane_index(mut self, plane_index: u32) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn plane_index(mut self, plane_index: u32) -> Self {
         self.inner.plane_index = plane_index;
         self
     }
-    pub fn plane_stack_index(
-        mut self,
-        plane_stack_index: u32,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn plane_stack_index(mut self, plane_stack_index: u32) -> Self {
         self.inner.plane_stack_index = plane_stack_index;
         self
     }
-    pub fn transform(
-        mut self,
-        transform: SurfaceTransformFlagsKHR,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.transform = transform;
         self
     }
-    pub fn global_alpha(mut self, global_alpha: f32) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn global_alpha(mut self, global_alpha: f32) -> Self {
         self.inner.global_alpha = global_alpha;
         self
     }
-    pub fn alpha_mode(
-        mut self,
-        alpha_mode: DisplayPlaneAlphaFlagsKHR,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn alpha_mode(mut self, alpha_mode: DisplayPlaneAlphaFlagsKHR) -> Self {
         self.inner.alpha_mode = alpha_mode;
         self
     }
-    pub fn image_extent(
-        mut self,
-        image_extent: Extent2D,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
+    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
         self.inner.image_extent = image_extent;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplaySurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplaySurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplaySurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11123,25 +10111,25 @@ impl<'a> ::std::ops::Deref for DisplayPr
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPresentInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPresentInfoKHRBuilder<'a> {
-    pub fn src_rect(mut self, src_rect: Rect2D) -> DisplayPresentInfoKHRBuilder<'a> {
+    pub fn src_rect(mut self, src_rect: Rect2D) -> Self {
         self.inner.src_rect = src_rect;
         self
     }
-    pub fn dst_rect(mut self, dst_rect: Rect2D) -> DisplayPresentInfoKHRBuilder<'a> {
+    pub fn dst_rect(mut self, dst_rect: Rect2D) -> Self {
         self.inner.dst_rect = dst_rect;
         self
     }
-    pub fn persistent(mut self, persistent: bool) -> DisplayPresentInfoKHRBuilder<'a> {
+    pub fn persistent(mut self, persistent: bool) -> Self {
         self.inner.persistent = persistent.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPresentInfoKHR {
         self.inner
@@ -11182,74 +10170,56 @@ impl<'a> ::std::ops::Deref for SurfaceCa
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceCapabilitiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceCapabilitiesKHRBuilder<'a> {
-    pub fn min_image_count(mut self, min_image_count: u32) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
         self.inner.min_image_count = min_image_count;
         self
     }
-    pub fn max_image_count(mut self, max_image_count: u32) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
         self.inner.max_image_count = max_image_count;
         self
     }
-    pub fn current_extent(mut self, current_extent: Extent2D) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
         self.inner.current_extent = current_extent;
         self
     }
-    pub fn min_image_extent(
-        mut self,
-        min_image_extent: Extent2D,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
         self.inner.min_image_extent = min_image_extent;
         self
     }
-    pub fn max_image_extent(
-        mut self,
-        max_image_extent: Extent2D,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
         self.inner.max_image_extent = max_image_extent;
         self
     }
-    pub fn max_image_array_layers(
-        mut self,
-        max_image_array_layers: u32,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
         self.inner.max_image_array_layers = max_image_array_layers;
         self
     }
-    pub fn supported_transforms(
-        mut self,
-        supported_transforms: SurfaceTransformFlagsKHR,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
         self.inner.supported_transforms = supported_transforms;
         self
     }
-    pub fn current_transform(
-        mut self,
-        current_transform: SurfaceTransformFlagsKHR,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.current_transform = current_transform;
         self
     }
     pub fn supported_composite_alpha(
         mut self,
         supported_composite_alpha: CompositeAlphaFlagsKHR,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.supported_composite_alpha = supported_composite_alpha;
         self
     }
-    pub fn supported_usage_flags(
-        mut self,
-        supported_usage_flags: ImageUsageFlags,
-    ) -> SurfaceCapabilitiesKHRBuilder<'a> {
+    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
         self.inner.supported_usage_flags = supported_usage_flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceCapabilitiesKHR {
         self.inner
@@ -11282,57 +10252,36 @@ impl AndroidSurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct AndroidSurfaceCreateInfoKHRBuilder<'a> {
     inner: AndroidSurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAndroidSurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for AndroidSurfaceCreateInfoKHRBuilder<'a> {
     type Target = AndroidSurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AndroidSurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AndroidSurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: AndroidSurfaceCreateFlagsKHR,
-    ) -> AndroidSurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn window(mut self, window: *mut ANativeWindow) -> AndroidSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: AndroidSurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn window(mut self, window: *mut ANativeWindow) -> Self {
         self.inner.window = window;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAndroidSurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AndroidSurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AndroidSurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11362,54 +10311,36 @@ impl ViSurfaceCreateInfoNN {
         }
     }
 }
 #[repr(transparent)]
 pub struct ViSurfaceCreateInfoNNBuilder<'a> {
     inner: ViSurfaceCreateInfoNN,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsViSurfaceCreateInfoNN {}
 impl<'a> ::std::ops::Deref for ViSurfaceCreateInfoNNBuilder<'a> {
     type Target = ViSurfaceCreateInfoNN;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ViSurfaceCreateInfoNNBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ViSurfaceCreateInfoNNBuilder<'a> {
-    pub fn flags(mut self, flags: ViSurfaceCreateFlagsNN) -> ViSurfaceCreateInfoNNBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn window(mut self, window: *mut c_void) -> ViSurfaceCreateInfoNNBuilder<'a> {
+    pub fn flags(mut self, flags: ViSurfaceCreateFlagsNN) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn window(mut self, window: *mut c_void) -> Self {
         self.inner.window = window;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsViSurfaceCreateInfoNN>(
-        mut self,
-        next: &'a mut T,
-    ) -> ViSurfaceCreateInfoNNBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ViSurfaceCreateInfoNN {
         self.inner
     }
 }
 #[repr(C)]
@@ -11441,61 +10372,40 @@ impl WaylandSurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct WaylandSurfaceCreateInfoKHRBuilder<'a> {
     inner: WaylandSurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsWaylandSurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for WaylandSurfaceCreateInfoKHRBuilder<'a> {
     type Target = WaylandSurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for WaylandSurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> WaylandSurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: WaylandSurfaceCreateFlagsKHR,
-    ) -> WaylandSurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn display(mut self, display: *mut wl_display) -> WaylandSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: WaylandSurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn display(mut self, display: *mut wl_display) -> Self {
         self.inner.display = display;
         self
     }
-    pub fn surface(mut self, surface: *mut wl_surface) -> WaylandSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn surface(mut self, surface: *mut wl_surface) -> Self {
         self.inner.surface = surface;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsWaylandSurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> WaylandSurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> WaylandSurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11527,61 +10437,40 @@ impl Win32SurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct Win32SurfaceCreateInfoKHRBuilder<'a> {
     inner: Win32SurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsWin32SurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for Win32SurfaceCreateInfoKHRBuilder<'a> {
     type Target = Win32SurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for Win32SurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Win32SurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: Win32SurfaceCreateFlagsKHR,
-    ) -> Win32SurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn hinstance(mut self, hinstance: HINSTANCE) -> Win32SurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: Win32SurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn hinstance(mut self, hinstance: HINSTANCE) -> Self {
         self.inner.hinstance = hinstance;
         self
     }
-    pub fn hwnd(mut self, hwnd: HWND) -> Win32SurfaceCreateInfoKHRBuilder<'a> {
+    pub fn hwnd(mut self, hwnd: HWND) -> Self {
         self.inner.hwnd = hwnd;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsWin32SurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> Win32SurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Win32SurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11613,61 +10502,40 @@ impl XlibSurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct XlibSurfaceCreateInfoKHRBuilder<'a> {
     inner: XlibSurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsXlibSurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for XlibSurfaceCreateInfoKHRBuilder<'a> {
     type Target = XlibSurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for XlibSurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> XlibSurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: XlibSurfaceCreateFlagsKHR,
-    ) -> XlibSurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn dpy(mut self, dpy: *mut Display) -> XlibSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: XlibSurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn dpy(mut self, dpy: *mut Display) -> Self {
         self.inner.dpy = dpy;
         self
     }
-    pub fn window(mut self, window: Window) -> XlibSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn window(mut self, window: Window) -> Self {
         self.inner.window = window;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsXlibSurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> XlibSurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> XlibSurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11699,61 +10567,40 @@ impl XcbSurfaceCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct XcbSurfaceCreateInfoKHRBuilder<'a> {
     inner: XcbSurfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsXcbSurfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for XcbSurfaceCreateInfoKHRBuilder<'a> {
     type Target = XcbSurfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for XcbSurfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> XcbSurfaceCreateInfoKHRBuilder<'a> {
-    pub fn flags(mut self, flags: XcbSurfaceCreateFlagsKHR) -> XcbSurfaceCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn connection(
-        mut self,
-        connection: *mut xcb_connection_t,
-    ) -> XcbSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: XcbSurfaceCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn connection(mut self, connection: *mut xcb_connection_t) -> Self {
         self.inner.connection = connection;
         self
     }
-    pub fn window(mut self, window: xcb_window_t) -> XcbSurfaceCreateInfoKHRBuilder<'a> {
+    pub fn window(mut self, window: xcb_window_t) -> Self {
         self.inner.window = window;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsXcbSurfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> XcbSurfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> XcbSurfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -11785,64 +10632,40 @@ impl DirectFBSurfaceCreateInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DirectFBSurfaceCreateInfoEXTBuilder<'a> {
     inner: DirectFBSurfaceCreateInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDirectFBSurfaceCreateInfoEXT {}
 impl<'a> ::std::ops::Deref for DirectFBSurfaceCreateInfoEXTBuilder<'a> {
     type Target = DirectFBSurfaceCreateInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DirectFBSurfaceCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DirectFBSurfaceCreateFlagsEXT,
-    ) -> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn dfb(mut self, dfb: *mut IDirectFB) -> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DirectFBSurfaceCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn dfb(mut self, dfb: *mut IDirectFB) -> Self {
         self.inner.dfb = dfb;
         self
     }
-    pub fn surface(
-        mut self,
-        surface: *mut IDirectFBSurface,
-    ) -> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
+    pub fn surface(mut self, surface: *mut IDirectFBSurface) -> Self {
         self.inner.surface = surface;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDirectFBSurfaceCreateInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DirectFBSurfaceCreateInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DirectFBSurfaceCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -11872,60 +10695,36 @@ impl ImagePipeSurfaceCreateInfoFUCHSIA {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
     inner: ImagePipeSurfaceCreateInfoFUCHSIA,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImagePipeSurfaceCreateInfoFUCHSIA {}
 impl<'a> ::std::ops::Deref for ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
     type Target = ImagePipeSurfaceCreateInfoFUCHSIA;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: ImagePipeSurfaceCreateFlagsFUCHSIA,
-    ) -> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn image_pipe_handle(
-        mut self,
-        image_pipe_handle: zx_handle_t,
-    ) -> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
+    pub fn flags(mut self, flags: ImagePipeSurfaceCreateFlagsFUCHSIA) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn image_pipe_handle(mut self, image_pipe_handle: zx_handle_t) -> Self {
         self.inner.image_pipe_handle = image_pipe_handle;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImagePipeSurfaceCreateInfoFUCHSIA>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImagePipeSurfaceCreateInfoFUCHSIABuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImagePipeSurfaceCreateInfoFUCHSIA {
         self.inner
     }
 }
 #[repr(C)]
@@ -11955,68 +10754,109 @@ impl StreamDescriptorSurfaceCreateInfoGG
         }
     }
 }
 #[repr(transparent)]
 pub struct StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
     inner: StreamDescriptorSurfaceCreateInfoGGP,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsStreamDescriptorSurfaceCreateInfoGGP {}
 impl<'a> ::std::ops::Deref for StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
     type Target = StreamDescriptorSurfaceCreateInfoGGP;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: StreamDescriptorSurfaceCreateFlagsGGP,
-    ) -> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stream_descriptor(
-        mut self,
-        stream_descriptor: GgpStreamDescriptor,
-    ) -> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
+    pub fn flags(mut self, flags: StreamDescriptorSurfaceCreateFlagsGGP) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stream_descriptor(mut self, stream_descriptor: GgpStreamDescriptor) -> Self {
         self.inner.stream_descriptor = stream_descriptor;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsStreamDescriptorSurfaceCreateInfoGGP>(
-        mut self,
-        next: &'a mut T,
-    ) -> StreamDescriptorSurfaceCreateInfoGGPBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> StreamDescriptorSurfaceCreateInfoGGP {
         self.inner
     }
 }
 #[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkScreenSurfaceCreateInfoQNX.html>"]
+pub struct ScreenSurfaceCreateInfoQNX {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: ScreenSurfaceCreateFlagsQNX,
+    pub context: *mut _screen_context,
+    pub window: *mut _screen_window,
+}
+impl ::std::default::Default for ScreenSurfaceCreateInfoQNX {
+    fn default() -> ScreenSurfaceCreateInfoQNX {
+        ScreenSurfaceCreateInfoQNX {
+            s_type: StructureType::SCREEN_SURFACE_CREATE_INFO_QNX,
+            p_next: ::std::ptr::null(),
+            flags: ScreenSurfaceCreateFlagsQNX::default(),
+            context: ::std::ptr::null_mut(),
+            window: ::std::ptr::null_mut(),
+        }
+    }
+}
+impl ScreenSurfaceCreateInfoQNX {
+    pub fn builder<'a>() -> ScreenSurfaceCreateInfoQNXBuilder<'a> {
+        ScreenSurfaceCreateInfoQNXBuilder {
+            inner: ScreenSurfaceCreateInfoQNX::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct ScreenSurfaceCreateInfoQNXBuilder<'a> {
+    inner: ScreenSurfaceCreateInfoQNX,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for ScreenSurfaceCreateInfoQNXBuilder<'a> {
+    type Target = ScreenSurfaceCreateInfoQNX;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for ScreenSurfaceCreateInfoQNXBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> ScreenSurfaceCreateInfoQNXBuilder<'a> {
+    pub fn flags(mut self, flags: ScreenSurfaceCreateFlagsQNX) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn context(mut self, context: &'a mut _screen_context) -> Self {
+        self.inner.context = context;
+        self
+    }
+    pub fn window(mut self, window: &'a mut _screen_window) -> Self {
+        self.inner.window = window;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> ScreenSurfaceCreateInfoQNX {
+        self.inner
+    }
+}
+#[repr(C)]
 #[derive(Copy, Clone, Default, Debug, PartialEq, Eq, Hash)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSurfaceFormatKHR.html>"]
 pub struct SurfaceFormatKHR {
     pub format: Format,
     pub color_space: ColorSpaceKHR,
 }
 impl SurfaceFormatKHR {
     pub fn builder<'a>() -> SurfaceFormatKHRBuilder<'a> {
@@ -12038,21 +10878,21 @@ impl<'a> ::std::ops::Deref for SurfaceFo
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceFormatKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceFormatKHRBuilder<'a> {
-    pub fn format(mut self, format: Format) -> SurfaceFormatKHRBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn color_space(mut self, color_space: ColorSpaceKHR) -> SurfaceFormatKHRBuilder<'a> {
+    pub fn color_space(mut self, color_space: ColorSpaceKHR) -> Self {
         self.inner.color_space = color_space;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceFormatKHR {
         self.inner
@@ -12126,113 +10966,83 @@ impl<'a> ::std::ops::Deref for Swapchain
     }
 }
 impl<'a> ::std::ops::DerefMut for SwapchainCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SwapchainCreateInfoKHRBuilder<'a> {
-    pub fn flags(mut self, flags: SwapchainCreateFlagsKHR) -> SwapchainCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn surface(mut self, surface: SurfaceKHR) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: SwapchainCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
         self.inner.surface = surface;
         self
     }
-    pub fn min_image_count(mut self, min_image_count: u32) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
         self.inner.min_image_count = min_image_count;
         self
     }
-    pub fn image_format(mut self, image_format: Format) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_format(mut self, image_format: Format) -> Self {
         self.inner.image_format = image_format;
         self
     }
-    pub fn image_color_space(
-        mut self,
-        image_color_space: ColorSpaceKHR,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_color_space(mut self, image_color_space: ColorSpaceKHR) -> Self {
         self.inner.image_color_space = image_color_space;
         self
     }
-    pub fn image_extent(mut self, image_extent: Extent2D) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_extent(mut self, image_extent: Extent2D) -> Self {
         self.inner.image_extent = image_extent;
         self
     }
-    pub fn image_array_layers(
-        mut self,
-        image_array_layers: u32,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_array_layers(mut self, image_array_layers: u32) -> Self {
         self.inner.image_array_layers = image_array_layers;
         self
     }
-    pub fn image_usage(
-        mut self,
-        image_usage: ImageUsageFlags,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
         self.inner.image_usage = image_usage;
         self
     }
-    pub fn image_sharing_mode(
-        mut self,
-        image_sharing_mode: SharingMode,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn image_sharing_mode(mut self, image_sharing_mode: SharingMode) -> Self {
         self.inner.image_sharing_mode = image_sharing_mode;
         self
     }
-    pub fn queue_family_indices(
-        mut self,
-        queue_family_indices: &'a [u32],
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
         self.inner.queue_family_index_count = queue_family_indices.len() as _;
         self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
         self
     }
-    pub fn pre_transform(
-        mut self,
-        pre_transform: SurfaceTransformFlagsKHR,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn pre_transform(mut self, pre_transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.pre_transform = pre_transform;
         self
     }
-    pub fn composite_alpha(
-        mut self,
-        composite_alpha: CompositeAlphaFlagsKHR,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn composite_alpha(mut self, composite_alpha: CompositeAlphaFlagsKHR) -> Self {
         self.inner.composite_alpha = composite_alpha;
         self
     }
-    pub fn present_mode(
-        mut self,
-        present_mode: PresentModeKHR,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn present_mode(mut self, present_mode: PresentModeKHR) -> Self {
         self.inner.present_mode = present_mode;
         self
     }
-    pub fn clipped(mut self, clipped: bool) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn clipped(mut self, clipped: bool) -> Self {
         self.inner.clipped = clipped.into();
         self
     }
-    pub fn old_swapchain(
-        mut self,
-        old_swapchain: SwapchainKHR,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn old_swapchain(mut self, old_swapchain: SwapchainKHR) -> Self {
         self.inner.old_swapchain = old_swapchain;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSwapchainCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> SwapchainCreateInfoKHRBuilder<'a> {
+    pub fn push_next<T: ExtendsSwapchainCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -12291,48 +11101,42 @@ impl<'a> ::std::ops::Deref for PresentIn
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentInfoKHRBuilder<'a> {
-    pub fn wait_semaphores(
-        mut self,
-        wait_semaphores: &'a [Semaphore],
-    ) -> PresentInfoKHRBuilder<'a> {
+    pub fn wait_semaphores(mut self, wait_semaphores: &'a [Semaphore]) -> Self {
         self.inner.wait_semaphore_count = wait_semaphores.len() as _;
         self.inner.p_wait_semaphores = wait_semaphores.as_ptr();
         self
     }
-    pub fn swapchains(mut self, swapchains: &'a [SwapchainKHR]) -> PresentInfoKHRBuilder<'a> {
+    pub fn swapchains(mut self, swapchains: &'a [SwapchainKHR]) -> Self {
         self.inner.swapchain_count = swapchains.len() as _;
         self.inner.p_swapchains = swapchains.as_ptr();
         self
     }
-    pub fn image_indices(mut self, image_indices: &'a [u32]) -> PresentInfoKHRBuilder<'a> {
+    pub fn image_indices(mut self, image_indices: &'a [u32]) -> Self {
         self.inner.swapchain_count = image_indices.len() as _;
         self.inner.p_image_indices = image_indices.as_ptr();
         self
     }
-    pub fn results(mut self, results: &'a mut [Result]) -> PresentInfoKHRBuilder<'a> {
+    pub fn results(mut self, results: &'a mut [Result]) -> Self {
         self.inner.swapchain_count = results.len() as _;
         self.inner.p_results = results.as_mut_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPresentInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PresentInfoKHRBuilder<'a> {
+    pub fn push_next<T: ExtendsPresentInfoKHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -12397,34 +11201,25 @@ impl<'a> ::std::ops::Deref for DebugRepo
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugReportCallbackCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugReportCallbackCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DebugReportFlagsEXT,
-    ) -> DebugReportCallbackCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn pfn_callback(
-        mut self,
-        pfn_callback: PFN_vkDebugReportCallbackEXT,
-    ) -> DebugReportCallbackCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DebugReportFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn pfn_callback(mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) -> Self {
         self.inner.pfn_callback = pfn_callback;
         self
     }
-    pub fn user_data(
-        mut self,
-        user_data: *mut c_void,
-    ) -> DebugReportCallbackCreateInfoEXTBuilder<'a> {
+    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
         self.inner.p_user_data = user_data;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugReportCallbackCreateInfoEXT {
         self.inner
@@ -12474,17 +11269,17 @@ impl<'a> ::std::ops::DerefMut for Valida
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ValidationFlagsEXTBuilder<'a> {
     pub fn disabled_validation_checks(
         mut self,
         disabled_validation_checks: &'a [ValidationCheckEXT],
-    ) -> ValidationFlagsEXTBuilder<'a> {
+    ) -> Self {
         self.inner.disabled_validation_check_count = disabled_validation_checks.len() as _;
         self.inner.p_disabled_validation_checks = disabled_validation_checks.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ValidationFlagsEXT {
@@ -12539,25 +11334,25 @@ impl<'a> ::std::ops::DerefMut for Valida
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ValidationFeaturesEXTBuilder<'a> {
     pub fn enabled_validation_features(
         mut self,
         enabled_validation_features: &'a [ValidationFeatureEnableEXT],
-    ) -> ValidationFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.enabled_validation_feature_count = enabled_validation_features.len() as _;
         self.inner.p_enabled_validation_features = enabled_validation_features.as_ptr();
         self
     }
     pub fn disabled_validation_features(
         mut self,
         disabled_validation_features: &'a [ValidationFeatureDisableEXT],
-    ) -> ValidationFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.disabled_validation_feature_count = disabled_validation_features.len() as _;
         self.inner.p_disabled_validation_features = disabled_validation_features.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ValidationFeaturesEXT {
@@ -12609,20 +11404,17 @@ impl<'a> ::std::ops::Deref for PipelineR
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
-    pub fn rasterization_order(
-        mut self,
-        rasterization_order: RasterizationOrderAMD,
-    ) -> PipelineRasterizationStateRasterizationOrderAMDBuilder<'a> {
+    pub fn rasterization_order(mut self, rasterization_order: RasterizationOrderAMD) -> Self {
         self.inner.rasterization_order = rasterization_order;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRasterizationStateRasterizationOrderAMD {
         self.inner
@@ -12657,64 +11449,40 @@ impl DebugMarkerObjectNameInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugMarkerObjectNameInfoEXTBuilder<'a> {
     inner: DebugMarkerObjectNameInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugMarkerObjectNameInfoEXT {}
 impl<'a> ::std::ops::Deref for DebugMarkerObjectNameInfoEXTBuilder<'a> {
     type Target = DebugMarkerObjectNameInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugMarkerObjectNameInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugMarkerObjectNameInfoEXTBuilder<'a> {
-    pub fn object_type(
-        mut self,
-        object_type: DebugReportObjectTypeEXT,
-    ) -> DebugMarkerObjectNameInfoEXTBuilder<'a> {
+    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
         self.inner.object_type = object_type;
         self
     }
-    pub fn object(mut self, object: u64) -> DebugMarkerObjectNameInfoEXTBuilder<'a> {
+    pub fn object(mut self, object: u64) -> Self {
         self.inner.object = object;
         self
     }
-    pub fn object_name(
-        mut self,
-        object_name: &'a ::std::ffi::CStr,
-    ) -> DebugMarkerObjectNameInfoEXTBuilder<'a> {
+    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_object_name = object_name.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugMarkerObjectNameInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugMarkerObjectNameInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugMarkerObjectNameInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -12750,66 +11518,45 @@ impl DebugMarkerObjectTagInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugMarkerObjectTagInfoEXTBuilder<'a> {
     inner: DebugMarkerObjectTagInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugMarkerObjectTagInfoEXT {}
 impl<'a> ::std::ops::Deref for DebugMarkerObjectTagInfoEXTBuilder<'a> {
     type Target = DebugMarkerObjectTagInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugMarkerObjectTagInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugMarkerObjectTagInfoEXTBuilder<'a> {
-    pub fn object_type(
-        mut self,
-        object_type: DebugReportObjectTypeEXT,
-    ) -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
+    pub fn object_type(mut self, object_type: DebugReportObjectTypeEXT) -> Self {
         self.inner.object_type = object_type;
         self
     }
-    pub fn object(mut self, object: u64) -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
+    pub fn object(mut self, object: u64) -> Self {
         self.inner.object = object;
         self
     }
-    pub fn tag_name(mut self, tag_name: u64) -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
+    pub fn tag_name(mut self, tag_name: u64) -> Self {
         self.inner.tag_name = tag_name;
         self
     }
-    pub fn tag(mut self, tag: &'a [u8]) -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
+    pub fn tag(mut self, tag: &'a [u8]) -> Self {
         self.inner.tag_size = tag.len() as _;
         self.inner.p_tag = tag.as_ptr() as *const c_void;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugMarkerObjectTagInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugMarkerObjectTagInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugMarkerObjectTagInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -12839,57 +11586,36 @@ impl DebugMarkerMarkerInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugMarkerMarkerInfoEXTBuilder<'a> {
     inner: DebugMarkerMarkerInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugMarkerMarkerInfoEXT {}
 impl<'a> ::std::ops::Deref for DebugMarkerMarkerInfoEXTBuilder<'a> {
     type Target = DebugMarkerMarkerInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugMarkerMarkerInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugMarkerMarkerInfoEXTBuilder<'a> {
-    pub fn marker_name(
-        mut self,
-        marker_name: &'a ::std::ffi::CStr,
-    ) -> DebugMarkerMarkerInfoEXTBuilder<'a> {
+    pub fn marker_name(mut self, marker_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_marker_name = marker_name.as_ptr();
         self
     }
-    pub fn color(mut self, color: [f32; 4]) -> DebugMarkerMarkerInfoEXTBuilder<'a> {
+    pub fn color(mut self, color: [f32; 4]) -> Self {
         self.inner.color = color;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugMarkerMarkerInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugMarkerMarkerInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugMarkerMarkerInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -12931,20 +11657,17 @@ impl<'a> ::std::ops::Deref for Dedicated
     }
 }
 impl<'a> ::std::ops::DerefMut for DedicatedAllocationImageCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DedicatedAllocationImageCreateInfoNVBuilder<'a> {
-    pub fn dedicated_allocation(
-        mut self,
-        dedicated_allocation: bool,
-    ) -> DedicatedAllocationImageCreateInfoNVBuilder<'a> {
+    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
         self.inner.dedicated_allocation = dedicated_allocation.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DedicatedAllocationImageCreateInfoNV {
         self.inner
@@ -12989,20 +11712,17 @@ impl<'a> ::std::ops::Deref for Dedicated
     }
 }
 impl<'a> ::std::ops::DerefMut for DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
-    pub fn dedicated_allocation(
-        mut self,
-        dedicated_allocation: bool,
-    ) -> DedicatedAllocationBufferCreateInfoNVBuilder<'a> {
+    pub fn dedicated_allocation(mut self, dedicated_allocation: bool) -> Self {
         self.inner.dedicated_allocation = dedicated_allocation.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DedicatedAllocationBufferCreateInfoNV {
         self.inner
@@ -13049,21 +11769,21 @@ impl<'a> ::std::ops::Deref for Dedicated
     }
 }
 impl<'a> ::std::ops::DerefMut for DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
-    pub fn image(mut self, image: Image) -> DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn buffer(mut self, buffer: Buffer) -> DedicatedAllocationMemoryAllocateInfoNVBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DedicatedAllocationMemoryAllocateInfoNV {
         self.inner
@@ -13101,38 +11821,38 @@ impl<'a> ::std::ops::DerefMut for Extern
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalImageFormatPropertiesNVBuilder<'a> {
     pub fn image_format_properties(
         mut self,
         image_format_properties: ImageFormatProperties,
-    ) -> ExternalImageFormatPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.image_format_properties = image_format_properties;
         self
     }
     pub fn external_memory_features(
         mut self,
         external_memory_features: ExternalMemoryFeatureFlagsNV,
-    ) -> ExternalImageFormatPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.external_memory_features = external_memory_features;
         self
     }
     pub fn export_from_imported_handle_types(
         mut self,
         export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNV,
-    ) -> ExternalImageFormatPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
         self
     }
     pub fn compatible_handle_types(
         mut self,
         compatible_handle_types: ExternalMemoryHandleTypeFlagsNV,
-    ) -> ExternalImageFormatPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.compatible_handle_types = compatible_handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalImageFormatPropertiesNV {
         self.inner
@@ -13177,20 +11897,17 @@ impl<'a> ::std::ops::Deref for ExternalM
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalMemoryImageCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalMemoryImageCreateInfoNVBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalMemoryHandleTypeFlagsNV,
-    ) -> ExternalMemoryImageCreateInfoNVBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalMemoryImageCreateInfoNV {
         self.inner
@@ -13235,20 +11952,17 @@ impl<'a> ::std::ops::Deref for ExportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportMemoryAllocateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportMemoryAllocateInfoNVBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalMemoryHandleTypeFlagsNV,
-    ) -> ExportMemoryAllocateInfoNVBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlagsNV) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportMemoryAllocateInfoNV {
         self.inner
@@ -13295,24 +12009,21 @@ impl<'a> ::std::ops::Deref for ImportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportMemoryWin32HandleInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportMemoryWin32HandleInfoNVBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlagsNV,
-    ) -> ImportMemoryWin32HandleInfoNVBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlagsNV) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn handle(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoNVBuilder<'a> {
+    pub fn handle(mut self, handle: HANDLE) -> Self {
         self.inner.handle = handle;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportMemoryWin32HandleInfoNV {
         self.inner
@@ -13359,24 +12070,21 @@ impl<'a> ::std::ops::Deref for ExportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportMemoryWin32HandleInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportMemoryWin32HandleInfoNVBuilder<'a> {
-    pub fn attributes(
-        mut self,
-        attributes: &'a SECURITY_ATTRIBUTES,
-    ) -> ExportMemoryWin32HandleInfoNVBuilder<'a> {
+    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
         self.inner.p_attributes = attributes;
         self
     }
-    pub fn dw_access(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoNVBuilder<'a> {
+    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
         self.inner.dw_access = dw_access;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportMemoryWin32HandleInfoNV {
         self.inner
@@ -13421,64 +12129,51 @@ impl Win32KeyedMutexAcquireReleaseInfoNV
 }
 #[repr(transparent)]
 pub struct Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
     inner: Win32KeyedMutexAcquireReleaseInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
 unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}
 unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoNV {}
+unsafe impl ExtendsSubmitInfo2KHR for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'_> {}
+unsafe impl ExtendsSubmitInfo2KHR for Win32KeyedMutexAcquireReleaseInfoNV {}
 impl<'a> ::std::ops::Deref for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
     type Target = Win32KeyedMutexAcquireReleaseInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
-    pub fn acquire_syncs(
-        mut self,
-        acquire_syncs: &'a [DeviceMemory],
-    ) -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
+    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
         self.inner.acquire_count = acquire_syncs.len() as _;
         self.inner.p_acquire_syncs = acquire_syncs.as_ptr();
         self
     }
-    pub fn acquire_keys(
-        mut self,
-        acquire_keys: &'a [u64],
-    ) -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
+    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
         self.inner.acquire_count = acquire_keys.len() as _;
         self.inner.p_acquire_keys = acquire_keys.as_ptr();
         self
     }
-    pub fn acquire_timeout_milliseconds(
-        mut self,
-        acquire_timeout_milliseconds: &'a [u32],
-    ) -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
+    pub fn acquire_timeout_milliseconds(mut self, acquire_timeout_milliseconds: &'a [u32]) -> Self {
         self.inner.acquire_count = acquire_timeout_milliseconds.len() as _;
         self.inner.p_acquire_timeout_milliseconds = acquire_timeout_milliseconds.as_ptr();
         self
     }
-    pub fn release_syncs(
-        mut self,
-        release_syncs: &'a [DeviceMemory],
-    ) -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
+    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
         self.inner.release_count = release_syncs.len() as _;
         self.inner.p_release_syncs = release_syncs.as_ptr();
         self
     }
-    pub fn release_keys(
-        mut self,
-        release_keys: &'a [u64],
-    ) -> Win32KeyedMutexAcquireReleaseInfoNVBuilder<'a> {
+    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
         self.inner.release_count = release_keys.len() as _;
         self.inner.p_release_keys = release_keys.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoNV {
@@ -13510,34 +12205,36 @@ impl PhysicalDeviceDeviceGeneratedComman
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
-    pub fn device_generated_commands(
-        mut self,
-        device_generated_commands: bool,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsFeaturesNVBuilder<'a> {
+    pub fn device_generated_commands(mut self, device_generated_commands: bool) -> Self {
         self.inner.device_generated_commands = device_generated_commands.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
         self.inner
@@ -13582,20 +12279,17 @@ impl<'a> ::std::ops::Deref for DevicePri
     }
 }
 impl<'a> ::std::ops::DerefMut for DevicePrivateDataCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DevicePrivateDataCreateInfoEXTBuilder<'a> {
-    pub fn private_data_slot_request_count(
-        mut self,
-        private_data_slot_request_count: u32,
-    ) -> DevicePrivateDataCreateInfoEXTBuilder<'a> {
+    pub fn private_data_slot_request_count(mut self, private_data_slot_request_count: u32) -> Self {
         self.inner.private_data_slot_request_count = private_data_slot_request_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DevicePrivateDataCreateInfoEXT {
         self.inner
@@ -13626,51 +12320,30 @@ impl PrivateDataSlotCreateInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct PrivateDataSlotCreateInfoEXTBuilder<'a> {
     inner: PrivateDataSlotCreateInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPrivateDataSlotCreateInfoEXT {}
 impl<'a> ::std::ops::Deref for PrivateDataSlotCreateInfoEXTBuilder<'a> {
     type Target = PrivateDataSlotCreateInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PrivateDataSlotCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PrivateDataSlotCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PrivateDataSlotCreateFlagsEXT,
-    ) -> PrivateDataSlotCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPrivateDataSlotCreateInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> PrivateDataSlotCreateInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: PrivateDataSlotCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PrivateDataSlotCreateInfoEXT {
         self.inner
     }
@@ -13700,34 +12373,33 @@ impl PhysicalDevicePrivateDataFeaturesEX
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePrivateDataFeaturesEXTBuilder<'a> {
     inner: PhysicalDevicePrivateDataFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrivateDataFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePrivateDataFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrivateDataFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePrivateDataFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePrivateDataFeaturesEXTBuilder<'a> {
     type Target = PhysicalDevicePrivateDataFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePrivateDataFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePrivateDataFeaturesEXTBuilder<'a> {
-    pub fn private_data(
-        mut self,
-        private_data: bool,
-    ) -> PhysicalDevicePrivateDataFeaturesEXTBuilder<'a> {
+    pub fn private_data(mut self, private_data: bool) -> Self {
         self.inner.private_data = private_data.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePrivateDataFeaturesEXT {
         self.inner
@@ -13791,91 +12463,140 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
-    pub fn max_graphics_shader_group_count(
-        mut self,
-        max_graphics_shader_group_count: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    pub fn max_graphics_shader_group_count(mut self, max_graphics_shader_group_count: u32) -> Self {
         self.inner.max_graphics_shader_group_count = max_graphics_shader_group_count;
         self
     }
-    pub fn max_indirect_sequence_count(
-        mut self,
-        max_indirect_sequence_count: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    pub fn max_indirect_sequence_count(mut self, max_indirect_sequence_count: u32) -> Self {
         self.inner.max_indirect_sequence_count = max_indirect_sequence_count;
         self
     }
     pub fn max_indirect_commands_token_count(
         mut self,
         max_indirect_commands_token_count: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_indirect_commands_token_count = max_indirect_commands_token_count;
         self
     }
     pub fn max_indirect_commands_stream_count(
         mut self,
         max_indirect_commands_stream_count: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_indirect_commands_stream_count = max_indirect_commands_stream_count;
         self
     }
     pub fn max_indirect_commands_token_offset(
         mut self,
         max_indirect_commands_token_offset: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_indirect_commands_token_offset = max_indirect_commands_token_offset;
         self
     }
     pub fn max_indirect_commands_stream_stride(
         mut self,
         max_indirect_commands_stream_stride: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_indirect_commands_stream_stride = max_indirect_commands_stream_stride;
         self
     }
     pub fn min_sequences_count_buffer_offset_alignment(
         mut self,
         min_sequences_count_buffer_offset_alignment: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.min_sequences_count_buffer_offset_alignment =
             min_sequences_count_buffer_offset_alignment;
         self
     }
     pub fn min_sequences_index_buffer_offset_alignment(
         mut self,
         min_sequences_index_buffer_offset_alignment: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.min_sequences_index_buffer_offset_alignment =
             min_sequences_index_buffer_offset_alignment;
         self
     }
     pub fn min_indirect_commands_buffer_offset_alignment(
         mut self,
         min_indirect_commands_buffer_offset_alignment: u32,
-    ) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.min_indirect_commands_buffer_offset_alignment =
             min_indirect_commands_buffer_offset_alignment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMultiDrawPropertiesEXT.html>"]
+pub struct PhysicalDeviceMultiDrawPropertiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub max_multi_draw_count: u32,
+}
+impl ::std::default::Default for PhysicalDeviceMultiDrawPropertiesEXT {
+    fn default() -> PhysicalDeviceMultiDrawPropertiesEXT {
+        PhysicalDeviceMultiDrawPropertiesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            max_multi_draw_count: u32::default(),
+        }
+    }
+}
+impl PhysicalDeviceMultiDrawPropertiesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
+        PhysicalDeviceMultiDrawPropertiesEXTBuilder {
+            inner: PhysicalDeviceMultiDrawPropertiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
+    inner: PhysicalDeviceMultiDrawPropertiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceMultiDrawPropertiesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
+    type Target = PhysicalDeviceMultiDrawPropertiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceMultiDrawPropertiesEXTBuilder<'a> {
+    pub fn max_multi_draw_count(mut self, max_multi_draw_count: u32) -> Self {
+        self.inner.max_multi_draw_count = max_multi_draw_count;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceMultiDrawPropertiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkGraphicsShaderGroupCreateInfoNV.html>"]
 pub struct GraphicsShaderGroupCreateInfoNV {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub stage_count: u32,
     pub p_stages: *const PipelineShaderStageCreateInfo,
     pub p_vertex_input_state: *const PipelineVertexInputStateCreateInfo,
     pub p_tessellation_state: *const PipelineTessellationStateCreateInfo,
@@ -13900,68 +12621,47 @@ impl GraphicsShaderGroupCreateInfoNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct GraphicsShaderGroupCreateInfoNVBuilder<'a> {
     inner: GraphicsShaderGroupCreateInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGraphicsShaderGroupCreateInfoNV {}
 impl<'a> ::std::ops::Deref for GraphicsShaderGroupCreateInfoNVBuilder<'a> {
     type Target = GraphicsShaderGroupCreateInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GraphicsShaderGroupCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
-    pub fn stages(
-        mut self,
-        stages: &'a [PipelineShaderStageCreateInfo],
-    ) -> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
         self.inner.stage_count = stages.len() as _;
         self.inner.p_stages = stages.as_ptr();
         self
     }
     pub fn vertex_input_state(
         mut self,
         vertex_input_state: &'a PipelineVertexInputStateCreateInfo,
-    ) -> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.p_vertex_input_state = vertex_input_state;
         self
     }
     pub fn tessellation_state(
         mut self,
         tessellation_state: &'a PipelineTessellationStateCreateInfo,
-    ) -> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.p_tessellation_state = tessellation_state;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGraphicsShaderGroupCreateInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> GraphicsShaderGroupCreateInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GraphicsShaderGroupCreateInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -14012,28 +12712,22 @@ impl<'a> ::std::ops::Deref for GraphicsP
     }
 }
 impl<'a> ::std::ops::DerefMut for GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
-    pub fn groups(
-        mut self,
-        groups: &'a [GraphicsShaderGroupCreateInfoNV],
-    ) -> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
+    pub fn groups(mut self, groups: &'a [GraphicsShaderGroupCreateInfoNV]) -> Self {
         self.inner.group_count = groups.len() as _;
         self.inner.p_groups = groups.as_ptr();
         self
     }
-    pub fn pipelines(
-        mut self,
-        pipelines: &'a [Pipeline],
-    ) -> GraphicsPipelineShaderGroupsCreateInfoNVBuilder<'a> {
+    pub fn pipelines(mut self, pipelines: &'a [Pipeline]) -> Self {
         self.inner.pipeline_count = pipelines.len() as _;
         self.inner.p_pipelines = pipelines.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GraphicsPipelineShaderGroupsCreateInfoNV {
@@ -14066,17 +12760,17 @@ impl<'a> ::std::ops::Deref for BindShade
     }
 }
 impl<'a> ::std::ops::DerefMut for BindShaderGroupIndirectCommandNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindShaderGroupIndirectCommandNVBuilder<'a> {
-    pub fn group_index(mut self, group_index: u32) -> BindShaderGroupIndirectCommandNVBuilder<'a> {
+    pub fn group_index(mut self, group_index: u32) -> Self {
         self.inner.group_index = group_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindShaderGroupIndirectCommandNV {
         self.inner
@@ -14110,31 +12804,25 @@ impl<'a> ::std::ops::Deref for BindIndex
     }
 }
 impl<'a> ::std::ops::DerefMut for BindIndexBufferIndirectCommandNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindIndexBufferIndirectCommandNVBuilder<'a> {
-    pub fn buffer_address(
-        mut self,
-        buffer_address: DeviceAddress,
-    ) -> BindIndexBufferIndirectCommandNVBuilder<'a> {
+    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
         self.inner.buffer_address = buffer_address;
         self
     }
-    pub fn size(mut self, size: u32) -> BindIndexBufferIndirectCommandNVBuilder<'a> {
+    pub fn size(mut self, size: u32) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn index_type(
-        mut self,
-        index_type: IndexType,
-    ) -> BindIndexBufferIndirectCommandNVBuilder<'a> {
+    pub fn index_type(mut self, index_type: IndexType) -> Self {
         self.inner.index_type = index_type;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindIndexBufferIndirectCommandNV {
         self.inner
@@ -14168,28 +12856,25 @@ impl<'a> ::std::ops::Deref for BindVerte
     }
 }
 impl<'a> ::std::ops::DerefMut for BindVertexBufferIndirectCommandNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindVertexBufferIndirectCommandNVBuilder<'a> {
-    pub fn buffer_address(
-        mut self,
-        buffer_address: DeviceAddress,
-    ) -> BindVertexBufferIndirectCommandNVBuilder<'a> {
+    pub fn buffer_address(mut self, buffer_address: DeviceAddress) -> Self {
         self.inner.buffer_address = buffer_address;
         self
     }
-    pub fn size(mut self, size: u32) -> BindVertexBufferIndirectCommandNVBuilder<'a> {
+    pub fn size(mut self, size: u32) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn stride(mut self, stride: u32) -> BindVertexBufferIndirectCommandNVBuilder<'a> {
+    pub fn stride(mut self, stride: u32) -> Self {
         self.inner.stride = stride;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindVertexBufferIndirectCommandNV {
         self.inner
@@ -14221,17 +12906,17 @@ impl<'a> ::std::ops::Deref for SetStateF
     }
 }
 impl<'a> ::std::ops::DerefMut for SetStateFlagsIndirectCommandNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SetStateFlagsIndirectCommandNVBuilder<'a> {
-    pub fn data(mut self, data: u32) -> SetStateFlagsIndirectCommandNVBuilder<'a> {
+    pub fn data(mut self, data: u32) -> Self {
         self.inner.data = data;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SetStateFlagsIndirectCommandNV {
         self.inner
@@ -14264,21 +12949,21 @@ impl<'a> ::std::ops::Deref for IndirectC
     }
 }
 impl<'a> ::std::ops::DerefMut for IndirectCommandsStreamNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> IndirectCommandsStreamNVBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> IndirectCommandsStreamNVBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> IndirectCommandsStreamNVBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> IndirectCommandsStreamNV {
         self.inner
@@ -14333,126 +13018,84 @@ impl IndirectCommandsLayoutTokenNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct IndirectCommandsLayoutTokenNVBuilder<'a> {
     inner: IndirectCommandsLayoutTokenNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsIndirectCommandsLayoutTokenNV {}
 impl<'a> ::std::ops::Deref for IndirectCommandsLayoutTokenNVBuilder<'a> {
     type Target = IndirectCommandsLayoutTokenNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for IndirectCommandsLayoutTokenNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> IndirectCommandsLayoutTokenNVBuilder<'a> {
-    pub fn token_type(
-        mut self,
-        token_type: IndirectCommandsTokenTypeNV,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn token_type(mut self, token_type: IndirectCommandsTokenTypeNV) -> Self {
         self.inner.token_type = token_type;
         self
     }
-    pub fn stream(mut self, stream: u32) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn stream(mut self, stream: u32) -> Self {
         self.inner.stream = stream;
         self
     }
-    pub fn offset(mut self, offset: u32) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn offset(mut self, offset: u32) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn vertex_binding_unit(
-        mut self,
-        vertex_binding_unit: u32,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn vertex_binding_unit(mut self, vertex_binding_unit: u32) -> Self {
         self.inner.vertex_binding_unit = vertex_binding_unit;
         self
     }
-    pub fn vertex_dynamic_stride(
-        mut self,
-        vertex_dynamic_stride: bool,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn vertex_dynamic_stride(mut self, vertex_dynamic_stride: bool) -> Self {
         self.inner.vertex_dynamic_stride = vertex_dynamic_stride.into();
         self
     }
     pub fn pushconstant_pipeline_layout(
         mut self,
         pushconstant_pipeline_layout: PipelineLayout,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    ) -> Self {
         self.inner.pushconstant_pipeline_layout = pushconstant_pipeline_layout;
         self
     }
     pub fn pushconstant_shader_stage_flags(
         mut self,
         pushconstant_shader_stage_flags: ShaderStageFlags,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    ) -> Self {
         self.inner.pushconstant_shader_stage_flags = pushconstant_shader_stage_flags;
         self
     }
-    pub fn pushconstant_offset(
-        mut self,
-        pushconstant_offset: u32,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn pushconstant_offset(mut self, pushconstant_offset: u32) -> Self {
         self.inner.pushconstant_offset = pushconstant_offset;
         self
     }
-    pub fn pushconstant_size(
-        mut self,
-        pushconstant_size: u32,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn pushconstant_size(mut self, pushconstant_size: u32) -> Self {
         self.inner.pushconstant_size = pushconstant_size;
         self
     }
-    pub fn indirect_state_flags(
-        mut self,
-        indirect_state_flags: IndirectStateFlagsNV,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn indirect_state_flags(mut self, indirect_state_flags: IndirectStateFlagsNV) -> Self {
         self.inner.indirect_state_flags = indirect_state_flags;
         self
     }
-    pub fn index_types(
-        mut self,
-        index_types: &'a [IndexType],
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn index_types(mut self, index_types: &'a [IndexType]) -> Self {
         self.inner.index_type_count = index_types.len() as _;
         self.inner.p_index_types = index_types.as_ptr();
         self
     }
-    pub fn index_type_values(
-        mut self,
-        index_type_values: &'a [u32],
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
+    pub fn index_type_values(mut self, index_type_values: &'a [u32]) -> Self {
         self.inner.index_type_count = index_type_values.len() as _;
         self.inner.p_index_type_values = index_type_values.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsIndirectCommandsLayoutTokenNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> IndirectCommandsLayoutTokenNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> IndirectCommandsLayoutTokenNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -14490,76 +13133,46 @@ impl IndirectCommandsLayoutCreateInfoNV 
         }
     }
 }
 #[repr(transparent)]
 pub struct IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
     inner: IndirectCommandsLayoutCreateInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsIndirectCommandsLayoutCreateInfoNV {}
 impl<'a> ::std::ops::Deref for IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
     type Target = IndirectCommandsLayoutCreateInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: IndirectCommandsLayoutUsageFlagsNV,
-    ) -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: IndirectCommandsLayoutUsageFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn tokens(
-        mut self,
-        tokens: &'a [IndirectCommandsLayoutTokenNV],
-    ) -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
+    pub fn tokens(mut self, tokens: &'a [IndirectCommandsLayoutTokenNV]) -> Self {
         self.inner.token_count = tokens.len() as _;
         self.inner.p_tokens = tokens.as_ptr();
         self
     }
-    pub fn stream_strides(
-        mut self,
-        stream_strides: &'a [u32],
-    ) -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
+    pub fn stream_strides(mut self, stream_strides: &'a [u32]) -> Self {
         self.inner.stream_count = stream_strides.len() as _;
         self.inner.p_stream_strides = stream_strides.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsIndirectCommandsLayoutCreateInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> IndirectCommandsLayoutCreateInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> IndirectCommandsLayoutCreateInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -14611,125 +13224,80 @@ impl GeneratedCommandsInfoNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct GeneratedCommandsInfoNVBuilder<'a> {
     inner: GeneratedCommandsInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGeneratedCommandsInfoNV {}
 impl<'a> ::std::ops::Deref for GeneratedCommandsInfoNVBuilder<'a> {
     type Target = GeneratedCommandsInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GeneratedCommandsInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeneratedCommandsInfoNVBuilder<'a> {
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn pipeline(mut self, pipeline: Pipeline) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
         self.inner.pipeline = pipeline;
         self
     }
     pub fn indirect_commands_layout(
         mut self,
         indirect_commands_layout: IndirectCommandsLayoutNV,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.indirect_commands_layout = indirect_commands_layout;
         self
     }
-    pub fn streams(
-        mut self,
-        streams: &'a [IndirectCommandsStreamNV],
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn streams(mut self, streams: &'a [IndirectCommandsStreamNV]) -> Self {
         self.inner.stream_count = streams.len() as _;
         self.inner.p_streams = streams.as_ptr();
         self
     }
-    pub fn sequences_count(mut self, sequences_count: u32) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn sequences_count(mut self, sequences_count: u32) -> Self {
         self.inner.sequences_count = sequences_count;
         self
     }
-    pub fn preprocess_buffer(
-        mut self,
-        preprocess_buffer: Buffer,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn preprocess_buffer(mut self, preprocess_buffer: Buffer) -> Self {
         self.inner.preprocess_buffer = preprocess_buffer;
         self
     }
-    pub fn preprocess_offset(
-        mut self,
-        preprocess_offset: DeviceSize,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn preprocess_offset(mut self, preprocess_offset: DeviceSize) -> Self {
         self.inner.preprocess_offset = preprocess_offset;
         self
     }
-    pub fn preprocess_size(
-        mut self,
-        preprocess_size: DeviceSize,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn preprocess_size(mut self, preprocess_size: DeviceSize) -> Self {
         self.inner.preprocess_size = preprocess_size;
         self
     }
-    pub fn sequences_count_buffer(
-        mut self,
-        sequences_count_buffer: Buffer,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn sequences_count_buffer(mut self, sequences_count_buffer: Buffer) -> Self {
         self.inner.sequences_count_buffer = sequences_count_buffer;
         self
     }
-    pub fn sequences_count_offset(
-        mut self,
-        sequences_count_offset: DeviceSize,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn sequences_count_offset(mut self, sequences_count_offset: DeviceSize) -> Self {
         self.inner.sequences_count_offset = sequences_count_offset;
         self
     }
-    pub fn sequences_index_buffer(
-        mut self,
-        sequences_index_buffer: Buffer,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn sequences_index_buffer(mut self, sequences_index_buffer: Buffer) -> Self {
         self.inner.sequences_index_buffer = sequences_index_buffer;
         self
     }
-    pub fn sequences_index_offset(
-        mut self,
-        sequences_index_offset: DeviceSize,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
+    pub fn sequences_index_offset(mut self, sequences_index_offset: DeviceSize) -> Self {
         self.inner.sequences_index_offset = sequences_index_offset;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGeneratedCommandsInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> GeneratedCommandsInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeneratedCommandsInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -14763,74 +13331,47 @@ impl GeneratedCommandsMemoryRequirements
         }
     }
 }
 #[repr(transparent)]
 pub struct GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
     inner: GeneratedCommandsMemoryRequirementsInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGeneratedCommandsMemoryRequirementsInfoNV {}
 impl<'a> ::std::ops::Deref for GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
     type Target = GeneratedCommandsMemoryRequirementsInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn pipeline(
-        mut self,
-        pipeline: Pipeline,
-    ) -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
+    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
         self.inner.pipeline = pipeline;
         self
     }
     pub fn indirect_commands_layout(
         mut self,
         indirect_commands_layout: IndirectCommandsLayoutNV,
-    ) -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.indirect_commands_layout = indirect_commands_layout;
         self
     }
-    pub fn max_sequences_count(
-        mut self,
-        max_sequences_count: u32,
-    ) -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
+    pub fn max_sequences_count(mut self, max_sequences_count: u32) -> Self {
         self.inner.max_sequences_count = max_sequences_count;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGeneratedCommandsMemoryRequirementsInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> GeneratedCommandsMemoryRequirementsInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeneratedCommandsMemoryRequirementsInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -14860,35 +13401,47 @@ impl PhysicalDeviceFeatures2 {
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFeatures2Builder<'a> {
     inner: PhysicalDeviceFeatures2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFeatures2Builder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFeatures2 {}
+pub unsafe trait ExtendsPhysicalDeviceFeatures2 {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFeatures2Builder<'a> {
     type Target = PhysicalDeviceFeatures2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFeatures2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFeatures2Builder<'a> {
-    pub fn features(
-        mut self,
-        features: PhysicalDeviceFeatures,
-    ) -> PhysicalDeviceFeatures2Builder<'a> {
+    pub fn features(mut self, features: PhysicalDeviceFeatures) -> Self {
         self.inner.features = features;
         self
     }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsPhysicalDeviceFeatures2>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFeatures2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -14929,32 +13482,26 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceProperties2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceProperties2Builder<'a> {
-    pub fn properties(
-        mut self,
-        properties: PhysicalDeviceProperties,
-    ) -> PhysicalDeviceProperties2Builder<'a> {
+    pub fn properties(mut self, properties: PhysicalDeviceProperties) -> Self {
         self.inner.properties = properties;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceProperties2Builder<'a> {
+    pub fn push_next<T: ExtendsPhysicalDeviceProperties2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15003,32 +13550,26 @@ impl<'a> ::std::ops::Deref for FormatPro
     }
 }
 impl<'a> ::std::ops::DerefMut for FormatProperties2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FormatProperties2Builder<'a> {
-    pub fn format_properties(
-        mut self,
-        format_properties: FormatProperties,
-    ) -> FormatProperties2Builder<'a> {
+    pub fn format_properties(mut self, format_properties: FormatProperties) -> Self {
         self.inner.format_properties = format_properties;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFormatProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> FormatProperties2Builder<'a> {
+    pub fn push_next<T: ExtendsFormatProperties2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15080,29 +13621,26 @@ impl<'a> ::std::ops::DerefMut for ImageF
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageFormatProperties2Builder<'a> {
     pub fn image_format_properties(
         mut self,
         image_format_properties: ImageFormatProperties,
-    ) -> ImageFormatProperties2Builder<'a> {
+    ) -> Self {
         self.inner.image_format_properties = image_format_properties;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageFormatProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageFormatProperties2Builder<'a> {
+    pub fn push_next<T: ExtendsImageFormatProperties2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15159,45 +13697,42 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageFormatInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceImageFormatInfo2Builder<'a> {
-    pub fn format(mut self, format: Format) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn ty(mut self, ty: ImageType) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
+    pub fn ty(mut self, ty: ImageType) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn tiling(mut self, tiling: ImageTiling) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
+    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
         self.inner.tiling = tiling;
         self
     }
-    pub fn usage(mut self, usage: ImageUsageFlags) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
+    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn flags(mut self, flags: ImageCreateFlags) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceImageFormatInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceImageFormatInfo2Builder<'a> {
+    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsPhysicalDeviceImageFormatInfo2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15249,29 +13784,26 @@ impl<'a> ::std::ops::DerefMut for QueueF
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueueFamilyProperties2Builder<'a> {
     pub fn queue_family_properties(
         mut self,
         queue_family_properties: QueueFamilyProperties,
-    ) -> QueueFamilyProperties2Builder<'a> {
+    ) -> Self {
         self.inner.queue_family_properties = queue_family_properties;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsQueueFamilyProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> QueueFamilyProperties2Builder<'a> {
+    pub fn push_next<T: ExtendsQueueFamilyProperties2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15320,32 +13852,26 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryProperties2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMemoryProperties2Builder<'a> {
-    pub fn memory_properties(
-        mut self,
-        memory_properties: PhysicalDeviceMemoryProperties,
-    ) -> PhysicalDeviceMemoryProperties2Builder<'a> {
+    pub fn memory_properties(mut self, memory_properties: PhysicalDeviceMemoryProperties) -> Self {
         self.inner.memory_properties = memory_properties;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceMemoryProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceMemoryProperties2Builder<'a> {
+    pub fn push_next<T: ExtendsPhysicalDeviceMemoryProperties2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -15381,53 +13907,32 @@ impl SparseImageFormatProperties2 {
         }
     }
 }
 #[repr(transparent)]
 pub struct SparseImageFormatProperties2Builder<'a> {
     inner: SparseImageFormatProperties2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSparseImageFormatProperties2 {}
 impl<'a> ::std::ops::Deref for SparseImageFormatProperties2Builder<'a> {
     type Target = SparseImageFormatProperties2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageFormatProperties2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageFormatProperties2Builder<'a> {
-    pub fn properties(
-        mut self,
-        properties: SparseImageFormatProperties,
-    ) -> SparseImageFormatProperties2Builder<'a> {
+    pub fn properties(mut self, properties: SparseImageFormatProperties) -> Self {
         self.inner.properties = properties;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSparseImageFormatProperties2>(
-        mut self,
-        next: &'a mut T,
-    ) -> SparseImageFormatProperties2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageFormatProperties2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -15463,75 +13968,48 @@ impl PhysicalDeviceSparseImageFormatInfo
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
     inner: PhysicalDeviceSparseImageFormatInfo2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceSparseImageFormatInfo2 {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
     type Target = PhysicalDeviceSparseImageFormatInfo2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
-    pub fn format(mut self, format: Format) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn ty(mut self, ty: ImageType) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
+    pub fn ty(mut self, ty: ImageType) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn samples(
-        mut self,
-        samples: SampleCountFlags,
-    ) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
+    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
         self.inner.samples = samples;
         self
     }
-    pub fn usage(
-        mut self,
-        usage: ImageUsageFlags,
-    ) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
+    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn tiling(
-        mut self,
-        tiling: ImageTiling,
-    ) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
+    pub fn tiling(mut self, tiling: ImageTiling) -> Self {
         self.inner.tiling = tiling;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceSparseImageFormatInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceSparseImageFormatInfo2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSparseImageFormatInfo2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -15576,20 +14054,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
-    pub fn max_push_descriptors(
-        mut self,
-        max_push_descriptors: u32,
-    ) -> PhysicalDevicePushDescriptorPropertiesKHRBuilder<'a> {
+    pub fn max_push_descriptors(mut self, max_push_descriptors: u32) -> Self {
         self.inner.max_push_descriptors = max_push_descriptors;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePushDescriptorPropertiesKHR {
         self.inner
@@ -15624,29 +14099,29 @@ impl<'a> ::std::ops::Deref for Conforman
     }
 }
 impl<'a> ::std::ops::DerefMut for ConformanceVersionBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ConformanceVersionBuilder<'a> {
-    pub fn major(mut self, major: u8) -> ConformanceVersionBuilder<'a> {
+    pub fn major(mut self, major: u8) -> Self {
         self.inner.major = major;
         self
     }
-    pub fn minor(mut self, minor: u8) -> ConformanceVersionBuilder<'a> {
+    pub fn minor(mut self, minor: u8) -> Self {
         self.inner.minor = minor;
         self
     }
-    pub fn subminor(mut self, subminor: u8) -> ConformanceVersionBuilder<'a> {
+    pub fn subminor(mut self, subminor: u8) -> Self {
         self.inner.subminor = subminor;
         self
     }
-    pub fn patch(mut self, patch: u8) -> ConformanceVersionBuilder<'a> {
+    pub fn patch(mut self, patch: u8) -> Self {
         self.inner.patch = patch;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ConformanceVersion {
         self.inner
@@ -15713,38 +14188,29 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDriverPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDriverPropertiesBuilder<'a> {
-    pub fn driver_id(mut self, driver_id: DriverId) -> PhysicalDeviceDriverPropertiesBuilder<'a> {
+    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
         self.inner.driver_id = driver_id;
         self
     }
-    pub fn driver_name(
-        mut self,
-        driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
-    ) -> PhysicalDeviceDriverPropertiesBuilder<'a> {
+    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
         self.inner.driver_name = driver_name;
         self
     }
-    pub fn driver_info(
-        mut self,
-        driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
-    ) -> PhysicalDeviceDriverPropertiesBuilder<'a> {
+    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
         self.inner.driver_info = driver_info;
         self
     }
-    pub fn conformance_version(
-        mut self,
-        conformance_version: ConformanceVersion,
-    ) -> PhysicalDeviceDriverPropertiesBuilder<'a> {
+    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
         self.inner.conformance_version = conformance_version;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDriverProperties {
         self.inner
@@ -15791,17 +14257,17 @@ impl<'a> ::std::ops::Deref for PresentRe
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentRegionsKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentRegionsKHRBuilder<'a> {
-    pub fn regions(mut self, regions: &'a [PresentRegionKHR]) -> PresentRegionsKHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [PresentRegionKHR]) -> Self {
         self.inner.swapchain_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PresentRegionsKHR {
@@ -15843,17 +14309,17 @@ impl<'a> ::std::ops::Deref for PresentRe
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentRegionKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentRegionKHRBuilder<'a> {
-    pub fn rectangles(mut self, rectangles: &'a [RectLayerKHR]) -> PresentRegionKHRBuilder<'a> {
+    pub fn rectangles(mut self, rectangles: &'a [RectLayerKHR]) -> Self {
         self.inner.rectangle_count = rectangles.len() as _;
         self.inner.p_rectangles = rectangles.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PresentRegionKHR {
@@ -15888,25 +14354,25 @@ impl<'a> ::std::ops::Deref for RectLayer
     }
 }
 impl<'a> ::std::ops::DerefMut for RectLayerKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RectLayerKHRBuilder<'a> {
-    pub fn offset(mut self, offset: Offset2D) -> RectLayerKHRBuilder<'a> {
+    pub fn offset(mut self, offset: Offset2D) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn extent(mut self, extent: Extent2D) -> RectLayerKHRBuilder<'a> {
+    pub fn extent(mut self, extent: Extent2D) -> Self {
         self.inner.extent = extent;
         self
     }
-    pub fn layer(mut self, layer: u32) -> RectLayerKHRBuilder<'a> {
+    pub fn layer(mut self, layer: u32) -> Self {
         self.inner.layer = layer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RectLayerKHR {
         self.inner
@@ -15939,16 +14405,18 @@ impl PhysicalDeviceVariablePointersFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
     inner: PhysicalDeviceVariablePointersFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVariablePointersFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVariablePointersFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVariablePointersFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVariablePointersFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
     type Target = PhysicalDeviceVariablePointersFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -15956,24 +14424,21 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
     pub fn variable_pointers_storage_buffer(
         mut self,
         variable_pointers_storage_buffer: bool,
-    ) -> PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
         self
     }
-    pub fn variable_pointers(
-        mut self,
-        variable_pointers: bool,
-    ) -> PhysicalDeviceVariablePointersFeaturesBuilder<'a> {
+    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
         self.inner.variable_pointers = variable_pointers.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVariablePointersFeatures {
         self.inner
@@ -16010,31 +14475,31 @@ impl<'a> ::std::ops::DerefMut for Extern
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalMemoryPropertiesBuilder<'a> {
     pub fn external_memory_features(
         mut self,
         external_memory_features: ExternalMemoryFeatureFlags,
-    ) -> ExternalMemoryPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.external_memory_features = external_memory_features;
         self
     }
     pub fn export_from_imported_handle_types(
         mut self,
         export_from_imported_handle_types: ExternalMemoryHandleTypeFlags,
-    ) -> ExternalMemoryPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
         self
     }
     pub fn compatible_handle_types(
         mut self,
         compatible_handle_types: ExternalMemoryHandleTypeFlags,
-    ) -> ExternalMemoryPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.compatible_handle_types = compatible_handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalMemoryProperties {
         self.inner
@@ -16082,20 +14547,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> PhysicalDeviceExternalImageFormatInfoBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExternalImageFormatInfo {
         self.inner
@@ -16143,17 +14605,17 @@ impl<'a> ::std::ops::DerefMut for Extern
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalImageFormatPropertiesBuilder<'a> {
     pub fn external_memory_properties(
         mut self,
         external_memory_properties: ExternalMemoryProperties,
-    ) -> ExternalImageFormatPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.external_memory_properties = external_memory_properties;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalImageFormatProperties {
         self.inner
@@ -16188,64 +14650,40 @@ impl PhysicalDeviceExternalBufferInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceExternalBufferInfoBuilder<'a> {
     inner: PhysicalDeviceExternalBufferInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceExternalBufferInfo {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceExternalBufferInfoBuilder<'a> {
     type Target = PhysicalDeviceExternalBufferInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalBufferInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExternalBufferInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: BufferCreateFlags,
-    ) -> PhysicalDeviceExternalBufferInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn usage(mut self, usage: BufferUsageFlags) -> PhysicalDeviceExternalBufferInfoBuilder<'a> {
+    pub fn flags(mut self, flags: BufferCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn usage(mut self, usage: BufferUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> PhysicalDeviceExternalBufferInfoBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceExternalBufferInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceExternalBufferInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExternalBufferInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -16273,53 +14711,35 @@ impl ExternalBufferProperties {
         }
     }
 }
 #[repr(transparent)]
 pub struct ExternalBufferPropertiesBuilder<'a> {
     inner: ExternalBufferProperties,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsExternalBufferProperties {}
 impl<'a> ::std::ops::Deref for ExternalBufferPropertiesBuilder<'a> {
     type Target = ExternalBufferProperties;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalBufferPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalBufferPropertiesBuilder<'a> {
     pub fn external_memory_properties(
         mut self,
         external_memory_properties: ExternalMemoryProperties,
-    ) -> ExternalBufferPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.external_memory_properties = external_memory_properties;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsExternalBufferProperties>(
-        mut self,
-        next: &'a mut T,
-    ) -> ExternalBufferPropertiesBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalBufferProperties {
         self.inner
     }
 }
 #[repr(C)]
@@ -16369,48 +14789,33 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceIDPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceIDPropertiesBuilder<'a> {
-    pub fn device_uuid(
-        mut self,
-        device_uuid: [u8; UUID_SIZE],
-    ) -> PhysicalDeviceIDPropertiesBuilder<'a> {
+    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.device_uuid = device_uuid;
         self
     }
-    pub fn driver_uuid(
-        mut self,
-        driver_uuid: [u8; UUID_SIZE],
-    ) -> PhysicalDeviceIDPropertiesBuilder<'a> {
+    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.driver_uuid = driver_uuid;
         self
     }
-    pub fn device_luid(
-        mut self,
-        device_luid: [u8; LUID_SIZE],
-    ) -> PhysicalDeviceIDPropertiesBuilder<'a> {
+    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
         self.inner.device_luid = device_luid;
         self
     }
-    pub fn device_node_mask(
-        mut self,
-        device_node_mask: u32,
-    ) -> PhysicalDeviceIDPropertiesBuilder<'a> {
+    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
         self.inner.device_node_mask = device_node_mask;
         self
     }
-    pub fn device_luid_valid(
-        mut self,
-        device_luid_valid: bool,
-    ) -> PhysicalDeviceIDPropertiesBuilder<'a> {
+    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
         self.inner.device_luid_valid = device_luid_valid.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceIDProperties {
         self.inner
@@ -16455,20 +14860,17 @@ impl<'a> ::std::ops::Deref for ExternalM
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalMemoryImageCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalMemoryImageCreateInfoBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalMemoryHandleTypeFlags,
-    ) -> ExternalMemoryImageCreateInfoBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalMemoryImageCreateInfo {
         self.inner
@@ -16513,20 +14915,17 @@ impl<'a> ::std::ops::Deref for ExternalM
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalMemoryBufferCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalMemoryBufferCreateInfoBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalMemoryHandleTypeFlags,
-    ) -> ExternalMemoryBufferCreateInfoBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalMemoryBufferCreateInfo {
         self.inner
@@ -16571,20 +14970,17 @@ impl<'a> ::std::ops::Deref for ExportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportMemoryAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportMemoryAllocateInfoBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalMemoryHandleTypeFlags,
-    ) -> ExportMemoryAllocateInfoBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportMemoryAllocateInfo {
         self.inner
@@ -16633,28 +15029,25 @@ impl<'a> ::std::ops::Deref for ImportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportMemoryWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn handle(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle(mut self, handle: HANDLE) -> Self {
         self.inner.handle = handle;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ImportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportMemoryWin32HandleInfoKHR {
         self.inner
@@ -16703,40 +15096,210 @@ impl<'a> ::std::ops::Deref for ExportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportMemoryWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
-    pub fn attributes(
-        mut self,
-        attributes: &'a SECURITY_ATTRIBUTES,
-    ) -> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
         self.inner.p_attributes = attributes;
         self
     }
-    pub fn dw_access(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
         self.inner.dw_access = dw_access;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ExportMemoryWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportMemoryWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImportMemoryZirconHandleInfoFUCHSIA.html>"]
+pub struct ImportMemoryZirconHandleInfoFUCHSIA {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub handle_type: ExternalMemoryHandleTypeFlags,
+    pub handle: zx_handle_t,
+}
+impl ::std::default::Default for ImportMemoryZirconHandleInfoFUCHSIA {
+    fn default() -> ImportMemoryZirconHandleInfoFUCHSIA {
+        ImportMemoryZirconHandleInfoFUCHSIA {
+            s_type: StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
+            p_next: ::std::ptr::null(),
+            handle_type: ExternalMemoryHandleTypeFlags::default(),
+            handle: zx_handle_t::default(),
+        }
+    }
+}
+impl ImportMemoryZirconHandleInfoFUCHSIA {
+    pub fn builder<'a>() -> ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
+        ImportMemoryZirconHandleInfoFUCHSIABuilder {
+            inner: ImportMemoryZirconHandleInfoFUCHSIA::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
+    inner: ImportMemoryZirconHandleInfoFUCHSIA,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryZirconHandleInfoFUCHSIABuilder<'_> {}
+unsafe impl ExtendsMemoryAllocateInfo for ImportMemoryZirconHandleInfoFUCHSIA {}
+impl<'a> ::std::ops::Deref for ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
+    type Target = ImportMemoryZirconHandleInfoFUCHSIA;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> ImportMemoryZirconHandleInfoFUCHSIABuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
+        self.inner.handle_type = handle_type;
+        self
+    }
+    pub fn handle(mut self, handle: zx_handle_t) -> Self {
+        self.inner.handle = handle;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> ImportMemoryZirconHandleInfoFUCHSIA {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryZirconHandlePropertiesFUCHSIA.html>"]
+pub struct MemoryZirconHandlePropertiesFUCHSIA {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub memory_type_bits: u32,
+}
+impl ::std::default::Default for MemoryZirconHandlePropertiesFUCHSIA {
+    fn default() -> MemoryZirconHandlePropertiesFUCHSIA {
+        MemoryZirconHandlePropertiesFUCHSIA {
+            s_type: StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
+            p_next: ::std::ptr::null_mut(),
+            memory_type_bits: u32::default(),
+        }
+    }
+}
+impl MemoryZirconHandlePropertiesFUCHSIA {
+    pub fn builder<'a>() -> MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
+        MemoryZirconHandlePropertiesFUCHSIABuilder {
+            inner: MemoryZirconHandlePropertiesFUCHSIA::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
+    inner: MemoryZirconHandlePropertiesFUCHSIA,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
+    type Target = MemoryZirconHandlePropertiesFUCHSIA;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MemoryZirconHandlePropertiesFUCHSIABuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
+        self.inner.memory_type_bits = memory_type_bits;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MemoryZirconHandlePropertiesFUCHSIA {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryGetZirconHandleInfoFUCHSIA.html>"]
+pub struct MemoryGetZirconHandleInfoFUCHSIA {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub memory: DeviceMemory,
+    pub handle_type: ExternalMemoryHandleTypeFlags,
+}
+impl ::std::default::Default for MemoryGetZirconHandleInfoFUCHSIA {
+    fn default() -> MemoryGetZirconHandleInfoFUCHSIA {
+        MemoryGetZirconHandleInfoFUCHSIA {
+            s_type: StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
+            p_next: ::std::ptr::null(),
+            memory: DeviceMemory::default(),
+            handle_type: ExternalMemoryHandleTypeFlags::default(),
+        }
+    }
+}
+impl MemoryGetZirconHandleInfoFUCHSIA {
+    pub fn builder<'a>() -> MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
+        MemoryGetZirconHandleInfoFUCHSIABuilder {
+            inner: MemoryGetZirconHandleInfoFUCHSIA::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
+    inner: MemoryGetZirconHandleInfoFUCHSIA,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
+    type Target = MemoryGetZirconHandleInfoFUCHSIA;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MemoryGetZirconHandleInfoFUCHSIABuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
+        self.inner.memory = memory;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
+        self.inner.handle_type = handle_type;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MemoryGetZirconHandleInfoFUCHSIA {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryWin32HandlePropertiesKHR.html>"]
 pub struct MemoryWin32HandlePropertiesKHR {
     pub s_type: StructureType,
     pub p_next: *mut c_void,
     pub memory_type_bits: u32,
 }
 impl ::std::default::Default for MemoryWin32HandlePropertiesKHR {
     fn default() -> MemoryWin32HandlePropertiesKHR {
@@ -16755,53 +15318,32 @@ impl MemoryWin32HandlePropertiesKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryWin32HandlePropertiesKHRBuilder<'a> {
     inner: MemoryWin32HandlePropertiesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryWin32HandlePropertiesKHR {}
 impl<'a> ::std::ops::Deref for MemoryWin32HandlePropertiesKHRBuilder<'a> {
     type Target = MemoryWin32HandlePropertiesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryWin32HandlePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryWin32HandlePropertiesKHRBuilder<'a> {
-    pub fn memory_type_bits(
-        mut self,
-        memory_type_bits: u32,
-    ) -> MemoryWin32HandlePropertiesKHRBuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
         self.inner.memory_type_bits = memory_type_bits;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryWin32HandlePropertiesKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryWin32HandlePropertiesKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryWin32HandlePropertiesKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -16831,57 +15373,36 @@ impl MemoryGetWin32HandleInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryGetWin32HandleInfoKHRBuilder<'a> {
     inner: MemoryGetWin32HandleInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryGetWin32HandleInfoKHR {}
 impl<'a> ::std::ops::Deref for MemoryGetWin32HandleInfoKHRBuilder<'a> {
     type Target = MemoryGetWin32HandleInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryGetWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryGetWin32HandleInfoKHRBuilder<'a> {
-    pub fn memory(mut self, memory: DeviceMemory) -> MemoryGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> MemoryGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryGetWin32HandleInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryGetWin32HandleInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryGetWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -16925,24 +15446,21 @@ impl<'a> ::std::ops::Deref for ImportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportMemoryFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportMemoryFdInfoKHRBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> ImportMemoryFdInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn fd(mut self, fd: c_int) -> ImportMemoryFdInfoKHRBuilder<'a> {
+    pub fn fd(mut self, fd: c_int) -> Self {
         self.inner.fd = fd;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportMemoryFdInfoKHR {
         self.inner
@@ -16973,50 +15491,32 @@ impl MemoryFdPropertiesKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryFdPropertiesKHRBuilder<'a> {
     inner: MemoryFdPropertiesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryFdPropertiesKHR {}
 impl<'a> ::std::ops::Deref for MemoryFdPropertiesKHRBuilder<'a> {
     type Target = MemoryFdPropertiesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryFdPropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryFdPropertiesKHRBuilder<'a> {
-    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> MemoryFdPropertiesKHRBuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
         self.inner.memory_type_bits = memory_type_bits;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryFdPropertiesKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryFdPropertiesKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryFdPropertiesKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -17046,57 +15546,36 @@ impl MemoryGetFdInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryGetFdInfoKHRBuilder<'a> {
     inner: MemoryGetFdInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryGetFdInfoKHR {}
 impl<'a> ::std::ops::Deref for MemoryGetFdInfoKHRBuilder<'a> {
     type Target = MemoryGetFdInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryGetFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryGetFdInfoKHRBuilder<'a> {
-    pub fn memory(mut self, memory: DeviceMemory) -> MemoryGetFdInfoKHRBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> MemoryGetFdInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryGetFdInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryGetFdInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryGetFdInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -17138,64 +15617,51 @@ impl Win32KeyedMutexAcquireReleaseInfoKH
 }
 #[repr(transparent)]
 pub struct Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
     inner: Win32KeyedMutexAcquireReleaseInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
 unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}
 unsafe impl ExtendsSubmitInfo for Win32KeyedMutexAcquireReleaseInfoKHR {}
+unsafe impl ExtendsSubmitInfo2KHR for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'_> {}
+unsafe impl ExtendsSubmitInfo2KHR for Win32KeyedMutexAcquireReleaseInfoKHR {}
 impl<'a> ::std::ops::Deref for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
     type Target = Win32KeyedMutexAcquireReleaseInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
-    pub fn acquire_syncs(
-        mut self,
-        acquire_syncs: &'a [DeviceMemory],
-    ) -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
+    pub fn acquire_syncs(mut self, acquire_syncs: &'a [DeviceMemory]) -> Self {
         self.inner.acquire_count = acquire_syncs.len() as _;
         self.inner.p_acquire_syncs = acquire_syncs.as_ptr();
         self
     }
-    pub fn acquire_keys(
-        mut self,
-        acquire_keys: &'a [u64],
-    ) -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
+    pub fn acquire_keys(mut self, acquire_keys: &'a [u64]) -> Self {
         self.inner.acquire_count = acquire_keys.len() as _;
         self.inner.p_acquire_keys = acquire_keys.as_ptr();
         self
     }
-    pub fn acquire_timeouts(
-        mut self,
-        acquire_timeouts: &'a [u32],
-    ) -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
+    pub fn acquire_timeouts(mut self, acquire_timeouts: &'a [u32]) -> Self {
         self.inner.acquire_count = acquire_timeouts.len() as _;
         self.inner.p_acquire_timeouts = acquire_timeouts.as_ptr();
         self
     }
-    pub fn release_syncs(
-        mut self,
-        release_syncs: &'a [DeviceMemory],
-    ) -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
+    pub fn release_syncs(mut self, release_syncs: &'a [DeviceMemory]) -> Self {
         self.inner.release_count = release_syncs.len() as _;
         self.inner.p_release_syncs = release_syncs.as_ptr();
         self
     }
-    pub fn release_keys(
-        mut self,
-        release_keys: &'a [u64],
-    ) -> Win32KeyedMutexAcquireReleaseInfoKHRBuilder<'a> {
+    pub fn release_keys(mut self, release_keys: &'a [u64]) -> Self {
         self.inner.release_count = release_keys.len() as _;
         self.inner.p_release_keys = release_keys.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoKHR {
@@ -17240,32 +15706,29 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalSemaphoreHandleTypeFlags,
-    ) -> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsPhysicalDeviceExternalSemaphoreInfo>(
         mut self,
         next: &'a mut T,
-    ) -> PhysicalDeviceExternalSemaphoreInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -17305,67 +15768,49 @@ impl ExternalSemaphoreProperties {
         }
     }
 }
 #[repr(transparent)]
 pub struct ExternalSemaphorePropertiesBuilder<'a> {
     inner: ExternalSemaphoreProperties,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsExternalSemaphoreProperties {}
 impl<'a> ::std::ops::Deref for ExternalSemaphorePropertiesBuilder<'a> {
     type Target = ExternalSemaphoreProperties;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalSemaphorePropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalSemaphorePropertiesBuilder<'a> {
     pub fn export_from_imported_handle_types(
         mut self,
         export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlags,
-    ) -> ExternalSemaphorePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
         self
     }
     pub fn compatible_handle_types(
         mut self,
         compatible_handle_types: ExternalSemaphoreHandleTypeFlags,
-    ) -> ExternalSemaphorePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.compatible_handle_types = compatible_handle_types;
         self
     }
     pub fn external_semaphore_features(
         mut self,
         external_semaphore_features: ExternalSemaphoreFeatureFlags,
-    ) -> ExternalSemaphorePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.external_semaphore_features = external_semaphore_features;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsExternalSemaphoreProperties>(
-        mut self,
-        next: &'a mut T,
-    ) -> ExternalSemaphorePropertiesBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalSemaphoreProperties {
         self.inner
     }
 }
 #[repr(C)]
@@ -17407,20 +15852,17 @@ impl<'a> ::std::ops::Deref for ExportSem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportSemaphoreCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportSemaphoreCreateInfoBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalSemaphoreHandleTypeFlags,
-    ) -> ExportSemaphoreCreateInfoBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportSemaphoreCreateInfo {
         self.inner
@@ -17459,75 +15901,48 @@ impl ImportSemaphoreWin32HandleInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
     inner: ImportSemaphoreWin32HandleInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImportSemaphoreWin32HandleInfoKHR {}
 impl<'a> ::std::ops::Deref for ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
     type Target = ImportSemaphoreWin32HandleInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
-    pub fn semaphore(
-        mut self,
-        semaphore: Semaphore,
-    ) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn flags(
-        mut self,
-        flags: SemaphoreImportFlags,
-    ) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalSemaphoreHandleTypeFlags,
-    ) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn handle(mut self, handle: HANDLE) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle(mut self, handle: HANDLE) -> Self {
         self.inner.handle = handle;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImportSemaphoreWin32HandleInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImportSemaphoreWin32HandleInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportSemaphoreWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -17573,28 +15988,25 @@ impl<'a> ::std::ops::Deref for ExportSem
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
-    pub fn attributes(
-        mut self,
-        attributes: &'a SECURITY_ATTRIBUTES,
-    ) -> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
         self.inner.p_attributes = attributes;
         self
     }
-    pub fn dw_access(mut self, dw_access: DWORD) -> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
         self.inner.dw_access = dw_access;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ExportSemaphoreWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportSemaphoreWin32HandleInfoKHR {
         self.inner
@@ -17645,28 +16057,22 @@ impl<'a> ::std::ops::Deref for D3D12Fenc
     }
 }
 impl<'a> ::std::ops::DerefMut for D3D12FenceSubmitInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> D3D12FenceSubmitInfoKHRBuilder<'a> {
-    pub fn wait_semaphore_values(
-        mut self,
-        wait_semaphore_values: &'a [u64],
-    ) -> D3D12FenceSubmitInfoKHRBuilder<'a> {
+    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
         self.inner.wait_semaphore_values_count = wait_semaphore_values.len() as _;
         self.inner.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
         self
     }
-    pub fn signal_semaphore_values(
-        mut self,
-        signal_semaphore_values: &'a [u64],
-    ) -> D3D12FenceSubmitInfoKHRBuilder<'a> {
+    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
         self.inner.signal_semaphore_values_count = signal_semaphore_values.len() as _;
         self.inner.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> D3D12FenceSubmitInfoKHR {
@@ -17700,57 +16106,36 @@ impl SemaphoreGetWin32HandleInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
     inner: SemaphoreGetWin32HandleInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSemaphoreGetWin32HandleInfoKHR {}
 impl<'a> ::std::ops::Deref for SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
     type Target = SemaphoreGetWin32HandleInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
-    pub fn semaphore(mut self, semaphore: Semaphore) -> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalSemaphoreHandleTypeFlags,
-    ) -> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSemaphoreGetWin32HandleInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> SemaphoreGetWin32HandleInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SemaphoreGetWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -17784,65 +16169,44 @@ impl ImportSemaphoreFdInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImportSemaphoreFdInfoKHRBuilder<'a> {
     inner: ImportSemaphoreFdInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImportSemaphoreFdInfoKHR {}
 impl<'a> ::std::ops::Deref for ImportSemaphoreFdInfoKHRBuilder<'a> {
     type Target = ImportSemaphoreFdInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportSemaphoreFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportSemaphoreFdInfoKHRBuilder<'a> {
-    pub fn semaphore(mut self, semaphore: Semaphore) -> ImportSemaphoreFdInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn flags(mut self, flags: SemaphoreImportFlags) -> ImportSemaphoreFdInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalSemaphoreHandleTypeFlags,
-    ) -> ImportSemaphoreFdInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn fd(mut self, fd: c_int) -> ImportSemaphoreFdInfoKHRBuilder<'a> {
+    pub fn fd(mut self, fd: c_int) -> Self {
         self.inner.fd = fd;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImportSemaphoreFdInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImportSemaphoreFdInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportSemaphoreFdInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -17872,66 +16236,175 @@ impl SemaphoreGetFdInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct SemaphoreGetFdInfoKHRBuilder<'a> {
     inner: SemaphoreGetFdInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSemaphoreGetFdInfoKHR {}
 impl<'a> ::std::ops::Deref for SemaphoreGetFdInfoKHRBuilder<'a> {
     type Target = SemaphoreGetFdInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreGetFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreGetFdInfoKHRBuilder<'a> {
-    pub fn semaphore(mut self, semaphore: Semaphore) -> SemaphoreGetFdInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalSemaphoreHandleTypeFlags,
-    ) -> SemaphoreGetFdInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSemaphoreGetFdInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> SemaphoreGetFdInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SemaphoreGetFdInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImportSemaphoreZirconHandleInfoFUCHSIA.html>"]
+pub struct ImportSemaphoreZirconHandleInfoFUCHSIA {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub semaphore: Semaphore,
+    pub flags: SemaphoreImportFlags,
+    pub handle_type: ExternalSemaphoreHandleTypeFlags,
+    pub zircon_handle: zx_handle_t,
+}
+impl ::std::default::Default for ImportSemaphoreZirconHandleInfoFUCHSIA {
+    fn default() -> ImportSemaphoreZirconHandleInfoFUCHSIA {
+        ImportSemaphoreZirconHandleInfoFUCHSIA {
+            s_type: StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
+            p_next: ::std::ptr::null(),
+            semaphore: Semaphore::default(),
+            flags: SemaphoreImportFlags::default(),
+            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
+            zircon_handle: zx_handle_t::default(),
+        }
+    }
+}
+impl ImportSemaphoreZirconHandleInfoFUCHSIA {
+    pub fn builder<'a>() -> ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
+        ImportSemaphoreZirconHandleInfoFUCHSIABuilder {
+            inner: ImportSemaphoreZirconHandleInfoFUCHSIA::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
+    inner: ImportSemaphoreZirconHandleInfoFUCHSIA,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
+    type Target = ImportSemaphoreZirconHandleInfoFUCHSIA;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> ImportSemaphoreZirconHandleInfoFUCHSIABuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
+        self.inner.semaphore = semaphore;
+        self
+    }
+    pub fn flags(mut self, flags: SemaphoreImportFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
+        self.inner.handle_type = handle_type;
+        self
+    }
+    pub fn zircon_handle(mut self, zircon_handle: zx_handle_t) -> Self {
+        self.inner.zircon_handle = zircon_handle;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> ImportSemaphoreZirconHandleInfoFUCHSIA {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreGetZirconHandleInfoFUCHSIA.html>"]
+pub struct SemaphoreGetZirconHandleInfoFUCHSIA {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub semaphore: Semaphore,
+    pub handle_type: ExternalSemaphoreHandleTypeFlags,
+}
+impl ::std::default::Default for SemaphoreGetZirconHandleInfoFUCHSIA {
+    fn default() -> SemaphoreGetZirconHandleInfoFUCHSIA {
+        SemaphoreGetZirconHandleInfoFUCHSIA {
+            s_type: StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
+            p_next: ::std::ptr::null(),
+            semaphore: Semaphore::default(),
+            handle_type: ExternalSemaphoreHandleTypeFlags::default(),
+        }
+    }
+}
+impl SemaphoreGetZirconHandleInfoFUCHSIA {
+    pub fn builder<'a>() -> SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
+        SemaphoreGetZirconHandleInfoFUCHSIABuilder {
+            inner: SemaphoreGetZirconHandleInfoFUCHSIA::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
+    inner: SemaphoreGetZirconHandleInfoFUCHSIA,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
+    type Target = SemaphoreGetZirconHandleInfoFUCHSIA;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> SemaphoreGetZirconHandleInfoFUCHSIABuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
+        self.inner.semaphore = semaphore;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalSemaphoreHandleTypeFlags) -> Self {
+        self.inner.handle_type = handle_type;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> SemaphoreGetZirconHandleInfoFUCHSIA {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalFenceInfo.html>"]
 pub struct PhysicalDeviceExternalFenceInfo {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub handle_type: ExternalFenceHandleTypeFlags,
 }
 impl ::std::default::Default for PhysicalDeviceExternalFenceInfo {
     fn default() -> PhysicalDeviceExternalFenceInfo {
@@ -17950,53 +16423,32 @@ impl PhysicalDeviceExternalFenceInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceExternalFenceInfoBuilder<'a> {
     inner: PhysicalDeviceExternalFenceInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceExternalFenceInfo {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceExternalFenceInfoBuilder<'a> {
     type Target = PhysicalDeviceExternalFenceInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalFenceInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExternalFenceInfoBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalFenceHandleTypeFlags,
-    ) -> PhysicalDeviceExternalFenceInfoBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceExternalFenceInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceExternalFenceInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExternalFenceInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -18028,67 +16480,49 @@ impl ExternalFenceProperties {
         }
     }
 }
 #[repr(transparent)]
 pub struct ExternalFencePropertiesBuilder<'a> {
     inner: ExternalFenceProperties,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsExternalFenceProperties {}
 impl<'a> ::std::ops::Deref for ExternalFencePropertiesBuilder<'a> {
     type Target = ExternalFenceProperties;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalFencePropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalFencePropertiesBuilder<'a> {
     pub fn export_from_imported_handle_types(
         mut self,
         export_from_imported_handle_types: ExternalFenceHandleTypeFlags,
-    ) -> ExternalFencePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.export_from_imported_handle_types = export_from_imported_handle_types;
         self
     }
     pub fn compatible_handle_types(
         mut self,
         compatible_handle_types: ExternalFenceHandleTypeFlags,
-    ) -> ExternalFencePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.compatible_handle_types = compatible_handle_types;
         self
     }
     pub fn external_fence_features(
         mut self,
         external_fence_features: ExternalFenceFeatureFlags,
-    ) -> ExternalFencePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.external_fence_features = external_fence_features;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsExternalFenceProperties>(
-        mut self,
-        next: &'a mut T,
-    ) -> ExternalFencePropertiesBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalFenceProperties {
         self.inner
     }
 }
 #[repr(C)]
@@ -18130,20 +16564,17 @@ impl<'a> ::std::ops::Deref for ExportFen
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportFenceCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportFenceCreateInfoBuilder<'a> {
-    pub fn handle_types(
-        mut self,
-        handle_types: ExternalFenceHandleTypeFlags,
-    ) -> ExportFenceCreateInfoBuilder<'a> {
+    pub fn handle_types(mut self, handle_types: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_types = handle_types;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportFenceCreateInfo {
         self.inner
@@ -18182,69 +16613,48 @@ impl ImportFenceWin32HandleInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImportFenceWin32HandleInfoKHRBuilder<'a> {
     inner: ImportFenceWin32HandleInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImportFenceWin32HandleInfoKHR {}
 impl<'a> ::std::ops::Deref for ImportFenceWin32HandleInfoKHRBuilder<'a> {
     type Target = ImportFenceWin32HandleInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportFenceWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportFenceWin32HandleInfoKHRBuilder<'a> {
-    pub fn fence(mut self, fence: Fence) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn fence(mut self, fence: Fence) -> Self {
         self.inner.fence = fence;
         self
     }
-    pub fn flags(mut self, flags: FenceImportFlags) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalFenceHandleTypeFlags,
-    ) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn handle(mut self, handle: HANDLE) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle(mut self, handle: HANDLE) -> Self {
         self.inner.handle = handle;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImportFenceWin32HandleInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImportFenceWin32HandleInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportFenceWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -18290,28 +16700,25 @@ impl<'a> ::std::ops::Deref for ExportFen
     }
 }
 impl<'a> ::std::ops::DerefMut for ExportFenceWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExportFenceWin32HandleInfoKHRBuilder<'a> {
-    pub fn attributes(
-        mut self,
-        attributes: &'a SECURITY_ATTRIBUTES,
-    ) -> ExportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn attributes(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> Self {
         self.inner.p_attributes = attributes;
         self
     }
-    pub fn dw_access(mut self, dw_access: DWORD) -> ExportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn dw_access(mut self, dw_access: DWORD) -> Self {
         self.inner.dw_access = dw_access;
         self
     }
-    pub fn name(mut self, name: LPCWSTR) -> ExportFenceWin32HandleInfoKHRBuilder<'a> {
+    pub fn name(mut self, name: LPCWSTR) -> Self {
         self.inner.name = name;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExportFenceWin32HandleInfoKHR {
         self.inner
@@ -18344,57 +16751,36 @@ impl FenceGetWin32HandleInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct FenceGetWin32HandleInfoKHRBuilder<'a> {
     inner: FenceGetWin32HandleInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsFenceGetWin32HandleInfoKHR {}
 impl<'a> ::std::ops::Deref for FenceGetWin32HandleInfoKHRBuilder<'a> {
     type Target = FenceGetWin32HandleInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for FenceGetWin32HandleInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FenceGetWin32HandleInfoKHRBuilder<'a> {
-    pub fn fence(mut self, fence: Fence) -> FenceGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn fence(mut self, fence: Fence) -> Self {
         self.inner.fence = fence;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalFenceHandleTypeFlags,
-    ) -> FenceGetWin32HandleInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFenceGetWin32HandleInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> FenceGetWin32HandleInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FenceGetWin32HandleInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -18428,65 +16814,44 @@ impl ImportFenceFdInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImportFenceFdInfoKHRBuilder<'a> {
     inner: ImportFenceFdInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImportFenceFdInfoKHR {}
 impl<'a> ::std::ops::Deref for ImportFenceFdInfoKHRBuilder<'a> {
     type Target = ImportFenceFdInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportFenceFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportFenceFdInfoKHRBuilder<'a> {
-    pub fn fence(mut self, fence: Fence) -> ImportFenceFdInfoKHRBuilder<'a> {
+    pub fn fence(mut self, fence: Fence) -> Self {
         self.inner.fence = fence;
         self
     }
-    pub fn flags(mut self, flags: FenceImportFlags) -> ImportFenceFdInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalFenceHandleTypeFlags,
-    ) -> ImportFenceFdInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: FenceImportFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn fd(mut self, fd: c_int) -> ImportFenceFdInfoKHRBuilder<'a> {
+    pub fn fd(mut self, fd: c_int) -> Self {
         self.inner.fd = fd;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImportFenceFdInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImportFenceFdInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportFenceFdInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -18516,57 +16881,36 @@ impl FenceGetFdInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct FenceGetFdInfoKHRBuilder<'a> {
     inner: FenceGetFdInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsFenceGetFdInfoKHR {}
 impl<'a> ::std::ops::Deref for FenceGetFdInfoKHRBuilder<'a> {
     type Target = FenceGetFdInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for FenceGetFdInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FenceGetFdInfoKHRBuilder<'a> {
-    pub fn fence(mut self, fence: Fence) -> FenceGetFdInfoKHRBuilder<'a> {
+    pub fn fence(mut self, fence: Fence) -> Self {
         self.inner.fence = fence;
         self
     }
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalFenceHandleTypeFlags,
-    ) -> FenceGetFdInfoKHRBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalFenceHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFenceGetFdInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> FenceGetFdInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FenceGetFdInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -18598,45 +16942,41 @@ impl PhysicalDeviceMultiviewFeatures {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceMultiviewFeaturesBuilder<'a> {
     inner: PhysicalDeviceMultiviewFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiviewFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiviewFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceMultiviewFeaturesBuilder<'a> {
     type Target = PhysicalDeviceMultiviewFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
-    pub fn multiview(mut self, multiview: bool) -> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
+    pub fn multiview(mut self, multiview: bool) -> Self {
         self.inner.multiview = multiview.into();
         self
     }
-    pub fn multiview_geometry_shader(
-        mut self,
-        multiview_geometry_shader: bool,
-    ) -> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
+    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
         self.inner.multiview_geometry_shader = multiview_geometry_shader.into();
         self
     }
-    pub fn multiview_tessellation_shader(
-        mut self,
-        multiview_tessellation_shader: bool,
-    ) -> PhysicalDeviceMultiviewFeaturesBuilder<'a> {
+    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
         self.inner.multiview_tessellation_shader = multiview_tessellation_shader.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMultiviewFeatures {
         self.inner
@@ -18683,27 +17023,21 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiviewPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMultiviewPropertiesBuilder<'a> {
-    pub fn max_multiview_view_count(
-        mut self,
-        max_multiview_view_count: u32,
-    ) -> PhysicalDeviceMultiviewPropertiesBuilder<'a> {
+    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
         self.inner.max_multiview_view_count = max_multiview_view_count;
         self
     }
-    pub fn max_multiview_instance_index(
-        mut self,
-        max_multiview_instance_index: u32,
-    ) -> PhysicalDeviceMultiviewPropertiesBuilder<'a> {
+    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
         self.inner.max_multiview_instance_index = max_multiview_instance_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMultiviewProperties {
         self.inner
@@ -18758,33 +17092,27 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassMultiviewCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassMultiviewCreateInfoBuilder<'a> {
-    pub fn view_masks(mut self, view_masks: &'a [u32]) -> RenderPassMultiviewCreateInfoBuilder<'a> {
+    pub fn view_masks(mut self, view_masks: &'a [u32]) -> Self {
         self.inner.subpass_count = view_masks.len() as _;
         self.inner.p_view_masks = view_masks.as_ptr();
         self
     }
-    pub fn view_offsets(
-        mut self,
-        view_offsets: &'a [i32],
-    ) -> RenderPassMultiviewCreateInfoBuilder<'a> {
+    pub fn view_offsets(mut self, view_offsets: &'a [i32]) -> Self {
         self.inner.dependency_count = view_offsets.len() as _;
         self.inner.p_view_offsets = view_offsets.as_ptr();
         self
     }
-    pub fn correlation_masks(
-        mut self,
-        correlation_masks: &'a [u32],
-    ) -> RenderPassMultiviewCreateInfoBuilder<'a> {
+    pub fn correlation_masks(mut self, correlation_masks: &'a [u32]) -> Self {
         self.inner.correlation_mask_count = correlation_masks.len() as _;
         self.inner.p_correlation_masks = correlation_masks.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassMultiviewCreateInfo {
@@ -18836,117 +17164,78 @@ impl SurfaceCapabilities2EXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct SurfaceCapabilities2EXTBuilder<'a> {
     inner: SurfaceCapabilities2EXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSurfaceCapabilities2EXT {}
 impl<'a> ::std::ops::Deref for SurfaceCapabilities2EXTBuilder<'a> {
     type Target = SurfaceCapabilities2EXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceCapabilities2EXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceCapabilities2EXTBuilder<'a> {
-    pub fn min_image_count(mut self, min_image_count: u32) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn min_image_count(mut self, min_image_count: u32) -> Self {
         self.inner.min_image_count = min_image_count;
         self
     }
-    pub fn max_image_count(mut self, max_image_count: u32) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn max_image_count(mut self, max_image_count: u32) -> Self {
         self.inner.max_image_count = max_image_count;
         self
     }
-    pub fn current_extent(
-        mut self,
-        current_extent: Extent2D,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn current_extent(mut self, current_extent: Extent2D) -> Self {
         self.inner.current_extent = current_extent;
         self
     }
-    pub fn min_image_extent(
-        mut self,
-        min_image_extent: Extent2D,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn min_image_extent(mut self, min_image_extent: Extent2D) -> Self {
         self.inner.min_image_extent = min_image_extent;
         self
     }
-    pub fn max_image_extent(
-        mut self,
-        max_image_extent: Extent2D,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn max_image_extent(mut self, max_image_extent: Extent2D) -> Self {
         self.inner.max_image_extent = max_image_extent;
         self
     }
-    pub fn max_image_array_layers(
-        mut self,
-        max_image_array_layers: u32,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn max_image_array_layers(mut self, max_image_array_layers: u32) -> Self {
         self.inner.max_image_array_layers = max_image_array_layers;
         self
     }
-    pub fn supported_transforms(
-        mut self,
-        supported_transforms: SurfaceTransformFlagsKHR,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn supported_transforms(mut self, supported_transforms: SurfaceTransformFlagsKHR) -> Self {
         self.inner.supported_transforms = supported_transforms;
         self
     }
-    pub fn current_transform(
-        mut self,
-        current_transform: SurfaceTransformFlagsKHR,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn current_transform(mut self, current_transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.current_transform = current_transform;
         self
     }
     pub fn supported_composite_alpha(
         mut self,
         supported_composite_alpha: CompositeAlphaFlagsKHR,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    ) -> Self {
         self.inner.supported_composite_alpha = supported_composite_alpha;
         self
     }
-    pub fn supported_usage_flags(
-        mut self,
-        supported_usage_flags: ImageUsageFlags,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    pub fn supported_usage_flags(mut self, supported_usage_flags: ImageUsageFlags) -> Self {
         self.inner.supported_usage_flags = supported_usage_flags;
         self
     }
     pub fn supported_surface_counters(
         mut self,
         supported_surface_counters: SurfaceCounterFlagsEXT,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
+    ) -> Self {
         self.inner.supported_surface_counters = supported_surface_counters;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSurfaceCapabilities2EXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> SurfaceCapabilities2EXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceCapabilities2EXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -18974,53 +17263,32 @@ impl DisplayPowerInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayPowerInfoEXTBuilder<'a> {
     inner: DisplayPowerInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayPowerInfoEXT {}
 impl<'a> ::std::ops::Deref for DisplayPowerInfoEXTBuilder<'a> {
     type Target = DisplayPowerInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPowerInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPowerInfoEXTBuilder<'a> {
-    pub fn power_state(
-        mut self,
-        power_state: DisplayPowerStateEXT,
-    ) -> DisplayPowerInfoEXTBuilder<'a> {
+    pub fn power_state(mut self, power_state: DisplayPowerStateEXT) -> Self {
         self.inner.power_state = power_state;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayPowerInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayPowerInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPowerInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -19048,53 +17316,32 @@ impl DeviceEventInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DeviceEventInfoEXTBuilder<'a> {
     inner: DeviceEventInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDeviceEventInfoEXT {}
 impl<'a> ::std::ops::Deref for DeviceEventInfoEXTBuilder<'a> {
     type Target = DeviceEventInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceEventInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceEventInfoEXTBuilder<'a> {
-    pub fn device_event(
-        mut self,
-        device_event: DeviceEventTypeEXT,
-    ) -> DeviceEventInfoEXTBuilder<'a> {
+    pub fn device_event(mut self, device_event: DeviceEventTypeEXT) -> Self {
         self.inner.device_event = device_event;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceEventInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceEventInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceEventInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -19122,53 +17369,32 @@ impl DisplayEventInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayEventInfoEXTBuilder<'a> {
     inner: DisplayEventInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayEventInfoEXT {}
 impl<'a> ::std::ops::Deref for DisplayEventInfoEXTBuilder<'a> {
     type Target = DisplayEventInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayEventInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayEventInfoEXTBuilder<'a> {
-    pub fn display_event(
-        mut self,
-        display_event: DisplayEventTypeEXT,
-    ) -> DisplayEventInfoEXTBuilder<'a> {
+    pub fn display_event(mut self, display_event: DisplayEventTypeEXT) -> Self {
         self.inner.display_event = display_event;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayEventInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayEventInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayEventInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -19210,20 +17436,17 @@ impl<'a> ::std::ops::Deref for Swapchain
     }
 }
 impl<'a> ::std::ops::DerefMut for SwapchainCounterCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SwapchainCounterCreateInfoEXTBuilder<'a> {
-    pub fn surface_counters(
-        mut self,
-        surface_counters: SurfaceCounterFlagsEXT,
-    ) -> SwapchainCounterCreateInfoEXTBuilder<'a> {
+    pub fn surface_counters(mut self, surface_counters: SurfaceCounterFlagsEXT) -> Self {
         self.inner.surface_counters = surface_counters;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SwapchainCounterCreateInfoEXT {
         self.inner
@@ -19258,67 +17481,43 @@ impl PhysicalDeviceGroupProperties {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceGroupPropertiesBuilder<'a> {
     inner: PhysicalDeviceGroupProperties,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceGroupProperties {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceGroupPropertiesBuilder<'a> {
     type Target = PhysicalDeviceGroupProperties;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceGroupPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceGroupPropertiesBuilder<'a> {
-    pub fn physical_device_count(
-        mut self,
-        physical_device_count: u32,
-    ) -> PhysicalDeviceGroupPropertiesBuilder<'a> {
+    pub fn physical_device_count(mut self, physical_device_count: u32) -> Self {
         self.inner.physical_device_count = physical_device_count;
         self
     }
     pub fn physical_devices(
         mut self,
         physical_devices: [PhysicalDevice; MAX_DEVICE_GROUP_SIZE],
-    ) -> PhysicalDeviceGroupPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.physical_devices = physical_devices;
         self
     }
-    pub fn subset_allocation(
-        mut self,
-        subset_allocation: bool,
-    ) -> PhysicalDeviceGroupPropertiesBuilder<'a> {
+    pub fn subset_allocation(mut self, subset_allocation: bool) -> Self {
         self.inner.subset_allocation = subset_allocation.into();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceGroupProperties>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceGroupPropertiesBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceGroupProperties {
         self.inner
     }
 }
 #[repr(C)]
@@ -19362,21 +17561,21 @@ impl<'a> ::std::ops::Deref for MemoryAll
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryAllocateFlagsInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryAllocateFlagsInfoBuilder<'a> {
-    pub fn flags(mut self, flags: MemoryAllocateFlags) -> MemoryAllocateFlagsInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn device_mask(mut self, device_mask: u32) -> MemoryAllocateFlagsInfoBuilder<'a> {
+    pub fn flags(mut self, flags: MemoryAllocateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn device_mask(mut self, device_mask: u32) -> Self {
         self.inner.device_mask = device_mask;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryAllocateFlagsInfo {
         self.inner
@@ -19424,37 +17623,34 @@ impl<'a> ::std::ops::Deref for BindBuffe
     }
 }
 impl<'a> ::std::ops::DerefMut for BindBufferMemoryInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindBufferMemoryInfoBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> BindBufferMemoryInfoBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn memory(mut self, memory: DeviceMemory) -> BindBufferMemoryInfoBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> BindBufferMemoryInfoBuilder<'a> {
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
         self.inner.memory_offset = memory_offset;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBindBufferMemoryInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BindBufferMemoryInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsBindBufferMemoryInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -19506,20 +17702,17 @@ impl<'a> ::std::ops::Deref for BindBuffe
     }
 }
 impl<'a> ::std::ops::DerefMut for BindBufferMemoryDeviceGroupInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindBufferMemoryDeviceGroupInfoBuilder<'a> {
-    pub fn device_indices(
-        mut self,
-        device_indices: &'a [u32],
-    ) -> BindBufferMemoryDeviceGroupInfoBuilder<'a> {
+    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
         self.inner.device_index_count = device_indices.len() as _;
         self.inner.p_device_indices = device_indices.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindBufferMemoryDeviceGroupInfo {
@@ -19568,37 +17761,34 @@ impl<'a> ::std::ops::Deref for BindImage
     }
 }
 impl<'a> ::std::ops::DerefMut for BindImageMemoryInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindImageMemoryInfoBuilder<'a> {
-    pub fn image(mut self, image: Image) -> BindImageMemoryInfoBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn memory(mut self, memory: DeviceMemory) -> BindImageMemoryInfoBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> BindImageMemoryInfoBuilder<'a> {
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
         self.inner.memory_offset = memory_offset;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBindImageMemoryInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BindImageMemoryInfoBuilder<'a> {
+    pub fn push_next<T: ExtendsBindImageMemoryInfo>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -19654,28 +17844,25 @@ impl<'a> ::std::ops::Deref for BindImage
     }
 }
 impl<'a> ::std::ops::DerefMut for BindImageMemoryDeviceGroupInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindImageMemoryDeviceGroupInfoBuilder<'a> {
-    pub fn device_indices(
-        mut self,
-        device_indices: &'a [u32],
-    ) -> BindImageMemoryDeviceGroupInfoBuilder<'a> {
+    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
         self.inner.device_index_count = device_indices.len() as _;
         self.inner.p_device_indices = device_indices.as_ptr();
         self
     }
     pub fn split_instance_bind_regions(
         mut self,
         split_instance_bind_regions: &'a [Rect2D],
-    ) -> BindImageMemoryDeviceGroupInfoBuilder<'a> {
+    ) -> Self {
         self.inner.split_instance_bind_region_count = split_instance_bind_regions.len() as _;
         self.inner.p_split_instance_bind_regions = split_instance_bind_regions.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindImageMemoryDeviceGroupInfo {
@@ -19725,24 +17912,21 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupRenderPassBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupRenderPassBeginInfoBuilder<'a> {
-    pub fn device_mask(mut self, device_mask: u32) -> DeviceGroupRenderPassBeginInfoBuilder<'a> {
+    pub fn device_mask(mut self, device_mask: u32) -> Self {
         self.inner.device_mask = device_mask;
         self
     }
-    pub fn device_render_areas(
-        mut self,
-        device_render_areas: &'a [Rect2D],
-    ) -> DeviceGroupRenderPassBeginInfoBuilder<'a> {
+    pub fn device_render_areas(mut self, device_render_areas: &'a [Rect2D]) -> Self {
         self.inner.device_render_area_count = device_render_areas.len() as _;
         self.inner.p_device_render_areas = device_render_areas.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupRenderPassBeginInfo {
@@ -19788,17 +17972,17 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupCommandBufferBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupCommandBufferBeginInfoBuilder<'a> {
-    pub fn device_mask(mut self, device_mask: u32) -> DeviceGroupCommandBufferBeginInfoBuilder<'a> {
+    pub fn device_mask(mut self, device_mask: u32) -> Self {
         self.inner.device_mask = device_mask;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupCommandBufferBeginInfo {
         self.inner
@@ -19856,33 +18040,30 @@ impl<'a> ::std::ops::DerefMut for Device
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupSubmitInfoBuilder<'a> {
     pub fn wait_semaphore_device_indices(
         mut self,
         wait_semaphore_device_indices: &'a [u32],
-    ) -> DeviceGroupSubmitInfoBuilder<'a> {
+    ) -> Self {
         self.inner.wait_semaphore_count = wait_semaphore_device_indices.len() as _;
         self.inner.p_wait_semaphore_device_indices = wait_semaphore_device_indices.as_ptr();
         self
     }
-    pub fn command_buffer_device_masks(
-        mut self,
-        command_buffer_device_masks: &'a [u32],
-    ) -> DeviceGroupSubmitInfoBuilder<'a> {
+    pub fn command_buffer_device_masks(mut self, command_buffer_device_masks: &'a [u32]) -> Self {
         self.inner.command_buffer_count = command_buffer_device_masks.len() as _;
         self.inner.p_command_buffer_device_masks = command_buffer_device_masks.as_ptr();
         self
     }
     pub fn signal_semaphore_device_indices(
         mut self,
         signal_semaphore_device_indices: &'a [u32],
-    ) -> DeviceGroupSubmitInfoBuilder<'a> {
+    ) -> Self {
         self.inner.signal_semaphore_count = signal_semaphore_device_indices.len() as _;
         self.inner.p_signal_semaphore_device_indices = signal_semaphore_device_indices.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupSubmitInfo {
@@ -19930,51 +18111,45 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupBindSparseInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupBindSparseInfoBuilder<'a> {
-    pub fn resource_device_index(
-        mut self,
-        resource_device_index: u32,
-    ) -> DeviceGroupBindSparseInfoBuilder<'a> {
+    pub fn resource_device_index(mut self, resource_device_index: u32) -> Self {
         self.inner.resource_device_index = resource_device_index;
         self
     }
-    pub fn memory_device_index(
-        mut self,
-        memory_device_index: u32,
-    ) -> DeviceGroupBindSparseInfoBuilder<'a> {
+    pub fn memory_device_index(mut self, memory_device_index: u32) -> Self {
         self.inner.memory_device_index = memory_device_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupBindSparseInfo {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceGroupPresentCapabilitiesKHR.html>"]
 pub struct DeviceGroupPresentCapabilitiesKHR {
     pub s_type: StructureType,
-    pub p_next: *const c_void,
+    pub p_next: *mut c_void,
     pub present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
     pub modes: DeviceGroupPresentModeFlagsKHR,
 }
 impl ::std::default::Default for DeviceGroupPresentCapabilitiesKHR {
     fn default() -> DeviceGroupPresentCapabilitiesKHR {
         DeviceGroupPresentCapabilitiesKHR {
             s_type: StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
-            p_next: ::std::ptr::null(),
+            p_next: ::std::ptr::null_mut(),
             present_mask: unsafe { ::std::mem::zeroed() },
             modes: DeviceGroupPresentModeFlagsKHR::default(),
         }
     }
 }
 impl DeviceGroupPresentCapabilitiesKHR {
     pub fn builder<'a>() -> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
         DeviceGroupPresentCapabilitiesKHRBuilder {
@@ -19983,60 +18158,36 @@ impl DeviceGroupPresentCapabilitiesKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
     inner: DeviceGroupPresentCapabilitiesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDeviceGroupPresentCapabilitiesKHR {}
 impl<'a> ::std::ops::Deref for DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
     type Target = DeviceGroupPresentCapabilitiesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
-    pub fn present_mask(
-        mut self,
-        present_mask: [u32; MAX_DEVICE_GROUP_SIZE],
-    ) -> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
+    pub fn present_mask(mut self, present_mask: [u32; MAX_DEVICE_GROUP_SIZE]) -> Self {
         self.inner.present_mask = present_mask;
         self
     }
-    pub fn modes(
-        mut self,
-        modes: DeviceGroupPresentModeFlagsKHR,
-    ) -> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
+    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
         self.inner.modes = modes;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceGroupPresentCapabilitiesKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceGroupPresentCapabilitiesKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupPresentCapabilitiesKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -20078,17 +18229,17 @@ impl<'a> ::std::ops::Deref for ImageSwap
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageSwapchainCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageSwapchainCreateInfoKHRBuilder<'a> {
-    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> ImageSwapchainCreateInfoKHRBuilder<'a> {
+    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
         self.inner.swapchain = swapchain;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageSwapchainCreateInfoKHR {
         self.inner
@@ -20135,24 +18286,21 @@ impl<'a> ::std::ops::Deref for BindImage
     }
 }
 impl<'a> ::std::ops::DerefMut for BindImageMemorySwapchainInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindImageMemorySwapchainInfoKHRBuilder<'a> {
-    pub fn swapchain(
-        mut self,
-        swapchain: SwapchainKHR,
-    ) -> BindImageMemorySwapchainInfoKHRBuilder<'a> {
+    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
         self.inner.swapchain = swapchain;
         self
     }
-    pub fn image_index(mut self, image_index: u32) -> BindImageMemorySwapchainInfoKHRBuilder<'a> {
+    pub fn image_index(mut self, image_index: u32) -> Self {
         self.inner.image_index = image_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindImageMemorySwapchainInfoKHR {
         self.inner
@@ -20191,66 +18339,48 @@ impl AcquireNextImageInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct AcquireNextImageInfoKHRBuilder<'a> {
     inner: AcquireNextImageInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAcquireNextImageInfoKHR {}
 impl<'a> ::std::ops::Deref for AcquireNextImageInfoKHRBuilder<'a> {
     type Target = AcquireNextImageInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AcquireNextImageInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AcquireNextImageInfoKHRBuilder<'a> {
-    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> AcquireNextImageInfoKHRBuilder<'a> {
+    pub fn swapchain(mut self, swapchain: SwapchainKHR) -> Self {
         self.inner.swapchain = swapchain;
         self
     }
-    pub fn timeout(mut self, timeout: u64) -> AcquireNextImageInfoKHRBuilder<'a> {
+    pub fn timeout(mut self, timeout: u64) -> Self {
         self.inner.timeout = timeout;
         self
     }
-    pub fn semaphore(mut self, semaphore: Semaphore) -> AcquireNextImageInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn fence(mut self, fence: Fence) -> AcquireNextImageInfoKHRBuilder<'a> {
+    pub fn fence(mut self, fence: Fence) -> Self {
         self.inner.fence = fence;
         self
     }
-    pub fn device_mask(mut self, device_mask: u32) -> AcquireNextImageInfoKHRBuilder<'a> {
+    pub fn device_mask(mut self, device_mask: u32) -> Self {
         self.inner.device_mask = device_mask;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAcquireNextImageInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AcquireNextImageInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AcquireNextImageInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -20296,25 +18426,22 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupPresentInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupPresentInfoKHRBuilder<'a> {
-    pub fn device_masks(mut self, device_masks: &'a [u32]) -> DeviceGroupPresentInfoKHRBuilder<'a> {
+    pub fn device_masks(mut self, device_masks: &'a [u32]) -> Self {
         self.inner.swapchain_count = device_masks.len() as _;
         self.inner.p_device_masks = device_masks.as_ptr();
         self
     }
-    pub fn mode(
-        mut self,
-        mode: DeviceGroupPresentModeFlagsKHR,
-    ) -> DeviceGroupPresentInfoKHRBuilder<'a> {
+    pub fn mode(mut self, mode: DeviceGroupPresentModeFlagsKHR) -> Self {
         self.inner.mode = mode;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupPresentInfoKHR {
         self.inner
@@ -20361,20 +18488,17 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupDeviceCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupDeviceCreateInfoBuilder<'a> {
-    pub fn physical_devices(
-        mut self,
-        physical_devices: &'a [PhysicalDevice],
-    ) -> DeviceGroupDeviceCreateInfoBuilder<'a> {
+    pub fn physical_devices(mut self, physical_devices: &'a [PhysicalDevice]) -> Self {
         self.inner.physical_device_count = physical_devices.len() as _;
         self.inner.p_physical_devices = physical_devices.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupDeviceCreateInfo {
@@ -20420,20 +18544,17 @@ impl<'a> ::std::ops::Deref for DeviceGro
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
-    pub fn modes(
-        mut self,
-        modes: DeviceGroupPresentModeFlagsKHR,
-    ) -> DeviceGroupSwapchainCreateInfoKHRBuilder<'a> {
+    pub fn modes(mut self, modes: DeviceGroupPresentModeFlagsKHR) -> Self {
         self.inner.modes = modes;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceGroupSwapchainCreateInfoKHR {
         self.inner
@@ -20470,46 +18591,37 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorUpdateTemplateEntryBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorUpdateTemplateEntryBuilder<'a> {
-    pub fn dst_binding(mut self, dst_binding: u32) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn dst_binding(mut self, dst_binding: u32) -> Self {
         self.inner.dst_binding = dst_binding;
         self
     }
-    pub fn dst_array_element(
-        mut self,
-        dst_array_element: u32,
-    ) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn dst_array_element(mut self, dst_array_element: u32) -> Self {
         self.inner.dst_array_element = dst_array_element;
         self
     }
-    pub fn descriptor_count(
-        mut self,
-        descriptor_count: u32,
-    ) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn descriptor_count(mut self, descriptor_count: u32) -> Self {
         self.inner.descriptor_count = descriptor_count;
         self
     }
-    pub fn descriptor_type(
-        mut self,
-        descriptor_type: DescriptorType,
-    ) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
         self.inner.descriptor_type = descriptor_type;
         self
     }
-    pub fn offset(mut self, offset: usize) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn offset(mut self, offset: usize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn stride(mut self, stride: usize) -> DescriptorUpdateTemplateEntryBuilder<'a> {
+    pub fn stride(mut self, stride: usize) -> Self {
         self.inner.stride = stride;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorUpdateTemplateEntry {
         self.inner
@@ -20554,93 +18666,60 @@ impl DescriptorUpdateTemplateCreateInfo 
         }
     }
 }
 #[repr(transparent)]
 pub struct DescriptorUpdateTemplateCreateInfoBuilder<'a> {
     inner: DescriptorUpdateTemplateCreateInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDescriptorUpdateTemplateCreateInfo {}
 impl<'a> ::std::ops::Deref for DescriptorUpdateTemplateCreateInfoBuilder<'a> {
     type Target = DescriptorUpdateTemplateCreateInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorUpdateTemplateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DescriptorUpdateTemplateCreateFlags,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn flags(mut self, flags: DescriptorUpdateTemplateCreateFlags) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn descriptor_update_entries(
         mut self,
         descriptor_update_entries: &'a [DescriptorUpdateTemplateEntry],
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_update_entry_count = descriptor_update_entries.len() as _;
         self.inner.p_descriptor_update_entries = descriptor_update_entries.as_ptr();
         self
     }
-    pub fn template_type(
-        mut self,
-        template_type: DescriptorUpdateTemplateType,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn template_type(mut self, template_type: DescriptorUpdateTemplateType) -> Self {
         self.inner.template_type = template_type;
         self
     }
-    pub fn descriptor_set_layout(
-        mut self,
-        descriptor_set_layout: DescriptorSetLayout,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn descriptor_set_layout(mut self, descriptor_set_layout: DescriptorSetLayout) -> Self {
         self.inner.descriptor_set_layout = descriptor_set_layout;
         self
     }
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn pipeline_layout(
-        mut self,
-        pipeline_layout: PipelineLayout,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn pipeline_layout(mut self, pipeline_layout: PipelineLayout) -> Self {
         self.inner.pipeline_layout = pipeline_layout;
         self
     }
-    pub fn set(mut self, set: u32) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
+    pub fn set(mut self, set: u32) -> Self {
         self.inner.set = set;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDescriptorUpdateTemplateCreateInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DescriptorUpdateTemplateCreateInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorUpdateTemplateCreateInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -20670,33 +18749,205 @@ impl<'a> ::std::ops::Deref for XYColorEX
     }
 }
 impl<'a> ::std::ops::DerefMut for XYColorEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> XYColorEXTBuilder<'a> {
-    pub fn x(mut self, x: f32) -> XYColorEXTBuilder<'a> {
+    pub fn x(mut self, x: f32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: f32) -> XYColorEXTBuilder<'a> {
+    pub fn y(mut self, y: f32) -> Self {
         self.inner.y = y;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> XYColorEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html>"]
+pub struct PhysicalDevicePresentIdFeaturesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub present_id: Bool32,
+}
+impl ::std::default::Default for PhysicalDevicePresentIdFeaturesKHR {
+    fn default() -> PhysicalDevicePresentIdFeaturesKHR {
+        PhysicalDevicePresentIdFeaturesKHR {
+            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            present_id: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDevicePresentIdFeaturesKHR {
+    pub fn builder<'a>() -> PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
+        PhysicalDevicePresentIdFeaturesKHRBuilder {
+            inner: PhysicalDevicePresentIdFeaturesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
+    inner: PhysicalDevicePresentIdFeaturesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentIdFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentIdFeaturesKHR {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentIdFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentIdFeaturesKHR {}
+impl<'a> ::std::ops::Deref for PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
+    type Target = PhysicalDevicePresentIdFeaturesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDevicePresentIdFeaturesKHRBuilder<'a> {
+    pub fn present_id(mut self, present_id: bool) -> Self {
+        self.inner.present_id = present_id.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDevicePresentIdFeaturesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPresentIdKHR.html>"]
+pub struct PresentIdKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub swapchain_count: u32,
+    pub p_present_ids: *const u64,
+}
+impl ::std::default::Default for PresentIdKHR {
+    fn default() -> PresentIdKHR {
+        PresentIdKHR {
+            s_type: StructureType::PRESENT_ID_KHR,
+            p_next: ::std::ptr::null(),
+            swapchain_count: u32::default(),
+            p_present_ids: ::std::ptr::null(),
+        }
+    }
+}
+impl PresentIdKHR {
+    pub fn builder<'a>() -> PresentIdKHRBuilder<'a> {
+        PresentIdKHRBuilder {
+            inner: PresentIdKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PresentIdKHRBuilder<'a> {
+    inner: PresentIdKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPresentInfoKHR for PresentIdKHRBuilder<'_> {}
+unsafe impl ExtendsPresentInfoKHR for PresentIdKHR {}
+impl<'a> ::std::ops::Deref for PresentIdKHRBuilder<'a> {
+    type Target = PresentIdKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PresentIdKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PresentIdKHRBuilder<'a> {
+    pub fn present_ids(mut self, present_ids: &'a [u64]) -> Self {
+        self.inner.swapchain_count = present_ids.len() as _;
+        self.inner.p_present_ids = present_ids.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PresentIdKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html>"]
+pub struct PhysicalDevicePresentWaitFeaturesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub present_wait: Bool32,
+}
+impl ::std::default::Default for PhysicalDevicePresentWaitFeaturesKHR {
+    fn default() -> PhysicalDevicePresentWaitFeaturesKHR {
+        PhysicalDevicePresentWaitFeaturesKHR {
+            s_type: StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            present_wait: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDevicePresentWaitFeaturesKHR {
+    pub fn builder<'a>() -> PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
+        PhysicalDevicePresentWaitFeaturesKHRBuilder {
+            inner: PhysicalDevicePresentWaitFeaturesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
+    inner: PhysicalDevicePresentWaitFeaturesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentWaitFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePresentWaitFeaturesKHR {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentWaitFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePresentWaitFeaturesKHR {}
+impl<'a> ::std::ops::Deref for PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
+    type Target = PhysicalDevicePresentWaitFeaturesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDevicePresentWaitFeaturesKHRBuilder<'a> {
+    pub fn present_wait(mut self, present_wait: bool) -> Self {
+        self.inner.present_wait = present_wait.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDevicePresentWaitFeaturesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkHdrMetadataEXT.html>"]
 pub struct HdrMetadataEXT {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub display_primary_red: XYColorEXT,
     pub display_primary_green: XYColorEXT,
     pub display_primary_blue: XYColorEXT,
     pub white_point: XYColorEXT,
@@ -20729,93 +18980,60 @@ impl HdrMetadataEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct HdrMetadataEXTBuilder<'a> {
     inner: HdrMetadataEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsHdrMetadataEXT {}
 impl<'a> ::std::ops::Deref for HdrMetadataEXTBuilder<'a> {
     type Target = HdrMetadataEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for HdrMetadataEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> HdrMetadataEXTBuilder<'a> {
-    pub fn display_primary_red(
-        mut self,
-        display_primary_red: XYColorEXT,
-    ) -> HdrMetadataEXTBuilder<'a> {
+    pub fn display_primary_red(mut self, display_primary_red: XYColorEXT) -> Self {
         self.inner.display_primary_red = display_primary_red;
         self
     }
-    pub fn display_primary_green(
-        mut self,
-        display_primary_green: XYColorEXT,
-    ) -> HdrMetadataEXTBuilder<'a> {
+    pub fn display_primary_green(mut self, display_primary_green: XYColorEXT) -> Self {
         self.inner.display_primary_green = display_primary_green;
         self
     }
-    pub fn display_primary_blue(
-        mut self,
-        display_primary_blue: XYColorEXT,
-    ) -> HdrMetadataEXTBuilder<'a> {
+    pub fn display_primary_blue(mut self, display_primary_blue: XYColorEXT) -> Self {
         self.inner.display_primary_blue = display_primary_blue;
         self
     }
-    pub fn white_point(mut self, white_point: XYColorEXT) -> HdrMetadataEXTBuilder<'a> {
+    pub fn white_point(mut self, white_point: XYColorEXT) -> Self {
         self.inner.white_point = white_point;
         self
     }
-    pub fn max_luminance(mut self, max_luminance: f32) -> HdrMetadataEXTBuilder<'a> {
+    pub fn max_luminance(mut self, max_luminance: f32) -> Self {
         self.inner.max_luminance = max_luminance;
         self
     }
-    pub fn min_luminance(mut self, min_luminance: f32) -> HdrMetadataEXTBuilder<'a> {
+    pub fn min_luminance(mut self, min_luminance: f32) -> Self {
         self.inner.min_luminance = min_luminance;
         self
     }
-    pub fn max_content_light_level(
-        mut self,
-        max_content_light_level: f32,
-    ) -> HdrMetadataEXTBuilder<'a> {
+    pub fn max_content_light_level(mut self, max_content_light_level: f32) -> Self {
         self.inner.max_content_light_level = max_content_light_level;
         self
     }
-    pub fn max_frame_average_light_level(
-        mut self,
-        max_frame_average_light_level: f32,
-    ) -> HdrMetadataEXTBuilder<'a> {
+    pub fn max_frame_average_light_level(mut self, max_frame_average_light_level: f32) -> Self {
         self.inner.max_frame_average_light_level = max_frame_average_light_level;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsHdrMetadataEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> HdrMetadataEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> HdrMetadataEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -20857,20 +19075,17 @@ impl<'a> ::std::ops::Deref for DisplayNa
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
-    pub fn local_dimming_support(
-        mut self,
-        local_dimming_support: bool,
-    ) -> DisplayNativeHdrSurfaceCapabilitiesAMDBuilder<'a> {
+    pub fn local_dimming_support(mut self, local_dimming_support: bool) -> Self {
         self.inner.local_dimming_support = local_dimming_support.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayNativeHdrSurfaceCapabilitiesAMD {
         self.inner
@@ -20915,20 +19130,17 @@ impl<'a> ::std::ops::Deref for Swapchain
     }
 }
 impl<'a> ::std::ops::DerefMut for SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
-    pub fn local_dimming_enable(
-        mut self,
-        local_dimming_enable: bool,
-    ) -> SwapchainDisplayNativeHdrCreateInfoAMDBuilder<'a> {
+    pub fn local_dimming_enable(mut self, local_dimming_enable: bool) -> Self {
         self.inner.local_dimming_enable = local_dimming_enable.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SwapchainDisplayNativeHdrCreateInfoAMD {
         self.inner
@@ -20960,20 +19172,17 @@ impl<'a> ::std::ops::Deref for RefreshCy
     }
 }
 impl<'a> ::std::ops::DerefMut for RefreshCycleDurationGOOGLEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RefreshCycleDurationGOOGLEBuilder<'a> {
-    pub fn refresh_duration(
-        mut self,
-        refresh_duration: u64,
-    ) -> RefreshCycleDurationGOOGLEBuilder<'a> {
+    pub fn refresh_duration(mut self, refresh_duration: u64) -> Self {
         self.inner.refresh_duration = refresh_duration;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RefreshCycleDurationGOOGLE {
         self.inner
@@ -21009,45 +19218,33 @@ impl<'a> ::std::ops::Deref for PastPrese
     }
 }
 impl<'a> ::std::ops::DerefMut for PastPresentationTimingGOOGLEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PastPresentationTimingGOOGLEBuilder<'a> {
-    pub fn present_id(mut self, present_id: u32) -> PastPresentationTimingGOOGLEBuilder<'a> {
+    pub fn present_id(mut self, present_id: u32) -> Self {
         self.inner.present_id = present_id;
         self
     }
-    pub fn desired_present_time(
-        mut self,
-        desired_present_time: u64,
-    ) -> PastPresentationTimingGOOGLEBuilder<'a> {
+    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
         self.inner.desired_present_time = desired_present_time;
         self
     }
-    pub fn actual_present_time(
-        mut self,
-        actual_present_time: u64,
-    ) -> PastPresentationTimingGOOGLEBuilder<'a> {
+    pub fn actual_present_time(mut self, actual_present_time: u64) -> Self {
         self.inner.actual_present_time = actual_present_time;
         self
     }
-    pub fn earliest_present_time(
-        mut self,
-        earliest_present_time: u64,
-    ) -> PastPresentationTimingGOOGLEBuilder<'a> {
+    pub fn earliest_present_time(mut self, earliest_present_time: u64) -> Self {
         self.inner.earliest_present_time = earliest_present_time;
         self
     }
-    pub fn present_margin(
-        mut self,
-        present_margin: u64,
-    ) -> PastPresentationTimingGOOGLEBuilder<'a> {
+    pub fn present_margin(mut self, present_margin: u64) -> Self {
         self.inner.present_margin = present_margin;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PastPresentationTimingGOOGLE {
         self.inner
@@ -21094,17 +19291,17 @@ impl<'a> ::std::ops::Deref for PresentTi
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentTimesInfoGOOGLEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentTimesInfoGOOGLEBuilder<'a> {
-    pub fn times(mut self, times: &'a [PresentTimeGOOGLE]) -> PresentTimesInfoGOOGLEBuilder<'a> {
+    pub fn times(mut self, times: &'a [PresentTimeGOOGLE]) -> Self {
         self.inner.swapchain_count = times.len() as _;
         self.inner.p_times = times.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PresentTimesInfoGOOGLE {
@@ -21138,24 +19335,21 @@ impl<'a> ::std::ops::Deref for PresentTi
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentTimeGOOGLEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentTimeGOOGLEBuilder<'a> {
-    pub fn present_id(mut self, present_id: u32) -> PresentTimeGOOGLEBuilder<'a> {
+    pub fn present_id(mut self, present_id: u32) -> Self {
         self.inner.present_id = present_id;
         self
     }
-    pub fn desired_present_time(
-        mut self,
-        desired_present_time: u64,
-    ) -> PresentTimeGOOGLEBuilder<'a> {
+    pub fn desired_present_time(mut self, desired_present_time: u64) -> Self {
         self.inner.desired_present_time = desired_present_time;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PresentTimeGOOGLE {
         self.inner
@@ -21188,54 +19382,36 @@ impl IOSSurfaceCreateInfoMVK {
         }
     }
 }
 #[repr(transparent)]
 pub struct IOSSurfaceCreateInfoMVKBuilder<'a> {
     inner: IOSSurfaceCreateInfoMVK,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsIOSSurfaceCreateInfoMVK {}
 impl<'a> ::std::ops::Deref for IOSSurfaceCreateInfoMVKBuilder<'a> {
     type Target = IOSSurfaceCreateInfoMVK;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for IOSSurfaceCreateInfoMVKBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> IOSSurfaceCreateInfoMVKBuilder<'a> {
-    pub fn flags(mut self, flags: IOSSurfaceCreateFlagsMVK) -> IOSSurfaceCreateInfoMVKBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn view(mut self, view: *const c_void) -> IOSSurfaceCreateInfoMVKBuilder<'a> {
+    pub fn flags(mut self, flags: IOSSurfaceCreateFlagsMVK) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn view(mut self, view: *const c_void) -> Self {
         self.inner.p_view = view;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsIOSSurfaceCreateInfoMVK>(
-        mut self,
-        next: &'a mut T,
-    ) -> IOSSurfaceCreateInfoMVKBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> IOSSurfaceCreateInfoMVK {
         self.inner
     }
 }
 #[repr(C)]
@@ -21265,57 +19441,36 @@ impl MacOSSurfaceCreateInfoMVK {
         }
     }
 }
 #[repr(transparent)]
 pub struct MacOSSurfaceCreateInfoMVKBuilder<'a> {
     inner: MacOSSurfaceCreateInfoMVK,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMacOSSurfaceCreateInfoMVK {}
 impl<'a> ::std::ops::Deref for MacOSSurfaceCreateInfoMVKBuilder<'a> {
     type Target = MacOSSurfaceCreateInfoMVK;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MacOSSurfaceCreateInfoMVKBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MacOSSurfaceCreateInfoMVKBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: MacOSSurfaceCreateFlagsMVK,
-    ) -> MacOSSurfaceCreateInfoMVKBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn view(mut self, view: *const c_void) -> MacOSSurfaceCreateInfoMVKBuilder<'a> {
+    pub fn flags(mut self, flags: MacOSSurfaceCreateFlagsMVK) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn view(mut self, view: *const c_void) -> Self {
         self.inner.p_view = view;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMacOSSurfaceCreateInfoMVK>(
-        mut self,
-        next: &'a mut T,
-    ) -> MacOSSurfaceCreateInfoMVKBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MacOSSurfaceCreateInfoMVK {
         self.inner
     }
 }
 #[repr(C)]
@@ -21345,57 +19500,36 @@ impl MetalSurfaceCreateInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct MetalSurfaceCreateInfoEXTBuilder<'a> {
     inner: MetalSurfaceCreateInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMetalSurfaceCreateInfoEXT {}
 impl<'a> ::std::ops::Deref for MetalSurfaceCreateInfoEXTBuilder<'a> {
     type Target = MetalSurfaceCreateInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MetalSurfaceCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MetalSurfaceCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: MetalSurfaceCreateFlagsEXT,
-    ) -> MetalSurfaceCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn layer(mut self, layer: *const CAMetalLayer) -> MetalSurfaceCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: MetalSurfaceCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn layer(mut self, layer: *const CAMetalLayer) -> Self {
         self.inner.p_layer = layer;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMetalSurfaceCreateInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> MetalSurfaceCreateInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MetalSurfaceCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -21425,21 +19559,21 @@ impl<'a> ::std::ops::Deref for ViewportW
     }
 }
 impl<'a> ::std::ops::DerefMut for ViewportWScalingNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ViewportWScalingNVBuilder<'a> {
-    pub fn xcoeff(mut self, xcoeff: f32) -> ViewportWScalingNVBuilder<'a> {
+    pub fn xcoeff(mut self, xcoeff: f32) -> Self {
         self.inner.xcoeff = xcoeff;
         self
     }
-    pub fn ycoeff(mut self, ycoeff: f32) -> ViewportWScalingNVBuilder<'a> {
+    pub fn ycoeff(mut self, ycoeff: f32) -> Self {
         self.inner.ycoeff = ycoeff;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ViewportWScalingNV {
         self.inner
@@ -21491,27 +19625,21 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
-    pub fn viewport_w_scaling_enable(
-        mut self,
-        viewport_w_scaling_enable: bool,
-    ) -> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
+    pub fn viewport_w_scaling_enable(mut self, viewport_w_scaling_enable: bool) -> Self {
         self.inner.viewport_w_scaling_enable = viewport_w_scaling_enable.into();
         self
     }
-    pub fn viewport_w_scalings(
-        mut self,
-        viewport_w_scalings: &'a [ViewportWScalingNV],
-    ) -> PipelineViewportWScalingStateCreateInfoNVBuilder<'a> {
+    pub fn viewport_w_scalings(mut self, viewport_w_scalings: &'a [ViewportWScalingNV]) -> Self {
         self.inner.viewport_count = viewport_w_scalings.len() as _;
         self.inner.p_viewport_w_scalings = viewport_w_scalings.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineViewportWScalingStateCreateInfoNV {
@@ -21547,29 +19675,29 @@ impl<'a> ::std::ops::Deref for ViewportS
     }
 }
 impl<'a> ::std::ops::DerefMut for ViewportSwizzleNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ViewportSwizzleNVBuilder<'a> {
-    pub fn x(mut self, x: ViewportCoordinateSwizzleNV) -> ViewportSwizzleNVBuilder<'a> {
+    pub fn x(mut self, x: ViewportCoordinateSwizzleNV) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: ViewportCoordinateSwizzleNV) -> ViewportSwizzleNVBuilder<'a> {
+    pub fn y(mut self, y: ViewportCoordinateSwizzleNV) -> Self {
         self.inner.y = y;
         self
     }
-    pub fn z(mut self, z: ViewportCoordinateSwizzleNV) -> ViewportSwizzleNVBuilder<'a> {
+    pub fn z(mut self, z: ViewportCoordinateSwizzleNV) -> Self {
         self.inner.z = z;
         self
     }
-    pub fn w(mut self, w: ViewportCoordinateSwizzleNV) -> ViewportSwizzleNVBuilder<'a> {
+    pub fn w(mut self, w: ViewportCoordinateSwizzleNV) -> Self {
         self.inner.w = w;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ViewportSwizzleNV {
         self.inner
@@ -21621,27 +19749,21 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineViewportSwizzleStateCreateFlagsNV,
-    ) -> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn viewport_swizzles(
-        mut self,
-        viewport_swizzles: &'a [ViewportSwizzleNV],
-    ) -> PipelineViewportSwizzleStateCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineViewportSwizzleStateCreateFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn viewport_swizzles(mut self, viewport_swizzles: &'a [ViewportSwizzleNV]) -> Self {
         self.inner.viewport_count = viewport_swizzles.len() as _;
         self.inner.p_viewport_swizzles = viewport_swizzles.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineViewportSwizzleStateCreateInfoNV {
@@ -21690,20 +19812,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
-    pub fn max_discard_rectangles(
-        mut self,
-        max_discard_rectangles: u32,
-    ) -> PhysicalDeviceDiscardRectanglePropertiesEXTBuilder<'a> {
+    pub fn max_discard_rectangles(mut self, max_discard_rectangles: u32) -> Self {
         self.inner.max_discard_rectangles = max_discard_rectangles;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDiscardRectanglePropertiesEXT {
         self.inner
@@ -21757,34 +19876,28 @@ impl<'a> ::std::ops::Deref for PipelineD
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineDiscardRectangleStateCreateFlagsEXT,
-    ) -> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineDiscardRectangleStateCreateFlagsEXT) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn discard_rectangle_mode(
         mut self,
         discard_rectangle_mode: DiscardRectangleModeEXT,
-    ) -> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.discard_rectangle_mode = discard_rectangle_mode;
         self
     }
-    pub fn discard_rectangles(
-        mut self,
-        discard_rectangles: &'a [Rect2D],
-    ) -> PipelineDiscardRectangleStateCreateInfoEXTBuilder<'a> {
+    pub fn discard_rectangles(mut self, discard_rectangles: &'a [Rect2D]) -> Self {
         self.inner.discard_rectangle_count = discard_rectangles.len() as _;
         self.inner.p_discard_rectangles = discard_rectangles.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineDiscardRectangleStateCreateInfoEXT {
@@ -21839,17 +19952,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
     pub fn per_view_position_all_components(
         mut self,
         per_view_position_all_components: bool,
-    ) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVXBuilder<'a> {
+    ) -> Self {
         self.inner.per_view_position_all_components = per_view_position_all_components.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
         self.inner
@@ -21883,31 +19996,25 @@ impl<'a> ::std::ops::Deref for InputAtta
     }
 }
 impl<'a> ::std::ops::DerefMut for InputAttachmentAspectReferenceBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> InputAttachmentAspectReferenceBuilder<'a> {
-    pub fn subpass(mut self, subpass: u32) -> InputAttachmentAspectReferenceBuilder<'a> {
+    pub fn subpass(mut self, subpass: u32) -> Self {
         self.inner.subpass = subpass;
         self
     }
-    pub fn input_attachment_index(
-        mut self,
-        input_attachment_index: u32,
-    ) -> InputAttachmentAspectReferenceBuilder<'a> {
+    pub fn input_attachment_index(mut self, input_attachment_index: u32) -> Self {
         self.inner.input_attachment_index = input_attachment_index;
         self
     }
-    pub fn aspect_mask(
-        mut self,
-        aspect_mask: ImageAspectFlags,
-    ) -> InputAttachmentAspectReferenceBuilder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> InputAttachmentAspectReference {
         self.inner
@@ -21957,17 +20064,17 @@ impl<'a> ::std::ops::DerefMut for Render
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
     pub fn aspect_references(
         mut self,
         aspect_references: &'a [InputAttachmentAspectReference],
-    ) -> RenderPassInputAttachmentAspectCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.aspect_reference_count = aspect_references.len() as _;
         self.inner.p_aspect_references = aspect_references.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassInputAttachmentAspectCreateInfo {
@@ -22012,29 +20119,26 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
-    pub fn surface(mut self, surface: SurfaceKHR) -> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
+    pub fn surface(mut self, surface: SurfaceKHR) -> Self {
         self.inner.surface = surface;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceSurfaceInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceSurfaceInfo2KHRBuilder<'a> {
+    pub fn push_next<T: ExtendsPhysicalDeviceSurfaceInfo2KHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -22083,32 +20187,26 @@ impl<'a> ::std::ops::Deref for SurfaceCa
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceCapabilities2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceCapabilities2KHRBuilder<'a> {
-    pub fn surface_capabilities(
-        mut self,
-        surface_capabilities: SurfaceCapabilitiesKHR,
-    ) -> SurfaceCapabilities2KHRBuilder<'a> {
+    pub fn surface_capabilities(mut self, surface_capabilities: SurfaceCapabilitiesKHR) -> Self {
         self.inner.surface_capabilities = surface_capabilities;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSurfaceCapabilities2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> SurfaceCapabilities2KHRBuilder<'a> {
+    pub fn push_next<T: ExtendsSurfaceCapabilities2KHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -22144,53 +20242,32 @@ impl SurfaceFormat2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct SurfaceFormat2KHRBuilder<'a> {
     inner: SurfaceFormat2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSurfaceFormat2KHR {}
 impl<'a> ::std::ops::Deref for SurfaceFormat2KHRBuilder<'a> {
     type Target = SurfaceFormat2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceFormat2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceFormat2KHRBuilder<'a> {
-    pub fn surface_format(
-        mut self,
-        surface_format: SurfaceFormatKHR,
-    ) -> SurfaceFormat2KHRBuilder<'a> {
+    pub fn surface_format(mut self, surface_format: SurfaceFormatKHR) -> Self {
         self.inner.surface_format = surface_format;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSurfaceFormat2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> SurfaceFormat2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceFormat2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22218,53 +20295,32 @@ impl DisplayProperties2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayProperties2KHRBuilder<'a> {
     inner: DisplayProperties2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayProperties2KHR {}
 impl<'a> ::std::ops::Deref for DisplayProperties2KHRBuilder<'a> {
     type Target = DisplayProperties2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayProperties2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayProperties2KHRBuilder<'a> {
-    pub fn display_properties(
-        mut self,
-        display_properties: DisplayPropertiesKHR,
-    ) -> DisplayProperties2KHRBuilder<'a> {
+    pub fn display_properties(mut self, display_properties: DisplayPropertiesKHR) -> Self {
         self.inner.display_properties = display_properties;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayProperties2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayProperties2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayProperties2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22292,53 +20348,35 @@ impl DisplayPlaneProperties2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayPlaneProperties2KHRBuilder<'a> {
     inner: DisplayPlaneProperties2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayPlaneProperties2KHR {}
 impl<'a> ::std::ops::Deref for DisplayPlaneProperties2KHRBuilder<'a> {
     type Target = DisplayPlaneProperties2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPlaneProperties2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPlaneProperties2KHRBuilder<'a> {
     pub fn display_plane_properties(
         mut self,
         display_plane_properties: DisplayPlanePropertiesKHR,
-    ) -> DisplayPlaneProperties2KHRBuilder<'a> {
+    ) -> Self {
         self.inner.display_plane_properties = display_plane_properties;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayPlaneProperties2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayPlaneProperties2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPlaneProperties2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22366,53 +20404,35 @@ impl DisplayModeProperties2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayModeProperties2KHRBuilder<'a> {
     inner: DisplayModeProperties2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayModeProperties2KHR {}
 impl<'a> ::std::ops::Deref for DisplayModeProperties2KHRBuilder<'a> {
     type Target = DisplayModeProperties2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayModeProperties2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayModeProperties2KHRBuilder<'a> {
     pub fn display_mode_properties(
         mut self,
         display_mode_properties: DisplayModePropertiesKHR,
-    ) -> DisplayModeProperties2KHRBuilder<'a> {
+    ) -> Self {
         self.inner.display_mode_properties = display_mode_properties;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayModeProperties2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayModeProperties2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayModeProperties2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22442,54 +20462,36 @@ impl DisplayPlaneInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayPlaneInfo2KHRBuilder<'a> {
     inner: DisplayPlaneInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayPlaneInfo2KHR {}
 impl<'a> ::std::ops::Deref for DisplayPlaneInfo2KHRBuilder<'a> {
     type Target = DisplayPlaneInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPlaneInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPlaneInfo2KHRBuilder<'a> {
-    pub fn mode(mut self, mode: DisplayModeKHR) -> DisplayPlaneInfo2KHRBuilder<'a> {
+    pub fn mode(mut self, mode: DisplayModeKHR) -> Self {
         self.inner.mode = mode;
         self
     }
-    pub fn plane_index(mut self, plane_index: u32) -> DisplayPlaneInfo2KHRBuilder<'a> {
+    pub fn plane_index(mut self, plane_index: u32) -> Self {
         self.inner.plane_index = plane_index;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayPlaneInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayPlaneInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPlaneInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22517,53 +20519,32 @@ impl DisplayPlaneCapabilities2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct DisplayPlaneCapabilities2KHRBuilder<'a> {
     inner: DisplayPlaneCapabilities2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDisplayPlaneCapabilities2KHR {}
 impl<'a> ::std::ops::Deref for DisplayPlaneCapabilities2KHRBuilder<'a> {
     type Target = DisplayPlaneCapabilities2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DisplayPlaneCapabilities2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DisplayPlaneCapabilities2KHRBuilder<'a> {
-    pub fn capabilities(
-        mut self,
-        capabilities: DisplayPlaneCapabilitiesKHR,
-    ) -> DisplayPlaneCapabilities2KHRBuilder<'a> {
+    pub fn capabilities(mut self, capabilities: DisplayPlaneCapabilitiesKHR) -> Self {
         self.inner.capabilities = capabilities;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDisplayPlaneCapabilities2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> DisplayPlaneCapabilities2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DisplayPlaneCapabilities2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -22608,17 +20589,17 @@ impl<'a> ::std::ops::DerefMut for Shared
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
     pub fn shared_present_supported_usage_flags(
         mut self,
         shared_present_supported_usage_flags: ImageUsageFlags,
-    ) -> SharedPresentSurfaceCapabilitiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.shared_present_supported_usage_flags = shared_present_supported_usage_flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SharedPresentSurfaceCapabilitiesKHR {
         self.inner
@@ -22655,56 +20636,49 @@ impl PhysicalDevice16BitStorageFeatures 
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevice16BitStorageFeaturesBuilder<'a> {
     inner: PhysicalDevice16BitStorageFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice16BitStorageFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice16BitStorageFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice16BitStorageFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice16BitStorageFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDevice16BitStorageFeaturesBuilder<'a> {
     type Target = PhysicalDevice16BitStorageFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevice16BitStorageFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
-    pub fn storage_buffer16_bit_access(
-        mut self,
-        storage_buffer16_bit_access: bool,
-    ) -> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
+    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
         self.inner.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
         self
     }
     pub fn uniform_and_storage_buffer16_bit_access(
         mut self,
         uniform_and_storage_buffer16_bit_access: bool,
-    ) -> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.uniform_and_storage_buffer16_bit_access =
             uniform_and_storage_buffer16_bit_access.into();
         self
     }
-    pub fn storage_push_constant16(
-        mut self,
-        storage_push_constant16: bool,
-    ) -> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
+    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
         self.inner.storage_push_constant16 = storage_push_constant16.into();
         self
     }
-    pub fn storage_input_output16(
-        mut self,
-        storage_input_output16: bool,
-    ) -> PhysicalDevice16BitStorageFeaturesBuilder<'a> {
+    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
         self.inner.storage_input_output16 = storage_input_output16.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevice16BitStorageFeatures {
         self.inner
@@ -22755,41 +20729,29 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
-    pub fn subgroup_size(
-        mut self,
-        subgroup_size: u32,
-    ) -> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
+    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
         self.inner.subgroup_size = subgroup_size;
         self
     }
-    pub fn supported_stages(
-        mut self,
-        supported_stages: ShaderStageFlags,
-    ) -> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
+    pub fn supported_stages(mut self, supported_stages: ShaderStageFlags) -> Self {
         self.inner.supported_stages = supported_stages;
         self
     }
-    pub fn supported_operations(
-        mut self,
-        supported_operations: SubgroupFeatureFlags,
-    ) -> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
+    pub fn supported_operations(mut self, supported_operations: SubgroupFeatureFlags) -> Self {
         self.inner.supported_operations = supported_operations;
         self
     }
-    pub fn quad_operations_in_all_stages(
-        mut self,
-        quad_operations_in_all_stages: bool,
-    ) -> PhysicalDeviceSubgroupPropertiesBuilder<'a> {
+    pub fn quad_operations_in_all_stages(mut self, quad_operations_in_all_stages: bool) -> Self {
         self.inner.quad_operations_in_all_stages = quad_operations_in_all_stages.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSubgroupProperties {
         self.inner
@@ -22820,16 +20782,21 @@ impl PhysicalDeviceShaderSubgroupExtende
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
     inner: PhysicalDeviceShaderSubgroupExtendedTypesFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSubgroupExtendedTypesFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
     type Target = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
     fn deref(&self) -> &Self::Target {
@@ -22837,20 +20804,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
-    pub fn shader_subgroup_extended_types(
-        mut self,
-        shader_subgroup_extended_types: bool,
-    ) -> PhysicalDeviceShaderSubgroupExtendedTypesFeaturesBuilder<'a> {
+    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
         self.inner.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
         self.inner
@@ -22881,50 +20845,32 @@ impl BufferMemoryRequirementsInfo2 {
         }
     }
 }
 #[repr(transparent)]
 pub struct BufferMemoryRequirementsInfo2Builder<'a> {
     inner: BufferMemoryRequirementsInfo2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBufferMemoryRequirementsInfo2 {}
 impl<'a> ::std::ops::Deref for BufferMemoryRequirementsInfo2Builder<'a> {
     type Target = BufferMemoryRequirementsInfo2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferMemoryRequirementsInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferMemoryRequirementsInfo2Builder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> BufferMemoryRequirementsInfo2Builder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferMemoryRequirementsInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferMemoryRequirementsInfo2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferMemoryRequirementsInfo2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -22965,29 +20911,26 @@ impl<'a> ::std::ops::Deref for ImageMemo
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageMemoryRequirementsInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageMemoryRequirementsInfo2Builder<'a> {
-    pub fn image(mut self, image: Image) -> ImageMemoryRequirementsInfo2Builder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageMemoryRequirementsInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageMemoryRequirementsInfo2Builder<'a> {
+    pub fn push_next<T: ExtendsImageMemoryRequirementsInfo2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -23023,50 +20966,32 @@ impl ImageSparseMemoryRequirementsInfo2 
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageSparseMemoryRequirementsInfo2Builder<'a> {
     inner: ImageSparseMemoryRequirementsInfo2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageSparseMemoryRequirementsInfo2 {}
 impl<'a> ::std::ops::Deref for ImageSparseMemoryRequirementsInfo2Builder<'a> {
     type Target = ImageSparseMemoryRequirementsInfo2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageSparseMemoryRequirementsInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageSparseMemoryRequirementsInfo2Builder<'a> {
-    pub fn image(mut self, image: Image) -> ImageSparseMemoryRequirementsInfo2Builder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageSparseMemoryRequirementsInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageSparseMemoryRequirementsInfo2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageSparseMemoryRequirementsInfo2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -23107,32 +21032,26 @@ impl<'a> ::std::ops::Deref for MemoryReq
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryRequirements2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryRequirements2Builder<'a> {
-    pub fn memory_requirements(
-        mut self,
-        memory_requirements: MemoryRequirements,
-    ) -> MemoryRequirements2Builder<'a> {
+    pub fn memory_requirements(mut self, memory_requirements: MemoryRequirements) -> Self {
         self.inner.memory_requirements = memory_requirements;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryRequirements2>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryRequirements2Builder<'a> {
+    pub fn push_next<T: ExtendsMemoryRequirements2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -23168,53 +21087,35 @@ impl SparseImageMemoryRequirements2 {
         }
     }
 }
 #[repr(transparent)]
 pub struct SparseImageMemoryRequirements2Builder<'a> {
     inner: SparseImageMemoryRequirements2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSparseImageMemoryRequirements2 {}
 impl<'a> ::std::ops::Deref for SparseImageMemoryRequirements2Builder<'a> {
     type Target = SparseImageMemoryRequirements2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SparseImageMemoryRequirements2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SparseImageMemoryRequirements2Builder<'a> {
     pub fn memory_requirements(
         mut self,
         memory_requirements: SparseImageMemoryRequirements,
-    ) -> SparseImageMemoryRequirements2Builder<'a> {
+    ) -> Self {
         self.inner.memory_requirements = memory_requirements;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSparseImageMemoryRequirements2>(
-        mut self,
-        next: &'a mut T,
-    ) -> SparseImageMemoryRequirements2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SparseImageMemoryRequirements2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -23259,17 +21160,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePointClippingPropertiesBuilder<'a> {
     pub fn point_clipping_behavior(
         mut self,
         point_clipping_behavior: PointClippingBehavior,
-    ) -> PhysicalDevicePointClippingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.point_clipping_behavior = point_clipping_behavior;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePointClippingProperties {
         self.inner
@@ -23316,27 +21217,21 @@ impl<'a> ::std::ops::Deref for MemoryDed
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryDedicatedRequirementsBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryDedicatedRequirementsBuilder<'a> {
-    pub fn prefers_dedicated_allocation(
-        mut self,
-        prefers_dedicated_allocation: bool,
-    ) -> MemoryDedicatedRequirementsBuilder<'a> {
+    pub fn prefers_dedicated_allocation(mut self, prefers_dedicated_allocation: bool) -> Self {
         self.inner.prefers_dedicated_allocation = prefers_dedicated_allocation.into();
         self
     }
-    pub fn requires_dedicated_allocation(
-        mut self,
-        requires_dedicated_allocation: bool,
-    ) -> MemoryDedicatedRequirementsBuilder<'a> {
+    pub fn requires_dedicated_allocation(mut self, requires_dedicated_allocation: bool) -> Self {
         self.inner.requires_dedicated_allocation = requires_dedicated_allocation.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryDedicatedRequirements {
         self.inner
@@ -23383,21 +21278,21 @@ impl<'a> ::std::ops::Deref for MemoryDed
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryDedicatedAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryDedicatedAllocateInfoBuilder<'a> {
-    pub fn image(mut self, image: Image) -> MemoryDedicatedAllocateInfoBuilder<'a> {
+    pub fn image(mut self, image: Image) -> Self {
         self.inner.image = image;
         self
     }
-    pub fn buffer(mut self, buffer: Buffer) -> MemoryDedicatedAllocateInfoBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryDedicatedAllocateInfo {
         self.inner
@@ -23442,17 +21337,17 @@ impl<'a> ::std::ops::Deref for ImageView
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageViewUsageCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageViewUsageCreateInfoBuilder<'a> {
-    pub fn usage(mut self, usage: ImageUsageFlags) -> ImageViewUsageCreateInfoBuilder<'a> {
+    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageViewUsageCreateInfo {
         self.inner
@@ -23503,20 +21398,17 @@ impl<'a> ::std::ops::Deref for PipelineT
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
-    pub fn domain_origin(
-        mut self,
-        domain_origin: TessellationDomainOrigin,
-    ) -> PipelineTessellationDomainOriginStateCreateInfoBuilder<'a> {
+    pub fn domain_origin(mut self, domain_origin: TessellationDomainOrigin) -> Self {
         self.inner.domain_origin = domain_origin;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineTessellationDomainOriginStateCreateInfo {
         self.inner
@@ -23563,20 +21455,17 @@ impl<'a> ::std::ops::Deref for SamplerYc
     }
 }
 impl<'a> ::std::ops::DerefMut for SamplerYcbcrConversionInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerYcbcrConversionInfoBuilder<'a> {
-    pub fn conversion(
-        mut self,
-        conversion: SamplerYcbcrConversion,
-    ) -> SamplerYcbcrConversionInfoBuilder<'a> {
+    pub fn conversion(mut self, conversion: SamplerYcbcrConversion) -> Self {
         self.inner.conversion = conversion;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SamplerYcbcrConversionInfo {
         self.inner
@@ -23634,78 +21523,57 @@ impl<'a> ::std::ops::Deref for SamplerYc
     }
 }
 impl<'a> ::std::ops::DerefMut for SamplerYcbcrConversionCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerYcbcrConversionCreateInfoBuilder<'a> {
-    pub fn format(mut self, format: Format) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn ycbcr_model(
-        mut self,
-        ycbcr_model: SamplerYcbcrModelConversion,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn ycbcr_model(mut self, ycbcr_model: SamplerYcbcrModelConversion) -> Self {
         self.inner.ycbcr_model = ycbcr_model;
         self
     }
-    pub fn ycbcr_range(
-        mut self,
-        ycbcr_range: SamplerYcbcrRange,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn ycbcr_range(mut self, ycbcr_range: SamplerYcbcrRange) -> Self {
         self.inner.ycbcr_range = ycbcr_range;
         self
     }
-    pub fn components(
-        mut self,
-        components: ComponentMapping,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn components(mut self, components: ComponentMapping) -> Self {
         self.inner.components = components;
         self
     }
-    pub fn x_chroma_offset(
-        mut self,
-        x_chroma_offset: ChromaLocation,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn x_chroma_offset(mut self, x_chroma_offset: ChromaLocation) -> Self {
         self.inner.x_chroma_offset = x_chroma_offset;
         self
     }
-    pub fn y_chroma_offset(
-        mut self,
-        y_chroma_offset: ChromaLocation,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn y_chroma_offset(mut self, y_chroma_offset: ChromaLocation) -> Self {
         self.inner.y_chroma_offset = y_chroma_offset;
         self
     }
-    pub fn chroma_filter(
-        mut self,
-        chroma_filter: Filter,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn chroma_filter(mut self, chroma_filter: Filter) -> Self {
         self.inner.chroma_filter = chroma_filter;
         self
     }
-    pub fn force_explicit_reconstruction(
-        mut self,
-        force_explicit_reconstruction: bool,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    pub fn force_explicit_reconstruction(mut self, force_explicit_reconstruction: bool) -> Self {
         self.inner.force_explicit_reconstruction = force_explicit_reconstruction.into();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsSamplerYcbcrConversionCreateInfo>(
         mut self,
         next: &'a mut T,
-    ) -> SamplerYcbcrConversionCreateInfoBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -23755,20 +21623,17 @@ impl<'a> ::std::ops::Deref for BindImage
     }
 }
 impl<'a> ::std::ops::DerefMut for BindImagePlaneMemoryInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindImagePlaneMemoryInfoBuilder<'a> {
-    pub fn plane_aspect(
-        mut self,
-        plane_aspect: ImageAspectFlags,
-    ) -> BindImagePlaneMemoryInfoBuilder<'a> {
+    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
         self.inner.plane_aspect = plane_aspect;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindImagePlaneMemoryInfo {
         self.inner
@@ -23813,20 +21678,17 @@ impl<'a> ::std::ops::Deref for ImagePlan
     }
 }
 impl<'a> ::std::ops::DerefMut for ImagePlaneMemoryRequirementsInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImagePlaneMemoryRequirementsInfoBuilder<'a> {
-    pub fn plane_aspect(
-        mut self,
-        plane_aspect: ImageAspectFlags,
-    ) -> ImagePlaneMemoryRequirementsInfoBuilder<'a> {
+    pub fn plane_aspect(mut self, plane_aspect: ImageAspectFlags) -> Self {
         self.inner.plane_aspect = plane_aspect;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImagePlaneMemoryRequirementsInfo {
         self.inner
@@ -23857,34 +21719,36 @@ impl PhysicalDeviceSamplerYcbcrConversio
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
     inner: PhysicalDeviceSamplerYcbcrConversionFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSamplerYcbcrConversionFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSamplerYcbcrConversionFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
     type Target = PhysicalDeviceSamplerYcbcrConversionFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
-    pub fn sampler_ycbcr_conversion(
-        mut self,
-        sampler_ycbcr_conversion: bool,
-    ) -> PhysicalDeviceSamplerYcbcrConversionFeaturesBuilder<'a> {
+    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
         self.inner.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSamplerYcbcrConversionFeatures {
         self.inner
@@ -23935,17 +21799,17 @@ impl<'a> ::std::ops::DerefMut for Sample
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
     pub fn combined_image_sampler_descriptor_count(
         mut self,
         combined_image_sampler_descriptor_count: u32,
-    ) -> SamplerYcbcrConversionImageFormatPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.combined_image_sampler_descriptor_count =
             combined_image_sampler_descriptor_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SamplerYcbcrConversionImageFormatProperties {
@@ -23994,17 +21858,17 @@ impl<'a> ::std::ops::DerefMut for Textur
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> TextureLODGatherFormatPropertiesAMDBuilder<'a> {
     pub fn supports_texture_gather_lod_bias_amd(
         mut self,
         supports_texture_gather_lod_bias_amd: bool,
-    ) -> TextureLODGatherFormatPropertiesAMDBuilder<'a> {
+    ) -> Self {
         self.inner.supports_texture_gather_lod_bias_amd =
             supports_texture_gather_lod_bias_amd.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> TextureLODGatherFormatPropertiesAMD {
@@ -24040,59 +21904,38 @@ impl ConditionalRenderingBeginInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct ConditionalRenderingBeginInfoEXTBuilder<'a> {
     inner: ConditionalRenderingBeginInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsConditionalRenderingBeginInfoEXT {}
 impl<'a> ::std::ops::Deref for ConditionalRenderingBeginInfoEXTBuilder<'a> {
     type Target = ConditionalRenderingBeginInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ConditionalRenderingBeginInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ConditionalRenderingBeginInfoEXTBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> ConditionalRenderingBeginInfoEXTBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> ConditionalRenderingBeginInfoEXTBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn flags(
-        mut self,
-        flags: ConditionalRenderingFlagsEXT,
-    ) -> ConditionalRenderingBeginInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsConditionalRenderingBeginInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> ConditionalRenderingBeginInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: ConditionalRenderingFlagsEXT) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ConditionalRenderingBeginInfoEXT {
         self.inner
     }
@@ -24136,17 +21979,17 @@ impl<'a> ::std::ops::Deref for Protected
     }
 }
 impl<'a> ::std::ops::DerefMut for ProtectedSubmitInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ProtectedSubmitInfoBuilder<'a> {
-    pub fn protected_submit(mut self, protected_submit: bool) -> ProtectedSubmitInfoBuilder<'a> {
+    pub fn protected_submit(mut self, protected_submit: bool) -> Self {
         self.inner.protected_submit = protected_submit.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ProtectedSubmitInfo {
         self.inner
@@ -24177,34 +22020,33 @@ impl PhysicalDeviceProtectedMemoryFeatur
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
     inner: PhysicalDeviceProtectedMemoryFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProtectedMemoryFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProtectedMemoryFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProtectedMemoryFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProtectedMemoryFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
     type Target = PhysicalDeviceProtectedMemoryFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
-    pub fn protected_memory(
-        mut self,
-        protected_memory: bool,
-    ) -> PhysicalDeviceProtectedMemoryFeaturesBuilder<'a> {
+    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
         self.inner.protected_memory = protected_memory.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceProtectedMemoryFeatures {
         self.inner
@@ -24252,20 +22094,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
-    pub fn protected_no_fault(
-        mut self,
-        protected_no_fault: bool,
-    ) -> PhysicalDeviceProtectedMemoryPropertiesBuilder<'a> {
+    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
         self.inner.protected_no_fault = protected_no_fault.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceProtectedMemoryProperties {
         self.inner
@@ -24300,58 +22139,40 @@ impl DeviceQueueInfo2 {
         }
     }
 }
 #[repr(transparent)]
 pub struct DeviceQueueInfo2Builder<'a> {
     inner: DeviceQueueInfo2,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDeviceQueueInfo2 {}
 impl<'a> ::std::ops::Deref for DeviceQueueInfo2Builder<'a> {
     type Target = DeviceQueueInfo2;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceQueueInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceQueueInfo2Builder<'a> {
-    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> DeviceQueueInfo2Builder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn queue_family_index(mut self, queue_family_index: u32) -> DeviceQueueInfo2Builder<'a> {
+    pub fn flags(mut self, flags: DeviceQueueCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
         self.inner.queue_family_index = queue_family_index;
         self
     }
-    pub fn queue_index(mut self, queue_index: u32) -> DeviceQueueInfo2Builder<'a> {
+    pub fn queue_index(mut self, queue_index: u32) -> Self {
         self.inner.queue_index = queue_index;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceQueueInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceQueueInfo2Builder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceQueueInfo2 {
         self.inner
     }
 }
 #[repr(C)]
@@ -24400,34 +22221,25 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCoverageToColorStateCreateFlagsNV,
-    ) -> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn coverage_to_color_enable(
-        mut self,
-        coverage_to_color_enable: bool,
-    ) -> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCoverageToColorStateCreateFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn coverage_to_color_enable(mut self, coverage_to_color_enable: bool) -> Self {
         self.inner.coverage_to_color_enable = coverage_to_color_enable.into();
         self
     }
-    pub fn coverage_to_color_location(
-        mut self,
-        coverage_to_color_location: u32,
-    ) -> PipelineCoverageToColorStateCreateInfoNVBuilder<'a> {
+    pub fn coverage_to_color_location(mut self, coverage_to_color_location: u32) -> Self {
         self.inner.coverage_to_color_location = coverage_to_color_location;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCoverageToColorStateCreateInfoNV {
         self.inner
@@ -24480,25 +22292,25 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
     pub fn filter_minmax_single_component_formats(
         mut self,
         filter_minmax_single_component_formats: bool,
-    ) -> PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.filter_minmax_single_component_formats =
             filter_minmax_single_component_formats.into();
         self
     }
     pub fn filter_minmax_image_component_mapping(
         mut self,
         filter_minmax_image_component_mapping: bool,
-    ) -> PhysicalDeviceSamplerFilterMinmaxPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.filter_minmax_image_component_mapping =
             filter_minmax_image_component_mapping.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSamplerFilterMinmaxProperties {
@@ -24532,21 +22344,21 @@ impl<'a> ::std::ops::Deref for SampleLoc
     }
 }
 impl<'a> ::std::ops::DerefMut for SampleLocationEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SampleLocationEXTBuilder<'a> {
-    pub fn x(mut self, x: f32) -> SampleLocationEXTBuilder<'a> {
+    pub fn x(mut self, x: f32) -> Self {
         self.inner.x = x;
         self
     }
-    pub fn y(mut self, y: f32) -> SampleLocationEXTBuilder<'a> {
+    pub fn y(mut self, y: f32) -> Self {
         self.inner.y = y;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SampleLocationEXT {
         self.inner
@@ -24585,46 +22397,42 @@ impl SampleLocationsInfoEXT {
 }
 #[repr(transparent)]
 pub struct SampleLocationsInfoEXTBuilder<'a> {
     inner: SampleLocationsInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
 unsafe impl ExtendsImageMemoryBarrier for SampleLocationsInfoEXTBuilder<'_> {}
 unsafe impl ExtendsImageMemoryBarrier for SampleLocationsInfoEXT {}
+unsafe impl ExtendsImageMemoryBarrier2KHR for SampleLocationsInfoEXTBuilder<'_> {}
+unsafe impl ExtendsImageMemoryBarrier2KHR for SampleLocationsInfoEXT {}
 impl<'a> ::std::ops::Deref for SampleLocationsInfoEXTBuilder<'a> {
     type Target = SampleLocationsInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SampleLocationsInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SampleLocationsInfoEXTBuilder<'a> {
     pub fn sample_locations_per_pixel(
         mut self,
         sample_locations_per_pixel: SampleCountFlags,
-    ) -> SampleLocationsInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.sample_locations_per_pixel = sample_locations_per_pixel;
         self
     }
-    pub fn sample_location_grid_size(
-        mut self,
-        sample_location_grid_size: Extent2D,
-    ) -> SampleLocationsInfoEXTBuilder<'a> {
+    pub fn sample_location_grid_size(mut self, sample_location_grid_size: Extent2D) -> Self {
         self.inner.sample_location_grid_size = sample_location_grid_size;
         self
     }
-    pub fn sample_locations(
-        mut self,
-        sample_locations: &'a [SampleLocationEXT],
-    ) -> SampleLocationsInfoEXTBuilder<'a> {
+    pub fn sample_locations(mut self, sample_locations: &'a [SampleLocationEXT]) -> Self {
         self.inner.sample_locations_count = sample_locations.len() as _;
         self.inner.p_sample_locations = sample_locations.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SampleLocationsInfoEXT {
@@ -24658,27 +22466,21 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentSampleLocationsEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentSampleLocationsEXTBuilder<'a> {
-    pub fn attachment_index(
-        mut self,
-        attachment_index: u32,
-    ) -> AttachmentSampleLocationsEXTBuilder<'a> {
+    pub fn attachment_index(mut self, attachment_index: u32) -> Self {
         self.inner.attachment_index = attachment_index;
         self
     }
-    pub fn sample_locations_info(
-        mut self,
-        sample_locations_info: SampleLocationsInfoEXT,
-    ) -> AttachmentSampleLocationsEXTBuilder<'a> {
+    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
         self.inner.sample_locations_info = sample_locations_info;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AttachmentSampleLocationsEXT {
         self.inner
@@ -24711,24 +22513,21 @@ impl<'a> ::std::ops::Deref for SubpassSa
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassSampleLocationsEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassSampleLocationsEXTBuilder<'a> {
-    pub fn subpass_index(mut self, subpass_index: u32) -> SubpassSampleLocationsEXTBuilder<'a> {
+    pub fn subpass_index(mut self, subpass_index: u32) -> Self {
         self.inner.subpass_index = subpass_index;
         self
     }
-    pub fn sample_locations_info(
-        mut self,
-        sample_locations_info: SampleLocationsInfoEXT,
-    ) -> SubpassSampleLocationsEXTBuilder<'a> {
+    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
         self.inner.sample_locations_info = sample_locations_info;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassSampleLocationsEXT {
         self.inner
@@ -24782,27 +22581,27 @@ impl<'a> ::std::ops::DerefMut for Render
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
     pub fn attachment_initial_sample_locations(
         mut self,
         attachment_initial_sample_locations: &'a [AttachmentSampleLocationsEXT],
-    ) -> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.attachment_initial_sample_locations_count =
             attachment_initial_sample_locations.len() as _;
         self.inner.p_attachment_initial_sample_locations =
             attachment_initial_sample_locations.as_ptr();
         self
     }
     pub fn post_subpass_sample_locations(
         mut self,
         post_subpass_sample_locations: &'a [SubpassSampleLocationsEXT],
-    ) -> RenderPassSampleLocationsBeginInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.post_subpass_sample_locations_count = post_subpass_sample_locations.len() as _;
         self.inner.p_post_subpass_sample_locations = post_subpass_sample_locations.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassSampleLocationsBeginInfoEXT {
@@ -24856,27 +22655,21 @@ impl<'a> ::std::ops::Deref for PipelineS
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
-    pub fn sample_locations_enable(
-        mut self,
-        sample_locations_enable: bool,
-    ) -> PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
+    pub fn sample_locations_enable(mut self, sample_locations_enable: bool) -> Self {
         self.inner.sample_locations_enable = sample_locations_enable.into();
         self
     }
-    pub fn sample_locations_info(
-        mut self,
-        sample_locations_info: SampleLocationsInfoEXT,
-    ) -> PipelineSampleLocationsStateCreateInfoEXTBuilder<'a> {
+    pub fn sample_locations_info(mut self, sample_locations_info: SampleLocationsInfoEXT) -> Self {
         self.inner.sample_locations_info = sample_locations_info;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineSampleLocationsStateCreateInfoEXT {
         self.inner
@@ -24935,45 +22728,39 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
     pub fn sample_location_sample_counts(
         mut self,
         sample_location_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.sample_location_sample_counts = sample_location_sample_counts;
         self
     }
     pub fn max_sample_location_grid_size(
         mut self,
         max_sample_location_grid_size: Extent2D,
-    ) -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_sample_location_grid_size = max_sample_location_grid_size;
         self
     }
     pub fn sample_location_coordinate_range(
         mut self,
         sample_location_coordinate_range: [f32; 2],
-    ) -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.sample_location_coordinate_range = sample_location_coordinate_range;
         self
     }
-    pub fn sample_location_sub_pixel_bits(
-        mut self,
-        sample_location_sub_pixel_bits: u32,
-    ) -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
+    pub fn sample_location_sub_pixel_bits(mut self, sample_location_sub_pixel_bits: u32) -> Self {
         self.inner.sample_location_sub_pixel_bits = sample_location_sub_pixel_bits;
         self
     }
-    pub fn variable_sample_locations(
-        mut self,
-        variable_sample_locations: bool,
-    ) -> PhysicalDeviceSampleLocationsPropertiesEXTBuilder<'a> {
+    pub fn variable_sample_locations(mut self, variable_sample_locations: bool) -> Self {
         self.inner.variable_sample_locations = variable_sample_locations.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSampleLocationsPropertiesEXT {
         self.inner
@@ -25004,53 +22791,35 @@ impl MultisamplePropertiesEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct MultisamplePropertiesEXTBuilder<'a> {
     inner: MultisamplePropertiesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMultisamplePropertiesEXT {}
 impl<'a> ::std::ops::Deref for MultisamplePropertiesEXTBuilder<'a> {
     type Target = MultisamplePropertiesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MultisamplePropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MultisamplePropertiesEXTBuilder<'a> {
     pub fn max_sample_location_grid_size(
         mut self,
         max_sample_location_grid_size: Extent2D,
-    ) -> MultisamplePropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_sample_location_grid_size = max_sample_location_grid_size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMultisamplePropertiesEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> MultisamplePropertiesEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MultisamplePropertiesEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -25092,20 +22861,17 @@ impl<'a> ::std::ops::Deref for SamplerRe
     }
 }
 impl<'a> ::std::ops::DerefMut for SamplerReductionModeCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerReductionModeCreateInfoBuilder<'a> {
-    pub fn reduction_mode(
-        mut self,
-        reduction_mode: SamplerReductionMode,
-    ) -> SamplerReductionModeCreateInfoBuilder<'a> {
+    pub fn reduction_mode(mut self, reduction_mode: SamplerReductionMode) -> Self {
         self.inner.reduction_mode = reduction_mode;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SamplerReductionModeCreateInfo {
         self.inner
@@ -25136,16 +22902,21 @@ impl PhysicalDeviceBlendOperationAdvance
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceBlendOperationAdvancedFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBlendOperationAdvancedFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -25153,29 +22924,86 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
     pub fn advanced_blend_coherent_operations(
         mut self,
         advanced_blend_coherent_operations: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_coherent_operations = advanced_blend_coherent_operations.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html>"]
+pub struct PhysicalDeviceMultiDrawFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub multi_draw: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceMultiDrawFeaturesEXT {
+    fn default() -> PhysicalDeviceMultiDrawFeaturesEXT {
+        PhysicalDeviceMultiDrawFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            multi_draw: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceMultiDrawFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
+        PhysicalDeviceMultiDrawFeaturesEXTBuilder {
+            inner: PhysicalDeviceMultiDrawFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceMultiDrawFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMultiDrawFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMultiDrawFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceMultiDrawFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceMultiDrawFeaturesEXTBuilder<'a> {
+    pub fn multi_draw(mut self, multi_draw: bool) -> Self {
+        self.inner.multi_draw = multi_draw.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceMultiDrawFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.html>"]
 pub struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
     pub s_type: StructureType,
     pub p_next: *mut c_void,
     pub advanced_blend_max_color_attachments: u32,
     pub advanced_blend_independent_blend: Bool32,
     pub advanced_blend_non_premultiplied_src_color: Bool32,
     pub advanced_blend_non_premultiplied_dst_color: Bool32,
@@ -25224,54 +23052,51 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
     pub fn advanced_blend_max_color_attachments(
         mut self,
         advanced_blend_max_color_attachments: u32,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_max_color_attachments = advanced_blend_max_color_attachments;
         self
     }
     pub fn advanced_blend_independent_blend(
         mut self,
         advanced_blend_independent_blend: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_independent_blend = advanced_blend_independent_blend.into();
         self
     }
     pub fn advanced_blend_non_premultiplied_src_color(
         mut self,
         advanced_blend_non_premultiplied_src_color: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_non_premultiplied_src_color =
             advanced_blend_non_premultiplied_src_color.into();
         self
     }
     pub fn advanced_blend_non_premultiplied_dst_color(
         mut self,
         advanced_blend_non_premultiplied_dst_color: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_non_premultiplied_dst_color =
             advanced_blend_non_premultiplied_dst_color.into();
         self
     }
     pub fn advanced_blend_correlated_overlap(
         mut self,
         advanced_blend_correlated_overlap: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.advanced_blend_correlated_overlap = advanced_blend_correlated_overlap.into();
         self
     }
-    pub fn advanced_blend_all_operations(
-        mut self,
-        advanced_blend_all_operations: bool,
-    ) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXTBuilder<'a> {
+    pub fn advanced_blend_all_operations(mut self, advanced_blend_all_operations: bool) -> Self {
         self.inner.advanced_blend_all_operations = advanced_blend_all_operations.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
         self.inner
@@ -25326,34 +23151,25 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
-    pub fn src_premultiplied(
-        mut self,
-        src_premultiplied: bool,
-    ) -> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
+    pub fn src_premultiplied(mut self, src_premultiplied: bool) -> Self {
         self.inner.src_premultiplied = src_premultiplied.into();
         self
     }
-    pub fn dst_premultiplied(
-        mut self,
-        dst_premultiplied: bool,
-    ) -> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
+    pub fn dst_premultiplied(mut self, dst_premultiplied: bool) -> Self {
         self.inner.dst_premultiplied = dst_premultiplied.into();
         self
     }
-    pub fn blend_overlap(
-        mut self,
-        blend_overlap: BlendOverlapEXT,
-    ) -> PipelineColorBlendAdvancedStateCreateInfoEXTBuilder<'a> {
+    pub fn blend_overlap(mut self, blend_overlap: BlendOverlapEXT) -> Self {
         self.inner.blend_overlap = blend_overlap;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineColorBlendAdvancedStateCreateInfoEXT {
         self.inner
@@ -25386,41 +23202,43 @@ impl PhysicalDeviceInlineUniformBlockFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceInlineUniformBlockFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInlineUniformBlockFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInlineUniformBlockFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceInlineUniformBlockFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
-    pub fn inline_uniform_block(
-        mut self,
-        inline_uniform_block: bool,
-    ) -> PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
+    pub fn inline_uniform_block(mut self, inline_uniform_block: bool) -> Self {
         self.inner.inline_uniform_block = inline_uniform_block.into();
         self
     }
     pub fn descriptor_binding_inline_uniform_block_update_after_bind(
         mut self,
         descriptor_binding_inline_uniform_block_update_after_bind: bool,
-    ) -> PhysicalDeviceInlineUniformBlockFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_inline_uniform_block_update_after_bind =
             descriptor_binding_inline_uniform_block_update_after_bind.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -25478,52 +23296,49 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
-    pub fn max_inline_uniform_block_size(
-        mut self,
-        max_inline_uniform_block_size: u32,
-    ) -> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
+    pub fn max_inline_uniform_block_size(mut self, max_inline_uniform_block_size: u32) -> Self {
         self.inner.max_inline_uniform_block_size = max_inline_uniform_block_size;
         self
     }
     pub fn max_per_stage_descriptor_inline_uniform_blocks(
         mut self,
         max_per_stage_descriptor_inline_uniform_blocks: u32,
-    ) -> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_inline_uniform_blocks =
             max_per_stage_descriptor_inline_uniform_blocks;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_inline_uniform_blocks(
         mut self,
         max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
-    ) -> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_inline_uniform_blocks =
             max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
         self
     }
     pub fn max_descriptor_set_inline_uniform_blocks(
         mut self,
         max_descriptor_set_inline_uniform_blocks: u32,
-    ) -> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_inline_uniform_blocks =
             max_descriptor_set_inline_uniform_blocks;
         self
     }
     pub fn max_descriptor_set_update_after_bind_inline_uniform_blocks(
         mut self,
         max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
-    ) -> PhysicalDeviceInlineUniformBlockPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_inline_uniform_blocks =
             max_descriptor_set_update_after_bind_inline_uniform_blocks;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -25572,17 +23387,17 @@ impl<'a> ::std::ops::Deref for WriteDesc
     }
 }
 impl<'a> ::std::ops::DerefMut for WriteDescriptorSetInlineUniformBlockEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> WriteDescriptorSetInlineUniformBlockEXTBuilder<'a> {
-    pub fn data(mut self, data: &'a [u8]) -> WriteDescriptorSetInlineUniformBlockEXTBuilder<'a> {
+    pub fn data(mut self, data: &'a [u8]) -> Self {
         self.inner.data_size = data.len() as _;
         self.inner.p_data = data.as_ptr() as *const c_void;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> WriteDescriptorSetInlineUniformBlockEXT {
@@ -25634,17 +23449,17 @@ impl<'a> ::std::ops::DerefMut for Descri
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorPoolInlineUniformBlockCreateInfoEXTBuilder<'a> {
     pub fn max_inline_uniform_block_bindings(
         mut self,
         max_inline_uniform_block_bindings: u32,
-    ) -> DescriptorPoolInlineUniformBlockCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_inline_uniform_block_bindings = max_inline_uniform_block_bindings;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorPoolInlineUniformBlockCreateInfoEXT {
         self.inner
@@ -25703,41 +23518,35 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCoverageModulationStateCreateFlagsNV,
-    ) -> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCoverageModulationStateCreateFlagsNV) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn coverage_modulation_mode(
         mut self,
         coverage_modulation_mode: CoverageModulationModeNV,
-    ) -> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.coverage_modulation_mode = coverage_modulation_mode;
         self
     }
     pub fn coverage_modulation_table_enable(
         mut self,
         coverage_modulation_table_enable: bool,
-    ) -> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.coverage_modulation_table_enable = coverage_modulation_table_enable.into();
         self
     }
-    pub fn coverage_modulation_table(
-        mut self,
-        coverage_modulation_table: &'a [f32],
-    ) -> PipelineCoverageModulationStateCreateInfoNVBuilder<'a> {
+    pub fn coverage_modulation_table(mut self, coverage_modulation_table: &'a [f32]) -> Self {
         self.inner.coverage_modulation_table_count = coverage_modulation_table.len() as _;
         self.inner.p_coverage_modulation_table = coverage_modulation_table.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCoverageModulationStateCreateInfoNV {
@@ -25789,20 +23598,17 @@ impl<'a> ::std::ops::Deref for ImageForm
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageFormatListCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageFormatListCreateInfoBuilder<'a> {
-    pub fn view_formats(
-        mut self,
-        view_formats: &'a [Format],
-    ) -> ImageFormatListCreateInfoBuilder<'a> {
+    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
         self.inner.view_format_count = view_formats.len() as _;
         self.inner.p_view_formats = view_formats.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageFormatListCreateInfo {
@@ -25838,61 +23644,37 @@ impl ValidationCacheCreateInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct ValidationCacheCreateInfoEXTBuilder<'a> {
     inner: ValidationCacheCreateInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsValidationCacheCreateInfoEXT {}
 impl<'a> ::std::ops::Deref for ValidationCacheCreateInfoEXTBuilder<'a> {
     type Target = ValidationCacheCreateInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ValidationCacheCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ValidationCacheCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: ValidationCacheCreateFlagsEXT,
-    ) -> ValidationCacheCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn initial_data(
-        mut self,
-        initial_data: &'a [u8],
-    ) -> ValidationCacheCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: ValidationCacheCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn initial_data(mut self, initial_data: &'a [u8]) -> Self {
         self.inner.initial_data_size = initial_data.len() as _;
         self.inner.p_initial_data = initial_data.as_ptr() as *const c_void;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsValidationCacheCreateInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> ValidationCacheCreateInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ValidationCacheCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -25934,20 +23716,17 @@ impl<'a> ::std::ops::Deref for ShaderMod
     }
 }
 impl<'a> ::std::ops::DerefMut for ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
-    pub fn validation_cache(
-        mut self,
-        validation_cache: ValidationCacheEXT,
-    ) -> ShaderModuleValidationCacheCreateInfoEXTBuilder<'a> {
+    pub fn validation_cache(mut self, validation_cache: ValidationCacheEXT) -> Self {
         self.inner.validation_cache = validation_cache;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ShaderModuleValidationCacheCreateInfoEXT {
         self.inner
@@ -25994,27 +23773,21 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
-    pub fn max_per_set_descriptors(
-        mut self,
-        max_per_set_descriptors: u32,
-    ) -> PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
+    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
         self.inner.max_per_set_descriptors = max_per_set_descriptors;
         self
     }
-    pub fn max_memory_allocation_size(
-        mut self,
-        max_memory_allocation_size: DeviceSize,
-    ) -> PhysicalDeviceMaintenance3PropertiesBuilder<'a> {
+    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
         self.inner.max_memory_allocation_size = max_memory_allocation_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMaintenance3Properties {
         self.inner
@@ -26058,29 +23831,26 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutSupportBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetLayoutSupportBuilder<'a> {
-    pub fn supported(mut self, supported: bool) -> DescriptorSetLayoutSupportBuilder<'a> {
+    pub fn supported(mut self, supported: bool) -> Self {
         self.inner.supported = supported.into();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDescriptorSetLayoutSupport>(
-        mut self,
-        next: &'a mut T,
-    ) -> DescriptorSetLayoutSupportBuilder<'a> {
+    pub fn push_next<T: ExtendsDescriptorSetLayoutSupport>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -26116,34 +23886,36 @@ impl PhysicalDeviceShaderDrawParametersF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
     inner: PhysicalDeviceShaderDrawParametersFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderDrawParametersFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDrawParametersFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
     type Target = PhysicalDeviceShaderDrawParametersFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
-    pub fn shader_draw_parameters(
-        mut self,
-        shader_draw_parameters: bool,
-    ) -> PhysicalDeviceShaderDrawParametersFeaturesBuilder<'a> {
+    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
         self.inner.shader_draw_parameters = shader_draw_parameters.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderDrawParametersFeatures {
         self.inner
@@ -26176,41 +23948,37 @@ impl PhysicalDeviceShaderFloat16Int8Feat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
     inner: PhysicalDeviceShaderFloat16Int8Features,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderFloat16Int8Features {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderFloat16Int8Features {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
     type Target = PhysicalDeviceShaderFloat16Int8Features;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
-    pub fn shader_float16(
-        mut self,
-        shader_float16: bool,
-    ) -> PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
+    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
         self.inner.shader_float16 = shader_float16.into();
         self
     }
-    pub fn shader_int8(
-        mut self,
-        shader_int8: bool,
-    ) -> PhysicalDeviceShaderFloat16Int8FeaturesBuilder<'a> {
+    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
         self.inner.shader_int8 = shader_int8.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderFloat16Int8Features {
         self.inner
@@ -26290,132 +24058,123 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
     pub fn denorm_behavior_independence(
         mut self,
         denorm_behavior_independence: ShaderFloatControlsIndependence,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.denorm_behavior_independence = denorm_behavior_independence;
         self
     }
     pub fn rounding_mode_independence(
         mut self,
         rounding_mode_independence: ShaderFloatControlsIndependence,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.rounding_mode_independence = rounding_mode_independence;
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float16(
         mut self,
         shader_signed_zero_inf_nan_preserve_float16: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float16 =
             shader_signed_zero_inf_nan_preserve_float16.into();
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float32(
         mut self,
         shader_signed_zero_inf_nan_preserve_float32: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float32 =
             shader_signed_zero_inf_nan_preserve_float32.into();
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float64(
         mut self,
         shader_signed_zero_inf_nan_preserve_float64: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float64 =
             shader_signed_zero_inf_nan_preserve_float64.into();
         self
     }
-    pub fn shader_denorm_preserve_float16(
-        mut self,
-        shader_denorm_preserve_float16: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
         self.inner.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
         self
     }
-    pub fn shader_denorm_preserve_float32(
-        mut self,
-        shader_denorm_preserve_float32: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
         self.inner.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
         self
     }
-    pub fn shader_denorm_preserve_float64(
-        mut self,
-        shader_denorm_preserve_float64: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
         self.inner.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float16(
         mut self,
         shader_denorm_flush_to_zero_float16: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float32(
         mut self,
         shader_denorm_flush_to_zero_float32: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float64(
         mut self,
         shader_denorm_flush_to_zero_float64: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
         self
     }
     pub fn shader_rounding_mode_rte_float16(
         mut self,
         shader_rounding_mode_rte_float16: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
         self
     }
     pub fn shader_rounding_mode_rte_float32(
         mut self,
         shader_rounding_mode_rte_float32: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
         self
     }
     pub fn shader_rounding_mode_rte_float64(
         mut self,
         shader_rounding_mode_rte_float64: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float16(
         mut self,
         shader_rounding_mode_rtz_float16: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float32(
         mut self,
         shader_rounding_mode_rtz_float32: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float64(
         mut self,
         shader_rounding_mode_rtz_float64: bool,
-    ) -> PhysicalDeviceFloatControlsPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFloatControlsProperties {
         self.inner
@@ -26446,34 +24205,33 @@ impl PhysicalDeviceHostQueryResetFeature
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
     inner: PhysicalDeviceHostQueryResetFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceHostQueryResetFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceHostQueryResetFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceHostQueryResetFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceHostQueryResetFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
     type Target = PhysicalDeviceHostQueryResetFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
-    pub fn host_query_reset(
-        mut self,
-        host_query_reset: bool,
-    ) -> PhysicalDeviceHostQueryResetFeaturesBuilder<'a> {
+    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
         self.inner.host_query_reset = host_query_reset.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceHostQueryResetFeatures {
         self.inner
@@ -26506,21 +24264,21 @@ impl<'a> ::std::ops::Deref for NativeBuf
     }
 }
 impl<'a> ::std::ops::DerefMut for NativeBufferUsage2ANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> NativeBufferUsage2ANDROIDBuilder<'a> {
-    pub fn consumer(mut self, consumer: u64) -> NativeBufferUsage2ANDROIDBuilder<'a> {
+    pub fn consumer(mut self, consumer: u64) -> Self {
         self.inner.consumer = consumer;
         self
     }
-    pub fn producer(mut self, producer: u64) -> NativeBufferUsage2ANDROIDBuilder<'a> {
+    pub fn producer(mut self, producer: u64) -> Self {
         self.inner.producer = producer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> NativeBufferUsage2ANDROID {
         self.inner
@@ -26559,66 +24317,48 @@ impl NativeBufferANDROID {
         }
     }
 }
 #[repr(transparent)]
 pub struct NativeBufferANDROIDBuilder<'a> {
     inner: NativeBufferANDROID,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsNativeBufferANDROID {}
 impl<'a> ::std::ops::Deref for NativeBufferANDROIDBuilder<'a> {
     type Target = NativeBufferANDROID;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for NativeBufferANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> NativeBufferANDROIDBuilder<'a> {
-    pub fn handle(mut self, handle: *const c_void) -> NativeBufferANDROIDBuilder<'a> {
+    pub fn handle(mut self, handle: *const c_void) -> Self {
         self.inner.handle = handle;
         self
     }
-    pub fn stride(mut self, stride: c_int) -> NativeBufferANDROIDBuilder<'a> {
+    pub fn stride(mut self, stride: c_int) -> Self {
         self.inner.stride = stride;
         self
     }
-    pub fn format(mut self, format: c_int) -> NativeBufferANDROIDBuilder<'a> {
+    pub fn format(mut self, format: c_int) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn usage(mut self, usage: c_int) -> NativeBufferANDROIDBuilder<'a> {
+    pub fn usage(mut self, usage: c_int) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn usage2(mut self, usage2: NativeBufferUsage2ANDROID) -> NativeBufferANDROIDBuilder<'a> {
+    pub fn usage2(mut self, usage2: NativeBufferUsage2ANDROID) -> Self {
         self.inner.usage2 = usage2;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsNativeBufferANDROID>(
-        mut self,
-        next: &'a mut T,
-    ) -> NativeBufferANDROIDBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> NativeBufferANDROID {
         self.inner
     }
 }
 #[repr(C)]
@@ -26646,53 +24386,32 @@ impl SwapchainImageCreateInfoANDROID {
         }
     }
 }
 #[repr(transparent)]
 pub struct SwapchainImageCreateInfoANDROIDBuilder<'a> {
     inner: SwapchainImageCreateInfoANDROID,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSwapchainImageCreateInfoANDROID {}
 impl<'a> ::std::ops::Deref for SwapchainImageCreateInfoANDROIDBuilder<'a> {
     type Target = SwapchainImageCreateInfoANDROID;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SwapchainImageCreateInfoANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SwapchainImageCreateInfoANDROIDBuilder<'a> {
-    pub fn usage(
-        mut self,
-        usage: SwapchainImageUsageFlagsANDROID,
-    ) -> SwapchainImageCreateInfoANDROIDBuilder<'a> {
+    pub fn usage(mut self, usage: SwapchainImageUsageFlagsANDROID) -> Self {
         self.inner.usage = usage;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSwapchainImageCreateInfoANDROID>(
-        mut self,
-        next: &'a mut T,
-    ) -> SwapchainImageCreateInfoANDROIDBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SwapchainImageCreateInfoANDROID {
         self.inner
     }
 }
 #[repr(C)]
@@ -26720,53 +24439,32 @@ impl PhysicalDevicePresentationPropertie
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
     inner: PhysicalDevicePresentationPropertiesANDROID,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDevicePresentationPropertiesANDROID {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
     type Target = PhysicalDevicePresentationPropertiesANDROID;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
-    pub fn shared_image(
-        mut self,
-        shared_image: bool,
-    ) -> PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
+    pub fn shared_image(mut self, shared_image: bool) -> Self {
         self.inner.shared_image = shared_image.into();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDevicePresentationPropertiesANDROID>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDevicePresentationPropertiesANDROIDBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePresentationPropertiesANDROID {
         self.inner
     }
 }
 #[repr(C)]
@@ -26799,42 +24497,33 @@ impl<'a> ::std::ops::Deref for ShaderRes
     }
 }
 impl<'a> ::std::ops::DerefMut for ShaderResourceUsageAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ShaderResourceUsageAMDBuilder<'a> {
-    pub fn num_used_vgprs(mut self, num_used_vgprs: u32) -> ShaderResourceUsageAMDBuilder<'a> {
+    pub fn num_used_vgprs(mut self, num_used_vgprs: u32) -> Self {
         self.inner.num_used_vgprs = num_used_vgprs;
         self
     }
-    pub fn num_used_sgprs(mut self, num_used_sgprs: u32) -> ShaderResourceUsageAMDBuilder<'a> {
+    pub fn num_used_sgprs(mut self, num_used_sgprs: u32) -> Self {
         self.inner.num_used_sgprs = num_used_sgprs;
         self
     }
-    pub fn lds_size_per_local_work_group(
-        mut self,
-        lds_size_per_local_work_group: u32,
-    ) -> ShaderResourceUsageAMDBuilder<'a> {
+    pub fn lds_size_per_local_work_group(mut self, lds_size_per_local_work_group: u32) -> Self {
         self.inner.lds_size_per_local_work_group = lds_size_per_local_work_group;
         self
     }
-    pub fn lds_usage_size_in_bytes(
-        mut self,
-        lds_usage_size_in_bytes: usize,
-    ) -> ShaderResourceUsageAMDBuilder<'a> {
+    pub fn lds_usage_size_in_bytes(mut self, lds_usage_size_in_bytes: usize) -> Self {
         self.inner.lds_usage_size_in_bytes = lds_usage_size_in_bytes;
         self
     }
-    pub fn scratch_mem_usage_in_bytes(
-        mut self,
-        scratch_mem_usage_in_bytes: usize,
-    ) -> ShaderResourceUsageAMDBuilder<'a> {
+    pub fn scratch_mem_usage_in_bytes(mut self, scratch_mem_usage_in_bytes: usize) -> Self {
         self.inner.scratch_mem_usage_in_bytes = scratch_mem_usage_in_bytes;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ShaderResourceUsageAMD {
         self.inner
@@ -26885,62 +24574,41 @@ impl<'a> ::std::ops::Deref for ShaderSta
     }
 }
 impl<'a> ::std::ops::DerefMut for ShaderStatisticsInfoAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ShaderStatisticsInfoAMDBuilder<'a> {
-    pub fn shader_stage_mask(
-        mut self,
-        shader_stage_mask: ShaderStageFlags,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn shader_stage_mask(mut self, shader_stage_mask: ShaderStageFlags) -> Self {
         self.inner.shader_stage_mask = shader_stage_mask;
         self
     }
-    pub fn resource_usage(
-        mut self,
-        resource_usage: ShaderResourceUsageAMD,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn resource_usage(mut self, resource_usage: ShaderResourceUsageAMD) -> Self {
         self.inner.resource_usage = resource_usage;
         self
     }
-    pub fn num_physical_vgprs(
-        mut self,
-        num_physical_vgprs: u32,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn num_physical_vgprs(mut self, num_physical_vgprs: u32) -> Self {
         self.inner.num_physical_vgprs = num_physical_vgprs;
         self
     }
-    pub fn num_physical_sgprs(
-        mut self,
-        num_physical_sgprs: u32,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn num_physical_sgprs(mut self, num_physical_sgprs: u32) -> Self {
         self.inner.num_physical_sgprs = num_physical_sgprs;
         self
     }
-    pub fn num_available_vgprs(
-        mut self,
-        num_available_vgprs: u32,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn num_available_vgprs(mut self, num_available_vgprs: u32) -> Self {
         self.inner.num_available_vgprs = num_available_vgprs;
         self
     }
-    pub fn num_available_sgprs(
-        mut self,
-        num_available_sgprs: u32,
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn num_available_sgprs(mut self, num_available_sgprs: u32) -> Self {
         self.inner.num_available_sgprs = num_available_sgprs;
         self
     }
-    pub fn compute_work_group_size(
-        mut self,
-        compute_work_group_size: [u32; 3],
-    ) -> ShaderStatisticsInfoAMDBuilder<'a> {
+    pub fn compute_work_group_size(mut self, compute_work_group_size: [u32; 3]) -> Self {
         self.inner.compute_work_group_size = compute_work_group_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ShaderStatisticsInfoAMD {
         self.inner
@@ -26985,32 +24653,153 @@ impl<'a> ::std::ops::Deref for DeviceQue
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceQueueGlobalPriorityCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceQueueGlobalPriorityCreateInfoEXTBuilder<'a> {
-    pub fn global_priority(
-        mut self,
-        global_priority: QueueGlobalPriorityEXT,
-    ) -> DeviceQueueGlobalPriorityCreateInfoEXTBuilder<'a> {
+    pub fn global_priority(mut self, global_priority: QueueGlobalPriorityEXT) -> Self {
         self.inner.global_priority = global_priority;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceQueueGlobalPriorityCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.html>"]
+pub struct PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub global_priority_query: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+    fn default() -> PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+        PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            global_priority_query: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'a> {
+        PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder {
+            inner: PhysicalDeviceGlobalPriorityQueryFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceGlobalPriorityQueryFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceGlobalPriorityQueryFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceGlobalPriorityQueryFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceGlobalPriorityQueryFeaturesEXTBuilder<'a> {
+    pub fn global_priority_query(mut self, global_priority_query: bool) -> Self {
+        self.inner.global_priority_query = global_priority_query.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceGlobalPriorityQueryFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFamilyGlobalPriorityPropertiesEXT.html>"]
+pub struct QueueFamilyGlobalPriorityPropertiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub priority_count: u32,
+    pub priorities: [QueueGlobalPriorityEXT; MAX_GLOBAL_PRIORITY_SIZE_EXT],
+}
+impl ::std::default::Default for QueueFamilyGlobalPriorityPropertiesEXT {
+    fn default() -> QueueFamilyGlobalPriorityPropertiesEXT {
+        QueueFamilyGlobalPriorityPropertiesEXT {
+            s_type: StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            priority_count: u32::default(),
+            priorities: unsafe { ::std::mem::zeroed() },
+        }
+    }
+}
+impl QueueFamilyGlobalPriorityPropertiesEXT {
+    pub fn builder<'a>() -> QueueFamilyGlobalPriorityPropertiesEXTBuilder<'a> {
+        QueueFamilyGlobalPriorityPropertiesEXTBuilder {
+            inner: QueueFamilyGlobalPriorityPropertiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct QueueFamilyGlobalPriorityPropertiesEXTBuilder<'a> {
+    inner: QueueFamilyGlobalPriorityPropertiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyGlobalPriorityPropertiesEXTBuilder<'_> {}
+unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyGlobalPriorityPropertiesEXT {}
+impl<'a> ::std::ops::Deref for QueueFamilyGlobalPriorityPropertiesEXTBuilder<'a> {
+    type Target = QueueFamilyGlobalPriorityPropertiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for QueueFamilyGlobalPriorityPropertiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> QueueFamilyGlobalPriorityPropertiesEXTBuilder<'a> {
+    pub fn priority_count(mut self, priority_count: u32) -> Self {
+        self.inner.priority_count = priority_count;
+        self
+    }
+    pub fn priorities(
+        mut self,
+        priorities: [QueueGlobalPriorityEXT; MAX_GLOBAL_PRIORITY_SIZE_EXT],
+    ) -> Self {
+        self.inner.priorities = priorities;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> QueueFamilyGlobalPriorityPropertiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDebugUtilsObjectNameInfoEXT.html>"]
 pub struct DebugUtilsObjectNameInfoEXT {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub object_type: ObjectType,
     pub object_handle: u64,
     pub p_object_name: *const c_char,
 }
@@ -27033,64 +24822,40 @@ impl DebugUtilsObjectNameInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugUtilsObjectNameInfoEXTBuilder<'a> {
     inner: DebugUtilsObjectNameInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugUtilsObjectNameInfoEXT {}
 impl<'a> ::std::ops::Deref for DebugUtilsObjectNameInfoEXTBuilder<'a> {
     type Target = DebugUtilsObjectNameInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugUtilsObjectNameInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugUtilsObjectNameInfoEXTBuilder<'a> {
-    pub fn object_type(
-        mut self,
-        object_type: ObjectType,
-    ) -> DebugUtilsObjectNameInfoEXTBuilder<'a> {
+    pub fn object_type(mut self, object_type: ObjectType) -> Self {
         self.inner.object_type = object_type;
         self
     }
-    pub fn object_handle(mut self, object_handle: u64) -> DebugUtilsObjectNameInfoEXTBuilder<'a> {
+    pub fn object_handle(mut self, object_handle: u64) -> Self {
         self.inner.object_handle = object_handle;
         self
     }
-    pub fn object_name(
-        mut self,
-        object_name: &'a ::std::ffi::CStr,
-    ) -> DebugUtilsObjectNameInfoEXTBuilder<'a> {
+    pub fn object_name(mut self, object_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_object_name = object_name.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugUtilsObjectNameInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugUtilsObjectNameInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugUtilsObjectNameInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27126,63 +24891,45 @@ impl DebugUtilsObjectTagInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugUtilsObjectTagInfoEXTBuilder<'a> {
     inner: DebugUtilsObjectTagInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugUtilsObjectTagInfoEXT {}
 impl<'a> ::std::ops::Deref for DebugUtilsObjectTagInfoEXTBuilder<'a> {
     type Target = DebugUtilsObjectTagInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugUtilsObjectTagInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugUtilsObjectTagInfoEXTBuilder<'a> {
-    pub fn object_type(mut self, object_type: ObjectType) -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
+    pub fn object_type(mut self, object_type: ObjectType) -> Self {
         self.inner.object_type = object_type;
         self
     }
-    pub fn object_handle(mut self, object_handle: u64) -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
+    pub fn object_handle(mut self, object_handle: u64) -> Self {
         self.inner.object_handle = object_handle;
         self
     }
-    pub fn tag_name(mut self, tag_name: u64) -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
+    pub fn tag_name(mut self, tag_name: u64) -> Self {
         self.inner.tag_name = tag_name;
         self
     }
-    pub fn tag(mut self, tag: &'a [u8]) -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
+    pub fn tag(mut self, tag: &'a [u8]) -> Self {
         self.inner.tag_size = tag.len() as _;
         self.inner.p_tag = tag.as_ptr() as *const c_void;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugUtilsObjectTagInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugUtilsObjectTagInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugUtilsObjectTagInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27212,54 +24959,36 @@ impl DebugUtilsLabelEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugUtilsLabelEXTBuilder<'a> {
     inner: DebugUtilsLabelEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugUtilsLabelEXT {}
 impl<'a> ::std::ops::Deref for DebugUtilsLabelEXTBuilder<'a> {
     type Target = DebugUtilsLabelEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugUtilsLabelEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugUtilsLabelEXTBuilder<'a> {
-    pub fn label_name(mut self, label_name: &'a ::std::ffi::CStr) -> DebugUtilsLabelEXTBuilder<'a> {
+    pub fn label_name(mut self, label_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_label_name = label_name.as_ptr();
         self
     }
-    pub fn color(mut self, color: [f32; 4]) -> DebugUtilsLabelEXTBuilder<'a> {
+    pub fn color(mut self, color: [f32; 4]) -> Self {
         self.inner.color = color;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugUtilsLabelEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugUtilsLabelEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugUtilsLabelEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27325,48 +25054,36 @@ impl<'a> ::std::ops::Deref for DebugUtil
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DebugUtilsMessengerCreateFlagsEXT,
-    ) -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn message_severity(
-        mut self,
-        message_severity: DebugUtilsMessageSeverityFlagsEXT,
-    ) -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DebugUtilsMessengerCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn message_severity(mut self, message_severity: DebugUtilsMessageSeverityFlagsEXT) -> Self {
         self.inner.message_severity = message_severity;
         self
     }
-    pub fn message_type(
-        mut self,
-        message_type: DebugUtilsMessageTypeFlagsEXT,
-    ) -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
+    pub fn message_type(mut self, message_type: DebugUtilsMessageTypeFlagsEXT) -> Self {
         self.inner.message_type = message_type;
         self
     }
     pub fn pfn_user_callback(
         mut self,
         pfn_user_callback: PFN_vkDebugUtilsMessengerCallbackEXT,
-    ) -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.pfn_user_callback = pfn_user_callback;
         self
     }
-    pub fn user_data(
-        mut self,
-        user_data: *mut c_void,
-    ) -> DebugUtilsMessengerCreateInfoEXTBuilder<'a> {
+    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
         self.inner.p_user_data = user_data;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugUtilsMessengerCreateInfoEXT {
         self.inner
@@ -27415,98 +25132,59 @@ impl DebugUtilsMessengerCallbackDataEXT 
         }
     }
 }
 #[repr(transparent)]
 pub struct DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
     inner: DebugUtilsMessengerCallbackDataEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDebugUtilsMessengerCallbackDataEXT {}
 impl<'a> ::std::ops::Deref for DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
     type Target = DebugUtilsMessengerCallbackDataEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DebugUtilsMessengerCallbackDataFlagsEXT,
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn message_id_name(
-        mut self,
-        message_id_name: &'a ::std::ffi::CStr,
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DebugUtilsMessengerCallbackDataFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn message_id_name(mut self, message_id_name: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_message_id_name = message_id_name.as_ptr();
         self
     }
-    pub fn message_id_number(
-        mut self,
-        message_id_number: i32,
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn message_id_number(mut self, message_id_number: i32) -> Self {
         self.inner.message_id_number = message_id_number;
         self
     }
-    pub fn message(
-        mut self,
-        message: &'a ::std::ffi::CStr,
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn message(mut self, message: &'a ::std::ffi::CStr) -> Self {
         self.inner.p_message = message.as_ptr();
         self
     }
-    pub fn queue_labels(
-        mut self,
-        queue_labels: &'a [DebugUtilsLabelEXT],
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn queue_labels(mut self, queue_labels: &'a [DebugUtilsLabelEXT]) -> Self {
         self.inner.queue_label_count = queue_labels.len() as _;
         self.inner.p_queue_labels = queue_labels.as_ptr();
         self
     }
-    pub fn cmd_buf_labels(
-        mut self,
-        cmd_buf_labels: &'a [DebugUtilsLabelEXT],
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn cmd_buf_labels(mut self, cmd_buf_labels: &'a [DebugUtilsLabelEXT]) -> Self {
         self.inner.cmd_buf_label_count = cmd_buf_labels.len() as _;
         self.inner.p_cmd_buf_labels = cmd_buf_labels.as_ptr();
         self
     }
-    pub fn objects(
-        mut self,
-        objects: &'a [DebugUtilsObjectNameInfoEXT],
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
+    pub fn objects(mut self, objects: &'a [DebugUtilsObjectNameInfoEXT]) -> Self {
         self.inner.object_count = objects.len() as _;
         self.inner.p_objects = objects.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDebugUtilsMessengerCallbackDataEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DebugUtilsMessengerCallbackDataEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DebugUtilsMessengerCallbackDataEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27534,34 +25212,36 @@ impl PhysicalDeviceDeviceMemoryReportFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceDeviceMemoryReportFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDeviceMemoryReportFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceDeviceMemoryReportFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
-    pub fn device_memory_report(
-        mut self,
-        device_memory_report: bool,
-    ) -> PhysicalDeviceDeviceMemoryReportFeaturesEXTBuilder<'a> {
+    pub fn device_memory_report(mut self, device_memory_report: bool) -> Self {
         self.inner.device_memory_report = device_memory_report.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDeviceMemoryReportFeaturesEXT {
         self.inner
@@ -27624,63 +25304,57 @@ impl<'a> ::std::ops::Deref for DeviceDev
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DeviceMemoryReportFlagsEXT,
-    ) -> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn pfn_user_callback(
         mut self,
         pfn_user_callback: PFN_vkDeviceMemoryReportCallbackEXT,
-    ) -> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.pfn_user_callback = pfn_user_callback;
         self
     }
-    pub fn user_data(
-        mut self,
-        user_data: *mut c_void,
-    ) -> DeviceDeviceMemoryReportCreateInfoEXTBuilder<'a> {
+    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
         self.inner.p_user_data = user_data;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceDeviceMemoryReportCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDeviceMemoryReportCallbackDataEXT.html>"]
 pub struct DeviceMemoryReportCallbackDataEXT {
     pub s_type: StructureType,
-    pub p_next: *const c_void,
+    pub p_next: *mut c_void,
     pub flags: DeviceMemoryReportFlagsEXT,
     pub ty: DeviceMemoryReportEventTypeEXT,
     pub memory_object_id: u64,
     pub size: DeviceSize,
     pub object_type: ObjectType,
     pub object_handle: u64,
     pub heap_index: u32,
 }
 impl ::std::default::Default for DeviceMemoryReportCallbackDataEXT {
     fn default() -> DeviceMemoryReportCallbackDataEXT {
         DeviceMemoryReportCallbackDataEXT {
             s_type: StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
-            p_next: ::std::ptr::null(),
+            p_next: ::std::ptr::null_mut(),
             flags: DeviceMemoryReportFlagsEXT::default(),
             ty: DeviceMemoryReportEventTypeEXT::default(),
             memory_object_id: u64::default(),
             size: DeviceSize::default(),
             object_type: ObjectType::default(),
             object_handle: u64::default(),
             heap_index: u32::default(),
         }
@@ -27694,89 +25368,56 @@ impl DeviceMemoryReportCallbackDataEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct DeviceMemoryReportCallbackDataEXTBuilder<'a> {
     inner: DeviceMemoryReportCallbackDataEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDeviceMemoryReportCallbackDataEXT {}
 impl<'a> ::std::ops::Deref for DeviceMemoryReportCallbackDataEXTBuilder<'a> {
     type Target = DeviceMemoryReportCallbackDataEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceMemoryReportCallbackDataEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DeviceMemoryReportFlagsEXT,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn ty(
-        mut self,
-        ty: DeviceMemoryReportEventTypeEXT,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn flags(mut self, flags: DeviceMemoryReportFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn ty(mut self, ty: DeviceMemoryReportEventTypeEXT) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn memory_object_id(
-        mut self,
-        memory_object_id: u64,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn memory_object_id(mut self, memory_object_id: u64) -> Self {
         self.inner.memory_object_id = memory_object_id;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn object_type(
-        mut self,
-        object_type: ObjectType,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn object_type(mut self, object_type: ObjectType) -> Self {
         self.inner.object_type = object_type;
         self
     }
-    pub fn object_handle(
-        mut self,
-        object_handle: u64,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn object_handle(mut self, object_handle: u64) -> Self {
         self.inner.object_handle = object_handle;
         self
     }
-    pub fn heap_index(mut self, heap_index: u32) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
+    pub fn heap_index(mut self, heap_index: u32) -> Self {
         self.inner.heap_index = heap_index;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceMemoryReportCallbackDataEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceMemoryReportCallbackDataEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceMemoryReportCallbackDataEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27820,27 +25461,21 @@ impl<'a> ::std::ops::Deref for ImportMem
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportMemoryHostPointerInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportMemoryHostPointerInfoEXTBuilder<'a> {
-    pub fn handle_type(
-        mut self,
-        handle_type: ExternalMemoryHandleTypeFlags,
-    ) -> ImportMemoryHostPointerInfoEXTBuilder<'a> {
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
         self.inner.handle_type = handle_type;
         self
     }
-    pub fn host_pointer(
-        mut self,
-        host_pointer: *mut c_void,
-    ) -> ImportMemoryHostPointerInfoEXTBuilder<'a> {
+    pub fn host_pointer(mut self, host_pointer: *mut c_void) -> Self {
         self.inner.p_host_pointer = host_pointer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportMemoryHostPointerInfoEXT {
         self.inner
@@ -27871,53 +25506,32 @@ impl MemoryHostPointerPropertiesEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryHostPointerPropertiesEXTBuilder<'a> {
     inner: MemoryHostPointerPropertiesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryHostPointerPropertiesEXT {}
 impl<'a> ::std::ops::Deref for MemoryHostPointerPropertiesEXTBuilder<'a> {
     type Target = MemoryHostPointerPropertiesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryHostPointerPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryHostPointerPropertiesEXTBuilder<'a> {
-    pub fn memory_type_bits(
-        mut self,
-        memory_type_bits: u32,
-    ) -> MemoryHostPointerPropertiesEXTBuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
         self.inner.memory_type_bits = memory_type_bits;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryHostPointerPropertiesEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryHostPointerPropertiesEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryHostPointerPropertiesEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -27965,17 +25579,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
     pub fn min_imported_host_pointer_alignment(
         mut self,
         min_imported_host_pointer_alignment: DeviceSize,
-    ) -> PhysicalDeviceExternalMemoryHostPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.min_imported_host_pointer_alignment = min_imported_host_pointer_alignment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExternalMemoryHostPropertiesEXT {
         self.inner
@@ -28042,80 +25656,71 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
-    pub fn primitive_overestimation_size(
-        mut self,
-        primitive_overestimation_size: f32,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    pub fn primitive_overestimation_size(mut self, primitive_overestimation_size: f32) -> Self {
         self.inner.primitive_overestimation_size = primitive_overestimation_size;
         self
     }
     pub fn max_extra_primitive_overestimation_size(
         mut self,
         max_extra_primitive_overestimation_size: f32,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_extra_primitive_overestimation_size =
             max_extra_primitive_overestimation_size;
         self
     }
     pub fn extra_primitive_overestimation_size_granularity(
         mut self,
         extra_primitive_overestimation_size_granularity: f32,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.extra_primitive_overestimation_size_granularity =
             extra_primitive_overestimation_size_granularity;
         self
     }
-    pub fn primitive_underestimation(
-        mut self,
-        primitive_underestimation: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    pub fn primitive_underestimation(mut self, primitive_underestimation: bool) -> Self {
         self.inner.primitive_underestimation = primitive_underestimation.into();
         self
     }
     pub fn conservative_point_and_line_rasterization(
         mut self,
         conservative_point_and_line_rasterization: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.conservative_point_and_line_rasterization =
             conservative_point_and_line_rasterization.into();
         self
     }
     pub fn degenerate_triangles_rasterized(
         mut self,
         degenerate_triangles_rasterized: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.degenerate_triangles_rasterized = degenerate_triangles_rasterized.into();
         self
     }
-    pub fn degenerate_lines_rasterized(
-        mut self,
-        degenerate_lines_rasterized: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    pub fn degenerate_lines_rasterized(mut self, degenerate_lines_rasterized: bool) -> Self {
         self.inner.degenerate_lines_rasterized = degenerate_lines_rasterized.into();
         self
     }
     pub fn fully_covered_fragment_shader_input_variable(
         mut self,
         fully_covered_fragment_shader_input_variable: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fully_covered_fragment_shader_input_variable =
             fully_covered_fragment_shader_input_variable.into();
         self
     }
     pub fn conservative_rasterization_post_depth_coverage(
         mut self,
         conservative_rasterization_post_depth_coverage: bool,
-    ) -> PhysicalDeviceConservativeRasterizationPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.conservative_rasterization_post_depth_coverage =
             conservative_rasterization_post_depth_coverage.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceConservativeRasterizationPropertiesEXT {
@@ -28147,53 +25752,32 @@ impl CalibratedTimestampInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct CalibratedTimestampInfoEXTBuilder<'a> {
     inner: CalibratedTimestampInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCalibratedTimestampInfoEXT {}
 impl<'a> ::std::ops::Deref for CalibratedTimestampInfoEXTBuilder<'a> {
     type Target = CalibratedTimestampInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CalibratedTimestampInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CalibratedTimestampInfoEXTBuilder<'a> {
-    pub fn time_domain(
-        mut self,
-        time_domain: TimeDomainEXT,
-    ) -> CalibratedTimestampInfoEXTBuilder<'a> {
+    pub fn time_domain(mut self, time_domain: TimeDomainEXT) -> Self {
         self.inner.time_domain = time_domain;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCalibratedTimestampInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> CalibratedTimestampInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CalibratedTimestampInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -28261,111 +25845,69 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
-    pub fn shader_engine_count(
-        mut self,
-        shader_engine_count: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn shader_engine_count(mut self, shader_engine_count: u32) -> Self {
         self.inner.shader_engine_count = shader_engine_count;
         self
     }
-    pub fn shader_arrays_per_engine_count(
-        mut self,
-        shader_arrays_per_engine_count: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn shader_arrays_per_engine_count(mut self, shader_arrays_per_engine_count: u32) -> Self {
         self.inner.shader_arrays_per_engine_count = shader_arrays_per_engine_count;
         self
     }
-    pub fn compute_units_per_shader_array(
-        mut self,
-        compute_units_per_shader_array: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn compute_units_per_shader_array(mut self, compute_units_per_shader_array: u32) -> Self {
         self.inner.compute_units_per_shader_array = compute_units_per_shader_array;
         self
     }
-    pub fn simd_per_compute_unit(
-        mut self,
-        simd_per_compute_unit: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn simd_per_compute_unit(mut self, simd_per_compute_unit: u32) -> Self {
         self.inner.simd_per_compute_unit = simd_per_compute_unit;
         self
     }
-    pub fn wavefronts_per_simd(
-        mut self,
-        wavefronts_per_simd: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn wavefronts_per_simd(mut self, wavefronts_per_simd: u32) -> Self {
         self.inner.wavefronts_per_simd = wavefronts_per_simd;
         self
     }
-    pub fn wavefront_size(
-        mut self,
-        wavefront_size: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn wavefront_size(mut self, wavefront_size: u32) -> Self {
         self.inner.wavefront_size = wavefront_size;
         self
     }
-    pub fn sgprs_per_simd(
-        mut self,
-        sgprs_per_simd: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn sgprs_per_simd(mut self, sgprs_per_simd: u32) -> Self {
         self.inner.sgprs_per_simd = sgprs_per_simd;
         self
     }
-    pub fn min_sgpr_allocation(
-        mut self,
-        min_sgpr_allocation: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn min_sgpr_allocation(mut self, min_sgpr_allocation: u32) -> Self {
         self.inner.min_sgpr_allocation = min_sgpr_allocation;
         self
     }
-    pub fn max_sgpr_allocation(
-        mut self,
-        max_sgpr_allocation: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn max_sgpr_allocation(mut self, max_sgpr_allocation: u32) -> Self {
         self.inner.max_sgpr_allocation = max_sgpr_allocation;
         self
     }
-    pub fn sgpr_allocation_granularity(
-        mut self,
-        sgpr_allocation_granularity: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn sgpr_allocation_granularity(mut self, sgpr_allocation_granularity: u32) -> Self {
         self.inner.sgpr_allocation_granularity = sgpr_allocation_granularity;
         self
     }
-    pub fn vgprs_per_simd(
-        mut self,
-        vgprs_per_simd: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn vgprs_per_simd(mut self, vgprs_per_simd: u32) -> Self {
         self.inner.vgprs_per_simd = vgprs_per_simd;
         self
     }
-    pub fn min_vgpr_allocation(
-        mut self,
-        min_vgpr_allocation: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn min_vgpr_allocation(mut self, min_vgpr_allocation: u32) -> Self {
         self.inner.min_vgpr_allocation = min_vgpr_allocation;
         self
     }
-    pub fn max_vgpr_allocation(
-        mut self,
-        max_vgpr_allocation: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn max_vgpr_allocation(mut self, max_vgpr_allocation: u32) -> Self {
         self.inner.max_vgpr_allocation = max_vgpr_allocation;
         self
     }
-    pub fn vgpr_allocation_granularity(
-        mut self,
-        vgpr_allocation_granularity: u32,
-    ) -> PhysicalDeviceShaderCorePropertiesAMDBuilder<'a> {
+    pub fn vgpr_allocation_granularity(mut self, vgpr_allocation_granularity: u32) -> Self {
         self.inner.vgpr_allocation_granularity = vgpr_allocation_granularity;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderCorePropertiesAMD {
         self.inner
@@ -28415,24 +25957,21 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
     pub fn shader_core_features(
         mut self,
         shader_core_features: ShaderCorePropertiesFlagsAMD,
-    ) -> PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
+    ) -> Self {
         self.inner.shader_core_features = shader_core_features;
         self
     }
-    pub fn active_compute_unit_count(
-        mut self,
-        active_compute_unit_count: u32,
-    ) -> PhysicalDeviceShaderCoreProperties2AMDBuilder<'a> {
+    pub fn active_compute_unit_count(mut self, active_compute_unit_count: u32) -> Self {
         self.inner.active_compute_unit_count = active_compute_unit_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderCoreProperties2AMD {
         self.inner
@@ -28487,34 +26026,31 @@ impl<'a> ::std::ops::Deref for PipelineR
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineRasterizationConservativeStateCreateFlagsEXT,
-    ) -> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineRasterizationConservativeStateCreateFlagsEXT) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn conservative_rasterization_mode(
         mut self,
         conservative_rasterization_mode: ConservativeRasterizationModeEXT,
-    ) -> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.conservative_rasterization_mode = conservative_rasterization_mode;
         self
     }
     pub fn extra_primitive_overestimation_size(
         mut self,
         extra_primitive_overestimation_size: f32,
-    ) -> PipelineRasterizationConservativeStateCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.extra_primitive_overestimation_size = extra_primitive_overestimation_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRasterizationConservativeStateCreateInfoEXT {
         self.inner
@@ -28583,16 +26119,18 @@ impl PhysicalDeviceDescriptorIndexingFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
     inner: PhysicalDeviceDescriptorIndexingFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDescriptorIndexingFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDescriptorIndexingFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
     type Target = PhysicalDeviceDescriptorIndexingFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -28600,179 +26138,176 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
     pub fn shader_input_attachment_array_dynamic_indexing(
         mut self,
         shader_input_attachment_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_input_attachment_array_dynamic_indexing =
             shader_input_attachment_array_dynamic_indexing.into();
         self
     }
     pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
         mut self,
         shader_uniform_texel_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_texel_buffer_array_dynamic_indexing =
             shader_uniform_texel_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_storage_texel_buffer_array_dynamic_indexing(
         mut self,
         shader_storage_texel_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_texel_buffer_array_dynamic_indexing =
             shader_storage_texel_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_uniform_buffer_array_non_uniform_indexing(
         mut self,
         shader_uniform_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_uniform_buffer_array_non_uniform_indexing =
             shader_uniform_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_sampled_image_array_non_uniform_indexing(
         mut self,
         shader_sampled_image_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_sampled_image_array_non_uniform_indexing =
             shader_sampled_image_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_buffer_array_non_uniform_indexing(
         mut self,
         shader_storage_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_buffer_array_non_uniform_indexing =
             shader_storage_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_image_array_non_uniform_indexing(
         mut self,
         shader_storage_image_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_array_non_uniform_indexing =
             shader_storage_image_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_input_attachment_array_non_uniform_indexing(
         mut self,
         shader_input_attachment_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_input_attachment_array_non_uniform_indexing =
             shader_input_attachment_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
         mut self,
         shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_texel_buffer_array_non_uniform_indexing =
             shader_uniform_texel_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
         mut self,
         shader_storage_texel_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_texel_buffer_array_non_uniform_indexing =
             shader_storage_texel_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn descriptor_binding_uniform_buffer_update_after_bind(
         mut self,
         descriptor_binding_uniform_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_uniform_buffer_update_after_bind =
             descriptor_binding_uniform_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_sampled_image_update_after_bind(
         mut self,
         descriptor_binding_sampled_image_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_sampled_image_update_after_bind =
             descriptor_binding_sampled_image_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_image_update_after_bind(
         mut self,
         descriptor_binding_storage_image_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_image_update_after_bind =
             descriptor_binding_storage_image_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_buffer_update_after_bind(
         mut self,
         descriptor_binding_storage_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_buffer_update_after_bind =
             descriptor_binding_storage_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
         mut self,
         descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_uniform_texel_buffer_update_after_bind =
             descriptor_binding_uniform_texel_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
         mut self,
         descriptor_binding_storage_texel_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_texel_buffer_update_after_bind =
             descriptor_binding_storage_texel_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_update_unused_while_pending(
         mut self,
         descriptor_binding_update_unused_while_pending: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_update_unused_while_pending =
             descriptor_binding_update_unused_while_pending.into();
         self
     }
     pub fn descriptor_binding_partially_bound(
         mut self,
         descriptor_binding_partially_bound: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
         self
     }
     pub fn descriptor_binding_variable_descriptor_count(
         mut self,
         descriptor_binding_variable_descriptor_count: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_variable_descriptor_count =
             descriptor_binding_variable_descriptor_count.into();
         self
     }
-    pub fn runtime_descriptor_array(
-        mut self,
-        runtime_descriptor_array: bool,
-    ) -> PhysicalDeviceDescriptorIndexingFeaturesBuilder<'a> {
+    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
         self.inner.runtime_descriptor_array = runtime_descriptor_array.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDescriptorIndexingFeatures {
         self.inner
@@ -28867,209 +26402,206 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
     pub fn max_update_after_bind_descriptors_in_all_pools(
         mut self,
         max_update_after_bind_descriptors_in_all_pools: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_update_after_bind_descriptors_in_all_pools =
             max_update_after_bind_descriptors_in_all_pools;
         self
     }
     pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
         mut self,
         shader_uniform_buffer_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_buffer_array_non_uniform_indexing_native =
             shader_uniform_buffer_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_sampled_image_array_non_uniform_indexing_native(
         mut self,
         shader_sampled_image_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_sampled_image_array_non_uniform_indexing_native =
             shader_sampled_image_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_storage_buffer_array_non_uniform_indexing_native(
         mut self,
         shader_storage_buffer_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_buffer_array_non_uniform_indexing_native =
             shader_storage_buffer_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_storage_image_array_non_uniform_indexing_native(
         mut self,
         shader_storage_image_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_image_array_non_uniform_indexing_native =
             shader_storage_image_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_input_attachment_array_non_uniform_indexing_native(
         mut self,
         shader_input_attachment_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_input_attachment_array_non_uniform_indexing_native =
             shader_input_attachment_array_non_uniform_indexing_native.into();
         self
     }
     pub fn robust_buffer_access_update_after_bind(
         mut self,
         robust_buffer_access_update_after_bind: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.robust_buffer_access_update_after_bind =
             robust_buffer_access_update_after_bind.into();
         self
     }
-    pub fn quad_divergent_implicit_lod(
-        mut self,
-        quad_divergent_implicit_lod: bool,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
         self.inner.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_samplers(
         mut self,
         max_per_stage_descriptor_update_after_bind_samplers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_samplers =
             max_per_stage_descriptor_update_after_bind_samplers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
         mut self,
         max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_uniform_buffers =
             max_per_stage_descriptor_update_after_bind_uniform_buffers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
         mut self,
         max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_storage_buffers =
             max_per_stage_descriptor_update_after_bind_storage_buffers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
         mut self,
         max_per_stage_descriptor_update_after_bind_sampled_images: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_sampled_images =
             max_per_stage_descriptor_update_after_bind_sampled_images;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_storage_images(
         mut self,
         max_per_stage_descriptor_update_after_bind_storage_images: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_storage_images =
             max_per_stage_descriptor_update_after_bind_storage_images;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
         mut self,
         max_per_stage_descriptor_update_after_bind_input_attachments: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_input_attachments =
             max_per_stage_descriptor_update_after_bind_input_attachments;
         self
     }
     pub fn max_per_stage_update_after_bind_resources(
         mut self,
         max_per_stage_update_after_bind_resources: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_update_after_bind_resources =
             max_per_stage_update_after_bind_resources;
         self
     }
     pub fn max_descriptor_set_update_after_bind_samplers(
         mut self,
         max_descriptor_set_update_after_bind_samplers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_update_after_bind_samplers =
             max_descriptor_set_update_after_bind_samplers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_uniform_buffers(
         mut self,
         max_descriptor_set_update_after_bind_uniform_buffers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_uniform_buffers =
             max_descriptor_set_update_after_bind_uniform_buffers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
         mut self,
         max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
             max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_buffers(
         mut self,
         max_descriptor_set_update_after_bind_storage_buffers: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_buffers =
             max_descriptor_set_update_after_bind_storage_buffers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
         mut self,
         max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_buffers_dynamic =
             max_descriptor_set_update_after_bind_storage_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_update_after_bind_sampled_images(
         mut self,
         max_descriptor_set_update_after_bind_sampled_images: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_sampled_images =
             max_descriptor_set_update_after_bind_sampled_images;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_images(
         mut self,
         max_descriptor_set_update_after_bind_storage_images: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_images =
             max_descriptor_set_update_after_bind_storage_images;
         self
     }
     pub fn max_descriptor_set_update_after_bind_input_attachments(
         mut self,
         max_descriptor_set_update_after_bind_input_attachments: u32,
-    ) -> PhysicalDeviceDescriptorIndexingPropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_input_attachments =
             max_descriptor_set_update_after_bind_input_attachments;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -29121,20 +26653,17 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
-    pub fn binding_flags(
-        mut self,
-        binding_flags: &'a [DescriptorBindingFlags],
-    ) -> DescriptorSetLayoutBindingFlagsCreateInfoBuilder<'a> {
+    pub fn binding_flags(mut self, binding_flags: &'a [DescriptorBindingFlags]) -> Self {
         self.inner.binding_count = binding_flags.len() as _;
         self.inner.p_binding_flags = binding_flags.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorSetLayoutBindingFlagsCreateInfo {
@@ -29185,20 +26714,17 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
-    pub fn descriptor_counts(
-        mut self,
-        descriptor_counts: &'a [u32],
-    ) -> DescriptorSetVariableDescriptorCountAllocateInfoBuilder<'a> {
+    pub fn descriptor_counts(mut self, descriptor_counts: &'a [u32]) -> Self {
         self.inner.descriptor_set_count = descriptor_counts.len() as _;
         self.inner.p_descriptor_counts = descriptor_counts.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorSetVariableDescriptorCountAllocateInfo {
@@ -29250,20 +26776,17 @@ impl<'a> ::std::ops::Deref for Descripto
     }
 }
 impl<'a> ::std::ops::DerefMut for DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
-    pub fn max_variable_descriptor_count(
-        mut self,
-        max_variable_descriptor_count: u32,
-    ) -> DescriptorSetVariableDescriptorCountLayoutSupportBuilder<'a> {
+    pub fn max_variable_descriptor_count(mut self, max_variable_descriptor_count: u32) -> Self {
         self.inner.max_variable_descriptor_count = max_variable_descriptor_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DescriptorSetVariableDescriptorCountLayoutSupport {
         self.inner
@@ -29323,70 +26846,58 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentDescription2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentDescription2Builder<'a> {
-    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> AttachmentDescription2Builder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn format(mut self, format: Format) -> AttachmentDescription2Builder<'a> {
+    pub fn flags(mut self, flags: AttachmentDescriptionFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn samples(mut self, samples: SampleCountFlags) -> AttachmentDescription2Builder<'a> {
+    pub fn samples(mut self, samples: SampleCountFlags) -> Self {
         self.inner.samples = samples;
         self
     }
-    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> AttachmentDescription2Builder<'a> {
+    pub fn load_op(mut self, load_op: AttachmentLoadOp) -> Self {
         self.inner.load_op = load_op;
         self
     }
-    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> AttachmentDescription2Builder<'a> {
+    pub fn store_op(mut self, store_op: AttachmentStoreOp) -> Self {
         self.inner.store_op = store_op;
         self
     }
-    pub fn stencil_load_op(
-        mut self,
-        stencil_load_op: AttachmentLoadOp,
-    ) -> AttachmentDescription2Builder<'a> {
+    pub fn stencil_load_op(mut self, stencil_load_op: AttachmentLoadOp) -> Self {
         self.inner.stencil_load_op = stencil_load_op;
         self
     }
-    pub fn stencil_store_op(
-        mut self,
-        stencil_store_op: AttachmentStoreOp,
-    ) -> AttachmentDescription2Builder<'a> {
+    pub fn stencil_store_op(mut self, stencil_store_op: AttachmentStoreOp) -> Self {
         self.inner.stencil_store_op = stencil_store_op;
         self
     }
-    pub fn initial_layout(
-        mut self,
-        initial_layout: ImageLayout,
-    ) -> AttachmentDescription2Builder<'a> {
+    pub fn initial_layout(mut self, initial_layout: ImageLayout) -> Self {
         self.inner.initial_layout = initial_layout;
         self
     }
-    pub fn final_layout(mut self, final_layout: ImageLayout) -> AttachmentDescription2Builder<'a> {
+    pub fn final_layout(mut self, final_layout: ImageLayout) -> Self {
         self.inner.final_layout = final_layout;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAttachmentDescription2>(
-        mut self,
-        next: &'a mut T,
-    ) -> AttachmentDescription2Builder<'a> {
+    pub fn push_next<T: ExtendsAttachmentDescription2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -29439,37 +26950,34 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentReference2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentReference2Builder<'a> {
-    pub fn attachment(mut self, attachment: u32) -> AttachmentReference2Builder<'a> {
+    pub fn attachment(mut self, attachment: u32) -> Self {
         self.inner.attachment = attachment;
         self
     }
-    pub fn layout(mut self, layout: ImageLayout) -> AttachmentReference2Builder<'a> {
+    pub fn layout(mut self, layout: ImageLayout) -> Self {
         self.inner.layout = layout;
         self
     }
-    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> AttachmentReference2Builder<'a> {
+    pub fn aspect_mask(mut self, aspect_mask: ImageAspectFlags) -> Self {
         self.inner.aspect_mask = aspect_mask;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAttachmentReference2>(
-        mut self,
-        next: &'a mut T,
-    ) -> AttachmentReference2Builder<'a> {
+    pub fn push_next<T: ExtendsAttachmentReference2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -29538,79 +27046,61 @@ impl<'a> ::std::ops::Deref for SubpassDe
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassDescription2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassDescription2Builder<'a> {
-    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> SubpassDescription2Builder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn pipeline_bind_point(
-        mut self,
-        pipeline_bind_point: PipelineBindPoint,
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn flags(mut self, flags: SubpassDescriptionFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn pipeline_bind_point(mut self, pipeline_bind_point: PipelineBindPoint) -> Self {
         self.inner.pipeline_bind_point = pipeline_bind_point;
         self
     }
-    pub fn view_mask(mut self, view_mask: u32) -> SubpassDescription2Builder<'a> {
+    pub fn view_mask(mut self, view_mask: u32) -> Self {
         self.inner.view_mask = view_mask;
         self
     }
-    pub fn input_attachments(
-        mut self,
-        input_attachments: &'a [AttachmentReference2],
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn input_attachments(mut self, input_attachments: &'a [AttachmentReference2]) -> Self {
         self.inner.input_attachment_count = input_attachments.len() as _;
         self.inner.p_input_attachments = input_attachments.as_ptr();
         self
     }
-    pub fn color_attachments(
-        mut self,
-        color_attachments: &'a [AttachmentReference2],
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn color_attachments(mut self, color_attachments: &'a [AttachmentReference2]) -> Self {
         self.inner.color_attachment_count = color_attachments.len() as _;
         self.inner.p_color_attachments = color_attachments.as_ptr();
         self
     }
-    pub fn resolve_attachments(
-        mut self,
-        resolve_attachments: &'a [AttachmentReference2],
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn resolve_attachments(mut self, resolve_attachments: &'a [AttachmentReference2]) -> Self {
         self.inner.color_attachment_count = resolve_attachments.len() as _;
         self.inner.p_resolve_attachments = resolve_attachments.as_ptr();
         self
     }
     pub fn depth_stencil_attachment(
         mut self,
         depth_stencil_attachment: &'a AttachmentReference2,
-    ) -> SubpassDescription2Builder<'a> {
+    ) -> Self {
         self.inner.p_depth_stencil_attachment = depth_stencil_attachment;
         self
     }
-    pub fn preserve_attachments(
-        mut self,
-        preserve_attachments: &'a [u32],
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn preserve_attachments(mut self, preserve_attachments: &'a [u32]) -> Self {
         self.inner.preserve_attachment_count = preserve_attachments.len() as _;
         self.inner.p_preserve_attachments = preserve_attachments.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSubpassDescription2>(
-        mut self,
-        next: &'a mut T,
-    ) -> SubpassDescription2Builder<'a> {
+    pub fn push_next<T: ExtendsSubpassDescription2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -29673,72 +27163,54 @@ impl<'a> ::std::ops::Deref for SubpassDe
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassDependency2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassDependency2Builder<'a> {
-    pub fn src_subpass(mut self, src_subpass: u32) -> SubpassDependency2Builder<'a> {
+    pub fn src_subpass(mut self, src_subpass: u32) -> Self {
         self.inner.src_subpass = src_subpass;
         self
     }
-    pub fn dst_subpass(mut self, dst_subpass: u32) -> SubpassDependency2Builder<'a> {
+    pub fn dst_subpass(mut self, dst_subpass: u32) -> Self {
         self.inner.dst_subpass = dst_subpass;
         self
     }
-    pub fn src_stage_mask(
-        mut self,
-        src_stage_mask: PipelineStageFlags,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags) -> Self {
         self.inner.src_stage_mask = src_stage_mask;
         self
     }
-    pub fn dst_stage_mask(
-        mut self,
-        dst_stage_mask: PipelineStageFlags,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags) -> Self {
         self.inner.dst_stage_mask = dst_stage_mask;
         self
     }
-    pub fn src_access_mask(
-        mut self,
-        src_access_mask: AccessFlags,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags) -> Self {
         self.inner.src_access_mask = src_access_mask;
         self
     }
-    pub fn dst_access_mask(
-        mut self,
-        dst_access_mask: AccessFlags,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags) -> Self {
         self.inner.dst_access_mask = dst_access_mask;
         self
     }
-    pub fn dependency_flags(
-        mut self,
-        dependency_flags: DependencyFlags,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
         self.inner.dependency_flags = dependency_flags;
         self
     }
-    pub fn view_offset(mut self, view_offset: i32) -> SubpassDependency2Builder<'a> {
+    pub fn view_offset(mut self, view_offset: i32) -> Self {
         self.inner.view_offset = view_offset;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSubpassDependency2>(
-        mut self,
-        next: &'a mut T,
-    ) -> SubpassDependency2Builder<'a> {
+    pub fn push_next<T: ExtendsSubpassDependency2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -29803,61 +27275,46 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassCreateInfo2Builder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassCreateInfo2Builder<'a> {
-    pub fn flags(mut self, flags: RenderPassCreateFlags) -> RenderPassCreateInfo2Builder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn attachments(
-        mut self,
-        attachments: &'a [AttachmentDescription2],
-    ) -> RenderPassCreateInfo2Builder<'a> {
+    pub fn flags(mut self, flags: RenderPassCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn attachments(mut self, attachments: &'a [AttachmentDescription2]) -> Self {
         self.inner.attachment_count = attachments.len() as _;
         self.inner.p_attachments = attachments.as_ptr();
         self
     }
-    pub fn subpasses(
-        mut self,
-        subpasses: &'a [SubpassDescription2],
-    ) -> RenderPassCreateInfo2Builder<'a> {
+    pub fn subpasses(mut self, subpasses: &'a [SubpassDescription2]) -> Self {
         self.inner.subpass_count = subpasses.len() as _;
         self.inner.p_subpasses = subpasses.as_ptr();
         self
     }
-    pub fn dependencies(
-        mut self,
-        dependencies: &'a [SubpassDependency2],
-    ) -> RenderPassCreateInfo2Builder<'a> {
+    pub fn dependencies(mut self, dependencies: &'a [SubpassDependency2]) -> Self {
         self.inner.dependency_count = dependencies.len() as _;
         self.inner.p_dependencies = dependencies.as_ptr();
         self
     }
-    pub fn correlated_view_masks(
-        mut self,
-        correlated_view_masks: &'a [u32],
-    ) -> RenderPassCreateInfo2Builder<'a> {
+    pub fn correlated_view_masks(mut self, correlated_view_masks: &'a [u32]) -> Self {
         self.inner.correlated_view_mask_count = correlated_view_masks.len() as _;
         self.inner.p_correlated_view_masks = correlated_view_masks.as_ptr();
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRenderPassCreateInfo2>(
-        mut self,
-        next: &'a mut T,
-    ) -> RenderPassCreateInfo2Builder<'a> {
+    pub fn push_next<T: ExtendsRenderPassCreateInfo2>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -29893,50 +27350,32 @@ impl SubpassBeginInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct SubpassBeginInfoBuilder<'a> {
     inner: SubpassBeginInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSubpassBeginInfo {}
 impl<'a> ::std::ops::Deref for SubpassBeginInfoBuilder<'a> {
     type Target = SubpassBeginInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassBeginInfoBuilder<'a> {
-    pub fn contents(mut self, contents: SubpassContents) -> SubpassBeginInfoBuilder<'a> {
+    pub fn contents(mut self, contents: SubpassContents) -> Self {
         self.inner.contents = contents;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSubpassBeginInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SubpassBeginInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassBeginInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -29962,46 +27401,28 @@ impl SubpassEndInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct SubpassEndInfoBuilder<'a> {
     inner: SubpassEndInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSubpassEndInfo {}
 impl<'a> ::std::ops::Deref for SubpassEndInfoBuilder<'a> {
     type Target = SubpassEndInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassEndInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassEndInfoBuilder<'a> {
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSubpassEndInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SubpassEndInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassEndInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -30029,34 +27450,33 @@ impl PhysicalDeviceTimelineSemaphoreFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
     inner: PhysicalDeviceTimelineSemaphoreFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTimelineSemaphoreFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTimelineSemaphoreFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
     type Target = PhysicalDeviceTimelineSemaphoreFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
-    pub fn timeline_semaphore(
-        mut self,
-        timeline_semaphore: bool,
-    ) -> PhysicalDeviceTimelineSemaphoreFeaturesBuilder<'a> {
+    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
         self.inner.timeline_semaphore = timeline_semaphore.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTimelineSemaphoreFeatures {
         self.inner
@@ -30107,17 +27527,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
     pub fn max_timeline_semaphore_value_difference(
         mut self,
         max_timeline_semaphore_value_difference: u64,
-    ) -> PhysicalDeviceTimelineSemaphorePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_timeline_semaphore_value_difference =
             max_timeline_semaphore_value_difference;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTimelineSemaphoreProperties {
@@ -30167,24 +27587,21 @@ impl<'a> ::std::ops::Deref for Semaphore
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreTypeCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreTypeCreateInfoBuilder<'a> {
-    pub fn semaphore_type(
-        mut self,
-        semaphore_type: SemaphoreType,
-    ) -> SemaphoreTypeCreateInfoBuilder<'a> {
+    pub fn semaphore_type(mut self, semaphore_type: SemaphoreType) -> Self {
         self.inner.semaphore_type = semaphore_type;
         self
     }
-    pub fn initial_value(mut self, initial_value: u64) -> SemaphoreTypeCreateInfoBuilder<'a> {
+    pub fn initial_value(mut self, initial_value: u64) -> Self {
         self.inner.initial_value = initial_value;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SemaphoreTypeCreateInfo {
         self.inner
@@ -30237,28 +27654,22 @@ impl<'a> ::std::ops::Deref for TimelineS
     }
 }
 impl<'a> ::std::ops::DerefMut for TimelineSemaphoreSubmitInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> TimelineSemaphoreSubmitInfoBuilder<'a> {
-    pub fn wait_semaphore_values(
-        mut self,
-        wait_semaphore_values: &'a [u64],
-    ) -> TimelineSemaphoreSubmitInfoBuilder<'a> {
+    pub fn wait_semaphore_values(mut self, wait_semaphore_values: &'a [u64]) -> Self {
         self.inner.wait_semaphore_value_count = wait_semaphore_values.len() as _;
         self.inner.p_wait_semaphore_values = wait_semaphore_values.as_ptr();
         self
     }
-    pub fn signal_semaphore_values(
-        mut self,
-        signal_semaphore_values: &'a [u64],
-    ) -> TimelineSemaphoreSubmitInfoBuilder<'a> {
+    pub fn signal_semaphore_values(mut self, signal_semaphore_values: &'a [u64]) -> Self {
         self.inner.signal_semaphore_value_count = signal_semaphore_values.len() as _;
         self.inner.p_signal_semaphore_values = signal_semaphore_values.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> TimelineSemaphoreSubmitInfo {
@@ -30296,60 +27707,42 @@ impl SemaphoreWaitInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct SemaphoreWaitInfoBuilder<'a> {
     inner: SemaphoreWaitInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSemaphoreWaitInfo {}
 impl<'a> ::std::ops::Deref for SemaphoreWaitInfoBuilder<'a> {
     type Target = SemaphoreWaitInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreWaitInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreWaitInfoBuilder<'a> {
-    pub fn flags(mut self, flags: SemaphoreWaitFlags) -> SemaphoreWaitInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn semaphores(mut self, semaphores: &'a [Semaphore]) -> SemaphoreWaitInfoBuilder<'a> {
+    pub fn flags(mut self, flags: SemaphoreWaitFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn semaphores(mut self, semaphores: &'a [Semaphore]) -> Self {
         self.inner.semaphore_count = semaphores.len() as _;
         self.inner.p_semaphores = semaphores.as_ptr();
         self
     }
-    pub fn values(mut self, values: &'a [u64]) -> SemaphoreWaitInfoBuilder<'a> {
+    pub fn values(mut self, values: &'a [u64]) -> Self {
         self.inner.semaphore_count = values.len() as _;
         self.inner.p_values = values.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSemaphoreWaitInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SemaphoreWaitInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SemaphoreWaitInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -30379,54 +27772,36 @@ impl SemaphoreSignalInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct SemaphoreSignalInfoBuilder<'a> {
     inner: SemaphoreSignalInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsSemaphoreSignalInfo {}
 impl<'a> ::std::ops::Deref for SemaphoreSignalInfoBuilder<'a> {
     type Target = SemaphoreSignalInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for SemaphoreSignalInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SemaphoreSignalInfoBuilder<'a> {
-    pub fn semaphore(mut self, semaphore: Semaphore) -> SemaphoreSignalInfoBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
         self.inner.semaphore = semaphore;
         self
     }
-    pub fn value(mut self, value: u64) -> SemaphoreSignalInfoBuilder<'a> {
+    pub fn value(mut self, value: u64) -> Self {
         self.inner.value = value;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsSemaphoreSignalInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> SemaphoreSignalInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SemaphoreSignalInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -30456,21 +27831,21 @@ impl<'a> ::std::ops::Deref for VertexInp
     }
 }
 impl<'a> ::std::ops::DerefMut for VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
-    pub fn binding(mut self, binding: u32) -> VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
+    pub fn binding(mut self, binding: u32) -> Self {
         self.inner.binding = binding;
         self
     }
-    pub fn divisor(mut self, divisor: u32) -> VertexInputBindingDivisorDescriptionEXTBuilder<'a> {
+    pub fn divisor(mut self, divisor: u32) -> Self {
         self.inner.divisor = divisor;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> VertexInputBindingDivisorDescriptionEXT {
         self.inner
@@ -30526,17 +27901,17 @@ impl<'a> ::std::ops::DerefMut for Pipeli
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
     pub fn vertex_binding_divisors(
         mut self,
         vertex_binding_divisors: &'a [VertexInputBindingDivisorDescriptionEXT],
-    ) -> PipelineVertexInputDivisorStateCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_binding_divisor_count = vertex_binding_divisors.len() as _;
         self.inner.p_vertex_binding_divisors = vertex_binding_divisors.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineVertexInputDivisorStateCreateInfoEXT {
@@ -30585,20 +27960,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
-    pub fn max_vertex_attrib_divisor(
-        mut self,
-        max_vertex_attrib_divisor: u32,
-    ) -> PhysicalDeviceVertexAttributeDivisorPropertiesEXTBuilder<'a> {
+    pub fn max_vertex_attrib_divisor(mut self, max_vertex_attrib_divisor: u32) -> Self {
         self.inner.max_vertex_attrib_divisor = max_vertex_attrib_divisor;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
         self.inner
@@ -30649,38 +28021,29 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
-    pub fn pci_domain(
-        mut self,
-        pci_domain: u32,
-    ) -> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
+    pub fn pci_domain(mut self, pci_domain: u32) -> Self {
         self.inner.pci_domain = pci_domain;
         self
     }
-    pub fn pci_bus(mut self, pci_bus: u32) -> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
+    pub fn pci_bus(mut self, pci_bus: u32) -> Self {
         self.inner.pci_bus = pci_bus;
         self
     }
-    pub fn pci_device(
-        mut self,
-        pci_device: u32,
-    ) -> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
+    pub fn pci_device(mut self, pci_device: u32) -> Self {
         self.inner.pci_device = pci_device;
         self
     }
-    pub fn pci_function(
-        mut self,
-        pci_function: u32,
-    ) -> PhysicalDevicePCIBusInfoPropertiesEXTBuilder<'a> {
+    pub fn pci_function(mut self, pci_function: u32) -> Self {
         self.inner.pci_function = pci_function;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePCIBusInfoPropertiesEXT {
         self.inner
@@ -30725,20 +28088,17 @@ impl<'a> ::std::ops::Deref for ImportAnd
     }
 }
 impl<'a> ::std::ops::DerefMut for ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
-    pub fn buffer(
-        mut self,
-        buffer: *mut AHardwareBuffer,
-    ) -> ImportAndroidHardwareBufferInfoANDROIDBuilder<'a> {
+    pub fn buffer(mut self, buffer: *mut AHardwareBuffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImportAndroidHardwareBufferInfoANDROID {
         self.inner
@@ -30783,20 +28143,17 @@ impl<'a> ::std::ops::Deref for AndroidHa
     }
 }
 impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferUsageANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AndroidHardwareBufferUsageANDROIDBuilder<'a> {
-    pub fn android_hardware_buffer_usage(
-        mut self,
-        android_hardware_buffer_usage: u64,
-    ) -> AndroidHardwareBufferUsageANDROIDBuilder<'a> {
+    pub fn android_hardware_buffer_usage(mut self, android_hardware_buffer_usage: u64) -> Self {
         self.inner.android_hardware_buffer_usage = android_hardware_buffer_usage;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AndroidHardwareBufferUsageANDROID {
         self.inner
@@ -30842,39 +28199,33 @@ impl<'a> ::std::ops::Deref for AndroidHa
     }
 }
 impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
-    pub fn allocation_size(
-        mut self,
-        allocation_size: DeviceSize,
-    ) -> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
+    pub fn allocation_size(mut self, allocation_size: DeviceSize) -> Self {
         self.inner.allocation_size = allocation_size;
         self
     }
-    pub fn memory_type_bits(
-        mut self,
-        memory_type_bits: u32,
-    ) -> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
+    pub fn memory_type_bits(mut self, memory_type_bits: u32) -> Self {
         self.inner.memory_type_bits = memory_type_bits;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsAndroidHardwareBufferPropertiesANDROID>(
         mut self,
         next: &'a mut T,
-    ) -> AndroidHardwareBufferPropertiesANDROIDBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -30910,53 +28261,32 @@ impl MemoryGetAndroidHardwareBufferInfoA
         }
     }
 }
 #[repr(transparent)]
 pub struct MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
     inner: MemoryGetAndroidHardwareBufferInfoANDROID,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsMemoryGetAndroidHardwareBufferInfoANDROID {}
 impl<'a> ::std::ops::Deref for MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
     type Target = MemoryGetAndroidHardwareBufferInfoANDROID;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
-    pub fn memory(
-        mut self,
-        memory: DeviceMemory,
-    ) -> MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsMemoryGetAndroidHardwareBufferInfoANDROID>(
-        mut self,
-        next: &'a mut T,
-    ) -> MemoryGetAndroidHardwareBufferInfoANDROIDBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryGetAndroidHardwareBufferInfoANDROID {
         self.inner
     }
 }
 #[repr(C)]
@@ -31018,69 +28348,51 @@ impl<'a> ::std::ops::Deref for AndroidHa
     }
 }
 impl<'a> ::std::ops::DerefMut for AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
-    pub fn format(
-        mut self,
-        format: Format,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn external_format(
-        mut self,
-        external_format: u64,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn external_format(mut self, external_format: u64) -> Self {
         self.inner.external_format = external_format;
         self
     }
-    pub fn format_features(
-        mut self,
-        format_features: FormatFeatureFlags,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn format_features(mut self, format_features: FormatFeatureFlags) -> Self {
         self.inner.format_features = format_features;
         self
     }
     pub fn sampler_ycbcr_conversion_components(
         mut self,
         sampler_ycbcr_conversion_components: ComponentMapping,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    ) -> Self {
         self.inner.sampler_ycbcr_conversion_components = sampler_ycbcr_conversion_components;
         self
     }
     pub fn suggested_ycbcr_model(
         mut self,
         suggested_ycbcr_model: SamplerYcbcrModelConversion,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    ) -> Self {
         self.inner.suggested_ycbcr_model = suggested_ycbcr_model;
         self
     }
-    pub fn suggested_ycbcr_range(
-        mut self,
-        suggested_ycbcr_range: SamplerYcbcrRange,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn suggested_ycbcr_range(mut self, suggested_ycbcr_range: SamplerYcbcrRange) -> Self {
         self.inner.suggested_ycbcr_range = suggested_ycbcr_range;
         self
     }
-    pub fn suggested_x_chroma_offset(
-        mut self,
-        suggested_x_chroma_offset: ChromaLocation,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn suggested_x_chroma_offset(mut self, suggested_x_chroma_offset: ChromaLocation) -> Self {
         self.inner.suggested_x_chroma_offset = suggested_x_chroma_offset;
         self
     }
-    pub fn suggested_y_chroma_offset(
-        mut self,
-        suggested_y_chroma_offset: ChromaLocation,
-    ) -> AndroidHardwareBufferFormatPropertiesANDROIDBuilder<'a> {
+    pub fn suggested_y_chroma_offset(mut self, suggested_y_chroma_offset: ChromaLocation) -> Self {
         self.inner.suggested_y_chroma_offset = suggested_y_chroma_offset;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AndroidHardwareBufferFormatPropertiesANDROID {
         self.inner
@@ -31131,20 +28443,17 @@ impl<'a> ::std::ops::Deref for CommandBu
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
-    pub fn conditional_rendering_enable(
-        mut self,
-        conditional_rendering_enable: bool,
-    ) -> CommandBufferInheritanceConditionalRenderingInfoEXTBuilder<'a> {
+    pub fn conditional_rendering_enable(mut self, conditional_rendering_enable: bool) -> Self {
         self.inner.conditional_rendering_enable = conditional_rendering_enable.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CommandBufferInheritanceConditionalRenderingInfoEXT {
         self.inner
@@ -31191,17 +28500,17 @@ impl<'a> ::std::ops::Deref for ExternalF
     }
 }
 impl<'a> ::std::ops::DerefMut for ExternalFormatANDROIDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ExternalFormatANDROIDBuilder<'a> {
-    pub fn external_format(mut self, external_format: u64) -> ExternalFormatANDROIDBuilder<'a> {
+    pub fn external_format(mut self, external_format: u64) -> Self {
         self.inner.external_format = external_format;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ExternalFormatANDROID {
         self.inner
@@ -31236,49 +28545,45 @@ impl PhysicalDevice8BitStorageFeatures {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevice8BitStorageFeaturesBuilder<'a> {
     inner: PhysicalDevice8BitStorageFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice8BitStorageFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice8BitStorageFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice8BitStorageFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice8BitStorageFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDevice8BitStorageFeaturesBuilder<'a> {
     type Target = PhysicalDevice8BitStorageFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevice8BitStorageFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
-    pub fn storage_buffer8_bit_access(
-        mut self,
-        storage_buffer8_bit_access: bool,
-    ) -> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
+    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
         self.inner.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
         self
     }
     pub fn uniform_and_storage_buffer8_bit_access(
         mut self,
         uniform_and_storage_buffer8_bit_access: bool,
-    ) -> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.uniform_and_storage_buffer8_bit_access =
             uniform_and_storage_buffer8_bit_access.into();
         self
     }
-    pub fn storage_push_constant8(
-        mut self,
-        storage_push_constant8: bool,
-    ) -> PhysicalDevice8BitStorageFeaturesBuilder<'a> {
+    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
         self.inner.storage_push_constant8 = storage_push_constant8.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevice8BitStorageFeatures {
         self.inner
@@ -31311,41 +28616,43 @@ impl PhysicalDeviceConditionalRenderingF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceConditionalRenderingFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceConditionalRenderingFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceConditionalRenderingFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceConditionalRenderingFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
-    pub fn conditional_rendering(
-        mut self,
-        conditional_rendering: bool,
-    ) -> PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
+    pub fn conditional_rendering(mut self, conditional_rendering: bool) -> Self {
         self.inner.conditional_rendering = conditional_rendering.into();
         self
     }
     pub fn inherited_conditional_rendering(
         mut self,
         inherited_conditional_rendering: bool,
-    ) -> PhysicalDeviceConditionalRenderingFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.inherited_conditional_rendering = inherited_conditional_rendering.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceConditionalRenderingFeaturesEXT {
         self.inner
@@ -31380,48 +28687,47 @@ impl PhysicalDeviceVulkanMemoryModelFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
     inner: PhysicalDeviceVulkanMemoryModelFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkanMemoryModelFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkanMemoryModelFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
     type Target = PhysicalDeviceVulkanMemoryModelFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
-    pub fn vulkan_memory_model(
-        mut self,
-        vulkan_memory_model: bool,
-    ) -> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
+    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
         self.inner.vulkan_memory_model = vulkan_memory_model.into();
         self
     }
     pub fn vulkan_memory_model_device_scope(
         mut self,
         vulkan_memory_model_device_scope: bool,
-    ) -> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
         self
     }
     pub fn vulkan_memory_model_availability_visibility_chains(
         mut self,
         vulkan_memory_model_availability_visibility_chains: bool,
-    ) -> PhysicalDeviceVulkanMemoryModelFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .vulkan_memory_model_availability_visibility_chains =
             vulkan_memory_model_availability_visibility_chains.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -31456,41 +28762,37 @@ impl PhysicalDeviceShaderAtomicInt64Feat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
     inner: PhysicalDeviceShaderAtomicInt64Features,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicInt64Features {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicInt64Features {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
     type Target = PhysicalDeviceShaderAtomicInt64Features;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
-    pub fn shader_buffer_int64_atomics(
-        mut self,
-        shader_buffer_int64_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
+    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
         self.inner.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
         self
     }
-    pub fn shader_shared_int64_atomics(
-        mut self,
-        shader_shared_int64_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicInt64FeaturesBuilder<'a> {
+    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
         self.inner.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderAtomicInt64Features {
         self.inner
@@ -31543,123 +28845,272 @@ impl PhysicalDeviceShaderAtomicFloatFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceShaderAtomicFloatFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloatFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceShaderAtomicFloatFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
-    pub fn shader_buffer_float32_atomics(
-        mut self,
-        shader_buffer_float32_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn shader_buffer_float32_atomics(mut self, shader_buffer_float32_atomics: bool) -> Self {
         self.inner.shader_buffer_float32_atomics = shader_buffer_float32_atomics.into();
         self
     }
     pub fn shader_buffer_float32_atomic_add(
         mut self,
         shader_buffer_float32_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_buffer_float32_atomic_add = shader_buffer_float32_atomic_add.into();
         self
     }
-    pub fn shader_buffer_float64_atomics(
-        mut self,
-        shader_buffer_float64_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn shader_buffer_float64_atomics(mut self, shader_buffer_float64_atomics: bool) -> Self {
         self.inner.shader_buffer_float64_atomics = shader_buffer_float64_atomics.into();
         self
     }
     pub fn shader_buffer_float64_atomic_add(
         mut self,
         shader_buffer_float64_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_buffer_float64_atomic_add = shader_buffer_float64_atomic_add.into();
         self
     }
-    pub fn shader_shared_float32_atomics(
-        mut self,
-        shader_shared_float32_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn shader_shared_float32_atomics(mut self, shader_shared_float32_atomics: bool) -> Self {
         self.inner.shader_shared_float32_atomics = shader_shared_float32_atomics.into();
         self
     }
     pub fn shader_shared_float32_atomic_add(
         mut self,
         shader_shared_float32_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_shared_float32_atomic_add = shader_shared_float32_atomic_add.into();
         self
     }
-    pub fn shader_shared_float64_atomics(
-        mut self,
-        shader_shared_float64_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn shader_shared_float64_atomics(mut self, shader_shared_float64_atomics: bool) -> Self {
         self.inner.shader_shared_float64_atomics = shader_shared_float64_atomics.into();
         self
     }
     pub fn shader_shared_float64_atomic_add(
         mut self,
         shader_shared_float64_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_shared_float64_atomic_add = shader_shared_float64_atomic_add.into();
         self
     }
-    pub fn shader_image_float32_atomics(
-        mut self,
-        shader_image_float32_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn shader_image_float32_atomics(mut self, shader_image_float32_atomics: bool) -> Self {
         self.inner.shader_image_float32_atomics = shader_image_float32_atomics.into();
         self
     }
     pub fn shader_image_float32_atomic_add(
         mut self,
         shader_image_float32_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_image_float32_atomic_add = shader_image_float32_atomic_add.into();
         self
     }
-    pub fn sparse_image_float32_atomics(
-        mut self,
-        sparse_image_float32_atomics: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    pub fn sparse_image_float32_atomics(mut self, sparse_image_float32_atomics: bool) -> Self {
         self.inner.sparse_image_float32_atomics = sparse_image_float32_atomics.into();
         self
     }
     pub fn sparse_image_float32_atomic_add(
         mut self,
         sparse_image_float32_atomic_add: bool,
-    ) -> PhysicalDeviceShaderAtomicFloatFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.sparse_image_float32_atomic_add = sparse_image_float32_atomic_add.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderAtomicFloatFeaturesEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html>"]
+pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub shader_buffer_float16_atomics: Bool32,
+    pub shader_buffer_float16_atomic_add: Bool32,
+    pub shader_buffer_float16_atomic_min_max: Bool32,
+    pub shader_buffer_float32_atomic_min_max: Bool32,
+    pub shader_buffer_float64_atomic_min_max: Bool32,
+    pub shader_shared_float16_atomics: Bool32,
+    pub shader_shared_float16_atomic_add: Bool32,
+    pub shader_shared_float16_atomic_min_max: Bool32,
+    pub shader_shared_float32_atomic_min_max: Bool32,
+    pub shader_shared_float64_atomic_min_max: Bool32,
+    pub shader_image_float32_atomic_min_max: Bool32,
+    pub sparse_image_float32_atomic_min_max: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+    fn default() -> PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+        PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            shader_buffer_float16_atomics: Bool32::default(),
+            shader_buffer_float16_atomic_add: Bool32::default(),
+            shader_buffer_float16_atomic_min_max: Bool32::default(),
+            shader_buffer_float32_atomic_min_max: Bool32::default(),
+            shader_buffer_float64_atomic_min_max: Bool32::default(),
+            shader_shared_float16_atomics: Bool32::default(),
+            shader_shared_float16_atomic_add: Bool32::default(),
+            shader_shared_float16_atomic_min_max: Bool32::default(),
+            shader_shared_float32_atomic_min_max: Bool32::default(),
+            shader_shared_float64_atomic_min_max: Bool32::default(),
+            shader_image_float32_atomic_min_max: Bool32::default(),
+            sparse_image_float32_atomic_min_max: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
+        PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder {
+            inner: PhysicalDeviceShaderAtomicFloat2FeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceShaderAtomicFloat2FeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderAtomicFloat2FeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceShaderAtomicFloat2FeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceShaderAtomicFloat2FeaturesEXTBuilder<'a> {
+    pub fn shader_buffer_float16_atomics(mut self, shader_buffer_float16_atomics: bool) -> Self {
+        self.inner.shader_buffer_float16_atomics = shader_buffer_float16_atomics.into();
+        self
+    }
+    pub fn shader_buffer_float16_atomic_add(
+        mut self,
+        shader_buffer_float16_atomic_add: bool,
+    ) -> Self {
+        self.inner.shader_buffer_float16_atomic_add = shader_buffer_float16_atomic_add.into();
+        self
+    }
+    pub fn shader_buffer_float16_atomic_min_max(
+        mut self,
+        shader_buffer_float16_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_buffer_float16_atomic_min_max =
+            shader_buffer_float16_atomic_min_max.into();
+        self
+    }
+    pub fn shader_buffer_float32_atomic_min_max(
+        mut self,
+        shader_buffer_float32_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_buffer_float32_atomic_min_max =
+            shader_buffer_float32_atomic_min_max.into();
+        self
+    }
+    pub fn shader_buffer_float64_atomic_min_max(
+        mut self,
+        shader_buffer_float64_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_buffer_float64_atomic_min_max =
+            shader_buffer_float64_atomic_min_max.into();
+        self
+    }
+    pub fn shader_shared_float16_atomics(mut self, shader_shared_float16_atomics: bool) -> Self {
+        self.inner.shader_shared_float16_atomics = shader_shared_float16_atomics.into();
+        self
+    }
+    pub fn shader_shared_float16_atomic_add(
+        mut self,
+        shader_shared_float16_atomic_add: bool,
+    ) -> Self {
+        self.inner.shader_shared_float16_atomic_add = shader_shared_float16_atomic_add.into();
+        self
+    }
+    pub fn shader_shared_float16_atomic_min_max(
+        mut self,
+        shader_shared_float16_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_shared_float16_atomic_min_max =
+            shader_shared_float16_atomic_min_max.into();
+        self
+    }
+    pub fn shader_shared_float32_atomic_min_max(
+        mut self,
+        shader_shared_float32_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_shared_float32_atomic_min_max =
+            shader_shared_float32_atomic_min_max.into();
+        self
+    }
+    pub fn shader_shared_float64_atomic_min_max(
+        mut self,
+        shader_shared_float64_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_shared_float64_atomic_min_max =
+            shader_shared_float64_atomic_min_max.into();
+        self
+    }
+    pub fn shader_image_float32_atomic_min_max(
+        mut self,
+        shader_image_float32_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.shader_image_float32_atomic_min_max = shader_image_float32_atomic_min_max.into();
+        self
+    }
+    pub fn sparse_image_float32_atomic_min_max(
+        mut self,
+        sparse_image_float32_atomic_min_max: bool,
+    ) -> Self {
+        self.inner.sparse_image_float32_atomic_min_max = sparse_image_float32_atomic_min_max.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html>"]
 pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
     pub s_type: StructureType,
     pub p_next: *mut c_void,
     pub vertex_attribute_instance_rate_divisor: Bool32,
     pub vertex_attribute_instance_rate_zero_divisor: Bool32,
 }
 impl ::std::default::Default for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
@@ -31680,16 +29131,21 @@ impl PhysicalDeviceVertexAttributeDiviso
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceVertexAttributeDivisorFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexAttributeDivisorFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceVertexAttributeDivisorFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -31697,25 +29153,25 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
     pub fn vertex_attribute_instance_rate_divisor(
         mut self,
         vertex_attribute_instance_rate_divisor: bool,
-    ) -> PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_attribute_instance_rate_divisor =
             vertex_attribute_instance_rate_divisor.into();
         self
     }
     pub fn vertex_attribute_instance_rate_zero_divisor(
         mut self,
         vertex_attribute_instance_rate_zero_divisor: bool,
-    ) -> PhysicalDeviceVertexAttributeDivisorFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_attribute_instance_rate_zero_divisor =
             vertex_attribute_instance_rate_zero_divisor.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
@@ -31764,17 +29220,17 @@ impl<'a> ::std::ops::DerefMut for QueueF
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueueFamilyCheckpointPropertiesNVBuilder<'a> {
     pub fn checkpoint_execution_stage_mask(
         mut self,
         checkpoint_execution_stage_mask: PipelineStageFlags,
-    ) -> QueueFamilyCheckpointPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> QueueFamilyCheckpointPropertiesNV {
         self.inner
@@ -31807,57 +29263,36 @@ impl CheckpointDataNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct CheckpointDataNVBuilder<'a> {
     inner: CheckpointDataNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCheckpointDataNV {}
 impl<'a> ::std::ops::Deref for CheckpointDataNVBuilder<'a> {
     type Target = CheckpointDataNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CheckpointDataNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CheckpointDataNVBuilder<'a> {
-    pub fn stage(mut self, stage: PipelineStageFlags) -> CheckpointDataNVBuilder<'a> {
+    pub fn stage(mut self, stage: PipelineStageFlags) -> Self {
         self.inner.stage = stage;
         self
     }
-    pub fn checkpoint_marker(
-        mut self,
-        checkpoint_marker: *mut c_void,
-    ) -> CheckpointDataNVBuilder<'a> {
+    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
         self.inner.p_checkpoint_marker = checkpoint_marker;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCheckpointDataNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> CheckpointDataNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CheckpointDataNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -31911,38 +29346,32 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
     pub fn supported_depth_resolve_modes(
         mut self,
         supported_depth_resolve_modes: ResolveModeFlags,
-    ) -> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.supported_depth_resolve_modes = supported_depth_resolve_modes;
         self
     }
     pub fn supported_stencil_resolve_modes(
         mut self,
         supported_stencil_resolve_modes: ResolveModeFlags,
-    ) -> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
         self
     }
-    pub fn independent_resolve_none(
-        mut self,
-        independent_resolve_none: bool,
-    ) -> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
+    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
         self.inner.independent_resolve_none = independent_resolve_none.into();
         self
     }
-    pub fn independent_resolve(
-        mut self,
-        independent_resolve: bool,
-    ) -> PhysicalDeviceDepthStencilResolvePropertiesBuilder<'a> {
+    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
         self.inner.independent_resolve = independent_resolve.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDepthStencilResolveProperties {
         self.inner
@@ -31991,34 +29420,28 @@ impl<'a> ::std::ops::Deref for SubpassDe
     }
 }
 impl<'a> ::std::ops::DerefMut for SubpassDescriptionDepthStencilResolveBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SubpassDescriptionDepthStencilResolveBuilder<'a> {
-    pub fn depth_resolve_mode(
-        mut self,
-        depth_resolve_mode: ResolveModeFlags,
-    ) -> SubpassDescriptionDepthStencilResolveBuilder<'a> {
+    pub fn depth_resolve_mode(mut self, depth_resolve_mode: ResolveModeFlags) -> Self {
         self.inner.depth_resolve_mode = depth_resolve_mode;
         self
     }
-    pub fn stencil_resolve_mode(
-        mut self,
-        stencil_resolve_mode: ResolveModeFlags,
-    ) -> SubpassDescriptionDepthStencilResolveBuilder<'a> {
+    pub fn stencil_resolve_mode(mut self, stencil_resolve_mode: ResolveModeFlags) -> Self {
         self.inner.stencil_resolve_mode = stencil_resolve_mode;
         self
     }
     pub fn depth_stencil_resolve_attachment(
         mut self,
         depth_stencil_resolve_attachment: &'a AttachmentReference2,
-    ) -> SubpassDescriptionDepthStencilResolveBuilder<'a> {
+    ) -> Self {
         self.inner.p_depth_stencil_resolve_attachment = depth_stencil_resolve_attachment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SubpassDescriptionDepthStencilResolve {
         self.inner
@@ -32063,17 +29486,17 @@ impl<'a> ::std::ops::Deref for ImageView
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageViewASTCDecodeModeEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageViewASTCDecodeModeEXTBuilder<'a> {
-    pub fn decode_mode(mut self, decode_mode: Format) -> ImageViewASTCDecodeModeEXTBuilder<'a> {
+    pub fn decode_mode(mut self, decode_mode: Format) -> Self {
         self.inner.decode_mode = decode_mode;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageViewASTCDecodeModeEXT {
         self.inner
@@ -32104,34 +29527,33 @@ impl PhysicalDeviceASTCDecodeFeaturesEXT
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceASTCDecodeFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceASTCDecodeFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceASTCDecodeFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceASTCDecodeFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
-    pub fn decode_mode_shared_exponent(
-        mut self,
-        decode_mode_shared_exponent: bool,
-    ) -> PhysicalDeviceASTCDecodeFeaturesEXTBuilder<'a> {
+    pub fn decode_mode_shared_exponent(mut self, decode_mode_shared_exponent: bool) -> Self {
         self.inner.decode_mode_shared_exponent = decode_mode_shared_exponent.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceASTCDecodeFeaturesEXT {
         self.inner
@@ -32164,41 +29586,40 @@ impl PhysicalDeviceTransformFeedbackFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceTransformFeedbackFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTransformFeedbackFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTransformFeedbackFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceTransformFeedbackFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
-    pub fn transform_feedback(
-        mut self,
-        transform_feedback: bool,
-    ) -> PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
+    pub fn transform_feedback(mut self, transform_feedback: bool) -> Self {
         self.inner.transform_feedback = transform_feedback.into();
         self
     }
-    pub fn geometry_streams(
-        mut self,
-        geometry_streams: bool,
-    ) -> PhysicalDeviceTransformFeedbackFeaturesEXTBuilder<'a> {
+    pub fn geometry_streams(mut self, geometry_streams: bool) -> Self {
         self.inner.geometry_streams = geometry_streams.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTransformFeedbackFeaturesEXT {
         self.inner
@@ -32264,88 +29685,76 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
-    pub fn max_transform_feedback_streams(
-        mut self,
-        max_transform_feedback_streams: u32,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    pub fn max_transform_feedback_streams(mut self, max_transform_feedback_streams: u32) -> Self {
         self.inner.max_transform_feedback_streams = max_transform_feedback_streams;
         self
     }
-    pub fn max_transform_feedback_buffers(
-        mut self,
-        max_transform_feedback_buffers: u32,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    pub fn max_transform_feedback_buffers(mut self, max_transform_feedback_buffers: u32) -> Self {
         self.inner.max_transform_feedback_buffers = max_transform_feedback_buffers;
         self
     }
     pub fn max_transform_feedback_buffer_size(
         mut self,
         max_transform_feedback_buffer_size: DeviceSize,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_transform_feedback_buffer_size = max_transform_feedback_buffer_size;
         self
     }
     pub fn max_transform_feedback_stream_data_size(
         mut self,
         max_transform_feedback_stream_data_size: u32,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_transform_feedback_stream_data_size =
             max_transform_feedback_stream_data_size;
         self
     }
     pub fn max_transform_feedback_buffer_data_size(
         mut self,
         max_transform_feedback_buffer_data_size: u32,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_transform_feedback_buffer_data_size =
             max_transform_feedback_buffer_data_size;
         self
     }
     pub fn max_transform_feedback_buffer_data_stride(
         mut self,
         max_transform_feedback_buffer_data_stride: u32,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_transform_feedback_buffer_data_stride =
             max_transform_feedback_buffer_data_stride;
         self
     }
-    pub fn transform_feedback_queries(
-        mut self,
-        transform_feedback_queries: bool,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    pub fn transform_feedback_queries(mut self, transform_feedback_queries: bool) -> Self {
         self.inner.transform_feedback_queries = transform_feedback_queries.into();
         self
     }
     pub fn transform_feedback_streams_lines_triangles(
         mut self,
         transform_feedback_streams_lines_triangles: bool,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.transform_feedback_streams_lines_triangles =
             transform_feedback_streams_lines_triangles.into();
         self
     }
     pub fn transform_feedback_rasterization_stream_select(
         mut self,
         transform_feedback_rasterization_stream_select: bool,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.transform_feedback_rasterization_stream_select =
             transform_feedback_rasterization_stream_select.into();
         self
     }
-    pub fn transform_feedback_draw(
-        mut self,
-        transform_feedback_draw: bool,
-    ) -> PhysicalDeviceTransformFeedbackPropertiesEXTBuilder<'a> {
+    pub fn transform_feedback_draw(mut self, transform_feedback_draw: bool) -> Self {
         self.inner.transform_feedback_draw = transform_feedback_draw.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTransformFeedbackPropertiesEXT {
         self.inner
@@ -32398,27 +29807,21 @@ impl<'a> ::std::ops::Deref for PipelineR
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineRasterizationStateStreamCreateFlagsEXT,
-    ) -> PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn rasterization_stream(
-        mut self,
-        rasterization_stream: u32,
-    ) -> PipelineRasterizationStateStreamCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineRasterizationStateStreamCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn rasterization_stream(mut self, rasterization_stream: u32) -> Self {
         self.inner.rasterization_stream = rasterization_stream;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRasterizationStateStreamCreateInfoEXT {
         self.inner
@@ -32449,16 +29852,21 @@ impl PhysicalDeviceRepresentativeFragmen
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceRepresentativeFragmentTestFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRepresentativeFragmentTestFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
     fn deref(&self) -> &Self::Target {
@@ -32466,20 +29874,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
-    pub fn representative_fragment_test(
-        mut self,
-        representative_fragment_test: bool,
-    ) -> PhysicalDeviceRepresentativeFragmentTestFeaturesNVBuilder<'a> {
+    pub fn representative_fragment_test(mut self, representative_fragment_test: bool) -> Self {
         self.inner.representative_fragment_test = representative_fragment_test.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
         self.inner
@@ -32533,17 +29938,17 @@ impl<'a> ::std::ops::DerefMut for Pipeli
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
     pub fn representative_fragment_test_enable(
         mut self,
         representative_fragment_test_enable: bool,
-    ) -> PipelineRepresentativeFragmentTestStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.representative_fragment_test_enable = representative_fragment_test_enable.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRepresentativeFragmentTestStateCreateInfoNV {
         self.inner
@@ -32574,34 +29979,33 @@ impl PhysicalDeviceExclusiveScissorFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceExclusiveScissorFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExclusiveScissorFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExclusiveScissorFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceExclusiveScissorFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
-    pub fn exclusive_scissor(
-        mut self,
-        exclusive_scissor: bool,
-    ) -> PhysicalDeviceExclusiveScissorFeaturesNVBuilder<'a> {
+    pub fn exclusive_scissor(mut self, exclusive_scissor: bool) -> Self {
         self.inner.exclusive_scissor = exclusive_scissor.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExclusiveScissorFeaturesNV {
         self.inner
@@ -32654,20 +30058,17 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
-    pub fn exclusive_scissors(
-        mut self,
-        exclusive_scissors: &'a [Rect2D],
-    ) -> PipelineViewportExclusiveScissorStateCreateInfoNVBuilder<'a> {
+    pub fn exclusive_scissors(mut self, exclusive_scissors: &'a [Rect2D]) -> Self {
         self.inner.exclusive_scissor_count = exclusive_scissors.len() as _;
         self.inner.p_exclusive_scissors = exclusive_scissors.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineViewportExclusiveScissorStateCreateInfoNV {
@@ -32699,34 +30100,36 @@ impl PhysicalDeviceCornerSampledImageFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceCornerSampledImageFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCornerSampledImageFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCornerSampledImageFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceCornerSampledImageFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
-    pub fn corner_sampled_image(
-        mut self,
-        corner_sampled_image: bool,
-    ) -> PhysicalDeviceCornerSampledImageFeaturesNVBuilder<'a> {
+    pub fn corner_sampled_image(mut self, corner_sampled_image: bool) -> Self {
         self.inner.corner_sampled_image = corner_sampled_image.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCornerSampledImageFeaturesNV {
         self.inner
@@ -32759,16 +30162,21 @@ impl PhysicalDeviceComputeShaderDerivati
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceComputeShaderDerivativesFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceComputeShaderDerivativesFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceComputeShaderDerivativesFeaturesNV;
     fn deref(&self) -> &Self::Target {
@@ -32776,27 +30184,24 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
-    pub fn compute_derivative_group_quads(
-        mut self,
-        compute_derivative_group_quads: bool,
-    ) -> PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
+    pub fn compute_derivative_group_quads(mut self, compute_derivative_group_quads: bool) -> Self {
         self.inner.compute_derivative_group_quads = compute_derivative_group_quads.into();
         self
     }
     pub fn compute_derivative_group_linear(
         mut self,
         compute_derivative_group_linear: bool,
-    ) -> PhysicalDeviceComputeShaderDerivativesFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.compute_derivative_group_linear = compute_derivative_group_linear.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceComputeShaderDerivativesFeaturesNV {
         self.inner
@@ -32827,16 +30232,21 @@ impl PhysicalDeviceFragmentShaderBarycen
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceFragmentShaderBarycentricFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderBarycentricFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceFragmentShaderBarycentricFeaturesNV;
     fn deref(&self) -> &Self::Target {
@@ -32844,20 +30254,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'a> {
-    pub fn fragment_shader_barycentric(
-        mut self,
-        fragment_shader_barycentric: bool,
-    ) -> PhysicalDeviceFragmentShaderBarycentricFeaturesNVBuilder<'a> {
+    pub fn fragment_shader_barycentric(mut self, fragment_shader_barycentric: bool) -> Self {
         self.inner.fragment_shader_barycentric = fragment_shader_barycentric.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
         self.inner
@@ -32888,34 +30295,36 @@ impl PhysicalDeviceShaderImageFootprintF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceShaderImageFootprintFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageFootprintFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageFootprintFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceShaderImageFootprintFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
-    pub fn image_footprint(
-        mut self,
-        image_footprint: bool,
-    ) -> PhysicalDeviceShaderImageFootprintFeaturesNVBuilder<'a> {
+    pub fn image_footprint(mut self, image_footprint: bool) -> Self {
         self.inner.image_footprint = image_footprint.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderImageFootprintFeaturesNV {
         self.inner
@@ -32946,16 +30355,24 @@ impl PhysicalDeviceDedicatedAllocationIm
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
     fn deref(&self) -> &Self::Target {
@@ -32968,17 +30385,17 @@ impl<'a> ::std::ops::DerefMut
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
     pub fn dedicated_allocation_image_aliasing(
         mut self,
         dedicated_allocation_image_aliasing: bool,
-    ) -> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.dedicated_allocation_image_aliasing = dedicated_allocation_image_aliasing.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
         self.inner
@@ -33022,17 +30439,17 @@ impl<'a> ::std::ops::DerefMut for Shadin
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ShadingRatePaletteNVBuilder<'a> {
     pub fn shading_rate_palette_entries(
         mut self,
         shading_rate_palette_entries: &'a [ShadingRatePaletteEntryNV],
-    ) -> ShadingRatePaletteNVBuilder<'a> {
+    ) -> Self {
         self.inner.shading_rate_palette_entry_count = shading_rate_palette_entries.len() as _;
         self.inner.p_shading_rate_palette_entries = shading_rate_palette_entries.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ShadingRatePaletteNV {
@@ -33088,27 +30505,24 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
-    pub fn shading_rate_image_enable(
-        mut self,
-        shading_rate_image_enable: bool,
-    ) -> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
+    pub fn shading_rate_image_enable(mut self, shading_rate_image_enable: bool) -> Self {
         self.inner.shading_rate_image_enable = shading_rate_image_enable.into();
         self
     }
     pub fn shading_rate_palettes(
         mut self,
         shading_rate_palettes: &'a [ShadingRatePaletteNV],
-    ) -> PipelineViewportShadingRateImageStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.viewport_count = shading_rate_palettes.len() as _;
         self.inner.p_shading_rate_palettes = shading_rate_palettes.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineViewportShadingRateImageStateCreateInfoNV {
@@ -33142,41 +30556,40 @@ impl PhysicalDeviceShadingRateImageFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceShadingRateImageFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShadingRateImageFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShadingRateImageFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceShadingRateImageFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
-    pub fn shading_rate_image(
-        mut self,
-        shading_rate_image: bool,
-    ) -> PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
+    pub fn shading_rate_image(mut self, shading_rate_image: bool) -> Self {
         self.inner.shading_rate_image = shading_rate_image.into();
         self
     }
     pub fn shading_rate_coarse_sample_order(
         mut self,
         shading_rate_coarse_sample_order: bool,
-    ) -> PhysicalDeviceShadingRateImageFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.shading_rate_coarse_sample_order = shading_rate_coarse_sample_order.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShadingRateImageFeaturesNV {
         self.inner
@@ -33228,45 +30641,96 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
-    pub fn shading_rate_texel_size(
-        mut self,
-        shading_rate_texel_size: Extent2D,
-    ) -> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
+    pub fn shading_rate_texel_size(mut self, shading_rate_texel_size: Extent2D) -> Self {
         self.inner.shading_rate_texel_size = shading_rate_texel_size;
         self
     }
-    pub fn shading_rate_palette_size(
-        mut self,
-        shading_rate_palette_size: u32,
-    ) -> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
+    pub fn shading_rate_palette_size(mut self, shading_rate_palette_size: u32) -> Self {
         self.inner.shading_rate_palette_size = shading_rate_palette_size;
         self
     }
-    pub fn shading_rate_max_coarse_samples(
-        mut self,
-        shading_rate_max_coarse_samples: u32,
-    ) -> PhysicalDeviceShadingRateImagePropertiesNVBuilder<'a> {
+    pub fn shading_rate_max_coarse_samples(mut self, shading_rate_max_coarse_samples: u32) -> Self {
         self.inner.shading_rate_max_coarse_samples = shading_rate_max_coarse_samples;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShadingRateImagePropertiesNV {
         self.inner
     }
 }
 #[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html>"]
+pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub invocation_mask: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+    fn default() -> PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+        PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+            s_type: StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
+            p_next: ::std::ptr::null_mut(),
+            invocation_mask: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+    pub fn builder<'a>() -> PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
+        PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder {
+            inner: PhysicalDeviceInvocationMaskFeaturesHUAWEI::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
+    inner: PhysicalDeviceInvocationMaskFeaturesHUAWEI,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInvocationMaskFeaturesHUAWEI {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
+    type Target = PhysicalDeviceInvocationMaskFeaturesHUAWEI;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceInvocationMaskFeaturesHUAWEIBuilder<'a> {
+    pub fn invocation_mask(mut self, invocation_mask: bool) -> Self {
+        self.inner.invocation_mask = invocation_mask.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceInvocationMaskFeaturesHUAWEI {
+        self.inner
+    }
+}
+#[repr(C)]
 #[derive(Copy, Clone, Default, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCoarseSampleLocationNV.html>"]
 pub struct CoarseSampleLocationNV {
     pub pixel_x: u32,
     pub pixel_y: u32,
     pub sample: u32,
 }
 impl CoarseSampleLocationNV {
@@ -33289,25 +30753,25 @@ impl<'a> ::std::ops::Deref for CoarseSam
     }
 }
 impl<'a> ::std::ops::DerefMut for CoarseSampleLocationNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CoarseSampleLocationNVBuilder<'a> {
-    pub fn pixel_x(mut self, pixel_x: u32) -> CoarseSampleLocationNVBuilder<'a> {
+    pub fn pixel_x(mut self, pixel_x: u32) -> Self {
         self.inner.pixel_x = pixel_x;
         self
     }
-    pub fn pixel_y(mut self, pixel_y: u32) -> CoarseSampleLocationNVBuilder<'a> {
+    pub fn pixel_y(mut self, pixel_y: u32) -> Self {
         self.inner.pixel_y = pixel_y;
         self
     }
-    pub fn sample(mut self, sample: u32) -> CoarseSampleLocationNVBuilder<'a> {
+    pub fn sample(mut self, sample: u32) -> Self {
         self.inner.sample = sample;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CoarseSampleLocationNV {
         self.inner
@@ -33352,31 +30816,25 @@ impl<'a> ::std::ops::Deref for CoarseSam
     }
 }
 impl<'a> ::std::ops::DerefMut for CoarseSampleOrderCustomNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CoarseSampleOrderCustomNVBuilder<'a> {
-    pub fn shading_rate(
-        mut self,
-        shading_rate: ShadingRatePaletteEntryNV,
-    ) -> CoarseSampleOrderCustomNVBuilder<'a> {
+    pub fn shading_rate(mut self, shading_rate: ShadingRatePaletteEntryNV) -> Self {
         self.inner.shading_rate = shading_rate;
         self
     }
-    pub fn sample_count(mut self, sample_count: u32) -> CoarseSampleOrderCustomNVBuilder<'a> {
+    pub fn sample_count(mut self, sample_count: u32) -> Self {
         self.inner.sample_count = sample_count;
         self
     }
-    pub fn sample_locations(
-        mut self,
-        sample_locations: &'a [CoarseSampleLocationNV],
-    ) -> CoarseSampleOrderCustomNVBuilder<'a> {
+    pub fn sample_locations(mut self, sample_locations: &'a [CoarseSampleLocationNV]) -> Self {
         self.inner.sample_location_count = sample_locations.len() as _;
         self.inner.p_sample_locations = sample_locations.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CoarseSampleOrderCustomNV {
@@ -33432,27 +30890,24 @@ impl<'a> ::std::ops::Deref for PipelineV
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
-    pub fn sample_order_type(
-        mut self,
-        sample_order_type: CoarseSampleOrderTypeNV,
-    ) -> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
+    pub fn sample_order_type(mut self, sample_order_type: CoarseSampleOrderTypeNV) -> Self {
         self.inner.sample_order_type = sample_order_type;
         self
     }
     pub fn custom_sample_orders(
         mut self,
         custom_sample_orders: &'a [CoarseSampleOrderCustomNV],
-    ) -> PipelineViewportCoarseSampleOrderStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.custom_sample_order_count = custom_sample_orders.len() as _;
         self.inner.p_custom_sample_orders = custom_sample_orders.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineViewportCoarseSampleOrderStateCreateInfoNV {
@@ -33486,41 +30941,37 @@ impl PhysicalDeviceMeshShaderFeaturesNV 
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceMeshShaderFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMeshShaderFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMeshShaderFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceMeshShaderFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
-    pub fn task_shader(
-        mut self,
-        task_shader: bool,
-    ) -> PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
+    pub fn task_shader(mut self, task_shader: bool) -> Self {
         self.inner.task_shader = task_shader.into();
         self
     }
-    pub fn mesh_shader(
-        mut self,
-        mesh_shader: bool,
-    ) -> PhysicalDeviceMeshShaderFeaturesNVBuilder<'a> {
+    pub fn mesh_shader(mut self, mesh_shader: bool) -> Self {
         self.inner.mesh_shader = mesh_shader.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMeshShaderFeaturesNV {
         self.inner
@@ -33589,104 +31040,71 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
-    pub fn max_draw_mesh_tasks_count(
-        mut self,
-        max_draw_mesh_tasks_count: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_draw_mesh_tasks_count(mut self, max_draw_mesh_tasks_count: u32) -> Self {
         self.inner.max_draw_mesh_tasks_count = max_draw_mesh_tasks_count;
         self
     }
-    pub fn max_task_work_group_invocations(
-        mut self,
-        max_task_work_group_invocations: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_task_work_group_invocations(mut self, max_task_work_group_invocations: u32) -> Self {
         self.inner.max_task_work_group_invocations = max_task_work_group_invocations;
         self
     }
-    pub fn max_task_work_group_size(
-        mut self,
-        max_task_work_group_size: [u32; 3],
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_task_work_group_size(mut self, max_task_work_group_size: [u32; 3]) -> Self {
         self.inner.max_task_work_group_size = max_task_work_group_size;
         self
     }
-    pub fn max_task_total_memory_size(
-        mut self,
-        max_task_total_memory_size: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_task_total_memory_size(mut self, max_task_total_memory_size: u32) -> Self {
         self.inner.max_task_total_memory_size = max_task_total_memory_size;
         self
     }
-    pub fn max_task_output_count(
-        mut self,
-        max_task_output_count: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_task_output_count(mut self, max_task_output_count: u32) -> Self {
         self.inner.max_task_output_count = max_task_output_count;
         self
     }
-    pub fn max_mesh_work_group_invocations(
-        mut self,
-        max_mesh_work_group_invocations: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_work_group_invocations(mut self, max_mesh_work_group_invocations: u32) -> Self {
         self.inner.max_mesh_work_group_invocations = max_mesh_work_group_invocations;
         self
     }
-    pub fn max_mesh_work_group_size(
-        mut self,
-        max_mesh_work_group_size: [u32; 3],
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_work_group_size(mut self, max_mesh_work_group_size: [u32; 3]) -> Self {
         self.inner.max_mesh_work_group_size = max_mesh_work_group_size;
         self
     }
-    pub fn max_mesh_total_memory_size(
-        mut self,
-        max_mesh_total_memory_size: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_total_memory_size(mut self, max_mesh_total_memory_size: u32) -> Self {
         self.inner.max_mesh_total_memory_size = max_mesh_total_memory_size;
         self
     }
-    pub fn max_mesh_output_vertices(
-        mut self,
-        max_mesh_output_vertices: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_output_vertices(mut self, max_mesh_output_vertices: u32) -> Self {
         self.inner.max_mesh_output_vertices = max_mesh_output_vertices;
         self
     }
-    pub fn max_mesh_output_primitives(
-        mut self,
-        max_mesh_output_primitives: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_output_primitives(mut self, max_mesh_output_primitives: u32) -> Self {
         self.inner.max_mesh_output_primitives = max_mesh_output_primitives;
         self
     }
-    pub fn max_mesh_multiview_view_count(
-        mut self,
-        max_mesh_multiview_view_count: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    pub fn max_mesh_multiview_view_count(mut self, max_mesh_multiview_view_count: u32) -> Self {
         self.inner.max_mesh_multiview_view_count = max_mesh_multiview_view_count;
         self
     }
     pub fn mesh_output_per_vertex_granularity(
         mut self,
         mesh_output_per_vertex_granularity: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.mesh_output_per_vertex_granularity = mesh_output_per_vertex_granularity;
         self
     }
     pub fn mesh_output_per_primitive_granularity(
         mut self,
         mesh_output_per_primitive_granularity: u32,
-    ) -> PhysicalDeviceMeshShaderPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.mesh_output_per_primitive_granularity = mesh_output_per_primitive_granularity;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMeshShaderPropertiesNV {
         self.inner
@@ -33719,21 +31137,21 @@ impl<'a> ::std::ops::Deref for DrawMeshT
     }
 }
 impl<'a> ::std::ops::DerefMut for DrawMeshTasksIndirectCommandNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DrawMeshTasksIndirectCommandNVBuilder<'a> {
-    pub fn task_count(mut self, task_count: u32) -> DrawMeshTasksIndirectCommandNVBuilder<'a> {
+    pub fn task_count(mut self, task_count: u32) -> Self {
         self.inner.task_count = task_count;
         self
     }
-    pub fn first_task(mut self, first_task: u32) -> DrawMeshTasksIndirectCommandNVBuilder<'a> {
+    pub fn first_task(mut self, first_task: u32) -> Self {
         self.inner.first_task = first_task;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DrawMeshTasksIndirectCommandNV {
         self.inner
@@ -33772,81 +31190,48 @@ impl RayTracingShaderGroupCreateInfoNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct RayTracingShaderGroupCreateInfoNVBuilder<'a> {
     inner: RayTracingShaderGroupCreateInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsRayTracingShaderGroupCreateInfoNV {}
 impl<'a> ::std::ops::Deref for RayTracingShaderGroupCreateInfoNVBuilder<'a> {
     type Target = RayTracingShaderGroupCreateInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for RayTracingShaderGroupCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: RayTracingShaderGroupTypeKHR,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn general_shader(
-        mut self,
-        general_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn general_shader(mut self, general_shader: u32) -> Self {
         self.inner.general_shader = general_shader;
         self
     }
-    pub fn closest_hit_shader(
-        mut self,
-        closest_hit_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
         self.inner.closest_hit_shader = closest_hit_shader;
         self
     }
-    pub fn any_hit_shader(
-        mut self,
-        any_hit_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
         self.inner.any_hit_shader = any_hit_shader;
         self
     }
-    pub fn intersection_shader(
-        mut self,
-        intersection_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
+    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
         self.inner.intersection_shader = intersection_shader;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRayTracingShaderGroupCreateInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> RayTracingShaderGroupCreateInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RayTracingShaderGroupCreateInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -33884,88 +31269,55 @@ impl RayTracingShaderGroupCreateInfoKHR 
         }
     }
 }
 #[repr(transparent)]
 pub struct RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
     inner: RayTracingShaderGroupCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsRayTracingShaderGroupCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
     type Target = RayTracingShaderGroupCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: RayTracingShaderGroupTypeKHR,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    pub fn ty(mut self, ty: RayTracingShaderGroupTypeKHR) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn general_shader(
-        mut self,
-        general_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    pub fn general_shader(mut self, general_shader: u32) -> Self {
         self.inner.general_shader = general_shader;
         self
     }
-    pub fn closest_hit_shader(
-        mut self,
-        closest_hit_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    pub fn closest_hit_shader(mut self, closest_hit_shader: u32) -> Self {
         self.inner.closest_hit_shader = closest_hit_shader;
         self
     }
-    pub fn any_hit_shader(
-        mut self,
-        any_hit_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    pub fn any_hit_shader(mut self, any_hit_shader: u32) -> Self {
         self.inner.any_hit_shader = any_hit_shader;
         self
     }
-    pub fn intersection_shader(
-        mut self,
-        intersection_shader: u32,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    pub fn intersection_shader(mut self, intersection_shader: u32) -> Self {
         self.inner.intersection_shader = intersection_shader;
         self
     }
     pub fn shader_group_capture_replay_handle(
         mut self,
         shader_group_capture_replay_handle: *const c_void,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.p_shader_group_capture_replay_handle = shader_group_capture_replay_handle;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRayTracingShaderGroupCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> RayTracingShaderGroupCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RayTracingShaderGroupCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -34022,73 +31374,52 @@ impl<'a> ::std::ops::Deref for RayTracin
     }
 }
 impl<'a> ::std::ops::DerefMut for RayTracingPipelineCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RayTracingPipelineCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCreateFlags,
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stages(
-        mut self,
-        stages: &'a [PipelineShaderStageCreateInfo],
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
         self.inner.stage_count = stages.len() as _;
         self.inner.p_stages = stages.as_ptr();
         self
     }
-    pub fn groups(
-        mut self,
-        groups: &'a [RayTracingShaderGroupCreateInfoNV],
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoNV]) -> Self {
         self.inner.group_count = groups.len() as _;
         self.inner.p_groups = groups.as_ptr();
         self
     }
-    pub fn max_recursion_depth(
-        mut self,
-        max_recursion_depth: u32,
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
         self.inner.max_recursion_depth = max_recursion_depth;
         self
     }
-    pub fn layout(mut self, layout: PipelineLayout) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn layout(mut self, layout: PipelineLayout) -> Self {
         self.inner.layout = layout;
         self
     }
-    pub fn base_pipeline_handle(
-        mut self,
-        base_pipeline_handle: Pipeline,
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
         self.inner.base_pipeline_handle = base_pipeline_handle;
         self
     }
-    pub fn base_pipeline_index(
-        mut self,
-        base_pipeline_index: i32,
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
         self.inner.base_pipeline_index = base_pipeline_index;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> RayTracingPipelineCreateInfoNVBuilder<'a> {
+    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoNV>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -34159,94 +31490,70 @@ impl<'a> ::std::ops::Deref for RayTracin
     }
 }
 impl<'a> ::std::ops::DerefMut for RayTracingPipelineCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RayTracingPipelineCreateInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCreateFlags,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn stages(
-        mut self,
-        stages: &'a [PipelineShaderStageCreateInfo],
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn stages(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> Self {
         self.inner.stage_count = stages.len() as _;
         self.inner.p_stages = stages.as_ptr();
         self
     }
-    pub fn groups(
-        mut self,
-        groups: &'a [RayTracingShaderGroupCreateInfoKHR],
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn groups(mut self, groups: &'a [RayTracingShaderGroupCreateInfoKHR]) -> Self {
         self.inner.group_count = groups.len() as _;
         self.inner.p_groups = groups.as_ptr();
         self
     }
     pub fn max_pipeline_ray_recursion_depth(
         mut self,
         max_pipeline_ray_recursion_depth: u32,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_pipeline_ray_recursion_depth = max_pipeline_ray_recursion_depth;
         self
     }
-    pub fn library_info(
-        mut self,
-        library_info: &'a PipelineLibraryCreateInfoKHR,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn library_info(mut self, library_info: &'a PipelineLibraryCreateInfoKHR) -> Self {
         self.inner.p_library_info = library_info;
         self
     }
     pub fn library_interface(
         mut self,
         library_interface: &'a RayTracingPipelineInterfaceCreateInfoKHR,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.p_library_interface = library_interface;
         self
     }
-    pub fn dynamic_state(
-        mut self,
-        dynamic_state: &'a PipelineDynamicStateCreateInfo,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn dynamic_state(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> Self {
         self.inner.p_dynamic_state = dynamic_state;
         self
     }
-    pub fn layout(mut self, layout: PipelineLayout) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn layout(mut self, layout: PipelineLayout) -> Self {
         self.inner.layout = layout;
         self
     }
-    pub fn base_pipeline_handle(
-        mut self,
-        base_pipeline_handle: Pipeline,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn base_pipeline_handle(mut self, base_pipeline_handle: Pipeline) -> Self {
         self.inner.base_pipeline_handle = base_pipeline_handle;
         self
     }
-    pub fn base_pipeline_index(
-        mut self,
-        base_pipeline_index: i32,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn base_pipeline_index(mut self, base_pipeline_index: i32) -> Self {
         self.inner.base_pipeline_index = base_pipeline_index;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> RayTracingPipelineCreateInfoKHRBuilder<'a> {
+    pub fn push_next<T: ExtendsRayTracingPipelineCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -34302,93 +31609,72 @@ impl GeometryTrianglesNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct GeometryTrianglesNVBuilder<'a> {
     inner: GeometryTrianglesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGeometryTrianglesNV {}
 impl<'a> ::std::ops::Deref for GeometryTrianglesNVBuilder<'a> {
     type Target = GeometryTrianglesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GeometryTrianglesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeometryTrianglesNVBuilder<'a> {
-    pub fn vertex_data(mut self, vertex_data: Buffer) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn vertex_data(mut self, vertex_data: Buffer) -> Self {
         self.inner.vertex_data = vertex_data;
         self
     }
-    pub fn vertex_offset(mut self, vertex_offset: DeviceSize) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn vertex_offset(mut self, vertex_offset: DeviceSize) -> Self {
         self.inner.vertex_offset = vertex_offset;
         self
     }
-    pub fn vertex_count(mut self, vertex_count: u32) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn vertex_count(mut self, vertex_count: u32) -> Self {
         self.inner.vertex_count = vertex_count;
         self
     }
-    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
         self.inner.vertex_stride = vertex_stride;
         self
     }
-    pub fn vertex_format(mut self, vertex_format: Format) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
         self.inner.vertex_format = vertex_format;
         self
     }
-    pub fn index_data(mut self, index_data: Buffer) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn index_data(mut self, index_data: Buffer) -> Self {
         self.inner.index_data = index_data;
         self
     }
-    pub fn index_offset(mut self, index_offset: DeviceSize) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn index_offset(mut self, index_offset: DeviceSize) -> Self {
         self.inner.index_offset = index_offset;
         self
     }
-    pub fn index_count(mut self, index_count: u32) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn index_count(mut self, index_count: u32) -> Self {
         self.inner.index_count = index_count;
         self
     }
-    pub fn index_type(mut self, index_type: IndexType) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn index_type(mut self, index_type: IndexType) -> Self {
         self.inner.index_type = index_type;
         self
     }
-    pub fn transform_data(mut self, transform_data: Buffer) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn transform_data(mut self, transform_data: Buffer) -> Self {
         self.inner.transform_data = transform_data;
         self
     }
-    pub fn transform_offset(
-        mut self,
-        transform_offset: DeviceSize,
-    ) -> GeometryTrianglesNVBuilder<'a> {
+    pub fn transform_offset(mut self, transform_offset: DeviceSize) -> Self {
         self.inner.transform_offset = transform_offset;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGeometryTrianglesNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> GeometryTrianglesNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeometryTrianglesNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -34422,62 +31708,44 @@ impl GeometryAABBNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct GeometryAABBNVBuilder<'a> {
     inner: GeometryAABBNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGeometryAABBNV {}
 impl<'a> ::std::ops::Deref for GeometryAABBNVBuilder<'a> {
     type Target = GeometryAABBNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GeometryAABBNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeometryAABBNVBuilder<'a> {
-    pub fn aabb_data(mut self, aabb_data: Buffer) -> GeometryAABBNVBuilder<'a> {
+    pub fn aabb_data(mut self, aabb_data: Buffer) -> Self {
         self.inner.aabb_data = aabb_data;
         self
     }
-    pub fn num_aab_bs(mut self, num_aab_bs: u32) -> GeometryAABBNVBuilder<'a> {
+    pub fn num_aab_bs(mut self, num_aab_bs: u32) -> Self {
         self.inner.num_aab_bs = num_aab_bs;
         self
     }
-    pub fn stride(mut self, stride: u32) -> GeometryAABBNVBuilder<'a> {
+    pub fn stride(mut self, stride: u32) -> Self {
         self.inner.stride = stride;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> GeometryAABBNVBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGeometryAABBNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> GeometryAABBNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeometryAABBNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -34507,21 +31775,21 @@ impl<'a> ::std::ops::Deref for GeometryD
     }
 }
 impl<'a> ::std::ops::DerefMut for GeometryDataNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeometryDataNVBuilder<'a> {
-    pub fn triangles(mut self, triangles: GeometryTrianglesNV) -> GeometryDataNVBuilder<'a> {
+    pub fn triangles(mut self, triangles: GeometryTrianglesNV) -> Self {
         self.inner.triangles = triangles;
         self
     }
-    pub fn aabbs(mut self, aabbs: GeometryAABBNV) -> GeometryDataNVBuilder<'a> {
+    pub fn aabbs(mut self, aabbs: GeometryAABBNV) -> Self {
         self.inner.aabbs = aabbs;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeometryDataNV {
         self.inner
@@ -34556,53 +31824,38 @@ impl GeometryNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct GeometryNVBuilder<'a> {
     inner: GeometryNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsGeometryNV {}
 impl<'a> ::std::ops::Deref for GeometryNVBuilder<'a> {
     type Target = GeometryNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for GeometryNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> GeometryNVBuilder<'a> {
-    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> GeometryNVBuilder<'a> {
+    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
         self.inner.geometry_type = geometry_type;
         self
     }
-    pub fn geometry(mut self, geometry: GeometryDataNV) -> GeometryNVBuilder<'a> {
+    pub fn geometry(mut self, geometry: GeometryDataNV) -> Self {
         self.inner.geometry = geometry;
         self
     }
-    pub fn flags(mut self, flags: GeometryFlagsKHR) -> GeometryNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsGeometryNV>(mut self, next: &'a mut T) -> GeometryNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> GeometryNV {
         self.inner
     }
@@ -34640,69 +31893,45 @@ impl AccelerationStructureInfoNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureInfoNVBuilder<'a> {
     inner: AccelerationStructureInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureInfoNV {}
 impl<'a> ::std::ops::Deref for AccelerationStructureInfoNVBuilder<'a> {
     type Target = AccelerationStructureInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureInfoNVBuilder<'a> {
-    pub fn ty(mut self, ty: AccelerationStructureTypeNV) -> AccelerationStructureInfoNVBuilder<'a> {
+    pub fn ty(mut self, ty: AccelerationStructureTypeNV) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn flags(
-        mut self,
-        flags: BuildAccelerationStructureFlagsNV,
-    ) -> AccelerationStructureInfoNVBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn instance_count(mut self, instance_count: u32) -> AccelerationStructureInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn instance_count(mut self, instance_count: u32) -> Self {
         self.inner.instance_count = instance_count;
         self
     }
-    pub fn geometries(
-        mut self,
-        geometries: &'a [GeometryNV],
-    ) -> AccelerationStructureInfoNVBuilder<'a> {
+    pub fn geometries(mut self, geometries: &'a [GeometryNV]) -> Self {
         self.inner.geometry_count = geometries.len() as _;
         self.inner.p_geometries = geometries.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -34732,60 +31961,36 @@ impl AccelerationStructureCreateInfoNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureCreateInfoNVBuilder<'a> {
     inner: AccelerationStructureCreateInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureCreateInfoNV {}
 impl<'a> ::std::ops::Deref for AccelerationStructureCreateInfoNVBuilder<'a> {
     type Target = AccelerationStructureCreateInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureCreateInfoNVBuilder<'a> {
-    pub fn compacted_size(
-        mut self,
-        compacted_size: DeviceSize,
-    ) -> AccelerationStructureCreateInfoNVBuilder<'a> {
+    pub fn compacted_size(mut self, compacted_size: DeviceSize) -> Self {
         self.inner.compacted_size = compacted_size;
         self
     }
-    pub fn info(
-        mut self,
-        info: AccelerationStructureInfoNV,
-    ) -> AccelerationStructureCreateInfoNVBuilder<'a> {
+    pub fn info(mut self, info: AccelerationStructureInfoNV) -> Self {
         self.inner.info = info;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureCreateInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureCreateInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureCreateInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -34821,75 +32026,48 @@ impl BindAccelerationStructureMemoryInfo
         }
     }
 }
 #[repr(transparent)]
 pub struct BindAccelerationStructureMemoryInfoNVBuilder<'a> {
     inner: BindAccelerationStructureMemoryInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBindAccelerationStructureMemoryInfoNV {}
 impl<'a> ::std::ops::Deref for BindAccelerationStructureMemoryInfoNVBuilder<'a> {
     type Target = BindAccelerationStructureMemoryInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BindAccelerationStructureMemoryInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
     pub fn acceleration_structure(
         mut self,
         acceleration_structure: AccelerationStructureNV,
-    ) -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure = acceleration_structure;
         self
     }
-    pub fn memory(
-        mut self,
-        memory: DeviceMemory,
-    ) -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    pub fn memory_offset(
-        mut self,
-        memory_offset: DeviceSize,
-    ) -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
         self.inner.memory_offset = memory_offset;
         self
     }
-    pub fn device_indices(
-        mut self,
-        device_indices: &'a [u32],
-    ) -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
+    pub fn device_indices(mut self, device_indices: &'a [u32]) -> Self {
         self.inner.device_index_count = device_indices.len() as _;
         self.inner.p_device_indices = device_indices.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBindAccelerationStructureMemoryInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> BindAccelerationStructureMemoryInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BindAccelerationStructureMemoryInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -34936,17 +32114,17 @@ impl<'a> ::std::ops::DerefMut for WriteD
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
     pub fn acceleration_structures(
         mut self,
         acceleration_structures: &'a [AccelerationStructureKHR],
-    ) -> WriteDescriptorSetAccelerationStructureKHRBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure_count = acceleration_structures.len() as _;
         self.inner.p_acceleration_structures = acceleration_structures.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> WriteDescriptorSetAccelerationStructureKHR {
@@ -34997,17 +32175,17 @@ impl<'a> ::std::ops::DerefMut for WriteD
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
     pub fn acceleration_structures(
         mut self,
         acceleration_structures: &'a [AccelerationStructureNV],
-    ) -> WriteDescriptorSetAccelerationStructureNVBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure_count = acceleration_structures.len() as _;
         self.inner.p_acceleration_structures = acceleration_structures.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> WriteDescriptorSetAccelerationStructureNV {
@@ -35041,60 +32219,39 @@ impl AccelerationStructureMemoryRequirem
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
     inner: AccelerationStructureMemoryRequirementsInfoNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureMemoryRequirementsInfoNV {}
 impl<'a> ::std::ops::Deref for AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
     type Target = AccelerationStructureMemoryRequirementsInfoNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: AccelerationStructureMemoryRequirementsTypeNV,
-    ) -> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
+    pub fn ty(mut self, ty: AccelerationStructureMemoryRequirementsTypeNV) -> Self {
         self.inner.ty = ty;
         self
     }
     pub fn acceleration_structure(
         mut self,
         acceleration_structure: AccelerationStructureNV,
-    ) -> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure = acceleration_structure;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureMemoryRequirementsInfoNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureMemoryRequirementsInfoNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureMemoryRequirementsInfoNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -35130,65 +32287,67 @@ impl PhysicalDeviceAccelerationStructure
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceAccelerationStructureFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceAccelerationStructureFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceAccelerationStructureFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceAccelerationStructureFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
-    pub fn acceleration_structure(
-        mut self,
-        acceleration_structure: bool,
-    ) -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
+    pub fn acceleration_structure(mut self, acceleration_structure: bool) -> Self {
         self.inner.acceleration_structure = acceleration_structure.into();
         self
     }
     pub fn acceleration_structure_capture_replay(
         mut self,
         acceleration_structure_capture_replay: bool,
-    ) -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure_capture_replay =
             acceleration_structure_capture_replay.into();
         self
     }
     pub fn acceleration_structure_indirect_build(
         mut self,
         acceleration_structure_indirect_build: bool,
-    ) -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure_indirect_build =
             acceleration_structure_indirect_build.into();
         self
     }
     pub fn acceleration_structure_host_commands(
         mut self,
         acceleration_structure_host_commands: bool,
-    ) -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure_host_commands =
             acceleration_structure_host_commands.into();
         self
     }
     pub fn descriptor_binding_acceleration_structure_update_after_bind(
         mut self,
         descriptor_binding_acceleration_structure_update_after_bind: bool,
-    ) -> PhysicalDeviceAccelerationStructureFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_acceleration_structure_update_after_bind =
             descriptor_binding_acceleration_structure_update_after_bind.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -35229,67 +32388,69 @@ impl PhysicalDeviceRayTracingPipelineFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceRayTracingPipelineFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingPipelineFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceRayTracingPipelineFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
-    pub fn ray_tracing_pipeline(
-        mut self,
-        ray_tracing_pipeline: bool,
-    ) -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
+    pub fn ray_tracing_pipeline(mut self, ray_tracing_pipeline: bool) -> Self {
         self.inner.ray_tracing_pipeline = ray_tracing_pipeline.into();
         self
     }
     pub fn ray_tracing_pipeline_shader_group_handle_capture_replay(
         mut self,
         ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
-    ) -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .ray_tracing_pipeline_shader_group_handle_capture_replay =
             ray_tracing_pipeline_shader_group_handle_capture_replay.into();
         self
     }
     pub fn ray_tracing_pipeline_shader_group_handle_capture_replay_mixed(
         mut self,
         ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
-    ) -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed =
             ray_tracing_pipeline_shader_group_handle_capture_replay_mixed.into();
         self
     }
     pub fn ray_tracing_pipeline_trace_rays_indirect(
         mut self,
         ray_tracing_pipeline_trace_rays_indirect: bool,
-    ) -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.ray_tracing_pipeline_trace_rays_indirect =
             ray_tracing_pipeline_trace_rays_indirect.into();
         self
     }
     pub fn ray_traversal_primitive_culling(
         mut self,
         ray_traversal_primitive_culling: bool,
-    ) -> PhysicalDeviceRayTracingPipelineFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.ray_traversal_primitive_culling = ray_traversal_primitive_culling.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRayTracingPipelineFeaturesKHR {
         self.inner
@@ -35320,31 +32481,33 @@ impl PhysicalDeviceRayQueryFeaturesKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceRayQueryFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayQueryFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayQueryFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayQueryFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayQueryFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceRayQueryFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
-    pub fn ray_query(mut self, ray_query: bool) -> PhysicalDeviceRayQueryFeaturesKHRBuilder<'a> {
+    pub fn ray_query(mut self, ray_query: bool) -> Self {
         self.inner.ray_query = ray_query.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRayQueryFeaturesKHR {
         self.inner
@@ -35406,75 +32569,66 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
-    pub fn max_geometry_count(
-        mut self,
-        max_geometry_count: u64,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
         self.inner.max_geometry_count = max_geometry_count;
         self
     }
-    pub fn max_instance_count(
-        mut self,
-        max_instance_count: u64,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
         self.inner.max_instance_count = max_instance_count;
         self
     }
-    pub fn max_primitive_count(
-        mut self,
-        max_primitive_count: u64,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    pub fn max_primitive_count(mut self, max_primitive_count: u64) -> Self {
         self.inner.max_primitive_count = max_primitive_count;
         self
     }
     pub fn max_per_stage_descriptor_acceleration_structures(
         mut self,
         max_per_stage_descriptor_acceleration_structures: u32,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_descriptor_acceleration_structures =
             max_per_stage_descriptor_acceleration_structures;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_acceleration_structures(
         mut self,
         max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_acceleration_structures =
             max_per_stage_descriptor_update_after_bind_acceleration_structures;
         self
     }
     pub fn max_descriptor_set_acceleration_structures(
         mut self,
         max_descriptor_set_acceleration_structures: u32,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_acceleration_structures =
             max_descriptor_set_acceleration_structures;
         self
     }
     pub fn max_descriptor_set_update_after_bind_acceleration_structures(
         mut self,
         max_descriptor_set_update_after_bind_acceleration_structures: u32,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_acceleration_structures =
             max_descriptor_set_update_after_bind_acceleration_structures;
         self
     }
     pub fn min_acceleration_structure_scratch_offset_alignment(
         mut self,
         min_acceleration_structure_scratch_offset_alignment: u32,
-    ) -> PhysicalDeviceAccelerationStructurePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .min_acceleration_structure_scratch_offset_alignment =
             min_acceleration_structure_scratch_offset_alignment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -35538,70 +32692,52 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
-    pub fn shader_group_handle_size(
-        mut self,
-        shader_group_handle_size: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
         self.inner.shader_group_handle_size = shader_group_handle_size;
         self
     }
-    pub fn max_ray_recursion_depth(
-        mut self,
-        max_ray_recursion_depth: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn max_ray_recursion_depth(mut self, max_ray_recursion_depth: u32) -> Self {
         self.inner.max_ray_recursion_depth = max_ray_recursion_depth;
         self
     }
-    pub fn max_shader_group_stride(
-        mut self,
-        max_shader_group_stride: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
         self.inner.max_shader_group_stride = max_shader_group_stride;
         self
     }
-    pub fn shader_group_base_alignment(
-        mut self,
-        shader_group_base_alignment: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
         self.inner.shader_group_base_alignment = shader_group_base_alignment;
         self
     }
     pub fn shader_group_handle_capture_replay_size(
         mut self,
         shader_group_handle_capture_replay_size: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.shader_group_handle_capture_replay_size =
             shader_group_handle_capture_replay_size;
         self
     }
     pub fn max_ray_dispatch_invocation_count(
         mut self,
         max_ray_dispatch_invocation_count: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_ray_dispatch_invocation_count = max_ray_dispatch_invocation_count;
         self
     }
-    pub fn shader_group_handle_alignment(
-        mut self,
-        shader_group_handle_alignment: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn shader_group_handle_alignment(mut self, shader_group_handle_alignment: u32) -> Self {
         self.inner.shader_group_handle_alignment = shader_group_handle_alignment;
         self
     }
-    pub fn max_ray_hit_attribute_size(
-        mut self,
-        max_ray_hit_attribute_size: u32,
-    ) -> PhysicalDeviceRayTracingPipelinePropertiesKHRBuilder<'a> {
+    pub fn max_ray_hit_attribute_size(mut self, max_ray_hit_attribute_size: u32) -> Self {
         self.inner.max_ray_hit_attribute_size = max_ray_hit_attribute_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRayTracingPipelinePropertiesKHR {
         self.inner
@@ -35660,69 +32796,48 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
-    pub fn shader_group_handle_size(
-        mut self,
-        shader_group_handle_size: u32,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn shader_group_handle_size(mut self, shader_group_handle_size: u32) -> Self {
         self.inner.shader_group_handle_size = shader_group_handle_size;
         self
     }
-    pub fn max_recursion_depth(
-        mut self,
-        max_recursion_depth: u32,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn max_recursion_depth(mut self, max_recursion_depth: u32) -> Self {
         self.inner.max_recursion_depth = max_recursion_depth;
         self
     }
-    pub fn max_shader_group_stride(
-        mut self,
-        max_shader_group_stride: u32,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn max_shader_group_stride(mut self, max_shader_group_stride: u32) -> Self {
         self.inner.max_shader_group_stride = max_shader_group_stride;
         self
     }
-    pub fn shader_group_base_alignment(
-        mut self,
-        shader_group_base_alignment: u32,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn shader_group_base_alignment(mut self, shader_group_base_alignment: u32) -> Self {
         self.inner.shader_group_base_alignment = shader_group_base_alignment;
         self
     }
-    pub fn max_geometry_count(
-        mut self,
-        max_geometry_count: u64,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn max_geometry_count(mut self, max_geometry_count: u64) -> Self {
         self.inner.max_geometry_count = max_geometry_count;
         self
     }
-    pub fn max_instance_count(
-        mut self,
-        max_instance_count: u64,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn max_instance_count(mut self, max_instance_count: u64) -> Self {
         self.inner.max_instance_count = max_instance_count;
         self
     }
-    pub fn max_triangle_count(
-        mut self,
-        max_triangle_count: u64,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    pub fn max_triangle_count(mut self, max_triangle_count: u64) -> Self {
         self.inner.max_triangle_count = max_triangle_count;
         self
     }
     pub fn max_descriptor_set_acceleration_structures(
         mut self,
         max_descriptor_set_acceleration_structures: u32,
-    ) -> PhysicalDeviceRayTracingPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_acceleration_structures =
             max_descriptor_set_acceleration_structures;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRayTracingPropertiesNV {
@@ -35757,28 +32872,25 @@ impl<'a> ::std::ops::Deref for StridedDe
     }
 }
 impl<'a> ::std::ops::DerefMut for StridedDeviceAddressRegionKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> StridedDeviceAddressRegionKHRBuilder<'a> {
-    pub fn device_address(
-        mut self,
-        device_address: DeviceAddress,
-    ) -> StridedDeviceAddressRegionKHRBuilder<'a> {
+    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
         self.inner.device_address = device_address;
         self
     }
-    pub fn stride(mut self, stride: DeviceSize) -> StridedDeviceAddressRegionKHRBuilder<'a> {
+    pub fn stride(mut self, stride: DeviceSize) -> Self {
         self.inner.stride = stride;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> StridedDeviceAddressRegionKHRBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> StridedDeviceAddressRegionKHR {
         self.inner
@@ -35812,25 +32924,25 @@ impl<'a> ::std::ops::Deref for TraceRays
     }
 }
 impl<'a> ::std::ops::DerefMut for TraceRaysIndirectCommandKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> TraceRaysIndirectCommandKHRBuilder<'a> {
-    pub fn width(mut self, width: u32) -> TraceRaysIndirectCommandKHRBuilder<'a> {
+    pub fn width(mut self, width: u32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: u32) -> TraceRaysIndirectCommandKHRBuilder<'a> {
+    pub fn height(mut self, height: u32) -> Self {
         self.inner.height = height;
         self
     }
-    pub fn depth(mut self, depth: u32) -> TraceRaysIndirectCommandKHRBuilder<'a> {
+    pub fn depth(mut self, depth: u32) -> Self {
         self.inner.depth = depth;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> TraceRaysIndirectCommandKHR {
         self.inner
@@ -35880,17 +32992,17 @@ impl<'a> ::std::ops::DerefMut for DrmFor
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DrmFormatModifierPropertiesListEXTBuilder<'a> {
     pub fn drm_format_modifier_properties(
         mut self,
         drm_format_modifier_properties: &'a mut [DrmFormatModifierPropertiesEXT],
-    ) -> DrmFormatModifierPropertiesListEXTBuilder<'a> {
+    ) -> Self {
         self.inner.drm_format_modifier_count = drm_format_modifier_properties.len() as _;
         self.inner.p_drm_format_modifier_properties = drm_format_modifier_properties.as_mut_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DrmFormatModifierPropertiesListEXT {
@@ -35925,34 +33037,28 @@ impl<'a> ::std::ops::Deref for DrmFormat
     }
 }
 impl<'a> ::std::ops::DerefMut for DrmFormatModifierPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DrmFormatModifierPropertiesEXTBuilder<'a> {
-    pub fn drm_format_modifier(
-        mut self,
-        drm_format_modifier: u64,
-    ) -> DrmFormatModifierPropertiesEXTBuilder<'a> {
+    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
         self.inner.drm_format_modifier = drm_format_modifier;
         self
     }
-    pub fn drm_format_modifier_plane_count(
-        mut self,
-        drm_format_modifier_plane_count: u32,
-    ) -> DrmFormatModifierPropertiesEXTBuilder<'a> {
+    pub fn drm_format_modifier_plane_count(mut self, drm_format_modifier_plane_count: u32) -> Self {
         self.inner.drm_format_modifier_plane_count = drm_format_modifier_plane_count;
         self
     }
     pub fn drm_format_modifier_tiling_features(
         mut self,
         drm_format_modifier_tiling_features: FormatFeatureFlags,
-    ) -> DrmFormatModifierPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.drm_format_modifier_tiling_features = drm_format_modifier_tiling_features;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DrmFormatModifierPropertiesEXT {
         self.inner
@@ -36006,34 +33112,25 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
-    pub fn drm_format_modifier(
-        mut self,
-        drm_format_modifier: u64,
-    ) -> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
+    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
         self.inner.drm_format_modifier = drm_format_modifier;
         self
     }
-    pub fn sharing_mode(
-        mut self,
-        sharing_mode: SharingMode,
-    ) -> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
+    pub fn sharing_mode(mut self, sharing_mode: SharingMode) -> Self {
         self.inner.sharing_mode = sharing_mode;
         self
     }
-    pub fn queue_family_indices(
-        mut self,
-        queue_family_indices: &'a [u32],
-    ) -> PhysicalDeviceImageDrmFormatModifierInfoEXTBuilder<'a> {
+    pub fn queue_family_indices(mut self, queue_family_indices: &'a [u32]) -> Self {
         self.inner.queue_family_index_count = queue_family_indices.len() as _;
         self.inner.p_queue_family_indices = queue_family_indices.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceImageDrmFormatModifierInfoEXT {
@@ -36081,20 +33178,17 @@ impl<'a> ::std::ops::Deref for ImageDrmF
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
-    pub fn drm_format_modifiers(
-        mut self,
-        drm_format_modifiers: &'a [u64],
-    ) -> ImageDrmFormatModifierListCreateInfoEXTBuilder<'a> {
+    pub fn drm_format_modifiers(mut self, drm_format_modifiers: &'a [u64]) -> Self {
         self.inner.drm_format_modifier_count = drm_format_modifiers.len() as _;
         self.inner.p_drm_format_modifiers = drm_format_modifiers.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageDrmFormatModifierListCreateInfoEXT {
@@ -36144,27 +33238,21 @@ impl<'a> ::std::ops::Deref for ImageDrmF
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
-    pub fn drm_format_modifier(
-        mut self,
-        drm_format_modifier: u64,
-    ) -> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
+    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
         self.inner.drm_format_modifier = drm_format_modifier;
         self
     }
-    pub fn plane_layouts(
-        mut self,
-        plane_layouts: &'a [SubresourceLayout],
-    ) -> ImageDrmFormatModifierExplicitCreateInfoEXTBuilder<'a> {
+    pub fn plane_layouts(mut self, plane_layouts: &'a [SubresourceLayout]) -> Self {
         self.inner.drm_format_modifier_plane_count = plane_layouts.len() as _;
         self.inner.p_plane_layouts = plane_layouts.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageDrmFormatModifierExplicitCreateInfoEXT {
@@ -36196,53 +33284,32 @@ impl ImageDrmFormatModifierPropertiesEXT
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
     inner: ImageDrmFormatModifierPropertiesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageDrmFormatModifierPropertiesEXT {}
 impl<'a> ::std::ops::Deref for ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
     type Target = ImageDrmFormatModifierPropertiesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
-    pub fn drm_format_modifier(
-        mut self,
-        drm_format_modifier: u64,
-    ) -> ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
+    pub fn drm_format_modifier(mut self, drm_format_modifier: u64) -> Self {
         self.inner.drm_format_modifier = drm_format_modifier;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageDrmFormatModifierPropertiesEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageDrmFormatModifierPropertiesEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageDrmFormatModifierPropertiesEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -36286,20 +33353,17 @@ impl<'a> ::std::ops::Deref for ImageSten
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageStencilUsageCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageStencilUsageCreateInfoBuilder<'a> {
-    pub fn stencil_usage(
-        mut self,
-        stencil_usage: ImageUsageFlags,
-    ) -> ImageStencilUsageCreateInfoBuilder<'a> {
+    pub fn stencil_usage(mut self, stencil_usage: ImageUsageFlags) -> Self {
         self.inner.stencil_usage = stencil_usage;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageStencilUsageCreateInfo {
         self.inner
@@ -36347,17 +33411,17 @@ impl<'a> ::std::ops::DerefMut for Device
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
     pub fn overallocation_behavior(
         mut self,
         overallocation_behavior: MemoryOverallocationBehaviorAMD,
-    ) -> DeviceMemoryOverallocationCreateInfoAMDBuilder<'a> {
+    ) -> Self {
         self.inner.overallocation_behavior = overallocation_behavior;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceMemoryOverallocationCreateInfoAMD {
         self.inner
@@ -36392,48 +33456,47 @@ impl PhysicalDeviceFragmentDensityMapFea
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceFragmentDensityMapFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMapFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceFragmentDensityMapFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
-    pub fn fragment_density_map(
-        mut self,
-        fragment_density_map: bool,
-    ) -> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
+    pub fn fragment_density_map(mut self, fragment_density_map: bool) -> Self {
         self.inner.fragment_density_map = fragment_density_map.into();
         self
     }
-    pub fn fragment_density_map_dynamic(
-        mut self,
-        fragment_density_map_dynamic: bool,
-    ) -> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
+    pub fn fragment_density_map_dynamic(mut self, fragment_density_map_dynamic: bool) -> Self {
         self.inner.fragment_density_map_dynamic = fragment_density_map_dynamic.into();
         self
     }
     pub fn fragment_density_map_non_subsampled_images(
         mut self,
         fragment_density_map_non_subsampled_images: bool,
-    ) -> PhysicalDeviceFragmentDensityMapFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_density_map_non_subsampled_images =
             fragment_density_map_non_subsampled_images.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentDensityMapFeaturesEXT {
@@ -36465,34 +33528,36 @@ impl PhysicalDeviceFragmentDensityMap2Fe
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceFragmentDensityMap2FeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentDensityMap2FeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceFragmentDensityMap2FeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
-    pub fn fragment_density_map_deferred(
-        mut self,
-        fragment_density_map_deferred: bool,
-    ) -> PhysicalDeviceFragmentDensityMap2FeaturesEXTBuilder<'a> {
+    pub fn fragment_density_map_deferred(mut self, fragment_density_map_deferred: bool) -> Self {
         self.inner.fragment_density_map_deferred = fragment_density_map_deferred.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentDensityMap2FeaturesEXT {
         self.inner
@@ -36547,31 +33612,28 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
     pub fn min_fragment_density_texel_size(
         mut self,
         min_fragment_density_texel_size: Extent2D,
-    ) -> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.min_fragment_density_texel_size = min_fragment_density_texel_size;
         self
     }
     pub fn max_fragment_density_texel_size(
         mut self,
         max_fragment_density_texel_size: Extent2D,
-    ) -> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_density_texel_size = max_fragment_density_texel_size;
         self
     }
-    pub fn fragment_density_invocations(
-        mut self,
-        fragment_density_invocations: bool,
-    ) -> PhysicalDeviceFragmentDensityMapPropertiesEXTBuilder<'a> {
+    pub fn fragment_density_invocations(mut self, fragment_density_invocations: bool) -> Self {
         self.inner.fragment_density_invocations = fragment_density_invocations.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentDensityMapPropertiesEXT {
         self.inner
@@ -36625,42 +33687,36 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
-    pub fn subsampled_loads(
-        mut self,
-        subsampled_loads: bool,
-    ) -> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
+    pub fn subsampled_loads(mut self, subsampled_loads: bool) -> Self {
         self.inner.subsampled_loads = subsampled_loads.into();
         self
     }
     pub fn subsampled_coarse_reconstruction_early_access(
         mut self,
         subsampled_coarse_reconstruction_early_access: bool,
-    ) -> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.subsampled_coarse_reconstruction_early_access =
             subsampled_coarse_reconstruction_early_access.into();
         self
     }
-    pub fn max_subsampled_array_layers(
-        mut self,
-        max_subsampled_array_layers: u32,
-    ) -> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
+    pub fn max_subsampled_array_layers(mut self, max_subsampled_array_layers: u32) -> Self {
         self.inner.max_subsampled_array_layers = max_subsampled_array_layers;
         self
     }
     pub fn max_descriptor_set_subsampled_samplers(
         mut self,
         max_descriptor_set_subsampled_samplers: u32,
-    ) -> PhysicalDeviceFragmentDensityMap2PropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_subsampled_samplers = max_descriptor_set_subsampled_samplers;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentDensityMap2PropertiesEXT {
         self.inner
@@ -36710,17 +33766,17 @@ impl<'a> ::std::ops::DerefMut for Render
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
     pub fn fragment_density_map_attachment(
         mut self,
         fragment_density_map_attachment: AttachmentReference,
-    ) -> RenderPassFragmentDensityMapCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_density_map_attachment = fragment_density_map_attachment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassFragmentDensityMapCreateInfoEXT {
         self.inner
@@ -36751,34 +33807,33 @@ impl PhysicalDeviceScalarBlockLayoutFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
     inner: PhysicalDeviceScalarBlockLayoutFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceScalarBlockLayoutFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceScalarBlockLayoutFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
     type Target = PhysicalDeviceScalarBlockLayoutFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
-    pub fn scalar_block_layout(
-        mut self,
-        scalar_block_layout: bool,
-    ) -> PhysicalDeviceScalarBlockLayoutFeaturesBuilder<'a> {
+    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
         self.inner.scalar_block_layout = scalar_block_layout.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceScalarBlockLayoutFeatures {
         self.inner
@@ -36823,20 +33878,17 @@ impl<'a> ::std::ops::Deref for SurfacePr
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceProtectedCapabilitiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceProtectedCapabilitiesKHRBuilder<'a> {
-    pub fn supports_protected(
-        mut self,
-        supports_protected: bool,
-    ) -> SurfaceProtectedCapabilitiesKHRBuilder<'a> {
+    pub fn supports_protected(mut self, supports_protected: bool) -> Self {
         self.inner.supports_protected = supports_protected.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceProtectedCapabilitiesKHR {
         self.inner
@@ -36867,16 +33919,21 @@ impl PhysicalDeviceUniformBufferStandard
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
     inner: PhysicalDeviceUniformBufferStandardLayoutFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceUniformBufferStandardLayoutFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
     type Target = PhysicalDeviceUniformBufferStandardLayoutFeatures;
     fn deref(&self) -> &Self::Target {
@@ -36884,20 +33941,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
-    pub fn uniform_buffer_standard_layout(
-        mut self,
-        uniform_buffer_standard_layout: bool,
-    ) -> PhysicalDeviceUniformBufferStandardLayoutFeaturesBuilder<'a> {
+    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
         self.inner.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceUniformBufferStandardLayoutFeatures {
         self.inner
@@ -36928,34 +33982,33 @@ impl PhysicalDeviceDepthClipEnableFeatur
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceDepthClipEnableFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDepthClipEnableFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDepthClipEnableFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceDepthClipEnableFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
-    pub fn depth_clip_enable(
-        mut self,
-        depth_clip_enable: bool,
-    ) -> PhysicalDeviceDepthClipEnableFeaturesEXTBuilder<'a> {
+    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
         self.inner.depth_clip_enable = depth_clip_enable.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDepthClipEnableFeaturesEXT {
         self.inner
@@ -37008,27 +34061,21 @@ impl<'a> ::std::ops::Deref for PipelineR
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineRasterizationDepthClipStateCreateFlagsEXT,
-    ) -> PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn depth_clip_enable(
-        mut self,
-        depth_clip_enable: bool,
-    ) -> PipelineRasterizationDepthClipStateCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineRasterizationDepthClipStateCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn depth_clip_enable(mut self, depth_clip_enable: bool) -> Self {
         self.inner.depth_clip_enable = depth_clip_enable.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRasterizationDepthClipStateCreateInfoEXT {
         self.inner
@@ -37078,27 +34125,21 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
-    pub fn heap_budget(
-        mut self,
-        heap_budget: [DeviceSize; MAX_MEMORY_HEAPS],
-    ) -> PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
+    pub fn heap_budget(mut self, heap_budget: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
         self.inner.heap_budget = heap_budget;
         self
     }
-    pub fn heap_usage(
-        mut self,
-        heap_usage: [DeviceSize; MAX_MEMORY_HEAPS],
-    ) -> PhysicalDeviceMemoryBudgetPropertiesEXTBuilder<'a> {
+    pub fn heap_usage(mut self, heap_usage: [DeviceSize; MAX_MEMORY_HEAPS]) -> Self {
         self.inner.heap_usage = heap_usage;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMemoryBudgetPropertiesEXT {
         self.inner
@@ -37129,34 +34170,33 @@ impl PhysicalDeviceMemoryPriorityFeature
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceMemoryPriorityFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMemoryPriorityFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMemoryPriorityFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceMemoryPriorityFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
-    pub fn memory_priority(
-        mut self,
-        memory_priority: bool,
-    ) -> PhysicalDeviceMemoryPriorityFeaturesEXTBuilder<'a> {
+    pub fn memory_priority(mut self, memory_priority: bool) -> Self {
         self.inner.memory_priority = memory_priority.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMemoryPriorityFeaturesEXT {
         self.inner
@@ -37201,17 +34241,17 @@ impl<'a> ::std::ops::Deref for MemoryPri
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryPriorityAllocateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryPriorityAllocateInfoEXTBuilder<'a> {
-    pub fn priority(mut self, priority: f32) -> MemoryPriorityAllocateInfoEXTBuilder<'a> {
+    pub fn priority(mut self, priority: f32) -> Self {
         self.inner.priority = priority;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryPriorityAllocateInfoEXT {
         self.inner
@@ -37246,49 +34286,51 @@ impl PhysicalDeviceBufferDeviceAddressFe
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
     inner: PhysicalDeviceBufferDeviceAddressFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
     type Target = PhysicalDeviceBufferDeviceAddressFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
-    pub fn buffer_device_address(
-        mut self,
-        buffer_device_address: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
+    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
         self.inner.buffer_device_address = buffer_device_address.into();
         self
     }
     pub fn buffer_device_address_capture_replay(
         mut self,
         buffer_device_address_capture_replay: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_capture_replay =
             buffer_device_address_capture_replay.into();
         self
     }
     pub fn buffer_device_address_multi_device(
         mut self,
         buffer_device_address_multi_device: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceBufferDeviceAddressFeatures {
         self.inner
@@ -37323,49 +34365,51 @@ impl PhysicalDeviceBufferDeviceAddressFe
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceBufferDeviceAddressFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceBufferDeviceAddressFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
-    pub fn buffer_device_address(
-        mut self,
-        buffer_device_address: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
+    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
         self.inner.buffer_device_address = buffer_device_address.into();
         self
     }
     pub fn buffer_device_address_capture_replay(
         mut self,
         buffer_device_address_capture_replay: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_capture_replay =
             buffer_device_address_capture_replay.into();
         self
     }
     pub fn buffer_device_address_multi_device(
         mut self,
         buffer_device_address_multi_device: bool,
-    ) -> PhysicalDeviceBufferDeviceAddressFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceBufferDeviceAddressFeaturesEXT {
         self.inner
@@ -37396,50 +34440,32 @@ impl BufferDeviceAddressInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct BufferDeviceAddressInfoBuilder<'a> {
     inner: BufferDeviceAddressInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBufferDeviceAddressInfo {}
 impl<'a> ::std::ops::Deref for BufferDeviceAddressInfoBuilder<'a> {
     type Target = BufferDeviceAddressInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferDeviceAddressInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferDeviceAddressInfoBuilder<'a> {
-    pub fn buffer(mut self, buffer: Buffer) -> BufferDeviceAddressInfoBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferDeviceAddressInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferDeviceAddressInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferDeviceAddressInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -37481,20 +34507,17 @@ impl<'a> ::std::ops::Deref for BufferOpa
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
-    pub fn opaque_capture_address(
-        mut self,
-        opaque_capture_address: u64,
-    ) -> BufferOpaqueCaptureAddressCreateInfoBuilder<'a> {
+    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
         self.inner.opaque_capture_address = opaque_capture_address;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferOpaqueCaptureAddressCreateInfo {
         self.inner
@@ -37539,20 +34562,17 @@ impl<'a> ::std::ops::Deref for BufferDev
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferDeviceAddressCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferDeviceAddressCreateInfoEXTBuilder<'a> {
-    pub fn device_address(
-        mut self,
-        device_address: DeviceAddress,
-    ) -> BufferDeviceAddressCreateInfoEXTBuilder<'a> {
+    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
         self.inner.device_address = device_address;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferDeviceAddressCreateInfoEXT {
         self.inner
@@ -37600,20 +34620,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
-    pub fn image_view_type(
-        mut self,
-        image_view_type: ImageViewType,
-    ) -> PhysicalDeviceImageViewImageFormatInfoEXTBuilder<'a> {
+    pub fn image_view_type(mut self, image_view_type: ImageViewType) -> Self {
         self.inner.image_view_type = image_view_type;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceImageViewImageFormatInfoEXT {
         self.inner
@@ -37663,27 +34680,21 @@ impl<'a> ::std::ops::Deref for FilterCub
     }
 }
 impl<'a> ::std::ops::DerefMut for FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
-    pub fn filter_cubic(
-        mut self,
-        filter_cubic: bool,
-    ) -> FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
+    pub fn filter_cubic(mut self, filter_cubic: bool) -> Self {
         self.inner.filter_cubic = filter_cubic.into();
         self
     }
-    pub fn filter_cubic_minmax(
-        mut self,
-        filter_cubic_minmax: bool,
-    ) -> FilterCubicImageViewImageFormatPropertiesEXTBuilder<'a> {
+    pub fn filter_cubic_minmax(mut self, filter_cubic_minmax: bool) -> Self {
         self.inner.filter_cubic_minmax = filter_cubic_minmax.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FilterCubicImageViewImageFormatPropertiesEXT {
         self.inner
@@ -37714,34 +34725,36 @@ impl PhysicalDeviceImagelessFramebufferF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
     inner: PhysicalDeviceImagelessFramebufferFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImagelessFramebufferFeatures {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImagelessFramebufferFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
     type Target = PhysicalDeviceImagelessFramebufferFeatures;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
-    pub fn imageless_framebuffer(
-        mut self,
-        imageless_framebuffer: bool,
-    ) -> PhysicalDeviceImagelessFramebufferFeaturesBuilder<'a> {
+    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
         self.inner.imageless_framebuffer = imageless_framebuffer.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceImagelessFramebufferFeatures {
         self.inner
@@ -37791,17 +34804,17 @@ impl<'a> ::std::ops::DerefMut for Frameb
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FramebufferAttachmentsCreateInfoBuilder<'a> {
     pub fn attachment_image_infos(
         mut self,
         attachment_image_infos: &'a [FramebufferAttachmentImageInfo],
-    ) -> FramebufferAttachmentsCreateInfoBuilder<'a> {
+    ) -> Self {
         self.inner.attachment_image_info_count = attachment_image_infos.len() as _;
         self.inner.p_attachment_image_infos = attachment_image_infos.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FramebufferAttachmentsCreateInfo {
@@ -37845,74 +34858,53 @@ impl FramebufferAttachmentImageInfo {
         }
     }
 }
 #[repr(transparent)]
 pub struct FramebufferAttachmentImageInfoBuilder<'a> {
     inner: FramebufferAttachmentImageInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsFramebufferAttachmentImageInfo {}
 impl<'a> ::std::ops::Deref for FramebufferAttachmentImageInfoBuilder<'a> {
     type Target = FramebufferAttachmentImageInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for FramebufferAttachmentImageInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FramebufferAttachmentImageInfoBuilder<'a> {
-    pub fn flags(mut self, flags: ImageCreateFlags) -> FramebufferAttachmentImageInfoBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn usage(mut self, usage: ImageUsageFlags) -> FramebufferAttachmentImageInfoBuilder<'a> {
+    pub fn flags(mut self, flags: ImageCreateFlags) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn usage(mut self, usage: ImageUsageFlags) -> Self {
         self.inner.usage = usage;
         self
     }
-    pub fn width(mut self, width: u32) -> FramebufferAttachmentImageInfoBuilder<'a> {
+    pub fn width(mut self, width: u32) -> Self {
         self.inner.width = width;
         self
     }
-    pub fn height(mut self, height: u32) -> FramebufferAttachmentImageInfoBuilder<'a> {
+    pub fn height(mut self, height: u32) -> Self {
         self.inner.height = height;
         self
     }
-    pub fn layer_count(mut self, layer_count: u32) -> FramebufferAttachmentImageInfoBuilder<'a> {
+    pub fn layer_count(mut self, layer_count: u32) -> Self {
         self.inner.layer_count = layer_count;
         self
     }
-    pub fn view_formats(
-        mut self,
-        view_formats: &'a [Format],
-    ) -> FramebufferAttachmentImageInfoBuilder<'a> {
+    pub fn view_formats(mut self, view_formats: &'a [Format]) -> Self {
         self.inner.view_format_count = view_formats.len() as _;
         self.inner.p_view_formats = view_formats.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFramebufferAttachmentImageInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> FramebufferAttachmentImageInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FramebufferAttachmentImageInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -37956,20 +34948,17 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassAttachmentBeginInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassAttachmentBeginInfoBuilder<'a> {
-    pub fn attachments(
-        mut self,
-        attachments: &'a [ImageView],
-    ) -> RenderPassAttachmentBeginInfoBuilder<'a> {
+    pub fn attachments(mut self, attachments: &'a [ImageView]) -> Self {
         self.inner.attachment_count = attachments.len() as _;
         self.inner.p_attachments = attachments.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassAttachmentBeginInfo {
@@ -38001,16 +34990,21 @@ impl PhysicalDeviceTextureCompressionAST
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;
     fn deref(&self) -> &Self::Target {
@@ -38018,20 +35012,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'a> {
-    pub fn texture_compression_astc_hdr(
-        mut self,
-        texture_compression_astc_hdr: bool,
-    ) -> PhysicalDeviceTextureCompressionASTCHDRFeaturesEXTBuilder<'a> {
+    pub fn texture_compression_astc_hdr(mut self, texture_compression_astc_hdr: bool) -> Self {
         self.inner.texture_compression_astc_hdr = texture_compression_astc_hdr.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
         self.inner
@@ -38064,41 +35055,43 @@ impl PhysicalDeviceCooperativeMatrixFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceCooperativeMatrixFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCooperativeMatrixFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCooperativeMatrixFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceCooperativeMatrixFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
-    pub fn cooperative_matrix(
-        mut self,
-        cooperative_matrix: bool,
-    ) -> PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
+    pub fn cooperative_matrix(mut self, cooperative_matrix: bool) -> Self {
         self.inner.cooperative_matrix = cooperative_matrix.into();
         self
     }
     pub fn cooperative_matrix_robust_buffer_access(
         mut self,
         cooperative_matrix_robust_buffer_access: bool,
-    ) -> PhysicalDeviceCooperativeMatrixFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.cooperative_matrix_robust_buffer_access =
             cooperative_matrix_robust_buffer_access.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCooperativeMatrixFeaturesNV {
@@ -38150,17 +35143,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
     pub fn cooperative_matrix_supported_stages(
         mut self,
         cooperative_matrix_supported_stages: ShaderStageFlags,
-    ) -> PhysicalDeviceCooperativeMatrixPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.cooperative_matrix_supported_stages = cooperative_matrix_supported_stages;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCooperativeMatrixPropertiesNV {
         self.inner
@@ -38205,78 +35198,60 @@ impl CooperativeMatrixPropertiesNV {
         }
     }
 }
 #[repr(transparent)]
 pub struct CooperativeMatrixPropertiesNVBuilder<'a> {
     inner: CooperativeMatrixPropertiesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCooperativeMatrixPropertiesNV {}
 impl<'a> ::std::ops::Deref for CooperativeMatrixPropertiesNVBuilder<'a> {
     type Target = CooperativeMatrixPropertiesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CooperativeMatrixPropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CooperativeMatrixPropertiesNVBuilder<'a> {
-    pub fn m_size(mut self, m_size: u32) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn m_size(mut self, m_size: u32) -> Self {
         self.inner.m_size = m_size;
         self
     }
-    pub fn n_size(mut self, n_size: u32) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn n_size(mut self, n_size: u32) -> Self {
         self.inner.n_size = n_size;
         self
     }
-    pub fn k_size(mut self, k_size: u32) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn k_size(mut self, k_size: u32) -> Self {
         self.inner.k_size = k_size;
         self
     }
-    pub fn a_type(mut self, a_type: ComponentTypeNV) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn a_type(mut self, a_type: ComponentTypeNV) -> Self {
         self.inner.a_type = a_type;
         self
     }
-    pub fn b_type(mut self, b_type: ComponentTypeNV) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn b_type(mut self, b_type: ComponentTypeNV) -> Self {
         self.inner.b_type = b_type;
         self
     }
-    pub fn c_type(mut self, c_type: ComponentTypeNV) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn c_type(mut self, c_type: ComponentTypeNV) -> Self {
         self.inner.c_type = c_type;
         self
     }
-    pub fn d_type(mut self, d_type: ComponentTypeNV) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn d_type(mut self, d_type: ComponentTypeNV) -> Self {
         self.inner.d_type = d_type;
         self
     }
-    pub fn scope(mut self, scope: ScopeNV) -> CooperativeMatrixPropertiesNVBuilder<'a> {
+    pub fn scope(mut self, scope: ScopeNV) -> Self {
         self.inner.scope = scope;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCooperativeMatrixPropertiesNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> CooperativeMatrixPropertiesNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CooperativeMatrixPropertiesNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -38304,34 +35279,36 @@ impl PhysicalDeviceYcbcrImageArraysFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceYcbcrImageArraysFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcrImageArraysFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceYcbcrImageArraysFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
-    pub fn ycbcr_image_arrays(
-        mut self,
-        ycbcr_image_arrays: bool,
-    ) -> PhysicalDeviceYcbcrImageArraysFeaturesEXTBuilder<'a> {
+    pub fn ycbcr_image_arrays(mut self, ycbcr_image_arrays: bool) -> Self {
         self.inner.ycbcr_image_arrays = ycbcr_image_arrays.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceYcbcrImageArraysFeaturesEXT {
         self.inner
@@ -38366,61 +35343,40 @@ impl ImageViewHandleInfoNVX {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageViewHandleInfoNVXBuilder<'a> {
     inner: ImageViewHandleInfoNVX,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageViewHandleInfoNVX {}
 impl<'a> ::std::ops::Deref for ImageViewHandleInfoNVXBuilder<'a> {
     type Target = ImageViewHandleInfoNVX;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageViewHandleInfoNVXBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageViewHandleInfoNVXBuilder<'a> {
-    pub fn image_view(mut self, image_view: ImageView) -> ImageViewHandleInfoNVXBuilder<'a> {
+    pub fn image_view(mut self, image_view: ImageView) -> Self {
         self.inner.image_view = image_view;
         self
     }
-    pub fn descriptor_type(
-        mut self,
-        descriptor_type: DescriptorType,
-    ) -> ImageViewHandleInfoNVXBuilder<'a> {
+    pub fn descriptor_type(mut self, descriptor_type: DescriptorType) -> Self {
         self.inner.descriptor_type = descriptor_type;
         self
     }
-    pub fn sampler(mut self, sampler: Sampler) -> ImageViewHandleInfoNVXBuilder<'a> {
+    pub fn sampler(mut self, sampler: Sampler) -> Self {
         self.inner.sampler = sampler;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageViewHandleInfoNVX>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageViewHandleInfoNVXBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageViewHandleInfoNVX {
         self.inner
     }
 }
 #[repr(C)]
@@ -38450,57 +35406,36 @@ impl ImageViewAddressPropertiesNVX {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageViewAddressPropertiesNVXBuilder<'a> {
     inner: ImageViewAddressPropertiesNVX,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageViewAddressPropertiesNVX {}
 impl<'a> ::std::ops::Deref for ImageViewAddressPropertiesNVXBuilder<'a> {
     type Target = ImageViewAddressPropertiesNVX;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageViewAddressPropertiesNVXBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageViewAddressPropertiesNVXBuilder<'a> {
-    pub fn device_address(
-        mut self,
-        device_address: DeviceAddress,
-    ) -> ImageViewAddressPropertiesNVXBuilder<'a> {
+    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
         self.inner.device_address = device_address;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> ImageViewAddressPropertiesNVXBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageViewAddressPropertiesNVX>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageViewAddressPropertiesNVXBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageViewAddressPropertiesNVX {
         self.inner
     }
 }
 #[repr(C)]
@@ -38542,17 +35477,17 @@ impl<'a> ::std::ops::Deref for PresentFr
     }
 }
 impl<'a> ::std::ops::DerefMut for PresentFrameTokenGGPBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PresentFrameTokenGGPBuilder<'a> {
-    pub fn frame_token(mut self, frame_token: GgpFrameToken) -> PresentFrameTokenGGPBuilder<'a> {
+    pub fn frame_token(mut self, frame_token: GgpFrameToken) -> Self {
         self.inner.frame_token = frame_token;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PresentFrameTokenGGP {
         self.inner
@@ -38585,24 +35520,21 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineCreationFeedbackEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCreationFeedbackEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCreationFeedbackFlagsEXT,
-    ) -> PipelineCreationFeedbackEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn duration(mut self, duration: u64) -> PipelineCreationFeedbackEXTBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCreationFeedbackFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn duration(mut self, duration: u64) -> Self {
         self.inner.duration = duration;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCreationFeedbackEXT {
         self.inner
@@ -38666,24 +35598,24 @@ impl<'a> ::std::ops::DerefMut for Pipeli
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCreationFeedbackCreateInfoEXTBuilder<'a> {
     pub fn pipeline_creation_feedback(
         mut self,
         pipeline_creation_feedback: &'a mut PipelineCreationFeedbackEXT,
-    ) -> PipelineCreationFeedbackCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.p_pipeline_creation_feedback = pipeline_creation_feedback;
         self
     }
     pub fn pipeline_stage_creation_feedbacks(
         mut self,
         pipeline_stage_creation_feedbacks: &'a mut [PipelineCreationFeedbackEXT],
-    ) -> PipelineCreationFeedbackCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.pipeline_stage_creation_feedback_count =
             pipeline_stage_creation_feedbacks.len() as _;
         self.inner.p_pipeline_stage_creation_feedbacks =
             pipeline_stage_creation_feedbacks.as_mut_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
@@ -38733,20 +35665,17 @@ impl<'a> ::std::ops::Deref for SurfaceFu
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
-    pub fn full_screen_exclusive(
-        mut self,
-        full_screen_exclusive: FullScreenExclusiveEXT,
-    ) -> SurfaceFullScreenExclusiveInfoEXTBuilder<'a> {
+    pub fn full_screen_exclusive(mut self, full_screen_exclusive: FullScreenExclusiveEXT) -> Self {
         self.inner.full_screen_exclusive = full_screen_exclusive;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceFullScreenExclusiveInfoEXT {
         self.inner
@@ -38796,20 +35725,17 @@ impl<'a> ::std::ops::Deref for SurfaceFu
     }
 }
 impl<'a> ::std::ops::DerefMut for SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
-    pub fn hmonitor(
-        mut self,
-        hmonitor: HMONITOR,
-    ) -> SurfaceFullScreenExclusiveWin32InfoEXTBuilder<'a> {
+    pub fn hmonitor(mut self, hmonitor: HMONITOR) -> Self {
         self.inner.hmonitor = hmonitor;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceFullScreenExclusiveWin32InfoEXT {
         self.inner
@@ -38860,17 +35786,17 @@ impl<'a> ::std::ops::DerefMut for Surfac
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
     pub fn full_screen_exclusive_supported(
         mut self,
         full_screen_exclusive_supported: bool,
-    ) -> SurfaceCapabilitiesFullScreenExclusiveEXTBuilder<'a> {
+    ) -> Self {
         self.inner.full_screen_exclusive_supported = full_screen_exclusive_supported.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SurfaceCapabilitiesFullScreenExclusiveEXT {
         self.inner
@@ -38903,16 +35829,21 @@ impl PhysicalDevicePerformanceQueryFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
     inner: PhysicalDevicePerformanceQueryFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePerformanceQueryFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePerformanceQueryFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
     type Target = PhysicalDevicePerformanceQueryFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -38920,24 +35851,24 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
     pub fn performance_counter_query_pools(
         mut self,
         performance_counter_query_pools: bool,
-    ) -> PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.performance_counter_query_pools = performance_counter_query_pools.into();
         self
     }
     pub fn performance_counter_multiple_query_pools(
         mut self,
         performance_counter_multiple_query_pools: bool,
-    ) -> PhysicalDevicePerformanceQueryFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.performance_counter_multiple_query_pools =
             performance_counter_multiple_query_pools.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePerformanceQueryFeaturesKHR {
@@ -38989,43 +35920,43 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
     pub fn allow_command_buffer_query_copies(
         mut self,
         allow_command_buffer_query_copies: bool,
-    ) -> PhysicalDevicePerformanceQueryPropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.allow_command_buffer_query_copies = allow_command_buffer_query_copies.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePerformanceQueryPropertiesKHR {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPerformanceCounterKHR.html>"]
 pub struct PerformanceCounterKHR {
     pub s_type: StructureType,
-    pub p_next: *const c_void,
+    pub p_next: *mut c_void,
     pub unit: PerformanceCounterUnitKHR,
     pub scope: PerformanceCounterScopeKHR,
     pub storage: PerformanceCounterStorageKHR,
     pub uuid: [u8; UUID_SIZE],
 }
 impl ::std::default::Default for PerformanceCounterKHR {
     fn default() -> PerformanceCounterKHR {
         PerformanceCounterKHR {
             s_type: StructureType::PERFORMANCE_COUNTER_KHR,
-            p_next: ::std::ptr::null(),
+            p_next: ::std::ptr::null_mut(),
             unit: PerformanceCounterUnitKHR::default(),
             scope: PerformanceCounterScopeKHR::default(),
             storage: PerformanceCounterStorageKHR::default(),
             uuid: unsafe { ::std::mem::zeroed() },
         }
     }
 }
 impl PerformanceCounterKHR {
@@ -39036,78 +35967,57 @@ impl PerformanceCounterKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceCounterKHRBuilder<'a> {
     inner: PerformanceCounterKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceCounterKHR {}
 impl<'a> ::std::ops::Deref for PerformanceCounterKHRBuilder<'a> {
     type Target = PerformanceCounterKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceCounterKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceCounterKHRBuilder<'a> {
-    pub fn unit(mut self, unit: PerformanceCounterUnitKHR) -> PerformanceCounterKHRBuilder<'a> {
+    pub fn unit(mut self, unit: PerformanceCounterUnitKHR) -> Self {
         self.inner.unit = unit;
         self
     }
-    pub fn scope(mut self, scope: PerformanceCounterScopeKHR) -> PerformanceCounterKHRBuilder<'a> {
+    pub fn scope(mut self, scope: PerformanceCounterScopeKHR) -> Self {
         self.inner.scope = scope;
         self
     }
-    pub fn storage(
-        mut self,
-        storage: PerformanceCounterStorageKHR,
-    ) -> PerformanceCounterKHRBuilder<'a> {
+    pub fn storage(mut self, storage: PerformanceCounterStorageKHR) -> Self {
         self.inner.storage = storage;
         self
     }
-    pub fn uuid(mut self, uuid: [u8; UUID_SIZE]) -> PerformanceCounterKHRBuilder<'a> {
+    pub fn uuid(mut self, uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.uuid = uuid;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceCounterKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceCounterKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceCounterKHR {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPerformanceCounterDescriptionKHR.html>"]
 pub struct PerformanceCounterDescriptionKHR {
     pub s_type: StructureType,
-    pub p_next: *const c_void,
+    pub p_next: *mut c_void,
     pub flags: PerformanceCounterDescriptionFlagsKHR,
     pub name: [c_char; MAX_DESCRIPTION_SIZE],
     pub category: [c_char; MAX_DESCRIPTION_SIZE],
     pub description: [c_char; MAX_DESCRIPTION_SIZE],
 }
 impl fmt::Debug for PerformanceCounterDescriptionKHR {
     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
         fmt.debug_struct("PerformanceCounterDescriptionKHR")
@@ -39125,17 +36035,17 @@ impl fmt::Debug for PerformanceCounterDe
             })
             .finish()
     }
 }
 impl ::std::default::Default for PerformanceCounterDescriptionKHR {
     fn default() -> PerformanceCounterDescriptionKHR {
         PerformanceCounterDescriptionKHR {
             s_type: StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR,
-            p_next: ::std::ptr::null(),
+            p_next: ::std::ptr::null_mut(),
             flags: PerformanceCounterDescriptionFlagsKHR::default(),
             name: unsafe { ::std::mem::zeroed() },
             category: unsafe { ::std::mem::zeroed() },
             description: unsafe { ::std::mem::zeroed() },
         }
     }
 }
 impl PerformanceCounterDescriptionKHR {
@@ -39146,74 +36056,44 @@ impl PerformanceCounterDescriptionKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceCounterDescriptionKHRBuilder<'a> {
     inner: PerformanceCounterDescriptionKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceCounterDescriptionKHR {}
 impl<'a> ::std::ops::Deref for PerformanceCounterDescriptionKHRBuilder<'a> {
     type Target = PerformanceCounterDescriptionKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceCounterDescriptionKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceCounterDescriptionKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PerformanceCounterDescriptionFlagsKHR,
-    ) -> PerformanceCounterDescriptionKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn name(
-        mut self,
-        name: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PerformanceCounterDescriptionKHRBuilder<'a> {
+    pub fn flags(mut self, flags: PerformanceCounterDescriptionFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.name = name;
         self
     }
-    pub fn category(
-        mut self,
-        category: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PerformanceCounterDescriptionKHRBuilder<'a> {
+    pub fn category(mut self, category: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.category = category;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PerformanceCounterDescriptionKHRBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceCounterDescriptionKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceCounterDescriptionKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceCounterDescriptionKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -39259,27 +36139,21 @@ impl<'a> ::std::ops::Deref for QueryPool
     }
 }
 impl<'a> ::std::ops::DerefMut for QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
-    pub fn queue_family_index(
-        mut self,
-        queue_family_index: u32,
-    ) -> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
+    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
         self.inner.queue_family_index = queue_family_index;
         self
     }
-    pub fn counter_indices(
-        mut self,
-        counter_indices: &'a [u32],
-    ) -> QueryPoolPerformanceCreateInfoKHRBuilder<'a> {
+    pub fn counter_indices(mut self, counter_indices: &'a [u32]) -> Self {
         self.inner.counter_index_count = counter_indices.len() as _;
         self.inner.p_counter_indices = counter_indices.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> QueryPoolPerformanceCreateInfoKHR {
@@ -39329,57 +36203,36 @@ impl AcquireProfilingLockInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct AcquireProfilingLockInfoKHRBuilder<'a> {
     inner: AcquireProfilingLockInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAcquireProfilingLockInfoKHR {}
 impl<'a> ::std::ops::Deref for AcquireProfilingLockInfoKHRBuilder<'a> {
     type Target = AcquireProfilingLockInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AcquireProfilingLockInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AcquireProfilingLockInfoKHRBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: AcquireProfilingLockFlagsKHR,
-    ) -> AcquireProfilingLockInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn timeout(mut self, timeout: u64) -> AcquireProfilingLockInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: AcquireProfilingLockFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn timeout(mut self, timeout: u64) -> Self {
         self.inner.timeout = timeout;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAcquireProfilingLockInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AcquireProfilingLockInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AcquireProfilingLockInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -39409,32 +36262,31 @@ impl PerformanceQuerySubmitInfoKHR {
 }
 #[repr(transparent)]
 pub struct PerformanceQuerySubmitInfoKHRBuilder<'a> {
     inner: PerformanceQuerySubmitInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
 unsafe impl ExtendsSubmitInfo for PerformanceQuerySubmitInfoKHRBuilder<'_> {}
 unsafe impl ExtendsSubmitInfo for PerformanceQuerySubmitInfoKHR {}
+unsafe impl ExtendsSubmitInfo2KHR for PerformanceQuerySubmitInfoKHRBuilder<'_> {}
+unsafe impl ExtendsSubmitInfo2KHR for PerformanceQuerySubmitInfoKHR {}
 impl<'a> ::std::ops::Deref for PerformanceQuerySubmitInfoKHRBuilder<'a> {
     type Target = PerformanceQuerySubmitInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceQuerySubmitInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceQuerySubmitInfoKHRBuilder<'a> {
-    pub fn counter_pass_index(
-        mut self,
-        counter_pass_index: u32,
-    ) -> PerformanceQuerySubmitInfoKHRBuilder<'a> {
+    pub fn counter_pass_index(mut self, counter_pass_index: u32) -> Self {
         self.inner.counter_pass_index = counter_pass_index;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceQuerySubmitInfoKHR {
         self.inner
@@ -39465,51 +36317,30 @@ impl HeadlessSurfaceCreateInfoEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct HeadlessSurfaceCreateInfoEXTBuilder<'a> {
     inner: HeadlessSurfaceCreateInfoEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsHeadlessSurfaceCreateInfoEXT {}
 impl<'a> ::std::ops::Deref for HeadlessSurfaceCreateInfoEXTBuilder<'a> {
     type Target = HeadlessSurfaceCreateInfoEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for HeadlessSurfaceCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> HeadlessSurfaceCreateInfoEXTBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: HeadlessSurfaceCreateFlagsEXT,
-    ) -> HeadlessSurfaceCreateInfoEXTBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsHeadlessSurfaceCreateInfoEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> HeadlessSurfaceCreateInfoEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: HeadlessSurfaceCreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> HeadlessSurfaceCreateInfoEXT {
         self.inner
     }
@@ -39539,34 +36370,36 @@ impl PhysicalDeviceCoverageReductionMode
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceCoverageReductionModeFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoverageReductionModeFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoverageReductionModeFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceCoverageReductionModeFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
-    pub fn coverage_reduction_mode(
-        mut self,
-        coverage_reduction_mode: bool,
-    ) -> PhysicalDeviceCoverageReductionModeFeaturesNVBuilder<'a> {
+    pub fn coverage_reduction_mode(mut self, coverage_reduction_mode: bool) -> Self {
         self.inner.coverage_reduction_mode = coverage_reduction_mode.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCoverageReductionModeFeaturesNV {
         self.inner
@@ -39619,27 +36452,24 @@ impl<'a> ::std::ops::Deref for PipelineC
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: PipelineCoverageReductionStateCreateFlagsNV,
-    ) -> PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: PipelineCoverageReductionStateCreateFlagsNV) -> Self {
         self.inner.flags = flags;
         self
     }
     pub fn coverage_reduction_mode(
         mut self,
         coverage_reduction_mode: CoverageReductionModeNV,
-    ) -> PipelineCoverageReductionStateCreateInfoNVBuilder<'a> {
+    ) -> Self {
         self.inner.coverage_reduction_mode = coverage_reduction_mode;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCoverageReductionStateCreateInfoNV {
         self.inner
@@ -39676,74 +36506,47 @@ impl FramebufferMixedSamplesCombinationN
         }
     }
 }
 #[repr(transparent)]
 pub struct FramebufferMixedSamplesCombinationNVBuilder<'a> {
     inner: FramebufferMixedSamplesCombinationNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsFramebufferMixedSamplesCombinationNV {}
 impl<'a> ::std::ops::Deref for FramebufferMixedSamplesCombinationNVBuilder<'a> {
     type Target = FramebufferMixedSamplesCombinationNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for FramebufferMixedSamplesCombinationNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FramebufferMixedSamplesCombinationNVBuilder<'a> {
     pub fn coverage_reduction_mode(
         mut self,
         coverage_reduction_mode: CoverageReductionModeNV,
-    ) -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
+    ) -> Self {
         self.inner.coverage_reduction_mode = coverage_reduction_mode;
         self
     }
-    pub fn rasterization_samples(
-        mut self,
-        rasterization_samples: SampleCountFlags,
-    ) -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
+    pub fn rasterization_samples(mut self, rasterization_samples: SampleCountFlags) -> Self {
         self.inner.rasterization_samples = rasterization_samples;
         self
     }
-    pub fn depth_stencil_samples(
-        mut self,
-        depth_stencil_samples: SampleCountFlags,
-    ) -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
+    pub fn depth_stencil_samples(mut self, depth_stencil_samples: SampleCountFlags) -> Self {
         self.inner.depth_stencil_samples = depth_stencil_samples;
         self
     }
-    pub fn color_samples(
-        mut self,
-        color_samples: SampleCountFlags,
-    ) -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
+    pub fn color_samples(mut self, color_samples: SampleCountFlags) -> Self {
         self.inner.color_samples = color_samples;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsFramebufferMixedSamplesCombinationNV>(
-        mut self,
-        next: &'a mut T,
-    ) -> FramebufferMixedSamplesCombinationNVBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FramebufferMixedSamplesCombinationNV {
         self.inner
     }
 }
 #[repr(C)]
@@ -39771,16 +36574,21 @@ impl PhysicalDeviceShaderIntegerFunction
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
     inner: PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
     type Target = PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
     fn deref(&self) -> &Self::Target {
@@ -39788,20 +36596,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
-    pub fn shader_integer_functions2(
-        mut self,
-        shader_integer_functions2: bool,
-    ) -> PhysicalDeviceShaderIntegerFunctions2FeaturesINTELBuilder<'a> {
+    pub fn shader_integer_functions2(mut self, shader_integer_functions2: bool) -> Self {
         self.inner.shader_integer_functions2 = shader_integer_functions2.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
         self.inner
@@ -39857,21 +36662,21 @@ impl<'a> ::std::ops::Deref for Performan
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceValueINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceValueINTELBuilder<'a> {
-    pub fn ty(mut self, ty: PerformanceValueTypeINTEL) -> PerformanceValueINTELBuilder<'a> {
+    pub fn ty(mut self, ty: PerformanceValueTypeINTEL) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn data(mut self, data: PerformanceValueDataINTEL) -> PerformanceValueINTELBuilder<'a> {
+    pub fn data(mut self, data: PerformanceValueDataINTEL) -> Self {
         self.inner.data = data;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceValueINTEL {
         self.inner
@@ -39902,53 +36707,32 @@ impl InitializePerformanceApiInfoINTEL {
         }
     }
 }
 #[repr(transparent)]
 pub struct InitializePerformanceApiInfoINTELBuilder<'a> {
     inner: InitializePerformanceApiInfoINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsInitializePerformanceApiInfoINTEL {}
 impl<'a> ::std::ops::Deref for InitializePerformanceApiInfoINTELBuilder<'a> {
     type Target = InitializePerformanceApiInfoINTEL;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for InitializePerformanceApiInfoINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> InitializePerformanceApiInfoINTELBuilder<'a> {
-    pub fn user_data(
-        mut self,
-        user_data: *mut c_void,
-    ) -> InitializePerformanceApiInfoINTELBuilder<'a> {
+    pub fn user_data(mut self, user_data: *mut c_void) -> Self {
         self.inner.p_user_data = user_data;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsInitializePerformanceApiInfoINTEL>(
-        mut self,
-        next: &'a mut T,
-    ) -> InitializePerformanceApiInfoINTELBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> InitializePerformanceApiInfoINTEL {
         self.inner
     }
 }
 #[repr(C)]
@@ -39993,17 +36777,17 @@ impl<'a> ::std::ops::DerefMut for QueryP
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
     pub fn performance_counters_sampling(
         mut self,
         performance_counters_sampling: QueryPoolSamplingModeINTEL,
-    ) -> QueryPoolPerformanceQueryCreateInfoINTELBuilder<'a> {
+    ) -> Self {
         self.inner.performance_counters_sampling = performance_counters_sampling;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> QueryPoolPerformanceQueryCreateInfoINTEL {
         self.inner
@@ -40034,50 +36818,32 @@ impl PerformanceMarkerInfoINTEL {
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceMarkerInfoINTELBuilder<'a> {
     inner: PerformanceMarkerInfoINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceMarkerInfoINTEL {}
 impl<'a> ::std::ops::Deref for PerformanceMarkerInfoINTELBuilder<'a> {
     type Target = PerformanceMarkerInfoINTEL;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceMarkerInfoINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceMarkerInfoINTELBuilder<'a> {
-    pub fn marker(mut self, marker: u64) -> PerformanceMarkerInfoINTELBuilder<'a> {
+    pub fn marker(mut self, marker: u64) -> Self {
         self.inner.marker = marker;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceMarkerInfoINTEL>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceMarkerInfoINTELBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceMarkerInfoINTEL {
         self.inner
     }
 }
 #[repr(C)]
@@ -40105,50 +36871,32 @@ impl PerformanceStreamMarkerInfoINTEL {
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceStreamMarkerInfoINTELBuilder<'a> {
     inner: PerformanceStreamMarkerInfoINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceStreamMarkerInfoINTEL {}
 impl<'a> ::std::ops::Deref for PerformanceStreamMarkerInfoINTELBuilder<'a> {
     type Target = PerformanceStreamMarkerInfoINTEL;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceStreamMarkerInfoINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceStreamMarkerInfoINTELBuilder<'a> {
-    pub fn marker(mut self, marker: u32) -> PerformanceStreamMarkerInfoINTELBuilder<'a> {
+    pub fn marker(mut self, marker: u32) -> Self {
         self.inner.marker = marker;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceStreamMarkerInfoINTEL>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceStreamMarkerInfoINTELBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceStreamMarkerInfoINTEL {
         self.inner
     }
 }
 #[repr(C)]
@@ -40180,61 +36928,40 @@ impl PerformanceOverrideInfoINTEL {
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceOverrideInfoINTELBuilder<'a> {
     inner: PerformanceOverrideInfoINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceOverrideInfoINTEL {}
 impl<'a> ::std::ops::Deref for PerformanceOverrideInfoINTELBuilder<'a> {
     type Target = PerformanceOverrideInfoINTEL;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceOverrideInfoINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceOverrideInfoINTELBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: PerformanceOverrideTypeINTEL,
-    ) -> PerformanceOverrideInfoINTELBuilder<'a> {
+    pub fn ty(mut self, ty: PerformanceOverrideTypeINTEL) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn enable(mut self, enable: bool) -> PerformanceOverrideInfoINTELBuilder<'a> {
+    pub fn enable(mut self, enable: bool) -> Self {
         self.inner.enable = enable.into();
         self
     }
-    pub fn parameter(mut self, parameter: u64) -> PerformanceOverrideInfoINTELBuilder<'a> {
+    pub fn parameter(mut self, parameter: u64) -> Self {
         self.inner.parameter = parameter;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceOverrideInfoINTEL>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceOverrideInfoINTELBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceOverrideInfoINTEL {
         self.inner
     }
 }
 #[repr(C)]
@@ -40262,53 +36989,32 @@ impl PerformanceConfigurationAcquireInfo
         }
     }
 }
 #[repr(transparent)]
 pub struct PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
     inner: PerformanceConfigurationAcquireInfoINTEL,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPerformanceConfigurationAcquireInfoINTEL {}
 impl<'a> ::std::ops::Deref for PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
     type Target = PerformanceConfigurationAcquireInfoINTEL;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: PerformanceConfigurationTypeINTEL,
-    ) -> PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
+    pub fn ty(mut self, ty: PerformanceConfigurationTypeINTEL) -> Self {
         self.inner.ty = ty;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPerformanceConfigurationAcquireInfoINTEL>(
-        mut self,
-        next: &'a mut T,
-    ) -> PerformanceConfigurationAcquireInfoINTELBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PerformanceConfigurationAcquireInfoINTEL {
         self.inner
     }
 }
 #[repr(C)]
@@ -40338,41 +37044,37 @@ impl PhysicalDeviceShaderClockFeaturesKH
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceShaderClockFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderClockFeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderClockFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderClockFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderClockFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceShaderClockFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
-    pub fn shader_subgroup_clock(
-        mut self,
-        shader_subgroup_clock: bool,
-    ) -> PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
+    pub fn shader_subgroup_clock(mut self, shader_subgroup_clock: bool) -> Self {
         self.inner.shader_subgroup_clock = shader_subgroup_clock.into();
         self
     }
-    pub fn shader_device_clock(
-        mut self,
-        shader_device_clock: bool,
-    ) -> PhysicalDeviceShaderClockFeaturesKHRBuilder<'a> {
+    pub fn shader_device_clock(mut self, shader_device_clock: bool) -> Self {
         self.inner.shader_device_clock = shader_device_clock.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderClockFeaturesKHR {
         self.inner
@@ -40403,34 +37105,33 @@ impl PhysicalDeviceIndexTypeUint8Feature
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceIndexTypeUint8FeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceIndexTypeUint8FeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceIndexTypeUint8FeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
-    pub fn index_type_uint8(
-        mut self,
-        index_type_uint8: bool,
-    ) -> PhysicalDeviceIndexTypeUint8FeaturesEXTBuilder<'a> {
+    pub fn index_type_uint8(mut self, index_type_uint8: bool) -> Self {
         self.inner.index_type_uint8 = index_type_uint8.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceIndexTypeUint8FeaturesEXT {
         self.inner
@@ -40480,27 +37181,21 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
-    pub fn shader_sm_count(
-        mut self,
-        shader_sm_count: u32,
-    ) -> PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
+    pub fn shader_sm_count(mut self, shader_sm_count: u32) -> Self {
         self.inner.shader_sm_count = shader_sm_count;
         self
     }
-    pub fn shader_warps_per_sm(
-        mut self,
-        shader_warps_per_sm: u32,
-    ) -> PhysicalDeviceShaderSMBuiltinsPropertiesNVBuilder<'a> {
+    pub fn shader_warps_per_sm(mut self, shader_warps_per_sm: u32) -> Self {
         self.inner.shader_warps_per_sm = shader_warps_per_sm;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderSMBuiltinsPropertiesNV {
         self.inner
@@ -40531,34 +37226,33 @@ impl PhysicalDeviceShaderSMBuiltinsFeatu
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceShaderSMBuiltinsFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSMBuiltinsFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceShaderSMBuiltinsFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
-    pub fn shader_sm_builtins(
-        mut self,
-        shader_sm_builtins: bool,
-    ) -> PhysicalDeviceShaderSMBuiltinsFeaturesNVBuilder<'a> {
+    pub fn shader_sm_builtins(mut self, shader_sm_builtins: bool) -> Self {
         self.inner.shader_sm_builtins = shader_sm_builtins.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderSMBuiltinsFeaturesNV {
         self.inner
@@ -40593,16 +37287,21 @@ impl PhysicalDeviceFragmentShaderInterlo
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceFragmentShaderInterlockFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShaderInterlockFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceFragmentShaderInterlockFeaturesEXT;
     fn deref(&self) -> &Self::Target {
@@ -40613,31 +37312,31 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
     pub fn fragment_shader_sample_interlock(
         mut self,
         fragment_shader_sample_interlock: bool,
-    ) -> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shader_sample_interlock = fragment_shader_sample_interlock.into();
         self
     }
     pub fn fragment_shader_pixel_interlock(
         mut self,
         fragment_shader_pixel_interlock: bool,
-    ) -> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shader_pixel_interlock = fragment_shader_pixel_interlock.into();
         self
     }
     pub fn fragment_shader_shading_rate_interlock(
         mut self,
         fragment_shader_shading_rate_interlock: bool,
-    ) -> PhysicalDeviceFragmentShaderInterlockFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shader_shading_rate_interlock =
             fragment_shader_shading_rate_interlock.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
@@ -40669,16 +37368,21 @@ impl PhysicalDeviceSeparateDepthStencilL
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
     inner: PhysicalDeviceSeparateDepthStencilLayoutsFeatures,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSeparateDepthStencilLayoutsFeatures {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
     type Target = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
     fn deref(&self) -> &Self::Target {
@@ -40686,20 +37390,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
-    pub fn separate_depth_stencil_layouts(
-        mut self,
-        separate_depth_stencil_layouts: bool,
-    ) -> PhysicalDeviceSeparateDepthStencilLayoutsFeaturesBuilder<'a> {
+    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
         self.inner.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
         self.inner
@@ -40744,20 +37445,17 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentReferenceStencilLayoutBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentReferenceStencilLayoutBuilder<'a> {
-    pub fn stencil_layout(
-        mut self,
-        stencil_layout: ImageLayout,
-    ) -> AttachmentReferenceStencilLayoutBuilder<'a> {
+    pub fn stencil_layout(mut self, stencil_layout: ImageLayout) -> Self {
         self.inner.stencil_layout = stencil_layout;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AttachmentReferenceStencilLayout {
         self.inner
@@ -40804,27 +37502,21 @@ impl<'a> ::std::ops::Deref for Attachmen
     }
 }
 impl<'a> ::std::ops::DerefMut for AttachmentDescriptionStencilLayoutBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AttachmentDescriptionStencilLayoutBuilder<'a> {
-    pub fn stencil_initial_layout(
-        mut self,
-        stencil_initial_layout: ImageLayout,
-    ) -> AttachmentDescriptionStencilLayoutBuilder<'a> {
+    pub fn stencil_initial_layout(mut self, stencil_initial_layout: ImageLayout) -> Self {
         self.inner.stencil_initial_layout = stencil_initial_layout;
         self
     }
-    pub fn stencil_final_layout(
-        mut self,
-        stencil_final_layout: ImageLayout,
-    ) -> AttachmentDescriptionStencilLayoutBuilder<'a> {
+    pub fn stencil_final_layout(mut self, stencil_final_layout: ImageLayout) -> Self {
         self.inner.stencil_final_layout = stencil_final_layout;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AttachmentDescriptionStencilLayout {
         self.inner
@@ -40855,16 +37547,24 @@ impl PhysicalDevicePipelineExecutablePro
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
     inner: PhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
     type Target = PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
     fn deref(&self) -> &Self::Target {
@@ -40872,20 +37572,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
-    pub fn pipeline_executable_info(
-        mut self,
-        pipeline_executable_info: bool,
-    ) -> PhysicalDevicePipelineExecutablePropertiesFeaturesKHRBuilder<'a> {
+    pub fn pipeline_executable_info(mut self, pipeline_executable_info: bool) -> Self {
         self.inner.pipeline_executable_info = pipeline_executable_info.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
         self.inner
@@ -40916,50 +37613,32 @@ impl PipelineInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineInfoKHRBuilder<'a> {
     inner: PipelineInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineInfoKHR {}
 impl<'a> ::std::ops::Deref for PipelineInfoKHRBuilder<'a> {
     type Target = PipelineInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineInfoKHRBuilder<'a> {
-    pub fn pipeline(mut self, pipeline: Pipeline) -> PipelineInfoKHRBuilder<'a> {
+    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
         self.inner.pipeline = pipeline;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -41009,74 +37688,44 @@ impl PipelineExecutablePropertiesKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineExecutablePropertiesKHRBuilder<'a> {
     inner: PipelineExecutablePropertiesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineExecutablePropertiesKHR {}
 impl<'a> ::std::ops::Deref for PipelineExecutablePropertiesKHRBuilder<'a> {
     type Target = PipelineExecutablePropertiesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineExecutablePropertiesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineExecutablePropertiesKHRBuilder<'a> {
-    pub fn stages(
-        mut self,
-        stages: ShaderStageFlags,
-    ) -> PipelineExecutablePropertiesKHRBuilder<'a> {
+    pub fn stages(mut self, stages: ShaderStageFlags) -> Self {
         self.inner.stages = stages;
         self
     }
-    pub fn name(
-        mut self,
-        name: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutablePropertiesKHRBuilder<'a> {
+    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.name = name;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutablePropertiesKHRBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
-    pub fn subgroup_size(
-        mut self,
-        subgroup_size: u32,
-    ) -> PipelineExecutablePropertiesKHRBuilder<'a> {
+    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
         self.inner.subgroup_size = subgroup_size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineExecutablePropertiesKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineExecutablePropertiesKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineExecutablePropertiesKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -41106,57 +37755,36 @@ impl PipelineExecutableInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineExecutableInfoKHRBuilder<'a> {
     inner: PipelineExecutableInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineExecutableInfoKHR {}
 impl<'a> ::std::ops::Deref for PipelineExecutableInfoKHRBuilder<'a> {
     type Target = PipelineExecutableInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineExecutableInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineExecutableInfoKHRBuilder<'a> {
-    pub fn pipeline(mut self, pipeline: Pipeline) -> PipelineExecutableInfoKHRBuilder<'a> {
+    pub fn pipeline(mut self, pipeline: Pipeline) -> Self {
         self.inner.pipeline = pipeline;
         self
     }
-    pub fn executable_index(
-        mut self,
-        executable_index: u32,
-    ) -> PipelineExecutableInfoKHRBuilder<'a> {
+    pub fn executable_index(mut self, executable_index: u32) -> Self {
         self.inner.executable_index = executable_index;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineExecutableInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineExecutableInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineExecutableInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -41220,74 +37848,44 @@ impl PipelineExecutableStatisticKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineExecutableStatisticKHRBuilder<'a> {
     inner: PipelineExecutableStatisticKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineExecutableStatisticKHR {}
 impl<'a> ::std::ops::Deref for PipelineExecutableStatisticKHRBuilder<'a> {
     type Target = PipelineExecutableStatisticKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineExecutableStatisticKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineExecutableStatisticKHRBuilder<'a> {
-    pub fn name(
-        mut self,
-        name: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutableStatisticKHRBuilder<'a> {
+    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.name = name;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutableStatisticKHRBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
-    pub fn format(
-        mut self,
-        format: PipelineExecutableStatisticFormatKHR,
-    ) -> PipelineExecutableStatisticKHRBuilder<'a> {
+    pub fn format(mut self, format: PipelineExecutableStatisticFormatKHR) -> Self {
         self.inner.format = format;
         self
     }
-    pub fn value(
-        mut self,
-        value: PipelineExecutableStatisticValueKHR,
-    ) -> PipelineExecutableStatisticKHRBuilder<'a> {
+    pub fn value(mut self, value: PipelineExecutableStatisticValueKHR) -> Self {
         self.inner.value = value;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineExecutableStatisticKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineExecutableStatisticKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineExecutableStatisticKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -41340,75 +37938,45 @@ impl PipelineExecutableInternalRepresent
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineExecutableInternalRepresentationKHRBuilder<'a> {
     inner: PipelineExecutableInternalRepresentationKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineExecutableInternalRepresentationKHR {}
 impl<'a> ::std::ops::Deref for PipelineExecutableInternalRepresentationKHRBuilder<'a> {
     type Target = PipelineExecutableInternalRepresentationKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineExecutableInternalRepresentationKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
-    pub fn name(
-        mut self,
-        name: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
+    pub fn name(mut self, name: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.name = name;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
-    pub fn is_text(
-        mut self,
-        is_text: bool,
-    ) -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
+    pub fn is_text(mut self, is_text: bool) -> Self {
         self.inner.is_text = is_text.into();
         self
     }
-    pub fn data(
-        mut self,
-        data: &'a mut [u8],
-    ) -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
+    pub fn data(mut self, data: &'a mut [u8]) -> Self {
         self.inner.data_size = data.len() as _;
         self.inner.p_data = data.as_mut_ptr() as *mut c_void;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineExecutableInternalRepresentationKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineExecutableInternalRepresentationKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineExecutableInternalRepresentationKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -41436,16 +38004,24 @@ impl PhysicalDeviceShaderDemoteToHelperI
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
     fn deref(&self) -> &Self::Target {
@@ -41458,17 +38034,17 @@ impl<'a> ::std::ops::DerefMut
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'a> {
     pub fn shader_demote_to_helper_invocation(
         mut self,
         shader_demote_to_helper_invocation: bool,
-    ) -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.shader_demote_to_helper_invocation = shader_demote_to_helper_invocation.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
         self.inner
@@ -41499,34 +38075,36 @@ impl PhysicalDeviceTexelBufferAlignmentF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceTexelBufferAlignmentFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceTexelBufferAlignmentFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceTexelBufferAlignmentFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
-    pub fn texel_buffer_alignment(
-        mut self,
-        texel_buffer_alignment: bool,
-    ) -> PhysicalDeviceTexelBufferAlignmentFeaturesEXTBuilder<'a> {
+    pub fn texel_buffer_alignment(mut self, texel_buffer_alignment: bool) -> Self {
         self.inner.texel_buffer_alignment = texel_buffer_alignment.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
         self.inner
@@ -41583,42 +38161,42 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceTexelBufferAlignmentPropertiesEXTBuilder<'a> {
     pub fn storage_texel_buffer_offset_alignment_bytes(
         mut self,
         storage_texel_buffer_offset_alignment_bytes: DeviceSize,
-    ) -> PhysicalDeviceTexelBufferAlignmentPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.storage_texel_buffer_offset_alignment_bytes =
             storage_texel_buffer_offset_alignment_bytes;
         self
     }
     pub fn storage_texel_buffer_offset_single_texel_alignment(
         mut self,
         storage_texel_buffer_offset_single_texel_alignment: bool,
-    ) -> PhysicalDeviceTexelBufferAlignmentPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner
             .storage_texel_buffer_offset_single_texel_alignment =
             storage_texel_buffer_offset_single_texel_alignment.into();
         self
     }
     pub fn uniform_texel_buffer_offset_alignment_bytes(
         mut self,
         uniform_texel_buffer_offset_alignment_bytes: DeviceSize,
-    ) -> PhysicalDeviceTexelBufferAlignmentPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.uniform_texel_buffer_offset_alignment_bytes =
             uniform_texel_buffer_offset_alignment_bytes;
         self
     }
     pub fn uniform_texel_buffer_offset_single_texel_alignment(
         mut self,
         uniform_texel_buffer_offset_single_texel_alignment: bool,
-    ) -> PhysicalDeviceTexelBufferAlignmentPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner
             .uniform_texel_buffer_offset_single_texel_alignment =
             uniform_texel_buffer_offset_single_texel_alignment.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
@@ -41653,41 +38231,40 @@ impl PhysicalDeviceSubgroupSizeControlFe
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceSubgroupSizeControlFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubgroupSizeControlFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubgroupSizeControlFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceSubgroupSizeControlFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
-    pub fn subgroup_size_control(
-        mut self,
-        subgroup_size_control: bool,
-    ) -> PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
+    pub fn subgroup_size_control(mut self, subgroup_size_control: bool) -> Self {
         self.inner.subgroup_size_control = subgroup_size_control.into();
         self
     }
-    pub fn compute_full_subgroups(
-        mut self,
-        compute_full_subgroups: bool,
-    ) -> PhysicalDeviceSubgroupSizeControlFeaturesEXTBuilder<'a> {
+    pub fn compute_full_subgroups(mut self, compute_full_subgroups: bool) -> Self {
         self.inner.compute_full_subgroups = compute_full_subgroups.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSubgroupSizeControlFeaturesEXT {
         self.inner
@@ -41741,41 +38318,32 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
-    pub fn min_subgroup_size(
-        mut self,
-        min_subgroup_size: u32,
-    ) -> PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
+    pub fn min_subgroup_size(mut self, min_subgroup_size: u32) -> Self {
         self.inner.min_subgroup_size = min_subgroup_size;
         self
     }
-    pub fn max_subgroup_size(
-        mut self,
-        max_subgroup_size: u32,
-    ) -> PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
+    pub fn max_subgroup_size(mut self, max_subgroup_size: u32) -> Self {
         self.inner.max_subgroup_size = max_subgroup_size;
         self
     }
-    pub fn max_compute_workgroup_subgroups(
-        mut self,
-        max_compute_workgroup_subgroups: u32,
-    ) -> PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
+    pub fn max_compute_workgroup_subgroups(mut self, max_compute_workgroup_subgroups: u32) -> Self {
         self.inner.max_compute_workgroup_subgroups = max_compute_workgroup_subgroups;
         self
     }
     pub fn required_subgroup_size_stages(
         mut self,
         required_subgroup_size_stages: ShaderStageFlags,
-    ) -> PhysicalDeviceSubgroupSizeControlPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.required_subgroup_size_stages = required_subgroup_size_stages;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceSubgroupSizeControlPropertiesEXT {
         self.inner
@@ -41826,32 +38394,152 @@ impl<'a> ::std::ops::Deref for PipelineS
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineShaderStageRequiredSubgroupSizeCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineShaderStageRequiredSubgroupSizeCreateInfoEXTBuilder<'a> {
-    pub fn required_subgroup_size(
-        mut self,
-        required_subgroup_size: u32,
-    ) -> PipelineShaderStageRequiredSubgroupSizeCreateInfoEXTBuilder<'a> {
+    pub fn required_subgroup_size(mut self, required_subgroup_size: u32) -> Self {
         self.inner.required_subgroup_size = required_subgroup_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubpassShadingPipelineCreateInfoHUAWEI.html>"]
+pub struct SubpassShadingPipelineCreateInfoHUAWEI {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub render_pass: RenderPass,
+    pub subpass: u32,
+}
+impl ::std::default::Default for SubpassShadingPipelineCreateInfoHUAWEI {
+    fn default() -> SubpassShadingPipelineCreateInfoHUAWEI {
+        SubpassShadingPipelineCreateInfoHUAWEI {
+            s_type: StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
+            p_next: ::std::ptr::null_mut(),
+            render_pass: RenderPass::default(),
+            subpass: u32::default(),
+        }
+    }
+}
+impl SubpassShadingPipelineCreateInfoHUAWEI {
+    pub fn builder<'a>() -> SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
+        SubpassShadingPipelineCreateInfoHUAWEIBuilder {
+            inner: SubpassShadingPipelineCreateInfoHUAWEI::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
+    inner: SubpassShadingPipelineCreateInfoHUAWEI,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsComputePipelineCreateInfo for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'_> {}
+unsafe impl ExtendsComputePipelineCreateInfo for SubpassShadingPipelineCreateInfoHUAWEI {}
+impl<'a> ::std::ops::Deref for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
+    type Target = SubpassShadingPipelineCreateInfoHUAWEI;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> SubpassShadingPipelineCreateInfoHUAWEIBuilder<'a> {
+    pub fn render_pass(mut self, render_pass: RenderPass) -> Self {
+        self.inner.render_pass = render_pass;
+        self
+    }
+    pub fn subpass(mut self, subpass: u32) -> Self {
+        self.inner.subpass = subpass;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> SubpassShadingPipelineCreateInfoHUAWEI {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubpassShadingPropertiesHUAWEI.html>"]
+pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub max_subpass_shading_workgroup_size_aspect_ratio: u32,
+}
+impl ::std::default::Default for PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+    fn default() -> PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+        PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
+            p_next: ::std::ptr::null_mut(),
+            max_subpass_shading_workgroup_size_aspect_ratio: u32::default(),
+        }
+    }
+}
+impl PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+    pub fn builder<'a>() -> PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
+        PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder {
+            inner: PhysicalDeviceSubpassShadingPropertiesHUAWEI::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
+    inner: PhysicalDeviceSubpassShadingPropertiesHUAWEI,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceProperties2
+    for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceSubpassShadingPropertiesHUAWEI {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
+    type Target = PhysicalDeviceSubpassShadingPropertiesHUAWEI;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceSubpassShadingPropertiesHUAWEIBuilder<'a> {
+    pub fn max_subpass_shading_workgroup_size_aspect_ratio(
+        mut self,
+        max_subpass_shading_workgroup_size_aspect_ratio: u32,
+    ) -> Self {
+        self.inner.max_subpass_shading_workgroup_size_aspect_ratio =
+            max_subpass_shading_workgroup_size_aspect_ratio;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceSubpassShadingPropertiesHUAWEI {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryOpaqueCaptureAddressAllocateInfo.html>"]
 pub struct MemoryOpaqueCaptureAddressAllocateInfo {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub opaque_capture_address: u64,
 }
 impl ::std::default::Default for MemoryOpaqueCaptureAddressAllocateInfo {
     fn default() -> MemoryOpaqueCaptureAddressAllocateInfo {
@@ -41884,20 +38572,17 @@ impl<'a> ::std::ops::Deref for MemoryOpa
     }
 }
 impl<'a> ::std::ops::DerefMut for MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
-    pub fn opaque_capture_address(
-        mut self,
-        opaque_capture_address: u64,
-    ) -> MemoryOpaqueCaptureAddressAllocateInfoBuilder<'a> {
+    pub fn opaque_capture_address(mut self, opaque_capture_address: u64) -> Self {
         self.inner.opaque_capture_address = opaque_capture_address;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MemoryOpaqueCaptureAddressAllocateInfo {
         self.inner
@@ -41928,53 +38613,32 @@ impl DeviceMemoryOpaqueCaptureAddressInf
         }
     }
 }
 #[repr(transparent)]
 pub struct DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
     inner: DeviceMemoryOpaqueCaptureAddressInfo,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsDeviceMemoryOpaqueCaptureAddressInfo {}
 impl<'a> ::std::ops::Deref for DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
     type Target = DeviceMemoryOpaqueCaptureAddressInfo;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
-    pub fn memory(
-        mut self,
-        memory: DeviceMemory,
-    ) -> DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
         self.inner.memory = memory;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsDeviceMemoryOpaqueCaptureAddressInfo>(
-        mut self,
-        next: &'a mut T,
-    ) -> DeviceMemoryOpaqueCaptureAddressInfoBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceMemoryOpaqueCaptureAddressInfo {
         self.inner
     }
 }
 #[repr(C)]
@@ -42012,69 +38676,56 @@ impl PhysicalDeviceLineRasterizationFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceLineRasterizationFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceLineRasterizationFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceLineRasterizationFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceLineRasterizationFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
-    pub fn rectangular_lines(
-        mut self,
-        rectangular_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn rectangular_lines(mut self, rectangular_lines: bool) -> Self {
         self.inner.rectangular_lines = rectangular_lines.into();
         self
     }
-    pub fn bresenham_lines(
-        mut self,
-        bresenham_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn bresenham_lines(mut self, bresenham_lines: bool) -> Self {
         self.inner.bresenham_lines = bresenham_lines.into();
         self
     }
-    pub fn smooth_lines(
-        mut self,
-        smooth_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn smooth_lines(mut self, smooth_lines: bool) -> Self {
         self.inner.smooth_lines = smooth_lines.into();
         self
     }
-    pub fn stippled_rectangular_lines(
-        mut self,
-        stippled_rectangular_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn stippled_rectangular_lines(mut self, stippled_rectangular_lines: bool) -> Self {
         self.inner.stippled_rectangular_lines = stippled_rectangular_lines.into();
         self
     }
-    pub fn stippled_bresenham_lines(
-        mut self,
-        stippled_bresenham_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn stippled_bresenham_lines(mut self, stippled_bresenham_lines: bool) -> Self {
         self.inner.stippled_bresenham_lines = stippled_bresenham_lines.into();
         self
     }
-    pub fn stippled_smooth_lines(
-        mut self,
-        stippled_smooth_lines: bool,
-    ) -> PhysicalDeviceLineRasterizationFeaturesEXTBuilder<'a> {
+    pub fn stippled_smooth_lines(mut self, stippled_smooth_lines: bool) -> Self {
         self.inner.stippled_smooth_lines = stippled_smooth_lines.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceLineRasterizationFeaturesEXT {
         self.inner
@@ -42122,20 +38773,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
-    pub fn line_sub_pixel_precision_bits(
-        mut self,
-        line_sub_pixel_precision_bits: u32,
-    ) -> PhysicalDeviceLineRasterizationPropertiesEXTBuilder<'a> {
+    pub fn line_sub_pixel_precision_bits(mut self, line_sub_pixel_precision_bits: u32) -> Self {
         self.inner.line_sub_pixel_precision_bits = line_sub_pixel_precision_bits;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceLineRasterizationPropertiesEXT {
         self.inner
@@ -42195,38 +38843,29 @@ impl<'a> ::std::ops::DerefMut for Pipeli
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
     pub fn line_rasterization_mode(
         mut self,
         line_rasterization_mode: LineRasterizationModeEXT,
-    ) -> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
+    ) -> Self {
         self.inner.line_rasterization_mode = line_rasterization_mode;
         self
     }
-    pub fn stippled_line_enable(
-        mut self,
-        stippled_line_enable: bool,
-    ) -> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
+    pub fn stippled_line_enable(mut self, stippled_line_enable: bool) -> Self {
         self.inner.stippled_line_enable = stippled_line_enable.into();
         self
     }
-    pub fn line_stipple_factor(
-        mut self,
-        line_stipple_factor: u32,
-    ) -> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
+    pub fn line_stipple_factor(mut self, line_stipple_factor: u32) -> Self {
         self.inner.line_stipple_factor = line_stipple_factor;
         self
     }
-    pub fn line_stipple_pattern(
-        mut self,
-        line_stipple_pattern: u16,
-    ) -> PipelineRasterizationLineStateCreateInfoEXTBuilder<'a> {
+    pub fn line_stipple_pattern(mut self, line_stipple_pattern: u16) -> Self {
         self.inner.line_stipple_pattern = line_stipple_pattern;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineRasterizationLineStateCreateInfoEXT {
         self.inner
@@ -42257,16 +38896,24 @@ impl PhysicalDevicePipelineCreationCache
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'a> {
     inner: PhysicalDevicePipelineCreationCacheControlFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePipelineCreationCacheControlFeaturesEXT
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePipelineCreationCacheControlFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'a> {
     type Target = PhysicalDevicePipelineCreationCacheControlFeaturesEXT;
     fn deref(&self) -> &Self::Target {
@@ -42277,17 +38924,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'a> {
     pub fn pipeline_creation_cache_control(
         mut self,
         pipeline_creation_cache_control: bool,
-    ) -> PhysicalDevicePipelineCreationCacheControlFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.pipeline_creation_cache_control = pipeline_creation_cache_control.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePipelineCreationCacheControlFeaturesEXT {
         self.inner
@@ -42340,109 +38987,84 @@ impl PhysicalDeviceVulkan11Features {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceVulkan11FeaturesBuilder<'a> {
     inner: PhysicalDeviceVulkan11Features,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan11FeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan11Features {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan11FeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan11Features {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan11FeaturesBuilder<'a> {
     type Target = PhysicalDeviceVulkan11Features;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan11FeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
-    pub fn storage_buffer16_bit_access(
-        mut self,
-        storage_buffer16_bit_access: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn storage_buffer16_bit_access(mut self, storage_buffer16_bit_access: bool) -> Self {
         self.inner.storage_buffer16_bit_access = storage_buffer16_bit_access.into();
         self
     }
     pub fn uniform_and_storage_buffer16_bit_access(
         mut self,
         uniform_and_storage_buffer16_bit_access: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.uniform_and_storage_buffer16_bit_access =
             uniform_and_storage_buffer16_bit_access.into();
         self
     }
-    pub fn storage_push_constant16(
-        mut self,
-        storage_push_constant16: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn storage_push_constant16(mut self, storage_push_constant16: bool) -> Self {
         self.inner.storage_push_constant16 = storage_push_constant16.into();
         self
     }
-    pub fn storage_input_output16(
-        mut self,
-        storage_input_output16: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn storage_input_output16(mut self, storage_input_output16: bool) -> Self {
         self.inner.storage_input_output16 = storage_input_output16.into();
         self
     }
-    pub fn multiview(mut self, multiview: bool) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn multiview(mut self, multiview: bool) -> Self {
         self.inner.multiview = multiview.into();
         self
     }
-    pub fn multiview_geometry_shader(
-        mut self,
-        multiview_geometry_shader: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn multiview_geometry_shader(mut self, multiview_geometry_shader: bool) -> Self {
         self.inner.multiview_geometry_shader = multiview_geometry_shader.into();
         self
     }
-    pub fn multiview_tessellation_shader(
-        mut self,
-        multiview_tessellation_shader: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn multiview_tessellation_shader(mut self, multiview_tessellation_shader: bool) -> Self {
         self.inner.multiview_tessellation_shader = multiview_tessellation_shader.into();
         self
     }
     pub fn variable_pointers_storage_buffer(
         mut self,
         variable_pointers_storage_buffer: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.variable_pointers_storage_buffer = variable_pointers_storage_buffer.into();
         self
     }
-    pub fn variable_pointers(
-        mut self,
-        variable_pointers: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn variable_pointers(mut self, variable_pointers: bool) -> Self {
         self.inner.variable_pointers = variable_pointers.into();
         self
     }
-    pub fn protected_memory(
-        mut self,
-        protected_memory: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn protected_memory(mut self, protected_memory: bool) -> Self {
         self.inner.protected_memory = protected_memory.into();
         self
     }
-    pub fn sampler_ycbcr_conversion(
-        mut self,
-        sampler_ycbcr_conversion: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn sampler_ycbcr_conversion(mut self, sampler_ycbcr_conversion: bool) -> Self {
         self.inner.sampler_ycbcr_conversion = sampler_ycbcr_conversion.into();
         self
     }
-    pub fn shader_draw_parameters(
-        mut self,
-        shader_draw_parameters: bool,
-    ) -> PhysicalDeviceVulkan11FeaturesBuilder<'a> {
+    pub fn shader_draw_parameters(mut self, shader_draw_parameters: bool) -> Self {
         self.inner.shader_draw_parameters = shader_draw_parameters.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVulkan11Features {
         self.inner
@@ -42515,119 +39137,86 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan11PropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
-    pub fn device_uuid(
-        mut self,
-        device_uuid: [u8; UUID_SIZE],
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn device_uuid(mut self, device_uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.device_uuid = device_uuid;
         self
     }
-    pub fn driver_uuid(
-        mut self,
-        driver_uuid: [u8; UUID_SIZE],
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn driver_uuid(mut self, driver_uuid: [u8; UUID_SIZE]) -> Self {
         self.inner.driver_uuid = driver_uuid;
         self
     }
-    pub fn device_luid(
-        mut self,
-        device_luid: [u8; LUID_SIZE],
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn device_luid(mut self, device_luid: [u8; LUID_SIZE]) -> Self {
         self.inner.device_luid = device_luid;
         self
     }
-    pub fn device_node_mask(
-        mut self,
-        device_node_mask: u32,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn device_node_mask(mut self, device_node_mask: u32) -> Self {
         self.inner.device_node_mask = device_node_mask;
         self
     }
-    pub fn device_luid_valid(
-        mut self,
-        device_luid_valid: bool,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn device_luid_valid(mut self, device_luid_valid: bool) -> Self {
         self.inner.device_luid_valid = device_luid_valid.into();
         self
     }
-    pub fn subgroup_size(
-        mut self,
-        subgroup_size: u32,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn subgroup_size(mut self, subgroup_size: u32) -> Self {
         self.inner.subgroup_size = subgroup_size;
         self
     }
     pub fn subgroup_supported_stages(
         mut self,
         subgroup_supported_stages: ShaderStageFlags,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.subgroup_supported_stages = subgroup_supported_stages;
         self
     }
     pub fn subgroup_supported_operations(
         mut self,
         subgroup_supported_operations: SubgroupFeatureFlags,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.subgroup_supported_operations = subgroup_supported_operations;
         self
     }
     pub fn subgroup_quad_operations_in_all_stages(
         mut self,
         subgroup_quad_operations_in_all_stages: bool,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.subgroup_quad_operations_in_all_stages =
             subgroup_quad_operations_in_all_stages.into();
         self
     }
     pub fn point_clipping_behavior(
         mut self,
         point_clipping_behavior: PointClippingBehavior,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.point_clipping_behavior = point_clipping_behavior;
         self
     }
-    pub fn max_multiview_view_count(
-        mut self,
-        max_multiview_view_count: u32,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn max_multiview_view_count(mut self, max_multiview_view_count: u32) -> Self {
         self.inner.max_multiview_view_count = max_multiview_view_count;
         self
     }
-    pub fn max_multiview_instance_index(
-        mut self,
-        max_multiview_instance_index: u32,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn max_multiview_instance_index(mut self, max_multiview_instance_index: u32) -> Self {
         self.inner.max_multiview_instance_index = max_multiview_instance_index;
         self
     }
-    pub fn protected_no_fault(
-        mut self,
-        protected_no_fault: bool,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn protected_no_fault(mut self, protected_no_fault: bool) -> Self {
         self.inner.protected_no_fault = protected_no_fault.into();
         self
     }
-    pub fn max_per_set_descriptors(
-        mut self,
-        max_per_set_descriptors: u32,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn max_per_set_descriptors(mut self, max_per_set_descriptors: u32) -> Self {
         self.inner.max_per_set_descriptors = max_per_set_descriptors;
         self
     }
-    pub fn max_memory_allocation_size(
-        mut self,
-        max_memory_allocation_size: DeviceSize,
-    ) -> PhysicalDeviceVulkan11PropertiesBuilder<'a> {
+    pub fn max_memory_allocation_size(mut self, max_memory_allocation_size: DeviceSize) -> Self {
         self.inner.max_memory_allocation_size = max_memory_allocation_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVulkan11Properties {
         self.inner
@@ -42750,386 +39339,322 @@ impl PhysicalDeviceVulkan12Features {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceVulkan12FeaturesBuilder<'a> {
     inner: PhysicalDeviceVulkan12Features,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan12FeaturesBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVulkan12Features {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan12FeaturesBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVulkan12Features {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceVulkan12FeaturesBuilder<'a> {
     type Target = PhysicalDeviceVulkan12Features;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan12FeaturesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
-    pub fn sampler_mirror_clamp_to_edge(
-        mut self,
-        sampler_mirror_clamp_to_edge: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn sampler_mirror_clamp_to_edge(mut self, sampler_mirror_clamp_to_edge: bool) -> Self {
         self.inner.sampler_mirror_clamp_to_edge = sampler_mirror_clamp_to_edge.into();
         self
     }
-    pub fn draw_indirect_count(
-        mut self,
-        draw_indirect_count: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn draw_indirect_count(mut self, draw_indirect_count: bool) -> Self {
         self.inner.draw_indirect_count = draw_indirect_count.into();
         self
     }
-    pub fn storage_buffer8_bit_access(
-        mut self,
-        storage_buffer8_bit_access: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn storage_buffer8_bit_access(mut self, storage_buffer8_bit_access: bool) -> Self {
         self.inner.storage_buffer8_bit_access = storage_buffer8_bit_access.into();
         self
     }
     pub fn uniform_and_storage_buffer8_bit_access(
         mut self,
         uniform_and_storage_buffer8_bit_access: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.uniform_and_storage_buffer8_bit_access =
             uniform_and_storage_buffer8_bit_access.into();
         self
     }
-    pub fn storage_push_constant8(
-        mut self,
-        storage_push_constant8: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn storage_push_constant8(mut self, storage_push_constant8: bool) -> Self {
         self.inner.storage_push_constant8 = storage_push_constant8.into();
         self
     }
-    pub fn shader_buffer_int64_atomics(
-        mut self,
-        shader_buffer_int64_atomics: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_buffer_int64_atomics(mut self, shader_buffer_int64_atomics: bool) -> Self {
         self.inner.shader_buffer_int64_atomics = shader_buffer_int64_atomics.into();
         self
     }
-    pub fn shader_shared_int64_atomics(
-        mut self,
-        shader_shared_int64_atomics: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_shared_int64_atomics(mut self, shader_shared_int64_atomics: bool) -> Self {
         self.inner.shader_shared_int64_atomics = shader_shared_int64_atomics.into();
         self
     }
-    pub fn shader_float16(
-        mut self,
-        shader_float16: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_float16(mut self, shader_float16: bool) -> Self {
         self.inner.shader_float16 = shader_float16.into();
         self
     }
-    pub fn shader_int8(mut self, shader_int8: bool) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_int8(mut self, shader_int8: bool) -> Self {
         self.inner.shader_int8 = shader_int8.into();
         self
     }
-    pub fn descriptor_indexing(
-        mut self,
-        descriptor_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn descriptor_indexing(mut self, descriptor_indexing: bool) -> Self {
         self.inner.descriptor_indexing = descriptor_indexing.into();
         self
     }
     pub fn shader_input_attachment_array_dynamic_indexing(
         mut self,
         shader_input_attachment_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_input_attachment_array_dynamic_indexing =
             shader_input_attachment_array_dynamic_indexing.into();
         self
     }
     pub fn shader_uniform_texel_buffer_array_dynamic_indexing(
         mut self,
         shader_uniform_texel_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_texel_buffer_array_dynamic_indexing =
             shader_uniform_texel_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_storage_texel_buffer_array_dynamic_indexing(
         mut self,
         shader_storage_texel_buffer_array_dynamic_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_texel_buffer_array_dynamic_indexing =
             shader_storage_texel_buffer_array_dynamic_indexing.into();
         self
     }
     pub fn shader_uniform_buffer_array_non_uniform_indexing(
         mut self,
         shader_uniform_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_uniform_buffer_array_non_uniform_indexing =
             shader_uniform_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_sampled_image_array_non_uniform_indexing(
         mut self,
         shader_sampled_image_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_sampled_image_array_non_uniform_indexing =
             shader_sampled_image_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_buffer_array_non_uniform_indexing(
         mut self,
         shader_storage_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_buffer_array_non_uniform_indexing =
             shader_storage_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_image_array_non_uniform_indexing(
         mut self,
         shader_storage_image_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_storage_image_array_non_uniform_indexing =
             shader_storage_image_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_input_attachment_array_non_uniform_indexing(
         mut self,
         shader_input_attachment_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_input_attachment_array_non_uniform_indexing =
             shader_input_attachment_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_uniform_texel_buffer_array_non_uniform_indexing(
         mut self,
         shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_texel_buffer_array_non_uniform_indexing =
             shader_uniform_texel_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn shader_storage_texel_buffer_array_non_uniform_indexing(
         mut self,
         shader_storage_texel_buffer_array_non_uniform_indexing: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_texel_buffer_array_non_uniform_indexing =
             shader_storage_texel_buffer_array_non_uniform_indexing.into();
         self
     }
     pub fn descriptor_binding_uniform_buffer_update_after_bind(
         mut self,
         descriptor_binding_uniform_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_uniform_buffer_update_after_bind =
             descriptor_binding_uniform_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_sampled_image_update_after_bind(
         mut self,
         descriptor_binding_sampled_image_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_sampled_image_update_after_bind =
             descriptor_binding_sampled_image_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_image_update_after_bind(
         mut self,
         descriptor_binding_storage_image_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_image_update_after_bind =
             descriptor_binding_storage_image_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_buffer_update_after_bind(
         mut self,
         descriptor_binding_storage_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_buffer_update_after_bind =
             descriptor_binding_storage_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_uniform_texel_buffer_update_after_bind(
         mut self,
         descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_uniform_texel_buffer_update_after_bind =
             descriptor_binding_uniform_texel_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_storage_texel_buffer_update_after_bind(
         mut self,
         descriptor_binding_storage_texel_buffer_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .descriptor_binding_storage_texel_buffer_update_after_bind =
             descriptor_binding_storage_texel_buffer_update_after_bind.into();
         self
     }
     pub fn descriptor_binding_update_unused_while_pending(
         mut self,
         descriptor_binding_update_unused_while_pending: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_update_unused_while_pending =
             descriptor_binding_update_unused_while_pending.into();
         self
     }
     pub fn descriptor_binding_partially_bound(
         mut self,
         descriptor_binding_partially_bound: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_partially_bound = descriptor_binding_partially_bound.into();
         self
     }
     pub fn descriptor_binding_variable_descriptor_count(
         mut self,
         descriptor_binding_variable_descriptor_count: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.descriptor_binding_variable_descriptor_count =
             descriptor_binding_variable_descriptor_count.into();
         self
     }
-    pub fn runtime_descriptor_array(
-        mut self,
-        runtime_descriptor_array: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn runtime_descriptor_array(mut self, runtime_descriptor_array: bool) -> Self {
         self.inner.runtime_descriptor_array = runtime_descriptor_array.into();
         self
     }
-    pub fn sampler_filter_minmax(
-        mut self,
-        sampler_filter_minmax: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn sampler_filter_minmax(mut self, sampler_filter_minmax: bool) -> Self {
         self.inner.sampler_filter_minmax = sampler_filter_minmax.into();
         self
     }
-    pub fn scalar_block_layout(
-        mut self,
-        scalar_block_layout: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn scalar_block_layout(mut self, scalar_block_layout: bool) -> Self {
         self.inner.scalar_block_layout = scalar_block_layout.into();
         self
     }
-    pub fn imageless_framebuffer(
-        mut self,
-        imageless_framebuffer: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn imageless_framebuffer(mut self, imageless_framebuffer: bool) -> Self {
         self.inner.imageless_framebuffer = imageless_framebuffer.into();
         self
     }
-    pub fn uniform_buffer_standard_layout(
-        mut self,
-        uniform_buffer_standard_layout: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn uniform_buffer_standard_layout(mut self, uniform_buffer_standard_layout: bool) -> Self {
         self.inner.uniform_buffer_standard_layout = uniform_buffer_standard_layout.into();
         self
     }
-    pub fn shader_subgroup_extended_types(
-        mut self,
-        shader_subgroup_extended_types: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_subgroup_extended_types(mut self, shader_subgroup_extended_types: bool) -> Self {
         self.inner.shader_subgroup_extended_types = shader_subgroup_extended_types.into();
         self
     }
-    pub fn separate_depth_stencil_layouts(
-        mut self,
-        separate_depth_stencil_layouts: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn separate_depth_stencil_layouts(mut self, separate_depth_stencil_layouts: bool) -> Self {
         self.inner.separate_depth_stencil_layouts = separate_depth_stencil_layouts.into();
         self
     }
-    pub fn host_query_reset(
-        mut self,
-        host_query_reset: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn host_query_reset(mut self, host_query_reset: bool) -> Self {
         self.inner.host_query_reset = host_query_reset.into();
         self
     }
-    pub fn timeline_semaphore(
-        mut self,
-        timeline_semaphore: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn timeline_semaphore(mut self, timeline_semaphore: bool) -> Self {
         self.inner.timeline_semaphore = timeline_semaphore.into();
         self
     }
-    pub fn buffer_device_address(
-        mut self,
-        buffer_device_address: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn buffer_device_address(mut self, buffer_device_address: bool) -> Self {
         self.inner.buffer_device_address = buffer_device_address.into();
         self
     }
     pub fn buffer_device_address_capture_replay(
         mut self,
         buffer_device_address_capture_replay: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_capture_replay =
             buffer_device_address_capture_replay.into();
         self
     }
     pub fn buffer_device_address_multi_device(
         mut self,
         buffer_device_address_multi_device: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.buffer_device_address_multi_device = buffer_device_address_multi_device.into();
         self
     }
-    pub fn vulkan_memory_model(
-        mut self,
-        vulkan_memory_model: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn vulkan_memory_model(mut self, vulkan_memory_model: bool) -> Self {
         self.inner.vulkan_memory_model = vulkan_memory_model.into();
         self
     }
     pub fn vulkan_memory_model_device_scope(
         mut self,
         vulkan_memory_model_device_scope: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner.vulkan_memory_model_device_scope = vulkan_memory_model_device_scope.into();
         self
     }
     pub fn vulkan_memory_model_availability_visibility_chains(
         mut self,
         vulkan_memory_model_availability_visibility_chains: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    ) -> Self {
         self.inner
             .vulkan_memory_model_availability_visibility_chains =
             vulkan_memory_model_availability_visibility_chains.into();
         self
     }
-    pub fn shader_output_viewport_index(
-        mut self,
-        shader_output_viewport_index: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_output_viewport_index(mut self, shader_output_viewport_index: bool) -> Self {
         self.inner.shader_output_viewport_index = shader_output_viewport_index.into();
         self
     }
-    pub fn shader_output_layer(
-        mut self,
-        shader_output_layer: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn shader_output_layer(mut self, shader_output_layer: bool) -> Self {
         self.inner.shader_output_layer = shader_output_layer.into();
         self
     }
-    pub fn subgroup_broadcast_dynamic_id(
-        mut self,
-        subgroup_broadcast_dynamic_id: bool,
-    ) -> PhysicalDeviceVulkan12FeaturesBuilder<'a> {
+    pub fn subgroup_broadcast_dynamic_id(mut self, subgroup_broadcast_dynamic_id: bool) -> Self {
         self.inner.subgroup_broadcast_dynamic_id = subgroup_broadcast_dynamic_id.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVulkan12Features {
         self.inner
@@ -43478,420 +40003,393 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceVulkan12PropertiesBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
-    pub fn driver_id(mut self, driver_id: DriverId) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn driver_id(mut self, driver_id: DriverId) -> Self {
         self.inner.driver_id = driver_id;
         self
     }
-    pub fn driver_name(
-        mut self,
-        driver_name: [c_char; MAX_DRIVER_NAME_SIZE],
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn driver_name(mut self, driver_name: [c_char; MAX_DRIVER_NAME_SIZE]) -> Self {
         self.inner.driver_name = driver_name;
         self
     }
-    pub fn driver_info(
-        mut self,
-        driver_info: [c_char; MAX_DRIVER_INFO_SIZE],
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn driver_info(mut self, driver_info: [c_char; MAX_DRIVER_INFO_SIZE]) -> Self {
         self.inner.driver_info = driver_info;
         self
     }
-    pub fn conformance_version(
-        mut self,
-        conformance_version: ConformanceVersion,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn conformance_version(mut self, conformance_version: ConformanceVersion) -> Self {
         self.inner.conformance_version = conformance_version;
         self
     }
     pub fn denorm_behavior_independence(
         mut self,
         denorm_behavior_independence: ShaderFloatControlsIndependence,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.denorm_behavior_independence = denorm_behavior_independence;
         self
     }
     pub fn rounding_mode_independence(
         mut self,
         rounding_mode_independence: ShaderFloatControlsIndependence,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.rounding_mode_independence = rounding_mode_independence;
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float16(
         mut self,
         shader_signed_zero_inf_nan_preserve_float16: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float16 =
             shader_signed_zero_inf_nan_preserve_float16.into();
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float32(
         mut self,
         shader_signed_zero_inf_nan_preserve_float32: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float32 =
             shader_signed_zero_inf_nan_preserve_float32.into();
         self
     }
     pub fn shader_signed_zero_inf_nan_preserve_float64(
         mut self,
         shader_signed_zero_inf_nan_preserve_float64: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_signed_zero_inf_nan_preserve_float64 =
             shader_signed_zero_inf_nan_preserve_float64.into();
         self
     }
-    pub fn shader_denorm_preserve_float16(
-        mut self,
-        shader_denorm_preserve_float16: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float16(mut self, shader_denorm_preserve_float16: bool) -> Self {
         self.inner.shader_denorm_preserve_float16 = shader_denorm_preserve_float16.into();
         self
     }
-    pub fn shader_denorm_preserve_float32(
-        mut self,
-        shader_denorm_preserve_float32: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float32(mut self, shader_denorm_preserve_float32: bool) -> Self {
         self.inner.shader_denorm_preserve_float32 = shader_denorm_preserve_float32.into();
         self
     }
-    pub fn shader_denorm_preserve_float64(
-        mut self,
-        shader_denorm_preserve_float64: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn shader_denorm_preserve_float64(mut self, shader_denorm_preserve_float64: bool) -> Self {
         self.inner.shader_denorm_preserve_float64 = shader_denorm_preserve_float64.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float16(
         mut self,
         shader_denorm_flush_to_zero_float16: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float16 = shader_denorm_flush_to_zero_float16.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float32(
         mut self,
         shader_denorm_flush_to_zero_float32: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float32 = shader_denorm_flush_to_zero_float32.into();
         self
     }
     pub fn shader_denorm_flush_to_zero_float64(
         mut self,
         shader_denorm_flush_to_zero_float64: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_denorm_flush_to_zero_float64 = shader_denorm_flush_to_zero_float64.into();
         self
     }
     pub fn shader_rounding_mode_rte_float16(
         mut self,
         shader_rounding_mode_rte_float16: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float16 = shader_rounding_mode_rte_float16.into();
         self
     }
     pub fn shader_rounding_mode_rte_float32(
         mut self,
         shader_rounding_mode_rte_float32: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float32 = shader_rounding_mode_rte_float32.into();
         self
     }
     pub fn shader_rounding_mode_rte_float64(
         mut self,
         shader_rounding_mode_rte_float64: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rte_float64 = shader_rounding_mode_rte_float64.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float16(
         mut self,
         shader_rounding_mode_rtz_float16: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float16 = shader_rounding_mode_rtz_float16.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float32(
         mut self,
         shader_rounding_mode_rtz_float32: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float32 = shader_rounding_mode_rtz_float32.into();
         self
     }
     pub fn shader_rounding_mode_rtz_float64(
         mut self,
         shader_rounding_mode_rtz_float64: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.shader_rounding_mode_rtz_float64 = shader_rounding_mode_rtz_float64.into();
         self
     }
     pub fn max_update_after_bind_descriptors_in_all_pools(
         mut self,
         max_update_after_bind_descriptors_in_all_pools: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_update_after_bind_descriptors_in_all_pools =
             max_update_after_bind_descriptors_in_all_pools;
         self
     }
     pub fn shader_uniform_buffer_array_non_uniform_indexing_native(
         mut self,
         shader_uniform_buffer_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_uniform_buffer_array_non_uniform_indexing_native =
             shader_uniform_buffer_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_sampled_image_array_non_uniform_indexing_native(
         mut self,
         shader_sampled_image_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_sampled_image_array_non_uniform_indexing_native =
             shader_sampled_image_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_storage_buffer_array_non_uniform_indexing_native(
         mut self,
         shader_storage_buffer_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_buffer_array_non_uniform_indexing_native =
             shader_storage_buffer_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_storage_image_array_non_uniform_indexing_native(
         mut self,
         shader_storage_image_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_storage_image_array_non_uniform_indexing_native =
             shader_storage_image_array_non_uniform_indexing_native.into();
         self
     }
     pub fn shader_input_attachment_array_non_uniform_indexing_native(
         mut self,
         shader_input_attachment_array_non_uniform_indexing_native: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .shader_input_attachment_array_non_uniform_indexing_native =
             shader_input_attachment_array_non_uniform_indexing_native.into();
         self
     }
     pub fn robust_buffer_access_update_after_bind(
         mut self,
         robust_buffer_access_update_after_bind: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.robust_buffer_access_update_after_bind =
             robust_buffer_access_update_after_bind.into();
         self
     }
-    pub fn quad_divergent_implicit_lod(
-        mut self,
-        quad_divergent_implicit_lod: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn quad_divergent_implicit_lod(mut self, quad_divergent_implicit_lod: bool) -> Self {
         self.inner.quad_divergent_implicit_lod = quad_divergent_implicit_lod.into();
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_samplers(
         mut self,
         max_per_stage_descriptor_update_after_bind_samplers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_samplers =
             max_per_stage_descriptor_update_after_bind_samplers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_uniform_buffers(
         mut self,
         max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_uniform_buffers =
             max_per_stage_descriptor_update_after_bind_uniform_buffers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_storage_buffers(
         mut self,
         max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_storage_buffers =
             max_per_stage_descriptor_update_after_bind_storage_buffers;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_sampled_images(
         mut self,
         max_per_stage_descriptor_update_after_bind_sampled_images: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_sampled_images =
             max_per_stage_descriptor_update_after_bind_sampled_images;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_storage_images(
         mut self,
         max_per_stage_descriptor_update_after_bind_storage_images: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_storage_images =
             max_per_stage_descriptor_update_after_bind_storage_images;
         self
     }
     pub fn max_per_stage_descriptor_update_after_bind_input_attachments(
         mut self,
         max_per_stage_descriptor_update_after_bind_input_attachments: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_per_stage_descriptor_update_after_bind_input_attachments =
             max_per_stage_descriptor_update_after_bind_input_attachments;
         self
     }
     pub fn max_per_stage_update_after_bind_resources(
         mut self,
         max_per_stage_update_after_bind_resources: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_per_stage_update_after_bind_resources =
             max_per_stage_update_after_bind_resources;
         self
     }
     pub fn max_descriptor_set_update_after_bind_samplers(
         mut self,
         max_descriptor_set_update_after_bind_samplers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_descriptor_set_update_after_bind_samplers =
             max_descriptor_set_update_after_bind_samplers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_uniform_buffers(
         mut self,
         max_descriptor_set_update_after_bind_uniform_buffers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_uniform_buffers =
             max_descriptor_set_update_after_bind_uniform_buffers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_uniform_buffers_dynamic(
         mut self,
         max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_uniform_buffers_dynamic =
             max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_buffers(
         mut self,
         max_descriptor_set_update_after_bind_storage_buffers: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_buffers =
             max_descriptor_set_update_after_bind_storage_buffers;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_buffers_dynamic(
         mut self,
         max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_buffers_dynamic =
             max_descriptor_set_update_after_bind_storage_buffers_dynamic;
         self
     }
     pub fn max_descriptor_set_update_after_bind_sampled_images(
         mut self,
         max_descriptor_set_update_after_bind_sampled_images: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_sampled_images =
             max_descriptor_set_update_after_bind_sampled_images;
         self
     }
     pub fn max_descriptor_set_update_after_bind_storage_images(
         mut self,
         max_descriptor_set_update_after_bind_storage_images: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_storage_images =
             max_descriptor_set_update_after_bind_storage_images;
         self
     }
     pub fn max_descriptor_set_update_after_bind_input_attachments(
         mut self,
         max_descriptor_set_update_after_bind_input_attachments: u32,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_descriptor_set_update_after_bind_input_attachments =
             max_descriptor_set_update_after_bind_input_attachments;
         self
     }
     pub fn supported_depth_resolve_modes(
         mut self,
         supported_depth_resolve_modes: ResolveModeFlags,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.supported_depth_resolve_modes = supported_depth_resolve_modes;
         self
     }
     pub fn supported_stencil_resolve_modes(
         mut self,
         supported_stencil_resolve_modes: ResolveModeFlags,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.supported_stencil_resolve_modes = supported_stencil_resolve_modes;
         self
     }
-    pub fn independent_resolve_none(
-        mut self,
-        independent_resolve_none: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn independent_resolve_none(mut self, independent_resolve_none: bool) -> Self {
         self.inner.independent_resolve_none = independent_resolve_none.into();
         self
     }
-    pub fn independent_resolve(
-        mut self,
-        independent_resolve: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    pub fn independent_resolve(mut self, independent_resolve: bool) -> Self {
         self.inner.independent_resolve = independent_resolve.into();
         self
     }
     pub fn filter_minmax_single_component_formats(
         mut self,
         filter_minmax_single_component_formats: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.filter_minmax_single_component_formats =
             filter_minmax_single_component_formats.into();
         self
     }
     pub fn filter_minmax_image_component_mapping(
         mut self,
         filter_minmax_image_component_mapping: bool,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.filter_minmax_image_component_mapping =
             filter_minmax_image_component_mapping.into();
         self
     }
     pub fn max_timeline_semaphore_value_difference(
         mut self,
         max_timeline_semaphore_value_difference: u64,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.max_timeline_semaphore_value_difference =
             max_timeline_semaphore_value_difference;
         self
     }
     pub fn framebuffer_integer_color_sample_counts(
         mut self,
         framebuffer_integer_color_sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceVulkan12PropertiesBuilder<'a> {
+    ) -> Self {
         self.inner.framebuffer_integer_color_sample_counts =
             framebuffer_integer_color_sample_counts;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceVulkan12Properties {
@@ -43942,17 +40440,17 @@ impl<'a> ::std::ops::DerefMut for Pipeli
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineCompilerControlCreateInfoAMDBuilder<'a> {
     pub fn compiler_control_flags(
         mut self,
         compiler_control_flags: PipelineCompilerControlFlagsAMD,
-    ) -> PipelineCompilerControlCreateInfoAMDBuilder<'a> {
+    ) -> Self {
         self.inner.compiler_control_flags = compiler_control_flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineCompilerControlCreateInfoAMD {
         self.inner
@@ -43983,34 +40481,33 @@ impl PhysicalDeviceCoherentMemoryFeature
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
     inner: PhysicalDeviceCoherentMemoryFeaturesAMD,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCoherentMemoryFeaturesAMD {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCoherentMemoryFeaturesAMD {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
     type Target = PhysicalDeviceCoherentMemoryFeaturesAMD;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
-    pub fn device_coherent_memory(
-        mut self,
-        device_coherent_memory: bool,
-    ) -> PhysicalDeviceCoherentMemoryFeaturesAMDBuilder<'a> {
+    pub fn device_coherent_memory(mut self, device_coherent_memory: bool) -> Self {
         self.inner.device_coherent_memory = device_coherent_memory.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCoherentMemoryFeaturesAMD {
         self.inner
@@ -44070,81 +40567,48 @@ impl PhysicalDeviceToolPropertiesEXT {
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceToolPropertiesEXTBuilder<'a> {
     inner: PhysicalDeviceToolPropertiesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceToolPropertiesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceToolPropertiesEXTBuilder<'a> {
     type Target = PhysicalDeviceToolPropertiesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceToolPropertiesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
-    pub fn name(
-        mut self,
-        name: [c_char; MAX_EXTENSION_NAME_SIZE],
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
+    pub fn name(mut self, name: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
         self.inner.name = name;
         self
     }
-    pub fn version(
-        mut self,
-        version: [c_char; MAX_EXTENSION_NAME_SIZE],
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
+    pub fn version(mut self, version: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
         self.inner.version = version;
         self
     }
-    pub fn purposes(
-        mut self,
-        purposes: ToolPurposeFlagsEXT,
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
+    pub fn purposes(mut self, purposes: ToolPurposeFlagsEXT) -> Self {
         self.inner.purposes = purposes;
         self
     }
-    pub fn description(
-        mut self,
-        description: [c_char; MAX_DESCRIPTION_SIZE],
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
+    pub fn description(mut self, description: [c_char; MAX_DESCRIPTION_SIZE]) -> Self {
         self.inner.description = description;
         self
     }
-    pub fn layer(
-        mut self,
-        layer: [c_char; MAX_EXTENSION_NAME_SIZE],
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
+    pub fn layer(mut self, layer: [c_char; MAX_EXTENSION_NAME_SIZE]) -> Self {
         self.inner.layer = layer;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceToolPropertiesEXT>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceToolPropertiesEXTBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceToolPropertiesEXT {
         self.inner
     }
 }
 #[repr(C)]
@@ -44198,24 +40662,21 @@ impl<'a> ::std::ops::Deref for SamplerCu
     }
 }
 impl<'a> ::std::ops::DerefMut for SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
-    pub fn custom_border_color(
-        mut self,
-        custom_border_color: ClearColorValue,
-    ) -> SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
+    pub fn custom_border_color(mut self, custom_border_color: ClearColorValue) -> Self {
         self.inner.custom_border_color = custom_border_color;
         self
     }
-    pub fn format(mut self, format: Format) -> SamplerCustomBorderColorCreateInfoEXTBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
         self.inner.format = format;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> SamplerCustomBorderColorCreateInfoEXT {
         self.inner
@@ -44266,17 +40727,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
     pub fn max_custom_border_color_samplers(
         mut self,
         max_custom_border_color_samplers: u32,
-    ) -> PhysicalDeviceCustomBorderColorPropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.max_custom_border_color_samplers = max_custom_border_color_samplers;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCustomBorderColorPropertiesEXT {
         self.inner
@@ -44309,41 +40770,43 @@ impl PhysicalDeviceCustomBorderColorFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceCustomBorderColorFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceCustomBorderColorFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceCustomBorderColorFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceCustomBorderColorFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
-    pub fn custom_border_colors(
-        mut self,
-        custom_border_colors: bool,
-    ) -> PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
+    pub fn custom_border_colors(mut self, custom_border_colors: bool) -> Self {
         self.inner.custom_border_colors = custom_border_colors.into();
         self
     }
     pub fn custom_border_color_without_format(
         mut self,
         custom_border_color_without_format: bool,
-    ) -> PhysicalDeviceCustomBorderColorFeaturesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.custom_border_color_without_format = custom_border_color_without_format.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceCustomBorderColorFeaturesEXT {
         self.inner
@@ -44438,74 +40901,53 @@ impl<'a> ::std::ops::Deref for Accelerat
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
-    pub fn vertex_format(
-        mut self,
-        vertex_format: Format,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn vertex_format(mut self, vertex_format: Format) -> Self {
         self.inner.vertex_format = vertex_format;
         self
     }
-    pub fn vertex_data(
-        mut self,
-        vertex_data: DeviceOrHostAddressConstKHR,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.vertex_data = vertex_data;
         self
     }
-    pub fn vertex_stride(
-        mut self,
-        vertex_stride: DeviceSize,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn vertex_stride(mut self, vertex_stride: DeviceSize) -> Self {
         self.inner.vertex_stride = vertex_stride;
         self
     }
-    pub fn max_vertex(
-        mut self,
-        max_vertex: u32,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn max_vertex(mut self, max_vertex: u32) -> Self {
         self.inner.max_vertex = max_vertex;
         self
     }
-    pub fn index_type(
-        mut self,
-        index_type: IndexType,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn index_type(mut self, index_type: IndexType) -> Self {
         self.inner.index_type = index_type;
         self
     }
-    pub fn index_data(
-        mut self,
-        index_data: DeviceOrHostAddressConstKHR,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn index_data(mut self, index_data: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.index_data = index_data;
         self
     }
-    pub fn transform_data(
-        mut self,
-        transform_data: DeviceOrHostAddressConstKHR,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    pub fn transform_data(mut self, transform_data: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.transform_data = transform_data;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsAccelerationStructureGeometryTrianglesDataKHR>(
         mut self,
         next: &'a mut T,
-    ) -> AccelerationStructureGeometryTrianglesDataKHRBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -44553,60 +40995,36 @@ impl AccelerationStructureGeometryAabbsD
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
     inner: AccelerationStructureGeometryAabbsDataKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureGeometryAabbsDataKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
     type Target = AccelerationStructureGeometryAabbsDataKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
-    pub fn data(
-        mut self,
-        data: DeviceOrHostAddressConstKHR,
-    ) -> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
+    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.data = data;
         self
     }
-    pub fn stride(
-        mut self,
-        stride: DeviceSize,
-    ) -> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
+    pub fn stride(mut self, stride: DeviceSize) -> Self {
         self.inner.stride = stride;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureGeometryAabbsDataKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureGeometryAabbsDataKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureGeometryAabbsDataKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -44646,60 +41064,36 @@ impl AccelerationStructureGeometryInstan
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
     inner: AccelerationStructureGeometryInstancesDataKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureGeometryInstancesDataKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
     type Target = AccelerationStructureGeometryInstancesDataKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
-    pub fn array_of_pointers(
-        mut self,
-        array_of_pointers: bool,
-    ) -> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
+    pub fn array_of_pointers(mut self, array_of_pointers: bool) -> Self {
         self.inner.array_of_pointers = array_of_pointers.into();
         self
     }
-    pub fn data(
-        mut self,
-        data: DeviceOrHostAddressConstKHR,
-    ) -> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
+    pub fn data(mut self, data: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.data = data;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureGeometryInstancesDataKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureGeometryInstancesDataKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureGeometryInstancesDataKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -44755,62 +41149,38 @@ impl AccelerationStructureGeometryKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureGeometryKHRBuilder<'a> {
     inner: AccelerationStructureGeometryKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureGeometryKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureGeometryKHRBuilder<'a> {
     type Target = AccelerationStructureGeometryKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureGeometryKHRBuilder<'a> {
-    pub fn geometry_type(
-        mut self,
-        geometry_type: GeometryTypeKHR,
-    ) -> AccelerationStructureGeometryKHRBuilder<'a> {
+    pub fn geometry_type(mut self, geometry_type: GeometryTypeKHR) -> Self {
         self.inner.geometry_type = geometry_type;
         self
     }
-    pub fn geometry(
-        mut self,
-        geometry: AccelerationStructureGeometryDataKHR,
-    ) -> AccelerationStructureGeometryKHRBuilder<'a> {
+    pub fn geometry(mut self, geometry: AccelerationStructureGeometryDataKHR) -> Self {
         self.inner.geometry = geometry;
         self
     }
-    pub fn flags(mut self, flags: GeometryFlagsKHR) -> AccelerationStructureGeometryKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureGeometryKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureGeometryKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
+    pub fn flags(mut self, flags: GeometryFlagsKHR) -> Self {
+        self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureGeometryKHR {
         self.inner
     }
@@ -44879,104 +41249,71 @@ impl AccelerationStructureBuildGeometryI
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
     inner: AccelerationStructureBuildGeometryInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureBuildGeometryInfoKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
     type Target = AccelerationStructureBuildGeometryInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
-    pub fn ty(
-        mut self,
-        ty: AccelerationStructureTypeKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn flags(
-        mut self,
-        flags: BuildAccelerationStructureFlagsKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
-        self.inner.flags = flags;
-        self
-    }
-    pub fn mode(
-        mut self,
-        mode: BuildAccelerationStructureModeKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: BuildAccelerationStructureFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn mode(mut self, mode: BuildAccelerationStructureModeKHR) -> Self {
         self.inner.mode = mode;
         self
     }
     pub fn src_acceleration_structure(
         mut self,
         src_acceleration_structure: AccelerationStructureKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.src_acceleration_structure = src_acceleration_structure;
         self
     }
     pub fn dst_acceleration_structure(
         mut self,
         dst_acceleration_structure: AccelerationStructureKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.dst_acceleration_structure = dst_acceleration_structure;
         self
     }
-    pub fn geometries(
-        mut self,
-        geometries: &'a [AccelerationStructureGeometryKHR],
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+    pub fn geometries(mut self, geometries: &'a [AccelerationStructureGeometryKHR]) -> Self {
         self.inner.geometry_count = geometries.len() as _;
         self.inner.p_geometries = geometries.as_ptr();
         self
     }
     pub fn geometries_ptrs(
         mut self,
-        geometries: &'a [*const AccelerationStructureGeometryKHR],
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+        geometries: &'a [&'a AccelerationStructureGeometryKHR],
+    ) -> Self {
         self.inner.geometry_count = geometries.len() as _;
-        self.inner.pp_geometries = geometries.as_ptr();
-        self
-    }
-    pub fn scratch_data(
-        mut self,
-        scratch_data: DeviceOrHostAddressKHR,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
+        self.inner.pp_geometries = geometries.as_ptr() as *const *const _;
+        self
+    }
+    pub fn scratch_data(mut self, scratch_data: DeviceOrHostAddressKHR) -> Self {
         self.inner.scratch_data = scratch_data;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureBuildGeometryInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureBuildGeometryInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureBuildGeometryInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45008,41 +41345,29 @@ impl<'a> ::std::ops::Deref for Accelerat
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
-    pub fn primitive_count(
-        mut self,
-        primitive_count: u32,
-    ) -> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
+    pub fn primitive_count(mut self, primitive_count: u32) -> Self {
         self.inner.primitive_count = primitive_count;
         self
     }
-    pub fn primitive_offset(
-        mut self,
-        primitive_offset: u32,
-    ) -> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
+    pub fn primitive_offset(mut self, primitive_offset: u32) -> Self {
         self.inner.primitive_offset = primitive_offset;
         self
     }
-    pub fn first_vertex(
-        mut self,
-        first_vertex: u32,
-    ) -> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
+    pub fn first_vertex(mut self, first_vertex: u32) -> Self {
         self.inner.first_vertex = first_vertex;
         self
     }
-    pub fn transform_offset(
-        mut self,
-        transform_offset: u32,
-    ) -> AccelerationStructureBuildRangeInfoKHRBuilder<'a> {
+    pub fn transform_offset(mut self, transform_offset: u32) -> Self {
         self.inner.transform_offset = transform_offset;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureBuildRangeInfoKHR {
         self.inner
@@ -45096,58 +41421,49 @@ impl<'a> ::std::ops::Deref for Accelerat
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureCreateInfoKHRBuilder<'a> {
-    pub fn create_flags(
-        mut self,
-        create_flags: AccelerationStructureCreateFlagsKHR,
-    ) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn create_flags(mut self, create_flags: AccelerationStructureCreateFlagsKHR) -> Self {
         self.inner.create_flags = create_flags;
         self
     }
-    pub fn buffer(mut self, buffer: Buffer) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
         self.inner.buffer = buffer;
         self
     }
-    pub fn offset(mut self, offset: DeviceSize) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
         self.inner.offset = offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    pub fn ty(
-        mut self,
-        ty: AccelerationStructureTypeKHR,
-    ) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn ty(mut self, ty: AccelerationStructureTypeKHR) -> Self {
         self.inner.ty = ty;
         self
     }
-    pub fn device_address(
-        mut self,
-        device_address: DeviceAddress,
-    ) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    pub fn device_address(mut self, device_address: DeviceAddress) -> Self {
         self.inner.device_address = device_address;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
     pub fn push_next<T: ExtendsAccelerationStructureCreateInfoKHR>(
         mut self,
         next: &'a mut T,
-    ) -> AccelerationStructureCreateInfoKHRBuilder<'a> {
+    ) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -45189,37 +41505,37 @@ impl<'a> ::std::ops::Deref for AabbPosit
     }
 }
 impl<'a> ::std::ops::DerefMut for AabbPositionsKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AabbPositionsKHRBuilder<'a> {
-    pub fn min_x(mut self, min_x: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn min_x(mut self, min_x: f32) -> Self {
         self.inner.min_x = min_x;
         self
     }
-    pub fn min_y(mut self, min_y: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn min_y(mut self, min_y: f32) -> Self {
         self.inner.min_y = min_y;
         self
     }
-    pub fn min_z(mut self, min_z: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn min_z(mut self, min_z: f32) -> Self {
         self.inner.min_z = min_z;
         self
     }
-    pub fn max_x(mut self, max_x: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn max_x(mut self, max_x: f32) -> Self {
         self.inner.max_x = max_x;
         self
     }
-    pub fn max_y(mut self, max_y: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn max_y(mut self, max_y: f32) -> Self {
         self.inner.max_y = max_y;
         self
     }
-    pub fn max_z(mut self, max_z: f32) -> AabbPositionsKHRBuilder<'a> {
+    pub fn max_z(mut self, max_z: f32) -> Self {
         self.inner.max_z = max_z;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AabbPositionsKHR {
         self.inner
@@ -45233,16 +41549,17 @@ pub struct TransformMatrixKHR {
 #[repr(C)]
 #[derive(Copy, Clone)]
 pub union AccelerationStructureReferenceKHR {
     pub device_handle: DeviceAddress,
     pub host_handle: AccelerationStructureKHR,
 }
 #[repr(C)]
 #[derive(Copy, Clone)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureInstanceKHR.html>"]
 pub struct AccelerationStructureInstanceKHR {
     pub transform: TransformMatrixKHR,
     pub instance_custom_index_and_mask: u32,
     pub instance_shader_binding_table_record_offset_and_flags: u32,
     pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
@@ -45269,53 +41586,35 @@ impl AccelerationStructureDeviceAddressI
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
     inner: AccelerationStructureDeviceAddressInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureDeviceAddressInfoKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
     type Target = AccelerationStructureDeviceAddressInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
     pub fn acceleration_structure(
         mut self,
         acceleration_structure: AccelerationStructureKHR,
-    ) -> AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.acceleration_structure = acceleration_structure;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureDeviceAddressInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureDeviceAddressInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureDeviceAddressInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45343,53 +41642,32 @@ impl AccelerationStructureVersionInfoKHR
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureVersionInfoKHRBuilder<'a> {
     inner: AccelerationStructureVersionInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureVersionInfoKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureVersionInfoKHRBuilder<'a> {
     type Target = AccelerationStructureVersionInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureVersionInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureVersionInfoKHRBuilder<'a> {
-    pub fn version_data(
-        mut self,
-        version_data: &'a [u8; 2 * UUID_SIZE],
-    ) -> AccelerationStructureVersionInfoKHRBuilder<'a> {
+    pub fn version_data(mut self, version_data: &'a [u8; 2 * UUID_SIZE]) -> Self {
         self.inner.p_version_data = version_data.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureVersionInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureVersionInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureVersionInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45421,67 +41699,40 @@ impl CopyAccelerationStructureInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyAccelerationStructureInfoKHRBuilder<'a> {
     inner: CopyAccelerationStructureInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyAccelerationStructureInfoKHR {}
 impl<'a> ::std::ops::Deref for CopyAccelerationStructureInfoKHRBuilder<'a> {
     type Target = CopyAccelerationStructureInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyAccelerationStructureInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyAccelerationStructureInfoKHRBuilder<'a> {
-    pub fn src(
-        mut self,
-        src: AccelerationStructureKHR,
-    ) -> CopyAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
         self.inner.src = src;
         self
     }
-    pub fn dst(
-        mut self,
-        dst: AccelerationStructureKHR,
-    ) -> CopyAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
         self.inner.dst = dst;
         self
     }
-    pub fn mode(
-        mut self,
-        mode: CopyAccelerationStructureModeKHR,
-    ) -> CopyAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
         self.inner.mode = mode;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyAccelerationStructureInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyAccelerationStructureInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyAccelerationStructureInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45524,67 +41775,40 @@ impl CopyAccelerationStructureToMemoryIn
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
     inner: CopyAccelerationStructureToMemoryInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyAccelerationStructureToMemoryInfoKHR {}
 impl<'a> ::std::ops::Deref for CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
     type Target = CopyAccelerationStructureToMemoryInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
-    pub fn src(
-        mut self,
-        src: AccelerationStructureKHR,
-    ) -> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
+    pub fn src(mut self, src: AccelerationStructureKHR) -> Self {
         self.inner.src = src;
         self
     }
-    pub fn dst(
-        mut self,
-        dst: DeviceOrHostAddressKHR,
-    ) -> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
+    pub fn dst(mut self, dst: DeviceOrHostAddressKHR) -> Self {
         self.inner.dst = dst;
         self
     }
-    pub fn mode(
-        mut self,
-        mode: CopyAccelerationStructureModeKHR,
-    ) -> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
+    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
         self.inner.mode = mode;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyAccelerationStructureToMemoryInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyAccelerationStructureToMemoryInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyAccelerationStructureToMemoryInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45627,67 +41851,40 @@ impl CopyMemoryToAccelerationStructureIn
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
     inner: CopyMemoryToAccelerationStructureInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyMemoryToAccelerationStructureInfoKHR {}
 impl<'a> ::std::ops::Deref for CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
     type Target = CopyMemoryToAccelerationStructureInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
-    pub fn src(
-        mut self,
-        src: DeviceOrHostAddressConstKHR,
-    ) -> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn src(mut self, src: DeviceOrHostAddressConstKHR) -> Self {
         self.inner.src = src;
         self
     }
-    pub fn dst(
-        mut self,
-        dst: AccelerationStructureKHR,
-    ) -> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn dst(mut self, dst: AccelerationStructureKHR) -> Self {
         self.inner.dst = dst;
         self
     }
-    pub fn mode(
-        mut self,
-        mode: CopyAccelerationStructureModeKHR,
-    ) -> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
+    pub fn mode(mut self, mode: CopyAccelerationStructureModeKHR) -> Self {
         self.inner.mode = mode;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyMemoryToAccelerationStructureInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyMemoryToAccelerationStructureInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyMemoryToAccelerationStructureInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45717,60 +41914,39 @@ impl RayTracingPipelineInterfaceCreateIn
         }
     }
 }
 #[repr(transparent)]
 pub struct RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
     inner: RayTracingPipelineInterfaceCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsRayTracingPipelineInterfaceCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
     type Target = RayTracingPipelineInterfaceCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
-    pub fn max_pipeline_ray_payload_size(
-        mut self,
-        max_pipeline_ray_payload_size: u32,
-    ) -> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
+    pub fn max_pipeline_ray_payload_size(mut self, max_pipeline_ray_payload_size: u32) -> Self {
         self.inner.max_pipeline_ray_payload_size = max_pipeline_ray_payload_size;
         self
     }
     pub fn max_pipeline_ray_hit_attribute_size(
         mut self,
         max_pipeline_ray_hit_attribute_size: u32,
-    ) -> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_pipeline_ray_hit_attribute_size = max_pipeline_ray_hit_attribute_size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsRayTracingPipelineInterfaceCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> RayTracingPipelineInterfaceCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RayTracingPipelineInterfaceCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45800,54 +41976,33 @@ impl PipelineLibraryCreateInfoKHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct PipelineLibraryCreateInfoKHRBuilder<'a> {
     inner: PipelineLibraryCreateInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPipelineLibraryCreateInfoKHR {}
 impl<'a> ::std::ops::Deref for PipelineLibraryCreateInfoKHRBuilder<'a> {
     type Target = PipelineLibraryCreateInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineLibraryCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineLibraryCreateInfoKHRBuilder<'a> {
-    pub fn libraries(
-        mut self,
-        libraries: &'a [Pipeline],
-    ) -> PipelineLibraryCreateInfoKHRBuilder<'a> {
+    pub fn libraries(mut self, libraries: &'a [Pipeline]) -> Self {
         self.inner.library_count = libraries.len() as _;
         self.inner.p_libraries = libraries.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPipelineLibraryCreateInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PipelineLibraryCreateInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineLibraryCreateInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -45875,46 +42030,127 @@ impl PhysicalDeviceExtendedDynamicStateF
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceExtendedDynamicStateFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicStateFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceExtendedDynamicStateFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
-    pub fn extended_dynamic_state(
-        mut self,
-        extended_dynamic_state: bool,
-    ) -> PhysicalDeviceExtendedDynamicStateFeaturesEXTBuilder<'a> {
+    pub fn extended_dynamic_state(mut self, extended_dynamic_state: bool) -> Self {
         self.inner.extended_dynamic_state = extended_dynamic_state.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceExtendedDynamicStateFeaturesEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html>"]
+pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub extended_dynamic_state2: Bool32,
+    pub extended_dynamic_state2_logic_op: Bool32,
+    pub extended_dynamic_state2_patch_control_points: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+    fn default() -> PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+        PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            extended_dynamic_state2: Bool32::default(),
+            extended_dynamic_state2_logic_op: Bool32::default(),
+            extended_dynamic_state2_patch_control_points: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
+        PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder {
+            inner: PhysicalDeviceExtendedDynamicState2FeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceExtendedDynamicState2FeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExtendedDynamicState2FeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceExtendedDynamicState2FeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceExtendedDynamicState2FeaturesEXTBuilder<'a> {
+    pub fn extended_dynamic_state2(mut self, extended_dynamic_state2: bool) -> Self {
+        self.inner.extended_dynamic_state2 = extended_dynamic_state2.into();
+        self
+    }
+    pub fn extended_dynamic_state2_logic_op(
+        mut self,
+        extended_dynamic_state2_logic_op: bool,
+    ) -> Self {
+        self.inner.extended_dynamic_state2_logic_op = extended_dynamic_state2_logic_op.into();
+        self
+    }
+    pub fn extended_dynamic_state2_patch_control_points(
+        mut self,
+        extended_dynamic_state2_patch_control_points: bool,
+    ) -> Self {
+        self.inner.extended_dynamic_state2_patch_control_points =
+            extended_dynamic_state2_patch_control_points.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceExtendedDynamicState2FeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRenderPassTransformBeginInfoQCOM.html>"]
 pub struct RenderPassTransformBeginInfoQCOM {
     pub s_type: StructureType,
     pub p_next: *mut c_void,
     pub transform: SurfaceTransformFlagsKHR,
 }
 impl ::std::default::Default for RenderPassTransformBeginInfoQCOM {
     fn default() -> RenderPassTransformBeginInfoQCOM {
@@ -45947,20 +42183,17 @@ impl<'a> ::std::ops::Deref for RenderPas
     }
 }
 impl<'a> ::std::ops::DerefMut for RenderPassTransformBeginInfoQCOMBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> RenderPassTransformBeginInfoQCOMBuilder<'a> {
-    pub fn transform(
-        mut self,
-        transform: SurfaceTransformFlagsKHR,
-    ) -> RenderPassTransformBeginInfoQCOMBuilder<'a> {
+    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.transform = transform;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> RenderPassTransformBeginInfoQCOM {
         self.inner
@@ -46007,20 +42240,17 @@ impl<'a> ::std::ops::Deref for CopyComma
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyCommandTransformInfoQCOMBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyCommandTransformInfoQCOMBuilder<'a> {
-    pub fn transform(
-        mut self,
-        transform: SurfaceTransformFlagsKHR,
-    ) -> CopyCommandTransformInfoQCOMBuilder<'a> {
+    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.transform = transform;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyCommandTransformInfoQCOM {
         self.inner
@@ -46073,27 +42303,21 @@ impl<'a> ::std::ops::Deref for CommandBu
     }
 }
 impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
-    pub fn transform(
-        mut self,
-        transform: SurfaceTransformFlagsKHR,
-    ) -> CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
+    pub fn transform(mut self, transform: SurfaceTransformFlagsKHR) -> Self {
         self.inner.transform = transform;
         self
     }
-    pub fn render_area(
-        mut self,
-        render_area: Rect2D,
-    ) -> CommandBufferInheritanceRenderPassTransformInfoQCOMBuilder<'a> {
+    pub fn render_area(mut self, render_area: Rect2D) -> Self {
         self.inner.render_area = render_area;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CommandBufferInheritanceRenderPassTransformInfoQCOM {
         self.inner
@@ -46124,34 +42348,36 @@ impl PhysicalDeviceDiagnosticsConfigFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceDiagnosticsConfigFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceDiagnosticsConfigFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceDiagnosticsConfigFeaturesNV;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
-    pub fn diagnostics_config(
-        mut self,
-        diagnostics_config: bool,
-    ) -> PhysicalDeviceDiagnosticsConfigFeaturesNVBuilder<'a> {
+    pub fn diagnostics_config(mut self, diagnostics_config: bool) -> Self {
         self.inner.diagnostics_config = diagnostics_config.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceDiagnosticsConfigFeaturesNV {
         self.inner
@@ -46196,20 +42422,17 @@ impl<'a> ::std::ops::Deref for DeviceDia
     }
 }
 impl<'a> ::std::ops::DerefMut for DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
-    pub fn flags(
-        mut self,
-        flags: DeviceDiagnosticsConfigFlagsNV,
-    ) -> DeviceDiagnosticsConfigCreateInfoNVBuilder<'a> {
+    pub fn flags(mut self, flags: DeviceDiagnosticsConfigFlagsNV) -> Self {
         self.inner.flags = flags;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> DeviceDiagnosticsConfigCreateInfoNV {
         self.inner
@@ -46240,16 +42463,24 @@ impl PhysicalDeviceZeroInitializeWorkgro
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR;
     fn deref(&self) -> &Self::Target {
@@ -46262,30 +42493,105 @@ impl<'a> ::std::ops::DerefMut
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'a> {
     pub fn shader_zero_initialize_workgroup_memory(
         mut self,
         shader_zero_initialize_workgroup_memory: bool,
-    ) -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.shader_zero_initialize_workgroup_memory =
             shader_zero_initialize_workgroup_memory.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html>"]
+pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub shader_subgroup_uniform_control_flow: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+    fn default() -> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+        PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+            s_type:
+                StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            shader_subgroup_uniform_control_flow: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+    pub fn builder<'a>() -> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
+        PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder {
+            inner: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
+    inner: PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
+{
+}
+unsafe impl ExtendsDeviceCreateInfo
+    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {}
+impl<'a> ::std::ops::Deref
+    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a>
+{
+    type Target = PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut
+    for PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a>
+{
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRBuilder<'a> {
+    pub fn shader_subgroup_uniform_control_flow(
+        mut self,
+        shader_subgroup_uniform_control_flow: bool,
+    ) -> Self {
+        self.inner.shader_subgroup_uniform_control_flow =
+            shader_subgroup_uniform_control_flow.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html>"]
 pub struct PhysicalDeviceRobustness2FeaturesEXT {
     pub s_type: StructureType,
     pub p_next: *mut c_void,
     pub robust_buffer_access2: Bool32,
     pub robust_image_access2: Bool32,
     pub null_descriptor: Bool32,
 }
@@ -46308,48 +42614,41 @@ impl PhysicalDeviceRobustness2FeaturesEX
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceRobustness2FeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRobustness2FeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRobustness2FeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRobustness2FeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRobustness2FeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceRobustness2FeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
-    pub fn robust_buffer_access2(
-        mut self,
-        robust_buffer_access2: bool,
-    ) -> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
+    pub fn robust_buffer_access2(mut self, robust_buffer_access2: bool) -> Self {
         self.inner.robust_buffer_access2 = robust_buffer_access2.into();
         self
     }
-    pub fn robust_image_access2(
-        mut self,
-        robust_image_access2: bool,
-    ) -> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
+    pub fn robust_image_access2(mut self, robust_image_access2: bool) -> Self {
         self.inner.robust_image_access2 = robust_image_access2.into();
         self
     }
-    pub fn null_descriptor(
-        mut self,
-        null_descriptor: bool,
-    ) -> PhysicalDeviceRobustness2FeaturesEXTBuilder<'a> {
+    pub fn null_descriptor(mut self, null_descriptor: bool) -> Self {
         self.inner.null_descriptor = null_descriptor.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRobustness2FeaturesEXT {
         self.inner
@@ -46399,25 +42698,25 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
     pub fn robust_storage_buffer_access_size_alignment(
         mut self,
         robust_storage_buffer_access_size_alignment: DeviceSize,
-    ) -> PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.robust_storage_buffer_access_size_alignment =
             robust_storage_buffer_access_size_alignment;
         self
     }
     pub fn robust_uniform_buffer_access_size_alignment(
         mut self,
         robust_uniform_buffer_access_size_alignment: DeviceSize,
-    ) -> PhysicalDeviceRobustness2PropertiesEXTBuilder<'a> {
+    ) -> Self {
         self.inner.robust_uniform_buffer_access_size_alignment =
             robust_uniform_buffer_access_size_alignment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceRobustness2PropertiesEXT {
@@ -46449,34 +42748,33 @@ impl PhysicalDeviceImageRobustnessFeatur
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceImageRobustnessFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceImageRobustnessFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceImageRobustnessFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceImageRobustnessFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'a> {
-    pub fn robust_image_access(
-        mut self,
-        robust_image_access: bool,
-    ) -> PhysicalDeviceImageRobustnessFeaturesEXTBuilder<'a> {
+    pub fn robust_image_access(mut self, robust_image_access: bool) -> Self {
         self.inner.robust_image_access = robust_image_access.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceImageRobustnessFeaturesEXT {
         self.inner
@@ -46513,16 +42811,24 @@ impl PhysicalDeviceWorkgroupMemoryExplic
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
+{
+}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
     fn deref(&self) -> &Self::Target {
@@ -46535,41 +42841,41 @@ impl<'a> ::std::ops::DerefMut
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
     pub fn workgroup_memory_explicit_layout(
         mut self,
         workgroup_memory_explicit_layout: bool,
-    ) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.workgroup_memory_explicit_layout = workgroup_memory_explicit_layout.into();
         self
     }
     pub fn workgroup_memory_explicit_layout_scalar_block_layout(
         mut self,
         workgroup_memory_explicit_layout_scalar_block_layout: bool,
-    ) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .workgroup_memory_explicit_layout_scalar_block_layout =
             workgroup_memory_explicit_layout_scalar_block_layout.into();
         self
     }
     pub fn workgroup_memory_explicit_layout8_bit_access(
         mut self,
         workgroup_memory_explicit_layout8_bit_access: bool,
-    ) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.workgroup_memory_explicit_layout8_bit_access =
             workgroup_memory_explicit_layout8_bit_access.into();
         self
     }
     pub fn workgroup_memory_explicit_layout16_bit_access(
         mut self,
         workgroup_memory_explicit_layout16_bit_access: bool,
-    ) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.workgroup_memory_explicit_layout16_bit_access =
             workgroup_memory_explicit_layout16_bit_access.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
@@ -46629,16 +42935,21 @@ impl PhysicalDevicePortabilitySubsetFeat
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
     inner: PhysicalDevicePortabilitySubsetFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevicePortabilitySubsetFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevicePortabilitySubsetFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
     type Target = PhysicalDevicePortabilitySubsetFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
@@ -46646,113 +42957,83 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
     pub fn constant_alpha_color_blend_factors(
         mut self,
         constant_alpha_color_blend_factors: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.constant_alpha_color_blend_factors = constant_alpha_color_blend_factors.into();
         self
     }
-    pub fn events(mut self, events: bool) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn events(mut self, events: bool) -> Self {
         self.inner.events = events.into();
         self
     }
     pub fn image_view_format_reinterpretation(
         mut self,
         image_view_format_reinterpretation: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.image_view_format_reinterpretation = image_view_format_reinterpretation.into();
         self
     }
-    pub fn image_view_format_swizzle(
-        mut self,
-        image_view_format_swizzle: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn image_view_format_swizzle(mut self, image_view_format_swizzle: bool) -> Self {
         self.inner.image_view_format_swizzle = image_view_format_swizzle.into();
         self
     }
-    pub fn image_view2_d_on3_d_image(
-        mut self,
-        image_view2_d_on3_d_image: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn image_view2_d_on3_d_image(mut self, image_view2_d_on3_d_image: bool) -> Self {
         self.inner.image_view2_d_on3_d_image = image_view2_d_on3_d_image.into();
         self
     }
-    pub fn multisample_array_image(
-        mut self,
-        multisample_array_image: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn multisample_array_image(mut self, multisample_array_image: bool) -> Self {
         self.inner.multisample_array_image = multisample_array_image.into();
         self
     }
-    pub fn mutable_comparison_samplers(
-        mut self,
-        mutable_comparison_samplers: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn mutable_comparison_samplers(mut self, mutable_comparison_samplers: bool) -> Self {
         self.inner.mutable_comparison_samplers = mutable_comparison_samplers.into();
         self
     }
-    pub fn point_polygons(
-        mut self,
-        point_polygons: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn point_polygons(mut self, point_polygons: bool) -> Self {
         self.inner.point_polygons = point_polygons.into();
         self
     }
-    pub fn sampler_mip_lod_bias(
-        mut self,
-        sampler_mip_lod_bias: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn sampler_mip_lod_bias(mut self, sampler_mip_lod_bias: bool) -> Self {
         self.inner.sampler_mip_lod_bias = sampler_mip_lod_bias.into();
         self
     }
-    pub fn separate_stencil_mask_ref(
-        mut self,
-        separate_stencil_mask_ref: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn separate_stencil_mask_ref(mut self, separate_stencil_mask_ref: bool) -> Self {
         self.inner.separate_stencil_mask_ref = separate_stencil_mask_ref.into();
         self
     }
     pub fn shader_sample_rate_interpolation_functions(
         mut self,
         shader_sample_rate_interpolation_functions: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.shader_sample_rate_interpolation_functions =
             shader_sample_rate_interpolation_functions.into();
         self
     }
-    pub fn tessellation_isolines(
-        mut self,
-        tessellation_isolines: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn tessellation_isolines(mut self, tessellation_isolines: bool) -> Self {
         self.inner.tessellation_isolines = tessellation_isolines.into();
         self
     }
-    pub fn tessellation_point_mode(
-        mut self,
-        tessellation_point_mode: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn tessellation_point_mode(mut self, tessellation_point_mode: bool) -> Self {
         self.inner.tessellation_point_mode = tessellation_point_mode.into();
         self
     }
-    pub fn triangle_fans(
-        mut self,
-        triangle_fans: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    pub fn triangle_fans(mut self, triangle_fans: bool) -> Self {
         self.inner.triangle_fans = triangle_fans.into();
         self
     }
     pub fn vertex_attribute_access_beyond_stride(
         mut self,
         vertex_attribute_access_beyond_stride: bool,
-    ) -> PhysicalDevicePortabilitySubsetFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.vertex_attribute_access_beyond_stride =
             vertex_attribute_access_beyond_stride.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePortabilitySubsetFeaturesKHR {
@@ -46804,17 +43085,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
     pub fn min_vertex_input_binding_stride_alignment(
         mut self,
         min_vertex_input_binding_stride_alignment: u32,
-    ) -> PhysicalDevicePortabilitySubsetPropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.min_vertex_input_binding_stride_alignment =
             min_vertex_input_binding_stride_alignment;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevicePortabilitySubsetPropertiesKHR {
@@ -46848,53 +43129,109 @@ impl PhysicalDevice4444FormatsFeaturesEX
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
     inner: PhysicalDevice4444FormatsFeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice4444FormatsFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDevice4444FormatsFeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice4444FormatsFeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDevice4444FormatsFeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
     type Target = PhysicalDevice4444FormatsFeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
-    pub fn format_a4r4g4b4(
-        mut self,
-        format_a4r4g4b4: bool,
-    ) -> PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
+    pub fn format_a4r4g4b4(mut self, format_a4r4g4b4: bool) -> Self {
         self.inner.format_a4r4g4b4 = format_a4r4g4b4.into();
         self
     }
-    pub fn format_a4b4g4r4(
-        mut self,
-        format_a4b4g4r4: bool,
-    ) -> PhysicalDevice4444FormatsFeaturesEXTBuilder<'a> {
+    pub fn format_a4b4g4r4(mut self, format_a4b4g4r4: bool) -> Self {
         self.inner.format_a4b4g4r4 = format_a4b4g4r4.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDevice4444FormatsFeaturesEXT {
         self.inner
     }
 }
 #[repr(C)]
 #[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html>"]
+pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub subpass_shading: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+    fn default() -> PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+        PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+            s_type: StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
+            p_next: ::std::ptr::null_mut(),
+            subpass_shading: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+    pub fn builder<'a>() -> PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
+        PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder {
+            inner: PhysicalDeviceSubpassShadingFeaturesHUAWEI::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
+    inner: PhysicalDeviceSubpassShadingFeaturesHUAWEI,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSubpassShadingFeaturesHUAWEI {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
+    type Target = PhysicalDeviceSubpassShadingFeaturesHUAWEI;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceSubpassShadingFeaturesHUAWEIBuilder<'a> {
+    pub fn subpass_shading(mut self, subpass_shading: bool) -> Self {
+        self.inner.subpass_shading = subpass_shading.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceSubpassShadingFeaturesHUAWEI {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
 #[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferCopy2KHR.html>"]
 pub struct BufferCopy2KHR {
     pub s_type: StructureType,
     pub p_next: *const c_void,
     pub src_offset: DeviceSize,
     pub dst_offset: DeviceSize,
     pub size: DeviceSize,
 }
@@ -46917,58 +43254,40 @@ impl BufferCopy2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct BufferCopy2KHRBuilder<'a> {
     inner: BufferCopy2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBufferCopy2KHR {}
 impl<'a> ::std::ops::Deref for BufferCopy2KHRBuilder<'a> {
     type Target = BufferCopy2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferCopy2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferCopy2KHRBuilder<'a> {
-    pub fn src_offset(mut self, src_offset: DeviceSize) -> BufferCopy2KHRBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: DeviceSize) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> BufferCopy2KHRBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: DeviceSize) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn size(mut self, size: DeviceSize) -> BufferCopy2KHRBuilder<'a> {
+    pub fn size(mut self, size: DeviceSize) -> Self {
         self.inner.size = size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferCopy2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferCopy2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BufferCopy2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47004,72 +43323,48 @@ impl ImageCopy2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageCopy2KHRBuilder<'a> {
     inner: ImageCopy2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageCopy2KHR {}
 impl<'a> ::std::ops::Deref for ImageCopy2KHRBuilder<'a> {
     type Target = ImageCopy2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageCopy2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageCopy2KHRBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageCopy2KHRBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offset(mut self, src_offset: Offset3D) -> ImageCopy2KHRBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageCopy2KHRBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: Offset3D) -> ImageCopy2KHRBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> ImageCopy2KHRBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageCopy2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageCopy2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageCopy2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47116,47 +43411,38 @@ impl<'a> ::std::ops::Deref for ImageBlit
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageBlit2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageBlit2KHRBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageBlit2KHRBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> ImageBlit2KHRBuilder<'a> {
+    pub fn src_offsets(mut self, src_offsets: [Offset3D; 2]) -> Self {
         self.inner.src_offsets = src_offsets;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageBlit2KHRBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> ImageBlit2KHRBuilder<'a> {
+    pub fn dst_offsets(mut self, dst_offsets: [Offset3D; 2]) -> Self {
         self.inner.dst_offsets = dst_offsets;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageBlit2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageBlit2KHRBuilder<'a> {
+    pub fn push_next<T: ExtendsImageBlit2KHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -47215,55 +43501,46 @@ impl<'a> ::std::ops::Deref for BufferIma
     }
 }
 impl<'a> ::std::ops::DerefMut for BufferImageCopy2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BufferImageCopy2KHRBuilder<'a> {
-    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn buffer_offset(mut self, buffer_offset: DeviceSize) -> Self {
         self.inner.buffer_offset = buffer_offset;
         self
     }
-    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn buffer_row_length(mut self, buffer_row_length: u32) -> Self {
         self.inner.buffer_row_length = buffer_row_length;
         self
     }
-    pub fn buffer_image_height(
-        mut self,
-        buffer_image_height: u32,
-    ) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn buffer_image_height(mut self, buffer_image_height: u32) -> Self {
         self.inner.buffer_image_height = buffer_image_height;
         self
     }
-    pub fn image_subresource(
-        mut self,
-        image_subresource: ImageSubresourceLayers,
-    ) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn image_subresource(mut self, image_subresource: ImageSubresourceLayers) -> Self {
         self.inner.image_subresource = image_subresource;
         self
     }
-    pub fn image_offset(mut self, image_offset: Offset3D) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn image_offset(mut self, image_offset: Offset3D) -> Self {
         self.inner.image_offset = image_offset;
         self
     }
-    pub fn image_extent(mut self, image_extent: Extent3D) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn image_extent(mut self, image_extent: Extent3D) -> Self {
         self.inner.image_extent = image_extent;
         self
     }
     #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
     #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
     #[doc = r" valid extension structs can be pushed into the chain."]
     #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
     #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBufferImageCopy2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> BufferImageCopy2KHRBuilder<'a> {
+    pub fn push_next<T: ExtendsBufferImageCopy2KHR>(mut self, next: &'a mut T) -> Self {
         unsafe {
             let next_ptr = next as *mut T as *mut BaseOutStructure;
             let last_next = ptr_chain_iter(next).last().unwrap();
             (*last_next).p_next = self.inner.p_next as _;
             self.inner.p_next = next_ptr as _;
         }
         self
     }
@@ -47307,72 +43584,48 @@ impl ImageResolve2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ImageResolve2KHRBuilder<'a> {
     inner: ImageResolve2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsImageResolve2KHR {}
 impl<'a> ::std::ops::Deref for ImageResolve2KHRBuilder<'a> {
     type Target = ImageResolve2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ImageResolve2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ImageResolve2KHRBuilder<'a> {
-    pub fn src_subresource(
-        mut self,
-        src_subresource: ImageSubresourceLayers,
-    ) -> ImageResolve2KHRBuilder<'a> {
+    pub fn src_subresource(mut self, src_subresource: ImageSubresourceLayers) -> Self {
         self.inner.src_subresource = src_subresource;
         self
     }
-    pub fn src_offset(mut self, src_offset: Offset3D) -> ImageResolve2KHRBuilder<'a> {
+    pub fn src_offset(mut self, src_offset: Offset3D) -> Self {
         self.inner.src_offset = src_offset;
         self
     }
-    pub fn dst_subresource(
-        mut self,
-        dst_subresource: ImageSubresourceLayers,
-    ) -> ImageResolve2KHRBuilder<'a> {
+    pub fn dst_subresource(mut self, dst_subresource: ImageSubresourceLayers) -> Self {
         self.inner.dst_subresource = dst_subresource;
         self
     }
-    pub fn dst_offset(mut self, dst_offset: Offset3D) -> ImageResolve2KHRBuilder<'a> {
+    pub fn dst_offset(mut self, dst_offset: Offset3D) -> Self {
         self.inner.dst_offset = dst_offset;
         self
     }
-    pub fn extent(mut self, extent: Extent3D) -> ImageResolve2KHRBuilder<'a> {
+    pub fn extent(mut self, extent: Extent3D) -> Self {
         self.inner.extent = extent;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsImageResolve2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ImageResolve2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ImageResolve2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47406,59 +43659,41 @@ impl CopyBufferInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyBufferInfo2KHRBuilder<'a> {
     inner: CopyBufferInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyBufferInfo2KHR {}
 impl<'a> ::std::ops::Deref for CopyBufferInfo2KHRBuilder<'a> {
     type Target = CopyBufferInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyBufferInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyBufferInfo2KHRBuilder<'a> {
-    pub fn src_buffer(mut self, src_buffer: Buffer) -> CopyBufferInfo2KHRBuilder<'a> {
+    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
         self.inner.src_buffer = src_buffer;
         self
     }
-    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> CopyBufferInfo2KHRBuilder<'a> {
+    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
         self.inner.dst_buffer = dst_buffer;
         self
     }
-    pub fn regions(mut self, regions: &'a [BufferCopy2KHR]) -> CopyBufferInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [BufferCopy2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyBufferInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyBufferInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyBufferInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47496,73 +43731,49 @@ impl CopyImageInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyImageInfo2KHRBuilder<'a> {
     inner: CopyImageInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyImageInfo2KHR {}
 impl<'a> ::std::ops::Deref for CopyImageInfo2KHRBuilder<'a> {
     type Target = CopyImageInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyImageInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyImageInfo2KHRBuilder<'a> {
-    pub fn src_image(mut self, src_image: Image) -> CopyImageInfo2KHRBuilder<'a> {
+    pub fn src_image(mut self, src_image: Image) -> Self {
         self.inner.src_image = src_image;
         self
     }
-    pub fn src_image_layout(
-        mut self,
-        src_image_layout: ImageLayout,
-    ) -> CopyImageInfo2KHRBuilder<'a> {
+    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
         self.inner.src_image_layout = src_image_layout;
         self
     }
-    pub fn dst_image(mut self, dst_image: Image) -> CopyImageInfo2KHRBuilder<'a> {
+    pub fn dst_image(mut self, dst_image: Image) -> Self {
         self.inner.dst_image = dst_image;
         self
     }
-    pub fn dst_image_layout(
-        mut self,
-        dst_image_layout: ImageLayout,
-    ) -> CopyImageInfo2KHRBuilder<'a> {
+    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
         self.inner.dst_image_layout = dst_image_layout;
         self
     }
-    pub fn regions(mut self, regions: &'a [ImageCopy2KHR]) -> CopyImageInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [ImageCopy2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyImageInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyImageInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyImageInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47602,77 +43813,53 @@ impl BlitImageInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct BlitImageInfo2KHRBuilder<'a> {
     inner: BlitImageInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsBlitImageInfo2KHR {}
 impl<'a> ::std::ops::Deref for BlitImageInfo2KHRBuilder<'a> {
     type Target = BlitImageInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for BlitImageInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> BlitImageInfo2KHRBuilder<'a> {
-    pub fn src_image(mut self, src_image: Image) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn src_image(mut self, src_image: Image) -> Self {
         self.inner.src_image = src_image;
         self
     }
-    pub fn src_image_layout(
-        mut self,
-        src_image_layout: ImageLayout,
-    ) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
         self.inner.src_image_layout = src_image_layout;
         self
     }
-    pub fn dst_image(mut self, dst_image: Image) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn dst_image(mut self, dst_image: Image) -> Self {
         self.inner.dst_image = dst_image;
         self
     }
-    pub fn dst_image_layout(
-        mut self,
-        dst_image_layout: ImageLayout,
-    ) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
         self.inner.dst_image_layout = dst_image_layout;
         self
     }
-    pub fn regions(mut self, regions: &'a [ImageBlit2KHR]) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [ImageBlit2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    pub fn filter(mut self, filter: Filter) -> BlitImageInfo2KHRBuilder<'a> {
+    pub fn filter(mut self, filter: Filter) -> Self {
         self.inner.filter = filter;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsBlitImageInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> BlitImageInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> BlitImageInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47708,69 +43895,45 @@ impl CopyBufferToImageInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyBufferToImageInfo2KHRBuilder<'a> {
     inner: CopyBufferToImageInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyBufferToImageInfo2KHR {}
 impl<'a> ::std::ops::Deref for CopyBufferToImageInfo2KHRBuilder<'a> {
     type Target = CopyBufferToImageInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyBufferToImageInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyBufferToImageInfo2KHRBuilder<'a> {
-    pub fn src_buffer(mut self, src_buffer: Buffer) -> CopyBufferToImageInfo2KHRBuilder<'a> {
+    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
         self.inner.src_buffer = src_buffer;
         self
     }
-    pub fn dst_image(mut self, dst_image: Image) -> CopyBufferToImageInfo2KHRBuilder<'a> {
+    pub fn dst_image(mut self, dst_image: Image) -> Self {
         self.inner.dst_image = dst_image;
         self
     }
-    pub fn dst_image_layout(
-        mut self,
-        dst_image_layout: ImageLayout,
-    ) -> CopyBufferToImageInfo2KHRBuilder<'a> {
+    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
         self.inner.dst_image_layout = dst_image_layout;
         self
     }
-    pub fn regions(
-        mut self,
-        regions: &'a [BufferImageCopy2KHR],
-    ) -> CopyBufferToImageInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [BufferImageCopy2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyBufferToImageInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyBufferToImageInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyBufferToImageInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47806,69 +43969,45 @@ impl CopyImageToBufferInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct CopyImageToBufferInfo2KHRBuilder<'a> {
     inner: CopyImageToBufferInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsCopyImageToBufferInfo2KHR {}
 impl<'a> ::std::ops::Deref for CopyImageToBufferInfo2KHRBuilder<'a> {
     type Target = CopyImageToBufferInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for CopyImageToBufferInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> CopyImageToBufferInfo2KHRBuilder<'a> {
-    pub fn src_image(mut self, src_image: Image) -> CopyImageToBufferInfo2KHRBuilder<'a> {
+    pub fn src_image(mut self, src_image: Image) -> Self {
         self.inner.src_image = src_image;
         self
     }
-    pub fn src_image_layout(
-        mut self,
-        src_image_layout: ImageLayout,
-    ) -> CopyImageToBufferInfo2KHRBuilder<'a> {
+    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
         self.inner.src_image_layout = src_image_layout;
         self
     }
-    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> CopyImageToBufferInfo2KHRBuilder<'a> {
+    pub fn dst_buffer(mut self, dst_buffer: Buffer) -> Self {
         self.inner.dst_buffer = dst_buffer;
         self
     }
-    pub fn regions(
-        mut self,
-        regions: &'a [BufferImageCopy2KHR],
-    ) -> CopyImageToBufferInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [BufferImageCopy2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsCopyImageToBufferInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> CopyImageToBufferInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> CopyImageToBufferInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -47906,73 +44045,49 @@ impl ResolveImageInfo2KHR {
         }
     }
 }
 #[repr(transparent)]
 pub struct ResolveImageInfo2KHRBuilder<'a> {
     inner: ResolveImageInfo2KHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsResolveImageInfo2KHR {}
 impl<'a> ::std::ops::Deref for ResolveImageInfo2KHRBuilder<'a> {
     type Target = ResolveImageInfo2KHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for ResolveImageInfo2KHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> ResolveImageInfo2KHRBuilder<'a> {
-    pub fn src_image(mut self, src_image: Image) -> ResolveImageInfo2KHRBuilder<'a> {
+    pub fn src_image(mut self, src_image: Image) -> Self {
         self.inner.src_image = src_image;
         self
     }
-    pub fn src_image_layout(
-        mut self,
-        src_image_layout: ImageLayout,
-    ) -> ResolveImageInfo2KHRBuilder<'a> {
+    pub fn src_image_layout(mut self, src_image_layout: ImageLayout) -> Self {
         self.inner.src_image_layout = src_image_layout;
         self
     }
-    pub fn dst_image(mut self, dst_image: Image) -> ResolveImageInfo2KHRBuilder<'a> {
+    pub fn dst_image(mut self, dst_image: Image) -> Self {
         self.inner.dst_image = dst_image;
         self
     }
-    pub fn dst_image_layout(
-        mut self,
-        dst_image_layout: ImageLayout,
-    ) -> ResolveImageInfo2KHRBuilder<'a> {
+    pub fn dst_image_layout(mut self, dst_image_layout: ImageLayout) -> Self {
         self.inner.dst_image_layout = dst_image_layout;
         self
     }
-    pub fn regions(mut self, regions: &'a [ImageResolve2KHR]) -> ResolveImageInfo2KHRBuilder<'a> {
+    pub fn regions(mut self, regions: &'a [ImageResolve2KHR]) -> Self {
         self.inner.region_count = regions.len() as _;
         self.inner.p_regions = regions.as_ptr();
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsResolveImageInfo2KHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> ResolveImageInfo2KHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> ResolveImageInfo2KHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -48002,41 +44117,40 @@ impl PhysicalDeviceShaderImageAtomicInt6
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
     inner: PhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
     type Target = PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
-    pub fn shader_image_int64_atomics(
-        mut self,
-        shader_image_int64_atomics: bool,
-    ) -> PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
+    pub fn shader_image_int64_atomics(mut self, shader_image_int64_atomics: bool) -> Self {
         self.inner.shader_image_int64_atomics = shader_image_int64_atomics.into();
         self
     }
-    pub fn sparse_image_int64_atomics(
-        mut self,
-        sparse_image_int64_atomics: bool,
-    ) -> PhysicalDeviceShaderImageAtomicInt64FeaturesEXTBuilder<'a> {
+    pub fn sparse_image_int64_atomics(mut self, sparse_image_int64_atomics: bool) -> Self {
         self.inner.sparse_image_int64_atomics = sparse_image_int64_atomics.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
         self.inner
@@ -48086,24 +44200,24 @@ impl<'a> ::std::ops::DerefMut for Fragme
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
     pub fn fragment_shading_rate_attachment(
         mut self,
         fragment_shading_rate_attachment: &'a AttachmentReference2,
-    ) -> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.p_fragment_shading_rate_attachment = fragment_shading_rate_attachment;
         self
     }
     pub fn shading_rate_attachment_texel_size(
         mut self,
         shading_rate_attachment_texel_size: Extent2D,
-    ) -> FragmentShadingRateAttachmentInfoKHRBuilder<'a> {
+    ) -> Self {
         self.inner.shading_rate_attachment_texel_size = shading_rate_attachment_texel_size;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> FragmentShadingRateAttachmentInfoKHR {
         self.inner
@@ -48153,27 +44267,21 @@ impl<'a> ::std::ops::Deref for PipelineF
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
-    pub fn fragment_size(
-        mut self,
-        fragment_size: Extent2D,
-    ) -> PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
+    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
         self.inner.fragment_size = fragment_size;
         self
     }
-    pub fn combiner_ops(
-        mut self,
-        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
-    ) -> PipelineFragmentShadingRateStateCreateInfoKHRBuilder<'a> {
+    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
         self.inner.combiner_ops = combiner_ops;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineFragmentShadingRateStateCreateInfoKHR {
         self.inner
@@ -48208,48 +44316,50 @@ impl PhysicalDeviceFragmentShadingRateFe
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceFragmentShadingRateFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'_> {}
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceFragmentShadingRateFeaturesKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
-    pub fn pipeline_fragment_shading_rate(
-        mut self,
-        pipeline_fragment_shading_rate: bool,
-    ) -> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
+    pub fn pipeline_fragment_shading_rate(mut self, pipeline_fragment_shading_rate: bool) -> Self {
         self.inner.pipeline_fragment_shading_rate = pipeline_fragment_shading_rate.into();
         self
     }
     pub fn primitive_fragment_shading_rate(
         mut self,
         primitive_fragment_shading_rate: bool,
-    ) -> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.primitive_fragment_shading_rate = primitive_fragment_shading_rate.into();
         self
     }
     pub fn attachment_fragment_shading_rate(
         mut self,
         attachment_fragment_shading_rate: bool,
-    ) -> PhysicalDeviceFragmentShadingRateFeaturesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.attachment_fragment_shading_rate = attachment_fragment_shading_rate.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShadingRateFeaturesKHR {
         self.inner
@@ -48332,148 +44442,142 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
     pub fn min_fragment_shading_rate_attachment_texel_size(
         mut self,
         min_fragment_shading_rate_attachment_texel_size: Extent2D,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.min_fragment_shading_rate_attachment_texel_size =
             min_fragment_shading_rate_attachment_texel_size;
         self
     }
     pub fn max_fragment_shading_rate_attachment_texel_size(
         mut self,
         max_fragment_shading_rate_attachment_texel_size: Extent2D,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_shading_rate_attachment_texel_size =
             max_fragment_shading_rate_attachment_texel_size;
         self
     }
     pub fn max_fragment_shading_rate_attachment_texel_size_aspect_ratio(
         mut self,
         max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .max_fragment_shading_rate_attachment_texel_size_aspect_ratio =
             max_fragment_shading_rate_attachment_texel_size_aspect_ratio;
         self
     }
     pub fn primitive_fragment_shading_rate_with_multiple_viewports(
         mut self,
         primitive_fragment_shading_rate_with_multiple_viewports: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .primitive_fragment_shading_rate_with_multiple_viewports =
             primitive_fragment_shading_rate_with_multiple_viewports.into();
         self
     }
     pub fn layered_shading_rate_attachments(
         mut self,
         layered_shading_rate_attachments: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.layered_shading_rate_attachments = layered_shading_rate_attachments.into();
         self
     }
     pub fn fragment_shading_rate_non_trivial_combiner_ops(
         mut self,
         fragment_shading_rate_non_trivial_combiner_ops: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shading_rate_non_trivial_combiner_ops =
             fragment_shading_rate_non_trivial_combiner_ops.into();
         self
     }
-    pub fn max_fragment_size(
-        mut self,
-        max_fragment_size: Extent2D,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    pub fn max_fragment_size(mut self, max_fragment_size: Extent2D) -> Self {
         self.inner.max_fragment_size = max_fragment_size;
         self
     }
-    pub fn max_fragment_size_aspect_ratio(
-        mut self,
-        max_fragment_size_aspect_ratio: u32,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    pub fn max_fragment_size_aspect_ratio(mut self, max_fragment_size_aspect_ratio: u32) -> Self {
         self.inner.max_fragment_size_aspect_ratio = max_fragment_size_aspect_ratio;
         self
     }
     pub fn max_fragment_shading_rate_coverage_samples(
         mut self,
         max_fragment_shading_rate_coverage_samples: u32,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_shading_rate_coverage_samples =
             max_fragment_shading_rate_coverage_samples;
         self
     }
     pub fn max_fragment_shading_rate_rasterization_samples(
         mut self,
         max_fragment_shading_rate_rasterization_samples: SampleCountFlags,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_shading_rate_rasterization_samples =
             max_fragment_shading_rate_rasterization_samples;
         self
     }
     pub fn fragment_shading_rate_with_shader_depth_stencil_writes(
         mut self,
         fragment_shading_rate_with_shader_depth_stencil_writes: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .fragment_shading_rate_with_shader_depth_stencil_writes =
             fragment_shading_rate_with_shader_depth_stencil_writes.into();
         self
     }
     pub fn fragment_shading_rate_with_sample_mask(
         mut self,
         fragment_shading_rate_with_sample_mask: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shading_rate_with_sample_mask =
             fragment_shading_rate_with_sample_mask.into();
         self
     }
     pub fn fragment_shading_rate_with_shader_sample_mask(
         mut self,
         fragment_shading_rate_with_shader_sample_mask: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shading_rate_with_shader_sample_mask =
             fragment_shading_rate_with_shader_sample_mask.into();
         self
     }
     pub fn fragment_shading_rate_with_conservative_rasterization(
         mut self,
         fragment_shading_rate_with_conservative_rasterization: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .fragment_shading_rate_with_conservative_rasterization =
             fragment_shading_rate_with_conservative_rasterization.into();
         self
     }
     pub fn fragment_shading_rate_with_fragment_shader_interlock(
         mut self,
         fragment_shading_rate_with_fragment_shader_interlock: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .fragment_shading_rate_with_fragment_shader_interlock =
             fragment_shading_rate_with_fragment_shader_interlock.into();
         self
     }
     pub fn fragment_shading_rate_with_custom_sample_locations(
         mut self,
         fragment_shading_rate_with_custom_sample_locations: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner
             .fragment_shading_rate_with_custom_sample_locations =
             fragment_shading_rate_with_custom_sample_locations.into();
         self
     }
     pub fn fragment_shading_rate_strict_multiply_combiner(
         mut self,
         fragment_shading_rate_strict_multiply_combiner: bool,
-    ) -> PhysicalDeviceFragmentShadingRatePropertiesKHRBuilder<'a> {
+    ) -> Self {
         self.inner.fragment_shading_rate_strict_multiply_combiner =
             fragment_shading_rate_strict_multiply_combiner.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShadingRatePropertiesKHR {
@@ -48507,60 +44611,36 @@ impl PhysicalDeviceFragmentShadingRateKH
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
     inner: PhysicalDeviceFragmentShadingRateKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsPhysicalDeviceFragmentShadingRateKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
     type Target = PhysicalDeviceFragmentShadingRateKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
-    pub fn sample_counts(
-        mut self,
-        sample_counts: SampleCountFlags,
-    ) -> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
+    pub fn sample_counts(mut self, sample_counts: SampleCountFlags) -> Self {
         self.inner.sample_counts = sample_counts;
         self
     }
-    pub fn fragment_size(
-        mut self,
-        fragment_size: Extent2D,
-    ) -> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
+    pub fn fragment_size(mut self, fragment_size: Extent2D) -> Self {
         self.inner.fragment_size = fragment_size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsPhysicalDeviceFragmentShadingRateKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> PhysicalDeviceFragmentShadingRateKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShadingRateKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -48588,16 +44668,21 @@ impl PhysicalDeviceShaderTerminateInvoca
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'a> {
     inner: PhysicalDeviceShaderTerminateInvocationFeaturesKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceShaderTerminateInvocationFeaturesKHR {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'a> {
     type Target = PhysicalDeviceShaderTerminateInvocationFeaturesKHR;
     fn deref(&self) -> &Self::Target {
@@ -48605,20 +44690,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'a> {
-    pub fn shader_terminate_invocation(
-        mut self,
-        shader_terminate_invocation: bool,
-    ) -> PhysicalDeviceShaderTerminateInvocationFeaturesKHRBuilder<'a> {
+    pub fn shader_terminate_invocation(mut self, shader_terminate_invocation: bool) -> Self {
         self.inner.shader_terminate_invocation = shader_terminate_invocation.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceShaderTerminateInvocationFeaturesKHR {
         self.inner
@@ -48653,16 +44735,21 @@ impl PhysicalDeviceFragmentShadingRateEn
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
     inner: PhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
     type Target = PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
     fn deref(&self) -> &Self::Target {
@@ -48670,34 +44757,31 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
-    pub fn fragment_shading_rate_enums(
-        mut self,
-        fragment_shading_rate_enums: bool,
-    ) -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
+    pub fn fragment_shading_rate_enums(mut self, fragment_shading_rate_enums: bool) -> Self {
         self.inner.fragment_shading_rate_enums = fragment_shading_rate_enums.into();
         self
     }
     pub fn supersample_fragment_shading_rates(
         mut self,
         supersample_fragment_shading_rates: bool,
-    ) -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.supersample_fragment_shading_rates = supersample_fragment_shading_rates.into();
         self
     }
     pub fn no_invocation_fragment_shading_rates(
         mut self,
         no_invocation_fragment_shading_rates: bool,
-    ) -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNVBuilder<'a> {
+    ) -> Self {
         self.inner.no_invocation_fragment_shading_rates =
             no_invocation_fragment_shading_rates.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
@@ -48752,17 +44836,17 @@ impl<'a> ::std::ops::DerefMut for Physic
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
     pub fn max_fragment_shading_rate_invocation_count(
         mut self,
         max_fragment_shading_rate_invocation_count: SampleCountFlags,
-    ) -> PhysicalDeviceFragmentShadingRateEnumsPropertiesNVBuilder<'a> {
+    ) -> Self {
         self.inner.max_fragment_shading_rate_invocation_count =
             max_fragment_shading_rate_invocation_count;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
@@ -48815,34 +44899,25 @@ impl<'a> ::std::ops::Deref for PipelineF
     }
 }
 impl<'a> ::std::ops::DerefMut for PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
-    pub fn shading_rate_type(
-        mut self,
-        shading_rate_type: FragmentShadingRateTypeNV,
-    ) -> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
+    pub fn shading_rate_type(mut self, shading_rate_type: FragmentShadingRateTypeNV) -> Self {
         self.inner.shading_rate_type = shading_rate_type;
         self
     }
-    pub fn shading_rate(
-        mut self,
-        shading_rate: FragmentShadingRateNV,
-    ) -> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
+    pub fn shading_rate(mut self, shading_rate: FragmentShadingRateNV) -> Self {
         self.inner.shading_rate = shading_rate;
         self
     }
-    pub fn combiner_ops(
-        mut self,
-        combiner_ops: [FragmentShadingRateCombinerOpKHR; 2],
-    ) -> PipelineFragmentShadingRateEnumStateCreateInfoNVBuilder<'a> {
+    pub fn combiner_ops(mut self, combiner_ops: [FragmentShadingRateCombinerOpKHR; 2]) -> Self {
         self.inner.combiner_ops = combiner_ops;
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PipelineFragmentShadingRateEnumStateCreateInfoNV {
         self.inner
@@ -48877,67 +44952,40 @@ impl AccelerationStructureBuildSizesInfo
         }
     }
 }
 #[repr(transparent)]
 pub struct AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
     inner: AccelerationStructureBuildSizesInfoKHR,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
-pub unsafe trait ExtendsAccelerationStructureBuildSizesInfoKHR {}
 impl<'a> ::std::ops::Deref for AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
     type Target = AccelerationStructureBuildSizesInfoKHR;
     fn deref(&self) -> &Self::Target {
         &self.inner
     }
 }
 impl<'a> ::std::ops::DerefMut for AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
-    pub fn acceleration_structure_size(
-        mut self,
-        acceleration_structure_size: DeviceSize,
-    ) -> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
+    pub fn acceleration_structure_size(mut self, acceleration_structure_size: DeviceSize) -> Self {
         self.inner.acceleration_structure_size = acceleration_structure_size;
         self
     }
-    pub fn update_scratch_size(
-        mut self,
-        update_scratch_size: DeviceSize,
-    ) -> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
+    pub fn update_scratch_size(mut self, update_scratch_size: DeviceSize) -> Self {
         self.inner.update_scratch_size = update_scratch_size;
         self
     }
-    pub fn build_scratch_size(
-        mut self,
-        build_scratch_size: DeviceSize,
-    ) -> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
+    pub fn build_scratch_size(mut self, build_scratch_size: DeviceSize) -> Self {
         self.inner.build_scratch_size = build_scratch_size;
         self
     }
-    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
-    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
-    #[doc = r" valid extension structs can be pushed into the chain."]
-    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
-    #[doc = r" chain will look like `A -> D -> B -> C`."]
-    pub fn push_next<T: ExtendsAccelerationStructureBuildSizesInfoKHR>(
-        mut self,
-        next: &'a mut T,
-    ) -> AccelerationStructureBuildSizesInfoKHRBuilder<'a> {
-        unsafe {
-            let next_ptr = next as *mut T as *mut BaseOutStructure;
-            let last_next = ptr_chain_iter(next).last().unwrap();
-            (*last_next).p_next = self.inner.p_next as _;
-            self.inner.p_next = next_ptr as _;
-        }
-        self
-    }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> AccelerationStructureBuildSizesInfoKHR {
         self.inner
     }
 }
 #[repr(C)]
@@ -48965,16 +45013,21 @@ impl PhysicalDeviceMutableDescriptorType
         }
     }
 }
 #[repr(transparent)]
 pub struct PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'a> {
     inner: PhysicalDeviceMutableDescriptorTypeFeaturesVALVE,
     marker: ::std::marker::PhantomData<&'a ()>,
 }
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
 unsafe impl ExtendsDeviceCreateInfo
     for PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'_>
 {
 }
 unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {}
 impl<'a> ::std::ops::Deref for PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'a> {
     type Target = PhysicalDeviceMutableDescriptorTypeFeaturesVALVE;
     fn deref(&self) -> &Self::Target {
@@ -48982,20 +45035,17 @@ impl<'a> ::std::ops::Deref for PhysicalD
     }
 }
 impl<'a> ::std::ops::DerefMut for PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'a> {
-    pub fn mutable_descriptor_type(
-        mut self,
-        mutable_descriptor_type: bool,
-    ) -> PhysicalDeviceMutableDescriptorTypeFeaturesVALVEBuilder<'a> {
+    pub fn mutable_descriptor_type(mut self, mutable_descriptor_type: bool) -> Self {
         self.inner.mutable_descriptor_type = mutable_descriptor_type.into();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> PhysicalDeviceMutableDescriptorTypeFeaturesVALVE {
         self.inner
@@ -49036,20 +45086,17 @@ impl<'a> ::std::ops::Deref for MutableDe
     }
 }
 impl<'a> ::std::ops::DerefMut for MutableDescriptorTypeListVALVEBuilder<'a> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MutableDescriptorTypeListVALVEBuilder<'a> {
-    pub fn descriptor_types(
-        mut self,
-        descriptor_types: &'a [DescriptorType],
-    ) -> MutableDescriptorTypeListVALVEBuilder<'a> {
+    pub fn descriptor_types(mut self, descriptor_types: &'a [DescriptorType]) -> Self {
         self.inner.descriptor_type_count = descriptor_types.len() as _;
         self.inner.p_descriptor_types = descriptor_types.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MutableDescriptorTypeListVALVE {
@@ -49105,20 +45152,5629 @@ impl<'a> ::std::ops::DerefMut for Mutabl
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.inner
     }
 }
 impl<'a> MutableDescriptorTypeCreateInfoVALVEBuilder<'a> {
     pub fn mutable_descriptor_type_lists(
         mut self,
         mutable_descriptor_type_lists: &'a [MutableDescriptorTypeListVALVE],
-    ) -> MutableDescriptorTypeCreateInfoVALVEBuilder<'a> {
+    ) -> Self {
         self.inner.mutable_descriptor_type_list_count = mutable_descriptor_type_lists.len() as _;
         self.inner.p_mutable_descriptor_type_lists = mutable_descriptor_type_lists.as_ptr();
         self
     }
     #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
     #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
     #[doc = r" so references to builders can be passed directly to Vulkan functions."]
     pub fn build(self) -> MutableDescriptorTypeCreateInfoVALVE {
         self.inner
     }
 }
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html>"]
+pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub vertex_input_dynamic_state: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+    fn default() -> PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+        PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            vertex_input_dynamic_state: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
+        PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder {
+            inner: PhysicalDeviceVertexInputDynamicStateFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceVertexInputDynamicStateFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo
+    for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceVertexInputDynamicStateFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceVertexInputDynamicStateFeaturesEXTBuilder<'a> {
+    pub fn vertex_input_dynamic_state(mut self, vertex_input_dynamic_state: bool) -> Self {
+        self.inner.vertex_input_dynamic_state = vertex_input_dynamic_state.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html>"]
+pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub external_memory_rdma: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+    fn default() -> PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+        PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+            s_type: StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
+            p_next: ::std::ptr::null_mut(),
+            external_memory_rdma: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+    pub fn builder<'a>() -> PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
+        PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder {
+            inner: PhysicalDeviceExternalMemoryRDMAFeaturesNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
+    inner: PhysicalDeviceExternalMemoryRDMAFeaturesNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceExternalMemoryRDMAFeaturesNV {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
+    type Target = PhysicalDeviceExternalMemoryRDMAFeaturesNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceExternalMemoryRDMAFeaturesNVBuilder<'a> {
+    pub fn external_memory_rdma(mut self, external_memory_rdma: bool) -> Self {
+        self.inner.external_memory_rdma = external_memory_rdma.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceExternalMemoryRDMAFeaturesNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputBindingDescription2EXT.html>"]
+pub struct VertexInputBindingDescription2EXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub binding: u32,
+    pub stride: u32,
+    pub input_rate: VertexInputRate,
+    pub divisor: u32,
+}
+impl ::std::default::Default for VertexInputBindingDescription2EXT {
+    fn default() -> VertexInputBindingDescription2EXT {
+        VertexInputBindingDescription2EXT {
+            s_type: StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
+            p_next: ::std::ptr::null_mut(),
+            binding: u32::default(),
+            stride: u32::default(),
+            input_rate: VertexInputRate::default(),
+            divisor: u32::default(),
+        }
+    }
+}
+impl VertexInputBindingDescription2EXT {
+    pub fn builder<'a>() -> VertexInputBindingDescription2EXTBuilder<'a> {
+        VertexInputBindingDescription2EXTBuilder {
+            inner: VertexInputBindingDescription2EXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VertexInputBindingDescription2EXTBuilder<'a> {
+    inner: VertexInputBindingDescription2EXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VertexInputBindingDescription2EXTBuilder<'a> {
+    type Target = VertexInputBindingDescription2EXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VertexInputBindingDescription2EXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VertexInputBindingDescription2EXTBuilder<'a> {
+    pub fn binding(mut self, binding: u32) -> Self {
+        self.inner.binding = binding;
+        self
+    }
+    pub fn stride(mut self, stride: u32) -> Self {
+        self.inner.stride = stride;
+        self
+    }
+    pub fn input_rate(mut self, input_rate: VertexInputRate) -> Self {
+        self.inner.input_rate = input_rate;
+        self
+    }
+    pub fn divisor(mut self, divisor: u32) -> Self {
+        self.inner.divisor = divisor;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VertexInputBindingDescription2EXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVertexInputAttributeDescription2EXT.html>"]
+pub struct VertexInputAttributeDescription2EXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub location: u32,
+    pub binding: u32,
+    pub format: Format,
+    pub offset: u32,
+}
+impl ::std::default::Default for VertexInputAttributeDescription2EXT {
+    fn default() -> VertexInputAttributeDescription2EXT {
+        VertexInputAttributeDescription2EXT {
+            s_type: StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
+            p_next: ::std::ptr::null_mut(),
+            location: u32::default(),
+            binding: u32::default(),
+            format: Format::default(),
+            offset: u32::default(),
+        }
+    }
+}
+impl VertexInputAttributeDescription2EXT {
+    pub fn builder<'a>() -> VertexInputAttributeDescription2EXTBuilder<'a> {
+        VertexInputAttributeDescription2EXTBuilder {
+            inner: VertexInputAttributeDescription2EXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VertexInputAttributeDescription2EXTBuilder<'a> {
+    inner: VertexInputAttributeDescription2EXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VertexInputAttributeDescription2EXTBuilder<'a> {
+    type Target = VertexInputAttributeDescription2EXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VertexInputAttributeDescription2EXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VertexInputAttributeDescription2EXTBuilder<'a> {
+    pub fn location(mut self, location: u32) -> Self {
+        self.inner.location = location;
+        self
+    }
+    pub fn binding(mut self, binding: u32) -> Self {
+        self.inner.binding = binding;
+        self
+    }
+    pub fn format(mut self, format: Format) -> Self {
+        self.inner.format = format;
+        self
+    }
+    pub fn offset(mut self, offset: u32) -> Self {
+        self.inner.offset = offset;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VertexInputAttributeDescription2EXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html>"]
+pub struct PhysicalDeviceColorWriteEnableFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub color_write_enable: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceColorWriteEnableFeaturesEXT {
+    fn default() -> PhysicalDeviceColorWriteEnableFeaturesEXT {
+        PhysicalDeviceColorWriteEnableFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            color_write_enable: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceColorWriteEnableFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
+        PhysicalDeviceColorWriteEnableFeaturesEXTBuilder {
+            inner: PhysicalDeviceColorWriteEnableFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceColorWriteEnableFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceColorWriteEnableFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceColorWriteEnableFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceColorWriteEnableFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceColorWriteEnableFeaturesEXTBuilder<'a> {
+    pub fn color_write_enable(mut self, color_write_enable: bool) -> Self {
+        self.inner.color_write_enable = color_write_enable.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceColorWriteEnableFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineColorWriteCreateInfoEXT.html>"]
+pub struct PipelineColorWriteCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub attachment_count: u32,
+    pub p_color_write_enables: *const Bool32,
+}
+impl ::std::default::Default for PipelineColorWriteCreateInfoEXT {
+    fn default() -> PipelineColorWriteCreateInfoEXT {
+        PipelineColorWriteCreateInfoEXT {
+            s_type: StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            attachment_count: u32::default(),
+            p_color_write_enables: ::std::ptr::null(),
+        }
+    }
+}
+impl PipelineColorWriteCreateInfoEXT {
+    pub fn builder<'a>() -> PipelineColorWriteCreateInfoEXTBuilder<'a> {
+        PipelineColorWriteCreateInfoEXTBuilder {
+            inner: PipelineColorWriteCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PipelineColorWriteCreateInfoEXTBuilder<'a> {
+    inner: PipelineColorWriteCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPipelineColorBlendStateCreateInfo
+    for PipelineColorWriteCreateInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPipelineColorBlendStateCreateInfo for PipelineColorWriteCreateInfoEXT {}
+impl<'a> ::std::ops::Deref for PipelineColorWriteCreateInfoEXTBuilder<'a> {
+    type Target = PipelineColorWriteCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PipelineColorWriteCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PipelineColorWriteCreateInfoEXTBuilder<'a> {
+    pub fn color_write_enables(mut self, color_write_enables: &'a [Bool32]) -> Self {
+        self.inner.attachment_count = color_write_enables.len() as _;
+        self.inner.p_color_write_enables = color_write_enables.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PipelineColorWriteCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryBarrier2KHR.html>"]
+pub struct MemoryBarrier2KHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub src_stage_mask: PipelineStageFlags2KHR,
+    pub src_access_mask: AccessFlags2KHR,
+    pub dst_stage_mask: PipelineStageFlags2KHR,
+    pub dst_access_mask: AccessFlags2KHR,
+}
+impl ::std::default::Default for MemoryBarrier2KHR {
+    fn default() -> MemoryBarrier2KHR {
+        MemoryBarrier2KHR {
+            s_type: StructureType::MEMORY_BARRIER_2_KHR,
+            p_next: ::std::ptr::null(),
+            src_stage_mask: PipelineStageFlags2KHR::default(),
+            src_access_mask: AccessFlags2KHR::default(),
+            dst_stage_mask: PipelineStageFlags2KHR::default(),
+            dst_access_mask: AccessFlags2KHR::default(),
+        }
+    }
+}
+impl MemoryBarrier2KHR {
+    pub fn builder<'a>() -> MemoryBarrier2KHRBuilder<'a> {
+        MemoryBarrier2KHRBuilder {
+            inner: MemoryBarrier2KHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MemoryBarrier2KHRBuilder<'a> {
+    inner: MemoryBarrier2KHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsSubpassDependency2 for MemoryBarrier2KHRBuilder<'_> {}
+unsafe impl ExtendsSubpassDependency2 for MemoryBarrier2KHR {}
+impl<'a> ::std::ops::Deref for MemoryBarrier2KHRBuilder<'a> {
+    type Target = MemoryBarrier2KHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MemoryBarrier2KHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MemoryBarrier2KHRBuilder<'a> {
+    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.src_stage_mask = src_stage_mask;
+        self
+    }
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.src_access_mask = src_access_mask;
+        self
+    }
+    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.dst_stage_mask = dst_stage_mask;
+        self
+    }
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.dst_access_mask = dst_access_mask;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MemoryBarrier2KHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageMemoryBarrier2KHR.html>"]
+pub struct ImageMemoryBarrier2KHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub src_stage_mask: PipelineStageFlags2KHR,
+    pub src_access_mask: AccessFlags2KHR,
+    pub dst_stage_mask: PipelineStageFlags2KHR,
+    pub dst_access_mask: AccessFlags2KHR,
+    pub old_layout: ImageLayout,
+    pub new_layout: ImageLayout,
+    pub src_queue_family_index: u32,
+    pub dst_queue_family_index: u32,
+    pub image: Image,
+    pub subresource_range: ImageSubresourceRange,
+}
+impl ::std::default::Default for ImageMemoryBarrier2KHR {
+    fn default() -> ImageMemoryBarrier2KHR {
+        ImageMemoryBarrier2KHR {
+            s_type: StructureType::IMAGE_MEMORY_BARRIER_2_KHR,
+            p_next: ::std::ptr::null(),
+            src_stage_mask: PipelineStageFlags2KHR::default(),
+            src_access_mask: AccessFlags2KHR::default(),
+            dst_stage_mask: PipelineStageFlags2KHR::default(),
+            dst_access_mask: AccessFlags2KHR::default(),
+            old_layout: ImageLayout::default(),
+            new_layout: ImageLayout::default(),
+            src_queue_family_index: u32::default(),
+            dst_queue_family_index: u32::default(),
+            image: Image::default(),
+            subresource_range: ImageSubresourceRange::default(),
+        }
+    }
+}
+impl ImageMemoryBarrier2KHR {
+    pub fn builder<'a>() -> ImageMemoryBarrier2KHRBuilder<'a> {
+        ImageMemoryBarrier2KHRBuilder {
+            inner: ImageMemoryBarrier2KHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct ImageMemoryBarrier2KHRBuilder<'a> {
+    inner: ImageMemoryBarrier2KHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsImageMemoryBarrier2KHR {}
+impl<'a> ::std::ops::Deref for ImageMemoryBarrier2KHRBuilder<'a> {
+    type Target = ImageMemoryBarrier2KHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for ImageMemoryBarrier2KHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> ImageMemoryBarrier2KHRBuilder<'a> {
+    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.src_stage_mask = src_stage_mask;
+        self
+    }
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.src_access_mask = src_access_mask;
+        self
+    }
+    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.dst_stage_mask = dst_stage_mask;
+        self
+    }
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.dst_access_mask = dst_access_mask;
+        self
+    }
+    pub fn old_layout(mut self, old_layout: ImageLayout) -> Self {
+        self.inner.old_layout = old_layout;
+        self
+    }
+    pub fn new_layout(mut self, new_layout: ImageLayout) -> Self {
+        self.inner.new_layout = new_layout;
+        self
+    }
+    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
+        self.inner.src_queue_family_index = src_queue_family_index;
+        self
+    }
+    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
+        self.inner.dst_queue_family_index = dst_queue_family_index;
+        self
+    }
+    pub fn image(mut self, image: Image) -> Self {
+        self.inner.image = image;
+        self
+    }
+    pub fn subresource_range(mut self, subresource_range: ImageSubresourceRange) -> Self {
+        self.inner.subresource_range = subresource_range;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsImageMemoryBarrier2KHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> ImageMemoryBarrier2KHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkBufferMemoryBarrier2KHR.html>"]
+pub struct BufferMemoryBarrier2KHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub src_stage_mask: PipelineStageFlags2KHR,
+    pub src_access_mask: AccessFlags2KHR,
+    pub dst_stage_mask: PipelineStageFlags2KHR,
+    pub dst_access_mask: AccessFlags2KHR,
+    pub src_queue_family_index: u32,
+    pub dst_queue_family_index: u32,
+    pub buffer: Buffer,
+    pub offset: DeviceSize,
+    pub size: DeviceSize,
+}
+impl ::std::default::Default for BufferMemoryBarrier2KHR {
+    fn default() -> BufferMemoryBarrier2KHR {
+        BufferMemoryBarrier2KHR {
+            s_type: StructureType::BUFFER_MEMORY_BARRIER_2_KHR,
+            p_next: ::std::ptr::null(),
+            src_stage_mask: PipelineStageFlags2KHR::default(),
+            src_access_mask: AccessFlags2KHR::default(),
+            dst_stage_mask: PipelineStageFlags2KHR::default(),
+            dst_access_mask: AccessFlags2KHR::default(),
+            src_queue_family_index: u32::default(),
+            dst_queue_family_index: u32::default(),
+            buffer: Buffer::default(),
+            offset: DeviceSize::default(),
+            size: DeviceSize::default(),
+        }
+    }
+}
+impl BufferMemoryBarrier2KHR {
+    pub fn builder<'a>() -> BufferMemoryBarrier2KHRBuilder<'a> {
+        BufferMemoryBarrier2KHRBuilder {
+            inner: BufferMemoryBarrier2KHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct BufferMemoryBarrier2KHRBuilder<'a> {
+    inner: BufferMemoryBarrier2KHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for BufferMemoryBarrier2KHRBuilder<'a> {
+    type Target = BufferMemoryBarrier2KHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for BufferMemoryBarrier2KHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> BufferMemoryBarrier2KHRBuilder<'a> {
+    pub fn src_stage_mask(mut self, src_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.src_stage_mask = src_stage_mask;
+        self
+    }
+    pub fn src_access_mask(mut self, src_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.src_access_mask = src_access_mask;
+        self
+    }
+    pub fn dst_stage_mask(mut self, dst_stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.dst_stage_mask = dst_stage_mask;
+        self
+    }
+    pub fn dst_access_mask(mut self, dst_access_mask: AccessFlags2KHR) -> Self {
+        self.inner.dst_access_mask = dst_access_mask;
+        self
+    }
+    pub fn src_queue_family_index(mut self, src_queue_family_index: u32) -> Self {
+        self.inner.src_queue_family_index = src_queue_family_index;
+        self
+    }
+    pub fn dst_queue_family_index(mut self, dst_queue_family_index: u32) -> Self {
+        self.inner.dst_queue_family_index = dst_queue_family_index;
+        self
+    }
+    pub fn buffer(mut self, buffer: Buffer) -> Self {
+        self.inner.buffer = buffer;
+        self
+    }
+    pub fn offset(mut self, offset: DeviceSize) -> Self {
+        self.inner.offset = offset;
+        self
+    }
+    pub fn size(mut self, size: DeviceSize) -> Self {
+        self.inner.size = size;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> BufferMemoryBarrier2KHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDependencyInfoKHR.html>"]
+pub struct DependencyInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub dependency_flags: DependencyFlags,
+    pub memory_barrier_count: u32,
+    pub p_memory_barriers: *const MemoryBarrier2KHR,
+    pub buffer_memory_barrier_count: u32,
+    pub p_buffer_memory_barriers: *const BufferMemoryBarrier2KHR,
+    pub image_memory_barrier_count: u32,
+    pub p_image_memory_barriers: *const ImageMemoryBarrier2KHR,
+}
+impl ::std::default::Default for DependencyInfoKHR {
+    fn default() -> DependencyInfoKHR {
+        DependencyInfoKHR {
+            s_type: StructureType::DEPENDENCY_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            dependency_flags: DependencyFlags::default(),
+            memory_barrier_count: u32::default(),
+            p_memory_barriers: ::std::ptr::null(),
+            buffer_memory_barrier_count: u32::default(),
+            p_buffer_memory_barriers: ::std::ptr::null(),
+            image_memory_barrier_count: u32::default(),
+            p_image_memory_barriers: ::std::ptr::null(),
+        }
+    }
+}
+impl DependencyInfoKHR {
+    pub fn builder<'a>() -> DependencyInfoKHRBuilder<'a> {
+        DependencyInfoKHRBuilder {
+            inner: DependencyInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct DependencyInfoKHRBuilder<'a> {
+    inner: DependencyInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for DependencyInfoKHRBuilder<'a> {
+    type Target = DependencyInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for DependencyInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> DependencyInfoKHRBuilder<'a> {
+    pub fn dependency_flags(mut self, dependency_flags: DependencyFlags) -> Self {
+        self.inner.dependency_flags = dependency_flags;
+        self
+    }
+    pub fn memory_barriers(mut self, memory_barriers: &'a [MemoryBarrier2KHR]) -> Self {
+        self.inner.memory_barrier_count = memory_barriers.len() as _;
+        self.inner.p_memory_barriers = memory_barriers.as_ptr();
+        self
+    }
+    pub fn buffer_memory_barriers(
+        mut self,
+        buffer_memory_barriers: &'a [BufferMemoryBarrier2KHR],
+    ) -> Self {
+        self.inner.buffer_memory_barrier_count = buffer_memory_barriers.len() as _;
+        self.inner.p_buffer_memory_barriers = buffer_memory_barriers.as_ptr();
+        self
+    }
+    pub fn image_memory_barriers(
+        mut self,
+        image_memory_barriers: &'a [ImageMemoryBarrier2KHR],
+    ) -> Self {
+        self.inner.image_memory_barrier_count = image_memory_barriers.len() as _;
+        self.inner.p_image_memory_barriers = image_memory_barriers.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> DependencyInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSemaphoreSubmitInfoKHR.html>"]
+pub struct SemaphoreSubmitInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub semaphore: Semaphore,
+    pub value: u64,
+    pub stage_mask: PipelineStageFlags2KHR,
+    pub device_index: u32,
+}
+impl ::std::default::Default for SemaphoreSubmitInfoKHR {
+    fn default() -> SemaphoreSubmitInfoKHR {
+        SemaphoreSubmitInfoKHR {
+            s_type: StructureType::SEMAPHORE_SUBMIT_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            semaphore: Semaphore::default(),
+            value: u64::default(),
+            stage_mask: PipelineStageFlags2KHR::default(),
+            device_index: u32::default(),
+        }
+    }
+}
+impl SemaphoreSubmitInfoKHR {
+    pub fn builder<'a>() -> SemaphoreSubmitInfoKHRBuilder<'a> {
+        SemaphoreSubmitInfoKHRBuilder {
+            inner: SemaphoreSubmitInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct SemaphoreSubmitInfoKHRBuilder<'a> {
+    inner: SemaphoreSubmitInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for SemaphoreSubmitInfoKHRBuilder<'a> {
+    type Target = SemaphoreSubmitInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for SemaphoreSubmitInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> SemaphoreSubmitInfoKHRBuilder<'a> {
+    pub fn semaphore(mut self, semaphore: Semaphore) -> Self {
+        self.inner.semaphore = semaphore;
+        self
+    }
+    pub fn value(mut self, value: u64) -> Self {
+        self.inner.value = value;
+        self
+    }
+    pub fn stage_mask(mut self, stage_mask: PipelineStageFlags2KHR) -> Self {
+        self.inner.stage_mask = stage_mask;
+        self
+    }
+    pub fn device_index(mut self, device_index: u32) -> Self {
+        self.inner.device_index = device_index;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> SemaphoreSubmitInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferSubmitInfoKHR.html>"]
+pub struct CommandBufferSubmitInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub command_buffer: CommandBuffer,
+    pub device_mask: u32,
+}
+impl ::std::default::Default for CommandBufferSubmitInfoKHR {
+    fn default() -> CommandBufferSubmitInfoKHR {
+        CommandBufferSubmitInfoKHR {
+            s_type: StructureType::COMMAND_BUFFER_SUBMIT_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            command_buffer: CommandBuffer::default(),
+            device_mask: u32::default(),
+        }
+    }
+}
+impl CommandBufferSubmitInfoKHR {
+    pub fn builder<'a>() -> CommandBufferSubmitInfoKHRBuilder<'a> {
+        CommandBufferSubmitInfoKHRBuilder {
+            inner: CommandBufferSubmitInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CommandBufferSubmitInfoKHRBuilder<'a> {
+    inner: CommandBufferSubmitInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for CommandBufferSubmitInfoKHRBuilder<'a> {
+    type Target = CommandBufferSubmitInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CommandBufferSubmitInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CommandBufferSubmitInfoKHRBuilder<'a> {
+    pub fn command_buffer(mut self, command_buffer: CommandBuffer) -> Self {
+        self.inner.command_buffer = command_buffer;
+        self
+    }
+    pub fn device_mask(mut self, device_mask: u32) -> Self {
+        self.inner.device_mask = device_mask;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CommandBufferSubmitInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSubmitInfo2KHR.html>"]
+pub struct SubmitInfo2KHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: SubmitFlagsKHR,
+    pub wait_semaphore_info_count: u32,
+    pub p_wait_semaphore_infos: *const SemaphoreSubmitInfoKHR,
+    pub command_buffer_info_count: u32,
+    pub p_command_buffer_infos: *const CommandBufferSubmitInfoKHR,
+    pub signal_semaphore_info_count: u32,
+    pub p_signal_semaphore_infos: *const SemaphoreSubmitInfoKHR,
+}
+impl ::std::default::Default for SubmitInfo2KHR {
+    fn default() -> SubmitInfo2KHR {
+        SubmitInfo2KHR {
+            s_type: StructureType::SUBMIT_INFO_2_KHR,
+            p_next: ::std::ptr::null(),
+            flags: SubmitFlagsKHR::default(),
+            wait_semaphore_info_count: u32::default(),
+            p_wait_semaphore_infos: ::std::ptr::null(),
+            command_buffer_info_count: u32::default(),
+            p_command_buffer_infos: ::std::ptr::null(),
+            signal_semaphore_info_count: u32::default(),
+            p_signal_semaphore_infos: ::std::ptr::null(),
+        }
+    }
+}
+impl SubmitInfo2KHR {
+    pub fn builder<'a>() -> SubmitInfo2KHRBuilder<'a> {
+        SubmitInfo2KHRBuilder {
+            inner: SubmitInfo2KHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct SubmitInfo2KHRBuilder<'a> {
+    inner: SubmitInfo2KHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsSubmitInfo2KHR {}
+impl<'a> ::std::ops::Deref for SubmitInfo2KHRBuilder<'a> {
+    type Target = SubmitInfo2KHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for SubmitInfo2KHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> SubmitInfo2KHRBuilder<'a> {
+    pub fn flags(mut self, flags: SubmitFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn wait_semaphore_infos(
+        mut self,
+        wait_semaphore_infos: &'a [SemaphoreSubmitInfoKHR],
+    ) -> Self {
+        self.inner.wait_semaphore_info_count = wait_semaphore_infos.len() as _;
+        self.inner.p_wait_semaphore_infos = wait_semaphore_infos.as_ptr();
+        self
+    }
+    pub fn command_buffer_infos(
+        mut self,
+        command_buffer_infos: &'a [CommandBufferSubmitInfoKHR],
+    ) -> Self {
+        self.inner.command_buffer_info_count = command_buffer_infos.len() as _;
+        self.inner.p_command_buffer_infos = command_buffer_infos.as_ptr();
+        self
+    }
+    pub fn signal_semaphore_infos(
+        mut self,
+        signal_semaphore_infos: &'a [SemaphoreSubmitInfoKHR],
+    ) -> Self {
+        self.inner.signal_semaphore_info_count = signal_semaphore_infos.len() as _;
+        self.inner.p_signal_semaphore_infos = signal_semaphore_infos.as_ptr();
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsSubmitInfo2KHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> SubmitInfo2KHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkQueueFamilyCheckpointProperties2NV.html>"]
+pub struct QueueFamilyCheckpointProperties2NV {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub checkpoint_execution_stage_mask: PipelineStageFlags2KHR,
+}
+impl ::std::default::Default for QueueFamilyCheckpointProperties2NV {
+    fn default() -> QueueFamilyCheckpointProperties2NV {
+        QueueFamilyCheckpointProperties2NV {
+            s_type: StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV,
+            p_next: ::std::ptr::null_mut(),
+            checkpoint_execution_stage_mask: PipelineStageFlags2KHR::default(),
+        }
+    }
+}
+impl QueueFamilyCheckpointProperties2NV {
+    pub fn builder<'a>() -> QueueFamilyCheckpointProperties2NVBuilder<'a> {
+        QueueFamilyCheckpointProperties2NVBuilder {
+            inner: QueueFamilyCheckpointProperties2NV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct QueueFamilyCheckpointProperties2NVBuilder<'a> {
+    inner: QueueFamilyCheckpointProperties2NV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointProperties2NVBuilder<'_> {}
+unsafe impl ExtendsQueueFamilyProperties2 for QueueFamilyCheckpointProperties2NV {}
+impl<'a> ::std::ops::Deref for QueueFamilyCheckpointProperties2NVBuilder<'a> {
+    type Target = QueueFamilyCheckpointProperties2NV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for QueueFamilyCheckpointProperties2NVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> QueueFamilyCheckpointProperties2NVBuilder<'a> {
+    pub fn checkpoint_execution_stage_mask(
+        mut self,
+        checkpoint_execution_stage_mask: PipelineStageFlags2KHR,
+    ) -> Self {
+        self.inner.checkpoint_execution_stage_mask = checkpoint_execution_stage_mask;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> QueueFamilyCheckpointProperties2NV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCheckpointData2NV.html>"]
+pub struct CheckpointData2NV {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub stage: PipelineStageFlags2KHR,
+    pub p_checkpoint_marker: *mut c_void,
+}
+impl ::std::default::Default for CheckpointData2NV {
+    fn default() -> CheckpointData2NV {
+        CheckpointData2NV {
+            s_type: StructureType::CHECKPOINT_DATA_2_NV,
+            p_next: ::std::ptr::null_mut(),
+            stage: PipelineStageFlags2KHR::default(),
+            p_checkpoint_marker: ::std::ptr::null_mut(),
+        }
+    }
+}
+impl CheckpointData2NV {
+    pub fn builder<'a>() -> CheckpointData2NVBuilder<'a> {
+        CheckpointData2NVBuilder {
+            inner: CheckpointData2NV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CheckpointData2NVBuilder<'a> {
+    inner: CheckpointData2NV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for CheckpointData2NVBuilder<'a> {
+    type Target = CheckpointData2NV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CheckpointData2NVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CheckpointData2NVBuilder<'a> {
+    pub fn stage(mut self, stage: PipelineStageFlags2KHR) -> Self {
+        self.inner.stage = stage;
+        self
+    }
+    pub fn checkpoint_marker(mut self, checkpoint_marker: *mut c_void) -> Self {
+        self.inner.p_checkpoint_marker = checkpoint_marker;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CheckpointData2NV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSynchronization2FeaturesKHR.html>"]
+pub struct PhysicalDeviceSynchronization2FeaturesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub synchronization2: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceSynchronization2FeaturesKHR {
+    fn default() -> PhysicalDeviceSynchronization2FeaturesKHR {
+        PhysicalDeviceSynchronization2FeaturesKHR {
+            s_type: StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            synchronization2: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceSynchronization2FeaturesKHR {
+    pub fn builder<'a>() -> PhysicalDeviceSynchronization2FeaturesKHRBuilder<'a> {
+        PhysicalDeviceSynchronization2FeaturesKHRBuilder {
+            inner: PhysicalDeviceSynchronization2FeaturesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceSynchronization2FeaturesKHRBuilder<'a> {
+    inner: PhysicalDeviceSynchronization2FeaturesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceSynchronization2FeaturesKHRBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceSynchronization2FeaturesKHR {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSynchronization2FeaturesKHRBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceSynchronization2FeaturesKHR {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceSynchronization2FeaturesKHRBuilder<'a> {
+    type Target = PhysicalDeviceSynchronization2FeaturesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceSynchronization2FeaturesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceSynchronization2FeaturesKHRBuilder<'a> {
+    pub fn synchronization2(mut self, synchronization2: bool) -> Self {
+        self.inner.synchronization2 = synchronization2.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceSynchronization2FeaturesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoQueueFamilyProperties2KHR.html>"]
+pub struct VideoQueueFamilyProperties2KHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub video_codec_operations: VideoCodecOperationFlagsKHR,
+}
+impl ::std::default::Default for VideoQueueFamilyProperties2KHR {
+    fn default() -> VideoQueueFamilyProperties2KHR {
+        VideoQueueFamilyProperties2KHR {
+            s_type: StructureType::VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR,
+            p_next: ::std::ptr::null_mut(),
+            video_codec_operations: VideoCodecOperationFlagsKHR::default(),
+        }
+    }
+}
+impl VideoQueueFamilyProperties2KHR {
+    pub fn builder<'a>() -> VideoQueueFamilyProperties2KHRBuilder<'a> {
+        VideoQueueFamilyProperties2KHRBuilder {
+            inner: VideoQueueFamilyProperties2KHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoQueueFamilyProperties2KHRBuilder<'a> {
+    inner: VideoQueueFamilyProperties2KHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsQueueFamilyProperties2 for VideoQueueFamilyProperties2KHRBuilder<'_> {}
+unsafe impl ExtendsQueueFamilyProperties2 for VideoQueueFamilyProperties2KHR {}
+impl<'a> ::std::ops::Deref for VideoQueueFamilyProperties2KHRBuilder<'a> {
+    type Target = VideoQueueFamilyProperties2KHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoQueueFamilyProperties2KHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoQueueFamilyProperties2KHRBuilder<'a> {
+    pub fn video_codec_operations(
+        mut self,
+        video_codec_operations: VideoCodecOperationFlagsKHR,
+    ) -> Self {
+        self.inner.video_codec_operations = video_codec_operations;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoQueueFamilyProperties2KHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoProfilesKHR.html>"]
+pub struct VideoProfilesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub profile_count: u32,
+    pub p_profiles: *const VideoProfileKHR,
+}
+impl ::std::default::Default for VideoProfilesKHR {
+    fn default() -> VideoProfilesKHR {
+        VideoProfilesKHR {
+            s_type: StructureType::VIDEO_PROFILES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            profile_count: u32::default(),
+            p_profiles: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoProfilesKHR {
+    pub fn builder<'a>() -> VideoProfilesKHRBuilder<'a> {
+        VideoProfilesKHRBuilder {
+            inner: VideoProfilesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoProfilesKHRBuilder<'a> {
+    inner: VideoProfilesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsFormatProperties2 for VideoProfilesKHRBuilder<'_> {}
+unsafe impl ExtendsFormatProperties2 for VideoProfilesKHR {}
+unsafe impl ExtendsImageCreateInfo for VideoProfilesKHRBuilder<'_> {}
+unsafe impl ExtendsImageCreateInfo for VideoProfilesKHR {}
+unsafe impl ExtendsImageViewCreateInfo for VideoProfilesKHRBuilder<'_> {}
+unsafe impl ExtendsImageViewCreateInfo for VideoProfilesKHR {}
+unsafe impl ExtendsBufferCreateInfo for VideoProfilesKHRBuilder<'_> {}
+unsafe impl ExtendsBufferCreateInfo for VideoProfilesKHR {}
+impl<'a> ::std::ops::Deref for VideoProfilesKHRBuilder<'a> {
+    type Target = VideoProfilesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoProfilesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoProfilesKHRBuilder<'a> {
+    pub fn profile_count(mut self, profile_count: u32) -> Self {
+        self.inner.profile_count = profile_count;
+        self
+    }
+    pub fn profiles(mut self, profiles: &'a VideoProfileKHR) -> Self {
+        self.inner.p_profiles = profiles;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoProfilesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVideoFormatInfoKHR.html>"]
+pub struct PhysicalDeviceVideoFormatInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub image_usage: ImageUsageFlags,
+    pub p_video_profiles: *const VideoProfilesKHR,
+}
+impl ::std::default::Default for PhysicalDeviceVideoFormatInfoKHR {
+    fn default() -> PhysicalDeviceVideoFormatInfoKHR {
+        PhysicalDeviceVideoFormatInfoKHR {
+            s_type: StructureType::PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
+            p_next: ::std::ptr::null_mut(),
+            image_usage: ImageUsageFlags::default(),
+            p_video_profiles: ::std::ptr::null(),
+        }
+    }
+}
+impl PhysicalDeviceVideoFormatInfoKHR {
+    pub fn builder<'a>() -> PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
+        PhysicalDeviceVideoFormatInfoKHRBuilder {
+            inner: PhysicalDeviceVideoFormatInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
+    inner: PhysicalDeviceVideoFormatInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
+    type Target = PhysicalDeviceVideoFormatInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceVideoFormatInfoKHRBuilder<'a> {
+    pub fn image_usage(mut self, image_usage: ImageUsageFlags) -> Self {
+        self.inner.image_usage = image_usage;
+        self
+    }
+    pub fn video_profiles(mut self, video_profiles: &'a VideoProfilesKHR) -> Self {
+        self.inner.p_video_profiles = video_profiles;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceVideoFormatInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoFormatPropertiesKHR.html>"]
+pub struct VideoFormatPropertiesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub format: Format,
+}
+impl ::std::default::Default for VideoFormatPropertiesKHR {
+    fn default() -> VideoFormatPropertiesKHR {
+        VideoFormatPropertiesKHR {
+            s_type: StructureType::VIDEO_FORMAT_PROPERTIES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            format: Format::default(),
+        }
+    }
+}
+impl VideoFormatPropertiesKHR {
+    pub fn builder<'a>() -> VideoFormatPropertiesKHRBuilder<'a> {
+        VideoFormatPropertiesKHRBuilder {
+            inner: VideoFormatPropertiesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoFormatPropertiesKHRBuilder<'a> {
+    inner: VideoFormatPropertiesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoFormatPropertiesKHRBuilder<'a> {
+    type Target = VideoFormatPropertiesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoFormatPropertiesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoFormatPropertiesKHRBuilder<'a> {
+    pub fn format(mut self, format: Format) -> Self {
+        self.inner.format = format;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoFormatPropertiesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoProfileKHR.html>"]
+pub struct VideoProfileKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub video_codec_operation: VideoCodecOperationFlagsKHR,
+    pub chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
+    pub luma_bit_depth: VideoComponentBitDepthFlagsKHR,
+    pub chroma_bit_depth: VideoComponentBitDepthFlagsKHR,
+}
+impl ::std::default::Default for VideoProfileKHR {
+    fn default() -> VideoProfileKHR {
+        VideoProfileKHR {
+            s_type: StructureType::VIDEO_PROFILE_KHR,
+            p_next: ::std::ptr::null_mut(),
+            video_codec_operation: VideoCodecOperationFlagsKHR::default(),
+            chroma_subsampling: VideoChromaSubsamplingFlagsKHR::default(),
+            luma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
+            chroma_bit_depth: VideoComponentBitDepthFlagsKHR::default(),
+        }
+    }
+}
+impl VideoProfileKHR {
+    pub fn builder<'a>() -> VideoProfileKHRBuilder<'a> {
+        VideoProfileKHRBuilder {
+            inner: VideoProfileKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoProfileKHRBuilder<'a> {
+    inner: VideoProfileKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsQueryPoolCreateInfo for VideoProfileKHRBuilder<'_> {}
+unsafe impl ExtendsQueryPoolCreateInfo for VideoProfileKHR {}
+unsafe impl ExtendsFormatProperties2 for VideoProfileKHRBuilder<'_> {}
+unsafe impl ExtendsFormatProperties2 for VideoProfileKHR {}
+unsafe impl ExtendsImageCreateInfo for VideoProfileKHRBuilder<'_> {}
+unsafe impl ExtendsImageCreateInfo for VideoProfileKHR {}
+unsafe impl ExtendsImageViewCreateInfo for VideoProfileKHRBuilder<'_> {}
+unsafe impl ExtendsImageViewCreateInfo for VideoProfileKHR {}
+unsafe impl ExtendsBufferCreateInfo for VideoProfileKHRBuilder<'_> {}
+unsafe impl ExtendsBufferCreateInfo for VideoProfileKHR {}
+pub unsafe trait ExtendsVideoProfileKHR {}
+impl<'a> ::std::ops::Deref for VideoProfileKHRBuilder<'a> {
+    type Target = VideoProfileKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoProfileKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoProfileKHRBuilder<'a> {
+    pub fn video_codec_operation(
+        mut self,
+        video_codec_operation: VideoCodecOperationFlagsKHR,
+    ) -> Self {
+        self.inner.video_codec_operation = video_codec_operation;
+        self
+    }
+    pub fn chroma_subsampling(
+        mut self,
+        chroma_subsampling: VideoChromaSubsamplingFlagsKHR,
+    ) -> Self {
+        self.inner.chroma_subsampling = chroma_subsampling;
+        self
+    }
+    pub fn luma_bit_depth(mut self, luma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
+        self.inner.luma_bit_depth = luma_bit_depth;
+        self
+    }
+    pub fn chroma_bit_depth(mut self, chroma_bit_depth: VideoComponentBitDepthFlagsKHR) -> Self {
+        self.inner.chroma_bit_depth = chroma_bit_depth;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoProfileKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoProfileKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoCapabilitiesKHR.html>"]
+pub struct VideoCapabilitiesKHR {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub capability_flags: VideoCapabilitiesFlagsKHR,
+    pub min_bitstream_buffer_offset_alignment: DeviceSize,
+    pub min_bitstream_buffer_size_alignment: DeviceSize,
+    pub video_picture_extent_granularity: Extent2D,
+    pub min_extent: Extent2D,
+    pub max_extent: Extent2D,
+    pub max_reference_pictures_slots_count: u32,
+    pub max_reference_pictures_active_count: u32,
+}
+impl ::std::default::Default for VideoCapabilitiesKHR {
+    fn default() -> VideoCapabilitiesKHR {
+        VideoCapabilitiesKHR {
+            s_type: StructureType::VIDEO_CAPABILITIES_KHR,
+            p_next: ::std::ptr::null_mut(),
+            capability_flags: VideoCapabilitiesFlagsKHR::default(),
+            min_bitstream_buffer_offset_alignment: DeviceSize::default(),
+            min_bitstream_buffer_size_alignment: DeviceSize::default(),
+            video_picture_extent_granularity: Extent2D::default(),
+            min_extent: Extent2D::default(),
+            max_extent: Extent2D::default(),
+            max_reference_pictures_slots_count: u32::default(),
+            max_reference_pictures_active_count: u32::default(),
+        }
+    }
+}
+impl VideoCapabilitiesKHR {
+    pub fn builder<'a>() -> VideoCapabilitiesKHRBuilder<'a> {
+        VideoCapabilitiesKHRBuilder {
+            inner: VideoCapabilitiesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoCapabilitiesKHRBuilder<'a> {
+    inner: VideoCapabilitiesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoCapabilitiesKHR {}
+impl<'a> ::std::ops::Deref for VideoCapabilitiesKHRBuilder<'a> {
+    type Target = VideoCapabilitiesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoCapabilitiesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoCapabilitiesKHRBuilder<'a> {
+    pub fn capability_flags(mut self, capability_flags: VideoCapabilitiesFlagsKHR) -> Self {
+        self.inner.capability_flags = capability_flags;
+        self
+    }
+    pub fn min_bitstream_buffer_offset_alignment(
+        mut self,
+        min_bitstream_buffer_offset_alignment: DeviceSize,
+    ) -> Self {
+        self.inner.min_bitstream_buffer_offset_alignment = min_bitstream_buffer_offset_alignment;
+        self
+    }
+    pub fn min_bitstream_buffer_size_alignment(
+        mut self,
+        min_bitstream_buffer_size_alignment: DeviceSize,
+    ) -> Self {
+        self.inner.min_bitstream_buffer_size_alignment = min_bitstream_buffer_size_alignment;
+        self
+    }
+    pub fn video_picture_extent_granularity(
+        mut self,
+        video_picture_extent_granularity: Extent2D,
+    ) -> Self {
+        self.inner.video_picture_extent_granularity = video_picture_extent_granularity;
+        self
+    }
+    pub fn min_extent(mut self, min_extent: Extent2D) -> Self {
+        self.inner.min_extent = min_extent;
+        self
+    }
+    pub fn max_extent(mut self, max_extent: Extent2D) -> Self {
+        self.inner.max_extent = max_extent;
+        self
+    }
+    pub fn max_reference_pictures_slots_count(
+        mut self,
+        max_reference_pictures_slots_count: u32,
+    ) -> Self {
+        self.inner.max_reference_pictures_slots_count = max_reference_pictures_slots_count;
+        self
+    }
+    pub fn max_reference_pictures_active_count(
+        mut self,
+        max_reference_pictures_active_count: u32,
+    ) -> Self {
+        self.inner.max_reference_pictures_active_count = max_reference_pictures_active_count;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoCapabilitiesKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoCapabilitiesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoGetMemoryPropertiesKHR.html>"]
+pub struct VideoGetMemoryPropertiesKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub memory_bind_index: u32,
+    pub p_memory_requirements: *mut MemoryRequirements2,
+}
+impl ::std::default::Default for VideoGetMemoryPropertiesKHR {
+    fn default() -> VideoGetMemoryPropertiesKHR {
+        VideoGetMemoryPropertiesKHR {
+            s_type: StructureType::VIDEO_GET_MEMORY_PROPERTIES_KHR,
+            p_next: ::std::ptr::null(),
+            memory_bind_index: u32::default(),
+            p_memory_requirements: ::std::ptr::null_mut(),
+        }
+    }
+}
+impl VideoGetMemoryPropertiesKHR {
+    pub fn builder<'a>() -> VideoGetMemoryPropertiesKHRBuilder<'a> {
+        VideoGetMemoryPropertiesKHRBuilder {
+            inner: VideoGetMemoryPropertiesKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoGetMemoryPropertiesKHRBuilder<'a> {
+    inner: VideoGetMemoryPropertiesKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoGetMemoryPropertiesKHRBuilder<'a> {
+    type Target = VideoGetMemoryPropertiesKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoGetMemoryPropertiesKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoGetMemoryPropertiesKHRBuilder<'a> {
+    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
+        self.inner.memory_bind_index = memory_bind_index;
+        self
+    }
+    pub fn memory_requirements(mut self, memory_requirements: &'a mut MemoryRequirements2) -> Self {
+        self.inner.p_memory_requirements = memory_requirements;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoGetMemoryPropertiesKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoBindMemoryKHR.html>"]
+pub struct VideoBindMemoryKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub memory_bind_index: u32,
+    pub memory: DeviceMemory,
+    pub memory_offset: DeviceSize,
+    pub memory_size: DeviceSize,
+}
+impl ::std::default::Default for VideoBindMemoryKHR {
+    fn default() -> VideoBindMemoryKHR {
+        VideoBindMemoryKHR {
+            s_type: StructureType::VIDEO_BIND_MEMORY_KHR,
+            p_next: ::std::ptr::null(),
+            memory_bind_index: u32::default(),
+            memory: DeviceMemory::default(),
+            memory_offset: DeviceSize::default(),
+            memory_size: DeviceSize::default(),
+        }
+    }
+}
+impl VideoBindMemoryKHR {
+    pub fn builder<'a>() -> VideoBindMemoryKHRBuilder<'a> {
+        VideoBindMemoryKHRBuilder {
+            inner: VideoBindMemoryKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoBindMemoryKHRBuilder<'a> {
+    inner: VideoBindMemoryKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoBindMemoryKHRBuilder<'a> {
+    type Target = VideoBindMemoryKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoBindMemoryKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoBindMemoryKHRBuilder<'a> {
+    pub fn memory_bind_index(mut self, memory_bind_index: u32) -> Self {
+        self.inner.memory_bind_index = memory_bind_index;
+        self
+    }
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
+        self.inner.memory = memory;
+        self
+    }
+    pub fn memory_offset(mut self, memory_offset: DeviceSize) -> Self {
+        self.inner.memory_offset = memory_offset;
+        self
+    }
+    pub fn memory_size(mut self, memory_size: DeviceSize) -> Self {
+        self.inner.memory_size = memory_size;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoBindMemoryKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoPictureResourceKHR.html>"]
+pub struct VideoPictureResourceKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub coded_offset: Offset2D,
+    pub coded_extent: Extent2D,
+    pub base_array_layer: u32,
+    pub image_view_binding: ImageView,
+}
+impl ::std::default::Default for VideoPictureResourceKHR {
+    fn default() -> VideoPictureResourceKHR {
+        VideoPictureResourceKHR {
+            s_type: StructureType::VIDEO_PICTURE_RESOURCE_KHR,
+            p_next: ::std::ptr::null(),
+            coded_offset: Offset2D::default(),
+            coded_extent: Extent2D::default(),
+            base_array_layer: u32::default(),
+            image_view_binding: ImageView::default(),
+        }
+    }
+}
+impl VideoPictureResourceKHR {
+    pub fn builder<'a>() -> VideoPictureResourceKHRBuilder<'a> {
+        VideoPictureResourceKHRBuilder {
+            inner: VideoPictureResourceKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoPictureResourceKHRBuilder<'a> {
+    inner: VideoPictureResourceKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoPictureResourceKHRBuilder<'a> {
+    type Target = VideoPictureResourceKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoPictureResourceKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoPictureResourceKHRBuilder<'a> {
+    pub fn coded_offset(mut self, coded_offset: Offset2D) -> Self {
+        self.inner.coded_offset = coded_offset;
+        self
+    }
+    pub fn coded_extent(mut self, coded_extent: Extent2D) -> Self {
+        self.inner.coded_extent = coded_extent;
+        self
+    }
+    pub fn base_array_layer(mut self, base_array_layer: u32) -> Self {
+        self.inner.base_array_layer = base_array_layer;
+        self
+    }
+    pub fn image_view_binding(mut self, image_view_binding: ImageView) -> Self {
+        self.inner.image_view_binding = image_view_binding;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoPictureResourceKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoReferenceSlotKHR.html>"]
+pub struct VideoReferenceSlotKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub slot_index: i8,
+    pub p_picture_resource: *const VideoPictureResourceKHR,
+}
+impl ::std::default::Default for VideoReferenceSlotKHR {
+    fn default() -> VideoReferenceSlotKHR {
+        VideoReferenceSlotKHR {
+            s_type: StructureType::VIDEO_REFERENCE_SLOT_KHR,
+            p_next: ::std::ptr::null(),
+            slot_index: i8::default(),
+            p_picture_resource: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoReferenceSlotKHR {
+    pub fn builder<'a>() -> VideoReferenceSlotKHRBuilder<'a> {
+        VideoReferenceSlotKHRBuilder {
+            inner: VideoReferenceSlotKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoReferenceSlotKHRBuilder<'a> {
+    inner: VideoReferenceSlotKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoReferenceSlotKHR {}
+impl<'a> ::std::ops::Deref for VideoReferenceSlotKHRBuilder<'a> {
+    type Target = VideoReferenceSlotKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoReferenceSlotKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoReferenceSlotKHRBuilder<'a> {
+    pub fn slot_index(mut self, slot_index: i8) -> Self {
+        self.inner.slot_index = slot_index;
+        self
+    }
+    pub fn picture_resource(mut self, picture_resource: &'a VideoPictureResourceKHR) -> Self {
+        self.inner.p_picture_resource = picture_resource;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoReferenceSlotKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoReferenceSlotKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeInfoKHR.html>"]
+pub struct VideoDecodeInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoDecodeFlagsKHR,
+    pub coded_offset: Offset2D,
+    pub coded_extent: Extent2D,
+    pub src_buffer: Buffer,
+    pub src_buffer_offset: DeviceSize,
+    pub src_buffer_range: DeviceSize,
+    pub dst_picture_resource: VideoPictureResourceKHR,
+    pub p_setup_reference_slot: *const VideoReferenceSlotKHR,
+    pub reference_slot_count: u32,
+    pub p_reference_slots: *const VideoReferenceSlotKHR,
+}
+impl ::std::default::Default for VideoDecodeInfoKHR {
+    fn default() -> VideoDecodeInfoKHR {
+        VideoDecodeInfoKHR {
+            s_type: StructureType::VIDEO_DECODE_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoDecodeFlagsKHR::default(),
+            coded_offset: Offset2D::default(),
+            coded_extent: Extent2D::default(),
+            src_buffer: Buffer::default(),
+            src_buffer_offset: DeviceSize::default(),
+            src_buffer_range: DeviceSize::default(),
+            dst_picture_resource: VideoPictureResourceKHR::default(),
+            p_setup_reference_slot: ::std::ptr::null(),
+            reference_slot_count: u32::default(),
+            p_reference_slots: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeInfoKHR {
+    pub fn builder<'a>() -> VideoDecodeInfoKHRBuilder<'a> {
+        VideoDecodeInfoKHRBuilder {
+            inner: VideoDecodeInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeInfoKHRBuilder<'a> {
+    inner: VideoDecodeInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoDecodeInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoDecodeInfoKHRBuilder<'a> {
+    type Target = VideoDecodeInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoDecodeFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn coded_offset(mut self, coded_offset: Offset2D) -> Self {
+        self.inner.coded_offset = coded_offset;
+        self
+    }
+    pub fn coded_extent(mut self, coded_extent: Extent2D) -> Self {
+        self.inner.coded_extent = coded_extent;
+        self
+    }
+    pub fn src_buffer(mut self, src_buffer: Buffer) -> Self {
+        self.inner.src_buffer = src_buffer;
+        self
+    }
+    pub fn src_buffer_offset(mut self, src_buffer_offset: DeviceSize) -> Self {
+        self.inner.src_buffer_offset = src_buffer_offset;
+        self
+    }
+    pub fn src_buffer_range(mut self, src_buffer_range: DeviceSize) -> Self {
+        self.inner.src_buffer_range = src_buffer_range;
+        self
+    }
+    pub fn dst_picture_resource(mut self, dst_picture_resource: VideoPictureResourceKHR) -> Self {
+        self.inner.dst_picture_resource = dst_picture_resource;
+        self
+    }
+    pub fn setup_reference_slot(mut self, setup_reference_slot: &'a VideoReferenceSlotKHR) -> Self {
+        self.inner.p_setup_reference_slot = setup_reference_slot;
+        self
+    }
+    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
+        self.inner.reference_slot_count = reference_slots.len() as _;
+        self.inner.p_reference_slots = reference_slots.as_ptr();
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoDecodeInfoKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264ProfileEXT.html>"]
+pub struct VideoDecodeH264ProfileEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub std_profile_idc: StdVideoH264ProfileIdc,
+    pub field_layout: VideoDecodeH264FieldLayoutFlagsEXT,
+}
+impl ::std::default::Default for VideoDecodeH264ProfileEXT {
+    fn default() -> VideoDecodeH264ProfileEXT {
+        VideoDecodeH264ProfileEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_PROFILE_EXT,
+            p_next: ::std::ptr::null(),
+            std_profile_idc: StdVideoH264ProfileIdc::default(),
+            field_layout: VideoDecodeH264FieldLayoutFlagsEXT::default(),
+        }
+    }
+}
+impl VideoDecodeH264ProfileEXT {
+    pub fn builder<'a>() -> VideoDecodeH264ProfileEXTBuilder<'a> {
+        VideoDecodeH264ProfileEXTBuilder {
+            inner: VideoDecodeH264ProfileEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264ProfileEXTBuilder<'a> {
+    inner: VideoDecodeH264ProfileEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoProfileKHR for VideoDecodeH264ProfileEXTBuilder<'_> {}
+unsafe impl ExtendsVideoProfileKHR for VideoDecodeH264ProfileEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264ProfileEXTBuilder<'a> {
+    type Target = VideoDecodeH264ProfileEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264ProfileEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264ProfileEXTBuilder<'a> {
+    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
+        self.inner.std_profile_idc = std_profile_idc;
+        self
+    }
+    pub fn field_layout(mut self, field_layout: VideoDecodeH264FieldLayoutFlagsEXT) -> Self {
+        self.inner.field_layout = field_layout;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264ProfileEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264CapabilitiesEXT.html>"]
+pub struct VideoDecodeH264CapabilitiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub max_level: u32,
+    pub field_offset_granularity: Offset2D,
+    pub std_extension_version: ExtensionProperties,
+}
+impl ::std::default::Default for VideoDecodeH264CapabilitiesEXT {
+    fn default() -> VideoDecodeH264CapabilitiesEXT {
+        VideoDecodeH264CapabilitiesEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_CAPABILITIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            max_level: u32::default(),
+            field_offset_granularity: Offset2D::default(),
+            std_extension_version: ExtensionProperties::default(),
+        }
+    }
+}
+impl VideoDecodeH264CapabilitiesEXT {
+    pub fn builder<'a>() -> VideoDecodeH264CapabilitiesEXTBuilder<'a> {
+        VideoDecodeH264CapabilitiesEXTBuilder {
+            inner: VideoDecodeH264CapabilitiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264CapabilitiesEXTBuilder<'a> {
+    inner: VideoDecodeH264CapabilitiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH264CapabilitiesEXTBuilder<'_> {}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH264CapabilitiesEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264CapabilitiesEXTBuilder<'a> {
+    type Target = VideoDecodeH264CapabilitiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264CapabilitiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264CapabilitiesEXTBuilder<'a> {
+    pub fn max_level(mut self, max_level: u32) -> Self {
+        self.inner.max_level = max_level;
+        self
+    }
+    pub fn field_offset_granularity(mut self, field_offset_granularity: Offset2D) -> Self {
+        self.inner.field_offset_granularity = field_offset_granularity;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: ExtensionProperties) -> Self {
+        self.inner.std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264CapabilitiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264SessionCreateInfoEXT.html>"]
+pub struct VideoDecodeH264SessionCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoDecodeH264CreateFlagsEXT,
+    pub p_std_extension_version: *const ExtensionProperties,
+}
+impl ::std::default::Default for VideoDecodeH264SessionCreateInfoEXT {
+    fn default() -> VideoDecodeH264SessionCreateInfoEXT {
+        VideoDecodeH264SessionCreateInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            flags: VideoDecodeH264CreateFlagsEXT::default(),
+            p_std_extension_version: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264SessionCreateInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH264SessionCreateInfoEXTBuilder<'a> {
+        VideoDecodeH264SessionCreateInfoEXTBuilder {
+            inner: VideoDecodeH264SessionCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264SessionCreateInfoEXTBuilder<'a> {
+    inner: VideoDecodeH264SessionCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoDecodeH264SessionCreateInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoDecodeH264SessionCreateInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264SessionCreateInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH264SessionCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264SessionCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264SessionCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: VideoDecodeH264CreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: &'a ExtensionProperties) -> Self {
+        self.inner.p_std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264SessionCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264SessionParametersAddInfoEXT.html>"]
+pub struct VideoDecodeH264SessionParametersAddInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub sps_std_count: u32,
+    pub p_sps_std: *const StdVideoH264SequenceParameterSet,
+    pub pps_std_count: u32,
+    pub p_pps_std: *const StdVideoH264PictureParameterSet,
+}
+impl ::std::default::Default for VideoDecodeH264SessionParametersAddInfoEXT {
+    fn default() -> VideoDecodeH264SessionParametersAddInfoEXT {
+        VideoDecodeH264SessionParametersAddInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            sps_std_count: u32::default(),
+            p_sps_std: ::std::ptr::null(),
+            pps_std_count: u32::default(),
+            p_pps_std: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264SessionParametersAddInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH264SessionParametersAddInfoEXTBuilder<'a> {
+        VideoDecodeH264SessionParametersAddInfoEXTBuilder {
+            inner: VideoDecodeH264SessionParametersAddInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    inner: VideoDecodeH264SessionParametersAddInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoDecodeH264SessionParametersAddInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoDecodeH264SessionParametersAddInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoDecodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH264SessionParametersAddInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    pub fn sps_std(mut self, sps_std: &'a [StdVideoH264SequenceParameterSet]) -> Self {
+        self.inner.sps_std_count = sps_std.len() as _;
+        self.inner.p_sps_std = sps_std.as_ptr();
+        self
+    }
+    pub fn pps_std(mut self, pps_std: &'a [StdVideoH264PictureParameterSet]) -> Self {
+        self.inner.pps_std_count = pps_std.len() as _;
+        self.inner.p_pps_std = pps_std.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264SessionParametersAddInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264SessionParametersCreateInfoEXT.html>"]
+pub struct VideoDecodeH264SessionParametersCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub max_sps_std_count: u32,
+    pub max_pps_std_count: u32,
+    pub p_parameters_add_info: *const VideoDecodeH264SessionParametersAddInfoEXT,
+}
+impl ::std::default::Default for VideoDecodeH264SessionParametersCreateInfoEXT {
+    fn default() -> VideoDecodeH264SessionParametersCreateInfoEXT {
+        VideoDecodeH264SessionParametersCreateInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            max_sps_std_count: u32::default(),
+            max_pps_std_count: u32::default(),
+            p_parameters_add_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264SessionParametersCreateInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+        VideoDecodeH264SessionParametersCreateInfoEXTBuilder {
+            inner: VideoDecodeH264SessionParametersCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    inner: VideoDecodeH264SessionParametersCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoDecodeH264SessionParametersCreateInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH264SessionParametersCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
+        self.inner.max_sps_std_count = max_sps_std_count;
+        self
+    }
+    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
+        self.inner.max_pps_std_count = max_pps_std_count;
+        self
+    }
+    pub fn parameters_add_info(
+        mut self,
+        parameters_add_info: &'a VideoDecodeH264SessionParametersAddInfoEXT,
+    ) -> Self {
+        self.inner.p_parameters_add_info = parameters_add_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264SessionParametersCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264PictureInfoEXT.html>"]
+pub struct VideoDecodeH264PictureInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_std_picture_info: *const StdVideoDecodeH264PictureInfo,
+    pub slices_count: u32,
+    pub p_slices_data_offsets: *const u32,
+}
+impl ::std::default::Default for VideoDecodeH264PictureInfoEXT {
+    fn default() -> VideoDecodeH264PictureInfoEXT {
+        VideoDecodeH264PictureInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_PICTURE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            p_std_picture_info: ::std::ptr::null(),
+            slices_count: u32::default(),
+            p_slices_data_offsets: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264PictureInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH264PictureInfoEXTBuilder<'a> {
+        VideoDecodeH264PictureInfoEXTBuilder {
+            inner: VideoDecodeH264PictureInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264PictureInfoEXTBuilder<'a> {
+    inner: VideoDecodeH264PictureInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH264PictureInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH264PictureInfoEXT {}
+pub unsafe trait ExtendsVideoDecodeH264PictureInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264PictureInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH264PictureInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264PictureInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264PictureInfoEXTBuilder<'a> {
+    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoDecodeH264PictureInfo) -> Self {
+        self.inner.p_std_picture_info = std_picture_info;
+        self
+    }
+    pub fn slices_data_offsets(mut self, slices_data_offsets: &'a [u32]) -> Self {
+        self.inner.slices_count = slices_data_offsets.len() as _;
+        self.inner.p_slices_data_offsets = slices_data_offsets.as_ptr();
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoDecodeH264PictureInfoEXT>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264PictureInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264DpbSlotInfoEXT.html>"]
+pub struct VideoDecodeH264DpbSlotInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_std_reference_info: *const StdVideoDecodeH264ReferenceInfo,
+}
+impl ::std::default::Default for VideoDecodeH264DpbSlotInfoEXT {
+    fn default() -> VideoDecodeH264DpbSlotInfoEXT {
+        VideoDecodeH264DpbSlotInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            p_std_reference_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264DpbSlotInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH264DpbSlotInfoEXTBuilder<'a> {
+        VideoDecodeH264DpbSlotInfoEXTBuilder {
+            inner: VideoDecodeH264DpbSlotInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264DpbSlotInfoEXTBuilder<'a> {
+    inner: VideoDecodeH264DpbSlotInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH264DpbSlotInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH264DpbSlotInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264DpbSlotInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH264DpbSlotInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264DpbSlotInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264DpbSlotInfoEXTBuilder<'a> {
+    pub fn std_reference_info(
+        mut self,
+        std_reference_info: &'a StdVideoDecodeH264ReferenceInfo,
+    ) -> Self {
+        self.inner.p_std_reference_info = std_reference_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264DpbSlotInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH264MvcEXT.html>"]
+pub struct VideoDecodeH264MvcEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_std_mvc: *const StdVideoDecodeH264Mvc,
+}
+impl ::std::default::Default for VideoDecodeH264MvcEXT {
+    fn default() -> VideoDecodeH264MvcEXT {
+        VideoDecodeH264MvcEXT {
+            s_type: StructureType::VIDEO_DECODE_H264_MVC_EXT,
+            p_next: ::std::ptr::null(),
+            p_std_mvc: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH264MvcEXT {
+    pub fn builder<'a>() -> VideoDecodeH264MvcEXTBuilder<'a> {
+        VideoDecodeH264MvcEXTBuilder {
+            inner: VideoDecodeH264MvcEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH264MvcEXTBuilder<'a> {
+    inner: VideoDecodeH264MvcEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoDecodeH264PictureInfoEXT for VideoDecodeH264MvcEXTBuilder<'_> {}
+unsafe impl ExtendsVideoDecodeH264PictureInfoEXT for VideoDecodeH264MvcEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH264MvcEXTBuilder<'a> {
+    type Target = VideoDecodeH264MvcEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH264MvcEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH264MvcEXTBuilder<'a> {
+    pub fn std_mvc(mut self, std_mvc: &'a StdVideoDecodeH264Mvc) -> Self {
+        self.inner.p_std_mvc = std_mvc;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH264MvcEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265ProfileEXT.html>"]
+pub struct VideoDecodeH265ProfileEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub std_profile_idc: StdVideoH265ProfileIdc,
+}
+impl ::std::default::Default for VideoDecodeH265ProfileEXT {
+    fn default() -> VideoDecodeH265ProfileEXT {
+        VideoDecodeH265ProfileEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_PROFILE_EXT,
+            p_next: ::std::ptr::null(),
+            std_profile_idc: StdVideoH265ProfileIdc::default(),
+        }
+    }
+}
+impl VideoDecodeH265ProfileEXT {
+    pub fn builder<'a>() -> VideoDecodeH265ProfileEXTBuilder<'a> {
+        VideoDecodeH265ProfileEXTBuilder {
+            inner: VideoDecodeH265ProfileEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265ProfileEXTBuilder<'a> {
+    inner: VideoDecodeH265ProfileEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoProfileKHR for VideoDecodeH265ProfileEXTBuilder<'_> {}
+unsafe impl ExtendsVideoProfileKHR for VideoDecodeH265ProfileEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH265ProfileEXTBuilder<'a> {
+    type Target = VideoDecodeH265ProfileEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265ProfileEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265ProfileEXTBuilder<'a> {
+    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH265ProfileIdc) -> Self {
+        self.inner.std_profile_idc = std_profile_idc;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265ProfileEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265CapabilitiesEXT.html>"]
+pub struct VideoDecodeH265CapabilitiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub max_level: u32,
+    pub std_extension_version: ExtensionProperties,
+}
+impl ::std::default::Default for VideoDecodeH265CapabilitiesEXT {
+    fn default() -> VideoDecodeH265CapabilitiesEXT {
+        VideoDecodeH265CapabilitiesEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_CAPABILITIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            max_level: u32::default(),
+            std_extension_version: ExtensionProperties::default(),
+        }
+    }
+}
+impl VideoDecodeH265CapabilitiesEXT {
+    pub fn builder<'a>() -> VideoDecodeH265CapabilitiesEXTBuilder<'a> {
+        VideoDecodeH265CapabilitiesEXTBuilder {
+            inner: VideoDecodeH265CapabilitiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265CapabilitiesEXTBuilder<'a> {
+    inner: VideoDecodeH265CapabilitiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH265CapabilitiesEXTBuilder<'_> {}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoDecodeH265CapabilitiesEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH265CapabilitiesEXTBuilder<'a> {
+    type Target = VideoDecodeH265CapabilitiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265CapabilitiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265CapabilitiesEXTBuilder<'a> {
+    pub fn max_level(mut self, max_level: u32) -> Self {
+        self.inner.max_level = max_level;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: ExtensionProperties) -> Self {
+        self.inner.std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265CapabilitiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265SessionCreateInfoEXT.html>"]
+pub struct VideoDecodeH265SessionCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoDecodeH265CreateFlagsEXT,
+    pub p_std_extension_version: *const ExtensionProperties,
+}
+impl ::std::default::Default for VideoDecodeH265SessionCreateInfoEXT {
+    fn default() -> VideoDecodeH265SessionCreateInfoEXT {
+        VideoDecodeH265SessionCreateInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            flags: VideoDecodeH265CreateFlagsEXT::default(),
+            p_std_extension_version: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH265SessionCreateInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH265SessionCreateInfoEXTBuilder<'a> {
+        VideoDecodeH265SessionCreateInfoEXTBuilder {
+            inner: VideoDecodeH265SessionCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265SessionCreateInfoEXTBuilder<'a> {
+    inner: VideoDecodeH265SessionCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoDecodeH265SessionCreateInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoDecodeH265SessionCreateInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH265SessionCreateInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH265SessionCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265SessionCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265SessionCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: VideoDecodeH265CreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: &'a ExtensionProperties) -> Self {
+        self.inner.p_std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265SessionCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265SessionParametersAddInfoEXT.html>"]
+pub struct VideoDecodeH265SessionParametersAddInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub sps_std_count: u32,
+    pub p_sps_std: *const StdVideoH265SequenceParameterSet,
+    pub pps_std_count: u32,
+    pub p_pps_std: *const StdVideoH265PictureParameterSet,
+}
+impl ::std::default::Default for VideoDecodeH265SessionParametersAddInfoEXT {
+    fn default() -> VideoDecodeH265SessionParametersAddInfoEXT {
+        VideoDecodeH265SessionParametersAddInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            sps_std_count: u32::default(),
+            p_sps_std: ::std::ptr::null(),
+            pps_std_count: u32::default(),
+            p_pps_std: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH265SessionParametersAddInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH265SessionParametersAddInfoEXTBuilder<'a> {
+        VideoDecodeH265SessionParametersAddInfoEXTBuilder {
+            inner: VideoDecodeH265SessionParametersAddInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265SessionParametersAddInfoEXTBuilder<'a> {
+    inner: VideoDecodeH265SessionParametersAddInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoDecodeH265SessionParametersAddInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoDecodeH265SessionParametersAddInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoDecodeH265SessionParametersAddInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH265SessionParametersAddInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265SessionParametersAddInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265SessionParametersAddInfoEXTBuilder<'a> {
+    pub fn sps_std(mut self, sps_std: &'a [StdVideoH265SequenceParameterSet]) -> Self {
+        self.inner.sps_std_count = sps_std.len() as _;
+        self.inner.p_sps_std = sps_std.as_ptr();
+        self
+    }
+    pub fn pps_std(mut self, pps_std: &'a [StdVideoH265PictureParameterSet]) -> Self {
+        self.inner.pps_std_count = pps_std.len() as _;
+        self.inner.p_pps_std = pps_std.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265SessionParametersAddInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265SessionParametersCreateInfoEXT.html>"]
+pub struct VideoDecodeH265SessionParametersCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub max_sps_std_count: u32,
+    pub max_pps_std_count: u32,
+    pub p_parameters_add_info: *const VideoDecodeH265SessionParametersAddInfoEXT,
+}
+impl ::std::default::Default for VideoDecodeH265SessionParametersCreateInfoEXT {
+    fn default() -> VideoDecodeH265SessionParametersCreateInfoEXT {
+        VideoDecodeH265SessionParametersCreateInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            max_sps_std_count: u32::default(),
+            max_pps_std_count: u32::default(),
+            p_parameters_add_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH265SessionParametersCreateInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'a> {
+        VideoDecodeH265SessionParametersCreateInfoEXTBuilder {
+            inner: VideoDecodeH265SessionParametersCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'a> {
+    inner: VideoDecodeH265SessionParametersCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoDecodeH265SessionParametersCreateInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH265SessionParametersCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265SessionParametersCreateInfoEXTBuilder<'a> {
+    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
+        self.inner.max_sps_std_count = max_sps_std_count;
+        self
+    }
+    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
+        self.inner.max_pps_std_count = max_pps_std_count;
+        self
+    }
+    pub fn parameters_add_info(
+        mut self,
+        parameters_add_info: &'a VideoDecodeH265SessionParametersAddInfoEXT,
+    ) -> Self {
+        self.inner.p_parameters_add_info = parameters_add_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265SessionParametersCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265PictureInfoEXT.html>"]
+pub struct VideoDecodeH265PictureInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_std_picture_info: *mut StdVideoDecodeH265PictureInfo,
+    pub slices_count: u32,
+    pub p_slices_data_offsets: *const u32,
+}
+impl ::std::default::Default for VideoDecodeH265PictureInfoEXT {
+    fn default() -> VideoDecodeH265PictureInfoEXT {
+        VideoDecodeH265PictureInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_PICTURE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            p_std_picture_info: ::std::ptr::null_mut(),
+            slices_count: u32::default(),
+            p_slices_data_offsets: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH265PictureInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH265PictureInfoEXTBuilder<'a> {
+        VideoDecodeH265PictureInfoEXTBuilder {
+            inner: VideoDecodeH265PictureInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265PictureInfoEXTBuilder<'a> {
+    inner: VideoDecodeH265PictureInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH265PictureInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoDecodeInfoKHR for VideoDecodeH265PictureInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH265PictureInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH265PictureInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265PictureInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265PictureInfoEXTBuilder<'a> {
+    pub fn std_picture_info(
+        mut self,
+        std_picture_info: &'a mut StdVideoDecodeH265PictureInfo,
+    ) -> Self {
+        self.inner.p_std_picture_info = std_picture_info;
+        self
+    }
+    pub fn slices_data_offsets(mut self, slices_data_offsets: &'a [u32]) -> Self {
+        self.inner.slices_count = slices_data_offsets.len() as _;
+        self.inner.p_slices_data_offsets = slices_data_offsets.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265PictureInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoDecodeH265DpbSlotInfoEXT.html>"]
+pub struct VideoDecodeH265DpbSlotInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_std_reference_info: *const StdVideoDecodeH265ReferenceInfo,
+}
+impl ::std::default::Default for VideoDecodeH265DpbSlotInfoEXT {
+    fn default() -> VideoDecodeH265DpbSlotInfoEXT {
+        VideoDecodeH265DpbSlotInfoEXT {
+            s_type: StructureType::VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            p_std_reference_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoDecodeH265DpbSlotInfoEXT {
+    pub fn builder<'a>() -> VideoDecodeH265DpbSlotInfoEXTBuilder<'a> {
+        VideoDecodeH265DpbSlotInfoEXTBuilder {
+            inner: VideoDecodeH265DpbSlotInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoDecodeH265DpbSlotInfoEXTBuilder<'a> {
+    inner: VideoDecodeH265DpbSlotInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH265DpbSlotInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoReferenceSlotKHR for VideoDecodeH265DpbSlotInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoDecodeH265DpbSlotInfoEXTBuilder<'a> {
+    type Target = VideoDecodeH265DpbSlotInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoDecodeH265DpbSlotInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoDecodeH265DpbSlotInfoEXTBuilder<'a> {
+    pub fn std_reference_info(
+        mut self,
+        std_reference_info: &'a StdVideoDecodeH265ReferenceInfo,
+    ) -> Self {
+        self.inner.p_std_reference_info = std_reference_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoDecodeH265DpbSlotInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoSessionCreateInfoKHR.html>"]
+pub struct VideoSessionCreateInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub queue_family_index: u32,
+    pub flags: VideoSessionCreateFlagsKHR,
+    pub p_video_profile: *const VideoProfileKHR,
+    pub picture_format: Format,
+    pub max_coded_extent: Extent2D,
+    pub reference_pictures_format: Format,
+    pub max_reference_pictures_slots_count: u32,
+    pub max_reference_pictures_active_count: u32,
+}
+impl ::std::default::Default for VideoSessionCreateInfoKHR {
+    fn default() -> VideoSessionCreateInfoKHR {
+        VideoSessionCreateInfoKHR {
+            s_type: StructureType::VIDEO_SESSION_CREATE_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            queue_family_index: u32::default(),
+            flags: VideoSessionCreateFlagsKHR::default(),
+            p_video_profile: ::std::ptr::null(),
+            picture_format: Format::default(),
+            max_coded_extent: Extent2D::default(),
+            reference_pictures_format: Format::default(),
+            max_reference_pictures_slots_count: u32::default(),
+            max_reference_pictures_active_count: u32::default(),
+        }
+    }
+}
+impl VideoSessionCreateInfoKHR {
+    pub fn builder<'a>() -> VideoSessionCreateInfoKHRBuilder<'a> {
+        VideoSessionCreateInfoKHRBuilder {
+            inner: VideoSessionCreateInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoSessionCreateInfoKHRBuilder<'a> {
+    inner: VideoSessionCreateInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoSessionCreateInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoSessionCreateInfoKHRBuilder<'a> {
+    type Target = VideoSessionCreateInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoSessionCreateInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoSessionCreateInfoKHRBuilder<'a> {
+    pub fn queue_family_index(mut self, queue_family_index: u32) -> Self {
+        self.inner.queue_family_index = queue_family_index;
+        self
+    }
+    pub fn flags(mut self, flags: VideoSessionCreateFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn video_profile(mut self, video_profile: &'a VideoProfileKHR) -> Self {
+        self.inner.p_video_profile = video_profile;
+        self
+    }
+    pub fn picture_format(mut self, picture_format: Format) -> Self {
+        self.inner.picture_format = picture_format;
+        self
+    }
+    pub fn max_coded_extent(mut self, max_coded_extent: Extent2D) -> Self {
+        self.inner.max_coded_extent = max_coded_extent;
+        self
+    }
+    pub fn reference_pictures_format(mut self, reference_pictures_format: Format) -> Self {
+        self.inner.reference_pictures_format = reference_pictures_format;
+        self
+    }
+    pub fn max_reference_pictures_slots_count(
+        mut self,
+        max_reference_pictures_slots_count: u32,
+    ) -> Self {
+        self.inner.max_reference_pictures_slots_count = max_reference_pictures_slots_count;
+        self
+    }
+    pub fn max_reference_pictures_active_count(
+        mut self,
+        max_reference_pictures_active_count: u32,
+    ) -> Self {
+        self.inner.max_reference_pictures_active_count = max_reference_pictures_active_count;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoSessionCreateInfoKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoSessionCreateInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoSessionParametersCreateInfoKHR.html>"]
+pub struct VideoSessionParametersCreateInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub video_session_parameters_template: VideoSessionParametersKHR,
+    pub video_session: VideoSessionKHR,
+}
+impl ::std::default::Default for VideoSessionParametersCreateInfoKHR {
+    fn default() -> VideoSessionParametersCreateInfoKHR {
+        VideoSessionParametersCreateInfoKHR {
+            s_type: StructureType::VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            video_session_parameters_template: VideoSessionParametersKHR::default(),
+            video_session: VideoSessionKHR::default(),
+        }
+    }
+}
+impl VideoSessionParametersCreateInfoKHR {
+    pub fn builder<'a>() -> VideoSessionParametersCreateInfoKHRBuilder<'a> {
+        VideoSessionParametersCreateInfoKHRBuilder {
+            inner: VideoSessionParametersCreateInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoSessionParametersCreateInfoKHRBuilder<'a> {
+    inner: VideoSessionParametersCreateInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoSessionParametersCreateInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoSessionParametersCreateInfoKHRBuilder<'a> {
+    type Target = VideoSessionParametersCreateInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoSessionParametersCreateInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoSessionParametersCreateInfoKHRBuilder<'a> {
+    pub fn video_session_parameters_template(
+        mut self,
+        video_session_parameters_template: VideoSessionParametersKHR,
+    ) -> Self {
+        self.inner.video_session_parameters_template = video_session_parameters_template;
+        self
+    }
+    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
+        self.inner.video_session = video_session;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoSessionParametersCreateInfoKHR>(
+        mut self,
+        next: &'a mut T,
+    ) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoSessionParametersCreateInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoSessionParametersUpdateInfoKHR.html>"]
+pub struct VideoSessionParametersUpdateInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub update_sequence_count: u32,
+}
+impl ::std::default::Default for VideoSessionParametersUpdateInfoKHR {
+    fn default() -> VideoSessionParametersUpdateInfoKHR {
+        VideoSessionParametersUpdateInfoKHR {
+            s_type: StructureType::VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            update_sequence_count: u32::default(),
+        }
+    }
+}
+impl VideoSessionParametersUpdateInfoKHR {
+    pub fn builder<'a>() -> VideoSessionParametersUpdateInfoKHRBuilder<'a> {
+        VideoSessionParametersUpdateInfoKHRBuilder {
+            inner: VideoSessionParametersUpdateInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoSessionParametersUpdateInfoKHRBuilder<'a> {
+    inner: VideoSessionParametersUpdateInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoSessionParametersUpdateInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoSessionParametersUpdateInfoKHRBuilder<'a> {
+    type Target = VideoSessionParametersUpdateInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoSessionParametersUpdateInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoSessionParametersUpdateInfoKHRBuilder<'a> {
+    pub fn update_sequence_count(mut self, update_sequence_count: u32) -> Self {
+        self.inner.update_sequence_count = update_sequence_count;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoSessionParametersUpdateInfoKHR>(
+        mut self,
+        next: &'a mut T,
+    ) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoSessionParametersUpdateInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoBeginCodingInfoKHR.html>"]
+pub struct VideoBeginCodingInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoBeginCodingFlagsKHR,
+    pub codec_quality_preset: VideoCodingQualityPresetFlagsKHR,
+    pub video_session: VideoSessionKHR,
+    pub video_session_parameters: VideoSessionParametersKHR,
+    pub reference_slot_count: u32,
+    pub p_reference_slots: *const VideoReferenceSlotKHR,
+}
+impl ::std::default::Default for VideoBeginCodingInfoKHR {
+    fn default() -> VideoBeginCodingInfoKHR {
+        VideoBeginCodingInfoKHR {
+            s_type: StructureType::VIDEO_BEGIN_CODING_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoBeginCodingFlagsKHR::default(),
+            codec_quality_preset: VideoCodingQualityPresetFlagsKHR::default(),
+            video_session: VideoSessionKHR::default(),
+            video_session_parameters: VideoSessionParametersKHR::default(),
+            reference_slot_count: u32::default(),
+            p_reference_slots: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoBeginCodingInfoKHR {
+    pub fn builder<'a>() -> VideoBeginCodingInfoKHRBuilder<'a> {
+        VideoBeginCodingInfoKHRBuilder {
+            inner: VideoBeginCodingInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoBeginCodingInfoKHRBuilder<'a> {
+    inner: VideoBeginCodingInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoBeginCodingInfoKHRBuilder<'a> {
+    type Target = VideoBeginCodingInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoBeginCodingInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoBeginCodingInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoBeginCodingFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn codec_quality_preset(
+        mut self,
+        codec_quality_preset: VideoCodingQualityPresetFlagsKHR,
+    ) -> Self {
+        self.inner.codec_quality_preset = codec_quality_preset;
+        self
+    }
+    pub fn video_session(mut self, video_session: VideoSessionKHR) -> Self {
+        self.inner.video_session = video_session;
+        self
+    }
+    pub fn video_session_parameters(
+        mut self,
+        video_session_parameters: VideoSessionParametersKHR,
+    ) -> Self {
+        self.inner.video_session_parameters = video_session_parameters;
+        self
+    }
+    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
+        self.inner.reference_slot_count = reference_slots.len() as _;
+        self.inner.p_reference_slots = reference_slots.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoBeginCodingInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEndCodingInfoKHR.html>"]
+pub struct VideoEndCodingInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoEndCodingFlagsKHR,
+}
+impl ::std::default::Default for VideoEndCodingInfoKHR {
+    fn default() -> VideoEndCodingInfoKHR {
+        VideoEndCodingInfoKHR {
+            s_type: StructureType::VIDEO_END_CODING_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoEndCodingFlagsKHR::default(),
+        }
+    }
+}
+impl VideoEndCodingInfoKHR {
+    pub fn builder<'a>() -> VideoEndCodingInfoKHRBuilder<'a> {
+        VideoEndCodingInfoKHRBuilder {
+            inner: VideoEndCodingInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEndCodingInfoKHRBuilder<'a> {
+    inner: VideoEndCodingInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoEndCodingInfoKHRBuilder<'a> {
+    type Target = VideoEndCodingInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEndCodingInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEndCodingInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoEndCodingFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEndCodingInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoCodingControlInfoKHR.html>"]
+pub struct VideoCodingControlInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoCodingControlFlagsKHR,
+}
+impl ::std::default::Default for VideoCodingControlInfoKHR {
+    fn default() -> VideoCodingControlInfoKHR {
+        VideoCodingControlInfoKHR {
+            s_type: StructureType::VIDEO_CODING_CONTROL_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoCodingControlFlagsKHR::default(),
+        }
+    }
+}
+impl VideoCodingControlInfoKHR {
+    pub fn builder<'a>() -> VideoCodingControlInfoKHRBuilder<'a> {
+        VideoCodingControlInfoKHRBuilder {
+            inner: VideoCodingControlInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoCodingControlInfoKHRBuilder<'a> {
+    inner: VideoCodingControlInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoCodingControlInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoCodingControlInfoKHRBuilder<'a> {
+    type Target = VideoCodingControlInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoCodingControlInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoCodingControlInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoCodingControlFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoCodingControlInfoKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoCodingControlInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeInfoKHR.html>"]
+pub struct VideoEncodeInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoEncodeFlagsKHR,
+    pub quality_level: u32,
+    pub coded_extent: Extent2D,
+    pub dst_bitstream_buffer: Buffer,
+    pub dst_bitstream_buffer_offset: DeviceSize,
+    pub dst_bitstream_buffer_max_range: DeviceSize,
+    pub src_picture_resource: VideoPictureResourceKHR,
+    pub p_setup_reference_slot: *const VideoReferenceSlotKHR,
+    pub reference_slot_count: u32,
+    pub p_reference_slots: *const VideoReferenceSlotKHR,
+}
+impl ::std::default::Default for VideoEncodeInfoKHR {
+    fn default() -> VideoEncodeInfoKHR {
+        VideoEncodeInfoKHR {
+            s_type: StructureType::VIDEO_ENCODE_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoEncodeFlagsKHR::default(),
+            quality_level: u32::default(),
+            coded_extent: Extent2D::default(),
+            dst_bitstream_buffer: Buffer::default(),
+            dst_bitstream_buffer_offset: DeviceSize::default(),
+            dst_bitstream_buffer_max_range: DeviceSize::default(),
+            src_picture_resource: VideoPictureResourceKHR::default(),
+            p_setup_reference_slot: ::std::ptr::null(),
+            reference_slot_count: u32::default(),
+            p_reference_slots: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeInfoKHR {
+    pub fn builder<'a>() -> VideoEncodeInfoKHRBuilder<'a> {
+        VideoEncodeInfoKHRBuilder {
+            inner: VideoEncodeInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeInfoKHRBuilder<'a> {
+    inner: VideoEncodeInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+pub unsafe trait ExtendsVideoEncodeInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoEncodeInfoKHRBuilder<'a> {
+    type Target = VideoEncodeInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoEncodeFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn quality_level(mut self, quality_level: u32) -> Self {
+        self.inner.quality_level = quality_level;
+        self
+    }
+    pub fn coded_extent(mut self, coded_extent: Extent2D) -> Self {
+        self.inner.coded_extent = coded_extent;
+        self
+    }
+    pub fn dst_bitstream_buffer(mut self, dst_bitstream_buffer: Buffer) -> Self {
+        self.inner.dst_bitstream_buffer = dst_bitstream_buffer;
+        self
+    }
+    pub fn dst_bitstream_buffer_offset(mut self, dst_bitstream_buffer_offset: DeviceSize) -> Self {
+        self.inner.dst_bitstream_buffer_offset = dst_bitstream_buffer_offset;
+        self
+    }
+    pub fn dst_bitstream_buffer_max_range(
+        mut self,
+        dst_bitstream_buffer_max_range: DeviceSize,
+    ) -> Self {
+        self.inner.dst_bitstream_buffer_max_range = dst_bitstream_buffer_max_range;
+        self
+    }
+    pub fn src_picture_resource(mut self, src_picture_resource: VideoPictureResourceKHR) -> Self {
+        self.inner.src_picture_resource = src_picture_resource;
+        self
+    }
+    pub fn setup_reference_slot(mut self, setup_reference_slot: &'a VideoReferenceSlotKHR) -> Self {
+        self.inner.p_setup_reference_slot = setup_reference_slot;
+        self
+    }
+    pub fn reference_slots(mut self, reference_slots: &'a [VideoReferenceSlotKHR]) -> Self {
+        self.inner.reference_slot_count = reference_slots.len() as _;
+        self.inner.p_reference_slots = reference_slots.as_ptr();
+        self
+    }
+    #[doc = r" Prepends the given extension struct between the root and the first pointer. This"]
+    #[doc = r" method only exists on structs that can be passed to a function directly. Only"]
+    #[doc = r" valid extension structs can be pushed into the chain."]
+    #[doc = r" If the chain looks like `A -> B -> C`, and you call `builder.push_next(&mut D)`, then the"]
+    #[doc = r" chain will look like `A -> D -> B -> C`."]
+    pub fn push_next<T: ExtendsVideoEncodeInfoKHR>(mut self, next: &'a mut T) -> Self {
+        unsafe {
+            let next_ptr = next as *mut T as *mut BaseOutStructure;
+            let last_next = ptr_chain_iter(next).last().unwrap();
+            (*last_next).p_next = self.inner.p_next as _;
+            self.inner.p_next = next_ptr as _;
+        }
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeRateControlInfoKHR.html>"]
+pub struct VideoEncodeRateControlInfoKHR {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoEncodeRateControlFlagsKHR,
+    pub rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
+    pub average_bitrate: u32,
+    pub peak_to_average_bitrate_ratio: u16,
+    pub frame_rate_numerator: u16,
+    pub frame_rate_denominator: u16,
+    pub virtual_buffer_size_in_ms: u32,
+}
+impl ::std::default::Default for VideoEncodeRateControlInfoKHR {
+    fn default() -> VideoEncodeRateControlInfoKHR {
+        VideoEncodeRateControlInfoKHR {
+            s_type: StructureType::VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
+            p_next: ::std::ptr::null(),
+            flags: VideoEncodeRateControlFlagsKHR::default(),
+            rate_control_mode: VideoEncodeRateControlModeFlagsKHR::default(),
+            average_bitrate: u32::default(),
+            peak_to_average_bitrate_ratio: u16::default(),
+            frame_rate_numerator: u16::default(),
+            frame_rate_denominator: u16::default(),
+            virtual_buffer_size_in_ms: u32::default(),
+        }
+    }
+}
+impl VideoEncodeRateControlInfoKHR {
+    pub fn builder<'a>() -> VideoEncodeRateControlInfoKHRBuilder<'a> {
+        VideoEncodeRateControlInfoKHRBuilder {
+            inner: VideoEncodeRateControlInfoKHR::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeRateControlInfoKHRBuilder<'a> {
+    inner: VideoEncodeRateControlInfoKHR,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlInfoKHRBuilder<'_> {}
+unsafe impl ExtendsVideoCodingControlInfoKHR for VideoEncodeRateControlInfoKHR {}
+impl<'a> ::std::ops::Deref for VideoEncodeRateControlInfoKHRBuilder<'a> {
+    type Target = VideoEncodeRateControlInfoKHR;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeRateControlInfoKHRBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeRateControlInfoKHRBuilder<'a> {
+    pub fn flags(mut self, flags: VideoEncodeRateControlFlagsKHR) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn rate_control_mode(
+        mut self,
+        rate_control_mode: VideoEncodeRateControlModeFlagsKHR,
+    ) -> Self {
+        self.inner.rate_control_mode = rate_control_mode;
+        self
+    }
+    pub fn average_bitrate(mut self, average_bitrate: u32) -> Self {
+        self.inner.average_bitrate = average_bitrate;
+        self
+    }
+    pub fn peak_to_average_bitrate_ratio(mut self, peak_to_average_bitrate_ratio: u16) -> Self {
+        self.inner.peak_to_average_bitrate_ratio = peak_to_average_bitrate_ratio;
+        self
+    }
+    pub fn frame_rate_numerator(mut self, frame_rate_numerator: u16) -> Self {
+        self.inner.frame_rate_numerator = frame_rate_numerator;
+        self
+    }
+    pub fn frame_rate_denominator(mut self, frame_rate_denominator: u16) -> Self {
+        self.inner.frame_rate_denominator = frame_rate_denominator;
+        self
+    }
+    pub fn virtual_buffer_size_in_ms(mut self, virtual_buffer_size_in_ms: u32) -> Self {
+        self.inner.virtual_buffer_size_in_ms = virtual_buffer_size_in_ms;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeRateControlInfoKHR {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264CapabilitiesEXT.html>"]
+pub struct VideoEncodeH264CapabilitiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoEncodeH264CapabilitiesFlagsEXT,
+    pub input_mode_flags: VideoEncodeH264InputModeFlagsEXT,
+    pub output_mode_flags: VideoEncodeH264OutputModeFlagsEXT,
+    pub min_picture_size_in_mbs: Extent2D,
+    pub max_picture_size_in_mbs: Extent2D,
+    pub input_image_data_alignment: Extent2D,
+    pub max_num_l0_reference_for_p: u8,
+    pub max_num_l0_reference_for_b: u8,
+    pub max_num_l1_reference: u8,
+    pub quality_level_count: u8,
+    pub std_extension_version: ExtensionProperties,
+}
+impl ::std::default::Default for VideoEncodeH264CapabilitiesEXT {
+    fn default() -> VideoEncodeH264CapabilitiesEXT {
+        VideoEncodeH264CapabilitiesEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_CAPABILITIES_EXT,
+            p_next: ::std::ptr::null(),
+            flags: VideoEncodeH264CapabilitiesFlagsEXT::default(),
+            input_mode_flags: VideoEncodeH264InputModeFlagsEXT::default(),
+            output_mode_flags: VideoEncodeH264OutputModeFlagsEXT::default(),
+            min_picture_size_in_mbs: Extent2D::default(),
+            max_picture_size_in_mbs: Extent2D::default(),
+            input_image_data_alignment: Extent2D::default(),
+            max_num_l0_reference_for_p: u8::default(),
+            max_num_l0_reference_for_b: u8::default(),
+            max_num_l1_reference: u8::default(),
+            quality_level_count: u8::default(),
+            std_extension_version: ExtensionProperties::default(),
+        }
+    }
+}
+impl VideoEncodeH264CapabilitiesEXT {
+    pub fn builder<'a>() -> VideoEncodeH264CapabilitiesEXTBuilder<'a> {
+        VideoEncodeH264CapabilitiesEXTBuilder {
+            inner: VideoEncodeH264CapabilitiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264CapabilitiesEXTBuilder<'a> {
+    inner: VideoEncodeH264CapabilitiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH264CapabilitiesEXTBuilder<'_> {}
+unsafe impl ExtendsVideoCapabilitiesKHR for VideoEncodeH264CapabilitiesEXT {}
+impl<'a> ::std::ops::Deref for VideoEncodeH264CapabilitiesEXTBuilder<'a> {
+    type Target = VideoEncodeH264CapabilitiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264CapabilitiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264CapabilitiesEXTBuilder<'a> {
+    pub fn flags(mut self, flags: VideoEncodeH264CapabilitiesFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn input_mode_flags(mut self, input_mode_flags: VideoEncodeH264InputModeFlagsEXT) -> Self {
+        self.inner.input_mode_flags = input_mode_flags;
+        self
+    }
+    pub fn output_mode_flags(
+        mut self,
+        output_mode_flags: VideoEncodeH264OutputModeFlagsEXT,
+    ) -> Self {
+        self.inner.output_mode_flags = output_mode_flags;
+        self
+    }
+    pub fn min_picture_size_in_mbs(mut self, min_picture_size_in_mbs: Extent2D) -> Self {
+        self.inner.min_picture_size_in_mbs = min_picture_size_in_mbs;
+        self
+    }
+    pub fn max_picture_size_in_mbs(mut self, max_picture_size_in_mbs: Extent2D) -> Self {
+        self.inner.max_picture_size_in_mbs = max_picture_size_in_mbs;
+        self
+    }
+    pub fn input_image_data_alignment(mut self, input_image_data_alignment: Extent2D) -> Self {
+        self.inner.input_image_data_alignment = input_image_data_alignment;
+        self
+    }
+    pub fn max_num_l0_reference_for_p(mut self, max_num_l0_reference_for_p: u8) -> Self {
+        self.inner.max_num_l0_reference_for_p = max_num_l0_reference_for_p;
+        self
+    }
+    pub fn max_num_l0_reference_for_b(mut self, max_num_l0_reference_for_b: u8) -> Self {
+        self.inner.max_num_l0_reference_for_b = max_num_l0_reference_for_b;
+        self
+    }
+    pub fn max_num_l1_reference(mut self, max_num_l1_reference: u8) -> Self {
+        self.inner.max_num_l1_reference = max_num_l1_reference;
+        self
+    }
+    pub fn quality_level_count(mut self, quality_level_count: u8) -> Self {
+        self.inner.quality_level_count = quality_level_count;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: ExtensionProperties) -> Self {
+        self.inner.std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264CapabilitiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264SessionCreateInfoEXT.html>"]
+pub struct VideoEncodeH264SessionCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub flags: VideoEncodeH264CreateFlagsEXT,
+    pub max_picture_size_in_mbs: Extent2D,
+    pub p_std_extension_version: *const ExtensionProperties,
+}
+impl ::std::default::Default for VideoEncodeH264SessionCreateInfoEXT {
+    fn default() -> VideoEncodeH264SessionCreateInfoEXT {
+        VideoEncodeH264SessionCreateInfoEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            flags: VideoEncodeH264CreateFlagsEXT::default(),
+            max_picture_size_in_mbs: Extent2D::default(),
+            p_std_extension_version: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264SessionCreateInfoEXT {
+    pub fn builder<'a>() -> VideoEncodeH264SessionCreateInfoEXTBuilder<'a> {
+        VideoEncodeH264SessionCreateInfoEXTBuilder {
+            inner: VideoEncodeH264SessionCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264SessionCreateInfoEXTBuilder<'a> {
+    inner: VideoEncodeH264SessionCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoEncodeH264SessionCreateInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoSessionCreateInfoKHR for VideoEncodeH264SessionCreateInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoEncodeH264SessionCreateInfoEXTBuilder<'a> {
+    type Target = VideoEncodeH264SessionCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264SessionCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264SessionCreateInfoEXTBuilder<'a> {
+    pub fn flags(mut self, flags: VideoEncodeH264CreateFlagsEXT) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn max_picture_size_in_mbs(mut self, max_picture_size_in_mbs: Extent2D) -> Self {
+        self.inner.max_picture_size_in_mbs = max_picture_size_in_mbs;
+        self
+    }
+    pub fn std_extension_version(mut self, std_extension_version: &'a ExtensionProperties) -> Self {
+        self.inner.p_std_extension_version = std_extension_version;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264SessionCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264SessionParametersAddInfoEXT.html>"]
+pub struct VideoEncodeH264SessionParametersAddInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub sps_std_count: u32,
+    pub p_sps_std: *const StdVideoH264SequenceParameterSet,
+    pub pps_std_count: u32,
+    pub p_pps_std: *const StdVideoH264PictureParameterSet,
+}
+impl ::std::default::Default for VideoEncodeH264SessionParametersAddInfoEXT {
+    fn default() -> VideoEncodeH264SessionParametersAddInfoEXT {
+        VideoEncodeH264SessionParametersAddInfoEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            sps_std_count: u32::default(),
+            p_sps_std: ::std::ptr::null(),
+            pps_std_count: u32::default(),
+            p_pps_std: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264SessionParametersAddInfoEXT {
+    pub fn builder<'a>() -> VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
+        VideoEncodeH264SessionParametersAddInfoEXTBuilder {
+            inner: VideoEncodeH264SessionParametersAddInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    inner: VideoEncodeH264SessionParametersAddInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersUpdateInfoKHR
+    for VideoEncodeH264SessionParametersAddInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    type Target = VideoEncodeH264SessionParametersAddInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264SessionParametersAddInfoEXTBuilder<'a> {
+    pub fn sps_std(mut self, sps_std: &'a [StdVideoH264SequenceParameterSet]) -> Self {
+        self.inner.sps_std_count = sps_std.len() as _;
+        self.inner.p_sps_std = sps_std.as_ptr();
+        self
+    }
+    pub fn pps_std(mut self, pps_std: &'a [StdVideoH264PictureParameterSet]) -> Self {
+        self.inner.pps_std_count = pps_std.len() as _;
+        self.inner.p_pps_std = pps_std.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264SessionParametersAddInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264SessionParametersCreateInfoEXT.html>"]
+pub struct VideoEncodeH264SessionParametersCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub max_sps_std_count: u32,
+    pub max_pps_std_count: u32,
+    pub p_parameters_add_info: *const VideoEncodeH264SessionParametersAddInfoEXT,
+}
+impl ::std::default::Default for VideoEncodeH264SessionParametersCreateInfoEXT {
+    fn default() -> VideoEncodeH264SessionParametersCreateInfoEXT {
+        VideoEncodeH264SessionParametersCreateInfoEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            max_sps_std_count: u32::default(),
+            max_pps_std_count: u32::default(),
+            p_parameters_add_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264SessionParametersCreateInfoEXT {
+    pub fn builder<'a>() -> VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+        VideoEncodeH264SessionParametersCreateInfoEXTBuilder {
+            inner: VideoEncodeH264SessionParametersCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    inner: VideoEncodeH264SessionParametersCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsVideoSessionParametersCreateInfoKHR
+    for VideoEncodeH264SessionParametersCreateInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    type Target = VideoEncodeH264SessionParametersCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264SessionParametersCreateInfoEXTBuilder<'a> {
+    pub fn max_sps_std_count(mut self, max_sps_std_count: u32) -> Self {
+        self.inner.max_sps_std_count = max_sps_std_count;
+        self
+    }
+    pub fn max_pps_std_count(mut self, max_pps_std_count: u32) -> Self {
+        self.inner.max_pps_std_count = max_pps_std_count;
+        self
+    }
+    pub fn parameters_add_info(
+        mut self,
+        parameters_add_info: &'a VideoEncodeH264SessionParametersAddInfoEXT,
+    ) -> Self {
+        self.inner.p_parameters_add_info = parameters_add_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264SessionParametersCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264DpbSlotInfoEXT.html>"]
+pub struct VideoEncodeH264DpbSlotInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub slot_index: i8,
+    pub p_std_picture_info: *const StdVideoEncodeH264PictureInfo,
+}
+impl ::std::default::Default for VideoEncodeH264DpbSlotInfoEXT {
+    fn default() -> VideoEncodeH264DpbSlotInfoEXT {
+        VideoEncodeH264DpbSlotInfoEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            slot_index: i8::default(),
+            p_std_picture_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264DpbSlotInfoEXT {
+    pub fn builder<'a>() -> VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
+        VideoEncodeH264DpbSlotInfoEXTBuilder {
+            inner: VideoEncodeH264DpbSlotInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
+    inner: VideoEncodeH264DpbSlotInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
+    type Target = VideoEncodeH264DpbSlotInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264DpbSlotInfoEXTBuilder<'a> {
+    pub fn slot_index(mut self, slot_index: i8) -> Self {
+        self.inner.slot_index = slot_index;
+        self
+    }
+    pub fn std_picture_info(mut self, std_picture_info: &'a StdVideoEncodeH264PictureInfo) -> Self {
+        self.inner.p_std_picture_info = std_picture_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264DpbSlotInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264VclFrameInfoEXT.html>"]
+pub struct VideoEncodeH264VclFrameInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub ref_default_final_list0_entry_count: u8,
+    pub p_ref_default_final_list0_entries: *const VideoEncodeH264DpbSlotInfoEXT,
+    pub ref_default_final_list1_entry_count: u8,
+    pub p_ref_default_final_list1_entries: *const VideoEncodeH264DpbSlotInfoEXT,
+    pub nalu_slice_entry_count: u32,
+    pub p_nalu_slice_entries: *const VideoEncodeH264NaluSliceEXT,
+    pub p_current_picture_info: *const VideoEncodeH264DpbSlotInfoEXT,
+}
+impl ::std::default::Default for VideoEncodeH264VclFrameInfoEXT {
+    fn default() -> VideoEncodeH264VclFrameInfoEXT {
+        VideoEncodeH264VclFrameInfoEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            ref_default_final_list0_entry_count: u8::default(),
+            p_ref_default_final_list0_entries: ::std::ptr::null(),
+            ref_default_final_list1_entry_count: u8::default(),
+            p_ref_default_final_list1_entries: ::std::ptr::null(),
+            nalu_slice_entry_count: u32::default(),
+            p_nalu_slice_entries: ::std::ptr::null(),
+            p_current_picture_info: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264VclFrameInfoEXT {
+    pub fn builder<'a>() -> VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
+        VideoEncodeH264VclFrameInfoEXTBuilder {
+            inner: VideoEncodeH264VclFrameInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
+    inner: VideoEncodeH264VclFrameInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264VclFrameInfoEXTBuilder<'_> {}
+unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264VclFrameInfoEXT {}
+impl<'a> ::std::ops::Deref for VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
+    type Target = VideoEncodeH264VclFrameInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264VclFrameInfoEXTBuilder<'a> {
+    pub fn ref_default_final_list0_entries(
+        mut self,
+        ref_default_final_list0_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
+    ) -> Self {
+        self.inner.ref_default_final_list0_entry_count = ref_default_final_list0_entries.len() as _;
+        self.inner.p_ref_default_final_list0_entries = ref_default_final_list0_entries.as_ptr();
+        self
+    }
+    pub fn ref_default_final_list1_entries(
+        mut self,
+        ref_default_final_list1_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
+    ) -> Self {
+        self.inner.ref_default_final_list1_entry_count = ref_default_final_list1_entries.len() as _;
+        self.inner.p_ref_default_final_list1_entries = ref_default_final_list1_entries.as_ptr();
+        self
+    }
+    pub fn nalu_slice_entries(
+        mut self,
+        nalu_slice_entries: &'a [VideoEncodeH264NaluSliceEXT],
+    ) -> Self {
+        self.inner.nalu_slice_entry_count = nalu_slice_entries.len() as _;
+        self.inner.p_nalu_slice_entries = nalu_slice_entries.as_ptr();
+        self
+    }
+    pub fn current_picture_info(
+        mut self,
+        current_picture_info: &'a VideoEncodeH264DpbSlotInfoEXT,
+    ) -> Self {
+        self.inner.p_current_picture_info = current_picture_info;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264VclFrameInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264EmitPictureParametersEXT.html>"]
+pub struct VideoEncodeH264EmitPictureParametersEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub sps_id: u8,
+    pub emit_sps_enable: Bool32,
+    pub pps_id_entry_count: u32,
+    pub pps_id_entries: *const u8,
+}
+impl ::std::default::Default for VideoEncodeH264EmitPictureParametersEXT {
+    fn default() -> VideoEncodeH264EmitPictureParametersEXT {
+        VideoEncodeH264EmitPictureParametersEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT,
+            p_next: ::std::ptr::null(),
+            sps_id: u8::default(),
+            emit_sps_enable: Bool32::default(),
+            pps_id_entry_count: u32::default(),
+            pps_id_entries: ::std::ptr::null(),
+        }
+    }
+}
+impl VideoEncodeH264EmitPictureParametersEXT {
+    pub fn builder<'a>() -> VideoEncodeH264EmitPictureParametersEXTBuilder<'a> {
+        VideoEncodeH264EmitPictureParametersEXTBuilder {
+            inner: VideoEncodeH264EmitPictureParametersEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264EmitPictureParametersEXTBuilder<'a> {
+    inner: VideoEncodeH264EmitPictureParametersEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264EmitPictureParametersEXTBuilder<'_> {}
+unsafe impl ExtendsVideoEncodeInfoKHR for VideoEncodeH264EmitPictureParametersEXT {}
+impl<'a> ::std::ops::Deref for VideoEncodeH264EmitPictureParametersEXTBuilder<'a> {
+    type Target = VideoEncodeH264EmitPictureParametersEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264EmitPictureParametersEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264EmitPictureParametersEXTBuilder<'a> {
+    pub fn sps_id(mut self, sps_id: u8) -> Self {
+        self.inner.sps_id = sps_id;
+        self
+    }
+    pub fn emit_sps_enable(mut self, emit_sps_enable: bool) -> Self {
+        self.inner.emit_sps_enable = emit_sps_enable.into();
+        self
+    }
+    pub fn pps_id_entries(mut self, pps_id_entries: &'a [u8]) -> Self {
+        self.inner.pps_id_entry_count = pps_id_entries.len() as _;
+        self.inner.pps_id_entries = pps_id_entries.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264EmitPictureParametersEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264ProfileEXT.html>"]
+pub struct VideoEncodeH264ProfileEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub std_profile_idc: StdVideoH264ProfileIdc,
+}
+impl ::std::default::Default for VideoEncodeH264ProfileEXT {
+    fn default() -> VideoEncodeH264ProfileEXT {
+        VideoEncodeH264ProfileEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_PROFILE_EXT,
+            p_next: ::std::ptr::null(),
+            std_profile_idc: StdVideoH264ProfileIdc::default(),
+        }
+    }
+}
+impl VideoEncodeH264ProfileEXT {
+    pub fn builder<'a>() -> VideoEncodeH264ProfileEXTBuilder<'a> {
+        VideoEncodeH264ProfileEXTBuilder {
+            inner: VideoEncodeH264ProfileEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264ProfileEXTBuilder<'a> {
+    inner: VideoEncodeH264ProfileEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsVideoProfileKHR for VideoEncodeH264ProfileEXTBuilder<'_> {}
+unsafe impl ExtendsVideoProfileKHR for VideoEncodeH264ProfileEXT {}
+impl<'a> ::std::ops::Deref for VideoEncodeH264ProfileEXTBuilder<'a> {
+    type Target = VideoEncodeH264ProfileEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264ProfileEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264ProfileEXTBuilder<'a> {
+    pub fn std_profile_idc(mut self, std_profile_idc: StdVideoH264ProfileIdc) -> Self {
+        self.inner.std_profile_idc = std_profile_idc;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264ProfileEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkVideoEncodeH264NaluSliceEXT.html>"]
+pub struct VideoEncodeH264NaluSliceEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub p_slice_header_std: *const StdVideoEncodeH264SliceHeader,
+    pub mb_count: u32,
+    pub ref_final_list0_entry_count: u8,
+    pub p_ref_final_list0_entries: *const VideoEncodeH264DpbSlotInfoEXT,
+    pub ref_final_list1_entry_count: u8,
+    pub p_ref_final_list1_entries: *const VideoEncodeH264DpbSlotInfoEXT,
+    pub preceding_nalu_bytes: u32,
+    pub min_qp: u8,
+    pub max_qp: u8,
+}
+impl ::std::default::Default for VideoEncodeH264NaluSliceEXT {
+    fn default() -> VideoEncodeH264NaluSliceEXT {
+        VideoEncodeH264NaluSliceEXT {
+            s_type: StructureType::VIDEO_ENCODE_H264_NALU_SLICE_EXT,
+            p_next: ::std::ptr::null(),
+            p_slice_header_std: ::std::ptr::null(),
+            mb_count: u32::default(),
+            ref_final_list0_entry_count: u8::default(),
+            p_ref_final_list0_entries: ::std::ptr::null(),
+            ref_final_list1_entry_count: u8::default(),
+            p_ref_final_list1_entries: ::std::ptr::null(),
+            preceding_nalu_bytes: u32::default(),
+            min_qp: u8::default(),
+            max_qp: u8::default(),
+        }
+    }
+}
+impl VideoEncodeH264NaluSliceEXT {
+    pub fn builder<'a>() -> VideoEncodeH264NaluSliceEXTBuilder<'a> {
+        VideoEncodeH264NaluSliceEXTBuilder {
+            inner: VideoEncodeH264NaluSliceEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct VideoEncodeH264NaluSliceEXTBuilder<'a> {
+    inner: VideoEncodeH264NaluSliceEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for VideoEncodeH264NaluSliceEXTBuilder<'a> {
+    type Target = VideoEncodeH264NaluSliceEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for VideoEncodeH264NaluSliceEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> VideoEncodeH264NaluSliceEXTBuilder<'a> {
+    pub fn slice_header_std(mut self, slice_header_std: &'a StdVideoEncodeH264SliceHeader) -> Self {
+        self.inner.p_slice_header_std = slice_header_std;
+        self
+    }
+    pub fn mb_count(mut self, mb_count: u32) -> Self {
+        self.inner.mb_count = mb_count;
+        self
+    }
+    pub fn ref_final_list0_entries(
+        mut self,
+        ref_final_list0_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
+    ) -> Self {
+        self.inner.ref_final_list0_entry_count = ref_final_list0_entries.len() as _;
+        self.inner.p_ref_final_list0_entries = ref_final_list0_entries.as_ptr();
+        self
+    }
+    pub fn ref_final_list1_entries(
+        mut self,
+        ref_final_list1_entries: &'a [VideoEncodeH264DpbSlotInfoEXT],
+    ) -> Self {
+        self.inner.ref_final_list1_entry_count = ref_final_list1_entries.len() as _;
+        self.inner.p_ref_final_list1_entries = ref_final_list1_entries.as_ptr();
+        self
+    }
+    pub fn preceding_nalu_bytes(mut self, preceding_nalu_bytes: u32) -> Self {
+        self.inner.preceding_nalu_bytes = preceding_nalu_bytes;
+        self
+    }
+    pub fn min_qp(mut self, min_qp: u8) -> Self {
+        self.inner.min_qp = min_qp;
+        self
+    }
+    pub fn max_qp(mut self, max_qp: u8) -> Self {
+        self.inner.max_qp = max_qp;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> VideoEncodeH264NaluSliceEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html>"]
+pub struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub inherited_viewport_scissor2_d: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceInheritedViewportScissorFeaturesNV {
+    fn default() -> PhysicalDeviceInheritedViewportScissorFeaturesNV {
+        PhysicalDeviceInheritedViewportScissorFeaturesNV {
+            s_type: StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
+            p_next: ::std::ptr::null_mut(),
+            inherited_viewport_scissor2_d: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceInheritedViewportScissorFeaturesNV {
+    pub fn builder<'a>() -> PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
+        PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder {
+            inner: PhysicalDeviceInheritedViewportScissorFeaturesNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
+    inner: PhysicalDeviceInheritedViewportScissorFeaturesNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
+unsafe impl ExtendsDeviceCreateInfo
+    for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceInheritedViewportScissorFeaturesNV {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
+    type Target = PhysicalDeviceInheritedViewportScissorFeaturesNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceInheritedViewportScissorFeaturesNVBuilder<'a> {
+    pub fn inherited_viewport_scissor2_d(mut self, inherited_viewport_scissor2_d: bool) -> Self {
+        self.inner.inherited_viewport_scissor2_d = inherited_viewport_scissor2_d.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceInheritedViewportScissorFeaturesNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCommandBufferInheritanceViewportScissorInfoNV.html>"]
+pub struct CommandBufferInheritanceViewportScissorInfoNV {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub viewport_scissor2_d: Bool32,
+    pub viewport_depth_count: u32,
+    pub p_viewport_depths: *const Viewport,
+}
+impl ::std::default::Default for CommandBufferInheritanceViewportScissorInfoNV {
+    fn default() -> CommandBufferInheritanceViewportScissorInfoNV {
+        CommandBufferInheritanceViewportScissorInfoNV {
+            s_type: StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
+            p_next: ::std::ptr::null(),
+            viewport_scissor2_d: Bool32::default(),
+            viewport_depth_count: u32::default(),
+            p_viewport_depths: ::std::ptr::null(),
+        }
+    }
+}
+impl CommandBufferInheritanceViewportScissorInfoNV {
+    pub fn builder<'a>() -> CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
+        CommandBufferInheritanceViewportScissorInfoNVBuilder {
+            inner: CommandBufferInheritanceViewportScissorInfoNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
+    inner: CommandBufferInheritanceViewportScissorInfoNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsCommandBufferInheritanceInfo
+    for CommandBufferInheritanceViewportScissorInfoNVBuilder<'_>
+{
+}
+unsafe impl ExtendsCommandBufferInheritanceInfo for CommandBufferInheritanceViewportScissorInfoNV {}
+impl<'a> ::std::ops::Deref for CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
+    type Target = CommandBufferInheritanceViewportScissorInfoNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CommandBufferInheritanceViewportScissorInfoNVBuilder<'a> {
+    pub fn viewport_scissor2_d(mut self, viewport_scissor2_d: bool) -> Self {
+        self.inner.viewport_scissor2_d = viewport_scissor2_d.into();
+        self
+    }
+    pub fn viewport_depth_count(mut self, viewport_depth_count: u32) -> Self {
+        self.inner.viewport_depth_count = viewport_depth_count;
+        self
+    }
+    pub fn viewport_depths(mut self, viewport_depths: &'a Viewport) -> Self {
+        self.inner.p_viewport_depths = viewport_depths;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CommandBufferInheritanceViewportScissorInfoNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html>"]
+pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub ycbcr2plane444_formats: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+    fn default() -> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+        PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            ycbcr2plane444_formats: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
+        PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder {
+            inner: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTBuilder<'a> {
+    pub fn ycbcr2plane444_formats(mut self, ycbcr2plane444_formats: bool) -> Self {
+        self.inner.ycbcr2plane444_formats = ycbcr2plane444_formats.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html>"]
+pub struct PhysicalDeviceProvokingVertexFeaturesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub provoking_vertex_last: Bool32,
+    pub transform_feedback_preserves_provoking_vertex: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceProvokingVertexFeaturesEXT {
+    fn default() -> PhysicalDeviceProvokingVertexFeaturesEXT {
+        PhysicalDeviceProvokingVertexFeaturesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            provoking_vertex_last: Bool32::default(),
+            transform_feedback_preserves_provoking_vertex: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceProvokingVertexFeaturesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
+        PhysicalDeviceProvokingVertexFeaturesEXTBuilder {
+            inner: PhysicalDeviceProvokingVertexFeaturesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
+    inner: PhysicalDeviceProvokingVertexFeaturesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceProvokingVertexFeaturesEXT {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceProvokingVertexFeaturesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
+    type Target = PhysicalDeviceProvokingVertexFeaturesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceProvokingVertexFeaturesEXTBuilder<'a> {
+    pub fn provoking_vertex_last(mut self, provoking_vertex_last: bool) -> Self {
+        self.inner.provoking_vertex_last = provoking_vertex_last.into();
+        self
+    }
+    pub fn transform_feedback_preserves_provoking_vertex(
+        mut self,
+        transform_feedback_preserves_provoking_vertex: bool,
+    ) -> Self {
+        self.inner.transform_feedback_preserves_provoking_vertex =
+            transform_feedback_preserves_provoking_vertex.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceProvokingVertexFeaturesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProvokingVertexPropertiesEXT.html>"]
+pub struct PhysicalDeviceProvokingVertexPropertiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub provoking_vertex_mode_per_pipeline: Bool32,
+    pub transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceProvokingVertexPropertiesEXT {
+    fn default() -> PhysicalDeviceProvokingVertexPropertiesEXT {
+        PhysicalDeviceProvokingVertexPropertiesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            provoking_vertex_mode_per_pipeline: Bool32::default(),
+            transform_feedback_preserves_triangle_fan_provoking_vertex: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceProvokingVertexPropertiesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
+        PhysicalDeviceProvokingVertexPropertiesEXTBuilder {
+            inner: PhysicalDeviceProvokingVertexPropertiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
+    inner: PhysicalDeviceProvokingVertexPropertiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceProperties2
+    for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceProvokingVertexPropertiesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
+    type Target = PhysicalDeviceProvokingVertexPropertiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceProvokingVertexPropertiesEXTBuilder<'a> {
+    pub fn provoking_vertex_mode_per_pipeline(
+        mut self,
+        provoking_vertex_mode_per_pipeline: bool,
+    ) -> Self {
+        self.inner.provoking_vertex_mode_per_pipeline = provoking_vertex_mode_per_pipeline.into();
+        self
+    }
+    pub fn transform_feedback_preserves_triangle_fan_provoking_vertex(
+        mut self,
+        transform_feedback_preserves_triangle_fan_provoking_vertex: bool,
+    ) -> Self {
+        self.inner
+            .transform_feedback_preserves_triangle_fan_provoking_vertex =
+            transform_feedback_preserves_triangle_fan_provoking_vertex.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceProvokingVertexPropertiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.html>"]
+pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub provoking_vertex_mode: ProvokingVertexModeEXT,
+}
+impl ::std::default::Default for PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+    fn default() -> PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+        PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+            s_type: StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
+            p_next: ::std::ptr::null(),
+            provoking_vertex_mode: ProvokingVertexModeEXT::default(),
+        }
+    }
+}
+impl PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+    pub fn builder<'a>() -> PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
+        PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder {
+            inner: PipelineRasterizationProvokingVertexStateCreateInfoEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
+    inner: PipelineRasterizationProvokingVertexStateCreateInfoEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPipelineRasterizationStateCreateInfo
+    for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'_>
+{
+}
+unsafe impl ExtendsPipelineRasterizationStateCreateInfo
+    for PipelineRasterizationProvokingVertexStateCreateInfoEXT
+{
+}
+impl<'a> ::std::ops::Deref for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
+    type Target = PipelineRasterizationProvokingVertexStateCreateInfoEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut
+    for PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a>
+{
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PipelineRasterizationProvokingVertexStateCreateInfoEXTBuilder<'a> {
+    pub fn provoking_vertex_mode(mut self, provoking_vertex_mode: ProvokingVertexModeEXT) -> Self {
+        self.inner.provoking_vertex_mode = provoking_vertex_mode;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PipelineRasterizationProvokingVertexStateCreateInfoEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCuModuleCreateInfoNVX.html>"]
+pub struct CuModuleCreateInfoNVX {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub data_size: usize,
+    pub p_data: *const c_void,
+}
+impl ::std::default::Default for CuModuleCreateInfoNVX {
+    fn default() -> CuModuleCreateInfoNVX {
+        CuModuleCreateInfoNVX {
+            s_type: StructureType::CU_MODULE_CREATE_INFO_NVX,
+            p_next: ::std::ptr::null(),
+            data_size: usize::default(),
+            p_data: ::std::ptr::null(),
+        }
+    }
+}
+impl CuModuleCreateInfoNVX {
+    pub fn builder<'a>() -> CuModuleCreateInfoNVXBuilder<'a> {
+        CuModuleCreateInfoNVXBuilder {
+            inner: CuModuleCreateInfoNVX::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CuModuleCreateInfoNVXBuilder<'a> {
+    inner: CuModuleCreateInfoNVX,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for CuModuleCreateInfoNVXBuilder<'a> {
+    type Target = CuModuleCreateInfoNVX;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CuModuleCreateInfoNVXBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CuModuleCreateInfoNVXBuilder<'a> {
+    pub fn data_size(mut self, data_size: usize) -> Self {
+        self.inner.data_size = data_size;
+        self
+    }
+    pub fn data(mut self, data: *const c_void) -> Self {
+        self.inner.p_data = data;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CuModuleCreateInfoNVX {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCuFunctionCreateInfoNVX.html>"]
+pub struct CuFunctionCreateInfoNVX {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub module: CuModuleNVX,
+    pub p_name: *const c_char,
+}
+impl ::std::default::Default for CuFunctionCreateInfoNVX {
+    fn default() -> CuFunctionCreateInfoNVX {
+        CuFunctionCreateInfoNVX {
+            s_type: StructureType::CU_FUNCTION_CREATE_INFO_NVX,
+            p_next: ::std::ptr::null(),
+            module: CuModuleNVX::default(),
+            p_name: ::std::ptr::null(),
+        }
+    }
+}
+impl CuFunctionCreateInfoNVX {
+    pub fn builder<'a>() -> CuFunctionCreateInfoNVXBuilder<'a> {
+        CuFunctionCreateInfoNVXBuilder {
+            inner: CuFunctionCreateInfoNVX::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CuFunctionCreateInfoNVXBuilder<'a> {
+    inner: CuFunctionCreateInfoNVX,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for CuFunctionCreateInfoNVXBuilder<'a> {
+    type Target = CuFunctionCreateInfoNVX;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CuFunctionCreateInfoNVXBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CuFunctionCreateInfoNVXBuilder<'a> {
+    pub fn module(mut self, module: CuModuleNVX) -> Self {
+        self.inner.module = module;
+        self
+    }
+    pub fn name(mut self, name: &'a ::std::ffi::CStr) -> Self {
+        self.inner.p_name = name.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CuFunctionCreateInfoNVX {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkCuLaunchInfoNVX.html>"]
+pub struct CuLaunchInfoNVX {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub function: CuFunctionNVX,
+    pub grid_dim_x: u32,
+    pub grid_dim_y: u32,
+    pub grid_dim_z: u32,
+    pub block_dim_x: u32,
+    pub block_dim_y: u32,
+    pub block_dim_z: u32,
+    pub shared_mem_bytes: u32,
+    pub param_count: usize,
+    pub p_params: *const *const c_void,
+    pub extra_count: usize,
+    pub p_extras: *const *const c_void,
+}
+impl ::std::default::Default for CuLaunchInfoNVX {
+    fn default() -> CuLaunchInfoNVX {
+        CuLaunchInfoNVX {
+            s_type: StructureType::CU_LAUNCH_INFO_NVX,
+            p_next: ::std::ptr::null(),
+            function: CuFunctionNVX::default(),
+            grid_dim_x: u32::default(),
+            grid_dim_y: u32::default(),
+            grid_dim_z: u32::default(),
+            block_dim_x: u32::default(),
+            block_dim_y: u32::default(),
+            block_dim_z: u32::default(),
+            shared_mem_bytes: u32::default(),
+            param_count: usize::default(),
+            p_params: ::std::ptr::null(),
+            extra_count: usize::default(),
+            p_extras: ::std::ptr::null(),
+        }
+    }
+}
+impl CuLaunchInfoNVX {
+    pub fn builder<'a>() -> CuLaunchInfoNVXBuilder<'a> {
+        CuLaunchInfoNVXBuilder {
+            inner: CuLaunchInfoNVX::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct CuLaunchInfoNVXBuilder<'a> {
+    inner: CuLaunchInfoNVX,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for CuLaunchInfoNVXBuilder<'a> {
+    type Target = CuLaunchInfoNVX;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for CuLaunchInfoNVXBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> CuLaunchInfoNVXBuilder<'a> {
+    pub fn function(mut self, function: CuFunctionNVX) -> Self {
+        self.inner.function = function;
+        self
+    }
+    pub fn grid_dim_x(mut self, grid_dim_x: u32) -> Self {
+        self.inner.grid_dim_x = grid_dim_x;
+        self
+    }
+    pub fn grid_dim_y(mut self, grid_dim_y: u32) -> Self {
+        self.inner.grid_dim_y = grid_dim_y;
+        self
+    }
+    pub fn grid_dim_z(mut self, grid_dim_z: u32) -> Self {
+        self.inner.grid_dim_z = grid_dim_z;
+        self
+    }
+    pub fn block_dim_x(mut self, block_dim_x: u32) -> Self {
+        self.inner.block_dim_x = block_dim_x;
+        self
+    }
+    pub fn block_dim_y(mut self, block_dim_y: u32) -> Self {
+        self.inner.block_dim_y = block_dim_y;
+        self
+    }
+    pub fn block_dim_z(mut self, block_dim_z: u32) -> Self {
+        self.inner.block_dim_z = block_dim_z;
+        self
+    }
+    pub fn shared_mem_bytes(mut self, shared_mem_bytes: u32) -> Self {
+        self.inner.shared_mem_bytes = shared_mem_bytes;
+        self
+    }
+    pub fn params(mut self, params: &'a [*const c_void]) -> Self {
+        self.inner.param_count = params.len() as _;
+        self.inner.p_params = params.as_ptr();
+        self
+    }
+    pub fn extras(mut self, extras: &'a [*const c_void]) -> Self {
+        self.inner.extra_count = extras.len() as _;
+        self.inner.p_extras = extras.as_ptr();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> CuLaunchInfoNVX {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDrmPropertiesEXT.html>"]
+pub struct PhysicalDeviceDrmPropertiesEXT {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub has_primary: Bool32,
+    pub has_render: Bool32,
+    pub primary_major: i64,
+    pub primary_minor: i64,
+    pub render_major: i64,
+    pub render_minor: i64,
+}
+impl ::std::default::Default for PhysicalDeviceDrmPropertiesEXT {
+    fn default() -> PhysicalDeviceDrmPropertiesEXT {
+        PhysicalDeviceDrmPropertiesEXT {
+            s_type: StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
+            p_next: ::std::ptr::null_mut(),
+            has_primary: Bool32::default(),
+            has_render: Bool32::default(),
+            primary_major: i64::default(),
+            primary_minor: i64::default(),
+            render_major: i64::default(),
+            render_minor: i64::default(),
+        }
+    }
+}
+impl PhysicalDeviceDrmPropertiesEXT {
+    pub fn builder<'a>() -> PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
+        PhysicalDeviceDrmPropertiesEXTBuilder {
+            inner: PhysicalDeviceDrmPropertiesEXT::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
+    inner: PhysicalDeviceDrmPropertiesEXT,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDrmPropertiesEXTBuilder<'_> {}
+unsafe impl ExtendsPhysicalDeviceProperties2 for PhysicalDeviceDrmPropertiesEXT {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
+    type Target = PhysicalDeviceDrmPropertiesEXT;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceDrmPropertiesEXTBuilder<'a> {
+    pub fn has_primary(mut self, has_primary: bool) -> Self {
+        self.inner.has_primary = has_primary.into();
+        self
+    }
+    pub fn has_render(mut self, has_render: bool) -> Self {
+        self.inner.has_render = has_render.into();
+        self
+    }
+    pub fn primary_major(mut self, primary_major: i64) -> Self {
+        self.inner.primary_major = primary_major;
+        self
+    }
+    pub fn primary_minor(mut self, primary_minor: i64) -> Self {
+        self.inner.primary_minor = primary_minor;
+        self
+    }
+    pub fn render_major(mut self, render_major: i64) -> Self {
+        self.inner.render_major = render_major;
+        self
+    }
+    pub fn render_minor(mut self, render_minor: i64) -> Self {
+        self.inner.render_minor = render_minor;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceDrmPropertiesEXT {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html>"]
+pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+    pub s_type: StructureType,
+    pub p_next: *mut c_void,
+    pub ray_tracing_motion_blur: Bool32,
+    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32,
+}
+impl ::std::default::Default for PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+    fn default() -> PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+        PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+            s_type: StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
+            p_next: ::std::ptr::null_mut(),
+            ray_tracing_motion_blur: Bool32::default(),
+            ray_tracing_motion_blur_pipeline_trace_rays_indirect: Bool32::default(),
+        }
+    }
+}
+impl PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+    pub fn builder<'a>() -> PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
+        PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder {
+            inner: PhysicalDeviceRayTracingMotionBlurFeaturesNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
+    inner: PhysicalDeviceRayTracingMotionBlurFeaturesNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2
+    for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'_>
+{
+}
+unsafe impl ExtendsPhysicalDeviceFeatures2 for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'_> {}
+unsafe impl ExtendsDeviceCreateInfo for PhysicalDeviceRayTracingMotionBlurFeaturesNV {}
+impl<'a> ::std::ops::Deref for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
+    type Target = PhysicalDeviceRayTracingMotionBlurFeaturesNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> PhysicalDeviceRayTracingMotionBlurFeaturesNVBuilder<'a> {
+    pub fn ray_tracing_motion_blur(mut self, ray_tracing_motion_blur: bool) -> Self {
+        self.inner.ray_tracing_motion_blur = ray_tracing_motion_blur.into();
+        self
+    }
+    pub fn ray_tracing_motion_blur_pipeline_trace_rays_indirect(
+        mut self,
+        ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
+    ) -> Self {
+        self.inner
+            .ray_tracing_motion_blur_pipeline_trace_rays_indirect =
+            ray_tracing_motion_blur_pipeline_trace_rays_indirect.into();
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> PhysicalDeviceRayTracingMotionBlurFeaturesNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureGeometryMotionTrianglesDataNV.html>"]
+pub struct AccelerationStructureGeometryMotionTrianglesDataNV {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub vertex_data: DeviceOrHostAddressConstKHR,
+}
+impl fmt::Debug for AccelerationStructureGeometryMotionTrianglesDataNV {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("AccelerationStructureGeometryMotionTrianglesDataNV")
+            .field("s_type", &self.s_type)
+            .field("p_next", &self.p_next)
+            .field("vertex_data", &"union")
+            .finish()
+    }
+}
+impl ::std::default::Default for AccelerationStructureGeometryMotionTrianglesDataNV {
+    fn default() -> AccelerationStructureGeometryMotionTrianglesDataNV {
+        AccelerationStructureGeometryMotionTrianglesDataNV {
+            s_type: StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
+            p_next: ::std::ptr::null(),
+            vertex_data: DeviceOrHostAddressConstKHR::default(),
+        }
+    }
+}
+impl AccelerationStructureGeometryMotionTrianglesDataNV {
+    pub fn builder<'a>() -> AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
+        AccelerationStructureGeometryMotionTrianglesDataNVBuilder {
+            inner: AccelerationStructureGeometryMotionTrianglesDataNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
+    inner: AccelerationStructureGeometryMotionTrianglesDataNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
+    for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'_>
+{
+}
+unsafe impl ExtendsAccelerationStructureGeometryTrianglesDataKHR
+    for AccelerationStructureGeometryMotionTrianglesDataNV
+{
+}
+impl<'a> ::std::ops::Deref for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
+    type Target = AccelerationStructureGeometryMotionTrianglesDataNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> AccelerationStructureGeometryMotionTrianglesDataNVBuilder<'a> {
+    pub fn vertex_data(mut self, vertex_data: DeviceOrHostAddressConstKHR) -> Self {
+        self.inner.vertex_data = vertex_data;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> AccelerationStructureGeometryMotionTrianglesDataNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureMotionInfoNV.html>"]
+pub struct AccelerationStructureMotionInfoNV {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub max_instances: u32,
+    pub flags: AccelerationStructureMotionInfoFlagsNV,
+}
+impl ::std::default::Default for AccelerationStructureMotionInfoNV {
+    fn default() -> AccelerationStructureMotionInfoNV {
+        AccelerationStructureMotionInfoNV {
+            s_type: StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV,
+            p_next: ::std::ptr::null(),
+            max_instances: u32::default(),
+            flags: AccelerationStructureMotionInfoFlagsNV::default(),
+        }
+    }
+}
+impl AccelerationStructureMotionInfoNV {
+    pub fn builder<'a>() -> AccelerationStructureMotionInfoNVBuilder<'a> {
+        AccelerationStructureMotionInfoNVBuilder {
+            inner: AccelerationStructureMotionInfoNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct AccelerationStructureMotionInfoNVBuilder<'a> {
+    inner: AccelerationStructureMotionInfoNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+unsafe impl ExtendsAccelerationStructureCreateInfoKHR
+    for AccelerationStructureMotionInfoNVBuilder<'_>
+{
+}
+unsafe impl ExtendsAccelerationStructureCreateInfoKHR for AccelerationStructureMotionInfoNV {}
+impl<'a> ::std::ops::Deref for AccelerationStructureMotionInfoNVBuilder<'a> {
+    type Target = AccelerationStructureMotionInfoNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for AccelerationStructureMotionInfoNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> AccelerationStructureMotionInfoNVBuilder<'a> {
+    pub fn max_instances(mut self, max_instances: u32) -> Self {
+        self.inner.max_instances = max_instances;
+        self
+    }
+    pub fn flags(mut self, flags: AccelerationStructureMotionInfoFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> AccelerationStructureMotionInfoNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Default, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSRTDataNV.html>"]
+pub struct SRTDataNV {
+    pub sx: f32,
+    pub a: f32,
+    pub b: f32,
+    pub pvx: f32,
+    pub sy: f32,
+    pub c: f32,
+    pub pvy: f32,
+    pub sz: f32,
+    pub pvz: f32,
+    pub qx: f32,
+    pub qy: f32,
+    pub qz: f32,
+    pub qw: f32,
+    pub tx: f32,
+    pub ty: f32,
+    pub tz: f32,
+}
+impl SRTDataNV {
+    pub fn builder<'a>() -> SRTDataNVBuilder<'a> {
+        SRTDataNVBuilder {
+            inner: SRTDataNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct SRTDataNVBuilder<'a> {
+    inner: SRTDataNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for SRTDataNVBuilder<'a> {
+    type Target = SRTDataNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for SRTDataNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> SRTDataNVBuilder<'a> {
+    pub fn sx(mut self, sx: f32) -> Self {
+        self.inner.sx = sx;
+        self
+    }
+    pub fn a(mut self, a: f32) -> Self {
+        self.inner.a = a;
+        self
+    }
+    pub fn b(mut self, b: f32) -> Self {
+        self.inner.b = b;
+        self
+    }
+    pub fn pvx(mut self, pvx: f32) -> Self {
+        self.inner.pvx = pvx;
+        self
+    }
+    pub fn sy(mut self, sy: f32) -> Self {
+        self.inner.sy = sy;
+        self
+    }
+    pub fn c(mut self, c: f32) -> Self {
+        self.inner.c = c;
+        self
+    }
+    pub fn pvy(mut self, pvy: f32) -> Self {
+        self.inner.pvy = pvy;
+        self
+    }
+    pub fn sz(mut self, sz: f32) -> Self {
+        self.inner.sz = sz;
+        self
+    }
+    pub fn pvz(mut self, pvz: f32) -> Self {
+        self.inner.pvz = pvz;
+        self
+    }
+    pub fn qx(mut self, qx: f32) -> Self {
+        self.inner.qx = qx;
+        self
+    }
+    pub fn qy(mut self, qy: f32) -> Self {
+        self.inner.qy = qy;
+        self
+    }
+    pub fn qz(mut self, qz: f32) -> Self {
+        self.inner.qz = qz;
+        self
+    }
+    pub fn qw(mut self, qw: f32) -> Self {
+        self.inner.qw = qw;
+        self
+    }
+    pub fn tx(mut self, tx: f32) -> Self {
+        self.inner.tx = tx;
+        self
+    }
+    pub fn ty(mut self, ty: f32) -> Self {
+        self.inner.ty = ty;
+        self
+    }
+    pub fn tz(mut self, tz: f32) -> Self {
+        self.inner.tz = tz;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> SRTDataNV {
+        self.inner
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureSRTMotionInstanceNV.html>"]
+pub struct AccelerationStructureSRTMotionInstanceNV {
+    pub transform_t0: SRTDataNV,
+    pub transform_t1: SRTDataNV,
+    pub instance_custom_index_and_mask: u32,
+    pub instance_shader_binding_table_record_offset_and_flags: u32,
+    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/AccelerationStructureMatrixMotionInstanceNV.html>"]
+pub struct AccelerationStructureMatrixMotionInstanceNV {
+    pub transform_t0: TransformMatrixKHR,
+    pub transform_t1: TransformMatrixKHR,
+    pub instance_custom_index_and_mask: u32,
+    pub instance_shader_binding_table_record_offset_and_flags: u32,
+    pub acceleration_structure_reference: AccelerationStructureReferenceKHR,
+}
+#[repr(C)]
+#[derive(Copy, Clone)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureMotionInstanceDataNV.html>"]
+pub union AccelerationStructureMotionInstanceDataNV {
+    pub static_instance: AccelerationStructureInstanceKHR,
+    pub matrix_motion_instance: AccelerationStructureMatrixMotionInstanceNV,
+    pub srt_motion_instance: AccelerationStructureSRTMotionInstanceNV,
+}
+impl ::std::default::Default for AccelerationStructureMotionInstanceDataNV {
+    fn default() -> AccelerationStructureMotionInstanceDataNV {
+        unsafe { ::std::mem::zeroed() }
+    }
+}
+#[repr(C)]
+#[derive(Copy, Clone, Default)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkAccelerationStructureMotionInstanceNV.html>"]
+pub struct AccelerationStructureMotionInstanceNV {
+    pub ty: AccelerationStructureMotionInstanceTypeNV,
+    pub flags: AccelerationStructureMotionInstanceFlagsNV,
+    pub data: AccelerationStructureMotionInstanceDataNV,
+}
+impl fmt::Debug for AccelerationStructureMotionInstanceNV {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("AccelerationStructureMotionInstanceNV")
+            .field("ty", &self.ty)
+            .field("flags", &self.flags)
+            .field("data", &"union")
+            .finish()
+    }
+}
+impl AccelerationStructureMotionInstanceNV {
+    pub fn builder<'a>() -> AccelerationStructureMotionInstanceNVBuilder<'a> {
+        AccelerationStructureMotionInstanceNVBuilder {
+            inner: AccelerationStructureMotionInstanceNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct AccelerationStructureMotionInstanceNVBuilder<'a> {
+    inner: AccelerationStructureMotionInstanceNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for AccelerationStructureMotionInstanceNVBuilder<'a> {
+    type Target = AccelerationStructureMotionInstanceNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for AccelerationStructureMotionInstanceNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> AccelerationStructureMotionInstanceNVBuilder<'a> {
+    pub fn ty(mut self, ty: AccelerationStructureMotionInstanceTypeNV) -> Self {
+        self.inner.ty = ty;
+        self
+    }
+    pub fn flags(mut self, flags: AccelerationStructureMotionInstanceFlagsNV) -> Self {
+        self.inner.flags = flags;
+        self
+    }
+    pub fn data(mut self, data: AccelerationStructureMotionInstanceDataNV) -> Self {
+        self.inner.data = data;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> AccelerationStructureMotionInstanceNV {
+        self.inner
+    }
+}
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkRemoteAddressNV.html>"]
+pub type RemoteAddressNV = c_void;
+#[repr(C)]
+#[derive(Copy, Clone, Debug)]
+#[doc = "<https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkMemoryGetRemoteAddressInfoNV.html>"]
+pub struct MemoryGetRemoteAddressInfoNV {
+    pub s_type: StructureType,
+    pub p_next: *const c_void,
+    pub memory: DeviceMemory,
+    pub handle_type: ExternalMemoryHandleTypeFlags,
+}
+impl ::std::default::Default for MemoryGetRemoteAddressInfoNV {
+    fn default() -> MemoryGetRemoteAddressInfoNV {
+        MemoryGetRemoteAddressInfoNV {
+            s_type: StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
+            p_next: ::std::ptr::null(),
+            memory: DeviceMemory::default(),
+            handle_type: ExternalMemoryHandleTypeFlags::default(),
+        }
+    }
+}
+impl MemoryGetRemoteAddressInfoNV {
+    pub fn builder<'a>() -> MemoryGetRemoteAddressInfoNVBuilder<'a> {
+        MemoryGetRemoteAddressInfoNVBuilder {
+            inner: MemoryGetRemoteAddressInfoNV::default(),
+            marker: ::std::marker::PhantomData,
+        }
+    }
+}
+#[repr(transparent)]
+pub struct MemoryGetRemoteAddressInfoNVBuilder<'a> {
+    inner: MemoryGetRemoteAddressInfoNV,
+    marker: ::std::marker::PhantomData<&'a ()>,
+}
+impl<'a> ::std::ops::Deref for MemoryGetRemoteAddressInfoNVBuilder<'a> {
+    type Target = MemoryGetRemoteAddressInfoNV;
+    fn deref(&self) -> &Self::Target {
+        &self.inner
+    }
+}
+impl<'a> ::std::ops::DerefMut for MemoryGetRemoteAddressInfoNVBuilder<'a> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.inner
+    }
+}
+impl<'a> MemoryGetRemoteAddressInfoNVBuilder<'a> {
+    pub fn memory(mut self, memory: DeviceMemory) -> Self {
+        self.inner.memory = memory;
+        self
+    }
+    pub fn handle_type(mut self, handle_type: ExternalMemoryHandleTypeFlags) -> Self {
+        self.inner.handle_type = handle_type;
+        self
+    }
+    #[doc = r" Calling build will **discard** all the lifetime information. Only call this if"]
+    #[doc = r" necessary! Builders implement `Deref` targeting their corresponding Vulkan struct,"]
+    #[doc = r" so references to builders can be passed directly to Vulkan functions."]
+    pub fn build(self) -> MemoryGetRemoteAddressInfoNV {
+        self.inner
+    }
+}