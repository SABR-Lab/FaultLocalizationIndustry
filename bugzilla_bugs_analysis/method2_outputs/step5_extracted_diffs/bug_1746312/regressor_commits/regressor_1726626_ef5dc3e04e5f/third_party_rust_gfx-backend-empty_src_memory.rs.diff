# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/gfx-backend-empty/src/memory.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/gfx-backend-empty/src/memory.rs b/third_party/rust/gfx-backend-empty/src/memory.rs
deleted file mode 100644
--- a/third_party/rust/gfx-backend-empty/src/memory.rs
+++ /dev/null
@@ -1,58 +0,0 @@
-use hal::{
-    device::{AllocationError, MapError, OutOfMemory},
-    memory::Segment,
-    MemoryTypeId,
-};
-use std::cell::UnsafeCell;
-use std::convert::TryInto;
-
-/// A memory allocation.
-#[derive(Debug)]
-pub struct Memory {
-    /// The type of memory this block was allocated from.
-    memory_type: MemoryTypeId,
-    /// Size of the allocated memory block.
-    size: u64,
-    /// The backing memory allocation.
-    data: UnsafeCell<Box<[u8]>>,
-}
-
-impl Memory {
-    pub fn allocate(memory_type: MemoryTypeId, size: u64) -> Result<Self, AllocationError> {
-        assert_eq!(memory_type.0, 0, "We only support one memory type");
-
-        // Allocate a buffer in RAM
-        let data = {
-            let size = size
-                .try_into()
-                // If we're on 32-bit and the given size is greater than 2^32,
-                // we certainly can't allocate it.
-                .map_err(|_| AllocationError::OutOfMemory(OutOfMemory::Host))?;
-
-            vec![0u8; size].into_boxed_slice()
-        };
-
-        let memory = Memory {
-            memory_type,
-            size,
-            data: UnsafeCell::new(data),
-        };
-        Ok(memory)
-    }
-
-    pub fn map(&self, segment: Segment) -> Result<*mut u8, MapError> {
-        if segment.offset >= self.size {
-            return Err(MapError::OutOfBounds);
-        }
-        if let Some(size) = segment.size {
-            if segment.offset + size > self.size {
-                return Err(MapError::OutOfBounds);
-            }
-        }
-
-        let data = unsafe { &mut *self.data.get() };
-        Ok(data.as_mut_ptr())
-    }
-}
-
-unsafe impl Sync for Memory {}