# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/dot/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/dot/mod.rs b/third_party/rust/naga/src/back/dot/mod.rs
--- a/third_party/rust/naga/src/back/dot/mod.rs
+++ b/third_party/rust/naga/src/back/dot/mod.rs
@@ -4,17 +4,20 @@
  * of IR inspection and debugging.
 !*/
 
 use crate::{
     arena::Handle,
     valid::{FunctionInfo, ModuleInfo},
 };
 
-use std::fmt::{Error as FmtError, Write as _};
+use std::{
+    borrow::Cow,
+    fmt::{Error as FmtError, Write as _},
+};
 
 #[derive(Default)]
 struct StatementGraph {
     nodes: Vec<&'static str>,
     flow: Vec<(usize, usize, &'static str)>,
     dependencies: Vec<(usize, Handle<crate::Expression>, &'static str)>,
     emits: Vec<(usize, Handle<crate::Expression>)>,
     calls: Vec<(usize, Handle<crate::Function>)>,
@@ -115,31 +118,45 @@ impl StatementGraph {
                         self.dependencies.push((id, arg, "arg"));
                     }
                     if let Some(expr) = result {
                         self.emits.push((id, expr));
                     }
                     self.calls.push((id, function));
                     "Call"
                 }
+                S::Atomic {
+                    pointer,
+                    ref fun,
+                    value,
+                    result,
+                } => {
+                    self.emits.push((id, result));
+                    self.dependencies.push((id, pointer, "pointer"));
+                    self.dependencies.push((id, value, "value"));
+                    if let crate::AtomicFunction::Exchange { compare: Some(cmp) } = *fun {
+                        self.dependencies.push((id, cmp, "cmp"));
+                    }
+                    "Atomic"
+                }
             };
         }
         root
     }
 }
 
 #[allow(clippy::manual_unwrap_or)]
 fn name(option: &Option<String>) -> &str {
     match *option {
         Some(ref name) => name,
         None => "",
     }
 }
 
-/// set39 color scheme from https://graphviz.org/doc/info/colors.html
+/// set39 color scheme from <https://graphviz.org/doc/info/colors.html>
 const COLORS: &[&str] = &[
     "white", // pattern starts at 1
     "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5",
     "#d9d9d9",
 ];
 
 fn write_fun(
     output: &mut String,
@@ -262,19 +279,19 @@ fn write_fun(
             }
             E::ImageQuery { image, query } => {
                 edges.insert("image", image);
                 let args = match query {
                     crate::ImageQuery::Size { level } => {
                         if let Some(expr) = level {
                             edges.insert("level", expr);
                         }
-                        std::borrow::Cow::from("ImageSize")
+                        Cow::from("ImageSize")
                     }
-                    _ => format!("{:?}", query).into(),
+                    _ => Cow::Owned(format!("{:?}", query)),
                 };
                 (args, 7)
             }
             E::Unary { op, expr } => {
                 edges.insert("expr", expr);
                 (format!("{:?}", op).into(), 6)
             }
             E::Binary { op, left, right } => {
@@ -322,17 +339,18 @@ fn write_fun(
             } => {
                 edges.insert("", expr);
                 let string = match convert {
                     Some(width) => format!("Convert<{:?},{}>", kind, width),
                     None => format!("Bitcast<{:?}>", kind),
                 };
                 (string.into(), 3)
             }
-            E::Call(_function) => ("Call".into(), 4),
+            E::CallResult(_function) => ("CallResult".into(), 4),
+            E::AtomicResult { .. } => ("AtomicResult".into(), 4),
             E::ArrayLength(expr) => {
                 edges.insert("", expr);
                 ("ArrayLength".into(), 7)
             }
         };
 
         // give uniform expressions an outline
         let color_attr = match info {