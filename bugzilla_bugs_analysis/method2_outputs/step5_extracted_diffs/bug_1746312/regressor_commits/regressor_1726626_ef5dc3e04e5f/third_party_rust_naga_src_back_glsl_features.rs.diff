# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/glsl/features.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/glsl/features.rs b/third_party/rust/naga/src/back/glsl/features.rs
--- a/third_party/rust/naga/src/back/glsl/features.rs
+++ b/third_party/rust/naga/src/back/glsl/features.rs
@@ -27,16 +27,18 @@ bitflags::bitflags! {
         /// Interpolation and auxiliary qualifiers. Perspective, Flat, and
         /// Centroid are available in all GLSL versions we support.
         const NOPERSPECTIVE_QUALIFIER = 1 << 11;
         const SAMPLE_QUALIFIER = 1 << 12;
         const CLIP_DISTANCE = 1 << 13;
         const CULL_DISTANCE = 1 << 14;
         // Sample ID
         const SAMPLE_VARIABLES = 1 << 15;
+        /// Arrays with a dynamic length
+        const DYNAMIC_ARRAY_SIZE = 1 << 16;
     }
 }
 
 /// Helper structure used to store the required [`Features`](Features) needed to output a
 /// [`Module`](crate::Module)
 ///
 /// Provides helper methods to check for availability and writing required extensions
 pub struct FeaturesManager(Features);
@@ -93,16 +95,17 @@ impl FeaturesManager {
         // so use 0 that way the check will always be false and can be optimized away
         check_feature!(TEXTURE_1D, 0);
         check_feature!(NOPERSPECTIVE_QUALIFIER, 130);
         check_feature!(SAMPLE_QUALIFIER, 400, 320);
         // gl_ClipDistance is supported by core versions > 1.3 and aren't supported by an es versions without extensions
         check_feature!(CLIP_DISTANCE, 130, 300);
         check_feature!(CULL_DISTANCE, 450, 300);
         check_feature!(SAMPLE_VARIABLES, 400, 300);
+        check_feature!(DYNAMIC_ARRAY_SIZE, 430, 310);
 
         // Return an error if there are missing features
         if missing.is_empty() {
             Ok(())
         } else {
             Err(Error::MissingFeatures(missing))
         }
     }
@@ -197,66 +200,110 @@ impl FeaturesManager {
 
 impl<'a, W> Writer<'a, W> {
     /// Helper method that searches the module for all the needed [`Features`](Features)
     ///
     /// # Errors
     /// If the version doesn't support any of the needed [`Features`](Features) a
     /// [`Error::MissingFeatures`](super::Error::MissingFeatures) will be returned
     pub(super) fn collect_required_features(&mut self) -> BackendResult {
+        let ep_info = self.info.get_entry_point(self.entry_point_idx as usize);
+
         if let Some(depth_test) = self.entry_point.early_depth_test {
-            self.features.request(Features::IMAGE_LOAD_STORE);
+            // If IMAGE_LOAD_STORE is supported for this version of GLSL
+            if self.options.version.supports_early_depth_test() {
+                self.features.request(Features::IMAGE_LOAD_STORE);
+            }
 
             if depth_test.conservative.is_some() {
                 self.features.request(Features::CONSERVATIVE_DEPTH);
             }
         }
 
         for arg in self.entry_point.function.arguments.iter() {
             self.varying_required_features(arg.binding.as_ref(), arg.ty);
         }
         if let Some(ref result) = self.entry_point.function.result {
             self.varying_required_features(result.binding.as_ref(), result.ty);
         }
 
-        if let ShaderStage::Compute = self.options.shader_stage {
+        if let ShaderStage::Compute = self.entry_point.stage {
             self.features.request(Features::COMPUTE_SHADER)
         }
 
-        for (_, ty) in self.module.types.iter() {
+        for (ty_handle, ty) in self.module.types.iter() {
             match ty.inner {
                 TypeInner::Scalar { kind, width } => self.scalar_required_features(kind, width),
                 TypeInner::Vector { kind, width, .. } => self.scalar_required_features(kind, width),
                 TypeInner::Matrix { width, .. } => {
                     self.scalar_required_features(ScalarKind::Float, width)
                 }
-                TypeInner::Array { base, .. } => {
+                TypeInner::Array { base, size, .. } => {
                     if let TypeInner::Array { .. } = self.module.types[base].inner {
                         self.features.request(Features::ARRAY_OF_ARRAYS)
                     }
+
+                    // If the array is dynamically sized
+                    if size == crate::ArraySize::Dynamic {
+                        let mut is_used = false;
+
+                        // Check if this type is used in a global that is needed by the current entrypoint
+                        for (global_handle, global) in self.module.global_variables.iter() {
+                            // Skip unused globals
+                            if ep_info[global_handle].is_empty() {
+                                continue;
+                            }
+
+                            // If this array is the type of a global, then this array is used
+                            if global.ty == ty_handle {
+                                is_used = true;
+                                break;
+                            }
+
+                            // If the type of this global is a struct
+                            if let crate::TypeInner::Struct { ref members, .. } =
+                                self.module.types[global.ty].inner
+                            {
+                                // Check the last element of the struct to see if it's type uses
+                                // this array
+                                if let Some(last) = members.last() {
+                                    if last.ty == ty_handle {
+                                        is_used = true;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+
+                        // If this dynamically size array is used, we need dynamic array size support
+                        if is_used {
+                            self.features.request(Features::DYNAMIC_ARRAY_SIZE);
+                        }
+                    }
                 }
                 TypeInner::Image {
                     dim,
                     arrayed,
                     class,
                 } => {
                     if arrayed && dim == ImageDimension::Cube {
                         self.features.request(Features::CUBE_TEXTURES_ARRAY)
                     } else if dim == ImageDimension::D1 {
                         self.features.request(Features::TEXTURE_1D)
                     }
 
                     match class {
-                        ImageClass::Sampled { multi: true, .. } => {
+                        ImageClass::Sampled { multi: true, .. }
+                        | ImageClass::Depth { multi: true } => {
                             self.features.request(Features::MULTISAMPLED_TEXTURES);
                             if arrayed {
                                 self.features.request(Features::MULTISAMPLED_TEXTURE_ARRAYS);
                             }
                         }
-                        ImageClass::Storage(format) => match format {
+                        ImageClass::Storage { format, .. } => match format {
                             StorageFormat::R8Unorm
                             | StorageFormat::R8Snorm
                             | StorageFormat::R8Uint
                             | StorageFormat::R8Sint
                             | StorageFormat::R16Uint
                             | StorageFormat::R16Sint
                             | StorageFormat::R16Float
                             | StorageFormat::Rg8Unorm
@@ -270,27 +317,31 @@ impl<'a, W> Writer<'a, W> {
                             | StorageFormat::Rg11b10Float
                             | StorageFormat::Rg32Uint
                             | StorageFormat::Rg32Sint
                             | StorageFormat::Rg32Float => {
                                 self.features.request(Features::FULL_IMAGE_FORMATS)
                             }
                             _ => {}
                         },
-                        _ => {}
+                        ImageClass::Sampled { multi: false, .. }
+                        | ImageClass::Depth { multi: false } => {}
                     }
                 }
                 _ => {}
             }
         }
 
-        for (_, global) in self.module.global_variables.iter() {
+        for (handle, global) in self.module.global_variables.iter() {
+            if ep_info[handle].is_empty() {
+                continue;
+            }
             match global.class {
                 StorageClass::WorkGroup => self.features.request(Features::COMPUTE_SHADER),
-                StorageClass::Storage => self.features.request(Features::BUFFER_STORAGE),
+                StorageClass::Storage { .. } => self.features.request(Features::BUFFER_STORAGE),
                 StorageClass::PushConstant => return Err(Error::PushConstantNotSupported),
                 _ => {}
             }
         }
 
         self.features.check_availability(self.options.version)
     }
 