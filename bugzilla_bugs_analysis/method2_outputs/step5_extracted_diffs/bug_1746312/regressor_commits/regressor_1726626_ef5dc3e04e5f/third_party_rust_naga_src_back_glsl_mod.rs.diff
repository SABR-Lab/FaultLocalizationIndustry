# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/glsl/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/glsl/mod.rs b/third_party/rust/naga/src/back/glsl/mod.rs
--- a/third_party/rust/naga/src/back/glsl/mod.rs
+++ b/third_party/rust/naga/src/back/glsl/mod.rs
@@ -39,23 +39,19 @@
 // The only thing that glsl removes that makes a difference are pointers.
 //
 // Additions that are relevant for the backend are the discard keyword, the introduction of
 // vector, matrices, samplers, image types and functions that provide common shader operations
 
 pub use features::Features;
 
 use crate::{
-    proc::{EntryPointIndex, NameKey, Namer, TypeResolution},
-    valid::{FunctionInfo, ModuleInfo},
-    Arena, ArraySize, BinaryOperator, Binding, BuiltIn, Bytes, ConservativeDepth, Constant,
-    ConstantInner, DerivativeAxis, Expression, FastHashMap, Function, GlobalVariable, Handle,
-    ImageClass, Interpolation, LocalVariable, Module, RelationalFunction, Sampling, ScalarKind,
-    ScalarValue, ShaderStage, Statement, StorageAccess, StorageClass, StorageFormat, StructMember,
-    Type, TypeInner, UnaryOperator,
+    back,
+    proc::{self, NameKey},
+    valid, Handle, ShaderStage, TypeInner,
 };
 use features::FeaturesManager;
 use std::{
     cmp::Ordering,
     fmt,
     fmt::{Error as FmtError, Write},
 };
 use thiserror::Error;
@@ -64,22 +60,38 @@ use thiserror::Error;
 mod features;
 /// Contains a constant with a slice of all the reserved keywords RESERVED_KEYWORDS
 mod keywords;
 
 /// List of supported core glsl versions
 pub const SUPPORTED_CORE_VERSIONS: &[u16] = &[330, 400, 410, 420, 430, 440, 450];
 /// List of supported es glsl versions
 pub const SUPPORTED_ES_VERSIONS: &[u16] = &[300, 310, 320];
-const INDENT: &str = "    ";
+
+pub type BindingMap = std::collections::BTreeMap<crate::ResourceBinding, u8>;
 
-const COMPONENTS: &[char] = &['x', 'y', 'z', 'w'];
+impl crate::AtomicFunction {
+    fn to_glsl(self) -> &'static str {
+        match self {
+            Self::Add => "Add",
+            Self::And => "And",
+            Self::InclusiveOr => "Or",
+            Self::ExclusiveOr => "Xor",
+            Self::Min => "Min",
+            Self::Max => "Max",
+            Self::Exchange { compare: None } => "Exchange",
+            Self::Exchange { compare: Some(_) } => "", //TODO
+        }
+    }
+}
 
 /// glsl version
 #[derive(Debug, Copy, Clone, PartialEq)]
+#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub enum Version {
     /// `core` glsl
     Desktop(u16),
     /// `es` glsl
     Embedded(u16),
 }
 
 impl Version {
@@ -99,19 +111,28 @@ impl Version {
     /// so this also checks for version validity
     fn is_supported(&self) -> bool {
         match *self {
             Version::Desktop(v) => SUPPORTED_CORE_VERSIONS.contains(&v),
             Version::Embedded(v) => SUPPORTED_ES_VERSIONS.contains(&v),
         }
     }
 
-    /// Checks if the version supports explicit `layout(location=)` qualifiers.
+    /// Checks if the version supports all of the explicit layouts:
+    /// - `location=` qualifiers for bindings
+    /// - `binding=` qualifiers for resources
+    ///
+    /// Note: `location=` for vertex inputs and fragment outputs is supported
+    /// unconditionally for GLES 300.
     fn supports_explicit_locations(&self) -> bool {
-        *self >= Version::Embedded(300) || *self >= Version::Desktop(410)
+        *self >= Version::Embedded(310) || *self >= Version::Desktop(410)
+    }
+
+    fn supports_early_depth_test(&self) -> bool {
+        *self >= Version::Desktop(130) || *self >= Version::Embedded(310)
     }
 }
 
 impl PartialOrd for Version {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
         match (*self, *other) {
             (Version::Desktop(x), Version::Desktop(y)) => Some(x.cmp(&y)),
             (Version::Embedded(x), Version::Embedded(y)) => Some(x.cmp(&y)),
@@ -124,104 +145,86 @@ impl fmt::Display for Version {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match *self {
             Version::Desktop(v) => write!(f, "{} core", v),
             Version::Embedded(v) => write!(f, "{} es", v),
         }
     }
 }
 
+bitflags::bitflags! {
+    #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+    #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
+    pub struct WriterFlags: u32 {
+        /// Flip output Y and extend Z from (0,1) to (-1,1).
+        const ADJUST_COORDINATE_SPACE = 0x1;
+        /// Supports GL_EXT_texture_shadow_lod on the host, which provides
+        /// additional functions on shadows and arrays of shadows.
+        const TEXTURE_SHADOW_LOD = 0x2;
+    }
+}
+
 /// Structure that contains the configuration used in the [`Writer`](Writer)
 #[derive(Debug, Clone)]
+#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct Options {
     /// The glsl version to be used
     pub version: Version,
+    /// Configuration flags for the writer.
+    pub writer_flags: WriterFlags,
+    /// Map of resources association to binding locations.
+    pub binding_map: BindingMap,
+}
+
+impl Default for Options {
+    fn default() -> Self {
+        Options {
+            version: Version::Embedded(310),
+            writer_flags: WriterFlags::ADJUST_COORDINATE_SPACE,
+            binding_map: BindingMap::default(),
+        }
+    }
+}
+
+// A subset of options that are meant to be changed per pipeline.
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
+pub struct PipelineOptions {
     /// The stage of the entry point
     pub shader_stage: ShaderStage,
     /// The name of the entry point
     ///
     /// If no entry point that matches is found a error will be thrown while creating a new instance
     /// of [`Writer`](struct.Writer.html)
     pub entry_point: String,
 }
 
-impl Default for Options {
-    fn default() -> Self {
-        Options {
-            version: Version::Embedded(320),
-            shader_stage: ShaderStage::Compute,
-            entry_point: "main".to_string(),
-        }
-    }
-}
-
 /// Structure that contains a reflection info
 pub struct ReflectionInfo {
-    pub texture_mapping: FastHashMap<String, TextureMapping>,
-    pub uniforms: FastHashMap<Handle<GlobalVariable>, String>,
+    pub texture_mapping: crate::FastHashMap<String, TextureMapping>,
+    pub uniforms: crate::FastHashMap<Handle<crate::GlobalVariable>, String>,
 }
 
 /// Structure that connects a texture to a sampler or not
 ///
 /// glsl pre vulkan has no concept of separate textures and samplers instead everything is a
 /// `gsamplerN` where `g` is the scalar type and `N` is the dimension, but naga uses separate textures
 /// and samplers in the IR so the backend produces a [`HashMap`](crate::FastHashMap) with the texture name
 /// as a key and a [`TextureMapping`](TextureMapping) as a value this way the user knows where to bind.
 ///
 /// [`Storage`](crate::ImageClass::Storage) images produce `gimageN` and don't have an associated sampler
 /// so the [`sampler`](Self::sampler) field will be [`None`](std::option::Option::None)
 #[derive(Debug, Clone)]
 pub struct TextureMapping {
     /// Handle to the image global variable
-    pub texture: Handle<GlobalVariable>,
+    pub texture: Handle<crate::GlobalVariable>,
     /// Handle to the associated sampler global variable if it exists
-    pub sampler: Option<Handle<GlobalVariable>>,
-}
-
-/// Stores the current function type (either a regular function or an entry point)
-///
-/// Also stores data needed to identify it (handle for a regular function or index for an entry point)
-enum FunctionType {
-    /// A regular function and it's handle
-    Function(Handle<Function>),
-    /// A entry point and it's index
-    EntryPoint(EntryPointIndex),
-}
-
-/// Helper structure that stores data needed when writing the function
-struct FunctionCtx<'a> {
-    /// The current function being written
-    func: FunctionType,
-    /// Analysis about the function
-    info: &'a FunctionInfo,
-    /// The expression arena of the current function being written
-    expressions: &'a Arena<Expression>,
-    /// Map of expressions that have associated variable names
-    named_expressions: &'a crate::NamedExpressions,
-}
-
-impl<'a> FunctionCtx<'_> {
-    /// Helper method that generates a [`NameKey`](crate::proc::NameKey) for a local in the current function
-    fn name_key(&self, local: Handle<LocalVariable>) -> NameKey {
-        match self.func {
-            FunctionType::Function(handle) => NameKey::FunctionLocal(handle, local),
-            FunctionType::EntryPoint(idx) => NameKey::EntryPointLocal(idx, local),
-        }
-    }
-
-    /// Helper method that generates a [`NameKey`](crate::proc::NameKey) for a function argument.
-    ///
-    /// # Panics
-    /// - If the function arguments are less or equal to `arg`
-    fn argument_key(&self, arg: u32) -> NameKey {
-        match self.func {
-            FunctionType::Function(handle) => NameKey::FunctionArgument(handle, arg),
-            FunctionType::EntryPoint(ep_index) => NameKey::EntryPointArgument(ep_index, arg),
-        }
-    }
+    pub sampler: Option<Handle<crate::GlobalVariable>>,
 }
 
 /// Helper structure that generates a number
 #[derive(Default)]
 struct IdGenerator(u32);
 
 impl IdGenerator {
     /// Generates a number that's guaranteed to be unique for this `IdGenerator`
@@ -236,44 +239,44 @@ impl IdGenerator {
 /// Helper wrapper used to get a name for a varying
 ///
 /// Varying have different naming schemes depending on their binding:
 /// - Varyings with builtin bindings get the from [`glsl_built_in`](glsl_built_in).
 /// - Varyings with location bindings are named `_S_location_X` where `S` is a
 ///   prefix identifying which pipeline stage the varying connects, and `X` is
 ///   the location.
 struct VaryingName<'a> {
-    binding: &'a Binding,
+    binding: &'a crate::Binding,
     stage: ShaderStage,
     output: bool,
 }
 impl fmt::Display for VaryingName<'_> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match *self.binding {
-            Binding::Location { location, .. } => {
+            crate::Binding::Location { location, .. } => {
                 let prefix = match (self.stage, self.output) {
                     (ShaderStage::Compute, _) => unreachable!(),
                     // pipeline to vertex
                     (ShaderStage::Vertex, false) => "p2vs",
                     // vertex to fragment
                     (ShaderStage::Vertex, true) | (ShaderStage::Fragment, false) => "vs2fs",
                     // fragment to pipeline
                     (ShaderStage::Fragment, true) => "fs2p",
                 };
                 write!(f, "_{}_location{}", prefix, location,)
             }
-            Binding::BuiltIn(built_in) => {
+            crate::Binding::BuiltIn(built_in) => {
                 write!(f, "{}", glsl_built_in(built_in, self.output))
             }
         }
     }
 }
 
 /// Shorthand result used internally by the backend
-type BackendResult = Result<(), Error>;
+type BackendResult<T = ()> = Result<T, Error>;
 
 /// A glsl compilation error.
 #[derive(Debug, Error)]
 pub enum Error {
     /// A error occurred while writing to the output
     #[error("Format error")]
     FmtError(#[from] FmtError),
     /// The specified [`Version`](Version) doesn't have all required [`Features`](super)
@@ -291,96 +294,102 @@ pub enum Error {
     /// The entry point couldn't be found
     #[error("The requested entry point couldn't be found")]
     EntryPointNotFound,
     /// A call was made to an unsupported external
     #[error("A call was made to an unsupported external: {0}")]
     UnsupportedExternal(String),
     /// A scalar with an unsupported width was requested
     #[error("A scalar with an unsupported width was requested: {0:?} {1:?}")]
-    UnsupportedScalar(ScalarKind, Bytes),
+    UnsupportedScalar(crate::ScalarKind, crate::Bytes),
     /// A image was used with multiple samplers, this isn't supported
     #[error("A image was used with multiple samplers")]
     ImageMultipleSamplers,
     #[error("{0}")]
     Custom(String),
 }
 
 /// Main structure of the glsl backend responsible for all code generation
 pub struct Writer<'a, W> {
     // Inputs
     /// The module being written
-    module: &'a Module,
+    module: &'a crate::Module,
     /// The module analysis.
-    info: &'a ModuleInfo,
+    info: &'a valid::ModuleInfo,
     /// The output writer
     out: W,
     /// User defined configuration to be used
     options: &'a Options,
 
     // Internal State
     /// Features manager used to store all the needed features and write them
     features: FeaturesManager,
-    namer: Namer,
+    namer: proc::Namer,
     /// A map with all the names needed for writing the module
     /// (generated by a [`Namer`](crate::proc::Namer))
-    names: FastHashMap<NameKey, String>,
+    names: crate::FastHashMap<NameKey, String>,
     /// A map with all the names needed for reflections
-    reflection_names: FastHashMap<Handle<Type>, String>,
+    reflection_names_uniforms: crate::FastHashMap<Handle<crate::Type>, String>,
+    /// A map with the names of global variables needed for reflections
+    reflection_names_globals: crate::FastHashMap<Handle<crate::GlobalVariable>, String>,
     /// The selected entry point
     entry_point: &'a crate::EntryPoint,
     /// The index of the selected entry point
-    entry_point_idx: EntryPointIndex,
+    entry_point_idx: proc::EntryPointIndex,
     /// Used to generate a unique number for blocks
     block_id: IdGenerator,
     /// Set of expressions that have associated temporary variables
     named_expressions: crate::NamedExpressions,
 }
 
 impl<'a, W: Write> Writer<'a, W> {
     /// Creates a new [`Writer`](Writer) instance
     ///
     /// # Errors
     /// - If the version specified isn't supported (or invalid)
     /// - If the entry point couldn't be found on the module
     /// - If the version specified doesn't support some used features
     pub fn new(
         out: W,
-        module: &'a Module,
-        info: &'a ModuleInfo,
+        module: &'a crate::Module,
+        info: &'a valid::ModuleInfo,
         options: &'a Options,
+        pipeline_options: &'a PipelineOptions,
     ) -> Result<Self, Error> {
         // Check if the requested version is supported
         if !options.version.is_supported() {
             log::error!("Version {}", options.version);
             return Err(Error::VersionNotSupported);
         }
 
         // Try to find the entry point and corresponding index
         let ep_idx = module
             .entry_points
             .iter()
-            .position(|ep| options.shader_stage == ep.stage && options.entry_point == ep.name)
+            .position(|ep| {
+                pipeline_options.shader_stage == ep.stage && pipeline_options.entry_point == ep.name
+            })
             .ok_or(Error::EntryPointNotFound)?;
 
         // Generate a map with names required to write the module
-        let mut names = FastHashMap::default();
-        let mut namer = Namer::default();
+        let mut names = crate::FastHashMap::default();
+        let mut namer = proc::Namer::default();
         namer.reset(module, keywords::RESERVED_KEYWORDS, &["gl_"], &mut names);
 
         // Build the instance
         let mut this = Self {
             module,
             info,
             out,
             options,
             namer,
             features: FeaturesManager::new(),
             names,
-            reflection_names: FastHashMap::default(),
+            reflection_names_uniforms: crate::FastHashMap::default(),
+            reflection_names_globals: crate::FastHashMap::default(),
             entry_point: &module.entry_points[ep_idx],
             entry_point_idx: ep_idx as u16,
 
             block_id: IdGenerator::default(),
             named_expressions: crate::NamedExpressions::default(),
         };
 
         // Find all features required to print this module
@@ -407,50 +416,68 @@ impl<'a, W: Write> Writer<'a, W> {
         // Write all the needed extensions
         //
         // This used to be the last thing being written as it allowed to search for features while
         // writing the module saving some loops but some older versions (420 or less) required the
         // extensions to appear before being used, even though extensions are part of the
         // preprocessor not the processor ¯\_(ツ)_/¯
         self.features.write(self.options.version, &mut self.out)?;
 
-        // glsl es requires a precision to be specified for floats
+        // Write the additional extensions
+        if self
+            .options
+            .writer_flags
+            .contains(WriterFlags::TEXTURE_SHADOW_LOD)
+        {
+            // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_shadow_lod.txt
+            writeln!(self.out, "#extension GL_EXT_texture_shadow_lod : require")?;
+        }
+
+        // glsl es requires a precision to be specified for floats and ints
         // TODO: Should this be user configurable?
         if es {
             writeln!(self.out)?;
             writeln!(self.out, "precision highp float;")?;
+            writeln!(self.out, "precision highp int;")?;
             writeln!(self.out)?;
         }
 
-        if self.options.shader_stage == ShaderStage::Compute {
+        if self.entry_point.stage == ShaderStage::Compute {
             let workgroup_size = self.entry_point.workgroup_size;
             writeln!(
                 self.out,
                 "layout(local_size_x = {}, local_size_y = {}, local_size_z = {}) in;",
                 workgroup_size[0], workgroup_size[1], workgroup_size[2]
             )?;
             writeln!(self.out)?;
         }
 
         // Enable early depth tests if needed
         if let Some(depth_test) = self.entry_point.early_depth_test {
-            writeln!(self.out, "layout(early_fragment_tests) in;")?;
+            // If early depth test is supported for this version of GLSL
+            if self.options.version.supports_early_depth_test() {
+                writeln!(self.out, "layout(early_fragment_tests) in;")?;
+
+                if let Some(conservative) = depth_test.conservative {
+                    use crate::ConservativeDepth as Cd;
 
-            if let Some(conservative) = depth_test.conservative {
-                writeln!(
-                    self.out,
-                    "layout (depth_{}) out float gl_FragDepth;",
-                    match conservative {
-                        ConservativeDepth::GreaterEqual => "greater",
-                        ConservativeDepth::LessEqual => "less",
-                        ConservativeDepth::Unchanged => "unchanged",
-                    }
-                )?;
+                    let depth = match conservative {
+                        Cd::GreaterEqual => "greater",
+                        Cd::LessEqual => "less",
+                        Cd::Unchanged => "unchanged",
+                    };
+                    writeln!(self.out, "layout (depth_{}) out float gl_FragDepth;", depth)?;
+                }
+                writeln!(self.out)?;
+            } else {
+                log::warn!(
+                    "Early depth testing is not supported for this version of GLSL: {}",
+                    self.options.version
+                );
             }
-            writeln!(self.out)?;
         }
 
         // Write all structs
         //
         // This are always ordered because of the IR is structured in a way that you can't make a
         // struct without adding all of it's members first
         for (handle, ty) in self.module.types.iter() {
             if let TypeInner::Struct { ref members, .. } = ty.inner {
@@ -482,27 +509,51 @@ impl<'a, W: Write> Writer<'a, W> {
             match self.module.types[global.ty].inner {
                 // We treat images separately because they might require
                 // writing the storage format
                 TypeInner::Image {
                     dim,
                     arrayed,
                     class,
                 } => {
-                    // Write the storage format if needed
-                    if let TypeInner::Image {
-                        class: ImageClass::Storage(format),
-                        ..
-                    } = self.module.types[global.ty].inner
-                    {
-                        write!(self.out, "layout({}) ", glsl_storage_format(format))?;
+                    // Gather the storage format if needed
+                    let storage_format_access = match self.module.types[global.ty].inner {
+                        TypeInner::Image {
+                            class: crate::ImageClass::Storage { format, access },
+                            ..
+                        } => Some((format, access)),
+                        _ => None,
+                    };
+                    // Gether the location if needed
+                    let layout_binding = if self.options.version.supports_explicit_locations() {
+                        let br = global.binding.as_ref().unwrap();
+                        self.options.binding_map.get(br).cloned()
+                    } else {
+                        None
+                    };
+
+                    // Write all the layout qualifiers
+                    if layout_binding.is_some() || storage_format_access.is_some() {
+                        write!(self.out, "layout(")?;
+                        if let Some(binding) = layout_binding {
+                            write!(self.out, "binding = {}", binding)?;
+                        }
+                        if let Some((format, _)) = storage_format_access {
+                            let format_str = glsl_storage_format(format);
+                            let separator = match layout_binding {
+                                Some(_) => ",",
+                                None => "",
+                            };
+                            write!(self.out, "{}{}", separator, format_str)?;
+                        }
+                        write!(self.out, ") ")?;
                     }
 
-                    if let Some(storage_access) = glsl_storage_access(global.storage_access) {
-                        write!(self.out, "{} ", storage_access)?;
+                    if let Some((_, access)) = storage_format_access {
+                        self.write_storage_access(access)?;
                     }
 
                     // All images in glsl are `uniform`
                     // The trailing space is important
                     write!(self.out, "uniform ")?;
 
                     // write the type
                     //
@@ -511,25 +562,27 @@ impl<'a, W: Write> Writer<'a, W> {
                     self.write_image_type(dim, arrayed, class)?;
 
                     // Finally write the name and end the global with a `;`
                     // The leading space is important
                     let global_name = self.get_global_name(handle, global);
                     writeln!(self.out, " {};", global_name)?;
                     writeln!(self.out)?;
 
-                    self.reflection_names.insert(global.ty, global_name);
+                    self.reflection_names_globals.insert(handle, global_name);
                 }
                 // glsl has no concept of samplers so we just ignore it
                 TypeInner::Sampler { .. } => continue,
                 // All other globals are written by `write_global`
                 _ => {
-                    self.write_global(handle, global)?;
-                    // Add a newline (only for readability)
-                    writeln!(self.out)?;
+                    if !ep_info[handle].is_empty() {
+                        self.write_global(handle, global)?;
+                        // Add a newline (only for readability)
+                        writeln!(self.out)?;
+                    }
                 }
             }
         }
 
         for arg in self.entry_point.function.arguments.iter() {
             self.write_varying(arg.binding.as_ref(), arg.ty, false)?;
         }
         if let Some(ref result) = self.entry_point.function.result {
@@ -545,69 +598,82 @@ impl<'a, W: Write> Writer<'a, W> {
                 continue;
             }
 
             // We also `clone` to satisfy the borrow checker
             let name = self.names[&NameKey::Function(handle)].clone();
             let fun_info = &self.info[handle];
 
             // Write the function
-            self.write_function(FunctionType::Function(handle), function, fun_info, &name)?;
+            self.write_function(
+                back::FunctionType::Function(handle),
+                function,
+                fun_info,
+                &name,
+            )?;
 
             writeln!(self.out)?;
         }
 
         self.write_function(
-            FunctionType::EntryPoint(self.entry_point_idx),
+            back::FunctionType::EntryPoint(self.entry_point_idx),
             &self.entry_point.function,
             ep_info,
             "main",
         )?;
 
         // Add newline at the end of file
         writeln!(self.out)?;
 
         // Collect all relection info and return it to the user
         self.collect_reflection_info()
     }
 
-    fn write_array_size(&mut self, size: ArraySize) -> BackendResult {
+    fn write_array_size(&mut self, size: crate::ArraySize) -> BackendResult {
         write!(self.out, "[")?;
 
         // Write the array size
         // Writes nothing if `ArraySize::Dynamic`
-        // Panics if `ArraySize::Constant` has a constant that isn't an uint
+        // Panics if `ArraySize::Constant` has a constant that isn't an sint or uint
         match size {
-            ArraySize::Constant(const_handle) => match self.module.constants[const_handle].inner {
-                ConstantInner::Scalar {
-                    width: _,
-                    value: ScalarValue::Uint(size),
-                } => write!(self.out, "{}", size)?,
-                _ => unreachable!(),
-            },
-            ArraySize::Dynamic => (),
+            crate::ArraySize::Constant(const_handle) => {
+                match self.module.constants[const_handle].inner {
+                    crate::ConstantInner::Scalar {
+                        width: _,
+                        value: crate::ScalarValue::Uint(size),
+                    } => write!(self.out, "{}", size)?,
+                    crate::ConstantInner::Scalar {
+                        width: _,
+                        value: crate::ScalarValue::Sint(size),
+                    } => write!(self.out, "{}", size)?,
+                    _ => unreachable!(),
+                }
+            }
+            crate::ArraySize::Dynamic => (),
         }
 
         write!(self.out, "]")?;
         Ok(())
     }
 
     /// Helper method used to write value types
     ///
     /// # Notes
     /// Adds no trailing or leading whitespace
     ///
     /// # Panics
     /// - If type is either a image, a sampler, a pointer, or a struct
     /// - If it's an Array with a [`ArraySize::Constant`](crate::ArraySize::Constant) with a
-    /// constant that isn't [`Uint`](crate::ConstantInner::Uint)
+    /// constant that isn't a [`Scalar`](crate::ConstantInner::Scalar) or if the
+    /// scalar value isn't an [`Sint`](crate::ScalarValue::Sint) or [`Uint`](crate::ScalarValue::Uint)
     fn write_value_type(&mut self, inner: &TypeInner) -> BackendResult {
         match *inner {
             // Scalars are simple we just get the full name from `glsl_scalar`
             TypeInner::Scalar { kind, width }
+            | TypeInner::Atomic { kind, width }
             | TypeInner::ValuePointer {
                 size: None,
                 kind,
                 width,
                 class: _,
             } => write!(self.out, "{}", glsl_scalar(kind, width)?.full)?,
             // Vectors are just `gvecN` where `g` is the scalar prefix and `N` is the vector size
             TypeInner::Vector { size, kind, width }
@@ -629,17 +695,17 @@ impl<'a, W: Write> Writer<'a, W> {
             // extra branch to write matrices this way
             TypeInner::Matrix {
                 columns,
                 rows,
                 width,
             } => write!(
                 self.out,
                 "{}mat{}x{}",
-                glsl_scalar(ScalarKind::Float, width)?.prefix,
+                glsl_scalar(crate::ScalarKind::Float, width)?.prefix,
                 columns as u8,
                 rows as u8
             )?,
             // GLSL arrays are written as `type name[size]`
             // Current code is written arrays only as `[size]`
             // Base `type` and `name` should be written outside
             TypeInner::Array { size, .. } => self.write_array_size(size)?,
             // Panic if either Image, Sampler, Pointer, or a Struct is being written
@@ -658,18 +724,19 @@ impl<'a, W: Write> Writer<'a, W> {
     /// Helper method used to write non image/sampler types
     ///
     /// # Notes
     /// Adds no trailing or leading whitespace
     ///
     /// # Panics
     /// - If type is either a image or sampler
     /// - If it's an Array with a [`ArraySize::Constant`](crate::ArraySize::Constant) with a
-    /// constant that isn't [`Uint`](crate::ConstantInner::Uint)
-    fn write_type(&mut self, ty: Handle<Type>) -> BackendResult {
+    /// constant that isn't a [`Scalar`](crate::ConstantInner::Scalar) or if the
+    /// scalar value isn't an [`Sint`](crate::ScalarValue::Sint) or [`Uint`](crate::ScalarValue::Uint)
+    fn write_type(&mut self, ty: Handle<crate::Type>) -> BackendResult {
         match self.module.types[ty].inner {
             // glsl has no pointer types so just write types as normal and loads are skipped
             TypeInner::Pointer { base, .. } => self.write_type(base),
             TypeInner::Struct {
                 top_level: true,
                 ref members,
                 span: _,
             } => self.write_struct(true, ty, members),
@@ -689,36 +756,38 @@ impl<'a, W: Write> Writer<'a, W> {
     /// Helper method to write a image type
     ///
     /// # Notes
     /// Adds no leading or trailing whitespace
     fn write_image_type(
         &mut self,
         dim: crate::ImageDimension,
         arrayed: bool,
-        class: ImageClass,
+        class: crate::ImageClass,
     ) -> BackendResult {
         // glsl images consist of four parts the scalar prefix, the image "type", the dimensions
         // and modifiers
         //
         // There exists two image types
         // - sampler - for sampled images
         // - image - for storage images
         //
         // There are three possible modifiers that can be used together and must be written in
         // this order to be valid
         // - MS - used if it's a multisampled image
         // - Array - used if it's an image array
         // - Shadow - used if it's a depth image
+        use crate::ImageClass as Ic;
 
         let (base, kind, ms, comparison) = match class {
-            ImageClass::Sampled { kind, multi: true } => ("sampler", kind, "MS", ""),
-            ImageClass::Sampled { kind, multi: false } => ("sampler", kind, "", ""),
-            ImageClass::Depth => ("sampler", crate::ScalarKind::Float, "", "Shadow"),
-            ImageClass::Storage(format) => ("image", format.into(), "", ""),
+            Ic::Sampled { kind, multi: true } => ("sampler", kind, "MS", ""),
+            Ic::Sampled { kind, multi: false } => ("sampler", kind, "", ""),
+            Ic::Depth { multi: true } => ("sampler", crate::ScalarKind::Float, "MS", ""),
+            Ic::Depth { multi: false } => ("sampler", crate::ScalarKind::Float, "", "Shadow"),
+            Ic::Storage { format, .. } => ("image", format.into(), "", ""),
         };
 
         write!(
             self.out,
             "highp {}{}{}{}{}{}",
             glsl_scalar(kind, 4)?.prefix,
             base,
             glsl_dimension(dim),
@@ -734,21 +803,30 @@ impl<'a, W: Write> Writer<'a, W> {
     ///
     /// # Notes
     /// Adds a newline
     ///
     /// # Panics
     /// If the global has type sampler
     fn write_global(
         &mut self,
-        handle: Handle<GlobalVariable>,
-        global: &GlobalVariable,
+        handle: Handle<crate::GlobalVariable>,
+        global: &crate::GlobalVariable,
     ) -> BackendResult {
-        if let Some(storage_access) = glsl_storage_access(global.storage_access) {
-            write!(self.out, "{} ", storage_access)?;
+        if self.options.version.supports_explicit_locations() {
+            if let Some(ref br) = global.binding {
+                match self.options.binding_map.get(br) {
+                    Some(binding) => write!(self.out, "layout(binding = {}) ", binding)?,
+                    None => log::debug!("unassigned binding for {:?}", global.name),
+                }
+            }
+        }
+
+        if let crate::StorageClass::Storage { access } = global.class {
+            self.write_storage_access(access)?;
         }
 
         // Write the storage class
         // Trailing space is important
         if let Some(storage_class) = glsl_storage_class(global.class) {
             write!(self.out, "{} ", storage_class)?;
         } else if let TypeInner::Struct {
             top_level: true, ..
@@ -763,84 +841,96 @@ impl<'a, W: Write> Writer<'a, W> {
 
         // Finally write the global name and end the global with a `;` and a newline
         // Leading space is important
         let global_name = self.get_global_name(handle, global);
         write!(self.out, " {}", global_name)?;
         if let TypeInner::Array { size, .. } = self.module.types[global.ty].inner {
             self.write_array_size(size)?;
         }
-        if let Some(default_value) = zero_init_value_str(&self.module.types[global.ty].inner) {
-            write!(self.out, " = {}", default_value)?;
-        };
+
+        if is_value_init_supported(self.module, global.ty) {
+            write!(self.out, " = ")?;
+            if let Some(init) = global.init {
+                self.write_constant(init)?;
+            } else {
+                self.write_zero_init_value(global.ty)?;
+            }
+        }
         writeln!(self.out, ";")?;
 
         Ok(())
     }
 
     /// Helper method used to get a name for a global
     ///
     /// Globals have different naming schemes depending on their binding:
     /// - Globals without bindings use the name from the [`Namer`](crate::proc::Namer)
     /// - Globals with resource binding are named `_group_X_binding_Y` where `X`
     ///   is the group and `Y` is the binding
-    fn get_global_name(&self, handle: Handle<GlobalVariable>, global: &GlobalVariable) -> String {
+    fn get_global_name(
+        &self,
+        handle: Handle<crate::GlobalVariable>,
+        global: &crate::GlobalVariable,
+    ) -> String {
         match global.binding {
             Some(ref br) => {
                 format!("_group_{}_binding_{}", br.group, br.binding)
             }
             None => self.names[&NameKey::GlobalVariable(handle)].clone(),
         }
     }
 
     /// Writes the varying declaration.
     fn write_varying(
         &mut self,
-        binding: Option<&Binding>,
-        ty: Handle<Type>,
+        binding: Option<&crate::Binding>,
+        ty: Handle<crate::Type>,
         output: bool,
     ) -> Result<(), Error> {
         match self.module.types[ty].inner {
             crate::TypeInner::Struct { ref members, .. } => {
                 for member in members {
                     self.write_varying(member.binding.as_ref(), member.ty, output)?;
                 }
             }
             _ => {
                 let (location, interpolation, sampling) = match binding {
-                    Some(&Binding::Location {
+                    Some(&crate::Binding::Location {
                         location,
                         interpolation,
                         sampling,
                     }) => (location, interpolation, sampling),
                     _ => return Ok(()),
                 };
 
                 // Write the interpolation modifier if needed
                 //
                 // We ignore all interpolation and auxiliary modifiers that aren't used in fragment
                 // shaders' input globals or vertex shaders' output globals.
-                let emit_interpolation_and_auxiliary = match self.options.shader_stage {
+                let emit_interpolation_and_auxiliary = match self.entry_point.stage {
                     ShaderStage::Vertex => output,
                     ShaderStage::Fragment => !output,
                     _ => false,
                 };
+
+                // Write the I/O locations, if allowed
+                if self.options.version.supports_explicit_locations()
+                    || !emit_interpolation_and_auxiliary
+                {
+                    write!(self.out, "layout(location = {}) ", location)?;
+                }
+
+                // Write the interpolation qualifier.
                 if let Some(interp) = interpolation {
                     if emit_interpolation_and_auxiliary {
                         write!(self.out, "{} ", glsl_interpolation(interp))?;
                     }
                 }
 
-                // Write the storage class
-                if !emit_interpolation_and_auxiliary
-                    && self.options.version.supports_explicit_locations()
-                {
-                    write!(self.out, "layout(location = {}) ", location)?;
-                }
-
                 // Write the sampling auxiliary qualifier.
                 //
                 // Before GLSL 4.2, the `centroid` and `sample` qualifiers were required to appear
                 // immediately before the `in` / `out` qualifier, so we'll just follow that rule
                 // here, regardless of the version.
                 if let Some(sampling) = sampling {
                     if emit_interpolation_and_auxiliary {
                         if let Some(qualifier) = glsl_sampling(sampling) {
@@ -854,17 +944,17 @@ impl<'a, W: Write> Writer<'a, W> {
 
                 // Write the type
                 // `write_type` adds no leading or trailing spaces
                 self.write_type(ty)?;
 
                 // Finally write the global name and end the global with a `;` and a newline
                 // Leading space is important
                 let vname = VaryingName {
-                    binding: &Binding::Location {
+                    binding: &crate::Binding::Location {
                         location,
                         interpolation: None,
                         sampling: None,
                     },
                     stage: self.entry_point.stage,
                     output,
                 };
                 writeln!(self.out, " {};", vname)?;
@@ -874,24 +964,24 @@ impl<'a, W: Write> Writer<'a, W> {
     }
 
     /// Helper method used to write functions (both entry points and regular functions)
     ///
     /// # Notes
     /// Adds a newline
     fn write_function(
         &mut self,
-        ty: FunctionType,
-        func: &Function,
-        info: &FunctionInfo,
+        ty: back::FunctionType,
+        func: &crate::Function,
+        info: &valid::FunctionInfo,
         name: &str,
     ) -> BackendResult {
         // Create a function context for the function being written
-        let ctx = FunctionCtx {
-            func: ty,
+        let ctx = back::FunctionCtx {
+            ty,
             info,
             expressions: &func.expressions,
             named_expressions: &func.named_expressions,
         };
 
         self.named_expressions.clear();
 
         // Write the function header
@@ -902,55 +992,93 @@ impl<'a, W: Write> Writer<'a, W> {
         // `name` is the function name
         // `args` is a comma separated list of `type name`
         //  | - `type` is the argument type
         //  | - `name` is the argument name
 
         // Start by writing the return type if any otherwise write void
         // This is the only place where `void` is a valid type
         // (though it's more a keyword than a type)
-        if let FunctionType::EntryPoint(_) = ctx.func {
+        if let back::FunctionType::EntryPoint(_) = ctx.ty {
             write!(self.out, "void")?;
         } else if let Some(ref result) = func.result {
             self.write_type(result.ty)?;
         } else {
             write!(self.out, "void")?;
         }
 
         // Write the function name and open parentheses for the argument list
         write!(self.out, " {}(", name)?;
 
         // Write the comma separated argument list
         //
         // We need access to `Self` here so we use the reference passed to the closure as an
         // argument instead of capturing as that would cause a borrow checker error
-        let arguments = match ctx.func {
-            FunctionType::EntryPoint(_) => &[][..],
-            FunctionType::Function(_) => &func.arguments,
+        let arguments = match ctx.ty {
+            back::FunctionType::EntryPoint(_) => &[][..],
+            back::FunctionType::Function(_) => &func.arguments,
         };
-        self.write_slice(arguments, |this, i, arg| {
+        let arguments: Vec<_> = arguments
+            .iter()
+            .filter(|arg| match self.module.types[arg.ty].inner {
+                TypeInner::Sampler { .. } => false,
+                _ => true,
+            })
+            .collect();
+        self.write_slice(&arguments, |this, i, arg| {
             // Write the argument type
-            // `write_type` adds no trailing spaces
-            this.write_type(arg.ty)?;
+            match this.module.types[arg.ty].inner {
+                // We treat images separately because they might require
+                // writing the storage format
+                TypeInner::Image {
+                    dim,
+                    arrayed,
+                    class,
+                } => {
+                    // Write the storage format if needed
+                    if let TypeInner::Image {
+                        class: crate::ImageClass::Storage { format, .. },
+                        ..
+                    } = this.module.types[arg.ty].inner
+                    {
+                        write!(this.out, "layout({}) ", glsl_storage_format(format))?;
+                    }
+
+                    // write the type
+                    //
+                    // This is way we need the leading space because `write_image_type` doesn't add
+                    // any spaces at the beginning or end
+                    this.write_image_type(dim, arrayed, class)?;
+                }
+                TypeInner::Pointer { base, .. } => {
+                    // write parameter qualifiers
+                    write!(this.out, "inout ")?;
+                    this.write_type(base)?;
+                }
+                // All other types are written by `write_type`
+                _ => {
+                    this.write_type(arg.ty)?;
+                }
+            }
 
             // Write the argument name
             // The leading space is important
             write!(this.out, " {}", &this.names[&ctx.argument_key(i)])?;
 
             Ok(())
         })?;
 
         // Close the parentheses and open braces to start the function body
         writeln!(self.out, ") {{")?;
 
         // Compose the function arguments from globals, in case of an entry point.
-        if let FunctionType::EntryPoint(ep_index) = ctx.func {
+        if let back::FunctionType::EntryPoint(ep_index) = ctx.ty {
             let stage = self.module.entry_points[ep_index as usize].stage;
             for (index, arg) in func.arguments.iter().enumerate() {
-                write!(self.out, "{}", INDENT)?;
+                write!(self.out, "{}", back::INDENT)?;
                 self.write_type(arg.ty)?;
                 let name = &self.names[&NameKey::EntryPointArgument(ep_index, index as u32)];
                 write!(self.out, " {}", name)?;
                 write!(self.out, " = ")?;
                 match self.module.types[arg.ty].inner {
                     crate::TypeInner::Struct { ref members, .. } => {
                         self.write_type(arg.ty)?;
                         write!(self.out, "(")?;
@@ -981,32 +1109,38 @@ impl<'a, W: Write> Writer<'a, W> {
 
         // Write all function locals
         // Locals are `type name (= init)?;` where the init part (including the =) are optional
         //
         // Always adds a newline
         for (handle, local) in func.local_variables.iter() {
             // Write indentation (only for readability) and the type
             // `write_type` adds no trailing space
-            write!(self.out, "{}", INDENT)?;
+            write!(self.out, "{}", back::INDENT)?;
             self.write_type(local.ty)?;
 
             // Write the local name
             // The leading space is important
             write!(self.out, " {}", self.names[&ctx.name_key(handle)])?;
-
+            // Write size for array type
+            if let TypeInner::Array { size, .. } = self.module.types[local.ty].inner {
+                self.write_array_size(size)?;
+            }
             // Write the local initializer if needed
             if let Some(init) = local.init {
                 // Put the equal signal only if there's a initializer
                 // The leading and trailing spaces aren't needed but help with readability
                 write!(self.out, " = ")?;
 
                 // Write the constant
                 // `write_constant` adds no trailing or leading space/newline
-                self.write_constant(&self.module.constants[init])?;
+                self.write_constant(init)?;
+            } else if is_value_init_supported(self.module, local.ty) {
+                write!(self.out, " = ")?;
+                self.write_zero_init_value(local.ty)?;
             }
 
             // Finish the local with `;` and add a newline (only for readability)
             writeln!(self.out, ";")?
         }
 
         // Write the function body (statement list)
         for sta in func.body.iter() {
@@ -1049,105 +1183,106 @@ impl<'a, W: Write> Writer<'a, W> {
 
         Ok(())
     }
 
     /// Helper method used to write constants
     ///
     /// # Notes
     /// Adds no newlines or leading/trailing whitespace
-    fn write_constant(&mut self, constant: &Constant) -> BackendResult {
-        match constant.inner {
-            ConstantInner::Scalar {
+    fn write_constant(&mut self, handle: Handle<crate::Constant>) -> BackendResult {
+        use crate::ScalarValue as Sv;
+
+        match self.module.constants[handle].inner {
+            crate::ConstantInner::Scalar {
                 width: _,
                 ref value,
             } => match *value {
                 // Signed integers don't need anything special
-                ScalarValue::Sint(int) => write!(self.out, "{}", int)?,
+                Sv::Sint(int) => write!(self.out, "{}", int)?,
                 // Unsigned integers need a `u` at the end
                 //
                 // While `core` doesn't necessarily need it, it's allowed and since `es` needs it we
                 // always write it as the extra branch wouldn't have any benefit in readability
-                ScalarValue::Uint(int) => write!(self.out, "{}u", int)?,
+                Sv::Uint(int) => write!(self.out, "{}u", int)?,
                 // Floats are written using `Debug` instead of `Display` because it always appends the
                 // decimal part even it's zero which is needed for a valid glsl float constant
-                ScalarValue::Float(float) => write!(self.out, "{:?}", float)?,
+                Sv::Float(float) => write!(self.out, "{:?}", float)?,
                 // Booleans are either `true` or `false` so nothing special needs to be done
-                ScalarValue::Bool(boolean) => write!(self.out, "{}", boolean)?,
+                Sv::Bool(boolean) => write!(self.out, "{}", boolean)?,
             },
             // Composite constant are created using the same syntax as compose
             // `type(components)` where `components` is a comma separated list of constants
-            ConstantInner::Composite { ty, ref components } => {
+            crate::ConstantInner::Composite { ty, ref components } => {
                 self.write_type(ty)?;
                 write!(self.out, "(")?;
 
                 // Write the comma separated constants
-                self.write_slice(components, |this, _, arg| {
-                    this.write_constant(&this.module.constants[*arg])
-                })?;
+                self.write_slice(components, |this, _, arg| this.write_constant(*arg))?;
 
                 write!(self.out, ")")?
             }
         }
 
         Ok(())
     }
 
     /// Helper method used to write structs
     ///
     /// # Notes
     /// Ends in a newline
     fn write_struct(
         &mut self,
         block: bool,
-        handle: Handle<Type>,
-        members: &[StructMember],
+        handle: Handle<crate::Type>,
+        members: &[crate::StructMember],
     ) -> BackendResult {
         // glsl structs are written as in C
         // `struct name() { members };`
         //  | `struct` is a keyword
         //  | `name` is the struct name
         //  | `members` is a semicolon separated list of `type name`
         //      | `type` is the member type
         //      | `name` is the member name
         let name = &self.names[&NameKey::Type(handle)];
 
         // If struct is a block we need to write `block_name { members }` where `block_name` must be
         // unique between blocks and structs so we add `_block_ID` where `ID` is a `IdGenerator`
         // generated number so it's unique and `members` are the same as in a struct
         if block {
             // Write the block name, it's just the struct name appended with `_block_ID`
-            let block_name = format!("{}_block_{}", name, self.block_id.generate());
+            let stage_postfix = match self.entry_point.stage {
+                ShaderStage::Vertex => "Vs",
+                ShaderStage::Fragment => "Fs",
+                ShaderStage::Compute => "Cs",
+            };
+            let block_name = format!(
+                "{}_block_{}{}",
+                name,
+                self.block_id.generate(),
+                stage_postfix
+            );
             writeln!(self.out, "{} {{", block_name)?;
 
-            self.reflection_names.insert(handle, block_name);
+            self.reflection_names_uniforms.insert(handle, block_name);
         } else {
             writeln!(self.out, "struct {} {{", name)?;
         }
 
         for (idx, member) in members.iter().enumerate() {
             // The indentation is only for readability
-            write!(self.out, "{}", INDENT)?;
+            write!(self.out, "{}", back::INDENT)?;
 
             match self.module.types[member.ty].inner {
                 TypeInner::Array {
                     base,
                     size,
                     stride: _,
                 } => {
-                    // GLSL arrays are written as `type name[size]`
-                    let ty_name = match self.module.types[base].inner {
-                        // Write scalar type by backend so as not to depend on the front-end implementation
-                        // Name returned from frontend can be generated (type1, float1, etc.)
-                        TypeInner::Scalar { kind, width } => glsl_scalar(kind, width)?.full,
-                        _ => &self.names[&NameKey::Type(base)],
-                    };
-
-                    // Write `type` and `name`
-                    write!(self.out, "{}", ty_name)?;
+                    self.write_type(base)?;
                     write!(
                         self.out,
                         " {}",
                         &self.names[&NameKey::StructMember(handle, idx as u32)]
                     )?;
                     // Write [size]
                     self.write_array_size(size)?;
                     // Newline is important
@@ -1182,34 +1317,37 @@ impl<'a, W: Write> Writer<'a, W> {
     }
 
     /// Helper method used to write statements
     ///
     /// # Notes
     /// Always adds a newline
     fn write_stmt(
         &mut self,
-        sta: &Statement,
-        ctx: &FunctionCtx<'_>,
+        sta: &crate::Statement,
+        ctx: &back::FunctionCtx,
         indent: usize,
     ) -> BackendResult {
+        use crate::Statement;
+        use back::INDENT;
+
         match *sta {
             // This is where we can generate intermediate constants for some expression types.
             Statement::Emit(ref range) => {
                 for handle in range.clone() {
                     let expr_name = if let Some(name) = ctx.named_expressions.get(&handle) {
                         // Front end provides names for all variables at the start of writing.
                         // But we write them to step by step. We need to recache them
                         // Otherwise, we could accidentally write variable name instead of full expression.
                         // Also, we use sanitized names! It defense backend from generating variable with name from reserved keywords.
                         Some(self.namer.call_unique(name))
                     } else {
                         let min_ref_count = ctx.expressions[handle].bake_ref_count();
                         if min_ref_count <= ctx.info[handle].ref_count {
-                            Some(format!("_expr{}", handle.index()))
+                            Some(format!("{}{}", super::BAKE_PREFIX, handle.index()))
                         } else {
                             None
                         }
                     };
 
                     if let Some(name) = expr_name {
                         write!(self.out, "{}", INDENT.repeat(indent))?;
                         self.write_named_expr(handle, name, ctx)?;
@@ -1298,21 +1436,16 @@ impl<'a, W: Write> Writer<'a, W> {
                         "{}case {}:",
                         INDENT.repeat(indent + 1),
                         case.value
                     )?;
 
                     for sta in case.body.iter() {
                         self.write_stmt(sta, ctx, indent + 2)?;
                     }
-
-                    // Write `break;` if the block isn't fallthrough
-                    if !case.fall_through {
-                        writeln!(self.out, "{}break;", INDENT.repeat(indent + 2))?;
-                    }
                 }
 
                 // Only write the default block if the block isn't empty
                 // Writing default without a block is valid but it's more readable this way
                 if !default.is_empty() {
                     writeln!(self.out, "{}default:", INDENT.repeat(indent + 1))?;
 
                     for sta in default {
@@ -1320,81 +1453,112 @@ impl<'a, W: Write> Writer<'a, W> {
                     }
                 }
 
                 writeln!(self.out, "{}}}", INDENT.repeat(indent))?
             }
             // Loops in naga IR are based on wgsl loops, glsl can emulate the behaviour by using a
             // while true loop and appending the continuing block to the body resulting on:
             // ```
+            // bool loop_init = true;
             // while(true) {
-            //  body
-            //  continuing
+            //  if (!loop_init) { <continuing> }
+            //  loop_init = false;
+            //  <body>
             // }
             // ```
             Statement::Loop {
                 ref body,
                 ref continuing,
             } => {
-                write!(self.out, "{}", INDENT.repeat(indent))?;
-                writeln!(self.out, "while(true) {{")?;
-
-                for sta in body.iter().chain(continuing.iter()) {
+                if !continuing.is_empty() {
+                    let gate_name = self.namer.call("loop_init");
+                    writeln!(
+                        self.out,
+                        "{}bool {} = true;",
+                        INDENT.repeat(indent),
+                        gate_name
+                    )?;
+                    writeln!(self.out, "{}while(true) {{", INDENT.repeat(indent))?;
+                    writeln!(
+                        self.out,
+                        "{}if (!{}) {{",
+                        INDENT.repeat(indent + 1),
+                        gate_name
+                    )?;
+                    for sta in continuing {
+                        self.write_stmt(sta, ctx, indent + 1)?;
+                    }
+                    writeln!(self.out, "{}}}", INDENT.repeat(indent + 1))?;
+                    writeln!(
+                        self.out,
+                        "{}{} = false;",
+                        INDENT.repeat(indent + 1),
+                        gate_name
+                    )?;
+                } else {
+                    writeln!(self.out, "{}while(true) {{", INDENT.repeat(indent))?;
+                }
+                for sta in body {
                     self.write_stmt(sta, ctx, indent + 1)?;
                 }
-
                 writeln!(self.out, "{}}}", INDENT.repeat(indent))?
             }
             // Break, continue and return as written as in C
             // `break;`
             Statement::Break => {
                 write!(self.out, "{}", INDENT.repeat(indent))?;
                 writeln!(self.out, "break;")?
             }
             // `continue;`
             Statement::Continue => {
                 write!(self.out, "{}", INDENT.repeat(indent))?;
                 writeln!(self.out, "continue;")?
             }
             // `return expr;`, `expr` is optional
             Statement::Return { value } => {
                 write!(self.out, "{}", INDENT.repeat(indent))?;
-                match ctx.func {
-                    FunctionType::Function(_) => {
+                match ctx.ty {
+                    back::FunctionType::Function(_) => {
                         write!(self.out, "return")?;
                         // Write the expression to be returned if needed
                         if let Some(expr) = value {
                             write!(self.out, " ")?;
                             self.write_expr(expr, ctx)?;
                         }
                         writeln!(self.out, ";")?;
                     }
-                    FunctionType::EntryPoint(ep_index) => {
+                    back::FunctionType::EntryPoint(ep_index) => {
                         let ep = &self.module.entry_points[ep_index as usize];
                         if let Some(ref result) = ep.function.result {
                             let value = value.unwrap();
                             match self.module.types[result.ty].inner {
                                 crate::TypeInner::Struct { ref members, .. } => {
-                                    let (mut is_temp_struct_used, mut return_struct) = (false, "");
-                                    if let Expression::Compose { .. } = ctx.expressions[value] {
-                                        is_temp_struct_used = true;
-                                        return_struct = "_tmp_return";
-                                        write!(
-                                            self.out,
-                                            "{} {} = ",
-                                            &self.names[&NameKey::Type(result.ty)],
-                                            return_struct
-                                        )?;
-                                        self.write_expr(value, ctx)?;
-                                        writeln!(self.out, ";")?;
-                                        write!(self.out, "{}", INDENT.repeat(indent))?;
-                                    }
+                                    let temp_struct_name = match ctx.expressions[value] {
+                                        crate::Expression::Compose { .. } => {
+                                            let return_struct = "_tmp_return";
+                                            write!(
+                                                self.out,
+                                                "{} {} = ",
+                                                &self.names[&NameKey::Type(result.ty)],
+                                                return_struct
+                                            )?;
+                                            self.write_expr(value, ctx)?;
+                                            writeln!(self.out, ";")?;
+                                            write!(self.out, "{}", INDENT.repeat(indent))?;
+                                            Some(return_struct)
+                                        }
+                                        _ => None,
+                                    };
+
                                     for (index, member) in members.iter().enumerate() {
                                         // TODO: handle builtin in better way
-                                        if let Some(Binding::BuiltIn(builtin)) = member.binding {
+                                        if let Some(crate::Binding::BuiltIn(builtin)) =
+                                            member.binding
+                                        {
                                             match builtin {
                                                 crate::BuiltIn::ClipDistance
                                                 | crate::BuiltIn::CullDistance
                                                 | crate::BuiltIn::PointSize => {
                                                     if self.options.version.is_es() {
                                                         continue;
                                                     }
                                                 }
@@ -1407,37 +1571,55 @@ impl<'a, W: Write> Writer<'a, W> {
                                             stage: ep.stage,
                                             output: true,
                                         };
                                         let field_name = self.names
                                             [&NameKey::StructMember(result.ty, index as u32)]
                                             .clone();
                                         write!(self.out, "{} = ", varying_name)?;
 
-                                        if !is_temp_struct_used {
+                                        if let Some(struct_name) = temp_struct_name {
+                                            write!(self.out, "{}", struct_name)?;
+                                        } else {
                                             self.write_expr(value, ctx)?;
                                         }
 
-                                        writeln!(self.out, "{}.{};", return_struct, &field_name)?;
+                                        writeln!(self.out, ".{};", field_name)?;
                                         write!(self.out, "{}", INDENT.repeat(indent))?;
                                     }
                                 }
                                 _ => {
                                     let name = VaryingName {
                                         binding: result.binding.as_ref().unwrap(),
                                         stage: ep.stage,
                                         output: true,
                                     };
                                     write!(self.out, "{} = ", name)?;
                                     self.write_expr(value, ctx)?;
                                     writeln!(self.out, ";")?;
                                     write!(self.out, "{}", INDENT.repeat(indent))?;
                                 }
                             }
                         }
+
+                        if let back::FunctionType::EntryPoint(ep_index) = ctx.ty {
+                            if self.module.entry_points[ep_index as usize].stage
+                                == crate::ShaderStage::Vertex
+                                && self
+                                    .options
+                                    .writer_flags
+                                    .contains(WriterFlags::ADJUST_COORDINATE_SPACE)
+                            {
+                                writeln!(
+                                    self.out,
+                                    "gl_Position.yz = vec2(-gl_Position.y, gl_Position.z * 2.0 - gl_Position.w);",
+                                )?;
+                                write!(self.out, "{}", INDENT.repeat(indent))?;
+                            }
+                        }
                         writeln!(self.out, "return;")?;
                     }
                 }
             }
             // This is one of the places were glsl adds to the syntax of C in this case the discard
             // keyword which ceases all further processing in a fragment shader, it's called OpKill
             // in spir-v that's why it's called `Statement::Kill`
             Statement::Kill => writeln!(self.out, "{}discard;", INDENT.repeat(indent))?,
@@ -1482,36 +1664,78 @@ impl<'a, W: Write> Writer<'a, W> {
             // A `Call` is written `name(arguments)` where `arguments` is a comma separated expressions list
             Statement::Call {
                 function,
                 ref arguments,
                 result,
             } => {
                 write!(self.out, "{}", INDENT.repeat(indent))?;
                 if let Some(expr) = result {
-                    let name = format!("_expr{}", expr.index());
+                    let name = format!("{}{}", super::BAKE_PREFIX, expr.index());
                     let result = self.module.functions[function].result.as_ref().unwrap();
                     self.write_type(result.ty)?;
                     write!(self.out, " {} = ", name)?;
                     self.named_expressions.insert(expr, name);
                 }
                 write!(self.out, "{}(", &self.names[&NameKey::Function(function)])?;
-                self.write_slice(arguments, |this, _, arg| this.write_expr(*arg, ctx))?;
+                let arguments: Vec<_> = arguments
+                    .iter()
+                    .enumerate()
+                    .filter_map(|(i, arg)| {
+                        let arg_ty = self.module.functions[function].arguments[i].ty;
+                        match self.module.types[arg_ty].inner {
+                            TypeInner::Sampler { .. } => None,
+                            _ => Some(*arg),
+                        }
+                    })
+                    .collect();
+                self.write_slice(&arguments, |this, _, arg| this.write_expr(*arg, ctx))?;
                 writeln!(self.out, ");")?
             }
+            Statement::Atomic {
+                pointer,
+                ref fun,
+                value,
+                result,
+            } => {
+                write!(self.out, "{}", INDENT.repeat(indent))?;
+                let res_name = format!("{}{}", super::BAKE_PREFIX, result.index());
+                let res_ty = ctx.info[result].ty.inner_with(&self.module.types);
+                self.write_value_type(res_ty)?;
+                write!(self.out, " {} = ", res_name)?;
+                self.named_expressions.insert(result, res_name);
+
+                let fun_str = fun.to_glsl();
+                write!(self.out, "atomic{}(", fun_str)?;
+                self.write_expr(pointer, ctx)?;
+                if let crate::AtomicFunction::Exchange { compare: Some(_) } = *fun {
+                    return Err(Error::Custom(
+                        "atomic CompareExchange is not implemented".to_string(),
+                    ));
+                }
+                write!(self.out, ", ")?;
+                self.write_expr(value, ctx)?;
+                writeln!(self.out, ");")?;
+            }
         }
 
         Ok(())
     }
 
     /// Helper method to write expressions
     ///
     /// # Notes
     /// Doesn't add any newlines or leading/trailing spaces
-    fn write_expr(&mut self, expr: Handle<Expression>, ctx: &FunctionCtx<'_>) -> BackendResult {
+    fn write_expr(
+        &mut self,
+        expr: Handle<crate::Expression>,
+        ctx: &back::FunctionCtx<'_>,
+    ) -> BackendResult {
+        use crate::Expression;
+
         if let Some(name) = self.named_expressions.get(&expr) {
             write!(self.out, "{}", name)?;
             return Ok(());
         }
 
         match ctx.expressions[expr] {
             // `Access` is applied to arrays, vectors and matrices and is written as indexing
             Expression::Access { base, index } => {
@@ -1534,17 +1758,17 @@ impl<'a, W: Write> Writer<'a, W> {
                         Some(base)
                     }
                     _ => base_ty_res.handle(),
                 };
 
                 match *resolved {
                     TypeInner::Vector { .. } => {
                         // Write vector access as a swizzle
-                        write!(self.out, ".{}", COMPONENTS[index as usize])?
+                        write!(self.out, ".{}", back::COMPONENTS[index as usize])?
                     }
                     TypeInner::Matrix { .. }
                     | TypeInner::Array { .. }
                     | TypeInner::ValuePointer { .. } => write!(self.out, "[{}]", index)?,
                     TypeInner::Struct { .. } => {
                         // This will never panic in case the type is a `Struct`, this is not true
                         // for other types so we can only check while inside this match arm
                         let ty = base_ty_handle.unwrap();
@@ -1554,19 +1778,17 @@ impl<'a, W: Write> Writer<'a, W> {
                             ".{}",
                             &self.names[&NameKey::StructMember(ty, index)]
                         )?
                     }
                     ref other => return Err(Error::Custom(format!("Cannot index {:?}", other))),
                 }
             }
             // Constants are delegated to `write_constant`
-            Expression::Constant(constant) => {
-                self.write_constant(&self.module.constants[constant])?
-            }
+            Expression::Constant(constant) => self.write_constant(constant)?,
             // `Splat` needs to actually write down a vector, it's not always inferred in GLSL.
             Expression::Splat { size: _, value } => {
                 let resolved = ctx.info[expr].ty.inner_with(&self.module.types);
                 self.write_value_type(resolved)?;
                 write!(self.out, "(")?;
                 self.write_expr(value, ctx)?;
                 write!(self.out, ")")?
             }
@@ -1574,24 +1796,29 @@ impl<'a, W: Write> Writer<'a, W> {
             Expression::Swizzle {
                 size,
                 vector,
                 pattern,
             } => {
                 self.write_expr(vector, ctx)?;
                 write!(self.out, ".")?;
                 for &sc in pattern[..size as usize].iter() {
-                    self.out.write_char(COMPONENTS[sc as usize])?;
+                    self.out.write_char(back::COMPONENTS[sc as usize])?;
                 }
             }
             // `Compose` is pretty simple we just write `type(components)` where `components` is a
             // comma separated list of expressions
             Expression::Compose { ty, ref components } => {
                 self.write_type(ty)?;
 
+                let resolved = ctx.info[expr].ty.inner_with(&self.module.types);
+                if let TypeInner::Array { size, .. } = *resolved {
+                    self.write_array_size(size)?;
+                }
+
                 write!(self.out, "(")?;
                 self.write_slice(components, |this, _, arg| this.write_expr(*arg, ctx))?;
                 write!(self.out, ")")?
             }
             // Function arguments are written as the argument name
             Expression::FunctionArgument(pos) => {
                 write!(self.out, "{}", &self.names[&ctx.argument_key(pos)])?
             }
@@ -1613,44 +1840,56 @@ impl<'a, W: Write> Writer<'a, W> {
             // if it's automatic or it it's bias:
             // `texture(image, coordinate)` - Automatic sample level
             // `texture(image, coordinate, bias)` - Bias sample level
             // `textureLod(image, coordinate, level)` - Zero or Exact sample level
             //
             // Furthermore if `depth_ref` is some we need to append it to the coordinate vector
             Expression::ImageSample {
                 image,
-                sampler: _, //TODO
+                sampler: _, //TODO?
                 coordinate,
                 array_index,
-                offset: _, //TODO
+                offset,
                 level,
                 depth_ref,
             } => {
-                //TODO: handle MS
+                let dim = match *ctx.info[image].ty.inner_with(&self.module.types) {
+                    TypeInner::Image { dim, .. } => dim,
+                    _ => unreachable!(),
+                };
 
                 // textureLod on sampler2DArrayShadow and samplerCubeShadow does not exist in GLSL.
                 // To emulate this, we will have to use textureGrad with a constant gradient of 0.
-                let workaround_lod_array_shadow_as_grad =
-                    array_index.is_some() && depth_ref.is_some();
+                let workaround_lod_array_shadow_as_grad = (array_index.is_some()
+                    || dim == crate::ImageDimension::Cube)
+                    && depth_ref.is_some()
+                    && !self
+                        .options
+                        .writer_flags
+                        .contains(WriterFlags::TEXTURE_SHADOW_LOD);
 
                 //Write the function to be used depending on the sample level
                 let fun_name = match level {
                     crate::SampleLevel::Auto | crate::SampleLevel::Bias(_) => "texture",
                     crate::SampleLevel::Zero | crate::SampleLevel::Exact(_) => {
                         if workaround_lod_array_shadow_as_grad {
                             "textureGrad"
                         } else {
                             "textureLod"
                         }
                     }
                     crate::SampleLevel::Gradient { .. } => "textureGrad",
                 };
+                let offset_name = match offset {
+                    Some(_) => "Offset",
+                    None => "",
+                };
 
-                write!(self.out, "{}(", fun_name)?;
+                write!(self.out, "{}{}(", fun_name, offset_name)?;
 
                 // Write the image that will be used
                 self.write_expr(image, ctx)?;
                 // The space here isn't required but it helps with readability
                 write!(self.out, ", ")?;
 
                 // We need to get the coordinates vector size to later build a vector that's `size + 1`
                 // if `depth_ref` is some, if it isn't a vector we panic as that's not a valid expression
@@ -1681,25 +1920,26 @@ impl<'a, W: Write> Writer<'a, W> {
                 write!(self.out, ")")?;
 
                 match level {
                     // Auto needs no more arguments
                     crate::SampleLevel::Auto => (),
                     // Zero needs level set to 0
                     crate::SampleLevel::Zero => {
                         if workaround_lod_array_shadow_as_grad {
-                            write!(self.out, ", vec2(0, 0), vec2(0,0)")?;
+                            write!(self.out, ", vec2(0,0), vec2(0,0)")?;
                         } else {
-                            write!(self.out, ", 0")?;
+                            write!(self.out, ", 0.0")?;
                         }
                     }
                     // Exact and bias require another argument
                     crate::SampleLevel::Exact(expr) => {
                         if workaround_lod_array_shadow_as_grad {
-                            write!(self.out, ", vec2(0, 0), vec2(0,0)")?;
+                            log::warn!("Unable to `textureLod` a shadow array, ignoring the LOD");
+                            write!(self.out, ", vec2(0,0), vec2(0,0)")?;
                         } else {
                             write!(self.out, ", ")?;
                             self.write_expr(expr, ctx)?;
                         }
                     }
                     crate::SampleLevel::Bias(expr) => {
                         write!(self.out, ", ")?;
                         self.write_expr(expr, ctx)?;
@@ -1707,16 +1947,21 @@ impl<'a, W: Write> Writer<'a, W> {
                     crate::SampleLevel::Gradient { x, y } => {
                         write!(self.out, ", ")?;
                         self.write_expr(x, ctx)?;
                         write!(self.out, ", ")?;
                         self.write_expr(y, ctx)?;
                     }
                 }
 
+                if let Some(constant) = offset {
+                    write!(self.out, ", ")?;
+                    self.write_constant(constant)?;
+                }
+
                 // End the function
                 write!(self.out, ")")?
             }
             // `ImageLoad` is also a bit complicated.
             // There are two functions one for sampled
             // images another for storage images, the former uses `texelFetch` and the latter uses
             // `imageLoad`.
             // Furthermore we have `index` which is always `Some` for sampled images
@@ -1735,20 +1980,22 @@ impl<'a, W: Write> Writer<'a, W> {
                         dim,
                         arrayed: _,
                         class,
                     } => (dim, class),
                     _ => unreachable!(),
                 };
 
                 let fun_name = match class {
-                    ImageClass::Sampled { .. } => "texelFetch",
-                    ImageClass::Storage(_) => "imageLoad",
+                    crate::ImageClass::Sampled { .. } => "texelFetch",
+                    crate::ImageClass::Storage { .. } => "imageLoad",
                     // TODO: Is there even a function for this?
-                    ImageClass::Depth => todo!(),
+                    crate::ImageClass::Depth { multi: _ } => {
+                        return Err(Error::Custom("TODO: depth sample loads".to_string()))
+                    }
                 };
 
                 write!(self.out, "{}(", fun_name)?;
                 self.write_expr(image, ctx)?;
                 write!(self.out, ", ")?;
                 self.write_texture_coordinates(coordinate, array_index, dim, ctx)?;
 
                 if let Some(index_expr) = index {
@@ -1757,16 +2004,18 @@ impl<'a, W: Write> Writer<'a, W> {
                 }
                 write!(self.out, ")")?;
             }
             // Query translates into one of the:
             // - textureSize/imageSize
             // - textureQueryLevels
             // - textureSamples/imageSamples
             Expression::ImageQuery { image, query } => {
+                use crate::ImageClass;
+
                 // This will only panic if the module is invalid
                 let (dim, class) = match *ctx.info[image].ty.inner_with(&self.module.types) {
                     TypeInner::Image {
                         dim,
                         arrayed: _,
                         class,
                     } => (dim, class),
                     _ => unreachable!(),
@@ -1775,121 +2024,121 @@ impl<'a, W: Write> Writer<'a, W> {
                     crate::ImageDimension::D1 => 1,
                     crate::ImageDimension::D2 => 2,
                     crate::ImageDimension::D3 => 3,
                     crate::ImageDimension::Cube => 2,
                 };
                 match query {
                     crate::ImageQuery::Size { level } => {
                         match class {
-                            ImageClass::Sampled { .. } | ImageClass::Depth => {
+                            ImageClass::Sampled { .. } | ImageClass::Depth { .. } => {
                                 write!(self.out, "textureSize(")?;
                                 self.write_expr(image, ctx)?;
                                 write!(self.out, ",")?;
                                 if let Some(expr) = level {
                                     self.write_expr(expr, ctx)?;
                                 } else {
                                     write!(self.out, "0",)?;
                                 }
                             }
-                            ImageClass::Storage(_) => {
+                            ImageClass::Storage { .. } => {
                                 write!(self.out, "imageSize(")?;
                                 self.write_expr(image, ctx)?;
                             }
                         }
                         write!(self.out, ").{}", &"xyz"[..components])?;
                     }
                     crate::ImageQuery::NumLevels => {
                         write!(self.out, "textureQueryLevels(",)?;
                         self.write_expr(image, ctx)?;
                         write!(self.out, ")",)?;
                     }
                     crate::ImageQuery::NumLayers => {
                         let fun_name = match class {
-                            ImageClass::Sampled { .. } | ImageClass::Depth => "textureSize",
-                            ImageClass::Storage(_) => "imageSize",
+                            ImageClass::Sampled { .. } | ImageClass::Depth { .. } => "textureSize",
+                            ImageClass::Storage { .. } => "imageSize",
                         };
                         write!(self.out, "{}(", fun_name)?;
                         self.write_expr(image, ctx)?;
-                        write!(self.out, ",0).{}", COMPONENTS[components])?;
+                        write!(self.out, ",0).{}", back::COMPONENTS[components])?;
                     }
                     crate::ImageQuery::NumSamples => {
                         // assumes ARB_shader_texture_image_samples
                         let fun_name = match class {
-                            ImageClass::Sampled { .. } | ImageClass::Depth => "textureSamples",
-                            ImageClass::Storage(_) => "imageSamples",
+                            ImageClass::Sampled { .. } | ImageClass::Depth { .. } => {
+                                "textureSamples"
+                            }
+                            ImageClass::Storage { .. } => "imageSamples",
                         };
                         write!(self.out, "{}(", fun_name)?;
                         self.write_expr(image, ctx)?;
                         write!(self.out, ")",)?;
                     }
                 }
-                return Err(Error::Custom("ImageQuery not implemented".to_string()));
             }
             // `Unary` is pretty straightforward
             // "-" - for `Negate`
             // "~" - for `Not` if it's an integer
             // "!" - for `Not` if it's a boolean
             //
             // We also wrap the everything in parentheses to avoid precedence issues
             Expression::Unary { op, expr } => {
+                use crate::{ScalarKind as Sk, UnaryOperator as Uo};
+
                 write!(
                     self.out,
                     "({} ",
                     match op {
-                        UnaryOperator::Negate => "-",
-                        UnaryOperator::Not =>
-                            match *ctx.info[expr].ty.inner_with(&self.module.types) {
-                                TypeInner::Scalar {
-                                    kind: ScalarKind::Sint,
-                                    ..
-                                } => "~",
-                                TypeInner::Scalar {
-                                    kind: ScalarKind::Uint,
-                                    ..
-                                } => "~",
-                                TypeInner::Scalar {
-                                    kind: ScalarKind::Bool,
-                                    ..
-                                } => "!",
-                                ref other =>
-                                    return Err(Error::Custom(format!(
-                                        "Cannot apply not to type {:?}",
-                                        other
-                                    ))),
-                            },
+                        Uo::Negate => "-",
+                        Uo::Not => match *ctx.info[expr].ty.inner_with(&self.module.types) {
+                            TypeInner::Scalar { kind: Sk::Sint, .. } => "~",
+                            TypeInner::Scalar { kind: Sk::Uint, .. } => "~",
+                            TypeInner::Scalar { kind: Sk::Bool, .. } => "!",
+                            ref other =>
+                                return Err(Error::Custom(format!(
+                                    "Cannot apply not to type {:?}",
+                                    other
+                                ))),
+                        },
                     }
                 )?;
 
                 self.write_expr(expr, ctx)?;
 
                 write!(self.out, ")")?
             }
             // `Binary` we just write `left op right`, except when dealing with
             // comparison operations on vectors as they are implemented with
             // builtin functions.
             // Once again we wrap everything in parentheses to avoid precedence issues
             Expression::Binary { op, left, right } => {
                 // Holds `Some(function_name)` if the binary operation is
                 // implemented as a function call
-                let function = if let (&TypeInner::Vector { .. }, &TypeInner::Vector { .. }) = (
-                    ctx.info[left].ty.inner_with(&self.module.types),
-                    ctx.info[right].ty.inner_with(&self.module.types),
-                ) {
-                    match op {
-                        BinaryOperator::Less => Some("lessThan"),
-                        BinaryOperator::LessEqual => Some("lessThanEqual"),
-                        BinaryOperator::Greater => Some("greaterThan"),
-                        BinaryOperator::GreaterEqual => Some("greaterThanEqual"),
-                        BinaryOperator::Equal => Some("equal"),
-                        BinaryOperator::NotEqual => Some("notEqual"),
+                use crate::{BinaryOperator as Bo, ScalarKind as Sk, TypeInner as Ti};
+
+                let left_inner = ctx.info[left].ty.inner_with(&self.module.types);
+                let right_inner = ctx.info[right].ty.inner_with(&self.module.types);
+
+                let function = match (left_inner, right_inner) {
+                    (&Ti::Vector { .. }, &Ti::Vector { .. }) => match op {
+                        Bo::Less => Some("lessThan"),
+                        Bo::LessEqual => Some("lessThanEqual"),
+                        Bo::Greater => Some("greaterThan"),
+                        Bo::GreaterEqual => Some("greaterThanEqual"),
+                        Bo::Equal => Some("equal"),
+                        Bo::NotEqual => Some("notEqual"),
                         _ => None,
-                    }
-                } else {
-                    None
+                    },
+                    _ => match (left_inner.scalar_kind(), right_inner.scalar_kind()) {
+                        (Some(Sk::Float), _) | (_, Some(Sk::Float)) => match op {
+                            Bo::Modulo => Some("mod"),
+                            _ => None,
+                        },
+                        _ => None,
+                    },
                 };
 
                 write!(self.out, "{}(", function.unwrap_or(""))?;
                 self.write_expr(left, ctx)?;
 
                 if function.is_some() {
                     write!(self.out, ",")?
                 } else {
@@ -1902,49 +2151,71 @@ impl<'a, W: Write> Writer<'a, W> {
             }
             // `Select` is written as `condition ? accept : reject`
             // We wrap everything in parentheses to avoid precedence issues
             Expression::Select {
                 condition,
                 accept,
                 reject,
             } => {
-                write!(self.out, "(")?;
-                self.write_expr(condition, ctx)?;
-                write!(self.out, " ? ")?;
-                self.write_expr(accept, ctx)?;
-                write!(self.out, " : ")?;
-                self.write_expr(reject, ctx)?;
+                let cond_ty = ctx.info[condition].ty.inner_with(&self.module.types);
+                let vec_select = if let TypeInner::Vector { .. } = *cond_ty {
+                    true
+                } else {
+                    false
+                };
+
+                // TODO: Boolean mix on desktop required GL_EXT_shader_integer_mix
+                if vec_select {
+                    write!(self.out, "mix(")?;
+                    self.write_expr(accept, ctx)?;
+                    write!(self.out, ", ")?;
+                    self.write_expr(reject, ctx)?;
+                    write!(self.out, ", ")?;
+                    self.write_expr(condition, ctx)?;
+                } else {
+                    write!(self.out, "(")?;
+                    self.write_expr(condition, ctx)?;
+                    write!(self.out, " ? ")?;
+                    self.write_expr(accept, ctx)?;
+                    write!(self.out, " : ")?;
+                    self.write_expr(reject, ctx)?;
+                }
+
                 write!(self.out, ")")?
             }
             // `Derivative` is a function call to a glsl provided function
             Expression::Derivative { axis, expr } => {
+                use crate::DerivativeAxis as Da;
+
                 write!(
                     self.out,
                     "{}(",
                     match axis {
-                        DerivativeAxis::X => "dFdx",
-                        DerivativeAxis::Y => "dFdy",
-                        DerivativeAxis::Width => "fwidth",
+                        Da::X => "dFdx",
+                        Da::Y => "dFdy",
+                        Da::Width => "fwidth",
                     }
                 )?;
                 self.write_expr(expr, ctx)?;
                 write!(self.out, ")")?
             }
             // `Relational` is a normal function call to some glsl provided functions
             Expression::Relational { fun, argument } => {
+                use crate::RelationalFunction as Rf;
+
                 let fun_name = match fun {
                     // There's no specific function for this but we can invert the result of `isinf`
-                    RelationalFunction::IsFinite => "!isinf",
-                    RelationalFunction::IsInf => "isinf",
-                    RelationalFunction::IsNan => "isnan",
+                    Rf::IsFinite => "!isinf",
+                    Rf::IsInf => "isinf",
+                    Rf::IsNan => "isnan",
                     // There's also no function for this but we can invert `isnan`
-                    RelationalFunction::IsNormal => "!isnan",
-                    RelationalFunction::All => "all",
-                    RelationalFunction::Any => "any",
+                    Rf::IsNormal => "!isnan",
+                    Rf::All => "all",
+                    Rf::Any => "any",
                 };
                 write!(self.out, "{}(", fun_name)?;
 
                 self.write_expr(argument, ctx)?;
 
                 write!(self.out, ")")?
             }
             Expression::Math {
@@ -1966,23 +2237,26 @@ impl<'a, W: Write> Writer<'a, W> {
                     Mf::Cosh => "cosh",
                     Mf::Sin => "sin",
                     Mf::Sinh => "sinh",
                     Mf::Tan => "tan",
                     Mf::Tanh => "tanh",
                     Mf::Acos => "acos",
                     Mf::Asin => "asin",
                     Mf::Atan => "atan",
+                    Mf::Asinh => "asinh",
+                    Mf::Acosh => "acosh",
+                    Mf::Atanh => "atanh",
                     // glsl doesn't have atan2 function
                     // use two-argument variation of the atan function
                     Mf::Atan2 => "atan",
                     // decomposition
                     Mf::Ceil => "ceil",
                     Mf::Floor => "floor",
-                    Mf::Round => "round",
+                    Mf::Round => "roundEven",
                     Mf::Fract => "fract",
                     Mf::Trunc => "trunc",
                     Mf::Modf => "modf",
                     Mf::Frexp => "frexp",
                     Mf::Ldexp => "ldexp",
                     // exponent
                     Mf::Exp => "exp",
                     Mf::Exp2 => "exp2",
@@ -2041,138 +2315,215 @@ impl<'a, W: Write> Writer<'a, W> {
                         // this is similar to `write_type`, but with the target kind
                         let scalar = glsl_scalar(target_kind, width)?;
                         match *inner {
                             TypeInner::Vector { size, .. } => {
                                 write!(self.out, "{}vec{}", scalar.prefix, size as u8)?
                             }
                             _ => write!(self.out, "{}", scalar.full)?,
                         }
+
+                        write!(self.out, "(")?;
+                        self.write_expr(expr, ctx)?;
+                        write!(self.out, ")")?
                     }
                     None => {
+                        use crate::ScalarKind as Sk;
+
                         let source_kind = inner.scalar_kind().unwrap();
-                        write!(
-                            self.out,
-                            "{}",
-                            match (source_kind, target_kind) {
-                                (ScalarKind::Float, ScalarKind::Sint) => "floatBitsToInt",
-                                (ScalarKind::Float, ScalarKind::Uint) => "floatBitsToUInt",
-                                (ScalarKind::Sint, ScalarKind::Float) => "intBitsToFloat",
-                                (ScalarKind::Uint, ScalarKind::Float) => "uintBitsToFloat",
-                                // There is no way to bitcast between Uint/Sint in glsl. Use constructor conversion
-                                (ScalarKind::Uint, ScalarKind::Sint) => "int",
-                                (ScalarKind::Sint, ScalarKind::Uint) => "uint",
-                                _ => {
-                                    return Err(Error::Custom(format!(
-                                        "Cannot bitcast {:?} to {:?}",
-                                        source_kind, target_kind
-                                    )));
-                                }
-                            }
-                        )?;
+                        let conv_op = match (source_kind, target_kind) {
+                            (Sk::Float, Sk::Sint) => "floatBitsToInt",
+                            (Sk::Float, Sk::Uint) => "floatBitsToUInt",
+                            (Sk::Sint, Sk::Float) => "intBitsToFloat",
+                            (Sk::Uint, Sk::Float) => "uintBitsToFloat",
+                            // There is no way to bitcast between Uint/Sint in glsl. Use constructor conversion
+                            (Sk::Uint, Sk::Sint) => "int",
+                            (Sk::Sint, Sk::Uint) => "uint",
+
+                            (Sk::Bool, Sk::Sint) => "int",
+                            (Sk::Bool, Sk::Uint) => "uint",
+                            (Sk::Bool, Sk::Float) => "float",
+
+                            (Sk::Sint, Sk::Bool) => "bool",
+                            (Sk::Uint, Sk::Bool) => "bool",
+                            (Sk::Float, Sk::Bool) => "bool",
+
+                            // No conversion needed
+                            (Sk::Sint, Sk::Sint) => "",
+                            (Sk::Uint, Sk::Uint) => "",
+                            (Sk::Float, Sk::Float) => "",
+                            (Sk::Bool, Sk::Bool) => "",
+                        };
+                        write!(self.out, "{}", conv_op)?;
+                        if !conv_op.is_empty() {
+                            write!(self.out, "(")?;
+                        }
+                        self.write_expr(expr, ctx)?;
+                        if !conv_op.is_empty() {
+                            write!(self.out, ")")?
+                        }
                     }
                 }
-
-                write!(self.out, "(")?;
-                self.write_expr(expr, ctx)?;
-                write!(self.out, ")")?
             }
-            Expression::Call(_function) => unreachable!(),
+            // These expressions never show up in `Emit`.
+            Expression::CallResult(_) | Expression::AtomicResult { .. } => unreachable!(),
             // `ArrayLength` is written as `expr.length()` and we convert it to a uint
             Expression::ArrayLength(expr) => {
                 write!(self.out, "uint(")?;
                 self.write_expr(expr, ctx)?;
                 write!(self.out, ".length())")?
             }
         }
 
         Ok(())
     }
 
     fn write_texture_coordinates(
         &mut self,
-        coordinate: Handle<Expression>,
-        array_index: Option<Handle<Expression>>,
+        coordinate: Handle<crate::Expression>,
+        array_index: Option<Handle<crate::Expression>>,
         dim: crate::ImageDimension,
-        ctx: &FunctionCtx,
+        ctx: &back::FunctionCtx,
     ) -> Result<(), Error> {
+        use crate::ImageDimension as IDim;
+
         match array_index {
             Some(layer_expr) => {
                 let tex_coord_type = match dim {
-                    crate::ImageDimension::D1 => "ivec2",
-                    crate::ImageDimension::D2 => "ivec3",
-                    crate::ImageDimension::D3 => "ivec4",
-                    crate::ImageDimension::Cube => "ivec4",
+                    IDim::D1 => "ivec2",
+                    IDim::D2 => "ivec3",
+                    IDim::D3 => "ivec4",
+                    IDim::Cube => "ivec4",
                 };
                 write!(self.out, "{}(", tex_coord_type)?;
                 self.write_expr(coordinate, ctx)?;
                 write!(self.out, ", ")?;
                 self.write_expr(layer_expr, ctx)?;
                 write!(self.out, ")")?;
             }
             None => {
                 self.write_expr(coordinate, ctx)?;
             }
         }
         Ok(())
     }
 
     fn write_named_expr(
         &mut self,
-        handle: Handle<Expression>,
+        handle: Handle<crate::Expression>,
         name: String,
-        ctx: &FunctionCtx,
+        ctx: &back::FunctionCtx,
     ) -> BackendResult {
         match ctx.info[handle].ty {
-            TypeResolution::Handle(ty_handle) => match self.module.types[ty_handle].inner {
+            proc::TypeResolution::Handle(ty_handle) => match self.module.types[ty_handle].inner {
                 TypeInner::Struct { .. } => {
                     let ty_name = &self.names[&NameKey::Type(ty_handle)];
                     write!(self.out, "{}", ty_name)?;
                 }
                 _ => {
                     self.write_type(ty_handle)?;
                 }
             },
-            TypeResolution::Value(ref inner) => {
+            proc::TypeResolution::Value(ref inner) => {
                 self.write_value_type(inner)?;
             }
         }
 
         let base_ty_res = &ctx.info[handle].ty;
         let resolved = base_ty_res.inner_with(&self.module.types);
 
-        // If rhs is a array type, we should write temp variable as a dynamic array
-        let array_str = if let TypeInner::Array { .. } = *resolved {
-            "[]"
-        } else {
-            ""
-        };
-
-        write!(self.out, " {}{} = ", name, array_str)?;
+        write!(self.out, " {}", name)?;
+        if let TypeInner::Array { size, .. } = *resolved {
+            self.write_array_size(size)?;
+        }
+        write!(self.out, " = ")?;
         self.write_expr(handle, ctx)?;
         writeln!(self.out, ";")?;
         self.named_expressions.insert(handle, name);
 
         Ok(())
     }
 
+    /// Helper function that write string with default zero initialization for supported types
+    fn write_zero_init_value(&mut self, ty: Handle<crate::Type>) -> BackendResult {
+        let inner = &self.module.types[ty].inner;
+        match *inner {
+            TypeInner::Scalar { kind, .. } => {
+                self.write_zero_init_scalar(kind)?;
+            }
+            TypeInner::Vector { size, kind, .. } => {
+                self.write_value_type(inner)?;
+                write!(self.out, "(")?;
+                for _ in 1..(size as usize) {
+                    self.write_zero_init_scalar(kind)?;
+                    write!(self.out, ", ")?;
+                }
+                // write last parameter without comma and space
+                self.write_zero_init_scalar(kind)?;
+                write!(self.out, ")")?;
+            }
+            TypeInner::Matrix { columns, rows, .. } => {
+                let number_of_components = (columns as usize) * (rows as usize);
+                self.write_value_type(inner)?;
+                write!(self.out, "(")?;
+                for _ in 1..number_of_components {
+                    // IR supports only float matrix
+                    self.write_zero_init_scalar(crate::ScalarKind::Float)?;
+                    write!(self.out, ", ")?;
+                }
+                // write last parameter without comma and space
+                self.write_zero_init_scalar(crate::ScalarKind::Float)?;
+                write!(self.out, ")")?;
+            }
+            _ => {} // TODO:
+        }
+
+        Ok(())
+    }
+
+    /// Helper function that write string with zero initialization for scalar
+    fn write_zero_init_scalar(&mut self, kind: crate::ScalarKind) -> BackendResult {
+        match kind {
+            crate::ScalarKind::Bool => write!(self.out, "false")?,
+            crate::ScalarKind::Uint => write!(self.out, "0u")?,
+            crate::ScalarKind::Float => write!(self.out, "0.0")?,
+            crate::ScalarKind::Sint => write!(self.out, "0")?,
+        }
+
+        Ok(())
+    }
+
+    /// Helper function that return the glsl storage access string of [`StorageAccess`](crate::StorageAccess)
+    ///
+    /// glsl allows adding both `readonly` and `writeonly` but this means that
+    /// they can only be used to query information about the resource which isn't what
+    /// we want here so when storage access is both `LOAD` and `STORE` add no modifiers
+    fn write_storage_access(&mut self, storage_access: crate::StorageAccess) -> BackendResult {
+        if !storage_access.contains(crate::StorageAccess::STORE) {
+            write!(self.out, "readonly ")?;
+        }
+        if !storage_access.contains(crate::StorageAccess::LOAD) {
+            write!(self.out, "writeonly ")?;
+        }
+        Ok(())
+    }
+
     /// Helper method used to produce the reflection info that's returned to the user
     ///
     /// It takes an iterator of [`Function`](crate::Function) references instead of
     /// [`Handle`](crate::arena::Handle) because [`EntryPoint`](crate::EntryPoint) isn't in any
     /// [`Arena`](crate::arena::Arena) and we need to traverse it
     fn collect_reflection_info(&self) -> Result<ReflectionInfo, Error> {
         use std::collections::hash_map::Entry;
         let info = self.info.get_entry_point(self.entry_point_idx as usize);
-        let mut mappings = FastHashMap::default();
-        let mut uniforms = FastHashMap::default();
+        let mut mappings = crate::FastHashMap::default();
+        let mut uniforms = crate::FastHashMap::default();
 
         for sampling in info.sampling_set.iter() {
-            let global = self.module.global_variables[sampling.image].clone();
-            let tex_name = self.reflection_names[&global.ty].clone();
+            let tex_name = self.reflection_names_globals[&sampling.image].clone();
 
             match mappings.entry(tex_name) {
                 Entry::Vacant(v) => {
                     v.insert(TextureMapping {
                         texture: sampling.image,
                         sampler: Some(sampling.sampler),
                     });
                 }
@@ -2186,18 +2537,18 @@ impl<'a, W: Write> Writer<'a, W> {
         }
 
         for (handle, var) in self.module.global_variables.iter() {
             if info[handle].is_empty() {
                 continue;
             }
             match self.module.types[var.ty].inner {
                 crate::TypeInner::Struct { .. } => match var.class {
-                    StorageClass::Uniform | StorageClass::Storage => {
-                        let name = self.reflection_names[&var.ty].clone();
+                    crate::StorageClass::Uniform | crate::StorageClass::Storage { .. } => {
+                        let name = self.reflection_names_uniforms[&var.ty].clone();
                         uniforms.insert(handle, name);
                     }
                     _ => (),
                 },
                 _ => continue,
             }
         }
 
@@ -2219,190 +2570,178 @@ struct ScalarString<'a> {
 }
 
 /// Helper function that returns scalar related strings
 ///
 /// Check [`ScalarString`](ScalarString) for the information provided
 ///
 /// # Errors
 /// If a [`Float`](crate::ScalarKind::Float) with an width that isn't 4 or 8
-fn glsl_scalar(kind: ScalarKind, width: Bytes) -> Result<ScalarString<'static>, Error> {
+fn glsl_scalar(
+    kind: crate::ScalarKind,
+    width: crate::Bytes,
+) -> Result<ScalarString<'static>, Error> {
+    use crate::ScalarKind as Sk;
+
     Ok(match kind {
-        ScalarKind::Sint => ScalarString {
+        Sk::Sint => ScalarString {
             prefix: "i",
             full: "int",
         },
-        ScalarKind::Uint => ScalarString {
+        Sk::Uint => ScalarString {
             prefix: "u",
             full: "uint",
         },
-        ScalarKind::Float => match width {
+        Sk::Float => match width {
             4 => ScalarString {
                 prefix: "",
                 full: "float",
             },
             8 => ScalarString {
                 prefix: "d",
                 full: "double",
             },
             _ => return Err(Error::UnsupportedScalar(kind, width)),
         },
-        ScalarKind::Bool => ScalarString {
+        Sk::Bool => ScalarString {
             prefix: "b",
             full: "bool",
         },
     })
 }
 
 /// Helper function that returns the glsl variable name for a builtin
-fn glsl_built_in(built_in: BuiltIn, output: bool) -> &'static str {
+fn glsl_built_in(built_in: crate::BuiltIn, output: bool) -> &'static str {
+    use crate::BuiltIn as Bi;
+
     match built_in {
-        BuiltIn::Position => {
+        Bi::Position => {
             if output {
                 "gl_Position"
             } else {
                 "gl_FragCoord"
             }
         }
         // vertex
-        BuiltIn::BaseInstance => "uint(gl_BaseInstance)",
-        BuiltIn::BaseVertex => "uint(gl_BaseVertex)",
-        BuiltIn::ClipDistance => "gl_ClipDistance",
-        BuiltIn::CullDistance => "gl_CullDistance",
-        BuiltIn::InstanceIndex => "uint(gl_InstanceID)",
-        BuiltIn::PointSize => "gl_PointSize",
-        BuiltIn::VertexIndex => "uint(gl_VertexID)",
+        Bi::BaseInstance => "uint(gl_BaseInstance)",
+        Bi::BaseVertex => "uint(gl_BaseVertex)",
+        Bi::ClipDistance => "gl_ClipDistance",
+        Bi::CullDistance => "gl_CullDistance",
+        Bi::InstanceIndex => "uint(gl_InstanceID)",
+        Bi::PointSize => "gl_PointSize",
+        Bi::VertexIndex => "uint(gl_VertexID)",
         // fragment
-        BuiltIn::FragDepth => "gl_FragDepth",
-        BuiltIn::FrontFacing => "gl_FrontFacing",
-        BuiltIn::SampleIndex => "gl_SampleID",
-        BuiltIn::SampleMask => {
+        Bi::FragDepth => "gl_FragDepth",
+        Bi::FrontFacing => "gl_FrontFacing",
+        Bi::PrimitiveIndex => "uint(gl_PrimitiveID)",
+        Bi::SampleIndex => "gl_SampleID",
+        Bi::SampleMask => {
             if output {
                 "gl_SampleMask"
             } else {
                 "gl_SampleMaskIn"
             }
         }
         // compute
-        BuiltIn::GlobalInvocationId => "gl_GlobalInvocationID",
-        BuiltIn::LocalInvocationId => "gl_LocalInvocationID",
-        BuiltIn::LocalInvocationIndex => "gl_LocalInvocationIndex",
-        BuiltIn::WorkGroupId => "gl_WorkGroupID",
-        BuiltIn::WorkGroupSize => "gl_WorkGroupSize",
+        Bi::GlobalInvocationId => "gl_GlobalInvocationID",
+        Bi::LocalInvocationId => "gl_LocalInvocationID",
+        Bi::LocalInvocationIndex => "gl_LocalInvocationIndex",
+        Bi::WorkGroupId => "gl_WorkGroupID",
+        Bi::WorkGroupSize => "gl_WorkGroupSize",
+        Bi::NumWorkGroups => "gl_NumWorkGroups",
     }
 }
 
 /// Helper function that returns the string corresponding to the storage class
-fn glsl_storage_class(class: StorageClass) -> Option<&'static str> {
+fn glsl_storage_class(class: crate::StorageClass) -> Option<&'static str> {
+    use crate::StorageClass as Sc;
+
     match class {
-        StorageClass::Function => None,
-        StorageClass::Private => None,
-        StorageClass::Storage => Some("buffer"),
-        StorageClass::Uniform => Some("uniform"),
-        StorageClass::Handle => Some("uniform"),
-        StorageClass::WorkGroup => Some("shared"),
-        StorageClass::PushConstant => None,
+        Sc::Function => None,
+        Sc::Private => None,
+        Sc::Storage { .. } => Some("buffer"),
+        Sc::Uniform => Some("uniform"),
+        Sc::Handle => Some("uniform"),
+        Sc::WorkGroup => Some("shared"),
+        Sc::PushConstant => None,
     }
 }
 
 /// Helper function that returns the string corresponding to the glsl interpolation qualifier
-fn glsl_interpolation(interpolation: Interpolation) -> &'static str {
+fn glsl_interpolation(interpolation: crate::Interpolation) -> &'static str {
+    use crate::Interpolation as I;
+
     match interpolation {
-        Interpolation::Perspective => "smooth",
-        Interpolation::Linear => "noperspective",
-        Interpolation::Flat => "flat",
+        I::Perspective => "smooth",
+        I::Linear => "noperspective",
+        I::Flat => "flat",
     }
 }
 
 /// Return the GLSL auxiliary qualifier for the given sampling value.
-fn glsl_sampling(sampling: Sampling) -> Option<&'static str> {
+fn glsl_sampling(sampling: crate::Sampling) -> Option<&'static str> {
+    use crate::Sampling as S;
+
     match sampling {
-        Sampling::Center => None,
-        Sampling::Centroid => Some("centroid"),
-        Sampling::Sample => Some("sample"),
+        S::Center => None,
+        S::Centroid => Some("centroid"),
+        S::Sample => Some("sample"),
     }
 }
 
 /// Helper function that returns the glsl dimension string of [`ImageDimension`](crate::ImageDimension)
 fn glsl_dimension(dim: crate::ImageDimension) -> &'static str {
+    use crate::ImageDimension as IDim;
+
     match dim {
-        crate::ImageDimension::D1 => "1D",
-        crate::ImageDimension::D2 => "2D",
-        crate::ImageDimension::D3 => "3D",
-        crate::ImageDimension::Cube => "Cube",
+        IDim::D1 => "1D",
+        IDim::D2 => "2D",
+        IDim::D3 => "3D",
+        IDim::Cube => "Cube",
     }
 }
 
 /// Helper function that returns the glsl storage format string of [`StorageFormat`](crate::StorageFormat)
-fn glsl_storage_format(format: StorageFormat) -> &'static str {
+fn glsl_storage_format(format: crate::StorageFormat) -> &'static str {
+    use crate::StorageFormat as Sf;
+
     match format {
-        StorageFormat::R8Unorm => "r8",
-        StorageFormat::R8Snorm => "r8_snorm",
-        StorageFormat::R8Uint => "r8ui",
-        StorageFormat::R8Sint => "r8i",
-        StorageFormat::R16Uint => "r16ui",
-        StorageFormat::R16Sint => "r16i",
-        StorageFormat::R16Float => "r16f",
-        StorageFormat::Rg8Unorm => "rg8",
-        StorageFormat::Rg8Snorm => "rg8_snorm",
-        StorageFormat::Rg8Uint => "rg8ui",
-        StorageFormat::Rg8Sint => "rg8i",
-        StorageFormat::R32Uint => "r32ui",
-        StorageFormat::R32Sint => "r32i",
-        StorageFormat::R32Float => "r32f",
-        StorageFormat::Rg16Uint => "rg16ui",
-        StorageFormat::Rg16Sint => "rg16i",
-        StorageFormat::Rg16Float => "rg16f",
-        StorageFormat::Rgba8Unorm => "rgba8ui",
-        StorageFormat::Rgba8Snorm => "rgba8_snorm",
-        StorageFormat::Rgba8Uint => "rgba8ui",
-        StorageFormat::Rgba8Sint => "rgba8i",
-        StorageFormat::Rgb10a2Unorm => "rgb10_a2ui",
-        StorageFormat::Rg11b10Float => "r11f_g11f_b10f",
-        StorageFormat::Rg32Uint => "rg32ui",
-        StorageFormat::Rg32Sint => "rg32i",
-        StorageFormat::Rg32Float => "rg32f",
-        StorageFormat::Rgba16Uint => "rgba16ui",
-        StorageFormat::Rgba16Sint => "rgba16i",
-        StorageFormat::Rgba16Float => "rgba16f",
-        StorageFormat::Rgba32Uint => "rgba32ui",
-        StorageFormat::Rgba32Sint => "rgba32i",
-        StorageFormat::Rgba32Float => "rgba32f",
+        Sf::R8Unorm => "r8",
+        Sf::R8Snorm => "r8_snorm",
+        Sf::R8Uint => "r8ui",
+        Sf::R8Sint => "r8i",
+        Sf::R16Uint => "r16ui",
+        Sf::R16Sint => "r16i",
+        Sf::R16Float => "r16f",
+        Sf::Rg8Unorm => "rg8",
+        Sf::Rg8Snorm => "rg8_snorm",
+        Sf::Rg8Uint => "rg8ui",
+        Sf::Rg8Sint => "rg8i",
+        Sf::R32Uint => "r32ui",
+        Sf::R32Sint => "r32i",
+        Sf::R32Float => "r32f",
+        Sf::Rg16Uint => "rg16ui",
+        Sf::Rg16Sint => "rg16i",
+        Sf::Rg16Float => "rg16f",
+        Sf::Rgba8Unorm => "rgba8ui",
+        Sf::Rgba8Snorm => "rgba8_snorm",
+        Sf::Rgba8Uint => "rgba8ui",
+        Sf::Rgba8Sint => "rgba8i",
+        Sf::Rgb10a2Unorm => "rgb10_a2ui",
+        Sf::Rg11b10Float => "r11f_g11f_b10f",
+        Sf::Rg32Uint => "rg32ui",
+        Sf::Rg32Sint => "rg32i",
+        Sf::Rg32Float => "rg32f",
+        Sf::Rgba16Uint => "rgba16ui",
+        Sf::Rgba16Sint => "rgba16i",
+        Sf::Rgba16Float => "rgba16f",
+        Sf::Rgba32Uint => "rgba32ui",
+        Sf::Rgba32Sint => "rgba32i",
+        Sf::Rgba32Float => "rgba32f",
     }
 }
 
-/// Helper function that return the glsl storage access string of [`StorageAccess`](crate::StorageAccess)
-///
-/// glsl allows adding both `readonly` and `writeonly` but this means that
-/// they can only be used to query information about the resource which isn't what
-/// we want here so when storage access is both `LOAD` and `STORE` add no modifiers
-fn glsl_storage_access(storage_access: StorageAccess) -> Option<&'static str> {
-    if storage_access == StorageAccess::LOAD {
-        Some("readonly")
-    } else if storage_access == StorageAccess::STORE {
-        Some("writeonly")
-    } else {
-        None
+fn is_value_init_supported(module: &crate::Module, ty: Handle<crate::Type>) -> bool {
+    match module.types[ty].inner {
+        TypeInner::Scalar { .. } | TypeInner::Vector { .. } | TypeInner::Matrix { .. } => true,
+        _ => false,
     }
 }
-
-/// Helper function that return string with default zero initialization for supported types
-fn zero_init_value_str(inner: &TypeInner) -> Option<String> {
-    match *inner {
-        TypeInner::Scalar { kind, .. } => match kind {
-            ScalarKind::Bool => Some(String::from("false")),
-            _ => Some(String::from("0")),
-        },
-        TypeInner::Vector { size, kind, width } => {
-            if let Ok(scalar_string) = glsl_scalar(kind, width) {
-                let vec_type = format!("{}vec{}", scalar_string.prefix, size as u8);
-                match size {
-                    crate::VectorSize::Bi => Some(format!("{}(0, 0)", vec_type)),
-                    crate::VectorSize::Tri => Some(format!("{}(0, 0, 0)", vec_type)),
-                    crate::VectorSize::Quad => Some(format!("{}(0, 0, 0, 0)", vec_type)),
-                }
-            } else {
-                None
-            }
-        }
-        _ => None,
-    }
-}