# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/msl/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/msl/mod.rs b/third_party/rust/naga/src/back/msl/mod.rs
--- a/third_party/rust/naga/src/back/msl/mod.rs
+++ b/third_party/rust/naga/src/back/msl/mod.rs
@@ -19,17 +19,20 @@ At the beginning of the entry point, we 
 the arguments as they are declared on IR side, so that the rest of the logic can
 pretend that MSL doesn't have all the restrictions it has.
 
 For the result type, if it's a structure, we re-compose it with a temporary value
 holding the result.
 !*/
 
 use crate::{arena::Handle, valid::ModuleInfo};
-use std::fmt::{Error as FmtError, Write};
+use std::{
+    fmt::{Error as FmtError, Write},
+    ops,
+};
 
 mod keywords;
 pub mod sampler;
 mod writer;
 
 pub use writer::Writer;
 
 pub type Slot = u8;
@@ -52,53 +55,59 @@ pub struct BindTarget {
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub texture: Option<Slot>,
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub sampler: Option<BindSamplerTarget>,
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub mutable: bool,
 }
 
-#[derive(Clone, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
-#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
-#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
-pub struct BindSource {
-    pub stage: crate::ShaderStage,
-    pub group: u32,
-    pub binding: u32,
-}
+// Using `BTreeMap` instead of `HashMap` so that we can hash itself.
+pub type BindingMap = std::collections::BTreeMap<crate::ResourceBinding, BindTarget>;
 
-pub type BindingMap = std::collections::BTreeMap<BindSource, BindTarget>;
-
-#[derive(Clone, Debug, Default, Hash, Eq, Ord, PartialEq, PartialOrd)]
+#[derive(Clone, Debug, Default, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct PerStageResources {
     #[cfg_attr(feature = "deserialize", serde(default))]
+    pub resources: BindingMap,
+
+    #[cfg_attr(feature = "deserialize", serde(default))]
     pub push_constant_buffer: Option<Slot>,
 
     /// The slot of a buffer that contains an array of `u32`,
     /// one for the size of each bound buffer that contains a runtime array,
     /// in order of [`crate::GlobalVariable`] declarations.
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub sizes_buffer: Option<Slot>,
 }
 
-#[derive(Clone, Debug, Default, Hash, Eq, Ord, PartialEq, PartialOrd)]
+#[derive(Clone, Debug, Default, Hash, Eq, PartialEq)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct PerStageMap {
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub vs: PerStageResources,
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub fs: PerStageResources,
     #[cfg_attr(feature = "deserialize", serde(default))]
     pub cs: PerStageResources,
 }
 
+impl ops::Index<crate::ShaderStage> for PerStageMap {
+    type Output = PerStageResources;
+    fn index(&self, stage: crate::ShaderStage) -> &PerStageResources {
+        match stage {
+            crate::ShaderStage::Vertex => &self.vs,
+            crate::ShaderStage::Fragment => &self.fs,
+            crate::ShaderStage::Compute => &self.cs,
+        }
+    }
+}
+
 enum ResolvedBinding {
     BuiltIn(crate::BuiltIn),
     Attribute(u32),
     Color(u32),
     User {
         prefix: &'static str,
         index: u32,
         interpolation: Option<ResolvedInterpolation>,
@@ -141,54 +150,51 @@ pub enum Error {
     CapabilityNotSupported(crate::valid::Capabilities),
 }
 
 #[derive(Clone, Debug, PartialEq, thiserror::Error)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub enum EntryPointError {
     #[error("mapping of {0:?} is missing")]
-    MissingBinding(BindSource),
-    #[error("mapping for push constants at stage {0:?} is missing")]
-    MissingPushConstants(crate::ShaderStage),
-    #[error("mapping for sizes buffer for stage {0:?} is missing")]
-    MissingSizesBuffer(crate::ShaderStage),
+    MissingBinding(crate::ResourceBinding),
+    #[error("mapping for push constants is missing")]
+    MissingPushConstants,
+    #[error("mapping for sizes buffer is missing")]
+    MissingSizesBuffer,
 }
 
 #[derive(Clone, Copy, Debug)]
 enum LocationMode {
     VertexInput,
     FragmentOutput,
     Intermediate,
     Uniform,
 }
 
 #[derive(Clone, Debug, Hash, PartialEq, Eq)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct Options {
     /// (Major, Minor) target version of the Metal Shading Language.
     pub lang_version: (u8, u8),
-    /// Binding model mapping to Metal.
-    pub binding_map: BindingMap,
-    /// Map of per-stage resources (e.g. push constants) to slots
+    /// Map of per-stage resources to slots.
     pub per_stage_map: PerStageMap,
     /// Samplers to be inlined into the code.
     pub inline_samplers: Vec<sampler::InlineSampler>,
     /// Make it possible to link different stages via SPIRV-Cross.
     pub spirv_cross_compatibility: bool,
     /// Don't panic on missing bindings, instead generate invalid MSL.
     pub fake_missing_bindings: bool,
 }
 
 impl Default for Options {
     fn default() -> Self {
         Options {
-            lang_version: (1, 0),
-            binding_map: BindingMap::default(),
+            lang_version: (1, 1),
             per_stage_map: PerStageMap::default(),
             inline_samplers: Vec::new(),
             spirv_cross_compatibility: false,
             fake_missing_bindings: true,
         }
     }
 }
 
@@ -252,29 +258,24 @@ impl Options {
         }
     }
 
     fn resolve_resource_binding(
         &self,
         stage: crate::ShaderStage,
         res_binding: &crate::ResourceBinding,
     ) -> Result<ResolvedBinding, EntryPointError> {
-        let source = BindSource {
-            stage,
-            group: res_binding.group,
-            binding: res_binding.binding,
-        };
-        match self.binding_map.get(&source) {
+        match self.per_stage_map[stage].resources.get(res_binding) {
             Some(target) => Ok(ResolvedBinding::Resource(target.clone())),
             None if self.fake_missing_bindings => Ok(ResolvedBinding::User {
                 prefix: "fake",
                 index: 0,
                 interpolation: None,
             }),
-            None => Err(EntryPointError::MissingBinding(source)),
+            None => Err(EntryPointError::MissingBinding(res_binding.clone())),
         }
     }
 
     fn resolve_push_constants(
         &self,
         stage: crate::ShaderStage,
     ) -> Result<ResolvedBinding, EntryPointError> {
         let slot = match stage {
@@ -289,43 +290,38 @@ impl Options {
                 sampler: None,
                 mutable: false,
             })),
             None if self.fake_missing_bindings => Ok(ResolvedBinding::User {
                 prefix: "fake",
                 index: 0,
                 interpolation: None,
             }),
-            None => Err(EntryPointError::MissingPushConstants(stage)),
+            None => Err(EntryPointError::MissingPushConstants),
         }
     }
 
     fn resolve_sizes_buffer(
         &self,
         stage: crate::ShaderStage,
     ) -> Result<ResolvedBinding, EntryPointError> {
-        let slot = match stage {
-            crate::ShaderStage::Vertex => self.per_stage_map.vs.sizes_buffer,
-            crate::ShaderStage::Fragment => self.per_stage_map.fs.sizes_buffer,
-            crate::ShaderStage::Compute => self.per_stage_map.cs.sizes_buffer,
-        };
-
+        let slot = self.per_stage_map[stage].sizes_buffer;
         match slot {
             Some(slot) => Ok(ResolvedBinding::Resource(BindTarget {
                 buffer: Some(slot),
                 texture: None,
                 sampler: None,
                 mutable: false,
             })),
             None if self.fake_missing_bindings => Ok(ResolvedBinding::User {
                 prefix: "fake",
                 index: 0,
                 interpolation: None,
             }),
-            None => Err(EntryPointError::MissingSizesBuffer(stage)),
+            None => Err(EntryPointError::MissingSizesBuffer),
         }
     }
 }
 
 impl ResolvedBinding {
     fn as_inline_sampler<'a>(&self, options: &'a Options) -> Option<&'a sampler::InlineSampler> {
         match *self {
             Self::Resource(BindTarget {
@@ -347,25 +343,27 @@ impl ResolvedBinding {
                     Bi::BaseVertex => "base_vertex",
                     Bi::ClipDistance => "clip_distance",
                     Bi::InstanceIndex => "instance_id",
                     Bi::PointSize => "point_size",
                     Bi::VertexIndex => "vertex_id",
                     // fragment
                     Bi::FragDepth => "depth(any)",
                     Bi::FrontFacing => "front_facing",
+                    Bi::PrimitiveIndex => "primitive_id",
                     Bi::SampleIndex => "sample_id",
                     Bi::SampleMask => "sample_mask",
                     // compute
                     Bi::GlobalInvocationId => "thread_position_in_grid",
                     Bi::LocalInvocationId => "thread_position_in_threadgroup",
                     Bi::LocalInvocationIndex => "thread_index_in_threadgroup",
                     Bi::WorkGroupId => "threadgroup_position_in_grid",
                     Bi::WorkGroupSize => "dispatch_threads_per_threadgroup",
-                    _ => return Err(Error::UnsupportedBuiltIn(built_in)),
+                    Bi::NumWorkGroups => "threadgroups_per_grid",
+                    Bi::CullDistance => return Err(Error::UnsupportedBuiltIn(built_in)),
                 };
                 write!(out, "{}", name)?;
             }
             Self::Attribute(index) => write!(out, "attribute({})", index)?,
             Self::Color(index) => write!(out, "color({})", index)?,
             Self::User {
                 prefix,
                 index,