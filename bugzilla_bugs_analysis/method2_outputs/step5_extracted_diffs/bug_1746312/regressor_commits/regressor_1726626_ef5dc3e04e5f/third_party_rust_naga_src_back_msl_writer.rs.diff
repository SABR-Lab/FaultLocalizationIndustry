# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/msl/writer.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/msl/writer.rs b/third_party/rust/naga/src/back/msl/writer.rs
--- a/third_party/rust/naga/src/back/msl/writer.rs
+++ b/third_party/rust/naga/src/back/msl/writer.rs
@@ -1,129 +1,133 @@
-use super::{
-    keywords::RESERVED, sampler as sm, Error, LocationMode, Options, PipelineOptions,
-    TranslationInfo,
-};
+use super::{sampler as sm, Error, LocationMode, Options, PipelineOptions, TranslationInfo};
 use crate::{
-    arena::{Arena, Handle},
-    back::vector_size_str,
-    proc::{EntryPointIndex, NameKey, Namer, TypeResolution},
-    valid::{Capabilities, FunctionInfo, GlobalUse, ModuleInfo},
-    FastHashMap,
+    arena::Handle,
+    back,
+    proc::{self, NameKey, TypeResolution},
+    valid, FastHashMap, FastHashSet,
 };
 use std::{
     fmt::{Display, Error as FmtError, Formatter, Write},
     iter,
 };
 
+/// Shorthand result used internally by the backend
+type BackendResult = Result<(), Error>;
+
 const NAMESPACE: &str = "metal";
-const INDENT: &str = "    ";
-const BAKE_PREFIX: &str = "_e";
 const WRAPPED_ARRAY_FIELD: &str = "inner";
+// This is a hack: we need to pass a pointer to an atomic,
+// but generally the backend isn't putting "&" in front of every pointer.
+// Some more general handling of pointers is needed to be implemented here.
+const ATOMIC_REFERENCE: &str = "&";
 
 #[derive(Clone)]
 struct Level(usize);
 impl Level {
     fn next(&self) -> Self {
         Level(self.0 + 1)
     }
 }
 impl Display for Level {
     fn fmt(&self, formatter: &mut Formatter<'_>) -> Result<(), FmtError> {
-        (0..self.0).try_for_each(|_| formatter.write_str(INDENT))
+        (0..self.0).try_for_each(|_| formatter.write_str(back::INDENT))
     }
 }
 
 struct TypeContext<'a> {
     handle: Handle<crate::Type>,
-    arena: &'a Arena<crate::Type>,
+    arena: &'a crate::Arena<crate::Type>,
     names: &'a FastHashMap<NameKey, String>,
     access: crate::StorageAccess,
     first_time: bool,
 }
 
 impl<'a> Display for TypeContext<'a> {
     fn fmt(&self, out: &mut Formatter<'_>) -> Result<(), FmtError> {
         let ty = &self.arena[self.handle];
         if ty.needs_alias() && !self.first_time {
             let name = &self.names[&NameKey::Type(self.handle)];
             return write!(out, "{}", name);
         }
 
         match ty.inner {
-            // work around Metal toolchain bug with `uint` typedef
-            crate::TypeInner::Scalar {
-                kind: crate::ScalarKind::Uint,
-                ..
-            } => {
-                write!(out, "metal::uint")
+            crate::TypeInner::Scalar { kind, .. } => {
+                match kind {
+                    // work around Metal toolchain bug with `uint` typedef
+                    crate::ScalarKind::Uint => write!(out, "{}::uint", NAMESPACE),
+                    _ => {
+                        let kind_str = scalar_kind_string(kind);
+                        write!(out, "{}", kind_str)
+                    }
+                }
             }
-            crate::TypeInner::Scalar { kind, .. } => {
-                write!(out, "{}", scalar_kind_string(kind))
+            crate::TypeInner::Atomic { kind, .. } => {
+                write!(out, "{}::atomic_{}", NAMESPACE, scalar_kind_string(kind))
             }
             crate::TypeInner::Vector { size, kind, .. } => {
                 write!(
                     out,
                     "{}::{}{}",
                     NAMESPACE,
                     scalar_kind_string(kind),
-                    vector_size_str(size),
+                    back::vector_size_str(size),
                 )
             }
             crate::TypeInner::Matrix { columns, rows, .. } => {
                 write!(
                     out,
                     "{}::{}{}x{}",
                     NAMESPACE,
                     scalar_kind_string(crate::ScalarKind::Float),
-                    vector_size_str(columns),
-                    vector_size_str(rows),
+                    back::vector_size_str(columns),
+                    back::vector_size_str(rows),
                 )
             }
             crate::TypeInner::Pointer { base, class } => {
                 let sub = Self {
                     handle: base,
                     first_time: false,
                     ..*self
                 };
-                let class_name = match class.get_name(self.access) {
+                let class_name = match class.to_msl_name() {
                     Some(name) => name,
                     None => return Ok(()),
                 };
                 write!(out, "{} {}&", class_name, sub)
             }
             crate::TypeInner::ValuePointer {
                 size: None,
                 kind,
                 width: _,
                 class,
             } => {
-                let class_name = match class.get_name(self.access) {
+                let class_name = match class.to_msl_name() {
                     Some(name) => name,
                     None => return Ok(()),
                 };
                 write!(out, "{} {}&", class_name, scalar_kind_string(kind),)
             }
             crate::TypeInner::ValuePointer {
                 size: Some(size),
                 kind,
                 width: _,
                 class,
             } => {
-                let class_name = match class.get_name(self.access) {
+                let class_name = match class.to_msl_name() {
                     Some(name) => name,
                     None => return Ok(()),
                 };
                 write!(
                     out,
                     "{} {}::{}{}&",
                     class_name,
                     NAMESPACE,
                     scalar_kind_string(kind),
-                    vector_size_str(size),
+                    back::vector_size_str(size),
                 )
             }
             crate::TypeInner::Array { base, .. } => {
                 let sub = Self {
                     handle: base,
                     first_time: false,
                     ..*self
                 };
@@ -147,18 +151,25 @@ impl<'a> Display for TypeContext<'a> {
                     crate::ImageClass::Sampled { kind, multi } => {
                         let (msaa_str, access) = if multi {
                             ("_ms", "read")
                         } else {
                             ("", "sample")
                         };
                         ("texture", msaa_str, kind, access)
                     }
-                    crate::ImageClass::Depth => ("depth", "", crate::ScalarKind::Float, "sample"),
-                    crate::ImageClass::Storage(format) => {
+                    crate::ImageClass::Depth { multi } => {
+                        let (msaa_str, access) = if multi {
+                            ("_ms", "read")
+                        } else {
+                            ("", "sample")
+                        };
+                        ("depth", msaa_str, crate::ScalarKind::Float, access)
+                    }
+                    crate::ImageClass::Storage { format, .. } => {
                         let access = if self
                             .access
                             .contains(crate::StorageAccess::LOAD | crate::StorageAccess::STORE)
                         {
                             "read_write"
                         } else if self.access.contains(crate::StorageAccess::STORE) {
                             "write"
                         } else if self.access.contains(crate::StorageAccess::LOAD) {
@@ -190,37 +201,48 @@ impl<'a> Display for TypeContext<'a> {
         }
     }
 }
 
 struct TypedGlobalVariable<'a> {
     module: &'a crate::Module,
     names: &'a FastHashMap<NameKey, String>,
     handle: Handle<crate::GlobalVariable>,
-    usage: GlobalUse,
+    usage: valid::GlobalUse,
     reference: bool,
 }
 
 impl<'a> TypedGlobalVariable<'a> {
-    fn try_fmt<W: Write>(&self, out: &mut W) -> Result<(), Error> {
+    fn try_fmt<W: Write>(&self, out: &mut W) -> BackendResult {
         let var = &self.module.global_variables[self.handle];
         let name = &self.names[&NameKey::GlobalVariable(self.handle)];
+
+        let storage_access = match var.class {
+            crate::StorageClass::Storage { access } => access,
+            _ => match self.module.types[var.ty].inner {
+                crate::TypeInner::Image {
+                    class: crate::ImageClass::Storage { access, .. },
+                    ..
+                } => access,
+                _ => crate::StorageAccess::default(),
+            },
+        };
         let ty_name = TypeContext {
             handle: var.ty,
             arena: &self.module.types,
             names: self.names,
-            access: var.storage_access,
+            access: storage_access,
             first_time: false,
         };
 
-        let (space, access, reference) = match var.class.get_name(var.storage_access) {
+        let (space, access, reference) = match var.class.to_msl_name() {
             Some(space) if self.reference => {
                 let access = match var.class {
                     crate::StorageClass::Private | crate::StorageClass::WorkGroup
-                        if !self.usage.contains(GlobalUse::WRITE) =>
+                        if !self.usage.contains(valid::GlobalUse::WRITE) =>
                     {
                         "const"
                     }
                     _ => "",
                 };
                 (space, access, "&")
             }
             _ => ("", "", ""),
@@ -237,17 +259,17 @@ impl<'a> TypedGlobalVariable<'a> {
             reference,
             name,
         )?)
     }
 }
 
 struct ConstantContext<'a> {
     handle: Handle<crate::Constant>,
-    arena: &'a Arena<crate::Constant>,
+    arena: &'a crate::Arena<crate::Constant>,
     names: &'a FastHashMap<NameKey, String>,
     first_time: bool,
 }
 
 impl<'a> Display for ConstantContext<'a> {
     fn fmt(&self, out: &mut Formatter<'_>) -> Result<(), FmtError> {
         let con = &self.arena[self.handle];
         if con.needs_alias() && !self.first_time {
@@ -283,35 +305,34 @@ impl<'a> Display for ConstantContext<'a>
         }
     }
 }
 
 pub struct Writer<W> {
     out: W,
     names: FastHashMap<NameKey, String>,
     named_expressions: crate::NamedExpressions,
-    namer: Namer,
+    namer: proc::Namer,
     runtime_sized_buffers: FastHashMap<Handle<crate::GlobalVariable>, usize>,
     #[cfg(test)]
-    put_expression_stack_pointers: crate::FastHashSet<*const ()>,
+    put_expression_stack_pointers: FastHashSet<*const ()>,
     #[cfg(test)]
-    put_block_stack_pointers: crate::FastHashSet<*const ()>,
+    put_block_stack_pointers: FastHashSet<*const ()>,
+    struct_member_pads: FastHashSet<(Handle<crate::Type>, u32)>,
 }
 
 fn scalar_kind_string(kind: crate::ScalarKind) -> &'static str {
     match kind {
         crate::ScalarKind::Float => "float",
         crate::ScalarKind::Sint => "int",
         crate::ScalarKind::Uint => "uint",
         crate::ScalarKind::Bool => "bool",
     }
 }
 
-const COMPONENTS: &[char] = &['x', 'y', 'z', 'w'];
-
 fn separate(need_separator: bool) -> &'static str {
     if need_separator {
         ","
     } else {
         ""
     }
 }
 
@@ -336,17 +357,17 @@ fn should_pack_struct_member(
             size: crate::VectorSize::Tri,
             width: 4,
             kind,
         } if member.offset & 0xF != 0 || is_tight => Some(kind),
         _ => None,
     }
 }
 
-fn needs_array_length(ty: Handle<crate::Type>, arena: &Arena<crate::Type>) -> bool {
+fn needs_array_length(ty: Handle<crate::Type>, arena: &crate::Arena<crate::Type>) -> bool {
     if let crate::TypeInner::Struct { ref members, .. } = arena[ty].inner {
         if let Some(member) = members.last() {
             if let crate::TypeInner::Array {
                 size: crate::ArraySize::Dynamic,
                 ..
             } = arena[member.ty].inner
             {
                 return true;
@@ -359,49 +380,50 @@ fn needs_array_length(ty: Handle<crate::
 impl crate::StorageClass {
     /// Returns true for storage classes, for which the global
     /// variables are passed in function arguments.
     /// These arguments need to be passed through any functions
     /// called from the entry point.
     fn needs_pass_through(&self) -> bool {
         match *self {
             crate::StorageClass::Uniform
-            | crate::StorageClass::Storage
+            | crate::StorageClass::Storage { .. }
             | crate::StorageClass::Private
+            | crate::StorageClass::WorkGroup
             | crate::StorageClass::PushConstant
             | crate::StorageClass::Handle => true,
-            _ => false,
+            crate::StorageClass::Function => false,
         }
     }
 
-    fn get_name(&self, access: crate::StorageAccess) -> Option<&'static str> {
-        match *self {
+    fn to_msl_name(self) -> Option<&'static str> {
+        match self {
             Self::Handle => None,
             Self::Uniform | Self::PushConstant => Some("constant"),
-            //TODO: should still be "constant" for read-only buffers
-            Self::Storage => Some(if access.contains(crate::StorageAccess::STORE) {
-                "device"
-            } else {
-                "constant"
-            }),
+            Self::Storage { access } if access.contains(crate::StorageAccess::STORE) => {
+                Some("device")
+            }
+            Self::Storage { .. } => Some("constant"),
             Self::Private | Self::Function => Some("thread"),
             Self::WorkGroup => Some("threadgroup"),
         }
     }
 }
 
 impl crate::Type {
     // Returns `true` if we need to emit an alias for this type.
     fn needs_alias(&self) -> bool {
         use crate::TypeInner as Ti;
+
         match self.inner {
             // value types are concise enough, we only alias them if they are named
             Ti::Scalar { .. }
             | Ti::Vector { .. }
             | Ti::Matrix { .. }
+            | Ti::Atomic { .. }
             | Ti::Pointer { .. }
             | Ti::ValuePointer { .. } => self.name.is_some(),
             // composite types are better to be aliased, regardless of the name
             Ti::Struct { .. } | Ti::Array { .. } => true,
             // handle types may be different, depending on the global var access, so we always inline them
             Ti::Image { .. } | Ti::Sampler { .. } => false,
         }
     }
@@ -414,65 +436,66 @@ impl crate::Constant {
             crate::ConstantInner::Scalar { .. } => self.name.is_some(),
             crate::ConstantInner::Composite { .. } => true,
         }
     }
 }
 
 enum FunctionOrigin {
     Handle(Handle<crate::Function>),
-    EntryPoint(EntryPointIndex),
+    EntryPoint(proc::EntryPointIndex),
 }
 
 struct ExpressionContext<'a> {
     function: &'a crate::Function,
     origin: FunctionOrigin,
-    info: &'a FunctionInfo,
+    info: &'a valid::FunctionInfo,
     module: &'a crate::Module,
     pipeline_options: &'a PipelineOptions,
 }
 
 impl<'a> ExpressionContext<'a> {
     fn resolve_type(&self, handle: Handle<crate::Expression>) -> &'a crate::TypeInner {
         self.info[handle].ty.inner_with(&self.module.types)
     }
 }
 
 struct StatementContext<'a> {
     expression: ExpressionContext<'a>,
-    mod_info: &'a ModuleInfo,
+    mod_info: &'a valid::ModuleInfo,
     result_struct: Option<&'a str>,
 }
 
 impl<W: Write> Writer<W> {
     /// Creates a new `Writer` instance.
     pub fn new(out: W) -> Self {
         Writer {
             out,
             names: FastHashMap::default(),
             named_expressions: crate::NamedExpressions::default(),
-            namer: Namer::default(),
+            namer: proc::Namer::default(),
             runtime_sized_buffers: FastHashMap::default(),
             #[cfg(test)]
             put_expression_stack_pointers: Default::default(),
             #[cfg(test)]
             put_block_stack_pointers: Default::default(),
+            struct_member_pads: FastHashSet::default(),
         }
     }
 
     /// Finishes writing and returns the output.
     pub fn finish(self) -> W {
         self.out
     }
 
     fn put_call_parameters(
         &mut self,
         parameters: impl Iterator<Item = Handle<crate::Expression>>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         write!(self.out, "(")?;
         for (i, handle) in parameters.enumerate() {
             if i != 0 {
                 write!(self.out, ", ")?;
             }
             self.put_expression(handle, context, true)?;
         }
         write!(self.out, ")")?;
@@ -480,32 +503,32 @@ impl<W: Write> Writer<W> {
     }
 
     fn put_image_query(
         &mut self,
         image: Handle<crate::Expression>,
         query: &str,
         level: Option<Handle<crate::Expression>>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         self.put_expression(image, context, false)?;
         write!(self.out, ".get_{}(", query)?;
         if let Some(expr) = level {
             self.put_expression(expr, context, true)?;
         }
         write!(self.out, ")")?;
         Ok(())
     }
 
     fn put_image_size_query(
         &mut self,
         image: Handle<crate::Expression>,
         level: Option<Handle<crate::Expression>>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         //Note: MSL only has separate width/height/depth queries,
         // so compose the result of them.
         let dim = match *context.resolve_type(image) {
             crate::TypeInner::Image { dim, .. } => dim,
             ref other => unreachable!("Unexpected type {:?}", other),
         };
         match dim {
             crate::ImageDimension::D1 => {
@@ -525,47 +548,47 @@ impl<W: Write> Writer<W> {
                 self.put_image_query(image, "width", level, context)?;
                 write!(self.out, ", ")?;
                 self.put_image_query(image, "height", level, context)?;
                 write!(self.out, ", ")?;
                 self.put_image_query(image, "depth", level, context)?;
                 write!(self.out, ")")?;
             }
             crate::ImageDimension::Cube => {
-                write!(self.out, "int3(")?;
+                write!(self.out, "int2(")?;
                 self.put_image_query(image, "width", level, context)?;
                 write!(self.out, ")")?;
             }
         }
         Ok(())
     }
 
     fn put_storage_image_coordinate(
         &mut self,
         expr: Handle<crate::Expression>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         // coordinates in IR are int, but Metal expects uint
         let size_str = match *context.info[expr].ty.inner_with(&context.module.types) {
             crate::TypeInner::Scalar { .. } => "",
-            crate::TypeInner::Vector { size, .. } => vector_size_str(size),
+            crate::TypeInner::Vector { size, .. } => back::vector_size_str(size),
             _ => return Err(Error::Validation),
         };
         write!(self.out, "{}::uint{}(", NAMESPACE, size_str)?;
         self.put_expression(expr, context, true)?;
         write!(self.out, ")")?;
         Ok(())
     }
 
     fn put_image_sample_level(
         &mut self,
         image: Handle<crate::Expression>,
         level: crate::SampleLevel,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         let has_levels = match *context.resolve_type(image) {
             crate::TypeInner::Image {
                 dim: crate::ImageDimension::D1,
                 ..
             } => false,
             _ => true,
         };
         match level {
@@ -582,79 +605,83 @@ impl<W: Write> Writer<W> {
                 write!(self.out, ")")?;
             }
             crate::SampleLevel::Bias(h) => {
                 write!(self.out, ", {}::bias(", NAMESPACE)?;
                 self.put_expression(h, context, true)?;
                 write!(self.out, ")")?;
             }
             crate::SampleLevel::Gradient { x, y } => {
-                write!(self.out, ", {}::gradient(", NAMESPACE)?;
+                write!(self.out, ", {}::gradient2d(", NAMESPACE)?;
                 self.put_expression(x, context, true)?;
                 write!(self.out, ", ")?;
                 self.put_expression(y, context, true)?;
                 write!(self.out, ")")?;
             }
         }
         Ok(())
     }
 
     fn put_compose(
         &mut self,
         ty: Handle<crate::Type>,
         components: &[Handle<crate::Expression>],
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         match context.module.types[ty].inner {
             crate::TypeInner::Scalar { width: 4, kind } if components.len() == 1 => {
                 write!(self.out, "{}", scalar_kind_string(kind))?;
                 self.put_call_parameters(components.iter().cloned(), context)?;
             }
             crate::TypeInner::Vector { size, kind, .. } => {
                 write!(
                     self.out,
                     "{}::{}{}",
                     NAMESPACE,
                     scalar_kind_string(kind),
-                    vector_size_str(size)
+                    back::vector_size_str(size)
                 )?;
                 self.put_call_parameters(components.iter().cloned(), context)?;
             }
             crate::TypeInner::Matrix { columns, rows, .. } => {
                 let kind = crate::ScalarKind::Float;
                 write!(
                     self.out,
                     "{}::{}{}x{}",
                     NAMESPACE,
                     scalar_kind_string(kind),
-                    vector_size_str(columns),
-                    vector_size_str(rows)
+                    back::vector_size_str(columns),
+                    back::vector_size_str(rows)
                 )?;
                 self.put_call_parameters(components.iter().cloned(), context)?;
             }
             crate::TypeInner::Array { .. } | crate::TypeInner::Struct { .. } => {
                 write!(self.out, "{} {{", &self.names[&NameKey::Type(ty)])?;
-                for (i, &component) in components.iter().enumerate() {
-                    if i != 0 {
+                for (index, &component) in components.iter().enumerate() {
+                    if index != 0 {
                         write!(self.out, ", ")?;
                     }
+                    // insert padding initialization, if needed
+                    if self.struct_member_pads.contains(&(ty, index as u32)) {
+                        write!(self.out, "{{}}, ")?;
+                    }
                     self.put_expression(component, context, true)?;
                 }
                 write!(self.out, "}}")?;
             }
             _ => return Err(Error::UnsupportedCompose(ty)),
         }
         Ok(())
     }
 
     fn put_array_length(
         &mut self,
         expr: Handle<crate::Expression>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         let handle = match context.function.expressions[expr] {
             crate::Expression::AccessIndex { base, .. } => {
                 match context.function.expressions[base] {
                     crate::Expression::GlobalVariable(handle) => handle,
                     _ => return Err(Error::Validation),
                 }
             }
             _ => return Err(Error::Validation),
@@ -692,22 +719,41 @@ impl<W: Write> Writer<W> {
             } else {
                 Err(Error::Validation)
             }
         } else {
             Err(Error::Validation)
         }
     }
 
+    fn put_atomic_fetch(
+        &mut self,
+        pointer: Handle<crate::Expression>,
+        key: &str,
+        value: Handle<crate::Expression>,
+        context: &ExpressionContext,
+    ) -> BackendResult {
+        write!(
+            self.out,
+            "{}::atomic_fetch_{}_explicit({}",
+            NAMESPACE, key, ATOMIC_REFERENCE
+        )?;
+        self.put_expression(pointer, context, true)?;
+        write!(self.out, ", ")?;
+        self.put_expression(value, context, true)?;
+        write!(self.out, ", {}::memory_order_relaxed)", NAMESPACE)?;
+        Ok(())
+    }
+
     fn put_expression(
         &mut self,
         expr_handle: Handle<crate::Expression>,
         context: &ExpressionContext,
         is_scoped: bool,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         // Add to the set in order to track the stack size.
         #[cfg(test)]
         #[allow(trivial_casts)]
         self.put_expression_stack_pointers
             .insert(&expr_handle as *const _ as *const ());
 
         if let Some(name) = self.named_expressions.get(&expr_handle) {
             write!(self.out, "{}", name)?;
@@ -754,24 +800,27 @@ impl<W: Write> Writer<W> {
                 };
                 match *resolved {
                     crate::TypeInner::Struct { .. } => {
                         let base_ty = base_ty_handle.unwrap();
                         let name = &self.names[&NameKey::StructMember(base_ty, index)];
                         write!(self.out, ".{}", name)?;
                     }
                     crate::TypeInner::ValuePointer { .. } | crate::TypeInner::Vector { .. } => {
-                        write!(self.out, ".{}", COMPONENTS[index as usize])?;
+                        write!(self.out, ".{}", back::COMPONENTS[index as usize])?;
                     }
-                    crate::TypeInner::Matrix { .. } => {
+                    crate::TypeInner::Array {
+                        size: crate::ArraySize::Constant(_),
+                        ..
+                    } => {
+                        write!(self.out, ".{}[{}]", WRAPPED_ARRAY_FIELD, index)?;
+                    }
+                    crate::TypeInner::Array { .. } | crate::TypeInner::Matrix { .. } => {
                         write!(self.out, "[{}]", index)?;
                     }
-                    crate::TypeInner::Array { .. } => {
-                        write!(self.out, ".{}[{}]", WRAPPED_ARRAY_FIELD, index)?;
-                    }
                     _ => {
                         // unexpected indexing, should fail validation
                     }
                 }
             }
             crate::Expression::Constant(handle) => {
                 let coco = ConstantContext {
                     handle,
@@ -782,31 +831,31 @@ impl<W: Write> Writer<W> {
                 write!(self.out, "{}", coco)?;
             }
             crate::Expression::Splat { size, value } => {
                 let scalar_kind = match *context.resolve_type(value) {
                     crate::TypeInner::Scalar { kind, .. } => kind,
                     _ => return Err(Error::Validation),
                 };
                 let scalar = scalar_kind_string(scalar_kind);
-                let size = vector_size_str(size);
+                let size = back::vector_size_str(size);
 
                 write!(self.out, "{}::{}{}(", NAMESPACE, scalar, size)?;
                 self.put_expression(value, context, true)?;
                 write!(self.out, ")")?;
             }
             crate::Expression::Swizzle {
                 size,
                 vector,
                 pattern,
             } => {
                 self.put_expression(vector, context, false)?;
                 write!(self.out, ".")?;
                 for &sc in pattern[..size as usize].iter() {
-                    write!(self.out, "{}", COMPONENTS[sc as usize])?;
+                    write!(self.out, "{}", back::COMPONENTS[sc as usize])?;
                 }
             }
             crate::Expression::Compose { ty, ref components } => {
                 self.put_compose(ty, components, context)?;
             }
             crate::Expression::FunctionArgument(index) => {
                 let name_key = match context.origin {
                     FunctionOrigin::Handle(handle) => NameKey::FunctionArgument(handle, index),
@@ -833,48 +882,63 @@ impl<W: Write> Writer<W> {
                 let name = &self.names[&name_key];
                 write!(self.out, "{}", name)?;
             }
             crate::Expression::Load { pointer } => {
                 // Because packed vectors such as `packed_float3` cannot be directly multipied by
                 // matrices, we wrap them with `float3` on load.
                 let wrap_packed_vec_scalar_kind = match context.function.expressions[pointer] {
                     crate::Expression::AccessIndex { base, index } => {
-                        let ty = match context.resolve_type(base) {
-                            &crate::TypeInner::Pointer { base, .. } => {
+                        let ty = match *context.resolve_type(base) {
+                            crate::TypeInner::Pointer { base, .. } => {
                                 &context.module.types[base].inner
                             }
-                            // This path is unexpected and shouldn't happen, but it's easier
-                            // to leave in.
-                            ty => ty,
+                            ref ty => ty,
                         };
                         match *ty {
                             crate::TypeInner::Struct {
                                 ref members, span, ..
                             } => should_pack_struct_member(
                                 members,
                                 span,
                                 index as usize,
                                 context.module,
                             ),
                             _ => None,
                         }
                     }
                     _ => None,
                 };
+                let is_atomic = match *context.resolve_type(pointer) {
+                    crate::TypeInner::Pointer { base, .. } => {
+                        match context.module.types[base].inner {
+                            crate::TypeInner::Atomic { .. } => true,
+                            _ => false,
+                        }
+                    }
+                    _ => false,
+                };
 
                 if let Some(scalar_kind) = wrap_packed_vec_scalar_kind {
                     write!(
                         self.out,
                         "{}::{}3(",
                         NAMESPACE,
                         scalar_kind_string(scalar_kind)
                     )?;
                     self.put_expression(pointer, context, true)?;
                     write!(self.out, ")")?;
+                } else if is_atomic {
+                    write!(
+                        self.out,
+                        "{}::atomic_load_explicit({}",
+                        NAMESPACE, ATOMIC_REFERENCE
+                    )?;
+                    self.put_expression(pointer, context, true)?;
+                    write!(self.out, ", {}::memory_order_relaxed)", NAMESPACE)?;
                 } else {
                     // We don't do any dereferencing with `*` here as pointer arguments to functions
                     // are done by `&` references and not `*` pointers. These do not need to be
                     // dereferenced.
                     self.put_expression(pointer, context, is_scoped)?;
                 }
             }
             crate::Expression::ImageSample {
@@ -1071,20 +1135,23 @@ impl<W: Write> Writer<W> {
                     Mf::Sin => "sin",
                     Mf::Sinh => "sinh",
                     Mf::Tan => "tan",
                     Mf::Tanh => "tanh",
                     Mf::Acos => "acos",
                     Mf::Asin => "asin",
                     Mf::Atan => "atan",
                     Mf::Atan2 => "atan2",
+                    Mf::Asinh => "asinh",
+                    Mf::Acosh => "acosh",
+                    Mf::Atanh => "atanh",
                     // decomposition
                     Mf::Ceil => "ceil",
                     Mf::Floor => "floor",
-                    Mf::Round => "round",
+                    Mf::Round => "rint",
                     Mf::Fract => "fract",
                     Mf::Trunc => "trunc",
                     Mf::Modf => "modf",
                     Mf::Frexp => "frexp",
                     Mf::Ldexp => "ldexp",
                     // exponent
                     Mf::Exp => "exp",
                     Mf::Exp2 => "exp2",
@@ -1132,47 +1199,51 @@ impl<W: Write> Writer<W> {
             crate::Expression::As {
                 expr,
                 kind,
                 convert,
             } => {
                 let scalar = scalar_kind_string(kind);
                 let (size, width) = match *context.resolve_type(expr) {
                     crate::TypeInner::Scalar { width, .. } => ("", width),
-                    crate::TypeInner::Vector { size, width, .. } => (vector_size_str(size), width),
+                    crate::TypeInner::Vector { size, width, .. } => {
+                        (back::vector_size_str(size), width)
+                    }
                     _ => return Err(Error::Validation),
                 };
                 let op = match convert {
                     Some(w) if w == width => "static_cast",
                     Some(8) if kind == crate::ScalarKind::Float => {
-                        return Err(Error::CapabilityNotSupported(Capabilities::FLOAT64))
+                        return Err(Error::CapabilityNotSupported(valid::Capabilities::FLOAT64))
                     }
                     Some(_) => return Err(Error::Validation),
                     None => "as_type",
                 };
                 write!(self.out, "{}<{}{}>(", op, scalar, size)?;
                 self.put_expression(expr, context, true)?;
                 write!(self.out, ")")?;
             }
             // has to be a named expression
-            crate::Expression::Call(_) => unreachable!(),
+            crate::Expression::CallResult(_) | crate::Expression::AtomicResult { .. } => {
+                unreachable!()
+            }
             crate::Expression::ArrayLength(expr) => {
                 self.put_array_length(expr, context)?;
             }
         }
         Ok(())
     }
 
     fn put_return_value(
         &mut self,
         level: Level,
         expr_handle: Handle<crate::Expression>,
         result_struct: Option<&str>,
         context: &ExpressionContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         match result_struct {
             Some(struct_name) => {
                 let result_ty = context.function.result.as_ref().unwrap().ty;
                 match context.module.types[result_ty].inner {
                     crate::TypeInner::Struct { ref members, .. } => {
                         let tmp = "_tmp";
                         write!(self.out, "{}const auto {} = ", level, tmp)?;
                         self.put_expression(expr_handle, context, true)?;
@@ -1239,17 +1310,17 @@ impl<W: Write> Writer<W> {
         Ok(())
     }
 
     fn start_baking_expression(
         &mut self,
         handle: Handle<crate::Expression>,
         context: &ExpressionContext,
         name: &str,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         match context.info[handle].ty {
             TypeResolution::Handle(ty_handle) => {
                 let ty_name = TypeContext {
                     handle: ty_handle,
                     arena: &context.module.types,
                     names: &self.names,
                     access: crate::StorageAccess::empty(),
                     first_time: false,
@@ -1260,27 +1331,27 @@ impl<W: Write> Writer<W> {
                 write!(self.out, "{}", scalar_kind_string(kind))?;
             }
             TypeResolution::Value(crate::TypeInner::Vector { size, kind, .. }) => {
                 write!(
                     self.out,
                     "{}::{}{}",
                     NAMESPACE,
                     scalar_kind_string(kind),
-                    vector_size_str(size)
+                    back::vector_size_str(size)
                 )?;
             }
             TypeResolution::Value(crate::TypeInner::Matrix { columns, rows, .. }) => {
                 write!(
                     self.out,
                     "{}::{}{}x{}",
                     NAMESPACE,
                     scalar_kind_string(crate::ScalarKind::Float),
-                    vector_size_str(columns),
-                    vector_size_str(rows),
+                    back::vector_size_str(columns),
+                    back::vector_size_str(rows),
                 )?;
             }
             TypeResolution::Value(ref other) => {
                 log::error!("Type {:?} isn't a known local", other);
                 return Err(Error::FeatureNotImplemented("weird local type".to_string()));
             }
         }
 
@@ -1290,17 +1361,17 @@ impl<W: Write> Writer<W> {
         Ok(())
     }
 
     fn put_block(
         &mut self,
         level: Level,
         statements: &[crate::Statement],
         context: &StatementContext,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         // Add to the set in order to track the stack size.
         #[cfg(test)]
         #[allow(trivial_casts)]
         self.put_block_stack_pointers
             .insert(&level as *const _ as *const ());
 
         for statement in statements {
             log::trace!("statement[{}] {:?}", level.0, statement);
@@ -1314,17 +1385,17 @@ impl<W: Write> Writer<W> {
                             // But we write them to step by step. We need to recache them
                             // Otherwise, we could accidentally write variable name instead of full expression.
                             // Also, we use sanitized names! It defense backend from generating variable with name from reserved keywords.
                             Some(self.namer.call_unique(name))
                         } else {
                             let min_ref_count =
                                 context.expression.function.expressions[handle].bake_ref_count();
                             if min_ref_count <= context.expression.info[handle].ref_count {
-                                Some(format!("{}{}", BAKE_PREFIX, handle.index()))
+                                Some(format!("{}{}", back::BAKE_PREFIX, handle.index()))
                             } else {
                                 None
                             }
                         };
 
                         if let Some(name) = expr_name {
                             write!(self.out, "{}", level)?;
                             self.start_baking_expression(handle, &context.expression, &name)?;
@@ -1440,49 +1511,58 @@ impl<W: Write> Writer<W> {
                         writeln!(
                             self.out,
                             "{}{}::threadgroup_barrier({}::mem_flags::mem_threadgroup);",
                             level, NAMESPACE, NAMESPACE,
                         )?;
                     }
                 }
                 crate::Statement::Store { pointer, value } => {
-                    // we can't assign fixed-size arrays
                     let pointer_info = &context.expression.info[pointer];
-                    let array_size =
+                    let (array_size, is_atomic) =
                         match *pointer_info.ty.inner_with(&context.expression.module.types) {
                             crate::TypeInner::Pointer { base, .. } => {
                                 match context.expression.module.types[base].inner {
                                     crate::TypeInner::Array {
                                         size: crate::ArraySize::Constant(ch),
                                         ..
-                                    } => Some(ch),
-                                    _ => None,
+                                    } => (Some(ch), false),
+                                    crate::TypeInner::Atomic { .. } => (None, true),
+                                    _ => (None, false),
                                 }
                             }
-                            _ => None,
+                            _ => (None, false),
                         };
-                    match array_size {
-                        Some(const_handle) => {
-                            let size = context.expression.module.constants[const_handle]
-                                .to_array_length()
-                                .unwrap();
-                            write!(self.out, "{}for(int _i=0; _i<{}; ++_i) ", level, size)?;
-                            self.put_expression(pointer, &context.expression, true)?;
-                            write!(self.out, ".{}[_i] = ", WRAPPED_ARRAY_FIELD)?;
-                            self.put_expression(value, &context.expression, true)?;
-                            writeln!(self.out, ".{}[_i];", WRAPPED_ARRAY_FIELD)?;
-                        }
-                        None => {
-                            write!(self.out, "{}", level)?;
-                            self.put_expression(pointer, &context.expression, true)?;
-                            write!(self.out, " = ")?;
-                            self.put_expression(value, &context.expression, true)?;
-                            writeln!(self.out, ";")?;
-                        }
+
+                    // we can't assign fixed-size arrays
+                    if let Some(const_handle) = array_size {
+                        let size = context.expression.module.constants[const_handle]
+                            .to_array_length()
+                            .unwrap();
+                        write!(self.out, "{}for(int _i=0; _i<{}; ++_i) ", level, size)?;
+                        self.put_expression(pointer, &context.expression, true)?;
+                        write!(self.out, ".{}[_i] = ", WRAPPED_ARRAY_FIELD)?;
+                        self.put_expression(value, &context.expression, true)?;
+                        writeln!(self.out, ".{}[_i];", WRAPPED_ARRAY_FIELD)?;
+                    } else if is_atomic {
+                        write!(
+                            self.out,
+                            "{}{}::atomic_store_explicit({}",
+                            level, NAMESPACE, ATOMIC_REFERENCE
+                        )?;
+                        self.put_expression(pointer, &context.expression, true)?;
+                        write!(self.out, ", ")?;
+                        self.put_expression(value, &context.expression, true)?;
+                        writeln!(self.out, ", {}::memory_order_relaxed);", NAMESPACE)?;
+                    } else {
+                        write!(self.out, "{}", level)?;
+                        self.put_expression(pointer, &context.expression, true)?;
+                        write!(self.out, " = ")?;
+                        self.put_expression(value, &context.expression, true)?;
+                        writeln!(self.out, ";")?;
                     }
                 }
                 crate::Statement::ImageStore {
                     image,
                     coordinate,
                     array_index,
                     value,
                 } => {
@@ -1500,17 +1580,17 @@ impl<W: Write> Writer<W> {
                 }
                 crate::Statement::Call {
                     function,
                     ref arguments,
                     result,
                 } => {
                     write!(self.out, "{}", level)?;
                     if let Some(expr) = result {
-                        let name = format!("{}{}", BAKE_PREFIX, expr.index());
+                        let name = format!("{}{}", back::BAKE_PREFIX, expr.index());
                         self.start_baking_expression(expr, &context.expression, &name)?;
                         self.named_expressions.insert(expr, name);
                     }
                     let fun_name = &self.names[&NameKey::Function(function)];
                     write!(self.out, "{}(", fun_name)?;
                     // first, write down the actual arguments
                     for (i, &handle) in arguments.iter().enumerate() {
                         if i != 0 {
@@ -1543,16 +1623,65 @@ impl<W: Write> Writer<W> {
                             write!(self.out, ", ")?;
                         }
                         write!(self.out, "_buffer_sizes")?;
                     }
 
                     // done
                     writeln!(self.out, ");")?;
                 }
+                crate::Statement::Atomic {
+                    pointer,
+                    ref fun,
+                    value,
+                    result,
+                } => {
+                    write!(self.out, "{}", level)?;
+                    let res_name = format!("{}{}", back::BAKE_PREFIX, result.index());
+                    self.start_baking_expression(result, &context.expression, &res_name)?;
+                    self.named_expressions.insert(result, res_name);
+                    match *fun {
+                        crate::AtomicFunction::Add => {
+                            self.put_atomic_fetch(pointer, "add", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::And => {
+                            self.put_atomic_fetch(pointer, "and", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::InclusiveOr => {
+                            self.put_atomic_fetch(pointer, "or", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::ExclusiveOr => {
+                            self.put_atomic_fetch(pointer, "xor", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::Min => {
+                            self.put_atomic_fetch(pointer, "min", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::Max => {
+                            self.put_atomic_fetch(pointer, "max", value, &context.expression)?;
+                        }
+                        crate::AtomicFunction::Exchange { compare: None } => {
+                            write!(
+                                self.out,
+                                "{}::atomic_exchange_explicit({}",
+                                NAMESPACE, ATOMIC_REFERENCE,
+                            )?;
+                            self.put_expression(pointer, &context.expression, true)?;
+                            write!(self.out, ", ")?;
+                            self.put_expression(value, &context.expression, true)?;
+                            write!(self.out, ", {}::memory_order_relaxed)", NAMESPACE)?;
+                        }
+                        crate::AtomicFunction::Exchange { .. } => {
+                            return Err(Error::FeatureNotImplemented(
+                                "atomic CompareExchange".to_string(),
+                            ));
+                        }
+                    }
+                    // done
+                    writeln!(self.out, ";")?;
+                }
             }
         }
 
         // un-emit expressions
         //TODO: take care of loop/continuing?
         for statement in statements {
             if let crate::Statement::Emit(ref range) = *statement {
                 for handle in range.clone() {
@@ -1561,24 +1690,31 @@ impl<W: Write> Writer<W> {
             }
         }
         Ok(())
     }
 
     pub fn write(
         &mut self,
         module: &crate::Module,
-        info: &ModuleInfo,
+        info: &valid::ModuleInfo,
         options: &Options,
         pipeline_options: &PipelineOptions,
     ) -> Result<TranslationInfo, Error> {
         self.names.clear();
-        self.namer.reset(module, RESERVED, &[], &mut self.names);
+        self.namer
+            .reset(module, super::keywords::RESERVED, &[], &mut self.names);
         self.runtime_sized_buffers.clear();
+        self.struct_member_pads.clear();
 
+        writeln!(
+            self.out,
+            "// language: metal{}.{}",
+            options.lang_version.0, options.lang_version.1
+        )?;
         writeln!(self.out, "#include <metal_stdlib>")?;
         writeln!(self.out, "#include <simd/simd.h>")?;
         writeln!(self.out)?;
 
         {
             let mut indices = vec![];
             for (handle, var) in module.global_variables.iter() {
                 if needs_array_length(var.ty, &module.types) {
@@ -1587,31 +1723,31 @@ impl<W: Write> Writer<W> {
                     indices.push(idx);
                 }
             }
 
             if !indices.is_empty() {
                 writeln!(self.out, "struct _mslBufferSizes {{")?;
 
                 for idx in indices {
-                    writeln!(self.out, "{}{}::uint size{};", INDENT, NAMESPACE, idx)?;
+                    writeln!(self.out, "{}{}::uint size{};", back::INDENT, NAMESPACE, idx)?;
                 }
 
                 writeln!(self.out, "}};")?;
                 writeln!(self.out)?;
             }
         };
 
         self.write_scalar_constants(module)?;
         self.write_type_defs(module)?;
         self.write_composite_constants(module)?;
         self.write_functions(module, info, options, pipeline_options)
     }
 
-    fn write_type_defs(&mut self, module: &crate::Module) -> Result<(), Error> {
+    fn write_type_defs(&mut self, module: &crate::Module) -> BackendResult {
         for (handle, ty) in module.types.iter() {
             if !ty.needs_alias() {
                 continue;
             }
             let name = &self.names[&NameKey::Type(handle)];
             match ty.inner {
                 crate::TypeInner::Array {
                     base,
@@ -1634,62 +1770,71 @@ impl<W: Write> Writer<W> {
                                 names: &self.names,
                                 first_time: false,
                             };
 
                             writeln!(self.out, "struct {} {{", name)?;
                             writeln!(
                                 self.out,
                                 "{}{} {}[{}];",
-                                INDENT, base_name, WRAPPED_ARRAY_FIELD, coco
+                                back::INDENT,
+                                base_name,
+                                WRAPPED_ARRAY_FIELD,
+                                coco
                             )?;
                             writeln!(self.out, "}};")?;
                         }
                         crate::ArraySize::Dynamic => {
                             writeln!(self.out, "typedef {} {}[1];", base_name, name)?;
                         }
                     }
                 }
                 crate::TypeInner::Struct {
                     ref members, span, ..
                 } => {
                     writeln!(self.out, "struct {} {{", name)?;
                     let mut last_offset = 0;
                     for (index, member) in members.iter().enumerate() {
                         // quick and dirty way to figure out if we need this...
                         if member.binding.is_none() && member.offset > last_offset {
+                            self.struct_member_pads.insert((handle, index as u32));
                             let pad = member.offset - last_offset;
-                            //TODO: adjust the struct initializers
-                            writeln!(self.out, "{}char _pad{}[{}];", INDENT, index, pad)?;
+                            writeln!(self.out, "{}char _pad{}[{}];", back::INDENT, index, pad)?;
                         }
                         let ty_inner = &module.types[member.ty].inner;
                         last_offset = member.offset + ty_inner.span(&module.constants);
 
                         let member_name = &self.names[&NameKey::StructMember(handle, index as u32)];
 
                         // If the member should be packed (as is the case for a misaligned vec3) issue a packed vector
                         match should_pack_struct_member(members, span, index, module) {
                             Some(kind) => {
                                 writeln!(
                                     self.out,
                                     "{}packed_{}3 {};",
-                                    INDENT,
+                                    back::INDENT,
                                     scalar_kind_string(kind),
                                     member_name
                                 )?;
                             }
                             None => {
                                 let base_name = TypeContext {
                                     handle: member.ty,
                                     arena: &module.types,
                                     names: &self.names,
                                     access: crate::StorageAccess::empty(),
                                     first_time: false,
                                 };
-                                writeln!(self.out, "{}{} {};", INDENT, base_name, member_name)?;
+                                writeln!(
+                                    self.out,
+                                    "{}{} {};",
+                                    back::INDENT,
+                                    base_name,
+                                    member_name
+                                )?;
 
                                 // for 3-component vectors, add one component
                                 if let crate::TypeInner::Vector {
                                     size: crate::VectorSize::Tri,
                                     kind: _,
                                     width,
                                 } = *ty_inner
                                 {
@@ -1710,17 +1855,17 @@ impl<W: Write> Writer<W> {
                     };
                     writeln!(self.out, "typedef {} {};", ty_name, name)?;
                 }
             }
         }
         Ok(())
     }
 
-    fn write_scalar_constants(&mut self, module: &crate::Module) -> Result<(), Error> {
+    fn write_scalar_constants(&mut self, module: &crate::Module) -> BackendResult {
         for (handle, constant) in module.constants.iter() {
             match constant.inner {
                 crate::ConstantInner::Scalar {
                     width: _,
                     ref value,
                 } if constant.name.is_some() => {
                     debug_assert!(constant.needs_alias());
                     write!(self.out, "constexpr constant ")?;
@@ -1748,17 +1893,17 @@ impl<W: Write> Writer<W> {
                     writeln!(self.out, " {} = {};", name, coco)?;
                 }
                 _ => {}
             }
         }
         Ok(())
     }
 
-    fn write_composite_constants(&mut self, module: &crate::Module) -> Result<(), Error> {
+    fn write_composite_constants(&mut self, module: &crate::Module) -> BackendResult {
         for (handle, constant) in module.constants.iter() {
             match constant.inner {
                 crate::ConstantInner::Scalar { .. } => {}
                 crate::ConstantInner::Composite { ty, ref components } => {
                     debug_assert!(constant.needs_alias());
                     let name = &self.names[&NameKey::Constant(handle)];
                     let ty_name = TypeContext {
                         handle: ty,
@@ -1784,17 +1929,17 @@ impl<W: Write> Writer<W> {
         }
         Ok(())
     }
 
     fn put_inline_sampler_properties(
         &mut self,
         level: Level,
         sampler: &sm::InlineSampler,
-    ) -> Result<(), Error> {
+    ) -> BackendResult {
         for (&letter, address) in ['s', 't', 'r'].iter().zip(sampler.address.iter()) {
             writeln!(
                 self.out,
                 "{}{}::{}_address::{},",
                 level,
                 NAMESPACE,
                 letter,
                 address.as_str(),
@@ -1862,17 +2007,17 @@ impl<W: Write> Writer<W> {
         )?;
         Ok(())
     }
 
     // Returns the array of mapped entry point names.
     fn write_functions(
         &mut self,
         module: &crate::Module,
-        mod_info: &ModuleInfo,
+        mod_info: &valid::ModuleInfo,
         options: &Options,
         pipeline_options: &PipelineOptions,
     ) -> Result<TranslationInfo, Error> {
         let mut pass_through_globals = Vec::new();
         for (fun_handle, fun) in module.functions.iter() {
             let fun_info = &mod_info[fun_handle];
             pass_through_globals.clear();
             let mut supports_array_length = false;
@@ -1916,54 +2061,57 @@ impl<W: Write> Writer<W> {
                 let separator = separate(
                     !pass_through_globals.is_empty()
                         || index + 1 != fun.arguments.len()
                         || supports_array_length,
                 );
                 writeln!(
                     self.out,
                     "{}{} {}{}",
-                    INDENT, param_type_name, name, separator
+                    back::INDENT,
+                    param_type_name,
+                    name,
+                    separator
                 )?;
             }
             for (index, &handle) in pass_through_globals.iter().enumerate() {
                 let tyvar = TypedGlobalVariable {
                     module,
                     names: &self.names,
                     handle,
                     usage: fun_info[handle],
                     reference: true,
                 };
                 let separator =
                     separate(index + 1 != pass_through_globals.len() || supports_array_length);
-                write!(self.out, "{}", INDENT)?;
+                write!(self.out, "{}", back::INDENT)?;
                 tyvar.try_fmt(&mut self.out)?;
                 writeln!(self.out, "{}", separator)?;
             }
 
             if supports_array_length {
                 writeln!(
                     self.out,
                     "{}constant _mslBufferSizes& _buffer_sizes",
-                    INDENT
+                    back::INDENT
                 )?;
             }
 
             writeln!(self.out, ") {{")?;
 
             for (local_handle, local) in fun.local_variables.iter() {
                 let ty_name = TypeContext {
                     handle: local.ty,
                     arena: &module.types,
                     names: &self.names,
                     access: crate::StorageAccess::empty(),
                     first_time: false,
                 };
                 let local_name = &self.names[&NameKey::FunctionLocal(fun_handle, local_handle)];
-                write!(self.out, "{}{} {}", INDENT, ty_name, local_name)?;
+                write!(self.out, "{}{} {}", back::INDENT, ty_name, local_name)?;
                 if let Some(value) = local.init {
                     let coco = ConstantContext {
                         handle: value,
                         arena: &module.constants,
                         names: &self.names,
                         first_time: false,
                     };
                     write!(self.out, " = {}", coco)?;
@@ -1991,25 +2139,37 @@ impl<W: Write> Writer<W> {
             entry_point_names: Vec::with_capacity(module.entry_points.len()),
         };
         for (ep_index, ep) in module.entry_points.iter().enumerate() {
             let fun = &ep.function;
             let fun_info = mod_info.get_entry_point(ep_index);
             let mut ep_error = None;
             let mut supports_array_length = false;
 
-            // skip this entry point if any global bindings are missing
+            // skip this entry point if any global bindings are missing,
+            // or their types are incompatible.
             if !options.fake_missing_bindings {
                 for (var_handle, var) in module.global_variables.iter() {
                     if fun_info[var_handle].is_empty() {
                         continue;
                     }
                     if let Some(ref br) = var.binding {
-                        if let Err(e) = options.resolve_resource_binding(ep.stage, br) {
-                            ep_error = Some(e);
+                        let good = match options.per_stage_map[ep.stage].resources.get(br) {
+                            Some(target) => match module.types[var.ty].inner {
+                                crate::TypeInner::Struct {
+                                    top_level: true, ..
+                                } => target.buffer.is_some(),
+                                crate::TypeInner::Image { .. } => target.texture.is_some(),
+                                crate::TypeInner::Sampler { .. } => target.sampler.is_some(),
+                                _ => false,
+                            },
+                            None => false,
+                        };
+                        if !good {
+                            ep_error = Some(super::EntryPointError::MissingBinding(br.clone()));
                             break;
                         }
                     }
                     if var.class == crate::StorageClass::PushConstant {
                         if let Err(e) = options.resolve_push_constants(ep.stage) {
                             ep_error = Some(e);
                             break;
                         }
@@ -2084,17 +2244,17 @@ impl<W: Write> Writer<W> {
                     let ty_name = TypeContext {
                         handle: ty,
                         arena: &module.types,
                         names: &self.names,
                         access: crate::StorageAccess::empty(),
                         first_time: false,
                     };
                     let resolved = options.resolve_local_binding(binding, in_mode)?;
-                    write!(self.out, "{}{} {}", INDENT, ty_name, name)?;
+                    write!(self.out, "{}{} {}", back::INDENT, ty_name, name)?;
                     resolved.try_fmt_decorated(&mut self.out, "")?;
                     writeln!(self.out, ";")?;
                 }
                 writeln!(self.out, "}};")?;
             }
 
             let result_member_name = self.namer.call("member");
             let result_type_name = match fun.result {
@@ -2144,17 +2304,17 @@ impl<W: Write> Writer<W> {
                         let array_len = match module.types[ty].inner {
                             crate::TypeInner::Array {
                                 size: crate::ArraySize::Constant(handle),
                                 ..
                             } => module.constants[handle].to_array_length(),
                             _ => None,
                         };
                         let resolved = options.resolve_local_binding(binding, out_mode)?;
-                        write!(self.out, "{}{} {}", INDENT, ty_name, name)?;
+                        write!(self.out, "{}{} {}", back::INDENT, ty_name, name)?;
                         resolved.try_fmt_decorated(&mut self.out, "")?;
                         if let Some(array_len) = array_len {
                             write!(self.out, " [{}]", array_len)?;
                         }
                         writeln!(self.out, ";")?;
                     }
                     writeln!(self.out, "}};")?;
                     &stage_out_name
@@ -2276,17 +2436,17 @@ impl<W: Write> Writer<W> {
                 if var.class == crate::StorageClass::Private {
                     let tyvar = TypedGlobalVariable {
                         module,
                         names: &self.names,
                         handle,
                         usage,
                         reference: false,
                     };
-                    write!(self.out, "{}", INDENT)?;
+                    write!(self.out, "{}", back::INDENT)?;
                     tyvar.try_fmt(&mut self.out)?;
                     match var.init {
                         Some(value) => {
                             let coco = ConstantContext {
                                 handle: value,
                                 arena: &module.constants,
                                 names: &self.names,
                                 first_time: false,
@@ -2300,35 +2460,39 @@ impl<W: Write> Writer<W> {
                 } else if let Some(ref binding) = var.binding {
                     // write an inline sampler
                     let resolved = options.resolve_resource_binding(ep.stage, binding).unwrap();
                     if let Some(sampler) = resolved.as_inline_sampler(options) {
                         let name = &self.names[&NameKey::GlobalVariable(handle)];
                         writeln!(
                             self.out,
                             "{}constexpr {}::sampler {}(",
-                            INDENT, NAMESPACE, name
+                            back::INDENT,
+                            NAMESPACE,
+                            name
                         )?;
                         self.put_inline_sampler_properties(Level(2), sampler)?;
-                        writeln!(self.out, "{});", INDENT)?;
+                        writeln!(self.out, "{});", back::INDENT)?;
                     }
                 }
             }
 
             // Now refactor the inputs in a way that the rest of the code expects
             for (arg_index, arg) in fun.arguments.iter().enumerate() {
                 let arg_name =
                     &self.names[&NameKey::EntryPointArgument(ep_index as _, arg_index as u32)];
                 match module.types[arg.ty].inner {
                     crate::TypeInner::Struct { ref members, .. } => {
                         let struct_name = &self.names[&NameKey::Type(arg.ty)];
                         write!(
                             self.out,
                             "{}const {} {} = {{ ",
-                            INDENT, struct_name, arg_name
+                            back::INDENT,
+                            struct_name,
+                            arg_name
                         )?;
                         for (member_index, member) in members.iter().enumerate() {
                             let name =
                                 &self.names[&NameKey::StructMember(arg.ty, member_index as u32)];
                             if member_index != 0 {
                                 write!(self.out, ", ")?;
                             }
                             if let Some(crate::Binding::Location { .. }) = member.binding {
@@ -2338,17 +2502,20 @@ impl<W: Write> Writer<W> {
                         }
                         writeln!(self.out, " }};")?;
                     }
                     _ => {
                         if let Some(crate::Binding::Location { .. }) = arg.binding {
                             writeln!(
                                 self.out,
                                 "{}const auto {} = {}.{};",
-                                INDENT, arg_name, varyings_member_name, arg_name
+                                back::INDENT,
+                                arg_name,
+                                varyings_member_name,
+                                arg_name
                             )?;
                         }
                     }
                 }
             }
 
             // Finally, declare all the local variables that we need
             //TODO: we can postpone this till the relevant expressions are emitted
@@ -2356,17 +2523,17 @@ impl<W: Write> Writer<W> {
                 let name = &self.names[&NameKey::EntryPointLocal(ep_index as _, local_handle)];
                 let ty_name = TypeContext {
                     handle: local.ty,
                     arena: &module.types,
                     names: &self.names,
                     access: crate::StorageAccess::empty(),
                     first_time: false,
                 };
-                write!(self.out, "{}{} {}", INDENT, ty_name, name)?;
+                write!(self.out, "{}{} {}", back::INDENT, ty_name, name)?;
                 if let Some(value) = local.init {
                     let coco = ConstantContext {
                         handle: value,
                         arena: &module.constants,
                         names: &self.names,
                         first_time: false,
                     };
                     write!(self.out, " = {}", coco)?;
@@ -2397,40 +2564,51 @@ impl<W: Write> Writer<W> {
     }
 }
 
 #[test]
 fn test_stack_size() {
     use crate::valid::{Capabilities, ValidationFlags};
     // create a module with at least one expression nested
     let mut module = crate::Module::default();
-    let constant = module.constants.append(crate::Constant {
-        name: None,
-        specialization: None,
-        inner: crate::ConstantInner::Scalar {
-            value: crate::ScalarValue::Float(1.0),
-            width: 4,
+    let constant = module.constants.append(
+        crate::Constant {
+            name: None,
+            specialization: None,
+            inner: crate::ConstantInner::Scalar {
+                value: crate::ScalarValue::Float(1.0),
+                width: 4,
+            },
         },
-    });
+        Default::default(),
+    );
     let mut fun = crate::Function::default();
     let const_expr = fun
         .expressions
-        .append(crate::Expression::Constant(constant));
-    let nested_expr = fun.expressions.append(crate::Expression::Unary {
-        op: crate::UnaryOperator::Negate,
-        expr: const_expr,
-    });
-    fun.body
-        .push(crate::Statement::Emit(fun.expressions.range_from(1)));
-    fun.body.push(crate::Statement::If {
-        condition: nested_expr,
-        accept: Vec::new(),
-        reject: Vec::new(),
-    });
-    let _ = module.functions.append(fun);
+        .append(crate::Expression::Constant(constant), Default::default());
+    let nested_expr = fun.expressions.append(
+        crate::Expression::Unary {
+            op: crate::UnaryOperator::Negate,
+            expr: const_expr,
+        },
+        Default::default(),
+    );
+    fun.body.push(
+        crate::Statement::Emit(fun.expressions.range_from(1)),
+        Default::default(),
+    );
+    fun.body.push(
+        crate::Statement::If {
+            condition: nested_expr,
+            accept: crate::Block::new(),
+            reject: crate::Block::new(),
+        },
+        Default::default(),
+    );
+    let _ = module.functions.append(fun, Default::default());
     // analyse the module
     let info = crate::valid::Validator::new(ValidationFlags::empty(), Capabilities::empty())
         .validate(&module)
         .unwrap();
     // process the module
     let mut writer = Writer::new(String::new());
     writer
         .write(&module, &info, &Default::default(), &Default::default())
@@ -2440,29 +2618,29 @@ fn test_stack_size() {
         // check expression stack
         let mut addresses = !0usize..0usize;
         for pointer in writer.put_expression_stack_pointers {
             addresses.start = addresses.start.min(pointer as usize);
             addresses.end = addresses.end.max(pointer as usize);
         }
         let stack_size = addresses.end - addresses.start;
         // check the size (in debug only)
-        // last observed macOS value: 17664
-        if stack_size < 14000 || stack_size > 19000 {
+        // last observed macOS value: 18304
+        if !(15000..=20000).contains(&stack_size) {
             panic!("`put_expression` stack size {} has changed!", stack_size);
         }
     }
 
     {
         // check block stack
         let mut addresses = !0usize..0usize;
         for pointer in writer.put_block_stack_pointers {
             addresses.start = addresses.start.min(pointer as usize);
             addresses.end = addresses.end.max(pointer as usize);
         }
         let stack_size = addresses.end - addresses.start;
         // check the size (in debug only)
-        // last observed macOS value: 13600
-        if stack_size < 11000 || stack_size > 16000 {
+        // last observed macOS value: 17504
+        if !(13000..=19000).contains(&stack_size) {
             panic!("`put_block` stack size {} has changed!", stack_size);
         }
     }
 }