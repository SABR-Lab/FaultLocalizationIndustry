# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/spv/helpers.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/spv/helpers.rs b/third_party/rust/naga/src/back/spv/helpers.rs
--- a/third_party/rust/naga/src/back/spv/helpers.rs
+++ b/third_party/rust/naga/src/back/spv/helpers.rs
@@ -20,17 +20,17 @@ pub(super) fn string_to_words(input: &st
     words
 }
 
 pub(super) fn map_storage_class(class: crate::StorageClass) -> spirv::StorageClass {
     match class {
         crate::StorageClass::Handle => spirv::StorageClass::UniformConstant,
         crate::StorageClass::Function => spirv::StorageClass::Function,
         crate::StorageClass::Private => spirv::StorageClass::Private,
-        crate::StorageClass::Storage => spirv::StorageClass::StorageBuffer,
+        crate::StorageClass::Storage { .. } => spirv::StorageClass::StorageBuffer,
         crate::StorageClass::Uniform => spirv::StorageClass::Uniform,
         crate::StorageClass::WorkGroup => spirv::StorageClass::Workgroup,
         crate::StorageClass::PushConstant => spirv::StorageClass::PushConstant,
     }
 }
 
 pub(super) fn contains_builtin(
     binding: Option<&crate::Binding>,
@@ -43,8 +43,21 @@ pub(super) fn contains_builtin(
     } else if let crate::TypeInner::Struct { ref members, .. } = arena[ty].inner {
         members
             .iter()
             .any(|member| contains_builtin(member.binding.as_ref(), member.ty, arena, built_in))
     } else {
         false // unreachable
     }
 }
+
+impl crate::StorageClass {
+    pub(super) fn to_spirv_semantics_and_scope(self) -> (spirv::MemorySemantics, spirv::Scope) {
+        match self {
+            Self::Storage { .. } => (spirv::MemorySemantics::UNIFORM_MEMORY, spirv::Scope::Device),
+            Self::WorkGroup => (
+                spirv::MemorySemantics::WORKGROUP_MEMORY,
+                spirv::Scope::Workgroup,
+            ),
+            _ => (spirv::MemorySemantics::empty(), spirv::Scope::Invocation),
+        }
+    }
+}