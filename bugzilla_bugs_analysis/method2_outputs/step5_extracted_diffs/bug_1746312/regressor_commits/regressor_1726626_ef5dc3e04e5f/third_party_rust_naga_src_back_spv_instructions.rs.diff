# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/spv/instructions.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/spv/instructions.rs b/third_party/rust/naga/src/back/spv/instructions.rs
--- a/third_party/rust/naga/src/back/spv/instructions.rs
+++ b/third_party/rust/naga/src/back/spv/instructions.rs
@@ -228,26 +228,26 @@ impl super::Instruction {
     ) -> Self {
         let mut instruction = Self::new(Op::TypeImage);
         instruction.set_result(id);
         instruction.add_operand(sampled_type_id);
         instruction.add_operand(dim as u32);
 
         let (depth, multi, sampled) = match image_class {
             crate::ImageClass::Sampled { kind: _, multi } => (false, multi, true),
-            crate::ImageClass::Depth => (true, false, true),
-            crate::ImageClass::Storage(_) => (false, false, false),
+            crate::ImageClass::Depth { multi } => (true, multi, true),
+            crate::ImageClass::Storage { .. } => (false, false, false),
         };
         instruction.add_operand(depth as u32);
         instruction.add_operand(arrayed as u32);
         instruction.add_operand(multi as u32);
         instruction.add_operand(if sampled { 1 } else { 2 });
 
         let format = match image_class {
-            crate::ImageClass::Storage(format) => match format {
+            crate::ImageClass::Storage { format, .. } => match format {
                 crate::StorageFormat::R8Unorm => spirv::ImageFormat::R8,
                 crate::StorageFormat::R8Snorm => spirv::ImageFormat::R8Snorm,
                 crate::StorageFormat::R8Uint => spirv::ImageFormat::R8ui,
                 crate::StorageFormat::R8Sint => spirv::ImageFormat::R8i,
                 crate::StorageFormat::R16Uint => spirv::ImageFormat::R16ui,
                 crate::StorageFormat::R16Sint => spirv::ImageFormat::R16i,
                 crate::StorageFormat::R16Float => spirv::ImageFormat::R16f,
                 crate::StorageFormat::Rg8Unorm => spirv::ImageFormat::Rg8,
@@ -434,32 +434,62 @@ impl super::Instruction {
 
         if let Some(memory_access) = memory_access {
             instruction.add_operand(memory_access.bits());
         }
 
         instruction
     }
 
+    pub(super) fn atomic_load(
+        result_type_id: Word,
+        id: Word,
+        pointer_id: Word,
+        scope_id: Word,
+        semantics_id: Word,
+    ) -> Self {
+        let mut instruction = Self::new(Op::AtomicLoad);
+        instruction.set_type(result_type_id);
+        instruction.set_result(id);
+        instruction.add_operand(pointer_id);
+        instruction.add_operand(scope_id);
+        instruction.add_operand(semantics_id);
+        instruction
+    }
+
     pub(super) fn store(
         pointer_id: Word,
-        object_id: Word,
+        value_id: Word,
         memory_access: Option<spirv::MemoryAccess>,
     ) -> Self {
         let mut instruction = Self::new(Op::Store);
         instruction.add_operand(pointer_id);
-        instruction.add_operand(object_id);
+        instruction.add_operand(value_id);
 
         if let Some(memory_access) = memory_access {
             instruction.add_operand(memory_access.bits());
         }
 
         instruction
     }
 
+    pub(super) fn atomic_store(
+        pointer_id: Word,
+        scope_id: Word,
+        semantics_id: Word,
+        value_id: Word,
+    ) -> Self {
+        let mut instruction = Self::new(Op::AtomicStore);
+        instruction.add_operand(pointer_id);
+        instruction.add_operand(scope_id);
+        instruction.add_operand(semantics_id);
+        instruction.add_operand(value_id);
+        instruction
+    }
+
     pub(super) fn access_chain(
         result_type_id: Word,
         id: Word,
         base_id: Word,
         index_ids: &[Word],
     ) -> Self {
         let mut instruction = Self::new(Op::AccessChain);
         instruction.set_type(result_type_id);
@@ -574,37 +604,24 @@ impl super::Instruction {
         instruction.add_operand(coordinates);
         if let Some(dref) = depth_ref {
             instruction.add_operand(dref);
         }
 
         instruction
     }
 
-    pub(super) fn image_fetch(
+    pub(super) fn image_fetch_or_read(
+        op: Op,
         result_type_id: Word,
         id: Word,
         image: Word,
         coordinates: Word,
     ) -> Self {
-        let mut instruction = Self::new(Op::ImageFetch);
-        instruction.set_type(result_type_id);
-        instruction.set_result(id);
-        instruction.add_operand(image);
-        instruction.add_operand(coordinates);
-        instruction
-    }
-
-    pub(super) fn image_read(
-        result_type_id: Word,
-        id: Word,
-        image: Word,
-        coordinates: Word,
-    ) -> Self {
-        let mut instruction = Self::new(Op::ImageRead);
+        let mut instruction = Self::new(op);
         instruction.set_type(result_type_id);
         instruction.set_result(id);
         instruction.add_operand(image);
         instruction.add_operand(coordinates);
         instruction
     }
 
     pub(super) fn image_write(image: Word, coordinates: Word, value: Word) -> Self {
@@ -729,16 +746,35 @@ impl super::Instruction {
     pub(super) fn relational(op: Op, result_type_id: Word, id: Word, expr_id: Word) -> Self {
         let mut instruction = Self::new(op);
         instruction.set_type(result_type_id);
         instruction.set_result(id);
         instruction.add_operand(expr_id);
         instruction
     }
 
+    pub(super) fn atomic_binary(
+        op: Op,
+        result_type_id: Word,
+        id: Word,
+        pointer: Word,
+        scope_id: Word,
+        semantics_id: Word,
+        value: Word,
+    ) -> Self {
+        let mut instruction = Self::new(op);
+        instruction.set_type(result_type_id);
+        instruction.set_result(id);
+        instruction.add_operand(pointer);
+        instruction.add_operand(scope_id);
+        instruction.add_operand(semantics_id);
+        instruction.add_operand(value);
+        instruction
+    }
+
     //
     // Bit Instructions
     //
 
     //
     // Relational and Logical Instructions
     //
 
@@ -753,16 +789,31 @@ impl super::Instruction {
         instruction.add_operand(expr_id);
         instruction
     }
 
     //
     // Control-Flow Instructions
     //
 
+    pub(super) fn phi(
+        result_type_id: Word,
+        result_id: Word,
+        var_parent_pairs: &[(Word, Word)],
+    ) -> Self {
+        let mut instruction = Self::new(Op::Phi);
+        instruction.add_operand(result_type_id);
+        instruction.add_operand(result_id);
+        for &(variable, parent) in var_parent_pairs {
+            instruction.add_operand(variable);
+            instruction.add_operand(parent);
+        }
+        instruction
+    }
+
     pub(super) fn selection_merge(
         merge_id: Word,
         selection_control: spirv::SelectionControl,
     ) -> Self {
         let mut instruction = Self::new(Op::SelectionMerge);
         instruction.add_operand(merge_id);
         instruction.add_operand(selection_control.bits());
         instruction