# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/spv/layout.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/back/spv/layout.rs b/third_party/rust/naga/src/back/spv/layout.rs
--- a/third_party/rust/naga/src/back/spv/layout.rs
+++ b/third_party/rust/naga/src/back/spv/layout.rs
@@ -20,32 +20,62 @@ impl PhysicalLayout {
         sink.extend(iter::once(self.magic_number));
         sink.extend(iter::once(self.version));
         sink.extend(iter::once(self.generator));
         sink.extend(iter::once(self.bound));
         sink.extend(iter::once(self.instruction_schema));
     }
 }
 
+impl super::recyclable::Recyclable for PhysicalLayout {
+    fn recycle(self) -> Self {
+        PhysicalLayout {
+            magic_number: self.magic_number,
+            version: self.version,
+            generator: self.generator,
+            instruction_schema: self.instruction_schema,
+            bound: 0,
+        }
+    }
+}
+
 impl LogicalLayout {
     pub(super) fn in_words(&self, sink: &mut impl Extend<Word>) {
         sink.extend(self.capabilities.iter().cloned());
         sink.extend(self.extensions.iter().cloned());
         sink.extend(self.ext_inst_imports.iter().cloned());
         sink.extend(self.memory_model.iter().cloned());
         sink.extend(self.entry_points.iter().cloned());
         sink.extend(self.execution_modes.iter().cloned());
         sink.extend(self.debugs.iter().cloned());
         sink.extend(self.annotations.iter().cloned());
         sink.extend(self.declarations.iter().cloned());
         sink.extend(self.function_declarations.iter().cloned());
         sink.extend(self.function_definitions.iter().cloned());
     }
 }
 
+impl super::recyclable::Recyclable for LogicalLayout {
+    fn recycle(self) -> Self {
+        Self {
+            capabilities: self.capabilities.recycle(),
+            extensions: self.extensions.recycle(),
+            ext_inst_imports: self.ext_inst_imports.recycle(),
+            memory_model: self.memory_model.recycle(),
+            entry_points: self.entry_points.recycle(),
+            execution_modes: self.execution_modes.recycle(),
+            debugs: self.debugs.recycle(),
+            annotations: self.annotations.recycle(),
+            declarations: self.declarations.recycle(),
+            function_declarations: self.function_declarations.recycle(),
+            function_definitions: self.function_definitions.recycle(),
+        }
+    }
+}
+
 impl Instruction {
     pub(super) fn new(op: Op) -> Self {
         Instruction {
             op,
             wc: 1, // Always start at 1 for the first word (OP + WC),
             type_id: None,
             result_id: None,
             operands: vec![],
@@ -100,20 +130,18 @@ impl Instruction {
             inst_index += 1;
         }
 
         if self.result_id.is_some() {
             assert_eq!(words[inst_index], self.result_id.unwrap());
             inst_index += 1;
         }
 
-        let mut op_index = 0;
-        for i in inst_index..wc as usize {
+        for (op_index, i) in (inst_index..wc as usize).enumerate() {
             assert_eq!(words[i], self.operands[op_index]);
-            op_index += 1;
         }
     }
 }
 
 #[test]
 fn test_physical_layout_in_words() {
     let bound = 5;
     let version = 0x10203;
@@ -143,17 +171,17 @@ fn test_logical_layout_in_words() {
         "Execution Modes",
         "Debugs",
         "Annotations",
         "Declarations",
         "Function Declarations",
         "Function Definitions",
     ];
 
-    for i in 0..layout_vectors {
+    for (i, _) in vector_names.iter().enumerate().take(layout_vectors) {
         let mut dummy_instruction = Instruction::new(Op::Constant);
         dummy_instruction.set_type((i + 1) as u32);
         dummy_instruction.set_result((i + 2) as u32);
         dummy_instruction.add_operand((i + 3) as u32);
         dummy_instruction.add_operands(super::helpers::string_to_words(
             format!("This is the vector: {}", vector_names[i]).as_str(),
         ));
         instructions.push(dummy_instruction);