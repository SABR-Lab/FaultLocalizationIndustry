# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/glsl/constants.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/glsl/constants.rs b/third_party/rust/naga/src/front/glsl/constants.rs
--- a/third_party/rust/naga/src/front/glsl/constants.rs
+++ b/third_party/rust/naga/src/front/glsl/constants.rs
@@ -20,16 +20,18 @@ pub enum ConstantSolvingError {
     #[error("Constants cannot access local variables")]
     LocalVariable,
     #[error("Cannot get the array length of a non array type")]
     InvalidArrayLengthArg,
     #[error("Constants cannot get the array length of a dynamically sized array")]
     ArrayLengthDynamic,
     #[error("Constants cannot call functions")]
     Call,
+    #[error("Constants don't support atomic functions")]
+    Atomic,
     #[error("Constants don't support relational functions")]
     Relational,
     #[error("Constants don't support derivative functions")]
     Derivative,
     #[error("Constants don't support select expressions")]
     Select,
     #[error("Constants don't support load expressions")]
     Load,
@@ -44,27 +46,30 @@ pub enum ConstantSolvingError {
     #[error("Constants don't support bitcasts")]
     Bitcast,
     #[error("Cannot cast type")]
     InvalidCastArg,
     #[error("Cannot apply the unary op to the argument")]
     InvalidUnaryOpArg,
     #[error("Cannot apply the binary op to the arguments")]
     InvalidBinaryOpArgs,
+    #[error("Cannot apply math function to type")]
+    InvalidMathArg,
     #[error("Splat/swizzle type is not registered")]
     DestinationTypeNotFound,
     #[error("Not implemented: {0}")]
     NotImplemented(String),
 }
 
 impl<'a> ConstantSolver<'a> {
     pub fn solve(
         &mut self,
         expr: Handle<Expression>,
     ) -> Result<Handle<Constant>, ConstantSolvingError> {
+        let span = self.expressions.get_span(expr).clone();
         match self.expressions[expr] {
             Expression::Constant(constant) => Ok(constant),
             Expression::AccessIndex { base, index } => self.access(base, index as usize),
             Expression::Access { base, index } => {
                 let index = self.solve(index)?;
 
                 self.access(base, self.constant_index(index)?)
             }
@@ -79,24 +84,27 @@ impl<'a> ConstantSolver<'a> {
                         self.types
                             .fetch_if(|t| t.inner == crate::TypeInner::Vector { size, kind, width })
                     }
                     ConstantInner::Composite { .. } => None,
                 };
 
                 //TODO: register the new type if needed
                 let ty = ty.ok_or(ConstantSolvingError::DestinationTypeNotFound)?;
-                Ok(self.constants.fetch_or_append(Constant {
-                    name: None,
-                    specialization: None,
-                    inner: ConstantInner::Composite {
-                        ty,
-                        components: vec![value_constant; size as usize],
+                Ok(self.constants.fetch_or_append(
+                    Constant {
+                        name: None,
+                        specialization: None,
+                        inner: ConstantInner::Composite {
+                            ty,
+                            components: vec![value_constant; size as usize],
+                        },
                     },
-                }))
+                    span,
+                ))
             }
             Expression::Swizzle {
                 size,
                 vector: src_vector,
                 pattern,
             } => {
                 let src_constant = self.solve(src_vector)?;
                 let (ty, src_components) = match self.constants[src_constant].inner {
@@ -120,57 +128,106 @@ impl<'a> ConstantSolver<'a> {
                 };
                 //TODO: register the new type if needed
                 let ty = ty.ok_or(ConstantSolvingError::DestinationTypeNotFound)?;
                 let components = pattern
                     .iter()
                     .map(|&sc| src_components[sc as usize])
                     .collect();
 
-                Ok(self.constants.fetch_or_append(Constant {
-                    name: None,
-                    specialization: None,
-                    inner: ConstantInner::Composite { ty, components },
-                }))
+                Ok(self.constants.fetch_or_append(
+                    Constant {
+                        name: None,
+                        specialization: None,
+                        inner: ConstantInner::Composite { ty, components },
+                    },
+                    span,
+                ))
             }
             Expression::Compose { ty, ref components } => {
                 let components = components
                     .iter()
                     .map(|c| self.solve(*c))
                     .collect::<Result<_, _>>()?;
 
-                Ok(self.constants.fetch_or_append(Constant {
-                    name: None,
-                    specialization: None,
-                    inner: ConstantInner::Composite { ty, components },
-                }))
+                Ok(self.constants.fetch_or_append(
+                    Constant {
+                        name: None,
+                        specialization: None,
+                        inner: ConstantInner::Composite { ty, components },
+                    },
+                    span,
+                ))
             }
             Expression::Unary { expr, op } => {
                 let expr_constant = self.solve(expr)?;
 
-                self.unary_op(op, expr_constant)
+                self.unary_op(op, expr_constant, span)
             }
             Expression::Binary { left, right, op } => {
                 let left_constant = self.solve(left)?;
                 let right_constant = self.solve(right)?;
 
-                self.binary_op(op, left_constant, right_constant)
+                self.binary_op(op, left_constant, right_constant, span)
             }
-            Expression::Math { fun, .. } => {
-                Err(ConstantSolvingError::NotImplemented(format!("{:?}", fun)))
+            Expression::Math { fun, arg, arg1, .. } => {
+                let arg = self.solve(arg)?;
+                let arg1 = arg1.map(|arg| self.solve(arg)).transpose()?;
+
+                let const0 = &self.constants[arg].inner;
+                let const1 = arg1.map(|arg| &self.constants[arg].inner);
+
+                match fun {
+                    crate::MathFunction::Pow => {
+                        let (value, width) = match (const0, const1.unwrap()) {
+                            (
+                                &ConstantInner::Scalar {
+                                    width,
+                                    value: value0,
+                                },
+                                &ConstantInner::Scalar { value: value1, .. },
+                            ) => (
+                                match (value0, value1) {
+                                    (ScalarValue::Sint(a), ScalarValue::Sint(b)) => {
+                                        ScalarValue::Sint(a.pow(b as u32))
+                                    }
+                                    (ScalarValue::Uint(a), ScalarValue::Uint(b)) => {
+                                        ScalarValue::Uint(a.pow(b as u32))
+                                    }
+                                    (ScalarValue::Float(a), ScalarValue::Float(b)) => {
+                                        ScalarValue::Float(a.powf(b))
+                                    }
+                                    _ => return Err(ConstantSolvingError::InvalidMathArg),
+                                },
+                                width,
+                            ),
+                            _ => return Err(ConstantSolvingError::InvalidMathArg),
+                        };
+
+                        Ok(self.constants.fetch_or_append(
+                            Constant {
+                                name: None,
+                                specialization: None,
+                                inner: ConstantInner::Scalar { width, value },
+                            },
+                            span,
+                        ))
+                    }
+                    _ => Err(ConstantSolvingError::NotImplemented(format!("{:?}", fun))),
+                }
             }
             Expression::As {
                 convert,
                 expr,
                 kind,
             } => {
                 let expr_constant = self.solve(expr)?;
 
                 match convert {
-                    Some(width) => self.cast(expr_constant, kind, width),
+                    Some(width) => self.cast(expr_constant, kind, width, span),
                     None => Err(ConstantSolvingError::Bitcast),
                 }
             }
             Expression::ArrayLength(expr) => {
                 let array = self.solve(expr)?;
 
                 match self.constants[array].inner {
                     ConstantInner::Scalar { .. } => {
@@ -188,17 +245,18 @@ impl<'a> ConstantSolver<'a> {
                 }
             }
 
             Expression::Load { .. } => Err(ConstantSolvingError::Load),
             Expression::Select { .. } => Err(ConstantSolvingError::Select),
             Expression::LocalVariable(_) => Err(ConstantSolvingError::LocalVariable),
             Expression::Derivative { .. } => Err(ConstantSolvingError::Derivative),
             Expression::Relational { .. } => Err(ConstantSolvingError::Relational),
-            Expression::Call { .. } => Err(ConstantSolvingError::Call),
+            Expression::CallResult { .. } => Err(ConstantSolvingError::Call),
+            Expression::AtomicResult { .. } => Err(ConstantSolvingError::Atomic),
             Expression::FunctionArgument(_) => Err(ConstantSolvingError::FunctionArg),
             Expression::GlobalVariable(_) => Err(ConstantSolvingError::GlobalVariable),
             Expression::ImageSample { .. }
             | Expression::ImageLoad { .. }
             | Expression::ImageQuery { .. } => Err(ConstantSolvingError::ImageExpression),
         }
     }
 
@@ -238,16 +296,17 @@ impl<'a> ConstantSolver<'a> {
         }
     }
 
     fn cast(
         &mut self,
         constant: Handle<Constant>,
         kind: ScalarKind,
         target_width: crate::Bytes,
+        span: crate::Span,
     ) -> Result<Handle<Constant>, ConstantSolvingError> {
         fn inner_cast<A: num_traits::FromPrimitive>(value: ScalarValue) -> A {
             match value {
                 ScalarValue::Sint(v) => A::from_i64(v),
                 ScalarValue::Uint(v) => A::from_u64(v),
                 ScalarValue::Float(v) => A::from_f64(v),
                 ScalarValue::Bool(v) => A::from_u64(v as u64),
             }
@@ -274,32 +333,36 @@ impl<'a> ConstantSolver<'a> {
                 ref mut components,
             } => {
                 match self.types[ty].inner {
                     TypeInner::Vector { .. } | TypeInner::Matrix { .. } => (),
                     _ => return Err(ConstantSolvingError::InvalidCastArg),
                 }
 
                 for component in components {
-                    *component = self.cast(*component, kind, target_width)?;
+                    *component = self.cast(*component, kind, target_width, span.clone())?;
                 }
             }
         }
 
-        Ok(self.constants.fetch_or_append(Constant {
-            name: None,
-            specialization: None,
-            inner,
-        }))
+        Ok(self.constants.fetch_or_append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner,
+            },
+            span,
+        ))
     }
 
     fn unary_op(
         &mut self,
         op: UnaryOperator,
         constant: Handle<Constant>,
+        span: crate::Span,
     ) -> Result<Handle<Constant>, ConstantSolvingError> {
         let mut inner = self.constants[constant].inner.clone();
 
         match inner {
             ConstantInner::Scalar { ref mut value, .. } => match op {
                 UnaryOperator::Negate => match *value {
                     ScalarValue::Sint(ref mut v) => *v = -*v,
                     ScalarValue::Float(ref mut v) => *v = -*v,
@@ -317,38 +380,42 @@ impl<'a> ConstantSolver<'a> {
                 ref mut components,
             } => {
                 match self.types[ty].inner {
                     TypeInner::Vector { .. } | TypeInner::Matrix { .. } => (),
                     _ => return Err(ConstantSolvingError::InvalidCastArg),
                 }
 
                 for component in components {
-                    *component = self.unary_op(op, *component)?
+                    *component = self.unary_op(op, *component, span.clone())?
                 }
             }
         }
 
-        Ok(self.constants.fetch_or_append(Constant {
-            name: None,
-            specialization: None,
-            inner,
-        }))
+        Ok(self.constants.fetch_or_append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner,
+            },
+            span,
+        ))
     }
 
     fn binary_op(
         &mut self,
         op: BinaryOperator,
         left: Handle<Constant>,
         right: Handle<Constant>,
+        span: crate::Span,
     ) -> Result<Handle<Constant>, ConstantSolvingError> {
-        let left = &self.constants[left].inner;
-        let right = &self.constants[right].inner;
+        let left_inner = &self.constants[left].inner;
+        let right_inner = &self.constants[right].inner;
 
-        let inner = match (left, right) {
+        let inner = match (left_inner, right_inner) {
             (
                 &ConstantInner::Scalar {
                     value: left_value,
                     width,
                 },
                 &ConstantInner::Scalar {
                     value: right_value,
                     width: _,
@@ -411,24 +478,41 @@ impl<'a> ConstantSolver<'a> {
                             })
                         }
                         _ => return Err(ConstantSolvingError::InvalidBinaryOpArgs),
                     },
                 };
 
                 ConstantInner::Scalar { value, width }
             }
+            (&ConstantInner::Composite { ref components, ty }, &ConstantInner::Scalar { .. }) => {
+                let mut components = components.clone();
+                for comp in components.iter_mut() {
+                    *comp = self.binary_op(op, *comp, right, span.clone())?;
+                }
+                ConstantInner::Composite { ty, components }
+            }
+            (&ConstantInner::Scalar { .. }, &ConstantInner::Composite { ref components, ty }) => {
+                let mut components = components.clone();
+                for comp in components.iter_mut() {
+                    *comp = self.binary_op(op, left, *comp, span.clone())?;
+                }
+                ConstantInner::Composite { ty, components }
+            }
             _ => return Err(ConstantSolvingError::InvalidBinaryOpArgs),
         };
 
-        Ok(self.constants.fetch_or_append(Constant {
-            name: None,
-            specialization: None,
-            inner,
-        }))
+        Ok(self.constants.fetch_or_append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner,
+            },
+            span,
+        ))
     }
 }
 
 #[cfg(test)]
 mod tests {
     use std::vec;
 
     use crate::{
@@ -439,69 +523,90 @@ mod tests {
     use super::ConstantSolver;
 
     #[test]
     fn unary_op() {
         let mut types = Arena::new();
         let mut expressions = Arena::new();
         let mut constants = Arena::new();
 
-        let vec_ty = types.append(Type {
-            name: None,
-            inner: TypeInner::Vector {
-                size: VectorSize::Bi,
-                kind: ScalarKind::Sint,
-                width: 4,
+        let vec_ty = types.append(
+            Type {
+                name: None,
+                inner: TypeInner::Vector {
+                    size: VectorSize::Bi,
+                    kind: ScalarKind::Sint,
+                    width: 4,
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let h = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Scalar {
-                width: 4,
-                value: ScalarValue::Sint(4),
+        let h = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Scalar {
+                    width: 4,
+                    value: ScalarValue::Sint(4),
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let h1 = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Scalar {
-                width: 4,
-                value: ScalarValue::Sint(8),
+        let h1 = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Scalar {
+                    width: 4,
+                    value: ScalarValue::Sint(8),
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let vec_h = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Composite {
-                ty: vec_ty,
-                components: vec![h, h1],
+        let vec_h = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Composite {
+                    ty: vec_ty,
+                    components: vec![h, h1],
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let expr = expressions.append(Expression::Constant(h));
-        let expr1 = expressions.append(Expression::Constant(vec_h));
+        let expr = expressions.append(Expression::Constant(h), Default::default());
+        let expr1 = expressions.append(Expression::Constant(vec_h), Default::default());
 
-        let root1 = expressions.append(Expression::Unary {
-            op: UnaryOperator::Negate,
-            expr,
-        });
+        let root1 = expressions.append(
+            Expression::Unary {
+                op: UnaryOperator::Negate,
+                expr,
+            },
+            Default::default(),
+        );
 
-        let root2 = expressions.append(Expression::Unary {
-            op: UnaryOperator::Not,
-            expr,
-        });
+        let root2 = expressions.append(
+            Expression::Unary {
+                op: UnaryOperator::Not,
+                expr,
+            },
+            Default::default(),
+        );
 
-        let root3 = expressions.append(Expression::Unary {
-            op: UnaryOperator::Not,
-            expr: expr1,
-        });
+        let root3 = expressions.append(
+            Expression::Unary {
+                op: UnaryOperator::Not,
+                expr: expr1,
+            },
+            Default::default(),
+        );
 
         let mut solver = ConstantSolver {
             types: &types,
             expressions: &expressions,
             constants: &mut constants,
         };
 
         let res1 = solver.solve(root1).unwrap();
@@ -550,32 +655,38 @@ mod tests {
         }
     }
 
     #[test]
     fn cast() {
         let mut expressions = Arena::new();
         let mut constants = Arena::new();
 
-        let h = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Scalar {
-                width: 4,
-                value: ScalarValue::Sint(4),
+        let h = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Scalar {
+                    width: 4,
+                    value: ScalarValue::Sint(4),
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let expr = expressions.append(Expression::Constant(h));
+        let expr = expressions.append(Expression::Constant(h), Default::default());
 
-        let root = expressions.append(Expression::As {
-            expr,
-            kind: ScalarKind::Bool,
-            convert: Some(crate::BOOL_WIDTH),
-        });
+        let root = expressions.append(
+            Expression::As {
+                expr,
+                kind: ScalarKind::Bool,
+                convert: Some(crate::BOOL_WIDTH),
+            },
+            Default::default(),
+        );
 
         let mut solver = ConstantSolver {
             types: &Arena::new(),
             expressions: &expressions,
             constants: &mut constants,
         };
 
         let res = solver.solve(root).unwrap();
@@ -590,96 +701,123 @@ mod tests {
     }
 
     #[test]
     fn access() {
         let mut types = Arena::new();
         let mut expressions = Arena::new();
         let mut constants = Arena::new();
 
-        let matrix_ty = types.append(Type {
-            name: None,
-            inner: TypeInner::Matrix {
-                columns: VectorSize::Bi,
-                rows: VectorSize::Tri,
-                width: 4,
+        let matrix_ty = types.append(
+            Type {
+                name: None,
+                inner: TypeInner::Matrix {
+                    columns: VectorSize::Bi,
+                    rows: VectorSize::Tri,
+                    width: 4,
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let vec_ty = types.append(Type {
-            name: None,
-            inner: TypeInner::Vector {
-                size: VectorSize::Tri,
-                kind: ScalarKind::Float,
-                width: 4,
+        let vec_ty = types.append(
+            Type {
+                name: None,
+                inner: TypeInner::Vector {
+                    size: VectorSize::Tri,
+                    kind: ScalarKind::Float,
+                    width: 4,
+                },
             },
-        });
+            Default::default(),
+        );
 
         let mut vec1_components = Vec::with_capacity(3);
         let mut vec2_components = Vec::with_capacity(3);
 
         for i in 0..3 {
-            let h = constants.append(Constant {
-                name: None,
-                specialization: None,
-                inner: ConstantInner::Scalar {
-                    width: 4,
-                    value: ScalarValue::Float(i as f64),
+            let h = constants.append(
+                Constant {
+                    name: None,
+                    specialization: None,
+                    inner: ConstantInner::Scalar {
+                        width: 4,
+                        value: ScalarValue::Float(i as f64),
+                    },
                 },
-            });
+                Default::default(),
+            );
 
             vec1_components.push(h)
         }
 
         for i in 3..6 {
-            let h = constants.append(Constant {
-                name: None,
-                specialization: None,
-                inner: ConstantInner::Scalar {
-                    width: 4,
-                    value: ScalarValue::Float(i as f64),
+            let h = constants.append(
+                Constant {
+                    name: None,
+                    specialization: None,
+                    inner: ConstantInner::Scalar {
+                        width: 4,
+                        value: ScalarValue::Float(i as f64),
+                    },
                 },
-            });
+                Default::default(),
+            );
 
             vec2_components.push(h)
         }
 
-        let vec1 = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Composite {
-                ty: vec_ty,
-                components: vec1_components,
+        let vec1 = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Composite {
+                    ty: vec_ty,
+                    components: vec1_components,
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let vec2 = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Composite {
-                ty: vec_ty,
-                components: vec2_components,
+        let vec2 = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Composite {
+                    ty: vec_ty,
+                    components: vec2_components,
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let h = constants.append(Constant {
-            name: None,
-            specialization: None,
-            inner: ConstantInner::Composite {
-                ty: matrix_ty,
-                components: vec![vec1, vec2],
+        let h = constants.append(
+            Constant {
+                name: None,
+                specialization: None,
+                inner: ConstantInner::Composite {
+                    ty: matrix_ty,
+                    components: vec![vec1, vec2],
+                },
             },
-        });
+            Default::default(),
+        );
 
-        let base = expressions.append(Expression::Constant(h));
-        let root1 = expressions.append(Expression::AccessIndex { base, index: 1 });
-        let root2 = expressions.append(Expression::AccessIndex {
-            base: root1,
-            index: 2,
-        });
+        let base = expressions.append(Expression::Constant(h), Default::default());
+        let root1 = expressions.append(
+            Expression::AccessIndex { base, index: 1 },
+            Default::default(),
+        );
+        let root2 = expressions.append(
+            Expression::AccessIndex {
+                base: root1,
+                index: 2,
+            },
+            Default::default(),
+        );
 
         let mut solver = ConstantSolver {
             types: &types,
             expressions: &expressions,
             constants: &mut constants,
         };
 
         let res1 = solver.solve(root1).unwrap();