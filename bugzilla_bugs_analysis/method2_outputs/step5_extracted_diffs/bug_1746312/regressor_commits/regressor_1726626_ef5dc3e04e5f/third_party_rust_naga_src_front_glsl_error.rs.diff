# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/glsl/error.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/glsl/error.rs b/third_party/rust/naga/src/front/glsl/error.rs
--- a/third_party/rust/naga/src/front/glsl/error.rs
+++ b/third_party/rust/naga/src/front/glsl/error.rs
@@ -1,36 +1,45 @@
 use super::{
     constants::ConstantSolvingError,
-    token::{SourceMetadata, Token, TokenValue},
+    token::{SourceMetadata, TokenValue},
 };
+use pp_rs::token::PreprocessorError;
 use std::borrow::Cow;
 use thiserror::Error;
 
 fn join_with_comma(list: &[ExpectedToken]) -> String {
     let mut string = "".to_string();
     for (i, val) in list.iter().enumerate() {
         string.push_str(&val.to_string());
         match i {
             i if i == list.len() - 1 => {}
             i if i == list.len() - 2 => string.push_str(" or "),
             _ => string.push_str(", "),
         }
     }
     string
 }
 
+/// One of the expected tokens returned in [`InvalidToken`](ErrorKind::InvalidToken)
 #[derive(Debug, PartialEq)]
 pub enum ExpectedToken {
+    /// A specific token was expected
     Token(TokenValue),
+    /// A type was expected
     TypeName,
+    /// An identifier was expected
     Identifier,
+    /// An integer literal was expected
     IntLiteral,
+    /// A float literal was expected
     FloatLiteral,
+    /// A boolean literal was expected
     BoolLiteral,
+    /// The end of file was expected
     Eof,
 }
 impl From<TokenValue> for ExpectedToken {
     fn from(token: TokenValue) -> Self {
         ExpectedToken::Token(token)
     }
 }
 impl std::fmt::Display for ExpectedToken {
@@ -42,85 +51,76 @@ impl std::fmt::Display for ExpectedToken
             ExpectedToken::IntLiteral => write!(f, "integer literal"),
             ExpectedToken::FloatLiteral => write!(f, "float literal"),
             ExpectedToken::BoolLiteral => write!(f, "bool literal"),
             ExpectedToken::Eof => write!(f, "end of file"),
         }
     }
 }
 
+/// Information about the cause of an error
 #[derive(Debug, Error)]
 #[cfg_attr(test, derive(PartialEq))]
 pub enum ErrorKind {
+    /// Whilst parsing as encountered an unexpected EOF.
     #[error("Unexpected end of file")]
     EndOfFile,
-    #[error("Invalid profile: {1}")]
-    InvalidProfile(SourceMetadata, String),
-    #[error("Invalid version: {1}")]
-    InvalidVersion(SourceMetadata, u64),
-    #[error("Expected {}, found {0}", join_with_comma(.1))]
-    InvalidToken(Token, Vec<ExpectedToken>),
-    #[error("Not implemented {0}")]
+    /// The shader specified an unsupported or invalid profile.
+    #[error("Invalid profile: {0}")]
+    InvalidProfile(String),
+    /// The shader requested an unsupported or invalid version.
+    #[error("Invalid version: {0}")]
+    InvalidVersion(u64),
+    /// Whilst parsing an unexpected token was encountered.
+    ///
+    /// A list of expected tokens is also returned.
+    #[error("Expected {}, found {0:?}", join_with_comma(.1))]
+    InvalidToken(TokenValue, Vec<ExpectedToken>),
+    /// A specific feature is not yet implemented.
+    ///
+    /// To help prioritize work please open an issue in the github issue tracker
+    /// if none exist already or react to the already existing one.
+    #[error("Not implemented: {0}")]
     NotImplemented(&'static str),
-    #[error("Unknown variable: {1}")]
-    UnknownVariable(SourceMetadata, String),
-    #[error("Unknown type: {1}")]
-    UnknownType(SourceMetadata, String),
-    #[error("Unknown field: {1}")]
-    UnknownField(SourceMetadata, String),
-    #[error("Unknown layout qualifier: {1}")]
-    UnknownLayoutQualifier(SourceMetadata, String),
+    /// A reference to a variable that wasn't declared was used.
+    #[error("Unknown variable: {0}")]
+    UnknownVariable(String),
+    /// A reference to a type that wasn't declared was used.
+    #[error("Unknown type: {0}")]
+    UnknownType(String),
+    /// A reference to a non existant member of a type was made.
+    #[error("Unknown field: {0}")]
+    UnknownField(String),
+    /// An unknown layout qualifier was used.
+    ///
+    /// If the qualifier does exist please open an issue in the github issue tracker
+    /// if none exist already or react to the already existing one to help
+    /// prioritize work.
+    #[error("Unknown layout qualifier: {0}")]
+    UnknownLayoutQualifier(String),
+    /// A variable with the same name already exists in the current scope.
     #[cfg(feature = "glsl-validate")]
-    #[error("Variable already declared: {1}")]
-    VariableAlreadyDeclared(SourceMetadata, String),
-    #[error("{1}")]
-    SemanticError(SourceMetadata, Cow<'static, str>),
+    #[error("Variable already declared: {0}")]
+    VariableAlreadyDeclared(String),
+    /// A semantic error was detected in the shader.
+    #[error("{0}")]
+    SemanticError(Cow<'static, str>),
+    /// An error was returned by the preprocessor.
+    #[error("{0:?}")]
+    PreprocessorError(PreprocessorError),
 }
 
-impl ErrorKind {
-    /// Returns the TokenMetadata if available
-    pub fn metadata(&self) -> Option<SourceMetadata> {
-        match *self {
-            ErrorKind::UnknownVariable(metadata, _)
-            | ErrorKind::InvalidProfile(metadata, _)
-            | ErrorKind::InvalidVersion(metadata, _)
-            | ErrorKind::UnknownLayoutQualifier(metadata, _)
-            | ErrorKind::SemanticError(metadata, _)
-            | ErrorKind::UnknownField(metadata, _) => Some(metadata),
-            #[cfg(feature = "glsl-validate")]
-            ErrorKind::VariableAlreadyDeclared(metadata, _) => Some(metadata),
-            ErrorKind::InvalidToken(ref token, _) => Some(token.meta),
-            _ => None,
-        }
-    }
-
-    pub(crate) fn wrong_function_args(
-        name: String,
-        expected: usize,
-        got: usize,
-        meta: SourceMetadata,
-    ) -> Self {
-        let msg = format!(
-            "Function \"{}\" expects {} arguments, got {}",
-            name, expected, got
-        );
-
-        ErrorKind::SemanticError(meta, msg.into())
+impl From<ConstantSolvingError> for ErrorKind {
+    fn from(err: ConstantSolvingError) -> Self {
+        ErrorKind::SemanticError(err.to_string().into())
     }
 }
 
-impl From<(SourceMetadata, ConstantSolvingError)> for ErrorKind {
-    fn from((meta, err): (SourceMetadata, ConstantSolvingError)) -> Self {
-        ErrorKind::SemanticError(meta, err.to_string().into())
-    }
-}
-
+/// Error returned during shader parsing
 #[derive(Debug, Error)]
 #[error("{kind}")]
-pub struct ParseError {
+#[cfg_attr(test, derive(PartialEq))]
+pub struct Error {
+    /// Holds the information about the error itself.
     pub kind: ErrorKind,
+    /// Holds information about the range of the source code where the error happened.
+    pub meta: SourceMetadata,
 }
-
-impl From<ErrorKind> for ParseError {
-    fn from(kind: ErrorKind) -> Self {
-        ParseError { kind }
-    }
-}