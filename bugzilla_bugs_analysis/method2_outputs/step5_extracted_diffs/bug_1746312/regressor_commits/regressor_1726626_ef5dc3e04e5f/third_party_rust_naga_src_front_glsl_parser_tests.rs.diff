# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/glsl/parser_tests.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/glsl/parser_tests.rs b/third_party/rust/naga/src/front/glsl/parser_tests.rs
--- a/third_party/rust/naga/src/front/glsl/parser_tests.rs
+++ b/third_party/rust/naga/src/front/glsl/parser_tests.rs
@@ -1,448 +1,540 @@
-use pp_rs::token::PreprocessorError;
-
-use super::lex::Lexer;
-use super::parser;
-use super::{ast::Profile, error::ErrorKind};
-use super::{ast::Program, SourceMetadata};
-use crate::front::glsl::error::ExpectedToken;
-use crate::{
-    front::glsl::{token::TokenValue, Token},
-    ShaderStage,
+use super::{
+    ast::Profile,
+    error::ExpectedToken,
+    error::{Error, ErrorKind},
+    token::TokenValue,
+    Options, Parser, SourceMetadata,
 };
-
-fn parse_program<'a>(
-    source: &str,
-    entry_points: &'a crate::FastHashMap<String, ShaderStage>,
-) -> Result<Program<'a>, ErrorKind> {
-    let mut program = Program::new(entry_points);
-    let defines = crate::FastHashMap::default();
-    let lex = Lexer::new(source, &defines);
-    let mut parser = parser::Parser::new(&mut program, lex);
-
-    parser.parse()?;
-    Ok(program)
-}
+use crate::ShaderStage;
+use pp_rs::token::PreprocessorError;
 
 #[test]
 fn version() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Vertex);
+    let mut parser = Parser::default();
+
     // invalid versions
     assert_eq!(
-        parse_program("#version 99000", &entry_points)
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                "#version 99000\n void main(){}",
+            )
             .err()
             .unwrap(),
-        ErrorKind::InvalidVersion(SourceMetadata { start: 9, end: 14 }, 99000),
+        vec![Error {
+            kind: ErrorKind::InvalidVersion(99000),
+            meta: SourceMetadata { start: 9, end: 14 }
+        }],
     );
 
     assert_eq!(
-        parse_program("#version 449", &entry_points).err().unwrap(),
-        ErrorKind::InvalidVersion(SourceMetadata { start: 9, end: 12 }, 449)
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                "#version 449\n void main(){}",
+            )
+            .err()
+            .unwrap(),
+        vec![Error {
+            kind: ErrorKind::InvalidVersion(449),
+            meta: SourceMetadata { start: 9, end: 12 }
+        }]
+    );
+
+    assert_eq!(
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                "#version 450 smart\n void main(){}",
+            )
+            .err()
+            .unwrap(),
+        vec![Error {
+            kind: ErrorKind::InvalidProfile("smart".into()),
+            meta: SourceMetadata { start: 13, end: 18 },
+        }]
     );
 
     assert_eq!(
-        parse_program("#version 450 smart", &entry_points)
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                "#version 450\nvoid main(){} #version 450",
+            )
             .err()
             .unwrap(),
-        ErrorKind::InvalidProfile(SourceMetadata { start: 13, end: 18 }, "smart".into())
-    );
-
-    assert_eq!(
-        parse_program("#version 450\nvoid f(){} #version 450", &entry_points)
-            .err()
-            .unwrap(),
-        ErrorKind::InvalidToken(
-            Token {
-                value: TokenValue::Unknown(PreprocessorError::UnexpectedHash),
-                meta: SourceMetadata { start: 24, end: 25 }
+        vec![
+            Error {
+                kind: ErrorKind::PreprocessorError(PreprocessorError::UnexpectedHash,),
+                meta: SourceMetadata { start: 27, end: 28 },
             },
-            vec![ExpectedToken::Eof]
-        )
+            Error {
+                kind: ErrorKind::InvalidToken(
+                    TokenValue::Identifier("version".into()),
+                    vec![ExpectedToken::Eof]
+                ),
+                meta: SourceMetadata { start: 28, end: 35 }
+            }
+        ]
     );
 
     // valid versions
-    let program = parse_program("  #  version 450\nvoid main() {}", &entry_points).unwrap();
-    assert_eq!((program.version, program.profile), (450, Profile::Core));
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            "  #  version 450\nvoid main() {}",
+        )
+        .unwrap();
+    assert_eq!(
+        (parser.metadata().version, parser.metadata().profile),
+        (450, Profile::Core)
+    );
 
-    let program = parse_program("#version 450\nvoid main() {}", &entry_points).unwrap();
-    assert_eq!((program.version, program.profile), (450, Profile::Core));
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            "#version 450\nvoid main() {}",
+        )
+        .unwrap();
+    assert_eq!(
+        (parser.metadata().version, parser.metadata().profile),
+        (450, Profile::Core)
+    );
 
-    let program = parse_program("#version 450 core\nvoid main() {}", &entry_points).unwrap();
-    assert_eq!((program.version, program.profile), (450, Profile::Core));
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            "#version 450 core\nvoid main() {}",
+        )
+        .unwrap();
+    assert_eq!(
+        (parser.metadata().version, parser.metadata().profile),
+        (450, Profile::Core)
+    );
 }
 
 #[test]
 fn control_flow() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Vertex);
+    let mut parser = Parser::default();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             if (true) {
                 return 1;
             } else {
                 return 2;
             }
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             if (true) {
                 return 1;
             }
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             int x;
             int y = 3;
             switch (5) {
                 case 2:
                     x = 2;
                 case 5:
                     x = 5;
                     y = 2;
                     break;
                 default:
                     x = 0;
             }
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
-    let _program = parse_program(
-        r#"
+        )
+        .unwrap();
+
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             int x = 0;
             while(x < 5) {
                 x = x + 1;
             }
             do {
                 x = x - 1;
             } while(x >= 4)
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             int x = 0;
             for(int i = 0; i < 10;) {
                 x = x + 2;
             }
             for(;;);
             return x;
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 }
 
 #[test]
 fn declarations() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Fragment);
+    let mut parser = Parser::default();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         layout(location = 0) in vec2 v_uv;
         layout(location = 0) out vec4 o_color;
         layout(set = 1, binding = 1) uniform texture2D tex;
         layout(set = 1, binding = 2) uniform sampler tex_sampler;
 
         layout(early_fragment_tests) in;
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         layout(std140, set = 2, binding = 0)
         uniform u_locals {
             vec3 model_offs;
             float load_time;
             ivec4 atlas_offs;
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
-        layout(push_constant, set = 2, binding = 0)
+        layout(push_constant)
         uniform u_locals {
             vec3 model_offs;
             float load_time;
             ivec4 atlas_offs;
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         layout(std430, set = 2, binding = 0)
         uniform u_locals {
             vec3 model_offs;
             float load_time;
             ivec4 atlas_offs;
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         layout(std140, set = 2, binding = 0)
         uniform u_locals {
             vec3 model_offs;
             float load_time;
         } block_var;
 
         void main() {
             load_time * model_offs;
             block_var.load_time * block_var.model_offs;
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         float vector = vec4(1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0);
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
+
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
+        #version 450
+        precision highp float;
+
+        void main() {}
+        "#,
+        )
+        .unwrap();
 }
 
 #[test]
 fn textures() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Fragment);
+    let mut parser = Parser::default();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #version 450
         layout(location = 0) in vec2 v_uv;
         layout(location = 0) out vec4 o_color;
         layout(set = 1, binding = 1) uniform texture2D tex;
         layout(set = 1, binding = 2) uniform sampler tex_sampler;
         void main() {
             o_color = texture(sampler2D(tex, tex_sampler), v_uv);
+            o_color.a = texture(sampler2D(tex, tex_sampler), v_uv, 2.0).a;
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 }
 
 #[test]
 fn functions() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Vertex);
+    let mut parser = Parser::default();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void test1(float);
         void test1(float) {}
 
         void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void test2(float a) {}
         void test3(float a, float b) {}
         void test4(float, float) {}
 
         void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         float test(float a) { return a; }
 
         void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         float test(vec4 p) {
             return p.x;
         }
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
     // Function overloading
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         float test(vec2 p);
         float test(vec3 p);
         float test(vec4 p);
 
         float test(vec2 p) {
             return p.x;
         }
 
         float test(vec3 p) {
             return p.x;
         }
 
         float test(vec4 p) {
             return p.x;
         }
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
     assert_eq!(
-        parse_program(
-            r#"
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                r#"
                 #  version 450
                 int test(vec4 p) {
                     return p.x;
                 }
 
                 float test(vec4 p) {
                     return p.x;
                 }
+
+                void main() {}
                 "#,
-            &entry_points
-        )
-        .err()
-        .unwrap(),
-        ErrorKind::SemanticError(
-            SourceMetadata {
+            )
+            .err()
+            .unwrap(),
+        vec![Error {
+            kind: ErrorKind::SemanticError("Function already defined".into()),
+            meta: SourceMetadata {
                 start: 134,
                 end: 152
             },
-            "Function already defined".into()
-        )
+        }]
     );
 
     println!();
 
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         float callee(uint q) {
             return float(q);
         }
 
         float caller() {
             callee(1u);
         }
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
     // Nested function call
-    let _program = parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
             #  version 450
             layout(set = 0, binding = 1) uniform texture2D t_noise;
             layout(set = 0, binding = 2) uniform sampler s_noise;
 
             void main() {
                 textureLod(sampler2D(t_noise, s_noise), vec2(1.0), 0);
             }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void fun(vec2 in_parameter, out float out_parameter) {
             ivec2 _ = ivec2(in_parameter);
         }
 
         void main() {
             float a;
             fun(vec2(1.0), a);
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 }
 
 #[test]
 fn constants() {
     use crate::{Constant, ConstantInner, ScalarValue};
+    let mut parser = Parser::default();
 
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Vertex);
-
-    let program = parse_program(
-        r#"
+    let module = parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         const float a = 1.0;
         float global = a;
         const float b = a;
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    let mut constants = program.module.constants.iter();
+    let mut constants = module.constants.iter();
 
     assert_eq!(
         constants.next().unwrap().1,
         &Constant {
             name: None,
             specialization: None,
             inner: ConstantInner::Scalar {
                 width: 4,
@@ -450,142 +542,289 @@ fn constants() {
             }
         }
     );
 
     assert!(constants.next().is_none());
 }
 
 #[test]
+fn function_overloading() {
+    let mut parser = Parser::default();
+
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
+        #  version 450
+
+        float saturate(float v) { return clamp(v, 0.0, 1.0); }
+        vec2 saturate(vec2 v) { return clamp(v, vec2(0.0), vec2(1.0)); }
+        vec3 saturate(vec3 v) { return clamp(v, vec3(0.0), vec3(1.0)); }
+        vec4 saturate(vec4 v) { return clamp(v, vec4(0.0), vec4(1.0)); }
+
+        void main() {
+            float v1 = saturate(1.5);
+            vec2 v2 = saturate(vec2(0.5, 1.5));
+            vec3 v3 = saturate(vec3(0.5, 1.5, 2.5));
+            vec3 v4 = saturate(vec4(0.5, 1.5, 2.5, 3.5));
+        }
+        "#,
+        )
+        .unwrap();
+}
+
+#[test]
 fn implicit_conversions() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Vertex);
+    let mut parser = Parser::default();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             mat4 a = mat4(1);
             float b = 1u;
             float c = 1 + 2.0;
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
+
+    assert_eq!(
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                r#"
+                #  version 450
+                void test(int a) {}
+                void test(uint a) {}
+
+                void main() {
+                    test(1.0);
+                }
+                "#,
+            )
+            .err()
+            .unwrap(),
+        vec![Error {
+            kind: ErrorKind::SemanticError("Unknown function \'test\'".into()),
+            meta: SourceMetadata {
+                start: 156,
+                end: 165
+            },
+        }]
+    );
+
+    assert_eq!(
+        parser
+            .parse(
+                &Options::from(ShaderStage::Vertex),
+                r#"
+                #  version 450
+                void test(float a) {}
+                void test(uint a) {}
+
+                void main() {
+                    test(1);
+                }
+                "#,
+            )
+            .err()
+            .unwrap(),
+        vec![Error {
+            kind: ErrorKind::SemanticError("Ambiguous best function for \'test\'".into()),
+            meta: SourceMetadata {
+                start: 158,
+                end: 165
+            },
+        }]
+    );
 }
 
 #[test]
 fn structs() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Fragment);
+    let mut parser = Parser::default();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         Test {
             vec4 pos;
           } xx;
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap_err();
+        )
+        .unwrap_err();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         struct Test {
             vec4 pos;
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         const int NUM_VECS = 42;
         struct Test {
             vec4 vecs[NUM_VECS];
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         struct Hello {
             vec4 test;
         } test() {
             return Hello( vec4(1.0) );
         }
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         struct Test {};
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap_err();
+        )
+        .unwrap_err();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         inout struct Test {
             vec4 x;
         };
+
+        void main() {}
         "#,
-        &entry_points,
-    )
-    .unwrap_err();
+        )
+        .unwrap_err();
 }
 
 #[test]
 fn swizzles() {
-    let mut entry_points = crate::FastHashMap::default();
-    entry_points.insert("".to_string(), ShaderStage::Fragment);
+    let mut parser = Parser::default();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             vec4 v = vec4(1);
             v.xyz = vec3(2);
             v.x = 5.0;
             v.xyz.zxy.yx.xy = vec2(5.0, 1.0);
         }
         "#,
-        &entry_points,
-    )
-    .unwrap();
+        )
+        .unwrap();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             vec4 v = vec4(1);
             v.xx = vec2(5.0);
         }
         "#,
-        &entry_points,
-    )
-    .unwrap_err();
+        )
+        .unwrap_err();
 
-    parse_program(
-        r#"
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
         #  version 450
         void main() {
             vec3 v = vec3(1);
             v.w = 2.0;
         }
         "#,
-        &entry_points,
-    )
-    .unwrap_err();
+        )
+        .unwrap_err();
 }
+
+#[test]
+fn expressions() {
+    let mut parser = Parser::default();
+
+    // Vector indexing
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
+        #  version 450
+        float test(int index) {
+            vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
+            return v[index] + 1.0;
+        }
+
+        void main() {}
+        "#,
+        )
+        .unwrap();
+
+    // Prefix increment/decrement
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
+        #  version 450
+        void main() {
+            uint index = 0;
+            
+            --index;
+            ++index;
+        }
+        "#,
+        )
+        .unwrap();
+
+    // Dynamic indexing of array
+    parser
+        .parse(
+            &Options::from(ShaderStage::Vertex),
+            r#"
+        #  version 450
+        void main() {
+            const vec4 positions[1] = { vec4(0) };
+
+            gl_Position = positions[gl_VertexIndex];
+        }
+        "#,
+        )
+        .unwrap();
+}