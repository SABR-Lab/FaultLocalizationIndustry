# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/glsl/token.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/glsl/token.rs b/third_party/rust/naga/src/front/glsl/token.rs
--- a/third_party/rust/naga/src/front/glsl/token.rs
+++ b/third_party/rust/naga/src/front/glsl/token.rs
@@ -1,67 +1,125 @@
-pub use pp_rs::token::{Float, Integer, PreprocessorError};
+use pp_rs::token::Location;
+pub use pp_rs::token::{Float, Integer, PreprocessorError, Token as PPToken};
 
+use super::ast::Precision;
 use crate::{Interpolation, Sampling, Type};
-use std::{fmt, ops::Range};
+use std::ops::Range;
 
+/// Represents a range of the source code
+///
+/// The `SourceMetadata` is used in error reporting to indicate a range of the
+/// original source code where the error happened.
+///
+/// For easy interaction with error crates like
+/// [`codespan`][codespan] the [`From`](From) trait is
+/// implemeted for [`Range<usize>`](Range) allowing for conversions from `SourceMetadata`.
+///
+/// ```rust
+/// # use naga::front::glsl::SourceMetadata;
+/// # use std::ops::Range;
+/// # let meta = SourceMetadata::default();
+/// let range: Range<usize> = meta.into();
+/// ```
+///
+/// Or in the case of [`codespan`][codespan]
+///
+/// ```rust
+/// # use naga::front::glsl::SourceMetadata;
+/// use codespan_reporting::diagnostic::Label;
+/// # let file = ();
+/// # let meta = SourceMetadata::default();
+/// let label = Label::primary(file, meta);
+/// ```
+///
+/// # Notes
+///
+/// [`start`](SourceMetadata::start) can be equal to
+/// [`end`](SourceMetadata::end) especially when reporting errors which aren't
+/// associated with a specific portion of the code.
+///
+/// [codespan]: https://docs.rs/codespan-reporting
 #[derive(Debug, Clone, Copy, Default)]
 #[cfg_attr(test, derive(PartialEq))]
 pub struct SourceMetadata {
     /// Byte offset into the source where the first char starts
     pub start: usize,
     /// Byte offset into the source where the first char not belonging to this
     /// source metadata starts
     pub end: usize,
 }
 
 impl SourceMetadata {
-    pub fn union(&self, other: &Self) -> Self {
+    pub(crate) fn union(&self, other: &Self) -> Self {
         SourceMetadata {
             start: self.start.min(other.start),
             end: self.end.max(other.end),
         }
     }
+
+    pub fn as_span(&self) -> crate::Span {
+        crate::Span::ByteRange(self.start..self.end)
+    }
+
+    pub(crate) fn none() -> Self {
+        SourceMetadata::default()
+    }
+}
+
+impl From<Location> for SourceMetadata {
+    fn from(loc: Location) -> Self {
+        SourceMetadata {
+            start: loc.start as usize,
+            end: loc.end as usize,
+        }
+    }
 }
 
 impl From<SourceMetadata> for Range<usize> {
     fn from(meta: SourceMetadata) -> Self {
         meta.start..meta.end
     }
 }
 
 #[derive(Debug)]
 #[cfg_attr(test, derive(PartialEq))]
 pub struct Token {
     pub value: TokenValue,
     pub meta: SourceMetadata,
 }
 
+/// A token passed from the lexing used in the parsing
+///
+/// This type is exported since it's returned in the
+/// [`InvalidToken`](super::ErrorKind::InvalidToken) error.
 #[derive(Debug, PartialEq)]
 pub enum TokenValue {
-    Unknown(PreprocessorError),
     Identifier(String),
 
-    Extension,
-    Version,
-    Pragma,
-
     FloatConstant(Float),
     IntConstant(Integer),
     BoolConstant(bool),
 
     Layout,
     In,
     Out,
     InOut,
     Uniform,
     Buffer,
     Const,
+    Shared,
+
+    Restrict,
+    StorageAccess(crate::StorageAccess),
+
     Interpolation(Interpolation),
     Sampling(Sampling),
+    Precision,
+    PrecisionQualifier(Precision),
 
     Continue,
     Break,
     Return,
     Discard,
 
     If,
     Else,
@@ -124,13 +182,22 @@ pub enum TokenValue {
     Slash,
     Percent,
     VerticalBar,
     Caret,
     Ampersand,
     Question,
 }
 
-impl fmt::Display for Token {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{:?}", self.value)
-    }
+#[derive(Debug)]
+#[cfg_attr(test, derive(PartialEq))]
+pub struct Directive {
+    pub kind: DirectiveKind,
+    pub tokens: Vec<PPToken>,
 }
+
+#[derive(Debug)]
+#[cfg_attr(test, derive(PartialEq))]
+pub enum DirectiveKind {
+    Version { is_first_directive: bool },
+    Extension,
+    Pragma,
+}