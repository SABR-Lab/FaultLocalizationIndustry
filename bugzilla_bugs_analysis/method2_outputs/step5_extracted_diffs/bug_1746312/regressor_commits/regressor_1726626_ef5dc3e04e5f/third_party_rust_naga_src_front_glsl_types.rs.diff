# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/glsl/types.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/glsl/types.rs b/third_party/rust/naga/src/front/glsl/types.rs
--- a/third_party/rust/naga/src/front/glsl/types.rs
+++ b/third_party/rust/naga/src/front/glsl/types.rs
@@ -1,17 +1,23 @@
-use crate::{ScalarKind, Type, TypeInner, VectorSize};
+use super::{
+    constants::ConstantSolver, context::Context, Error, ErrorKind, Parser, Result, SourceMetadata,
+};
+use crate::{
+    proc::ResolveContext, ArraySize, Bytes, Constant, Expression, Handle, ImageClass,
+    ImageDimension, ScalarKind, Type, TypeInner, VectorSize,
+};
 
 pub fn parse_type(type_name: &str) -> Option<Type> {
     match type_name {
         "bool" => Some(Type {
             name: None,
             inner: TypeInner::Scalar {
                 kind: ScalarKind::Bool,
-                width: 4, // https://stackoverflow.com/questions/9419781/what-is-the-size-of-glsl-boolean
+                width: crate::BOOL_WIDTH,
             },
         }),
         "float" => Some(Type {
             name: None,
             inner: TypeInner::Scalar {
                 kind: ScalarKind::Float,
                 width: 4,
             },
@@ -32,36 +38,27 @@ pub fn parse_type(type_name: &str) -> Op
         }),
         "uint" => Some(Type {
             name: None,
             inner: TypeInner::Scalar {
                 kind: ScalarKind::Uint,
                 width: 4,
             },
         }),
-        "texture2D" => Some(Type {
+        "sampler" | "samplerShadow" => Some(Type {
             name: None,
-            inner: TypeInner::Image {
-                dim: crate::ImageDimension::D2,
-                arrayed: false,
-                class: crate::ImageClass::Sampled {
-                    kind: ScalarKind::Float,
-                    multi: false,
-                },
+            inner: TypeInner::Sampler {
+                comparison: type_name == "samplerShadow",
             },
         }),
-        "sampler" => Some(Type {
-            name: None,
-            inner: TypeInner::Sampler { comparison: false },
-        }),
         word => {
             fn kind_width_parse(ty: &str) -> Option<(ScalarKind, u8)> {
                 Some(match ty {
                     "" => (ScalarKind::Float, 4),
-                    "b" => (ScalarKind::Bool, 4),
+                    "b" => (ScalarKind::Bool, crate::BOOL_WIDTH),
                     "i" => (ScalarKind::Sint, 4),
                     "u" => (ScalarKind::Uint, 4),
                     "d" => (ScalarKind::Float, 8),
                     _ => return None,
                 })
             }
 
             fn size_parse(n: &str) -> Option<VectorSize> {
@@ -109,12 +106,175 @@ pub fn parse_type(type_name: &str) -> Op
                     inner: TypeInner::Matrix {
                         columns,
                         rows,
                         width,
                     },
                 })
             };
 
-            vec_parse(word).or_else(|| mat_parse(word))
+            let texture_parse = |word: &str| {
+                let mut iter = word.split("texture");
+
+                let texture_kind = |ty| {
+                    Some(match ty {
+                        "" => ScalarKind::Float,
+                        "i" => ScalarKind::Sint,
+                        "u" => ScalarKind::Uint,
+                        _ => return None,
+                    })
+                };
+
+                let kind = iter.next()?;
+                let size = iter.next()?;
+                let kind = texture_kind(kind)?;
+
+                let sampled = |multi| ImageClass::Sampled { kind, multi };
+
+                let (dim, arrayed, class) = match size {
+                    "1D" => (ImageDimension::D1, false, sampled(false)),
+                    "1DArray" => (ImageDimension::D1, false, sampled(false)),
+                    "2D" => (ImageDimension::D2, false, sampled(false)),
+                    "2DArray" => (ImageDimension::D2, false, sampled(false)),
+                    "2DMS" => (ImageDimension::D2, true, sampled(true)),
+                    "2DMSArray" => (ImageDimension::D2, true, sampled(true)),
+                    "3D" => (ImageDimension::D3, false, sampled(false)),
+                    "Cube" => (ImageDimension::Cube, false, sampled(false)),
+                    "CubeArray" => (ImageDimension::D2, false, sampled(false)),
+                    _ => return None,
+                };
+
+                Some(Type {
+                    name: None,
+                    inner: TypeInner::Image {
+                        dim,
+                        arrayed,
+                        class,
+                    },
+                })
+            };
+
+            vec_parse(word)
+                .or_else(|| mat_parse(word))
+                .or_else(|| texture_parse(word))
         }
     }
 }
+
+pub fn scalar_components(ty: &TypeInner) -> Option<(ScalarKind, Bytes)> {
+    match *ty {
+        TypeInner::Scalar { kind, width } => Some((kind, width)),
+        TypeInner::Vector { kind, width, .. } => Some((kind, width)),
+        TypeInner::Matrix { width, .. } => Some((ScalarKind::Float, width)),
+        TypeInner::ValuePointer { kind, width, .. } => Some((kind, width)),
+        _ => None,
+    }
+}
+
+pub fn type_power(kind: ScalarKind, width: Bytes) -> Option<u32> {
+    Some(match kind {
+        ScalarKind::Sint => 0,
+        ScalarKind::Uint => 1,
+        ScalarKind::Float if width == 4 => 2,
+        ScalarKind::Float => 3,
+        ScalarKind::Bool => return None,
+    })
+}
+
+impl Parser {
+    pub(crate) fn typifier_grow(
+        &self,
+        ctx: &mut Context,
+        handle: Handle<Expression>,
+        meta: SourceMetadata,
+    ) -> Result<()> {
+        let resolve_ctx = ResolveContext {
+            constants: &self.module.constants,
+            types: &self.module.types,
+            global_vars: &self.module.global_variables,
+            local_vars: &ctx.locals,
+            functions: &self.module.functions,
+            arguments: &ctx.arguments,
+        };
+
+        ctx.typifier
+            .grow(handle, &ctx.expressions, &resolve_ctx)
+            .map_err(|error| Error {
+                kind: ErrorKind::SemanticError(format!("Can't resolve type: {:?}", error).into()),
+                meta,
+            })
+    }
+
+    pub(crate) fn resolve_type<'b>(
+        &'b self,
+        ctx: &'b mut Context,
+        handle: Handle<Expression>,
+        meta: SourceMetadata,
+    ) -> Result<&'b TypeInner> {
+        self.typifier_grow(ctx, handle, meta)?;
+        Ok(ctx.typifier.get(handle, &self.module.types))
+    }
+
+    /// Invalidates the cached type resolution for `handle` forcing a recomputation
+    pub(crate) fn invalidate_expression<'b>(
+        &'b self,
+        ctx: &'b mut Context,
+        handle: Handle<Expression>,
+        meta: SourceMetadata,
+    ) -> Result<()> {
+        let resolve_ctx = ResolveContext {
+            constants: &self.module.constants,
+            types: &self.module.types,
+            global_vars: &self.module.global_variables,
+            local_vars: &ctx.locals,
+            functions: &self.module.functions,
+            arguments: &ctx.arguments,
+        };
+
+        ctx.typifier
+            .invalidate(handle, &ctx.expressions, &resolve_ctx)
+            .map_err(|error| Error {
+                kind: ErrorKind::SemanticError(format!("Can't resolve type: {:?}", error).into()),
+                meta,
+            })
+    }
+
+    pub(crate) fn solve_constant(
+        &mut self,
+        ctx: &Context,
+        root: Handle<Expression>,
+        meta: SourceMetadata,
+    ) -> Result<Handle<Constant>> {
+        let mut solver = ConstantSolver {
+            types: &self.module.types,
+            expressions: &ctx.expressions,
+            constants: &mut self.module.constants,
+        };
+
+        solver.solve(root).map_err(|e| Error {
+            kind: e.into(),
+            meta,
+        })
+    }
+
+    pub(crate) fn maybe_array(
+        &mut self,
+        base: Handle<Type>,
+        meta: SourceMetadata,
+        array_specifier: Option<(ArraySize, SourceMetadata)>,
+    ) -> Handle<Type> {
+        array_specifier
+            .map(|(size, size_meta)| {
+                self.module.types.fetch_or_append(
+                    Type {
+                        name: None,
+                        inner: TypeInner::Array {
+                            base,
+                            size,
+                            stride: self.module.types[base].inner.span(&self.module.constants),
+                        },
+                    },
+                    meta.union(&size_meta).as_span(),
+                )
+            })
+            .unwrap_or(base)
+    }
+}