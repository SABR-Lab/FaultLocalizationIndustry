# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/mod.rs b/third_party/rust/naga/src/front/mod.rs
--- a/third_party/rust/naga/src/front/mod.rs
+++ b/third_party/rust/naga/src/front/mod.rs
@@ -6,16 +6,17 @@ pub mod glsl;
 pub mod spv;
 #[cfg(feature = "wgsl-in")]
 pub mod wgsl;
 
 use crate::{
     arena::{Arena, Handle},
     proc::{ResolveContext, ResolveError, TypeResolution},
 };
+use std::ops;
 
 /// Helper class to emit expressions
 #[allow(dead_code)]
 #[derive(Default, Debug)]
 struct Emitter {
     start_len: Option<usize>,
 }
 
@@ -23,20 +24,30 @@ struct Emitter {
 impl Emitter {
     fn start(&mut self, arena: &Arena<crate::Expression>) {
         if self.start_len.is_some() {
             unreachable!("Emitting has already started!");
         }
         self.start_len = Some(arena.len());
     }
     #[must_use]
-    fn finish(&mut self, arena: &Arena<crate::Expression>) -> Option<crate::Statement> {
+    fn finish(
+        &mut self,
+        arena: &Arena<crate::Expression>,
+    ) -> Option<(crate::Statement, crate::span::Span)> {
         let start_len = self.start_len.take().unwrap();
         if start_len != arena.len() {
-            Some(crate::Statement::Emit(arena.range_from(start_len)))
+            #[allow(unused_mut)]
+            let mut span = crate::span::Span::Unknown;
+            let range = arena.range_from(start_len);
+            #[cfg(feature = "span")]
+            for handle in range.clone() {
+                span.subsume(arena.get_span(handle))
+            }
+            Some((crate::Statement::Emit(range), span))
         } else {
             None
         }
     }
 }
 
 #[allow(dead_code)]
 impl super::ConstantInner {
@@ -44,68 +55,75 @@ impl super::ConstantInner {
         Self::Scalar {
             width: super::BOOL_WIDTH,
             value: super::ScalarValue::Bool(value),
         }
     }
 }
 
 /// Helper processor that derives the types of all expressions.
-#[derive(Debug)]
+#[derive(Debug, Default)]
 pub struct Typifier {
     resolutions: Vec<TypeResolution>,
 }
 
 impl Typifier {
     pub fn new() -> Self {
         Typifier {
             resolutions: Vec::new(),
         }
     }
 
+    pub fn reset(&mut self) {
+        self.resolutions.clear()
+    }
+
     pub fn get<'a>(
         &'a self,
         expr_handle: Handle<crate::Expression>,
         types: &'a Arena<crate::Type>,
     ) -> &'a crate::TypeInner {
         self.resolutions[expr_handle.index()].inner_with(types)
     }
 
-    pub fn get_handle(
-        &mut self,
-        expr_handle: Handle<crate::Expression>,
-        types: &mut Arena<crate::Type>,
-    ) -> Handle<crate::Type> {
-        let mut dummy = TypeResolution::Value(crate::TypeInner::Sampler { comparison: false });
-        let res = &mut self.resolutions[expr_handle.index()];
-
-        std::mem::swap(&mut dummy, res);
-
-        let v = match dummy {
-            TypeResolution::Handle(h) => h,
-            TypeResolution::Value(inner) => {
-                let h = types.fetch_or_append(crate::Type { name: None, inner });
-                dummy = TypeResolution::Handle(h);
-                h
-            }
-        };
-
-        std::mem::swap(&mut dummy, res);
-
-        v
-    }
-
     pub fn grow(
         &mut self,
         expr_handle: Handle<crate::Expression>,
         expressions: &Arena<crate::Expression>,
         ctx: &ResolveContext,
     ) -> Result<(), ResolveError> {
         if self.resolutions.len() <= expr_handle.index() {
             for (eh, expr) in expressions.iter().skip(self.resolutions.len()) {
                 let resolution = ctx.resolve(expr, |h| &self.resolutions[h.index()])?;
                 log::debug!("Resolving {:?} = {:?} : {:?}", eh, expr, resolution);
                 self.resolutions.push(resolution);
             }
         }
         Ok(())
     }
+
+    /// Invalidates the cached type resolution for `epxr_handle` forcing a recomputation
+    ///
+    /// If the type of the expression hasn't yet been calculated a
+    /// [`grow`](Self::grow) is performed instead
+    pub fn invalidate(
+        &mut self,
+        expr_handle: Handle<crate::Expression>,
+        expressions: &Arena<crate::Expression>,
+        ctx: &ResolveContext,
+    ) -> Result<(), ResolveError> {
+        if self.resolutions.len() <= expr_handle.index() {
+            self.grow(expr_handle, expressions, ctx)
+        } else {
+            let expr = &expressions[expr_handle];
+            let resolution = ctx.resolve(expr, |h| &self.resolutions[h.index()])?;
+            self.resolutions[expr_handle.index()] = resolution;
+            Ok(())
+        }
+    }
 }
+
+impl ops::Index<Handle<crate::Expression>> for Typifier {
+    type Output = TypeResolution;
+    fn index(&self, handle: Handle<crate::Expression>) -> &Self::Output {
+        &self.resolutions[handle.index()]
+    }
+}