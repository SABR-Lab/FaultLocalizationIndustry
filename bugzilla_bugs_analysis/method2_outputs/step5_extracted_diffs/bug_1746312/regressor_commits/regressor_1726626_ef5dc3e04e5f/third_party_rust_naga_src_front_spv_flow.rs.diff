# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/spv/flow.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/spv/flow.rs b/third_party/rust/naga/src/front/spv/flow.rs
--- a/third_party/rust/naga/src/front/spv/flow.rs
+++ b/third_party/rust/naga/src/front/spv/flow.rs
@@ -522,20 +522,23 @@ impl FlowGraph {
     ) {
         for node_index in self.flow.node_indices() {
             let phis = std::mem::take(&mut self.flow[node_index].phis);
             for phi in phis.iter() {
                 for &(variable_id, parent_id) in phi.variables.iter() {
                     let variable = &lookup_expression[&variable_id];
                     let parent_node = &mut self.flow[self.block_to_node[&parent_id]];
 
-                    parent_node.block.push(crate::Statement::Store {
-                        pointer: phi.pointer,
-                        value: variable.handle,
-                    });
+                    parent_node.block.push(
+                        crate::Statement::Store {
+                            pointer: phi.pointer,
+                            value: variable.handle,
+                        },
+                        crate::Span::Unknown,
+                    );
                 }
             }
             self.flow[node_index].phis = phis;
         }
     }
 
     /// Traverses the flow graph and returns a list of Naga's statements.
     pub(super) fn convert_to_naga(&mut self) -> Result<crate::Block, Error> {
@@ -543,17 +546,17 @@ impl FlowGraph {
     }
 
     fn convert_to_naga_traverse(
         &mut self,
         node_index: BlockNodeIndex,
         stop_nodes: std::collections::HashSet<BlockNodeIndex>,
     ) -> Result<crate::Block, Error> {
         if stop_nodes.contains(&node_index) {
-            return Ok(vec![]);
+            return Ok(crate::Block::new());
         }
 
         if self.flow[node_index].visited {
             return Err(Error::ControlFlowGraphCycle(self.flow[node_index].id));
         }
 
         self.flow[node_index].visited = true;
 
@@ -642,31 +645,35 @@ impl FlowGraph {
                                 .edges_directed(target_index, Direction::Outgoing)
                                 .next()
                                 .unwrap()
                                 .weight();
                             if edge == ControlFlowEdgeType::SwitchBreak
                                 || edge == ControlFlowEdgeType::LoopBreak
                             {
                                 // Do not add break if already has one as the last statement
-                                if let Some(&crate::Statement::Break) = statements.last() {
+                                if let Some(&crate::Statement::Break) = statements.as_ref().last() {
                                 } else {
-                                    statements.push(crate::Statement::Break);
+                                    statements.push(crate::Statement::Break, crate::Span::Unknown);
                                 }
                             }
                         }
                     }
 
-                    result.push(crate::Statement::If {
-                        condition,
-                        accept,
-                        reject,
-                    });
+                    result.push(
+                        crate::Statement::If {
+                            condition,
+                            accept,
+                            reject,
+                        },
+                        crate::Span::Unknown,
+                    );
 
-                    result.extend(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
+                    result
+                        .extend_block(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
 
                     Ok(result)
                 }
                 Terminator::Switch {
                     selector,
                     default_id,
                     ref targets,
                 } => {
@@ -698,26 +705,30 @@ impl FlowGraph {
                             body: self.convert_to_naga_traverse(
                                 left_target_node_index,
                                 stop_nodes_cases.clone(),
                             )?,
                             fall_through,
                         });
                     }
 
-                    result.push(crate::Statement::Switch {
-                        selector,
-                        cases,
-                        default: self.convert_to_naga_traverse(
-                            self.block_to_node[&default_id],
-                            stop_nodes_cases,
-                        )?,
-                    });
+                    result.push(
+                        crate::Statement::Switch {
+                            selector,
+                            cases,
+                            default: self.convert_to_naga_traverse(
+                                self.block_to_node[&default_id],
+                                stop_nodes_cases,
+                            )?,
+                        },
+                        crate::Span::Unknown,
+                    );
 
-                    result.extend(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
+                    result
+                        .extend_block(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
 
                     Ok(result)
                 }
                 _ => Err(Error::InvalidTerminator),
             },
             Some(ControlFlowNodeType::Loop) => {
                 let merge_node_index =
                     self.block_to_node[&self.flow[node_index].merge.unwrap().merge_block_id];
@@ -740,44 +751,51 @@ impl FlowGraph {
                     Terminator::BranchConditional {
                         condition,
                         true_id,
                         false_id,
                     } => {
                         let true_node_index = self.block_to_node[&true_id];
                         let false_node_index = self.block_to_node[&false_id];
 
-                        body.push(crate::Statement::If {
-                            condition,
-                            accept: if true_node_index == merge_node_index {
-                                vec![crate::Statement::Break]
-                            } else {
-                                self.convert_to_naga_traverse(
-                                    true_node_index,
-                                    stop_nodes_merge.clone(),
-                                )?
+                        body.push(
+                            crate::Statement::If {
+                                condition,
+                                accept: if true_node_index == merge_node_index {
+                                    crate::Block::from_vec(vec![crate::Statement::Break])
+                                } else {
+                                    self.convert_to_naga_traverse(
+                                        true_node_index,
+                                        stop_nodes_merge.clone(),
+                                    )?
+                                },
+                                reject: if false_node_index == merge_node_index {
+                                    crate::Block::from_vec(vec![crate::Statement::Break])
+                                } else {
+                                    self.convert_to_naga_traverse(
+                                        false_node_index,
+                                        stop_nodes_merge,
+                                    )?
+                                },
                             },
-                            reject: if false_node_index == merge_node_index {
-                                vec![crate::Statement::Break]
-                            } else {
-                                self.convert_to_naga_traverse(false_node_index, stop_nodes_merge)?
-                            },
-                        });
+                            crate::Span::Unknown,
+                        );
                     }
                     Terminator::Branch { target_id } => {
-                        body.extend(self.convert_to_naga_traverse(
+                        body.extend_block(self.convert_to_naga_traverse(
                             self.block_to_node[&target_id],
                             stop_nodes_merge,
                         )?)
                     }
                     _ => return Err(Error::InvalidTerminator),
                 };
 
-                let mut result = vec![crate::Statement::Loop { body, continuing }];
-                result.extend(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
+                let mut result =
+                    crate::Block::from_vec(vec![crate::Statement::Loop { body, continuing }]);
+                result.extend_block(self.convert_to_naga_traverse(merge_node_index, stop_nodes)?);
 
                 Ok(result)
             }
             Some(ControlFlowNodeType::Break) => {
                 let mut result: crate::Block = std::mem::take(&mut self.flow[node_index].block);
                 match self.flow[node_index].terminator {
                     Terminator::BranchConditional {
                         condition,
@@ -790,76 +808,84 @@ impl FlowGraph {
                         let true_edge =
                             self.flow[self.flow.find_edge(node_index, true_node_id).unwrap()];
                         let false_edge =
                             self.flow[self.flow.find_edge(node_index, false_node_id).unwrap()];
 
                         if true_edge == ControlFlowEdgeType::LoopBreak
                             || true_edge == ControlFlowEdgeType::IfBreak
                         {
-                            result.push(crate::Statement::If {
-                                condition,
-                                accept: if true_edge == ControlFlowEdgeType::LoopBreak {
-                                    vec![crate::Statement::Break]
-                                } else {
-                                    vec![]
+                            result.push(
+                                crate::Statement::If {
+                                    condition,
+                                    accept: if true_edge == ControlFlowEdgeType::LoopBreak {
+                                        crate::Block::from_vec(vec![crate::Statement::Break])
+                                    } else {
+                                        crate::Block::new()
+                                    },
+                                    reject: self
+                                        .convert_to_naga_traverse(false_node_id, stop_nodes)?,
                                 },
-                                reject: self.convert_to_naga_traverse(false_node_id, stop_nodes)?,
-                            });
+                                crate::Span::Unknown,
+                            );
                         } else if false_edge == ControlFlowEdgeType::LoopBreak
                             || false_edge == ControlFlowEdgeType::IfBreak
                         {
-                            result.push(crate::Statement::If {
-                                condition,
-                                accept: self.convert_to_naga_traverse(true_node_id, stop_nodes)?,
-                                reject: if false_edge == ControlFlowEdgeType::LoopBreak {
-                                    vec![crate::Statement::Break]
-                                } else {
-                                    vec![]
+                            result.push(
+                                crate::Statement::If {
+                                    condition,
+                                    accept: self
+                                        .convert_to_naga_traverse(true_node_id, stop_nodes)?,
+                                    reject: if false_edge == ControlFlowEdgeType::LoopBreak {
+                                        crate::Block::from_vec(vec![crate::Statement::Break])
+                                    } else {
+                                        crate::Block::new()
+                                    },
                                 },
-                            });
+                                crate::Span::Unknown,
+                            );
                         } else {
                             return Err(Error::InvalidEdgeClassification);
                         }
                     }
                     Terminator::Branch { target_id } => {
                         let target_index = self.block_to_node[&target_id];
 
                         let edge =
                             self.flow[self.flow.find_edge(node_index, target_index).unwrap()];
 
                         if edge == ControlFlowEdgeType::LoopBreak {
-                            result.push(crate::Statement::Break);
+                            result.push(crate::Statement::Break, crate::Span::Unknown);
                         }
                     }
                     _ => return Err(Error::InvalidTerminator),
                 };
                 Ok(result)
             }
             Some(ControlFlowNodeType::Continue) | Some(ControlFlowNodeType::Back) => {
                 Ok(std::mem::take(&mut self.flow[node_index].block))
             }
             Some(ControlFlowNodeType::Kill) => {
                 let mut result: crate::Block = std::mem::take(&mut self.flow[node_index].block);
-                result.push(crate::Statement::Kill);
+                result.push(crate::Statement::Kill, crate::Span::Unknown);
                 Ok(result)
             }
             Some(ControlFlowNodeType::Return) => {
                 let value = match self.flow[node_index].terminator {
                     Terminator::Return { value } => value,
                     _ => return Err(Error::InvalidTerminator),
                 };
                 let mut result: crate::Block = std::mem::take(&mut self.flow[node_index].block);
-                result.push(crate::Statement::Return { value });
+                result.push(crate::Statement::Return { value }, crate::Span::Unknown);
                 Ok(result)
             }
             Some(ControlFlowNodeType::Merge) | None => match self.flow[node_index].terminator {
                 Terminator::Branch { target_id } => {
-                    let mut result: crate::Block = std::mem::take(&mut self.flow[node_index].block);
-                    result.extend(
+                    let mut result = std::mem::take(&mut self.flow[node_index].block);
+                    result.extend_block(
                         self.convert_to_naga_traverse(self.block_to_node[&target_id], stop_nodes)?,
                     );
                     Ok(result)
                 }
                 _ => Ok(std::mem::take(&mut self.flow[node_index].block)),
             },
         }
     }