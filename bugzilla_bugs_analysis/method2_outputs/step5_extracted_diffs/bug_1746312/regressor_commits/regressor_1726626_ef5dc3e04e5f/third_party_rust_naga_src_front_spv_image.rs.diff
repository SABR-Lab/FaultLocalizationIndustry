# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/spv/image.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/spv/image.rs b/third_party/rust/naga/src/front/spv/image.rs
--- a/third_party/rust/naga/src/front/spv/image.rs
+++ b/third_party/rust/naga/src/front/spv/image.rs
@@ -1,9 +1,12 @@
-use crate::arena::{Arena, Handle};
+use crate::{
+    arena::{Arena, Handle},
+    FunctionArgument,
+};
 
 use super::{Error, LookupExpression, LookupHelper as _};
 
 #[derive(Clone, Debug)]
 pub(super) struct LookupSampledImage {
     image: Handle<crate::Expression>,
     sampler: Handle<crate::Expression>,
 }
@@ -14,23 +17,26 @@ bitflags::bitflags! {
         /// Regular sampling.
         const REGULAR = 0x1;
         /// Comparison sampling.
         const COMPARISON = 0x2;
     }
 }
 
 impl Arena<crate::Expression> {
-    fn get_global_var(
+    fn get_image_expr_ty(
         &self,
         handle: Handle<crate::Expression>,
-    ) -> Result<Handle<crate::GlobalVariable>, Error> {
+        global_vars: &Arena<crate::GlobalVariable>,
+        arguments: &[FunctionArgument],
+    ) -> Result<Handle<crate::Type>, Error> {
         match self[handle] {
-            crate::Expression::GlobalVariable(handle) => Ok(handle),
-            ref other => Err(Error::InvalidGlobalVar(other.clone())),
+            crate::Expression::GlobalVariable(handle) => Ok(global_vars[handle].ty),
+            crate::Expression::FunctionArgument(i) => Ok(arguments[i as usize].ty),
+            ref other => Err(Error::InvalidImageExpression(other.clone())),
         }
     }
 }
 
 /// Options of a sampling operation.
 #[derive(Debug)]
 pub struct SamplingOptions {
     /// Projection sampling: the division by W is expected to happen
@@ -78,85 +84,111 @@ fn extract_image_coordinates(
             })
             .expect("Required coordinate type should have been set up by `parse_type_image`!")
     });
     let extra_expr = crate::Expression::AccessIndex {
         base,
         index: required_size.map_or(1, |size| size as u32),
     };
 
+    let base_span = expressions.get_span(base).clone();
+
     match extra_coordinate {
         ExtraCoordinate::ArrayLayer => {
             let extracted = match required_size {
-                None => expressions.append(crate::Expression::AccessIndex { base, index: 0 }),
+                None => expressions.append(
+                    crate::Expression::AccessIndex { base, index: 0 },
+                    base_span.clone(),
+                ),
                 Some(size) => {
                     let mut components = Vec::with_capacity(size as usize);
                     for index in 0..size as u32 {
-                        let comp =
-                            expressions.append(crate::Expression::AccessIndex { base, index });
+                        let comp = expressions.append(
+                            crate::Expression::AccessIndex { base, index },
+                            base_span.clone(),
+                        );
                         components.push(comp);
                     }
-                    expressions.append(crate::Expression::Compose {
-                        ty: required_ty.unwrap(),
-                        components,
-                    })
+                    expressions.append(
+                        crate::Expression::Compose {
+                            ty: required_ty.unwrap(),
+                            components,
+                        },
+                        base_span.clone(),
+                    )
                 }
             };
-            let array_index_f32 = expressions.append(extra_expr);
-            let array_index = expressions.append(crate::Expression::As {
-                kind: crate::ScalarKind::Sint,
-                expr: array_index_f32,
-                convert: Some(4),
-            });
+            let array_index_f32 = expressions.append(extra_expr, base_span.clone());
+            let array_index = expressions.append(
+                crate::Expression::As {
+                    kind: crate::ScalarKind::Sint,
+                    expr: array_index_f32,
+                    convert: Some(4),
+                },
+                base_span,
+            );
             (extracted, Some(array_index))
         }
         ExtraCoordinate::Projection => {
-            let projection = expressions.append(extra_expr);
+            let projection = expressions.append(extra_expr, base_span.clone());
             let divided = match required_size {
                 None => {
-                    let temp =
-                        expressions.append(crate::Expression::AccessIndex { base, index: 0 });
-                    expressions.append(crate::Expression::Binary {
-                        op: crate::BinaryOperator::Divide,
-                        left: temp,
-                        right: projection,
-                    })
+                    let temp = expressions.append(
+                        crate::Expression::AccessIndex { base, index: 0 },
+                        base_span.clone(),
+                    );
+                    expressions.append(
+                        crate::Expression::Binary {
+                            op: crate::BinaryOperator::Divide,
+                            left: temp,
+                            right: projection,
+                        },
+                        base_span,
+                    )
                 }
                 Some(size) => {
                     let mut components = Vec::with_capacity(size as usize);
                     for index in 0..size as u32 {
-                        let temp =
-                            expressions.append(crate::Expression::AccessIndex { base, index });
-                        let comp = expressions.append(crate::Expression::Binary {
-                            op: crate::BinaryOperator::Divide,
-                            left: temp,
-                            right: projection,
-                        });
+                        let temp = expressions.append(
+                            crate::Expression::AccessIndex { base, index },
+                            base_span.clone(),
+                        );
+                        let comp = expressions.append(
+                            crate::Expression::Binary {
+                                op: crate::BinaryOperator::Divide,
+                                left: temp,
+                                right: projection,
+                            },
+                            base_span.clone(),
+                        );
                         components.push(comp);
                     }
-                    expressions.append(crate::Expression::Compose {
-                        ty: required_ty.unwrap(),
-                        components,
-                    })
+                    expressions.append(
+                        crate::Expression::Compose {
+                            ty: required_ty.unwrap(),
+                            components,
+                        },
+                        base_span,
+                    )
                 }
             };
             (divided, None)
         }
         ExtraCoordinate::Garbage if given_size == required_size => (base, None),
         ExtraCoordinate::Garbage => {
             use crate::SwizzleComponent as Sc;
             let cut_expr = match required_size {
                 None => crate::Expression::AccessIndex { base, index: 0 },
                 Some(size) => crate::Expression::Swizzle {
                     size,
                     vector: base,
                     pattern: [Sc::X, Sc::Y, Sc::Z, Sc::W],
                 },
             };
-            (expressions.append(cut_expr), None)
+            (expressions.append(cut_expr, base_span), None)
         }
     }
 }
 
 pub(super) fn patch_comparison_type(
     flags: SamplingFlags,
     var: &mut crate::GlobalVariable,
     arena: &mut Arena<crate::Type>,
@@ -165,35 +197,39 @@ pub(super) fn patch_comparison_type(
         return true;
     }
     if flags == SamplingFlags::all() {
         return false;
     }
 
     log::debug!("Flipping comparison for {:?}", var);
     let original_ty = &arena[var.ty];
+    let original_ty_span = arena.get_span(var.ty).clone();
     let ty_inner = match original_ty.inner {
         crate::TypeInner::Image {
-            class: _,
+            class: crate::ImageClass::Sampled { multi, .. },
             dim,
             arrayed,
         } => crate::TypeInner::Image {
-            class: crate::ImageClass::Depth,
+            class: crate::ImageClass::Depth { multi },
             dim,
             arrayed,
         },
         crate::TypeInner::Sampler { .. } => crate::TypeInner::Sampler { comparison: true },
         ref other => unreachable!("Unexpected type for comparison mutation: {:?}", other),
     };
 
     let name = original_ty.name.clone();
-    var.ty = arena.append(crate::Type {
-        name,
-        inner: ty_inner,
-    });
+    var.ty = arena.append(
+        crate::Type {
+            name,
+            inner: ty_inner,
+        },
+        original_ty_span,
+    );
     true
 }
 
 impl<I: Iterator<Item = u32>> super::Parser<I> {
     pub(super) fn parse_image_couple(&mut self) -> Result<(), Error> {
         let _result_type_id = self.next()?;
         let result_id = self.next()?;
         let image_id = self.next()?;
@@ -224,16 +260,17 @@ impl<I: Iterator<Item = u32>> super::Par
         Ok(())
     }
 
     pub(super) fn parse_image_write(
         &mut self,
         words_left: u16,
         type_arena: &Arena<crate::Type>,
         global_arena: &Arena<crate::GlobalVariable>,
+        arguments: &[FunctionArgument],
         expressions: &mut Arena<crate::Expression>,
     ) -> Result<crate::Statement, Error> {
         let image_id = self.next()?;
         let coordinate_id = self.next()?;
         let value_id = self.next()?;
 
         let image_ops = if words_left != 0 { self.next()? } else { 0 };
 
@@ -241,39 +278,38 @@ impl<I: Iterator<Item = u32>> super::Par
             let other = spirv::ImageOperands::from_bits_truncate(image_ops);
             log::warn!("Unknown image write ops {:?}", other);
             for _ in 1..words_left {
                 self.next()?;
             }
         }
 
         let image_lexp = self.lookup_expression.lookup(image_id)?;
-        let image_var_handle = expressions.get_global_var(image_lexp.handle)?;
-        let image_var = &global_arena[image_var_handle];
+        let image_ty = expressions.get_image_expr_ty(image_lexp.handle, global_arena, arguments)?;
 
         let coord_lexp = self.lookup_expression.lookup(coordinate_id)?;
         let coord_type_handle = self.lookup_type.lookup(coord_lexp.type_id)?.handle;
-        let (coordinate, array_index) = match type_arena[image_var.ty].inner {
+        let (coordinate, array_index) = match type_arena[image_ty].inner {
             crate::TypeInner::Image {
                 dim,
                 arrayed,
                 class: _,
             } => extract_image_coordinates(
                 dim,
                 if arrayed {
                     ExtraCoordinate::ArrayLayer
                 } else {
                     ExtraCoordinate::Garbage
                 },
                 coord_lexp.handle,
                 coord_type_handle,
                 type_arena,
                 expressions,
             ),
-            _ => return Err(Error::InvalidImage(image_var.ty)),
+            _ => return Err(Error::InvalidImage(image_ty)),
         };
 
         let value_lexp = self.lookup_expression.lookup(value_id)?;
 
         Ok(crate::Statement::ImageStore {
             image: image_lexp.handle,
             coordinate,
             array_index,
@@ -281,18 +317,20 @@ impl<I: Iterator<Item = u32>> super::Par
         })
     }
 
     pub(super) fn parse_image_load(
         &mut self,
         mut words_left: u16,
         type_arena: &Arena<crate::Type>,
         global_arena: &Arena<crate::GlobalVariable>,
+        arguments: &[FunctionArgument],
         expressions: &mut Arena<crate::Expression>,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let image_id = self.next()?;
         let coordinate_id = self.next()?;
 
         let mut image_ops = if words_left != 0 {
             words_left -= 1;
             self.next()?
@@ -323,65 +361,68 @@ impl<I: Iterator<Item = u32>> super::Par
                     }
                     break;
                 }
             }
             image_ops ^= bit;
         }
 
         let image_lexp = self.lookup_expression.lookup(image_id)?;
-        let image_var_handle = expressions.get_global_var(image_lexp.handle)?;
-        let image_var = &global_arena[image_var_handle];
+        let image_ty = expressions.get_image_expr_ty(image_lexp.handle, global_arena, arguments)?;
 
         let coord_lexp = self.lookup_expression.lookup(coordinate_id)?;
         let coord_type_handle = self.lookup_type.lookup(coord_lexp.type_id)?.handle;
-        let (coordinate, array_index) = match type_arena[image_var.ty].inner {
+        let (coordinate, array_index) = match type_arena[image_ty].inner {
             crate::TypeInner::Image {
                 dim,
                 arrayed,
                 class: _,
             } => extract_image_coordinates(
                 dim,
                 if arrayed {
                     ExtraCoordinate::ArrayLayer
                 } else {
                     ExtraCoordinate::Garbage
                 },
                 coord_lexp.handle,
                 coord_type_handle,
                 type_arena,
                 expressions,
             ),
-            _ => return Err(Error::InvalidImage(image_var.ty)),
+            _ => return Err(Error::InvalidImage(image_ty)),
         };
 
         let expr = crate::Expression::ImageLoad {
             image: image_lexp.handle,
             coordinate,
             array_index,
             index,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
+    #[allow(clippy::too_many_arguments)]
     pub(super) fn parse_image_sample(
         &mut self,
         mut words_left: u16,
         options: SamplingOptions,
         type_arena: &Arena<crate::Type>,
         global_arena: &Arena<crate::GlobalVariable>,
+        arguments: &[FunctionArgument],
         expressions: &mut Arena<crate::Expression>,
+        parameters_sampling: &mut [SamplingFlags],
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let sampled_image_id = self.next()?;
         let coordinate_id = self.next()?;
         let dref_id = if options.compare {
             Some(self.next()?)
         } else {
             None
@@ -403,19 +444,44 @@ impl<I: Iterator<Item = u32>> super::Par
                     let bias_expr = self.next()?;
                     let bias_handle = self.lookup_expression.lookup(bias_expr)?.handle;
                     level = crate::SampleLevel::Bias(bias_handle);
                     words_left -= 1;
                 }
                 spirv::ImageOperands::LOD => {
                     let lod_expr = self.next()?;
                     let lod_handle = self.lookup_expression.lookup(lod_expr)?.handle;
-                    level = crate::SampleLevel::Exact(lod_handle);
+                    level = if options.compare {
+                        log::debug!("Assuming {:?} is zero", lod_handle);
+                        crate::SampleLevel::Zero
+                    } else {
+                        crate::SampleLevel::Exact(lod_handle)
+                    };
                     words_left -= 1;
                 }
+                spirv::ImageOperands::GRAD => {
+                    let grad_x_expr = self.next()?;
+                    let grad_x_handle = self.lookup_expression.lookup(grad_x_expr)?.handle;
+                    let grad_y_expr = self.next()?;
+                    let grad_y_handle = self.lookup_expression.lookup(grad_y_expr)?.handle;
+                    level = if options.compare {
+                        log::debug!(
+                            "Assuming gradients {:?} and {:?} are not greater than 1",
+                            grad_x_handle,
+                            grad_y_handle
+                        );
+                        crate::SampleLevel::Zero
+                    } else {
+                        crate::SampleLevel::Gradient {
+                            x: grad_x_handle,
+                            y: grad_y_handle,
+                        }
+                    };
+                    words_left -= 2;
+                }
                 spirv::ImageOperands::CONST_OFFSET => {
                     let offset_constant = self.next()?;
                     let offset_handle = self.lookup_constant.lookup(offset_constant)?.handle;
                     offset = Some(offset_handle);
                     words_left -= 1;
                 }
                 other => {
                     log::warn!("Unknown image sample operand {:?}", other);
@@ -427,36 +493,47 @@ impl<I: Iterator<Item = u32>> super::Par
             }
             image_ops ^= bit;
         }
 
         let si_lexp = self.lookup_sampled_image.lookup(sampled_image_id)?;
         let coord_lexp = self.lookup_expression.lookup(coordinate_id)?;
         let coord_type_handle = self.lookup_type.lookup(coord_lexp.type_id)?.handle;
 
-        let image_var_handle = expressions.get_global_var(si_lexp.image)?;
-        let sampler_var_handle = expressions.get_global_var(si_lexp.sampler)?;
-        log::debug!(
-            "\t\t\tImage {:?} sampled with {:?} under {:?}",
-            image_var_handle,
-            sampler_var_handle,
-            options,
-        );
         let sampling_bit = if options.compare {
             SamplingFlags::COMPARISON
         } else {
             SamplingFlags::REGULAR
         };
-        if let Some(flags) = self.handle_sampling.get_mut(&image_var_handle) {
-            *flags |= sampling_bit;
+
+        let image_ty = match expressions[si_lexp.image] {
+            crate::Expression::GlobalVariable(handle) => {
+                if let Some(flags) = self.handle_sampling.get_mut(&handle) {
+                    *flags |= sampling_bit;
+                }
+
+                global_arena[handle].ty
+            }
+            crate::Expression::FunctionArgument(i) => {
+                parameters_sampling[i as usize] |= sampling_bit;
+                arguments[i as usize].ty
+            }
+            ref other => return Err(Error::InvalidGlobalVar(other.clone())),
+        };
+        match expressions[si_lexp.sampler] {
+            crate::Expression::GlobalVariable(handle) => {
+                *self.handle_sampling.get_mut(&handle).unwrap() |= sampling_bit
+            }
+            crate::Expression::FunctionArgument(i) => {
+                parameters_sampling[i as usize] |= sampling_bit;
+            }
+            ref other => return Err(Error::InvalidGlobalVar(other.clone())),
         }
-        *self.handle_sampling.get_mut(&sampler_var_handle).unwrap() |= sampling_bit;
 
-        let image_var = &global_arena[image_var_handle];
-        let (coordinate, array_index) = match type_arena[image_var.ty].inner {
+        let (coordinate, array_index) = match type_arena[image_ty].inner {
             crate::TypeInner::Image {
                 dim,
                 arrayed,
                 class: _,
             } => extract_image_coordinates(
                 dim,
                 if options.project {
                     ExtraCoordinate::Projection
@@ -465,17 +542,17 @@ impl<I: Iterator<Item = u32>> super::Par
                 } else {
                     ExtraCoordinate::Garbage
                 },
                 coord_lexp.handle,
                 coord_type_handle,
                 type_arena,
                 expressions,
             ),
-            _ => return Err(Error::InvalidImage(image_var.ty)),
+            _ => return Err(Error::InvalidImage(image_ty)),
         };
 
         let expr = crate::Expression::ImageSample {
             image: si_lexp.image,
             sampler: si_lexp.sampler,
             coordinate,
             array_index,
             offset,
@@ -483,28 +560,29 @@ impl<I: Iterator<Item = u32>> super::Par
             depth_ref: match dref_id {
                 Some(id) => Some(self.lookup_expression.lookup(id)?.handle),
                 None => None,
             },
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     pub(super) fn parse_image_query_size(
         &mut self,
         at_level: bool,
         expressions: &mut Arena<crate::Expression>,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let image_id = self.next()?;
         let level = if at_level {
             let level_id = self.next()?;
             let level_lexp = self.lookup_expression.lookup(level_id)?;
             Some(level_lexp.handle)
         } else {
@@ -516,40 +594,41 @@ impl<I: Iterator<Item = u32>> super::Par
 
         let expr = crate::Expression::ImageQuery {
             image: image_lexp.handle,
             query: crate::ImageQuery::Size { level },
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     pub(super) fn parse_image_query_other(
         &mut self,
         query: crate::ImageQuery,
         expressions: &mut Arena<crate::Expression>,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let image_id = self.next()?;
 
         let image_lexp = self.lookup_expression.lookup(image_id)?.clone();
 
         let expr = crate::Expression::ImageQuery {
             image: image_lexp.handle,
             query,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 }