# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/spv/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/spv/mod.rs b/third_party/rust/naga/src/front/spv/mod.rs
--- a/third_party/rust/naga/src/front/spv/mod.rs
+++ b/third_party/rust/naga/src/front/spv/mod.rs
@@ -64,16 +64,19 @@ pub const SUPPORTED_CAPABILITIES: &[spir
     spirv::Capability::ImageCubeArray,
     spirv::Capability::ImageMSArray,
     spirv::Capability::StorageImageExtendedFormats,
     spirv::Capability::Sampled1D,
     spirv::Capability::SampledCubeArray,
     spirv::Capability::Int8,
     spirv::Capability::Int16,
     spirv::Capability::Int64,
+    spirv::Capability::Float16,
+    spirv::Capability::Float64,
+    spirv::Capability::Geometry,
     // tricky ones
     spirv::Capability::UniformBufferArrayDynamicIndexing,
     spirv::Capability::StorageBufferArrayDynamicIndexing,
 ];
 pub const SUPPORTED_EXTENSIONS: &[&str] = &[
     "SPV_KHR_storage_buffer_storage_class",
     "SPV_KHR_vulkan_memory_model",
 ];
@@ -203,16 +206,29 @@ struct Block {
 bitflags::bitflags! {
     #[derive(Default)]
     struct DecorationFlags: u32 {
         const NON_READABLE = 0x1;
         const NON_WRITABLE = 0x2;
     }
 }
 
+impl DecorationFlags {
+    fn to_storage_access(self) -> crate::StorageAccess {
+        let mut access = crate::StorageAccess::all();
+        if self.contains(DecorationFlags::NON_READABLE) {
+            access &= !crate::StorageAccess::LOAD;
+        }
+        if self.contains(DecorationFlags::NON_WRITABLE) {
+            access &= !crate::StorageAccess::STORE;
+        }
+        access
+    }
+}
+
 #[derive(Debug, PartialEq)]
 enum Majority {
     Column,
     Row,
 }
 
 #[derive(Debug, Default)]
 struct Decoration {
@@ -275,16 +291,21 @@ impl Decoration {
 }
 
 #[derive(Debug)]
 struct LookupFunctionType {
     parameter_type_ids: Vec<spirv::Word>,
     return_type_id: spirv::Word,
 }
 
+struct LookupFunction {
+    handle: Handle<crate::Function>,
+    parameters_sampling: Vec<image::SamplingFlags>,
+}
+
 #[derive(Debug)]
 struct EntryPoint {
     stage: crate::ShaderStage,
     name: String,
     early_depth_test: Option<crate::EarlyDepthTest>,
     workgroup_size: [u32; 3],
     function_id: spirv::Word,
     variable_ids: Vec<spirv::Word>,
@@ -368,16 +389,17 @@ impl Default for Options {
             strict_capabilities: false,
             flow_graph_dump_prefix: None,
         }
     }
 }
 
 pub struct Parser<I> {
     data: I,
+    data_offset: usize,
     state: ModuleState,
     layouter: Layouter,
     temp_bytes: Vec<u8>,
     ext_glsl_id: Option<spirv::Word>,
     future_decor: FastHashMap<spirv::Word, Decoration>,
     future_member_decor: FastHashMap<(spirv::Word, MemberIndex), Decoration>,
     lookup_member: FastHashMap<(Handle<crate::Type>, MemberIndex), LookupMember>,
     handle_sampling: FastHashMap<Handle<crate::GlobalVariable>, image::SamplingFlags>,
@@ -387,17 +409,17 @@ pub struct Parser<I> {
     // Lookup for samplers and sampled images, storing flags on how they are used.
     lookup_constant: FastHashMap<spirv::Word, LookupConstant>,
     lookup_variable: FastHashMap<spirv::Word, LookupVariable>,
     lookup_expression: FastHashMap<spirv::Word, LookupExpression>,
     // Load overrides are used to work around row-major matrices
     lookup_load_override: FastHashMap<spirv::Word, LookupLoadOverride>,
     lookup_sampled_image: FastHashMap<spirv::Word, image::LookupSampledImage>,
     lookup_function_type: FastHashMap<spirv::Word, LookupFunctionType>,
-    lookup_function: FastHashMap<spirv::Word, Handle<crate::Function>>,
+    lookup_function: FastHashMap<spirv::Word, LookupFunction>,
     lookup_entry_point: FastHashMap<spirv::Word, EntryPoint>,
     //Note: each `OpFunctionCall` gets a single entry here, indexed by the
     // dummy `Handle<crate::Function>` of the call site.
     deferred_function_calls: Vec<spirv::Word>,
     dummy_functions: Arena<crate::Function>,
     // Graph of all function calls through the module.
     // It's used to sort the functions (as nodes) topologically,
     // so that in the IR any called function is already known.
@@ -406,16 +428,17 @@ pub struct Parser<I> {
     index_constants: Vec<Handle<crate::Constant>>,
     index_constant_expressions: Vec<Handle<crate::Expression>>,
 }
 
 impl<I: Iterator<Item = u32>> Parser<I> {
     pub fn new(data: I, options: &Options) -> Self {
         Parser {
             data,
+            data_offset: 0,
             state: ModuleState::Empty,
             layouter: Layouter::default(),
             temp_bytes: Vec::new(),
             ext_glsl_id: None,
             future_decor: FastHashMap::default(),
             future_member_decor: FastHashMap::default(),
             handle_sampling: FastHashMap::default(),
             lookup_member: FastHashMap::default(),
@@ -434,18 +457,31 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             dummy_functions: Arena::new(),
             function_call_graph: GraphMap::new(),
             options: options.clone(),
             index_constants: Vec::new(),
             index_constant_expressions: Vec::new(),
         }
     }
 
+    fn span_from(&self, from: usize) -> crate::Span {
+        crate::Span::ByteRange(from..self.data_offset)
+    }
+
+    fn span_from_with_op(&self, from: usize) -> crate::Span {
+        crate::Span::ByteRange((from - 4)..self.data_offset)
+    }
+
     fn next(&mut self) -> Result<u32, Error> {
-        self.data.next().ok_or(Error::IncompleteData)
+        if let Some(res) = self.data.next() {
+            self.data_offset += 4;
+            Ok(res)
+        } else {
+            Err(Error::IncompleteData)
+        }
     }
 
     fn next_inst(&mut self) -> Result<Instruction, Error> {
         let word = self.next()?;
         let (wc, opcode) = ((word >> 16) as u16, (word & 0xffff) as u16);
         if wc == 0 {
             return Err(Error::InvalidWordCount);
         }
@@ -554,187 +590,207 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         Ok(())
     }
 
     fn parse_expr_unary_op(
         &mut self,
         expressions: &mut Arena<crate::Expression>,
         op: crate::UnaryOperator,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let p_id = self.next()?;
 
         let p_lexp = self.lookup_expression.lookup(p_id)?;
 
         let expr = crate::Expression::Unary {
             op,
             expr: p_lexp.handle,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     fn parse_expr_binary_op(
         &mut self,
         expressions: &mut Arena<crate::Expression>,
         op: crate::BinaryOperator,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let p1_id = self.next()?;
         let p2_id = self.next()?;
 
         let p1_lexp = self.lookup_expression.lookup(p1_id)?;
         let p2_lexp = self.lookup_expression.lookup(p2_id)?;
 
         let expr = crate::Expression::Binary {
             op,
             left: p1_lexp.handle,
             right: p2_lexp.handle,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     /// A more complicated version of the binary op,
     /// where we force the operand to have the same type as the result.
     /// This is mostly needed for "i++" and "i--" coming from GLSL.
     fn parse_expr_binary_op_sign_adjusted(
         &mut self,
         expressions: &mut Arena<crate::Expression>,
         op: crate::BinaryOperator,
         types: &Arena<crate::Type>,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let p1_id = self.next()?;
         let p2_id = self.next()?;
+        let span = self.span_from_with_op(start);
 
         let p1_lexp = self.lookup_expression.lookup(p1_id)?;
         let p2_lexp = self.lookup_expression.lookup(p2_id)?;
         let result_lookup_ty = self.lookup_type.lookup(result_type_id)?;
         let kind = types[result_lookup_ty.handle].inner.scalar_kind().unwrap();
 
         let expr = crate::Expression::Binary {
             op,
             left: if p1_lexp.type_id == result_type_id {
                 p1_lexp.handle
             } else {
-                expressions.append(crate::Expression::As {
-                    expr: p1_lexp.handle,
-                    kind,
-                    convert: None,
-                })
+                expressions.append(
+                    crate::Expression::As {
+                        expr: p1_lexp.handle,
+                        kind,
+                        convert: None,
+                    },
+                    span.clone(),
+                )
             },
             right: if p2_lexp.type_id == result_type_id {
                 p2_lexp.handle
             } else {
-                expressions.append(crate::Expression::As {
-                    expr: p2_lexp.handle,
-                    kind,
-                    convert: None,
-                })
+                expressions.append(
+                    crate::Expression::As {
+                        expr: p2_lexp.handle,
+                        kind,
+                        convert: None,
+                    },
+                    span.clone(),
+                )
             },
         };
 
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, span),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     fn parse_expr_shift_op(
         &mut self,
         expressions: &mut Arena<crate::Expression>,
         op: crate::BinaryOperator,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let p1_id = self.next()?;
         let p2_id = self.next()?;
 
+        let span = self.span_from_with_op(start);
+
         let p1_lexp = self.lookup_expression.lookup(p1_id)?;
         let p2_lexp = self.lookup_expression.lookup(p2_id)?;
         // convert the shift to Uint
-        let p2_handle = expressions.append(crate::Expression::As {
-            expr: p2_lexp.handle,
-            kind: crate::ScalarKind::Uint,
-            convert: None,
-        });
+        let p2_handle = expressions.append(
+            crate::Expression::As {
+                expr: p2_lexp.handle,
+                kind: crate::ScalarKind::Uint,
+                convert: None,
+            },
+            span.clone(),
+        );
 
         let expr = crate::Expression::Binary {
             op,
             left: p1_lexp.handle,
             right: p2_handle,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, span),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
     fn parse_expr_derivative(
         &mut self,
         expressions: &mut Arena<crate::Expression>,
         axis: crate::DerivativeAxis,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         let result_type_id = self.next()?;
         let result_id = self.next()?;
         let arg_id = self.next()?;
 
         let arg_lexp = self.lookup_expression.lookup(arg_id)?;
 
         let expr = crate::Expression::Derivative {
             axis,
             expr: arg_lexp.handle,
         };
         self.lookup_expression.insert(
             result_id,
             LookupExpression {
-                handle: expressions.append(expr),
+                handle: expressions.append(expr, self.span_from_with_op(start)),
                 type_id: result_type_id,
             },
         );
         Ok(())
     }
 
+    #[allow(clippy::too_many_arguments)]
     fn insert_composite(
         &self,
         root_expr: Handle<crate::Expression>,
         root_type_id: spirv::Word,
         object_expr: Handle<crate::Expression>,
         selections: &[spirv::Word],
         type_arena: &Arena<crate::Type>,
         expressions: &mut Arena<crate::Expression>,
+        span: crate::Span,
     ) -> Result<Handle<crate::Expression>, Error> {
         let selection = match selections.first() {
             Some(&index) => index,
             None => return Ok(object_expr),
         };
+        let root_span = expressions.get_span(root_expr).clone();
         let root_lookup = self.lookup_type.lookup(root_type_id)?;
         let (count, child_type_id) = match type_arena[root_lookup.handle].inner {
             crate::TypeInner::Struct { ref members, .. } => {
                 let child_member = self
                     .lookup_member
                     .get(&(root_lookup.handle, selection))
                     .ok_or(Error::InvalidAccessType(root_type_id))?;
                 (members.len(), child_member.type_id)
@@ -747,70 +803,92 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     .ok_or(Error::InvalidAccessType(root_type_id))?;
                 (size as usize, child_type_id)
             }
             _ => return Err(Error::InvalidAccessType(root_type_id)),
         };
 
         let mut components = Vec::with_capacity(count);
         for index in 0..count as u32 {
-            let expr = expressions.append(crate::Expression::AccessIndex {
-                base: root_expr,
-                index,
-            });
+            let expr = expressions.append(
+                crate::Expression::AccessIndex {
+                    base: root_expr,
+                    index,
+                },
+                if index == selection {
+                    span.clone()
+                } else {
+                    root_span.clone()
+                },
+            );
             components.push(expr);
         }
         components[selection as usize] = self.insert_composite(
             components[selection as usize],
             child_type_id,
             object_expr,
             &selections[1..],
             type_arena,
             expressions,
+            span.clone(),
         )?;
 
-        Ok(expressions.append(crate::Expression::Compose {
-            ty: root_lookup.handle,
-            components,
-        }))
+        Ok(expressions.append(
+            crate::Expression::Compose {
+                ty: root_lookup.handle,
+                components,
+            },
+            span,
+        ))
     }
 
     #[allow(clippy::too_many_arguments)]
     fn next_block(
         &mut self,
         block_id: spirv::Word,
         function_id: spirv::Word,
         expressions: &mut Arena<crate::Expression>,
         local_arena: &mut Arena<crate::LocalVariable>,
         const_arena: &mut Arena<crate::Constant>,
         type_arena: &Arena<crate::Type>,
         global_arena: &Arena<crate::GlobalVariable>,
+        arguments: &[crate::FunctionArgument],
+        parmeter_sampling: &mut [image::SamplingFlags],
     ) -> Result<ControlFlowNode, Error> {
-        let mut block = Vec::new();
+        let mut block = crate::Block::new();
         let mut phis = Vec::new();
         let mut emitter = super::Emitter::default();
         emitter.start(expressions);
         let mut merge = None;
         let terminator = loop {
             use spirv::Op;
+            let start = self.data_offset;
             let inst = self.next_inst()?;
+            let span = crate::Span::ByteRange(start..(start + 4 * (inst.wc as usize)));
             log::debug!("\t\t{:?} [{}]", inst.op, inst.wc);
 
             match inst.op {
                 Op::Line => {
                     inst.expect(4)?;
                     let _file_id = self.next()?;
                     let _row_id = self.next()?;
                     let _col_id = self.next()?;
                 }
+                Op::NoLine => inst.expect(1)?,
                 Op::Undef => {
                     inst.expect(3)?;
-                    let _result_type_id = self.next()?;
-                    let _result_id = self.next()?;
-                    //TODO?
+                    let (type_id, id, handle) =
+                        self.parse_null_constant(inst, type_arena, const_arena)?;
+                    self.lookup_expression.insert(
+                        id,
+                        LookupExpression {
+                            handle: expressions.append(crate::Expression::Constant(handle), span),
+                            type_id,
+                        },
+                    );
                 }
                 Op::Variable => {
                     inst.expect_at_least(4)?;
                     block.extend(emitter.finish(expressions));
 
                     let result_type_id = self.next()?;
                     let result_id = self.next()?;
                     let _storage_class = self.next()?;
@@ -826,49 +904,56 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let name = self
                         .future_decor
                         .remove(&result_id)
                         .and_then(|decor| decor.name);
                     if let Some(ref name) = name {
                         log::debug!("\t\t\tid={} name={}", result_id, name);
                     }
                     let lookup_ty = self.lookup_type.lookup(result_type_id)?;
-                    let var_handle = local_arena.append(crate::LocalVariable {
-                        name,
-                        ty: match type_arena[lookup_ty.handle].inner {
-                            crate::TypeInner::Pointer { base, .. } => base,
-                            _ => lookup_ty.handle,
+                    let var_handle = local_arena.append(
+                        crate::LocalVariable {
+                            name,
+                            ty: match type_arena[lookup_ty.handle].inner {
+                                crate::TypeInner::Pointer { base, .. } => base,
+                                _ => lookup_ty.handle,
+                            },
+                            init,
                         },
-                        init,
-                    });
+                        span.clone(),
+                    );
 
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
                             handle: expressions
-                                .append(crate::Expression::LocalVariable(var_handle)),
+                                .append(crate::Expression::LocalVariable(var_handle), span),
                             type_id: result_type_id,
                         },
                     );
                     emitter.start(expressions);
                 }
                 Op::Phi => {
                     inst.expect_at_least(3)?;
                     block.extend(emitter.finish(expressions));
 
                     let result_type_id = self.next()?;
                     let result_id = self.next()?;
 
                     let name = format!("phi_{}", result_id);
-                    let var_handle = local_arena.append(crate::LocalVariable {
-                        name: Some(name),
-                        ty: self.lookup_type.lookup(result_type_id)?.handle,
-                        init: None,
-                    });
-                    let pointer = expressions.append(crate::Expression::LocalVariable(var_handle));
+                    let var_handle = local_arena.append(
+                        crate::LocalVariable {
+                            name: Some(name),
+                            ty: self.lookup_type.lookup(result_type_id)?.handle,
+                            init: None,
+                        },
+                        self.span_from(start),
+                    );
+                    let pointer = expressions
+                        .append(crate::Expression::LocalVariable(var_handle), span.clone());
 
                     let in_count = (inst.wc - 3) / 2;
                     let mut phi = PhiInstruction {
                         id: result_id,
                         pointer,
                         variables: Vec::with_capacity(in_count as usize),
                     };
                     for _ in 0..in_count {
@@ -880,17 +965,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     phis.push(phi);
                     emitter.start(expressions);
 
                     // Associate the lookup with an actual value, which is emitted
                     // into the current block.
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(crate::Expression::Load { pointer }),
+                            handle: expressions.append(crate::Expression::Load { pointer }, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::AccessChain | Op::InBoundsAccessChain => {
                     struct AccessExpression {
                         base_handle: Handle<crate::Expression>,
                         type_id: spirv::Word,
@@ -934,116 +1019,135 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                             // can only index a struct with a constant
                             crate::TypeInner::Struct { .. } => {
                                 let index = index_maybe
                                     .ok_or_else(|| Error::InvalidAccess(index_expr_data.clone()))?;
                                 let lookup_member = self
                                     .lookup_member
                                     .get(&(type_lookup.handle, index))
                                     .ok_or(Error::InvalidAccessType(acex.type_id))?;
-                                let base_handle =
-                                    expressions.append(crate::Expression::AccessIndex {
+                                let base_handle = expressions.append(
+                                    crate::Expression::AccessIndex {
                                         base: acex.base_handle,
                                         index,
-                                    });
+                                    },
+                                    span.clone(),
+                                );
                                 AccessExpression {
                                     base_handle,
                                     type_id: lookup_member.type_id,
                                     load_override: if lookup_member.row_major {
                                         debug_assert!(acex.load_override.is_none());
                                         let sub_type_lookup =
                                             self.lookup_type.lookup(lookup_member.type_id)?;
                                         Some(match type_arena[sub_type_lookup.handle].inner {
                                             // load it transposed, to match column major expectations
                                             crate::TypeInner::Matrix { .. } => {
-                                                let loaded =
-                                                    expressions.append(crate::Expression::Load {
+                                                let loaded = expressions.append(
+                                                    crate::Expression::Load {
                                                         pointer: base_handle,
-                                                    });
-                                                let transposed =
-                                                    expressions.append(crate::Expression::Math {
+                                                    },
+                                                    span.clone(),
+                                                );
+                                                let transposed = expressions.append(
+                                                    crate::Expression::Math {
                                                         fun: crate::MathFunction::Transpose,
                                                         arg: loaded,
                                                         arg1: None,
                                                         arg2: None,
-                                                    });
+                                                    },
+                                                    span.clone(),
+                                                );
                                                 LookupLoadOverride::Loaded(transposed)
                                             }
                                             _ => LookupLoadOverride::Pending,
                                         })
                                     } else {
                                         None
                                     },
                                 }
                             }
                             crate::TypeInner::Matrix { .. } => {
                                 let load_override = match acex.load_override {
                                     // We are indexing inside a row-major matrix
                                     Some(LookupLoadOverride::Loaded(load_expr)) => {
                                         let index = index_maybe.ok_or_else(|| {
                                             Error::InvalidAccess(index_expr_data.clone())
                                         })?;
-                                        let sub_handle =
-                                            expressions.append(crate::Expression::AccessIndex {
+                                        let sub_handle = expressions.append(
+                                            crate::Expression::AccessIndex {
                                                 base: load_expr,
                                                 index,
-                                            });
+                                            },
+                                            span.clone(),
+                                        );
                                         Some(LookupLoadOverride::Loaded(sub_handle))
                                     }
                                     _ => None,
                                 };
                                 let sub_expr = match index_maybe {
                                     Some(index) => crate::Expression::AccessIndex {
                                         base: acex.base_handle,
                                         index,
                                     },
                                     None => crate::Expression::Access {
                                         base: acex.base_handle,
                                         index: index_expr.handle,
                                     },
                                 };
                                 AccessExpression {
-                                    base_handle: expressions.append(sub_expr),
+                                    base_handle: expressions.append(sub_expr, span.clone()),
                                     type_id: type_lookup
                                         .base_id
                                         .ok_or(Error::InvalidAccessType(acex.type_id))?,
                                     load_override,
                                 }
                             }
                             // This must be a vector or an array.
                             _ => {
-                                let base_handle = expressions.append(crate::Expression::Access {
-                                    base: acex.base_handle,
-                                    index: index_expr.handle,
-                                });
+                                let base_handle = expressions.append(
+                                    crate::Expression::Access {
+                                        base: acex.base_handle,
+                                        index: index_expr.handle,
+                                    },
+                                    span.clone(),
+                                );
                                 let load_override = match acex.load_override {
                                     // If there is a load override in place, then we always end up
                                     // with a side-loaded value here.
                                     Some(lookup_load_override) => {
                                         let sub_expr = match lookup_load_override {
                                             // We must be indexing into the array of row-major matrices.
                                             // Let's load the result of indexing and transpose it.
                                             LookupLoadOverride::Pending => {
-                                                let loaded =
-                                                    expressions.append(crate::Expression::Load {
+                                                let loaded = expressions.append(
+                                                    crate::Expression::Load {
                                                         pointer: base_handle,
-                                                    });
-                                                expressions.append(crate::Expression::Math {
-                                                    fun: crate::MathFunction::Transpose,
-                                                    arg: loaded,
-                                                    arg1: None,
-                                                    arg2: None,
-                                                })
+                                                    },
+                                                    span.clone(),
+                                                );
+                                                expressions.append(
+                                                    crate::Expression::Math {
+                                                        fun: crate::MathFunction::Transpose,
+                                                        arg: loaded,
+                                                        arg1: None,
+                                                        arg2: None,
+                                                    },
+                                                    span.clone(),
+                                                )
                                             }
                                             // We are indexing inside a row-major matrix.
                                             LookupLoadOverride::Loaded(load_expr) => expressions
-                                                .append(crate::Expression::Access {
-                                                    base: load_expr,
-                                                    index: index_expr.handle,
-                                                }),
+                                                .append(
+                                                    crate::Expression::Access {
+                                                        base: load_expr,
+                                                        index: index_expr.handle,
+                                                    },
+                                                    span.clone(),
+                                                ),
                                         };
                                         Some(LookupLoadOverride::Loaded(sub_expr))
                                     }
                                     None => None,
                                 };
                                 AccessExpression {
                                     base_handle,
                                     type_id: type_lookup
@@ -1076,35 +1180,47 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let root_type_lookup = self.lookup_type.lookup(root_lexp.type_id)?;
                     let index_lexp = self.lookup_expression.lookup(index_id)?;
 
                     let num_components = match type_arena[root_type_lookup.handle].inner {
                         crate::TypeInner::Vector { size, .. } => size as usize,
                         _ => return Err(Error::InvalidVectorType(root_type_lookup.handle)),
                     };
 
-                    let mut handle = expressions.append(crate::Expression::Access {
-                        base: root_lexp.handle,
-                        index: self.index_constant_expressions[0],
-                    });
-                    for &index_expr in self.index_constant_expressions[1..num_components].iter() {
-                        let access_expr = expressions.append(crate::Expression::Access {
+                    let mut handle = expressions.append(
+                        crate::Expression::Access {
                             base: root_lexp.handle,
-                            index: index_expr,
-                        });
-                        let cond = expressions.append(crate::Expression::Binary {
-                            op: crate::BinaryOperator::Equal,
-                            left: index_expr,
-                            right: index_lexp.handle,
-                        });
-                        handle = expressions.append(crate::Expression::Select {
-                            condition: cond,
-                            accept: access_expr,
-                            reject: handle,
-                        });
+                            index: self.index_constant_expressions[0],
+                        },
+                        span.clone(),
+                    );
+                    for &index_expr in self.index_constant_expressions[1..num_components].iter() {
+                        let access_expr = expressions.append(
+                            crate::Expression::Access {
+                                base: root_lexp.handle,
+                                index: index_expr,
+                            },
+                            span.clone(),
+                        );
+                        let cond = expressions.append(
+                            crate::Expression::Binary {
+                                op: crate::BinaryOperator::Equal,
+                                left: index_expr,
+                                right: index_lexp.handle,
+                            },
+                            span.clone(),
+                        );
+                        handle = expressions.append(
+                            crate::Expression::Select {
+                                condition: cond,
+                                accept: access_expr,
+                                reject: handle,
+                            },
+                            span.clone(),
+                        );
                     }
 
                     self.lookup_expression.insert(
                         id,
                         LookupExpression {
                             handle,
                             type_id: result_type_id,
                         },
@@ -1125,36 +1241,48 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let index_lexp = self.lookup_expression.lookup(index_id)?;
 
                     let num_components = match type_arena[root_type_lookup.handle].inner {
                         crate::TypeInner::Vector { size, .. } => size as usize,
                         _ => return Err(Error::InvalidVectorType(root_type_lookup.handle)),
                     };
                     let mut components = Vec::with_capacity(num_components);
                     for &index_expr in self.index_constant_expressions[..num_components].iter() {
-                        let access_expr = expressions.append(crate::Expression::Access {
-                            base: root_lexp.handle,
-                            index: index_expr,
-                        });
-                        let cond = expressions.append(crate::Expression::Binary {
-                            op: crate::BinaryOperator::Equal,
-                            left: index_expr,
-                            right: index_lexp.handle,
-                        });
-                        let handle = expressions.append(crate::Expression::Select {
-                            condition: cond,
-                            accept: object_lexp.handle,
-                            reject: access_expr,
-                        });
+                        let access_expr = expressions.append(
+                            crate::Expression::Access {
+                                base: root_lexp.handle,
+                                index: index_expr,
+                            },
+                            span.clone(),
+                        );
+                        let cond = expressions.append(
+                            crate::Expression::Binary {
+                                op: crate::BinaryOperator::Equal,
+                                left: index_expr,
+                                right: index_lexp.handle,
+                            },
+                            span.clone(),
+                        );
+                        let handle = expressions.append(
+                            crate::Expression::Select {
+                                condition: cond,
+                                accept: object_lexp.handle,
+                                reject: access_expr,
+                            },
+                            span.clone(),
+                        );
                         components.push(handle);
                     }
-                    let handle = expressions.append(crate::Expression::Compose {
-                        ty: root_type_lookup.handle,
-                        components,
-                    });
+                    let handle = expressions.append(
+                        crate::Expression::Compose {
+                            ty: root_type_lookup.handle,
+                            components,
+                        },
+                        span.clone(),
+                    );
 
                     self.lookup_expression.insert(
                         id,
                         LookupExpression {
                             handle,
                             type_id: result_type_id,
                         },
                     );
@@ -1184,20 +1312,23 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                                 .base_id
                                 .ok_or(Error::InvalidAccessType(lexp.type_id))?,
                             ref other => {
                                 log::warn!("composite type {:?}", other);
                                 return Err(Error::UnsupportedType(type_lookup.handle));
                             }
                         };
                         lexp = LookupExpression {
-                            handle: expressions.append(crate::Expression::AccessIndex {
-                                base: lexp.handle,
-                                index,
-                            }),
+                            handle: expressions.append(
+                                crate::Expression::AccessIndex {
+                                    base: lexp.handle,
+                                    index,
+                                },
+                                span.clone(),
+                            ),
                             type_id,
                         };
                     }
 
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
                             handle: lexp.handle,
@@ -1221,16 +1352,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let root_lexp = self.lookup_expression.lookup(composite_id)?.clone();
                     let handle = self.insert_composite(
                         root_lexp.handle,
                         result_type_id,
                         object_lexp.handle,
                         &selections,
                         type_arena,
                         expressions,
+                        span,
                     )?;
 
                     self.lookup_expression.insert(
                         id,
                         LookupExpression {
                             handle,
                             type_id: result_type_id,
                         },
@@ -1258,17 +1390,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         {
                             crate::Expression::Splat { size, value: first }
                         }
                         _ => crate::Expression::Compose { ty, components },
                     };
                     self.lookup_expression.insert(
                         id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::Load => {
                     inst.expect_at_least(4)?;
 
                     let result_type_id = self.next()?;
@@ -1283,19 +1415,22 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let type_lookup = self.lookup_type.lookup(base_lexp.type_id)?;
                     let handle = match type_arena[type_lookup.handle].inner {
                         crate::TypeInner::Image { .. } | crate::TypeInner::Sampler { .. } => {
                             base_lexp.handle
                         }
                         _ => match self.lookup_load_override.get(&pointer_id) {
                             Some(&LookupLoadOverride::Loaded(handle)) => handle,
                             //Note: we aren't handling `LookupLoadOverride::Pending` properly here
-                            _ => expressions.append(crate::Expression::Load {
-                                pointer: base_lexp.handle,
-                            }),
+                            _ => expressions.append(
+                                crate::Expression::Load {
+                                    pointer: base_lexp.handle,
+                                },
+                                span,
+                            ),
                         },
                     };
 
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
                             handle,
                             type_id: result_type_id,
@@ -1309,20 +1444,23 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let pointer_id = self.next()?;
                     let value_id = self.next()?;
                     if inst.wc != 3 {
                         inst.expect(4)?;
                         let _memory_access = self.next()?;
                     }
                     let base_expr = self.lookup_expression.lookup(pointer_id)?;
                     let value_expr = self.lookup_expression.lookup(value_id)?;
-                    block.push(crate::Statement::Store {
-                        pointer: base_expr.handle,
-                        value: value_expr.handle,
-                    });
+                    block.push(
+                        crate::Statement::Store {
+                            pointer: base_expr.handle,
+                            value: value_expr.handle,
+                        },
+                        span,
+                    );
                     emitter.start(expressions);
                 }
                 // Arithmetic Instructions +, -, *, /, %
                 Op::SNegate | Op::FNegate => {
                     inst.expect(4)?;
                     self.parse_expr_unary_op(expressions, crate::UnaryOperator::Negate)?;
                 }
                 Op::IAdd => {
@@ -1380,17 +1518,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         fun: crate::MathFunction::Transpose,
                         arg: matrix_lexp.handle,
                         arg1: None,
                         arg2: None,
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::Dot => {
                     inst.expect(5)?;
 
                     let result_type_id = self.next()?;
@@ -1403,17 +1541,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         fun: crate::MathFunction::Dot,
                         arg: left_lexp.handle,
                         arg1: Some(right_lexp.handle),
                         arg2: None,
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::OuterProduct => {
                     inst.expect(5)?;
 
                     let result_type_id = self.next()?;
@@ -1426,17 +1564,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         fun: crate::MathFunction::Outer,
                         arg: left_lexp.handle,
                         arg1: Some(right_lexp.handle),
                         arg2: None,
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 // Bitwise instructions
                 Op::Not => {
                     inst.expect(4)?;
                     self.parse_expr_unary_op(expressions, crate::UnaryOperator::Not)?;
@@ -1473,57 +1611,94 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     self.parse_image_uncouple()?;
                 }
                 Op::SampledImage => {
                     inst.expect(5)?;
                     self.parse_image_couple()?;
                 }
                 Op::ImageWrite => {
                     let extra = inst.expect_at_least(4)?;
+                    let stmt = self.parse_image_write(
+                        extra,
+                        type_arena,
+                        global_arena,
+                        arguments,
+                        expressions,
+                    )?;
                     block.extend(emitter.finish(expressions));
-                    let stmt =
-                        self.parse_image_write(extra, type_arena, global_arena, expressions)?;
-                    block.push(stmt);
+                    block.push(stmt, span);
                     emitter.start(expressions);
                 }
                 Op::ImageFetch | Op::ImageRead => {
                     let extra = inst.expect_at_least(5)?;
-                    self.parse_image_load(extra, type_arena, global_arena, expressions)?;
+                    self.parse_image_load(extra, type_arena, global_arena, arguments, expressions)?;
                 }
                 Op::ImageSampleImplicitLod | Op::ImageSampleExplicitLod => {
                     let extra = inst.expect_at_least(5)?;
                     let options = image::SamplingOptions {
                         compare: false,
                         project: false,
                     };
-                    self.parse_image_sample(extra, options, type_arena, global_arena, expressions)?;
+                    self.parse_image_sample(
+                        extra,
+                        options,
+                        type_arena,
+                        global_arena,
+                        arguments,
+                        expressions,
+                        parmeter_sampling,
+                    )?;
                 }
                 Op::ImageSampleProjImplicitLod | Op::ImageSampleProjExplicitLod => {
                     let extra = inst.expect_at_least(5)?;
                     let options = image::SamplingOptions {
                         compare: false,
                         project: true,
                     };
-                    self.parse_image_sample(extra, options, type_arena, global_arena, expressions)?;
+                    self.parse_image_sample(
+                        extra,
+                        options,
+                        type_arena,
+                        global_arena,
+                        arguments,
+                        expressions,
+                        parmeter_sampling,
+                    )?;
                 }
                 Op::ImageSampleDrefImplicitLod | Op::ImageSampleDrefExplicitLod => {
                     let extra = inst.expect_at_least(6)?;
                     let options = image::SamplingOptions {
                         compare: true,
                         project: false,
                     };
-                    self.parse_image_sample(extra, options, type_arena, global_arena, expressions)?;
+                    self.parse_image_sample(
+                        extra,
+                        options,
+                        type_arena,
+                        global_arena,
+                        arguments,
+                        expressions,
+                        parmeter_sampling,
+                    )?;
                 }
                 Op::ImageSampleProjDrefImplicitLod | Op::ImageSampleProjDrefExplicitLod => {
                     let extra = inst.expect_at_least(6)?;
                     let options = image::SamplingOptions {
                         compare: true,
                         project: true,
                     };
-                    self.parse_image_sample(extra, options, type_arena, global_arena, expressions)?;
+                    self.parse_image_sample(
+                        extra,
+                        options,
+                        type_arena,
+                        global_arena,
+                        arguments,
+                        expressions,
+                        parmeter_sampling,
+                    )?;
                 }
                 Op::ImageQuerySize => {
                     inst.expect(4)?;
                     self.parse_image_query_size(false, expressions)?;
                 }
                 Op::ImageQuerySizeLod => {
                     inst.expect(5)?;
                     self.parse_image_query_size(true, expressions)?;
@@ -1552,17 +1727,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let expr = crate::Expression::Select {
                         condition: cond_lexp.handle,
                         accept: o1_lexp.handle,
                         reject: o2_lexp.handle,
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::VectorShuffle => {
                     inst.expect_at_least(5)?;
                     let result_type_id = self.next()?;
                     let result_id = self.next()?;
@@ -1630,41 +1805,41 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                             } else if index < n1 + n2 {
                                 crate::Expression::AccessIndex {
                                     base: v2_handle,
                                     index: index - n1,
                                 }
                             } else {
                                 return Err(Error::InvalidAccessIndex(index));
                             };
-                            components.push(expressions.append(expr));
+                            components.push(expressions.append(expr, span.clone()));
                         }
                         crate::Expression::Compose {
                             ty: self.lookup_type.lookup(result_type_id)?.handle,
                             components,
                         }
                     };
 
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::Bitcast
                 | Op::ConvertSToF
                 | Op::ConvertUToF
                 | Op::ConvertFToU
                 | Op::ConvertFToS
                 | Op::FConvert
                 | Op::UConvert
                 | Op::SConvert => {
-                    inst.expect_at_least(4)?;
+                    inst.expect(4)?;
                     let result_type_id = self.next()?;
                     let result_id = self.next()?;
                     let value_id = self.next()?;
 
                     let value_lexp = self.lookup_expression.lookup(value_id)?;
                     let ty_lookup = self.lookup_type.lookup(result_type_id)?;
                     let (kind, width) = match type_arena[ty_lookup.handle].inner {
                         crate::TypeInner::Scalar { kind, width }
@@ -1680,17 +1855,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                             None
                         } else {
                             Some(width)
                         },
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::FunctionCall => {
                     inst.expect_at_least(4)?;
                     block.extend(emitter.finish(expressions));
 
@@ -1705,31 +1880,35 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     }
 
                     // We just need an unique handle here, nothing more.
                     let function = self.add_call(function_id, func_id);
 
                     let result = if self.lookup_void_type == Some(result_type_id) {
                         None
                     } else {
-                        let expr_handle = expressions.append(crate::Expression::Call(function));
+                        let expr_handle = expressions
+                            .append(crate::Expression::CallResult(function), span.clone());
                         self.lookup_expression.insert(
                             result_id,
                             LookupExpression {
                                 handle: expr_handle,
                                 type_id: result_type_id,
                             },
                         );
                         Some(expr_handle)
                     };
-                    block.push(crate::Statement::Call {
-                        function,
-                        arguments,
-                        result,
-                    });
+                    block.push(
+                        crate::Statement::Call {
+                            function,
+                            arguments,
+                            result,
+                        },
+                        span,
+                    );
                     emitter.start(expressions);
                 }
                 Op::ExtInst => {
                     use crate::MathFunction as Mf;
                     use spirv::GLOp as Glo;
 
                     let base_wc = 5;
                     inst.expect_at_least(base_wc)?;
@@ -1745,62 +1924,74 @@ impl<I: Iterator<Item = u32>> Parser<I> 
 
                     if gl_op == Glo::Radians || gl_op == Glo::Degrees {
                         inst.expect(base_wc + 1)?;
                         let arg = {
                             let arg_id = self.next()?;
                             self.lookup_expression.lookup(arg_id)?.handle
                         };
 
-                        let constant_handle = const_arena.fetch_or_append(crate::Constant {
-                            name: None,
-                            specialization: None,
-                            inner: crate::ConstantInner::Scalar {
-                                width: 4,
-                                value: crate::ScalarValue::Float(match gl_op {
-                                    Glo::Radians => std::f64::consts::PI / 180.0,
-                                    Glo::Degrees => 180.0 / std::f64::consts::PI,
-                                    _ => unreachable!(),
-                                }),
+                        let constant_handle = const_arena.fetch_or_append(
+                            crate::Constant {
+                                name: None,
+                                specialization: None,
+                                inner: crate::ConstantInner::Scalar {
+                                    width: 4,
+                                    value: crate::ScalarValue::Float(match gl_op {
+                                        Glo::Radians => std::f64::consts::PI / 180.0,
+                                        Glo::Degrees => 180.0 / std::f64::consts::PI,
+                                        _ => unreachable!(),
+                                    }),
+                                },
                             },
-                        });
+                            Default::default(),
+                        );
 
-                        let expr_handle =
-                            expressions.append(crate::Expression::Constant(constant_handle));
+                        let expr_handle = expressions.append(
+                            crate::Expression::Constant(constant_handle),
+                            Default::default(),
+                        );
 
                         self.lookup_expression.insert(
                             result_id,
                             LookupExpression {
-                                handle: expressions.append(crate::Expression::Binary {
-                                    op: crate::BinaryOperator::Multiply,
-                                    left: arg,
-                                    right: expr_handle,
-                                }),
+                                handle: expressions.append(
+                                    crate::Expression::Binary {
+                                        op: crate::BinaryOperator::Multiply,
+                                        left: arg,
+                                        right: expr_handle,
+                                    },
+                                    span,
+                                ),
                                 type_id: result_type_id,
                             },
                         );
                     } else {
                         let fun = match gl_op {
                             Glo::Round => Mf::Round,
+                            Glo::RoundEven => Mf::Round,
                             Glo::Trunc => Mf::Trunc,
                             Glo::FAbs | Glo::SAbs => Mf::Abs,
                             Glo::FSign | Glo::SSign => Mf::Sign,
                             Glo::Floor => Mf::Floor,
                             Glo::Ceil => Mf::Ceil,
                             Glo::Fract => Mf::Fract,
                             Glo::Sin => Mf::Sin,
                             Glo::Cos => Mf::Cos,
                             Glo::Tan => Mf::Tan,
                             Glo::Asin => Mf::Asin,
                             Glo::Acos => Mf::Acos,
                             Glo::Atan => Mf::Atan,
                             Glo::Sinh => Mf::Sinh,
                             Glo::Cosh => Mf::Cosh,
                             Glo::Tanh => Mf::Tanh,
                             Glo::Atan2 => Mf::Atan2,
+                            Glo::Asinh => Mf::Asinh,
+                            Glo::Acosh => Mf::Acosh,
+                            Glo::Atanh => Mf::Atanh,
                             Glo::Pow => Mf::Pow,
                             Glo::Exp => Mf::Exp,
                             Glo::Log => Mf::Log,
                             Glo::Exp2 => Mf::Exp2,
                             Glo::Log2 => Mf::Log2,
                             Glo::Sqrt => Mf::Sqrt,
                             Glo::InverseSqrt => Mf::InverseSqrt,
                             Glo::MatrixInverse => Mf::Inverse,
@@ -1848,17 +2039,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                             fun,
                             arg,
                             arg1,
                             arg2,
                         };
                         self.lookup_expression.insert(
                             result_id,
                             LookupExpression {
-                                handle: expressions.append(expr),
+                                handle: expressions.append(expr, span),
                                 type_id: result_type_id,
                             },
                         );
                     }
                 }
                 // Relational and Logical Instructions
                 Op::LogicalNot => {
                     inst.expect(4)?;
@@ -1910,17 +2101,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
 
                     let expr = crate::Expression::Relational {
                         fun: map_relational_fun(inst.op)?,
                         argument: arg_lexp.handle,
                     };
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
-                            handle: expressions.append(expr),
+                            handle: expressions.append(expr, span),
                             type_id: result_type_id,
                         },
                     );
                 }
                 Op::Kill => {
                     inst.expect(1)?;
                     break Terminator::Kill;
                 }
@@ -1968,21 +2159,24 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let selector_lexp = &self.lookup_expression[&selector];
                     let selector_lty = self.lookup_type.lookup(selector_lexp.type_id)?;
                     let selector = match type_arena[selector_lty.handle].inner {
                         crate::TypeInner::Scalar {
                             kind: crate::ScalarKind::Uint,
                             width: _,
                         } => {
                             // IR expects a signed integer, so do a bitcast
-                            expressions.append(crate::Expression::As {
-                                kind: crate::ScalarKind::Sint,
-                                expr: selector_lexp.handle,
-                                convert: None,
-                            })
+                            expressions.append(
+                                crate::Expression::As {
+                                    kind: crate::ScalarKind::Sint,
+                                    expr: selector_lexp.handle,
+                                    convert: None,
+                                },
+                                span,
+                            )
                         }
                         crate::TypeInner::Scalar {
                             kind: crate::ScalarKind::Sint,
                             width: _,
                         } => selector_lexp.handle,
                         ref other => unimplemented!("Unexpected selector {:?}", other),
                     };
 
@@ -2041,22 +2235,26 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                     let structure_id = self.next()?;
                     let member_index = self.next()?;
 
                     // We're assuming that the validation pass, if it's run, will catch if the
                     // wrong types or parameters are supplied here.
 
                     let structure_ptr = self.lookup_expression.lookup(structure_id)?;
 
-                    let member_ptr = expressions.append(crate::Expression::AccessIndex {
-                        base: structure_ptr.handle,
-                        index: member_index,
-                    });
+                    let member_ptr = expressions.append(
+                        crate::Expression::AccessIndex {
+                            base: structure_ptr.handle,
+                            index: member_index,
+                        },
+                        span.clone(),
+                    );
 
-                    let length = expressions.append(crate::Expression::ArrayLength(member_ptr));
+                    let length =
+                        expressions.append(crate::Expression::ArrayLength(member_ptr), span);
 
                     self.lookup_expression.insert(
                         result_id,
                         LookupExpression {
                             handle: length,
                             type_id: result_type_id,
                         },
                     );
@@ -2073,25 +2271,31 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         spirv::MemoryAccess::NONE
                     };
 
                     // TODO: check if the source and target types are the same?
                     let target = self.lookup_expression.lookup(target_id)?;
                     let source = self.lookup_expression.lookup(source_id)?;
 
                     // This operation is practically the same as loading and then storing, I think.
-                    let value_expr = expressions.append(crate::Expression::Load {
-                        pointer: source.handle,
-                    });
+                    let value_expr = expressions.append(
+                        crate::Expression::Load {
+                            pointer: source.handle,
+                        },
+                        span.clone(),
+                    );
 
                     block.extend(emitter.finish(expressions));
-                    block.push(crate::Statement::Store {
-                        pointer: target.handle,
-                        value: value_expr,
-                    });
+                    block.push(
+                        crate::Statement::Store {
+                            pointer: target.handle,
+                            value: value_expr,
+                        },
+                        span,
+                    );
 
                     emitter.start(expressions);
                 }
                 Op::ControlBarrier => {
                     inst.expect(4)?;
                     let exec_scope_id = self.next()?;
                     let _mem_scope_raw = self.next()?;
                     let semantics_id = self.next()?;
@@ -2120,17 +2324,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         flags.set(
                             crate::Barrier::WORK_GROUP,
                             semantics
                                 & (spirv::MemorySemantics::SUBGROUP_MEMORY
                                     | spirv::MemorySemantics::WORKGROUP_MEMORY)
                                     .bits()
                                 != 0,
                         );
-                        block.push(crate::Statement::Barrier(flags));
+                        block.push(crate::Statement::Barrier(flags), span);
                     } else {
                         log::warn!("Unsupported barrier execution scope: {}", exec_scope);
                     }
                 }
                 _ => return Err(Error::UnsupportedInstruction(self.state, inst.op)),
             }
         };
 
@@ -2143,42 +2347,49 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             terminator,
             merge,
             construct: petgraph::graph::node_index(0),
             position: 0,
             visited: false,
         })
     }
 
-    fn make_expression_storage(&mut self) -> Arena<crate::Expression> {
+    fn make_expression_storage(
+        &mut self,
+        globals: &Arena<crate::GlobalVariable>,
+        constants: &Arena<crate::Constant>,
+    ) -> Arena<crate::Expression> {
         let mut expressions = Arena::new();
         #[allow(clippy::panic)]
         {
             assert!(self.lookup_expression.is_empty());
         }
         // register global variables
         for (&id, var) in self.lookup_variable.iter() {
-            let handle = expressions.append(crate::Expression::GlobalVariable(var.handle));
+            let span = globals.get_span(var.handle).clone();
+            let handle = expressions.append(crate::Expression::GlobalVariable(var.handle), span);
             self.lookup_expression.insert(
                 id,
                 LookupExpression {
                     type_id: var.type_id,
                     handle,
                 },
             );
         }
         // register special constants
         self.index_constant_expressions.clear();
         for &con_handle in self.index_constants.iter() {
-            let handle = expressions.append(crate::Expression::Constant(con_handle));
+            let span = constants.get_span(con_handle).clone();
+            let handle = expressions.append(crate::Expression::Constant(con_handle), span);
             self.index_constant_expressions.push(handle);
         }
         // register constants
         for (&id, con) in self.lookup_constant.iter() {
-            let handle = expressions.append(crate::Expression::Constant(con.handle));
+            let span = constants.get_span(con.handle).clone();
+            let handle = expressions.append(crate::Expression::Constant(con.handle), span);
             self.lookup_expression.insert(
                 id,
                 LookupExpression {
                     type_id: con.type_id,
                     handle,
                 },
             );
         }
@@ -2194,89 +2405,148 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             Ok(())
         }
     }
 
     /// Walk the statement tree and patch it in the following cases:
     /// 1. Function call targets are replaced by `deferred_function_calls` map
     /// 2. Lift the contents of "If" that only breaks on rejection, onto the parent after it.
     /// 3. Lift the contents of "Switch" that only has a default, onto the parent after it.
-    fn patch_statements(&self, statements: &mut crate::Block) -> Result<(), Error> {
+    fn patch_statements(
+        &mut self,
+        statements: &mut crate::Block,
+        expressions: &mut Arena<crate::Expression>,
+        fun_parameter_sampling: &mut [image::SamplingFlags],
+    ) -> Result<(), Error> {
         use crate::Statement as S;
         let mut i = 0usize;
         while i < statements.len() {
             match statements[i] {
                 S::Emit(_) => {}
                 S::Block(ref mut block) => {
-                    self.patch_statements(block)?;
+                    self.patch_statements(block, expressions, fun_parameter_sampling)?;
                 }
                 S::If {
                     condition: _,
                     ref mut accept,
                     ref mut reject,
                 } => {
                     if let [S::Break] = reject[..] {
                         // uplift "accept" into the parent
                         let extracted = mem::take(accept);
-                        statements.splice(i + 1..i + 1, extracted.into_iter());
+                        statements.splice(i + 1..i + 1, extracted);
                     } else {
-                        self.patch_statements(reject)?;
-                        self.patch_statements(accept)?;
+                        self.patch_statements(reject, expressions, fun_parameter_sampling)?;
+                        self.patch_statements(accept, expressions, fun_parameter_sampling)?;
                     }
                 }
                 S::Switch {
                     selector: _,
                     ref mut cases,
                     ref mut default,
                 } => {
                     if cases.is_empty() {
                         // uplift "default" into the parent
                         let extracted = mem::take(default);
-                        statements.splice(i + 1..i + 1, extracted.into_iter());
+                        statements.splice(i + 1..i + 1, extracted);
                     } else {
                         for case in cases.iter_mut() {
-                            self.patch_statements(&mut case.body)?;
+                            self.patch_statements(
+                                &mut case.body,
+                                expressions,
+                                fun_parameter_sampling,
+                            )?;
                         }
-                        self.patch_statements(default)?;
+                        self.patch_statements(default, expressions, fun_parameter_sampling)?;
                     }
                 }
                 S::Loop {
                     ref mut body,
                     ref mut continuing,
                 } => {
-                    self.patch_statements(body)?;
-                    self.patch_statements(continuing)?;
+                    self.patch_statements(body, expressions, fun_parameter_sampling)?;
+                    self.patch_statements(continuing, expressions, fun_parameter_sampling)?;
                 }
                 S::Break
                 | S::Continue
                 | S::Return { .. }
                 | S::Kill
                 | S::Barrier(_)
                 | S::Store { .. }
-                | S::ImageStore { .. } => {}
+                | S::ImageStore { .. }
+                | S::Atomic { .. } => {}
                 S::Call {
-                    ref mut function, ..
+                    function: ref mut callee,
+                    ref arguments,
+                    ..
                 } => {
-                    let fun_id = self.deferred_function_calls[function.index()];
-                    *function = *self.lookup_function.lookup(fun_id)?;
+                    let fun_id = self.deferred_function_calls[callee.index()];
+                    let fun_lookup = self.lookup_function.lookup(fun_id)?;
+                    *callee = fun_lookup.handle;
+
+                    // Patch sampling flags
+                    for (arg_index, arg) in arguments.iter().enumerate() {
+                        let flags = match fun_lookup.parameters_sampling.get(arg_index) {
+                            Some(&flags) if !flags.is_empty() => flags,
+                            _ => continue,
+                        };
+
+                        match expressions[*arg] {
+                            crate::Expression::GlobalVariable(handle) => {
+                                if let Some(sampling) = self.handle_sampling.get_mut(&handle) {
+                                    *sampling |= flags
+                                }
+                            }
+                            crate::Expression::FunctionArgument(i) => {
+                                fun_parameter_sampling[i as usize] |= flags;
+                            }
+                            ref other => return Err(Error::InvalidGlobalVar(other.clone())),
+                        }
+                    }
                 }
             }
             i += 1;
         }
         Ok(())
     }
 
-    fn patch_function(&self, fun: &mut crate::Function) -> Result<(), Error> {
+    fn patch_function(
+        &mut self,
+        handle: Option<Handle<crate::Function>>,
+        fun: &mut crate::Function,
+    ) -> Result<(), Error> {
+        // Note: this search is a bit unfortunate
+        let (fun_id, mut parameters_sampling) = match handle {
+            Some(h) => {
+                let (&fun_id, lookup) = self
+                    .lookup_function
+                    .iter_mut()
+                    .find(|&(_, ref lookup)| lookup.handle == h)
+                    .unwrap();
+                (fun_id, mem::take(&mut lookup.parameters_sampling))
+            }
+            None => (0, Vec::new()),
+        };
+
         for (_, expr) in fun.expressions.iter_mut() {
-            if let crate::Expression::Call(ref mut function) = *expr {
+            if let crate::Expression::CallResult(ref mut function) = *expr {
                 let fun_id = self.deferred_function_calls[function.index()];
-                *function = *self.lookup_function.lookup(fun_id)?;
+                *function = self.lookup_function.lookup(fun_id)?.handle;
             }
         }
-        self.patch_statements(&mut fun.body)?;
+
+        self.patch_statements(
+            &mut fun.body,
+            &mut fun.expressions,
+            &mut parameters_sampling,
+        )?;
+
+        if let Some(lookup) = self.lookup_function.get_mut(&fun_id) {
+            lookup.parameters_sampling = parameters_sampling;
+        }
         Ok(())
     }
 
     pub fn parse(mut self) -> Result<crate::Module, Error> {
         let mut module = {
             if self.next()? != spirv::MAGIC_NUMBER {
                 return Err(Error::InvalidHeader);
             }
@@ -2286,24 +2556,27 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             let _schema = self.next()?;
             log::info!("Generated by {} version {:x}", generator, version_raw);
             crate::Module::default()
         };
 
         // register indexing constants
         self.index_constants.clear();
         for i in 0..4 {
-            let handle = module.constants.append(crate::Constant {
-                name: None,
-                specialization: None,
-                inner: crate::ConstantInner::Scalar {
-                    width: 4,
-                    value: crate::ScalarValue::Sint(i),
+            let handle = module.constants.append(
+                crate::Constant {
+                    name: None,
+                    specialization: None,
+                    inner: crate::ConstantInner::Scalar {
+                        width: 4,
+                        value: crate::ScalarValue::Sint(i),
+                    },
                 },
-            });
+                Default::default(),
+            );
             self.index_constants.push(handle);
         }
 
         self.layouter.clear();
         self.dummy_functions = Arena::new();
         self.lookup_function.clear();
         self.function_call_graph.clear();
 
@@ -2343,17 +2616,19 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                 Op::TypeArray => self.parse_type_array(inst, &mut module),
                 Op::TypeRuntimeArray => self.parse_type_runtime_array(inst, &mut module),
                 Op::TypeStruct => self.parse_type_struct(inst, &mut module),
                 Op::TypeImage => self.parse_type_image(inst, &mut module),
                 Op::TypeSampledImage => self.parse_type_sampled_image(inst),
                 Op::TypeSampler => self.parse_type_sampler(inst, &mut module),
                 Op::Constant | Op::SpecConstant => self.parse_constant(inst, &mut module),
                 Op::ConstantComposite => self.parse_composite_constant(inst, &mut module),
-                Op::ConstantNull | Op::Undef => self.parse_null_constant(inst, &mut module),
+                Op::ConstantNull | Op::Undef => self
+                    .parse_null_constant(inst, &module.types, &mut module.constants)
+                    .map(|_| ()),
                 Op::ConstantTrue => self.parse_bool_constant(inst, true, &mut module),
                 Op::ConstantFalse => self.parse_bool_constant(inst, false, &mut module),
                 Op::Variable => self.parse_global_variable(inst, &mut module),
                 Op::Function => {
                     self.switch(ModuleState::Function, inst.op)?;
                     inst.expect(5)?;
                     self.parse_function(&mut module)
                 }
@@ -2361,35 +2636,37 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             }?;
         }
 
         log::info!("Patching...");
         {
             let mut nodes = petgraph::algo::toposort(&self.function_call_graph, None)
                 .map_err(|cycle| Error::FunctionCallCycle(cycle.node_id()))?;
             nodes.reverse(); // we need dominated first
-            let mut functions = mem::take(&mut module.functions).into_inner();
+            let mut functions = mem::take(&mut module.functions);
             for fun_id in nodes {
                 if fun_id > !(functions.len() as u32) {
                     // skip all the fake IDs registered for the entry points
                     continue;
                 }
-                let handle = self.lookup_function.get_mut(&fun_id).unwrap();
+                let lookup = self.lookup_function.get_mut(&fun_id).unwrap();
                 // take out the function from the old array
-                let fun = mem::take(&mut functions[handle.index()]);
+                let fun = mem::take(&mut functions[lookup.handle]);
                 // add it to the newly formed arena, and adjust the lookup
-                *handle = module.functions.append(fun);
+                lookup.handle = module
+                    .functions
+                    .append(fun, functions.get_span(lookup.handle).clone());
             }
         }
         // patch all the functions
-        for (_, fun) in module.functions.iter_mut() {
-            self.patch_function(fun)?;
+        for (handle, fun) in module.functions.iter_mut() {
+            self.patch_function(Some(handle), fun)?;
         }
         for ep in module.entry_points.iter_mut() {
-            self.patch_function(&mut ep.function)?;
+            self.patch_function(None, &mut ep.function)?;
         }
 
         // Check all the images and samplers to have consistent comparison property.
         for (handle, flags) in self.handle_sampling.drain() {
             if !image::patch_comparison_type(
                 flags,
                 module.global_variables.get_mut(handle),
                 &mut module.types,
@@ -2638,98 +2915,111 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         Ok(())
     }
 
     fn parse_type_bool(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(2)?;
         let id = self.next()?;
         let inner = crate::TypeInner::Scalar {
             kind: crate::ScalarKind::Bool,
             width: crate::BOOL_WIDTH,
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: None,
             },
         );
         Ok(())
     }
 
     fn parse_type_int(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(4)?;
         let id = self.next()?;
         let width = self.next()?;
         let sign = self.next()?;
         let inner = crate::TypeInner::Scalar {
             kind: match sign {
                 0 => crate::ScalarKind::Uint,
                 1 => crate::ScalarKind::Sint,
                 _ => return Err(Error::InvalidSign(sign)),
             },
             width: map_width(width)?,
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: None,
             },
         );
         Ok(())
     }
 
     fn parse_type_float(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(3)?;
         let id = self.next()?;
         let width = self.next()?;
         let inner = crate::TypeInner::Scalar {
             kind: crate::ScalarKind::Float,
             width: map_width(width)?,
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: None,
             },
         );
         Ok(())
     }
 
     fn parse_type_vector(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(4)?;
         let id = self.next()?;
         let type_id = self.next()?;
         let type_lookup = self.lookup_type.lookup(type_id)?;
         let (kind, width) = match module.types[type_lookup.handle].inner {
             crate::TypeInner::Scalar { kind, width } => (kind, width),
             _ => return Err(Error::InvalidInnerType(type_id)),
@@ -2738,31 +3028,35 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         let inner = crate::TypeInner::Vector {
             size: map_vector_size(component_count)?,
             kind,
             width,
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: Some(type_id),
             },
         );
         Ok(())
     }
 
     fn parse_type_matrix(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(4)?;
         let id = self.next()?;
         let vector_type_id = self.next()?;
         let num_columns = self.next()?;
         let decor = self.future_decor.remove(&id);
 
         let vector_type_lookup = self.lookup_type.lookup(vector_type_id)?;
@@ -2773,20 +3067,23 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                 width,
             },
             _ => return Err(Error::InvalidInnerType(vector_type_id)),
         };
 
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: decor.and_then(|dec| dec.name),
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: decor.and_then(|dec| dec.name),
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: Some(vector_type_id),
             },
         );
         Ok(())
     }
 
     fn parse_type_function(&mut self, inst: Instruction) -> Result<(), Error> {
         self.switch(ModuleState::Type, inst.op)?;
@@ -2804,63 +3101,69 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         Ok(())
     }
 
     fn parse_type_pointer(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(4)?;
         let id = self.next()?;
         let storage_class = self.next()?;
         let type_id = self.next()?;
 
         let decor = self.future_decor.remove(&id);
         let base_lookup_ty = self.lookup_type.lookup(type_id)?;
-        let class = match module.types[base_lookup_ty.handle].inner {
-            crate::TypeInner::Pointer { class, .. }
-            | crate::TypeInner::ValuePointer { class, .. } => class,
-            _ if self
-                .lookup_storage_buffer_types
-                .contains_key(&base_lookup_ty.handle) =>
-            {
-                crate::StorageClass::Storage
+        let class = if let Some(class) = module.types[base_lookup_ty.handle].inner.pointer_class() {
+            class
+        } else if self
+            .lookup_storage_buffer_types
+            .contains_key(&base_lookup_ty.handle)
+        {
+            crate::StorageClass::Storage {
+                access: crate::StorageAccess::default(),
             }
-            _ => match map_storage_class(storage_class)? {
+        } else {
+            match map_storage_class(storage_class)? {
                 ExtendedClass::Global(class) => class,
                 ExtendedClass::Input | ExtendedClass::Output => crate::StorageClass::Private,
-            },
+            }
         };
 
         // Don't bother with pointer stuff for `Handle` types.
         let lookup_ty = if class == crate::StorageClass::Handle {
             base_lookup_ty.clone()
         } else {
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: decor.and_then(|dec| dec.name),
-                    inner: crate::TypeInner::Pointer {
-                        base: base_lookup_ty.handle,
-                        class,
+                handle: module.types.append(
+                    crate::Type {
+                        name: decor.and_then(|dec| dec.name),
+                        inner: crate::TypeInner::Pointer {
+                            base: base_lookup_ty.handle,
+                            class,
+                        },
                     },
-                }),
+                    self.span_from_with_op(start),
+                ),
                 base_id: Some(type_id),
             }
         };
         self.lookup_type.insert(id, lookup_ty);
         Ok(())
     }
 
     fn parse_type_array(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(4)?;
         let id = self.next()?;
         let type_id = self.next()?;
         let length_id = self.next()?;
         let length_const = self.lookup_constant.lookup(length_id)?;
 
         let decor = self.future_decor.remove(&id).unwrap_or_default();
@@ -2871,31 +3174,35 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             stride: match decor.array_stride {
                 Some(stride) => stride.get(),
                 None => module.types[base].inner.span(&module.constants),
             },
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: decor.name,
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: decor.name,
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: Some(type_id),
             },
         );
         Ok(())
     }
 
     fn parse_type_runtime_array(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(3)?;
         let id = self.next()?;
         let type_id = self.next()?;
 
         let decor = self.future_decor.remove(&id).unwrap_or_default();
         let base = self.lookup_type.lookup(type_id)?.handle;
         let inner = crate::TypeInner::Array {
@@ -2904,31 +3211,35 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             stride: match decor.array_stride {
                 Some(stride) => stride.get(),
                 None => module.types[base].inner.span(&module.constants),
             },
         };
         self.lookup_type.insert(
             id,
             LookupType {
-                handle: module.types.append(crate::Type {
-                    name: decor.name,
-                    inner,
-                }),
+                handle: module.types.append(
+                    crate::Type {
+                        name: decor.name,
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 base_id: Some(type_id),
             },
         );
         Ok(())
     }
 
     fn parse_type_struct(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect_at_least(2)?;
         let id = self.next()?;
         let parent_decor = self.future_decor.remove(&id);
         let block_decor = parent_decor.as_ref().and_then(|decor| decor.block.clone());
 
         self.layouter
             .update(&module.types, &module.constants)
@@ -2941,24 +3252,17 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         for i in 0..u32::from(inst.wc) - 2 {
             let type_id = self.next()?;
             let ty = self.lookup_type.lookup(type_id)?.handle;
             let decor = self
                 .future_member_decor
                 .remove(&(id, i))
                 .unwrap_or_default();
 
-            let mut member_access = crate::StorageAccess::all();
-            if decor.flags.contains(DecorationFlags::NON_READABLE) {
-                member_access &= !crate::StorageAccess::LOAD;
-            }
-            if decor.flags.contains(DecorationFlags::NON_WRITABLE) {
-                member_access &= !crate::StorageAccess::STORE;
-            }
-            storage_access |= member_access;
+            storage_access |= decor.flags.to_storage_access();
 
             member_lookups.push(LookupMember {
                 type_id,
                 row_major: decor.matrix_major == Some(Majority::Row),
             });
 
             let binding = decor.io_binding().ok();
             // I/O structs don't have to have offsets, others do
@@ -2995,29 +3299,34 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                 ty,
                 binding,
                 offset,
             });
         }
 
         let inner = crate::TypeInner::Struct {
             top_level: block_decor.is_some(),
-            span: match members.last() {
-                Some(member) => {
+            span: members
+                .iter()
+                .map(|member| {
                     let end = member.offset + module.types[member.ty].inner.span(&module.constants);
                     ((end - 1) | (struct_alignment.get() - 1)) + 1
-                }
-                None => 4, //do we support this?
-            },
+                })
+                .max()
+                .unwrap_or(4), //do we support this?
             members,
         };
-        let ty_handle = module.types.append(crate::Type {
-            name: parent_decor.and_then(|dec| dec.name),
-            inner,
-        });
+
+        let ty_handle = module.types.append(
+            crate::Type {
+                name: parent_decor.and_then(|dec| dec.name),
+                inner,
+            },
+            self.span_from_with_op(start),
+        );
 
         if block_decor == Some(Block { buffer: true }) {
             self.lookup_storage_buffer_types
                 .insert(ty_handle, storage_access);
         }
         for (i, member_lookup) in member_lookups.into_iter().enumerate() {
             self.lookup_member
                 .insert((ty_handle, i as u32), member_lookup);
@@ -3032,67 +3341,77 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         Ok(())
     }
 
     fn parse_type_image(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(9)?;
 
         let id = self.next()?;
         let sample_type_id = self.next()?;
         let dim = self.next()?;
         let _is_depth = self.next()?;
         let is_array = self.next()? != 0;
         let is_msaa = self.next()? != 0;
         let _is_sampled = self.next()?;
         let format = self.next()?;
 
         let dim = map_image_dim(dim)?;
         let decor = self.future_decor.remove(&id).unwrap_or_default();
 
         // ensure there is a type for texture coordinate without extra components
-        module.types.fetch_or_append(crate::Type {
-            name: None,
-            inner: {
-                let kind = crate::ScalarKind::Float;
-                let width = 4;
-                match dim.required_coordinate_size() {
-                    None => crate::TypeInner::Scalar { kind, width },
-                    Some(size) => crate::TypeInner::Vector { size, kind, width },
-                }
+        module.types.fetch_or_append(
+            crate::Type {
+                name: None,
+                inner: {
+                    let kind = crate::ScalarKind::Float;
+                    let width = 4;
+                    match dim.required_coordinate_size() {
+                        None => crate::TypeInner::Scalar { kind, width },
+                        Some(size) => crate::TypeInner::Vector { size, kind, width },
+                    }
+                },
             },
-        });
+            Default::default(),
+        );
 
         let base_handle = self.lookup_type.lookup(sample_type_id)?.handle;
         let kind = module.types[base_handle]
             .inner
             .scalar_kind()
             .ok_or(Error::InvalidImageBaseType(base_handle))?;
 
         let inner = crate::TypeInner::Image {
             class: if format != 0 {
-                crate::ImageClass::Storage(map_image_format(format)?)
+                crate::ImageClass::Storage {
+                    format: map_image_format(format)?,
+                    access: crate::StorageAccess::default(),
+                }
             } else {
                 crate::ImageClass::Sampled {
                     kind,
                     multi: is_msaa,
                 }
             },
             dim,
             arrayed: is_array,
         };
 
-        let handle = module.types.append(crate::Type {
-            name: decor.name,
-            inner,
-        });
+        let handle = module.types.append(
+            crate::Type {
+                name: decor.name,
+                inner,
+            },
+            self.span_from_with_op(start),
+        );
 
         self.lookup_type.insert(
             id,
             LookupType {
                 handle,
                 base_id: Some(sample_type_id),
             },
         );
@@ -3114,39 +3433,44 @@ impl<I: Iterator<Item = u32>> Parser<I> 
         Ok(())
     }
 
     fn parse_type_sampler(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(2)?;
         let id = self.next()?;
         let decor = self.future_decor.remove(&id).unwrap_or_default();
-        let handle = module.types.append(crate::Type {
-            name: decor.name,
-            inner: crate::TypeInner::Sampler { comparison: false },
-        });
+        let handle = module.types.append(
+            crate::Type {
+                name: decor.name,
+                inner: crate::TypeInner::Sampler { comparison: false },
+            },
+            self.span_from_with_op(start),
+        );
         self.lookup_type.insert(
             id,
             LookupType {
                 handle,
                 base_id: None,
             },
         );
         Ok(())
     }
 
     fn parse_constant(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect_at_least(4)?;
         let type_id = self.next()?;
         let id = self.next()?;
         let type_lookup = self.lookup_type.lookup(type_id)?;
         let ty = type_lookup.handle;
 
         let inner = match module.types[ty].inner {
@@ -3206,32 +3530,36 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             _ => return Err(Error::UnsupportedType(type_lookup.handle)),
         };
 
         let decor = self.future_decor.remove(&id).unwrap_or_default();
 
         self.lookup_constant.insert(
             id,
             LookupConstant {
-                handle: module.constants.append(crate::Constant {
-                    specialization: decor.specialization,
-                    name: decor.name,
-                    inner,
-                }),
+                handle: module.constants.append(
+                    crate::Constant {
+                        specialization: decor.specialization,
+                        name: decor.name,
+                        inner,
+                    },
+                    self.span_from_with_op(start),
+                ),
                 type_id,
             },
         );
         Ok(())
     }
 
     fn parse_composite_constant(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect_at_least(3)?;
         let type_id = self.next()?;
         let type_lookup = self.lookup_type.lookup(type_id)?;
         let ty = type_lookup.handle;
         let id = self.next()?;
 
         let mut components = Vec::with_capacity(inst.wc as usize - 3);
@@ -3239,166 +3567,177 @@ impl<I: Iterator<Item = u32>> Parser<I> 
             let component_id = self.next()?;
             let constant = self.lookup_constant.lookup(component_id)?;
             components.push(constant.handle);
         }
 
         self.lookup_constant.insert(
             id,
             LookupConstant {
-                handle: module.constants.append(crate::Constant {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    specialization: None,
-                    inner: crate::ConstantInner::Composite { ty, components },
-                }),
+                handle: module.constants.append(
+                    crate::Constant {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        specialization: None,
+                        inner: crate::ConstantInner::Composite { ty, components },
+                    },
+                    self.span_from_with_op(start),
+                ),
                 type_id,
             },
         );
         Ok(())
     }
 
     fn parse_null_constant(
         &mut self,
         inst: Instruction,
-        module: &mut crate::Module,
-    ) -> Result<(), Error> {
+        types: &Arena<crate::Type>,
+        constants: &mut Arena<crate::Constant>,
+    ) -> Result<(u32, u32, Handle<crate::Constant>), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(3)?;
         let type_id = self.next()?;
         let id = self.next()?;
+        let span = self.span_from_with_op(start);
         let type_lookup = self.lookup_type.lookup(type_id)?;
         let ty = type_lookup.handle;
 
-        let inner = null::generate_null_constant(ty, &mut module.types, &mut module.constants)?;
-
-        self.lookup_constant.insert(
-            id,
-            LookupConstant {
-                handle: module.constants.append(crate::Constant {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    specialization: None, //TODO
-                    inner,
-                }),
-                type_id,
+        let inner = null::generate_null_constant(ty, types, constants, span.clone())?;
+        let handle = constants.append(
+            crate::Constant {
+                name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                specialization: None, //TODO
+                inner,
             },
+            span,
         );
-        Ok(())
+        self.lookup_constant
+            .insert(id, LookupConstant { handle, type_id });
+        Ok((type_id, id, handle))
     }
 
     fn parse_bool_constant(
         &mut self,
         inst: Instruction,
         value: bool,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect(3)?;
         let type_id = self.next()?;
         let id = self.next()?;
 
         self.lookup_constant.insert(
             id,
             LookupConstant {
-                handle: module.constants.append(crate::Constant {
-                    name: self.future_decor.remove(&id).and_then(|dec| dec.name),
-                    specialization: None, //TODO
-                    inner: crate::ConstantInner::boolean(value),
-                }),
+                handle: module.constants.append(
+                    crate::Constant {
+                        name: self.future_decor.remove(&id).and_then(|dec| dec.name),
+                        specialization: None, //TODO
+                        inner: crate::ConstantInner::boolean(value),
+                    },
+                    self.span_from_with_op(start),
+                ),
                 type_id,
             },
         );
         Ok(())
     }
 
     fn parse_global_variable(
         &mut self,
         inst: Instruction,
         module: &mut crate::Module,
     ) -> Result<(), Error> {
+        let start = self.data_offset;
         self.switch(ModuleState::Type, inst.op)?;
         inst.expect_at_least(4)?;
         let type_id = self.next()?;
         let id = self.next()?;
         let storage_class = self.next()?;
         let init = if inst.wc > 4 {
             inst.expect(5)?;
             let init_id = self.next()?;
             let lconst = self.lookup_constant.lookup(init_id)?;
             Some(lconst.handle)
         } else {
             None
         };
+        let span = self.span_from_with_op(start);
         let mut dec = self.future_decor.remove(&id).unwrap_or_default();
 
         let original_ty = self.lookup_type.lookup(type_id)?.handle;
-        let (effective_ty, is_storage) = match module.types[original_ty].inner {
-            crate::TypeInner::Pointer { base, class } => {
-                (base, class == crate::StorageClass::Storage)
-            }
-            crate::TypeInner::Image {
-                class: crate::ImageClass::Storage(_),
-                ..
-            } => (original_ty, true),
-            _ => (original_ty, false),
+        let mut effective_ty = original_ty;
+        if let crate::TypeInner::Pointer { base, class: _ } = module.types[original_ty].inner {
+            effective_ty = base;
         };
-        let (ext_class, type_storage_access) =
-            match self.lookup_storage_buffer_types.get(&effective_ty) {
-                Some(&access) => (ExtendedClass::Global(crate::StorageClass::Storage), access),
-                None => (
-                    map_storage_class(storage_class)?,
-                    crate::StorageAccess::all(),
-                ),
+        if let crate::TypeInner::Image {
+            dim,
+            arrayed,
+            class: crate::ImageClass::Storage { format, access: _ },
+        } = module.types[effective_ty].inner
+        {
+            // Storage image types in IR have to contain the access, but not in the SPIR-V.
+            // The same image type in SPIR-V can be used (and has to be used) for multiple images.
+            // So we copy the type out and apply the variable access decorations.
+            let access = dec.flags.to_storage_access();
+            let ty = crate::Type {
+                name: None,
+                inner: crate::TypeInner::Image {
+                    dim,
+                    arrayed,
+                    class: crate::ImageClass::Storage { format, access },
+                },
             };
+            effective_ty = module.types.append(ty, Default::default());
+        }
+
+        let ext_class = match self.lookup_storage_buffer_types.get(&effective_ty) {
+            Some(&access) => ExtendedClass::Global(crate::StorageClass::Storage { access }),
+            None => map_storage_class(storage_class)?,
+        };
 
         // Fix empty name for gl_PerVertex struct generated by glslang
         if let crate::TypeInner::Pointer { .. } = module.types[original_ty].inner {
             if ext_class == ExtendedClass::Input || ext_class == ExtendedClass::Output {
                 if let Some(ref dec_name) = dec.name {
                     if dec_name.is_empty() {
                         dec.name = Some("perVertexStruct".to_string())
                     }
                 }
             }
         }
 
         let (inner, var) = match ext_class {
-            ExtendedClass::Global(class) => {
-                let storage_access = if is_storage {
-                    let mut access = type_storage_access;
-                    if dec.flags.contains(DecorationFlags::NON_READABLE) {
-                        access &= !crate::StorageAccess::LOAD;
-                    }
-                    if dec.flags.contains(DecorationFlags::NON_WRITABLE) {
-                        access &= !crate::StorageAccess::STORE;
-                    }
-                    access
-                } else {
-                    crate::StorageAccess::empty()
-                };
-
+            ExtendedClass::Global(mut class) => {
+                if let crate::StorageClass::Storage { ref mut access } = class {
+                    *access &= dec.flags.to_storage_access();
+                }
                 let var = crate::GlobalVariable {
                     binding: dec.resource_binding(),
                     name: dec.name,
                     class,
                     ty: effective_ty,
                     init,
-                    storage_access,
                 };
                 (Variable::Global, var)
             }
             ExtendedClass::Input => {
                 let binding = dec.io_binding()?;
                 let mut unsigned_ty = effective_ty;
                 if let crate::Binding::BuiltIn(built_in) = binding {
                     let needs_inner_uint = match built_in {
                         crate::BuiltIn::BaseInstance
                         | crate::BuiltIn::BaseVertex
                         | crate::BuiltIn::InstanceIndex
                         | crate::BuiltIn::SampleIndex
                         | crate::BuiltIn::VertexIndex
+                        | crate::BuiltIn::PrimitiveIndex
                         | crate::BuiltIn::LocalInvocationIndex => Some(crate::TypeInner::Scalar {
                             kind: crate::ScalarKind::Uint,
                             width: 4,
                         }),
                         crate::BuiltIn::GlobalInvocationId
                         | crate::BuiltIn::LocalInvocationId
                         | crate::BuiltIn::WorkGroupId
                         | crate::BuiltIn::WorkGroupSize => Some(crate::TypeInner::Vector {
@@ -3409,45 +3748,45 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                         _ => None,
                     };
                     if let (Some(inner), Some(crate::ScalarKind::Sint)) = (
                         needs_inner_uint,
                         module.types[effective_ty].inner.scalar_kind(),
                     ) {
                         unsigned_ty = module
                             .types
-                            .fetch_or_append(crate::Type { name: None, inner });
+                            .fetch_or_append(crate::Type { name: None, inner }, Default::default());
                     }
                 }
 
                 let var = crate::GlobalVariable {
                     name: dec.name.clone(),
                     class: crate::StorageClass::Private,
                     binding: None,
                     ty: effective_ty,
                     init: None,
-                    storage_access: crate::StorageAccess::empty(),
                 };
                 let inner = Variable::Input(crate::FunctionArgument {
                     name: dec.name,
                     ty: unsigned_ty,
                     binding: Some(binding),
                 });
                 (inner, var)
             }
             ExtendedClass::Output => {
                 // For output interface blocks, this would be a structure.
                 let binding = dec.io_binding().ok();
                 let init = match binding {
                     Some(crate::Binding::BuiltIn(built_in)) => {
                         match null::generate_default_built_in(
                             Some(built_in),
                             effective_ty,
-                            &mut module.types,
+                            &module.types,
                             &mut module.constants,
+                            span.clone(),
                         ) {
                             Ok(handle) => Some(handle),
                             Err(e) => {
                                 log::warn!("Failed to initialize output built-in: {}", e);
                                 None
                             }
                         }
                     }
@@ -3466,51 +3805,54 @@ impl<I: Iterator<Item = u32>> Parser<I> 
                                 })
                                 .collect::<Vec<_>>();
 
                             let mut components = Vec::with_capacity(members.len());
                             for (built_in, member_ty) in pairs {
                                 let handle = null::generate_default_built_in(
                                     built_in,
                                     member_ty,
-                                    &mut module.types,
+                                    &module.types,
                                     &mut module.constants,
+                                    span.clone(),
                                 )?;
                                 components.push(handle);
                             }
-                            Some(module.constants.append(crate::Constant {
-                                name: None,
-                                specialization: None,
-                                inner: crate::ConstantInner::Composite {
-                                    ty: effective_ty,
-                                    components,
+                            Some(module.constants.append(
+                                crate::Constant {
+                                    name: None,
+                                    specialization: None,
+                                    inner: crate::ConstantInner::Composite {
+                                        ty: effective_ty,
+                                        components,
+                                    },
                                 },
-                            }))
+                                span.clone(),
+                            ))
                         }
                         _ => None,
                     },
                 };
 
                 let var = crate::GlobalVariable {
                     name: dec.name,
                     class: crate::StorageClass::Private,
                     binding: None,
                     ty: effective_ty,
                     init,
-                    storage_access: crate::StorageAccess::empty(),
                 };
                 let inner = Variable::Output(crate::FunctionResult {
                     ty: effective_ty,
                     binding,
                 });
                 (inner, var)
             }
         };
 
-        let handle = module.global_variables.append(var);
+        let handle = module.global_variables.append(var, span);
         if module.types[effective_ty].inner.can_comparison_sample() {
             log::debug!("\t\ttracking {:?} for sampling properties", handle);
             self.handle_sampling
                 .insert(handle, image::SamplingFlags::empty());
         }
 
         self.lookup_variable.insert(
             id,