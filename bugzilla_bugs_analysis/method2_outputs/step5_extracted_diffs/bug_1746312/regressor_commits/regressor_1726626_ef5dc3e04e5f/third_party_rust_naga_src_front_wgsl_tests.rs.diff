# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/wgsl/tests.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/front/wgsl/tests.rs b/third_party/rust/naga/src/front/wgsl/tests.rs
--- a/third_party/rust/naga/src/front/wgsl/tests.rs
+++ b/third_party/rust/naga/src/front/wgsl/tests.rs
@@ -16,27 +16,29 @@ fn parse_comment() {
 
 #[test]
 fn parse_types() {
     parse_str("let a : i32 = 2;").unwrap();
     assert!(parse_str("let a : x32 = 2;").is_err());
     parse_str("var t: texture_2d<f32>;").unwrap();
     parse_str("var t: texture_cube_array<i32>;").unwrap();
     parse_str("var t: texture_multisampled_2d<u32>;").unwrap();
-    parse_str("var t: [[access(write)]] texture_storage_1d<rgba8uint>;").unwrap();
-    parse_str("var t: [[access(read)]] texture_storage_3d<r32float>;").unwrap();
+    parse_str("var t: texture_storage_1d<rgba8uint,write>;").unwrap();
+    parse_str("var t: texture_storage_3d<r32float>;").unwrap();
 }
 
 #[test]
 fn parse_type_inference() {
     parse_str(
         "
         fn foo() {
             let a = 2u;
             let b: u32 = a;
+            var x = 3f32;
+            var y = vec2<f32>(1, 2);
         }",
     )
     .unwrap();
     assert!(parse_str(
         "
         fn foo() { let c : i32 = 2.0; }",
     )
     .is_err());
@@ -58,30 +60,46 @@ fn parse_type_cast() {
         "
         fn main() {
             let x: vec2<f32> = vec2<f32>(1.0, 2.0);
             let y: vec2<u32> = vec2<u32>(x);
         }
     ",
     )
     .unwrap();
+    parse_str(
+        "
+        fn main() {
+            let x: vec2<f32> = vec2<f32>(0.0);
+        }
+    ",
+    )
+    .unwrap();
+    assert!(parse_str(
+        "
+        fn main() {
+            let x: vec2<f32> = vec2<f32>(0);
+        }
+    ",
+    )
+    .is_err());
 }
 
 #[test]
 fn parse_struct() {
     parse_str(
         "
         [[block]] struct Foo { x: i32; };
         struct Bar {
             [[size(16)]] x: vec2<i32>;
             [[align(16)]] y: f32;
             [[size(32), align(8)]] z: vec3<f32>;
         };
         struct Empty {};
-        var s: [[access(read_write)]] Foo;
+        var<storage,read_write> s: Foo;
     ",
     )
     .unwrap();
 }
 
 #[test]
 fn parse_standard_fun() {
     parse_str(
@@ -212,30 +230,30 @@ fn parse_texture_load() {
         fn foo() {
             let r: vec4<i32> = textureLoad(t, vec2<i32>(10, 20), 2, 3);
         }
     ",
     )
     .unwrap();
     parse_str(
         "
-        var t: [[access(read)]] texture_storage_1d_array<r32float>;
+        var t: texture_storage_1d_array<r32float>;
         fn foo() {
             let r: vec4<f32> = textureLoad(t, 10, 2);
         }
     ",
     )
     .unwrap();
 }
 
 #[test]
 fn parse_texture_store() {
     parse_str(
         "
-        var t: [[access(write)]] texture_storage_2d<rgba8unorm>;
+        var t: texture_storage_2d<rgba8unorm,write>;
         fn foo() {
             textureStore(t, vec2<i32>(10, 20), vec4<f32>(0.0, 1.0, 2.0, 3.0));
         }
     ",
     )
     .unwrap();
 }
 
@@ -310,21 +328,53 @@ fn parse_array_length() {
     parse_str(
         "
         [[block]]
         struct Foo {
             data: [[stride(4)]] array<u32>;
         }; // this is used as both input and output for convenience
 
         [[group(0), binding(0)]]
-        var<storage> foo: [[access(read_write)]] Foo;
+        var<storage> foo: Foo;
 
         [[group(0), binding(1)]]
-        var<storage> bar: [[access(read)]] array<u32>;
+        var<storage> bar: array<u32>;
 
         fn foo() {
             var x: u32 = arrayLength(foo.data);
             var y: u32 = arrayLength(bar);
         }
         ",
     )
     .unwrap();
 }
+
+#[test]
+fn parse_storage_buffers() {
+    parse_str(
+        "
+        [[group(0), binding(0)]]
+        var<storage> foo: array<u32>;
+        ",
+    )
+    .unwrap();
+    parse_str(
+        "
+        [[group(0), binding(0)]]
+        var<storage,read> foo: array<u32>;
+        ",
+    )
+    .unwrap();
+    parse_str(
+        "
+        [[group(0), binding(0)]]
+        var<storage,write> foo: array<u32>;
+        ",
+    )
+    .unwrap();
+    parse_str(
+        "
+        [[group(0), binding(0)]]
+        var<storage,read_write> foo: array<u32>;
+        ",
+    )
+    .unwrap();
+}