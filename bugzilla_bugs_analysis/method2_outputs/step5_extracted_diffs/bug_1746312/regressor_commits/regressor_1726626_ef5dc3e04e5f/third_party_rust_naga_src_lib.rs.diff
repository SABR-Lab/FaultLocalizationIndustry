# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/lib.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/lib.rs b/third_party/rust/naga/src/lib.rs
--- a/third_party/rust/naga/src/lib.rs
+++ b/third_party/rust/naga/src/lib.rs
@@ -1,16 +1,16 @@
 /*! Universal shader translator.
 
 The central structure of the crate is [`Module`]. A `Module` contains:
 
-- [`EntryPoint`]s, the main functions for pipeline stages like vertex shading or
-  fragment shading,
+- [`Function`]s, which have arguments, a return type, local variables, and a body,
 
-- [`Function`]s, representing functions used by `EntryPoint`s and other `Function`s,
+- [`EntryPoint`]s, which are specialized functions that can serve as the entry
+  point for pipeline stages like vertex shading or fragment shading,
 
 - [`Constant`]s and [`GlobalVariable`]s used by `EntryPoint`s and `Function`s, and
 
 - [`Type`]s used by the above.
 
 The body of an `EntryPoint` or `Function` is represented using two types:
 
 - An [`Expression`] produces a value, but has no side effects or control flow.
@@ -24,90 +24,114 @@ The body of an `EntryPoint` or `Function
 
 `Statement`s form a tree, with pointers into the DAG of `Expression`s.
 
 Restricting side effects to statements simplifies analysis and code generation.
 A Naga backend can generate code to evaluate an `Expression` however and
 whenever it pleases, as long as it is certain to observe the side effects of all
 previously executed `Statement`s.
 
-Many `Statement` variants use the [`Block`] type, which is simply `Vec<Block>`,
-representing a series of statements executed in order. The body of an
+Many `Statement` variants use the [`Block`] type, which is `Vec<Statement>`,
+with optional span info, representing a series of statements executed in order. The body of an
 `EntryPoint`s or `Function` is a `Block`, and `Statement` has a
 [`Block`][Statement::Block] variant.
 
+## Arenas
+
 To improve translator performance and reduce memory usage, most structures are
 stored in an [`Arena`]. An `Arena<T>` stores a series of `T` values, indexed by
 [`Handle<T>`](Handle) values, which are just wrappers around integer indexes.
 For example, a `Function`'s expressions are stored in an `Arena<Expression>`,
 and compound expressions refer to their sub-expressions via `Handle<Expression>`
 values. (When examining the serialized form of a `Module`, note that the first
 element of an `Arena` has an index of 1, not 0.)
 
 ## Function Calls
 
-The Naga IR's representation of function calls is unusual. Most languages treat
+Naga's representation of function calls is unusual. Most languages treat
 function calls as expressions, but because calls may have side effects, Naga
-represents them with [`Statement::Call`]. A call statement may designate a
-particular `Expression` to represent its return value, if any, which can be used
-by subsequent statements and their expressions.
+represents them as a kind of statement, [`Statement::Call`]. If the function
+returns a value, a call statement designates a particular [`Expression::CallResult`]
+expression to represent its return value, for use by subsequent statements and
+expressions.
 
 ## `Expression` evaluation time and scope
 
-While the order of execution of [`Statement`]s is apparent from their structure,
-it is not so obvious exactly when a given [`Expression`] should be evaluated,
-since many `Statement`s and `Expression`s may refer to its value. But it is
-essential to clearly specify an expression's evaluation time, since that
-determines which statements' effects the expression should observe. It is also
-helpful to backends to limit the visibility of an `Expression`'s value to a
-portion of the statement tree.
+It is essential to know when an [`Expression`] should be evaluated, because its
+value may depend on previous [`Statement`]s' effects. But whereas the order of
+execution for a tree of `Statement`s is apparent from its structure, it is not
+so clear for `Expressions`, since an expression may be referred to by any number
+of `Statement`s and other `Expression`s.
+
+Naga's rules for when `Expression`s are evaluated are as follows:
+
+-   [`Constant`](Expression::Constant) expressions are considered to be
+    implicitly evaluated before execution begins.
 
-An `Expression` may only be used, whether by a `Statement` or another
-`Expression`, if one of the following is true:
+-   [`FunctionArgument`] and [`LocalVariable`] expressions are considered
+    implicitly evaluated upon entry to the function to which they belong.
+    Function arguments cannot be assigned to, and `LocalVariable` expressions
+    produce a *pointer to* the variable's value (for use with [`Load`] and
+    [`Store`]). Neither varies while the function executes, so it suffices to
+    consider these expressions evaluated once on entry.
 
-- The expression is an [`Expression::Constant`], [`Expression::FunctionArgument`], or
-  [`Expression::GlobalVariable`].
+-   Similarly, [`GlobalVariable`] expressions are considered implicitly
+    evaluated before execution begins, since their value does not change while
+    code executes, for one of two reasons:
 
-- The expression is an [`Expression::LocalVariable`] that is either the
-  `pointer` (destination) of a [`Statement::Store`], or initialized by some
-  previously executed `Statement::Store`.
+    -   Most `GlobalVariable` expressions produce a pointer to the variable's
+        value, for use with [`Load`] and [`Store`], as `LocalVariable`
+        expressions do. Although the variable's value may change, its address
+        does not.
 
-- The expression is the `result` of a [`Statement::Call`], representing the
-  call's return value. The call must be 'in scope' for the use (see below).
+    -   A `GlobalVariable` expression referring to a global in the
+        [`StorageClass::Handle`] storage class produces the value directly, not
+        a pointer. Such global variables hold opaque types like shaders or
+        images, and cannot be assigned to.
 
-- The expression is included in the range of some [`Statement::Emit`] that is
-  'in scope' for the use (see below). The [`Expression::needs_pre_emit`] method
-  returns `true` if the given expression does *not* need to be covered by an
-  `Emit` statement.
+-   A [`Call`](Expression::CallResult) expression that is the `result` of a
+    [`Statement::Call`], representing the call's return value, is evaluated when
+    the `Call` statement is executed.
+
+-   All other expressions are evaluated when the (unique) [`Statement::Emit`]
+    statement that covers them is executed. The [`Expression::needs_pre_emit`]
+    method returns `true` if the given expression is one of those variants that
+    does *not* need to be covered by an `Emit` statement.
 
-The scope of an expression evaluated by an `Emit` statement covers the
-subsequent expressions in that `Emit`, any following statements in the `Block`
-to which that `Emit` belongs (if any) and their sub-statements (if any).
+Each `Expression` has a *scope*, which is the region of the function within
+which it can be used by `Statement`s and other `Expression`s. It is a validation
+error to use an `Expression` outside its scope.
+
+An expression's scope is defined as follows:
+
+-   The scope of a [`Constant`], [`GlobalVariable`], [`FunctionArgument`] or
+    [`LocalVariable`] expression covers the entire `Function` in which it
+    occurs.
 
-If a `Call` statement has a `result` expression, then it is in scope for any
-statements following the `Call` in the `Block` to which that `Call` belongs (if
-any) and their sub-statements (if any).
+-   The scope of an expression evaluated by an [`Emit`] statement covers the
+    subsequent expressions in that `Emit`, the subsequent statements in the `Block`
+    to which that `Emit` belongs (if any) and their sub-statements (if any).
 
-This means that, for example, an expression evaluated by some statement in a
+-   If a [`Call`] statement has a `result` expression, then that expression's
+    scope covers the subsequent statements in the `Block` to which that `Call`
+    belongs (if any) and their sub-statements (if any).
+
+For example, this implies that an expression evaluated by some statement in a
 nested `Block` is not available in the `Block`'s parents. Such a value would
 need to be stored in a local variable to be carried upwards in the statement
 tree.
 
-## Variables
-
-An [`Expression::LocalVariable`] or [`Expression::GlobalVariable`] produces a
-pointer value referring to the variable's value. To retrieve the variable's
-value, use an [`Expression::Load`], with the variable expression as its
-`pointer` operand. To assign to a variable, use a [`Statement::Store`] with the
-variable expression as its `pointer` operand.
-
-As an exception, [`Expression::GlobalVariable`]s referring to
-[`GlobalVariable`]s whose `class` is [`StorageClass::Handle`] produce the
-variable's value directly; no `Load` is needed. These global variables refer to
-opaque values like samplers and images.
+[`Call`]: Statement::Call
+[`Constant`]: Expression::Constant
+[`Emit`]: Statement::Emit
+[`FunctionArgument`]: Expression::FunctionArgument
+[`GlobalVariable`]: Expression::GlobalVariable
+[`Load`]: Expression::Load
+[`LocalVariable`]: Expression::LocalVariable
+[`Store`]: Statement::Store
 
 !*/
 
 // TODO: use `strip_prefix` instead when Rust 1.45 <= MSRV
 #![allow(
     renamed_and_removed_lints,
     unknown_lints, // requires Rust 1.51
     clippy::new_without_default,
@@ -122,27 +146,30 @@ opaque values like samplers and images.
     unused_extern_crates,
     unused_qualifications,
     clippy::pattern_type_mismatch
 )]
 #![deny(clippy::panic)]
 
 mod arena;
 pub mod back;
+mod block;
 pub mod front;
 pub mod proc;
+mod span;
 pub mod valid;
 
 pub use crate::arena::{Arena, Handle, Range};
 
 use std::{
     collections::{HashMap, HashSet},
     hash::BuildHasherDefault,
 };
 
+pub use crate::span::Span;
 #[cfg(feature = "deserialize")]
 use serde::Deserialize;
 #[cfg(feature = "serialize")]
 use serde::Serialize;
 
 /// Width of a boolean type, in bytes.
 pub const BOOL_WIDTH: Bytes = 1;
 
@@ -159,34 +186,34 @@ pub(crate) type NamedExpressions = FastH
 ///   - Calling ```discard``` in a shader.
 ///   - Writing to the depth buffer, unless ConservativeDepth is enabled.
 ///
 /// SPIR-V: ExecutionMode EarlyFragmentTests
 /// In GLSL: layout(early_fragment_tests) in;
 /// HLSL: Attribute earlydepthstencil
 ///
 /// For more, see:
-///   - https://www.khronos.org/opengl/wiki/Early_Fragment_Test#Explicit_specification
-///   - https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-earlydepthstencil
+///   - <https://www.khronos.org/opengl/wiki/Early_Fragment_Test#Explicit_specification>
+///   - <https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-earlydepthstencil>
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct EarlyDepthTest {
     conservative: Option<ConservativeDepth>,
 }
 /// Enables adjusting depth without disabling early Z.
 ///
 /// SPIR-V: ExecutionMode DepthGreater/DepthLess/DepthUnchanged
 /// GLSL: layout (depth_<greater/less/unchanged/any>) out float gl_FragDepth;
 ///   - ```depth_any``` option behaves as if the layout qualifier was not present.
 /// HLSL: SV_Depth/SV_DepthGreaterEqual/SV_DepthLessEqual
 ///
 /// For more, see:
-///   - https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_conservative_depth.txt
-///   - https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#system-value-semantics
+///   - <https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_conservative_depth.txt>
+///   - <https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics#system-value-semantics>
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub enum ConservativeDepth {
     /// Shader may rewrite depth only with a value greater than calculated;
     GreaterEqual,
 
     /// Shader may rewrite depth smaller than one that would have been written without the modification.
@@ -216,17 +243,17 @@ pub enum StorageClass {
     Function,
     /// Private data, per invocation, mutable.
     Private,
     /// Workgroup shared data, mutable.
     WorkGroup,
     /// Uniform buffer data.
     Uniform,
     /// Storage buffer data, potentially mutable.
-    Storage,
+    Storage { access: StorageAccess },
     /// Opaque handles, such as samplers and images.
     Handle,
     /// Push constants.
     PushConstant,
 }
 
 /// Built-in inputs and outputs.
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
@@ -240,24 +267,26 @@ pub enum BuiltIn {
     ClipDistance,
     CullDistance,
     InstanceIndex,
     PointSize,
     VertexIndex,
     // fragment
     FragDepth,
     FrontFacing,
+    PrimitiveIndex,
     SampleIndex,
     SampleMask,
     // compute
     GlobalInvocationId,
     LocalInvocationId,
     LocalInvocationIndex,
     WorkGroupId,
     WorkGroupSize,
+    NumWorkGroups,
 }
 
 /// Number of bytes per scalar.
 pub type Bytes = u8;
 
 /// Number of components in a vector.
 #[repr(u8)]
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
@@ -431,23 +460,32 @@ pub enum StorageFormat {
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub enum ImageClass {
     /// Regular sampled image.
     Sampled {
         /// Kind of values to sample.
         kind: ScalarKind,
-        // Multi-sampled.
+        /// Multi-sampled image.
+        ///
+        /// A multi-sampled image holds several samples per texel. Multi-sampled
+        /// images cannot have mipmaps.
         multi: bool,
     },
     /// Depth comparison image.
-    Depth,
+    Depth {
+        /// Multi-sampled depth image.
+        multi: bool,
+    },
     /// Storage image.
-    Storage(StorageFormat),
+    Storage {
+        format: StorageFormat,
+        access: StorageAccess,
+    },
 }
 
 /// A data type declared in the module.
 #[derive(Debug, PartialEq)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct Type {
     /// The name of the type, if any.
@@ -470,45 +508,111 @@ pub enum TypeInner {
         width: Bytes,
     },
     /// Matrix of floats.
     Matrix {
         columns: VectorSize,
         rows: VectorSize,
         width: Bytes,
     },
+    /// Atomic scalar.
+    Atomic { kind: ScalarKind, width: Bytes },
     /// Pointer to another type.
+    ///
+    /// ## Pointers to non-`SIZED` types
+    ///
+    /// The `base` type of a pointer may be a non-[`SIZED`] type like a
+    /// dynamically-sized [`Array`], or a [`Struct`] whose last member is a
+    /// dynamically sized array. Such pointers occur as the types of
+    /// [`GlobalVariable`] or [`AccessIndex`] expressions referring to
+    /// dynamically-sized arrays.
+    ///
+    /// However, among pointers to non-`SIZED` types, only pointers to `Struct`s
+    /// are [`DATA`]. Pointers to dynamically sized `Array`s cannot be passed as
+    /// arguments, stored in variables, or held in arrays or structures. Their
+    /// only use is as the types of `AccessIndex` expressions.
+    ///
+    /// [`SIZED`]: valid::TypeFlags::SIZED
+    /// [`DATA`]: valid::TypeFlags::DATA
+    /// [`Array`]: TypeInner::Array
+    /// [`Struct`]: TypeInner::Struct
+    /// [`GlobalVariable`]: Expression::GlobalVariable
+    /// [`AccessIndex`]: Expression::AccessIndex
     Pointer {
         base: Handle<Type>,
         class: StorageClass,
     },
     /// Pointer to a value.
     ValuePointer {
         size: Option<VectorSize>,
         kind: ScalarKind,
         width: Bytes,
         class: StorageClass,
     },
+
     /// Homogenous list of elements.
+    ///
+    /// The `base` type must be a [`SIZED`], [`DATA`] type.
+    ///
+    /// ## Dynamically sized arrays
+    ///
+    /// An `Array` is [`SIZED`] unless its `size` is [`Dynamic`].
+    /// Dynamically-sized arrays may only appear in a few situations:
+    ///
+    /// -   They may appear as the last member of a [`Struct`] whose `top_level`
+    ///     flag is set.
+    ///
+    /// -   They may appear as the base type of a [`Pointer`]. An
+    ///     [`AccessIndex`] expression referring to a top-level struct's final
+    ///     unsized array member would have such a pointer type. However, such
+    ///     pointer types may only appear as the types of such intermediate
+    ///     expressions. They are not [`DATA`], and cannot be stored in
+    ///     variables, held in arrays or structs, or passed as parameters.
+    ///
+    /// [`SIZED`]: crate::valid::TypeFlags::SIZED
+    /// [`DATA`]: crate::valid::TypeFlags::DATA
+    /// [`Dynamic`]: ArraySize::Dynamic
+    /// [`Struct`]: TypeInner::Struct
+    /// [`Pointer`]: TypeInner::Pointer
+    /// [`AccessIndex`]: Expression::AccessIndex
     Array {
         base: Handle<Type>,
         size: ArraySize,
         stride: u32,
     },
+
     /// User-defined structure.
+    ///
+    /// A `Struct` type is [`DATA`], and the types of its members must be
+    /// `DATA` as well.
+    ///
+    /// Member types must be [`SIZED`], except for the final member of a
+    /// top-level struct, which may be a dynamically sized [`Array`]. The
+    /// `Struct` type itself is `SIZED` when all its members are `SIZED`.
+    ///
+    /// When `top_level` is true, this `Struct` represents the contents of a
+    /// buffer resource occupying a single binding slot in a shader's resource
+    /// interface. Top-level `Struct`s may not be used as members of any other
+    /// struct, or as array elements.
+    ///
+    /// [`DATA`]: crate::valid::TypeFlags::DATA
+    /// [`SIZED`]: crate::valid::TypeFlags::SIZED
+    /// [`Array`]: TypeInner::Array
     Struct {
+        /// This struct serves as the type of a binding slot in a shader's resource interface.
         top_level: bool,
         members: Vec<StructMember>,
         //TODO: should this be unaligned?
         span: u32,
     },
     /// Possibly multidimensional array of texels.
     Image {
         dim: ImageDimension,
         arrayed: bool,
+        //TODO: consider moving `multisampled: bool` out
         class: ImageClass,
     },
     /// Can be used to sample values from images.
     Sampler { comparison: bool },
 }
 
 /// Constant value.
 #[derive(Debug, PartialEq)]
@@ -557,17 +661,17 @@ pub enum Binding {
     Location {
         location: u32,
         interpolation: Option<Interpolation>,
         sampling: Option<Sampling>,
     },
 }
 
 /// Pipeline binding information for global resources.
-#[derive(Clone, Debug, Hash, PartialEq)]
+#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct ResourceBinding {
     /// The bind group index.
     pub group: u32,
     /// Binding number within the group.
     pub binding: u32,
 }
@@ -582,18 +686,16 @@ pub struct GlobalVariable {
     /// How this variable is to be stored.
     pub class: StorageClass,
     /// For resources, defines the binding point.
     pub binding: Option<ResourceBinding>,
     /// The type of this variable.
     pub ty: Handle<Type>,
     /// Initial value for this variable.
     pub init: Option<Handle<Constant>>,
-    /// Access bit for storage types of images and buffers.
-    pub storage_access: StorageAccess,
 }
 
 /// Variable defined at function level.
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct LocalVariable {
     /// Name of the variable, if any.
@@ -634,16 +736,33 @@ pub enum BinaryOperator {
     InclusiveOr,
     LogicalAnd,
     LogicalOr,
     ShiftLeft,
     /// Right shift carries the sign of signed integers only.
     ShiftRight,
 }
 
+/// Function on an atomic value.
+///
+/// Note: these do not include load/store, which use the existing
+/// [`Expression::Load`] and [`Statement::Store`].
+#[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
+#[cfg_attr(feature = "serialize", derive(Serialize))]
+#[cfg_attr(feature = "deserialize", derive(Deserialize))]
+pub enum AtomicFunction {
+    Add,
+    And,
+    ExclusiveOr,
+    InclusiveOr,
+    Min,
+    Max,
+    Exchange { compare: Option<Handle<Expression>> },
+}
+
 /// Axis on which to compute a derivative.
 #[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub enum DerivativeAxis {
     X,
     Y,
     Width,
@@ -678,16 +797,19 @@ pub enum MathFunction {
     Sin,
     Sinh,
     Tan,
     Tanh,
     Acos,
     Asin,
     Atan,
     Atan2,
+    Asinh,
+    Acosh,
+    Atanh,
     // decomposition
     Ceil,
     Floor,
     Round,
     Fract,
     Trunc,
     Modf,
     Frexp,
@@ -849,16 +971,18 @@ pub enum Expression {
         index: Handle<Expression>,
     },
     /// Array access with a known index.
     AccessIndex {
         base: Handle<Expression>,
         index: u32,
     },
     /// Constant value.
+    ///
+    /// Every `Constant` expression
     Constant(Handle<Constant>),
     /// Splat scalar into a vector.
     Splat {
         size: VectorSize,
         value: Handle<Expression>,
     },
     /// Vector swizzle.
     Swizzle {
@@ -866,44 +990,147 @@ pub enum Expression {
         vector: Handle<Expression>,
         pattern: [SwizzleComponent; 4],
     },
     /// Composite expression.
     Compose {
         ty: Handle<Type>,
         components: Vec<Handle<Expression>>,
     },
+
     /// Reference a function parameter, by its index.
+    ///
+    /// A `FunctionArgument` expression evaluates to a pointer to the argument's
+    /// value. You must use a [`Load`] expression to retrieve its value, or a
+    /// [`Store`] statement to assign it a new value.
+    ///
+    /// [`Load`]: Expression::Load
+    /// [`Store`]: Statement::Store
     FunctionArgument(u32),
+
     /// Reference a global variable.
+    ///
+    /// If the given `GlobalVariable`'s [`class`] is [`StorageClass::Handle`],
+    /// then the variable stores some opaque type like a sampler or an image,
+    /// and a `GlobalVariable` expression referring to it produces the
+    /// variable's value directly.
+    ///
+    /// For any other storage class, a `GlobalVariable` expression produces a
+    /// pointer to the variable's value. You must use a [`Load`] expression to
+    /// retrieve its value, or a [`Store`] statement to assign it a new value.
+    ///
+    /// [`class`]: GlobalVariable::class
+    /// [`Load`]: Expression::Load
+    /// [`Store`]: Statement::Store
     GlobalVariable(Handle<GlobalVariable>),
+
     /// Reference a local variable.
+    ///
+    /// A `LocalVariable` expression evaluates to a pointer to the variable's value.
+    /// You must use a [`Load`](Expression::Load) expression to retrieve its value,
+    /// or a [`Store`](Statement::Store) statement to assign it a new value.
     LocalVariable(Handle<LocalVariable>),
+
     /// Load a value indirectly.
+    ///
+    /// For [`TypeInner::Atomic`] the result is a corresponding scalar.
+    /// For other types behind the pointer<T>, the result is T.
     Load { pointer: Handle<Expression> },
     /// Sample a point from a sampled or a depth image.
     ImageSample {
         image: Handle<Expression>,
         sampler: Handle<Expression>,
         coordinate: Handle<Expression>,
         array_index: Option<Handle<Expression>>,
         offset: Option<Handle<Constant>>,
         level: SampleLevel,
         depth_ref: Option<Handle<Expression>>,
     },
+
     /// Load a texel from an image.
+    ///
+    /// For most images, this returns a four-element vector of the same
+    /// [`ScalarKind`] as the image. If the format of the image does not have
+    /// four components, default values are provided: the first three components
+    /// (typically R, G, and B) default to zero, and the final component
+    /// (typically alpha) defaults to one.
+    ///
+    /// However, if the image's [`class`] is [`Depth`], then this returns a
+    /// [`Float`] scalar value.
+    ///
+    /// [`ScalarKind`]: ScalarKind
+    /// [`class`]: TypeInner::Image::class
+    /// [`Depth`]: ImageClass::Depth
+    /// [`Float`]: ScalarKind::Float
     ImageLoad {
+        /// The image to load a texel from. This must have type [`Image`]. (This
+        /// will necessarily be a [`GlobalVariable`] or [`FunctionArgument`]
+        /// expression, since no other expressions are allowed to have that
+        /// type.)
+        ///
+        /// [`Image`]: TypeInner::Image
+        /// [`GlobalVariable`]: Expression::GlobalVariable
+        /// [`FunctionArgument`]: Expression::FunctionArgument
         image: Handle<Expression>,
+
+        /// The coordinate of the texel we wish to load. This must be a scalar
+        /// for [`D1`] images, a [`Bi`] vector for [`D2`] images, and a [`Tri`]
+        /// vector for [`D3`] images. (Array indices, sample indices, and
+        /// explicit level-of-detail values are supplied separately.) Its
+        /// component type must be [`Sint`].
+        ///
+        /// [`D1`]: ImageDimension::D1
+        /// [`D2`]: ImageDimension::D2
+        /// [`D3`]: ImageDimension::D3
+        /// [`Bi`]: VectorSize::Bi
+        /// [`Tri`]: VectorSize::Tri
+        /// [`Sint`]: ScalarKind::Sint
         coordinate: Handle<Expression>,
+
+        /// The index into an arrayed image. If the [`arrayed`] flag in
+        /// `image`'s type is `true`, then this must be `Some(expr)`, where
+        /// `expr` is a [`Sint`] scalar. Otherwise, it must be `None`.
+        ///
+        /// [`arrayed`]: TypeInner::Image::arrayed
+        /// [`Sint`]: ScalarKind::Sint
         array_index: Option<Handle<Expression>>,
-        /// For storage images, this is None.
-        /// For sampled images, this is the Some(Level).
-        /// For multisampled images, this is Some(Sample).
+
+        /// The sample within a particular texel.
+        ///
+        /// The meaning of this value depends on the [`class`] of `image`:
+        ///
+        /// -   [`Storage`] images hold exactly one sample per texel, so `index` must
+        ///     be `None`.
+        ///
+        /// -   [`Depth`] and [`Sampled`] images may be multisampled or have
+        ///     mipmaps, but not both. Which one is indicated by the variant's
+        ///     [`multi`] field:
+        ///
+        ///     - If `multi` is `true`, then the image has multiple samples per
+        ///       texel, and `index` must be `Some(sample)`, where `sample` is
+        ///       the index of the sample to retrieve.
+        ///
+        ///     - If `multi` is `false`, then the image may have mipmaps. In
+        ///       this case, `index` must be `Some(level)`, where `level`
+        ///       identifies the level of detail. Even if the image has only the
+        ///       full-sized version, `level` must still be present; its only
+        ///       in-range value is zero.
+        ///
+        /// When `index` is `Some` the value must be a `Sint` scalar value. If
+        /// it identifes a level of detail, zero represents the full resolution
+        /// mipmap.
+        ///
+        /// [`class`]: TypeInner::Image::class
+        /// [`Sampled`]: ImageClass::Sampled
+        /// [`Storage`]: ImageClass::Storage
+        /// [`Depth`]: ImageClass::Depth
+        /// [`multi`]: ImageClass::Sampled::multi
         index: Option<Handle<Expression>>,
     },
+
     /// Query information from an image.
     ImageQuery {
         image: Handle<Expression>,
         query: ImageQuery,
     },
     /// Apply an unary operator.
     Unary {
         op: UnaryOperator,
@@ -949,27 +1176,32 @@ pub enum Expression {
         expr: Handle<Expression>,
         /// Target scalar kind.
         kind: ScalarKind,
         /// If provided, converts to the specified byte width.
         /// Otherwise, bitcast.
         convert: Option<Bytes>,
     },
     /// Result of calling another function.
-    Call(Handle<Function>),
+    CallResult(Handle<Function>),
+    /// Result of an atomic operation.
+    AtomicResult {
+        kind: ScalarKind,
+        width: Bytes,
+        comparison: bool,
+    },
     /// Get the length of an array.
     /// The expression must resolve to a pointer to an array with a dynamic size.
     ///
     /// This doesn't match the semantics of spirv's `OpArrayLength`, which must be passed
     /// a pointer to a structure containing a runtime array in its' last field.
     ArrayLength(Handle<Expression>),
 }
 
-/// A code block is just a vector of statements.
-pub type Block = Vec<Statement>;
+pub use block::Block;
 
 /// A case for a switch statement.
 // Clone is used only for error reporting and is not intended for end users
 #[derive(Clone, Debug)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct SwitchCase {
     /// Value, upon which the case is considered true.
@@ -1003,55 +1235,125 @@ pub enum Statement {
         reject: Block,
     },
     /// Conditionally executes one of multiple blocks, based on the value of the selector.
     Switch {
         selector: Handle<Expression>, //int
         cases: Vec<SwitchCase>,
         default: Block,
     },
+
     /// Executes a block repeatedly.
+    ///
+    /// Each iteration of the loop executes the `body` block, followed by the
+    /// `continuing` block.
+    ///
+    /// Executing a [`Break`], [`Return`] or [`Kill`] statement exits the loop.
+    ///
+    /// A [`Continue`] statement in `body` jumps to the `continuing` block. The
+    /// `continuing` block is meant to be used to represent structures like the
+    /// third expression of a C-style `for` loop head, to which `continue`
+    /// statements in the loop's body jump.
+    ///
+    /// The `continuing` block and its substatements must not contain `Return`
+    /// or `Kill` statements, or any `Break` or `Continue` statements targeting
+    /// this loop. (It may have `Break` and `Continue` statements targeting
+    /// loops or switches nested within the `continuing` block.)
+    ///
+    /// [`Break`]: Statement::Break
+    /// [`Continue`]: Statement::Continue
+    /// [`Kill`]: Statement::Kill
+    /// [`Return`]: Statement::Return
     Loop { body: Block, continuing: Block },
-    /// Exits the loop.
+
+    /// Exits the innermost enclosing [`Loop`] or [`Switch`].
+    ///
+    /// A `Break` statement may only appear within a [`Loop`] or [`Switch`]
+    /// statement. It may not break out of a [`Loop`] from within the loop's
+    /// `continuing` block.
+    ///
+    /// [`Loop`]: Statement::Loop
+    /// [`Switch`]: Statement::Switch
     Break,
-    /// Skips execution to the next iteration of the loop.
+
+    /// Skips to the `continuing` block of the innermost enclosing [`Loop`].
+    ///
+    /// A `Continue` statement may only appear within the `body` block of the
+    /// innermost enclosing [`Loop`] statement. It must not appear within that
+    /// loop's `continuing` block.
+    ///
+    /// [`Loop`]: Statement::Loop
     Continue,
+
     /// Returns from the function (possibly with a value).
+    ///
+    /// `Return` statements are forbidden within the `continuing` block of a
+    /// [`Loop`] statement.
+    ///
+    /// [`Loop`]: Statement::Loop
     Return { value: Option<Handle<Expression>> },
+
     /// Aborts the current shader execution.
+    ///
+    /// `Kill` statements are forbidden within the `continuing` block of a
+    /// [`Loop`] statement.
+    ///
+    /// [`Loop`]: Statement::Loop
     Kill,
+
     /// Synchronize invocations within the work group.
     /// The `Barrier` flags control which memory accesses should be synchronized.
     /// If empty, this becomes purely an execution barrier.
     Barrier(Barrier),
     /// Stores a value at an address.
     ///
+    /// For [`TypeInner::Atomic`] type behind the pointer, the value
+    /// has to be a corresponding scalar.
+    /// For other types behind the pointer<T>, the value is T.
+    ///
     /// This statement is a barrier for any operations on the
     /// `Expression::LocalVariable` or `Expression::GlobalVariable`
     /// that is the destination of an access chain, started
     /// from the `pointer`.
     Store {
         pointer: Handle<Expression>,
         value: Handle<Expression>,
     },
-    /// Stores a value to an image.
+    /// Stores a texel value to an image.
     ///
-    /// Image has to point into a global variable of type `TypeInner::Image`.
+    /// The `image`, `coordinate`, and `array_index` fields have the same
+    /// meanings as the corresponding operands of an [`ImageLoad`] expression;
+    /// see that documentation for details. Storing into multisampled images or
+    /// images with mipmaps is not supported, so there is no `index`operand.
+    ///
     /// This statement is a barrier for any operations on the corresponding
-    /// `Expression::GlobalVariable` for this image.
+    /// [`Expression::GlobalVariable`] for this image.
+    ///
+    /// [`ImageLoad`]: Expression::ImageLoad
     ImageStore {
         image: Handle<Expression>,
         coordinate: Handle<Expression>,
         array_index: Option<Handle<Expression>>,
         value: Handle<Expression>,
     },
+    /// Atomic function.
+    Atomic {
+        /// Pointer to an atomic value.
+        pointer: Handle<Expression>,
+        /// Function to run on the atomic.
+        fun: AtomicFunction,
+        /// Value to use in the function.
+        value: Handle<Expression>,
+        /// Emitted expression as a result.
+        result: Handle<Expression>,
+    },
     /// Calls a function.
     ///
     /// If the `result` is `Some`, the corresponding expression has to be
-    /// `Expression::Call`, and this statement serves as a barrier for any
+    /// `Expression::CallResult`, and this statement serves as a barrier for any
     /// operations on that expression.
     Call {
         function: Handle<Function>,
         arguments: Vec<Handle<Expression>>,
         result: Option<Handle<Expression>>,
     },
 }
 
@@ -1096,17 +1398,56 @@ pub struct Function {
     /// Expressions used inside this function.
     pub expressions: Arena<Expression>,
     /// Map of expressions that have associated variable names
     pub named_expressions: NamedExpressions,
     /// Block of instructions comprising the body of the function.
     pub body: Block,
 }
 
-/// Exported function, to be run at a certain stage in the pipeline.
+/// The main function for a pipeline stage.
+///
+/// An [`EntryPoint`] is a [`Function`] that serves as the main function for a
+/// graphics or compute pipeline stage. For example, an `EntryPoint` whose
+/// [`stage`] is [`ShaderStage::Vertex`] can serve as a graphics pipeline's
+/// vertex shader.
+///
+/// Since an entry point is called directly by the graphics or compute pipeline,
+/// not by other WGSL functions, you must specify what the pipeline should pass
+/// as the entry point's arguments, and what values it will return. For example,
+/// a vertex shader needs a vertex's attributes as its arguments, but if it's
+/// used for instanced draw calls, it will also want to know the instance id.
+/// The vertex shader's return value will usually include an output vertex
+/// position, and possibly other attributes to be interpolated and passed along
+/// to a fragment shader.
+///
+/// To specify this, the arguments and result of an `EntryPoint`'s [`function`]
+/// must each have a [`Binding`], or be structs whose members all have
+/// `Binding`s. This associates every value passed to or returned from the entry
+/// point with either a [`BuiltIn`] or a [`Location`]:
+///
+/// -   A [`BuiltIn`] has special semantics, usually specific to its pipeline
+///     stage. For example, the result of a vertex shader can include a
+///     [`BuiltIn::Position`] value, which determines the position of a vertex
+///     of a rendered primitive. Or, a compute shader might take an argument
+///     whose binding is [`BuiltIn::WorkGroupSize`], through which the compute
+///     pipeline would pass the number of invocations in your workgroup.
+///
+/// -   A [`Location`] indicates user-defined IO to be passed from one pipeline
+///     stage to the next. For example, a vertex shader might also produce a
+///     `uv` texture location as a user-defined IO value.
+///
+/// In other words, the pipeline stage's input and output interface are
+/// determined by the bindings of the arguments and result of the `EntryPoint`'s
+/// [`function`].
+///
+/// [`Function`]: crate::Function
+/// [`Location`]: Binding::Location
+/// [`function`]: EntryPoint::function
+/// [`stage`]: EntryPoint::stage
 #[derive(Debug)]
 #[cfg_attr(feature = "serialize", derive(Serialize))]
 #[cfg_attr(feature = "deserialize", derive(Deserialize))]
 pub struct EntryPoint {
     /// Name of this entry point, visible externally.
     pub name: String,
     /// Shader stage.
     pub stage: ShaderStage,