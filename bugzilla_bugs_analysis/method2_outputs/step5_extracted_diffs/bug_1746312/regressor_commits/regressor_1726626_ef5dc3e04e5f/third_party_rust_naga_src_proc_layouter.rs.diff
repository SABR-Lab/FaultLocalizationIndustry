# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/proc/layouter.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/proc/layouter.rs b/third_party/rust/naga/src/proc/layouter.rs
--- a/third_party/rust/naga/src/proc/layouter.rs
+++ b/third_party/rust/naga/src/proc/layouter.rs
@@ -9,17 +9,17 @@ pub type Alignment = NonZeroU32;
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct TypeLayout {
     pub size: u32,
     pub alignment: Alignment,
 }
 
 /// Helper processor that derives the sizes of all types.
 /// It uses the default layout algorithm/table, described in
-/// https://github.com/gpuweb/gpuweb/issues/1393
+/// <https://github.com/gpuweb/gpuweb/issues/1393>
 #[derive(Debug, Default)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct Layouter {
     layouts: Vec<TypeLayout>,
 }
 
 impl ops::Index<Handle<crate::Type>> for Layouter {
@@ -67,17 +67,17 @@ impl Layouter {
         types: &Arena<crate::Type>,
         constants: &Arena<crate::Constant>,
     ) -> Result<(), InvalidBaseType> {
         use crate::TypeInner as Ti;
 
         for (ty_handle, ty) in types.iter().skip(self.layouts.len()) {
             let size = ty.inner.span(constants);
             let layout = match ty.inner {
-                Ti::Scalar { width, .. } => TypeLayout {
+                Ti::Scalar { width, .. } | Ti::Atomic { width, .. } => TypeLayout {
                     size,
                     alignment: Alignment::new(width as u32).unwrap(),
                 },
                 Ti::Vector {
                     size: vec_size,
                     width,
                     ..
                 } => TypeLayout {