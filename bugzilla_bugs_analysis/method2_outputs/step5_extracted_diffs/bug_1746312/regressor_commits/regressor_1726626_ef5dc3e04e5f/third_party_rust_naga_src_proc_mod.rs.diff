# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/proc/mod.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/proc/mod.rs b/third_party/rust/naga/src/proc/mod.rs
--- a/third_party/rust/naga/src/proc/mod.rs
+++ b/third_party/rust/naga/src/proc/mod.rs
@@ -1,21 +1,31 @@
 //! Module processing functionality.
 
+mod index;
 mod interpolator;
 mod layouter;
 mod namer;
 mod terminator;
 mod typifier;
 
+pub use index::IndexableLength;
 pub use layouter::{Alignment, InvalidBaseType, Layouter, TypeLayout};
 pub use namer::{EntryPointIndex, NameKey, Namer};
 pub use terminator::ensure_block_returns;
 pub use typifier::{ResolveContext, ResolveError, TypeResolution};
 
+#[derive(Clone, Debug, thiserror::Error, PartialEq)]
+pub enum ProcError {
+    #[error("type is not indexable, and has no length (validation error)")]
+    TypeNotIndexable,
+    #[error("array length is wrong kind of constant (validation error)")]
+    InvalidArraySizeConstant(crate::Handle<crate::Constant>),
+}
+
 impl From<super::StorageFormat> for super::ScalarKind {
     fn from(format: super::StorageFormat) -> Self {
         use super::{ScalarKind as Sk, StorageFormat as Sf};
         match format {
             Sf::R8Unorm => Sk::Float,
             Sf::R8Snorm => Sk::Float,
             Sf::R8Uint => Sk::Uint,
             Sf::R8Sint => Sk::Sint,
@@ -70,29 +80,41 @@ impl super::TypeInner {
             super::TypeInner::Scalar { kind, .. } | super::TypeInner::Vector { kind, .. } => {
                 Some(kind)
             }
             super::TypeInner::Matrix { .. } => Some(super::ScalarKind::Float),
             _ => None,
         }
     }
 
+    pub fn pointer_class(&self) -> Option<crate::StorageClass> {
+        match *self {
+            Self::Pointer { class, .. } => Some(class),
+            Self::ValuePointer { class, .. } => Some(class),
+            _ => None,
+        }
+    }
+
     pub fn span(&self, constants: &super::Arena<super::Constant>) -> u32 {
         match *self {
-            Self::Scalar { kind: _, width } => width as u32,
+            Self::Scalar { kind: _, width } | Self::Atomic { kind: _, width } => width as u32,
             Self::Vector {
                 size,
                 kind: _,
                 width,
             } => (size as u8 * width) as u32,
+            // matrices are treated as arrays of aligned columns
             Self::Matrix {
                 columns,
                 rows,
                 width,
-            } => (columns as u8 * rows as u8 * width) as u32,
+            } => {
+                let aligned_rows = if rows > crate::VectorSize::Bi { 4 } else { 2 };
+                columns as u32 * aligned_rows * width as u32
+            }
             Self::Pointer { .. } | Self::ValuePointer { .. } => POINTER_SPAN,
             Self::Array {
                 base: _,
                 size,
                 stride,
             } => {
                 let count = match size {
                     super::ArraySize::Constant(handle) => {
@@ -124,16 +146,19 @@ impl super::MathFunction {
             Self::Sin => 1,
             Self::Sinh => 1,
             Self::Tan => 1,
             Self::Tanh => 1,
             Self::Acos => 1,
             Self::Asin => 1,
             Self::Atan => 1,
             Self::Atan2 => 2,
+            Self::Asinh => 1,
+            Self::Acosh => 1,
+            Self::Atanh => 1,
             // decomposition
             Self::Ceil => 1,
             Self::Floor => 1,
             Self::Round => 1,
             Self::Fract => 1,
             Self::Trunc => 1,
             Self::Modf => 2,
             Self::Frexp => 2,
@@ -212,17 +237,29 @@ impl crate::SampleLevel {
         match *self {
             Self::Auto | Self::Bias(_) => true,
             Self::Zero | Self::Exact(_) | Self::Gradient { .. } => false,
         }
     }
 }
 
 impl crate::Constant {
-    pub fn to_array_length(&self) -> Option<u32> {
+    /// Interpret this constant as an array length, and return it as a `u32`.
+    ///
+    /// Ignore any specialization available for this constant; return its
+    /// unspecialized value.
+    ///
+    /// If the constant has an inappropriate kind (non-scalar or non-integer) or
+    /// value (negative, out of range for u32), return `None`. This usually
+    /// indicates an error, but only the caller has enough information to report
+    /// the error helpfully: in back ends, it's a validation error, but in front
+    /// ends, it may indicate ill-formed input (for example, a SPIR-V
+    /// `OpArrayType` referring to an inappropriate `OpConstant`). So we return
+    /// `Option` and let the caller sort things out.
+    pub(crate) fn to_array_length(&self) -> Option<u32> {
         use std::convert::TryInto;
         match self.inner {
             crate::ConstantInner::Scalar { value, width: _ } => match value {
                 crate::ScalarValue::Uint(value) => value.try_into().ok(),
                 // Accept a signed integer size to avoid
                 // requiring an explicit uint
                 // literal. Type inference should make
                 // this unnecessary.
@@ -283,8 +320,22 @@ impl super::SwizzleComponent {
         match idx {
             0 => Self::X,
             1 => Self::Y,
             2 => Self::Z,
             _ => Self::W,
         }
     }
 }
+
+#[test]
+fn test_matrix_size() {
+    let constants = crate::Arena::new();
+    assert_eq!(
+        crate::TypeInner::Matrix {
+            columns: crate::VectorSize::Tri,
+            rows: crate::VectorSize::Tri,
+            width: 4
+        }
+        .span(&constants),
+        48
+    );
+}