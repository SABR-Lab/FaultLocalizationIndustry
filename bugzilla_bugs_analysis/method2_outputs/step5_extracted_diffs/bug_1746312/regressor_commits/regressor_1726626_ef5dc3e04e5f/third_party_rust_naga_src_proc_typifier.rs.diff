# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/proc/typifier.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/proc/typifier.rs b/third_party/rust/naga/src/proc/typifier.rs
--- a/third_party/rust/naga/src/proc/typifier.rs
+++ b/third_party/rust/naga/src/proc/typifier.rs
@@ -345,17 +345,23 @@ impl<'a> ResolveContext<'a> {
             crate::Expression::LocalVariable(h) => {
                 let var = &self.local_vars[h];
                 TypeResolution::Value(Ti::Pointer {
                     base: var.ty,
                     class: crate::StorageClass::Function,
                 })
             }
             crate::Expression::Load { pointer } => match *past(pointer).inner_with(types) {
-                Ti::Pointer { base, class: _ } => TypeResolution::Handle(base),
+                Ti::Pointer { base, class: _ } => {
+                    if let Ti::Atomic { kind, width } = types[base].inner {
+                        TypeResolution::Value(Ti::Scalar { kind, width })
+                    } else {
+                        TypeResolution::Handle(base)
+                    }
+                }
                 Ti::ValuePointer {
                     size,
                     kind,
                     width,
                     class: _,
                 } => TypeResolution::Value(match size {
                     Some(size) => Ti::Vector { size, kind, width },
                     None => Ti::Scalar { kind, width },
@@ -363,26 +369,26 @@ impl<'a> ResolveContext<'a> {
                 ref other => {
                     log::error!("Pointer type {:?}", other);
                     return Err(ResolveError::InvalidPointer(pointer));
                 }
             },
             crate::Expression::ImageSample { image, .. }
             | crate::Expression::ImageLoad { image, .. } => match *past(image).inner_with(types) {
                 Ti::Image { class, .. } => TypeResolution::Value(match class {
-                    crate::ImageClass::Depth => Ti::Scalar {
+                    crate::ImageClass::Depth { multi: _ } => Ti::Scalar {
                         kind: crate::ScalarKind::Float,
                         width: 4,
                     },
                     crate::ImageClass::Sampled { kind, multi: _ } => Ti::Vector {
                         kind,
                         width: 4,
                         size: crate::VectorSize::Quad,
                     },
-                    crate::ImageClass::Storage(format) => Ti::Vector {
+                    crate::ImageClass::Storage { format, .. } => Ti::Vector {
                         kind: format.into(),
                         width: 4,
                         size: crate::VectorSize::Quad,
                     },
                 }),
                 ref other => {
                     log::error!("Image type {:?}", other);
                     return Err(ResolveError::InvalidImage(image));
@@ -390,22 +396,22 @@ impl<'a> ResolveContext<'a> {
             },
             crate::Expression::ImageQuery { image, query } => TypeResolution::Value(match query {
                 crate::ImageQuery::Size { level: _ } => match *past(image).inner_with(types) {
                     Ti::Image { dim, .. } => match dim {
                         crate::ImageDimension::D1 => Ti::Scalar {
                             kind: crate::ScalarKind::Sint,
                             width: 4,
                         },
-                        crate::ImageDimension::D2 => Ti::Vector {
+                        crate::ImageDimension::D2 | crate::ImageDimension::Cube => Ti::Vector {
                             size: crate::VectorSize::Bi,
                             kind: crate::ScalarKind::Sint,
                             width: 4,
                         },
-                        crate::ImageDimension::D3 | crate::ImageDimension::Cube => Ti::Vector {
+                        crate::ImageDimension::D3 => Ti::Vector {
                             size: crate::VectorSize::Tri,
                             kind: crate::ScalarKind::Sint,
                             width: 4,
                         },
                     },
                     ref other => {
                         log::error!("Image type {:?}", other);
                         return Err(ResolveError::InvalidImage(image));
@@ -497,16 +503,31 @@ impl<'a> ResolveContext<'a> {
                     TypeResolution::Value(inner)
                 }
                 crate::BinaryOperator::And
                 | crate::BinaryOperator::ExclusiveOr
                 | crate::BinaryOperator::InclusiveOr
                 | crate::BinaryOperator::ShiftLeft
                 | crate::BinaryOperator::ShiftRight => past(left).clone(),
             },
+            crate::Expression::AtomicResult {
+                kind,
+                width,
+                comparison,
+            } => {
+                if comparison {
+                    TypeResolution::Value(Ti::Vector {
+                        size: crate::VectorSize::Bi,
+                        kind,
+                        width,
+                    })
+                } else {
+                    TypeResolution::Value(Ti::Scalar { kind, width })
+                }
+            }
             crate::Expression::Select { accept, .. } => past(accept).clone(),
             crate::Expression::Derivative { axis: _, expr } => past(expr).clone(),
             crate::Expression::Relational { .. } => TypeResolution::Value(Ti::Scalar {
                 kind: crate::ScalarKind::Bool,
                 width: crate::BOOL_WIDTH,
             }),
             crate::Expression::Math {
                 fun,
@@ -528,16 +549,19 @@ impl<'a> ResolveContext<'a> {
                     Mf::Sin |
                     Mf::Sinh |
                     Mf::Tan |
                     Mf::Tanh |
                     Mf::Acos |
                     Mf::Asin |
                     Mf::Atan |
                     Mf::Atan2 |
+                    Mf::Asinh |
+                    Mf::Acosh |
+                    Mf::Atanh |
                     // decomposition
                     Mf::Ceil |
                     Mf::Floor |
                     Mf::Round |
                     Mf::Fract |
                     Mf::Trunc |
                     Mf::Modf |
                     Mf::Frexp |
@@ -655,17 +679,17 @@ impl<'a> ResolveContext<'a> {
                 }),
                 ref other => {
                     return Err(ResolveError::IncompatibleOperands(format!(
                         "{:?} as {:?}",
                         other, kind
                     )))
                 }
             },
-            crate::Expression::Call(function) => {
+            crate::Expression::CallResult(function) => {
                 let result = self.functions[function]
                     .result
                     .as_ref()
                     .ok_or(ResolveError::FunctionReturnsVoid)?;
                 TypeResolution::Handle(result.ty)
             }
             crate::Expression::ArrayLength(_) => TypeResolution::Value(Ti::Scalar {
                 kind: crate::ScalarKind::Uint,