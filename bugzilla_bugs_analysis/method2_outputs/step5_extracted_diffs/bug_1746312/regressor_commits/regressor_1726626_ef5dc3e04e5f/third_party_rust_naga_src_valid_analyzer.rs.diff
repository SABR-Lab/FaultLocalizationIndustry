# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/valid/analyzer.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/valid/analyzer.rs b/third_party/rust/naga/src/valid/analyzer.rs
--- a/third_party/rust/naga/src/valid/analyzer.rs
+++ b/third_party/rust/naga/src/valid/analyzer.rs
@@ -154,16 +154,42 @@ impl ExpressionInfo {
             ty: TypeResolution::Value(crate::TypeInner::Scalar {
                 kind: crate::ScalarKind::Bool,
                 width: 0,
             }),
         }
     }
 }
 
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
+enum GlobalOrArgument {
+    Global(Handle<crate::GlobalVariable>),
+    Argument(u32),
+}
+
+impl crate::Expression {
+    fn to_global_or_argument(&self) -> Result<GlobalOrArgument, ExpressionError> {
+        Ok(match *self {
+            crate::Expression::GlobalVariable(var) => GlobalOrArgument::Global(var),
+            crate::Expression::FunctionArgument(i) => GlobalOrArgument::Argument(i),
+            _ => return Err(ExpressionError::ExpectedGlobalOrArgument),
+        })
+    }
+}
+
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "serialize", derive(serde::Serialize))]
+#[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
+struct Sampling {
+    image: GlobalOrArgument,
+    sampler: GlobalOrArgument,
+}
+
 #[derive(Debug)]
 #[cfg_attr(feature = "serialize", derive(serde::Serialize))]
 #[cfg_attr(feature = "deserialize", derive(serde::Deserialize))]
 pub struct FunctionInfo {
     /// Validation flags.
     flags: ValidationFlags,
     /// Set of shader stages where calling this function is valid.
     pub available_stages: ShaderStages,
@@ -176,16 +202,18 @@ pub struct FunctionInfo {
     /// Vector of global variable usages.
     ///
     /// Each item corresponds to a global variable in the module.
     global_uses: Box<[GlobalUse]>,
     /// Vector of expression infos.
     ///
     /// Each item corresponds to an expression in the function.
     expressions: Box<[ExpressionInfo]>,
+    /// HashSet with information about sampling realized by the function
+    sampling: crate::FastHashSet<Sampling>,
 }
 
 impl FunctionInfo {
     pub fn global_variable_count(&self) -> usize {
         self.global_uses.len()
     }
     pub fn expression_count(&self) -> usize {
         self.expressions.len()
@@ -268,31 +296,66 @@ impl FunctionInfo {
             if let Some(_old) = assignable_global.replace(global) {
                 unreachable!()
             }
         }
         info.uniformity.non_uniform_result
     }
 
     /// Inherit information from a called function.
-    fn process_call(&mut self, info: &Self) -> FunctionUniformity {
+    fn process_call(
+        &mut self,
+        info: &Self,
+        arguments: &[Handle<crate::Expression>],
+        expression_arena: &Arena<crate::Expression>,
+    ) -> Result<FunctionUniformity, FunctionError> {
         for key in info.sampling_set.iter() {
             self.sampling_set.insert(key.clone());
         }
+        for sampling in info.sampling.iter() {
+            let image_storage = match sampling.image {
+                GlobalOrArgument::Global(var) => GlobalOrArgument::Global(var),
+                GlobalOrArgument::Argument(i) => {
+                    let handle = arguments[i as usize];
+                    expression_arena[handle]
+                        .to_global_or_argument()
+                        .map_err(|error| FunctionError::Expression { handle, error })?
+                }
+            };
+
+            let sampler_storage = match sampling.sampler {
+                GlobalOrArgument::Global(var) => GlobalOrArgument::Global(var),
+                GlobalOrArgument::Argument(i) => {
+                    let handle = arguments[i as usize];
+                    expression_arena[handle]
+                        .to_global_or_argument()
+                        .map_err(|error| FunctionError::Expression { handle, error })?
+                }
+            };
+
+            match (image_storage, sampler_storage) {
+                (GlobalOrArgument::Global(image), GlobalOrArgument::Global(sampler)) => {
+                    self.sampling_set.insert(SamplingKey { image, sampler });
+                }
+                (image, sampler) => {
+                    self.sampling.insert(Sampling { image, sampler });
+                }
+            }
+        }
         for (mine, other) in self.global_uses.iter_mut().zip(info.global_uses.iter()) {
             *mine |= *other;
         }
-        FunctionUniformity {
+        Ok(FunctionUniformity {
             result: info.uniformity.clone(),
             exit: if info.may_kill {
                 ExitFlags::MAY_KILL
             } else {
                 ExitFlags::empty()
             },
-        }
+        })
     }
 
     /// Computes the expression info and stores it in `self.expressions`.
     /// Also, bumps the reference counts on dependent expressions.
     #[allow(clippy::or_fun_call)]
     fn process_expression(
         &mut self,
         handle: Handle<crate::Expression>,
@@ -338,17 +401,18 @@ impl FunctionInfo {
             E::FunctionArgument(index) => {
                 let arg = &resolve_context.arguments[index as usize];
                 let uniform = match arg.binding {
                     Some(crate::Binding::BuiltIn(built_in)) => match built_in {
                         // per-polygon built-ins are uniform
                         crate::BuiltIn::FrontFacing
                         // per-work-group built-ins are uniform
                         | crate::BuiltIn::WorkGroupId
-                        | crate::BuiltIn::WorkGroupSize => true,
+                        | crate::BuiltIn::WorkGroupSize
+                        | crate::BuiltIn::NumWorkGroups => true,
                         _ => false,
                     },
                     // only flat inputs are uniform
                     Some(crate::Binding::Location {
                         interpolation: Some(crate::Interpolation::Flat),
                         ..
                     }) => true,
                     _ => false,
@@ -366,19 +430,18 @@ impl FunctionInfo {
                 let uniform = match var.class {
                     // local data is non-uniform
                     Sc::Function | Sc::Private => false,
                     // workgroup memory is exclusively accessed by the group
                     Sc::WorkGroup => true,
                     // uniform data
                     Sc::Uniform | Sc::PushConstant => true,
                     // storage data is only uniform when read-only
-                    Sc::Handle | Sc::Storage => {
-                        !var.storage_access.contains(crate::StorageAccess::STORE)
-                    }
+                    Sc::Storage { access } => !access.contains(crate::StorageAccess::STORE),
+                    Sc::Handle => false,
                 };
                 Uniformity {
                     non_uniform_result: if uniform { None } else { Some(handle) },
                     requirements: UniformityRequirements::empty(),
                 }
             }
             E::LocalVariable(_) => Uniformity {
                 non_uniform_result: Some(handle),
@@ -392,26 +455,31 @@ impl FunctionInfo {
                 image,
                 sampler,
                 coordinate,
                 array_index,
                 offset: _,
                 level,
                 depth_ref,
             } => {
-                self.sampling_set.insert(SamplingKey {
-                    image: match expression_arena[image] {
-                        crate::Expression::GlobalVariable(var) => var,
-                        _ => return Err(ExpressionError::ExpectedGlobalVariable),
-                    },
-                    sampler: match expression_arena[sampler] {
-                        crate::Expression::GlobalVariable(var) => var,
-                        _ => return Err(ExpressionError::ExpectedGlobalVariable),
-                    },
-                });
+                let image_storage = expression_arena[image].to_global_or_argument()?;
+                let sampler_storage = expression_arena[sampler].to_global_or_argument()?;
+
+                match (image_storage, sampler_storage) {
+                    (GlobalOrArgument::Global(image), GlobalOrArgument::Global(sampler)) => {
+                        self.sampling_set.insert(SamplingKey { image, sampler });
+                    }
+                    _ => {
+                        self.sampling.insert(Sampling {
+                            image: image_storage,
+                            sampler: sampler_storage,
+                        });
+                    }
+                }
+
                 // "nur" == "Non-Uniform Result"
                 let array_nur = array_index.and_then(|h| self.add_ref(h));
                 let level_nur = match level {
                     Sl::Auto | Sl::Zero => None,
                     Sl::Exact(h) | Sl::Bias(h) => self.add_ref(h),
                     Sl::Gradient { x, y } => self.add_ref(x).or(self.add_ref(y)),
                 };
                 let dref_nur = depth_ref.and_then(|h| self.add_ref(h));
@@ -495,22 +563,27 @@ impl FunctionInfo {
                     non_uniform_result: self.add_ref(arg).or(arg1_nur).or(arg2_nur),
                     requirements: UniformityRequirements::empty(),
                 }
             }
             E::As { expr, .. } => Uniformity {
                 non_uniform_result: self.add_ref(expr),
                 requirements: UniformityRequirements::empty(),
             },
-            E::Call(function) => {
-                let fun = other_functions
+            E::CallResult(function) => {
+                let info = other_functions
                     .get(function.index())
                     .ok_or(ExpressionError::CallToUndeclaredFunction(function))?;
-                self.process_call(fun).result
+
+                info.uniformity.clone()
             }
+            E::AtomicResult { .. } => Uniformity {
+                non_uniform_result: Some(handle),
+                requirements: UniformityRequirements::empty(),
+            },
             E::ArrayLength(expr) => Uniformity {
                 non_uniform_result: self.add_ref_impl(expr, GlobalUse::QUERY),
                 requirements: UniformityRequirements::empty(),
             },
         };
 
         let ty = resolve_context.resolve(expression, |h| &self.expressions[h.index()].ty)?;
         self.expressions[handle.index()] = ExpressionInfo {
@@ -532,16 +605,17 @@ impl FunctionInfo {
     /// Returns a `NonUniformControlFlow` error if any of the expressions in the block
     /// require uniformity, but the current flow is non-uniform.
     #[allow(clippy::or_fun_call)]
     fn process_block(
         &mut self,
         statements: &[crate::Statement],
         other_functions: &[FunctionInfo],
         mut disruptor: Option<UniformityDisruptor>,
+        expression_arena: &Arena<crate::Expression>,
     ) -> Result<FunctionUniformity, FunctionError> {
         use crate::Statement as S;
 
         let mut combined_uniformity = FunctionUniformity::new();
         for statement in statements {
             let uniformity = match *statement {
                 S::Emit(ref range) => {
                     let mut requirements = UniformityRequirements::empty();
@@ -577,64 +651,87 @@ impl FunctionInfo {
                 },
                 S::Barrier(_) => FunctionUniformity {
                     result: Uniformity {
                         non_uniform_result: None,
                         requirements: UniformityRequirements::WORK_GROUP_BARRIER,
                     },
                     exit: ExitFlags::empty(),
                 },
-                S::Block(ref b) => self.process_block(b, other_functions, disruptor)?,
+                S::Block(ref b) => {
+                    self.process_block(b, other_functions, disruptor, expression_arena)?
+                }
                 S::If {
                     condition,
                     ref accept,
                     ref reject,
                 } => {
                     let condition_nur = self.add_ref(condition);
                     let branch_disruptor =
                         disruptor.or(condition_nur.map(UniformityDisruptor::Expression));
-                    let accept_uniformity =
-                        self.process_block(accept, other_functions, branch_disruptor)?;
-                    let reject_uniformity =
-                        self.process_block(reject, other_functions, branch_disruptor)?;
+                    let accept_uniformity = self.process_block(
+                        accept,
+                        other_functions,
+                        branch_disruptor,
+                        expression_arena,
+                    )?;
+                    let reject_uniformity = self.process_block(
+                        reject,
+                        other_functions,
+                        branch_disruptor,
+                        expression_arena,
+                    )?;
                     accept_uniformity | reject_uniformity
                 }
                 S::Switch {
                     selector,
                     ref cases,
                     ref default,
                 } => {
                     let selector_nur = self.add_ref(selector);
                     let branch_disruptor =
                         disruptor.or(selector_nur.map(UniformityDisruptor::Expression));
                     let mut uniformity = FunctionUniformity::new();
                     let mut case_disruptor = branch_disruptor;
                     for case in cases.iter() {
-                        let case_uniformity =
-                            self.process_block(&case.body, other_functions, case_disruptor)?;
+                        let case_uniformity = self.process_block(
+                            &case.body,
+                            other_functions,
+                            case_disruptor,
+                            expression_arena,
+                        )?;
                         case_disruptor = if case.fall_through {
                             case_disruptor.or(case_uniformity.exit_disruptor())
                         } else {
                             branch_disruptor
                         };
                         uniformity = uniformity | case_uniformity;
                     }
                     // using the disruptor inherited from the last fall-through chain
-                    let default_exit =
-                        self.process_block(default, other_functions, case_disruptor)?;
+                    let default_exit = self.process_block(
+                        default,
+                        other_functions,
+                        case_disruptor,
+                        expression_arena,
+                    )?;
                     uniformity | default_exit
                 }
                 S::Loop {
                     ref body,
                     ref continuing,
                 } => {
-                    let body_uniformity = self.process_block(body, other_functions, disruptor)?;
+                    let body_uniformity =
+                        self.process_block(body, other_functions, disruptor, expression_arena)?;
                     let continuing_disruptor = disruptor.or(body_uniformity.exit_disruptor());
-                    let continuing_uniformity =
-                        self.process_block(continuing, other_functions, continuing_disruptor)?;
+                    let continuing_uniformity = self.process_block(
+                        continuing,
+                        other_functions,
+                        continuing_disruptor,
+                        expression_arena,
+                    )?;
                     body_uniformity | continuing_uniformity
                 }
                 S::Return { value } => FunctionUniformity {
                     result: Uniformity {
                         non_uniform_result: value.and_then(|expr| self.add_ref(expr)),
                         requirements: UniformityRequirements::empty(),
                     },
                     exit: if disruptor.is_some() {
@@ -675,17 +772,30 @@ impl FunctionInfo {
                     }
                     let info = other_functions.get(function.index()).ok_or(
                         FunctionError::InvalidCall {
                             function,
                             error: CallError::ForwardDeclaredFunction,
                         },
                     )?;
                     //Note: the result is validated by the Validator, not here
-                    self.process_call(info)
+                    self.process_call(info, arguments, expression_arena)?
+                }
+                S::Atomic {
+                    pointer,
+                    ref fun,
+                    value,
+                    result: _,
+                } => {
+                    let _ = self.add_ref_impl(pointer, GlobalUse::WRITE);
+                    let _ = self.add_ref(value);
+                    if let crate::AtomicFunction::Exchange { compare: Some(cmp) } = *fun {
+                        let _ = self.add_ref(cmp);
+                    }
+                    FunctionUniformity::new()
                 }
             };
 
             disruptor = disruptor.or(uniformity.exit_disruptor());
             combined_uniformity = combined_uniformity | uniformity;
         }
         Ok(combined_uniformity)
     }
@@ -703,16 +813,17 @@ impl ModuleInfo {
         let mut info = FunctionInfo {
             flags,
             available_stages: ShaderStages::all(),
             uniformity: Uniformity::new(),
             may_kill: false,
             sampling_set: crate::FastHashSet::default(),
             global_uses: vec![GlobalUse::empty(); module.global_variables.len()].into_boxed_slice(),
             expressions: vec![ExpressionInfo::new(); fun.expressions.len()].into_boxed_slice(),
+            sampling: crate::FastHashSet::default(),
         };
         let resolve_context = ResolveContext {
             constants: &module.constants,
             types: &module.types,
             global_vars: &module.global_variables,
             local_vars: &fun.local_variables,
             functions: &module.functions,
             arguments: &fun.arguments,
@@ -725,98 +836,117 @@ impl ModuleInfo {
                 &fun.expressions,
                 &self.functions,
                 &resolve_context,
             ) {
                 return Err(FunctionError::Expression { handle, error });
             }
         }
 
-        let uniformity = info.process_block(&fun.body, &self.functions, None)?;
+        let uniformity = info.process_block(&fun.body, &self.functions, None, &fun.expressions)?;
         info.uniformity = uniformity.result;
         info.may_kill = uniformity.exit.contains(ExitFlags::MAY_KILL);
 
         Ok(info)
     }
 
     pub fn get_entry_point(&self, index: usize) -> &FunctionInfo {
         &self.entry_points[index]
     }
 }
 
 #[test]
 fn uniform_control_flow() {
     use crate::{Expression as E, Statement as S};
 
     let mut constant_arena = Arena::new();
-    let constant = constant_arena.append(crate::Constant {
-        name: None,
-        specialization: None,
-        inner: crate::ConstantInner::Scalar {
-            width: 4,
-            value: crate::ScalarValue::Uint(0),
+    let constant = constant_arena.append(
+        crate::Constant {
+            name: None,
+            specialization: None,
+            inner: crate::ConstantInner::Scalar {
+                width: 4,
+                value: crate::ScalarValue::Uint(0),
+            },
         },
-    });
+        Default::default(),
+    );
     let mut type_arena = Arena::new();
-    let ty = type_arena.append(crate::Type {
-        name: None,
-        inner: crate::TypeInner::Vector {
-            size: crate::VectorSize::Bi,
-            kind: crate::ScalarKind::Float,
-            width: 4,
+    let ty = type_arena.append(
+        crate::Type {
+            name: None,
+            inner: crate::TypeInner::Vector {
+                size: crate::VectorSize::Bi,
+                kind: crate::ScalarKind::Float,
+                width: 4,
+            },
         },
-    });
+        Default::default(),
+    );
     let mut global_var_arena = Arena::new();
-    let non_uniform_global = global_var_arena.append(crate::GlobalVariable {
-        name: None,
-        init: None,
-        ty,
-        class: crate::StorageClass::Handle,
-        binding: None,
-        storage_access: crate::StorageAccess::STORE,
-    });
-    let uniform_global = global_var_arena.append(crate::GlobalVariable {
-        name: None,
-        init: None,
-        ty,
-        binding: None,
-        class: crate::StorageClass::Uniform,
-        storage_access: crate::StorageAccess::empty(),
-    });
+    let non_uniform_global = global_var_arena.append(
+        crate::GlobalVariable {
+            name: None,
+            init: None,
+            ty,
+            class: crate::StorageClass::Handle,
+            binding: None,
+        },
+        Default::default(),
+    );
+    let uniform_global = global_var_arena.append(
+        crate::GlobalVariable {
+            name: None,
+            init: None,
+            ty,
+            binding: None,
+            class: crate::StorageClass::Uniform,
+        },
+        Default::default(),
+    );
 
     let mut expressions = Arena::new();
     // checks the uniform control flow
-    let constant_expr = expressions.append(E::Constant(constant));
+    let constant_expr = expressions.append(E::Constant(constant), Default::default());
     // checks the non-uniform control flow
-    let derivative_expr = expressions.append(E::Derivative {
-        axis: crate::DerivativeAxis::X,
-        expr: constant_expr,
-    });
+    let derivative_expr = expressions.append(
+        E::Derivative {
+            axis: crate::DerivativeAxis::X,
+            expr: constant_expr,
+        },
+        Default::default(),
+    );
     let emit_range_constant_derivative = expressions.range_from(0);
-    let non_uniform_global_expr = expressions.append(E::GlobalVariable(non_uniform_global));
-    let uniform_global_expr = expressions.append(E::GlobalVariable(uniform_global));
+    let non_uniform_global_expr =
+        expressions.append(E::GlobalVariable(non_uniform_global), Default::default());
+    let uniform_global_expr =
+        expressions.append(E::GlobalVariable(uniform_global), Default::default());
     let emit_range_globals = expressions.range_from(2);
 
     // checks the QUERY flag
-    let query_expr = expressions.append(E::ArrayLength(uniform_global_expr));
+    let query_expr = expressions.append(E::ArrayLength(uniform_global_expr), Default::default());
     // checks the transitive WRITE flag
-    let access_expr = expressions.append(E::AccessIndex {
-        base: non_uniform_global_expr,
-        index: 1,
-    });
+    let access_expr = expressions.append(
+        E::AccessIndex {
+            base: non_uniform_global_expr,
+            index: 1,
+        },
+        Default::default(),
+    );
     let emit_range_query_access_globals = expressions.range_from(2);
 
     let mut info = FunctionInfo {
         flags: ValidationFlags::all(),
         available_stages: ShaderStages::all(),
         uniformity: Uniformity::new(),
         may_kill: false,
         sampling_set: crate::FastHashSet::default(),
         global_uses: vec![GlobalUse::empty(); global_var_arena.len()].into_boxed_slice(),
         expressions: vec![ExpressionInfo::new(); expressions.len()].into_boxed_slice(),
+        sampling: crate::FastHashSet::default(),
     };
     let resolve_context = ResolveContext {
         constants: &constant_arena,
         types: &type_arena,
         global_vars: &global_var_arena,
         local_vars: &Arena::new(),
         functions: &Arena::new(),
         arguments: &[],
@@ -830,52 +960,54 @@ fn uniform_control_flow() {
     assert_eq!(info[query_expr].ref_count, 0);
     assert_eq!(info[access_expr].ref_count, 0);
     assert_eq!(info[non_uniform_global], GlobalUse::empty());
     assert_eq!(info[uniform_global], GlobalUse::QUERY);
 
     let stmt_emit1 = S::Emit(emit_range_globals.clone());
     let stmt_if_uniform = S::If {
         condition: uniform_global_expr,
-        accept: Vec::new(),
+        accept: crate::Block::new(),
         reject: vec![
             S::Emit(emit_range_constant_derivative.clone()),
             S::Store {
                 pointer: constant_expr,
                 value: derivative_expr,
             },
-        ],
+        ]
+        .into(),
     };
     assert_eq!(
-        info.process_block(&[stmt_emit1, stmt_if_uniform], &[], None),
+        info.process_block(&[stmt_emit1, stmt_if_uniform], &[], None, &expressions),
         Ok(FunctionUniformity {
             result: Uniformity {
                 non_uniform_result: None,
                 requirements: UniformityRequirements::DERIVATIVE,
             },
             exit: ExitFlags::empty(),
         }),
     );
     assert_eq!(info[constant_expr].ref_count, 2);
     assert_eq!(info[uniform_global], GlobalUse::READ | GlobalUse::QUERY);
 
     let stmt_emit2 = S::Emit(emit_range_globals.clone());
     let stmt_if_non_uniform = S::If {
         condition: non_uniform_global_expr,
         accept: vec![
-            S::Emit(emit_range_constant_derivative.clone()),
+            S::Emit(emit_range_constant_derivative),
             S::Store {
                 pointer: constant_expr,
                 value: derivative_expr,
             },
-        ],
-        reject: Vec::new(),
+        ]
+        .into(),
+        reject: crate::Block::new(),
     };
     assert_eq!(
-        info.process_block(&[stmt_emit2, stmt_if_non_uniform], &[], None),
+        info.process_block(&[stmt_emit2, stmt_if_non_uniform], &[], None, &expressions),
         Err(FunctionError::NonUniformControlFlow(
             UniformityRequirements::DERIVATIVE,
             derivative_expr,
             UniformityDisruptor::Expression(non_uniform_global_expr)
         )),
     );
     assert_eq!(info[derivative_expr].ref_count, 1);
     assert_eq!(info[non_uniform_global], GlobalUse::READ);
@@ -883,17 +1015,18 @@ fn uniform_control_flow() {
     let stmt_emit3 = S::Emit(emit_range_globals);
     let stmt_return_non_uniform = S::Return {
         value: Some(non_uniform_global_expr),
     };
     assert_eq!(
         info.process_block(
             &[stmt_emit3, stmt_return_non_uniform],
             &[],
-            Some(UniformityDisruptor::Return)
+            Some(UniformityDisruptor::Return),
+            &expressions
         ),
         Ok(FunctionUniformity {
             result: Uniformity {
                 non_uniform_result: Some(non_uniform_global_expr),
                 requirements: UniformityRequirements::empty(),
             },
             exit: ExitFlags::MAY_RETURN,
         }),
@@ -909,17 +1042,18 @@ fn uniform_control_flow() {
     let stmt_return_pointer = S::Return {
         value: Some(access_expr),
     };
     let stmt_kill = S::Kill;
     assert_eq!(
         info.process_block(
             &[stmt_emit4, stmt_assign, stmt_kill, stmt_return_pointer],
             &[],
-            Some(UniformityDisruptor::Discard)
+            Some(UniformityDisruptor::Discard),
+            &expressions
         ),
         Ok(FunctionUniformity {
             result: Uniformity {
                 non_uniform_result: Some(non_uniform_global_expr),
                 requirements: UniformityRequirements::empty(),
             },
             exit: ExitFlags::all(),
         }),