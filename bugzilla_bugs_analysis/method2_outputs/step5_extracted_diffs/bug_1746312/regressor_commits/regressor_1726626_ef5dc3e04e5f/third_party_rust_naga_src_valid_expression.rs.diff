# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/valid/expression.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/valid/expression.rs b/third_party/rust/naga/src/valid/expression.rs
--- a/third_party/rust/naga/src/valid/expression.rs
+++ b/third_party/rust/naga/src/valid/expression.rs
@@ -1,29 +1,29 @@
 use super::{compose::validate_compose, ComposeError, FunctionInfo, ShaderStages, TypeFlags};
 use crate::{
     arena::{Arena, Handle},
-    proc::ResolveError,
+    proc::{ProcError, ResolveError},
 };
 
 #[derive(Clone, Debug, thiserror::Error)]
 #[cfg_attr(test, derive(PartialEq))]
 pub enum ExpressionError {
     #[error("Doesn't exist")]
     DoesntExist,
     #[error("Used by a statement before it was introduced into the scope by any of the dominating blocks")]
     NotInScope,
     #[error("Depends on {0:?}, which has not been processed yet")]
     ForwardDependency(Handle<crate::Expression>),
     #[error("Base type {0:?} is not compatible with this expression")]
     InvalidBaseType(Handle<crate::Expression>),
     #[error("Accessing with index {0:?} can't be done")]
     InvalidIndexType(Handle<crate::Expression>),
-    #[error("Accessing index {1} is out of {0:?} bounds")]
-    IndexOutOfBounds(Handle<crate::Expression>, u32),
+    #[error("Accessing index {1:?} is out of {0:?} bounds")]
+    IndexOutOfBounds(Handle<crate::Expression>, crate::ScalarValue),
     #[error("The expression {0:?} may only be indexed by a constant")]
     IndexMustBeConstant(Handle<crate::Expression>),
     #[error("Function argument {0:?} doesn't exist")]
     FunctionArgumentDoesntExist(u32),
     #[error("Constant {0:?} doesn't exist")]
     ConstantDoesntExist(Handle<crate::Constant>),
     #[error("Global variable {0:?} doesn't exist")]
     GlobalVarDoesntExist(Handle<crate::GlobalVariable>),
@@ -36,16 +36,18 @@ pub enum ExpressionError {
     #[error("Splatting {0:?} can't be done")]
     InvalidSplatType(Handle<crate::Expression>),
     #[error("Swizzling {0:?} can't be done")]
     InvalidVectorType(Handle<crate::Expression>),
     #[error("Swizzle component {0:?} is outside of vector size {1:?}")]
     InvalidSwizzleComponent(crate::SwizzleComponent, crate::VectorSize),
     #[error(transparent)]
     Compose(#[from] ComposeError),
+    #[error(transparent)]
+    Proc(#[from] ProcError),
     #[error("Operation {0:?} can't work with {1:?}")]
     InvalidUnaryOperandType(crate::UnaryOperator, Handle<crate::Expression>),
     #[error("Operation {0:?} can't work with {1:?} and {2:?}")]
     InvalidBinaryOperandTypes(
         crate::BinaryOperator,
         Handle<crate::Expression>,
         Handle<crate::Expression>,
     ),
@@ -54,16 +56,18 @@ pub enum ExpressionError {
     #[error("Relational argument {0:?} is not a boolean vector")]
     InvalidBooleanVector(Handle<crate::Expression>),
     #[error("Relational argument {0:?} is not a float")]
     InvalidFloatArgument(Handle<crate::Expression>),
     #[error("Type resolution failed")]
     Type(#[from] ResolveError),
     #[error("Not a global variable")]
     ExpectedGlobalVariable,
+    #[error("Not a global variable or a function argument")]
+    ExpectedGlobalOrArgument,
     #[error("Calling an undeclared function {0:?}")]
     CallToUndeclaredFunction(Handle<crate::Function>),
     #[error("Needs to be an image instead of {0:?}")]
     ExpectedImageType(Handle<crate::Type>),
     #[error("Needs to be an image instead of {0:?}")]
     ExpectedSamplerType(Handle<crate::Type>),
     #[error("Unable to operate on image class {0:?}")]
     InvalidImageClass(crate::ImageClass),
@@ -84,30 +88,32 @@ pub enum ExpressionError {
         image: crate::ImageClass,
         sampler: bool,
         has_ref: bool,
     },
     #[error("Sample offset constant {1:?} doesn't match the image dimension {0:?}")]
     InvalidSampleOffset(crate::ImageDimension, Handle<crate::Constant>),
     #[error("Depth reference {0:?} is not a scalar float")]
     InvalidDepthReference(Handle<crate::Expression>),
-    #[error("Sample level is not compatible with the image dimension {0:?}")]
-    InvalidSampleLevel(crate::ImageDimension),
+    #[error("Depth sample level can only be Auto or Zero")]
+    InvalidDepthSampleLevel,
     #[error("Sample level (exact) type {0:?} is not a scalar float")]
     InvalidSampleLevelExactType(Handle<crate::Expression>),
     #[error("Sample level (bias) type {0:?} is not a scalar float")]
     InvalidSampleLevelBiasType(Handle<crate::Expression>),
     #[error("Sample level (gradient) of {1:?} doesn't match the image dimension {0:?}")]
     InvalidSampleLevelGradientType(crate::ImageDimension, Handle<crate::Expression>),
     #[error("Unable to cast")]
     InvalidCastArgument,
     #[error("Invalid argument count for {0:?}")]
     WrongArgumentCount(crate::MathFunction),
     #[error("Argument [{1}] to {0:?} as expression {2:?} has an invalid type.")]
     InvalidArgumentType(crate::MathFunction, u32, Handle<crate::Expression>),
+    #[error("Atomic result type can't be {0:?} of {1} bytes")]
+    InvalidAtomicResultType(crate::ScalarKind, crate::Bytes),
 }
 
 struct ExpressionTypeResolver<'a> {
     root: Handle<crate::Expression>,
     types: &'a Arena<crate::Type>,
     info: &'a FunctionInfo,
 }
 
@@ -139,18 +145,19 @@ impl super::Validator {
         let resolver = ExpressionTypeResolver {
             root,
             types: &module.types,
             info,
         };
 
         let stages = match *expression {
             E::Access { base, index } => {
+                let base_type = resolver.resolve(base)?;
                 // See the documentation for `Expression::Access`.
-                let dynamic_indexing_restricted = match *resolver.resolve(base)? {
+                let dynamic_indexing_restricted = match *base_type {
                     Ti::Vector { .. } => false,
                     Ti::Matrix { .. } | Ti::Array { .. } => true,
                     Ti::Pointer { .. } | Ti::ValuePointer { size: Some(_), .. } => false,
                     ref other => {
                         log::error!("Indexing of {:?}", other);
                         return Err(ExpressionError::InvalidBaseType(base));
                     }
                 };
@@ -169,16 +176,46 @@ impl super::Validator {
                         return Err(ExpressionError::InvalidIndexType(index));
                     }
                 }
                 if dynamic_indexing_restricted
                     && function.expressions[index].is_dynamic_index(module)
                 {
                     return Err(ExpressionError::IndexMustBeConstant(base));
                 }
+
+                // If we know both the length and the index, we can do the
+                // bounds check now.
+                if let crate::proc::IndexableLength::Known(known_length) =
+                    base_type.indexable_length(module)?
+                {
+                    if let E::Constant(k) = function.expressions[index] {
+                        if let crate::Constant {
+                            // We must treat specializable constants as unknown.
+                            specialization: None,
+                            // Non-scalar indices should have been caught above.
+                            inner: crate::ConstantInner::Scalar { value, .. },
+                            ..
+                        } = module.constants[k]
+                        {
+                            match value {
+                                crate::ScalarValue::Uint(u) if u >= known_length as u64 => {
+                                    return Err(ExpressionError::IndexOutOfBounds(base, value));
+                                }
+                                crate::ScalarValue::Sint(s)
+                                    if s < 0 || s >= known_length as i64 =>
+                                {
+                                    return Err(ExpressionError::IndexOutOfBounds(base, value));
+                                }
+                                _ => (),
+                            }
+                        }
+                    }
+                }
+
                 ShaderStages::all()
             }
             E::AccessIndex { base, index } => {
                 fn resolve_index_limit(
                     module: &crate::Module,
                     top: Handle<crate::Expression>,
                     ty: &crate::TypeInner,
                     top_level: bool,
@@ -203,17 +240,20 @@ impl super::Validator {
                             return Err(ExpressionError::InvalidBaseType(top));
                         }
                     };
                     Ok(limit)
                 }
 
                 let limit = resolve_index_limit(module, base, resolver.resolve(base)?, true)?;
                 if index >= limit {
-                    return Err(ExpressionError::IndexOutOfBounds(base, index));
+                    return Err(ExpressionError::IndexOutOfBounds(
+                        base,
+                        crate::ScalarValue::Uint(limit as _),
+                    ));
                 }
                 ShaderStages::all()
             }
             E::Constant(handle) => {
                 let _ = module
                     .constants
                     .try_get(handle)
                     .ok_or(ExpressionError::ConstantDoesntExist(handle))?;
@@ -298,34 +338,36 @@ impl super::Validator {
                 sampler,
                 coordinate,
                 array_index,
                 offset,
                 level,
                 depth_ref,
             } => {
                 // check the validity of expressions
-                let image_var = match function.expressions[image] {
+                let image_ty = match function.expressions[image] {
                     crate::Expression::GlobalVariable(var_handle) => {
-                        &module.global_variables[var_handle]
+                        module.global_variables[var_handle].ty
                     }
+                    crate::Expression::FunctionArgument(i) => function.arguments[i as usize].ty,
                     _ => return Err(ExpressionError::ExpectedGlobalVariable),
                 };
-                let sampler_var = match function.expressions[sampler] {
+                let sampler_ty = match function.expressions[sampler] {
                     crate::Expression::GlobalVariable(var_handle) => {
-                        &module.global_variables[var_handle]
+                        module.global_variables[var_handle].ty
                     }
+                    crate::Expression::FunctionArgument(i) => function.arguments[i as usize].ty,
                     _ => return Err(ExpressionError::ExpectedGlobalVariable),
                 };
-                let comparison = match module.types[sampler_var.ty].inner {
+                let comparison = match module.types[sampler_ty].inner {
                     Ti::Sampler { comparison } => comparison,
-                    _ => return Err(ExpressionError::ExpectedSamplerType(sampler_var.ty)),
+                    _ => return Err(ExpressionError::ExpectedSamplerType(sampler_ty)),
                 };
 
-                let (class, dim) = match module.types[image_var.ty].inner {
+                let (class, dim) = match module.types[image_ty].inner {
                     Ti::Image {
                         class,
                         arrayed,
                         dim,
                     } => {
                         // check the array property
                         if arrayed != array_index.is_some() {
                             return Err(ExpressionError::InvalidImageArrayIndex);
@@ -336,26 +378,26 @@ impl super::Validator {
                                     kind: Sk::Sint,
                                     width: _,
                                 } => {}
                                 _ => return Err(ExpressionError::InvalidImageArrayIndexType(expr)),
                             }
                         }
                         (class, dim)
                     }
-                    _ => return Err(ExpressionError::ExpectedImageType(image_var.ty)),
+                    _ => return Err(ExpressionError::ExpectedImageType(image_ty)),
                 };
 
                 // check sampling and comparison properties
                 let image_depth = match class {
                     crate::ImageClass::Sampled {
                         kind: crate::ScalarKind::Float,
                         multi: false,
                     } => false,
-                    crate::ImageClass::Depth => true,
+                    crate::ImageClass::Depth { multi: false } => true,
                     _ => return Err(ExpressionError::InvalidImageClass(class)),
                 };
                 if comparison != depth_ref.is_some() || (comparison && !image_depth) {
                     return Err(ExpressionError::ComparisonSamplingMismatch {
                         image: class,
                         sampler: comparison,
                         has_ref: depth_ref.is_some(),
                     });
@@ -406,29 +448,27 @@ impl super::Validator {
                 // check depth reference type
                 if let Some(expr) = depth_ref {
                     match *resolver.resolve(expr)? {
                         Ti::Scalar {
                             kind: Sk::Float, ..
                         } => {}
                         _ => return Err(ExpressionError::InvalidDepthReference(expr)),
                     }
+                    match level {
+                        crate::SampleLevel::Auto | crate::SampleLevel::Zero => {}
+                        _ => return Err(ExpressionError::InvalidDepthSampleLevel),
+                    }
                 }
 
                 // check level properties
-                let can_level = match class {
-                    crate::ImageClass::Sampled { multi, .. } => !multi,
-                    crate::ImageClass::Storage { .. } => unreachable!(),
-                    crate::ImageClass::Depth { .. } => true,
-                };
                 match level {
-                    // require `can_level` here?
                     crate::SampleLevel::Auto => ShaderStages::FRAGMENT,
                     crate::SampleLevel::Zero => ShaderStages::all(),
-                    crate::SampleLevel::Exact(expr) if can_level => {
+                    crate::SampleLevel::Exact(expr) => {
                         match *resolver.resolve(expr)? {
                             Ti::Scalar {
                                 kind: Sk::Float, ..
                             } => {}
                             _ => return Err(ExpressionError::InvalidSampleLevelExactType(expr)),
                         }
                         ShaderStages::all()
                     }
@@ -465,32 +505,32 @@ impl super::Validator {
                                 ..
                             } if size as u32 == num_components => {}
                             _ => {
                                 return Err(ExpressionError::InvalidSampleLevelGradientType(dim, y))
                             }
                         }
                         ShaderStages::all()
                     }
-                    _ => return Err(ExpressionError::InvalidSampleLevel(dim)),
                 }
             }
             E::ImageLoad {
                 image,
                 coordinate,
                 array_index,
                 index,
             } => {
-                let var = match function.expressions[image] {
+                let ty = match function.expressions[image] {
                     crate::Expression::GlobalVariable(var_handle) => {
-                        &module.global_variables[var_handle]
+                        module.global_variables[var_handle].ty
                     }
+                    crate::Expression::FunctionArgument(i) => function.arguments[i as usize].ty,
                     _ => return Err(ExpressionError::ExpectedGlobalVariable),
                 };
-                match module.types[var.ty].inner {
+                match module.types[ty].inner {
                     Ti::Image {
                         class,
                         arrayed,
                         dim,
                     } => {
                         match resolver.resolve(coordinate)?.image_storage_coordinates() {
                             Some(coord_dim) if coord_dim == dim => {}
                             _ => {
@@ -523,46 +563,48 @@ impl super::Validator {
                                 Ti::Scalar {
                                     kind: Sk::Sint,
                                     width: _,
                                 } => {}
                                 _ => return Err(ExpressionError::InvalidImageOtherIndexType(expr)),
                             }
                         }
                     }
-                    _ => return Err(ExpressionError::ExpectedImageType(var.ty)),
+                    _ => return Err(ExpressionError::ExpectedImageType(ty)),
                 }
                 ShaderStages::all()
             }
             E::ImageQuery { image, query } => {
-                let var = match function.expressions[image] {
+                let ty = match function.expressions[image] {
                     crate::Expression::GlobalVariable(var_handle) => {
-                        &module.global_variables[var_handle]
+                        module.global_variables[var_handle].ty
                     }
+                    crate::Expression::FunctionArgument(i) => function.arguments[i as usize].ty,
                     _ => return Err(ExpressionError::ExpectedGlobalVariable),
                 };
-                match module.types[var.ty].inner {
+                match module.types[ty].inner {
                     Ti::Image { class, arrayed, .. } => {
                         let can_level = match class {
                             crate::ImageClass::Sampled { multi, .. } => !multi,
+                            crate::ImageClass::Depth { multi } => !multi,
                             crate::ImageClass::Storage { .. } => false,
-                            crate::ImageClass::Depth { .. } => true,
                         };
                         let good = match query {
                             crate::ImageQuery::NumLayers => arrayed,
                             crate::ImageQuery::Size { level: None } => true,
                             crate::ImageQuery::Size { level: Some(_) }
                             | crate::ImageQuery::NumLevels => can_level,
+                            //TODO: forbid on storage images
                             crate::ImageQuery::NumSamples => !can_level,
                         };
                         if !good {
                             return Err(ExpressionError::InvalidImageClass(class));
                         }
                     }
-                    _ => return Err(ExpressionError::ExpectedImageType(var.ty)),
+                    _ => return Err(ExpressionError::ExpectedImageType(ty)),
                 }
                 ShaderStages::all()
             }
             E::Unary { op, expr } => {
                 use crate::UnaryOperator as Uo;
                 let inner = resolver.resolve(expr)?;
                 match (op, inner.scalar_kind()) {
                     (_, Some(Sk::Sint))
@@ -884,16 +926,19 @@ impl super::Validator {
                     | Mf::Cosh
                     | Mf::Sin
                     | Mf::Sinh
                     | Mf::Tan
                     | Mf::Tanh
                     | Mf::Acos
                     | Mf::Asin
                     | Mf::Atan
+                    | Mf::Asinh
+                    | Mf::Acosh
+                    | Mf::Atanh
                     | Mf::Ceil
                     | Mf::Floor
                     | Mf::Round
                     | Mf::Fract
                     | Mf::Trunc
                     | Mf::Exp
                     | Mf::Exp2
                     | Mf::Log
@@ -1038,17 +1083,17 @@ impl super::Validator {
                         }
                         match *arg_ty {
                             Ti::Vector {
                                 kind: Sk::Float, ..
                             } => {}
                             _ => return Err(ExpressionError::InvalidArgumentType(fun, 0, arg)),
                         }
                     }
-                    Mf::FaceForward | Mf::Fma | Mf::Mix | Mf::SmoothStep => {
+                    Mf::FaceForward | Mf::Fma | Mf::SmoothStep => {
                         let (arg1_ty, arg2_ty) = match (arg1_ty, arg2_ty) {
                             (Some(ty1), Some(ty2)) => (ty1, ty2),
                             _ => return Err(ExpressionError::WrongArgumentCount(fun)),
                         };
                         match *arg_ty {
                             Ti::Scalar {
                                 kind: Sk::Float, ..
                             }
@@ -1067,16 +1112,56 @@ impl super::Validator {
                         if arg2_ty != arg_ty {
                             return Err(ExpressionError::InvalidArgumentType(
                                 fun,
                                 2,
                                 arg2.unwrap(),
                             ));
                         }
                     }
+                    Mf::Mix => {
+                        let (arg1_ty, arg2_ty) = match (arg1_ty, arg2_ty) {
+                            (Some(ty1), Some(ty2)) => (ty1, ty2),
+                            _ => return Err(ExpressionError::WrongArgumentCount(fun)),
+                        };
+                        let arg_width = match *arg_ty {
+                            Ti::Scalar {
+                                kind: Sk::Float,
+                                width,
+                            }
+                            | Ti::Vector {
+                                kind: Sk::Float,
+                                width,
+                                ..
+                            } => width,
+                            _ => return Err(ExpressionError::InvalidArgumentType(fun, 0, arg)),
+                        };
+                        if arg1_ty != arg_ty {
+                            return Err(ExpressionError::InvalidArgumentType(
+                                fun,
+                                1,
+                                arg1.unwrap(),
+                            ));
+                        }
+                        // the last argument can always be a scalar
+                        match *arg2_ty {
+                            Ti::Scalar {
+                                kind: Sk::Float,
+                                width,
+                            } if width == arg_width => {}
+                            _ if arg2_ty == arg_ty => {}
+                            _ => {
+                                return Err(ExpressionError::InvalidArgumentType(
+                                    fun,
+                                    2,
+                                    arg2.unwrap(),
+                                ));
+                            }
+                        }
+                    }
                     Mf::Inverse | Mf::Determinant => {
                         if arg1_ty.is_some() | arg2_ty.is_some() {
                             return Err(ExpressionError::WrongArgumentCount(fun));
                         }
                         let good = match *arg_ty {
                             Ti::Matrix { columns, rows, .. } => columns == rows,
                             _ => false,
                         };
@@ -1103,37 +1188,42 @@ impl super::Validator {
                             | Ti::Vector { kind: Sk::Sint, .. }
                             | Ti::Vector { kind: Sk::Uint, .. } => {}
                             _ => return Err(ExpressionError::InvalidArgumentType(fun, 0, arg)),
                         }
                     }
                 }
                 ShaderStages::all()
             }
-            E::As {
-                expr,
-                kind,
-                convert,
-            } => {
-                let prev_kind = resolver
-                    .resolve(expr)?
-                    .scalar_kind()
-                    .ok_or(ExpressionError::InvalidCastArgument)?;
+            E::As { kind, convert, .. } => {
                 match convert {
                     Some(width) if !self.check_width(kind, width) => {
                         return Err(ExpressionError::InvalidCastArgument)
                     }
-                    None if prev_kind == Sk::Bool || kind == Sk::Bool => {
-                        return Err(ExpressionError::InvalidCastArgument)
-                    }
                     _ => {}
                 }
                 ShaderStages::all()
             }
-            E::Call(function) => other_infos[function.index()].available_stages,
+            E::CallResult(function) => other_infos[function.index()].available_stages,
+            E::AtomicResult {
+                kind,
+                width,
+                comparison: _,
+            } => {
+                let good = match kind {
+                    crate::ScalarKind::Uint | crate::ScalarKind::Sint => {
+                        self.check_width(kind, width)
+                    }
+                    _ => false,
+                };
+                if !good {
+                    return Err(ExpressionError::InvalidAtomicResultType(kind, width));
+                }
+                ShaderStages::all()
+            }
             E::ArrayLength(expr) => match *resolver.resolve(expr)? {
                 Ti::Pointer { base, .. } => {
                     if let Some(&Ti::Array {
                         size: crate::ArraySize::Dynamic,
                         ..
                     }) = resolver.types.try_get(base).map(|ty| &ty.inner)
                     {
                         ShaderStages::all()