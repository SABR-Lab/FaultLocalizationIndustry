# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/valid/function.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/valid/function.rs b/third_party/rust/naga/src/valid/function.rs
--- a/third_party/rust/naga/src/valid/function.rs
+++ b/third_party/rust/naga/src/valid/function.rs
@@ -31,17 +31,32 @@ pub enum CallError {
         seen_expression: Handle<crate::Expression>,
     },
     #[error("The emitted expression doesn't match the call")]
     ExpressionMismatch(Option<Handle<crate::Expression>>),
 }
 
 #[derive(Clone, Debug, thiserror::Error)]
 #[cfg_attr(test, derive(PartialEq))]
+pub enum AtomicError {
+    #[error("Pointer {0:?} to atomic is invalid.")]
+    InvalidPointer(Handle<crate::Expression>),
+    #[error("Operand {0:?} has invalid type.")]
+    InvalidOperand(Handle<crate::Expression>),
+    #[error("Result expression {0:?} has already been introduced earlier")]
+    ResultAlreadyInScope(Handle<crate::Expression>),
+    #[error("Result type for {0:?} doesn't match the statement")]
+    ResultTypeMismatch(Handle<crate::Expression>),
+}
+
+#[derive(Clone, Debug, thiserror::Error)]
+#[cfg_attr(test, derive(PartialEq))]
 pub enum LocalVariableError {
+    #[error("Local variable has a type {0:?} that can't be stored in a local variable.")]
+    InvalidType(Handle<crate::Type>),
     #[error("Initializer doesn't match the variable type")]
     InitializerType,
 }
 
 #[derive(Clone, Debug, thiserror::Error)]
 #[cfg_attr(test, derive(PartialEq))]
 pub enum FunctionError {
     #[error("Expression {handle:?} is invalid")]
@@ -58,18 +73,20 @@ pub enum FunctionError {
         name: String,
         #[source]
         error: LocalVariableError,
     },
     #[error("Argument '{name}' at index {index} has a type that can't be passed into functions.")]
     InvalidArgumentType { index: usize, name: String },
     #[error("There are instructions after `return`/`break`/`continue`")]
     InstructionsAfterReturn,
-    #[error("The `break`/`continue` is used outside of a loop context")]
-    BreakContinueOutsideOfLoop,
+    #[error("The `break` is used outside of a `loop` or `switch` context")]
+    BreakOutsideOfLoopOrSwitch,
+    #[error("The `continue` is used outside of a `loop` context")]
+    ContinueOutsideOfLoop,
     #[error("The `return` is called within a `continuing` block")]
     InvalidReturnSpot,
     #[error("The `return` value {0:?} does not match the function return value")]
     InvalidReturnType(Option<Handle<crate::Expression>>),
     #[error("The `if` condition {0:?} is not a boolean scalar")]
     InvalidIfType(Handle<crate::Expression>),
     #[error("The `switch` value {0:?} is not an integer scalar")]
     InvalidSwitchType(Handle<crate::Expression>),
@@ -89,38 +106,42 @@ pub enum FunctionError {
     #[error("Image store parameters are invalid")]
     InvalidImageStore(#[source] ExpressionError),
     #[error("Call to {function:?} is invalid")]
     InvalidCall {
         function: Handle<crate::Function>,
         #[source]
         error: CallError,
     },
+    #[error("Atomic operation is invalid")]
+    InvalidAtomic(#[from] AtomicError),
     #[error(
         "Required uniformity of control flow for {0:?} in {1:?} is not fulfilled because of {2:?}"
     )]
     NonUniformControlFlow(
         UniformityRequirements,
         Handle<crate::Expression>,
         UniformityDisruptor,
     ),
 }
 
 bitflags::bitflags! {
     #[repr(transparent)]
-    struct Flags: u8 {
-        /// The control can jump out of this block.
-        const CAN_JUMP = 0x1;
-        /// The control is in a loop, can break and continue.
-        const IN_LOOP = 0x2;
+    struct ControlFlowAbility: u8 {
+        /// The control can return out of this block.
+        const RETURN = 0x1;
+        /// The control can break.
+        const BREAK = 0x2;
+        /// The control can continue.
+        const CONTINUE = 0x4;
     }
 }
 
 struct BlockContext<'a> {
-    flags: Flags,
+    abilities: ControlFlowAbility,
     info: &'a FunctionInfo,
     expressions: &'a Arena<crate::Expression>,
     types: &'a Arena<crate::Type>,
     global_vars: &'a Arena<crate::GlobalVariable>,
     functions: &'a Arena<crate::Function>,
     prev_infos: &'a [FunctionInfo],
     return_type: Option<Handle<crate::Type>>,
 }
@@ -128,38 +149,29 @@ struct BlockContext<'a> {
 impl<'a> BlockContext<'a> {
     fn new(
         fun: &'a crate::Function,
         module: &'a crate::Module,
         info: &'a FunctionInfo,
         prev_infos: &'a [FunctionInfo],
     ) -> Self {
         Self {
-            flags: Flags::CAN_JUMP,
+            abilities: ControlFlowAbility::RETURN,
             info,
             expressions: &fun.expressions,
             types: &module.types,
             global_vars: &module.global_variables,
             functions: &module.functions,
             prev_infos,
             return_type: fun.result.as_ref().map(|fr| fr.ty),
         }
     }
 
-    fn with_flags(&self, flags: Flags) -> Self {
-        BlockContext {
-            flags,
-            info: self.info,
-            expressions: self.expressions,
-            types: self.types,
-            global_vars: self.global_vars,
-            functions: self.functions,
-            prev_infos: self.prev_infos,
-            return_type: self.return_type,
-        }
+    fn with_abilities(&self, abilities: ControlFlowAbility) -> Self {
+        BlockContext { abilities, ..*self }
     }
 
     fn get_expression(
         &self,
         handle: Handle<crate::Expression>,
     ) -> Result<&'a crate::Expression, FunctionError> {
         self.expressions
             .try_get(handle)
@@ -237,27 +249,84 @@ impl super::Validator {
 
         if let Some(expr) = result {
             if self.valid_expression_set.insert(expr.index()) {
                 self.valid_expression_list.push(expr);
             } else {
                 return Err(CallError::ResultAlreadyInScope(expr));
             }
             match context.expressions[expr] {
-                crate::Expression::Call(callee) if fun.result.is_some() && callee == function => {}
+                crate::Expression::CallResult(callee)
+                    if fun.result.is_some() && callee == function => {}
                 _ => return Err(CallError::ExpressionMismatch(result)),
             }
         } else if fun.result.is_some() {
             return Err(CallError::ExpressionMismatch(result));
         }
 
         let callee_info = &context.prev_infos[function.index()];
         Ok(callee_info.available_stages)
     }
 
+    fn validate_atomic(
+        &mut self,
+        pointer: Handle<crate::Expression>,
+        fun: &crate::AtomicFunction,
+        value: Handle<crate::Expression>,
+        result: Handle<crate::Expression>,
+        context: &BlockContext,
+    ) -> Result<(), FunctionError> {
+        let pointer_inner = context.resolve_type(pointer, &self.valid_expression_set)?;
+        let (ptr_kind, ptr_width) = match *pointer_inner {
+            crate::TypeInner::Pointer { base, .. } => match context.types[base].inner {
+                crate::TypeInner::Atomic { kind, width } => (kind, width),
+                ref other => {
+                    log::error!("Atomic pointer to type {:?}", other);
+                    return Err(AtomicError::InvalidPointer(pointer).into());
+                }
+            },
+            ref other => {
+                log::error!("Atomic on type {:?}", other);
+                return Err(AtomicError::InvalidPointer(pointer).into());
+            }
+        };
+
+        let value_inner = context.resolve_type(value, &self.valid_expression_set)?;
+        match *value_inner {
+            crate::TypeInner::Scalar { width, kind } if kind == ptr_kind && width == ptr_width => {}
+            ref other => {
+                log::error!("Atomic operand type {:?}", other);
+                return Err(AtomicError::InvalidOperand(value).into());
+            }
+        }
+
+        if let crate::AtomicFunction::Exchange { compare: Some(cmp) } = *fun {
+            if context.resolve_type(cmp, &self.valid_expression_set)? != value_inner {
+                log::error!("Atomic exchange comparison has a different type from the value");
+                return Err(AtomicError::InvalidOperand(cmp).into());
+            }
+        }
+
+        if self.valid_expression_set.insert(result.index()) {
+            self.valid_expression_list.push(result);
+        } else {
+            return Err(AtomicError::ResultAlreadyInScope(result).into());
+        }
+        match context.expressions[result] {
+            //TODO: support atomic result with comparison
+            crate::Expression::AtomicResult {
+                kind,
+                width,
+                comparison: false,
+            } if kind == ptr_kind && width == ptr_width => {}
+            _ => return Err(AtomicError::ResultTypeMismatch(result).into()),
+        }
+        Ok(())
+    }
+
     fn validate_block_impl(
         &mut self,
         statements: &[crate::Statement],
         context: &BlockContext,
     ) -> Result<ShaderStages, FunctionError> {
         use crate::{Statement as S, TypeInner as Ti};
         let mut finished = false;
         let mut stages = ShaderStages::all();
@@ -306,46 +375,63 @@ impl super::Validator {
                         _ => return Err(FunctionError::InvalidSwitchType(selector)),
                     }
                     self.select_cases.clear();
                     for case in cases {
                         if !self.select_cases.insert(case.value) {
                             return Err(FunctionError::ConflictingSwitchCase(case.value));
                         }
                     }
+                    let pass_through_abilities = context.abilities
+                        & (ControlFlowAbility::RETURN | ControlFlowAbility::CONTINUE);
+                    let sub_context =
+                        context.with_abilities(pass_through_abilities | ControlFlowAbility::BREAK);
                     for case in cases {
-                        stages &= self.validate_block(&case.body, context)?;
+                        stages &= self.validate_block(&case.body, &sub_context)?;
                     }
-                    stages &= self.validate_block(default, context)?;
+                    stages &= self.validate_block(default, &sub_context)?;
                 }
                 S::Loop {
                     ref body,
                     ref continuing,
                 } => {
                     // special handling for block scoping is needed here,
                     // because the continuing{} block inherits the scope
                     let base_expression_count = self.valid_expression_list.len();
+                    let pass_through_abilities = context.abilities & ControlFlowAbility::RETURN;
                     stages &= self.validate_block_impl(
                         body,
-                        &context.with_flags(Flags::CAN_JUMP | Flags::IN_LOOP),
+                        &context.with_abilities(
+                            pass_through_abilities
+                                | ControlFlowAbility::BREAK
+                                | ControlFlowAbility::CONTINUE,
+                        ),
                     )?;
-                    stages &=
-                        self.validate_block_impl(continuing, &context.with_flags(Flags::empty()))?;
+                    stages &= self.validate_block_impl(
+                        continuing,
+                        &context.with_abilities(ControlFlowAbility::empty()),
+                    )?;
                     for handle in self.valid_expression_list.drain(base_expression_count..) {
                         self.valid_expression_set.remove(handle.index());
                     }
                 }
-                S::Break | S::Continue => {
-                    if !context.flags.contains(Flags::IN_LOOP) {
-                        return Err(FunctionError::BreakContinueOutsideOfLoop);
+                S::Break => {
+                    if !context.abilities.contains(ControlFlowAbility::BREAK) {
+                        return Err(FunctionError::BreakOutsideOfLoopOrSwitch);
+                    }
+                    finished = true;
+                }
+                S::Continue => {
+                    if !context.abilities.contains(ControlFlowAbility::CONTINUE) {
+                        return Err(FunctionError::ContinueOutsideOfLoop);
                     }
                     finished = true;
                 }
                 S::Return { value } => {
-                    if !context.flags.contains(Flags::CAN_JUMP) {
+                    if !context.abilities.contains(ControlFlowAbility::RETURN) {
                         return Err(FunctionError::InvalidReturnSpot);
                     }
                     let value_ty = value
                         .map(|expr| context.resolve_type(expr, &self.valid_expression_set))
                         .transpose()?;
                     let expected_ty = context.return_type.map(|ty| &context.types[ty].inner);
                     if value_ty != expected_ty {
                         log::error!(
@@ -380,17 +466,20 @@ impl super::Validator {
                     let value_ty = context.resolve_type(value, &self.valid_expression_set)?;
                     match *value_ty {
                         Ti::Image { .. } | Ti::Sampler { .. } => {
                             return Err(FunctionError::InvalidStoreValue(value));
                         }
                         _ => {}
                     }
                     let good = match *context.resolve_pointer_type(pointer)? {
-                        Ti::Pointer { base, class: _ } => *value_ty == context.types[base].inner,
+                        Ti::Pointer { base, class: _ } => match context.types[base].inner {
+                            Ti::Atomic { kind, width } => *value_ty == Ti::Scalar { kind, width },
+                            ref other => value_ty == other,
+                        },
                         Ti::ValuePointer {
                             size: Some(size),
                             kind,
                             width,
                             class: _,
                         } => *value_ty == Ti::Vector { size, kind, width },
                         Ti::ValuePointer {
                             size: None,
@@ -456,21 +545,23 @@ impl super::Validator {
                                     _ => {
                                         return Err(FunctionError::InvalidImageStore(
                                             ExpressionError::InvalidImageArrayIndexType(expr),
                                         ))
                                     }
                                 }
                             }
                             match class {
-                                crate::ImageClass::Storage(format) => crate::TypeInner::Vector {
-                                    kind: format.into(),
-                                    size: crate::VectorSize::Quad,
-                                    width: 4,
-                                },
+                                crate::ImageClass::Storage { format, .. } => {
+                                    crate::TypeInner::Vector {
+                                        kind: format.into(),
+                                        size: crate::VectorSize::Quad,
+                                        width: 4,
+                                    }
+                                }
                                 _ => {
                                     return Err(FunctionError::InvalidImageStore(
                                         ExpressionError::InvalidImageClass(class),
                                     ))
                                 }
                             }
                         }
                         _ => {
@@ -487,16 +578,24 @@ impl super::Validator {
                 S::Call {
                     function,
                     ref arguments,
                     result,
                 } => match self.validate_call(function, arguments, result, context) {
                     Ok(callee_stages) => stages &= callee_stages,
                     Err(error) => return Err(FunctionError::InvalidCall { function, error }),
                 },
+                S::Atomic {
+                    pointer,
+                    ref fun,
+                    value,
+                    result,
+                } => {
+                    self.validate_atomic(pointer, fun, value, result, context)?;
+                }
             }
         }
         Ok(stages)
     }
 
     fn validate_block(
         &mut self,
         statements: &[crate::Statement],
@@ -512,16 +611,22 @@ impl super::Validator {
 
     fn validate_local_var(
         &self,
         var: &crate::LocalVariable,
         types: &Arena<crate::Type>,
         constants: &Arena<crate::Constant>,
     ) -> Result<(), LocalVariableError> {
         log::debug!("var {:?}", var);
+        if !self.types[var.ty.index()]
+            .flags
+            .contains(TypeFlags::DATA | TypeFlags::SIZED)
+        {
+            return Err(LocalVariableError::InvalidType(var.ty));
+        }
         if let Some(const_handle) = var.init {
             match constants[const_handle].inner {
                 crate::ConstantInner::Scalar { width, ref value } => {
                     let ty_inner = crate::TypeInner::Scalar {
                         width,
                         kind: value.scalar_kind(),
                     };
                     if types[var.ty].inner != ty_inner {
@@ -553,26 +658,27 @@ impl super::Validator {
                     name: var.name.clone().unwrap_or_default(),
                     error,
                 })?;
         }
 
         for (index, argument) in fun.arguments.iter().enumerate() {
             if !self.types[argument.ty.index()]
                 .flags
-                .contains(TypeFlags::DATA | TypeFlags::SIZED)
+                .contains(TypeFlags::ARGUMENT)
             {
                 return Err(FunctionError::InvalidArgumentType {
                     index,
                     name: argument.name.clone().unwrap_or_default(),
                 });
             }
         }
 
         self.valid_expression_set.clear();
+        self.valid_expression_list.clear();
         for (handle, expr) in fun.expressions.iter() {
             if expr.needs_pre_emit() {
                 self.valid_expression_set.insert(handle.index());
             }
             if self.flags.contains(ValidationFlags::EXPRESSIONS) {
                 match self.validate_expression(
                     handle,
                     expr,