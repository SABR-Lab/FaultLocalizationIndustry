# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/valid/interface.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/valid/interface.rs b/third_party/rust/naga/src/valid/interface.rs
--- a/third_party/rust/naga/src/valid/interface.rs
+++ b/third_party/rust/naga/src/valid/interface.rs
@@ -10,21 +10,16 @@ use bit_set::BitSet;
 const MAX_WORKGROUP_SIZE: u32 = 0x4000;
 
 #[derive(Clone, Debug, thiserror::Error)]
 pub enum GlobalVariableError {
     #[error("Usage isn't compatible with the storage class")]
     InvalidUsage,
     #[error("Type isn't compatible with the storage class")]
     InvalidType,
-    #[error("Storage access {seen:?} exceeds the allowed {allowed:?}")]
-    InvalidStorageAccess {
-        allowed: crate::StorageAccess,
-        seen: crate::StorageAccess,
-    },
     #[error("Type flags {seen:?} do not meet the required {required:?}")]
     MissingTypeFlags {
         required: TypeFlags,
         seen: TypeFlags,
     },
     #[error("Capability {0:?} is not supported")]
     UnsupportedCapability(Capabilities),
     #[error("Binding decoration is missing or not applicable")]
@@ -48,16 +43,18 @@ pub enum VaryingError {
     #[error("Entry point arguments and return values must all have bindings")]
     MissingBinding,
     #[error("Struct member {0} is missing a binding")]
     MemberMissingBinding(u32),
     #[error("Multiple bindings at location {location} are present")]
     BindingCollision { location: u32 },
     #[error("Built-in {0:?} is present more than once")]
     DuplicateBuiltIn(crate::BuiltIn),
+    #[error("Capability {0:?} is not supported")]
+    UnsupportedCapability(Capabilities),
 }
 
 #[derive(Clone, Debug, thiserror::Error)]
 pub enum EntryPointError {
     #[error("Multiple conflicting entry points")]
     Conflict,
     #[error("Early depth test is not applicable")]
     UnexpectedEarlyDepthTest,
@@ -94,16 +91,17 @@ fn storage_usage(access: crate::StorageA
 
 struct VaryingContext<'a> {
     ty: Handle<crate::Type>,
     stage: crate::ShaderStage,
     output: bool,
     types: &'a Arena<crate::Type>,
     location_mask: &'a mut BitSet,
     built_in_mask: u32,
+    capabilities: Capabilities,
 }
 
 impl VaryingContext<'_> {
     fn validate_impl(&mut self, binding: &crate::Binding) -> Result<(), VaryingError> {
         use crate::{
             BuiltIn as Bi, ScalarKind as Sk, ShaderStage as St, TypeInner as Ti, VectorSize as Vs,
         };
 
@@ -171,16 +169,31 @@ impl VaryingContext<'_> {
                     Bi::FrontFacing => (
                         self.stage == St::Fragment && !self.output,
                         *ty_inner
                             == Ti::Scalar {
                                 kind: Sk::Bool,
                                 width: crate::BOOL_WIDTH,
                             },
                     ),
+                    Bi::PrimitiveIndex => {
+                        if !self.capabilities.contains(Capabilities::PRIMITIVE_INDEX) {
+                            return Err(VaryingError::UnsupportedCapability(
+                                Capabilities::PRIMITIVE_INDEX,
+                            ));
+                        }
+                        (
+                            self.stage == St::Fragment && !self.output,
+                            *ty_inner
+                                == Ti::Scalar {
+                                    kind: Sk::Uint,
+                                    width,
+                                },
+                        )
+                    }
                     Bi::SampleIndex => (
                         self.stage == St::Fragment && !self.output,
                         *ty_inner
                             == Ti::Scalar {
                                 kind: Sk::Uint,
                                 width,
                             },
                     ),
@@ -198,17 +211,18 @@ impl VaryingContext<'_> {
                             == Ti::Scalar {
                                 kind: Sk::Uint,
                                 width,
                             },
                     ),
                     Bi::GlobalInvocationId
                     | Bi::LocalInvocationId
                     | Bi::WorkGroupId
-                    | Bi::WorkGroupSize => (
+                    | Bi::WorkGroupSize
+                    | Bi::NumWorkGroups => (
                         self.stage == St::Compute && !self.output,
                         *ty_inner
                             == Ti::Vector {
                                 size: Vs::Tri,
                                 kind: Sk::Uint,
                                 width,
                             },
                     ),
@@ -299,84 +313,67 @@ impl super::Validator {
     pub(super) fn validate_global_var(
         &self,
         var: &crate::GlobalVariable,
         types: &Arena<crate::Type>,
     ) -> Result<(), GlobalVariableError> {
         log::debug!("var {:?}", var);
         let type_info = &self.types[var.ty.index()];
 
-        let (allowed_storage_access, required_type_flags, is_resource) = match var.class {
+        let (required_type_flags, is_resource) = match var.class {
             crate::StorageClass::Function => return Err(GlobalVariableError::InvalidUsage),
-            crate::StorageClass::Storage => {
+            crate::StorageClass::Storage { .. } => {
                 if let Err((ty_handle, disalignment)) = type_info.storage_layout {
                     if self.flags.contains(ValidationFlags::STRUCT_LAYOUTS) {
                         return Err(GlobalVariableError::Alignment(ty_handle, disalignment));
                     }
                 }
                 (
-                    crate::StorageAccess::all(),
                     TypeFlags::DATA | TypeFlags::HOST_SHARED | TypeFlags::TOP_LEVEL,
                     true,
                 )
             }
             crate::StorageClass::Uniform => {
                 if let Err((ty_handle, disalignment)) = type_info.uniform_layout {
                     if self.flags.contains(ValidationFlags::STRUCT_LAYOUTS) {
                         return Err(GlobalVariableError::Alignment(ty_handle, disalignment));
                     }
                 }
                 (
-                    crate::StorageAccess::empty(),
                     TypeFlags::DATA
+                        | TypeFlags::COPY
                         | TypeFlags::SIZED
                         | TypeFlags::HOST_SHARED
                         | TypeFlags::TOP_LEVEL,
                     true,
                 )
             }
             crate::StorageClass::Handle => {
-                let access = match types[var.ty].inner {
-                    crate::TypeInner::Image {
-                        class: crate::ImageClass::Storage(_),
-                        ..
-                    } => crate::StorageAccess::all(),
-                    crate::TypeInner::Image { .. } | crate::TypeInner::Sampler { .. } => {
-                        crate::StorageAccess::empty()
-                    }
+                match types[var.ty].inner {
+                    crate::TypeInner::Image { .. } | crate::TypeInner::Sampler { .. } => {}
                     _ => return Err(GlobalVariableError::InvalidType),
                 };
-                (access, TypeFlags::empty(), true)
+                (TypeFlags::empty(), true)
             }
-            crate::StorageClass::Private | crate::StorageClass::WorkGroup => (
-                crate::StorageAccess::empty(),
-                TypeFlags::DATA | TypeFlags::SIZED,
-                false,
-            ),
+            crate::StorageClass::Private | crate::StorageClass::WorkGroup => {
+                (TypeFlags::DATA | TypeFlags::SIZED, false)
+            }
             crate::StorageClass::PushConstant => {
                 if !self.capabilities.contains(Capabilities::PUSH_CONSTANT) {
                     return Err(GlobalVariableError::UnsupportedCapability(
                         Capabilities::PUSH_CONSTANT,
                     ));
                 }
                 (
-                    crate::StorageAccess::LOAD,
-                    TypeFlags::DATA | TypeFlags::HOST_SHARED | TypeFlags::SIZED,
+                    TypeFlags::DATA | TypeFlags::COPY | TypeFlags::HOST_SHARED | TypeFlags::SIZED,
                     false,
                 )
             }
         };
 
-        if !allowed_storage_access.contains(var.storage_access) {
-            return Err(GlobalVariableError::InvalidStorageAccess {
-                seen: var.storage_access,
-                allowed: allowed_storage_access,
-            });
-        }
-
         if !type_info.flags.contains(required_type_flags) {
             return Err(GlobalVariableError::MissingTypeFlags {
                 seen: type_info.flags,
                 required: required_type_flags,
             });
         }
 
         if is_resource != var.binding.is_some() {
@@ -424,31 +421,33 @@ impl super::Validator {
         for (index, fa) in ep.function.arguments.iter().enumerate() {
             let mut ctx = VaryingContext {
                 ty: fa.ty,
                 stage: ep.stage,
                 output: false,
                 types: &module.types,
                 location_mask: &mut self.location_mask,
                 built_in_mask: argument_built_ins,
+                capabilities: self.capabilities,
             };
             ctx.validate(fa.binding.as_ref())
                 .map_err(|e| EntryPointError::Argument(index as u32, e))?;
             argument_built_ins = ctx.built_in_mask;
         }
 
         self.location_mask.clear();
         if let Some(ref fr) = ep.function.result {
             let mut ctx = VaryingContext {
                 ty: fr.ty,
                 stage: ep.stage,
                 output: true,
                 types: &module.types,
                 location_mask: &mut self.location_mask,
                 built_in_mask: 0,
+                capabilities: self.capabilities,
             };
             ctx.validate(fr.binding.as_ref())
                 .map_err(EntryPointError::Result)?;
         }
 
         for bg in self.bind_group_masks.iter_mut() {
             bg.clear();
         }
@@ -456,22 +455,22 @@ impl super::Validator {
             let usage = info[var_handle];
             if usage.is_empty() {
                 continue;
             }
 
             let allowed_usage = match var.class {
                 crate::StorageClass::Function => unreachable!(),
                 crate::StorageClass::Uniform => GlobalUse::READ | GlobalUse::QUERY,
-                crate::StorageClass::Storage => storage_usage(var.storage_access),
+                crate::StorageClass::Storage { access } => storage_usage(access),
                 crate::StorageClass::Handle => match module.types[var.ty].inner {
                     crate::TypeInner::Image {
-                        class: crate::ImageClass::Storage(_),
+                        class: crate::ImageClass::Storage { access, .. },
                         ..
-                    } => storage_usage(var.storage_access),
+                    } => storage_usage(access),
                     _ => GlobalUse::READ | GlobalUse::QUERY,
                 },
                 crate::StorageClass::Private | crate::StorageClass::WorkGroup => GlobalUse::all(),
                 crate::StorageClass::PushConstant => GlobalUse::READ,
             };
             if !allowed_usage.contains(usage) {
                 log::warn!("\tUsage error for: {:?}", var);
                 log::warn!(