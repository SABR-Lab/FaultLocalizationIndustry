# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/valid/type.rs
# Commit: ef5dc3e04e5f
# Full Hash: ef5dc3e04e5f271eea0636ab3a495e95cc912f1d
# Author: Dzmitry Malyshau <dmalyshau@mozilla.com>
# Date: 2021-09-04 09:40:24
# Regressor Bug: 1726626
# File Overlap Count: 3
# Description:
#   Bug 1726626 - Move gfx/wgpu into a 3rd party dependency r=jgilbert,bholley
#   
#   This update makes wgpu a vendored dependency instead of having it in gfx/wgpu.
#   
#   ## Notes
# ==============================================================================

diff --git a/third_party/rust/naga/src/valid/type.rs b/third_party/rust/naga/src/valid/type.rs
--- a/third_party/rust/naga/src/valid/type.rs
+++ b/third_party/rust/naga/src/valid/type.rs
@@ -1,27 +1,62 @@
 use super::Capabilities;
 use crate::{
     arena::{Arena, Handle},
     proc::Alignment,
 };
 
 bitflags::bitflags! {
+    /// Flags associated with [`Type`]s by [`Validator`].
+    ///
+    /// [`Type`]: crate::Type
+    /// [`Validator`]: crate::valid::Validator
     #[repr(transparent)]
     pub struct TypeFlags: u8 {
         /// Can be used for data variables.
+        ///
+        /// This flag is required on types of local variables, function
+        /// arguments, array elements, and struct members.
+        ///
+        /// This includes all types except `Image`, `Sampler`,
+        /// and some `Pointer` types.
         const DATA = 0x1;
-        /// The data type has known size.
+
+        /// The data type has a size known by pipeline creation time.
+        ///
+        /// Unsized types are quite restricted. The only unsized types permitted
+        /// by Naga, other than the non-[`DATA`] types like [`Image`] and
+        /// [`Sampler`], are dynamically-sized [`Array`s], and [`Struct`s] whose
+        /// last members are such arrays. See the documentation for those types
+        /// for details.
+        ///
+        /// [`DATA`]: TypeFlags::DATA
+        /// [`Image`]: crate::Type::Image
+        /// [`Sampler`]: crate::Type::Sampler
+        /// [`Array`]: crate::Type::Array
+        /// [`Struct`]: crate::Type::struct
         const SIZED = 0x2;
+
+        /// The data can be copied around.
+        const COPY = 0x4;
+
         /// Can be be used for interfacing between pipeline stages.
-        const INTERFACE = 0x4;
+        ///
+        /// This includes non-bool scalars and vectors, matrices, and structs
+        /// and arrays containing only interface types.
+        const INTERFACE = 0x8;
+
         /// Can be used for host-shareable structures.
-        const HOST_SHARED = 0x8;
+        const HOST_SHARED = 0x10;
+
         /// This is a top-level host-shareable type.
-        const TOP_LEVEL = 0x10;
+        const TOP_LEVEL = 0x20;
+
+        /// This type can be passed as a function argument.
+        const ARGUMENT = 0x40;
     }
 }
 
 #[derive(Clone, Copy, Debug, thiserror::Error)]
 pub enum Disalignment {
     #[error("The array stride {stride} is not a multiple of the required alignment {alignment}")]
     ArrayStride { stride: u32, alignment: u32 },
     #[error("The struct span {span}, is not a multiple of the required alignment {alignment}")]
@@ -29,32 +64,38 @@ pub enum Disalignment {
     #[error("The struct member[{index}] offset {offset} is not a multiple of the required alignment {alignment}")]
     MemberOffset {
         index: u32,
         offset: u32,
         alignment: u32,
     },
     #[error("The struct member[{index}] is not statically sized")]
     UnsizedMember { index: u32 },
+    #[error("The type is not host-shareable")]
+    NonHostShareable,
 }
 
 #[derive(Clone, Debug, thiserror::Error)]
 pub enum TypeError {
     #[error("The {0:?} scalar width {1} is not supported")]
     InvalidWidth(crate::ScalarKind, crate::Bytes),
+    #[error("The {0:?} scalar width {1} is not supported for an atomic")]
+    InvalidAtomicWidth(crate::ScalarKind, crate::Bytes),
     #[error("The base handle {0:?} can not be resolved")]
     UnresolvedBase(Handle<crate::Type>),
+    #[error("Invalid type for pointer target {0:?}")]
+    InvalidPointerBase(Handle<crate::Type>),
     #[error("Expected data type, found {0:?}")]
     InvalidData(Handle<crate::Type>),
-    #[error("Structure type {0:?} can not be a block structure")]
-    InvalidBlockType(Handle<crate::Type>),
     #[error("Base type {0:?} for the array is invalid")]
     InvalidArrayBaseType(Handle<crate::Type>),
     #[error("The constant {0:?} can not be used for an array size")]
     InvalidArraySizeConstant(Handle<crate::Constant>),
+    #[error("Array type {0:?} must have a length of one or more")]
+    NonPositiveArrayLength(Handle<crate::Constant>),
     #[error("Array stride {stride} is smaller than the base element size {base_size}")]
     InsufficientArrayStride { stride: u32, base_size: u32 },
     #[error("Field '{0}' can't be dynamically-sized, has type {1:?}")]
     InvalidDynamicArray(String, Handle<crate::Type>),
     #[error("Structure member[{index}] at {offset} overlaps the previous member")]
     MemberOverlap { index: u32, offset: u32 },
     #[error(
         "Structure member[{index}] at {offset} and size {size} crosses the structure boundary of size {span}"
@@ -153,67 +194,105 @@ impl super::Validator {
         Ok(match types[handle].inner {
             Ti::Scalar { kind, width } => {
                 if !self.check_width(kind, width) {
                     return Err(TypeError::InvalidWidth(kind, width));
                 }
                 TypeInfo::new(
                     TypeFlags::DATA
                         | TypeFlags::SIZED
+                        | TypeFlags::COPY
                         | TypeFlags::INTERFACE
-                        | TypeFlags::HOST_SHARED,
+                        | TypeFlags::HOST_SHARED
+                        | TypeFlags::ARGUMENT,
                     width as u32,
                 )
             }
             Ti::Vector { size, kind, width } => {
                 if !self.check_width(kind, width) {
                     return Err(TypeError::InvalidWidth(kind, width));
                 }
                 let count = if size >= crate::VectorSize::Tri { 4 } else { 2 };
                 TypeInfo::new(
                     TypeFlags::DATA
                         | TypeFlags::SIZED
+                        | TypeFlags::COPY
                         | TypeFlags::INTERFACE
-                        | TypeFlags::HOST_SHARED,
+                        | TypeFlags::HOST_SHARED
+                        | TypeFlags::ARGUMENT,
                     count * (width as u32),
                 )
             }
             Ti::Matrix {
                 columns: _,
                 rows,
                 width,
             } => {
                 if !self.check_width(crate::ScalarKind::Float, width) {
                     return Err(TypeError::InvalidWidth(crate::ScalarKind::Float, width));
                 }
                 let count = if rows >= crate::VectorSize::Tri { 4 } else { 2 };
                 TypeInfo::new(
                     TypeFlags::DATA
                         | TypeFlags::SIZED
+                        | TypeFlags::COPY
                         | TypeFlags::INTERFACE
-                        | TypeFlags::HOST_SHARED,
+                        | TypeFlags::HOST_SHARED
+                        | TypeFlags::ARGUMENT,
                     count * (width as u32),
                 )
             }
+            Ti::Atomic { kind, width } => {
+                let good = match kind {
+                    crate::ScalarKind::Bool | crate::ScalarKind::Float => false,
+                    crate::ScalarKind::Sint | crate::ScalarKind::Uint => width == 4,
+                };
+                if !good {
+                    return Err(TypeError::InvalidAtomicWidth(kind, width));
+                }
+                TypeInfo::new(
+                    TypeFlags::DATA | TypeFlags::SIZED | TypeFlags::HOST_SHARED,
+                    width as u32,
+                )
+            }
             Ti::Pointer { base, class: _ } => {
                 if base >= handle {
                     return Err(TypeError::UnresolvedBase(base));
                 }
-                TypeInfo::new(TypeFlags::DATA | TypeFlags::SIZED, 0)
+
+                let base_info = &self.types[base.index()];
+                if !base_info.flags.contains(TypeFlags::DATA) {
+                    return Err(TypeError::InvalidPointerBase(base));
+                }
+                // Pointers to dynamically-sized arrays are needed, to serve as
+                // the type of an `AccessIndex` expression referring to a
+                // dynamically sized array appearing as the final member of a
+                // top-level `Struct`. But such pointers cannot be passed to
+                // functions, stored in variables, etc. So, we mark them as not
+                // `DATA`.
+                let data_flag = if base_info.flags.contains(TypeFlags::SIZED) {
+                    TypeFlags::DATA | TypeFlags::ARGUMENT
+                } else if let crate::TypeInner::Struct { .. } = types[base].inner {
+                    TypeFlags::DATA | TypeFlags::ARGUMENT
+                } else {
+                    TypeFlags::empty()
+                };
+
+                TypeInfo::new(data_flag | TypeFlags::SIZED | TypeFlags::COPY, 0)
             }
             Ti::ValuePointer {
                 size: _,
                 kind,
                 width,
                 class: _,
             } => {
                 if !self.check_width(kind, width) {
                     return Err(TypeError::InvalidWidth(kind, width));
                 }
-                TypeInfo::new(TypeFlags::SIZED, 0)
+                TypeInfo::new(TypeFlags::DATA | TypeFlags::SIZED | TypeFlags::COPY, 0)
             }
             Ti::Array { base, size, stride } => {
                 if base >= handle {
                     return Err(TypeError::UnresolvedBase(base));
                 }
                 let base_info = &self.types[base.index()];
                 if !base_info.flags.contains(TypeFlags::DATA | TypeFlags::SIZED) {
                     return Err(TypeError::InvalidArrayBaseType(base));
@@ -265,88 +344,99 @@ impl super::Validator {
                             Ok(Alignment::new(align))
                         }
                     }
                     Err(e) => Err(e),
                 };
 
                 let sized_flag = match size {
                     crate::ArraySize::Constant(const_handle) => {
-                        match constants.try_get(const_handle) {
+                        let length_is_positive = match constants.try_get(const_handle) {
                             Some(&crate::Constant {
                                 inner:
                                     crate::ConstantInner::Scalar {
                                         width: _,
-                                        value: crate::ScalarValue::Uint(_),
+                                        value: crate::ScalarValue::Uint(length),
                                     },
                                 ..
-                            }) => {}
+                            }) => length > 0,
                             // Accept a signed integer size to avoid
                             // requiring an explicit uint
                             // literal. Type inference should make
                             // this unnecessary.
                             Some(&crate::Constant {
                                 inner:
                                     crate::ConstantInner::Scalar {
                                         width: _,
-                                        value: crate::ScalarValue::Sint(_),
+                                        value: crate::ScalarValue::Sint(length),
                                     },
                                 ..
-                            }) => {}
+                            }) => length > 0,
                             other => {
                                 log::warn!("Array size {:?}", other);
                                 return Err(TypeError::InvalidArraySizeConstant(const_handle));
                             }
+                        };
+
+                        if !length_is_positive {
+                            return Err(TypeError::NonPositiveArrayLength(const_handle));
                         }
 
-                        TypeFlags::SIZED
+                        TypeFlags::SIZED | TypeFlags::ARGUMENT
                     }
                     crate::ArraySize::Dynamic => {
                         // Non-SIZED types may only appear as the last element of a structure.
                         // This is enforced by checks for SIZED-ness for all compound types,
                         // and a special case for structs.
                         TypeFlags::empty()
                     }
                 };
 
-                let base_mask = TypeFlags::HOST_SHARED | TypeFlags::INTERFACE;
+                let base_mask = TypeFlags::COPY | TypeFlags::HOST_SHARED | TypeFlags::INTERFACE;
                 TypeInfo {
                     flags: TypeFlags::DATA | (base_info.flags & base_mask) | sized_flag,
                     uniform_layout,
                     storage_layout,
                 }
             }
             Ti::Struct {
                 top_level,
                 ref members,
                 span,
             } => {
                 let mut ti = TypeInfo::new(
                     TypeFlags::DATA
                         | TypeFlags::SIZED
+                        | TypeFlags::COPY
                         | TypeFlags::HOST_SHARED
-                        | TypeFlags::INTERFACE,
+                        | TypeFlags::INTERFACE
+                        | TypeFlags::ARGUMENT,
                     1,
                 );
                 let mut min_offset = 0;
 
                 for (i, member) in members.iter().enumerate() {
                     if member.ty >= handle {
                         return Err(TypeError::UnresolvedBase(member.ty));
                     }
                     let base_info = &self.types[member.ty.index()];
                     if !base_info.flags.contains(TypeFlags::DATA) {
                         return Err(TypeError::InvalidData(member.ty));
                     }
-                    if top_level && !base_info.flags.contains(TypeFlags::INTERFACE) {
-                        return Err(TypeError::InvalidBlockType(member.ty));
-                    }
                     if base_info.flags.contains(TypeFlags::TOP_LEVEL) {
                         return Err(TypeError::NestedTopLevel);
                     }
+                    if !base_info.flags.contains(TypeFlags::HOST_SHARED) {
+                        if ti.uniform_layout.is_ok() {
+                            ti.uniform_layout = Err((member.ty, Disalignment::NonHostShareable));
+                        }
+                        if ti.storage_layout.is_ok() {
+                            ti.storage_layout = Err((member.ty, Disalignment::NonHostShareable));
+                        }
+                    }
                     ti.flags &= base_info.flags;
 
                     if member.offset < min_offset {
                         //HACK: this could be nicer. We want to allow some structures
                         // to not bother with offsets/alignments if they are never
                         // used for host sharing.
                         if member.offset == 0 {
                             ti.flags.set(TypeFlags::HOST_SHARED, false);
@@ -402,12 +492,12 @@ impl super::Validator {
                 let alignment = self.layouter[handle].alignment.get();
                 if span % alignment != 0 {
                     ti.uniform_layout = Err((handle, Disalignment::StructSpan { span, alignment }));
                     ti.storage_layout = Err((handle, Disalignment::StructSpan { span, alignment }));
                 }
 
                 ti
             }
-            Ti::Image { .. } | Ti::Sampler { .. } => TypeInfo::new(TypeFlags::empty(), 0),
+            Ti::Image { .. } | Ti::Sampler { .. } => TypeInfo::new(TypeFlags::ARGUMENT, 0),
         })
     }
 }