# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MIR.h
# Commit: 25adf505426d
# Full Hash: 25adf505426d21f67e15d146f879b0ea53d343a7
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2022-03-23 04:09:13
# Regressor Bug: 1642412
# File Overlap Count: 19
# Description:
#   Bug 1642412 - wasm: Rollup of inline table.get/set for anyref. r=lth
#   
#   Rollup of the previous inline table.get/set patches.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D141024
# ==============================================================================

diff -r 43f7556db2e1 -r 25adf505426d js/src/jit/MIR.h
--- a/js/src/jit/MIR.h	Tue Mar 22 19:44:13 2022 +0000
+++ b/js/src/jit/MIR.h	Tue Mar 22 19:59:05 2022 +0000
@@ -333,32 +333,34 @@
         1 << 9,                  // An array buffer view's length or byteOffset
     WasmGlobalCell = 1 << 10,    // A wasm global cell
     WasmTableElement = 1 << 11,  // An element of a wasm table
-    WasmStackResult = 1 << 12,   // A stack result from the current function
+    WasmTableMeta = 1 << 12,     // A wasm table elements pointer and
+                                 // length field, in Tls.
+    WasmStackResult = 1 << 13,   // A stack result from the current function
 
     // JSContext's exception state. This is used on instructions like MThrow
     // or MNewArrayDynamicLength that throw exceptions (other than OOM) but have
     // no other side effect, to ensure that they get their own up-to-date resume
     // point. (This resume point will be used when constructing the Baseline
     // frame during exception bailouts.)
-    ExceptionState = 1 << 13,
+    ExceptionState = 1 << 14,
 
     // Used for instructions that load the privateSlot of DOM proxies and
     // the ExpandoAndGeneration.
-    DOMProxyExpando = 1 << 14,
+    DOMProxyExpando = 1 << 15,
 
     // Hash table of a Map or Set object.
-    MapOrSetHashTable = 1 << 15,
+    MapOrSetHashTable = 1 << 16,
 
     // Internal state of the random number generator
-    RNG = 1 << 16,
+    RNG = 1 << 17,
 
     // The pendingException slot on the wasm tls object.
-    WasmPendingException = 1 << 17,
+    WasmPendingException = 1 << 18,
 
     Last = WasmPendingException,
 
     Any = Last | (Last - 1),
-    NumCategories = 18,
+    NumCategories = 19,
 
     // Indicates load or store.
     Store_ = 1 << 31
@@ -8988,11 +8990,12 @@
         aliases_(aliases) {
     // Different Tls data have different alias classes and only those classes
     // are allowed.
-    MOZ_ASSERT(aliases_.flags() ==
-                   AliasSet::Load(AliasSet::WasmHeapMeta).flags() ||
-               aliases_.flags() ==
-                   AliasSet::Load(AliasSet::WasmPendingException).flags() ||
-               aliases_.flags() == AliasSet::None().flags());
+    MOZ_ASSERT(
+        aliases_.flags() == AliasSet::Load(AliasSet::WasmHeapMeta).flags() ||
+        aliases_.flags() == AliasSet::Load(AliasSet::WasmTableMeta).flags() ||
+        aliases_.flags() ==
+            AliasSet::Load(AliasSet::WasmPendingException).flags() ||
+        aliases_.flags() == AliasSet::None().flags());
 
     // The only types supported at the moment.
     MOZ_ASSERT(type == MIRType::Pointer || type == MIRType::Int32 ||
@@ -9081,12 +9084,21 @@
 // For memory64, bounds check nodes are always of type Int64.
 
 class MWasmBoundsCheck : public MBinaryInstruction, public NoTypePolicy::Data {
+ public:
+  enum Target {
+    Memory,
+    Table,
+  };
+
+ private:
   wasm::BytecodeOffset bytecodeOffset_;
+  Target target_;
 
   explicit MWasmBoundsCheck(MDefinition* index, MDefinition* boundsCheckLimit,
-                            wasm::BytecodeOffset bytecodeOffset)
+                            wasm::BytecodeOffset bytecodeOffset, Target target)
       : MBinaryInstruction(classOpcode, index, boundsCheckLimit),
-        bytecodeOffset_(bytecodeOffset) {
+        bytecodeOffset_(bytecodeOffset),
+        target_(target) {
     MOZ_ASSERT(index->type() == boundsCheckLimit->type());
 
     // Bounds check is effectful: it throws for OOB.
@@ -9104,6 +9116,8 @@
 
   AliasSet getAliasSet() const override { return AliasSet::None(); }
 
+  bool isMemory() const { return target_ == MWasmBoundsCheck::Memory; }
+
   bool isRedundant() const { return !isGuard(); }
 
   void setRedundant() { setNotGuard(); }
@@ -9578,6 +9592,25 @@
   AliasType mightAlias(const MDefinition* def) const override;
 };
 
+class MWasmLoadTableElement : public MBinaryInstruction,
+                              public NoTypePolicy::Data {
+  MWasmLoadTableElement(MDefinition* elements, MDefinition* index)
+      : MBinaryInstruction(classOpcode, elements, index) {
+    setResultType(MIRType::RefOrNull);
+    setMovable();
+  }
+
+ public:
+  INSTRUCTION_HEADER(WasmLoadTableElement)
+  TRIVIAL_NEW_WRAPPERS
+  NAMED_OPERANDS((0, elements))
+  NAMED_OPERANDS((1, index))
+
+  AliasSet getAliasSet() const override {
+    return AliasSet::Load(AliasSet::WasmTableElement);
+  }
+};
+
 class MWasmStoreGlobalVar : public MBinaryInstruction,
                             public NoTypePolicy::Data {
   MWasmStoreGlobalVar(unsigned globalDataOffset, MDefinition* value,
@@ -9668,6 +9701,38 @@
   ALLOW_CLONE(MWasmDerivedPointer)
 };
 
+class MWasmDerivedIndexPointer : public MBinaryInstruction,
+                                 public NoTypePolicy::Data {
+  MWasmDerivedIndexPointer(MDefinition* base, MDefinition* index, Scale scale)
+      : MBinaryInstruction(classOpcode, base, index), scale_(scale) {
+    setResultType(MIRType::Pointer);
+    setMovable();
+  }
+
+  Scale scale_;
+
+ public:
+  INSTRUCTION_HEADER(WasmDerivedIndexPointer)
+  TRIVIAL_NEW_WRAPPERS
+  NAMED_OPERANDS((0, base))
+  NAMED_OPERANDS((1, index))
+
+  Scale scale() const { return scale_; }
+
+  AliasSet getAliasSet() const override { return AliasSet::None(); }
+
+  bool congruentTo(const MDefinition* ins) const override {
+    return congruentIfOperandsEqual(ins) &&
+           ins->toWasmDerivedIndexPointer()->scale() == scale();
+  }
+
+  ALLOW_CLONE(MWasmDerivedIndexPointer)
+};
+
+// Stores a reference to an address. This performs a pre-barrier on the address,
+// but not a post-barrier. A post-barrier must be performed separately, if it's
+// required.
+
 class MWasmStoreRef : public MAryInstruction<3>, public NoTypePolicy::Data {
   AliasSet::Flag aliasSet_;
 