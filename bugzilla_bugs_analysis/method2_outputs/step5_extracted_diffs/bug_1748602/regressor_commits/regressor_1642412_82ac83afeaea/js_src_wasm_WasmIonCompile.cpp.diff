# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmIonCompile.cpp
# Commit: 82ac83afeaea
# Full Hash: 82ac83afeaeaa3665037ea587c614fddaa8b648d
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2022-03-24 21:54:20
# Regressor Bug: 1642412
# File Overlap Count: 1
# Description:
#   Bug 1642412 - wasm: Don't read a call site line in operations that AsmJS won't emit one for. r=lth
#   
#   AsmJS will emit a call site line number for call, call indirect, and math builtins.
#   We currently read from the call site line number array for more operations than
#   these. This is normally fine, as long as the operations that try the read are
# ==============================================================================

diff -r 00b99ec19d1e -r 82ac83afeaea js/src/wasm/WasmIonCompile.cpp
--- a/js/src/wasm/WasmIonCompile.cpp	Thu Mar 24 17:56:52 2022 +0000
+++ b/js/src/wasm/WasmIonCompile.cpp	Thu Mar 24 17:56:53 2022 +0000
@@ -1677,12 +1677,13 @@
       // Handle a store to a ref-typed field specially
       if (v->type() == MIRType::RefOrNull) {
         // Load the previous value for the post-write barrier
-        auto* prevValue = MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
+        auto* prevValue =
+            MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
         curBlock_->add(prevValue);
 
         // Store the new value
         auto* store = MWasmStoreRef::New(alloc(), tlsPointer_, valueAddr, v,
-                                   AliasSet::WasmGlobalCell);
+                                         AliasSet::WasmGlobalCell);
         curBlock_->add(store);
 
         // Call the post-write barrier
@@ -1704,12 +1705,13 @@
       curBlock_->add(valueAddr);
 
       // Load the previous value for the post-write barrier
-      auto* prevValue = MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
+      auto* prevValue =
+          MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
       curBlock_->add(prevValue);
 
       // Store the new value
       auto* store = MWasmStoreRef::New(alloc(), tlsPointer_, valueAddr, v,
-                                 AliasSet::WasmGlobalVar);
+                                       AliasSet::WasmGlobalVar);
       curBlock_->add(store);
 
       // Call the post-write barrier
@@ -1760,7 +1762,8 @@
   }
 
   [[nodiscard]] bool tableSetAnyRef(const TableDesc& table, MDefinition* index,
-                              MDefinition* value, uint32_t lineOrBytecode) {
+                                    MDefinition* value,
+                                    uint32_t lineOrBytecode) {
     // Load the table length and perform a bounds check with spectre index
     // masking
     auto* length = loadTableLength(table);
@@ -3170,7 +3173,7 @@
   }
 
   bool emitNewException(MDefinition* tag, MDefinition** exception) {
-    uint32_t lineOrBytecode = readCallSiteLineOrBytecode();
+    uint32_t bytecodeOffset = readBytecodeOffset();
     const SymbolicAddressSignature& callee = SASigExceptionNew;
     CallCompileState args;
     if (!passInstance(callee.argTypes[0], &args)) {
@@ -3182,14 +3185,14 @@
     if (!finishCall(&args)) {
       return false;
     }
-    return builtinInstanceMethodCall(callee, lineOrBytecode, args, exception);
+    return builtinInstanceMethodCall(callee, bytecodeOffset, args, exception);
   }
 
   bool emitThrow(uint32_t tagIndex, const DefVector& argValues) {
     if (inDeadCode()) {
       return true;
     }
-    uint32_t lineOrBytecode = readCallSiteLineOrBytecode();
+    uint32_t bytecodeOffset = readBytecodeOffset();
 
     // Load the tag
     MDefinition* tag = loadTag(tagIndex);
@@ -3236,7 +3239,8 @@
       curBlock_->add(fieldAddr);
 
       // Load the previous value
-      auto* prevValue = MWasmLoadObjectDataField::New(alloc(), exception, data, offset, ToMIRType(type));
+      auto* prevValue = MWasmLoadObjectDataField::New(alloc(), exception, data,
+                                                      offset, ToMIRType(type));
       if (!prevValue) {
         return false;
       }
@@ -3251,7 +3255,7 @@
       curBlock_->add(store);
 
       // Call the post-write barrier
-      if (!postBarrierPrecise(lineOrBytecode, fieldAddr, prevValue)) {
+      if (!postBarrierPrecise(bytecodeOffset, fieldAddr, prevValue)) {
         return false;
       }
     }
@@ -3286,7 +3290,7 @@
 
     // If there is no surrounding catching block, call an instance method to
     // throw the exception.
-    uint32_t lineOrBytecode = readCallSiteLineOrBytecode();
+    uint32_t bytecodeOffset = readBytecodeOffset();
     const SymbolicAddressSignature& callee = SASigThrowException;
     CallCompileState args;
     if (!passInstance(callee.argTypes[0], &args)) {
@@ -3298,7 +3302,7 @@
     if (!finishCall(&args)) {
       return false;
     }
-    if (!builtinInstanceMethodCall(callee, lineOrBytecode, args)) {
+    if (!builtinInstanceMethodCall(callee, bytecodeOffset, args)) {
       return false;
     }
     unreachableTrap();
@@ -3331,6 +3335,15 @@
 
   /************************************************************ DECODING ***/
 
+  // AsmJS adds a line number to `callSiteLineNums` for certain operations that
+  // are represented by a JS call, such as math builtins. We use these line
+  // numbers when calling builtins. This method will read from
+  // `callSiteLineNums` when we are using AsmJS, or else return the current
+  // bytecode offset.
+  //
+  // This method MUST be called from opcodes that AsmJS will emit a call site
+  // line number for, or else the arrays will get out of sync. Other opcodes
+  // must use `readBytecodeOffset` below.
   uint32_t readCallSiteLineOrBytecode() {
     if (!func_.callSiteLineNums.empty()) {
       return func_.callSiteLineNums[lastReadCallSite_++];
@@ -3338,6 +3351,9 @@
     return iter_.lastOpcodeOffset();
   }
 
+  // Return the current bytecode offset.
+  uint32_t readBytecodeOffset() { return iter_.lastOpcodeOffset(); }
+
 #if DEBUG
   bool done() const { return iter_.done(); }
 #endif
@@ -4039,7 +4055,7 @@
 }
 
 static bool EmitSetGlobal(FunctionCompiler& f) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   uint32_t id;
   MDefinition* value;
@@ -4049,12 +4065,12 @@
 
   const GlobalDesc& global = f.moduleEnv().globals[id];
   MOZ_ASSERT(global.isMutable());
-  return f.storeGlobalVar(lineOrBytecode, global.offset(), global.isIndirect(),
+  return f.storeGlobalVar(bytecodeOffset, global.offset(), global.isIndirect(),
                           value);
 }
 
 static bool EmitTeeGlobal(FunctionCompiler& f) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   uint32_t id;
   MDefinition* value;
@@ -4065,7 +4081,7 @@
   const GlobalDesc& global = f.moduleEnv().globals[id];
   MOZ_ASSERT(global.isMutable());
 
-  return f.storeGlobalVar(lineOrBytecode, global.offset(), global.isIndirect(),
+  return f.storeGlobalVar(bytecodeOffset, global.offset(), global.isIndirect(),
                           value);
 }
 
@@ -4532,7 +4548,7 @@
 }
 
 static bool EmitMemoryGrow(FunctionCompiler& f) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       f.isNoMemOrMem32() ? SASigMemoryGrowM32 : SASigMemoryGrowM64;
@@ -4553,7 +4569,7 @@
   f.finishCall(&args);
 
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -4562,7 +4578,7 @@
 }
 
 static bool EmitMemorySize(FunctionCompiler& f) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       f.isNoMemOrMem32() ? SASigMemorySizeM32 : SASigMemorySizeM64;
@@ -4579,7 +4595,7 @@
   f.finishCall(&args);
 
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -4664,7 +4680,7 @@
   MOZ_ASSERT(type == ValType::I32 || type == ValType::I64);
   MOZ_ASSERT(SizeOf(type) == byteSize);
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       f.isNoMemOrMem32()
@@ -4707,7 +4723,7 @@
   }
 
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -4725,7 +4741,7 @@
 }
 
 static bool EmitWake(FunctionCompiler& f) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       f.isNoMemOrMem32() ? SASigWakeM32 : SASigWakeM64;
@@ -4760,7 +4776,7 @@
   }
 
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -4789,7 +4805,7 @@
 
 static bool EmitMemCopyCall(FunctionCompiler& f, MDefinition* dst,
                             MDefinition* src, MDefinition* len) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       (f.moduleEnv().usesSharedMemory()
@@ -4817,7 +4833,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitMemCopyInlineM32(FunctionCompiler& f, MDefinition* dst,
@@ -4993,7 +5009,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee = SASigTableCopy;
   CallCompileState args;
@@ -5028,7 +5044,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitDataOrElemDrop(FunctionCompiler& f, bool isData) {
@@ -5041,7 +5057,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       isData ? SASigDataDrop : SASigElemDrop;
@@ -5060,12 +5076,12 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitMemFillCall(FunctionCompiler& f, MDefinition* start,
                             MDefinition* val, MDefinition* len) {
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       (f.moduleEnv().usesSharedMemory()
@@ -5094,7 +5110,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitMemFillInlineM32(FunctionCompiler& f, MDefinition* start,
@@ -5225,7 +5241,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee =
       isMem ? (f.isMem32() ? SASigMemInitM32 : SASigMemInitM64)
@@ -5263,7 +5279,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 // Note, table.{get,grow,set} on table(funcref) are currently rejected by the
@@ -5280,7 +5296,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee = SASigTableFill;
   CallCompileState args;
@@ -5311,7 +5327,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitTableGet(FunctionCompiler& f) {
@@ -5335,7 +5351,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee = SASigTableGetFunc;
   CallCompileState args;
@@ -5363,7 +5379,7 @@
   // The return value here is either null, denoting an error, or a short-lived
   // pointer to a location containing a possibly-null ref.
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -5383,7 +5399,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee = SASigTableGrow;
   CallCompileState args;
@@ -5413,7 +5429,7 @@
   }
 
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -5433,11 +5449,11 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const TableDesc& table = f.moduleEnv().tables[tableIndex];
   if (table.elemType.tableRepr() == TableRepr::Ref) {
-    return f.tableSetAnyRef(table, index, value, lineOrBytecode);
+    return f.tableSetAnyRef(table, index, value, bytecodeOffset);
   }
 
   const SymbolicAddressSignature& callee = SASigTableSetFunc;
@@ -5467,7 +5483,7 @@
     return false;
   }
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitTableSize(FunctionCompiler& f) {
@@ -5501,7 +5517,7 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
 
   const SymbolicAddressSignature& callee = SASigRefFunc;
   CallCompileState args;
@@ -5524,7 +5540,7 @@
   // The return value here is either null, denoting an error, or a short-lived
   // pointer to a location containing a possibly-null ref.
   MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
+  if (!f.builtinInstanceMethodCall(callee, bytecodeOffset, args, &ret)) {
     return false;
   }
 
@@ -5771,7 +5787,7 @@
     return false;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
+  uint32_t bytecodeOffset = f.readBytecodeOffset();
   const SymbolicAddressSignature& callee = intrinsic->signature;
 
   CallCompileState args;
@@ -5790,7 +5806,7 @@
 
   f.finishCall(&args);
 
-  return f.builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  return f.builtinInstanceMethodCall(callee, bytecodeOffset, args);
 }
 
 static bool EmitBodyExprs(FunctionCompiler& f) {
