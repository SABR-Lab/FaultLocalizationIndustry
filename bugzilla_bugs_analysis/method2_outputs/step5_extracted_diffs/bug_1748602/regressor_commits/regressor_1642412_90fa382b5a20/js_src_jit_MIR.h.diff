# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MIR.h
# Commit: 90fa382b5a20
# Full Hash: 90fa382b5a203d2e28bfa69f29ab8edee150b77b
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2021-12-23 09:34:36
# Regressor Bug: 1642412
# File Overlap Count: 8
# Description:
#   Bug 1642412 - wasm: Optimize ion table.get/set/size. r=lth
#   
#   This commit adds ion fast paths for table.get/set when the table
#   representation is anyref. An unconditional fast path is added for
#   table.size.
# ==============================================================================

diff -r 40f861f62a0f -r 90fa382b5a20 js/src/jit/MIR.h
--- a/js/src/jit/MIR.h	Wed Dec 22 17:36:29 2021 +0000
+++ b/js/src/jit/MIR.h	Wed Dec 22 17:36:30 2021 +0000
@@ -333,21 +333,23 @@
         1 << 9,                  // An array buffer view's length or byteOffset
     WasmGlobalCell = 1 << 10,    // A wasm global cell
     WasmTableElement = 1 << 11,  // An element of a wasm table
-    WasmStackResult = 1 << 12,   // A stack result from the current function
+    WasmTableMeta = 1 << 12,     // A wasm table elements pointer and
+                                 // length field, in Tls.
+    WasmStackResult = 1 << 13,   // A stack result from the current function
 
     // JSContext's exception state. This is used on instructions like MThrow
     // or MNewArrayDynamicLength that throw exceptions (other than OOM) but have
     // no other side effect, to ensure that they get their own up-to-date resume
     // point. (This resume point will be used when constructing the Baseline
     // frame during exception bailouts.)
-    ExceptionState = 1 << 13,
+    ExceptionState = 1 << 14,
 
     // Used for instructions that load the privateSlot of DOM proxies and
     // the ExpandoAndGeneration.
-    DOMProxyExpando = 1 << 14,
+    DOMProxyExpando = 1 << 15,
 
     // Hash table of a Map or Set object.
-    MapOrSetHashTable = 1 << 15,
+    MapOrSetHashTable = 1 << 16,
 
     // Internal state of the random number generator
     RNG = 1 << 16,
@@ -9023,6 +9025,8 @@
     MOZ_ASSERT(aliases_.flags() ==
                    AliasSet::Load(AliasSet::WasmHeapMeta).flags() ||
                aliases_.flags() ==
+                   AliasSet::Load(AliasSet::WasmTableMeta).flags() ||
+               aliases_.flags() ==
                    AliasSet::Load(AliasSet::WasmPendingException).flags() ||
                aliases_.flags() == AliasSet::None().flags());
 
@@ -9084,12 +9088,21 @@
 // For memory64, bounds check nodes are always of type Int64.
 
 class MWasmBoundsCheck : public MBinaryInstruction, public NoTypePolicy::Data {
+ public:
+  enum Target {
+    Memory,
+    Table,
+  };
+
+ private:
   wasm::BytecodeOffset bytecodeOffset_;
+  Target target_;
 
   explicit MWasmBoundsCheck(MDefinition* index, MDefinition* boundsCheckLimit,
-                            wasm::BytecodeOffset bytecodeOffset)
+                            wasm::BytecodeOffset bytecodeOffset, Target target)
       : MBinaryInstruction(classOpcode, index, boundsCheckLimit),
-        bytecodeOffset_(bytecodeOffset) {
+        bytecodeOffset_(bytecodeOffset),
+        target_(target) {
     MOZ_ASSERT(index->type() == boundsCheckLimit->type());
 
     // Bounds check is effectful: it throws for OOB.
@@ -9107,6 +9120,8 @@
 
   AliasSet getAliasSet() const override { return AliasSet::None(); }
 
+  bool isMemory() const { return target_ == MWasmBoundsCheck::Memory; }
+
   bool isRedundant() const { return !isGuard(); }
 
   void setRedundant() { setNotGuard(); }
@@ -9581,6 +9596,21 @@
   AliasType mightAlias(const MDefinition* def) const override;
 };
 
+class MWasmLoadTableElement : public MBinaryInstruction,
+                              public NoTypePolicy::Data {
+  MWasmLoadTableElement(MDefinition* elements, MDefinition* index)
+      : MBinaryInstruction(classOpcode, elements, index) {
+    setResultType(MIRType::RefOrNull);
+    setMovable();
+  }
+
+ public:
+  INSTRUCTION_HEADER(WasmLoadTableElement)
+  TRIVIAL_NEW_WRAPPERS
+  NAMED_OPERANDS((0, elements))
+  NAMED_OPERANDS((1, index))
+};
+
 class MWasmStoreGlobalVar : public MBinaryInstruction,
                             public NoTypePolicy::Data {
   MWasmStoreGlobalVar(unsigned globalDataOffset, MDefinition* value,
@@ -9671,6 +9701,38 @@
   ALLOW_CLONE(MWasmDerivedPointer)
 };
 
+class MWasmDerivedIndexPointer : public MBinaryInstruction,
+                                 public NoTypePolicy::Data {
+  MWasmDerivedIndexPointer(MDefinition* base, MDefinition* index, Scale scale)
+      : MBinaryInstruction(classOpcode, base, index), scale_(scale) {
+    setResultType(MIRType::Pointer);
+    setMovable();
+  }
+
+  Scale scale_;
+
+ public:
+  INSTRUCTION_HEADER(WasmDerivedIndexPointer)
+  TRIVIAL_NEW_WRAPPERS
+  NAMED_OPERANDS((0, base))
+  NAMED_OPERANDS((1, index))
+
+  Scale scale() const { return scale_; }
+
+  AliasSet getAliasSet() const override { return AliasSet::None(); }
+
+  bool congruentTo(const MDefinition* ins) const override {
+    return congruentIfOperandsEqual(ins) &&
+           ins->toWasmDerivedIndexPointer()->scale() == scale();
+  }
+
+  ALLOW_CLONE(MWasmDerivedIndexPointer)
+};
+
+// Stores a reference to an address. This performs a pre-barrier on the address,
+// but not a post-barrier. A post-barrier must be performed separately, if it's
+// required.
+
 class MWasmStoreRef : public MAryInstruction<3>, public NoTypePolicy::Data {
   AliasSet::Flag aliasSet_;
 