# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmIonCompile.cpp
# Commit: 90fa382b5a20
# Full Hash: 90fa382b5a203d2e28bfa69f29ab8edee150b77b
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2021-12-23 09:34:36
# Regressor Bug: 1642412
# File Overlap Count: 8
# Description:
#   Bug 1642412 - wasm: Optimize ion table.get/set/size. r=lth
#   
#   This commit adds ion fast paths for table.get/set when the table
#   representation is anyref. An unconditional fast path is added for
#   table.size.
# ==============================================================================

diff -r 40f861f62a0f -r 90fa382b5a20 js/src/wasm/WasmIonCompile.cpp
--- a/js/src/wasm/WasmIonCompile.cpp	Wed Dec 22 17:36:29 2021 +0000
+++ b/js/src/wasm/WasmIonCompile.cpp	Wed Dec 22 17:36:30 2021 +0000
@@ -1315,8 +1315,9 @@
       actualBase = extended;
     }
 
-    auto* ins = MWasmBoundsCheck::New(alloc(), actualBase, boundsCheckLimit,
-                                      bytecodeOffset());
+    auto* ins =
+        MWasmBoundsCheck::New(alloc(), actualBase, boundsCheckLimit,
+                              bytecodeOffset(), MWasmBoundsCheck::Memory);
     curBlock_->add(ins);
     actualBase = ins;
 
@@ -1701,6 +1702,19 @@
 
   /************************************************ Global variable accesses */
 
+  bool postBarrierFiltering(MDefinition* valueAddr, uint32_t lineOrBytecode) {
+    const SymbolicAddressSignature& callee = SASigPostBarrierFiltering;
+    CallCompileState args;
+    if (!passInstance(callee.argTypes[0], &args)) {
+      return false;
+    }
+    if (!passArg(valueAddr, callee.argTypes[1], &args)) {
+      return false;
+    }
+    finishCall(&args);
+    return builtinInstanceMethodCall(callee, lineOrBytecode, args);
+  }
+
   MDefinition* loadGlobalVar(unsigned globalDataOffset, bool isConst,
                              bool isIndirect, MIRType type) {
     if (inDeadCode()) {
@@ -1770,6 +1784,69 @@
     return valueAddr;
   }
 
+  MDefinition* loadTableField(const TableDesc& table, unsigned fieldOffset,
+                              MIRType type) {
+    uint32_t globalDataOffset =
+        offsetof(TlsData, globalArea) + table.globalDataOffset + fieldOffset;
+    auto* load = MWasmLoadTls::New(alloc(), tlsPointer_, globalDataOffset, type,
+                                   AliasSet::Load(AliasSet::WasmTableMeta));
+    curBlock_->add(load);
+    return load;
+  }
+  MDefinition* loadTableLength(const TableDesc& table) {
+    return loadTableField(table, offsetof(TableTls, length), MIRType::Int32);
+  }
+  MDefinition* loadTableElements(const TableDesc& table) {
+    return loadTableField(table, offsetof(TableTls, elements),
+                          MIRType::Pointer);
+  }
+
+  MDefinition* tableGetAnyRef(const TableDesc& table, MDefinition* index) {
+    // Load the table length and perform a bounds check with spectre index
+    // masking
+    auto* length = loadTableLength(table);
+    auto* check = MWasmBoundsCheck::New(
+        alloc(), index, length, bytecodeOffset(), MWasmBoundsCheck::Table);
+    curBlock_->add(check);
+    if (JitOptions.spectreIndexMasking) {
+      index = check;
+    }
+
+    // Load the table elements and load the element
+    auto* elements = loadTableElements(table);
+    auto* element = MWasmLoadTableElement::New(alloc(), elements, index);
+    curBlock_->add(element);
+    return element;
+  }
+  MDefinition* tableSetAnyRef(const TableDesc& table, MDefinition* index,
+                              MDefinition* value, uint32_t lineOrBytecode) {
+    // Load the table length and perform a bounds check with spectre index
+    // masking
+    auto* length = loadTableLength(table);
+    auto* check = MWasmBoundsCheck::New(
+        alloc(), index, length, bytecodeOffset(), MWasmBoundsCheck::Table);
+    curBlock_->add(check);
+    if (JitOptions.spectreIndexMasking) {
+      index = check;
+    }
+
+    // Load the table elements and compute the value's location
+    auto* elements = loadTableElements(table);
+    auto* loc =
+        MWasmDerivedIndexPointer::New(alloc(), elements, index, ScalePointer);
+    curBlock_->add(loc);
+
+    // Store the new value and then perform the post barrier
+    auto* store = MWasmStoreRef::New(alloc(), tlsPointer_, loc, value,
+                                     AliasSet::WasmTableElement);
+    curBlock_->add(store);
+    if (!postBarrierFiltering(loc, lineOrBytecode)) {
+      return nullptr;
+    }
+
+    return store;
+  }
+
   void addInterruptCheck() {
     if (inDeadCode()) {
       return;
@@ -4076,19 +4153,8 @@
   // the nursery, and the value stored will very frequently be in the nursery.
   // The C++ postbarrier performs any necessary filtering.
 
-  if (barrierAddr) {
-    const SymbolicAddressSignature& callee = SASigPostBarrierFiltering;
-    CallCompileState args;
-    if (!f.passInstance(callee.argTypes[0], &args)) {
-      return false;
-    }
-    if (!f.passArg(barrierAddr, callee.argTypes[1], &args)) {
-      return false;
-    }
-    f.finishCall(&args);
-    if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args)) {
-      return false;
-    }
+  if (barrierAddr && !f.postBarrierFiltering(barrierAddr, lineOrBytecode)) {
+    return false;
   }
 
   return true;
@@ -5364,6 +5430,16 @@
     return true;
   }
 
+  const TableDesc& table = f.moduleEnv().tables[tableIndex];
+  if (table.elemType.tableRepr() == TableRepr::Ref) {
+    MDefinition* ret = f.tableGetAnyRef(table, index);
+    if (!ret) {
+      return false;
+    }
+    f.iter().setResult(ret);
+    return true;
+  }
+
   uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
 
   const SymbolicAddressSignature& callee = SASigTableGet;
@@ -5464,6 +5540,15 @@
 
   uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
 
+  const TableDesc& table = f.moduleEnv().tables[tableIndex];
+  if (table.elemType.tableRepr() == TableRepr::Ref) {
+    MDefinition* ret = f.tableSetAnyRef(table, index, value, lineOrBytecode);
+    if (!ret) {
+      return false;
+    }
+    return true;
+  }
+
   const SymbolicAddressSignature& callee = SASigTableSet;
   CallCompileState args;
   if (!f.passInstance(callee.argTypes[0], &args)) {
@@ -5504,33 +5589,14 @@
     return true;
   }
 
-  uint32_t lineOrBytecode = f.readCallSiteLineOrBytecode();
-
-  const SymbolicAddressSignature& callee = SASigTableSize;
-  CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  MDefinition* tableIndexArg =
-      f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
-    return false;
-  }
-
-  MDefinition* ret;
-  if (!f.builtinInstanceMethodCall(callee, lineOrBytecode, args, &ret)) {
-    return false;
-  }
-
-  f.iter().setResult(ret);
+  const TableDesc& table = f.moduleEnv().tables[tableIndex];
+
+  MDefinition* length = f.loadTableLength(table);
+  if (!length) {
+    return false;
+  }
+
+  f.iter().setResult(length);
   return true;
 }
 
