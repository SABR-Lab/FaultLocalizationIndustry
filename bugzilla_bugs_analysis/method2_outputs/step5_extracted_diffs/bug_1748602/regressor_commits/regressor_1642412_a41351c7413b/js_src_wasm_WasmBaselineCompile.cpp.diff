# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBaselineCompile.cpp
# Commit: a41351c7413b
# Full Hash: a41351c7413bfac7319da4af8d7437d620f71da8
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2022-03-23 04:09:13
# Regressor Bug: 1642412
# File Overlap Count: 7
# Description:
#   Bug 1642412 - wasm: Implement a 'precise' post-write barrier in baseline. r=jseward
#   
#   Add a post-write barrier which will remove a previous store buffer entry if the
#   new value stored in the field would not require it. This requires the previous
#   value to be loaded before the store and propagated to the post-write barrier
# ==============================================================================

diff -r d190ffcf25bf -r a41351c7413b js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp	Tue Mar 22 19:59:06 2022 +0000
+++ b/js/src/wasm/WasmBaselineCompile.cpp	Tue Mar 22 19:59:06 2022 +0000
@@ -4290,7 +4290,8 @@
         RegRef rv = popRef();
         pushPtr(data);
         // emitBarrieredStore preserves exn, rv
-        if (!emitBarrieredStore(Some(exn), valueAddr, rv)) {
+        if (!emitBarrieredStore(Some(exn), valueAddr, rv,
+                                PostBarrierKind::Imprecise)) {
           return false;
         }
         popPtr(data);
@@ -5157,7 +5158,8 @@
       }
       RegRef rv = popRef();
       // emitBarrieredStore preserves rv
-      if (!emitBarrieredStore(Nothing(), valueAddr, rv)) {
+      if (!emitBarrieredStore(Nothing(), valueAddr, rv,
+                              PostBarrierKind::Imprecise)) {
         return false;
       }
       freeRef(rv);
@@ -5961,7 +5963,8 @@
   value = popRef();
 #endif
 
-  if (!emitBarrieredStore(Nothing(), valueAddr, value)) {
+  if (!emitBarrieredStore(Nothing(), valueAddr, value,
+                          PostBarrierKind::Precise)) {
     return false;
   }
   freeRef(value);
@@ -6012,8 +6015,8 @@
   masm.bind(&skipBarrier);
 }
 
-bool BaseCompiler::emitPostBarrier(const Maybe<RegRef>& object,
-                                   RegPtr valueAddr, RegRef value) {
+bool BaseCompiler::emitPostBarrierImprecise(const Maybe<RegRef>& object,
+                                            RegPtr valueAddr, RegRef value) {
   uint32_t bytecodeOffset = iter_.lastOpcodeOffset();
 
   // We must force a sync before the guard so that locals are in a consistent
@@ -6050,8 +6053,35 @@
   return true;
 }
 
+bool BaseCompiler::emitPostBarrierPrecise(const Maybe<RegRef>& object,
+                                          RegPtr valueAddr, RegRef prevValue, RegRef value) {
+  uint32_t bytecodeOffset = iter_.lastOpcodeOffset();
+
+  // Push `object` and `value` to preserve them across the call.
+  if (object) {
+    pushRef(*object);
+  }
+  pushRef(value);
+
+  // Push the arguments and call the precise post-barrier
+  pushPtr(valueAddr);
+  pushRef(prevValue);
+  if (!emitInstanceCall(bytecodeOffset, SASigPostBarrierPrecise)) {
+    return false;
+  }
+
+  // Restore `object` and `value`.
+  popRef(value);
+  if (object) {
+    popRef(*object);
+  }
+
+  return true;
+}
+
 bool BaseCompiler::emitBarrieredStore(const Maybe<RegRef>& object,
-                                      RegPtr valueAddr, RegRef value) {
+                                      RegPtr valueAddr, RegRef value,
+                                      PostBarrierKind kind) {
   // TODO/AnyRef-boxing: With boxed immediates and strings, the write
   // barrier is going to have to be more complicated.
   ASSERT_ANYREF_IS_JSOBJECT;
@@ -6059,11 +6089,22 @@
   // The pre-barrier preserves all allocated registers.
   emitPreBarrier(valueAddr);
 
+  // The precise post-barrier requires the previous value stored in the field,
+  // in order to know if the previous store buffer entry needs to be removed.
+  RegRef prevValue;
+  if (kind == PostBarrierKind::Precise) {
+    prevValue = needRef();
+    masm.loadPtr(Address(valueAddr, 0), prevValue);
+  }
+
   // Store the value
   masm.storePtr(value, Address(valueAddr, 0));
 
-  // The post-barrier preserves object, value, and consumes valueAddr.
-  return emitPostBarrier(object, valueAddr, value);
+  // The post-barrier preserves object and value.
+  if (kind == PostBarrierKind::Precise) {
+    return emitPostBarrierPrecise(object, valueAddr, prevValue, value);
+  }
+  return emitPostBarrierImprecise(object, valueAddr, value);
 }
 
 void BaseCompiler::emitBarrieredClear(RegPtr valueAddr) {
@@ -6265,7 +6306,8 @@
   pushPtr(data);
 
   // emitBarrieredStore preserves object and value
-  if (!emitBarrieredStore(Some(object), valueAddr, value.ref())) {
+  if (!emitBarrieredStore(Some(object), valueAddr, value.ref(),
+                          PostBarrierKind::Imprecise)) {
     return false;
   }
   freeRef(value.ref());
@@ -6316,7 +6358,8 @@
   pushI32(index);
 
   // emitBarrieredStore preserves object and value
-  if (!emitBarrieredStore(Some(object), valueAddr, value.ref())) {
+  if (!emitBarrieredStore(Some(object), valueAddr, value.ref(),
+                          PostBarrierKind::Imprecise)) {
     return false;
   }
 