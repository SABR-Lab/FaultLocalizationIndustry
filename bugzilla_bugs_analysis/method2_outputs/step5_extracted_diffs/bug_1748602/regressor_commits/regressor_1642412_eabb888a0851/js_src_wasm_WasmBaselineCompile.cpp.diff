# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBaselineCompile.cpp
# Commit: eabb888a0851
# Full Hash: eabb888a0851fe2eff0716214abfb55ae643cbba
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2022-03-24 21:54:20
# Regressor Bug: 1642412
# File Overlap Count: 2
# Description:
#   Bug 1642412 - wasm: Refactor the baseline post-write barrier out of the barriered store function. r=jseward
#   
#   The barriered store function emits the post-write barrier directly, but calls
#   out to a function for the pre-write barrier. We should factor the post-write
#   barrier out so that we can use a different post-write barrier implementation
# ==============================================================================

diff -r aaf8c5eef48e -r eabb888a0851 js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp	Thu Mar 24 17:56:51 2022 +0000
+++ b/js/src/wasm/WasmBaselineCompile.cpp	Thu Mar 24 17:56:52 2022 +0000
@@ -6012,48 +6012,35 @@
   masm.bind(&skipBarrier);
 }
 
-// This frees the register `valueAddr`.
-
-bool BaseCompiler::emitPostBarrierCall(RegPtr valueAddr) {
+bool BaseCompiler::emitPostBarrier(const Maybe<RegRef>& object,
+                                   RegPtr valueAddr, RegRef value) {
   uint32_t bytecodeOffset = iter_.lastOpcodeOffset();
 
-  // The `valueAddr` is a raw pointer to the cell within some GC object or
-  // TLS area, and we guarantee that the GC will not run while the
-  // postbarrier call is active, so push a uintptr_t value.
-  pushPtr(valueAddr);
-  return emitInstanceCall(bytecodeOffset, SASigPostBarrier);
-}
-
-// Emits a store to a JS object pointer at the address valueAddr, which is
-// inside the GC cell `object`. Preserves `object` and `value`.
-bool BaseCompiler::emitBarrieredStore(const Maybe<RegRef>& object,
-                                      RegPtr valueAddr, RegRef value) {
-  // TODO/AnyRef-boxing: With boxed immediates and strings, the write
-  // barrier is going to have to be more complicated.
-  ASSERT_ANYREF_IS_JSOBJECT;
-
-  emitPreBarrier(valueAddr);  // Preserves valueAddr
-  masm.storePtr(value, Address(valueAddr, 0));
-
+  // We must force a sync before the guard so that locals are in a consistent
+  // location for whether or not the post-barrier call is taken.
+  sync();
+
+  // Emit a guard to skip the post-barrier call if it is not needed.
   Label skipBarrier;
-  sync();
-
-  RegRef otherScratch = needRef();
+  RegPtr otherScratch = needPtr();
   EmitWasmPostBarrierGuard(masm, object, otherScratch, value, &skipBarrier);
-  freeRef(otherScratch);
-
+  freePtr(otherScratch);
+
+  // Push `object` and `value` to preserve them across the call.
   if (object) {
     pushRef(*object);
   }
   pushRef(value);
 
-  // Consumes valueAddr
-  if (!emitPostBarrierCall(valueAddr)) {
-    return false;
-  }
-
-  // Consume all other operands as they may have been clobbered by the post
-  // barrier call
+  // The `valueAddr` is a raw pointer to the cell within some GC object or
+  // TLS area, and we are careful so that the GC will not run while the
+  // post-barrier call is active, so push a uintptr_t value.
+  pushPtr(valueAddr);
+  if (!emitInstanceCall(bytecodeOffset, SASigPostBarrier)) {
+    return false;
+  }
+
+  // Restore `object` and `value`.
   popRef(value);
   if (object) {
     popRef(*object);
@@ -6063,15 +6050,34 @@
   return true;
 }
 
-// Emits a store of nullptr to a JS object pointer at the address valueAddr.
-// Preserves `valueAddr`.
+bool BaseCompiler::emitBarrieredStore(const Maybe<RegRef>& object,
+                                      RegPtr valueAddr, RegRef value) {
+  // TODO/AnyRef-boxing: With boxed immediates and strings, the write
+  // barrier is going to have to be more complicated.
+  ASSERT_ANYREF_IS_JSOBJECT;
+
+  // The pre-barrier preserves all allocated registers.
+  emitPreBarrier(valueAddr);
+
+  // Store the value
+  masm.storePtr(value, Address(valueAddr, 0));
+
+  // The post-barrier preserves object, value, and consumes valueAddr.
+  return emitPostBarrier(object, valueAddr, value);
+}
+
 void BaseCompiler::emitBarrieredClear(RegPtr valueAddr) {
   // TODO/AnyRef-boxing: With boxed immediates and strings, the write
   // barrier is going to have to be more complicated.
   ASSERT_ANYREF_IS_JSOBJECT;
 
-  emitPreBarrier(valueAddr);  // Preserves valueAddr
+  // The pre-barrier preserves all allocated registers.
+  emitPreBarrier(valueAddr);
+
+  // Store null
   masm.storePtr(ImmWord(0), Address(valueAddr, 0));
+
+  // No post-barrier is needed, as null does not require a store buffer entry
 }
 
 //////////////////////////////////////////////////////////////////////////////
