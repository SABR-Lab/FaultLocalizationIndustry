# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/basetypes/Accessible.cpp
# Commit: c0a7fdc4bfca
# Full Hash: c0a7fdc4bfca0596ffecd347f0e248440e371989
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2022-01-05 09:33:53
# Regressor Bug: 1737944
# File Overlap Count: 2
# Description:
#   Bug 1737944 - P5: Unify GetLevelInternal and GetDefaultLevel as Accessible::GetLevel. r=Jamie
#   
#   The nsAccUtils method was a "fast" one for calculating set sizes and
#   conceptual parents. Unified it with
#   LocalAccessible::GetLevelInternal in Accessible::GetLevel with an
# ==============================================================================

diff -r f6ce0e05c92e -r c0a7fdc4bfca accessible/basetypes/Accessible.cpp
--- a/accessible/basetypes/Accessible.cpp	Tue Jan 04 21:01:35 2022 +0000
+++ b/accessible/basetypes/Accessible.cpp	Tue Jan 04 21:01:36 2022 +0000
@@ -5,6 +5,7 @@
 
 #include "Accessible.h"
 #include "ARIAMap.h"
+#include "States.h"
 #include "mozilla/a11y/HyperTextAccessibleBase.h"
 
 using namespace mozilla;
@@ -77,3 +78,135 @@
       parent ? parent->AsHyperTextBase() : nullptr;
   return hyperText ? hyperText->GetChildOffset(this) : 0;
 }
+
+int32_t Accessible::GetLevel(bool aFast) const {
+  int32_t level = 0;
+  if (!Parent()) return level;
+
+  roles::Role role = Role();
+  if (role == roles::OUTLINEITEM) {
+    // Always expose 'level' attribute for 'outlineitem' accessible. The number
+    // of nested 'grouping' accessibles containing 'outlineitem' accessible is
+    // its level.
+    level = 1;
+
+    if (!aFast) {
+      const Accessible* parent = this;
+      while ((parent = parent->Parent())) {
+        roles::Role parentRole = parent->Role();
+
+        if (parentRole == roles::OUTLINE) break;
+        if (parentRole == roles::GROUPING) ++level;
+      }
+    }
+  } else if (role == roles::LISTITEM && !aFast) {
+    // Expose 'level' attribute on nested lists. We support two hierarchies:
+    // a) list -> listitem -> list -> listitem (nested list is a last child
+    //   of listitem of the parent list);
+    // b) list -> listitem -> group -> listitem (nested listitems are contained
+    //   by group that is a last child of the parent listitem).
+
+    // Calculate 'level' attribute based on number of parent listitems.
+    level = 0;
+    const Accessible* parent = this;
+    while ((parent = parent->Parent())) {
+      roles::Role parentRole = parent->Role();
+
+      if (parentRole == roles::LISTITEM) {
+        ++level;
+      } else if (parentRole != roles::LIST && parentRole != roles::GROUPING) {
+        break;
+      }
+    }
+
+    if (level == 0) {
+      // If this listitem is on top of nested lists then expose 'level'
+      // attribute.
+      parent = Parent();
+      uint32_t siblingCount = parent->ChildCount();
+      for (uint32_t siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
+        Accessible* sibling = parent->ChildAt(siblingIdx);
+
+        Accessible* siblingChild = sibling->LastChild();
+        if (siblingChild) {
+          roles::Role lastChildRole = siblingChild->Role();
+          if (lastChildRole == roles::LIST ||
+              lastChildRole == roles::GROUPING) {
+            return 1;
+          }
+        }
+      }
+    } else {
+      ++level;  // level is 1-index based
+    }
+  } else if (role == roles::OPTION || role == roles::COMBOBOX_OPTION) {
+    if (const Accessible* parent = Parent()) {
+      if (parent->IsHTMLOptGroup()) {
+        return 2;
+      }
+
+      if (parent->IsListControl() && !parent->ARIARoleMap()) {
+        // This is for HTML selects only.
+        if (aFast) {
+          return 1;
+        }
+
+        for (Accessible* child = parent->FirstChild(); child;
+             child = child->NextSibling()) {
+          if (child->IsHTMLOptGroup()) {
+            return 1;
+          }
+        }
+      }
+    }
+  } else if (role == roles::HEADING) {
+    nsAtom* tagName = TagName();
+    if (tagName == nsGkAtoms::h1) {
+      return 1;
+    }
+    if (tagName == nsGkAtoms::h2) {
+      return 2;
+    }
+    if (tagName == nsGkAtoms::h3) {
+      return 3;
+    }
+    if (tagName == nsGkAtoms::h4) {
+      return 4;
+    }
+    if (tagName == nsGkAtoms::h5) {
+      return 5;
+    }
+    if (tagName == nsGkAtoms::h6) {
+      return 6;
+    }
+
+    const nsRoleMapEntry* ariaRole = this->ARIARoleMap();
+    if (ariaRole && ariaRole->Is(nsGkAtoms::heading)) {
+      // An aria heading with no aria level has a default level of 2.
+      return 2;
+    }
+  } else if (role == roles::COMMENT) {
+    // For comments, count the ancestor elements with the same role to get the
+    // level.
+    level = 1;
+
+    if (!aFast) {
+      const Accessible* parent = this;
+      while ((parent = parent->Parent())) {
+        roles::Role parentRole = parent->Role();
+        if (parentRole == roles::COMMENT) {
+          ++level;
+        }
+      }
+    }
+  } else if (role == roles::ROW) {
+    // It is a row inside flatten treegrid. Group level is always 1 until it
+    // is overriden by aria-level attribute.
+    const Accessible* parent = Parent();
+    if (parent->Role() == roles::TREE_TABLE) {
+      return 1;
+    }
+  }
+
+  return level;
+}