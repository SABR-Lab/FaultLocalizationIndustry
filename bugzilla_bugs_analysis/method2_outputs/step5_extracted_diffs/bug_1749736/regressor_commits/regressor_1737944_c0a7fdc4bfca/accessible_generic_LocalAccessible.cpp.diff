# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/LocalAccessible.cpp
# Commit: c0a7fdc4bfca
# Full Hash: c0a7fdc4bfca0596ffecd347f0e248440e371989
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2022-01-05 09:33:53
# Regressor Bug: 1737944
# File Overlap Count: 2
# Description:
#   Bug 1737944 - P5: Unify GetLevelInternal and GetDefaultLevel as Accessible::GetLevel. r=Jamie
#   
#   The nsAccUtils method was a "fast" one for calculating set sizes and
#   conceptual parents. Unified it with
#   LocalAccessible::GetLevelInternal in Accessible::GetLevel with an
# ==============================================================================

diff -r f6ce0e05c92e -r c0a7fdc4bfca accessible/generic/LocalAccessible.cpp
--- a/accessible/generic/LocalAccessible.cpp	Tue Jan 04 21:01:35 2022 +0000
+++ b/accessible/generic/LocalAccessible.cpp	Tue Jan 04 21:01:36 2022 +0000
@@ -1467,7 +1467,7 @@
 
   // Calculate group level if ARIA is missed.
   if (groupPos.level == 0) {
-    int32_t level = GetLevelInternal();
+    int32_t level = GetLevel(false);
     if (level != 0) {
       groupPos.level = level;
     } else {
@@ -3318,83 +3318,6 @@
   }
 }
 
-int32_t LocalAccessible::GetLevelInternal() {
-  int32_t level = nsAccUtils::GetDefaultLevel(this);
-
-  if (!IsBoundToParent()) return level;
-
-  roles::Role role = Role();
-  if (role == roles::OUTLINEITEM) {
-    // Always expose 'level' attribute for 'outlineitem' accessible. The number
-    // of nested 'grouping' accessibles containing 'outlineitem' accessible is
-    // its level.
-    level = 1;
-
-    LocalAccessible* parent = this;
-    while ((parent = parent->LocalParent())) {
-      roles::Role parentRole = parent->Role();
-
-      if (parentRole == roles::OUTLINE) break;
-      if (parentRole == roles::GROUPING) ++level;
-    }
-
-  } else if (role == roles::LISTITEM) {
-    // Expose 'level' attribute on nested lists. We support two hierarchies:
-    // a) list -> listitem -> list -> listitem (nested list is a last child
-    //   of listitem of the parent list);
-    // b) list -> listitem -> group -> listitem (nested listitems are contained
-    //   by group that is a last child of the parent listitem).
-
-    // Calculate 'level' attribute based on number of parent listitems.
-    level = 0;
-    LocalAccessible* parent = this;
-    while ((parent = parent->LocalParent())) {
-      roles::Role parentRole = parent->Role();
-
-      if (parentRole == roles::LISTITEM) {
-        ++level;
-      } else if (parentRole != roles::LIST && parentRole != roles::GROUPING) {
-        break;
-      }
-    }
-
-    if (level == 0) {
-      // If this listitem is on top of nested lists then expose 'level'
-      // attribute.
-      parent = LocalParent();
-      uint32_t siblingCount = parent->ChildCount();
-      for (uint32_t siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
-        LocalAccessible* sibling = parent->LocalChildAt(siblingIdx);
-
-        LocalAccessible* siblingChild = sibling->LocalLastChild();
-        if (siblingChild) {
-          roles::Role lastChildRole = siblingChild->Role();
-          if (lastChildRole == roles::LIST ||
-              lastChildRole == roles::GROUPING) {
-            return 1;
-          }
-        }
-      }
-    } else {
-      ++level;  // level is 1-index based
-    }
-  } else if (role == roles::COMMENT) {
-    // For comments, count the ancestor elements with the same role to get the
-    // level.
-    level = 1;
-
-    LocalAccessible* parent = this;
-    while ((parent = parent->LocalParent())) {
-      roles::Role parentRole = parent->Role();
-      if (parentRole == roles::COMMENT) {
-        ++level;
-      }
-    }
-  }
-
-  return level;
-}
-
 nsAtom* LocalAccessible::TagName() const {
   return mContent && mContent->IsElement() ? mContent->NodeInfo()->NameAtom()
                                            : nullptr;