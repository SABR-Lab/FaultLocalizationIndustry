# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/AccGroupInfo.cpp
# Commit: fca1ff7eabf4
# Full Hash: fca1ff7eabf4ddfca60184253136535d2285488d
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2022-01-05 09:33:53
# Regressor Bug: 1737944
# File Overlap Count: 2
# Description:
#   Bug 1737944 - P6: Put AccGroupInfo getter/creator in Accessible. r=Jamie
#   
#   Changed the methods a bit, instead of a HasDirty boolean method, I went
#   with a getter and a get-and-creator. This will lend better to remote
#   accessibles where we won't have a dirty flag.
# ==============================================================================

diff -r c0a7fdc4bfca -r fca1ff7eabf4 accessible/base/AccGroupInfo.cpp
--- a/accessible/base/AccGroupInfo.cpp	Tue Jan 04 21:01:36 2022 +0000
+++ b/accessible/base/AccGroupInfo.cpp	Tue Jan 04 21:01:36 2022 +0000
@@ -45,11 +45,11 @@
     if (BaseRole(siblingRole) != mRole) {
       continue;
     }
-    bool siblingHasGroupInfo =
-        sibling->mBits.groupInfo && !sibling->HasDirtyGroupInfo();
+
+    AccGroupInfo* siblingGroupInfo = sibling->GetGroupInfo();
     // Skip invisible siblings.
     // If the sibling has calculated group info, that means it's visible.
-    if (!siblingHasGroupInfo && sibling->State() & states::INVISIBLE) {
+    if (!siblingGroupInfo && sibling->State() & states::INVISIBLE) {
       continue;
     }
 
@@ -68,10 +68,10 @@
 
     // If the previous item in the group has calculated group information then
     // build group information for this item based on found one.
-    if (siblingHasGroupInfo) {
-      mPosInSet += sibling->mBits.groupInfo->mPosInSet;
-      mParent = sibling->mBits.groupInfo->mParent;
-      mSetSize = sibling->mBits.groupInfo->mSetSize;
+    if (siblingGroupInfo) {
+      mPosInSet += siblingGroupInfo->mPosInSet;
+      mParent = siblingGroupInfo->mParent;
+      mSetSize = siblingGroupInfo->mSetSize;
       return;
     }
 
@@ -92,11 +92,10 @@
     if (BaseRole(siblingRole) != mRole) {
       continue;
     }
-    bool siblingHasGroupInfo =
-        sibling->mBits.groupInfo && !sibling->HasDirtyGroupInfo();
+    AccGroupInfo* siblingGroupInfo = sibling->GetGroupInfo();
     // Skip invisible siblings.
     // If the sibling has calculated group info, that means it's visible.
-    if (!siblingHasGroupInfo && sibling->State() & states::INVISIBLE) {
+    if (!siblingGroupInfo && sibling->State() & states::INVISIBLE) {
       continue;
     }
 
@@ -109,9 +108,9 @@
 
     // If the next item in the group has calculated group information then
     // build group information for this item based on found one.
-    if (siblingHasGroupInfo) {
-      mParent = sibling->mBits.groupInfo->mParent;
-      mSetSize = sibling->mBits.groupInfo->mSetSize;
+    if (siblingGroupInfo) {
+      mParent = siblingGroupInfo->mParent;
+      mSetSize = siblingGroupInfo->mSetSize;
       return;
     }
 
@@ -183,7 +182,7 @@
     }
 
     if (item) {
-      AccGroupInfo* itemGroupInfo = item->GetGroupInfo();
+      AccGroupInfo* itemGroupInfo = item->GetOrCreateGroupInfo();
       if (itemGroupInfo && itemGroupInfo->ConceptualParent() == aContainer) {
         return item;
       }
@@ -200,7 +199,7 @@
        containerRole == roles::OUTLINEITEM)) {
     item = item->LocalFirstChild();
     if (item) {
-      AccGroupInfo* itemGroupInfo = item->GetGroupInfo();
+      AccGroupInfo* itemGroupInfo = item->GetOrCreateGroupInfo();
       if (itemGroupInfo && itemGroupInfo->ConceptualParent() == aContainer) {
         return item;
       }
@@ -293,7 +292,7 @@
   uint32_t childCount = parent->ChildCount();
   for (uint32_t idx = aItem->IndexInParent() + 1; idx < childCount; idx++) {
     LocalAccessible* nextItem = parent->LocalChildAt(idx);
-    AccGroupInfo* nextGroupInfo = nextItem->GetGroupInfo();
+    AccGroupInfo* nextGroupInfo = nextItem->GetOrCreateGroupInfo();
     if (nextGroupInfo &&
         nextGroupInfo->ConceptualParent() == groupInfo->ConceptualParent()) {
       return nextItem;