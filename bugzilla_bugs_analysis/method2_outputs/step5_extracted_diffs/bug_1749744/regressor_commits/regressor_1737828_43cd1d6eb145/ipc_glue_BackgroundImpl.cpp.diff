# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: ipc/glue/BackgroundImpl.cpp
# Commit: 43cd1d6eb145
# Full Hash: 43cd1d6eb1459ae16207f4c9396cf5113a7b034a
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2022-01-11 03:49:34
# Regressor Bug: 1737828
# File Overlap Count: 2
# Description:
#   Bug 1737828 - Avoid the main thread when starting PBackground, r=asuth,ipc-reviewers,necko-reviewers,kershaw,handyman
#   
#   This patch avoids requiring the main thread to create PBackground instances by
#   instead using a background starter TaskQueue, and sending messages from a
#   PBackgroundStarter actor hosted on that thread to the target background thread
# ==============================================================================

diff -r 400d19ddbff7 -r 43cd1d6eb145 ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp	Mon Jan 10 19:44:23 2022 +0000
+++ b/ipc/glue/BackgroundImpl.cpp	Mon Jan 10 20:09:14 2022 +0000
@@ -9,6 +9,7 @@
 
 #include "BackgroundChildImpl.h"
 #include "BackgroundParentImpl.h"
+#include "MainThreadUtils.h"
 #include "base/process_util.h"
 #include "base/task.h"
 #include "FileDescriptor.h"
@@ -28,7 +29,10 @@
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerRef.h"
+#include "mozilla/ipc/BackgroundStarterChild.h"
+#include "mozilla/ipc/BackgroundStarterParent.h"
 #include "mozilla/ipc/Endpoint.h"
+#include "mozilla/ipc/PBackgroundStarter.h"
 #include "mozilla/ipc/ProtocolTypes.h"
 #include "mozilla/net/SocketProcessChild.h"
 #include "mozilla/net/SocketProcessBridgeChild.h"
@@ -77,32 +81,30 @@
 // Utility Functions
 // -----------------------------------------------------------------------------
 
-void AssertIsInMainProcess() { MOZ_ASSERT(XRE_IsParentProcess()); }
-
 void AssertIsInMainOrSocketProcess() {
   MOZ_ASSERT(XRE_IsParentProcess() || XRE_IsSocketProcess());
 }
 
 void AssertIsOnMainThread() { THREADSAFETY_ASSERT(NS_IsMainThread()); }
 
-void AssertIsNotOnMainThread() { THREADSAFETY_ASSERT(!NS_IsMainThread()); }
-
 // -----------------------------------------------------------------------------
 // ParentImpl Declaration
 // -----------------------------------------------------------------------------
 
 class ParentImpl final : public BackgroundParentImpl {
+  friend class ChildImpl;
   friend class mozilla::ipc::BackgroundParent;
+  friend class mozilla::ipc::BackgroundStarterParent;
 
  private:
   class ShutdownObserver;
-  class CreateActorHelper;
 
   struct MOZ_STACK_CLASS TimerCallbackClosure {
     nsIThread* mThread;
-    nsTArray<ParentImpl*>* mLiveActors;
+    nsTArray<IToplevelProtocol*>* mLiveActors;
 
-    TimerCallbackClosure(nsIThread* aThread, nsTArray<ParentImpl*>* aLiveActors)
+    TimerCallbackClosure(nsIThread* aThread,
+                         nsTArray<IToplevelProtocol*>* aLiveActors)
         : mThread(aThread), mLiveActors(aLiveActors) {
       AssertIsInMainOrSocketProcess();
       AssertIsOnMainThread();
@@ -121,7 +123,7 @@
 
   // This is created and destroyed on the main thread but only modified on the
   // background thread. It is specific to each instance of sBackgroundThread.
-  static nsTArray<ParentImpl*>* sLiveActorsForBackgroundThread;
+  static nsTArray<IToplevelProtocol*>* sLiveActorsForBackgroundThread;
 
   // This is only modified on the main thread.
   static StaticRefPtr<nsITimer> sShutdownTimer;
@@ -130,10 +132,11 @@
   // work during shutdown.
   static Atomic<PRThread*> sBackgroundPRThread;
 
-  // This is only modified on the main thread. It maintains a count of live
-  // actors so that the background thread can be shut down when it is no longer
-  // needed.
-  static uint64_t sLiveActorCount;
+  // Maintains a count of live actors so that the background thread can be shut
+  // down when it is no longer needed.
+  // May be incremented on either the background thread (by an existing actor)
+  // or on the main thread, but must be decremented on the main thread.
+  static Atomic<uint64_t> sLiveActorCount;
 
   // This is only modified on the main thread. It is true after the shutdown
   // observer is registered and is never unset thereafter.
@@ -148,7 +151,7 @@
 
   // Set when the actor is opened successfully and used to handle shutdown
   // hangs. Only touched on the background thread.
-  nsTArray<ParentImpl*>* mLiveActorArray;
+  nsTArray<IToplevelProtocol*>* mLiveActorArray;
 
   // Set at construction to indicate whether this parent actor corresponds to a
   // child actor in another process or to a child actor from a different thread
@@ -160,9 +163,6 @@
   bool mActorDestroyed;
 
  public:
-  static already_AddRefed<ChildImpl> CreateActorForSameProcess(
-      nsIEventTarget* aMainEventTarget);
-
   static bool IsOnBackgroundThread() {
     return PR_GetCurrentThread() == sBackgroundPRThread;
   }
@@ -171,10 +171,9 @@
     THREADSAFETY_ASSERT(IsOnBackgroundThread());
   }
 
-  // `ParentImpl` instances are created and need to be deleted on the main
-  // thread, despite IPC controlling them on a background thread. Use
-  // `_WITH_DELETE_ON_MAIN_THREAD` to force destruction to occur on the desired
-  // thread.
+  // `ParentImpl` instances need to be deleted on the main thread, despite IPC
+  // controlling them on a background thread. Use `_WITH_DELETE_ON_MAIN_THREAD`
+  // to force destruction to occur on the desired thread.
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DELETE_ON_MAIN_THREAD(ParentImpl,
                                                                    override)
 
@@ -196,12 +195,9 @@
   static uint64_t GetChildID(PBackgroundParent* aBackgroundActor);
 
   // Forwarded from BackgroundParent.
-  static bool GetLiveActorArray(PBackgroundParent* aBackgroundActor,
-                                nsTArray<PBackgroundParent*>& aLiveActorArray);
-
-  // Forwarded from BackgroundParent.
-  static bool Alloc(ContentParent* aContent,
-                    Endpoint<PBackgroundParent>&& aEndpoint);
+  static bool AllocStarter(ContentParent* aContent,
+                           Endpoint<PBackgroundStarterParent>&& aEndpoint,
+                           bool aCrossProcess = true);
 
   static bool CreateBackgroundThread();
 
@@ -209,28 +205,20 @@
 
   static void ShutdownTimerCallback(nsITimer* aTimer, void* aClosure);
 
-  // For same-process actors.
-  ParentImpl()
-      : mLiveActorArray(nullptr),
-        mIsOtherProcessActor(false),
-        mActorDestroyed(false) {
-    AssertIsInMainProcess();
-    AssertIsOnMainThread();
-  }
-
-  // For other-process actors.
-  // NOTE: ParentImpl could be used in 3 cases below.
-  // 1. Between parent process and content process.
-  // 2. Between socket process and content process.
-  // 3. Between parent process and socket process.
-  // |mContent| should be not null for case 1. For case 2 and 3, it's null.
-  explicit ParentImpl(ContentParent* aContent)
-      : mContent(aContent),
+  // NOTE: ParentImpl could be used in 4 cases below.
+  // 1. Within the parent process.
+  // 2. Between parent process and content process.
+  // 3. Between socket process and content process.
+  // 4. Between parent process and socket process.
+  // |aContent| should be not null for case 2. For cases 1, 3 and 4, it's null.
+  explicit ParentImpl(already_AddRefed<ContentParent>&& aContent,
+                      bool aIsOtherProcessActor)
+      : mContent(std::move(aContent)),
         mLiveActorArray(nullptr),
-        mIsOtherProcessActor(true),
+        mIsOtherProcessActor(aIsOtherProcessActor),
         mActorDestroyed(false) {
     MOZ_ASSERT(XRE_IsParentProcess() || XRE_IsSocketProcess());
-    AssertIsOnMainThread();
+    MOZ_ASSERT_IF(!aIsOtherProcessActor, XRE_IsParentProcess());
   }
 
   ~ParentImpl() {
@@ -241,7 +229,7 @@
 
   void MainThreadActorDestroy();
 
-  void SetLiveActorArray(nsTArray<ParentImpl*>* aLiveActorArray) {
+  void SetLiveActorArray(nsTArray<IToplevelProtocol*>* aLiveActorArray) {
     AssertIsInMainOrSocketProcess();
     AssertIsOnBackgroundThread();
     MOZ_ASSERT(aLiveActorArray);
@@ -264,6 +252,7 @@
 class ChildImpl final : public BackgroundChildImpl {
   friend class mozilla::ipc::BackgroundChild;
   friend class mozilla::ipc::BackgroundChildImpl;
+  friend class mozilla::ipc::BackgroundStarterChild;
 
   typedef base::ProcessId ProcessId;
   typedef mozilla::ipc::Transport Transport;
@@ -271,8 +260,6 @@
   class ShutdownObserver;
 
  public:
-  class SendInitBackgroundRunnable;
-
   struct ThreadLocalInfo {
     ThreadLocalInfo()
 #ifdef DEBUG
@@ -282,7 +269,6 @@
     }
 
     RefPtr<ChildImpl> mActor;
-    RefPtr<SendInitBackgroundRunnable> mSendInitBackgroundRunnable;
     UniquePtr<BackgroundChildImpl::ThreadLocal> mConsumerThreadLocal;
 #ifdef DEBUG
     bool mClosed;
@@ -303,10 +289,7 @@
     using ActorCreateFunc = void (*)(ThreadLocalInfo*, unsigned int,
                                      nsIEventTarget*, ChildImpl**);
 
-    constexpr explicit ThreadInfoWrapper(ActorCreateFunc aFunc)
-        : mThreadLocalIndex(kBadThreadLocalIndex),
-          mMainThreadInfo(nullptr),
-          mCreateActorFunc(aFunc) {}
+    ThreadInfoWrapper() = default;
 
     void Startup() {
       MOZ_ASSERT(mThreadLocalIndex == kBadThreadLocalIndex,
@@ -331,6 +314,24 @@
         return;
       }
 
+      nsCOMPtr<nsISerialEventTarget> starterQueue;
+      {
+        auto lock = mStarterInfo.Lock();
+        starterQueue = lock->mTaskQueue.forget();
+        lock->mOtherPid = base::kInvalidProcessId;
+      }
+
+      if (starterQueue) {
+        starterQueue->Dispatch(
+            NS_NewRunnableFunction("PBackgroundStarterChild Close", [this] {
+              MOZ_ASSERT(mStarter);
+              if (mStarter) {
+                mStarter->Close();
+              }
+              mStarter = nullptr;
+            }));
+      }
+
       ThreadLocalInfo* threadLocalInfo;
 #ifdef DEBUG
       threadLocalInfo =
@@ -350,6 +351,40 @@
       }
     }
 
+    template <typename Actor>
+    void InitStarter(Actor* aActor) {
+      AssertIsOnMainThread();
+
+      // Create a pair of endpoints and send them to the other process.
+      Endpoint<PBackgroundStarterParent> parent;
+      Endpoint<PBackgroundStarterChild> child;
+      MOZ_ALWAYS_SUCCEEDS(PBackgroundStarter::CreateEndpoints(
+          aActor->OtherPid(), base::GetCurrentProcId(), &parent, &child));
+      MOZ_ALWAYS_TRUE(aActor->SendInitBackground(std::move(parent)));
+
+      InitStarter(std::move(child));
+    }
+
+    void InitStarter(Endpoint<PBackgroundStarterChild>&& aEndpoint) {
+      AssertIsOnMainThread();
+
+      base::ProcessId otherPid = aEndpoint.OtherPid();
+      nsCOMPtr<nsISerialEventTarget> taskQueue;
+      MOZ_ALWAYS_SUCCEEDS(NS_CreateBackgroundTaskQueue(
+          "PBackgroundStarter Queue", getter_AddRefs(taskQueue)));
+      taskQueue->Dispatch(NS_NewRunnableFunction(
+          "PBackgroundStarterChild Init",
+          [this, endpoint = std::move(aEndpoint)]() mutable {
+            mStarter = new BackgroundStarterChild();
+            MOZ_ALWAYS_TRUE(endpoint.Bind(mStarter));
+          }));
+
+      auto lock = mStarterInfo.Lock();
+      MOZ_RELEASE_ASSERT(!lock->mTaskQueue);
+      lock->mTaskQueue = taskQueue;
+      lock->mOtherPid = otherPid;
+    }
+
     void CloseForCurrentThread() {
       MOZ_ASSERT(!NS_IsMainThread());
 
@@ -357,7 +392,7 @@
         return;
       }
 
-      auto threadLocalInfo =
+      auto* threadLocalInfo =
           static_cast<ThreadLocalInfo*>(PR_GetThreadPrivate(mThreadLocalIndex));
 
       if (!threadLocalInfo) {
@@ -375,10 +410,7 @@
       MOZ_ASSERT(status == PR_SUCCESS);
     }
 
-    PBackgroundChild* GetOrCreateForCurrentThread(
-        nsIEventTarget* aMainEventTarget) {
-      MOZ_ASSERT_IF(NS_IsMainThread(), !aMainEventTarget);
-
+    PBackgroundChild* GetOrCreateForCurrentThread() {
       // Processes can be told to do final CC's during shutdown even though
       // they never finished starting (and thus call this), because they
       // hadn't gotten far enough to call Startup() before shutdown began.
@@ -390,10 +422,10 @@
         return nullptr;
       }
 
-      auto threadLocalInfo = NS_IsMainThread()
-                                 ? mMainThreadInfo
-                                 : static_cast<ThreadLocalInfo*>(
-                                       PR_GetThreadPrivate(mThreadLocalIndex));
+      auto* threadLocalInfo = NS_IsMainThread()
+                                  ? mMainThreadInfo
+                                  : static_cast<ThreadLocalInfo*>(
+                                        PR_GetThreadPrivate(mThreadLocalIndex));
 
       if (!threadLocalInfo) {
         auto newInfo = MakeUnique<ThreadLocalInfo>();
@@ -411,28 +443,75 @@
         threadLocalInfo = newInfo.release();
       }
 
-      PBackgroundChild* bgChild =
-          GetFromThreadInfo(aMainEventTarget, threadLocalInfo);
-      if (bgChild) {
-        return bgChild;
+      if (threadLocalInfo->mActor) {
+        return threadLocalInfo->mActor;
+      }
+
+      base::ProcessId otherPid = base::kInvalidProcessId;
+      nsCOMPtr<nsISerialEventTarget> starterQueue;
+      {
+        auto lock = mStarterInfo.Lock();
+        otherPid = lock->mOtherPid;
+        starterQueue = lock->mTaskQueue;
+      }
+
+      if (!starterQueue) {
+        CRASH_IN_CHILD_PROCESS("No BackgroundStarterChild");
+        return nullptr;
       }
 
-      RefPtr<ChildImpl> actor;
-      mCreateActorFunc(threadLocalInfo, mThreadLocalIndex, aMainEventTarget,
-                       getter_AddRefs(actor));
-      return actor;
+      Endpoint<PBackgroundParent> parent;
+      Endpoint<PBackgroundChild> child;
+      nsresult rv;
+      rv = PBackground::CreateEndpoints(otherPid, base::GetCurrentProcId(),
+                                        &parent, &child);
+      if (NS_FAILED(rv)) {
+        NS_WARNING("Failed to create top level actor!");
+        return nullptr;
+      }
+
+      RefPtr<ChildImpl> strongActor = new ChildImpl();
+      if (!child.Bind(strongActor)) {
+        CRASH_IN_CHILD_PROCESS("Failed to bind ChildImpl!");
+        return nullptr;
+      }
+      strongActor->SetActorAlive();
+      threadLocalInfo->mActor = strongActor;
+
+      // Dispatch to the background task queue to create the relevant actor in
+      // the remote process.
+      starterQueue->Dispatch(NS_NewRunnableFunction(
+          "PBackground GetOrCreateForCurrentThread",
+          [this, endpoint = std::move(parent)]() mutable {
+            if (!mStarter ||
+                !mStarter->SendInitBackground(std::move(endpoint))) {
+              NS_WARNING("Failed to create toplevel actor");
+            }
+          }));
+      return strongActor;
     }
 
    private:
     // This is only modified on the main thread. It is the thread-local index
     // that we use to store the BackgroundChild for each thread.
-    unsigned int mThreadLocalIndex;
+    unsigned int mThreadLocalIndex = kBadThreadLocalIndex;
 
     // On the main thread, we store TLS in this global instead of in
     // mThreadLocalIndex. That way, cooperative main threads all share the same
     // thread info.
-    ThreadLocalInfo* mMainThreadInfo;
-    ActorCreateFunc mCreateActorFunc;
+    ThreadLocalInfo* mMainThreadInfo = nullptr;
+
+    // Only modified on the starter task queue.
+    StaticRefPtr<BackgroundStarterChild> mStarter;
+
+    // The starter task queue and other process ID which will be used to launch
+    // processes of this type. Only modified on the main thread, but may be read
+    // by any thread wanting to start background actors.
+    struct StarterInfo {
+      base::ProcessId mOtherPid = base::kInvalidProcessId;
+      StaticRefPtr<nsISerialEventTarget> mTaskQueue;
+    };
+    StaticDataMutex<StarterInfo> mStarterInfo{"mStarterInfo"};
   };
 
   // For PBackground between parent and content process.
@@ -509,27 +588,30 @@
   // Forwarded from BackgroundChild.
   static PBackgroundChild* GetForCurrentThread();
 
-  // Helper function for getting PBackgroundChild from thread info.
-  static PBackgroundChild* GetFromThreadInfo(nsIEventTarget* aMainEventTarget,
-                                             ThreadLocalInfo* aThreadLocalInfo);
+  // Forwarded from BackgroundChild.
+  static PBackgroundChild* GetOrCreateForCurrentThread();
 
   // Forwarded from BackgroundChild.
-  static PBackgroundChild* GetOrCreateForCurrentThread(
-      nsIEventTarget* aMainEventTarget);
+  static PBackgroundChild* GetOrCreateSocketActorForCurrentThread();
 
   // Forwarded from BackgroundChild.
-  static PBackgroundChild* GetOrCreateSocketActorForCurrentThread(
-      nsIEventTarget* aMainEventTarget);
-
-  // Forwarded from BackgroundChild.
-  static PBackgroundChild* GetOrCreateForSocketParentBridgeForCurrentThread(
-      nsIEventTarget* aMainEventTarget);
+  static PBackgroundChild* GetOrCreateForSocketParentBridgeForCurrentThread();
 
   static void CloseForCurrentThread();
 
   // Forwarded from BackgroundChildImpl.
   static BackgroundChildImpl::ThreadLocal* GetThreadLocalForCurrentThread();
 
+  // Forwarded from BackgroundChild.
+  static void InitContentStarter(mozilla::dom::ContentChild* aContent);
+
+  // Forwarded from BackgroundChild.
+  static void InitSocketStarter(mozilla::net::SocketProcessChild* aSocket);
+
+  // Forwarded from BackgroundChild.
+  static void InitSocketBridgeStarter(
+      mozilla::net::SocketProcessBridgeChild* aSocketBridge);
+
   static void ThreadLocalDestructor(void* aThreadLocal);
 
   // This class is reference counted.
@@ -554,35 +636,6 @@
   ~ShutdownObserver() { AssertIsOnMainThread(); }
 };
 
-class ParentImpl::CreateActorHelper final : public Runnable {
-  mozilla::Monitor mMonitor;
-  RefPtr<ParentImpl> mParentActor;
-  nsCOMPtr<nsIThread> mThread;
-  nsresult mMainThreadResultCode;
-  bool mWaiting;
-
- public:
-  explicit CreateActorHelper()
-      : Runnable("Background::ParentImpl::CreateActorHelper"),
-        mMonitor("CreateActorHelper::mMonitor"),
-        mMainThreadResultCode(NS_OK),
-        mWaiting(true) {
-    AssertIsInMainOrSocketProcess();
-    AssertIsNotOnMainThread();
-  }
-
-  nsresult BlockAndGetResults(nsIEventTarget* aMainEventTarget,
-                              RefPtr<ParentImpl>& aParentActor,
-                              nsCOMPtr<nsIThread>& aThread);
-
- private:
-  ~CreateActorHelper() { AssertIsInMainOrSocketProcess(); }
-
-  nsresult RunOnMainThread();
-
-  NS_DECL_NSIRUNNABLE
-};
-
 // -----------------------------------------------------------------------------
 // ChildImpl Helper Declarations
 // -----------------------------------------------------------------------------
@@ -598,47 +651,6 @@
   ~ShutdownObserver() { AssertIsOnMainThread(); }
 };
 
-class ChildImpl::SendInitBackgroundRunnable final : public DiscardableRunnable {
-  nsCOMPtr<nsISerialEventTarget> mOwningEventTarget;
-  RefPtr<StrongWorkerRef> mWorkerRef;
-  Endpoint<PBackgroundParent> mParent;
-  mozilla::Mutex mMutex;
-  bool mSentInitBackground;
-  std::function<void(Endpoint<PBackgroundParent>&& aParent)> mSendInitfunc;
-  unsigned int mThreadLocalIndex;
-
- public:
-  static already_AddRefed<SendInitBackgroundRunnable> Create(
-      Endpoint<PBackgroundParent>&& aParent,
-      std::function<void(Endpoint<PBackgroundParent>&& aParent)>&& aFunc,
-      unsigned int aThreadLocalIndex);
-
-  void ClearEventTarget() {
-    mWorkerRef = nullptr;
-
-    mozilla::MutexAutoLock lock(mMutex);
-    mOwningEventTarget = nullptr;
-  }
-
- private:
-  explicit SendInitBackgroundRunnable(
-      Endpoint<PBackgroundParent>&& aParent,
-      std::function<void(Endpoint<PBackgroundParent>&& aParent)>&& aFunc,
-      unsigned int aThreadLocalIndex)
-      : DiscardableRunnable(
-            "Background::ChildImpl::SendInitBackgroundRunnable"),
-        mOwningEventTarget(GetCurrentSerialEventTarget()),
-        mParent(std::move(aParent)),
-        mMutex("SendInitBackgroundRunnable::mMutex"),
-        mSentInitBackground(false),
-        mSendInitfunc(std::move(aFunc)),
-        mThreadLocalIndex(aThreadLocalIndex) {}
-
-  ~SendInitBackgroundRunnable() = default;
-
-  NS_DECL_NSIRUNNABLE
-};
-
 }  // namespace
 
 namespace mozilla {
@@ -683,16 +695,9 @@
 }
 
 // static
-bool BackgroundParent::GetLiveActorArray(
-    PBackgroundParent* aBackgroundActor,
-    nsTArray<PBackgroundParent*>& aLiveActorArray) {
-  return ParentImpl::GetLiveActorArray(aBackgroundActor, aLiveActorArray);
-}
-
-// static
-bool BackgroundParent::Alloc(ContentParent* aContent,
-                             Endpoint<PBackgroundParent>&& aEndpoint) {
-  return ParentImpl::Alloc(aContent, std::move(aEndpoint));
+bool BackgroundParent::AllocStarter(
+    ContentParent* aContent, Endpoint<PBackgroundStarterParent>&& aEndpoint) {
+  return ParentImpl::AllocStarter(aContent, std::move(aEndpoint));
 }
 
 // -----------------------------------------------------------------------------
@@ -708,23 +713,19 @@
 }
 
 // static
-PBackgroundChild* BackgroundChild::GetOrCreateForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return ChildImpl::GetOrCreateForCurrentThread(aMainEventTarget);
+PBackgroundChild* BackgroundChild::GetOrCreateForCurrentThread() {
+  return ChildImpl::GetOrCreateForCurrentThread();
 }
 
 // static
-PBackgroundChild* BackgroundChild::GetOrCreateSocketActorForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return ChildImpl::GetOrCreateSocketActorForCurrentThread(aMainEventTarget);
+PBackgroundChild* BackgroundChild::GetOrCreateSocketActorForCurrentThread() {
+  return ChildImpl::GetOrCreateSocketActorForCurrentThread();
 }
 
 // static
 PBackgroundChild*
-BackgroundChild::GetOrCreateForSocketParentBridgeForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return ChildImpl::GetOrCreateForSocketParentBridgeForCurrentThread(
-      aMainEventTarget);
+BackgroundChild::GetOrCreateForSocketParentBridgeForCurrentThread() {
+  return ChildImpl::GetOrCreateForSocketParentBridgeForCurrentThread();
 }
 
 // static
@@ -732,6 +733,22 @@
   ChildImpl::CloseForCurrentThread();
 }
 
+// static
+void BackgroundChild::InitContentStarter(ContentChild* aContent) {
+  ChildImpl::InitContentStarter(aContent);
+}
+
+// static
+void BackgroundChild::InitSocketStarter(net::SocketProcessChild* aSocket) {
+  ChildImpl::InitSocketStarter(aSocket);
+}
+
+// static
+void BackgroundChild::InitSocketBridgeStarter(
+    net::SocketProcessBridgeChild* aSocketBridge) {
+  ChildImpl::InitSocketBridgeStarter(aSocketBridge);
+}
+
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl Public Methods
 // -----------------------------------------------------------------------------
@@ -748,13 +765,13 @@
 
 StaticRefPtr<nsIThread> ParentImpl::sBackgroundThread;
 
-nsTArray<ParentImpl*>* ParentImpl::sLiveActorsForBackgroundThread;
+nsTArray<IToplevelProtocol*>* ParentImpl::sLiveActorsForBackgroundThread;
 
 StaticRefPtr<nsITimer> ParentImpl::sShutdownTimer;
 
 Atomic<PRThread*> ParentImpl::sBackgroundPRThread;
 
-uint64_t ParentImpl::sLiveActorCount = 0;
+Atomic<uint64_t> ParentImpl::sLiveActorCount;
 
 bool ParentImpl::sShutdownObserverRegistered = false;
 
@@ -764,238 +781,11 @@
 // ChildImpl Static Members
 // -----------------------------------------------------------------------------
 
-static void ParentContentActorCreateFunc(
-    ChildImpl::ThreadLocalInfo* aThreadLocalInfo,
-    unsigned int aThreadLocalIndex, nsIEventTarget* aMainEventTarget,
-    ChildImpl** aOutput) {
-  if (XRE_IsParentProcess()) {
-    RefPtr<ChildImpl> strongActor =
-        ParentImpl::CreateActorForSameProcess(aMainEventTarget);
-    if (NS_WARN_IF(!strongActor)) {
-      return;
-    }
-
-    aThreadLocalInfo->mActor = strongActor;
-    strongActor.forget(aOutput);
-    return;
-  }
-
-  RefPtr<ContentChild> content = ContentChild::GetSingleton();
-  MOZ_ASSERT(content);
-
-  if (content->IsShuttingDown()) {
-    // The transport for ContentChild is shut down and can't be used to open
-    // PBackground.
-    return;
-  }
-
-  Endpoint<PBackgroundParent> parent;
-  Endpoint<PBackgroundChild> child;
-  nsresult rv;
-  rv = PBackground::CreateEndpoints(content->OtherPid(),
-                                    base::GetCurrentProcId(), &parent, &child);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to create top level actor!");
-    return;
-  }
-
-  RefPtr<ChildImpl::SendInitBackgroundRunnable> runnable;
-  if (!NS_IsMainThread()) {
-    runnable = ChildImpl::SendInitBackgroundRunnable::Create(
-        std::move(parent),
-        [](Endpoint<PBackgroundParent>&& aParent) {
-          RefPtr<ContentChild> content = ContentChild::GetSingleton();
-          MOZ_ASSERT(content);
-
-          if (!content->SendInitBackground(std::move(aParent))) {
-            NS_WARNING("Failed to create top level actor!");
-          }
-        },
-        aThreadLocalIndex);
-    if (!runnable) {
-      return;
-    }
-  }
-
-  RefPtr<ChildImpl> strongActor = new ChildImpl();
-
-  if (!child.Bind(strongActor)) {
-    CRASH_IN_CHILD_PROCESS("Failed to bind ChildImpl!");
-
-    return;
-  }
-
-  strongActor->SetActorAlive();
-
-  if (NS_IsMainThread()) {
-    if (!content->SendInitBackground(std::move(parent))) {
-      NS_WARNING("Failed to create top level actor!");
-      return;
-    }
-  } else {
-    if (aMainEventTarget) {
-      MOZ_ALWAYS_SUCCEEDS(
-          aMainEventTarget->Dispatch(runnable, NS_DISPATCH_NORMAL));
-    } else {
-      MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable));
-    }
-
-    aThreadLocalInfo->mSendInitBackgroundRunnable = runnable;
-  }
-
-  aThreadLocalInfo->mActor = strongActor;
-  strongActor.forget(aOutput);
-}
-
-ChildImpl::ThreadInfoWrapper ChildImpl::sParentAndContentProcessThreadInfo(
-    ParentContentActorCreateFunc);
-
-static void SocketContentActorCreateFunc(
-    ChildImpl::ThreadLocalInfo* aThreadLocalInfo,
-    unsigned int aThreadLocalIndex, nsIEventTarget* aMainEventTarget,
-    ChildImpl** aOutput) {
-  RefPtr<SocketProcessBridgeChild> bridgeChild =
-      SocketProcessBridgeChild::GetSingleton();
-
-  if (!bridgeChild || bridgeChild->IsShuttingDown()) {
-    // The transport for SocketProcessBridgeChild is shut down
-    // and can't be used to open PBackground.
-    return;
-  }
-
-  Endpoint<PBackgroundParent> parent;
-  Endpoint<PBackgroundChild> child;
-  nsresult rv;
-  rv = PBackground::CreateEndpoints(bridgeChild->SocketProcessPid(),
-                                    base::GetCurrentProcId(), &parent, &child);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to create top level actor!");
-    return;
-  }
+ChildImpl::ThreadInfoWrapper ChildImpl::sParentAndContentProcessThreadInfo;
 
-  RefPtr<ChildImpl::SendInitBackgroundRunnable> runnable;
-  if (!NS_IsMainThread()) {
-    runnable = ChildImpl::SendInitBackgroundRunnable::Create(
-        std::move(parent),
-        [](Endpoint<PBackgroundParent>&& aParent) {
-          RefPtr<SocketProcessBridgeChild> bridgeChild =
-              SocketProcessBridgeChild::GetSingleton();
-
-          if (!bridgeChild->SendInitBackground(std::move(aParent))) {
-            NS_WARNING("Failed to create top level actor!");
-          }
-        },
-        aThreadLocalIndex);
-    if (!runnable) {
-      return;
-    }
-  }
-
-  RefPtr<ChildImpl> strongActor = new ChildImpl();
-
-  if (!child.Bind(strongActor)) {
-    CRASH_IN_CHILD_PROCESS("Failed to bind ChildImpl!");
-
-    return;
-  }
-
-  strongActor->SetActorAlive();
-
-  if (NS_IsMainThread()) {
-    if (!bridgeChild->SendInitBackground(std::move(parent))) {
-      NS_WARNING("Failed to create top level actor!");
-      // Need to close the IPC channel before ChildImpl getting deleted.
-      strongActor->Close();
-      strongActor->AssertActorDestroyed();
-      return;
-    }
-  } else {
-    if (aMainEventTarget) {
-      MOZ_ALWAYS_SUCCEEDS(
-          aMainEventTarget->Dispatch(runnable, NS_DISPATCH_NORMAL));
-    } else {
-      MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable));
-    }
-
-    aThreadLocalInfo->mSendInitBackgroundRunnable = runnable;
-  }
-
-  aThreadLocalInfo->mActor = strongActor;
-  strongActor.forget(aOutput);
-}
-
-ChildImpl::ThreadInfoWrapper ChildImpl::sSocketAndContentProcessThreadInfo(
-    SocketContentActorCreateFunc);
-
-static void SocketParentActorCreateFunc(
-    ChildImpl::ThreadLocalInfo* aThreadLocalInfo,
-    unsigned int aThreadLocalIndex, nsIEventTarget* aMainEventTarget,
-    ChildImpl** aOutput) {
-  SocketProcessChild* socketChild = SocketProcessChild::GetSingleton();
+ChildImpl::ThreadInfoWrapper ChildImpl::sSocketAndContentProcessThreadInfo;
 
-  if (!socketChild || socketChild->IsShuttingDown()) {
-    return;
-  }
-
-  Endpoint<PBackgroundParent> parent;
-  Endpoint<PBackgroundChild> child;
-  nsresult rv;
-  rv = PBackground::CreateEndpoints(socketChild->OtherPid(),
-                                    base::GetCurrentProcId(), &parent, &child);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to create top level actor!");
-    return;
-  }
-
-  RefPtr<ChildImpl::SendInitBackgroundRunnable> runnable;
-  if (!NS_IsMainThread()) {
-    runnable = ChildImpl::SendInitBackgroundRunnable::Create(
-        std::move(parent),
-        [](Endpoint<PBackgroundParent>&& aParent) {
-          SocketProcessChild* socketChild = SocketProcessChild::GetSingleton();
-          MOZ_ASSERT(socketChild);
-
-          if (!socketChild->SendInitBackground(std::move(aParent))) {
-            MOZ_CRASH("Failed to create top level actor!");
-          }
-        },
-        aThreadLocalIndex);
-    if (!runnable) {
-      return;
-    }
-  }
-
-  RefPtr<ChildImpl> strongActor = new ChildImpl();
-
-  if (!child.Bind(strongActor)) {
-    CRASH_IN_CHILD_PROCESS("Failed to bind ChildImpl!");
-    return;
-  }
-
-  strongActor->SetActorAlive();
-
-  if (NS_IsMainThread()) {
-    if (!socketChild->SendInitBackground(std::move(parent))) {
-      NS_WARNING("Failed to create top level actor!");
-      return;
-    }
-  } else {
-    if (aMainEventTarget) {
-      MOZ_ALWAYS_SUCCEEDS(
-          aMainEventTarget->Dispatch(runnable, NS_DISPATCH_NORMAL));
-    } else {
-      MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable));
-    }
-
-    aThreadLocalInfo->mSendInitBackgroundRunnable = runnable;
-  }
-
-  aThreadLocalInfo->mActor = strongActor;
-  strongActor.forget(aOutput);
-}
-
-ChildImpl::ThreadInfoWrapper ChildImpl::sSocketAndParentProcessThreadInfo(
-    SocketParentActorCreateFunc);
+ChildImpl::ThreadInfoWrapper ChildImpl::sSocketAndParentProcessThreadInfo;
 
 bool ChildImpl::sShutdownHasStarted = false;
 
@@ -1030,6 +820,8 @@
     // it for us. This is safe since we are guaranteed that our AddRef runnable
     // will run before the reference we hand out can be released, and the
     // ContentParent can't die as long as the existing reference is maintained.
+    //
+    // XXX: Why can't we use `nsMainThreadPtrHandle` here instead?
     MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewNonOwningRunnableMethod(
         "ContentParent::AddRef", actor->mContent, &ContentParent::AddRef)));
   }
@@ -1073,36 +865,12 @@
 }
 
 // static
-bool ParentImpl::GetLiveActorArray(
-    PBackgroundParent* aBackgroundActor,
-    nsTArray<PBackgroundParent*>& aLiveActorArray) {
-  AssertIsOnBackgroundThread();
-  MOZ_ASSERT(aBackgroundActor);
-  MOZ_ASSERT(aLiveActorArray.IsEmpty());
-
-  auto actor = static_cast<ParentImpl*>(aBackgroundActor);
-  if (actor->mActorDestroyed) {
-    MOZ_ASSERT(false,
-               "GetLiveActorArray called after ActorDestroy was called!");
-    return false;
-  }
-
-  if (!actor->mLiveActorArray) {
-    return true;
-  }
-
-  for (ParentImpl* liveActor : *actor->mLiveActorArray) {
-    aLiveActorArray.AppendElement(liveActor);
-  }
-
-  return true;
-}
-
-// static
-bool ParentImpl::Alloc(ContentParent* aContent,
-                       Endpoint<PBackgroundParent>&& aEndpoint) {
+bool ParentImpl::AllocStarter(ContentParent* aContent,
+                              Endpoint<PBackgroundStarterParent>&& aEndpoint,
+                              bool aCrossProcess) {
   AssertIsInMainOrSocketProcess();
   AssertIsOnMainThread();
+
   MOZ_ASSERT(aEndpoint.IsValid());
 
   if (!sBackgroundThread && !CreateBackgroundThread()) {
@@ -1110,29 +878,18 @@
     return false;
   }
 
-  MOZ_ASSERT(sLiveActorsForBackgroundThread);
-
   sLiveActorCount++;
 
-  RefPtr<ParentImpl> actor = new ParentImpl(aContent);
+  RefPtr<BackgroundStarterParent> actor =
+      new BackgroundStarterParent(aContent, aCrossProcess);
 
   if (NS_FAILED(sBackgroundThread->Dispatch(NS_NewRunnableFunction(
-          "Background::ParentImpl::ConnectActorRunnable",
+          "BackgroundStarterParent::ConnectActorRunnable",
           [actor = std::move(actor), endpoint = std::move(aEndpoint),
            liveActorArray = sLiveActorsForBackgroundThread]() mutable {
             MOZ_ASSERT(endpoint.IsValid());
-            MOZ_ASSERT(liveActorArray);
-            // Transfer ownership to this thread. If Open() fails then we will
-            // release this reference in Destroy.
-            ParentImpl* actorTmp;
-            actor.forget(&actorTmp);
-
-            if (!endpoint.Bind(actorTmp)) {
-              actorTmp->Destroy();
-              return;
-            }
-
-            actorTmp->SetLiveActorArray(liveActorArray);
+            MOZ_ALWAYS_TRUE(endpoint.Bind(actor));
+            actor->SetLiveActorArray(liveActorArray);
           })))) {
     NS_WARNING("Failed to dispatch connect runnable!");
 
@@ -1144,64 +901,6 @@
 }
 
 // static
-already_AddRefed<ChildImpl> ParentImpl::CreateActorForSameProcess(
-    nsIEventTarget* aMainEventTarget) {
-  AssertIsInMainProcess();
-
-  RefPtr<ParentImpl> parentActor;
-  nsCOMPtr<nsIThread> backgroundThread;
-
-  if (NS_IsMainThread()) {
-    if (!sBackgroundThread && !CreateBackgroundThread()) {
-      NS_WARNING("Failed to create background thread!");
-      return nullptr;
-    }
-
-    MOZ_ASSERT(!sShutdownHasStarted);
-
-    sLiveActorCount++;
-
-    parentActor = new ParentImpl();
-    backgroundThread = sBackgroundThread.get();
-  } else {
-    RefPtr<CreateActorHelper> helper = new CreateActorHelper();
-
-    nsresult rv = helper->BlockAndGetResults(aMainEventTarget, parentActor,
-                                             backgroundThread);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return nullptr;
-    }
-  }
-
-  RefPtr<ChildImpl> childActor = new ChildImpl();
-
-  MessageChannel* parentChannel = parentActor->GetIPCChannel();
-  MOZ_ASSERT(parentChannel);
-
-  if (!childActor->Open(parentChannel, backgroundThread, ChildSide)) {
-    NS_WARNING("Failed to open ChildImpl!");
-
-    // Can't release it here, we will release this reference in Destroy.
-    ParentImpl* actor;
-    parentActor.forget(&actor);
-
-    actor->Destroy();
-
-    return nullptr;
-  }
-
-  childActor->SetActorAlive();
-
-  // Make sure the parent knows it is same process.
-  parentActor->SetOtherProcessId(base::GetCurrentProcId());
-
-  // Now that Open() has succeeded transfer the ownership of the actors to IPDL.
-  Unused << parentActor.forget();
-
-  return childActor.forget();
-}
-
-// static
 bool ParentImpl::CreateBackgroundThread() {
   AssertIsInMainOrSocketProcess();
   AssertIsOnMainThread();
@@ -1258,7 +957,7 @@
 
   sBackgroundThread = thread.forget();
 
-  sLiveActorsForBackgroundThread = new nsTArray<ParentImpl*>(1);
+  sLiveActorsForBackgroundThread = new nsTArray<IToplevelProtocol*>(1);
 
   if (!sShutdownTimer) {
     MOZ_ASSERT(newShutdownTimer);
@@ -1283,7 +982,8 @@
     nsCOMPtr<nsIThread> thread = sBackgroundThread.get();
     sBackgroundThread = nullptr;
 
-    UniquePtr<nsTArray<ParentImpl*>> liveActors(sLiveActorsForBackgroundThread);
+    UniquePtr<nsTArray<IToplevelProtocol*>> liveActors(
+        sLiveActorsForBackgroundThread);
     sLiveActorsForBackgroundThread = nullptr;
 
     MOZ_ASSERT_IF(!sShutdownHasStarted, !sLiveActorCount);
@@ -1333,20 +1033,21 @@
   // finished.
   sLiveActorCount++;
 
-  InvokeAsync(closure->mThread, __func__,
-              [liveActors = closure->mLiveActors]() {
-                MOZ_ASSERT(liveActors);
+  InvokeAsync(
+      closure->mThread, __func__,
+      [liveActors = closure->mLiveActors]() {
+        MOZ_ASSERT(liveActors);
 
-                if (!liveActors->IsEmpty()) {
-                  // Copy the array since calling Close() could mutate the
-                  // actual array.
-                  nsTArray<ParentImpl*> actorsToClose(liveActors->Clone());
-                  for (ParentImpl* actor : actorsToClose) {
-                    actor->Close();
-                  }
-                }
-                return GenericPromise::CreateAndResolve(true, __func__);
-              })
+        if (!liveActors->IsEmpty()) {
+          // Copy the array since calling Close() could mutate the
+          // actual array.
+          nsTArray<IToplevelProtocol*> actorsToClose(liveActors->Clone());
+          for (IToplevelProtocol* actor : actorsToClose) {
+            actor->Close();
+          }
+        }
+        return GenericPromise::CreateAndResolve(true, __func__);
+      })
       ->Then(GetCurrentSerialEventTarget(), __func__, []() {
         MOZ_ASSERT(sLiveActorCount);
         sLiveActorCount--;
@@ -1425,65 +1126,85 @@
   return NS_OK;
 }
 
-nsresult ParentImpl::CreateActorHelper::BlockAndGetResults(
-    nsIEventTarget* aMainEventTarget, RefPtr<ParentImpl>& aParentActor,
-    nsCOMPtr<nsIThread>& aThread) {
-  AssertIsNotOnMainThread();
-
-  if (aMainEventTarget) {
-    MOZ_ALWAYS_SUCCEEDS(aMainEventTarget->Dispatch(this, NS_DISPATCH_NORMAL));
-  } else {
-    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(this));
-  }
+BackgroundStarterParent::BackgroundStarterParent(ContentParent* aContent,
+                                                 bool aCrossProcess)
+    : mCrossProcess(aCrossProcess), mContent(aContent) {
+  AssertIsOnMainThread();
+  AssertIsInMainOrSocketProcess();
+  MOZ_ASSERT_IF(!mCrossProcess, !mContent);
+  MOZ_ASSERT_IF(!mCrossProcess, XRE_IsParentProcess());
+}
 
-  mozilla::MonitorAutoLock lock(mMonitor);
-  while (mWaiting) {
-    lock.Wait();
-  }
+void BackgroundStarterParent::SetLiveActorArray(
+    nsTArray<IToplevelProtocol*>* aLiveActorArray) {
+  AssertIsInMainOrSocketProcess();
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aLiveActorArray);
+  MOZ_ASSERT(!aLiveActorArray->Contains(this));
+  MOZ_ASSERT(!mLiveActorArray);
+  MOZ_ASSERT_IF(!mCrossProcess, OtherPid() == base::GetCurrentProcId());
 
-  if (NS_WARN_IF(NS_FAILED(mMainThreadResultCode))) {
-    return mMainThreadResultCode;
-  }
-
-  aParentActor = std::move(mParentActor);
-  aThread = std::move(mThread);
-  return NS_OK;
+  mLiveActorArray = aLiveActorArray;
+  mLiveActorArray->AppendElement(this);
 }
 
-nsresult ParentImpl::CreateActorHelper::RunOnMainThread() {
-  AssertIsOnMainThread();
+IPCResult BackgroundStarterParent::RecvInitBackground(
+    Endpoint<PBackgroundParent>&& aEndpoint) {
+  AssertIsOnBackgroundThread();
+
+  if (!aEndpoint.IsValid()) {
+    return IPC_FAIL(this,
+                    "Cannot initialize PBackground with invalid endpoint");
+  }
 
-  if (!sBackgroundThread && !CreateBackgroundThread()) {
-    NS_WARNING("Failed to create background thread!");
-    return NS_ERROR_FAILURE;
+  if (mContent) {
+    // We need to hand out a reference to our ContentParent for the new
+    // ParentImpl actor, but we also need to keep the one we have. We can't call
+    // AddRef here because ContentParent is not threadsafe so instead we
+    // dispatch a runnable to the main thread to do it for us. This is safe
+    // since we are guaranteed that our AddRef runnable will run before the
+    // reference we hand out can be released, and the ContentParent can't die as
+    // long as the existing reference is maintained.
+    //
+    // XXX: Why can't we use `nsMainThreadPtrHandle` here?
+    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewNonOwningRunnableMethod(
+        "ContentParent::AddRef", mContent, &ContentParent::AddRef)));
   }
 
-  MOZ_ASSERT(!sShutdownHasStarted);
+  ParentImpl* actor = new ParentImpl(
+      already_AddRefed<ContentParent>(mContent.get()), mCrossProcess);
 
-  sLiveActorCount++;
+  // Take a reference on this thread. If Open() fails then we will release this
+  // reference in Destroy.
+  NS_ADDREF(actor);
+
+  ParentImpl::sLiveActorCount++;
 
-  mParentActor = new ParentImpl();
-  mThread = sBackgroundThread;
+  if (!aEndpoint.Bind(actor)) {
+    actor->Destroy();
+    return IPC_OK();
+  }
 
-  return NS_OK;
+  if (mCrossProcess) {
+    actor->SetLiveActorArray(mLiveActorArray);
+  }
+  return IPC_OK();
 }
 
-NS_IMETHODIMP
-ParentImpl::CreateActorHelper::Run() {
-  AssertIsOnMainThread();
+void BackgroundStarterParent::ActorDestroy(ActorDestroyReason aReason) {
+  AssertIsOnBackgroundThread();
 
-  nsresult rv = RunOnMainThread();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    mMainThreadResultCode = rv;
+  if (mLiveActorArray) {
+    MOZ_ALWAYS_TRUE(mLiveActorArray->RemoveElement(this));
+    mLiveActorArray = nullptr;
   }
 
-  mozilla::MonitorAutoLock lock(mMonitor);
-  MOZ_ASSERT(mWaiting);
-
-  mWaiting = false;
-  lock.Notify();
-
-  return NS_OK;
+  // Make sure to decrement `sLiveActorCount` on the main thread.
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NS_NewRunnableFunction(
+      "BackgroundStarterParent::MainThreadDestroy", [self = RefPtr{this}] {
+        self->mContent = nullptr;
+        ParentImpl::sLiveActorCount--;
+      })));
 }
 
 // -----------------------------------------------------------------------------
@@ -1507,6 +1228,19 @@
   nsresult rv = observerService->AddObserver(
       observer, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID, false);
   MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));
+
+  // Initialize a starter actor to allow starting PBackground within the parent
+  // process.
+  if (XRE_IsParentProcess()) {
+    Endpoint<PBackgroundStarterParent> parent;
+    Endpoint<PBackgroundStarterChild> child;
+    MOZ_ALWAYS_SUCCEEDS(PBackgroundStarter::CreateEndpoints(
+        base::GetCurrentProcId(), base::GetCurrentProcId(), &parent, &child));
+
+    MOZ_ALWAYS_TRUE(ParentImpl::AllocStarter(nullptr, std::move(parent),
+                                             /* aCrossProcess */ false));
+    sParentAndContentProcessThreadInfo.InitStarter(std::move(child));
+  }
 }
 
 // static
@@ -1539,59 +1273,19 @@
 }
 
 /* static */
-PBackgroundChild* ChildImpl::GetFromThreadInfo(
-    nsIEventTarget* aMainEventTarget, ThreadLocalInfo* aThreadLocalInfo) {
-  MOZ_ASSERT(aThreadLocalInfo);
-
-  if (aThreadLocalInfo->mActor) {
-    RefPtr<SendInitBackgroundRunnable>& runnable =
-        aThreadLocalInfo->mSendInitBackgroundRunnable;
-
-    if (aMainEventTarget && runnable) {
-      // The SendInitBackgroundRunnable was already dispatched to the main
-      // thread to finish initialization of a new background child actor.
-      // However, the caller passed a custom main event target which indicates
-      // that synchronous blocking of the main thread is happening (done by
-      // creating a nested event target and spinning the event loop).
-      // It can happen that the SendInitBackgroundRunnable didn't have a chance
-      // to run before the synchronous blocking has occured. Unblocking of the
-      // main thread can depend on an IPC message received on this thread, so
-      // we have to dispatch the SendInitBackgroundRunnable to the custom main
-      // event target too, otherwise IPC will be only queueing messages on this
-      // thread. The runnable will run twice in the end, but that's a harmless
-      // race between the main and nested event queue of the main thread.
-      // There's a guard in the runnable implementation for calling
-      // SendInitBackground only once.
-
-      MOZ_ALWAYS_SUCCEEDS(
-          aMainEventTarget->Dispatch(runnable, NS_DISPATCH_NORMAL));
-    }
-
-    return aThreadLocalInfo->mActor;
-  }
-
-  return nullptr;
+PBackgroundChild* ChildImpl::GetOrCreateForCurrentThread() {
+  return sParentAndContentProcessThreadInfo.GetOrCreateForCurrentThread();
 }
 
 /* static */
-PBackgroundChild* ChildImpl::GetOrCreateForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return sParentAndContentProcessThreadInfo.GetOrCreateForCurrentThread(
-      aMainEventTarget);
+PBackgroundChild* ChildImpl::GetOrCreateSocketActorForCurrentThread() {
+  return sSocketAndContentProcessThreadInfo.GetOrCreateForCurrentThread();
 }
 
 /* static */
-PBackgroundChild* ChildImpl::GetOrCreateSocketActorForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return sSocketAndContentProcessThreadInfo.GetOrCreateForCurrentThread(
-      aMainEventTarget);
-}
-
-/* static */
-PBackgroundChild* ChildImpl::GetOrCreateForSocketParentBridgeForCurrentThread(
-    nsIEventTarget* aMainEventTarget) {
-  return sSocketAndParentProcessThreadInfo.GetOrCreateForCurrentThread(
-      aMainEventTarget);
+PBackgroundChild*
+ChildImpl::GetOrCreateForSocketParentBridgeForCurrentThread() {
+  return sSocketAndParentProcessThreadInfo.GetOrCreateForCurrentThread();
 }
 
 // static
@@ -1630,6 +1324,22 @@
 }
 
 // static
+void ChildImpl::InitContentStarter(mozilla::dom::ContentChild* aContent) {
+  sParentAndContentProcessThreadInfo.InitStarter(aContent);
+}
+
+// static
+void ChildImpl::InitSocketStarter(mozilla::net::SocketProcessChild* aSocket) {
+  sSocketAndParentProcessThreadInfo.InitStarter(aSocket);
+}
+
+// static
+void ChildImpl::InitSocketBridgeStarter(
+    mozilla::net::SocketProcessBridgeChild* aSocketBridge) {
+  sSocketAndContentProcessThreadInfo.InitStarter(aSocketBridge);
+}
+
+// static
 void ChildImpl::ThreadLocalDestructor(void* aThreadLocal) {
   auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
@@ -1641,10 +1351,6 @@
       threadLocalInfo->mActor->AssertActorDestroyed();
     }
 
-    if (threadLocalInfo->mSendInitBackgroundRunnable) {
-      threadLocalInfo->mSendInitBackgroundRunnable->ClearEventTarget();
-    }
-
     delete threadLocalInfo;
   }
 }
@@ -1672,73 +1378,3 @@
 
   return NS_OK;
 }
-
-// static
-already_AddRefed<ChildImpl::SendInitBackgroundRunnable>
-ChildImpl::SendInitBackgroundRunnable::Create(
-    Endpoint<PBackgroundParent>&& aParent,
-    std::function<void(Endpoint<PBackgroundParent>&& aParent)>&& aFunc,
-    unsigned int aThreadLocalIndex) {
-  MOZ_ASSERT(!NS_IsMainThread());
-
-  RefPtr<SendInitBackgroundRunnable> runnable = new SendInitBackgroundRunnable(
-      std::move(aParent), std::move(aFunc), aThreadLocalIndex);
-
-  WorkerPrivate* workerPrivate = mozilla::dom::GetCurrentThreadWorkerPrivate();
-  if (!workerPrivate) {
-    return runnable.forget();
-  }
-
-  workerPrivate->AssertIsOnWorkerThread();
-
-  runnable->mWorkerRef = StrongWorkerRef::Create(
-      workerPrivate, "ChildImpl::SendInitBackgroundRunnable");
-  if (NS_WARN_IF(!runnable->mWorkerRef)) {
-    return nullptr;
-  }
-
-  return runnable.forget();
-}
-
-NS_IMETHODIMP
-ChildImpl::SendInitBackgroundRunnable::Run() {
-  if (NS_IsMainThread()) {
-    if (mSentInitBackground) {
-      return NS_OK;
-    }
-
-    mSentInitBackground = true;
-
-    mSendInitfunc(std::move(mParent));
-
-    nsCOMPtr<nsISerialEventTarget> owningEventTarget;
-    {
-      mozilla::MutexAutoLock lock(mMutex);
-      owningEventTarget = mOwningEventTarget;
-    }
-
-    if (!owningEventTarget) {
-      return NS_OK;
-    }
-
-    nsresult rv = owningEventTarget->Dispatch(this, NS_DISPATCH_NORMAL);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
-
-    return NS_OK;
-  }
-
-  ClearEventTarget();
-
-  auto threadLocalInfo =
-      static_cast<ThreadLocalInfo*>(PR_GetThreadPrivate(mThreadLocalIndex));
-
-  if (!threadLocalInfo) {
-    return NS_OK;
-  }
-
-  threadLocalInfo->mSendInitBackgroundRunnable = nullptr;
-
-  return NS_OK;
-}