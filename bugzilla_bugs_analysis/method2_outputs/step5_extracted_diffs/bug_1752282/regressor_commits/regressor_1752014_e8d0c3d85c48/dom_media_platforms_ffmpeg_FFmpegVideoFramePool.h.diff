# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/ffmpeg/FFmpegVideoFramePool.h
# Commit: e8d0c3d85c48
# Full Hash: e8d0c3d85c48bc793ee27bcc9fbd3bcde819781f
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-01-26 16:31:34
# Regressor Bug: 1752014
# File Overlap Count: 1
# Description:
#   Bug 1752014 - Cleanup VideoFramePool::GetFreeVideoFrameSurface. r=stransky,media-playback-reviewers
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D136874
# ==============================================================================

diff -r 5c02a8fc256d -r e8d0c3d85c48 dom/media/platforms/ffmpeg/FFmpegVideoFramePool.h
--- a/dom/media/platforms/ffmpeg/FFmpegVideoFramePool.h	Tue Jan 25 21:51:17 2022 +0000
+++ b/dom/media/platforms/ffmpeg/FFmpegVideoFramePool.h	Tue Jan 25 22:01:38 2022 +0000
@@ -17,6 +17,8 @@
 namespace mozilla {
 
 class VideoFramePool;
+class VideoFrameSurfaceDMABuf;
+class VideoFrameSurfaceVAAPI;
 
 class VideoFrameSurface {
  public:
@@ -24,15 +26,13 @@
 
   VideoFrameSurface() = default;
 
-  virtual class VideoFrameSurfaceDMABuf* AsVideoFrameSurfaceDMABuf() {
+  virtual VideoFrameSurfaceDMABuf* AsVideoFrameSurfaceDMABuf() {
     return nullptr;
   }
-  virtual class VideoFrameSurfaceVAAPI* AsVideoFrameSurfaceVAAPI() {
-    return nullptr;
-  }
+  virtual VideoFrameSurfaceVAAPI* AsVideoFrameSurfaceVAAPI() { return nullptr; }
 
-  virtual void SetYUVColorSpace(mozilla::gfx::YUVColorSpace aColorSpace) = 0;
-  virtual void SetColorRange(mozilla::gfx::ColorRange aColorRange) = 0;
+  virtual void SetYUVColorSpace(gfx::YUVColorSpace aColorSpace) = 0;
+  virtual void SetColorRange(gfx::ColorRange aColorRange) = 0;
 
   virtual RefPtr<DMABufSurfaceYUV> GetDMABufSurface() { return nullptr; };
   virtual RefPtr<layers::Image> GetAsImage() = 0;
@@ -55,22 +55,20 @@
  public:
   explicit VideoFrameSurfaceDMABuf(DMABufSurface* aSurface);
 
-  class VideoFrameSurfaceDMABuf* AsVideoFrameSurfaceDMABuf() {
-    return this;
-  }
+  VideoFrameSurfaceDMABuf* AsVideoFrameSurfaceDMABuf() final { return this; }
 
-  void SetYUVColorSpace(mozilla::gfx::YUVColorSpace aColorSpace) {
+  void SetYUVColorSpace(gfx::YUVColorSpace aColorSpace) final {
     mSurface->GetAsDMABufSurfaceYUV()->SetYUVColorSpace(aColorSpace);
   }
-  void SetColorRange(mozilla::gfx::ColorRange aColorRange) {
+  void SetColorRange(gfx::ColorRange aColorRange) final {
     mSurface->GetAsDMABufSurfaceYUV()->SetColorRange(aColorRange);
   }
 
-  RefPtr<DMABufSurfaceYUV> GetDMABufSurface() {
+  RefPtr<DMABufSurfaceYUV> GetDMABufSurface() final {
     return mSurface->GetAsDMABufSurfaceYUV();
   };
 
-  RefPtr<layers::Image> GetAsImage();
+  RefPtr<layers::Image> GetAsImage() final;
 
  protected:
   // Check if DMABufSurface is used by any gecko rendering process
@@ -81,7 +79,7 @@
  protected:
   const RefPtr<DMABufSurface> mSurface;
 
-  ~VideoFrameSurfaceDMABuf(){};
+  virtual ~VideoFrameSurfaceDMABuf() = default;
 };
 
 // VideoFrameSurfaceVAAPI holds a reference to GPU data with a video frame.
@@ -113,15 +111,13 @@
 // Unfortunately there isn't any obvious way how to mark particular VASurface
 // as used. The best we can do is to hold a reference to particular AVBuffer
 // from decoded AVFrame and AVHWFramesContext which owns the AVBuffer.
-class VideoFrameSurfaceVAAPI : public VideoFrameSurfaceDMABuf {
+class VideoFrameSurfaceVAAPI final : public VideoFrameSurfaceDMABuf {
   friend class VideoFramePool;
 
  public:
   explicit VideoFrameSurfaceVAAPI(DMABufSurface* aSurface);
 
-  virtual class VideoFrameSurfaceVAAPI* AsVideoFrameSurfaceVAAPI() {
-    return this;
-  }
+  VideoFrameSurfaceVAAPI* AsVideoFrameSurfaceVAAPI() final { return this; }
 
  protected:
   // Lock VAAPI related data
@@ -132,7 +128,7 @@
   void ReleaseVAAPIData(bool aForFrameRecycle = true);
 
  private:
-  ~VideoFrameSurfaceVAAPI();
+  virtual ~VideoFrameSurfaceVAAPI();
 
   const FFmpegLibWrapper* mLib;
   AVBufferRef* mAVHWFramesContext;
@@ -158,10 +154,10 @@
  private:
   const bool mUseVAAPI;
   // Protect mDMABufSurfaces pool access
-  mozilla::Mutex mSurfaceLock;
-  nsTArray<RefPtr<VideoFrameSurface>> mDMABufSurfaces;
-  // We may fails to create texture over DMABuf memory due to driver bugs
-  // so check that before we export first DMABuf video frame.
+  Mutex mSurfaceLock;
+  nsTArray<RefPtr<VideoFrameSurfaceDMABuf>> mDMABufSurfaces;
+  // We may fail to create texture over DMABuf memory due to driver bugs so
+  // check that before we export first DMABuf video frame.
   Maybe<bool> mTextureCreationWorks;
 };
 
