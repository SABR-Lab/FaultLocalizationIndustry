# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditHelpers.h
# Commit: aeb15abd2346
# Full Hash: aeb15abd23467a3627da58edb9d9d7bacc118f21
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-11-24 15:52:24
# Regressor Bug: 1740858
# File Overlap Count: 1
# Description:
#   Bug 1740858 - Improve `SplitNodeResult` r=m_kato
#   
#   First, left/right node accessors are not used so that we can get rid of them.
#   However, we should have similar methods which can retrieve original node and
#   new node.  Therefore, this adds `GetNewContent()` and `GetOriginalContent()`.
# ==============================================================================

diff -r 891cba7d04e9 -r aeb15abd2346 editor/libeditor/HTMLEditHelpers.h
--- a/editor/libeditor/HTMLEditHelpers.h	Wed Nov 24 00:46:38 2021 +0000
+++ b/editor/libeditor/HTMLEditHelpers.h	Wed Nov 24 00:56:33 2021 +0000
@@ -13,6 +13,7 @@
  */
 
 #include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/Attributes.h"
 #include "mozilla/ContentIterator.h"
 #include "mozilla/EditorDOMPoint.h"
 #include "mozilla/RangeBoundary.h"
@@ -262,71 +263,101 @@
   bool DidSplit() const { return mPreviousNode && mNextNode; }
 
   /**
-   * GetLeftNode() simply returns the left node which was created at splitting.
-   * This returns nullptr if the node wasn't split.
-   */
-  nsIContent* GetLeftNode() const {
-    return mPreviousNode && mNextNode ? mPreviousNode.get() : nullptr;
-  }
-
-  /**
-   * GetRightNode() simply returns the right node which was split.
-   * This won't return nullptr unless failed to split due to invalid arguments.
+   * GetPreviousContent() returns previous content node at the split point.
    */
-  nsIContent* GetRightNode() const {
-    if (mGivenSplitPoint.IsSet()) {
-      return mGivenSplitPoint.GetChild();
-    }
-    return mPreviousNode && !mNextNode ? mPreviousNode : mNextNode;
-  }
-
-  /**
-   * GetPreviousNode() returns previous node at the split point.
-   */
-  nsIContent* GetPreviousNode() const {
+  MOZ_KNOWN_LIVE nsIContent* GetPreviousContent() const {
+    MOZ_ASSERT(Succeeded());
     if (mGivenSplitPoint.IsSet()) {
       return mGivenSplitPoint.IsEndOfContainer() ? mGivenSplitPoint.GetChild()
                                                  : nullptr;
     }
     return mPreviousNode;
   }
+  template <typename EditorDOMPointType>
+  EditorDOMPointType AtPreviousContent() const {
+    if (nsIContent* previousContent = GetPreviousContent()) {
+      return EditorDOMPointType(previousContent);
+    }
+    return EditorDOMPointType();
+  }
 
   /**
-   * GetNextNode() returns next node at the split point.
+   * GetNextContent() returns next content node at the split point.
    */
-  nsIContent* GetNextNode() const {
+  MOZ_KNOWN_LIVE nsIContent* GetNextContent() const {
+    MOZ_ASSERT(Succeeded());
     if (mGivenSplitPoint.IsSet()) {
       return !mGivenSplitPoint.IsEndOfContainer() ? mGivenSplitPoint.GetChild()
                                                   : nullptr;
     }
     return mNextNode;
   }
+  template <typename EditorDOMPointType>
+  EditorDOMPointType AtNextContent() const {
+    if (nsIContent* nextContent = GetNextContent()) {
+      return EditorDOMPointType(nextContent);
+    }
+    return EditorDOMPointType();
+  }
 
   /**
-   * SplitPoint() returns the split point in the container.
-   * This is useful when callers insert an element at split point with
+   * Returns new content node which is created at splitting a node.  I.e., this
+   * returns nullptr if no node was split.
+   */
+  MOZ_KNOWN_LIVE nsIContent* GetNewContent() const {
+    MOZ_ASSERT(Succeeded());
+    if (!DidSplit()) {
+      return nullptr;
+    }
+    return mDirection == SplitNodeDirection::LeftNodeIsNewOne ? mPreviousNode
+                                                              : mNextNode;
+  }
+  template <typename EditorDOMPointType>
+  EditorDOMPointType AtNewContent() const {
+    if (nsIContent* newContent = GetNewContent()) {
+      return EditorDOMPointType(newContent);
+    }
+    return EditorDOMPointType();
+  }
+
+  /**
+   * Returns original content node which is (or is just tried to be) split.
+   */
+  MOZ_KNOWN_LIVE nsIContent* GetOriginalContent() const {
+    MOZ_ASSERT(Succeeded());
+    if (mGivenSplitPoint.IsSet()) {
+      return mGivenSplitPoint.GetChild();
+    }
+    if (mDirection == SplitNodeDirection::LeftNodeIsNewOne) {
+      return mNextNode ? mNextNode : mPreviousNode;
+    }
+    return mPreviousNode ? mPreviousNode : mNextNode;
+  }
+  template <typename EditorDOMPointType>
+  EditorDOMPointType AtOriginalContent() const {
+    if (nsIContent* originalContent = GetOriginalContent()) {
+      return EditorDOMPointType(originalContent);
+    }
+    return EditorDOMPointType();
+  }
+
+  /**
+   * AtSplitPoint() returns the split point in the container.
    * HTMLEditor::CreateAndInsertElementWithTransaction() or something similar
    * methods.
-   *
-   * Note that the result is EditorRawDOMPoint but the nodes are grabbed
-   * by this instance.  Therefore, the life time of both container node
-   * and child node are guaranteed while using the result temporarily.
    */
-  EditorDOMPoint SplitPoint() const {
+  template <typename EditorDOMPointType>
+  EditorDOMPointType AtSplitPoint() const {
     if (Failed()) {
-      return EditorDOMPoint();
+      return EditorDOMPointType();
     }
     if (mGivenSplitPoint.IsSet()) {
-      return EditorDOMPoint(mGivenSplitPoint);
+      return EditorDOMPointType(mGivenSplitPoint);
     }
     if (!mPreviousNode) {
-      return EditorDOMPoint(mNextNode);
+      return EditorDOMPointType(mNextNode);
     }
-    EditorDOMPoint point(mPreviousNode);
-    DebugOnly<bool> advanced = point.AdvanceOffset();
-    NS_WARNING_ASSERTION(advanced,
-                         "Failed to advance offset to after previous node");
-    return point;
+    return EditorDOMPointType::After(mPreviousNode);
   }
 
   /**
@@ -337,33 +368,43 @@
    *                                    split point.
    * @param aNextNodeOfSplitPoint       Next node immediately after split
    *                                    point.
+   * @param aDirection                  The split direction which the HTML
+   *                                    editor tried to split a node with.
    */
   SplitNodeResult(nsIContent* aPreviousNodeOfSplitPoint,
-                  nsIContent* aNextNodeOfSplitPoint)
+                  nsIContent* aNextNodeOfSplitPoint,
+                  SplitNodeDirection aDirection)
       : mPreviousNode(aPreviousNodeOfSplitPoint),
         mNextNode(aNextNodeOfSplitPoint),
-        mRv(NS_OK) {
+        mRv(NS_OK),
+        mDirection(aDirection) {
     MOZ_DIAGNOSTIC_ASSERT(mPreviousNode || mNextNode);
   }
   SplitNodeResult(nsCOMPtr<nsIContent>&& aPreviousNodeOfSplitPoint,
-                  nsIContent* aNextNodeOfSplitPoint)
+                  nsIContent* aNextNodeOfSplitPoint,
+                  SplitNodeDirection aDirection)
       : mPreviousNode(std::move(aPreviousNodeOfSplitPoint)),
         mNextNode(aNextNodeOfSplitPoint),
-        mRv(NS_OK) {
+        mRv(NS_OK),
+        mDirection(aDirection) {
     MOZ_DIAGNOSTIC_ASSERT(mPreviousNode || mNextNode);
   }
   SplitNodeResult(nsIContent* aPreviousNodeOfSplitPoint,
-                  nsCOMPtr<nsIContent>&& aNextNodeOfSplitPoint)
+                  nsCOMPtr<nsIContent>&& aNextNodeOfSplitPoint,
+                  SplitNodeDirection aDirection)
       : mPreviousNode(aPreviousNodeOfSplitPoint),
         mNextNode(std::move(aNextNodeOfSplitPoint)),
-        mRv(NS_OK) {
+        mRv(NS_OK),
+        mDirection(aDirection) {
     MOZ_DIAGNOSTIC_ASSERT(mPreviousNode || mNextNode);
   }
   SplitNodeResult(nsCOMPtr<nsIContent>&& aPreviousNodeOfSplitPoint,
-                  nsCOMPtr<nsIContent>&& aNextNodeOfSplitPoint)
+                  nsCOMPtr<nsIContent>&& aNextNodeOfSplitPoint,
+                  SplitNodeDirection aDirection)
       : mPreviousNode(std::move(aPreviousNodeOfSplitPoint)),
         mNextNode(std::move(aNextNodeOfSplitPoint)),
-        mRv(NS_OK) {
+        mRv(NS_OK),
+        mDirection(aDirection) {
     MOZ_DIAGNOSTIC_ASSERT(mPreviousNode || mNextNode);
   }
 
@@ -372,7 +413,9 @@
    * but want to return given split point as right point.
    */
   explicit SplitNodeResult(const EditorRawDOMPoint& aGivenSplitPoint)
-      : mGivenSplitPoint(aGivenSplitPoint), mRv(NS_OK) {
+      : mGivenSplitPoint(aGivenSplitPoint),
+        mRv(NS_OK),
+        mDirection(SplitNodeDirection::LeftNodeIsNewOne) {
     MOZ_DIAGNOSTIC_ASSERT(mGivenSplitPoint.IsSet());
   }
 
@@ -380,7 +423,8 @@
    * This constructor shouldn't be used by anybody except methods which
    * use this as error result when it fails.
    */
-  explicit SplitNodeResult(nsresult aRv) : mRv(aRv) {
+  explicit SplitNodeResult(nsresult aRv)
+      : mRv(aRv), mDirection(SplitNodeDirection::LeftNodeIsNewOne) {
     MOZ_DIAGNOSTIC_ASSERT(NS_FAILED(mRv));
   }
 
@@ -402,6 +446,7 @@
   EditorDOMPoint mGivenSplitPoint;
 
   nsresult mRv;
+  SplitNodeDirection mDirection;
 
   SplitNodeResult() = delete;
 };
@@ -459,14 +504,14 @@
                               SplitNodeResult& aSplitResultAtRightOfMiddleNode)
       : mRv(NS_OK) {
     if (aSplitResultAtLeftOfMiddleNode.Succeeded()) {
-      mLeftContent = aSplitResultAtLeftOfMiddleNode.GetPreviousNode();
+      mLeftContent = aSplitResultAtLeftOfMiddleNode.GetPreviousContent();
     }
     if (aSplitResultAtRightOfMiddleNode.Succeeded()) {
-      mRightContent = aSplitResultAtRightOfMiddleNode.GetNextNode();
-      mMiddleContent = aSplitResultAtRightOfMiddleNode.GetPreviousNode();
+      mRightContent = aSplitResultAtRightOfMiddleNode.GetNextContent();
+      mMiddleContent = aSplitResultAtRightOfMiddleNode.GetPreviousContent();
     }
     if (!mMiddleContent && aSplitResultAtLeftOfMiddleNode.Succeeded()) {
-      mMiddleContent = aSplitResultAtLeftOfMiddleNode.GetNextNode();
+      mMiddleContent = aSplitResultAtLeftOfMiddleNode.GetNextContent();
     }
   }
 