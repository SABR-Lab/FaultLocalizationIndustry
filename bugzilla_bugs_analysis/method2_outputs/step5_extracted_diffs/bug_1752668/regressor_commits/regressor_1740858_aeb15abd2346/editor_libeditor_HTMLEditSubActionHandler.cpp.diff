# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: aeb15abd2346
# Full Hash: aeb15abd23467a3627da58edb9d9d7bacc118f21
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-11-24 15:52:24
# Regressor Bug: 1740858
# File Overlap Count: 1
# Description:
#   Bug 1740858 - Improve `SplitNodeResult` r=m_kato
#   
#   First, left/right node accessors are not used so that we can get rid of them.
#   However, we should have similar methods which can retrieve original node and
#   new node.  Therefore, this adds `GetNewContent()` and `GetOriginalContent()`.
# ==============================================================================

diff -r 891cba7d04e9 -r aeb15abd2346 editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Wed Nov 24 00:46:38 2021 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Wed Nov 24 00:56:33 2021 +0000
@@ -9,15 +9,17 @@
 #include <algorithm>
 #include <utility>
 
+#include "CSSEditUtils.h"
+#include "EditAction.h"
+#include "EditorDOMPoint.h"
+#include "EditorUtils.h"
 #include "HTMLEditUtils.h"
+#include "TypeInState.h"  // for SpecifiedStyle
 #include "WSRunObject.h"
+
 #include "mozilla/Assertions.h"
-#include "mozilla/CSSEditUtils.h"
 #include "mozilla/CheckedInt.h"
 #include "mozilla/ContentIterator.h"
-#include "mozilla/EditAction.h"
-#include "mozilla/EditorDOMPoint.h"
-#include "mozilla/EditorUtils.h"
 #include "mozilla/InternalMutationEvent.h"
 #include "mozilla/MathAlgorithms.h"
 #include "mozilla/OwningNonNull.h"
@@ -25,7 +27,6 @@
 #include "mozilla/RangeUtils.h"
 #include "mozilla/StaticPrefs_editor.h"  // for StaticPrefs::editor_*
 #include "mozilla/TextComposition.h"
-#include "mozilla/TypeInState.h"  // for SpecifiedStyle
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 #include "mozilla/dom/AncestorIterator.h"
@@ -1869,7 +1870,7 @@
             "eDoNotCreateEmptyContainer) failed");
         return splitLinkNodeResult.Rv();
       }
-      pointToBreak = splitLinkNodeResult.SplitPoint();
+      pointToBreak = splitLinkNodeResult.AtSplitPoint<EditorDOMPoint>();
     }
     Result<RefPtr<Element>, nsresult> result =
         WhiteSpaceVisibilityKeeper::InsertBRElement(*this, pointToBreak);
@@ -2143,7 +2144,8 @@
   // FYI: splitCiteNodeResult grabs the previous node with nsCOMPtr.  So, it's
   //      safe to access previousNodeOfSplitPoint even after changing the DOM
   //      tree and/or selection even though it's raw pointer.
-  nsIContent* previousNodeOfSplitPoint = splitCiteNodeResult.GetPreviousNode();
+  nsIContent* previousNodeOfSplitPoint =
+      splitCiteNodeResult.GetPreviousContent();
   if (previousNodeOfSplitPoint &&
       previousNodeOfSplitPoint->IsHTMLElement(nsGkAtoms::span) &&
       previousNodeOfSplitPoint->GetPrimaryFrame() &&
@@ -2167,16 +2169,14 @@
   // In most cases, <br> should be inserted after current cite.  However, if
   // left cite hasn't been created because the split point was start of the
   // cite node, <br> should be inserted before the current cite.
-  EditorDOMPoint pointToInsertBRNode(splitCiteNodeResult.SplitPoint());
   Result<RefPtr<Element>, nsresult> resultOfInsertingBRElement =
-      InsertBRElementWithTransaction(pointToInsertBRNode);
+      InsertBRElementWithTransaction(
+          splitCiteNodeResult.AtSplitPoint<EditorDOMPoint>());
   if (resultOfInsertingBRElement.isErr()) {
     NS_WARNING("HTMLEditor::InsertBRElementWithTransaction() failed");
     return EditActionIgnored(resultOfInsertingBRElement.unwrapErr());
   }
   MOZ_ASSERT(resultOfInsertingBRElement.inspect());
-  // Now, offset of pointToInsertBRNode is invalid.  Let's clear it.
-  pointToInsertBRNode.Clear();
 
   // Want selection before the break, and on same line.
   EditorDOMPoint atBRElement(resultOfInsertingBRElement.inspect());
@@ -3578,10 +3578,10 @@
         NS_WARNING("HTMLEditor::SplitNodeDeepWithTransaction() failed");
         return splitNodeResult.Rv();
       }
-      EditorDOMPoint pointToInsertBRNode(splitNodeResult.SplitPoint());
       // Put a <br> element at the split point
       Result<RefPtr<Element>, nsresult> resultOfInsertingBRElement =
-          InsertBRElementWithTransaction(pointToInsertBRNode);
+          InsertBRElementWithTransaction(
+              splitNodeResult.AtSplitPoint<EditorDOMPoint>());
       if (resultOfInsertingBRElement.isErr()) {
         NS_WARNING("HTMLEditor::InsertBRElementWithTransaction() failed");
         return resultOfInsertingBRElement.unwrapErr();
@@ -5083,7 +5083,7 @@
             "eAllowToCreateEmptyContainer) failed");
         return splitTextNodeResult.Rv();
       }
-      pointToPutCaret = splitTextNodeResult.SplitPoint();
+      pointToPutCaret = splitTextNodeResult.AtSplitPoint<EditorDOMPoint>();
     }
     if (!pointToPutCaret.IsInContentNode() ||
         !HTMLEditUtils::IsContainerNode(
@@ -6667,7 +6667,8 @@
             "eDoNotCreateEmptyContainer) caused changing editing host");
         return NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE;
       }
-      EditorRawDOMPoint splitPointAtEnd(splitEndInlineResult.SplitPoint());
+      const EditorRawDOMPoint& splitPointAtEnd =
+          splitEndInlineResult.AtSplitPoint<EditorRawDOMPoint>();
       if (!splitPointAtEnd.IsSet()) {
         NS_WARNING(
             "HTMLEditor::SplitNodeDeepWithTransaction(SplitAtEdges::"
@@ -6700,7 +6701,8 @@
     // XXX If we split only here because of collapsed range, we're modifying
     //     only start point of aRangeItem.  Shouldn't we modify end point here
     //     if it's collapsed?
-    EditorRawDOMPoint splitPointAtStart(splitStartInlineResult.SplitPoint());
+    const EditorRawDOMPoint& splitPointAtStart =
+        splitStartInlineResult.AtSplitPoint<EditorRawDOMPoint>();
     if (MOZ_UNLIKELY(!splitPointAtStart.IsSet())) {
       NS_WARNING(
           "HTMLEditor::SplitNodeDeepWithTransaction(SplitAtEdges::"
@@ -6745,7 +6747,7 @@
     }
 
     // Put previous node at the split point.
-    if (nsIContent* previousContent = splitNodeResult.GetPreviousNode()) {
+    if (nsIContent* previousContent = splitNodeResult.GetPreviousContent()) {
       // Might not be a left node.  A break might have been at the very
       // beginning of inline container, in which case
       // SplitNodeDeepWithTransaction() would not actually split anything.
@@ -6753,9 +6755,10 @@
     }
 
     // Move break outside of container and also put in node list
-    EditorDOMPoint atNextNode(splitNodeResult.GetNextNode());
     // MOZ_KnownLive because 'arrayOfBRElements' is guaranteed to keep it alive.
-    nsresult rv = MoveNodeWithTransaction(MOZ_KnownLive(brElement), atNextNode);
+    nsresult rv = MoveNodeWithTransaction(
+        MOZ_KnownLive(brElement),
+        splitNodeResult.AtNextContent<EditorDOMPoint>());
     if (NS_WARN_IF(Destroyed())) {
       return NS_ERROR_EDITOR_DESTROYED;
     }
@@ -6765,7 +6768,7 @@
     }
     aOutArrayOfContents.AppendElement(brElement);
 
-    nextContent = splitNodeResult.GetNextNode();
+    nextContent = splitNodeResult.GetNextContent();
   }
 
   // Now tack on remaining next node.
@@ -7188,17 +7191,23 @@
   // it'll be exposed as <br> with Element.innerHTML.  Therefore, we can use
   // normal <br> elements for placeholder in this case.  Note that Chromium
   // also behaves so.
-  if (splitDivOrPResult.GetPreviousNode()->IsElement()) {
+  if (Element* previousElementOfSplitPoint =
+          Element::FromNode(splitDivOrPResult.GetPreviousContent())) {
+    // MOZ_KnownLive(previousElementAtSplitPoint):
+    // It's grabbed by splitDivOrResult.
     nsresult rv = InsertBRElementIfEmptyBlockElement(
-        MOZ_KnownLive(*splitDivOrPResult.GetPreviousNode()->AsElement()));
+        MOZ_KnownLive(*previousElementOfSplitPoint));
     if (NS_FAILED(rv)) {
       NS_WARNING("HTMLEditor::InsertBRElementIfEmptyBlockElement() failed");
       return rv;
     }
   }
-  if (splitDivOrPResult.GetNextNode()->IsElement()) {
+  if (Element* nextElementOfSplitPoint =
+          Element::FromNode(splitDivOrPResult.GetNextContent())) {
+    // MOZ_KnownLive(nextElementAtSplitPoint):
+    // It's grabbed by splitDivOrResult.
     nsresult rv = InsertBRElementIfEmptyBlockElement(
-        MOZ_KnownLive(*splitDivOrPResult.GetNextNode()->AsElement()));
+        MOZ_KnownLive(*nextElementOfSplitPoint));
     if (NS_FAILED(rv)) {
       NS_WARNING("HTMLEditor::InsertBRElementIfEmptyBlockElement() failed");
       return rv;
@@ -7972,7 +7981,7 @@
     return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
-  EditorDOMPoint splitPoint = splitNodeResult.SplitPoint();
+  EditorDOMPoint splitPoint = splitNodeResult.AtSplitPoint<EditorDOMPoint>();
 
   if (aBRElementNextToSplitPoint == BRElementNextToSplitPoint::Delete) {
     // Consume a trailing br, if any.  This is to keep an alignment from