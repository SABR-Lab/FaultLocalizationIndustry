# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditor.cpp
# Commit: aeb15abd2346
# Full Hash: aeb15abd23467a3627da58edb9d9d7bacc118f21
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2021-11-24 15:52:24
# Regressor Bug: 1740858
# File Overlap Count: 1
# Description:
#   Bug 1740858 - Improve `SplitNodeResult` r=m_kato
#   
#   First, left/right node accessors are not used so that we can get rid of them.
#   However, we should have similar methods which can retrieve original node and
#   new node.  Therefore, this adds `GetNewContent()` and `GetOriginalContent()`.
# ==============================================================================

diff -r 891cba7d04e9 -r aeb15abd2346 editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp	Wed Nov 24 00:46:38 2021 +0000
+++ b/editor/libeditor/HTMLEditor.cpp	Wed Nov 24 00:56:33 2021 +0000
@@ -1924,7 +1924,7 @@
       NS_WARNING("HTMLEditor::SplitNodeDeepWithTransaction() failed");
       return EditorDOMPoint();  // TODO: Should return error with `Result`
     }
-    pointToInsert = splitNodeResult.SplitPoint();
+    pointToInsert = splitNodeResult.AtSplitPoint<EditorDOMPoint>();
     MOZ_ASSERT(pointToInsert.IsSet());
   }
 
@@ -4392,7 +4392,8 @@
       }
 
       lastSplitNodeResult =
-          SplitNodeResult(newLeftContentOrError.unwrap(), currentRightNode);
+          SplitNodeResult(newLeftContentOrError.unwrap(), currentRightNode,
+                          SplitNodeDirection::LeftNodeIsNewOne);
       if (currentRightNode == &aMostAncestorToSplit) {
         // Actually, we split aMostAncestorToSplit.
         return lastSplitNodeResult;
@@ -4404,7 +4405,8 @@
     // If the split point is end of the node and it is a text node or we're not
     // allowed to create empty container node, try to split its parent after it.
     else if (!atStartOfRightNode.IsStartOfContainer()) {
-      lastSplitNodeResult = SplitNodeResult(currentRightNode, nullptr);
+      lastSplitNodeResult = SplitNodeResult(
+          currentRightNode, nullptr, SplitNodeDirection::LeftNodeIsNewOne);
       if (currentRightNode == &aMostAncestorToSplit) {
         return lastSplitNodeResult;
       }
@@ -4418,7 +4420,8 @@
     // If the split point is start of the node and it is a text node or we're
     // not allowed to create empty container node, try to split its parent.
     else {
-      lastSplitNodeResult = SplitNodeResult(nullptr, currentRightNode);
+      lastSplitNodeResult = SplitNodeResult(
+          nullptr, currentRightNode, SplitNodeDirection::LeftNodeIsNewOne);
       if (currentRightNode == &aMostAncestorToSplit) {
         return lastSplitNodeResult;
       }