# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: 20e06cb8a8fd
# Full Hash: 20e06cb8a8fde5b133d3efa7cca3b92f127cf027
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2022-03-15 21:39:24
# Description:
#   Bug 1755458 - Use threadlocal shared WebGL context for accelerated canvas. r=lsalzman
#   
#   Because ClientWebGLContext is single threaded, we need a different
#   SharedContext for each thread that an accelerated Canvas2D is created
#   for.
# ==============================================================================

diff -r c09df30d2249 -r 20e06cb8a8fd dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Tue Mar 15 17:35:22 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Tue Mar 15 17:37:30 2022 +0000
@@ -213,16 +213,14 @@
 
 DrawTargetWebgl::~DrawTargetWebgl() {
   ClearSnapshot(false);
-
-  // If this was the last target the shared context used, then get rid of it.
-  if (--mSharedContext->mNumTargets <= 0 && sSharedContext == mSharedContext) {
-    sSharedContext = nullptr;
-  }
 }
 
 DrawTargetWebgl::SharedContext::SharedContext() = default;
 
 DrawTargetWebgl::SharedContext::~SharedContext() {
+  if (sSharedContext.init() && sSharedContext.get() == this) {
+    sSharedContext.set(nullptr);
+  }
   while (!mTextureHandles.isEmpty()) {
     PruneTextureHandle(mTextureHandles.popLast());
     --mNumTextureHandles;
@@ -264,7 +262,8 @@
   }
 }
 
-RefPtr<DrawTargetWebgl::SharedContext> DrawTargetWebgl::sSharedContext;
+MOZ_THREAD_LOCAL(DrawTargetWebgl::SharedContext*)
+DrawTargetWebgl::sSharedContext;
 
 // Try to initialize a new WebGL context. Verifies that the requested size does
 // not exceed the available texture limits and that shader creation succeeded.
@@ -275,14 +274,21 @@
   mSize = size;
   mFormat = format;
 
-  if (!sSharedContext || sSharedContext->IsContextLost()) {
+  if (!sSharedContext.init()) {
+    return false;
+  }
+
+  DrawTargetWebgl::SharedContext* sharedContext = sSharedContext.get();
+  if (!sharedContext || sharedContext->IsContextLost()) {
     mSharedContext = new DrawTargetWebgl::SharedContext;
     if (!mSharedContext->Initialize()) {
       mSharedContext = nullptr;
       return false;
     }
+
+    sSharedContext.set(mSharedContext.get());
   } else {
-    mSharedContext = sSharedContext;
+    mSharedContext = sharedContext;
   }
 
   if (size_t(std::max(size.width, size.height)) >
@@ -299,10 +305,6 @@
     return false;
   }
   mSkia->SetPermitSubpixelAA(IsOpaque(format));
-
-  // Remember the last shared context used.
-  ++mSharedContext->mNumTargets;
-  sSharedContext = mSharedContext;
   return true;
 }
 