# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: 7fea32057b92
# Full Hash: 7fea32057b920eac49960541efa2f3fea9074c19
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-02-12 09:47:43
# Regressor Bug: 1754130
# File Overlap Count: 2
# Description:
#   Bug 1754130 - Support presenting a WebGLFramebuffer to its own swap chain without opaque FB. r=aosmond,jgilbert
#   
#   Most of the support for presenting a WebGLFramebuffer to a swap chain existed as part of the
#   mechanism for opaque WebXR framebuffer support. However, such "opaque" framebuffer are meant
#   to be opaque in the sense that their attachments can't be inspected or changed, which does
# ==============================================================================

diff -r 1ac8f10e0025 -r 7fea32057b92 dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Fri Feb 11 15:36:30 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Fri Feb 11 15:36:30 2022 +0000
@@ -353,9 +353,11 @@
   }
   if (aDT != mCurrentTarget) {
     mCurrentTarget = aDT;
-    mWebgl->BindFramebuffer(LOCAL_GL_FRAMEBUFFER, aDT->mFramebuffer);
-    mViewportSize = aDT->GetSize();
-    mWebgl->Viewport(0, 0, mViewportSize.width, mViewportSize.height);
+    if (aDT) {
+      mWebgl->BindFramebuffer(LOCAL_GL_FRAMEBUFFER, aDT->mFramebuffer);
+      mViewportSize = aDT->GetSize();
+      mWebgl->Viewport(0, 0, mViewportSize.width, mViewportSize.height);
+    }
   }
   return true;
 }
@@ -648,6 +650,34 @@
   return Snapshot();
 }
 
+bool DrawTargetWebgl::CopySnapshotTo(DrawTarget* aDT) {
+  if (mSkiaValid ||
+      (mSnapshot &&
+       (mSnapshot->GetType() != SurfaceType::WEBGL ||
+        static_cast<SourceSurfaceWebgl*>(mSnapshot.get())->HasReadData()))) {
+    // There's already a snapshot that is mapped, so just use that.
+    return false;
+  }
+  // Otherwise, attempt to read the data directly into the DT pixels to avoid an
+  // intermediate copy.
+  if (!PrepareContext(false)) {
+    return false;
+  }
+  uint8_t* data = nullptr;
+  IntSize size;
+  int32_t stride = 0;
+  SurfaceFormat format = SurfaceFormat::UNKNOWN;
+  if (!aDT->LockBits(&data, &size, &stride, &format)) {
+    return false;
+  }
+  bool result =
+      mSharedContext->ReadInto(data, stride, format,
+                               {0, 0, std::min(size.width, mSize.width),
+                                std::min(size.height, mSize.height)});
+  aDT->ReleaseBits(data);
+  return result;
+}
+
 void DrawTargetWebgl::MarkChanged() {
   mSkiaValid = false;
   if (RefPtr<SourceSurfaceWebgl> snapshot = ClearSnapshot()) {
@@ -1476,7 +1506,7 @@
 
 // Prune a given texture handle and release its associated resources.
 void DrawTargetWebgl::SharedContext::PruneTextureHandle(
-    RefPtr<TextureHandle> aHandle) {
+    const RefPtr<TextureHandle>& aHandle) {
   // Invalidate the handle so nothing will subsequently use its contents.
   aHandle->Invalidate();
   // If the handle has an associated SourceSurface, unlink it.
@@ -2383,12 +2413,28 @@
   if (!mWebglValid) {
     FlushFromSkia();
   }
-  // Present the WebGL context.
-  mSharedContext->mWebgl->OnBeforePaintTransaction();
+  // Present the current WebGL framebuffer.
+  mSharedContext->mWebgl->Present(mFramebuffer);
+  // Ensure WebGL state gets reset properly next draw.
+  mSharedContext->ClearTarget();
+  mSharedContext->ClearLastTexture();
   //  Ensure we're not somehow using more than the allowed texture memory.
   mSharedContext->PruneTextureMemory();
 }
 
+Maybe<layers::SurfaceDescriptor> DrawTargetWebgl::GetFrontBuffer() {
+  if (mSkiaValid && !mSkiaLayer) {
+    // If there is a valid Skia snapshot that doesn't depend on WebGL state,
+    // then don't try to upload it back to WebGL, as that may incur further
+    // readbacks during compositing.
+    return Nothing();
+  }
+  if (!mWebglValid) {
+    FlushFromSkia();
+  }
+  return mSharedContext->mWebgl->GetFrontBuffer(mFramebuffer);
+}
+
 already_AddRefed<DrawTarget> DrawTargetWebgl::CreateSimilarDrawTarget(
     const IntSize& aSize, SurfaceFormat aFormat) const {
   return mSkia->CreateSimilarDrawTarget(aSize, aFormat);