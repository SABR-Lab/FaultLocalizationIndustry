# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/CanvasRenderer.cpp
# Commit: 7fea32057b92
# Full Hash: 7fea32057b920eac49960541efa2f3fea9074c19
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-02-12 09:47:43
# Regressor Bug: 1754130
# File Overlap Count: 2
# Description:
#   Bug 1754130 - Support presenting a WebGLFramebuffer to its own swap chain without opaque FB. r=aosmond,jgilbert
#   
#   Most of the support for presenting a WebGLFramebuffer to a swap chain existed as part of the
#   mechanism for opaque WebXR framebuffer support. However, such "opaque" framebuffer are meant
#   to be opaque in the sense that their attachments can't be inspected or changed, which does
# ==============================================================================

diff -r 1ac8f10e0025 -r 7fea32057b92 gfx/layers/CanvasRenderer.cpp
--- a/gfx/layers/CanvasRenderer.cpp	Fri Feb 11 15:36:30 2022 +0000
+++ b/gfx/layers/CanvasRenderer.cpp	Fri Feb 11 15:36:30 2022 +0000
@@ -68,6 +68,28 @@
   return std::make_shared<BorrowedSourceSurface>(provider, ss);
 }
 
+bool CanvasRenderer::CopySnapshotTo(gfx::DrawTarget* aDT,
+                                    bool aRequireAlphaPremult) {
+  auto* const context = mData.GetContext();
+  if (!context) return false;
+
+  if (RefPtr<PersistentBufferProvider> provider =
+          context->GetBufferProvider()) {
+    // If we can copy the snapshot directly to the DT, try that first.
+    if (provider->CopySnapshotTo(aDT)) {
+      return true;
+    }
+  }
+
+  // Otherwise, we have to borrow a snapshot before we can copy it to the DT.
+  auto borrowed = BorrowSnapshot(aRequireAlphaPremult);
+  if (!borrowed) {
+    return false;
+  }
+  aDT->CopySurface(borrowed->mSurf, borrowed->mSurf->GetRect(), {0, 0});
+  return true;
+}
+
 void CanvasRenderer::FirePreTransactionCallback() const {
   if (!mData.mDoPaintCallbacks) return;
   const auto context = mData.GetContext();