# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.h
# Commit: e178aa7d969e
# Full Hash: e178aa7d969e31550222e903b8844f80732d73bd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-02-12 09:47:43
# Regressor Bug: 1754130
# File Overlap Count: 2
# Description:
#   Bug 1754130 - Implement SourceSurfaceWebgl for faster snapshots of DrawTargetWebgl. r=aosmond
#   
#   Now that each DrawTargetWebgl shares the same WebGL context, we can efficiently draw snapshots
#   of one DrawTargetWebgl to another without requiring any readback or error-prone driver-provided
#   shared context/resource mechanism. We just need to simply pass the WebGL texture from one target
# ==============================================================================

diff -r acbba09f0bce -r e178aa7d969e dom/canvas/DrawTargetWebgl.h
--- a/dom/canvas/DrawTargetWebgl.h	Fri Feb 11 19:49:55 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.h	Fri Feb 11 19:49:55 2022 +0000
@@ -34,6 +34,7 @@
 class DrawTargetWebgl;
 class PathSkia;
 class SourceSurfaceSkia;
+class SourceSurfaceWebgl;
 
 class TextureHandle;
 class SharedTexture;
@@ -55,6 +56,7 @@
   friend class SharedTextureHandle;
   friend class StandaloneTexture;
   friend class TextureHandle;
+  friend class SourceSurfaceWebgl;
 
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(DrawTargetWebgl, override)
@@ -117,6 +119,9 @@
     RefPtr<WebGLUniformLocationJS> mImageProgramSwizzle;
     RefPtr<WebGLUniformLocationJS> mImageProgramSampler;
 
+    // Scratch framebuffer used to wrap textures for miscellaneous utility ops.
+    RefPtr<WebGLFramebufferJS> mScratchFramebuffer;
+
     uint32_t mMaxTextureSize = 0;
 
     CompositionOp mLastCompositionOp = CompositionOp::OP_SOURCE;
@@ -159,11 +164,27 @@
     }
     bool SetTarget(DrawTargetWebgl* aDT);
 
+    // Reset the current target.
     void ClearTarget() { mCurrentTarget = nullptr; }
-    void ClearLastTexture() { mLastTexture = nullptr; }
+    // Reset the last used texture to force binding next use.
+    void ClearLastTexture();
 
     bool SupportsPattern(const Pattern& aPattern);
 
+    void InitTexParameters(WebGLTextureJS* aTex);
+
+    bool ReadInto(uint8_t* aDstData, int32_t aDstStride, SurfaceFormat aFormat,
+                  const IntRect& aBounds, TextureHandle* aHandle = nullptr);
+    already_AddRefed<DataSourceSurface> ReadSnapshot(
+        TextureHandle* aHandle = nullptr);
+    already_AddRefed<TextureHandle> WrapSnapshot(const IntSize& aSize,
+                                                 SurfaceFormat aFormat,
+                                                 RefPtr<WebGLTextureJS> aTex);
+    already_AddRefed<TextureHandle> CopySnapshot();
+
+    already_AddRefed<WebGLTextureJS> GetCompatibleSnapshot(
+        SourceSurface* aSurface);
+
     bool DrawRectAccel(const Rect& aRect, const Pattern& aPattern,
                        const DrawOptions& aOptions,
                        Maybe<DeviceColor> aMaskColor = Nothing(),
@@ -357,6 +378,9 @@
   void MarkSkiaChanged(const DrawOptions& aOptions);
 
   bool ReadInto(uint8_t* aDstData, int32_t aDstStride);
+  already_AddRefed<DataSourceSurface> ReadSnapshot();
+  already_AddRefed<TextureHandle> CopySnapshot();
+  already_AddRefed<SourceSurfaceWebgl> ClearSnapshot();
 
   bool CreateFramebuffer();
 };