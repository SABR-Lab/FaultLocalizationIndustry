# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: f30dd1bddb47
# Full Hash: f30dd1bddb471a4f3487fe0e55e8c4bad0f8962a
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-02-12 09:47:43
# Regressor Bug: 1754130
# File Overlap Count: 2
# Description:
#   Bug 1754130 - Support presenting a WebGLFramebuffer to its own swap chain without opaque FB. r=aosmond,jgilbert
#   
#   Most of the support for presenting a WebGLFramebuffer to a swap chain existed as part of the
#   mechanism for opaque WebXR framebuffer support. However, such "opaque" framebuffer are meant
#   to be opaque in the sense that their attachments can't be inspected or changed, which does
# ==============================================================================

diff -r e178aa7d969e -r f30dd1bddb47 dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Fri Feb 11 19:49:55 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Fri Feb 11 19:49:56 2022 +0000
@@ -206,6 +206,11 @@
     snapshot->GiveTexture(
         mSharedContext->WrapSnapshot(GetSize(), GetFormat(), mTex.forget()));
   }
+
+  // If this was the last target the shared context used, then get rid of it.
+  if (--mSharedContext->mNumTargets <= 0 && sSharedContext == mSharedContext) {
+    sSharedContext = nullptr;
+  }
 }
 
 DrawTargetWebgl::SharedContext::SharedContext() = default;
@@ -252,7 +257,7 @@
   }
 }
 
-WeakPtr<DrawTargetWebgl::SharedContext> DrawTargetWebgl::sSharedContext;
+RefPtr<DrawTargetWebgl::SharedContext> DrawTargetWebgl::sSharedContext;
 
 // Try to initialize a new WebGL context. Verifies that the requested size does
 // not exceed the available texture limits and that shader creation succeeded.
@@ -269,7 +274,6 @@
       mSharedContext = nullptr;
       return false;
     }
-    sSharedContext = mSharedContext;
   } else {
     mSharedContext = sSharedContext;
   }
@@ -288,6 +292,9 @@
     return false;
   }
 
+  // Remember the last shared context used.
+  ++mSharedContext->mNumTargets;
+  sSharedContext = mSharedContext;
   return true;
 }
 
@@ -353,9 +360,11 @@
   }
   if (aDT != mCurrentTarget) {
     mCurrentTarget = aDT;
-    mWebgl->BindFramebuffer(LOCAL_GL_FRAMEBUFFER, aDT->mFramebuffer);
-    mViewportSize = aDT->GetSize();
-    mWebgl->Viewport(0, 0, mViewportSize.width, mViewportSize.height);
+    if (aDT) {
+      mWebgl->BindFramebuffer(LOCAL_GL_FRAMEBUFFER, aDT->mFramebuffer);
+      mViewportSize = aDT->GetSize();
+      mWebgl->Viewport(0, 0, mViewportSize.width, mViewportSize.height);
+    }
   }
   return true;
 }
@@ -648,6 +657,34 @@
   return Snapshot();
 }
 
+bool DrawTargetWebgl::CopySnapshotTo(DrawTarget* aDT) {
+  if (mSkiaValid ||
+      (mSnapshot &&
+       (mSnapshot->GetType() != SurfaceType::WEBGL ||
+        static_cast<SourceSurfaceWebgl*>(mSnapshot.get())->HasReadData()))) {
+    // There's already a snapshot that is mapped, so just use that.
+    return false;
+  }
+  // Otherwise, attempt to read the data directly into the DT pixels to avoid an
+  // intermediate copy.
+  if (!PrepareContext(false)) {
+    return false;
+  }
+  uint8_t* data = nullptr;
+  IntSize size;
+  int32_t stride = 0;
+  SurfaceFormat format = SurfaceFormat::UNKNOWN;
+  if (!aDT->LockBits(&data, &size, &stride, &format)) {
+    return false;
+  }
+  bool result =
+      mSharedContext->ReadInto(data, stride, format,
+                               {0, 0, std::min(size.width, mSize.width),
+                                std::min(size.height, mSize.height)});
+  aDT->ReleaseBits(data);
+  return result;
+}
+
 void DrawTargetWebgl::MarkChanged() {
   mSkiaValid = false;
   if (RefPtr<SourceSurfaceWebgl> snapshot = ClearSnapshot()) {
@@ -1476,7 +1513,7 @@
 
 // Prune a given texture handle and release its associated resources.
 void DrawTargetWebgl::SharedContext::PruneTextureHandle(
-    RefPtr<TextureHandle> aHandle) {
+    const RefPtr<TextureHandle>& aHandle) {
   // Invalidate the handle so nothing will subsequently use its contents.
   aHandle->Invalidate();
   // If the handle has an associated SourceSurface, unlink it.
@@ -2383,12 +2420,28 @@
   if (!mWebglValid) {
     FlushFromSkia();
   }
-  // Present the WebGL context.
-  mSharedContext->mWebgl->OnBeforePaintTransaction();
+  // Present the current WebGL framebuffer.
+  mSharedContext->mWebgl->Present(mFramebuffer);
+  // Ensure WebGL state gets reset properly next draw.
+  mSharedContext->ClearTarget();
+  mSharedContext->ClearLastTexture();
   //  Ensure we're not somehow using more than the allowed texture memory.
   mSharedContext->PruneTextureMemory();
 }
 
+Maybe<layers::SurfaceDescriptor> DrawTargetWebgl::GetFrontBuffer() {
+  if (mSkiaValid && !mSkiaLayer) {
+    // If there is a valid Skia snapshot that doesn't depend on WebGL state,
+    // then don't try to upload it back to WebGL, as that may incur further
+    // readbacks during compositing.
+    return Nothing();
+  }
+  if (!mWebglValid) {
+    FlushFromSkia();
+  }
+  return mSharedContext->mWebgl->GetFrontBuffer(mFramebuffer);
+}
+
 already_AddRefed<DrawTarget> DrawTargetWebgl::CreateSimilarDrawTarget(
     const IntSize& aSize, SurfaceFormat aFormat) const {
   return mSkia->CreateSimilarDrawTarget(aSize, aFormat);