# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/html/HTMLCanvasElement.cpp
# Commit: 5be8557c4721
# Full Hash: 5be8557c4721b4d1a2ac07bf5ae0516d9f2da2bc
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2021-12-10 09:10:34
# Regressor Bug: 1736177
# File Overlap Count: 2
# Description:
#   Bug 1736177 - Part 11. Plumb in OffscreenCanvasDisplayHelper. r=jgilbert
#   
#   This patch integrates OffscreenCanvasDisplayHelper with
#   HTMLCanvasElement, OffscreenCanvas and nsDisplayCanvas to allow
#   asynchronous display of an OffscreenCanvas.
# ==============================================================================

diff -r 49f8b4205a46 -r 5be8557c4721 dom/html/HTMLCanvasElement.cpp
--- a/dom/html/HTMLCanvasElement.cpp	Thu Dec 09 19:25:28 2021 +0000
+++ b/dom/html/HTMLCanvasElement.cpp	Thu Dec 09 19:25:28 2021 +0000
@@ -26,6 +26,7 @@
 #include "mozilla/dom/VideoStreamTrack.h"
 #include "mozilla/dom/MouseEvent.h"
 #include "mozilla/dom/OffscreenCanvas.h"
+#include "mozilla/dom/OffscreenCanvasDisplayHelper.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/gfx/Rect.h"
 #include "mozilla/layers/CanvasRenderer.h"
@@ -819,40 +820,45 @@
   CanvasRenderingContextHelper::ToBlob(aCx, global, aCallback, aType, aParams,
                                        usePlaceholder, aRv);
 }
-#define DISABLE_OFFSCREEN_CANVAS 1
+
 OffscreenCanvas* HTMLCanvasElement::TransferControlToOffscreen(
     ErrorResult& aRv) {
-  if (DISABLE_OFFSCREEN_CANVAS) {
-    aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+  if (mCurrentContext || mOffscreenCanvas) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
-  if (mCurrentContext) {
+
+  MOZ_ASSERT(!mOffscreenDisplay);
+
+  nsPIDOMWindowInner* win = OwnerDoc()->GetInnerWindow();
+  if (!win) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  if (!mOffscreenCanvas) {
-    MOZ_CRASH("todo");
-
-    nsPIDOMWindowInner* win = OwnerDoc()->GetInnerWindow();
-    if (!win) {
-      aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-      return nullptr;
+  LayersBackend backend = LayersBackend::LAYERS_NONE;
+  TextureType textureType = TextureType::Unknown;
+  nsIWidget* docWidget = nsContentUtils::WidgetForDocument(OwnerDoc());
+  if (docWidget) {
+    WindowRenderer* renderer = docWidget->GetWindowRenderer();
+    if (renderer) {
+      backend = renderer->GetCompositorBackendType();
+      textureType = TexTypeForWebgl(renderer->AsKnowsCompositor());
     }
+  }
 
-    // nsIntSize sz = GetWidthHeight();
-    // mOffscreenCanvas =
-    //    new OffscreenCanvas(win->AsGlobal(), sz.width, sz.height,
-    //                        GetCompositorBackendType(), renderer);
-    if (mWriteOnly) {
-      mOffscreenCanvas->SetWriteOnly();
-    }
+  nsIntSize sz = GetWidthHeight();
+  mOffscreenDisplay =
+      MakeRefPtr<OffscreenCanvasDisplayHelper>(this, sz.width, sz.height);
+  mOffscreenCanvas =
+      new OffscreenCanvas(win->AsGlobal(), sz.width, sz.height, backend,
+                          textureType, mOffscreenDisplay);
+  if (mWriteOnly) {
+    mOffscreenCanvas->SetWriteOnly();
+  }
 
-    if (!mContextObserver) {
-      mContextObserver = new HTMLCanvasElementObserver(this);
-    }
-  } else {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+  if (!mContextObserver) {
+    mContextObserver = new HTMLCanvasElementObserver(this);
   }
 
   return mOffscreenCanvas;
@@ -917,6 +923,7 @@
     JSContext* aCx, const nsAString& aContextId,
     JS::Handle<JS::Value> aContextOptions, ErrorResult& aRv) {
   if (mOffscreenCanvas) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
@@ -937,6 +944,11 @@
     return nullptr;
   }
 
+  if (mOffscreenCanvas) {
+    aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    return nullptr;
+  }
+
   CanvasContextType contextType = CanvasContextType::Canvas2D;
 
   if (!mCurrentContext) {
@@ -1002,6 +1014,16 @@
                                                 nsGkAtoms::all_urlsPermission);
 }
 
+void HTMLCanvasElement::InvalidateCanvasPlaceholder(uint32_t aWidth,
+                                                    uint32_t aHeight) {
+  // We need to keep our placeholder canvas dimensions in sync with the actual
+  // offscreen canvas. It is only a placeholder if we transferred the object to
+  // a worker thread.
+  if (mOffscreenCanvas->IsNeutered()) {
+    mOffscreenCanvas->UpdateNeuteredSize(aWidth, aHeight);
+  }
+}
+
 void HTMLCanvasElement::InvalidateCanvasContent(const gfx::Rect* damageRect) {
   // We don't need to flush anything here; if there's no frame or if
   // we plan to reframe we don't need to invalidate it anyway.
@@ -1083,29 +1105,31 @@
 }
 
 CanvasContextType HTMLCanvasElement::GetCurrentContextType() {
+  if (mOffscreenDisplay) {
+    return mOffscreenDisplay->GetContextType();
+  }
   return mCurrentContextType;
 }
 
 already_AddRefed<Image> HTMLCanvasElement::GetAsImage() {
+  if (mOffscreenDisplay) {
+    return mOffscreenDisplay->GetAsImage();
+  }
+
   if (mCurrentContext) {
     return mCurrentContext->GetAsImage();
   }
 
-  if (mOffscreenCanvas) {
-    MOZ_CRASH("todo");
-  }
-
   return nullptr;
 }
 
 bool HTMLCanvasElement::UpdateWebRenderCanvasData(
     nsDisplayListBuilder* aBuilder, WebRenderCanvasData* aCanvasData) {
+  MOZ_ASSERT(!mOffscreenDisplay);
+
   if (mCurrentContext) {
     return mCurrentContext->UpdateWebRenderCanvasData(aBuilder, aCanvasData);
   }
-  if (mOffscreenCanvas) {
-    MOZ_CRASH("todo");
-  }
 
   // Clear CanvasRenderer of WebRenderCanvasData
   aCanvasData->ClearCanvasRenderer();
@@ -1114,14 +1138,12 @@
 
 bool HTMLCanvasElement::InitializeCanvasRenderer(nsDisplayListBuilder* aBuilder,
                                                  CanvasRenderer* aRenderer) {
+  MOZ_ASSERT(!mOffscreenDisplay);
+
   if (mCurrentContext) {
     return mCurrentContext->InitializeCanvasRenderer(aBuilder, aRenderer);
   }
 
-  if (mOffscreenCanvas) {
-    MOZ_CRASH("todo");
-  }
-
   return false;
 }
 
@@ -1280,4 +1302,11 @@
   return static_cast<webgpu::CanvasContext*>(GetCurrentContext());
 }
 
+RefPtr<ImageContainer> HTMLCanvasElement::GetImageContainer() {
+  if (mOffscreenDisplay) {
+    return mOffscreenDisplay->GetImageContainer();
+  }
+  return nullptr;
+}
+
 }  // namespace mozilla::dom