# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/FinalizationObservers.cpp
# Commit: eac621ee0ea8
# Full Hash: eac621ee0ea80e28ae49bd2391ae51707b94369d
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2022-03-01 16:17:59
# Regressor Bug: 1755725
# File Overlap Count: 1
# Description:
#   Bug 1755725 - Part 3: Add cross-zone WeakRef wrappers to a weak set to keep them alive r=sfink
#   
#   This fixes weak ref behaviour with cross zone targets. Previously the wrapper
#   died because there was nothing to keep it alive and the weak ref target was
#   cleared, even if the target was still alive.
# ==============================================================================

diff -r 8e7816b5ea2a -r eac621ee0ea8 js/src/gc/FinalizationObservers.cpp
--- a/js/src/gc/FinalizationObservers.cpp	Tue Mar 01 08:28:41 2022 +0000
+++ b/js/src/gc/FinalizationObservers.cpp	Tue Mar 01 08:28:42 2022 +0000
@@ -32,12 +32,14 @@
       registries(zone),
       recordMap(zone),
       crossZoneRecords(zone),
-      weakRefMap(zone) {}
+      weakRefMap(zone),
+      crossZoneWeakRefs(zone) {}
 
 FinalizationObservers::~FinalizationObservers() {
   MOZ_ASSERT(registries.empty());
   MOZ_ASSERT(recordMap.empty());
   MOZ_ASSERT(crossZoneRecords.empty());
+  MOZ_ASSERT(crossZoneWeakRefs.empty());
 }
 
 bool GCRuntime::addFinalizationRegistry(
@@ -155,6 +157,12 @@
 }
 
 void FinalizationObservers::clearRecords() {
+  // Clear table entries related to FinalizationRecordObjects, which are not
+  // processed after the start of shutdown.
+  //
+  // WeakRefs are still updated during shutdown to avoid the possibility of
+  // stale or dangling pointers.
+
 #ifdef DEBUG
   checkTables();
 #endif
@@ -172,15 +180,18 @@
 }
 
 void FinalizationObservers::traceRoots(JSTracer* trc) {
-  // The crossZoneRecords weak map is traced as a root; this does not keep any
-  // of its entries alive by itself.
+  // The cross-zone wrapper weak maps are traced as roots; this does not keep
+  // any of their entries alive by itself.
   crossZoneRecords.trace(trc);
+  crossZoneWeakRefs.trace(trc);
 }
 
 void FinalizationObservers::traceWeakEdges(JSTracer* trc) {
-  // Sweep weak ref data.
-  weakRefMap.traceWeak(trc);
+  traceWeakWeakRefEdges(trc);
+  traceWeakFinalizationRegistryEdges(trc);
+}
 
+void FinalizationObservers::traceWeakFinalizationRegistryEdges(JSTracer* trc) {
   // Sweep finalization registry data and queue finalization records for cleanup
   // for any entries whose target is dying and remove them from the map.
 
@@ -313,27 +324,41 @@
 
 bool FinalizationObservers::addWeakRefTarget(HandleObject target,
                                              HandleObject weakRef) {
+  WeakRefObject* unwrappedWeakRef =
+      &UncheckedUnwrapWithoutExpose(weakRef)->as<WeakRefObject>();
+
+  Zone* weakRefZone = unwrappedWeakRef->zone();
+  bool crossZone = weakRefZone != zone;
+  if (crossZone && !addCrossZoneWrapper(crossZoneWeakRefs, weakRef)) {
+    return false;
+  }
+  auto wrapperGuard = mozilla::MakeScopeExit([&] {
+    if (crossZone) {
+      removeCrossZoneWrapper(crossZoneWeakRefs, weakRef);
+    }
+  });
+
   auto ptr = weakRefMap.lookupForAdd(target);
   if (!ptr && !weakRefMap.add(ptr, target, WeakRefHeapPtrVector(zone))) {
     return false;
   }
 
-  auto& refs = ptr->value();
-  return refs.emplaceBack(weakRef);
+  if (!ptr->value().emplaceBack(weakRef)) {
+    return false;
+  }
+
+  wrapperGuard.release();
+  return true;
 }
 
 void GCRuntime::nukeWeakRefWrapper(JSObject* wrapper, WeakRefObject* weakRef) {
   FinalizationObservers* observers = wrapper->zone()->finalizationObservers();
-  if (!observers) {
-    return;
-  }
-
-  if (observers->unregisterWeakRefWrapper(wrapper, weakRef)) {
-    weakRef->clearTarget();
+  if (observers) {
+    observers->unregisterWeakRefWrapper(wrapper, weakRef);
   }
 }
 
-bool FinalizationObservers::unregisterWeakRefWrapper(JSObject* wrapper,
+void FinalizationObservers::unregisterWeakRefWrapper(JSObject* wrapper,
                                                      WeakRefObject* weakRef) {
   JSObject* target = weakRef->target();
   MOZ_ASSERT(target);
@@ -348,7 +373,19 @@
     return remove;
   });
 
-  return removed;
+  if (removed) {
+    updateForRemovedWeakRef(wrapper, weakRef);
+  }
+}
+
+void FinalizationObservers::updateForRemovedWeakRef(JSObject* wrapper,
+                                                    WeakRefObject* weakRef) {
+  weakRef->clearTarget();
+
+  Zone* weakRefZone = weakRef->zone();
+  if (weakRefZone != zone) {
+    removeCrossZoneWrapper(crossZoneWeakRefs, wrapper);
+  }
 }
 
 static WeakRefObject* UnwrapWeakRef(JSObject* obj) {
@@ -357,30 +394,30 @@
   return &obj->as<WeakRefObject>();
 }
 
-void WeakRefMap::traceWeak(JSTracer* trc) {
-  for (Enum e(*this); !e.empty(); e.popFront()) {
+void FinalizationObservers::traceWeakWeakRefEdges(JSTracer* trc) {
+  for (WeakRefMap::Enum e(weakRefMap); !e.empty(); e.popFront()) {
     // If target is dying, clear the target field of all weakRefs, and remove
     // the entry from the map.
     auto result = TraceWeakEdge(trc, &e.front().mutableKey(), "WeakRef target");
     if (result.isDead()) {
       for (JSObject* obj : e.front().value()) {
-        UnwrapWeakRef(obj)->clearTarget();
+        updateForRemovedWeakRef(obj, UnwrapWeakRef(obj));
       }
       e.removeFront();
     } else {
       // Update the target field after compacting.
-      e.front().value().traceWeak(trc, result.finalTarget());
+      traceWeakWeakRefVector(trc, e.front().value(), result.finalTarget());
     }
   }
 }
 
-// Like GCVector::sweep, but this method will also update the target in every
-// weakRef in this GCVector.
-void WeakRefHeapPtrVector::traceWeak(JSTracer* trc, JSObject* target) {
-  mutableEraseIf([&](HeapPtrObject& obj) -> bool {
+void FinalizationObservers::traceWeakWeakRefVector(
+    JSTracer* trc, WeakRefHeapPtrVector& weakRefs, JSObject* target) {
+  weakRefs.mutableEraseIf([&](HeapPtrObject& obj) -> bool {
     auto result = TraceWeakEdge(trc, &obj, "WeakRef");
     if (result.isDead()) {
-      UnwrapWeakRef(result.initialTarget())->clearTarget();
+      JSObject* wrapper = result.initialTarget();
+      updateForRemovedWeakRef(wrapper, UnwrapWeakRef(wrapper));
     } else {
       UnwrapWeakRef(result.finalTarget())->setTargetUnbarriered(target);
     }
@@ -390,18 +427,30 @@
 
 #ifdef DEBUG
 void FinalizationObservers::checkTables() const {
-  // Check all cross-zone wrappers are present in crossZoneRecords.
-  size_t count = 0;
+  // Check all cross-zone wrappers are present in the appropriate table.
+  size_t recordCount = 0;
   for (auto r = recordMap.all(); !r.empty(); r.popFront()) {
     for (JSObject* object : r.front().value()) {
       FinalizationRecordObject* record = UnwrapFinalizationRecord(object);
       if (record && record->zone() != zone) {
         MOZ_ASSERT(crossZoneRecords.has(object));
-        count++;
+        recordCount++;
       }
     }
   }
-  MOZ_ASSERT(crossZoneRecords.count() == count);
+  MOZ_ASSERT(crossZoneRecords.count() == recordCount);
+
+  size_t weakRefCount = 0;
+  for (auto r = weakRefMap.all(); !r.empty(); r.popFront()) {
+    for (JSObject* object : r.front().value()) {
+      WeakRefObject* weakRef = UnwrapWeakRef(object);
+      if (weakRef && weakRef->zone() != zone) {
+        MOZ_ASSERT(crossZoneWeakRefs.has(object));
+        weakRefCount++;
+      }
+    }
+  }
+  MOZ_ASSERT(crossZoneWeakRefs.count() == weakRefCount);
 }
 #endif
 