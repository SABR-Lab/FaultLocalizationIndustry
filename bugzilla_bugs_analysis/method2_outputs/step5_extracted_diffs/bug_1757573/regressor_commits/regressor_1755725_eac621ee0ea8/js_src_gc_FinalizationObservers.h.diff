# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/FinalizationObservers.h
# Commit: eac621ee0ea8
# Full Hash: eac621ee0ea80e28ae49bd2391ae51707b94369d
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2022-03-01 16:17:59
# Regressor Bug: 1755725
# File Overlap Count: 1
# Description:
#   Bug 1755725 - Part 3: Add cross-zone WeakRef wrappers to a weak set to keep them alive r=sfink
#   
#   This fixes weak ref behaviour with cross zone targets. Previously the wrapper
#   died because there was nothing to keep it alive and the weak ref target was
#   cleared, even if the target was still alive.
# ==============================================================================

diff -r 8e7816b5ea2a -r eac621ee0ea8 js/src/gc/FinalizationObservers.h
--- a/js/src/gc/FinalizationObservers.h	Tue Mar 01 08:28:41 2022 +0000
+++ b/js/src/gc/FinalizationObservers.h	Tue Mar 01 08:28:42 2022 +0000
@@ -21,26 +21,6 @@
 
 namespace gc {
 
-// WeakRefHeapPtrVector is a GCVector of WeakRefObjects.
-class WeakRefHeapPtrVector
-    : public GCVector<js::HeapPtrObject, 1, js::ZoneAllocPolicy> {
- public:
-  // Called to update pointer to and possibly clear the target of each
-  // WeakRefObject.
-  using GCVector::GCVector;
-  void traceWeak(JSTracer* trc, JSObject* target);
-};
-
-// WeakRefMap is a per-zone GCHashMap, which maps from the target of the JS
-// WeakRef to the list of JS WeakRefs.
-class WeakRefMap
-    : public GCHashMap<HeapPtrObject, WeakRefHeapPtrVector,
-                       MovableCellHasher<HeapPtrObject>, ZoneAllocPolicy> {
- public:
-  using GCHashMap::GCHashMap;
-  void traceWeak(JSTracer* trc);
-};
-
 // Per-zone data structures to support FinalizationRegistry and WeakRef.
 class FinalizationObservers {
   Zone* const zone;
@@ -63,16 +43,27 @@
                 ZoneAllocPolicy>;
   RecordMap recordMap;
 
-  // A weak map used as a set of cross-zone record wrappers. The weak map
-  // marking rules keep the wrappers alive while the record is alive and ensure
-  // that they are both swept in the same sweep group.
+  // A weak map used as a set of cross-zone wrappers. This is used for both
+  // finalization registries and weak refs. For the former it has wrappers to
+  // finalization record objects and for the latter wrappers to weak refs.
+  //
+  // The weak map marking rules keep the wrappers alive while their targets are
+  // alive and ensure that they are both swept in the same sweep group.
   using WrapperWeakSet = ObjectValueWeakMap;
   WrapperWeakSet crossZoneRecords;
 
   // A map of weak ref targets to a vector of weak refs that are observing the
   // target. The weak refs may be in other zones and are wrapped appropriately.
+  using WeakRefHeapPtrVector =
+      GCVector<js::HeapPtrObject, 1, js::ZoneAllocPolicy>;
+  using WeakRefMap =
+      GCHashMap<HeapPtrObject, WeakRefHeapPtrVector,
+                MovableCellHasher<HeapPtrObject>, ZoneAllocPolicy>;
   WeakRefMap weakRefMap;
 
+  // A weak map used as a set of cross-zone weak refs wrappers.
+  WrapperWeakSet crossZoneWeakRefs;
+
  public:
   explicit FinalizationObservers(Zone* zone);
   ~FinalizationObservers();
@@ -88,7 +79,7 @@
   // WeakRef support:
   bool addWeakRefTarget(HandleObject target, HandleObject weakRef);
 
-  bool unregisterWeakRefWrapper(JSObject* wrapper, WeakRefObject* weakRef);
+  void unregisterWeakRefWrapper(JSObject* wrapper, WeakRefObject* weakRef);
 
   void traceRoots(JSTracer* trc);
   void traceWeakEdges(JSTracer* trc);
@@ -101,6 +92,13 @@
   bool addCrossZoneWrapper(WrapperWeakSet& weakSet, JSObject* wrapper);
   void removeCrossZoneWrapper(WrapperWeakSet& weakSet, JSObject* wrapper);
 
+  void updateForRemovedWeakRef(JSObject* wrapper, WeakRefObject* weakRef);
+
+  void traceWeakFinalizationRegistryEdges(JSTracer* trc);
+  void traceWeakWeakRefEdges(JSTracer* trc);
+  void traceWeakWeakRefVector(JSTracer* trc, WeakRefHeapPtrVector& weakRefs,
+                              JSObject* target);
+
   static bool shouldRemoveRecord(FinalizationRecordObject* record);
 };
 
