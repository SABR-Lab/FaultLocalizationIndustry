# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/AudioSink.cpp
# Commit: af366e7b6233
# Full Hash: af366e7b62333a382d506ba103fc414c451c5fd3
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-02-12 09:47:43
# Regressor Bug: 1754006
# File Overlap Count: 1
# Description:
#   Bug 1754006 - Increase the processed media queue size and threshold in AudioSink. r=alwu
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D138028
# ==============================================================================

diff -r b4ab5515b401 -r af366e7b6233 dom/media/mediasink/AudioSink.cpp
--- a/dom/media/mediasink/AudioSink.cpp	Fri Feb 11 16:34:24 2022 +0000
+++ b/dom/media/mediasink/AudioSink.cpp	Fri Feb 11 16:58:51 2022 +0000
@@ -30,9 +30,6 @@
 // The amount of audio frames that is used to fuzz rounding errors.
 static const int64_t AUDIO_FUZZ_FRAMES = 1;
 
-// Amount of audio frames we will be processing ahead of use
-static const int32_t LOW_AUDIO_USECS = 300000;
-
 using media::TimeUnit;
 
 AudioSink::AudioSink(AbstractThread* aThread,
@@ -54,9 +51,11 @@
           StaticPrefs::dom_media_silence_duration_for_audibility()),
       mIsAudioDataAudible(false),
       mProcessedQueueFinished(false),
-      mAudioQueue(aAudioQueue) {
+      mAudioQueue(aAudioQueue),
+      mProcessedQueueThresholdMS(
+          StaticPrefs::media_audio_audiosink_threshold_ms()) {
   // Twice the limit that trigger a refill.
-  float capacitySeconds = LOW_AUDIO_USECS / 1000. / 1000. * 2;
+  float capacitySeconds = mProcessedQueueThresholdMS / 1000.f * 2;
   mProcessedSPSCQueue =
       MakeUnique<SPSCQueue<AudioDataValue>>(static_cast<uint32_t>(
           capacitySeconds * static_cast<float>(mOutputChannels * mOutputRate)));
@@ -268,10 +267,9 @@
   NotifyAudioNeeded();
 }
 
-uint32_t AudioSink::AudioQueuedInRingBufferUs() const {
+uint32_t AudioSink::AudioQueuedInRingBufferMS() const {
   return static_cast<uint32_t>(
-      1000. * 1000 * SampleToFrame(mProcessedSPSCQueue->AvailableRead()) /
-      mOutputRate);
+      1000 * SampleToFrame(mProcessedSPSCQueue->AvailableRead()) / mOutputRate);
 }
 
 uint32_t AudioSink::SampleToFrame(uint32_t aSamples) const {
@@ -283,7 +281,7 @@
              "Not called from the owner's thread");
 
   while (mAudioQueue.GetSize() &&
-         AudioQueuedInRingBufferUs() < LOW_AUDIO_USECS) {
+         AudioQueuedInRingBufferMS() < mProcessedQueueThresholdMS) {
     // Check if there's room in our ring buffer.
     if (mAudioQueue.PeekFront()->Frames() >
         SampleToFrame(mProcessedSPSCQueue->AvailableWrite())) {