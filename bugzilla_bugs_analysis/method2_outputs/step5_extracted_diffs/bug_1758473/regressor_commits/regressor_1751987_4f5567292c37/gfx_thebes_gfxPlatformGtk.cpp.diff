# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/thebes/gfxPlatformGtk.cpp
# Commit: 4f5567292c37
# Full Hash: 4f5567292c37eedabac14b615f41c961cfc244f3
# Author: stransky <stransky@redhat.com>
# Date: 2022-02-24 03:51:41
# Regressor Bug: 1751987
# File Overlap Count: 1
# Description:
#   Bug 1751987 [Linux] Add VA-API feature r=aosmond
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D139301
# ==============================================================================

diff -r b7ea622c1205 -r 4f5567292c37 gfx/thebes/gfxPlatformGtk.cpp
--- a/gfx/thebes/gfxPlatformGtk.cpp	Wed Feb 23 11:47:06 2022 +0000
+++ b/gfx/thebes/gfxPlatformGtk.cpp	Wed Feb 23 11:47:07 2022 +0000
@@ -36,6 +36,7 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_gfx.h"
 #include "mozilla/StaticPrefs_layers.h"
+#include "mozilla/StaticPrefs_media.h"
 #include "nsAppRunner.h"
 #include "nsIGfxInfo.h"
 #include "nsMathUtils.h"
@@ -64,6 +65,7 @@
 #  include <gdk/gdkwayland.h>
 #  include "mozilla/widget/nsWaylandDisplay.h"
 #  include "mozilla/widget/DMABufLibWrapper.h"
+#  include "mozilla/widget/VAAPIUtils.h"
 #  include "mozilla/StaticPrefs_widget.h"
 #endif
 
@@ -106,11 +108,14 @@
     if (IsWaylandDisplay() || gfxConfig::IsEnabled(Feature::X11_EGL)) {
       gfxVars::SetUseEGL(true);
     }
-
     InitDmabufConfig();
     if (gfxConfig::IsEnabled(Feature::DMABUF)) {
       gfxVars::SetUseDMABuf(true);
     }
+    InitVAAPIConfig();
+    if (gfxConfig::IsEnabled(Feature::VAAPI)) {
+      gfxVars::SetUseVAAPI(true);
+    }
   }
 
   InitBackendPrefs(GetBackendPrefs());
@@ -223,6 +228,47 @@
 #endif
 }
 
+void gfxPlatformGtk::InitVAAPIConfig() {
+  FeatureState& feature = gfxConfig::GetFeature(Feature::VAAPI);
+#ifdef MOZ_WAYLAND
+  feature.DisableByDefault(FeatureStatus::Disabled,
+                           "VAAPI is disabled by default",
+                           "FEATURE_VAAPI_DISABLED"_ns);
+
+  if (StaticPrefs::media_ffmpeg_vaapi_enabled()) {
+    feature.UserForceEnable("Force enabled by pref");
+  }
+
+  nsCString failureId;
+  int32_t status;
+  nsCOMPtr<nsIGfxInfo> gfxInfo = components::GfxInfo::Service();
+  if (NS_FAILED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_VAAPI, failureId,
+                                          &status))) {
+    feature.Disable(FeatureStatus::BlockedNoGfxInfo, "gfxInfo is broken",
+                    "FEATURE_FAILURE_NO_GFX_INFO"_ns);
+  } else if (status != nsIGfxInfo::FEATURE_STATUS_OK) {
+    feature.Disable(FeatureStatus::Blocklisted, "Blocklisted by gfxInfo",
+                    failureId);
+  }
+
+  if (!gfxVars::UseEGL()) {
+    feature.ForceDisable(FeatureStatus::Unavailable, "Requires EGL",
+                         "FEATURE_FAILURE_REQUIRES_EGL"_ns);
+  }
+
+  if (feature.IsEnabled()) {
+    if (!VAAPIIsSupported()) {
+      feature.ForceDisable(FeatureStatus::Failed, "Failed to configure",
+                           failureId);
+    }
+  }
+#else
+  feature.DisableByDefault(FeatureStatus::Unavailable,
+                           "Wayland support missing",
+                           "FEATURE_FAILURE_NO_WAYLAND"_ns);
+#endif
+}
+
 void gfxPlatformGtk::InitWebRenderConfig() {
   gfxPlatform::InitWebRenderConfig();
 