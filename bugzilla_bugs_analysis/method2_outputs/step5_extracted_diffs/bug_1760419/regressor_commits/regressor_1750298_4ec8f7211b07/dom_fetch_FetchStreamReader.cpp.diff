# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/fetch/FetchStreamReader.cpp
# Commit: 4ec8f7211b07
# Full Hash: 4ec8f7211b0705481e717e365724a2e16d8601bb
# Author: Tom Schuster <evilpies@gmail.com>
# Date: 2022-03-19 09:41:58
# Regressor Bug: 1750298
# File Overlap Count: 1
# Description:
#   Bug 1750298 - Use custom ReadRequest for FetchStreamReader. r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D137681
# ==============================================================================

diff -r 1820f90df625 -r 4ec8f7211b07 dom/fetch/FetchStreamReader.cpp
--- a/dom/fetch/FetchStreamReader.cpp	Fri Mar 18 17:23:13 2022 +0000
+++ b/dom/fetch/FetchStreamReader.cpp	Fri Mar 18 17:46:32 2022 +0000
@@ -248,6 +248,43 @@
 }
 #endif
 
+#ifdef MOZ_DOM_STREAMS
+struct FetchReadRequest : public ReadRequest {
+ public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(FetchReadRequest, ReadRequest)
+
+  explicit FetchReadRequest(FetchStreamReader* aReader)
+      : mFetchStreamReader(aReader) {}
+
+  void ChunkSteps(JSContext* aCx, JS::Handle<JS::Value> aChunk,
+                  ErrorResult& aRv) override {
+    mFetchStreamReader->ChunkSteps(aCx, aChunk, aRv);
+  }
+
+  void CloseSteps(JSContext* aCx, ErrorResult& aRv) override {
+    mFetchStreamReader->CloseAndRelease(aCx, NS_BASE_STREAM_CLOSED);
+  }
+
+  void ErrorSteps(JSContext* aCx, JS::Handle<JS::Value> aError,
+                  ErrorResult& aRv) override {
+    mFetchStreamReader->ErrorSteps(aCx, aError, aRv);
+  }
+
+ protected:
+  virtual ~FetchReadRequest() = default;
+
+  RefPtr<FetchStreamReader> mFetchStreamReader;
+};
+
+NS_IMPL_CYCLE_COLLECTION_INHERITED(FetchReadRequest, ReadRequest,
+                                   mFetchStreamReader)
+NS_IMPL_ADDREF_INHERITED(FetchReadRequest, ReadRequest)
+NS_IMPL_RELEASE_INHERITED(FetchReadRequest, ReadRequest)
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(FetchReadRequest)
+NS_INTERFACE_MAP_END_INHERITING(ReadRequest)
+#endif
+
 // nsIOutputStreamCallback interface
 MOZ_CAN_RUN_SCRIPT_BOUNDARY
 NS_IMETHODIMP
@@ -273,22 +310,10 @@
 #ifdef MOZ_DOM_STREAMS
   IgnoredErrorResult rv;
 
+  // https://fetch.spec.whatwg.org/#incrementally-read-loop
   // The below very loosely tries to implement the incrementally-read-loop from
-  // the fetch spec: However, because of the structure of the surrounding code,
-  // it makes use of the Read_ReadRequest with one modification: For the
-  // purposes of this read, we use `aForAuthorCode=false` in constructing the
-  // read request. This makes the value resolve have a null prototype, hiding
-  // this code from potential interference via `Object.prototype.then`.
-  RefPtr<Promise> domPromise = Promise::Create(mGlobal, rv);
-  if (NS_WARN_IF(rv.Failed())) {
-    // Let's close the stream.
-    CloseAndRelease(aes.cx(), NS_ERROR_DOM_INVALID_STATE_ERR);
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<ReadRequest> readRequest =
-      new Read_ReadRequest(domPromise, /* aForAuthorCode = */ false);
-
+  // the fetch spec.
+  RefPtr<ReadRequest> readRequest = new FetchReadRequest(this);
   ReadableStreamDefaultReaderRead(aes.cx(), MOZ_KnownLive(mReader), readRequest,
                                   rv);
 
@@ -314,12 +339,61 @@
     CloseAndRelease(aes.cx(), NS_ERROR_DOM_INVALID_STATE_ERR);
     return NS_ERROR_FAILURE;
   }
-#endif
+
   // Let's wait.
   domPromise->AppendNativeHandler(this);
+#endif
+
   return NS_OK;
 }
 
+#ifdef MOZ_DOM_STREAMS
+void FetchStreamReader::ChunkSteps(JSContext* aCx, JS::Handle<JS::Value> aChunk,
+                                   ErrorResult& aRv) {
+  // This roughly implements the chunk steps from
+  // https://fetch.spec.whatwg.org/#incrementally-read-loop.
+
+  RootedSpiderMonkeyInterface<Uint8Array> chunk(aCx);
+  if (!aChunk.isObject() || !chunk.Init(&aChunk.toObject())) {
+    CloseAndRelease(aCx, NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+  chunk.ComputeState();
+
+  uint32_t len = chunk.Length();
+  if (len == 0) {
+    // If there is nothing to read, let's do another reading.
+    OnOutputStreamReady(mPipeOut);
+    return;
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(mBuffer.IsEmpty());
+
+  // Let's take a copy of the data.
+  if (!mBuffer.AppendElements(chunk.Data(), len, fallible)) {
+    CloseAndRelease(aCx, NS_ERROR_OUT_OF_MEMORY);
+    return;
+  }
+
+  mBufferOffset = 0;
+  mBufferRemaining = len;
+
+  nsresult rv = WriteBuffer();
+  if (NS_FAILED(rv)) {
+    // DOMException only understands errors from domerr.msg, so we normalize to
+    // identifying an abort if the write fails.
+    CloseAndRelease(aCx, NS_ERROR_DOM_ABORT_ERR);
+  }
+}
+
+void FetchStreamReader::ErrorSteps(JSContext* aCx, JS::Handle<JS::Value> aError,
+                                   ErrorResult& aRv) {
+  ReportErrorToConsole(aCx, aError);
+  CloseAndRelease(aCx, NS_ERROR_FAILURE);
+}
+
+#else
+
 void FetchStreamReader::ResolvedCallback(JSContext* aCx,
                                          JS::Handle<JS::Value> aValue,
                                          ErrorResult& aRv) {
@@ -382,6 +456,7 @@
     CloseAndRelease(aCx, NS_ERROR_DOM_ABORT_ERR);
   }
 }
+#endif
 
 nsresult FetchStreamReader::WriteBuffer() {
   MOZ_ASSERT(!mBuffer.IsEmpty());
@@ -419,12 +494,14 @@
   return NS_OK;
 }
 
+#ifndef MOZ_DOM_STREAMS
 void FetchStreamReader::RejectedCallback(JSContext* aCx,
                                          JS::Handle<JS::Value> aValue,
                                          ErrorResult& aRv) {
   ReportErrorToConsole(aCx, aValue);
   CloseAndRelease(aCx, NS_ERROR_FAILURE);
 }
+#endif
 
 void FetchStreamReader::ReportErrorToConsole(JSContext* aCx,
                                              JS::Handle<JS::Value> aValue) {