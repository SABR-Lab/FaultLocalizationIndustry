# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BaselineBailouts.cpp
# Commit: 89cdb1dee7a8
# Full Hash: 89cdb1dee7a85d6fcdc8ce81c495e4cf0c306dd3
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2022-03-24 21:54:20
# Regressor Bug: 1760989
# File Overlap Count: 1
# Description:
#   Bug 1760989 part 3 - Use ResumeMode in bailouts, other places. r=iain
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D141854
# ==============================================================================

diff -r d6b5689a4248 -r 89cdb1dee7a8 js/src/jit/BaselineBailouts.cpp
--- a/js/src/jit/BaselineBailouts.cpp	Thu Mar 24 10:08:17 2022 +0000
+++ b/js/src/jit/BaselineBailouts.cpp	Thu Mar 24 10:08:18 2022 +0000
@@ -114,6 +114,7 @@
 
   jsbytecode* pc_ = nullptr;
   JSOp op_ = JSOp::Nop;
+  mozilla::Maybe<ResumeMode> resumeMode_;
   uint32_t exprStackSlots_ = 0;
   void* prevFramePtr_ = nullptr;
   Maybe<BufferPointer<BaselineFrame>> blFrame_;
@@ -224,8 +225,10 @@
     return !catchingException() && iter_.resumeAfter();
   }
 
+  ResumeMode resumeMode() const { return *resumeMode_; }
+
   bool needToSaveCallerArgs() const {
-    return IsIonInlinableGetterOrSetterOp(op_);
+    return resumeMode() == ResumeMode::InlinedAccessor;
   }
 
   [[nodiscard]] bool enlarge() {
@@ -546,6 +549,7 @@
   pc_ = catchingException() ? excInfo_->resumePC()
                             : script_->offsetToPC(iter_.pcOffset());
   op_ = JSOp(*pc_);
+  resumeMode_ = mozilla::Some(iter_.resumeMode());
 
   return true;
 }
@@ -744,7 +748,7 @@
   return true;
 }
 
-// The caller side of inlined JSOp::FunCall and accessors must look
+// The caller side of inlined js::fun_call and accessors must look
 // like the function wasn't inlined.
 bool BaselineStackBuilder::fixUpCallerArgs(
     MutableHandleValueVector savedCallerArgs, bool* fixedUp) {
@@ -753,18 +757,20 @@
   // Inlining of SpreadCall-like frames not currently supported.
   MOZ_ASSERT(!IsSpreadOp(op_));
 
-  if (op_ != JSOp::FunCall && !needToSaveCallerArgs()) {
+  if (resumeMode() != ResumeMode::InlinedFunCall && !needToSaveCallerArgs()) {
     return true;
   }
 
   // Calculate how many arguments are consumed by the inlined call.
   // All calls pass |callee| and |this|.
   uint32_t inlinedArgs = 2;
-  if (op_ == JSOp::FunCall) {
+  if (resumeMode() == ResumeMode::InlinedFunCall) {
     // The first argument to an inlined FunCall becomes |this|,
     // if it exists. The rest are passed normally.
+    MOZ_ASSERT(IsInvokeOp(op_));
     inlinedArgs += GET_ARGC(pc_) > 0 ? GET_ARGC(pc_) - 1 : 0;
   } else {
+    MOZ_ASSERT(resumeMode() == ResumeMode::InlinedAccessor);
     MOZ_ASSERT(IsIonInlinableGetterOrSetterOp(op_));
     // Setters are passed one argument. Getters are passed none.
     if (IsSetPropOp(op_)) {
@@ -787,11 +793,11 @@
     }
   }
 
-  // When we inline JSOp::FunCall, we bypass the native and inline the
+  // When we inline js::fun_call, we bypass the native and inline the
   // target directly. When rebuilding the stack, we need to fill in
   // the right number of slots to make it look like the js_native was
   // actually called.
-  if (op_ == JSOp::FunCall) {
+  if (resumeMode() == ResumeMode::InlinedFunCall) {
     // We must transform the stack from |target, this, args| to
     // |js_fun_call, target, this, args|. The value of |js_fun_call|
     // will never be observed, so we push |undefined| for it, followed
@@ -994,7 +1000,7 @@
         return false;
       }
     }
-  } else if (op_ == JSOp::FunCall && GET_ARGC(pc_) == 0) {
+  } else if (resumeMode() == ResumeMode::InlinedFunCall && GET_ARGC(pc_) == 0) {
     // When calling FunCall with 0 arguments, we push |undefined|
     // for this. See BaselineCacheIRCompiler::pushFunCallArguments.
     MOZ_ASSERT(!pushedNewTarget);
@@ -1012,8 +1018,10 @@
     callee = *blFrame()->valueSlot(calleeSlot);
 
   } else {
+    MOZ_ASSERT(resumeMode() == ResumeMode::InlinedStandardCall ||
+               resumeMode() == ResumeMode::InlinedFunCall);
     actualArgc = GET_ARGC(pc_);
-    if (op_ == JSOp::FunCall) {
+    if (resumeMode() == ResumeMode::InlinedFunCall) {
       // See BaselineCacheIRCompiler::pushFunCallArguments.
       MOZ_ASSERT(actualArgc > 0);
       actualArgc--;
@@ -1298,12 +1306,12 @@
     return true;
   }
 
-  if (op_ == JSOp::FunCall) {
+  if (resumeMode() == ResumeMode::InlinedFunCall) {
     // For fun.call(this, ...); the reconstructed stack depth will
     // include the this. When inlining that is not included.
     // So the exprStackSlots will be one less.
     MOZ_ASSERT(expectedDepth - exprStackSlots() <= 1);
-  } else if (iter_.moreFrames() && IsIonInlinableGetterOrSetterOp(op_)) {
+  } else if (resumeMode() == ResumeMode::InlinedAccessor) {
     // Accessors coming out of ion are inlined via a complete
     // lie perpetrated by the compiler internally. Ion just rearranges
     // the stack, and pretends that it looked like a call all along.