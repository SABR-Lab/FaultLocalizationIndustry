# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmDebug.h
# Commit: 5ab04623c826
# Full Hash: 5ab04623c826b7f4d125fbb936754dd29af0a472
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2022-03-18 16:59:23
# Regressor Bug: 1756951
# File Overlap Count: 2
# Description:
#   Bug 1756951 - Part 1: Do not patch code when debugging. r=yury
#   
#   Instead of emitting a patchable call at entry/exit/breakpoints, emit a
#   conditional call to a per-instance handler that the debugger can
#   install.  The new code is larger than the code it replaces but within
# ==============================================================================

diff -r d209d5f4d95e -r 5ab04623c826 js/src/wasm/WasmDebug.h
--- a/js/src/wasm/WasmDebug.h	Fri Mar 18 07:20:52 2022 +0000
+++ b/js/src/wasm/WasmDebug.h	Fri Mar 18 07:56:07 2022 +0000
@@ -56,6 +56,30 @@
     HashMap<uint32_t, WasmBreakpointSite*, DefaultHasher<uint32_t>,
             SystemAllocPolicy>;
 
+/*
+ * [SMDOC] Wasm debug traps
+ *
+ * There is a single debug trap handler for the process, WasmHandleDebugTrap in
+ * WasmBuiltins.cpp.  That function is invoked through the Debug Trap Stub,
+ * generated by GenerateDebugTrapStub in WasmStubs.cpp.  When any function in an
+ * instance needs to trap for any reason (enter frame, leave frame, breakpoint,
+ * or single-stepping) then a pointer to the Debug Trap Stub is installed in the
+ * Instance.  Debug-enabled code will look for this pointer and call it if it is
+ * not null.
+ *
+ * WasmHandleDebugTrap may therefore be called very frequently when any function
+ * in the instance is being debugged, and must filter the trap against the
+ * tables in the DebugState.  It can make use of the return address for the
+ * call, which identifies the site uniquely.
+ *
+ * In order to greatly reduce the frequency of calls to the Debug Trap Stub, an
+ * array of flag bits, one per function, is attached to the instance.  The code
+ * at the breakable point calls a shared stub within the function containing the
+ * breakable point to check whether the bit is set for the function.  If it is
+ * not set, the stub can return to its caller immediately; if the bit is set,
+ * the stub will jump to the installed Debug Trap Stub.
+ */
+
 class DebugState {
   const SharedCode code_;
   const SharedModule module_;
@@ -69,7 +93,10 @@
   WasmBreakpointSiteMap breakpointSites_;
   StepperCounters stepperCounters_;
 
-  void toggleDebugTrap(uint32_t offset, bool enabled);
+  void enableDebuggingForFunction(Instance* instance, uint32_t funcIndex);
+  void disableDebuggingForFunction(Instance* instance, uint32_t funcIndex);
+  void enableDebugTrap(Instance* instance);
+  void disableDebugTrap(Instance* instance);
 
  public:
   DebugState(const Code& code, const Module& module);
@@ -88,15 +115,18 @@
   // debug trap. The enter/leave frame events enabled or disabled across
   // all functions.
 
-  void adjustEnterAndLeaveFrameTrapsState(JSContext* cx, bool enabled);
-  void ensureEnterFrameTrapsState(JSContext* cx, bool enabled);
+  void adjustEnterAndLeaveFrameTrapsState(JSContext* cx, Instance* instance,
+                                          bool enabled);
+  void ensureEnterFrameTrapsState(JSContext* cx, Instance* instance,
+                                  bool enabled);
   bool enterFrameTrapsEnabled() const { return enterFrameTrapsEnabled_; }
 
   // When the Code is debugEnabled, individual breakpoints can be enabled or
   // disabled at instruction offsets.
 
   bool hasBreakpointTrapAtOffset(uint32_t offset);
-  void toggleBreakpointTrap(JSRuntime* rt, uint32_t offset, bool enabled);
+  void toggleBreakpointTrap(JSRuntime* rt, Instance* instance, uint32_t offset,
+                            bool enabled);
   WasmBreakpointSite* getBreakpointSite(uint32_t offset) const;
   WasmBreakpointSite* getOrCreateBreakpointSite(JSContext* cx,
                                                 Instance* instance,
@@ -111,8 +141,10 @@
   // the granularity of individual functions.
 
   bool stepModeEnabled(uint32_t funcIndex) const;
-  [[nodiscard]] bool incrementStepperCount(JSContext* cx, uint32_t funcIndex);
-  void decrementStepperCount(JS::GCContext* gcx, uint32_t funcIndex);
+  [[nodiscard]] bool incrementStepperCount(JSContext* cx, Instance* instance,
+                                           uint32_t funcIndex);
+  void decrementStepperCount(JS::GCContext* gcx, Instance* instance,
+                             uint32_t funcIndex);
 
   // Stack inspection helpers.
 