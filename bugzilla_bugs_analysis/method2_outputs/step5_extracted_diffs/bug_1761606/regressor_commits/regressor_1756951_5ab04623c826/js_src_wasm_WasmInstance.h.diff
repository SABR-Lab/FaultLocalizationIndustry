# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmInstance.h
# Commit: 5ab04623c826
# Full Hash: 5ab04623c826b7f4d125fbb936754dd29af0a472
# Author: Lars T Hansen <lhansen@mozilla.com>
# Date: 2022-03-18 16:59:23
# Regressor Bug: 1756951
# File Overlap Count: 2
# Description:
#   Bug 1756951 - Part 1: Do not patch code when debugging. r=yury
#   
#   Instead of emitting a patchable call at entry/exit/breakpoints, emit a
#   conditional call to a per-instance handler that the debugger can
#   install.  The new code is larger than the code it replaces but within
# ==============================================================================

diff -r d209d5f4d95e -r 5ab04623c826 js/src/wasm/WasmInstance.h
--- a/js/src/wasm/WasmInstance.h	Fri Mar 18 07:20:52 2022 +0000
+++ b/js/src/wasm/WasmInstance.h	Fri Mar 18 07:56:07 2022 +0000
@@ -78,6 +78,10 @@
   // See "Linear memory addresses and bounds checking" in WasmMemory.cpp.
   uintptr_t boundsCheckLimit_;
 
+  // Null or a pointer to a per-process builtin thunk that will invoke the Debug
+  // Trap Handler.
+  void* debugTrapHandler_;
+
   // The containing JS::Realm.
   JS::Realm* realm_;
 
@@ -163,6 +167,14 @@
   // The wasm::DebugState for this instance, if any
   const UniqueDebugState maybeDebug_;
 
+  // If debugging, this is a per-funcIndex bit table denoting whether debugging
+  // is currently enabled for the function within the instance.  The flag is set
+  // if any breakpoint or function entry or exit point needs to be visited.  It
+  // is OK to conservatively set this flag, but there is very significant
+  // overhead to taking a breakpoint trap, so managing it precisely is
+  // worthwhile.
+  uint32_t* debugFilter_;
+
 #ifdef ENABLE_WASM_GC
   // A flag to control whether a pass to trace types in global data is
   // necessary or not. Purely an optimization
@@ -230,6 +242,9 @@
   static constexpr size_t offsetOfBoundsCheckLimit() {
     return offsetof(Instance, boundsCheckLimit_);
   }
+  static constexpr size_t offsetOfDebugTrapHandler() {
+    return offsetof(Instance, debugTrapHandler_);
+  }
 
   static constexpr size_t offsetOfRealm() { return offsetof(Instance, realm_); }
   static constexpr size_t offsetOfCx() { return offsetof(Instance, cx_); }
@@ -271,11 +286,16 @@
   static constexpr size_t offsetOfPreBarrierCode() {
     return offsetof(Instance, preBarrierCode_);
   }
+  static constexpr size_t offsetOfDebugFilter() {
+    return offsetof(Instance, debugFilter_);
+  }
   static constexpr size_t offsetOfGlobalArea() {
     return offsetof(Instance, globalArea_);
   }
 
   JSContext* cx() const { return cx_; }
+  void* debugTrapHandler() const { return debugTrapHandler_; }
+  void setDebugTrapHandler(void* newHandler) { debugTrapHandler_ = newHandler; }
   JS::Realm* realm() const { return realm_; }
   bool debugEnabled() const { return !!maybeDebug_; }
   DebugState& debug() { return *maybeDebug_; }
@@ -294,6 +314,9 @@
   bool isInterrupted() const;
   void resetInterrupt(JSContext* cx);
 
+  bool debugFilter(uint32_t funcIndex) const;
+  void setDebugFilter(uint32_t funcIndex, bool value);
+
   const Code& code() const { return *code_; }
   inline const CodeTier& code(Tier t) const;
   inline uint8_t* codeBase(Tier t) const;