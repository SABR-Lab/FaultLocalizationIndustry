# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: browser/components/sessionstore/SessionFile.jsm
# Commit: 2a8633af0279
# Full Hash: 2a8633af0279379685ba781c6c469e8b07ec13f4
# Author: Mathew Hodson <mathew.hodson@gmail.com>
# Date: 2022-03-26 09:28:42
# Regressor Bug: 1752853
# File Overlap Count: 1
# Description:
#   Bug 1752853 - Stop using a worker to write session store. r=Gijs,Standard8
#   
#   Remove now unused pref "browser.sessionstore.max_write_failures".
#   Rename and simplify test_shutdown_cleanup.js to make it more clear that
#   it is testing the isFinalWrite option.
# ==============================================================================

diff -r dd81d58d9d5f -r 2a8633af0279 browser/components/sessionstore/SessionFile.jsm
--- a/browser/components/sessionstore/SessionFile.jsm	Fri Mar 25 19:19:15 2022 +0000
+++ b/browser/components/sessionstore/SessionFile.jsm	Fri Mar 25 19:42:36 2022 +0000
@@ -11,17 +11,12 @@
  * This is a private API, meant to be used only by the session store.
  * It will change. Do not use it for any other purpose.
  *
- * Note that this module implicitly depends on one of two things:
- * 1. either the asynchronous file I/O system enqueues its requests
- *   and never attempts to simultaneously execute two I/O requests on
- *   the files used by this module from two distinct threads; or
- * 2. the clients of this API are well-behaved and do not place
- *   concurrent requests to the files used by this module.
- *
+ * Note that this module depends on SessionWriter and that it enqueues its I/O
+ * requests and never attempts to simultaneously execute two I/O requests on
+ * the files used by this module from two distinct threads.
  * Otherwise, we could encounter bugs, especially under Windows,
- *   e.g. if a request attempts to write sessionstore.js while
- *   another attempts to copy that file.
- *
+ * e.g. if a request attempts to write sessionstore.js while
+ * another attempts to copy that file.
  */
 
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
@@ -32,7 +27,7 @@
 XPCOMUtils.defineLazyModuleGetters(this, {
   RunState: "resource:///modules/sessionstore/RunState.jsm",
   SessionStore: "resource:///modules/sessionstore/SessionStore.jsm",
-  SessionWorker: "resource:///modules/sessionstore/SessionWorker.jsm",
+  SessionWriter: "resource:///modules/sessionstore/SessionWriter.jsm",
 });
 
 const PREF_UPGRADE_BACKUP = "browser.sessionstore.upgradeBackup.latestBuildID";
@@ -42,13 +37,6 @@
 const PREF_MAX_SERIALIZE_BACK = "browser.sessionstore.max_serialize_back";
 const PREF_MAX_SERIALIZE_FWD = "browser.sessionstore.max_serialize_forward";
 
-XPCOMUtils.defineLazyPreferenceGetter(
-  this,
-  "kMaxWriteFailures",
-  "browser.sessionstore.max_write_failures",
-  5
-);
-
 var SessionFile = {
   /**
    * Read the contents of the session file, asynchronously.
@@ -58,6 +46,7 @@
   },
   /**
    * Write the contents of the session file, asynchronously.
+   * @param aData - May get changed on shutdown.
    */
   write(aData) {
     return SessionFileInternal.write(aData);
@@ -76,15 +65,11 @@
   get Paths() {
     return SessionFileInternal.Paths;
   },
-
-  get MaxWriteFailures() {
-    return kMaxWriteFailures;
-  },
 };
 
 Object.freeze(SessionFile);
 
-var profileDir = Services.dirsvc.get("ProfD", Ci.nsIFile).path;
+const profileDir = PathUtils.profileDir;
 
 var SessionFileInternal = {
   Paths: Object.freeze({
@@ -194,14 +179,8 @@
   // Used for error reporting.
   _failures: 0,
 
-  // Object that keeps statistics that should help us make informed decisions
-  // about the current status of the worker.
-  _workerHealth: {
-    failures: 0,
-  },
-
-  // `true` once we have started initialization of the worker.
-  _initializationStarted: false,
+  // `true` once we have initialized SessionWriter.
+  _initialized: false,
 
   // A string that will be set to the session file name part that was read from
   // disk. It will be available _after_ a session file read() is done.
@@ -325,7 +304,7 @@
     return { result, noFilesFound };
   },
 
-  // Find the correct session file, read it and setup the worker.
+  // Find the correct session file and read it.
   async read() {
     // Load session files with lz4 compression.
     let { result, noFilesFound } = await this._readInternal(false);
@@ -355,87 +334,38 @@
 
     result.noFilesFound = noFilesFound;
 
-    // Initialize the worker (in the background) to let it handle backups and also
-    // as a workaround for bug 964531.
-    this._initWorker();
-
     return result;
   },
 
-  // Initialize the worker in the background.
-  // Since this called _before_ any other messages are posted to the worker (see
-  // `_postToWorker()`), we know that this initialization process will be completed
-  // on time.
-  // Thus, effectively, this blocks callees on its completion.
-  // In case of a worker crash/ shutdown during its initialization phase,
-  // `_checkWorkerHealth()` will detect it and flip the `_initializationStarted`
-  // property back to `false`. This means that we'll respawn the worker upon the
-  // next request, followed by the initialization sequence here. In other words;
-  // exactly the same procedure as when the worker crashed/ shut down 'regularly'.
-  //
-  // This will never throw an error.
-  _initWorker() {
-    return new Promise(resolve => {
-      if (this._initializationStarted) {
-        resolve();
-        return;
-      }
-
-      if (!this._readOrigin) {
-        throw new Error(
-          "_initWorker called too early! Please read the session file from disk first."
-        );
-      }
+  // Initialize SessionWriter.
+  // This should be called _before_ any other methods on SessionWriter (see
+  // `_callWriter()`).
+  _initWriter() {
+    if (this._initialized) {
+      return;
+    }
 
-      this._initializationStarted = true;
-      SessionWorker.post("init", [
-        this._readOrigin,
-        this._usingOldExtension,
-        this.Paths,
-        {
-          maxUpgradeBackups: Services.prefs.getIntPref(
-            PREF_MAX_UPGRADE_BACKUPS,
-            3
-          ),
-          maxSerializeBack: Services.prefs.getIntPref(
-            PREF_MAX_SERIALIZE_BACK,
-            10
-          ),
-          maxSerializeForward: Services.prefs.getIntPref(
-            PREF_MAX_SERIALIZE_FWD,
-            -1
-          ),
-        },
-      ])
-        .catch(err => {
-          // Ensure that we report errors but that they do not stop us.
-          Promise.reject(err);
-        })
-        .then(resolve);
+    if (!this._readOrigin) {
+      throw new Error(
+        "_initWriter called too early! Please read the session file from disk first."
+      );
+    }
+
+    this._initialized = true;
+    SessionWriter.init(this._readOrigin, this._usingOldExtension, this.Paths, {
+      maxUpgradeBackups: Services.prefs.getIntPref(PREF_MAX_UPGRADE_BACKUPS, 3),
+      maxSerializeBack: Services.prefs.getIntPref(PREF_MAX_SERIALIZE_BACK, 10),
+      maxSerializeForward: Services.prefs.getIntPref(
+        PREF_MAX_SERIALIZE_FWD,
+        -1
+      ),
     });
   },
 
-  // Post a message to the worker, making sure that it has been initialized first.
-  async _postToWorker(...args) {
-    await this._initWorker();
-    return SessionWorker.post(...args);
-  },
-
-  /**
-   * For good measure, terminate the worker when we've had over `kMaxWriteFailures`
-   * amount of failures to deal with. This will spawn a fresh worker upon the next
-   * write.
-   * This also resets the `_workerHealth` stats.
-   */
-  _checkWorkerHealth() {
-    if (this._workerHealth.failures >= kMaxWriteFailures) {
-      SessionWorker.terminate();
-      // Flag as not-initialized, to ensure that the worker state init is performed
-      // upon the next request.
-      this._initializationStarted = false;
-      // Reset the counter and report to telemetry.
-      this._workerHealth.failures = 0;
-    }
+  // Call a method of SessionWriter, making sure that it has been initialized first.
+  _callWriter(method, args = []) {
+    this._initWriter();
+    return SessionWriter[method](...args);
   },
 
   write(aData) {
@@ -455,7 +385,7 @@
 
     this._attempts++;
     let options = { isFinalWrite, performShutdownCleanup };
-    let promise = this._postToWorker("write", [aData, options]);
+    let promise = this._callWriter("write", [aData, options]);
 
     // Wait until the write is done.
     promise = promise.then(
@@ -476,7 +406,6 @@
         // Catch and report any errors.
         console.error("Could not write session state file ", err, err.stack);
         this._failures++;
-        this._workerHealth.failures++;
         // By not doing anything special here we ensure that |promise| cannot
         // be rejected anymore. The shutdown/cleanup code at the end of the
         // function will thus always be executed.
@@ -510,17 +439,15 @@
           null,
           "sessionstore-final-state-write-complete"
         );
-      } else {
-        this._checkWorkerHealth();
       }
     });
   },
 
   wipe() {
-    return this._postToWorker("wipe").then(() => {
+    return this._callWriter("wipe").then(() => {
       // After a wipe, we need to make sure to re-initialize upon the next read(),
-      // because the state variables as sent to the worker have changed.
-      this._initializationStarted = false;
+      // because the state variables as sent to the writer have changed.
+      this._initialized = false;
     });
   },
 