# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsJAR.h
# Commit: 24ee1c0756ae
# Full Hash: 24ee1c0756ae49b467d53c499dd0c16839e05eb2
# Author: Randell Jesup <rjesup@wgate.com>
# Date: 2022-03-08 22:01:59
# Regressor Bug: 1744043
# File Overlap Count: 1
# Description:
#   Bug 1744043: Clean up nsJAR r=nika,valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D132794
# ==============================================================================

diff -r 1c746ea21b95 -r 24ee1c0756ae modules/libjar/nsJAR.h
--- a/modules/libjar/nsJAR.h	Tue Mar 08 13:05:28 2022 +0000
+++ b/modules/libjar/nsJAR.h	Tue Mar 08 13:57:56 2022 +0000
@@ -13,7 +13,7 @@
 #include "prinrval.h"
 
 #include "mozilla/Atomics.h"
-#include "mozilla/Mutex.h"
+#include "mozilla/RecursiveMutex.h"
 #include "nsCOMPtr.h"
 #include "nsClassHashtable.h"
 #include "nsString.h"
@@ -53,8 +53,10 @@
 
   NS_DECL_NSIZIPREADER
 
-  nsresult GetJarPath(nsACString& aResult);
+  nsresult GetFullJarPath(nsACString& aResult);
 
+  // These access to mReleaseTime, which is locked by nsZipReaderCache's
+  // mLock, not nsJAR's mLock
   PRIntervalTime GetReleaseTime() { return mReleaseTime; }
 
   bool IsReleased() { return mReleaseTime != PR_INTERVAL_NO_TIMEOUT; }
@@ -64,29 +66,27 @@
   void ClearReleaseTime() { mReleaseTime = PR_INTERVAL_NO_TIMEOUT; }
 
   void SetZipReaderCache(nsZipReaderCache* aCache) {
-    mozilla::MutexAutoLock lock(mLock);
+    mozilla::RecursiveMutexAutoLock lock(mLock);
     mCache = aCache;
   }
 
   nsresult GetNSPRFileDesc(PRFileDesc** aNSPRFileDesc);
 
  protected:
-  //-- Private data members
-  nsCOMPtr<nsIFile> mZipFile;   // The zip/jar file on disk
-  nsCString mOuterZipEntry;     // The entry in the zip this zip is reading from
-  RefPtr<nsZipArchive> mZip;    // The underlying zip archive
-  PRIntervalTime mReleaseTime;  // used by nsZipReaderCache for flushing entries
+  nsresult LoadEntry(const nsACString& aFilename, nsCString& aBuf);
+  int32_t ReadLine(const char** src);
+
+  // used by nsZipReaderCache for flushing entries; access is locked by
+  // nsZipReaderCache's mLock
+  PRIntervalTime mReleaseTime;
+
+  //-- Private data members, protected by mLock
+  mozilla::RecursiveMutex mLock;
+  nsCString mOuterZipEntry;    // The entry in the zip this zip is reading from
+  nsCOMPtr<nsIFile> mZipFile;  // The zip/jar file on disk
+  RefPtr<nsZipArchive> mZip;   // The underlying zip archive
   nsZipReaderCache*
       mCache;  // if cached, this points to the cache it's contained in
-  mozilla::Mutex mLock;  // protect mCache and mZip
-  int64_t mMtime;
-  bool mOpened;
-
-  // true if mZip was adopted from elsewhere and should not be closed by us.
-  bool mSkipArchiveClosing;
-
-  nsresult LoadEntry(const nsACString& aFilename, nsCString& aBuf);
-  int32_t ReadLine(const char** src);
 };
 
 /**
@@ -105,14 +105,14 @@
  private:
   virtual ~nsJARItem() {}
 
-  uint32_t mSize;     /* size in original file */
-  uint32_t mRealsize; /* inflated size */
-  uint32_t mCrc32;
-  PRTime mLastModTime;
-  uint16_t mCompression;
-  uint32_t mPermissions;
-  bool mIsDirectory;
-  bool mIsSynthetic;
+  const uint32_t mSize;     /* size in original file */
+  const uint32_t mRealsize; /* inflated size */
+  const uint32_t mCrc32;
+  const PRTime mLastModTime;
+  const uint16_t mCompression;
+  const uint32_t mPermissions;
+  const bool mIsDirectory;
+  const bool mIsSynthetic;
 };
 
 /**
@@ -150,6 +150,8 @@
 class nsZipReaderCache : public nsIZipReaderCache,
                          public nsIObserver,
                          public nsSupportsWeakReference {
+  friend class nsJAR;
+
  public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIZIPREADERCACHE
@@ -162,6 +164,8 @@
   typedef nsRefPtrHashtable<nsCStringHashKey, nsJAR> ZipsHashtable;
 
  protected:
+  void AssertLockOwned() { mLock.AssertCurrentThreadOwns(); }
+
   virtual ~nsZipReaderCache();
 
   mozilla::Mutex mLock;