# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: modules/libjar/nsJARInputStream.cpp
# Commit: 24ee1c0756ae
# Full Hash: 24ee1c0756ae49b467d53c499dd0c16839e05eb2
# Author: Randell Jesup <rjesup@wgate.com>
# Date: 2022-03-08 22:01:59
# Regressor Bug: 1744043
# File Overlap Count: 1
# Description:
#   Bug 1744043: Clean up nsJAR r=nika,valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D132794
# ==============================================================================

diff -r 1c746ea21b95 -r 24ee1c0756ae modules/libjar/nsJARInputStream.cpp
--- a/modules/libjar/nsJARInputStream.cpp	Tue Mar 08 13:05:28 2022 +0000
+++ b/modules/libjar/nsJARInputStream.cpp	Tue Mar 08 13:57:56 2022 +0000
@@ -25,17 +25,19 @@
 
 /*----------------------------------------------------------
  * nsJARInputStream implementation
+ * Takes ownership of |fd|, even on failure
  *--------------------------------------------------------*/
 
-nsresult nsJARInputStream::InitFile(nsJAR* aJar, nsZipItem* item) {
+nsresult nsJARInputStream::InitFile(nsZipHandle* aFd, const uint8_t* aData,
+                                    nsZipItem* aItem) {
   nsresult rv = NS_OK;
-  MOZ_ASSERT(aJar, "Argument may not be null");
-  MOZ_ASSERT(item, "Argument may not be null");
+  MOZ_ASSERT(aFd, "Argument may not be null");
+  MOZ_ASSERT(aItem, "Argument may not be null");
 
   // Mark it as closed, in case something fails in initialisation
   mMode = MODE_CLOSED;
   //-- prepare for the compression type
-  switch (item->Compression()) {
+  switch (aItem->Compression()) {
     case STORED:
       mMode = MODE_COPY;
       break;
@@ -45,23 +47,24 @@
       NS_ENSURE_SUCCESS(rv, rv);
 
       mMode = MODE_INFLATE;
-      mInCrc = item->CRC32();
+      mInCrc = aItem->CRC32();
       mOutCrc = crc32(0L, Z_NULL, 0);
       break;
 
     default:
+      mFd = aFd;
       return NS_ERROR_NOT_IMPLEMENTED;
   }
 
   // Must keep handle to filepointer and mmap structure as long as we need
   // access to the mmapped data
-  mFd = aJar->mZip->GetFD();
-  mZs.next_in = (Bytef*)aJar->mZip->GetData(item);
+  mFd = aFd;
+  mZs.next_in = (Bytef*)aData;
   if (!mZs.next_in) {
     return NS_ERROR_FILE_CORRUPTED;
   }
-  mZs.avail_in = item->Size();
-  mOutSize = item->RealSize();
+  mZs.avail_in = aItem->Size();
+  mOutSize = aItem->RealSize();
   mZs.total_out = 0;
   return NS_OK;
 }
@@ -77,7 +80,8 @@
 
   // Keep the zipReader for getting the actual zipItems
   mJar = aJar;
-  nsZipFind* find;
+  mJar->mLock.AssertCurrentThreadIn();
+  UniquePtr<nsZipFind> find;
   nsresult rv;
   // We can get aDir's contents as strings via FindEntries
   // with the following pattern (see nsIZipReader.findEntries docs)
@@ -113,7 +117,7 @@
     ++curr;
   }
   nsAutoCString pattern = escDirName + "?*~"_ns + escDirName + "?*/?*"_ns;
-  rv = mJar->mZip->FindInit(pattern.get(), &find);
+  rv = mJar->mZip->FindInit(pattern.get(), getter_Transfers(find));
   if (NS_FAILED(rv)) return rv;
 
   const char* name;
@@ -122,7 +126,6 @@
     // Must copy, to make it zero-terminated
     mArray.AppendElement(nsCString(name, nameLen));
   }
-  delete find;
 
   if (rv != NS_ERROR_FILE_TARGET_DOES_NOT_EXIST && NS_FAILED(rv)) {
     return NS_ERROR_FAILURE;  // no error translation
@@ -301,6 +304,7 @@
   uint32_t numRead = CopyDataToBuffer(aBuffer, aCount);
 
   if (aCount > 0) {
+    RecursiveMutexAutoLock lock(mJar->mLock);
     // empty the buffer and start writing directory entry lines to it
     mBuffer.Truncate();
     mCurPos = 0;