# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/frontend/BytecodeEmitter.cpp
# Commit: 5f6b9e2fc3bb
# Full Hash: 5f6b9e2fc3bb3c5fd74f9871399269a2665a5270
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2022-03-09 09:44:44
# Regressor Bug: 885514
# File Overlap Count: 1
# Description:
#   Bug 885514: Refactor try/finally to use goto r=jandem
#   
#   JSOp::Gosub is just a JSOp::Goto that lies about its effect on the stack. We can start simplifying try/finally by using a JSOp::Goto instead.
#   
#   Currently, to make the stack depth work out when returning from a finally, Gosub pretends to pop two values (the arguments to retsub), and Finally pretends to push them. This means that bytecode analysis can treat Gosub as if it falls through, and the stack depth of the jumptarget following the gosub will be correct. This patch uses a different approach: bytecode analysis marks the return address as reachable when we push it using JSOp::ResumeIndex. This means that the bytecode no longer has to lie about stack depth.
# ==============================================================================

diff -r b199b21ed5a3 -r 5f6b9e2fc3bb js/src/frontend/BytecodeEmitter.cpp
--- a/js/src/frontend/BytecodeEmitter.cpp	Tue Mar 08 21:00:30 2022 +0000
+++ b/js/src/frontend/BytecodeEmitter.cpp	Tue Mar 08 21:10:21 2022 +0000
@@ -791,7 +791,7 @@
           if (!flushPops(bce_)) {
             return false;
           }
-          if (!bce_->emitGoSub(&finallyControl.gosubs)) {
+          if (!bce_->emitJumpToFinally(&finallyControl.finallyJumps_)) {
             //      [stack] ...
             return false;
           }
@@ -5018,7 +5018,8 @@
     // debugleaveblock
     // [poplexicalenv]              only if any local aliased
     // if there is a finally block:
-    //   gosub <finally>
+    //   goto <finally>
+    //   [jump target for returning from finally]
     //   goto <after finally>
     if (!tryCatch.emitCatch()) {
       return false;
@@ -5048,12 +5049,12 @@
   return true;
 }
 
-[[nodiscard]] bool BytecodeEmitter::emitGoSub(JumpList* jump) {
+[[nodiscard]] bool BytecodeEmitter::emitJumpToFinally(JumpList* jump) {
   // Emit the following:
   //
   //     False
   //     ResumeIndex <resumeIndex>
-  //     Gosub <target>
+  //     Goto <target>
   //   resumeOffset:
   //     JumpTarget
   //
@@ -5069,9 +5070,13 @@
     return false;
   }
 
-  if (!emitJumpNoFallthrough(JSOp::Gosub, jump)) {
-    return false;
-  }
+  if (!emitJumpNoFallthrough(JSOp::Goto, jump)) {
+    return false;
+  }
+
+  // When we return from the finally, the resume index and throwing
+  // values will have been popped.
+  bytecodeSection().setStackDepth(bytecodeSection().stackDepth() - 2);
 
   uint32_t resumeIndex;
   if (!allocateResumeIndex(bytecodeSection().offset(), &resumeIndex)) {
@@ -6281,7 +6286,7 @@
    * EmitNonLocalJumpFixup may add fixup bytecode to close open try
    * blocks having finally clauses and to exit intermingled let blocks.
    * We can't simply transfer control flow to our caller in that case,
-   * because we must gosub to those finally clauses from inner to outer,
+   * because we must execute those finally clauses from inner to outer,
    * with the correct stack pointer (i.e., after popping any with,
    * for/in, etc., slots nested inside the finally's try).
    *