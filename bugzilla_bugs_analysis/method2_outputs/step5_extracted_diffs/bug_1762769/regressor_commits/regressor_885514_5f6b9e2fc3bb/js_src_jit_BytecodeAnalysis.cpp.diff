# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BytecodeAnalysis.cpp
# Commit: 5f6b9e2fc3bb
# Full Hash: 5f6b9e2fc3bb3c5fd74f9871399269a2665a5270
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2022-03-09 09:44:44
# Regressor Bug: 885514
# File Overlap Count: 1
# Description:
#   Bug 885514: Refactor try/finally to use goto r=jandem
#   
#   JSOp::Gosub is just a JSOp::Goto that lies about its effect on the stack. We can start simplifying try/finally by using a JSOp::Goto instead.
#   
#   Currently, to make the stack depth work out when returning from a finally, Gosub pretends to pop two values (the arguments to retsub), and Finally pretends to push them. This means that bytecode analysis can treat Gosub as if it falls through, and the stack depth of the jumptarget following the gosub will be correct. This patch uses a different approach: bytecode analysis marks the return address as reachable when we push it using JSOp::ResumeIndex. This means that the bytecode no longer has to lie about stack depth.
# ==============================================================================

diff -r b199b21ed5a3 -r 5f6b9e2fc3bb js/src/jit/BytecodeAnalysis.cpp
--- a/js/src/jit/BytecodeAnalysis.cpp	Tue Mar 08 21:00:30 2022 +0000
+++ b/js/src/jit/BytecodeAnalysis.cpp	Tue Mar 08 21:10:21 2022 +0000
@@ -130,22 +130,34 @@
               (tn.kind() == TryNoteKind::Catch ||
                tn.kind() == TryNoteKind::Finally)) {
             uint32_t catchOrFinallyOffset = tn.start + tn.length;
+            uint32_t targetDepth =
+                tn.kind() == TryNoteKind::Finally ? stackDepth + 2 : stackDepth;
             BytecodeInfo& targetInfo = infos_[catchOrFinallyOffset];
-            targetInfo.init(stackDepth);
+            targetInfo.init(targetDepth);
             targetInfo.setJumpTarget(/* normallyReachable = */ false);
           }
         }
         break;
       }
 
+      case JSOp::ResumeIndex: {
+        // ResumeIndex is used to push a return address for a finally block. If
+        // this op is reachable, then so is that return address (with a smaller
+        // stack depth because the resume index and `throwing` will have been
+        // popped.
+        uint32_t resumeOffset = script_->resumeOffsets()[(it.getResumeIndex())];
+        infos_[resumeOffset].init(stackDepth - 2);
+        infos_[resumeOffset].setJumpTarget(normallyReachable);
+        break;
+      }
+
       case JSOp::LoopHead:
         infos_[offset].loopHeadCanOsr = normallyReachable;
         break;
 
 #ifdef DEBUG
       case JSOp::Exception:
-      case JSOp::Finally:
-        // Sanity check: ops only emitted in catch/finally blocks are never
+        // Sanity check: ops only emitted in catch blocks are never
         // normally reachable.
         MOZ_ASSERT(!normallyReachable);
         break;
@@ -184,10 +196,7 @@
 #endif
 
       infos_[targetOffset].init(newStackDepth);
-
-      // Gosub's target is a finally-block => not normally reachable.
-      bool targetNormallyReachable = (op != JSOp::Gosub) && normallyReachable;
-      infos_[targetOffset].setJumpTarget(targetNormallyReachable);
+      infos_[targetOffset].setJumpTarget(normallyReachable);
     }
 
     // Handle any fallthrough from this opcode.
@@ -200,10 +209,7 @@
 
       // Treat the fallthrough of a branch instruction as a jump target.
       if (jump) {
-        // Gosub falls through after executing a finally-block => not normally
-        // reachable.
-        bool nextNormallyReachable = (op != JSOp::Gosub) && normallyReachable;
-        infos_[fallthroughOffset].setJumpTarget(nextNormallyReachable);
+        infos_[fallthroughOffset].setJumpTarget(normallyReachable);
       }
     }
   }