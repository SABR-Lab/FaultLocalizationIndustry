# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BaselineCodeGen.cpp
# Commit: eeaeb40f8b86
# Full Hash: eeaeb40f8b869121eff65b1c2d11af423c9a9ecc
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2022-03-09 09:44:44
# Regressor Bug: 885514
# File Overlap Count: 1
# Description:
#   Bug 885514: Simplify JSOp::Retsub r=jandem
#   
#   Currently, JSOp::Retsub takes two arguments, and uses one to decide whether to throw the second or use it as a resume index. This patch splits out the exception-handling logic into explicit bytecode, leaving JSOp::Retsub as a simple indirect jump.
#   
#   To make the generated bytecode work out nicely, I've swapped the order of the arguments: now `throwing` is on top, and the exception/resumeindex argument is underneath it.
# ==============================================================================

diff -r 1cb0b352b024 -r eeaeb40f8b86 js/src/jit/BaselineCodeGen.cpp
--- a/js/src/jit/BaselineCodeGen.cpp	Tue Mar 08 21:10:22 2022 +0000
+++ b/js/src/jit/BaselineCodeGen.cpp	Tue Mar 08 21:10:22 2022 +0000
@@ -4693,28 +4693,14 @@
 
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emit_Retsub() {
-  frame.popRegsAndSync(2);
-
-  Label isReturn;
-  masm.branchTestBooleanTruthy(/* branchIfTrue = */ false, R0, &isReturn);
-
-  // R0 is |true|. We need to throw R1.
-  prepareVMCall();
-  pushArg(R1);
-
-  using Fn = bool (*)(JSContext*, HandleValue);
-  if (!callVM<Fn, js::ThrowOperation>()) {
-    return false;
-  }
-
-  masm.bind(&isReturn);
-
-  // R0 is |false|. R1 contains the resumeIndex to jump to.
-  Register resumeIndexReg = R1.scratchReg();
-  masm.unboxInt32(R1, resumeIndexReg);
+  frame.popRegsAndSync(1);
+
+  // R0 contains the resumeIndex to jump to.
+  Register resumeIndexReg = R0.scratchReg();
+  masm.unboxInt32(R0, resumeIndexReg);
 
   Register scratch1 = R2.scratchReg();
-  Register scratch2 = R0.scratchReg();
+  Register scratch2 = R1.scratchReg();
   jumpToResumeEntry(resumeIndexReg, scratch1, scratch2);
   return true;
 }