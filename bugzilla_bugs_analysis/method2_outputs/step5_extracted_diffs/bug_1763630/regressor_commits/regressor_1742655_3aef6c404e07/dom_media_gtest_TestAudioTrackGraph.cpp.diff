# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/gtest/TestAudioTrackGraph.cpp
# Commit: 3aef6c404e07
# Full Hash: 3aef6c404e07742214a5e3c1ccbcbd2ad1eee959
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2022-01-28 04:41:16
# Regressor Bug: 1742655
# File Overlap Count: 2
# Description:
#   Bug 1742655 - Rename AudioInputTrack to AudioProcessingTrack r=pehrsons
#   
#   Depends on D134628
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D134629
# ==============================================================================

diff -r b004b579d1ce -r 3aef6c404e07 dom/media/gtest/TestAudioTrackGraph.cpp
--- a/dom/media/gtest/TestAudioTrackGraph.cpp	Thu Jan 27 22:29:35 2022 +0000
+++ b/dom/media/gtest/TestAudioTrackGraph.cpp	Thu Jan 27 22:29:35 2022 +0000
@@ -40,13 +40,13 @@
  * Common ControlMessages
  */
 struct StartInputProcessing : public ControlMessage {
-  const RefPtr<AudioInputTrack> mInputTrack;
+  const RefPtr<AudioProcessingTrack> mProcessingTrack;
   const RefPtr<AudioInputProcessing> mInputProcessing;
 
-  StartInputProcessing(AudioInputTrack* aTrack,
+  StartInputProcessing(AudioProcessingTrack* aTrack,
                        AudioInputProcessing* aInputProcessing)
       : ControlMessage(aTrack),
-        mInputTrack(aTrack),
+        mProcessingTrack(aTrack),
         mInputProcessing(aInputProcessing) {}
   void Run() override { mInputProcessing->Start(mTrack->GraphImpl()); }
 };
@@ -54,7 +54,7 @@
 struct StopInputProcessing : public ControlMessage {
   const RefPtr<AudioInputProcessing> mInputProcessing;
 
-  explicit StopInputProcessing(AudioInputTrack* aTrack,
+  explicit StopInputProcessing(AudioProcessingTrack* aTrack,
                                AudioInputProcessing* aInputProcessing)
       : ControlMessage(aTrack), mInputProcessing(aInputProcessing) {}
   void Run() override { mInputProcessing->Stop(mTrack->GraphImpl()); }
@@ -243,19 +243,20 @@
   // We open an input through this track so that there's something triggering
   // EnsureNextIteration on the fallback driver after the callback driver has
   // gotten the error.
-  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<AudioInputProcessing> listener;
   auto started = Invoke([&] {
-    inputTrack = AudioInputTrack::Create(graph);
+    processingTrack = AudioProcessingTrack::Create(graph);
     listener = new AudioInputProcessing(2);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<SetPassThrough>(inputTrack, listener, true));
-    inputTrack->SetInputProcessing(listener);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(inputTrack, listener));
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
-    EXPECT_EQ(inputTrack->DeviceId().value(), deviceId);
-    return graph->NotifyWhenDeviceStarted(inputTrack);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<SetPassThrough>(processingTrack, listener, true));
+    processingTrack->SetInputProcessing(listener);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(processingTrack, listener));
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
+    EXPECT_EQ(processingTrack->DeviceId().value(), deviceId);
+    return graph->NotifyWhenDeviceStarted(processingTrack);
   });
 
   RefPtr<SmartMockCubebStream> stream = WaitFor(cubeb->StreamInitEvent());
@@ -279,15 +280,15 @@
 
   // Clean up.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(inputTrack, listener));
-    inputTrack->DisconnectDeviceInput();
-    inputTrack->Destroy();
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(processingTrack, listener));
+    processingTrack->DisconnectDeviceInput();
+    processingTrack->Destroy();
   });
   WaitFor(cubeb->StreamDestroyEvent());
 }
 
-TEST(TestAudioTrackGraph, AudioInputTrack)
+TEST(TestAudioTrackGraph, AudioProcessingTrack)
 {
   MockCubeb* cubeb = new MockCubeb();
   CubebUtils::ForceSetCubebContext(cubeb->AsCubebContext());
@@ -303,26 +304,27 @@
 
   const CubebUtils::AudioDeviceID deviceId = (void*)1;
 
-  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<ProcessedMediaTrack> outputTrack;
   RefPtr<MediaInputPort> port;
   RefPtr<AudioInputProcessing> listener;
   auto p = Invoke([&] {
-    inputTrack = AudioInputTrack::Create(graph);
+    processingTrack = AudioProcessingTrack::Create(graph);
     outputTrack = graph->CreateForwardedInputTrack(MediaSegment::AUDIO);
     outputTrack->QueueSetAutoend(false);
     outputTrack->AddAudioOutput(reinterpret_cast<void*>(1));
-    port = outputTrack->AllocateInputPort(inputTrack);
+    port = outputTrack->AllocateInputPort(processingTrack);
     /* Primary graph: Open Audio Input through SourceMediaTrack */
     listener = new AudioInputProcessing(2);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<SetPassThrough>(inputTrack, listener, true));
-    inputTrack->SetInputProcessing(listener);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(inputTrack, listener));
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<SetPassThrough>(processingTrack, listener, true));
+    processingTrack->SetInputProcessing(listener);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(processingTrack, listener));
     // Device id does not matter. Ignore.
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
-    return graph->NotifyWhenDeviceStarted(inputTrack);
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
+    return graph->NotifyWhenDeviceStarted(processingTrack);
   });
 
   RefPtr<SmartMockCubebStream> stream = WaitFor(cubeb->StreamInitEvent());
@@ -334,7 +336,7 @@
   // Otherwise the audio driver might be going very fast while the fallback
   // system clock driver is still in an iteration.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    processingTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   uint32_t totalFrames = 0;
   WaitUntil(stream->FramesVerifiedEvent(), [&](uint32_t aFrames) {
@@ -348,10 +350,10 @@
     outputTrack->RemoveAudioOutput((void*)1);
     outputTrack->Destroy();
     port->Destroy();
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(inputTrack, listener));
-    inputTrack->DisconnectDeviceInput();
-    inputTrack->Destroy();
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(processingTrack, listener));
+    processingTrack->DisconnectDeviceInput();
+    processingTrack->Destroy();
   });
 
   uint32_t inputRate = stream->InputSampleRate();
@@ -392,22 +394,23 @@
 
   const CubebUtils::AudioDeviceID deviceId = (void*)1;
 
-  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<ProcessedMediaTrack> outputTrack;
   RefPtr<MediaInputPort> port;
   RefPtr<AudioInputProcessing> listener;
   auto p = Invoke([&] {
-    inputTrack = AudioInputTrack::Create(graph);
+    processingTrack = AudioProcessingTrack::Create(graph);
     outputTrack = graph->CreateForwardedInputTrack(MediaSegment::AUDIO);
     outputTrack->QueueSetAutoend(false);
     outputTrack->AddAudioOutput(reinterpret_cast<void*>(1));
-    port = outputTrack->AllocateInputPort(inputTrack);
+    port = outputTrack->AllocateInputPort(processingTrack);
     listener = new AudioInputProcessing(2);
-    inputTrack->SetInputProcessing(listener);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(inputTrack, listener));
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
-    return graph->NotifyWhenDeviceStarted(inputTrack);
+    processingTrack->SetInputProcessing(listener);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(processingTrack, listener));
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
+    return graph->NotifyWhenDeviceStarted(processingTrack);
   });
 
   RefPtr<SmartMockCubebStream> stream = WaitFor(cubeb->StreamInitEvent());
@@ -424,7 +427,7 @@
   // Otherwise the audio driver might be going very fast while the fallback
   // system clock driver is still in an iteration.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    processingTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   {
     uint32_t totalFrames = 0;
@@ -436,16 +439,16 @@
   cubeb->DontGoFaster();
 
   // Close the input to see that no asserts go off due to bad state.
-  DispatchFunction([&] { inputTrack->DisconnectDeviceInput(); });
+  DispatchFunction([&] { processingTrack->DisconnectDeviceInput(); });
 
   stream = WaitFor(cubeb->StreamInitEvent());
   EXPECT_FALSE(stream->mHasInput);
   Unused << WaitFor(
-      Invoke([&] { return graph->NotifyWhenDeviceStarted(inputTrack); }));
+      Invoke([&] { return graph->NotifyWhenDeviceStarted(processingTrack); }));
 
   // Output-only. Wait for another second before unmuting.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    processingTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   {
     uint32_t totalFrames = 0;
@@ -459,17 +462,18 @@
   // Re-open the input to again see that no asserts go off due to bad state.
   DispatchFunction([&] {
     // Device id does not matter. Ignore.
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
   });
 
   stream = WaitFor(cubeb->StreamInitEvent());
   EXPECT_TRUE(stream->mHasInput);
   Unused << WaitFor(
-      Invoke([&] { return graph->NotifyWhenDeviceStarted(inputTrack); }));
+      Invoke([&] { return graph->NotifyWhenDeviceStarted(processingTrack); }));
 
   // Full-duplex. Wait for another second before finishing.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    processingTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   {
     uint32_t totalFrames = 0;
@@ -485,10 +489,10 @@
     outputTrack->RemoveAudioOutput((void*)1);
     outputTrack->Destroy();
     port->Destroy();
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(inputTrack, listener));
-    inputTrack->DisconnectDeviceInput();
-    inputTrack->Destroy();
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(processingTrack, listener));
+    processingTrack->DisconnectDeviceInput();
+    processingTrack->Destroy();
   });
 
   uint32_t inputRate = stream->InputSampleRate();
@@ -534,7 +538,7 @@
   return sqrt(rms);
 }
 
-TEST(TestAudioTrackGraph, AudioInputTrackDisabling)
+TEST(TestAudioTrackGraph, AudioProcessingTrackDisabling)
 {
   MockCubeb* cubeb = new MockCubeb();
   CubebUtils::ForceSetCubebContext(cubeb->AsCubebContext());
@@ -545,25 +549,26 @@
 
   const CubebUtils::AudioDeviceID deviceId = (void*)1;
 
-  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<ProcessedMediaTrack> outputTrack;
   RefPtr<MediaInputPort> port;
   RefPtr<AudioInputProcessing> listener;
   auto p = Invoke([&] {
-    inputTrack = AudioInputTrack::Create(graph);
+    processingTrack = AudioProcessingTrack::Create(graph);
     outputTrack = graph->CreateForwardedInputTrack(MediaSegment::AUDIO);
     outputTrack->QueueSetAutoend(false);
     outputTrack->AddAudioOutput(reinterpret_cast<void*>(1));
-    port = outputTrack->AllocateInputPort(inputTrack);
+    port = outputTrack->AllocateInputPort(processingTrack);
     /* Primary graph: Open Audio Input through SourceMediaTrack */
     listener = new AudioInputProcessing(2);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<SetPassThrough>(inputTrack, listener, true));
-    inputTrack->SetInputProcessing(listener);
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(inputTrack, listener));
-    return graph->NotifyWhenDeviceStarted(inputTrack);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<SetPassThrough>(processingTrack, listener, true));
+    processingTrack->SetInputProcessing(listener);
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(processingTrack, listener));
+    return graph->NotifyWhenDeviceStarted(processingTrack);
   });
 
   RefPtr<SmartMockCubebStream> stream = WaitFor(cubeb->StreamInitEvent());
@@ -586,7 +591,7 @@
     // toggle the track enabled mode, wait a second, do this ITERATION_COUNT
     // times
     DispatchFunction([&] {
-      inputTrack->SetDisabledTrackMode(currentMode);
+      processingTrack->SetDisabledTrackMode(currentMode);
       if (currentMode == DisabledTrackMode::SILENCE_BLACK) {
         currentMode = DisabledTrackMode::ENABLED;
       } else {
@@ -606,10 +611,10 @@
     outputTrack->RemoveAudioOutput((void*)1);
     outputTrack->Destroy();
     port->Destroy();
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(inputTrack, listener));
-    inputTrack->DisconnectDeviceInput();
-    inputTrack->Destroy();
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(processingTrack, listener));
+    processingTrack->DisconnectDeviceInput();
+    processingTrack->Destroy();
   });
 
   uint64_t preSilenceSamples;
@@ -668,45 +673,46 @@
   ~AudioTrackSet() = default;
 
   void Init(MediaTrackGraph* aGraph, uint32_t aInputChannelCount) {
-    mInputTrack = AudioInputTrack::Create(aGraph);
+    mProcessingTrack = AudioProcessingTrack::Create(aGraph);
     mOutputTrack = aGraph->CreateForwardedInputTrack(MediaSegment::AUDIO);
     mOutputTrack->QueueSetAutoend(false);
     mOutputTrack->AddAudioOutput(OutputTrackKey());
-    mPort = mOutputTrack->AllocateInputPort(mInputTrack);
+    mPort = mOutputTrack->AllocateInputPort(mProcessingTrack);
     mListener = new AudioInputProcessing(aInputChannelCount);
-    mInputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<SetPassThrough>(mInputTrack, mListener, true));
-    mInputTrack->SetInputProcessing(mListener);
-    mInputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(mInputTrack, mListener));
-    mInputTrack->ConnectDeviceInput(mInputDeviceID, mListener,
-                                    PRINCIPAL_HANDLE_NONE);
+    mProcessingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<SetPassThrough>(mProcessingTrack, mListener, true));
+    mProcessingTrack->SetInputProcessing(mListener);
+    mProcessingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(mProcessingTrack, mListener));
+    mProcessingTrack->ConnectDeviceInput(mInputDeviceID, mListener,
+                                         PRINCIPAL_HANDLE_NONE);
   }
 
   void Uninit() {
     mOutputTrack->RemoveAudioOutput(OutputTrackKey());
     mOutputTrack->Destroy();
     mPort->Destroy();
-    mInputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(mInputTrack, mListener));
-    mInputTrack->DisconnectDeviceInput();
-    mInputTrack->Destroy();
+    mProcessingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(mProcessingTrack, mListener));
+    mProcessingTrack->DisconnectDeviceInput();
+    mProcessingTrack->Destroy();
 
     mPort = nullptr;
     mOutputTrack = nullptr;
     mListener = nullptr;
-    mInputTrack = nullptr;
+    mProcessingTrack = nullptr;
   }
 
-  AudioInputTrack* InputTrack() { return mInputTrack; }
+  AudioProcessingTrack* InputTrack() { return mProcessingTrack; }
   AudioInputProcessing* InputProcessing() { return mListener; }
 
   void AppendMessage(UniquePtr<ControlMessage>&& aMessage) {
-    mInputTrack->GraphImpl()->AppendMessage(std::move(aMessage));
+    mProcessingTrack->GraphImpl()->AppendMessage(std::move(aMessage));
   }
 
   RefPtr<MediaTrackGraph::GraphStartedPromise> NotifyWhenDeviceStarted() {
-    return mInputTrack->GraphImpl()->NotifyWhenDeviceStarted(mInputTrack);
+    return mProcessingTrack->GraphImpl()->NotifyWhenDeviceStarted(
+        mProcessingTrack);
   }
 
  private:
@@ -717,7 +723,7 @@
   const void* mOutputTrackKey;
 
   // Member set in Init() and unset in Uninit()
-  RefPtr<AudioInputTrack> mInputTrack;
+  RefPtr<AudioProcessingTrack> mProcessingTrack;
   RefPtr<AudioInputProcessing> mListener;
   RefPtr<ProcessedMediaTrack> mOutputTrack;
   RefPtr<MediaInputPort> mPort;
@@ -792,9 +798,9 @@
 }
 
 // The GraphDriver's input channel count is always the same as the max input
-// channel among the GraphDriver's AudioInputTracks. This test checks if the
-// GraphDriver is switched when the max input channel among the AudioInputTracks
-// change.
+// channel among the GraphDriver's AudioProcessingTracks. This test checks if
+// the GraphDriver is switched when the max input channel among the
+// AudioProcessingTracks change.
 TEST(TestAudioTrackGraph, SwitchingDriverIfMaxChannelCountChanged)
 {
   MockCubeb* cubeb = new MockCubeb();
@@ -953,19 +959,20 @@
 
   const CubebUtils::AudioDeviceID deviceId = (void*)1;
 
-  RefPtr<AudioInputTrack> inputTrack;
+  RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<AudioInputProcessing> listener;
   auto primaryStarted = Invoke([&] {
     /* Primary graph: Create input track and open it */
-    inputTrack = AudioInputTrack::Create(primary);
+    processingTrack = AudioProcessingTrack::Create(primary);
     listener = new AudioInputProcessing(2);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<SetPassThrough>(inputTrack, listener, true));
-    inputTrack->SetInputProcessing(listener);
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StartInputProcessing>(inputTrack, listener));
-    inputTrack->ConnectDeviceInput(deviceId, listener, PRINCIPAL_HANDLE_NONE);
-    return primary->NotifyWhenDeviceStarted(inputTrack);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<SetPassThrough>(processingTrack, listener, true));
+    processingTrack->SetInputProcessing(listener);
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StartInputProcessing>(processingTrack, listener));
+    processingTrack->ConnectDeviceInput(deviceId, listener,
+                                        PRINCIPAL_HANDLE_NONE);
+    return primary->NotifyWhenDeviceStarted(processingTrack);
   });
 
   RefPtr<SmartMockCubebStream> inputStream = WaitFor(cubeb->StreamInitEvent());
@@ -982,7 +989,7 @@
 
     /* How the input track connects to another ProcessedMediaTrack.
      * Check in MediaManager how it is connected to AudioStreamTrack. */
-    port = transmitter->AllocateInputPort(inputTrack);
+    port = transmitter->AllocateInputPort(processingTrack);
     receiver->AddAudioOutput((void*)1);
     return partner->NotifyWhenDeviceStarted(receiver);
   });
@@ -1014,7 +1021,7 @@
 
   // Wait for 3s worth of audio data on the receiver stream.
   DispatchFunction([&] {
-    inputTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
+    processingTrack->GraphImpl()->AppendMessage(MakeUnique<GoFaster>(cubeb));
   });
   uint32_t totalFrames = 0;
   WaitUntil(partnerStream->FramesVerifiedEvent(), [&](uint32_t aFrames) {
@@ -1029,10 +1036,10 @@
     receiver->Destroy();
     transmitter->Destroy();
     port->Destroy();
-    inputTrack->GraphImpl()->AppendMessage(
-        MakeUnique<StopInputProcessing>(inputTrack, listener));
-    inputTrack->DisconnectDeviceInput();
-    inputTrack->Destroy();
+    processingTrack->GraphImpl()->AppendMessage(
+        MakeUnique<StopInputProcessing>(processingTrack, listener));
+    processingTrack->DisconnectDeviceInput();
+    processingTrack->Destroy();
   });
 
   uint32_t inputFrequency = inputStream->InputFrequency();