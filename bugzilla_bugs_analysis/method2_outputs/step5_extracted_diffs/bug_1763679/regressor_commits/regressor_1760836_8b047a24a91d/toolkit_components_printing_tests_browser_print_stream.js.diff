# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/printing/tests/browser_print_stream.js
# Commit: 8b047a24a91d
# Full Hash: 8b047a24a91df99818fd01165b6b00d05258a3d4
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-03-31 09:35:41
# Regressor Bug: 1760836
# File Overlap Count: 1
# Description:
#   Bug 1760836 - Support printing to an nsIOutputStream. r=jfkthame,jrmuizel,webdriver-reviewers,geckoview-reviewers,agi
#   
#   The trickiest bits are the PrintTargetCG ones, the rest is just plumbing
#   and cleanups and tests, but let me know if you want those to be split
#   out, can do.
# ==============================================================================

diff -r a04583558158 -r 8b047a24a91d toolkit/components/printing/tests/browser_print_stream.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/printing/tests/browser_print_stream.js	Wed Mar 30 18:51:58 2022 +0000
@@ -0,0 +1,104 @@
+//creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const PSSVC = Cc["@mozilla.org/gfx/printsettings-service;1"].getService(
+  Ci.nsIPrintSettingsService
+);
+
+async function printToDestination(aBrowser, aDestination) {
+  let tmpDir = Services.dirsvc.get("TmpD", Ci.nsIFile);
+  let fileName = `printDestinationTest-${aDestination}.pdf`;
+  let filePath = PathUtils.join(tmpDir.path, fileName);
+
+  info(`Printing to ${filePath}`);
+
+  let settings = PSSVC.newPrintSettings;
+  settings.outputFormat = Ci.nsIPrintSettings.kOutputFormatPDF;
+  settings.outputDestination = aDestination;
+
+  settings.headerStrCenter = "";
+  settings.headerStrLeft = "";
+  settings.headerStrRight = "";
+  settings.footerStrCenter = "";
+  settings.footerStrLeft = "";
+  settings.footerStrRight = "";
+
+  settings.unwriteableMarginTop = 1; /* Just to ensure settings are respected on both */
+  let outStream = null;
+  if (aDestination == Ci.nsIPrintSettings.kOutputDestinationFile) {
+    settings.toFileName = PathUtils.join(tmpDir.path, fileName);
+  } else {
+    is(aDestination, Ci.nsIPrintSettings.kOutputDestinationStream);
+    outStream = Cc["@mozilla.org/network/file-output-stream;1"].createInstance(
+      Ci.nsIFileOutputStream
+    );
+    let tmpFile = tmpDir.clone();
+    tmpFile.append(fileName);
+    outStream.init(tmpFile, -1, 0o666, 0);
+    settings.outputStream = outStream;
+  }
+
+  await aBrowser.browsingContext.print(settings);
+
+  return filePath;
+}
+
+// In Cocoa the CGContext adds a hash, plus there are other minor
+// non-user-visible differences, so we need to be a bit sloppy here.
+const COCOA_MAX_SIZE_DIFFERENCE = 100; // bytes
+
+add_task(async function testPrintToStream() {
+  await PrintHelper.withTestPage(async helper => {
+    let filePath = await printToDestination(
+      helper.sourceBrowser,
+      Ci.nsIPrintSettings.kOutputDestinationFile
+    );
+    let streamPath = await printToDestination(
+      helper.sourceBrowser,
+      Ci.nsIPrintSettings.kOutputDestinationStream
+    );
+
+    const isCocoa = AppConstants.platform == "macosx";
+
+    // Buffering shenanigans? Wait for sizes to match... There's no great
+    // IOUtils methods to force a flush without writing anything...
+    await TestUtils.waitForCondition(async function() {
+      let fileStat = await IOUtils.stat(filePath);
+      let streamStat = await IOUtils.stat(streamPath);
+
+      ok(fileStat.size > 0, "File file should not be empty: " + fileStat.size);
+      ok(
+        streamStat.size > 0,
+        "Stream file should not be empty: " + streamStat.size
+      );
+      if (isCocoa) {
+        return (
+          Math.abs(fileStat.size - streamStat.size) < COCOA_MAX_SIZE_DIFFERENCE
+        );
+      }
+      return fileStat.size == streamStat.size;
+    }, "Sizes should match");
+
+    if (!isCocoa) {
+      let fileData = await IOUtils.read(filePath);
+      let streamData = await IOUtils.read(streamPath);
+      ok(!!fileData.length, "File should not be empty");
+      is(fileData.length, streamData.length, "File size should be equal");
+      for (let i = 0; i < fileData.length; ++i) {
+        if (fileData[i] != streamData[i]) {
+          // This doesn't work reliably on automation, but works locally...
+          todo_is(
+            fileData[i],
+            streamData[i],
+            `Files should be equal (byte ${i} different)`
+          );
+          break;
+        }
+      }
+    }
+
+    await IOUtils.remove(filePath);
+    await IOUtils.remove(streamPath);
+  });
+});