# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsDeviceContextSpecG.cpp
# Commit: 8b047a24a91d
# Full Hash: 8b047a24a91df99818fd01165b6b00d05258a3d4
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-03-31 09:35:41
# Regressor Bug: 1760836
# File Overlap Count: 1
# Description:
#   Bug 1760836 - Support printing to an nsIOutputStream. r=jfkthame,jrmuizel,webdriver-reviewers,geckoview-reviewers,agi
#   
#   The trickiest bits are the PrintTargetCG ones, the rest is just plumbing
#   and cleanups and tests, but let me know if you want those to be split
#   out, can do.
# ==============================================================================

diff -r a04583558158 -r 8b047a24a91d widget/gtk/nsDeviceContextSpecG.cpp
--- a/widget/gtk/nsDeviceContextSpecG.cpp	Wed Mar 30 18:46:53 2022 +0000
+++ b/widget/gtk/nsDeviceContextSpecG.cpp	Wed Mar 30 18:51:58 2022 +0000
@@ -74,37 +74,46 @@
   width /= TWIPS_PER_POINT_FLOAT;
   height /= TWIPS_PER_POINT_FLOAT;
 
-  nsresult rv;
-
   // We shouldn't be attempting to get a surface if we've already got a spool
   // file.
   MOZ_ASSERT(!mSpoolFile);
 
-  // Spool file. Use Glib's temporary file function since we're
-  // already dependent on the gtk software stack.
-  gchar* buf;
-  gint fd = g_file_open_tmp("XXXXXX.tmp", &buf, nullptr);
-  if (-1 == fd) return nullptr;
-  close(fd);
+  auto stream = [&]() -> nsCOMPtr<nsIOutputStream> {
+    if (mPrintSettings->GetOutputDestination() ==
+        nsIPrintSettings::kOutputDestinationStream) {
+      nsCOMPtr<nsIOutputStream> out;
+      mPrintSettings->GetOutputStream(getter_AddRefs(out));
+      return out;
+    }
+    // Spool file. Use Glib's temporary file function since we're
+    // already dependent on the gtk software stack.
+    gchar* buf;
+    gint fd = g_file_open_tmp("XXXXXX.tmp", &buf, nullptr);
+    if (-1 == fd) {
+      return nullptr;
+    }
+    close(fd);
+    if (NS_FAILED(NS_NewNativeLocalFile(nsDependentCString(buf), false,
+                                        getter_AddRefs(mSpoolFile)))) {
+      unlink(buf);
+      g_free(buf);
+      return nullptr;
+    }
+    mSpoolName = buf;
+    g_free(buf);
+    mSpoolFile->SetPermissions(0600);
+    nsCOMPtr<nsIFileOutputStream> stream =
+        do_CreateInstance("@mozilla.org/network/file-output-stream;1");
+    if (NS_FAILED(stream->Init(mSpoolFile, -1, -1, 0))) {
+      return nullptr;
+    }
+    return stream;
+  }();
 
-  rv = NS_NewNativeLocalFile(nsDependentCString(buf), false,
-                             getter_AddRefs(mSpoolFile));
-  if (NS_FAILED(rv)) {
-    unlink(buf);
-    g_free(buf);
+  if (!stream) {
     return nullptr;
   }
 
-  mSpoolName = buf;
-  g_free(buf);
-
-  mSpoolFile->SetPermissions(0600);
-
-  nsCOMPtr<nsIFileOutputStream> stream =
-      do_CreateInstance("@mozilla.org/network/file-output-stream;1");
-  rv = stream->Init(mSpoolFile, -1, -1, 0);
-  if (NS_FAILED(rv)) return nullptr;
-
   return PrintTargetPDF::CreateOrNull(stream, IntSize::Ceil(width, height));
 }
 
@@ -197,12 +206,6 @@
     return NS_ERROR_NO_INTERFACE;
   }
 
-  // This is only set by embedders
-  bool toFile;
-  aPS->GetPrintToFile(&toFile);
-
-  mToPrinter = !toFile && !aIsPrintPreview;
-
   mGtkPrintSettings = mPrintSettings->GetGtkPrintSettings();
   mGtkPageSetup = mPrintSettings->GetGtkPageSetup();
 
@@ -309,55 +312,65 @@
 }
 
 NS_IMETHODIMP nsDeviceContextSpecGTK::EndDocument() {
-  if (mToPrinter) {
-    // At this point, we might have a GtkPrinter set up in nsPrintSettingsGTK,
-    // or we might not. In the single-process case, we probably will, as this
-    // is populated by the print settings dialog, or set to the default
-    // printer.
-    // In the multi-process case, we proxy the print settings dialog over to
-    // the parent process, and only get the name of the printer back on the
-    // content process side. In that case, we need to enumerate the printers
-    // on the content side, and find a printer with a matching name.
+  switch (mPrintSettings->GetOutputDestination()) {
+    case nsIPrintSettings::kOutputDestinationPrinter: {
+      // At this point, we might have a GtkPrinter set up in nsPrintSettingsGTK,
+      // or we might not. In the single-process case, we probably will, as this
+      // is populated by the print settings dialog, or set to the default
+      // printer.
+      // In the multi-process case, we proxy the print settings dialog over to
+      // the parent process, and only get the name of the printer back on the
+      // content process side. In that case, we need to enumerate the printers
+      // on the content side, and find a printer with a matching name.
 
-    if (mPrintSettings->GetGtkPrinter()) {
-      // We have a printer, so we can print right away.
-      StartPrintJob();
-    } else {
-      // We don't have a printer. We have to enumerate the printers and find
-      // one with a matching name.
-      NS_DispatchToCurrentThread(
-          NewRunnableMethod("nsDeviceContextSpecGTK::EnumeratePrinters", this,
-                            &nsDeviceContextSpecGTK::EnumeratePrinters));
+      if (mPrintSettings->GetGtkPrinter()) {
+        // We have a printer, so we can print right away.
+        StartPrintJob();
+      } else {
+        // We don't have a printer. We have to enumerate the printers and find
+        // one with a matching name.
+        NS_DispatchToCurrentThread(
+            NewRunnableMethod("nsDeviceContextSpecGTK::EnumeratePrinters", this,
+                              &nsDeviceContextSpecGTK::EnumeratePrinters));
+      }
+      break;
     }
-  } else {
-    // Handle print-to-file ourselves for the benefit of embedders
-    nsString targetPath;
-    nsCOMPtr<nsIFile> destFile;
-    mPrintSettings->GetToFileName(targetPath);
+    case nsIPrintSettings::kOutputDestinationFile: {
+      // Handle print-to-file ourselves for the benefit of embedders
+      nsString targetPath;
+      nsCOMPtr<nsIFile> destFile;
+      mPrintSettings->GetToFileName(targetPath);
 
-    nsresult rv = NS_NewLocalFile(targetPath, false, getter_AddRefs(destFile));
-    NS_ENSURE_SUCCESS(rv, rv);
+      nsresult rv =
+          NS_NewLocalFile(targetPath, false, getter_AddRefs(destFile));
+      NS_ENSURE_SUCCESS(rv, rv);
 
-    nsAutoString destLeafName;
-    rv = destFile->GetLeafName(destLeafName);
-    NS_ENSURE_SUCCESS(rv, rv);
+      nsAutoString destLeafName;
+      rv = destFile->GetLeafName(destLeafName);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsCOMPtr<nsIFile> destDir;
+      rv = destFile->GetParent(getter_AddRefs(destDir));
+      NS_ENSURE_SUCCESS(rv, rv);
 
-    nsCOMPtr<nsIFile> destDir;
-    rv = destFile->GetParent(getter_AddRefs(destDir));
-    NS_ENSURE_SUCCESS(rv, rv);
+      rv = mSpoolFile->MoveTo(destDir, destLeafName);
+      NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = mSpoolFile->MoveTo(destDir, destLeafName);
-    NS_ENSURE_SUCCESS(rv, rv);
+      mSpoolFile = nullptr;
 
-    mSpoolFile = nullptr;
-
-    // This is the standard way to get the UNIX umask. Ugh.
-    mode_t mask = umask(0);
-    umask(mask);
-    // If you're not familiar with umasks, they contain the bits of what NOT
-    // to set in the permissions (thats because files and directories have
-    // different numbers of bits for their permissions)
-    destFile->SetPermissions(0666 & ~(mask));
+      // This is the standard way to get the UNIX umask. Ugh.
+      mode_t mask = umask(0);
+      umask(mask);
+      // If you're not familiar with umasks, they contain the bits of what NOT
+      // to set in the permissions (thats because files and directories have
+      // different numbers of bits for their permissions)
+      destFile->SetPermissions(0666 & ~(mask));
+      break;
+    }
+    case nsIPrintSettings::kOutputDestinationStream:
+      // Nothing to do, handled in MakePrintTarget.
+      MOZ_ASSERT(!mSpoolFile);
+      break;
   }
   return NS_OK;
 }