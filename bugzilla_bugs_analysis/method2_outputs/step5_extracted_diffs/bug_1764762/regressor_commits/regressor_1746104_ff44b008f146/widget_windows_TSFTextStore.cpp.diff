# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/TSFTextStore.cpp
# Commit: ff44b008f146
# Full Hash: ff44b008f1460321cf8372400ce004d8a1178ea1
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-02-08 17:32:27
# Regressor Bug: 1746104
# File Overlap Count: 1
# Description:
#   Bug 1746104 - part 1-2: Make `TSFTextStore::Selection` have "no selection" state r=m_kato
#   
#   `Selection.removeAllRanges` can make there is no selection ranges.  Therefore,
#   `TSFTextStore::Selection` needs to represent the state.  This patch changes its
#   `mACP` to `Maybe<TS_SELECTION_ACP>` for making `Nothing` of it mean no
# ==============================================================================

diff -r 14e68c94b303 -r ff44b008f146 widget/windows/TSFTextStore.cpp
--- a/widget/windows/TSFTextStore.cpp	Mon Feb 07 22:33:30 2022 +0000
+++ b/widget/windows/TSFTextStore.cpp	Mon Feb 07 22:33:31 2022 +0000
@@ -2778,11 +2778,7 @@
   Maybe<Selection>& selectionForTSF = SelectionForTSF();
   if (selectionForTSF.isNothing()) {
     if (DoNotReturnErrorFromGetSelection()) {
-      TS_SELECTION_ACP acp;
-      acp.acpStart = acp.acpEnd = 0;
-      acp.style.ase = TS_AE_START;
-      acp.style.fInterimChar = FALSE;
-      *pSelection = acp;
+      *pSelection = Selection::EmptyACP();
       *pcFetched = 1;
       MOZ_LOG(
           gIMELog, LogLevel::Info,
@@ -2797,6 +2793,11 @@
              this));
     return E_FAIL;
   }
+  if (!selectionForTSF->HasRange()) {
+    *pSelection = Selection::EmptyACP();
+    *pcFetched = 0;
+    return TS_E_NOSELECTION;
+  }
   *pSelection = selectionForTSF->ACPRef();
   *pcFetched = 1;
   MOZ_LOG(gIMELog, LogLevel::Info,
@@ -3466,7 +3467,9 @@
 
     // The caret position has to be collapsed.
     uint32_t caretPosition = static_cast<uint32_t>(
-        selectionForTSF->MaxOffset() - mComposition->StartOffset());
+        selectionForTSF->HasRange()
+            ? selectionForTSF->MaxOffset() - mComposition->StartOffset()
+            : mComposition->StartOffset());
 
     // If caret is in the target clause and it doesn't have specific style,
     // the target clause will be painted as normal selection range.  Since
@@ -4481,7 +4484,8 @@
     // the latest composition.
     options.mRelativeToInsertionPoint = true;
     startOffset -= mContentForTSF->LatestCompositionRange()->StartOffset();
-  } else if (!CanAccessActualContentDirectly()) {
+  } else if (!CanAccessActualContentDirectly() &&
+             mSelectionForTSF->HasRange()) {
     // If TSF/TIP cannot access actual content directly, there may be pending
     // text and/or selection changes which have not been notified TSF yet.
     // Therefore, we should use relative to insertion point query since
@@ -4645,10 +4649,13 @@
       // caret rect immediately after modifying the composition string but
       // before unlocking the document.  In such case, we should return the
       // nearest character rect.
+      // (Let's return true if there is no selection which must be not expected
+      // by MS-IME nor TSF.)
       if (TSFPrefs::DoNotReturnNoLayoutErrorToMSJapaneseIMEAtCaret() &&
-          selectionForTSF.isSome() && aACPStart == aACPEnd &&
-          selectionForTSF->Collapsed() &&
-          selectionForTSF->EndOffset() == aACPEnd) {
+          aACPStart == aACPEnd && selectionForTSF.isSome() &&
+          (!selectionForTSF->HasRange() ||
+           (selectionForTSF->Collapsed() &&
+            selectionForTSF->EndOffset() == aACPEnd))) {
         int32_t minOffsetOfLayoutChanged =
             static_cast<int32_t>(mContentForTSF->MinModifiedOffset().value());
         aACPEnd = aACPStart = std::max(minOffsetOfLayoutChanged - 1, 0);
@@ -4676,9 +4683,12 @@
       // caret rect immediately after modifying the composition string but
       // before unlocking the document.  In such case, we should return the
       // nearest character rect.
+      // (Let's return true if there is no selection which must be not expected
+      // by MS-IME nor TSF.)
       else if (aACPStart == aACPEnd && selectionForTSF.isSome() &&
-               selectionForTSF->Collapsed() &&
-               selectionForTSF->EndOffset() == aACPEnd) {
+               (!selectionForTSF->HasRange() ||
+                (selectionForTSF->Collapsed() &&
+                 selectionForTSF->EndOffset() == aACPEnd))) {
         int32_t minOffsetOfLayoutChanged =
             static_cast<int32_t>(mContentForTSF->MinModifiedOffset().value());
         aACPEnd = aACPStart = std::max(minOffsetOfLayoutChanged - 1, 0);
@@ -5049,13 +5059,25 @@
     }
 
     // Simulate text insertion
-    *pacpStart = selectionForTSF->StartOffset();
-    *pacpEnd = selectionForTSF->EndOffset();
-    if (pChange) {
-      pChange->acpStart = selectionForTSF->StartOffset();
-      pChange->acpOldEnd = selectionForTSF->EndOffset();
-      pChange->acpNewEnd =
-          selectionForTSF->StartOffset() + static_cast<LONG>(cch);
+    if (selectionForTSF->HasRange()) {
+      *pacpStart = selectionForTSF->StartOffset();
+      *pacpEnd = selectionForTSF->EndOffset();
+      if (pChange) {
+        *pChange = TS_TEXTCHANGE{.acpStart = selectionForTSF->StartOffset(),
+                                 .acpOldEnd = selectionForTSF->EndOffset(),
+                                 .acpNewEnd = selectionForTSF->StartOffset() +
+                                              static_cast<LONG>(cch)};
+      }
+    } else {
+      // There is no error code to return "no selection" state from this method.
+      // This means that TSF/TIP should check `GetSelection` result first and
+      // stop using this.  However, this could be called by TIP/TSF if they do
+      // not do so.  Therefore, we should use start of editor instead, but
+      // notify the caller of nothing will be inserted with pChange->acpNewEnd.
+      *pacpStart = *pacpEnd = 0;
+      if (pChange) {
+        *pChange = TS_TEXTCHANGE{.acpStart = 0, .acpOldEnd = 0, .acpNewEnd = 0};
+      }
     }
   } else {
     if (!IsReadWriteLocked()) {
@@ -5289,6 +5311,9 @@
              "due to SelectionForTSF() failure",
              this));
     action->mAdjustSelection = true;
+  } else if (!selectionForTSF->HasRange()) {
+    // If there is no selection, let's collapse seletion to the insertion point.
+    action->mAdjustSelection = true;
   } else if (selectionForTSF->MinOffset() != aStart ||
              selectionForTSF->MaxOffset() != aStart + aLength) {
     // If new composition range is different from current selection range,
@@ -5518,7 +5543,7 @@
               ("0x%p   TSFTextStore::OnUpdateComposition() FAILED due to "
                "SelectionForTSF() failure",
                this));
-      return E_FAIL;
+      return S_OK;  // Don't return error only when we're logging.
     }
     MOZ_LOG(gIMELog, LogLevel::Info,
             ("0x%p   TSFTextStore::OnUpdateComposition() succeeded: "
@@ -6400,6 +6425,10 @@
     // position where TSFTextStore believes it at.
     options.mRelativeToInsertionPoint = true;
     caretOffset -= mComposition->StartOffset();
+  } else if (!selectionForTSF->HasRange()) {
+    // If there is no selection range, there is no good position to show windows
+    // of TIP...
+    return;
   } else if (!CanAccessActualContentDirectly()) {
     // If TSF/TIP cannot access actual content directly, there may be pending
     // text and/or selection changes which have not been notified TSF yet.