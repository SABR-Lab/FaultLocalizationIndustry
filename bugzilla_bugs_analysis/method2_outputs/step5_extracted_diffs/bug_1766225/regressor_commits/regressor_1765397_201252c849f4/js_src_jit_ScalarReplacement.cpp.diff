# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ScalarReplacement.cpp
# Commit: 201252c849f4
# Full Hash: 201252c849f427b49422fffea6ca65e36cdade1d
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2022-04-21 15:23:18
# Regressor Bug: 1765397
# File Overlap Count: 1
# Description:
#   Bug 1765397 - Part 7: Optimise slice when no end-index is present. r=iain
#   
#   This is the case which actually happens in practice and we should aim to
#   provide support for.
#   
# ==============================================================================

diff -r 257207e109b2 -r 201252c849f4 js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp	Thu Apr 21 08:45:47 2022 +0000
+++ b/js/src/jit/ScalarReplacement.cpp	Thu Apr 21 08:45:47 2022 +0000
@@ -1517,6 +1517,9 @@
     return args_->isCreateInlinedArgumentsObject();
   }
 
+  MNewArrayObject* inlineArgsArray(MInstruction* ins, Shape* shape,
+                                   uint32_t begin, uint32_t count);
+
   void visitGuardToClass(MGuardToClass* ins);
   void visitGuardProto(MGuardProto* ins);
   void visitGuardArgumentsObjectFlags(MGuardArgumentsObjectFlags* ins);
@@ -2028,6 +2031,52 @@
   ins->block()->discard(ins);
 }
 
+MNewArrayObject* ArgumentsReplacer::inlineArgsArray(MInstruction* ins,
+                                                    Shape* shape,
+                                                    uint32_t begin,
+                                                    uint32_t count) {
+  auto* actualArgs = args_->toCreateInlinedArgumentsObject();
+
+  // Contrary to |WarpBuilder::build_Rest()|, we can always create
+  // MNewArrayObject, because we're guaranteed to have a shape and all
+  // arguments can be stored into fixed elements.
+  static_assert(
+      gc::CanUseFixedElementsForArray(ArgumentsObject::MaxInlinedArgs));
+
+  gc::InitialHeap heap = gc::DefaultHeap;
+
+  // Allocate an array of the correct size.
+  auto* shapeConstant = MConstant::NewShape(alloc(), shape);
+  ins->block()->insertBefore(ins, shapeConstant);
+
+  auto* newArray = MNewArrayObject::New(alloc(), shapeConstant, count, heap);
+  ins->block()->insertBefore(ins, newArray);
+
+  if (count) {
+    auto* elements = MElements::New(alloc(), newArray);
+    ins->block()->insertBefore(ins, elements);
+
+    MConstant* index = nullptr;
+    for (uint32_t i = 0; i < count; i++) {
+      index = MConstant::New(alloc(), Int32Value(i));
+      ins->block()->insertBefore(ins, index);
+
+      MDefinition* arg = actualArgs->getArg(begin + i);
+      auto* store = MStoreElement::New(alloc(), elements, index, arg,
+                                       /* needsHoleCheck = */ false);
+      ins->block()->insertBefore(ins, store);
+
+      auto* barrier = MPostWriteBarrier::New(alloc(), newArray, arg);
+      ins->block()->insertBefore(ins, barrier);
+    }
+
+    auto* initLength = MSetInitializedLength::New(alloc(), elements, index);
+    ins->block()->insertBefore(ins, initLength);
+  }
+
+  return newArray;
+}
+
 void ArgumentsReplacer::visitArrayFromArgumentsObject(
     MArrayFromArgumentsObject* ins) {
   // Skip other arguments objects.
@@ -2055,45 +2104,7 @@
     uint32_t numActuals = actualArgs->numActuals();
     MOZ_ASSERT(numActuals <= ArgumentsObject::MaxInlinedArgs);
 
-    // Contrary to |WarpBuilder::build_Rest()|, we can always create
-    // MNewArrayObject, because we're guaranteed to have a shape and all
-    // arguments can be stored into fixed elements.
-    static_assert(
-        gc::CanUseFixedElementsForArray(ArgumentsObject::MaxInlinedArgs));
-
-    gc::InitialHeap heap = gc::DefaultHeap;
-
-    // Allocate an array of the correct size.
-    auto* shapeConstant = MConstant::NewShape(alloc(), shape);
-    ins->block()->insertBefore(ins, shapeConstant);
-
-    auto* newArray =
-        MNewArrayObject::New(alloc(), shapeConstant, numActuals, heap);
-    ins->block()->insertBefore(ins, newArray);
-
-    if (numActuals) {
-      auto* elements = MElements::New(alloc(), newArray);
-      ins->block()->insertBefore(ins, elements);
-
-      MConstant* index = nullptr;
-      for (uint32_t i = 0; i < numActuals; i++) {
-        index = MConstant::New(alloc(), Int32Value(i));
-        ins->block()->insertBefore(ins, index);
-
-        MDefinition* arg = actualArgs->getArg(i);
-        auto* store = MStoreElement::New(alloc(), elements, index, arg,
-                                         /* needsHoleCheck = */ false);
-        ins->block()->insertBefore(ins, store);
-
-        auto* barrier = MPostWriteBarrier::New(alloc(), newArray, arg);
-        ins->block()->insertBefore(ins, barrier);
-      }
-
-      auto* initLength = MSetInitializedLength::New(alloc(), elements, index);
-      ins->block()->insertBefore(ins, initLength);
-    }
-
-    replacement = newArray;
+    replacement = inlineArgsArray(ins, shape, 0, numActuals);
   } else {
     // We can use |MRest| to read all arguments, because we've guaranteed that
     // the arguments stored in the stack frame haven't changed; see the comment
@@ -2117,12 +2128,74 @@
   ins->block()->discard(ins);
 }
 
+static uint32_t NormalizeSlice(MDefinition* def, uint32_t length) {
+  int32_t value = def->toConstant()->toInt32();
+  if (value < 0) {
+    return std::max(int32_t(uint32_t(value) + length), 0);
+  }
+  return std::min(uint32_t(value), length);
+}
+
 void ArgumentsReplacer::visitArgumentsSlice(MArgumentsSlice* ins) {
   // Skip other arguments objects.
   if (ins->object() != args_) {
     return;
   }
 
+  // Optimise the common pattern |Array.prototype.slice.call(arguments, begin)|,
+  // where |begin| is a non-negative, constant int32.
+  //
+  // An absent end-index is replaced by |arguments.length|, so we try to match
+  // |Array.prototype.slice.call(arguments, begin, arguments.length)|.
+  if (isInlinedArguments()) {
+    // When this is an inlined arguments, |arguments.length| has been replaced
+    // by a constant.
+    if (ins->begin()->isConstant() && ins->end()->isConstant()) {
+      auto* actualArgs = args_->toCreateInlinedArgumentsObject();
+      uint32_t numActuals = actualArgs->numActuals();
+      MOZ_ASSERT(numActuals <= ArgumentsObject::MaxInlinedArgs);
+
+      uint32_t begin = NormalizeSlice(ins->begin(), numActuals);
+      uint32_t end = NormalizeSlice(ins->end(), numActuals);
+      uint32_t count = end > begin ? end - begin : 0;
+      MOZ_ASSERT(count <= numActuals);
+
+      Shape* shape = ins->templateObj()->shape();
+      auto* newArray = inlineArgsArray(ins, shape, begin, count);
+
+      ins->replaceAllUsesWith(newArray);
+
+      // Remove original instruction.
+      ins->block()->discard(ins);
+      return;
+    }
+  } else {
+    // Otherwise |arguments.length| is emitted as MArgumentsLength.
+    if (ins->begin()->isConstant() && ins->end()->isArgumentsLength()) {
+      int32_t begin = ins->begin()->toConstant()->toInt32();
+      if (begin >= 0) {
+        auto* numActuals = MArgumentsLength::New(alloc());
+        ins->block()->insertBefore(ins, numActuals);
+
+        // Set |numFormals| to read all arguments starting at |begin|.
+        uint32_t numFormals = begin;
+
+        Shape* shape = ins->templateObj()->shape();
+
+        // Use MRest because it can be scalar replaced, which enables further
+        // optimizations.
+        auto* rest = MRest::New(alloc(), numActuals, numFormals, shape);
+        ins->block()->insertBefore(ins, rest);
+
+        ins->replaceAllUsesWith(rest);
+
+        // Remove original instruction.
+        ins->block()->discard(ins);
+        return;
+      }
+    }
+  }
+
   MInstruction* numArgs;
   if (isInlinedArguments()) {
     uint32_t argc = args_->toCreateInlinedArgumentsObject()->numActuals();
