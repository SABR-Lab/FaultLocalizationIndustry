# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ScalarReplacement.cpp
# Commit: b037127d38f3
# Full Hash: b037127d38f3b0001c11ea8130bf8c7f85f8514b
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2022-04-21 15:23:18
# Regressor Bug: 1765397
# File Overlap Count: 1
# Description:
#   Bug 1765397 - Part 3: Scalar replace ArgumentsSlice on frame arguments. r=iain
#   
#   Adds support to scalar replace `MArgumentsSlice` for frame arguments. The next
#   patch will add support for inlined arguments.
#   
# ==============================================================================

diff -r aeb3d90e0434 -r b037127d38f3 js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp	Thu Apr 21 08:45:45 2022 +0000
+++ b/js/src/jit/ScalarReplacement.cpp	Thu Apr 21 08:45:45 2022 +0000
@@ -1528,6 +1528,7 @@
   void visitArgumentsObjectLength(MArgumentsObjectLength* ins);
   void visitApplyArgsObj(MApplyArgsObj* ins);
   void visitArrayFromArgumentsObject(MArrayFromArgumentsObject* ins);
+  void visitArgumentsSlice(MArgumentsSlice* ins);
   void visitLoadFixedSlot(MLoadFixedSlot* ins);
 
   bool oom() const { return oom_; }
@@ -1645,6 +1646,7 @@
       case MDefinition::Opcode::LoadArgumentsObjectArgHole:
       case MDefinition::Opcode::InArgumentsObjectArg:
       case MDefinition::Opcode::ArrayFromArgumentsObject:
+      case MDefinition::Opcode::ArgumentsSlice:
         break;
 
       // This instruction is a no-op used to test that scalar replacement
@@ -2115,6 +2117,51 @@
   ins->block()->discard(ins);
 }
 
+void ArgumentsReplacer::visitArgumentsSlice(MArgumentsSlice* ins) {
+  // Skip other arguments objects.
+  if (ins->object() != args_) {
+    return;
+  }
+
+  MInstruction* numArgs;
+  if (isInlinedArguments()) {
+    uint32_t argc = args_->toCreateInlinedArgumentsObject()->numActuals();
+    numArgs = MConstant::New(alloc(), Int32Value(argc));
+  } else {
+    numArgs = MArgumentsLength::New(alloc());
+  }
+  ins->block()->insertBefore(ins, numArgs);
+
+  auto* begin = MNormalizeSliceTerm::New(alloc(), ins->begin(), numArgs);
+  ins->block()->insertBefore(ins, begin);
+
+  auto* end = MNormalizeSliceTerm::New(alloc(), ins->end(), numArgs);
+  ins->block()->insertBefore(ins, end);
+
+  bool isMax = false;
+  auto* beginMin = MMinMax::New(alloc(), begin, end, MIRType::Int32, isMax);
+  ins->block()->insertBefore(ins, beginMin);
+
+  // Safe to truncate because both operands are positive and end >= beginMin.
+  auto* count = MSub::New(alloc(), end, beginMin, MIRType::Int32);
+  count->setTruncateKind(TruncateKind::Truncate);
+  ins->block()->insertBefore(ins, count);
+
+  MInstruction* replacement;
+  if (isInlinedArguments()) {
+    MOZ_CRASH("NYI");
+  } else {
+    replacement = MFrameArgumentsSlice::New(
+        alloc(), beginMin, count, ins->templateObj(), ins->initialHeap());
+  }
+  ins->block()->insertBefore(ins, replacement);
+
+  ins->replaceAllUsesWith(replacement);
+
+  // Remove original instruction.
+  ins->block()->discard(ins);
+}
+
 void ArgumentsReplacer::visitLoadFixedSlot(MLoadFixedSlot* ins) {
   // Skip other arguments objects.
   if (ins->object() != args_) {