# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DOMException.cpp
# Commit: 0f9f2acf6e13
# Full Hash: 0f9f2acf6e136933da9a105df64ca4cc20bcb15c
# Author: Kagami Sascha Rosylight <krosylight@mozilla.com>
# Date: 2022-04-20 03:39:48
# Regressor Bug: 1561357
# File Overlap Count: 1
# Description:
#   Bug 1561357 - Implement [Serializable] for DOMException r=smaug,sfink
#   
#   Skipping stack serialization here as
#   
#   * it's optional per the spec
# ==============================================================================

diff -r 6e296387dc26 -r 0f9f2acf6e13 dom/base/DOMException.cpp
--- a/dom/base/DOMException.cpp	Tue Apr 19 19:13:08 2022 +0000
+++ b/dom/base/DOMException.cpp	Tue Apr 19 19:31:27 2022 +0000
@@ -19,6 +19,9 @@
 #include "mozilla/dom/DOMExceptionBinding.h"
 #include "mozilla/ErrorResult.h"
 
+#include "js/TypeDecls.h"
+#include "js/StructuredClone.h"
+
 using namespace mozilla;
 using namespace mozilla::dom;
 
@@ -182,6 +185,12 @@
   }
 }
 
+Exception::Exception(nsCString&& aMessage, nsresult aResult, nsCString&& aName)
+    : mMessage(std::move(aMessage)),
+      mResult(aResult),
+      mName(std::move(aName)),
+      mHoldingJSVal(false) {}
+
 Exception::~Exception() {
   if (mHoldingJSVal) {
     MOZ_ASSERT(NS_IsMainThread());
@@ -324,6 +333,9 @@
                            const nsACString& aName, uint16_t aCode,
                            nsIStackFrame* aLocation)
     : Exception(aMessage, aRv, aName, aLocation, nullptr), mCode(aCode) {}
+DOMException::DOMException(nsresult aRv, nsCString&& aMessage,
+                           nsCString&& aName, uint16_t aCode)
+    : Exception(std::move(aMessage), aRv, std::move(aName)), mCode(aCode) {}
 
 void DOMException::ToString(JSContext* aCx, nsACString& aReturn) {
   aReturn.Truncate();
@@ -399,4 +411,54 @@
   return inst.forget();
 }
 
+static bool ReadAsCString(JSContext* aCx, JSStructuredCloneReader* aReader,
+                          nsCString& aString) {
+  JS::Rooted<JSString*> jsMessage(aCx);
+  if (!JS_ReadString(aReader, &jsMessage)) {
+    return false;
+  }
+  return AssignJSString(aCx, aString, jsMessage);
+}
+
+already_AddRefed<DOMException> DOMException::ReadStructuredClone(
+    JSContext* aCx, nsIGlobalObject* aGlobal,
+    JSStructuredCloneReader* aReader) {
+  uint32_t reserved;
+  nsresult rv;
+  nsCString message;
+  nsCString name;
+  uint16_t code;
+
+  if (!JS_ReadBytes(aReader, &reserved, 4) || !JS_ReadBytes(aReader, &rv, 4) ||
+      !ReadAsCString(aCx, aReader, message) ||
+      !ReadAsCString(aCx, aReader, name) || !JS_ReadBytes(aReader, &code, 2)) {
+    return nullptr;
+  };
+
+  return do_AddRef(
+      new DOMException(rv, std::move(message), std::move(name), code));
+}
+
+bool DOMException::WriteStructuredClone(
+    JSContext* aCx, JSStructuredCloneWriter* aWriter) const {
+  JS::Rooted<JS::Value> messageValue(aCx);
+  JS::Rooted<JS::Value> nameValue(aCx);
+  if (!NonVoidByteStringToJsval(aCx, mMessage, &messageValue) ||
+      !NonVoidByteStringToJsval(aCx, mName, &nameValue)) {
+    return false;
+  }
+
+  JS::Rooted<JSString*> message(aCx, messageValue.toString());
+  JS::Rooted<JSString*> name(aCx, nameValue.toString());
+
+  static_assert(sizeof(nsresult) == 4);
+
+  // A reserved field. Use this to indicate stack serialization support etc.
+  uint32_t reserved = 0;
+  return JS_WriteBytes(aWriter, &reserved, 4) &&
+         JS_WriteBytes(aWriter, &mResult, 4) &&
+         JS_WriteString(aWriter, message) && JS_WriteString(aWriter, name) &&
+         JS_WriteBytes(aWriter, &mCode, 2);
+};
+
 }  // namespace mozilla::dom