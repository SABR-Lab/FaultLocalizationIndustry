# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/HyperTextAccessible.cpp
# Commit: 95a2cae69fb9
# Full Hash: 95a2cae69fb9d3763a8a8aba8beba2a78fdd570b
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-05-05 16:11:56
# Regressor Bug: 1766794
# File Overlap Count: 2
# Description:
#   Bug 1766794: Lazily cache HyperText offsets for RemoteAccessibles. r=eeejay
#   
#   We already had a similar cache in local HyperTextAccessible.
#   This improves performance significantly when walking the text attributes of a container with a large number of text leaf children, such as is encountered when using view source.
#   This patch unifies that cache across local and remote.
# ==============================================================================

diff -r 3f8a611b454e -r 95a2cae69fb9 accessible/generic/HyperTextAccessible.cpp
--- a/accessible/generic/HyperTextAccessible.cpp	Thu May 05 10:56:32 2022 +0000
+++ b/accessible/generic/HyperTextAccessible.cpp	Thu May 05 11:14:12 2022 +0000
@@ -2092,21 +2092,13 @@
 }
 
 bool HyperTextAccessible::RemoveChild(LocalAccessible* aAccessible) {
-  const int32_t childIndex = aAccessible->IndexInParent();
-  if (childIndex < static_cast<int64_t>(mOffsets.Length())) {
-    mOffsets.RemoveLastElements(mOffsets.Length() -
-                                aAccessible->IndexInParent());
-  }
-
+  InvalidateCachedHyperTextOffsets();
   return AccessibleWrap::RemoveChild(aAccessible);
 }
 
 bool HyperTextAccessible::InsertChildAt(uint32_t aIndex,
                                         LocalAccessible* aChild) {
-  if (aIndex < mOffsets.Length()) {
-    mOffsets.RemoveLastElements(mOffsets.Length() - aIndex);
-  }
-
+  InvalidateCachedHyperTextOffsets();
   return AccessibleWrap::InsertChildAt(aIndex, aChild);
 }
 
@@ -2199,65 +2191,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// HyperTextAccessible public
-
-int32_t HyperTextAccessible::GetChildOffset(uint32_t aChildIndex,
-                                            bool aInvalidateAfter) const {
-  if (aChildIndex == 0) {
-    if (aInvalidateAfter) mOffsets.Clear();
-
-    return aChildIndex;
-  }
-
-  int32_t count = mOffsets.Length() - aChildIndex;
-  if (count > 0) {
-    if (aInvalidateAfter) mOffsets.RemoveElementsAt(aChildIndex, count);
-
-    return mOffsets[aChildIndex - 1];
-  }
-
-  uint32_t lastOffset =
-      mOffsets.IsEmpty() ? 0 : mOffsets[mOffsets.Length() - 1];
-
-  while (mOffsets.Length() < aChildIndex) {
-    LocalAccessible* child = mChildren[mOffsets.Length()];
-    lastOffset += nsAccUtils::TextLength(child);
-    mOffsets.AppendElement(lastOffset);
-  }
-
-  return mOffsets[aChildIndex - 1];
-}
-
-int32_t HyperTextAccessible::GetChildIndexAtOffset(uint32_t aOffset) const {
-  uint32_t lastOffset = 0;
-  const uint32_t offsetCount = mOffsets.Length();
-
-  if (offsetCount > 0) {
-    lastOffset = mOffsets[offsetCount - 1];
-    if (aOffset < lastOffset) {
-      size_t index;
-      if (BinarySearch(mOffsets, 0, offsetCount, aOffset, &index)) {
-        return (index < (offsetCount - 1)) ? index + 1 : index;
-      }
-
-      return (index == offsetCount) ? -1 : index;
-    }
-  }
-
-  uint32_t childCount = ChildCount();
-  while (mOffsets.Length() < childCount) {
-    LocalAccessible* child = LocalChildAt(mOffsets.Length());
-    lastOffset += nsAccUtils::TextLength(child);
-    mOffsets.AppendElement(lastOffset);
-    if (aOffset < lastOffset) return mOffsets.Length() - 1;
-  }
-
-  if (aOffset == lastOffset) return mOffsets.Length() - 1;
-
-  return -1;
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // HyperTextAccessible protected
 
 nsresult HyperTextAccessible::GetDOMPointByFrameOffset(