# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/basetypes/HyperTextAccessibleBase.cpp
# Commit: a81a40b250b4
# Full Hash: a81a40b250b401d6133c2490d8d2d3bd52f1bc6d
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-05-05 09:42:30
# Regressor Bug: 1766794
# File Overlap Count: 2
# Description:
#   Bug 1766794: Lazily cache HyperText offsets for RemoteAccessibles. r=eeejay
#   
#   We already had a similar cache in local HyperTextAccessible.
#   This improves performance significantly when walking the text attributes of a container with a large number of text leaf children, such as is encountered when using view source.
#   This patch unifies that cache across local and remote.
# ==============================================================================

diff -r 000ea1907a05 -r a81a40b250b4 accessible/basetypes/HyperTextAccessibleBase.cpp
--- a/accessible/basetypes/HyperTextAccessibleBase.cpp	Thu May 05 04:00:58 2022 +0000
+++ b/accessible/basetypes/HyperTextAccessibleBase.cpp	Thu May 05 04:31:12 2022 +0000
@@ -14,21 +14,33 @@
 
 namespace mozilla::a11y {
 
-int32_t HyperTextAccessibleBase::GetChildIndexAtOffset(uint32_t aOffset) const {
+void HyperTextAccessibleBase::BuildCachedHyperTextOffsets(
+    nsTArray<int32_t>& aOffsets) const {
   const Accessible* thisAcc = Acc();
   uint32_t childCount = thisAcc->ChildCount();
-  uint32_t lastTextOffset = 0;
-  for (uint32_t childIndex = 0; childIndex < childCount; ++childIndex) {
-    Accessible* child = thisAcc->ChildAt(childIndex);
-    lastTextOffset += nsAccUtils::TextLength(child);
-    if (aOffset < lastTextOffset) {
-      return childIndex;
-    }
+  int32_t lastTextOffset = 0;
+  while (aOffsets.Length() < childCount) {
+    Accessible* child = thisAcc->ChildAt(aOffsets.Length());
+    lastTextOffset += static_cast<int32_t>(nsAccUtils::TextLength(child));
+    aOffsets.AppendElement(lastTextOffset);
   }
-  if (aOffset == lastTextOffset) {
-    return childCount - 1;
+}
+
+int32_t HyperTextAccessibleBase::GetChildIndexAtOffset(uint32_t aOffset) const {
+  const auto& offsets = GetCachedHyperTextOffsets();
+  auto childCount = offsets.Length();
+  size_t index;
+  if (BinarySearch(offsets, 0, childCount, static_cast<int32_t>(aOffset),
+                   &index)) {
+    // aOffset is the exclusive end of a child, so return the child before it.
+    return static_cast<int32_t>(index < childCount - 1 ? index + 1 : index);
   }
-  return -1;
+  if (index == childCount) {
+    // aOffset is past the end of the text.
+    return -1;
+  }
+  // index points at the exclusive end after aOffset.
+  return static_cast<int32_t>(index);
 }
 
 Accessible* HyperTextAccessibleBase::GetChildAtOffset(uint32_t aOffset) const {
@@ -36,8 +48,8 @@
   return thisAcc->ChildAt(GetChildIndexAtOffset(aOffset));
 }
 
-int32_t HyperTextAccessibleBase::GetChildOffset(const Accessible* aChild,
-                                                bool aInvalidateAfter) const {
+int32_t HyperTextAccessibleBase::GetChildOffset(
+    const Accessible* aChild) const {
   const Accessible* thisAcc = Acc();
   if (aChild->Parent() != thisAcc) {
     return -1;
@@ -46,26 +58,16 @@
   if (index == -1) {
     return -1;
   }
-  return GetChildOffset(index, aInvalidateAfter);
+  return GetChildOffset(index);
 }
 
-int32_t HyperTextAccessibleBase::GetChildOffset(uint32_t aChildIndex,
-                                                bool aInvalidateAfter) const {
+int32_t HyperTextAccessibleBase::GetChildOffset(uint32_t aChildIndex) const {
   if (aChildIndex == 0) {
     return 0;
   }
-  const Accessible* thisAcc = Acc();
-  MOZ_ASSERT(aChildIndex <= thisAcc->ChildCount());
-  uint32_t lastTextOffset = 0;
-  for (uint32_t childIndex = 0; childIndex <= aChildIndex; ++childIndex) {
-    if (childIndex == aChildIndex) {
-      return lastTextOffset;
-    }
-    Accessible* child = thisAcc->ChildAt(childIndex);
-    lastTextOffset += nsAccUtils::TextLength(child);
-  }
-  MOZ_ASSERT_UNREACHABLE();
-  return lastTextOffset;
+  MOZ_ASSERT(aChildIndex <= Acc()->ChildCount());
+  const auto& offsets = GetCachedHyperTextOffsets();
+  return offsets[aChildIndex - 1];
 }
 
 uint32_t HyperTextAccessibleBase::CharacterCount() const {