# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: js/src/jit/BaselineBailouts.cpp
# Commit: d86140d2fd38
# Full Hash: d86140d2fd38138052eba5164efa5e1ec6c3fd0f
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2022-05-18 03:14:37
# Description:
#   Bug 1768660: Skip fewer values in buildExpressionStack r=jandem
#   
#   For the innermost frame of debugger mode bailouts, the current approach effectively uses an allow-list to decide which stack slots need to be recovered. This is fragile to any future bytecode changes that keep values alive on the expression stack. It's also unnecessary: if we just recover slots that are included in the snapshot, and skip slots that don't have allocations, everything works out.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D146525
# ==============================================================================

diff -r 6bca20cf5ff7 -r d86140d2fd38 js/src/jit/BaselineBailouts.cpp
--- a/js/src/jit/BaselineBailouts.cpp	Tue May 17 18:11:40 2022 +0000
+++ b/js/src/jit/BaselineBailouts.cpp	Tue May 17 18:17:51 2022 +0000
@@ -198,7 +198,6 @@
   bool envChainSlotCanBeOptimized();
 #endif
 
-  bool hasLiveStackValueAtDepth(uint32_t stackSlotIndex);
   bool isPrologueBailout();
   jsbytecode* getResumePC();
   void* getStubReturnAddress();
@@ -873,25 +872,18 @@
           exprStackSlots());
   for (uint32_t i = 0; i < exprStackSlots(); i++) {
     Value v;
-    if (propagatingIonExceptionForDebugMode()) {
-      // If we are in the middle of propagating an exception from Ion by
-      // bailing to baseline due to debug mode, we might not have all
-      // the stack if we are at the newest frame.
-      //
-      // For instance, if calling |f()| pushed an Ion frame which threw,
-      // the snapshot expects the return value to be pushed, but it's
-      // possible nothing was pushed before we threw. We can't drop
-      // iterators, however, so read them out. They will be closed by
-      // HandleExceptionBaseline.
-      MOZ_ASSERT(cx_->realm()->isDebuggee() || forcedReturn());
-      if (iter_.moreFrames() || hasLiveStackValueAtDepth(i)) {
-        v = iter_.read();
-      } else {
-        iter_.skip();
-        v = MagicValue(JS_OPTIMIZED_OUT);
-      }
-    } else {
-      v = iter_.read();
+    // If we are in the middle of propagating an exception from Ion by
+    // bailing to baseline due to debug mode, we might not have all
+    // the stack if we are at the newest frame.
+    //
+    // For instance, if calling |f()| pushed an Ion frame which threw,
+    // the snapshot expects the return value to be pushed, but it's
+    // possible nothing was pushed before we threw.
+    //
+    // We therefore use a fallible read here.
+    if (!iter_.tryRead(&v)) {
+      MOZ_ASSERT(propagatingIonExceptionForDebugMode() && !iter_.moreFrames());
+      v = MagicValue(JS_OPTIMIZED_OUT);
     }
     if (!writeValue(v, "StackValue")) {
       return false;
@@ -1457,33 +1449,6 @@
   return slowerPc;
 }
 
-bool BaselineStackBuilder::hasLiveStackValueAtDepth(uint32_t stackSlotIndex) {
-  // Return true iff stackSlotIndex is a stack value that's part of an active
-  // iterator loop instead of a normal expression stack slot.
-
-  MOZ_ASSERT(stackSlotIndex < exprStackSlots());
-
-  for (TryNoteIterAllNoGC tni(script_, pc_); !tni.done(); ++tni) {
-    const TryNote& tn = **tni;
-
-    switch (tn.kind()) {
-      case TryNoteKind::ForIn:
-      case TryNoteKind::ForOf:
-      case TryNoteKind::Destructuring:
-        MOZ_ASSERT(tn.stackDepth <= exprStackSlots());
-        if (stackSlotIndex < tn.stackDepth) {
-          return true;
-        }
-        break;
-
-      default:
-        break;
-    }
-  }
-
-  return false;
-}
-
 bool BaselineStackBuilder::isPrologueBailout() {
   // If we are propagating an exception for debug mode, we will not resume
   // into baseline code, but instead into HandleExceptionBaseline (i.e.,