# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/JitFrames.cpp
# Commit: 7f75f8b705e7
# Full Hash: 7f75f8b705e72090c3faa76aa8bac440c6d0fde6
# Author: Iain Ireland <iireland@mozilla.com>
# Date: 2022-03-31 09:35:41
# Regressor Bug: 885514
# File Overlap Count: 2
# Description:
#   Bug 885514: Support bailouts for finally r=jandem
#   
#   This is mostly modeled after the catch code. The main difference is that finally expects to resume in code where there are two additional values on the stack, so we store the exception in the ExceptionBailoutInfo and write it into the stack frame in BaselineStackBuilder.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D142118
# ==============================================================================

diff -r 8cd3f1a267ae -r 7f75f8b705e7 js/src/jit/JitFrames.cpp
--- a/js/src/jit/JitFrames.cpp	Wed Mar 30 23:19:47 2022 +0000
+++ b/js/src/jit/JitFrames.cpp	Wed Mar 30 23:19:47 2022 +0000
@@ -201,7 +201,7 @@
     // know. This is because we might not be able to fully reconstruct up
     // to the stack depth at the snapshot, as we could've thrown in the
     // middle of a call.
-    ExceptionBailoutInfo propagateInfo;
+    ExceptionBailoutInfo propagateInfo(cx);
     if (ExceptionHandlerBailout(cx, frame, rfe, propagateInfo)) {
       return;
     }
@@ -231,7 +231,7 @@
 
           // Bailout at the start of the catch block.
           jsbytecode* catchPC = script->offsetToPC(tn->start + tn->length);
-          ExceptionBailoutInfo excInfo(frame.frameNo(), catchPC,
+          ExceptionBailoutInfo excInfo(cx, frame.frameNo(), catchPC,
                                        tn->stackDepth);
           if (ExceptionHandlerBailout(cx, frame, rfe, excInfo)) {
             // Record exception locations to allow scope unwinding in
@@ -248,6 +248,44 @@
         }
         break;
 
+      case TryNoteKind::Finally: {
+        if (!cx->isExceptionPending()) {
+          // We don't catch uncatchable exceptions.
+          break;
+        }
+
+        script->resetWarmUpCounterToDelayIonCompilation();
+
+        if (*hitBailoutException) {
+          break;
+        }
+
+        // Bailout at the start of the finally block.
+        jsbytecode* finallyPC = script->offsetToPC(tn->start + tn->length);
+        ExceptionBailoutInfo excInfo(cx, frame.frameNo(), finallyPC,
+                                     tn->stackDepth);
+
+        RootedValue exception(cx);
+        if (!cx->getPendingException(&exception)) {
+          exception = UndefinedValue();
+        }
+        excInfo.setFinallyException(exception.get());
+        cx->clearPendingException();
+
+        if (ExceptionHandlerBailout(cx, frame, rfe, excInfo)) {
+          // Record exception locations to allow scope unwinding in
+          // |FinishBailoutToBaseline|
+          rfe->bailoutInfo->tryPC =
+              UnwindEnvironmentToTryPc(frame.script(), tn);
+          rfe->bailoutInfo->faultPC = frame.pc();
+          return;
+        }
+
+        *hitBailoutException = true;
+        MOZ_ASSERT(cx->isExceptionPending());
+        break;
+      }
+
       case TryNoteKind::ForOf:
       case TryNoteKind::Loop:
         break;
