# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/scene_building.rs
# Commit: 51ba9e64ff0a
# Full Hash: 51ba9e64ff0a4071cdd57dbf24110606faad781e
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-05-27 15:58:57
# Description:
#   Bug 1771388 - Ensure backdrop capture has same clip as backdrop render r=gfx-reviewers,lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D147482
# ==============================================================================

diff -r 5e2d37a71968 -r 51ba9e64ff0a gfx/wr/webrender/src/scene_building.rs
--- a/gfx/wr/webrender/src/scene_building.rs	Fri May 27 04:32:40 2022 +0000
+++ b/gfx/wr/webrender/src/scene_building.rs	Fri May 27 05:38:29 2022 +0000
@@ -1707,6 +1707,7 @@
 
                 self.add_backdrop_filter(
                     spatial_node_index,
+                    info.common.clip_id,
                     clip_chain_id,
                     &layout,
                     filters,
@@ -2217,6 +2218,7 @@
                 prim_list: PrimitiveList::empty(),
                 prim_flags,
                 spatial_node_index,
+                clip_id,
                 clip_chain_id,
                 composite_ops,
                 blit_reason,
@@ -3601,6 +3603,7 @@
     pub fn add_backdrop_filter(
         &mut self,
         spatial_node_index: SpatialNodeIndex,
+        clip_id: ClipId,
         clip_chain_id: ClipChainId,
         info: &LayoutPrimitiveInfo,
         filters: Vec<Filter>,
@@ -3614,12 +3617,39 @@
 
         self.make_current_slice_atomic_if_required();
 
+        // Ensure we create a clip-chain for the capture primitive that matches
+        // the render primitive, otherwise one might get culled while the other
+        // is considered visible.
+        let mut filter_clips = Vec::new();
+        for sc in self.sc_stack.iter().rev() {
+            if sc.flags.contains(StackingContextFlags::WRAPS_BACKDROP_FILTER) {
+                if let Some(clip_id) = sc.clip_id {
+                    filter_clips.push(clip_id);
+                }
+            } else {
+                break;
+            }
+        }
+
+        let filter_clip_chain_id = if filter_clips.is_empty() {
+            clip_chain_id
+        } else {
+            self.clip_store.push_clip_root(None, false);
+            for clip_id in filter_clips {
+                self.clip_store.push_clip_root(Some(clip_id), true);
+            }
+            let filtered_clip_chain_id = self.clip_store.get_or_build_clip_chain_id(clip_id);
+            self.clip_store.pop_clip_root();
+
+            filtered_clip_chain_id
+        };
+
         // Create the backdrop prim - this is a placeholder which sets the size of resolve
         // picture that reads from the backdrop root
         let backdrop_capture_instance = self.create_primitive(
             info,
             spatial_node_index,
-            ClipChainId::NONE,
+            filter_clip_chain_id,
             BackdropCapture {
             },
         );
@@ -3901,6 +3931,9 @@
     /// The positioning node for this stacking context
     spatial_node_index: SpatialNodeIndex,
 
+    /// The clip id for this stacking context
+    clip_id: Option<ClipId>,
+
     /// The clip chain for this stacking context
     clip_chain_id: ClipChainId,
 