# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/surface.rs
# Commit: c912923296d1
# Full Hash: c912923296d1fba93b6681dd44a3902d7689ef02
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-05-25 03:42:54
# Regressor Bug: 1769963
# File Overlap Count: 2
# Description:
#   Bug 1769963 - Fix backdrop-filter inside complex transform with CSS filter chain r=gfx-reviewers,lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D147124
# ==============================================================================

diff -r dd7e11f8b419 -r c912923296d1 gfx/wr/webrender/src/surface.rs
--- a/gfx/wr/webrender/src/surface.rs	Tue May 24 22:14:40 2022 +0000
+++ b/gfx/wr/webrender/src/surface.rs	Tue May 24 22:53:15 2022 +0000
@@ -207,6 +207,9 @@
     builder_stack: Vec<CommandBufferBuilder>,
     // Dirty rect stack used to reject adding primitives
     dirty_rect_stack: Vec<Vec<PictureRect>>,
+    // A stack of the output render tasks from any sub-graphs that haven't
+    // been consumed by BackdropRender prims yet
+    pub sub_graph_output_stack: Vec<RenderTaskId>,
 }
 
 impl SurfaceBuilder {
@@ -215,6 +218,7 @@
             current_cmd_buffers: CommandBufferTargets::Tiled { tiles: FastHashMap::default() },
             builder_stack: Vec::new(),
             dirty_rect_stack: Vec::new(),
+            sub_graph_output_stack: Vec::new(),
         }
     }
 
@@ -245,7 +249,6 @@
         &mut self,
         surface_index: SurfaceIndex,
         is_sub_graph: bool,
-        wraps_sub_graph: bool,
         clipping_rect: PictureRect,
         descriptor: SurfaceDescriptor,
         surfaces: &mut [SurfaceInfo],
@@ -267,7 +270,6 @@
                     render_task_id,
                     is_sub_graph,
                     None,
-                    wraps_sub_graph,
                 )
             }
             SurfaceDescriptorKind::Chained { render_task_id, root_task_id } => {
@@ -275,7 +277,6 @@
                     render_task_id,
                     is_sub_graph,
                     Some(root_task_id),
-                    wraps_sub_graph,
                 )
             }
         };
@@ -403,6 +404,9 @@
                     let resolve_task_id = builder.resolve_source.expect("bug: no resolve set");
                     let mut src_task_ids = Vec::new();
 
+                    // Make the output of the sub-graph a dependency of the new replacement tile task
+                    self.sub_graph_output_stack.push(child_root_task_id.unwrap_or(child_render_task_id));
+
                     // Set up dependencies for the sub-graph. The basic concepts below are the same, but for
                     // tiled surfaces are a little more complex as there are multiple tasks to set up.
                     //  (a) Set up new task(s) on parent surface that write to the same location
@@ -410,26 +414,7 @@
                     //  (c) Make the old parent surface tasks input dependencies of the resolve target
                     //  (d) Make the sub-graph output an input dependency of the new task(s).
 
-                    // If this surface wraps a sub-graph, we need to look up in the hierarchy to find where
-                    // the resource source actually is. This may happen in cases where a clip-mask applies to
-                    // a backdrop-filter and child content in the associated stacking context.
-                    let sub_graph_source_index = self.builder_stack
-                        .iter()
-                        .rposition(|builder| {
-                            !builder.wraps_sub_graph
-                        })
-                        .expect("bug: no parent that is not a sub graph wrapper");
-
-                    let sub_graph_parent = if sub_graph_source_index == self.builder_stack.len() - 1 {
-                        None
-                    } else {
-                        match self.builder_stack.last().unwrap().kind {
-                            CommandBufferBuilderKind::Simple { render_task_id, .. } => Some(render_task_id),
-                            _ => panic!("bug: should not occur on tiled surfaces"),
-                        }
-                    };
-
-                    match self.builder_stack[sub_graph_source_index].kind {
+                    match self.builder_stack.last_mut().unwrap().kind {
                         CommandBufferBuilderKind::Tiled { ref mut tiles } => {
                             let keys: Vec<TileKey> = tiles.keys().cloned().collect();
 
@@ -474,12 +459,6 @@
                                             ),
                                         );
 
-                                        // Make the output of the sub-graph a dependency of the new replacement tile task
-                                        rg_builder.add_dependency(
-                                            sub_graph_parent.unwrap_or(new_task_id),
-                                            child_root_task_id.unwrap_or(child_render_task_id),
-                                        );
-
                                         // Update the surface builder with the now current target for future primitives
                                         tiles.insert(
                                             key,
@@ -538,12 +517,6 @@
                                 ),
                             );
 
-                            // Make the output of the sub-graph a dependency of the new replacement tile task
-                            rg_builder.add_dependency(
-                                sub_graph_parent.unwrap_or(new_task_id),
-                                child_root_task_id.unwrap_or(child_render_task_id),
-                            );
-
                             // Update the surface builder with the now current target for future primitives
                             *parent_task_id = new_task_id;
                         }