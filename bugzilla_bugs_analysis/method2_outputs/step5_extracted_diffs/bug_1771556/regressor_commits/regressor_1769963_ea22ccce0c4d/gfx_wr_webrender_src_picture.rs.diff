# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/picture.rs
# Commit: ea22ccce0c4d
# Full Hash: ea22ccce0c4dbe8a1c7ace807924275497f6c899
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-05-25 09:36:24
# Regressor Bug: 1769963
# File Overlap Count: 1
# Description:
#   Bug 1769963 - Fix backdrop-filter inside complex transform with CSS filter chain r=gfx-reviewers,lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D147124
# ==============================================================================

diff -r 60c64f026b6b -r ea22ccce0c4d gfx/wr/webrender/src/picture.rs
--- a/gfx/wr/webrender/src/picture.rs	Wed May 25 05:48:08 2022 +0300
+++ b/gfx/wr/webrender/src/picture.rs	Wed May 25 02:59:32 2022 +0000
@@ -2945,6 +2945,7 @@
         surface_stack: &[(PictureIndex, SurfaceIndex)],
         composite_state: &mut CompositeState,
         gpu_cache: &mut GpuCache,
+        scratch: &mut PrimitiveScratchBuffer,
         is_root_tile_cache: bool,
         surfaces: &mut [SurfaceInfo],
     ) {
@@ -3308,7 +3309,12 @@
                     });
                 }
             }
-            PrimitiveInstanceKind::Backdrop { .. } => {
+            PrimitiveInstanceKind::BackdropCapture { .. } => {}
+            PrimitiveInstanceKind::BackdropRender { pic_index, .. } => {
+                // Mark that we need the sub-graph this render depends on so that
+                // we don't skip it during the prepare pass
+                scratch.required_sub_graphs.insert(pic_index);
+
                 // If this is a sub-graph, register the bounds on any affected tiles
                 // so we know how much to expand the content tile by.
 
@@ -3982,6 +3988,8 @@
     },
     /// Apply an SVG filter
     SvgFilter(Vec<FilterPrimitive>, Vec<SFilterData>),
+    /// A surface that is used as an input to another primitive
+    IntermediateSurface,
 }
 
 impl PictureCompositeMode {
@@ -4392,10 +4400,8 @@
         /// This picture establishes a sub-graph, which affects how SurfaceBuilder will
         /// set up dependencies in the render task graph
         const IS_SUB_GRAPH = 1 << 1;
-        /// This picture wraps a sub-graph, but is not the resolve source itself
-        const WRAPS_SUB_GRAPH = 1 << 2;
         /// If set, this picture should not apply snapping via changing the raster root
-        const DISABLE_SNAPPING = 1 << 3;
+        const DISABLE_SNAPPING = 1 << 2;
     }
 }
 
@@ -4488,6 +4494,7 @@
             Some(RasterConfig { composite_mode: PictureCompositeMode::ComponentTransferFilter(..), .. }) |
             Some(RasterConfig { composite_mode: PictureCompositeMode::TileCache { .. }, .. }) |
             Some(RasterConfig { composite_mode: PictureCompositeMode::SvgFilter(..), .. }) |
+            Some(RasterConfig { composite_mode: PictureCompositeMode::IntermediateSurface, .. }) |
             None => {
                 false
             }
@@ -5131,7 +5138,6 @@
                 frame_state.surface_builder.push_surface(
                     surface_index,
                     false,
-                    false,
                     surface_local_dirty_rect,
                     descriptor,
                     frame_state.surfaces,
@@ -5524,6 +5530,41 @@
                             surface_rects.clipped_local,
                         );
                     }
+                    PictureCompositeMode::IntermediateSurface => {
+                        if !scratch.required_sub_graphs.contains(&pic_index) {
+                            return None;
+                        }
+
+                        // TODO(gw): Remove all the mostly duplicated code in each of these
+                        //           match cases (they used to be quite different).
+                        let cmd_buffer_index = frame_state.cmd_buffers.create_cmd_buffer();
+
+                        let render_task_id = frame_state.rg_builder.add().init(
+                            RenderTask::new_dynamic(
+                                surface_rects.task_size,
+                                RenderTaskKind::new_picture(
+                                    surface_rects.task_size,
+                                    surface_rects.needs_scissor_rect,
+                                    surface_rects.clipped.min,
+                                    surface_spatial_node_index,
+                                    raster_spatial_node_index,
+                                    device_pixel_scale,
+                                    None,
+                                    None,
+                                    None,
+                                    cmd_buffer_index,
+                                    can_use_shared_surface,
+                                )
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
+                        );
+
+                        primary_render_task_id = render_task_id;
+
+                        surface_descriptor = SurfaceDescriptor::new_simple(
+                            render_task_id,
+                            surface_rects.clipped_local,
+                        );
+                    }
                     PictureCompositeMode::SvgFilter(ref primitives, ref filter_datas) => {
                         let cmd_buffer_index = frame_state.cmd_buffers.create_cmd_buffer();
 
@@ -5567,12 +5608,10 @@
                 }
 
                 let is_sub_graph = self.flags.contains(PictureFlags::IS_SUB_GRAPH);
-                let wraps_sub_graph = self.flags.contains(PictureFlags::WRAPS_SUB_GRAPH);
 
                 frame_state.surface_builder.push_surface(
                     raster_config.surface_index,
                     is_sub_graph,
-                    wraps_sub_graph,
                     surface_rects.clipped_local,
                     surface_descriptor,
                     frame_state.surfaces,
@@ -5611,6 +5650,7 @@
                     PictureCompositeMode::ComponentTransferFilter(..) |
                     PictureCompositeMode::Filter(..) |
                     PictureCompositeMode::MixBlend(..) |
+                    PictureCompositeMode::IntermediateSurface |
                     PictureCompositeMode::SvgFilter(..) => {
                         // TODO(gw): We can take advantage of the same logic that
                         //           exists in the opaque rect detection for tile
@@ -6211,6 +6251,7 @@
             }
             PictureCompositeMode::MixBlend(..) |
             PictureCompositeMode::Blit(_) |
+            PictureCompositeMode::IntermediateSurface |
             PictureCompositeMode::SvgFilter(..) => {}
         }
 
@@ -6931,7 +6972,7 @@
     scale_offset
 }
 
-fn calculate_screen_uv(
+pub fn calculate_screen_uv(
     p: DevicePoint,
     clipped: DeviceRect,
 ) -> DeviceHomogeneousVector {