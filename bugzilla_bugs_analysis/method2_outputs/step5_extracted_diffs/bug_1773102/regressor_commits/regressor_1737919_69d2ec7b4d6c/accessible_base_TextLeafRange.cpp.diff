# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/TextLeafRange.cpp
# Commit: 69d2ec7b4d6c
# Full Hash: 69d2ec7b4d6ca35da23f14602cdf78d939da40cb
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-05-27 15:58:57
# Regressor Bug: 1737919
# File Overlap Count: 1
# Description:
#   Bug 1737919 part 4: Update cached spelling errors when a spelling error is added without the text changing. r=morgan,smaug
#   
#   We already have an nsISelectionListener, but that only tells us that a change happened somewhere in the selection, not which range changed.
#   We don't want to push a cache update for all ranges when only one changed.
#   Therefore, this patch adds an accessibility notification in mozInlineSpellChecker::AddRange.
# ==============================================================================

diff -r 388a15605114 -r 69d2ec7b4d6c accessible/base/TextLeafRange.cpp
--- a/accessible/base/TextLeafRange.cpp	Fri May 27 10:56:41 2022 +0000
+++ b/accessible/base/TextLeafRange.cpp	Fri May 27 10:56:41 2022 +0000
@@ -8,15 +8,18 @@
 
 #include "HyperTextAccessible-inl.h"
 #include "mozilla/a11y/Accessible.h"
+#include "mozilla/a11y/CacheConstants.h"
 #include "mozilla/a11y/DocAccessible.h"
 #include "mozilla/a11y/DocAccessibleParent.h"
 #include "mozilla/a11y/LocalAccessible.h"
 #include "mozilla/BinarySearch.h"
 #include "mozilla/Casting.h"
 #include "mozilla/dom/CharacterData.h"
+#include "mozilla/dom/Document.h"
 #include "mozilla/intl/Segmenter.h"
 #include "mozilla/intl/WordBreaker.h"
 #include "mozilla/StaticPrefs_layout.h"
+#include "nsAccessibilityService.h"
 #include "nsAccUtils.h"
 #include "nsBlockFrame.h"
 #include "nsContentUtils.h"
@@ -24,6 +27,7 @@
 #include "nsIAccessiblePivot.h"
 #include "nsILineIterator.h"
 #include "nsINode.h"
+#include "nsRange.h"
 #include "nsStyleStructInlines.h"
 #include "nsTArray.h"
 #include "nsTextFrame.h"
@@ -1236,6 +1240,32 @@
   return offsets;
 }
 
+/* static */
+void TextLeafPoint::UpdateCachedSpellingError(dom::Document* aDocument,
+                                              const nsRange& aRange) {
+  DocAccessible* docAcc = GetExistingDocAccessible(aDocument);
+  if (!docAcc) {
+    return;
+  }
+  LocalAccessible* startAcc = docAcc->GetAccessible(aRange.GetStartContainer());
+  LocalAccessible* endAcc = docAcc->GetAccessible(aRange.GetEndContainer());
+  if (!startAcc || !endAcc) {
+    return;
+  }
+  for (Accessible* acc = startAcc; acc; acc = NextLeaf(acc)) {
+    if (acc->IsTextLeaf()) {
+      docAcc->QueueCacheUpdate(acc->AsLocal(), CacheDomain::Spelling);
+    }
+    if (acc == endAcc) {
+      // Subtle: We check this here rather than in the loop condition because
+      // we want to include endAcc but stop once we reach it. Putting it in the
+      // loop condition would mean we stop at endAcc, but we would also exclude
+      // it; i.e. we wouldn't push the cache for it.
+      break;
+    }
+  }
+}
+
 already_AddRefed<AccAttributes> TextLeafPoint::GetTextAttributesLocalAcc(
     bool aIncludeDefaults) const {
   LocalAccessible* acc = mAcc->AsLocal();