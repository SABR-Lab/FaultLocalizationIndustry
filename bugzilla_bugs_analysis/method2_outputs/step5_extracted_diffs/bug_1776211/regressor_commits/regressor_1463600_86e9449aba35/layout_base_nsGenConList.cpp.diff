# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsGenConList.cpp
# Commit: 86e9449aba35
# Full Hash: 86e9449aba35c7439e8a41a2804388994462c00d
# Author: Martin Robinson <mrobinson@igalia.com>
# Date: 2022-06-23 03:54:50
# Regressor Bug: 1463600
# File Overlap Count: 1
# Description:
#   Bug 1463600 - Implement CSS 'contain: style' r=emilio
#   
#   Add an implementation of CSS `contain: style`. This introduces two new
#   data structures, the ContainStyleScope and ContainStyleScopeManager.
#   
# ==============================================================================

diff -r c7d1d0cfaa6c -r 86e9449aba35 layout/base/nsGenConList.cpp
--- a/layout/base/nsGenConList.cpp	Wed Jun 22 10:30:03 2022 +0000
+++ b/layout/base/nsGenConList.cpp	Wed Jun 22 10:42:34 2022 +0000
@@ -125,6 +125,37 @@
   return cmp > 0;
 }
 
+nsGenConNode* nsGenConList::BinarySearch(
+    const mozilla::FunctionRef<bool(nsGenConNode*)>& aIsAfter) {
+  // The range of indices at which |aNode| could end up.
+  // (We already know it can't be at index mSize.)
+  uint32_t first = 0, last = mSize - 1;
+
+  // A cursor to avoid walking more than the length of the list.
+  nsGenConNode* curNode = mList.getLast();
+  uint32_t curIndex = mSize - 1;
+
+  while (first != last) {
+    uint32_t test = first + (last - first) / 2;
+    if (last == curIndex) {
+      for (; curIndex != test; --curIndex) curNode = Prev(curNode);
+    } else {
+      for (; curIndex != test; ++curIndex) curNode = Next(curNode);
+    }
+
+    if (aIsAfter(curNode)) {
+      first = test + 1;
+      // if we exit the loop, we need curNode to be right
+      ++curIndex;
+      curNode = Next(curNode);
+    } else {
+      last = test;
+    }
+  }
+
+  return curNode;
+}
+
 void nsGenConList::Insert(nsGenConNode* aNode) {
   // Check for append.
   if (mList.isEmpty() || NodeAfter(aNode, mList.getLast())) {
@@ -135,34 +166,11 @@
     // Fast path for inserting many consecutive nodes in one place
     mLastInserted->setNext(aNode);
   } else {
-    // Binary search.
-
-    // the range of indices at which |aNode| could end up.
-    // (We already know it can't be at index mSize.)
-    uint32_t first = 0, last = mSize - 1;
-
-    // A cursor to avoid walking more than the length of the list.
-    nsGenConNode* curNode = mList.getLast();
-    uint32_t curIndex = mSize - 1;
-
-    while (first != last) {
-      uint32_t test = (first + last) / 2;
-      if (last == curIndex) {
-        for (; curIndex != test; --curIndex) curNode = Prev(curNode);
-      } else {
-        for (; curIndex != test; ++curIndex) curNode = Next(curNode);
-      }
-
-      if (NodeAfter(aNode, curNode)) {
-        first = test + 1;
-        // if we exit the loop, we need curNode to be right
-        ++curIndex;
-        curNode = Next(curNode);
-      } else {
-        last = test;
-      }
-    }
-    curNode->setPrevious(aNode);
+    auto IsAfter = [aNode](nsGenConNode* curNode) {
+      return NodeAfter(aNode, curNode);
+    };
+    auto* insertionNode = BinarySearch(IsAfter);
+    insertionNode->setPrevious(aNode);
   }
   ++mSize;
 