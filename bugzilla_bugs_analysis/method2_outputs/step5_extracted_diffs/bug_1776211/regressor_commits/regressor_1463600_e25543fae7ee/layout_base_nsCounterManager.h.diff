# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCounterManager.h
# Commit: e25543fae7ee
# Full Hash: e25543fae7ee03ac57b9cfbfeb2418c9e2f490fc
# Author: Martin Robinson <mrobinson@igalia.com>
# Date: 2022-06-23 03:54:50
# Regressor Bug: 1463600
# File Overlap Count: 1
# Description:
#   Bug 1463600 - Implement CSS 'contain: style' r=emilio
#   
#   Add an implementation of CSS `contain: style`. This introduces two new
#   data structures, the ContainStyleScope and ContainStyleScopeManager.
#   
# ==============================================================================

diff -r 4230bdcf07ae -r e25543fae7ee layout/base/nsCounterManager.h
--- a/layout/base/nsCounterManager.h	Wed Jun 22 16:15:57 2022 +0000
+++ b/layout/base/nsCounterManager.h	Wed Jun 22 16:16:59 2022 +0000
@@ -19,6 +19,12 @@
 struct nsCounterUseNode;
 struct nsCounterChangeNode;
 
+namespace mozilla {
+
+class ContainStyleScope;
+
+}  // namespace mozilla
+
 struct nsCounterNode : public nsGenConNode {
   enum Type {
     RESET,      // a "counter number" pair in 'counter-reset'
@@ -54,6 +60,11 @@
   // outer scope.
   nsCounterNode* mScopePrev = nullptr;
 
+  // Whether or not this node's scope crosses `contain: style` boundaries.
+  // This can happen for USE nodes that come before any other types of
+  // nodes in a `contain: style` boundary's list.
+  bool mCrossesContainStyleBoundaries = false;
+
   inline nsCounterUseNode* UseNode();
   inline nsCounterChangeNode* ChangeNode();
 
@@ -200,7 +211,10 @@
 
 class nsCounterList : public nsGenConList {
  public:
-  nsCounterList() : nsGenConList(), mDirty(false) {}
+  nsCounterList(nsAtom* aCounterName, mozilla::ContainStyleScope* aScope)
+      : nsGenConList(), mCounterName(aCounterName), mScope(aScope) {
+    MOZ_ASSERT(aScope);
+  }
 
   // Return the first node for aFrame on this list, or nullptr.
   nsCounterNode* GetFirstNodeFor(nsIFrame* aFrame) const {
@@ -228,7 +242,16 @@
   }
 
   static int32_t ValueBefore(nsCounterNode* aNode) {
-    return aNode->mScopePrev ? aNode->mScopePrev->mValueAfter : 0;
+    if (!aNode->mScopePrev) {
+      return 0;
+    }
+
+    if (aNode->mType != nsCounterNode::USE &&
+        aNode->mScopePrev->mCrossesContainStyleBoundaries) {
+      return 0;
+    }
+
+    return aNode->mScopePrev->mValueAfter;
   }
 
   // Correctly set |aNode->mScopeStart| and |aNode->mScopePrev|
@@ -238,11 +261,18 @@
   // all nodes and update text in text content nodes.
   void RecalcAll();
 
-  bool IsDirty() { return mDirty; }
-  void SetDirty() { mDirty = true; }
+  bool IsDirty() const;
+  void SetDirty();
+  bool IsRecalculatingAll() const { return mRecalculatingAll; }
 
  private:
-  bool mDirty;
+  bool SetScopeByWalkingBackwardThroughList(
+      nsCounterNode* aNodeToSetScopeFor, const nsIContent* aNodeContent,
+      nsCounterNode* aNodeToBeginLookingAt);
+
+  RefPtr<nsAtom> mCounterName;
+  mozilla::ContainStyleScope* mScope;
+  bool mRecalculatingAll = false;
 };
 
 /**
@@ -251,12 +281,18 @@
  */
 class nsCounterManager {
  public:
+  explicit nsCounterManager(mozilla::ContainStyleScope* scope)
+      : mScope(scope) {}
+
   // Returns true if dirty
   bool AddCounterChanges(nsIFrame* aFrame);
 
   // Gets the appropriate counter list, creating it if necessary.
   // Guaranteed to return non-null. (Uses an infallible hashtable API.)
-  nsCounterList* CounterListFor(nsAtom* aCounterName);
+  nsCounterList* GetOrCreateCounterList(nsAtom* aCounterName);
+
+  // Gets the appropriate counter list, returning null if it doesn't exist.
+  nsCounterList* GetCounterList(nsAtom* aCounterName);
 
   // Clean up data in any dirty counter lists.
   void RecalcAll();
@@ -272,8 +308,11 @@
   void Clear() { mNames.Clear(); }
 
 #ifdef ACCESSIBILITY
-  // Returns the spoken text for the 'list-item' counter for aFrame in aText.
-  void GetSpokenCounterText(nsIFrame* aFrame, nsAString& aText) const;
+  // Set |aOrdinal| to the first used counter value for the given frame and
+  // return true. If no USE node for the given frame can be found, return false
+  // and do not change the value of |aOrdinal|.
+  bool GetFirstCounterValueForFrame(nsIFrame* aFrame,
+                                    mozilla::CounterValue& aOrdinal) const;
 #endif
 
 #if defined(DEBUG) || defined(MOZ_LAYOUT_DEBUGGER)
@@ -304,6 +343,7 @@
   }
 
  private:
+  mozilla::ContainStyleScope* mScope;
   nsClassHashtable<nsRefPtrHashKey<nsAtom>, nsCounterList> mNames;
 };
 