# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/apz/util/ChromeProcessController.cpp
# Commit: da8c34fec36e
# Full Hash: da8c34fec36e933ccfe93e458ccdbe9328132897
# Author: Mike Conley <mconley@mozilla.com>
# Date: 2022-06-22 03:32:25
# Regressor Bug: 1773865
# File Overlap Count: 1
# Description:
#   Bug 1773865 - Dispatch an event on the window document when a pinch zoom gesture ends. r=botond,smaug,NeilDeakin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D149283
# ==============================================================================

diff -r 2510b654e8f2 -r da8c34fec36e gfx/layers/apz/util/ChromeProcessController.cpp
--- a/gfx/layers/apz/util/ChromeProcessController.cpp	Tue Jun 21 13:56:53 2022 +0000
+++ b/gfx/layers/apz/util/ChromeProcessController.cpp	Tue Jun 21 14:02:19 2022 +0000
@@ -330,3 +330,23 @@
 
   APZCCallbackHelper::CancelAutoscroll(aGuid.mScrollId);
 }
+
+void ChromeProcessController::NotifyScaleGestureComplete(
+    const ScrollableLayerGuid& aGuid, float aScale) {
+  if (!mUIThread->IsOnCurrentThread()) {
+    mUIThread->Dispatch(NewRunnableMethod<ScrollableLayerGuid, float>(
+        "layers::ChromeProcessController::NotifyScaleGestureComplete", this,
+        &ChromeProcessController::NotifyScaleGestureComplete, aGuid, aScale));
+    return;
+  }
+
+  if (mWidget) {
+    // Dispatch the call to APZCCallbackHelper::NotifyScaleGestureComplete
+    // to the main thread so that it runs asynchronously from the current call.
+    // This is because the call can run arbitrary JS code, which can also spin
+    // the event loop and cause undesirable re-entrancy in APZ.
+    mUIThread->Dispatch(NewRunnableFunction(
+        "layers::ChromeProcessController::NotifyScaleGestureComplete",
+        &APZCCallbackHelper::NotifyScaleGestureComplete, mWidget, aScale));
+  }
+}