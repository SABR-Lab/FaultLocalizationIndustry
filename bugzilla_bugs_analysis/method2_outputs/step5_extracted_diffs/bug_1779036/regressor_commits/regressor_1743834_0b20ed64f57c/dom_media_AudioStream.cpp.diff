# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/AudioStream.cpp
# Commit: 0b20ed64f57c
# Full Hash: 0b20ed64f57cf7272cf1b4e9e5e2f52a34fd5075
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-05-24 21:44:48
# Regressor Bug: 1743834
# File Overlap Count: 1
# Description:
#   Bug 1743834 - Create and manage the lifetime of the AudioStream EndedPromise in AudioSinkWrapper. r=alwu,media-playback-reviewers
#   
#   We're going to shutdown the AudioStream in a subsequent patch, when audio is
#   muted. This will allow resolving it at the right time when the media ends while
#   muted.
# ==============================================================================

diff -r 0b1dc7c2fdfd -r 0b20ed64f57c dom/media/AudioStream.cpp
--- a/dom/media/AudioStream.cpp	Tue May 24 13:09:05 2022 +0000
+++ b/dom/media/AudioStream.cpp	Tue May 24 13:09:05 2022 +0000
@@ -320,19 +320,18 @@
   }
 }
 
-Result<already_AddRefed<MediaSink::EndedPromise>, nsresult>
-AudioStream::Start() {
+nsresult AudioStream::Start(
+    MozPromiseHolder<MediaSink::EndedPromise>& aEndedPromise) {
   TRACE("AudioStream::Start");
   MOZ_ASSERT(mState == INITIALIZED);
   mState = STARTED;
-
   RefPtr<MediaSink::EndedPromise> promise;
   {
     MonitorAutoLock mon(mMonitor);
     // As cubeb might call audio stream's state callback very soon after we
     // start cubeb, we have to create the promise beforehand in order to handle
     // the case where we immediately get `drained`.
-    promise = mEndedPromise.Ensure(__func__);
+    mEndedPromise = std::move(aEndedPromise);
     mPlaybackComplete = false;
 
     if (InvokeCubeb(cubeb_stream_start) != CUBEB_OK) {
@@ -344,9 +343,9 @@
                            : mState == DRAINED ? "DRAINED"
                                                : "ERRORED");
   if (mState == STARTED || mState == DRAINED) {
-    return promise.forget();
+    return NS_OK;
   }
-  return Err(NS_ERROR_FAILURE);
+  return NS_ERROR_FAILURE;
 }
 
 void AudioStream::Pause() {
@@ -391,7 +390,8 @@
   }
 }
 
-void AudioStream::Shutdown() {
+Maybe<MozPromiseHolder<MediaSink::EndedPromise>> AudioStream::Shutdown(
+    ShutdownCause aCause) {
   TRACE("AudioStream::Shutdown");
   LOG("Shutdown, state %d", mState.load());
 
@@ -414,7 +414,15 @@
   }
 
   mState = SHUTDOWN;
-  mEndedPromise.ResolveIfExists(true, __func__);
+  // When shutting down, if this AudioStream is shutting down because the
+  // HTMLMediaElement is now muted, hand back the ended promise, so that it can
+  // properly be resolved if the end of the media is reached while muted (i.e.
+  // without having an AudioStream)
+  if (aCause != ShutdownCause::Muting) {
+    mEndedPromise.ResolveIfExists(true, __func__);
+    return Nothing();
+  }
+  return Some(std::move(mEndedPromise));
 }
 
 int64_t AudioStream::GetPosition() {