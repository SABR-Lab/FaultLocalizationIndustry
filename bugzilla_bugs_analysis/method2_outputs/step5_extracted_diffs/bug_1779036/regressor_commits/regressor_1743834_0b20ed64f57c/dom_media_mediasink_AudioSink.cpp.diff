# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/AudioSink.cpp
# Commit: 0b20ed64f57c
# Full Hash: 0b20ed64f57cf7272cf1b4e9e5e2f52a34fd5075
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-05-24 21:44:48
# Regressor Bug: 1743834
# File Overlap Count: 1
# Description:
#   Bug 1743834 - Create and manage the lifetime of the AudioStream EndedPromise in AudioSinkWrapper. r=alwu,media-playback-reviewers
#   
#   We're going to shutdown the AudioStream in a subsequent patch, when audio is
#   muted. This will allow resolving it at the right time when the media ends while
#   muted.
# ==============================================================================

diff -r 0b1dc7c2fdfd -r 0b20ed64f57c dom/media/mediasink/AudioSink.cpp
--- a/dom/media/mediasink/AudioSink.cpp	Tue May 24 13:09:05 2022 +0000
+++ b/dom/media/mediasink/AudioSink.cpp	Tue May 24 13:09:05 2022 +0000
@@ -66,8 +66,9 @@
 
 AudioSink::~AudioSink() = default;
 
-Result<already_AddRefed<MediaSink::EndedPromise>, nsresult> AudioSink::Start(
-    const PlaybackParams& aParams) {
+nsresult AudioSink::Start(
+    const PlaybackParams& aParams,
+    MozPromiseHolder<MediaSink::EndedPromise>& aEndedPromise) {
   MOZ_ASSERT(mOwnerThread->IsCurrentThreadIn());
 
   mAudioQueueListener = mAudioQueue.PushEvent().Connect(
@@ -85,7 +86,7 @@
     return Err(rv);
   }
 
-  return mAudioStream->Start();
+  return mAudioStream->Start(aEndedPromise);
 }
 
 TimeUnit AudioSink::GetPosition() {
@@ -119,18 +120,60 @@
   return TimeUnit::FromMicroseconds(AudioQueuedInRingBufferMS());
 }
 
-void AudioSink::Shutdown() {
+void AudioSink::ReenqueueUnplayedAudioDataIfNeeded() {
+  // This is OK: the AudioStream has been shut down. Shutdown guarantees that
+  // the audio callback thread won't call back again.
+  mProcessedSPSCQueue->ResetThreadIds();
+
+  // construct an AudioData
+  int sampleCount = mProcessedSPSCQueue->AvailableRead();
+  uint32_t channelCount = mConverter->OutputConfig().Channels();
+  uint32_t rate = mConverter->OutputConfig().Rate();
+  uint32_t frameCount = sampleCount / channelCount;
+
+  auto duration = FramesToTimeUnit(frameCount, rate);
+  if (!duration.IsValid()) {
+    NS_WARNING("Int overflow in AudioSink");
+    mErrored = true;
+    return;
+  }
+
+  AlignedAudioBuffer queuedAudio(sampleCount);
+  DebugOnly<int> samplesRead =
+    mProcessedSPSCQueue->Dequeue(queuedAudio.Data(), sampleCount);
+  MOZ_ASSERT(samplesRead == sampleCount);
+
+  // Extrapolate mOffset, mTime from the front of the queue
+  // We can't really find a good value for `mOffset`, so we take what we have
+  // at the front of the queue.
+  // For `mTime`, assume there hasn't been a discontinuity recently.
+  RefPtr<AudioData> frontPacket = mAudioQueue.PeekFront();
+  RefPtr<AudioData> data =
+      new AudioData(frontPacket->mOffset, frontPacket->mTime - duration, std::move(queuedAudio),
+                    channelCount, rate);
+  MOZ_DIAGNOSTIC_ASSERT(duration == data->mDuration, "must be equal");
+
+  mAudioQueue.PushFront(data);
+}
+
+Maybe<MozPromiseHolder<MediaSink::EndedPromise>> AudioSink::Shutdown(
+    ShutdownCause aShutdownCause) {
   MOZ_ASSERT(mOwnerThread->IsCurrentThreadIn());
 
   mAudioQueueListener.Disconnect();
   mAudioQueueFinishListener.Disconnect();
   mProcessedQueueListener.Disconnect();
 
+  Maybe<MozPromiseHolder<MediaSink::EndedPromise>> rv;
+
   if (mAudioStream) {
-    mAudioStream->Shutdown();
+    rv = mAudioStream->Shutdown(aShutdownCause);
     mAudioStream = nullptr;
+    ReenqueueUnplayedAudioDataIfNeeded();
   }
   mProcessedQueueFinished = true;
+
+  return rv;
 }
 
 void AudioSink::SetVolume(double aVolume) {