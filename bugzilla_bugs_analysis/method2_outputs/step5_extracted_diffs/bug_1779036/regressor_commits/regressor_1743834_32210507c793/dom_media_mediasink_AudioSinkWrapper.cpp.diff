# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/AudioSinkWrapper.cpp
# Commit: 32210507c793
# Full Hash: 32210507c793a2b86b7d4582eb66bef331687671
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-04-20 21:53:00
# Regressor Bug: 1743834
# File Overlap Count: 1
# Description:
#   Bug 1743834 - Create and manage the lifetime of the AudioStream EndedPromise in AudioSinkWrapper. r=alwu,media-playback-reviewers
#   
#   We're going to shutdown the AudioStream in a subsequent patch, when audio is
#   muted. This will allow resolving it at the right time when the media ends while
#   muted.
# ==============================================================================

diff -r b15369c023af -r 32210507c793 dom/media/mediasink/AudioSinkWrapper.cpp
--- a/dom/media/mediasink/AudioSinkWrapper.cpp	Wed Apr 20 12:07:08 2022 +0000
+++ b/dom/media/mediasink/AudioSinkWrapper.cpp	Wed Apr 20 12:07:09 2022 +0000
@@ -27,6 +27,7 @@
   AssertOwnerThread();
   MOZ_ASSERT(!mIsStarted, "Must be called after playback stopped.");
   mCreator = nullptr;
+  mEndedPromiseHolder.ResolveIfExists(true, __func__);
 }
 
 RefPtr<MediaSink::EndedPromise> AudioSinkWrapper::OnEnded(TrackType aType) {
@@ -188,21 +189,32 @@
     return NS_OK;
   }
 
+  nsresult rv = StartAudioSink(aStartTime);
+
+  return rv;
+}
+
+nsresult AudioSinkWrapper::StartAudioSink(const TimeUnit& aStartTime) {
+  MOZ_ASSERT(!mAudioSink);
+
+  RefPtr<MediaSink::EndedPromise> promise =
+      mEndedPromiseHolder.Ensure(__func__);
+
   mAudioSink.reset(mCreator->Create(aStartTime));
-  Result<already_AddRefed<MediaSink::EndedPromise>, nsresult> rv =
-      mAudioSink->Start(mParams);
-  if (rv.isErr()) {
-    mEndedPromise =
-        MediaSink::EndedPromise::CreateAndReject(rv.unwrapErr(), __func__);
+  nsresult rv = mAudioSink->Start(mParams, mEndedPromiseHolder);
+  if (NS_FAILED(rv)) {
+    mEndedPromise = MediaSink::EndedPromise::CreateAndReject(rv, __func__);
   } else {
-    mEndedPromise = rv.unwrap();
+    mEndedPromise = promise;
   }
 
+  mAudioSinkEndedPromise.DisconnectIfExists();
   mEndedPromise
       ->Then(mOwnerThread.get(), __func__, this,
              &AudioSinkWrapper::OnAudioEnded, &AudioSinkWrapper::OnAudioEnded)
       ->Track(mAudioSinkEndedPromise);
-  return rv.isErr() ? rv.unwrapErr() : NS_OK;
+
+  return rv;
 }
 
 bool AudioSinkWrapper::IsAudioSourceEnded(const MediaInfo& aInfo) const {
@@ -221,7 +233,9 @@
 
   if (mAudioSink) {
     mAudioSinkEndedPromise.DisconnectIfExists();
-    mAudioSink->Shutdown();
+    DebugOnly<Maybe<MozPromiseHolder<EndedPromise>>> rv =
+        mAudioSink->Shutdown();
+    MOZ_ASSERT(rv.inspect().isNothing());
     mAudioSink = nullptr;
     mEndedPromise = nullptr;
   }