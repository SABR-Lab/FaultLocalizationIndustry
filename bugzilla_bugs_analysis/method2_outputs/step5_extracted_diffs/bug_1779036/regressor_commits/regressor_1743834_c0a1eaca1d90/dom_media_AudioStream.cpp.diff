# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/AudioStream.cpp
# Commit: c0a1eaca1d90
# Full Hash: c0a1eaca1d90a8e5ea6c3ee43670306b6bd6289a
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-05-10 03:50:31
# Regressor Bug: 1743834
# File Overlap Count: 1
# Description:
#   Bug 1743834 - Create and manage the lifetime of the AudioStream EndedPromise in AudioSinkWrapper. r=alwu,media-playback-reviewers
#   
#   We're going to shutdown the AudioStream in a subsequent patch, when audio is
#   muted. This will allow resolving it at the right time when the media ends while
#   muted.
# ==============================================================================

diff -r 798e05478220 -r c0a1eaca1d90 dom/media/AudioStream.cpp
--- a/dom/media/AudioStream.cpp	Mon May 09 13:20:49 2022 +0000
+++ b/dom/media/AudioStream.cpp	Mon May 09 13:20:49 2022 +0000
@@ -226,7 +226,8 @@
   return aFunction(mCubebStream.get(), std::forward<Args>(aArgs)...);
 }
 
-nsresult AudioStream::Init(AudioDeviceInfo* aSinkInfo) NO_THREAD_SAFETY_ANALYSIS {
+nsresult AudioStream::Init(AudioDeviceInfo* aSinkInfo)
+    NO_THREAD_SAFETY_ANALYSIS {
   auto startTime = TimeStamp::Now();
   TRACE("AudioStream::Init");
 
@@ -318,19 +319,18 @@
   }
 }
 
-Result<already_AddRefed<MediaSink::EndedPromise>, nsresult>
-AudioStream::Start() {
+nsresult AudioStream::Start(
+    MozPromiseHolder<MediaSink::EndedPromise>& aEndedPromise) {
   TRACE("AudioStream::Start");
   MOZ_ASSERT(mState == INITIALIZED);
   mState = STARTED;
-
   RefPtr<MediaSink::EndedPromise> promise;
   {
     MonitorAutoLock mon(mMonitor);
     // As cubeb might call audio stream's state callback very soon after we
     // start cubeb, we have to create the promise beforehand in order to handle
     // the case where we immediately get `drained`.
-    promise = mEndedPromise.Ensure(__func__);
+    mEndedPromise = std::move(aEndedPromise);
     mPlaybackComplete = false;
 
     if (InvokeCubeb(cubeb_stream_start) != CUBEB_OK) {
@@ -342,9 +342,9 @@
                            : mState == DRAINED ? "DRAINED"
                                                : "ERRORED");
   if (mState == STARTED || mState == DRAINED) {
-    return promise.forget();
+    return NS_OK;
   }
-  return Err(NS_ERROR_FAILURE);
+  return NS_ERROR_FAILURE;
 }
 
 void AudioStream::Pause() {
@@ -389,7 +389,8 @@
   }
 }
 
-void AudioStream::Shutdown() {
+Maybe<MozPromiseHolder<MediaSink::EndedPromise>> AudioStream::Shutdown(
+    ShutdownCause aCause) {
   TRACE("AudioStream::Shutdown");
   LOG("Shutdown, state %d", mState.load());
 
@@ -412,7 +413,15 @@
   }
 
   mState = SHUTDOWN;
-  mEndedPromise.ResolveIfExists(true, __func__);
+  // When shutting down, if this AudioStream is shutting down because the
+  // HTMLMediaElement is now muted, hand back the ended promise, so that it can
+  // properly be resolved if the end of the media is reached while muted (i.e.
+  // without having an AudioStream)
+  if (aCause != ShutdownCause::Muting) {
+    mEndedPromise.ResolveIfExists(true, __func__);
+    return Nothing();
+  }
+  return Some(std::move(mEndedPromise));
 }
 
 int64_t AudioStream::GetPosition() {