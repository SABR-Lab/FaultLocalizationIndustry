# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mediasink/AudioSink.cpp
# Commit: c632760187c5
# Full Hash: c632760187c5c0d69adcff405050d8f233ebca1d
# Author: Paul Adenot <paul@paul.cx>
# Date: 2022-05-24 21:44:48
# Regressor Bug: 1743834
# File Overlap Count: 1
# Description:
#   Bug 1743834 - Trigger the audibility event at the beginning of the initialization of an audio stream, when un-muting. r=alwu
#   
#   The initialization itself can take some time and this audibility event is used
#   to prioritize the process, that will soon become audible, on at least Windows,
#   so it's better to get prioritized slightly ahead of time.
# ==============================================================================

diff -r 7f259ef8550f -r c632760187c5 dom/media/mediasink/AudioSink.cpp
--- a/dom/media/mediasink/AudioSink.cpp	Tue May 24 13:09:09 2022 +0000
+++ b/dom/media/mediasink/AudioSink.cpp	Tue May 24 13:09:10 2022 +0000
@@ -60,11 +60,35 @@
           capacitySeconds * static_cast<float>(mOutputChannels * mOutputRate)));
   SINK_LOG("Ringbuffer has space for %u elements (%lf seconds)",
            mProcessedSPSCQueue->Capacity(), capacitySeconds);
+  // Determine if the data is likely to be audible when the stream will be
+  // ready, if possible.
+  RefPtr<AudioData> frontPacket = mAudioQueue.PeekFront();
+  if (frontPacket) {
+    mAudibilityMonitor.ProcessInterleaved(frontPacket->Data(), frontPacket->mChannels);
+    mIsAudioDataAudible = mAudibilityMonitor.RecentlyAudible();
+  } else {
+    // If no packets are available, consider the audio audible.
+    mIsAudioDataAudible = true;
+  }
 }
 
 AudioSink::~AudioSink() = default;
 
-nsresult AudioSink::InitializeAudioStream(const PlaybackParams& aParams) {
+nsresult AudioSink::InitializeAudioStream(
+    const PlaybackParams& aParams,
+    AudioSink::InitializationType aInitializationType) {
+  if (aInitializationType == AudioSink::InitializationType::UNMUTING) {
+    // Consider the stream to be audible immediately, before initialization
+    // finishes when unmuting, in case initialization takes some time and it
+    // looked audible when the AudioSink was created.
+    mAudibleEvent.Notify(mIsAudioDataAudible);
+  } else {
+    // If not unmuting, the audibility event will be dispatched as usual,
+    // inspecting the audio content as it's being played and signaling the
+    // audibility event when a different in state is detected.
+    mIsAudioDataAudible = false;
+  }
+
   // When AudioQueue is empty, there is no way to know the channel layout of
   // the coming audio data, so we use the predefined channel map instead.
   AudioConfig::ChannelLayout::ChannelMap channelMap =
@@ -73,6 +97,7 @@
   // mOutputChannels into SMPTE format, so there is no need to worry if
   // StaticPrefs::accessibility_monoaudio_enable() or
   // StaticPrefs::media_forcestereo_enabled() is applied.
+  MOZ_ASSERT(!mAudioStream);
   mAudioStream =
       new AudioStream(*this, mOutputRate, mOutputChannels, channelMap);
   nsresult rv = mAudioStream->Init(mAudioDevice);
@@ -87,6 +112,7 @@
   mAudioStream->SetVolume(aParams.mVolume);
   mAudioStream->SetPlaybackRate(aParams.mPlaybackRate);
   mAudioStream->SetPreservesPitch(aParams.mPreservesPitch);
+
   return NS_OK;
 }
 