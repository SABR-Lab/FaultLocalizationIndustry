# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/nsAccessibilityService.h
# Commit: 1bf4b290248b
# Full Hash: 1bf4b290248bb7ff5ae1c8bfe48016e2f03f5b54
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-07-12 09:33:27
# Regressor Bug: 1757121
# File Overlap Count: 1
# Description:
#   Bug 1757121 part 1: Allow nsAccessibilityService::MarkupAttribute/MarkupAttributes to take an Accessible. r=morgan
#   
#   Previously, these methods took a DOM nsIContent, making it impossible for them to work for RemoteAccessible.
#   GetMarkupMapInfoForNode has been renamed to GetMarkupMapInfoFor and has overloads for nsIContent and Accessible.
#   MarkupAttribute is a template which can take either, as we still need the nsIContent version elsewhere.
# ==============================================================================

diff -r 919ec20e9cef -r 1bf4b290248b accessible/base/nsAccessibilityService.h
--- a/accessible/base/nsAccessibilityService.h	Tue Jul 12 02:44:31 2022 +0000
+++ b/accessible/base/nsAccessibilityService.h	Tue Jul 12 02:45:56 2022 +0000
@@ -36,6 +36,7 @@
 namespace a11y {
 
 class AccAttributes;
+class Accessible;
 class ApplicationAccessible;
 class xpcAccessibleApplication;
 
@@ -265,18 +266,19 @@
 
   mozilla::a11y::role MarkupRole(const nsIContent* aContent) const {
     const mozilla::a11y::MarkupMapInfo* markupMap =
-        GetMarkupMapInfoForNode(aContent);
+        GetMarkupMapInfoFor(aContent);
     return markupMap ? markupMap->role : mozilla::a11y::roles::NOTHING;
   }
 
   /**
    * Return the associated value for a given attribute if
-   * it appears in the MarkupMap. Otherwise, it returns null.
+   * it appears in the MarkupMap. Otherwise, it returns null. This can be
+   * called with either an nsIContent or an Accessible.
    */
-  nsStaticAtom* MarkupAttribute(const nsIContent* aContent,
-                                nsStaticAtom* aAtom) const {
+  template <typename T>
+  nsStaticAtom* MarkupAttribute(T aSource, nsStaticAtom* aAtom) const {
     const mozilla::a11y::MarkupMapInfo* markupMap =
-        GetMarkupMapInfoForNode(aContent);
+        GetMarkupMapInfoFor(aSource);
     if (markupMap) {
       for (size_t i = 0; i < mozilla::ArrayLength(markupMap->attrs); i++) {
         const mozilla::a11y::MarkupAttrInfo* info = markupMap->attrs + i;
@@ -291,7 +293,7 @@
   /**
    * Set the object attribute defined by markup for the given element.
    */
-  void MarkupAttributes(const nsIContent* aContent,
+  void MarkupAttributes(mozilla::a11y::Accessible* aAcc,
                         mozilla::a11y::AccAttributes* aAttributes) const;
 
   /**
@@ -381,7 +383,7 @@
   MarkupMap mHTMLMarkupMap;
   MarkupMap mMathMLMarkupMap;
 
-  const mozilla::a11y::MarkupMapInfo* GetMarkupMapInfoForNode(
+  const mozilla::a11y::MarkupMapInfo* GetMarkupMapInfoFor(
       const nsIContent* aContent) const {
     if (aContent->IsHTMLElement()) {
       return mHTMLMarkupMap.Get(aContent->NodeInfo()->NameAtom());
@@ -395,6 +397,9 @@
     return nullptr;
   }
 
+  const mozilla::a11y::MarkupMapInfo* GetMarkupMapInfoFor(
+      mozilla::a11y::Accessible* aAcc) const;
+
   nsTHashMap<nsPtrHashKey<const nsAtom>, const mozilla::a11y::XULMarkupMapInfo*>
       mXULMarkupMap;
 