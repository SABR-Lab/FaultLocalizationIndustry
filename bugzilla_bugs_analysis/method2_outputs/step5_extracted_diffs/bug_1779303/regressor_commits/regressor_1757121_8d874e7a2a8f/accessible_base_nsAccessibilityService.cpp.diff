# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/nsAccessibilityService.cpp
# Commit: 8d874e7a2a8f
# Full Hash: 8d874e7a2a8fe3def139cce04a725ecabe0e21f0
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-06-29 16:48:50
# Regressor Bug: 1757121
# File Overlap Count: 1
# Description:
#   Bug 1757121 part 1: Allow nsAccessibilityService::MarkupAttribute/MarkupAttributes to take an Accessible. r=morgan
#   
#   Previously, these methods took a DOM nsIContent, making it impossible for them to work for RemoteAccessible.
#   GetMarkupMapInfoForNode has been renamed to GetMarkupMapInfoFor and has overloads for nsIContent and Accessible.
#   MarkupAttribute is a template which can take either, as we still need the nsIContent version elsewhere.
# ==============================================================================

diff -r 1d98c5a7861b -r 8d874e7a2a8f accessible/base/nsAccessibilityService.cpp
--- a/accessible/base/nsAccessibilityService.cpp	Wed Jun 29 06:55:45 2022 +0000
+++ b/accessible/base/nsAccessibilityService.cpp	Wed Jun 29 07:04:12 2022 +0000
@@ -960,7 +960,7 @@
     // display:contents element doesn't have a frame, but retains the semantics.
     // All its children are unaffected.
     if (nsCoreUtils::CanCreateAccessibleWithoutFrame(content)) {
-      const MarkupMapInfo* markupMap = GetMarkupMapInfoForNode(content);
+      const MarkupMapInfo* markupMap = GetMarkupMapInfoFor(content);
       if (markupMap && markupMap->new_func) {
         RefPtr<LocalAccessible> newAcc =
             markupMap->new_func(content->AsElement(), aContext);
@@ -1522,30 +1522,27 @@
 }
 
 void nsAccessibilityService::MarkupAttributes(
-    const nsIContent* aContent, AccAttributes* aAttributes) const {
-  const mozilla::a11y::MarkupMapInfo* markupMap =
-      GetMarkupMapInfoForNode(aContent);
+    Accessible* aAcc, AccAttributes* aAttributes) const {
+  const mozilla::a11y::MarkupMapInfo* markupMap = GetMarkupMapInfoFor(aAcc);
   if (!markupMap) return;
 
+  dom::Element* el = aAcc->IsLocal() ? aAcc->AsLocal()->Elm() : nullptr;
   for (uint32_t i = 0; i < ArrayLength(markupMap->attrs); i++) {
     const MarkupAttrInfo* info = markupMap->attrs + i;
     if (!info->name) break;
 
-    if (info->DOMAttrName) {
+    // XXX Expose DOM attributes for cached RemoteAccessibles.
+    if (info->DOMAttrName && el) {
       if (info->DOMAttrValue) {
-        if (aContent->IsElement() && aContent->AsElement()->AttrValueIs(
-                                         kNameSpaceID_None, info->DOMAttrName,
-                                         info->DOMAttrValue, eCaseMatters)) {
+        if (el->AttrValueIs(kNameSpaceID_None, info->DOMAttrName,
+                            info->DOMAttrValue, eCaseMatters)) {
           aAttributes->SetAttribute(info->name, info->DOMAttrValue);
         }
         continue;
       }
 
       nsString value;
-      if (aContent->IsElement()) {
-        aContent->AsElement()->GetAttr(kNameSpaceID_None, info->DOMAttrName,
-                                       value);
-      }
+      el->GetAttr(kNameSpaceID_None, info->DOMAttrName, value);
 
       if (!value.IsEmpty()) {
         aAttributes->SetAttribute(info->name, std::move(value));
@@ -1657,6 +1654,18 @@
                                    consumers.get());
 }
 
+const mozilla::a11y::MarkupMapInfo* nsAccessibilityService::GetMarkupMapInfoFor(
+    Accessible* aAcc) const {
+  if (LocalAccessible* localAcc = aAcc->AsLocal()) {
+    return GetMarkupMapInfoFor(localAcc->GetContent());
+  }
+  // XXX For now, we assume all RemoteAccessibles are HTML elements. This
+  // isn't strictly correct, but as far as current callers are concerned,
+  // this doesn't matter. If that changes in future, we could expose the
+  // element type via AccGenericType.
+  return mHTMLMarkupMap.Get(aAcc->TagName());
+}
+
 nsAccessibilityService* GetOrCreateAccService(uint32_t aNewConsumer) {
   // Do not initialize accessibility if it is force disabled.
   if (PlatformDisabledState() == ePlatformIsDisabled) {