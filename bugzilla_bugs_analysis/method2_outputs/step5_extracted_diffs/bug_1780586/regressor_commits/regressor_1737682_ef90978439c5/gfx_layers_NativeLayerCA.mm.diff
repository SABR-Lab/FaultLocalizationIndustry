# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/NativeLayerCA.mm
# Commit: ef90978439c5
# Full Hash: ef90978439c5541f2646af76d1c599a2cb36b140
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2022-07-21 03:47:38
# Regressor Bug: 1737682
# File Overlap Count: 1
# Description:
#   Bug 1737682 Part 1: Log whether or not we are hitting the detached state. r=mstange
#   
#   There are 10 enum cases that we track internally, one of which isn't
#   emitted as telemetry. These cases are 0-indexed to match the enum values.
#   
# ==============================================================================

diff -r ed4b0f82a124 -r ef90978439c5 gfx/layers/NativeLayerCA.mm
--- a/gfx/layers/NativeLayerCA.mm	Wed Jul 20 19:59:06 2022 +0000
+++ b/gfx/layers/NativeLayerCA.mm	Wed Jul 20 20:00:26 2022 +0000
@@ -26,6 +26,7 @@
 #include "mozilla/layers/ScreenshotGrabber.h"
 #include "mozilla/layers/SurfacePoolCA.h"
 #include "mozilla/StaticPrefs_gfx.h"
+#include "mozilla/Telemetry.h"
 #include "mozilla/webrender/RenderMacIOSurfaceTextureHost.h"
 #include "nsCocoaFeatures.h"
 #include "ScopedGLHelpers.h"
@@ -48,6 +49,48 @@
 using gl::GLContext;
 using gl::GLContextCGL;
 
+static Maybe<Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER> VideoLowPowerTypeToTelemetryType(
+    VideoLowPowerType aVideoLowPower) {
+  switch (aVideoLowPower) {
+    case VideoLowPowerType::LowPower:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::LowPower);
+
+    case VideoLowPowerType::FailMultipleVideo:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailMultipleVideo);
+
+    case VideoLowPowerType::FailWindowed:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailWindowed);
+
+    case VideoLowPowerType::FailOverlaid:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailOverlaid);
+
+    case VideoLowPowerType::FailBacking:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailBacking);
+
+    case VideoLowPowerType::FailMacOSVersion:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailMacOSVersion);
+
+    case VideoLowPowerType::FailPref:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailPref);
+
+    case VideoLowPowerType::FailSurface:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailSurface);
+
+    case VideoLowPowerType::FailEnqueue:
+      return Some(Telemetry::LABELS_GFX_MACOS_VIDEO_LOW_POWER::FailEnqueue);
+
+    default:
+      return Nothing();
+  }
+}
+
+static void EmitTelemetryForVideoLowPower(VideoLowPowerType aVideoLowPower) {
+  auto telemetryValue = VideoLowPowerTypeToTelemetryType(aVideoLowPower);
+  if (telemetryValue.isSome()) {
+    Telemetry::AccumulateCategorical(telemetryValue.value());
+  }
+}
+
 // Utility classes for NativeLayerRootSnapshotter (NLRS) profiler screenshots.
 
 class RenderSourceNLRS : public profiler_screenshots::RenderSource {
@@ -267,6 +310,14 @@
     }
   }
 
+  // Decide if we are going to emit telemetry about video low power on this commit.
+  mTelemetryCommitCount = (mTelemetryCommitCount + 1) % TELEMETRY_COMMIT_PERIOD;
+  if (mTelemetryCommitCount == 0) {
+    // Figure out if we are hitting video low power mode.
+    VideoLowPowerType videoLowPower = CheckVideoLowPower();
+    EmitTelemetryForVideoLowPower(videoLowPower);
+  }
+
   return true;
 }
 
@@ -442,6 +493,116 @@
   }
 }
 
+/* static */ bool IsCGColorOpaqueBlack(CGColorRef aColor) {
+  if (CGColorEqualToColor(aColor, CGColorGetConstantColor(kCGColorBlack))) {
+    return true;
+  }
+  size_t componentCount = CGColorGetNumberOfComponents(aColor);
+  const CGFloat* components = CGColorGetComponents(aColor);
+  for (size_t c = 0; c < componentCount - 1; ++c) {
+    if (components[c] > 0.0f) {
+      return false;
+    }
+  }
+  return components[componentCount - 1] >= 1.0f;
+}
+
+VideoLowPowerType NativeLayerRootCA::CheckVideoLowPower() {
+  // This deteremines whether the current layer contents qualify for the
+  // macOS Core Animation video low power mode. Those requirements are
+  // summarized at
+  // https://developer.apple.com/documentation/webkit/delivering_video_content_for_safari
+  // and we verify them by checking:
+  // 1) There must be exactly one video showing.
+  // 2) The topmost CALayer must be a AVSampleBufferDisplayLayer.
+  // 3) The video layer must be showing a buffer encoded in one of the
+  //    kCVPixelFormatType_420YpCbCr pixel formats.
+  // 4) The layer below that must cover the entire screen and have a black
+  //    background color.
+  // 5) The window must be fullscreen.
+  // This function checks these requirements empirically. If one of the checks
+  // fail, we either return immediately or do additional processing to
+  // determine more detail.
+
+  uint32_t videoLayerCount = 0;
+  NativeLayerCA* topLayer = nullptr;
+  CALayer* topCALayer = nil;
+  CALayer* secondCALayer = nil;
+  bool topLayerIsVideo = false;
+
+  for (auto layer : mSublayers) {
+    // Only layers with extent are contributing to our sublayers.
+    if (layer->HasExtent()) {
+      topLayer = layer;
+
+      secondCALayer = topCALayer;
+      topCALayer = topLayer->UnderlyingCALayer(WhichRepresentation::ONSCREEN);
+      topLayerIsVideo = topLayer->IsVideo();
+      if (topLayerIsVideo) {
+        ++videoLayerCount;
+      }
+    }
+  }
+
+  if (videoLayerCount == 0) {
+    return VideoLowPowerType::NotVideo;
+  }
+
+  if (videoLayerCount > 1) {
+    return VideoLowPowerType::FailMultipleVideo;
+  }
+
+  if (!mWindowIsFullscreen) {
+    return VideoLowPowerType::FailWindowed;
+  }
+
+  if (!topLayerIsVideo) {
+    return VideoLowPowerType::FailOverlaid;
+  }
+
+  if (!secondCALayer || !IsCGColorOpaqueBlack(secondCALayer.backgroundColor) ||
+      !CGRectContainsRect(secondCALayer.frame, secondCALayer.superlayer.bounds)) {
+    return VideoLowPowerType::FailBacking;
+  }
+
+  CALayer* topContentCALayer = topCALayer.sublayers[0];
+  if (![topContentCALayer isKindOfClass:[AVSampleBufferDisplayLayer class]]) {
+    // We didn't create a AVSampleBufferDisplayLayer for the top video layer.
+    // Try to figure out why by following some of the logic in
+    // NativeLayerCA::ShouldSpecializeVideo.
+    if (!nsCocoaFeatures::OnHighSierraOrLater()) {
+      return VideoLowPowerType::FailMacOSVersion;
+    }
+
+    if (!StaticPrefs::gfx_core_animation_specialize_video()) {
+      return VideoLowPowerType::FailPref;
+    }
+
+    // The only remaining reason is that the surface wasn't eligible. We
+    // assert this instead of if-ing it, to ensure that we always have a
+    // return value from this clause.
+#ifdef DEBUG
+    MOZ_ASSERT(topLayer->mTextureHost);
+    MacIOSurface* macIOSurface = topLayer->mTextureHost->GetSurface();
+    CFTypeRefPtr<IOSurfaceRef> surface = macIOSurface->GetIOSurfaceRef();
+    OSType pixelFormat = IOSurfaceGetPixelFormat(surface.get());
+    MOZ_ASSERT(!(pixelFormat == kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange ||
+                 pixelFormat == kCVPixelFormatType_420YpCbCr8BiPlanarFullRange ||
+                 pixelFormat == kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange ||
+                 pixelFormat == kCVPixelFormatType_420YpCbCr10BiPlanarFullRange));
+#endif
+    return VideoLowPowerType::FailSurface;
+  }
+
+  AVSampleBufferDisplayLayer* topVideoLayer = (AVSampleBufferDisplayLayer*)topContentCALayer;
+  if (topVideoLayer.status != AVQueuedSampleBufferRenderingStatusRendering) {
+    return VideoLowPowerType::FailEnqueue;
+  }
+
+  // As best we can tell, we're eligible for video low power mode. Hurrah!
+  return VideoLowPowerType::LowPower;
+}
+
 NativeLayerRootSnapshotterCA::NativeLayerRootSnapshotterCA(NativeLayerRootCA* aLayerRoot,
                                                            RefPtr<GLContext>&& aGL,
                                                            CALayer* aRootCALayer)