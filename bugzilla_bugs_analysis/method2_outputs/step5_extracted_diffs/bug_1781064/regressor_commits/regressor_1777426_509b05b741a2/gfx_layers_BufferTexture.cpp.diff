# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/BufferTexture.cpp
# Commit: 509b05b741a2
# Full Hash: 509b05b741a2c5b27f467f9bd8c45bb1f32902da
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-07-12 21:56:41
# Regressor Bug: 1777426
# File Overlap Count: 1
# Description:
#   Bug 1777426 - Ensure MemoryTextureData frees memory when owned by RemoteTextureMap. r=aosmond,gfx-reviewers
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D151422
# ==============================================================================

diff -r 2fdaa8eca97c -r 509b05b741a2 gfx/layers/BufferTexture.cpp
--- a/gfx/layers/BufferTexture.cpp	Tue Jul 12 06:56:20 2022 +0000
+++ b/gfx/layers/BufferTexture.cpp	Tue Jul 12 06:56:21 2022 +0000
@@ -49,14 +49,21 @@
 
   MemoryTextureData(const BufferDescriptor& aDesc,
                     gfx::BackendType aMoz2DBackend, uint8_t* aBuffer,
-                    size_t aBufferSize)
+                    size_t aBufferSize, bool aAutoDeallocate = false)
       : BufferTextureData(aDesc, aMoz2DBackend),
         mBuffer(aBuffer),
-        mBufferSize(aBufferSize) {
+        mBufferSize(aBufferSize),
+        mAutoDeallocate(aAutoDeallocate) {
     MOZ_ASSERT(aBuffer);
     MOZ_ASSERT(aBufferSize);
   }
 
+  virtual ~MemoryTextureData() override {
+    if (mAutoDeallocate) {
+      Deallocate(nullptr);
+    }
+  }
+
   virtual uint8_t* GetBuffer() override { return mBuffer; }
 
   virtual size_t GetBufferSize() override { return mBufferSize; }
@@ -64,6 +71,7 @@
  protected:
   uint8_t* mBuffer;
   size_t mBufferSize;
+  bool mAutoDeallocate;
 };
 
 class ShmemTextureData : public BufferTextureData {
@@ -434,7 +442,11 @@
 
   BufferDescriptor descriptor = RGBDescriptor(aSize, aFormat);
 
-  return new MemoryTextureData(descriptor, aMoz2DBackend, buf, bufSize);
+  // Remote textures are not managed by a texture client, so we need to ensure
+  // that memory is freed when the owning MemoryTextureData goes away.
+  bool autoDeallocate = !!(aFlags & TextureFlags::REMOTE_TEXTURE);
+  return new MemoryTextureData(descriptor, aMoz2DBackend, buf, bufSize,
+                               autoDeallocate);
 }
 
 void MemoryTextureData::Deallocate(LayersIPCChannel*) {