# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/LocalAccessible.cpp
# Commit: 6de77a6f3d23
# Full Hash: 6de77a6f3d23e393013e8526f71a137a4f4b98d2
# Author: Morgan Rae Reschenberg <mreschenberg@mozilla.com>
# Date: 2022-08-03 09:44:13
# Regressor Bug: 1774043
# File Overlap Count: 1
# Description:
#   Bug 1774043: [Part 1] Add cache domains, caching logic for LABEL_FOR and LABELLED_BY relations r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D152100
# ==============================================================================

diff -r 5a0ebbf37b2c -r 6de77a6f3d23 accessible/generic/LocalAccessible.cpp
--- a/accessible/generic/LocalAccessible.cpp	Wed Aug 03 04:20:39 2022 +0000
+++ b/accessible/generic/LocalAccessible.cpp	Wed Aug 03 05:09:53 2022 +0000
@@ -87,6 +87,7 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLCanvasElement.h"
 #include "mozilla/dom/HTMLBodyElement.h"
+#include "mozilla/dom/HTMLLabelElement.h"
 #include "mozilla/dom/KeyboardEventBinding.h"
 #include "mozilla/dom/TreeWalker.h"
 #include "mozilla/dom/UserActivation.h"
@@ -1348,6 +1349,10 @@
   }
 
   if (aAttribute == nsGkAtoms::aria_labelledby) {
+    // We only queue cache updates for explicit relations. Implicit, reverse
+    // relations are handled in ApplyCache and stored in a map on the remote
+    // document itself.
+    mDoc->QueueCacheUpdate(this, CacheDomain::Relations);
     mDoc->FireDelayedEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, this);
     if (aModType == dom::MutationEvent_Binding::MODIFICATION ||
         aModType == dom::MutationEvent_Binding::ADDITION) {
@@ -3558,6 +3563,39 @@
     }
   }
 
+  if (aCacheDomain & CacheDomain::Relations) {
+    for (auto const& data : kRelationTypeAtoms) {
+      nsTArray<uint64_t> ids;
+      nsStaticAtom* const relAtom = data.mAtom;
+
+      Relation rel;
+      if (data.mType == RelationType::LABEL_FOR) {
+        // Labels are a special case -- we need to validate that the target of
+        // their `for` attribute is in fact labelable. DOM checks this when we
+        // call GetControl().
+        if (dom::HTMLLabelElement* labelEl =
+                dom::HTMLLabelElement::FromNode(mContent)) {
+          rel.AppendTarget(mDoc, labelEl->GetControl());
+        }
+      } else {
+        // We use an IDRefsIterator here instead of calling RelationByType
+        // directly because we only want to cache explicit relations. Implicit
+        // relations will be computed and stored separately in the parent
+        // process.
+        rel.AppendIter(new IDRefsIterator(mDoc, mContent, relAtom));
+      }
+
+      while (LocalAccessible* acc = rel.Next()) {
+        ids.AppendElement(acc->IsDoc() ? 0 : acc->ID());
+      }
+      if (ids.Length()) {
+        fields->SetAttribute(relAtom, std::move(ids));
+      } else if (aUpdateType == CacheUpdateType::Update) {
+        fields->SetAttribute(relAtom, DeleteEntry());
+      }
+    }
+  }
+
   if (aUpdateType == CacheUpdateType::Initial) {
     // Add fields which never change and thus only need to be included in the
     // initial cache push.