# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsWindow.cpp
# Commit: 0531e0fd8b47
# Full Hash: 0531e0fd8b47b52fe15bc3f2c6a337b37a4c93fc
# Author: stransky <stransky@redhat.com>
# Date: 2022-07-26 21:44:38
# Regressor Bug: 1777664
# File Overlap Count: 1
# Description:
#   Bug 1777664 [Wayland] Don't pause compositor when nsWindow is hidden r=emilio
#   
#   We should not pause compositor as compositing is driven by refresh driver and compositor pause leads to browser freeze.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D152689
# ==============================================================================

diff -r 8a1503365add -r 0531e0fd8b47 widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:47 2022 +0000
+++ b/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:47 2022 +0000
@@ -1102,12 +1102,6 @@
   mWaylandPopupNext = mWaylandPopupPrev = nullptr;
 }
 
-void nsWindow::HideWaylandWindow() {
-  LOG("nsWindow::HideWaylandWindow: [%p]\n", this);
-  PauseCompositorHiddenWindow();
-  gtk_widget_hide(mShell);
-}
-
 // Gtk refuses to map popup window with x < 0 && y < 0 relative coordinates
 // see https://gitlab.gnome.org/GNOME/gtk/-/issues/4071
 // as a workaround just fool around and place the popup temporary to 0,0.
@@ -1209,7 +1203,7 @@
 
   // Hide only visible popups or popups closed pernamently.
   if (visible) {
-    HideWaylandWindow();
+    gtk_widget_hide(mShell);
 
     // If there's pending Move-To-Rect callback and we hide the popup
     // the callback won't be called any more.
@@ -1238,7 +1232,7 @@
       popup = prev;
     }
   }
-  HideWaylandWindow();
+  gtk_widget_hide(mShell);
 }
 
 void nsWindow::WaylandPopupRemoveClosedPopups() {
@@ -5322,7 +5316,6 @@
 void nsWindow::DisableRenderingToWindow() {
   LOG("nsWindow::DisableRenderingToWindow()");
 
-  PauseCompositorHiddenWindow();
   WaylandStopVsync();
   if (mCompositorWidgetDelegate) {
     mCompositorWidgetDelegate->DisableRendering();
@@ -6129,34 +6122,6 @@
   }
 }
 
-// Because wl_egl_window is destroyed on moz_container_unmap(),
-// the current compositor cannot use it anymore. To avoid crash,
-// pause the compositor and destroy EGLSurface & resume the compositor
-// and re-create EGLSurface on next expose event.
-void nsWindow::PauseCompositorHiddenWindow() {
-  LOG("nsWindow::PauseCompositorHiddenWindow");
-
-  if (mCompositorState != COMPOSITOR_ENABLED) {
-    LOG("  quit early, compositor is disabled");
-    return;
-  }
-
-  mCompositorState = COMPOSITOR_PAUSED_MISSING_WINDOW;
-
-  // Without remote widget / renderer we can't pause compositor.
-  // So delete LayerManager to avoid EGLSurface access.
-  CompositorBridgeChild* remoteRenderer = GetRemoteRenderer();
-  if (!remoteRenderer || !mCompositorWidgetDelegate) {
-    LOG("  deleted layer manager");
-    DestroyLayerManager();
-    return;
-  }
-
-  // XXX slow sync IPC
-  LOG("  paused compositor");
-  remoteRenderer->SendPause();
-}
-
 static int WindowResumeCompositor(void* data) {
   nsWindow* window = static_cast<nsWindow*>(data);
   window->ResumeCompositor();