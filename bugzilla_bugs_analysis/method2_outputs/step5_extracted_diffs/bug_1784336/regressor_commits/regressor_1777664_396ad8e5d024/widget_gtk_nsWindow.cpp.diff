# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsWindow.cpp
# Commit: 396ad8e5d024
# Full Hash: 396ad8e5d024cab6e42e26de98e27591155aa9c8
# Author: stransky <stransky@redhat.com>
# Date: 2022-07-26 21:44:38
# Regressor Bug: 1777664
# File Overlap Count: 1
# Description:
#   Bug 1777664 [Linux] Don't pause/resume compositor by nsWindow::SetCompositorWidgetDelegate() r=emilio
#   
#   nsWindow::SetCompositorWidgetDelegate() should not control compositor state as nsWindow::SetCompositorWidgetDelegate() itself is called by nsBaseWidget::CreateCompositor()/nsBaseWidget::DestroyCompositor().
#   
#   In this patch we remove compositor pause/resume from nsWindow::SetCompositorWidgetDelegate() and update only GdkWindow/XWindow stored in remote widget.
# ==============================================================================

diff -r 0fa3652858e9 -r 396ad8e5d024 widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:46 2022 +0000
+++ b/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:46 2022 +0000
@@ -5303,11 +5303,6 @@
 void nsWindow::EnableRenderingToWindow() {
   LOG("nsWindow::EnableRenderingToWindow()");
 
-  if (mCompositorWidgetDelegate) {
-    mCompositorWidgetDelegate->EnableRendering(GetX11Window(),
-                                               GetShapedState());
-  }
-
   if (GdkIsWaylandDisplay()) {
 #ifdef MOZ_WAYLAND
     moz_container_wayland_add_initial_draw_callback(
@@ -5417,6 +5412,11 @@
     mCompositorState = COMPOSITOR_PAUSED_MISSING_WINDOW;
   }
 
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->EnableRendering(GetX11Window(),
+                                               GetShapedState());
+  }
+
   EnableRenderingToWindow();
 
   if (mHasMappedToplevel) {
@@ -8503,15 +8503,18 @@
 /* nsWindow::SetCompositorWidgetDelegate() sets remote GtkCompositorWidget
  * to render into with compositor.
  *
- * If we're already visible we need to recreate compositor/vsync state.
+ * SetCompositorWidgetDelegate(delegate) is called from
+ * nsBaseWidget::CreateCompositor(), i.e. nsWindow::GetWindowRenderer().
+ *
+ * SetCompositorWidgetDelegate(null) is called from
+ * nsBaseWidget::DestroyCompositor().
  */
 void nsWindow::SetCompositorWidgetDelegate(CompositorWidgetDelegate* delegate) {
   LOG("nsWindow::SetCompositorWidgetDelegate %p\n", delegate);
 
-  // There's a change of remote widget - stop compositor and VSync as
-  // we're going re-init it.
-  if (mCompositorWidgetDelegate && mIsMapped) {
-    DisableRenderingToWindow();
+  // Remove reference to GdkWindow/XWindow from remote widget.
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->DisableRendering();
   }
 
   if (delegate) {
@@ -8519,10 +8522,10 @@
     MOZ_ASSERT(mCompositorWidgetDelegate,
                "nsWindow::SetCompositorWidgetDelegate called with a "
                "non-PlatformCompositorWidgetDelegate");
-    // This is called from nsBaseWidget::CreateCompositor() in which case
-    // we need to create a new EGL surface in RenderCompositorEGL on X11
+    // Pass recent GdkWindow/XWindow to remote widget.
     if (mIsMapped) {
-      EnableRenderingToWindow();
+      mCompositorWidgetDelegate->EnableRendering(GetX11Window(),
+                                                 GetShapedState());
     }
   } else {
     mCompositorWidgetDelegate = nullptr;
