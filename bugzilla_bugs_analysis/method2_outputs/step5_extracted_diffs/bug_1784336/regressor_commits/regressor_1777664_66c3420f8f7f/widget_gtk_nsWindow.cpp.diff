# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsWindow.cpp
# Commit: 66c3420f8f7f
# Full Hash: 66c3420f8f7fc12124e9fd1825d1d1fd8776b022
# Author: stransky <stransky@redhat.com>
# Date: 2022-07-26 21:44:38
# Regressor Bug: 1777664
# File Overlap Count: 1
# Description:
#   Bug 1777664 [Wayland] Remove EnableRenderingToWindow()/DisableRenderingToWindow/()/ResumeCompositorHiddenWindow() r=emilio
#   
#   Enable composition only once when nsWindow is created and don't stop compositon until a window is destroyed.
#   Remove COMPOSITOR_PAUSED_MISSING_WINDOW as we don't manage compositing for hidden windows any more.
#   
# ==============================================================================

diff -r 0531e0fd8b47 -r 66c3420f8f7f widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:47 2022 +0000
+++ b/widget/gtk/nsWindow.cpp	Tue Jul 26 14:56:48 2022 +0000
@@ -559,19 +559,13 @@
 
   LOG("nsWindow::Destroy\n");
 
-  // Clear up WebRender queue
-  RevokeTransactionIdAllocator();
-
-  DisableRenderingToWindow();
-
   mIsDestroyed = true;
   mCreated = false;
 
-  /** Need to clean our LayerManager up while still alive */
-  if (mWindowRenderer) {
-    mWindowRenderer->Destroy();
-  }
-  mWindowRenderer = nullptr;
+  if (mCompositorPauseTimeoutID) {
+    g_source_remove(mCompositorPauseTimeoutID);
+    mCompositorPauseTimeoutID = 0;
+  }
 
 #ifdef MOZ_WAYLAND
   // Shut down our local vsync source
@@ -583,17 +577,12 @@
   MozClearPointer(mXdgToken, xdg_activation_token_v1_destroy);
 #endif
 
-  if (mCompositorPauseTimeoutID) {
-    g_source_remove(mCompositorPauseTimeoutID);
-    mCompositorPauseTimeoutID = 0;
-  }
-
-  // It is safe to call DestroyeCompositor several times (here and
-  // in the parent class) since it will take effect only once.
-  // The reason we call it here is because on gtk platforms we need
-  // to destroy the compositor before we destroy the gdk window (which
-  // destroys the the gl context attached to it).
-  DestroyCompositor();
+  /** Need to clean our LayerManager up while still alive */
+  DestroyLayerManager();
+
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->DisableRendering();
+  }
 
   // Ensure any resources assigned to the window get cleaned up first
   // to avoid double-freeing.
@@ -1211,11 +1200,6 @@
   }
 
   if (mPopupClosed) {
-    // Clear rendering transactions of closed window and disable rendering to it
-    // (see https://bugzilla.mozilla.org/show_bug.cgi?id=1717451#c27 for
-    // details).
-    RevokeTransactionIdAllocator();
-
     LOG("Clearing mMoveToRectPopupSize\n");
     mMoveToRectPopupSize = {};
   }
@@ -5294,34 +5278,6 @@
   g_signal_handlers_disconnect_by_data(frame_clock, window);
 }
 
-void nsWindow::EnableRenderingToWindow() {
-  LOG("nsWindow::EnableRenderingToWindow()");
-
-  if (GdkIsWaylandDisplay()) {
-#ifdef MOZ_WAYLAND
-    moz_container_wayland_add_initial_draw_callback(
-        mContainer, [self = RefPtr{this}, this]() -> void {
-          LOG("moz_container_wayland initial create "
-              "ResumeCompositorHiddenWindow()");
-          self->ResumeCompositorHiddenWindow();
-          self->WaylandStartVsync();
-        });
-#endif
-  } else {
-    ResumeCompositorHiddenWindow();
-    WaylandStartVsync();
-  }
-}
-
-void nsWindow::DisableRenderingToWindow() {
-  LOG("nsWindow::DisableRenderingToWindow()");
-
-  WaylandStopVsync();
-  if (mCompositorWidgetDelegate) {
-    mCompositorWidgetDelegate->DisableRendering();
-  }
-}
-
 Window nsWindow::GetX11Window() {
 #ifdef MOZ_X11
   if (GdkIsX11Display()) {
@@ -5401,16 +5357,42 @@
 
   RefreshWindowClass();
 
-  if (mCompositorState == COMPOSITOR_PAUSED_INITIALLY) {
-    mCompositorState = COMPOSITOR_PAUSED_MISSING_WINDOW;
-  }
-
+  // If we're missing mCompositorWidgetDelegate here, EnableRendering()
+  // will be called later by SetCompositorWidgetDelegate(), which is
+  // fired by GetWindowRenderer()/CreateCompositor().
   if (mCompositorWidgetDelegate) {
     mCompositorWidgetDelegate->EnableRendering(GetX11Window(),
                                                GetShapedState());
   }
 
-  EnableRenderingToWindow();
+  if (mCompositorState == COMPOSITOR_PAUSED_INITIALLY) {
+    auto startCompositing = [self = RefPtr{this}, this]() -> void {
+      LOG("  start compositing");
+      WaylandStartVsync();
+
+      // Call GetWindowRenderer() to make sure we have
+      // mCompositorWidgetDelegate & mCompositorBridgeChild
+      // (a.k.a remoteRenderer).
+      (void)GetWindowRenderer();
+
+      CompositorBridgeChild* remoteRenderer = GetRemoteRenderer();
+      MOZ_ASSERT(mCompositorWidgetDelegate);
+      MOZ_ASSERT(remoteRenderer);
+
+      remoteRenderer->SendResumeAsync();
+      remoteRenderer->SendForcePresent(wr::RenderReasons::WIDGET);
+      mCompositorState = COMPOSITOR_ENABLED;
+    };
+
+    if (GdkIsWaylandDisplay()) {
+#ifdef MOZ_WAYLAND
+      moz_container_wayland_add_initial_draw_callback(mContainer,
+                                                      startCompositing);
+#endif
+    } else {
+      startCompositing();
+    }
+  }
 
   if (mHasMappedToplevel) {
     EnsureGrabs();
@@ -5422,8 +5404,12 @@
 void nsWindow::ReleaseGdkWindow() {
   LOG("nsWindow::ReleaseGdkWindow() [%p]", this);
 
+  WaylandStopVsync();
   DestroyChildWindows();
-  DisableRenderingToWindow();
+
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->DisableRendering();
+  }
 
   if (mGdkWindow) {
     g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
@@ -6100,28 +6086,6 @@
   }
 }
 
-void nsWindow::ResumeCompositorHiddenWindow() {
-  MOZ_RELEASE_ASSERT(NS_IsMainThread());
-
-  LOG("nsWindow::ResumeCompositorHiddenWindow\n");
-  if (mIsDestroyed || mCompositorState == COMPOSITOR_ENABLED) {
-    LOG("  early quit\n");
-    return;
-  }
-
-  if (CompositorBridgeChild* remoteRenderer = GetRemoteRenderer()) {
-    LOG("  resume\n");
-    MOZ_ASSERT(mCompositorWidgetDelegate);
-    if (mCompositorWidgetDelegate) {
-      mCompositorState = COMPOSITOR_ENABLED;
-      remoteRenderer->SendResumeAsync();
-    }
-    remoteRenderer->SendForcePresent(wr::RenderReasons::WIDGET);
-  } else {
-    LOG("  quit, failed to get remote renderer.\n");
-  }
-}
-
 static int WindowResumeCompositor(void* data) {
   nsWindow* window = static_cast<nsWindow*>(data);
   window->ResumeCompositor();