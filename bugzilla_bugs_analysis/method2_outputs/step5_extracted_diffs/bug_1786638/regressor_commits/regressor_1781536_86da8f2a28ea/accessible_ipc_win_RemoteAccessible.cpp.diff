# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/win/RemoteAccessible.cpp
# Commit: 86da8f2a28ea
# Full Hash: 86da8f2a28ea1992671d08dfb56c881a1a82daa5
# Author: James Teh <jteh@mozilla.com>
# Date: 2022-08-04 04:34:13
# Regressor Bug: 1781536
# File Overlap Count: 1
# Description:
#   Bug 1781536 part 3: Move RelationByType to base Accessible. r=morgan
#   
#   This required changing the RemoteAccessible implementations to return Relation instead of an array of RemoteAccessible.
#   Platform implementations have been updated to use the unified method where appropriate.
#   
# ==============================================================================

diff -r 95ae96802dbe -r 86da8f2a28ea accessible/ipc/win/RemoteAccessible.cpp
--- a/accessible/ipc/win/RemoteAccessible.cpp	Wed Aug 03 23:58:51 2022 +0000
+++ b/accessible/ipc/win/RemoteAccessible.cpp	Wed Aug 03 23:58:51 2022 +0000
@@ -16,6 +16,7 @@
 #include "mozilla/dom/BrowserParent.h"
 #include "mozilla/Unused.h"
 #include "mozilla/a11y/Platform.h"
+#include "Relation.h"
 #include "RelationType.h"
 #include "mozilla/a11y/Role.h"
 #include "mozilla/StaticPrefs_accessibility.h"
@@ -108,20 +109,28 @@
   return acc2.forget();
 }
 
-static RemoteAccessible* GetProxyFor(DocAccessibleParent* aDoc,
-                                     IUnknown* aCOMProxy) {
+static Maybe<uint64_t> GetIdFor(DocAccessibleParent* aDoc,
+                                IUnknown* aCOMProxy) {
   RefPtr<IGeckoCustom> custom;
   if (FAILED(aCOMProxy->QueryInterface(IID_IGeckoCustom,
                                        (void**)getter_AddRefs(custom)))) {
-    return nullptr;
+    return Nothing();
   }
 
   uint64_t id;
   if (FAILED(custom->get_ID(&id))) {
-    return nullptr;
+    return Nothing();
   }
 
-  return aDoc->GetAccessible(id);
+  return Some(id);
+}
+
+static RemoteAccessible* GetProxyFor(DocAccessibleParent* aDoc,
+                                     IUnknown* aCOMProxy) {
+  if (auto id = GetIdFor(aDoc, aCOMProxy)) {
+    return aDoc->GetAccessible(*id);
+  }
+  return nullptr;
 }
 
 ENameValueFlag RemoteAccessible::Name(nsString& aName) const {
@@ -390,15 +399,14 @@
   return attrsObj.forget();
 }
 
-nsTArray<RemoteAccessible*> RemoteAccessible::RelationByType(
-    RelationType aType) const {
+Relation RemoteAccessible::RelationByType(RelationType aType) const {
   if (StaticPrefs::accessibility_cache_enabled_AtStartup()) {
     return RemoteAccessibleBase<RemoteAccessible>::RelationByType(aType);
   }
 
   RefPtr<IAccessible2_2> acc = QueryInterface<IAccessible2_2>(this);
   if (!acc) {
-    return nsTArray<RemoteAccessible*>();
+    return Relation();
   }
 
   _bstr_t relationType;
@@ -410,7 +418,7 @@
   }
 
   if (!relationType) {
-    return nsTArray<RemoteAccessible*>();
+    return Relation();
   }
 
   IUnknown** targets;
@@ -418,18 +426,20 @@
   HRESULT hr =
       acc->get_relationTargetsOfType(relationType, 0, &targets, &nTargets);
   if (FAILED(hr)) {
-    return nsTArray<RemoteAccessible*>();
+    return Relation();
   }
 
-  nsTArray<RemoteAccessible*> proxies;
+  nsTArray<uint64_t> ids;
   for (long idx = 0; idx < nTargets; idx++) {
     IUnknown* target = targets[idx];
-    proxies.AppendElement(GetProxyFor(Document(), target));
+    if (auto id = GetIdFor(Document(), target)) {
+      ids.AppendElement(*id);
+    }
     target->Release();
   }
   CoTaskMemFree(targets);
 
-  return proxies;
+  return Relation(new RemoteAccIterator(std::move(ids), Document()));
 }
 
 double RemoteAccessible::CurValue() const {