# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/CookieServiceParent.cpp
# Commit: 33f21aec0e20
# Full Hash: 33f21aec0e20d39623554816399ee76d13d7e08f
# Author: edguloien <eguloien@mozilla.com>
# Date: 2022-08-23 21:47:27
# Regressor Bug: 1713203
# File Overlap Count: 1
# Description:
#   Bug 1713203 - Added check for host, scheme and origin attributes check before cookie change broadcast to content processes r=dveditz,dragana,nika
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D146346
# ==============================================================================

diff -r fe25d4f35ef8 -r 33f21aec0e20 netwerk/cookie/CookieServiceParent.cpp
--- a/netwerk/cookie/CookieServiceParent.cpp	Tue Aug 23 17:30:19 2022 +0000
+++ b/netwerk/cookie/CookieServiceParent.cpp	Tue Aug 23 17:36:24 2022 +0000
@@ -4,6 +4,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "CookieCommons.h"
+#include "CookieLogging.h"
 #include "mozilla/net/CookieService.h"
 #include "mozilla/net/CookieServiceParent.h"
 #include "mozilla/net/NeckoParent.h"
@@ -13,7 +14,9 @@
 #include "mozIThirdPartyUtil.h"
 #include "nsArrayUtils.h"
 #include "nsIChannel.h"
+#include "nsIEffectiveTLDService.h"
 #include "nsNetCID.h"
+#include "nsMixedContentBlocker.h"
 
 using namespace mozilla::ipc;
 
@@ -28,6 +31,10 @@
   // Get the CookieService instance directly, so we can call internal methods.
   mCookieService = CookieService::GetSingleton();
   NS_ASSERTION(mCookieService, "couldn't get nsICookieService");
+
+  mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID);
+  MOZ_ALWAYS_TRUE(mTLDService);
+
   mProcessingCookie = false;
 }
 
@@ -40,10 +47,10 @@
   nsTArray<OriginAttributes> attrsList;
   for (uint32_t i = 0; i < len; i++) {
     nsCOMPtr<nsICookie> xpcCookie = do_QueryElementAt(aCookieList, i);
-    auto* cookie = static_cast<Cookie*>(xpcCookie.get());
-    attrs = cookie->OriginAttributesRef();
-    cookieStruct = cookie->ToIPC();
-    if (cookie->IsHttpOnly()) {
+    const auto& cookie = xpcCookie->AsCookie();
+    attrs = cookie.OriginAttributesRef();
+    cookieStruct = cookie.ToIPC();
+    if (cookie.IsHttpOnly()) {
       // Child only needs to exist if an HttpOnly cookie exists, not its value
       cookieStruct.value() = "";
     }
@@ -55,26 +62,36 @@
 
 void CookieServiceParent::RemoveAll() { Unused << SendRemoveAll(); }
 
-void CookieServiceParent::RemoveCookie(nsICookie* aCookie) {
-  auto* cookie = static_cast<Cookie*>(aCookie);
-  const OriginAttributes& attrs = cookie->OriginAttributesRef();
-  CookieStruct cookieStruct = cookie->ToIPC();
-  if (cookie->IsHttpOnly()) {
+void CookieServiceParent::RemoveCookie(const Cookie& cookie) {
+  const OriginAttributes& attrs = cookie.OriginAttributesRef();
+  CookieStruct cookieStruct = cookie.ToIPC();
+  if (cookie.IsHttpOnly()) {
     cookieStruct.value() = "";
   }
   Unused << SendRemoveCookie(cookieStruct, attrs);
 }
 
-void CookieServiceParent::AddCookie(nsICookie* aCookie) {
-  auto* cookie = static_cast<Cookie*>(aCookie);
-  const OriginAttributes& attrs = cookie->OriginAttributesRef();
-  CookieStruct cookieStruct = cookie->ToIPC();
-  if (cookie->IsHttpOnly()) {
+void CookieServiceParent::AddCookie(const Cookie& cookie) {
+  const OriginAttributes& attrs = cookie.OriginAttributesRef();
+  CookieStruct cookieStruct = cookie.ToIPC();
+  if (cookie.IsHttpOnly()) {
     cookieStruct.value() = "";
   }
   Unused << SendAddCookie(cookieStruct, attrs);
 }
 
+bool CookieServiceParent::CookieMatchesContentList(const Cookie& cookie) {
+  nsCString baseDomain;
+  MOZ_ALWAYS_SUCCEEDS(CookieCommons::GetBaseDomainFromHost(
+      mTLDService, cookie.Host(), baseDomain));
+
+  CookieKey cookieKey(baseDomain, cookie.OriginAttributesRef());
+  if (Maybe<bool> allowSecure = mCookieKeysInContent.MaybeGet(cookieKey)) {
+    return (!cookie.IsSecure() || *allowSecure);
+  }
+  return false;
+}
+
 void CookieServiceParent::TrackCookieLoad(nsIChannel* aChannel) {
   nsCOMPtr<nsIURI> uri;
   aChannel->GetURI(getter_AddRefs(uri));
@@ -89,7 +106,6 @@
   StoragePrincipalHelper::PrepareEffectiveStoragePrincipalOriginAttributes(
       aChannel, attrs);
 
-  // Send matching cookies to Child.
   nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil;
   thirdPartyUtil = do_GetService(THIRDPARTYUTIL_CONTRACTID);
 
@@ -97,6 +113,9 @@
   ThirdPartyAnalysisResult result = thirdPartyUtil->AnalyzeChannel(
       aChannel, false, nullptr, nullptr, &rejectedReason);
 
+  UpdateCookieInContentList(uri, attrs);
+
+  // Send matching cookies to Child.
   nsTArray<Cookie*> foundCookieList;
   mCookieService->GetCookiesForURI(
       uri, aChannel, result.contains(ThirdPartyAnalysis::IsForeign),
@@ -110,6 +129,21 @@
   Unused << SendTrackCookiesLoad(matchingCookiesList, attrs);
 }
 
+// we append outgoing cookie info into a list here so the ContentParent can
+// filter cookies passing to unnecessary ContentProcesses
+void CookieServiceParent::UpdateCookieInContentList(
+    nsIURI* uri, const OriginAttributes& originAttrs) {
+  nsCString baseDomain;
+  bool requireAHostMatch = false;
+  MOZ_ALWAYS_SUCCEEDS(CookieCommons::GetBaseDomain(mTLDService, uri, baseDomain,
+                                                   requireAHostMatch));
+
+  CookieKey cookieKey(baseDomain, originAttrs);
+  bool& allowSecure = mCookieKeysInContent.LookupOrInsert(cookieKey, false);
+  allowSecure =
+      allowSecure || nsMixedContentBlocker::IsPotentiallyTrustworthyOrigin(uri);
+}
+
 // static
 void CookieServiceParent::SerialializeCookieList(
     const nsTArray<Cookie*>& aFoundCookieList,
@@ -138,6 +172,10 @@
     return IPC_FAIL(this, "aHost must not be null");
   }
 
+  // we append outgoing cookie info into a list here so the ContentParent can
+  // filter cookies that do not need to go to certain ContentProcesses
+  UpdateCookieInContentList(aHost, aAttrs);
+
   nsTArray<Cookie*> foundCookieList;
   // Note: passing nullptr as aChannel to GetCookiesForURI() here is fine since
   // this argument is only used for proper reporting of cookie loads, but the