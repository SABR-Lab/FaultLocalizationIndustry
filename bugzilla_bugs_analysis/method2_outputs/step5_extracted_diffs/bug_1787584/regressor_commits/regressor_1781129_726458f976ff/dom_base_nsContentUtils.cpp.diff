# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsContentUtils.cpp
# Commit: 726458f976ff
# Full Hash: 726458f976fff2b05bb0eaf7e940cd7be06d75f5
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2022-08-03 03:42:48
# Regressor Bug: 1781129
# File Overlap Count: 1
# Description:
#   Bug 1781129 - Part 1: Use BigBuffer for IPCDataTransfer, r=edgar
#   
#   The IPCDataTransfer type is used to transfer Clipboard/Drag & Drop payloads
#   over IPC to allow them to be written to or read from the relevant system
#   interfaces. Previously, the system which was used was somewhat complex, and
# ==============================================================================

diff -r 1aa5ec22f47a -r 726458f976ff dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp	Tue Aug 02 17:08:59 2022 +0000
+++ b/dom/base/nsContentUtils.cpp	Tue Aug 02 17:15:41 2022 +0000
@@ -7705,16 +7705,7 @@
 
 nsresult nsContentUtils::IPCTransferableToTransferable(
     const IPCDataTransfer& aDataTransfer, bool aAddDataFlavor,
-    nsITransferable* aTransferable, IShmemAllocator* aAllocator) {
-  auto release = MakeScopeExit([&] {
-    const nsTArray<IPCDataTransferItem>& items = aDataTransfer.items();
-    for (const auto& item : items) {
-      if (item.data().type() == IPCDataTransferData::TShmem) {
-        Unused << aAllocator->DeallocShmem(item.data().get_Shmem());
-      }
-    }
-  });
-
+    nsITransferable* aTransferable) {
   nsresult rv;
   const nsTArray<IPCDataTransferItem>& items = aDataTransfer.items();
   for (const auto& item : items) {
@@ -7722,70 +7713,63 @@
       aTransferable->AddDataFlavor(item.flavor().get());
     }
 
-    if (item.dataType() == TransferableDataType::String) {
-      nsCOMPtr<nsISupportsString> dataWrapper =
-          do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      if (item.data().type() == IPCDataTransferData::TShmem) {
-        Shmem itemData = item.data().get_Shmem();
-        const nsDependentSubstring text(itemData.get<char16_t>(),
-                                        itemData.Size<char16_t>());
-        rv = dataWrapper->SetData(text);
+    nsCOMPtr<nsISupports> transferData;
+    switch (item.data().type()) {
+      case IPCDataTransferData::TIPCDataTransferString: {
+        const auto& data = item.data().get_IPCDataTransferString();
+        nsCOMPtr<nsISupportsString> dataWrapper =
+            do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv);
+        NS_ENSURE_SUCCESS(rv, rv);
+        rv = dataWrapper->SetData(nsDependentSubstring(
+            reinterpret_cast<const char16_t*>(data.data().Data()),
+            data.data().Size() / sizeof(char16_t)));
         NS_ENSURE_SUCCESS(rv, rv);
-      } else {
-        const nsString& text = item.data().get_nsString();
-        rv = dataWrapper->SetData(text);
+        transferData = dataWrapper;
+        break;
+      }
+      case IPCDataTransferData::TIPCDataTransferCString: {
+        const auto& data = item.data().get_IPCDataTransferCString();
+        nsCOMPtr<nsISupportsCString> dataWrapper =
+            do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv);
         NS_ENSURE_SUCCESS(rv, rv);
+        rv = dataWrapper->SetData(nsDependentCSubstring(
+            reinterpret_cast<const char*>(data.data().Data()),
+            data.data().Size()));
+        NS_ENSURE_SUCCESS(rv, rv);
+        transferData = dataWrapper;
+        break;
       }
-
-      rv = aTransferable->SetTransferData(item.flavor().get(), dataWrapper);
-      NS_ENSURE_SUCCESS(rv, rv);
-      continue;
-    }
-
-    if (item.dataType() == TransferableDataType::ImageContainer) {
-      nsCOMPtr<imgIContainer> imageContainer;
-      rv = nsContentUtils::DataTransferItemToImage(
-          item, getter_AddRefs(imageContainer));
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = aTransferable->SetTransferData(item.flavor().get(), imageContainer);
-      NS_ENSURE_SUCCESS(rv, rv);
-      continue;
-    }
-
-    if (item.dataType() == TransferableDataType::InputStream) {
-      Shmem data = item.data().get_Shmem();
-      nsCOMPtr<nsIInputStream> stream;
-      rv = NS_NewCStringInputStream(
-          getter_AddRefs(stream),
-          nsDependentCSubstring(data.get<char>(), data.Size<char>()));
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = aTransferable->SetTransferData(item.flavor().get(), stream);
-      NS_ENSURE_SUCCESS(rv, rv);
-      continue;
-    }
-
-    if (item.dataType() == TransferableDataType::CString) {
-      nsCOMPtr<nsISupportsCString> dataWrapper =
-          do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      // The buffer contains the terminating null.
-      Shmem itemData = item.data().get_Shmem();
-      const nsDependentCSubstring text(itemData.get<char>(),
-                                       itemData.Size<char>());
-      rv = dataWrapper->SetData(text);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = aTransferable->SetTransferData(item.flavor().get(), dataWrapper);
-      NS_ENSURE_SUCCESS(rv, rv);
-      continue;
-    }
-
-    MOZ_ASSERT_UNREACHABLE("Unknown transferable data type");
+      case IPCDataTransferData::TIPCDataTransferInputStream: {
+        const auto& data = item.data().get_IPCDataTransferInputStream();
+        nsCOMPtr<nsIInputStream> stream;
+        rv = NS_NewByteInputStream(getter_AddRefs(stream),
+                                   AsChars(data.data().AsSpan()),
+                                   NS_ASSIGNMENT_COPY);
+        NS_ENSURE_SUCCESS(rv, rv);
+        transferData = stream.forget();
+        break;
+      }
+      case IPCDataTransferData::TIPCDataTransferImageContainer: {
+        const auto& data = item.data().get_IPCDataTransferImageContainer();
+        nsCOMPtr<imgIContainer> container;
+        rv = DeserializeDataTransferImageContainer(data,
+                                                   getter_AddRefs(container));
+        NS_ENSURE_SUCCESS(rv, rv);
+        transferData = container;
+        break;
+      }
+      case IPCDataTransferData::TIPCDataTransferBlob: {
+        const auto& data = item.data().get_IPCDataTransferBlob();
+        transferData = IPCBlobUtils::Deserialize(data.blob());
+        break;
+      }
+      case IPCDataTransferData::T__None:
+        MOZ_ASSERT_UNREACHABLE();
+        return NS_ERROR_FAILURE;
+    }
+
+    rv = aTransferable->SetTransferData(item.flavor().get(), transferData);
+    NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
 }
@@ -7794,11 +7778,11 @@
     const IPCDataTransfer& aDataTransfer, const bool& aIsPrivateData,
     nsIPrincipal* aRequestingPrincipal,
     const nsContentPolicyType& aContentPolicyType, bool aAddDataFlavor,
-    nsITransferable* aTransferable, IShmemAllocator* aAllocator) {
+    nsITransferable* aTransferable) {
   aTransferable->SetIsPrivateData(aIsPrivateData);
 
   nsresult rv = IPCTransferableToTransferable(aDataTransfer, aAddDataFlavor,
-                                              aTransferable, aAllocator);
+                                              aTransferable);
   NS_ENSURE_SUCCESS(rv, rv);
 
   aTransferable->SetRequestingPrincipal(aRequestingPrincipal);
@@ -7812,54 +7796,47 @@
   MOZ_ASSERT(aVariant);
   MOZ_ASSERT(aActor);
 
-  auto release = MakeScopeExit([&] {
-    if (aDataTransferItem.data().type() == IPCDataTransferData::TShmem) {
-      aActor->DeallocShmem(aDataTransferItem.data().get_Shmem());
-    }
-  });
-
-  if (aDataTransferItem.dataType() == TransferableDataType::String) {
-    if (aDataTransferItem.data().type() == IPCDataTransferData::TShmem) {
-      Shmem data = aDataTransferItem.data().get_Shmem();
-      aVariant->SetAsAString(
-          nsDependentSubstring(data.get<char16_t>(), data.Size<char16_t>()));
-      return NS_OK;
-    }
-
-    const nsString& data = aDataTransferItem.data().get_nsString();
-    aVariant->SetAsAString(data);
-    return NS_OK;
-  }
-
-  if (aDataTransferItem.dataType() == TransferableDataType::ImageContainer) {
-    // An image! Get the imgIContainer for it and set it in the
-    // variant.
-    nsCOMPtr<imgIContainer> imageContainer;
-    nsresult rv = nsContentUtils::DataTransferItemToImage(
-        aDataTransferItem, getter_AddRefs(imageContainer));
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    aVariant->SetAsISupports(imageContainer);
-    return NS_OK;
-  }
-
-  if (aDataTransferItem.dataType() == TransferableDataType::CString) {
-    Shmem data = aDataTransferItem.data().get_Shmem();
-    aVariant->SetAsACString(
-        nsDependentCSubstring(data.get<char>(), data.Size<char>()));
-    return NS_OK;
-  }
-
-  if (aDataTransferItem.dataType() == TransferableDataType::Blob) {
-    RefPtr<BlobImpl> blobImpl =
-        IPCBlobUtils::Deserialize(aDataTransferItem.data().get_IPCBlob());
-    aVariant->SetAsISupports(blobImpl);
-    return NS_OK;
-  }
-
-  MOZ_ASSERT_UNREACHABLE("Unknown transferable data type");
-  return NS_ERROR_UNEXPECTED;
+  switch (aDataTransferItem.data().type()) {
+    case IPCDataTransferData::TIPCDataTransferString: {
+      const auto& data = aDataTransferItem.data().get_IPCDataTransferString();
+      return aVariant->SetAsAString(nsDependentSubstring(
+          reinterpret_cast<const char16_t*>(data.data().Data()),
+          data.data().Size() / sizeof(char16_t)));
+    }
+    case IPCDataTransferData::TIPCDataTransferCString: {
+      const auto& data = aDataTransferItem.data().get_IPCDataTransferCString();
+      return aVariant->SetAsACString(nsDependentCSubstring(
+          reinterpret_cast<const char*>(data.data().Data()),
+          data.data().Size()));
+    }
+    case IPCDataTransferData::TIPCDataTransferInputStream: {
+      const auto& data =
+          aDataTransferItem.data().get_IPCDataTransferInputStream();
+      nsCOMPtr<nsIInputStream> stream;
+      nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream),
+                                          AsChars(data.data().AsSpan()),
+                                          NS_ASSIGNMENT_COPY);
+      NS_ENSURE_SUCCESS(rv, rv);
+      return aVariant->SetAsISupports(stream);
+    }
+    case IPCDataTransferData::TIPCDataTransferImageContainer: {
+      const auto& data =
+          aDataTransferItem.data().get_IPCDataTransferImageContainer();
+      nsCOMPtr<imgIContainer> container;
+      nsresult rv = DeserializeDataTransferImageContainer(
+          data, getter_AddRefs(container));
+      NS_ENSURE_SUCCESS(rv, rv);
+      return aVariant->SetAsISupports(container);
+    }
+    case IPCDataTransferData::TIPCDataTransferBlob: {
+      const auto& data = aDataTransferItem.data().get_IPCDataTransferBlob();
+      RefPtr<BlobImpl> blobImpl = IPCBlobUtils::Deserialize(data.blob());
+      return aVariant->SetAsISupports(blobImpl);
+    }
+    case IPCDataTransferData::T__None:
+      MOZ_ASSERT_UNREACHABLE();
+      return NS_ERROR_UNEXPECTED;
+  }
 }
 
 void nsContentUtils::TransferablesToIPCTransferables(
@@ -7973,22 +7950,24 @@
                                          aData.get<uint8_t>(), aStride);
 }
 
-nsresult nsContentUtils::DataTransferItemToImage(
-    const IPCDataTransferItem& aItem, imgIContainer** aContainer) {
-  MOZ_ASSERT(aItem.data().type() == IPCDataTransferData::TShmem);
-  MOZ_ASSERT(aItem.dataType() == TransferableDataType::ImageContainer);
-  MOZ_ASSERT(aItem.imageDetails().isSome());
-
-  const IPCDataTransferImage& imageDetails = aItem.imageDetails().value();
-  const IntSize size(imageDetails.width(), imageDetails.height());
-  RefPtr<DataSourceSurface> image =
-      ShmemToDataSurface(aItem.data().get_Shmem(), imageDetails.stride(), size,
-                         imageDetails.format());
-  if (!image) {
+nsresult nsContentUtils::DeserializeDataTransferImageContainer(
+    const IPCDataTransferImageContainer& aData, imgIContainer** aContainer) {
+  const IntSize size(aData.width(), aData.height());
+  size_t maxBufferSize = 0;
+  size_t usedBufferSize = 0;
+  nsresult rv = CalculateBufferSizeForImage(
+      aData.stride(), size, aData.format(), &maxBufferSize, &usedBufferSize);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (usedBufferSize > aData.data().Size()) {
     return NS_ERROR_FAILURE;
   }
-
-  RefPtr<gfxDrawable> drawable = new gfxSurfaceDrawable(image, size);
+  RefPtr<DataSourceSurface> surface =
+      CreateDataSourceSurfaceFromData(size, aData.format(), aData.data().Data(),
+                                      static_cast<int32_t>(aData.stride()));
+  if (!surface) {
+    return NS_ERROR_FAILURE;
+  }
+  RefPtr<gfxDrawable> drawable = new gfxSurfaceDrawable(surface, size);
   nsCOMPtr<imgIContainer> imageContainer =
       image::ImageOps::CreateFromDrawable(drawable);
   imageContainer.forget(aContainer);
@@ -8004,43 +7983,14 @@
          aFlavor.EqualsLiteral(kGIFImageMime);
 }
 
-static bool AllocateShmem(mozilla::dom::ContentChild* aChild,
-                          mozilla::dom::ContentParent* aParent, size_t aSize,
-                          mozilla::ipc::Shmem* aShmem) {
-  MOZ_ASSERT((aChild && !aParent) || (!aChild && aParent));
-  MOZ_ASSERT(aShmem);
-
-  IShmemAllocator* allocator = aChild ? static_cast<IShmemAllocator*>(aChild)
-                                      : static_cast<IShmemAllocator*>(aParent);
-
-  return allocator->AllocShmem(aSize, aShmem);
-}
-
-static Shmem ConvertToShmem(mozilla::dom::ContentChild* aChild,
-                            mozilla::dom::ContentParent* aParent,
-                            const nsACString& aInput) {
-  Shmem result;
-  if (!AllocateShmem(aChild, aParent, aInput.Length(), &result)) {
-    return result;
-  }
-
-  memcpy(result.get<char>(), aInput.BeginReading(), aInput.Length());
-
-  return result;
-}
-
-static Shmem ConvertToShmem(mozilla::dom::ContentChild* aChild,
-                            mozilla::dom::ContentParent* aParent,
-                            const nsAString& aInput) {
-  Shmem result;
-  uint32_t size = aInput.Length() * sizeof(char16_t);
-  if (!AllocateShmem(aChild, aParent, size, &result)) {
-    return result;
-  }
-
-  memcpy(result.get<char>(), aInput.BeginReading(), size);
-
-  return result;
+static IPCDataTransferString AsIPCDataTransferString(
+    Span<const char16_t> aInput) {
+  return IPCDataTransferString{BigBuffer(AsBytes(aInput))};
+}
+
+static IPCDataTransferCString AsIPCDataTransferCString(
+    Span<const char> aInput) {
+  return IPCDataTransferCString{BigBuffer(AsBytes(aInput))};
 }
 
 void nsContentUtils::TransferableToIPCTransferable(
@@ -8066,6 +8016,7 @@
       if (NS_FAILED(rv) || !data) {
         if (aInSyncMessage) {
           // Can't do anything.
+          // FIXME: This shouldn't be the case anymore!
           continue;
         }
 
@@ -8076,83 +8027,50 @@
         if (flavorStr.EqualsLiteral(kFilePromiseMime)) {
           IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
           item->flavor() = flavorStr;
-          item->data() = NS_ConvertUTF8toUTF16(flavorStr);
-          item->dataType() = TransferableDataType::String;
+          item->data() =
+              AsIPCDataTransferString(NS_ConvertUTF8toUTF16(flavorStr));
           continue;
         }
 
         // Empty element, transfer only the flavor
         IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
         item->flavor() = flavorStr;
-        item->data() = nsString();
-        item->dataType() = TransferableDataType::String;
-        continue;
-      }
-
-      if (nsCOMPtr<nsISupportsString> text = do_QueryInterface(data)) {
-        nsAutoString dataAsString;
-        text->GetData(dataAsString);
-
-        Maybe<Shmem> dataAsShmem;
-        uint32_t size = dataAsString.Length() * sizeof(char16_t);
-        // XXX IPCDataTransfer could contain multiple items, we give each item
-        // same bucket size. The IPC message includes more than data payload, so
-        // subtract 10 KB to make the total size within the bucket size. It
-        // would be nice if we could have a smarter way to decide when to use
-        // Shmem.
-        uint32_t threshold =
-            (IPC::Channel::kMaximumMessageSize / flavorList.Length()) -
-            (10 * 1024);
-        if (size > threshold) {
-          dataAsShmem.emplace(ConvertToShmem(aChild, aParent, dataAsString));
-          if (!dataAsShmem->IsReadable() || !dataAsShmem->Size<char16_t>()) {
-            continue;
-          }
-        }
-
-        IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
-        item->flavor() = flavorStr;
-        if (dataAsShmem) {
-          item->data() = dataAsShmem.value();
-        } else {
-          item->data() = dataAsString;
-        }
-        item->dataType() = TransferableDataType::String;
+        item->data() = AsIPCDataTransferString(EmptyString());
         continue;
       }
 
       // We need to handle nsIInputStream before nsISupportsCString, otherwise
       // nsStringInputStream would be coverted into a wrong type.
       if (nsCOMPtr<nsIInputStream> stream = do_QueryInterface(data)) {
-        // Images to be pasted on the clipboard are nsIInputStreams
+        IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
+        item->flavor() = flavorStr;
         nsCString imageData;
-        NS_ConsumeStream(stream, UINT32_MAX, imageData);
-
-        Shmem imageDataShmem = ConvertToShmem(aChild, aParent, imageData);
-        if (!imageDataShmem.IsReadable() || !imageDataShmem.Size<char>()) {
-          continue;
-        }
+        nsresult rv = NS_ConsumeStream(stream, UINT32_MAX, imageData);
+        MOZ_ASSERT(
+            rv != NS_BASE_STREAM_WOULD_BLOCK,
+            "cannot use async input streams in nsITransferable right now");
+        item->data() =
+            IPCDataTransferInputStream(BigBuffer(AsBytes(Span(imageData))));
+        continue;
+      }
+
+      if (nsCOMPtr<nsISupportsString> text = do_QueryInterface(data)) {
+        nsAutoString dataAsString;
+        MOZ_ALWAYS_SUCCEEDS(text->GetData(dataAsString));
 
         IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
         item->flavor() = flavorStr;
-        item->data() = std::move(imageDataShmem);
-        item->dataType() = TransferableDataType::InputStream;
+        item->data() = AsIPCDataTransferString(dataAsString);
         continue;
       }
 
       if (nsCOMPtr<nsISupportsCString> ctext = do_QueryInterface(data)) {
         nsAutoCString dataAsString;
-        ctext->GetData(dataAsString);
-
-        Shmem dataAsShmem = ConvertToShmem(aChild, aParent, dataAsString);
-        if (!dataAsShmem.IsReadable() || !dataAsShmem.Size<char>()) {
-          continue;
-        }
+        MOZ_ALWAYS_SUCCEEDS(ctext->GetData(dataAsString));
 
         IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
         item->flavor() = flavorStr;
-        item->data() = std::move(dataAsShmem);
-        item->dataType() = TransferableDataType::CString;
+        item->data() = AsIPCDataTransferCString(dataAsString);
         continue;
       }
 
@@ -8171,11 +8089,8 @@
         }
         size_t length;
         int32_t stride;
-        IShmemAllocator* allocator =
-            aChild ? static_cast<IShmemAllocator*>(aChild)
-                   : static_cast<IShmemAllocator*>(aParent);
-        Maybe<Shmem> surfaceData =
-            GetSurfaceData(*dataSurface, &length, &stride, allocator);
+        Maybe<BigBuffer> surfaceData =
+            GetSurfaceData(*dataSurface, &length, &stride);
 
         if (surfaceData.isNothing()) {
           continue;
@@ -8183,44 +8098,17 @@
 
         IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
         item->flavor() = flavorStr;
-        // Turn item->data() into an nsCString prior to accessing it.
-        item->data() = std::move(surfaceData.ref());
-        item->dataType() = TransferableDataType::ImageContainer;
 
         mozilla::gfx::IntSize size = dataSurface->GetSize();
-        item->imageDetails().emplace(size.width, size.height, stride,
-                                     dataSurface->GetFormat());
+        item->data() = IPCDataTransferImageContainer(
+            std::move(*surfaceData), size.width, size.height, stride,
+            dataSurface->GetFormat());
         continue;
       }
 
       // Otherwise, handle this as a file.
       nsCOMPtr<BlobImpl> blobImpl;
       if (nsCOMPtr<nsIFile> file = do_QueryInterface(data)) {
-        // If we can send this over as a blob, do so. Otherwise, we're
-        // responding to a sync message and the child can't process the blob
-        // constructor before processing our response, which would crash. In
-        // that case, hope that the caller is nsClipboardProxy::GetData,
-        // called from editor and send over images as raw data.
-        if (aInSyncMessage) {
-          nsAutoCString type;
-          if (IsFileImage(file, type)) {
-            nsAutoCString data;
-            SlurpFileToString(file, data);
-
-            Shmem dataAsShmem = ConvertToShmem(aChild, aParent, data);
-            if (!dataAsShmem.IsReadable() || !dataAsShmem.Size<char>()) {
-              continue;
-            }
-
-            IPCDataTransferItem* item =
-                aIPCDataTransfer->items().AppendElement();
-            item->flavor() = type;
-            item->data() = std::move(dataAsShmem);
-            item->dataType() = TransferableDataType::InputStream;
-          }
-          continue;
-        }
-
         if (aParent) {
           bool isDir = false;
           if (NS_SUCCEEDED(file->IsDirectory(&isDir)) && isDir) {
@@ -8250,11 +8138,6 @@
           continue;
         }
       } else {
-        if (aInSyncMessage) {
-          // Can't do anything.
-          continue;
-        }
-
         blobImpl = do_QueryInterface(data);
       }
 
@@ -8270,8 +8153,7 @@
 
         IPCDataTransferItem* item = aIPCDataTransfer->items().AppendElement();
         item->flavor() = flavorStr;
-        item->data() = ipcBlob;
-        item->dataType() = TransferableDataType::Blob;
+        item->data() = IPCDataTransferBlob(ipcBlob);
       }
     }
   }
@@ -8279,15 +8161,16 @@
 
 namespace {
 // The default type used for calling GetSurfaceData(). Gets surface data as
-// raw buffer.
-struct GetSurfaceDataRawBuffer {
-  using ReturnType = mozilla::UniquePtr<char[]>;
+// raw bigbuffer.
+struct GetSurfaceDataBigBuffer {
+  using ReturnType = Maybe<BigBuffer>;
   using BufferType = char*;
 
-  ReturnType Allocate(size_t aSize) { return ReturnType(new char[aSize]); }
-
-  static BufferType GetBuffer(const ReturnType& aReturnValue) {
-    return aReturnValue.get();
+  ReturnType Allocate(size_t aSize) { return Some(BigBuffer(aSize)); }
+
+  static BufferType GetBuffer(ReturnType& aReturnValue) {
+    return aReturnValue ? reinterpret_cast<char*>(aReturnValue->Data())
+                        : nullptr;
   }
 
   static ReturnType NullValue() { return ReturnType(); }
@@ -8325,7 +8208,7 @@
  * Get the pixel data from the given source surface and return it as a buffer.
  * The length and stride will be assigned from the surface.
  */
-template <typename GetSurfaceDataContext = GetSurfaceDataRawBuffer>
+template <typename GetSurfaceDataContext = GetSurfaceDataBigBuffer>
 typename GetSurfaceDataContext::ReturnType GetSurfaceDataImpl(
     DataSourceSurface& aSurface, size_t* aLength, int32_t* aStride,
     GetSurfaceDataContext aContext = GetSurfaceDataContext()) {
@@ -8362,9 +8245,9 @@
 }
 }  // Anonymous namespace.
 
-UniquePtr<char[]> nsContentUtils::GetSurfaceData(DataSourceSurface& aSurface,
-                                                 size_t* aLength,
-                                                 int32_t* aStride) {
+Maybe<BigBuffer> nsContentUtils::GetSurfaceData(DataSourceSurface& aSurface,
+                                                size_t* aLength,
+                                                int32_t* aStride) {
   return GetSurfaceDataImpl(aSurface, aLength, aStride);
 }
 