# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/manager/ssl/nsNSSCertificate.cpp
# Commit: 79d687137fdf
# Full Hash: 79d687137fdf26d60122e947ad7198521e34bbf9
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-09-03 09:32:11
# Regressor Bug: 1787942
# File Overlap Count: 3
# Description:
#   Bug 1788856 - initialize NSS as needed in nsNSSCertificate r=jschanck
#   
#   Previously, instantiating an nsIX509Cert (implemented by nsNSSCertificate)
#   would cause NSS to be initialized. However, if 'new nsNSSCertificate()' was
#   called directly (rather than going through XPCOM), NSS would not be
# ==============================================================================

diff -r b14b975aa6d7 -r 79d687137fdf security/manager/ssl/nsNSSCertificate.cpp
--- a/security/manager/ssl/nsNSSCertificate.cpp	Fri Sep 02 22:15:58 2022 +0000
+++ b/security/manager/ssl/nsNSSCertificate.cpp	Fri Sep 02 22:26:37 2022 +0000
@@ -78,6 +78,11 @@
   if (maybeCert.isSome()) {
     return UniqueCERTCertificate(CERT_DupCertificate((*maybeCert).get()));
   }
+
+  if (!EnsureNSSInitializedChromeOrContent()) {
+    return nullptr;
+  }
+
   SECItem derItem = {siBuffer, mDER.Elements(),
                      static_cast<unsigned int>(mDER.Length())};
   UniqueCERTCertificate cert(CERT_NewTempCertificate(
@@ -450,6 +455,11 @@
 nsresult nsNSSCertificate::GetCertificateHash(nsAString& aFingerprint,
                                               SECOidTag aHashAlg) {
   aFingerprint.Truncate();
+
+  if (!EnsureNSSInitializedChromeOrContent()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
   nsTArray<uint8_t> digestArray;
   nsresult rv =
       Digest::DigestBuf(aHashAlg, mDER.Elements(), mDER.Length(), digestArray);
@@ -505,6 +515,10 @@
     nsACString& aSha256SPKIDigest) {
   aSha256SPKIDigest.Truncate();
 
+  if (!EnsureNSSInitializedChromeOrContent()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
   pkix::Input certInput;
   pkix::Result result = certInput.Init(mDER.Elements(), mDER.Length());
   if (result != pkix::Result::Success) {