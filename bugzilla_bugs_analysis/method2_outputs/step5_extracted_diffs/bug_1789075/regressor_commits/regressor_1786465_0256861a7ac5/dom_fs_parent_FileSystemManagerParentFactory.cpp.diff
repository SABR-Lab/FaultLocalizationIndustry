# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/fs/parent/FileSystemManagerParentFactory.cpp
# Commit: 0256861a7ac5
# Full Hash: 0256861a7ac5da2076df7735d1522fca9725b346
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2022-08-31 21:54:47
# Regressor Bug: 1786465
# File Overlap Count: 3
# Description:
#   Bug 1786465 - Implement registration counting of FileSystemDataManager; r=dom-storage-reviewers,jesup
#   
#   FileSystemDataManager can be now closed when it's still alive (not in the
#   destructor).
#   
# ==============================================================================

diff -r 04e60585a3f0 -r 0256861a7ac5 dom/fs/parent/FileSystemManagerParentFactory.cpp
--- a/dom/fs/parent/FileSystemManagerParentFactory.cpp	Wed Aug 31 09:34:57 2022 +0000
+++ b/dom/fs/parent/FileSystemManagerParentFactory.cpp	Wed Aug 31 09:34:57 2022 +0000
@@ -37,6 +37,9 @@
     const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
     mozilla::ipc::Endpoint<PFileSystemManagerParent>&& aParentEndpoint,
     std::function<void(const nsresult&)>&& aResolver) {
+  using CreateActorPromise =
+      MozPromise<RefPtr<FileSystemManagerParent>, nsresult, true>;
+
   QM_TRY(OkIf(StaticPrefs::dom_fs_enabled()), IPC_OK(),
          [aResolver](const auto&) { aResolver(NS_ERROR_DOM_NOT_ALLOWED_ERR); });
 
@@ -49,28 +52,38 @@
   // This creates the file system data manager, which has to be done on
   // PBackground
   QM_TRY_UNWRAP(
-      RefPtr<fs::data::FileSystemDataManager> dataManager,
+      fs::Registered<fs::data::FileSystemDataManager> dataManager,
       fs::data::FileSystemDataManager::GetOrCreateFileSystemDataManager(origin),
       IPC_OK(), [aResolver](const auto& aRv) { aResolver(aRv); });
 
   fs::EntryId rootId = fs::data::GetRootHandle(origin);
 
-  InvokeAsync(dataManager->MutableIOTargetPtr(), __func__,
-              [dataManager = dataManager, rootId,
-               parentEndpoint = std::move(aParentEndpoint)]() mutable {
-                RefPtr<FileSystemManagerParent> parent =
-                    new FileSystemManagerParent(std::move(dataManager), rootId);
-                if (!parentEndpoint.Bind(parent)) {
-                  return BoolPromise::CreateAndReject(NS_ERROR_FAILURE,
-                                                      __func__);
-                }
-                return BoolPromise::CreateAndResolve(true, __func__);
-              })
+  InvokeAsync(
+      dataManager->MutableIOTargetPtr(), __func__,
+      [dataManager = RefPtr<fs::data::FileSystemDataManager>(dataManager),
+       rootId, parentEndpoint = std::move(aParentEndpoint)]() mutable {
+        RefPtr<FileSystemManagerParent> parent =
+            new FileSystemManagerParent(std::move(dataManager), rootId);
+
+        if (!parentEndpoint.Bind(parent)) {
+          return CreateActorPromise::CreateAndReject(NS_ERROR_FAILURE,
+                                                     __func__);
+        }
+
+        return CreateActorPromise::CreateAndResolve(std::move(parent),
+                                                    __func__);
+      })
       ->Then(GetCurrentSerialEventTarget(), __func__,
-             [aResolver](const BoolPromise::ResolveOrRejectValue& aValue) {
+             [dataManager = dataManager,
+              aResolver](CreateActorPromise::ResolveOrRejectValue&& aValue) {
                if (aValue.IsReject()) {
                  aResolver(aValue.RejectValue());
                } else {
+                 RefPtr<FileSystemManagerParent> parent =
+                     std::move(aValue.ResolveValue());
+
+                 dataManager->RegisterActor(WrapNotNull(parent));
+
                  aResolver(NS_OK);
                }
              });