# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/fs/parent/datamodel/FileSystemDataManager.cpp
# Commit: 0cc0844f049a
# Full Hash: 0cc0844f049af2d440767f5217f58d04479d03ff
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2022-08-31 21:54:47
# Regressor Bug: 1786465
# File Overlap Count: 2
# Description:
#   Bug 1786465 - Handle pending open/close operations in GetOrCreateFileSystemDataManager; r=dom-storage-reviewers,jesup
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D155790
# ==============================================================================

diff -r fbc09d7df86e -r 0cc0844f049a dom/fs/parent/datamodel/FileSystemDataManager.cpp
--- a/dom/fs/parent/datamodel/FileSystemDataManager.cpp	Wed Aug 31 09:34:59 2022 +0000
+++ b/dom/fs/parent/datamodel/FileSystemDataManager.cpp	Wed Aug 31 09:34:59 2022 +0000
@@ -99,9 +99,32 @@
 FileSystemDataManager::GetOrCreateFileSystemDataManager(const Origin& aOrigin) {
   if (RefPtr<FileSystemDataManager> dataManager =
           GetFileSystemDataManager(aOrigin)) {
-    // XXX Handle the case when the manager is asynchronouslly opening!
+    if (dataManager->IsOpening()) {
+      // We have to wait for the open to be finished before resolving the
+      // promise. The manager can't close itself in the meantime because we
+      // add a new registration in the lambda capture list.
+      return dataManager->OnOpen()->Then(
+          GetCurrentSerialEventTarget(), __func__,
+          [dataManager = Registered<FileSystemDataManager>(dataManager)](
+              const BoolPromise::ResolveOrRejectValue&) {
+            return CreatePromise::CreateAndResolve(dataManager, __func__);
+          });
+    }
 
-    // XXX Handle the case when the manager is asynchronouslly closing!
+    if (dataManager->IsClosing()) {
+      // First, we need to wait for the close to be finished. After that the
+      // manager is closed and it can't be opened again. The only option is
+      // to create a new manager and open it. However, all this stuff is
+      // asynchronous, so it can happen that something else called
+      // `GetOrCreateFileSystemManager` in the meantime. For that reason, we
+      // shouldn't try to create a new manager and open it here, a "recursive"
+      // call to `GetOrCreateFileSystemManager` will handle any new situation.
+      return dataManager->OnClose()->Then(
+          GetCurrentSerialEventTarget(), __func__,
+          [aOrigin](const BoolPromise::ResolveOrRejectValue&) {
+            return GetOrCreateFileSystemDataManager(aOrigin);
+          });
+    }
 
     return CreatePromise::CreateAndResolve(
         Registered<FileSystemDataManager>(std::move(dataManager)), __func__);