# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/fs/parent/datamodel/FileSystemDataManager.cpp
# Commit: fbc09d7df86e
# Full Hash: fbc09d7df86ec0a0e3a34a4598380aa547602448
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2022-08-31 21:54:47
# Regressor Bug: 1786465
# File Overlap Count: 2
# Description:
#   Bug 1786465 - Add support for asynchronous opening of FileSystemDataManager; r=dom-storage-reviewers,jesup
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D155789
# ==============================================================================

diff -r 3b39bc9214e6 -r fbc09d7df86e dom/fs/parent/datamodel/FileSystemDataManager.cpp
--- a/dom/fs/parent/datamodel/FileSystemDataManager.cpp	Wed Aug 31 09:34:58 2022 +0000
+++ b/dom/fs/parent/datamodel/FileSystemDataManager.cpp	Wed Aug 31 09:34:59 2022 +0000
@@ -13,6 +13,7 @@
 #include "nsBaseHashtable.h"
 #include "nsHashKeys.h"
 #include "nsNetCID.h"
+#include "nsProxyRelease.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 
@@ -98,6 +99,8 @@
 FileSystemDataManager::GetOrCreateFileSystemDataManager(const Origin& aOrigin) {
   if (RefPtr<FileSystemDataManager> dataManager =
           GetFileSystemDataManager(aOrigin)) {
+    // XXX Handle the case when the manager is asynchronouslly opening!
+
     // XXX Handle the case when the manager is asynchronouslly closing!
 
     return CreatePromise::CreateAndResolve(
@@ -120,8 +123,12 @@
 
   AddFileSystemDataManager(aOrigin, dataManager);
 
-  return CreatePromise::CreateAndResolve(
-      Registered<FileSystemDataManager>(std::move(dataManager)), __func__);
+  return dataManager->BeginOpen()->Then(
+      GetCurrentSerialEventTarget(), __func__,
+      [dataManager = Registered<FileSystemDataManager>(dataManager)](
+          const BoolPromise::ResolveOrRejectValue&) {
+        return CreatePromise::CreateAndResolve(dataManager, __func__);
+      });
 }
 
 void FileSystemDataManager::Register() { mRegCount++; }
@@ -154,6 +161,12 @@
   }
 }
 
+RefPtr<BoolPromise> FileSystemDataManager::OnOpen() {
+  MOZ_ASSERT(mState == State::Opening);
+
+  return mOpenPromiseHolder.Ensure(__func__);
+}
+
 RefPtr<BoolPromise> FileSystemDataManager::OnClose() {
   MOZ_ASSERT(mState == State::Closing);
 
@@ -164,8 +177,42 @@
   return !mRegCount && !mActors.Count();
 }
 
+RefPtr<BoolPromise> FileSystemDataManager::BeginOpen() {
+  MOZ_ASSERT(mState == State::Initial);
+
+  mState = State::Opening;
+
+  InvokeAsync(MutableIOTargetPtr(), __func__,
+              [self = RefPtr<FileSystemDataManager>(this)]() mutable {
+                nsCOMPtr<nsISerialEventTarget> target =
+                    self->MutableBackgroundTargetPtr();
+
+                NS_ProxyRelease("ReleaseFileSystemDataManager", target,
+                                self.forget());
+
+                return BoolPromise::CreateAndResolve(true, __func__);
+              })
+      ->Then(GetCurrentSerialEventTarget(), __func__,
+             [self = RefPtr<FileSystemDataManager>(this)](
+                 const BoolPromise::ResolveOrRejectValue& value) {
+               if (value.IsReject()) {
+                 self->mState = State::Initial;
+
+                 self->mOpenPromiseHolder.RejectIfExists(value.RejectValue(),
+                                                         __func__);
+
+               } else {
+                 self->mState = State::Open;
+
+                 self->mOpenPromiseHolder.ResolveIfExists(true, __func__);
+               }
+             });
+
+  return OnOpen();
+}
+
 RefPtr<BoolPromise> FileSystemDataManager::BeginClose() {
-  MOZ_ASSERT(mState == State::Initial);
+  MOZ_ASSERT(mState == State::Open);
   MOZ_ASSERT(IsInactive());
 
   mState = State::Closing;