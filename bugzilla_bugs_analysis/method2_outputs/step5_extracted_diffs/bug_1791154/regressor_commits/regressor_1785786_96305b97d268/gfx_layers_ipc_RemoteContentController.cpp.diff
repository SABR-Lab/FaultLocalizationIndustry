# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/RemoteContentController.cpp
# Commit: 96305b97d268
# Full Hash: 96305b97d268e8d70b9c4f0c357e7454412161c6
# Author: Jamie Nicol <jnicol@mozilla.com>
# Date: 2022-08-23 02:46:57
# Regressor Bug: 1785786
# File Overlap Count: 1
# Description:
#   Bug 1785786 - Forward UpdateOverscrollVelocity/Offset from GPU process to parent process. r=botond
#   
#   Since enabling the GPU process on Android, UpdateOverscrollOffset and
#   UpdateOverscrollVelocity messages no longer make their way to the
#   GeckoSession. This is because RemoteContentController currently only
# ==============================================================================

diff -r d61d6e56cb46 -r 96305b97d268 gfx/layers/ipc/RemoteContentController.cpp
--- a/gfx/layers/ipc/RemoteContentController.cpp	Mon Aug 22 18:34:44 2022 +0000
+++ b/gfx/layers/ipc/RemoteContentController.cpp	Mon Aug 22 18:47:28 2022 +0000
@@ -252,6 +252,23 @@
     if (rootController) {
       rootController->UpdateOverscrollVelocity(aGuid, aX, aY, aIsRootContent);
     }
+  } else if (XRE_IsGPUProcess()) {
+    if (!mCompositorThread->IsOnCurrentThread()) {
+      mCompositorThread->Dispatch(
+          NewRunnableMethod<ScrollableLayerGuid, float, float, bool>(
+              "layers::RemoteContentController::UpdateOverscrollVelocity", this,
+              &RemoteContentController::UpdateOverscrollVelocity, aGuid, aX, aY,
+              aIsRootContent));
+      return;
+    }
+
+    MOZ_RELEASE_ASSERT(mCompositorThread->IsOnCurrentThread());
+    GeckoContentController* rootController =
+        CompositorBridgeParent::GetGeckoContentControllerForRoot(
+            aGuid.mLayersId);
+    MOZ_RELEASE_ASSERT(rootController->IsRemote());
+    Unused << static_cast<RemoteContentController*>(rootController)
+                  ->SendUpdateOverscrollVelocity(aGuid, aX, aY, aIsRootContent);
   }
 }
 
@@ -277,6 +294,23 @@
     if (rootController) {
       rootController->UpdateOverscrollOffset(aGuid, aX, aY, aIsRootContent);
     }
+  } else if (XRE_IsGPUProcess()) {
+    if (!mCompositorThread->IsOnCurrentThread()) {
+      mCompositorThread->Dispatch(
+          NewRunnableMethod<ScrollableLayerGuid, float, float, bool>(
+              "layers::RemoteContentController::UpdateOverscrollOffset", this,
+              &RemoteContentController::UpdateOverscrollOffset, aGuid, aX, aY,
+              aIsRootContent));
+      return;
+    }
+
+    MOZ_RELEASE_ASSERT(mCompositorThread->IsOnCurrentThread());
+    GeckoContentController* rootController =
+        CompositorBridgeParent::GetGeckoContentControllerForRoot(
+            aGuid.mLayersId);
+    MOZ_RELEASE_ASSERT(rootController->IsRemote());
+    Unused << static_cast<RemoteContentController*>(rootController)
+                  ->SendUpdateOverscrollOffset(aGuid, aX, aY, aIsRootContent);
   }
 }
 
