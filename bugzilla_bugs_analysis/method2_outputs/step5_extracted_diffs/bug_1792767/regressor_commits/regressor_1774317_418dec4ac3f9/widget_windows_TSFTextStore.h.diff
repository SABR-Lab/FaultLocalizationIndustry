# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/TSFTextStore.h
# Commit: 418dec4ac3f9
# Full Hash: 418dec4ac3f99323de6d6957282e8d26bd44ea19
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-09-28 21:33:31
# Regressor Bug: 1774317
# File Overlap Count: 2
# Description:
#   Bug 1774317 - part 2: Make `TSFTextStore` support `GUID_PROP_URL` r=m_kato
#   
#   `GUID_PROP_URL` is defined here:
#   https://learn.microsoft.com/en-us/windows/win32/tsf/predefined-properties
#   
# ==============================================================================

diff -r 329666086b40 -r 418dec4ac3f9 widget/windows/TSFTextStore.h
--- a/widget/windows/TSFTextStore.h	Wed Sep 28 11:46:59 2022 +0000
+++ b/widget/windows/TSFTextStore.h	Wed Sep 28 11:46:59 2022 +0000
@@ -382,8 +382,7 @@
   HRESULT HandleRequestAttrs(DWORD aFlags, ULONG aFilterCount,
                              const TS_ATTRID* aFilterAttrs);
   void SetInputScope(const nsString& aHTMLInputType,
-                     const nsString& aHTMLInputInputmode,
-                     bool aInPrivateBrowsing);
+                     const nsString& aHTMLInputInputMode);
 
   // Creates native caret over our caret.  This method only works on desktop
   // application.  Otherwise, this does nothing.
@@ -1018,6 +1017,9 @@
   // The input scopes for this context, defaults to IS_DEFAULT.
   nsTArray<InputScope> mInputScopes;
 
+  // The URL cache of the focused document.
+  nsString mDocumentURL;
+
   // Support retrieving attributes.
   // TODO: We should support RightToLeft, perhaps.
   enum {
@@ -1026,56 +1028,59 @@
 
     // Supported attributes
     eInputScope = 0,
+    eDocumentURL,
     eTextVerticalWriting,
     eTextOrientation,
 
     // Count of the supported attributes
     NUM_OF_SUPPORTED_ATTRS
   };
-  bool mRequestedAttrs[NUM_OF_SUPPORTED_ATTRS];
+  bool mRequestedAttrs[NUM_OF_SUPPORTED_ATTRS]{false};
 
   int32_t GetRequestedAttrIndex(const TS_ATTRID& aAttrID);
   TS_ATTRID GetAttrID(int32_t aIndex);
 
-  bool mRequestedAttrValues;
+  bool mRequestedAttrValues = false;
 
   // If edit actions are being recorded without document lock, this is true.
   // Otherwise, false.
-  bool mIsRecordingActionsWithoutLock;
+  bool mIsRecordingActionsWithoutLock = false;
   // If GetTextExt() or GetACPFromPoint() is called and the layout hasn't been
   // calculated yet, these methods return TS_E_NOLAYOUT.  At that time,
   // mHasReturnedNoLayoutError is set to true.
-  bool mHasReturnedNoLayoutError;
+  bool mHasReturnedNoLayoutError = false;
   // Before calling ITextStoreACPSink::OnLayoutChange() and
   // ITfContextOwnerServices::OnLayoutChange(), mWaitingQueryLayout is set to
   // true.  This is set to  false when GetTextExt() or GetACPFromPoint() is
   // called.
-  bool mWaitingQueryLayout;
-  // During the documet is locked, we shouldn't destroy the instance.
+  bool mWaitingQueryLayout = false;
+  // During the document is locked, we shouldn't destroy the instance.
   // If this is true, the instance will be destroyed after unlocked.
   bool mPendingDestroy;
   // If this is false, MaybeFlushPendingNotifications() will clear the
   // mContentForTSF.
-  bool mDeferClearingContentForTSF;
+  bool mDeferClearingContentForTSF = false;
   // While the instance is dispatching events, the event may not be handled
   // synchronously in e10s mode.  So, in such case, in strictly speaking,
   // we shouldn't query layout information.  However, TS_E_NOLAYOUT bugs of
   // ITextStoreAPC::GetTextExt() blocks us to behave ideally.
   // For preventing it to be called, we should put off notifying TSF of
   // anything until layout information becomes available.
-  bool mDeferNotifyingTSF;
+  bool mDeferNotifyingTSF = false;
   // While the document is locked, committing composition always fails since
   // TSF needs another document lock for modifying the composition, selection
   // and etc.  So, committing composition should be performed after the
   // document is unlocked.
-  bool mDeferCommittingComposition;
-  bool mDeferCancellingComposition;
+  bool mDeferCommittingComposition = false;
+  bool mDeferCancellingComposition = false;
   // Immediately after a call of Destroy(), mDestroyed becomes true.  If this
   // is true, the instance shouldn't grant any requests from the TIP anymore.
-  bool mDestroyed;
+  bool mDestroyed = false;
   // While the instance is being destroyed, this is set to true for avoiding
   // recursive Destroy() calls.
-  bool mBeingDestroyed;
+  bool mBeingDestroyed = false;
+  // Whether we're in the private browsing mode.
+  bool mInPrivateBrowsing = true;
 
   // TSF thread manager object for the current application
   static StaticRefPtr<ITfThreadMgr> sThreadMgr;
