# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/NotificationController.cpp
# Commit: 9f1d0d70629c
# Full Hash: 9f1d0d70629c54acefe940e5f93310126b681fd9
# Author: Morgan Rae Reschenberg <mreschenberg@mozilla.com>
# Date: 2022-06-14 03:47:07
# Regressor Bug: 1758689
# File Overlap Count: 1
# Description:
#   Bug 1758689: Create and maintain a viewport cache for hittesting r=Jamie,emilio
#   
#   This hittesting approach is borrowed from our Android implementation.
#   We maintain a cache of ID's for accessibles which are visible in the viewport.
#   This cache is created with a call to `nsLayoutUtils::GetFramesForArea`, which
# ==============================================================================

diff -r b4f6fb035220 -r 9f1d0d70629c accessible/base/NotificationController.cpp
--- a/accessible/base/NotificationController.cpp	Mon Jun 13 22:11:11 2022 +0000
+++ b/accessible/base/NotificationController.cpp	Mon Jun 13 22:28:36 2022 +0000
@@ -83,7 +83,8 @@
 
 void NotificationController::Shutdown() {
   if (mObservingState != eNotObservingRefresh &&
-      mPresShell->RemoveRefreshObserver(this, FlushType::Display)) {
+      mPresShell->RemoveRefreshObserver(this, FlushType::Display) &&
+      mPresShell->RemovePostRefreshObserver(this)) {
     mObservingState = eNotObservingRefresh;
   }
 
@@ -453,7 +454,8 @@
   // asynchronously (after style and layout).
   if (mObservingState == eNotObservingRefresh) {
     if (mPresShell->AddRefreshObserver(this, FlushType::Display,
-                                       "Accessibility notifications")) {
+                                       "Accessibility notifications") &&
+        mPresShell->AddPostRefreshObserver(this)) {
       mObservingState = eRefreshObserving;
     }
   }
@@ -981,11 +983,30 @@
       !mFocusEvent && mEvents.IsEmpty() && mTextHash.Count() == 0 &&
       mHangingChildDocuments.IsEmpty() &&
       mDocument->HasLoadState(DocAccessible::eCompletelyLoaded) &&
-      mPresShell->RemoveRefreshObserver(this, FlushType::Display)) {
+      mPresShell->RemoveRefreshObserver(this, FlushType::Display) &&
+      mPresShell->RemovePostRefreshObserver(this)) {
     mObservingState = eNotObservingRefresh;
   }
 }
 
+void NotificationController::DidRefresh() {
+  if (IPCAccessibilityActive() && mDocument->IsViewportCacheDirty()) {
+    // It is now safe to send the viewport cache, because
+    // we know painting has finished.
+    RefPtr<AccAttributes> fields = mDocument->BundleFieldsForCache(
+        CacheDomain::Viewport, CacheUpdateType::Update);
+
+    if (fields->Count()) {
+      nsTArray<CacheData> data(1);
+      data.AppendElement(CacheData(0, fields));
+      MOZ_ASSERT(mDocument->IPCDoc());
+      mDocument->IPCDoc()->SendCache(CacheUpdateType::Update, data, true);
+    }
+
+    mDocument->SetViewportCacheDirty(false);
+  }
+}
+
 void NotificationController::EventMap::PutEvent(AccTreeMutationEvent* aEvent) {
   EventType type = GetEventType(aEvent);
   uint64_t addr = reinterpret_cast<uintptr_t>(aEvent->GetAccessible());