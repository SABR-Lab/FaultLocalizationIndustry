# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/RemoteAccessibleBase.cpp
# Commit: 9f1d0d70629c
# Full Hash: 9f1d0d70629c54acefe940e5f93310126b681fd9
# Author: Morgan Rae Reschenberg <mreschenberg@mozilla.com>
# Date: 2022-06-14 03:47:07
# Regressor Bug: 1758689
# File Overlap Count: 1
# Description:
#   Bug 1758689: Create and maintain a viewport cache for hittesting r=Jamie,emilio
#   
#   This hittesting approach is borrowed from our Android implementation.
#   We maintain a cache of ID's for accessibles which are visible in the viewport.
#   This cache is created with a call to `nsLayoutUtils::GetFramesForArea`, which
# ==============================================================================

diff -r b4f6fb035220 -r 9f1d0d70629c accessible/ipc/RemoteAccessibleBase.cpp
--- a/accessible/ipc/RemoteAccessibleBase.cpp	Mon Jun 13 22:11:11 2022 +0000
+++ b/accessible/ipc/RemoteAccessibleBase.cpp	Mon Jun 13 22:28:36 2022 +0000
@@ -314,6 +314,81 @@
 }
 
 template <class Derived>
+Accessible* RemoteAccessibleBase<Derived>::ChildAtPoint(
+    int32_t aX, int32_t aY, LocalAccessible::EWhichChildAtPoint aWhichChild) {
+  RemoteAccessible* lastMatch = nullptr;
+  // If `this` is a document, use its viewport cache instead of
+  // the cache of its parent document.
+  if (DocAccessibleParent* doc = IsDoc() ? AsDoc() : mDoc) {
+    if (auto maybeViewportCache =
+            doc->mCachedFields->GetAttribute<nsTArray<uint64_t>>(
+                nsGkAtoms::viewport)) {
+      // The retrieved viewport cache contains acc IDs in hittesting order.
+      // That is, items earlier in the list have z-indexes that are larger than
+      // those later in the list. If you were to build a tree by z-index, where
+      // chilren have larger z indices than their parents, iterating this list
+      // is essentially a postorder tree traversal.
+      const nsTArray<uint64_t>& viewportCache = *maybeViewportCache;
+
+      for (auto id : viewportCache) {
+        RemoteAccessible* acc = doc->GetAccessible(id);
+        if (!acc) {
+          // This can happen if the acc died in between
+          // pushing the viewport cache and doing this hittest
+          continue;
+        }
+
+        if (acc == this) {
+          // Even though we're searching from the doc's cache
+          // this call shouldn't pass the boundary defined by
+          // the acc this call originated on. If we hit `this`,
+          // return our most recent match.
+          break;
+        }
+
+        if (acc == doc) {
+          // If we're already in `doc`s viewport cache, and the doc is
+          // not the acc this call originated on, skip it.
+          // We have to have `doc` in this list, because we need to support
+          // calling `doc->ChildAtPoint()`. Without this check, we end up
+          // calling `doc->ChildAtPoint(...)` below which changes the context of
+          // this call.
+          continue;
+        }
+
+        if (acc->Bounds().Contains(aX, aY)) {
+          if (acc->IsDoc()) {
+            // If we encounter a doc, search its viewport
+            // cache. Do this even if we're looking for the
+            // deepest child, since in that case we should return
+            // the deepest child in the subdoc.
+            return acc->ChildAtPoint(aX, aY, aWhichChild);
+          }
+
+          if (aWhichChild == EWhichChildAtPoint::DeepestChild) {
+            // Because our rects are in hittesting order, the
+            // first match we encounter is guaranteed to be the
+            // deepest match.
+            lastMatch = acc;
+            break;
+          }
+
+          // We're looking for a DirectChild match. Update our
+          // `lastMatch` marker as we ascend towards `this`.
+          lastMatch = acc;
+        }
+      }
+    }
+  }
+
+  if (!lastMatch && Bounds().Contains(aX, aY)) {
+    return this;
+  }
+
+  return lastMatch;
+}
+
+template <class Derived>
 Maybe<nsRect> RemoteAccessibleBase<Derived>::RetrieveCachedBounds() const {
   MOZ_ASSERT(mCachedFields);
   if (!mCachedFields) {