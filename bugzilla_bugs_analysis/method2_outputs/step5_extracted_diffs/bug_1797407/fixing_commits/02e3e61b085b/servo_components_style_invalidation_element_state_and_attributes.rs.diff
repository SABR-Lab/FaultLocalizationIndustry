# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: servo/components/style/invalidation/element/state_and_attributes.rs
# Commit: 02e3e61b085b
# Full Hash: 02e3e61b085b61f5d5aa343503060fc973e09f79
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-10-26 22:42:58
# Description:
#   Bug 1797407 - Don't propagate bits for children invalidated under display:none/not in the flat tree. r=boris,firefox-style-system-reviewers
#   
#   Much like invalidated_descendants. This preserves our invariant that we
#   only visit elements with data in the post-traversal.
#   
# ==============================================================================

diff -r d29dbc982c8a -r 02e3e61b085b servo/components/style/invalidation/element/state_and_attributes.rs
--- a/servo/components/style/invalidation/element/state_and_attributes.rs	Wed Oct 26 14:34:50 2022 +0000
+++ b/servo/components/style/invalidation/element/state_and_attributes.rs	Wed Oct 26 14:37:34 2022 +0000
@@ -152,13 +152,16 @@
 
 /// Sets the appropriate restyle hint after invalidating the style of a given
 /// element.
-pub fn invalidated_self<E>(element: E)
+pub fn invalidated_self<E>(element: E) -> bool
 where
     E: TElement,
 {
-    if let Some(mut data) = element.mutate_data() {
-        data.hint.insert(RestyleHint::RESTYLE_SELF);
-    }
+    let mut data = match element.mutate_data() {
+        Some(data) => data,
+        None => return false,
+    };
+    data.hint.insert(RestyleHint::RESTYLE_SELF);
+    true
 }
 
 /// Sets the appropriate hint after invalidating the style of a sibling.
@@ -167,7 +170,9 @@
     E: TElement,
 {
     debug_assert_eq!(element.as_node().parent_node(), of.as_node().parent_node(), "Should be siblings");
-    invalidated_self(element);
+    if !invalidated_self(element) {
+        return;
+    }
     if element.traversal_parent() != of.traversal_parent() {
         let parent = element.as_node().parent_element_or_host();
         debug_assert!(parent.is_some(), "How can we have siblings without parent nodes?");