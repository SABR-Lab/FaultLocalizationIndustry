# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/invalidation/element/state_and_attributes.rs
# Commit: 7b671f8bf0fc
# Full Hash: 7b671f8bf0fc98548adbd5d9eccf1fac41addd69
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-10-20 21:51:26
# Regressor Bug: 1794720
# File Overlap Count: 1
# Description:
#   Bug 1794720 - fix invalidation of sibling combinators in different slots. r=firefox-style-system-reviewers,layout-reviewers,boris
#   
#   This extends the code to deal with sibling invalidation to handle the
#   case where the flat tree doesn't match the DOM tree. In the test-case
#   for example, dom is:
# ==============================================================================

diff -r 6c6037523786 -r 7b671f8bf0fc servo/components/style/invalidation/element/state_and_attributes.rs
--- a/servo/components/style/invalidation/element/state_and_attributes.rs	Thu Oct 20 08:36:24 2022 +0000
+++ b/servo/components/style/invalidation/element/state_and_attributes.rs	Thu Oct 20 08:39:18 2022 +0000
@@ -7,7 +7,7 @@
 
 use crate::context::SharedStyleContext;
 use crate::data::ElementData;
-use crate::dom::TElement;
+use crate::dom::{TElement, TNode};
 use crate::invalidation::element::element_wrapper::{ElementSnapshot, ElementWrapper};
 use crate::invalidation::element::invalidation_map::*;
 use crate::invalidation::element::invalidator::{DescendantInvalidationLists, InvalidationVector};
@@ -118,14 +118,10 @@
 }
 
 /// Propagates the bits after invalidating a descendant child.
-pub fn invalidated_descendants<E>(element: E, child: E)
+pub fn propagate_dirty_bit_up_to<E>(ancestor: E, child: E)
 where
     E: TElement,
 {
-    if !child.has_data() {
-        return;
-    }
-
     // The child may not be a flattened tree child of the current element,
     // but may be arbitrarily deep.
     //
@@ -136,10 +132,22 @@
         unsafe { parent.set_dirty_descendants() };
         current = parent.traversal_parent();
 
-        if parent == element {
-            break;
+        if parent == ancestor {
+            return;
         }
     }
+    debug_assert!(false, "Should've found {:?} as an ancestor of {:?}", ancestor, child);
+}
+
+/// Propagates the bits after invalidating a descendant child, if needed.
+pub fn invalidated_descendants<E>(element: E, child: E)
+where
+    E: TElement,
+{
+    if !child.has_data() {
+        return;
+    }
+    propagate_dirty_bit_up_to(element, child)
 }
 
 /// Sets the appropriate restyle hint after invalidating the style of a given
@@ -153,6 +161,22 @@
     }
 }
 
+/// Sets the appropriate hint after invalidating the style of a sibling.
+pub fn invalidated_sibling<E>(element: E, of: E)
+where
+    E: TElement,
+{
+    debug_assert_eq!(element.as_node().parent_node(), of.as_node().parent_node(), "Should be siblings");
+    invalidated_self(element);
+    if element.traversal_parent() != of.traversal_parent() {
+        let parent = element.as_node().parent_element_or_host();
+        debug_assert!(parent.is_some(), "How can we have siblings without parent nodes?");
+        if let Some(e) = parent {
+            propagate_dirty_bit_up_to(e, element)
+        }
+    }
+}
+
 impl<'a, 'b: 'a, E: 'a> InvalidationProcessor<'a, E>
     for StateAndAttrInvalidationProcessor<'a, 'b, E>
 where
@@ -366,6 +390,11 @@
         debug_assert_ne!(element, self.element);
         invalidated_self(element);
     }
+
+    fn invalidated_sibling(&mut self, element: E, of: E) {
+        debug_assert_ne!(element, self.element);
+        invalidated_sibling(element, of);
+    }
 }
 
 impl<'a, 'b, 'selectors, E> Collector<'a, 'b, 'selectors, E>