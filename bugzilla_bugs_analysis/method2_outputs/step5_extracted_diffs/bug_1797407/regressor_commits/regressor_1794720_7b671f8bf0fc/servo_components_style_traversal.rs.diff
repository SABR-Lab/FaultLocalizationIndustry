# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/traversal.rs
# Commit: 7b671f8bf0fc
# Full Hash: 7b671f8bf0fc98548adbd5d9eccf1fac41addd69
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-10-20 21:51:26
# Regressor Bug: 1794720
# File Overlap Count: 1
# Description:
#   Bug 1794720 - fix invalidation of sibling combinators in different slots. r=firefox-style-system-reviewers,layout-reviewers,boris
#   
#   This extends the code to deal with sibling invalidation to handle the
#   case where the flat tree doesn't match the DOM tree. In the test-case
#   for example, dom is:
# ==============================================================================

diff -r 6c6037523786 -r 7b671f8bf0fc servo/components/style/traversal.rs
--- a/servo/components/style/traversal.rs	Thu Oct 20 08:36:24 2022 +0000
+++ b/servo/components/style/traversal.rs	Thu Oct 20 08:39:18 2022 +0000
@@ -157,6 +157,8 @@
     /// such, we have a pre-traversal step to handle that part and determine whether
     /// a full traversal is needed.
     fn pre_traverse(root: E, shared_context: &SharedStyleContext) -> PreTraverseToken<E> {
+        use crate::invalidation::element::state_and_attributes::propagate_dirty_bit_up_to;
+
         let traversal_flags = shared_context.traversal_flags;
 
         let mut data = root.mutate_data();
@@ -174,11 +176,11 @@
                 );
 
                 if invalidation_result.has_invalidated_siblings() {
-                    let actual_root = root.traversal_parent().expect(
+                    let actual_root = root.as_node().parent_element_or_host().expect(
                         "How in the world can you invalidate \
                          siblings without a parent?",
                     );
-                    unsafe { actual_root.set_dirty_descendants() }
+                    propagate_dirty_bit_up_to(actual_root, root);
                     return PreTraverseToken(Some(actual_root));
                 }
             }