# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: 0b582207c30d
# Full Hash: 0b582207c30d4926cd642aa2321ed605dd12b804
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-09-12 21:40:55
# Regressor Bug: 1789849
# File Overlap Count: 1
# Description:
#   Bug 1789849 - Increment profile counters for a few more expensive events. r=aosmond
#   
#   Certain events like waiting on a round-trip to verify that the HostWebGLContext is
#   done using a shmem, or pushing a Skia layer which will need to be flatten later, can
#   be expensive, especially if they are used many times throughout a frame. However,
# ==============================================================================

diff -r 9cef48a4e5b6 -r 0b582207c30d dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:26:02 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:26:02 2022 +0000
@@ -596,6 +596,9 @@
   mSharedContext->SetClipRect(mClipBounds);
   // The Skia target contents was clobbered and is now invalid.
   mSkiaValid = false;
+  // We uploaded a surface, just as if we missed the texture cache, so account
+  // for that here.
+  mProfile.OnCacheMiss();
   return !!data;
 }
 
@@ -3163,6 +3166,9 @@
     // the Shmem have finished.
     (void)mWebgl->GetError();
     mWaitForShmem = false;
+    // The sync IPDL call can cause expensive round-trips to add up over time,
+    // so account for that here.
+    mCurrentTarget->mProfile.OnReadback();
   }
 }
 
@@ -3173,6 +3179,7 @@
       // If the Skia context needs initialization, clear it and enable layering.
       mSkiaValid = true;
       if (mWebglValid) {
+        mProfile.OnLayer();
         mSkiaLayer = true;
         mSkia->Clear();
       }
@@ -3284,8 +3291,9 @@
   float cacheRatio =
       StaticPrefs::gfx_canvas_accelerated_profile_cache_miss_ratio();
   if (mFallbacks > 0 ||
-      mCacheMisses + mReadbacks > cacheRatio * (mCacheMisses + mCacheHits +
-                                                mUncachedDraws + mReadbacks)) {
+      float(mCacheMisses + mReadbacks + mLayers) >
+          cacheRatio * float(mCacheMisses + mCacheHits + mUncachedDraws +
+                             mReadbacks + mLayers)) {
     failed = true;
   }
   if (failed) {
