# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: 9cef48a4e5b6
# Full Hash: 9cef48a4e5b61ad9c4e633b8cfaa005a9220672a
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-09-12 21:40:55
# Regressor Bug: 1789849
# File Overlap Count: 2
# Description:
#   Bug 1789849 - Avoid regenerating clip mask unless necessary. r=aosmond
#   
#   Sometimes the clip state is thrashed when we need to temporarily override
#   clipping to disable it. However, in this case, the clip mask itself remains
#   unchanged. The current invalidation scheme doesn't discern between generation
# ==============================================================================

diff -r aeb32fa2f7d5 -r 9cef48a4e5b6 dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:01:19 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:26:02 2022 +0000
@@ -532,7 +532,7 @@
 // render to the Skia target temporarily, transparent outside the clip region,
 // opaque inside, and upload this to a texture that can be used by the shaders.
 bool DrawTargetWebgl::GenerateComplexClipMask() {
-  if (!mClipDirty) {
+  if (!mClipChanged) {
     // If the clip mask was already generated, use the cached mask and bounds.
     mSharedContext->SetClipMask(mClipMask);
     mSharedContext->SetClipRect(mClipBounds);
@@ -596,7 +596,6 @@
   mSharedContext->SetClipRect(mClipBounds);
   // The Skia target contents was clobbered and is now invalid.
   mSkiaValid = false;
-  mClipDirty = false;
   return !!data;
 }
 
@@ -617,7 +616,6 @@
   }
   mSharedContext->SetClipRect(*clip);
   mSharedContext->SetNoClipMask();
-  mClipDirty = false;
   return true;
 }
 
@@ -629,13 +627,15 @@
     mSharedContext->SetClipRect(IntRect(IntPoint(), mSize));
     mSharedContext->SetNoClipMask();
     // Ensure the clip gets reset if clipping is later requested for the target.
-    mClipDirty = true;
-  } else if (mClipDirty || !mSharedContext->IsCurrentTarget(this)) {
+    mRefreshClipState = true;
+  } else if (mRefreshClipState || !mSharedContext->IsCurrentTarget(this)) {
     // Try to use a simple clip rect if possible. Otherwise, fall back to
     // generating a clip mask texture that can represent complex clip regions.
     if (!SetSimpleClipRect() && !GenerateComplexClipMask()) {
       return false;
     }
+    mClipChanged = false;
+    mRefreshClipState = false;
   }
   return mSharedContext->SetTarget(this);
 }
@@ -786,7 +786,7 @@
   if (mLastClipMask) {
     mTarget->mSharedContext->SetClipMask(mLastClipMask);
   }
-  mTarget->mClipDirty = true;
+  mTarget->mRefreshClipState = true;
 }
 
 // Utility method to install the target before copying a snapshot.
@@ -1217,23 +1217,27 @@
 }
 
 void DrawTargetWebgl::PushClip(const Path* aPath) {
-  mClipDirty = true;
+  mClipChanged = true;
+  mRefreshClipState = true;
   mSkia->PushClip(aPath);
 }
 
 void DrawTargetWebgl::PushClipRect(const Rect& aRect) {
-  mClipDirty = true;
+  mClipChanged = true;
+  mRefreshClipState = true;
   mSkia->PushClipRect(aRect);
 }
 
 void DrawTargetWebgl::PushDeviceSpaceClipRects(const IntRect* aRects,
                                                uint32_t aCount) {
-  mClipDirty = true;
+  mClipChanged = true;
+  mRefreshClipState = true;
   mSkia->PushDeviceSpaceClipRects(aRects, aCount);
 }
 
 void DrawTargetWebgl::PopClip() {
-  mClipDirty = true;
+  mClipChanged = true;
+  mRefreshClipState = true;
   mSkia->PopClip();
 }
 