# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: b3e786ad051c
# Full Hash: b3e786ad051cb83344b111e5cb8a19303dd6a77e
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-09-12 21:40:55
# Regressor Bug: 1789849
# File Overlap Count: 2
# Description:
#   Bug 1789849 - Use a separate DrawTargetSkia for rendering clip masks. r=aosmond
#   
#   Previously we were reusing the framebuffer's Skia DT to render the clip mask.
#   This was the path of least resistance since SkCanvas does not allow exporting
#   clip information, and there is no way to reset the bitmap storage inside an
# ==============================================================================

diff -r 0b582207c30d -r b3e786ad051c dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:26:02 2022 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Mon Sep 12 15:26:03 2022 +0000
@@ -543,8 +543,6 @@
     // in it.
     return false;
   }
-  // Wait for any existing uploads to finish.
-  mSharedContext->WaitForShmem();
   RefPtr<ClientWebGLContext> webgl = mSharedContext->mWebgl;
   if (!webgl) {
     return false;
@@ -564,17 +562,26 @@
     // If we can't get bounds, then just use the entire viewport.
     mClipBounds = IntRect(IntPoint(), mSize);
   }
-  // If initializing the clip mask, then clear the entire texture to ensure all
-  // pixels get filled with an empty mask regardless. Otherwise, restrict
-  // clearing to only the clip region.
-  IntRect dataBounds = init ? IntRect(IntPoint(), mSize) : mClipBounds;
-  mSkia->Clear(Rect(dataBounds), false);
-  // Reset any transforms so we can fill the entire inside of the clip region
+  // If initializing the clip mask, then allocate the entire texture to ensure
+  // all pixels get filled with an empty mask regardless. Otherwise, restrict
+  // uploading to only the clip region.
+  RefPtr<DrawTargetSkia> dt = new DrawTargetSkia;
+  if (!dt->Init(mClipBounds.Size(), SurfaceFormat::A8)) {
+    return false;
+  }
+  // Set the clip region and fill the entire inside of it
   // with opaque white.
-  Matrix xform = mSkia->GetTransform();
-  mSkia->SetTransform(Matrix());
-  mSkia->FillRect(Rect(dataBounds), ColorPattern(DeviceColor(1, 1, 1, 1)));
-  mSkia->SetTransform(xform);
+  for (auto& clipStack : mClipStack) {
+    dt->SetTransform(
+        Matrix(clipStack.mTransform).PostTranslate(-mClipBounds.TopLeft()));
+    if (clipStack.mPath) {
+      dt->PushClip(clipStack.mPath);
+    } else {
+      dt->PushClipRect(clipStack.mRect);
+    }
+  }
+  dt->SetTransform(Matrix::Translation(-mClipBounds.TopLeft()));
+  dt->FillRect(Rect(mClipBounds), ColorPattern(DeviceColor(1, 1, 1, 1)));
   // Bind the clip mask for uploading.
   webgl->ActiveTexture(LOCAL_GL_TEXTURE1);
   webgl->BindTexture(LOCAL_GL_TEXTURE_2D, mClipMask);
@@ -582,20 +589,25 @@
     mSharedContext->InitTexParameters(mClipMask, false);
   }
   RefPtr<DataSourceSurface> data;
-  if (RefPtr<SourceSurface> snapshot = mSkia->Snapshot()) {
+  if (RefPtr<SourceSurface> snapshot = dt->Snapshot()) {
     data = snapshot->GetDataSurface();
   }
   // Finally, upload the texture data and initialize texture storage if
   // necessary.
-  mSharedContext->UploadSurface(data, SurfaceFormat::B8G8R8A8, dataBounds,
-                                dataBounds.TopLeft(), init);
+  if (init && mClipBounds.Size() != mSize) {
+    mSharedContext->UploadSurface(nullptr, SurfaceFormat::A8,
+                                  IntRect(IntPoint(), mSize), IntPoint(), true,
+                                  true);
+    init = false;
+  }
+  mSharedContext->UploadSurface(data, SurfaceFormat::A8,
+                                IntRect(IntPoint(), mClipBounds.Size()),
+                                mClipBounds.TopLeft(), init);
   webgl->ActiveTexture(LOCAL_GL_TEXTURE0);
   // We already bound the texture, so notify the shared context that the clip
   // mask changed to it.
   mSharedContext->mLastClipMask = mClipMask;
   mSharedContext->SetClipRect(mClipBounds);
-  // The Skia target contents was clobbered and is now invalid.
-  mSkiaValid = false;
   // We uploaded a surface, just as if we missed the texture cache, so account
   // for that here.
   mProfile.OnCacheMiss();
@@ -1011,7 +1023,7 @@
         "varying vec2 v_cliptc;\n"
         "varying vec4 v_dist;\n"
         "void main() {\n"
-        "   vec4 clip = texture2D(u_clipmask, v_cliptc);\n"
+        "   float clip = texture2D(u_clipmask, v_cliptc).r;\n"
         "   vec2 dist = min(v_dist.xy, v_dist.zw);\n"
         "   float aa = clamp(min(dist.x, dist.y), 0.0, 1.0);\n"
         "   gl_FragColor = clip * aa * u_color;\n"
@@ -1094,7 +1106,7 @@
         "void main() {\n"
         "   vec2 tc = clamp(v_texcoord, u_texbounds.xy, u_texbounds.zw);\n"
         "   vec4 image = texture2D(u_sampler, tc);\n"
-        "   vec4 clip = texture2D(u_clipmask, v_cliptc);\n"
+        "   float clip = texture2D(u_clipmask, v_cliptc).r;\n"
         "   vec2 dist = min(v_dist.xy, v_dist.zw);\n"
         "   float aa = clamp(min(dist.x, dist.y), 0.0, 1.0);\n"
         "   gl_FragColor = clip * aa * u_color *\n"
@@ -1223,12 +1235,16 @@
   mClipChanged = true;
   mRefreshClipState = true;
   mSkia->PushClip(aPath);
+
+  mClipStack.push_back({GetTransform(), Rect(), aPath});
 }
 
 void DrawTargetWebgl::PushClipRect(const Rect& aRect) {
   mClipChanged = true;
   mRefreshClipState = true;
   mSkia->PushClipRect(aRect);
+
+  mClipStack.push_back({GetTransform(), aRect, nullptr});
 }
 
 void DrawTargetWebgl::PushDeviceSpaceClipRects(const IntRect* aRects,
@@ -1236,12 +1252,18 @@
   mClipChanged = true;
   mRefreshClipState = true;
   mSkia->PushDeviceSpaceClipRects(aRects, aCount);
+
+  for (uint32_t i = 0; i < aCount; i++) {
+    mClipStack.push_back({Matrix(), Rect(aRects[i]), nullptr});
+  }
 }
 
 void DrawTargetWebgl::PopClip() {
   mClipChanged = true;
   mRefreshClipState = true;
   mSkia->PopClip();
+
+  mClipStack.pop_back();
 }
 
 // Whether a given composition operator can be mapped to a WebGL blend mode.
@@ -1475,12 +1497,13 @@
     // Create a PBO filled with zero data to initialize the texture data and
     // avoid slow initialization inside WebGL.
     MOZ_ASSERT(aSrcRect.TopLeft() == IntPoint(0, 0));
-    if (!mZeroBuffer || mZeroSize.width < aSrcRect.width ||
-        mZeroSize.height < aSrcRect.height) {
+    size_t size =
+        size_t(GetAlignedStride<4>(aSrcRect.width, BytesPerPixel(aFormat))) *
+        aSrcRect.height;
+    if (!mZeroBuffer || size > mZeroSize) {
       mZeroBuffer = mWebgl->CreateBuffer();
-      mZeroSize = aSrcRect.Size();
+      mZeroSize = size;
       mWebgl->BindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, mZeroBuffer);
-      size_t size = 4 * mZeroSize.width * mZeroSize.height;
       // WebGL will zero initialize the empty buffer, so we don't send zero data
       // explicitly.
       mWebgl->RawBufferData(LOCAL_GL_PIXEL_UNPACK_BUFFER, nullptr, size,