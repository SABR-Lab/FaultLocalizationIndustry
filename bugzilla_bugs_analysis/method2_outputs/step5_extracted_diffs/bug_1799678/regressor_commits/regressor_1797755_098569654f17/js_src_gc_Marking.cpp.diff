# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Marking.cpp
# Commit: 098569654f17
# Full Hash: 098569654f17fe958cfa7ca7077e4d770044a62e
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2022-10-28 21:22:11
# Regressor Bug: 1797755
# File Overlap Count: 1
# Description:
#   Bug 1797755 - Part 4: Remove option to set maximum mark stack capacity in release builds r=sfink
#   
#   Currently we have a GC parameter that allows setting a maximum mark stack
#   capacity. This is only ever used by test code, not in the browser. This
#   requires extra unnecessary work in release builds if we move to a different
# ==============================================================================

diff -r 6e5a935e576a -r 098569654f17 js/src/gc/Marking.cpp
--- a/js/src/gc/Marking.cpp	Fri Oct 28 09:47:14 2022 +0000
+++ b/js/src/gc/Marking.cpp	Fri Oct 28 09:47:14 2022 +0000
@@ -1560,15 +1560,7 @@
   return ptr_;
 }
 
-MarkStack::MarkStack(size_t maxCapacity)
-    : topIndex_(0),
-      maxCapacity_(maxCapacity)
-#ifdef DEBUG
-      ,
-      iteratorCount_(0)
-#endif
-{
-}
+MarkStack::MarkStack() { MOZ_ASSERT(isEmpty()); }
 
 MarkStack::~MarkStack() {
   MOZ_ASSERT(isEmpty());
@@ -1588,13 +1580,14 @@
     capacity = NON_INCREMENTAL_MARK_STACK_BASE_CAPACITY;
   }
 
-  if (capacity > maxCapacity_) {
-    capacity = maxCapacity_;
-  }
+#ifdef JS_GC_ZEAL
+  capacity = std::min(capacity, maxCapacity_.ref());
+#endif
 
   return resize(capacity);
 }
 
+#ifdef JS_GC_ZEAL
 void MarkStack::setMaxCapacity(size_t maxCapacity) {
   MOZ_ASSERT(maxCapacity != 0);
   MOZ_ASSERT(isEmpty());
@@ -1606,6 +1599,7 @@
     (void)resize(maxCapacity_);
   }
 }
+#endif
 
 inline MarkStack::TaggedPtr* MarkStack::topPtr() { return &stack()[topIndex_]; }
 
@@ -1684,7 +1678,12 @@
 }
 
 MOZ_NEVER_INLINE bool MarkStack::enlarge(size_t count) {
-  size_t newCapacity = std::min(maxCapacity_.ref(), capacity() * 2);
+  size_t newCapacity = capacity() * 2;
+
+#ifdef JS_GC_ZEAL
+  newCapacity = std::min(newCapacity, maxCapacity_.ref());
+#endif
+
   if (newCapacity < capacity() + count) {
     return false;
   }