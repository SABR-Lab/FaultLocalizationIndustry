# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/builtin/TestingFunctions.cpp
# Commit: 186a012563fc
# Full Hash: 186a012563fc5fa63ca8bca17ce517e35787a675
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2022-10-28 21:22:11
# Regressor Bug: 1797755
# File Overlap Count: 1
# Description:
#   Bug 1797755 - Part 1: Move testing mark queue to GCRuntime r=sfink
#   
#   Parallel marking will use one GCMarker per thread. The testing mark queue is
#   really a per-runtime data structure, so this patch moves it to the GCRuntime.
#   
# ==============================================================================

diff -r cdb22d98c7eb -r 186a012563fc js/src/builtin/TestingFunctions.cpp
--- a/js/src/builtin/TestingFunctions.cpp	Fri Oct 28 09:18:47 2022 +0000
+++ b/js/src/builtin/TestingFunctions.cpp	Fri Oct 28 09:47:13 2022 +0000
@@ -2393,7 +2393,7 @@
   }
 
 #  ifdef DEBUG
-  val = Int32Value(gc.marker.queuePos);
+  val = Int32Value(gc.testMarkQueuePos());
   if (!JS_DefineProperty(cx, result, "queuePos", val, JSPROP_ENUMERATE)) {
     return false;
   }
@@ -6850,20 +6850,19 @@
 #ifdef DEBUG
 static bool EnqueueMark(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-
-  auto& queue = cx->runtime()->gc.marker.markQueue;
+  gc::GCRuntime* gc = &cx->runtime()->gc;
 
   if (args.get(0).isString()) {
     RootedString val(cx, args[0].toString());
     if (!val->ensureLinear(cx)) {
       return false;
     }
-    if (!queue.append(StringValue(val))) {
+    if (!gc->appendTestMarkQueue(StringValue(val))) {
       JS_ReportOutOfMemory(cx);
       return false;
     }
   } else if (args.get(0).isObject()) {
-    if (!queue.append(args[0])) {
+    if (!gc->appendTestMarkQueue(args[0])) {
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -6879,7 +6878,7 @@
 static bool GetMarkQueue(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  auto& queue = cx->runtime()->gc.marker.markQueue.get();
+  const auto& queue = cx->runtime()->gc.getTestMarkQueue();
 
   RootedObject result(cx, JS::NewArrayObject(cx, queue.length()));
   if (!result) {
@@ -6902,7 +6901,7 @@
 static bool ClearMarkQueue(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  cx->runtime()->gc.marker.markQueue.clear();
+  cx->runtime()->gc.clearTestMarkQueue();
   args.rval().setUndefined();
   return true;
 }