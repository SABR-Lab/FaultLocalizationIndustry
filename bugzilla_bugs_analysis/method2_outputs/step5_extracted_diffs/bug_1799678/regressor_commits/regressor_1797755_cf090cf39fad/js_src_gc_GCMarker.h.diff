# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/GCMarker.h
# Commit: cf090cf39fad
# Full Hash: cf090cf39fadeaefe73229499a1384a5145fc9c2
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2022-10-29 09:50:10
# Regressor Bug: 1797755
# File Overlap Count: 1
# Description:
#   Bug 1797755 - Part 1: Move testing mark queue to GCRuntime r=sfink
#   
#   Parallel marking will use one GCMarker per thread. The testing mark queue is
#   really a per-runtime data structure, so this patch moves it to the GCRuntime.
#   
# ==============================================================================

diff -r f6aaa6865516 -r cf090cf39fad js/src/gc/GCMarker.h
--- a/js/src/gc/GCMarker.h	Fri Oct 28 15:04:29 2022 +0000
+++ b/js/src/gc/GCMarker.h	Fri Oct 28 15:17:42 2022 +0000
@@ -338,15 +338,6 @@
 
   bool isDrained();
 
-  // The mark queue is a testing-only feature for controlling mark ordering and
-  // yield timing.
-  enum MarkQueueProgress {
-    QueueYielded,   // End this incremental GC slice, if possible
-    QueueComplete,  // Done with the queue
-    QueueSuspended  // Continue the GC without ending the slice
-  };
-  MarkQueueProgress processMarkQueue();
-
   enum ShouldReportMarkTime : bool {
     ReportMarkTime = true,
     DontReportMarkTime = false
@@ -379,8 +370,17 @@
   template <typename T>
   void markImplicitEdges(T* oldThing);
 
+  bool isRegularMarking() const {
+    return state == MarkingState::RegularMarking;
+  }
   bool isWeakMarking() const { return state == MarkingState::WeakMarking; }
 
+  bool isMarkStackEmpty() { return stack.isEmpty(); }
+
+  bool hasBlackEntries() const { return stack.position() > grayPosition; }
+
+  bool hasGrayEntries() const { return grayPosition > 0 && !stack.isEmpty(); }
+
  private:
 #ifdef DEBUG
   void checkZone(void* p);
@@ -429,13 +429,8 @@
   inline void pushValueRange(JSObject* obj, SlotsOrElementsKind kind,
                              size_t start, size_t end);
 
-  bool isMarkStackEmpty() { return stack.isEmpty(); }
-
-  bool hasBlackEntries() const { return stack.position() > grayPosition; }
-
-  bool hasGrayEntries() const { return grayPosition > 0 && !stack.isEmpty(); }
-
-  inline void processMarkStackTop(SliceBudget& budget);
+  void processMarkStackTop(SliceBudget& budget);
+  friend class gc::GCRuntime;
 
   void markDelayedChildren(gc::Arena* arena);
   void markAllDelayedChildren(ShouldReportMarkTime reportTime);
@@ -492,9 +487,6 @@
    */
   MainThreadOrGCTaskData<bool> checkAtomMarking;
 
-  /* The test marking queue might want to be marking a particular color. */
-  mozilla::Maybe<js::gc::MarkColor> queueMarkColor;
-
   /*
    * If this is true, all marked objects must belong to a compartment being
    * GCed. This is used to look for compartment bugs.
@@ -509,21 +501,6 @@
    */
   MainThreadOrGCTaskData<Compartment*> tracingCompartment;
   MainThreadOrGCTaskData<Zone*> tracingZone;
-
-  /*
-   * List of objects to mark at the beginning of a GC. May also contains string
-   * directives to change mark color or wait until different phases of the GC.
-   *
-   * This is a WeakCache because not everything in this list is guaranteed to
-   * end up marked (eg if you insert an object from an already-processed sweep
-   * group in the middle of an incremental GC). Also, the mark queue is not
-   * used during shutdown GCs. In either case, unmarked objects may need to be
-   * discarded.
-   */
-  JS::WeakCache<GCVector<HeapPtr<JS::Value>, 0, SystemAllocPolicy>> markQueue;
-
-  /* Position within the test mark queue. */
-  size_t queuePos;
 #endif  // DEBUG
 };
 