# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/loader/WorkerLoadContext.cpp
# Commit: 1034aeb0f8e2
# Full Hash: 1034aeb0f8e2d86ea04d8e6a8c717f13c9d772eb
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2022-11-18 15:46:32
# Regressor Bug: 1800496
# File Overlap Count: 2
# Description:
#   Bug 1800496 - Revert mCacheCreator to being defined as part of ScriptLoaderRunnable; r=asuth
#   
#   Previously, in the cancellation refactor, we removed knowledge of the list of scripts being loaded on the main thread. As a result of this, we could no longer clear the cache creator on the main thread after iterating over all requests. We can now do that once again, and it simplifies the code.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D162220
# ==============================================================================

diff -r dfe78c41e4eb -r 1034aeb0f8e2 dom/workers/loader/WorkerLoadContext.cpp
--- a/dom/workers/loader/WorkerLoadContext.cpp	Fri Nov 18 10:02:28 2022 +0000
+++ b/dom/workers/loader/WorkerLoadContext.cpp	Fri Nov 18 10:02:28 2022 +0000
@@ -17,25 +17,6 @@
       mKind(aKind),
       mClientInfo(aClientInfo){};
 
-void WorkerLoadContext::SetCacheCreator(
-    RefPtr<workerinternals::loader::CacheCreator> aCacheCreator) {
-  AssertIsOnMainThread();
-  mCacheCreator =
-      new nsMainThreadPtrHolder<workerinternals::loader::CacheCreator>(
-          "WorkerLoadContext::mCacheCreator", aCacheCreator);
-}
-
-void WorkerLoadContext::ClearCacheCreator() {
-  AssertIsOnMainThread();
-  mCacheCreator = nullptr;
-}
-
-RefPtr<workerinternals::loader::CacheCreator>
-WorkerLoadContext::GetCacheCreator() {
-  AssertIsOnMainThread();
-  return mCacheCreator.get();
-}
-
 ThreadSafeRequestHandle::ThreadSafeRequestHandle(
     JS::loader::ScriptLoadRequest* aRequest, nsISerialEventTarget* aSyncTarget)
     : mRequest(aRequest), mOwningEventTarget(aSyncTarget) {}
@@ -64,6 +45,12 @@
   return mRunnable->GetCancelResult();
 }
 
+workerinternals::loader::CacheCreator*
+ThreadSafeRequestHandle::GetCacheCreator() {
+  AssertIsOnMainThread();
+  return mRunnable->GetCacheCreator();
+}
+
 ThreadSafeRequestHandle::~ThreadSafeRequestHandle() {
   // Normally we only touch mStrongRef on the owning thread.  This is safe,
   // however, because when we do use mStrongRef on the owning thread we are