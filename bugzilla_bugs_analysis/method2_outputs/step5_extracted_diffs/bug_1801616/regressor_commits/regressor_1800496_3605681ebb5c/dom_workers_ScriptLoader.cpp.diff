# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/ScriptLoader.cpp
# Commit: 3605681ebb5c
# Full Hash: 3605681ebb5cb61f1dca13c546e03367857135ae
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2022-11-18 15:46:32
# Regressor Bug: 1800496
# File Overlap Count: 2
# Description:
#   Bug 1800496 - Initial cancellation revert; r=asuth
#   
#   This returns most of the behavior from https://searchfox.org/mozilla-central/rev/e0a7a014f3384ac1abc229d9961f244e3e70a52c/dom/workers/ScriptLoader.cpp#735-776
#   
#   What is missing at this point is batch dispatching, as we once again cancel one-at-a-time rather than as a group.
# ==============================================================================

diff -r 6118d850a96d -r 3605681ebb5c dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp	Fri Nov 18 10:02:26 2022 +0000
+++ b/dom/workers/ScriptLoader.cpp	Fri Nov 18 10:02:27 2022 +0000
@@ -373,20 +373,6 @@
   nsresult Cancel() override;
 };
 
-class AbruptCancellationRunnable final : public MainThreadWorkerSyncRunnable {
-  RefPtr<WorkerScriptLoader> mScriptLoader;
-
- public:
-  AbruptCancellationRunnable(WorkerScriptLoader* aScriptLoader,
-                             nsISerialEventTarget* aSyncLoopTarget);
-
- private:
-  ~AbruptCancellationRunnable() = default;
-
-  virtual bool WorkerRun(JSContext* aCx,
-                         WorkerPrivate* aWorkerPrivate) override;
-};
-
 template <typename Unit>
 static bool EvaluateSourceBuffer(JSContext* aCx,
                                  const JS::CompileOptions& aOptions,
@@ -582,10 +568,6 @@
     ThreadSafeRequestHandle* aRequestHandle, nsresult aRv) {
   AssertIsOnMainThread();
 
-  if (IsCancelled()) {
-    return;
-  }
-
   WorkerLoadContext* loadContext = aRequestHandle->GetContext();
 
   loadContext->mLoadResult = aRv;
@@ -692,9 +674,6 @@
     ThreadSafeRequestHandle* aRequestHandle, nsresult aStatus) {
   AssertIsOnMainThread();
 
-  // We expect our callers to runtime-check this in advance.
-  MOZ_ASSERT(!IsCancelled());
-
   LoadingFinished(aRequestHandle, aStatus);
   return NS_OK;
 }
@@ -708,46 +687,48 @@
 void WorkerScriptLoader::CancelMainThread(
     nsresult aCancelResult, nsTArray<ThreadSafeRequestHandle*>* aContextList) {
   AssertIsOnMainThread();
+  if (IsCancelled()) {
+    return;
+  }
   {
     MutexAutoLock lock(CleanUpLock());
 
     // Check if we have already cancelled, or if the worker has been killed
     // before we cancel.
-    if (IsCancelled() || CleanedUp()) {
+    if (CleanedUp()) {
       return;
     }
 
     mCancelMainThread = Some(aCancelResult);
 
-    bool shouldDispatch = false;
     for (ThreadSafeRequestHandle* handle : *aContextList) {
       if (handle->IsEmpty()) {
         continue;
       }
-      // In the case of a cancellation, service workers fetching from the
-      // cache will still be doing work despite CancelMainThread. Eagerly
-      // clear the promises associated with these scripts.
       WorkerLoadContext* loadContext = handle->GetContext();
       if (!loadContext) {
         continue;
       }
+
+      bool callLoadingFinished = true;
+
       if (loadContext->IsAwaitingPromise()) {
-        // This will trigger LoadingFinished if we do not set the cancel flag
-        // ahead of time. But, as we do that above, this should not be a
-        // concern.
         MOZ_ASSERT(mWorkerRef->Private()->IsServiceWorker());
         loadContext->mCachePromise->MaybeReject(NS_BINDING_ABORTED);
         loadContext->mCachePromise = nullptr;
-        shouldDispatch = true;
+        callLoadingFinished = false;
       }
-      // If at least one request has not been dispatched, we need to dispatch.
-      if (!loadContext->mLoadingFinished) {
-        shouldDispatch = true;
+      if (loadContext->mChannel) {
+        if (NS_SUCCEEDED(loadContext->mChannel->Cancel(aCancelResult))) {
+          callLoadingFinished = false;
+        } else {
+          NS_WARNING("Failed to cancel channel!");
+        }
       }
       loadContext->ClearCacheCreator();
-    }
-    if (shouldDispatch) {
-      DispatchAbruptShutdown();
+      if (callLoadingFinished && !loadContext->mLoadingFinished) {
+        LoadingFinished(handle, aCancelResult);
+      }
     }
   }
 }
@@ -1018,40 +999,6 @@
   return NS_OK;
 }
 
-void WorkerScriptLoader::DispatchAbruptShutdown() {
-  AssertIsOnMainThread();
-
-  RefPtr<AbruptCancellationRunnable> runnable =
-      new AbruptCancellationRunnable(this, mSyncLoopTarget);
-  if (!runnable->Dispatch()) {
-    MOZ_ASSERT(false, "This should never fail!");
-  }
-}
-
-void WorkerScriptLoader::AbruptShutdown() {
-  mWorkerRef->Private()->AssertIsOnWorkerThread();
-
-  // Move all requests to the loaded list
-  while (!mLoadingRequests.isEmpty()) {
-    ScriptLoadRequest* request = mLoadingRequests.getFirst();
-    RefPtr<ScriptLoadRequest> req = mLoadingRequests.Steal(request);
-    mLoadedRequests.AppendElement(req);
-  }
-
-  while (!mLoadedRequests.isEmpty()) {
-    RefPtr<ScriptLoadRequest> request = mLoadedRequests.StealFirst();
-    WorkerLoadContext* loadContext = request->GetWorkerLoadContext();
-    mRv.MightThrowJSException();
-    if (NS_FAILED(loadContext->mLoadResult)) {
-      ReportErrorToConsole(request, loadContext->mLoadResult);
-      break;
-    }
-  }
-
-  mLoadedRequests.CancelRequestsAndClear();
-  ShutdownScriptLoader(true, false);
-}
-
 bool WorkerScriptLoader::EvaluateScript(JSContext* aCx,
                                         ScriptLoadRequest* aRequest) {
   mWorkerRef->Private()->AssertIsOnWorkerThread();
@@ -1061,6 +1008,7 @@
   NS_ASSERTION(!loadContext->mChannel, "Should no longer have a channel!");
   NS_ASSERTION(aRequest->IsReadyToRun(), "Should be scheduled!");
 
+  MOZ_ASSERT(!mRv.Failed(), "Who failed it and why?");
   mRv.MightThrowJSException();
   if (NS_FAILED(loadContext->mLoadResult)) {
     ReportErrorToConsole(aRequest, loadContext->mLoadResult);
@@ -1209,25 +1157,6 @@
 
 NS_IMPL_ISUPPORTS(WorkerScriptLoader, nsINamed)
 
-AbruptCancellationRunnable::AbruptCancellationRunnable(
-    WorkerScriptLoader* aScriptLoader, nsISerialEventTarget* aSyncLoopTarget)
-    : MainThreadWorkerSyncRunnable(aScriptLoader->mWorkerRef->Private(),
-                                   aSyncLoopTarget),
-      mScriptLoader(aScriptLoader) {}
-
-bool AbruptCancellationRunnable::WorkerRun(JSContext* aCx,
-                                           WorkerPrivate* aWorkerPrivate) {
-  aWorkerPrivate->AssertIsOnWorkerThread();
-
-  // We must be on the same worker as we started on.
-  MOZ_ASSERT(
-      mScriptLoader->mSyncLoopTarget == mSyncLoopTarget,
-      "Unexpected SyncLoopTarget. Check if the sync loop was closed early");
-
-  mScriptLoader->AbruptShutdown();
-  return true;
-}
-
 ScriptExecutorRunnable::ScriptExecutorRunnable(
     WorkerScriptLoader* aScriptLoader, WorkerPrivate* aWorkerPrivate,
     nsISerialEventTarget* aSyncLoopTarget,