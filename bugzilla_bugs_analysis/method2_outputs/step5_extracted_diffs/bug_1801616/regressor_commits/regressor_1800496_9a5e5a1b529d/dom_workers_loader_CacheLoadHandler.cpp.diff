# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/loader/CacheLoadHandler.cpp
# Commit: 9a5e5a1b529d
# Full Hash: 9a5e5a1b529de42db783dc6f8720488c34b28c6e
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2022-11-18 15:46:32
# Regressor Bug: 1800496
# File Overlap Count: 2
# Description:
#   Bug 1800496 - Introduce ThreadSafeRequestHandle; r=asuth
#   
#   This introduces a new datastructure that wraps the ScriptLoadRequest. Previously, we were using the WorkerLoadContext to access the request, and we made it not cycle collected in order to make it safe across threads. This, of course, broke module behavior, as the cycle needs to be broken in more places, and things get rather complex.
#   
#   In the spirit of making everyone's life easier, the ThreadSafeRequestHandle exists as a way to move the request to the main thread, operate on it, and then return it to the worker. We no longer need to track and free the WorkerLoadContext. Once the ThreadSafeRequestHandle is returned to the worker, we release the request, and the handle is empty. There is a possibility that this will cause issues, so we should keep an eye on this. Alternatively, we can never release the ScriptLoadRequest and let the ThreadSafeRequestHandle clean it up on destruction.
# ==============================================================================

diff -r 879667e24ed7 -r 9a5e5a1b529d dom/workers/loader/CacheLoadHandler.cpp
--- a/dom/workers/loader/CacheLoadHandler.cpp	Fri Nov 18 10:02:25 2022 +0000
+++ b/dom/workers/loader/CacheLoadHandler.cpp	Fri Nov 18 10:02:25 2022 +0000
@@ -40,9 +40,9 @@
 
 NS_IMPL_ISUPPORTS0(CachePromiseHandler)
 
-CachePromiseHandler::CachePromiseHandler(WorkerScriptLoader* aLoader,
-                                         WorkerLoadContext* aLoadContext)
-    : mLoader(aLoader), mLoadContext(aLoadContext) {
+CachePromiseHandler::CachePromiseHandler(
+    WorkerScriptLoader* aLoader, ThreadSafeRequestHandle* aRequestHandle)
+    : mLoader(aLoader), mRequestHandle(aRequestHandle) {
   AssertIsOnMainThread();
   MOZ_ASSERT(mLoader);
 }
@@ -51,18 +51,21 @@
                                            JS::Handle<JS::Value> aValue,
                                            ErrorResult& aRv) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
+
   // May already have been canceled by CacheLoadHandler::Fail from
   // CancelMainThread.
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::WritingToCache ||
-             mLoadContext->mCacheStatus == WorkerLoadContext::Cancel);
-  MOZ_ASSERT_IF(mLoadContext->mCacheStatus == WorkerLoadContext::Cancel,
-                !mLoadContext->mCachePromise);
+  MOZ_ASSERT(loadContext->mCacheStatus == WorkerLoadContext::WritingToCache ||
+             loadContext->mCacheStatus == WorkerLoadContext::Cancel);
+  MOZ_ASSERT_IF(loadContext->mCacheStatus == WorkerLoadContext::Cancel,
+                !loadContext->mCachePromise);
 
-  if (mLoadContext->mCachePromise) {
-    mLoadContext->mCacheStatus = WorkerLoadContext::Cached;
-    mLoadContext->mCachePromise = nullptr;
-    if (mLoadContext->mRequest) {
-      mLoader->MaybeExecuteFinishedScripts(mLoadContext->mRequest);
+  if (loadContext->mCachePromise) {
+    loadContext->mCacheStatus = WorkerLoadContext::Cached;
+    loadContext->mCachePromise = nullptr;
+    if (loadContext->mRequest) {
+      mLoader->MaybeExecuteFinishedScripts(mRequestHandle);
     }
   }
 }
@@ -71,17 +74,20 @@
                                            JS::Handle<JS::Value> aValue,
                                            ErrorResult& aRv) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
+
   // May already have been canceled by CacheLoadHandler::Fail from
   // CancelMainThread.
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::WritingToCache ||
-             mLoadContext->mCacheStatus == WorkerLoadContext::Cancel);
-  mLoadContext->mCacheStatus = WorkerLoadContext::Cancel;
+  MOZ_ASSERT(loadContext->mCacheStatus == WorkerLoadContext::WritingToCache ||
+             loadContext->mCacheStatus == WorkerLoadContext::Cancel);
+  loadContext->mCacheStatus = WorkerLoadContext::Cancel;
 
-  mLoadContext->mCachePromise = nullptr;
+  loadContext->mCachePromise = nullptr;
 
   // This will delete the cache object and will call LoadingFinished() with an
   // error for each ongoing operation.
-  auto cacheCreator = mLoadContext->GetCacheCreator();
+  auto cacheCreator = loadContext->GetCacheCreator();
   if (cacheCreator) {
     cacheCreator->DeleteCache(NS_ERROR_FAILURE);
   }
@@ -226,10 +232,10 @@
 }
 
 CacheLoadHandler::CacheLoadHandler(ThreadSafeWorkerRef* aWorkerRef,
-                                   JS::loader::ScriptLoadRequest* aRequest,
+                                   ThreadSafeRequestHandle* aRequestHandle,
                                    bool aIsWorkerScript,
                                    WorkerScriptLoader* aLoader)
-    : mLoadContext(aRequest->GetWorkerLoadContext()),
+    : mRequestHandle(aRequestHandle),
       mLoader(aLoader),
       mWorkerRef(aWorkerRef),
       mIsWorkerScript(aIsWorkerScript),
@@ -249,6 +255,8 @@
 
 void CacheLoadHandler::Fail(nsresult aRv) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
   MOZ_ASSERT(NS_FAILED(aRv));
 
   if (mFailed) {
@@ -258,41 +266,41 @@
   mFailed = true;
 
   if (mPump) {
-    MOZ_ASSERT(mLoadContext->mCacheStatus ==
+    MOZ_ASSERT(loadContext->mCacheStatus ==
                WorkerLoadContext::ReadingFromCache);
     mPump->Cancel(aRv);
     mPump = nullptr;
   }
 
-  mLoadContext->mCacheStatus = WorkerLoadContext::Cancel;
+  loadContext->mCacheStatus = WorkerLoadContext::Cancel;
 
-  if (mLoadContext->mCachePromise) {
-    mLoadContext->mCachePromise->MaybeReject(aRv);
+  if (loadContext->mCachePromise) {
+    loadContext->mCachePromise->MaybeReject(aRv);
   }
 
-  mLoadContext->mCachePromise = nullptr;
+  loadContext->mCachePromise = nullptr;
 
-  mLoadContext->ClearCacheCreator();
-  if (mLoader->IsCancelled() || !mLoadContext->mRequest) {
+  loadContext->ClearCacheCreator();
+  if (mLoader->IsCancelled() || !loadContext->mRequest) {
     return;
   }
 
-  mLoader->LoadingFinished(mLoadContext->mRequest, aRv);
+  mLoader->LoadingFinished(mRequestHandle, aRv);
 }
 
 void CacheLoadHandler::Load(Cache* aCache) {
   AssertIsOnMainThread();
   MOZ_ASSERT(aCache);
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
 
   if (mLoader->IsCancelled()) {
     Fail(NS_BINDING_ABORTED);
     return;
   }
 
-  MOZ_ASSERT(mLoadContext->mRequest);
-
   nsCOMPtr<nsIURI> uri;
-  nsresult rv = NS_NewURI(getter_AddRefs(uri), mLoadContext->mRequest->mURL,
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), loadContext->mRequest->mURL,
                           nullptr, mBaseURI);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     Fail(rv);
@@ -306,11 +314,11 @@
     return;
   }
 
-  MOZ_ASSERT(mLoadContext->mFullURL.IsEmpty());
-  CopyUTF8toUTF16(spec, mLoadContext->mFullURL);
+  MOZ_ASSERT(loadContext->mFullURL.IsEmpty());
+  CopyUTF8toUTF16(spec, loadContext->mFullURL);
 
   mozilla::dom::RequestOrUSVString request;
-  request.SetAsUSVString().ShareOrDependUpon(mLoadContext->mFullURL);
+  request.SetAsUSVString().ShareOrDependUpon(loadContext->mFullURL);
 
   mozilla::dom::CacheQueryOptions params;
 
@@ -333,8 +341,10 @@
                                         JS::Handle<JS::Value> aValue,
                                         ErrorResult& aRv) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
 
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::Uncached);
+  MOZ_ASSERT(mRequestHandle->GetContext()->mCacheStatus ==
+             WorkerLoadContext::Uncached);
   Fail(NS_ERROR_FAILURE);
 }
 
@@ -342,6 +352,9 @@
                                         JS::Handle<JS::Value> aValue,
                                         ErrorResult& aRv) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
+
   // If we have already called 'Fail', we should not proceed. If we cancelled,
   // we should similarily not proceed.
   if (mFailed) {
@@ -352,7 +365,7 @@
     return;
   }
 
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::Uncached);
+  MOZ_ASSERT(loadContext->mCacheStatus == WorkerLoadContext::Uncached);
 
   nsresult rv;
 
@@ -374,8 +387,8 @@
       return;
     }
 
-    mLoadContext->mCacheStatus = WorkerLoadContext::ToBeCached;
-    rv = mLoader->LoadScript(mLoadContext->mRequest);
+    loadContext->mCacheStatus = WorkerLoadContext::ToBeCached;
+    rv = mLoader->LoadScript(mRequestHandle);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       Fail(rv);
     }
@@ -409,7 +422,7 @@
                           OriginTrial::CoepCredentialless));
 
   rv = ScriptResponseHeaderProcessor::ProcessCrossOriginEmbedderPolicyHeader(
-      mWorkerRef->Private(), coep, mLoadContext->IsTopLevel());
+      mWorkerRef->Private(), coep, loadContext->IsTopLevel());
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     Fail(rv);
@@ -425,14 +438,14 @@
   }
 
   if (!inputStream) {
-    mLoadContext->mCacheStatus = WorkerLoadContext::Cached;
+    loadContext->mCacheStatus = WorkerLoadContext::Cached;
 
     if (mLoader->IsCancelled()) {
-      auto cacheCreator = mLoadContext->GetCacheCreator();
+      auto cacheCreator = loadContext->GetCacheCreator();
       if (cacheCreator) {
         cacheCreator->DeleteCache(mLoader->GetCancelResult());
       }
-      mLoadContext->ClearCacheCreator();
+      loadContext->ClearCacheCreator();
       return;
     }
 
@@ -440,8 +453,8 @@
         (uint8_t*)"", 0, mChannelInfo, std::move(mPrincipalInfo),
         mCSPHeaderValue, mCSPReportOnlyHeaderValue, mReferrerPolicyHeaderValue);
 
-    mLoadContext->ClearCacheCreator();
-    mLoader->OnStreamComplete(mLoadContext->mRequest, rv);
+    loadContext->ClearCacheCreator();
+    mLoader->OnStreamComplete(mRequestHandle, rv);
     return;
   }
 
@@ -480,7 +493,7 @@
     }
   }
 
-  mLoadContext->mCacheStatus = WorkerLoadContext::ReadingFromCache;
+  loadContext->mCacheStatus = WorkerLoadContext::ReadingFromCache;
 }
 
 NS_IMETHODIMP
@@ -489,31 +502,33 @@
                                    uint32_t aStringLen,
                                    const uint8_t* aString) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
 
   mPump = nullptr;
 
   if (NS_FAILED(aStatus)) {
-    MOZ_ASSERT(mLoadContext->mCacheStatus ==
+    MOZ_ASSERT(loadContext->mCacheStatus ==
                    WorkerLoadContext::ReadingFromCache ||
-               mLoadContext->mCacheStatus == WorkerLoadContext::Cancel);
+               loadContext->mCacheStatus == WorkerLoadContext::Cancel);
     Fail(aStatus);
     return NS_OK;
   }
 
-  if (mLoader->IsCancelled() || !mLoadContext->mRequest) {
+  if (mLoader->IsCancelled() || !loadContext->mRequest) {
     Fail(NS_BINDING_ABORTED);
     return NS_OK;
   }
 
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::ReadingFromCache);
-  mLoadContext->mCacheStatus = WorkerLoadContext::Cached;
+  MOZ_ASSERT(loadContext->mCacheStatus == WorkerLoadContext::ReadingFromCache);
+  loadContext->mCacheStatus = WorkerLoadContext::Cached;
 
   MOZ_ASSERT(mPrincipalInfo);
 
   nsresult rv = DataReceivedFromCache(
       aString, aStringLen, mChannelInfo, std::move(mPrincipalInfo),
       mCSPHeaderValue, mCSPReportOnlyHeaderValue, mReferrerPolicyHeaderValue);
-  return mLoader->OnStreamComplete(mLoadContext->mRequest, rv);
+  return mLoader->OnStreamComplete(mRequestHandle, rv);
 }
 
 nsresult CacheLoadHandler::DataReceivedFromCache(
@@ -523,9 +538,11 @@
     const nsACString& aCSPReportOnlyHeaderValue,
     const nsACString& aReferrerPolicyHeaderValue) {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
 
-  MOZ_ASSERT(mLoadContext->mCacheStatus == WorkerLoadContext::Cached);
-  MOZ_ASSERT(mLoadContext->mRequest);
+  MOZ_ASSERT(loadContext->mCacheStatus == WorkerLoadContext::Cached);
+  MOZ_ASSERT(loadContext->mRequest);
 
   auto responsePrincipalOrErr = PrincipalInfoToPrincipal(*aPrincipalInfo);
   MOZ_DIAGNOSTIC_ASSERT(responsePrincipalOrErr.isOk());
@@ -539,8 +556,7 @@
 
   nsCOMPtr<nsIPrincipal> responsePrincipal = responsePrincipalOrErr.unwrap();
 
-  mLoadContext->mMutedErrorFlag.emplace(
-      !principal->Subsumes(responsePrincipal));
+  loadContext->mMutedErrorFlag.emplace(!principal->Subsumes(responsePrincipal));
 
   // May be null.
   Document* parentDoc = mWorkerRef->Private()->GetDocument();
@@ -550,21 +566,21 @@
   nsresult rv;
 
   // Set the Source type to "text" for decoding.
-  mLoadContext->mRequest->SetTextSource();
+  loadContext->mRequest->SetTextSource();
 
-  rv = mDecoder->DecodeRawData(mLoadContext->mRequest, aString, aStringLen,
+  rv = mDecoder->DecodeRawData(loadContext->mRequest, aString, aStringLen,
                                /* aEndOfStream = */ true);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (!mLoadContext->mRequest->ScriptTextLength()) {
+  if (!loadContext->mRequest->ScriptTextLength()) {
     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag, "DOM"_ns,
                                     parentDoc, nsContentUtils::eDOM_PROPERTIES,
                                     "EmptyWorkerSourceWarning");
   }
 
-  if (mLoadContext->IsTopLevel()) {
+  if (loadContext->IsTopLevel()) {
     nsCOMPtr<nsIURI> finalURI;
-    rv = NS_NewURI(getter_AddRefs(finalURI), mLoadContext->mFullURL);
+    rv = NS_NewURI(getter_AddRefs(finalURI), loadContext->mFullURL);
     if (NS_SUCCEEDED(rv)) {
       mWorkerRef->Private()->SetBaseURI(finalURI);
     }
@@ -617,7 +633,10 @@
 }
 
 void CacheLoadHandler::DataReceived() {
-  if (mLoadContext->IsTopLevel()) {
+  MOZ_ASSERT(!mRequestHandle->IsEmpty());
+  WorkerLoadContext* loadContext = mRequestHandle->GetContext();
+
+  if (loadContext->IsTopLevel()) {
     WorkerPrivate* parent = mWorkerRef->Private()->GetParent();
 
     if (parent) {