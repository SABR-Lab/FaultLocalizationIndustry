# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaDecoderStateMachine.cpp
# Commit: 1dd4093cd374
# Full Hash: 1dd4093cd3749e083a87f4a99905678db85e48a7
# Author: alwu <alwu@mozilla.com>
# Date: 2022-11-05 21:53:50
# Regressor Bug: 1262276
# File Overlap Count: 1
# Description:
#   Bug 1262276 - part5 : only seek one track at a time otherwise the previous seek target would be overwritten. r=padenot
#   
#   The media format reader's seek doesn't support seeking in parallel, so
#   that is why the format reader would seek video first, then audio.
#   
# ==============================================================================

diff -r 6672431765dc -r 1dd4093cd374 dom/media/MediaDecoderStateMachine.cpp
--- a/dom/media/MediaDecoderStateMachine.cpp	Sat Nov 05 02:23:30 2022 +0000
+++ b/dom/media/MediaDecoderStateMachine.cpp	Sat Nov 05 02:23:30 2022 +0000
@@ -819,7 +819,7 @@
 /**
  * Purpose: decode audio data for playback when media is in seamless
  * looping, we will adjust media time to make samples time monotonically
- * increasing.
+ * increasing. All its methods runs on its owner thread (MDSM thread).
  *
  * Transition to:
  *   DORMANT if playback is paused for a while.
@@ -946,6 +946,15 @@
     const bool isAudio = aType == TrackInfo::TrackType::kAudioTrack;
     MOZ_ASSERT_IF(isAudio, mMaster->HasAudio());
     MOZ_ASSERT_IF(!isAudio, mMaster->HasVideo());
+
+    if (IsReaderSeeking()) {
+      MOZ_ASSERT(!mPendingSeekingType);
+      mPendingSeekingType = Some(aType);
+      SLOG("Delay %s seeking until the reader finishes current seeking",
+           isAudio ? "audio" : "video");
+      return;
+    }
+
     auto& seekRequest = isAudio ? mAudioSeekRequest : mVideoSeekRequest;
     Reader()->ResetDecode(aType);
     Reader()
@@ -979,6 +988,12 @@
               } else {
                 RequestVideoDataFromReader();
               }
+              if (mPendingSeekingType) {
+                auto seekingType = *mPendingSeekingType;
+                mPendingSeekingType.reset();
+                SLOG("Perform pending %s seeking", TrackTypeToStr(seekingType));
+                RequestDataFromStartPosition(seekingType);
+              }
             },
             [this, isAudio](const SeekRejectValue& aReject) mutable -> void {
               AUTO_PROFILER_LABEL(
@@ -1228,6 +1243,10 @@
     return !isWaitingForNewData && DecodingState::ShouldStopPrerolling();
   }
 
+  bool IsReaderSeeking() const {
+    return mAudioSeekRequest.Exists() || mVideoSeekRequest.Exists();
+  }
+
   bool mIsReachingAudioEOS;
   bool mIsReachingVideoEOS;
   media::TimeUnit mAudioLoopingOffset = media::TimeUnit::Zero();
@@ -1236,6 +1255,9 @@
   MozPromiseRequestHolder<MediaFormatReader::SeekPromise> mVideoSeekRequest;
   MozPromiseRequestHolder<AudioDataPromise> mAudioDataRequest;
   MozPromiseRequestHolder<VideoDataPromise> mVideoDataRequest;
+  // The media format reader only allows seeking a track at a time, if we're
+  // already in seeking, then delay the new seek until the current one finishes.
+  Maybe<TrackInfo::TrackType> mPendingSeekingType;
 };
 
 /**
