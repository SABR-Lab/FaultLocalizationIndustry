# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaDecoderStateMachine.cpp
# Commit: 44e50217fdc9
# Full Hash: 44e50217fdc9be7470b9bd57c3d0af52e7f8c303
# Author: alwu <alwu@mozilla.com>
# Date: 2022-11-05 21:53:50
# Regressor Bug: 1262276
# File Overlap Count: 1
# Description:
#   Bug 1262276 - part11 : stop prerolling if the track data is waiting for the timestamp adjustment. r=padenot
#   
#   For pretty short media, (eg. gizmo-short.mp4), after reaching audio EOS,
#   the next audio sample would be put on waiting because we can't adjust
#   its timestamp yet.
# ==============================================================================

diff -r abd21243cfda -r 44e50217fdc9 dom/media/MediaDecoderStateMachine.cpp
--- a/dom/media/MediaDecoderStateMachine.cpp	Sat Nov 05 02:23:32 2022 +0000
+++ b/dom/media/MediaDecoderStateMachine.cpp	Sat Nov 05 02:23:32 2022 +0000
@@ -691,8 +691,26 @@
 
   virtual bool ShouldStopPrerolling() const {
     return mIsPrerolling &&
-           (DonePrerollingAudio() || mMaster->IsWaitingAudioData()) &&
-           (DonePrerollingVideo() || mMaster->IsWaitingVideoData());
+           (DonePrerollingAudio() ||
+            IsWaitingData(MediaData::Type::AUDIO_DATA)) &&
+           (DonePrerollingVideo() ||
+            IsWaitingData(MediaData::Type::VIDEO_DATA));
+  }
+
+  virtual bool IsWaitingData(MediaData::Type aType) const {
+    if (aType == MediaData::Type::AUDIO_DATA) {
+      return mMaster->IsWaitingAudioData();
+    }
+    MOZ_ASSERT(aType == MediaData::Type::VIDEO_DATA);
+    return mMaster->IsWaitingVideoData();
+  }
+
+  void MaybeStopPrerolling() {
+    if (ShouldStopPrerolling()) {
+      mIsPrerolling = false;
+      // Check if we can start playback.
+      mMaster->ScheduleStateMachine();
+    }
   }
 
  private:
@@ -728,14 +746,6 @@
                VideoPrerollFrames();
   }
 
-  void MaybeStopPrerolling() {
-    if (ShouldStopPrerolling()) {
-      mIsPrerolling = false;
-      // Check if we can start playback.
-      mMaster->ScheduleStateMachine();
-    }
-  }
-
   void StartDormantTimer() {
     if (!mMaster->mMediaSeekable) {
       // Don't enter dormant if the media is not seekable because we need to
@@ -1311,6 +1321,7 @@
     SLOG("put %s [%" PRId64 ",%" PRId64 "] on waiting",
          MediaData::TypeToStr(aData->mType), aData->mTime.ToMicroseconds(),
          aData->GetEndTime().ToMicroseconds());
+    MaybeStopPrerolling();
   }
 
   MediaResult LoopingAudioTimeAdjustment(AudioData* aAudio) {
@@ -1440,6 +1451,16 @@
     return mAudioSeekRequest.Exists() || mVideoSeekRequest.Exists();
   }
 
+  bool IsWaitingData(MediaData::Type aType) const override {
+    if (aType == MediaData::Type::AUDIO_DATA) {
+      return mMaster->IsWaitingAudioData() ||
+             IsDataWaitingForTimestampAdjustment(MediaData::Type::AUDIO_DATA);
+    }
+    MOZ_DIAGNOSTIC_ASSERT(aType == MediaData::Type::VIDEO_DATA);
+    return mMaster->IsWaitingVideoData() ||
+           IsDataWaitingForTimestampAdjustment(MediaData::Type::VIDEO_DATA);
+  }
+
   bool mIsReachingAudioEOS;
   bool mIsReachingVideoEOS;
 
