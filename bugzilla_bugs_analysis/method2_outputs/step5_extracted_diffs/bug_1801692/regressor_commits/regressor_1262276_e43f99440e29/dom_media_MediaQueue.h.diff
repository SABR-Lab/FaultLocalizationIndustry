# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaQueue.h
# Commit: e43f99440e29
# Full Hash: e43f99440e29c03afab556ee878159a00d46bae1
# Author: alwu <alwu@mozilla.com>
# Date: 2022-11-05 21:53:50
# Regressor Bug: 1262276
# File Overlap Count: 1
# Description:
#   Bug 1262276 - part12 : store looping offset in the media queue in order to keep timestamp consistantly increasing across different states. r=padenot
#   
#   When leaving looping state to another state, media data stored in the
#   media queue are already adjusted. If the new state requests a new data
#   but doesn't adjust its timestamp, then the data in the media queue will
# ==============================================================================

diff -r 44e50217fdc9 -r e43f99440e29 dom/media/MediaQueue.h
--- a/dom/media/MediaQueue.h	Sat Nov 05 02:23:32 2022 +0000
+++ b/dom/media/MediaQueue.h	Sat Nov 05 02:23:33 2022 +0000
@@ -17,7 +17,34 @@
 
 namespace mozilla {
 
+extern LazyLogModule gMediaDecoderLog;
+
+#  define QLOG(msg, ...)                       \
+    MOZ_LOG(gMediaDecoderLog, LogLevel::Debug, \
+            ("MediaQueue=%p " msg, this, ##__VA_ARGS__))
+
 class AudioData;
+class VideoData;
+
+template <typename T>
+struct TimestampAdjustmentTrait {
+  static const bool mValue = false;
+};
+
+template <>
+struct TimestampAdjustmentTrait<AudioData> {
+  static const bool mValue = true;
+};
+
+template <>
+struct TimestampAdjustmentTrait<VideoData> {
+  static const bool mValue = true;
+};
+
+template <typename T>
+struct NonTimestampAdjustmentTrait {
+  static const bool mValue = !TimestampAdjustmentTrait<T>::mValue;
+};
 
 template <class T>
 class MediaQueue : private nsRefPtrDeque<T> {
@@ -34,8 +61,34 @@
     return nsRefPtrDeque<T>::GetSize();
   }
 
+  template <typename U,
+            std::enable_if_t<TimestampAdjustmentTrait<U>::mValue, bool> = true>
+  inline void AdjustTimeStampIfNeeded(U* aItem) {
+    static_assert(std::is_same_v<U, AudioData> || std::is_same_v<U, VideoData>);
+    if (mOffset != media::TimeUnit::Zero()) {
+      const auto prev = aItem->mTime, prevEndTime = aItem->GetEndTime();
+      aItem->mTime += mOffset;
+      if (!aItem->mTime.IsValid()) {
+        NS_WARNING("Reverting timestamp adjustment due to sample overflow!");
+        aItem->mTime = prev;
+      } else {
+        QLOG("adjusted %s sample [%" PRId64 ",%" PRId64 "] -> [%" PRId64
+             ",%" PRId64 "]",
+             std::is_same_v<U, AudioData> ? "audio" : "video",
+             prev.ToMicroseconds(), prevEndTime.ToMicroseconds(),
+             aItem->mTime.ToMicroseconds(),
+             aItem->GetEndTime().ToMicroseconds());
+      }
+    }
+  }
+
+  template <typename U, std::enable_if_t<NonTimestampAdjustmentTrait<U>::mValue,
+                                         bool> = true>
+  inline void AdjustTimeStampIfNeeded(U* aItem) {}
+
   inline void PushFront(T* aItem) {
     RecursiveMutexAutoLock lock(mRecursiveMutex);
+    AdjustTimeStampIfNeeded(aItem);
     nsRefPtrDeque<T>::PushFront(aItem);
   }
 
@@ -50,6 +103,7 @@
 
     MOZ_DIAGNOSTIC_ASSERT(item);
     MOZ_DIAGNOSTIC_ASSERT(item->GetEndTime() >= item->mTime);
+    AdjustTimeStampIfNeeded(item);
     nsRefPtrDeque<T>::Push(dont_AddRef(item));
     mPushEvent.Notify(RefPtr<T>(item));
 
@@ -88,6 +142,7 @@
   void Reset() {
     RecursiveMutexAutoLock lock(mRecursiveMutex);
     nsRefPtrDeque<T>::Erase();
+    SetOffset(media::TimeUnit::Zero());
     mEndOfStream = false;
   }
 
@@ -154,6 +209,22 @@
     return frames;
   }
 
+  bool SetOffset(const media::TimeUnit& aOffset) {
+    if (!aOffset.IsValid()) {
+      QLOG("Invalid offset!");
+      return false;
+    }
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
+    mOffset = aOffset;
+    QLOG("Set media queue offset %" PRId64, mOffset.ToMicroseconds());
+    return true;
+  }
+
+  media::TimeUnit GetOffset() const {
+    RecursiveMutexAutoLock lock(mRecursiveMutex);
+    return mOffset;
+  }
+
   MediaEventSource<RefPtr<T>>& PopFrontEvent() { return mPopFrontEvent; }
 
   MediaEventSource<RefPtr<T>>& PushEvent() { return mPushEvent; }
@@ -186,8 +257,14 @@
   // True when we've decoded the last frame of data in the
   // bitstream for which we're queueing frame data.
   bool mEndOfStream;
+  // This offset will be added to any data pushed into the queue. We use it when
+  // the media queue starts receiving looped data, which timestamp needs to be
+  // modified.
+  media::TimeUnit mOffset;
 };
 
 }  // namespace mozilla
 
+#  undef QLOG
+
 #endif