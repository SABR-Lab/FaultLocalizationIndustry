# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/gtest/TestMediaQueue.cpp
# Commit: e43f99440e29
# Full Hash: e43f99440e29c03afab556ee878159a00d46bae1
# Author: alwu <alwu@mozilla.com>
# Date: 2022-11-05 21:53:50
# Regressor Bug: 1262276
# File Overlap Count: 1
# Description:
#   Bug 1262276 - part12 : store looping offset in the media queue in order to keep timestamp consistantly increasing across different states. r=padenot
#   
#   When leaving looping state to another state, media data stored in the
#   media queue are already adjusted. If the new state requests a new data
#   but doesn't adjust its timestamp, then the data in the media queue will
# ==============================================================================

diff -r 44e50217fdc9 -r e43f99440e29 dom/media/gtest/TestMediaQueue.cpp
--- a/dom/media/gtest/TestMediaQueue.cpp	Sat Nov 05 02:23:32 2022 +0000
+++ b/dom/media/gtest/TestMediaQueue.cpp	Sat Nov 05 02:23:33 2022 +0000
@@ -10,10 +10,23 @@
 using namespace mozilla;
 using mozilla::media::TimeUnit;
 
-MediaData* CreateDataRawPtr(int64_t aStartTime, int64_t aEndTime) {
+MediaData* CreateDataRawPtr(
+    int64_t aStartTime, int64_t aEndTime,
+    MediaData::Type aType = MediaData::Type::NULL_DATA) {
   const TimeUnit startTime = TimeUnit::FromMicroseconds(aStartTime);
   const TimeUnit endTime = TimeUnit::FromMicroseconds(aEndTime);
-  return new NullData(0, startTime, endTime - startTime);
+  MediaData* data;
+  if (aType == MediaData::Type::AUDIO_DATA) {
+    AlignedAudioBuffer samples;
+    data = new AudioData(0, startTime, std::move(samples), 2, 44100);
+    data->mDuration = endTime - startTime;
+  } else if (aType == MediaData::Type::VIDEO_DATA) {
+    data = new VideoData(0, startTime, endTime - startTime, true, startTime,
+                         gfx::IntSize(), 0);
+  } else {
+    data = new NullData(0, startTime, endTime - startTime);
+  }
+  return data;
 }
 
 already_AddRefed<MediaData> CreateData(int64_t aStartTime, int64_t aEndTime) {
@@ -196,4 +209,80 @@
   EXPECT_TRUE(emptyResult.IsEmpty());
 }
 
+TEST(MediaQueue, TimestampAdjustmentForSupportDataType)
+{
+  const size_t kOffSet = 30;
+  {
+    MediaQueue<AudioData> audioQueue;
+    audioQueue.Push(
+        CreateDataRawPtr(0, 10, MediaData::Type::AUDIO_DATA)->As<AudioData>());
+    audioQueue.SetOffset(TimeUnit::FromMicroseconds(kOffSet));
+    audioQueue.Push(
+        CreateDataRawPtr(0, 10, MediaData::Type::AUDIO_DATA)->As<AudioData>());
+
+    // Data stored before setting the offset shouldn't be changed
+    RefPtr<AudioData> data = audioQueue.PopFront();
+    EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+    EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+
+    // Data stored after setting the offset should be changed
+    data = audioQueue.PopFront();
+    EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0 + kOffSet));
+    EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10 + kOffSet));
+
+    // Reset will clean the offset.
+    audioQueue.Reset();
+    audioQueue.Push(
+        CreateDataRawPtr(0, 10, MediaData::Type::AUDIO_DATA)->As<AudioData>());
+    data = audioQueue.PopFront();
+    EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+    EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+  }
+
+  // Check another supported type
+  MediaQueue<VideoData> videoQueue;
+  videoQueue.Push(
+      CreateDataRawPtr(0, 10, MediaData::Type::VIDEO_DATA)->As<VideoData>());
+  videoQueue.SetOffset(TimeUnit::FromMicroseconds(kOffSet));
+  videoQueue.Push(
+      CreateDataRawPtr(0, 10, MediaData::Type::VIDEO_DATA)->As<VideoData>());
+
+  // Data stored before setting the offset shouldn't be changed
+  RefPtr<VideoData> data = videoQueue.PopFront();
+  EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+  EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+
+  // Data stored after setting the offset should be changed
+  data = videoQueue.PopFront();
+  EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0 + kOffSet));
+  EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10 + kOffSet));
+
+  // Reset will clean the offset.
+  videoQueue.Reset();
+  videoQueue.Push(
+      CreateDataRawPtr(0, 10, MediaData::Type::VIDEO_DATA)->As<VideoData>());
+  data = videoQueue.PopFront();
+  EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+  EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+}
+
+TEST(MediaQueue, TimestampAdjustmentForNotSupportDataType)
+{
+  const size_t kOffSet = 30;
+
+  MediaQueue<MediaData> queue;
+  queue.Push(CreateDataRawPtr(0, 10));
+  queue.SetOffset(TimeUnit::FromMicroseconds(kOffSet));
+  queue.Push(CreateDataRawPtr(0, 10));
+
+  // Offset won't affect any data at all.
+  RefPtr<MediaData> data = queue.PopFront();
+  EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+  EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+
+  data = queue.PopFront();
+  EXPECT_EQ(data->mTime, TimeUnit::FromMicroseconds(0));
+  EXPECT_EQ(data->GetEndTime(), TimeUnit::FromMicroseconds(10));
+}
+
 #undef EXPECT_EQUAL_SIZE_T
