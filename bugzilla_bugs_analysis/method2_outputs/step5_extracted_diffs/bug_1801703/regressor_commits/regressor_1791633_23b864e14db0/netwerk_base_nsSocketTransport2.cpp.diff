# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/nsSocketTransport2.cpp
# Commit: 23b864e14db0
# Full Hash: 23b864e14db0cf874d0e126b6299c8c44922dde3
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-16 09:31:06
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r 0bcba3375ec0 -r 23b864e14db0 netwerk/base/nsSocketTransport2.cpp
--- a/netwerk/base/nsSocketTransport2.cpp	Tue Nov 15 20:03:29 2022 +0000
+++ b/netwerk/base/nsSocketTransport2.cpp	Tue Nov 15 20:03:29 2022 +0000
@@ -47,7 +47,7 @@
 
 #if defined(FUZZING)
 #  include "FuzzyLayer.h"
-#  include "FuzzySecurityInfo.h"
+#  include "FuzzySocketControl.h"
 #  include "mozilla/StaticPrefs_fuzzing.h"
 #endif
 
@@ -1173,19 +1173,13 @@
     // info
     bool isSSL = mTypes[i].EqualsLiteral("ssl");
     if (isSSL || mTypes[i].EqualsLiteral("starttls")) {
-      // remember security info and give notification callbacks to PSM...
-      nsCOMPtr<nsIInterfaceRequestor> callbacks;
+      // remember security info
       {
         MutexAutoLock lock(mLock);
         mTLSSocketControl = tlsSocketControl;
-        callbacks = mCallbacks;
         SOCKET_LOG(("  [tlsSocketControl=%p callbacks=%p]\n",
                     mTLSSocketControl.get(), mCallbacks.get()));
       }
-      // don't call into PSM while holding mLock!!
-      if (tlsSocketControl) {
-        tlsSocketControl->SetNotificationCallbacks(callbacks);
-      }
       // remember if socket type is SSL so we can ProxyStartSSL if need be.
       usingSSL = isSSL;
     } else if (mTypes[i].EqualsLiteral("socks") ||
@@ -1335,7 +1329,7 @@
     SOCKET_LOG(("Successfully attached fuzzing IOLayer.\n"));
 
     if (usingSSL) {
-      mTLSSocketControl = new FuzzySecurityInfo();
+      mTLSSocketControl = new FuzzySocketControl();
     }
   }
 #endif
@@ -2233,13 +2227,6 @@
     mDNSRecord->ReportUnusable(SocketPort());
   }
 
-  // break any potential reference cycle between the security info object
-  // and ourselves by resetting its notification callbacks object.  see
-  // bug 285991 for details.
-  if (mTLSSocketControl) {
-    mTLSSocketControl->SetNotificationCallbacks(nullptr);
-  }
-
   // finally, release our reference to the socket (must do this within
   // the transport lock) possibly closing the socket. Also release our
   // listeners to break potential refcount cycles.
@@ -2420,22 +2407,10 @@
   NS_NewNotificationCallbacksAggregation(callbacks, nullptr,
                                          GetCurrentEventTarget(),
                                          getter_AddRefs(threadsafeCallbacks));
-
-  nsCOMPtr<nsITLSSocketControl> tlsSocketControl;
-  {
-    MutexAutoLock lock(mLock);
-    mCallbacks = threadsafeCallbacks;
-    SOCKET_LOG(("Reset callbacks for tlsSocketInfo=%p callbacks=%p\n",
-                mTLSSocketControl.get(), mCallbacks.get()));
-
-    tlsSocketControl = mTLSSocketControl;
-  }
-
-  // don't call into PSM while holding mLock!!
-  if (tlsSocketControl) {
-    tlsSocketControl->SetNotificationCallbacks(threadsafeCallbacks);
-  }
-
+  MutexAutoLock lock(mLock);
+  mCallbacks = threadsafeCallbacks;
+  SOCKET_LOG(("Reset callbacks for tlsSocketInfo=%p callbacks=%p\n",
+              mTLSSocketControl.get(), mCallbacks.get()));
   return NS_OK;
 }
 