# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/nsHttpConnectionMgr.cpp
# Commit: 23b864e14db0
# Full Hash: 23b864e14db0cf874d0e126b6299c8c44922dde3
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-16 09:31:06
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r 0bcba3375ec0 -r 23b864e14db0 netwerk/protocol/http/nsHttpConnectionMgr.cpp
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp	Tue Nov 15 20:03:29 2022 +0000
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp	Tue Nov 15 20:03:29 2022 +0000
@@ -15,7 +15,10 @@
 #include <algorithm>
 #include <utility>
 
+#include "ConnectionHandle.h"
+#include "HttpConnectionUDP.h"
 #include "NullHttpTransaction.h"
+#include "SpeculativeTransaction.h"
 #include "mozilla/Components.h"
 #include "mozilla/SpinEventLoopUntil.h"
 #include "mozilla/StaticPrefs_network.h"
@@ -28,10 +31,11 @@
 #include "nsHttpHandler.h"
 #include "nsIClassOfService.h"
 #include "nsIDNSByTypeRecord.h"
+#include "nsIDNSListener.h"
 #include "nsIDNSRecord.h"
-#include "nsIDNSListener.h"
 #include "nsIDNSService.h"
 #include "nsIHttpChannelInternal.h"
+#include "nsIPipe.h"
 #include "nsIRequestContext.h"
 #include "nsISocketTransport.h"
 #include "nsISocketTransportService.h"
@@ -39,11 +43,11 @@
 #include "nsIXPConnect.h"
 #include "nsInterfaceRequestorAgg.h"
 #include "nsNetCID.h"
+#include "nsNetSegmentUtils.h"
 #include "nsNetUtil.h"
 #include "nsQueryObject.h"
-#include "ConnectionHandle.h"
-#include "HttpConnectionUDP.h"
-#include "SpeculativeTransaction.h"
+#include "nsSocketTransportService2.h"
+#include "nsStreamUtils.h"
 
 namespace mozilla::net {
 
@@ -2475,8 +2479,42 @@
   }
 
   RefPtr<nsCompleteUpgradeData> upgradeData(data);
-  auto transportAvailableFunc = [upgradeData{std::move(upgradeData)},
-                                 aRv(rv)]() {
+
+  nsCOMPtr<nsIAsyncInputStream> socketIn;
+  nsCOMPtr<nsIAsyncOutputStream> socketOut;
+
+  // If this is for JS, the input and output sockets need to be piped over the
+  // socket thread. Otherwise, the JS may attempt to read and/or write the
+  // sockets on the main thread, which could cause network I/O on the main
+  // thread. This is particularly bad in the case of TLS connections, because
+  // PSM and NSS rely on those connections only being used on the socket
+  // thread.
+  if (data->mJsWrapped) {
+    nsCOMPtr<nsIAsyncInputStream> pipeIn;
+    uint32_t segsize = 0;
+    uint32_t segcount = 0;
+    net_ResolveSegmentParams(segsize, segcount);
+    if (NS_SUCCEEDED(rv)) {
+      NS_NewPipe2(getter_AddRefs(pipeIn), getter_AddRefs(socketOut), true, true,
+                  segsize, segcount);
+      rv = NS_AsyncCopy(pipeIn, data->mSocketOut, gSocketTransportService,
+                        NS_ASYNCCOPY_VIA_READSEGMENTS, segsize);
+    }
+
+    nsCOMPtr<nsIAsyncOutputStream> pipeOut;
+    if (NS_SUCCEEDED(rv)) {
+      NS_NewPipe2(getter_AddRefs(socketIn), getter_AddRefs(pipeOut), true, true,
+                  segsize, segcount);
+      rv = NS_AsyncCopy(data->mSocketIn, pipeOut, gSocketTransportService,
+                        NS_ASYNCCOPY_VIA_WRITESEGMENTS, segsize);
+    }
+  } else {
+    socketIn = upgradeData->mSocketIn;
+    socketOut = upgradeData->mSocketOut;
+  }
+
+  auto transportAvailableFunc = [upgradeData{std::move(upgradeData)}, socketIn,
+                                 socketOut, aRv(rv)]() {
     // Handle any potential previous errors first
     // and call OnUpgradeFailed if necessary.
     nsresult rv = aRv;
@@ -2493,8 +2531,7 @@
     }
 
     rv = upgradeData->mUpgradeListener->OnTransportAvailable(
-        upgradeData->mSocketTransport, upgradeData->mSocketIn,
-        upgradeData->mSocketOut);
+        upgradeData->mSocketTransport, socketIn, socketOut);
     if (NS_FAILED(rv)) {
       LOG(
           ("nsHttpConnectionMgr::OnMsgCompleteUpgrade OnTransportAvailable "