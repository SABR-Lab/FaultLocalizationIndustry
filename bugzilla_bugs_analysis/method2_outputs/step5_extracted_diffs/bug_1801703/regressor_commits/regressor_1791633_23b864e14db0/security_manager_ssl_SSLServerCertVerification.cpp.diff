# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/manager/ssl/SSLServerCertVerification.cpp
# Commit: 23b864e14db0
# Full Hash: 23b864e14db0cf874d0e126b6299c8c44922dde3
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-16 09:31:06
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r 0bcba3375ec0 -r 23b864e14db0 security/manager/ssl/SSLServerCertVerification.cpp
--- a/security/manager/ssl/SSLServerCertVerification.cpp	Tue Nov 15 20:03:29 2022 +0000
+++ b/security/manager/ssl/SSLServerCertVerification.cpp	Tue Nov 15 20:03:29 2022 +0000
@@ -65,11 +65,10 @@
 //
 // SSLServerCertVerificationResult must be dispatched to the socket transport
 // thread because we must only call SSL_* functions on the socket transport
-// thread since they may do I/O, because many parts of NSSSocketControl (the
-// subclass of TransportSecurityInfo used when validating certificates during
-// an SSL handshake) and the PSM NSS I/O layer are not thread-safe, and because
-// we need the event to interrupt the PR_Poll that may waiting for I/O on the
-// socket for which we are validating the cert.
+// thread since they may do I/O, because many parts of NSSSocketControl and the
+// PSM NSS I/O layer are not thread-safe, and because we need the event to
+// interrupt the PR_Poll that may waiting for I/O on the socket for which we
+// are validating the cert.
 //
 // When socket process is enabled, libssl is running on socket process. To
 // perform certificate authentication with CertVerifier, we have to send all
@@ -105,7 +104,6 @@
 #include "ScopedNSSTypes.h"
 #include "SharedCertVerifier.h"
 #include "SharedSSLState.h"
-#include "TransportSecurityInfo.h"
 #include "VerifySSLServerCertChild.h"
 #include "cert.h"
 #include "mozilla/Assertions.h"
@@ -383,16 +381,23 @@
 // Prohibit changing the server cert only if we negotiated SPDY,
 // in order to support SPDY's cross-origin connection pooling.
 static SECStatus BlockServerCertChangeForSpdy(
-    NSSSocketControl* infoObject, const UniqueCERTCertificate& serverCert) {
-  if (!infoObject->IsHandshakeCompleted()) {
+    NSSSocketControl* socketControl, const UniqueCERTCertificate& serverCert) {
+  if (!socketControl->IsHandshakeCompleted()) {
     // first handshake on this connection, not a
     // renegotiation.
     return SECSuccess;
   }
 
   // Filter out sockets that did not neogtiate SPDY via NPN
+  nsCOMPtr<nsITransportSecurityInfo> securityInfo;
+  nsresult rv = socketControl->GetSecurityInfo(getter_AddRefs(securityInfo));
+  MOZ_ASSERT(NS_SUCCEEDED(rv), "GetSecurityInfo() failed during renegotiation");
+  if (NS_FAILED(rv) || !securityInfo) {
+    PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
+    return SECFailure;
+  }
   nsAutoCString negotiatedNPN;
-  nsresult rv = infoObject->GetNegotiatedNPN(negotiatedNPN);
+  rv = securityInfo->GetNegotiatedNPN(negotiatedNPN);
   MOZ_ASSERT(NS_SUCCEEDED(rv),
              "GetNegotiatedNPN() failed during renegotiation");
 
@@ -407,8 +412,7 @@
   }
 
   // Check to see if the cert has actually changed
-  nsCOMPtr<nsIX509Cert> cert;
-  infoObject->GetServerCert(getter_AddRefs(cert));
+  nsCOMPtr<nsIX509Cert> cert(socketControl->GetServerCert());
   if (!cert) {
     PR_SetError(SEC_ERROR_LIBRARY_FAILURE, 0);
     return SECFailure;
@@ -814,7 +818,7 @@
 // Takes information needed for cert verification, does some consistency
 //  checks and calls SSLServerCertVerificationJob::Dispatch.
 SECStatus AuthCertificateHookInternal(
-    TransportSecurityInfo* infoObject, const void* aPtrForLogging,
+    CommonSocketControl* socketControl, const void* aPtrForLogging,
     const nsACString& hostName, nsTArray<nsTArray<uint8_t>>&& peerCertChain,
     Maybe<nsTArray<uint8_t>>& stapledOCSPResponse,
     Maybe<nsTArray<uint8_t>>& sctsFromTLSExtension,
@@ -825,7 +829,7 @@
   MOZ_LOG(gPIPNSSLog, LogLevel::Debug,
           ("[%p] starting AuthCertificateHookInternal\n", aPtrForLogging));
 
-  if (!infoObject || peerCertChain.IsEmpty()) {
+  if (!socketControl || peerCertChain.IsEmpty()) {
     PR_SetError(PR_INVALID_STATE_ERROR, 0);
     return SECFailure;
   }
@@ -853,12 +857,12 @@
 
   uint64_t addr = reinterpret_cast<uintptr_t>(aPtrForLogging);
   RefPtr<SSLServerCertVerificationResult> resultTask =
-      new SSLServerCertVerificationResult(infoObject);
+      new SSLServerCertVerificationResult(socketControl);
 
   if (XRE_IsSocketProcess()) {
     return RemoteProcessCertVerification(
-        std::move(peerCertChain), hostName, infoObject->GetPort(),
-        infoObject->GetOriginAttributes(), stapledOCSPResponse,
+        std::move(peerCertChain), hostName, socketControl->GetPort(),
+        socketControl->GetOriginAttributes(), stapledOCSPResponse,
         sctsFromTLSExtension, dcInfo, providerFlags, certVerifierFlags,
         resultTask);
   }
@@ -868,8 +872,8 @@
   // and we *want* to do certificate verification on a background thread
   // because of the performance benefits of doing so.
   return SSLServerCertVerificationJob::Dispatch(
-      addr, infoObject, std::move(peerCertChain), hostName,
-      infoObject->GetPort(), infoObject->GetOriginAttributes(),
+      addr, socketControl, std::move(peerCertChain), hostName,
+      socketControl->GetPort(), socketControl->GetOriginAttributes(),
       stapledOCSPResponse, sctsFromTLSExtension, dcInfo, providerFlags, Now(),
       certVerifierFlags, resultTask);
 }
@@ -983,7 +987,7 @@
 // checks and calls SSLServerCertVerificationJob::Dispatch.
 // This function is used for Quic.
 SECStatus AuthCertificateHookWithInfo(
-    TransportSecurityInfo* infoObject, const nsACString& aHostName,
+    CommonSocketControl* socketControl, const nsACString& aHostName,
     const void* aPtrForLogging, nsTArray<nsTArray<uint8_t>>&& peerCertChain,
     Maybe<nsTArray<nsTArray<uint8_t>>>& stapledOCSPResponses,
     Maybe<nsTArray<uint8_t>>& sctsFromTLSExtension, uint32_t providerFlags) {
@@ -1011,7 +1015,7 @@
   // for Delegated Credentials.
   Maybe<DelegatedCredentialInfo> dcInfo;
 
-  return AuthCertificateHookInternal(infoObject, aPtrForLogging, aHostName,
+  return AuthCertificateHookInternal(socketControl, aPtrForLogging, aHostName,
                                      std::move(peerCertChain),
                                      stapledOCSPResponse, sctsFromTLSExtension,
                                      dcInfo, providerFlags, certVerifierFlags);
@@ -1020,9 +1024,9 @@
 NS_IMPL_ISUPPORTS_INHERITED0(SSLServerCertVerificationResult, Runnable)
 
 SSLServerCertVerificationResult::SSLServerCertVerificationResult(
-    TransportSecurityInfo* infoObject)
+    CommonSocketControl* socketControl)
     : Runnable("psm::SSLServerCertVerificationResult"),
-      mInfoObject(infoObject),
+      mSocketControl(socketControl),
       mCertificateTransparencyStatus(0),
       mEVStatus(EVStatus::NotEV),
       mSucceeded(false),
@@ -1092,33 +1096,33 @@
     SaveIntermediateCerts(mBuiltChain);
   }
 
-  mInfoObject->SetMadeOCSPRequest(mMadeOCSPRequests);
+  mSocketControl->SetMadeOCSPRequests(mMadeOCSPRequests);
 
   if (mSucceeded) {
     MOZ_LOG(gPIPNSSLog, LogLevel::Debug,
             ("SSLServerCertVerificationResult::Run setting NEW cert"));
     nsTArray<uint8_t> certBytes(mBuiltChain.ElementAt(0).Clone());
     nsCOMPtr<nsIX509Cert> cert(new nsNSSCertificate(std::move(certBytes)));
-    mInfoObject->SetServerCert(cert, mEVStatus);
-    mInfoObject->SetSucceededCertChain(std::move(mBuiltChain));
+    mSocketControl->SetServerCert(cert, mEVStatus);
+    mSocketControl->SetSucceededCertChain(std::move(mBuiltChain));
 
-    mInfoObject->SetIsBuiltCertChainRootBuiltInRoot(
+    mSocketControl->SetIsBuiltCertChainRootBuiltInRoot(
         mIsBuiltCertChainRootBuiltInRoot);
-    mInfoObject->SetCertificateTransparencyStatus(
+    mSocketControl->SetCertificateTransparencyStatus(
         mCertificateTransparencyStatus);
   } else {
     nsTArray<uint8_t> certBytes(mPeerCertChain.ElementAt(0).Clone());
     nsCOMPtr<nsIX509Cert> cert(new nsNSSCertificate(std::move(certBytes)));
     // Certificate validation failed; store the peer certificate chain on
-    // infoObject so it can be used for error reporting.
-    mInfoObject->SetFailedCertChain(std::move(mPeerCertChain));
+    // mSocketControl so it can be used for error reporting.
+    mSocketControl->SetFailedCertChain(std::move(mPeerCertChain));
     if (mOverridableErrorCategory !=
         nsITransportSecurityInfo::OverridableErrorCategory::ERROR_UNSET) {
-      mInfoObject->SetStatusErrorBits(cert, mOverridableErrorCategory);
+      mSocketControl->SetStatusErrorBits(cert, mOverridableErrorCategory);
     }
   }
 
-  mInfoObject->SetCertVerificationResult(mFinalError);
+  mSocketControl->SetCertVerificationResult(mFinalError);
   return NS_OK;
 }
 