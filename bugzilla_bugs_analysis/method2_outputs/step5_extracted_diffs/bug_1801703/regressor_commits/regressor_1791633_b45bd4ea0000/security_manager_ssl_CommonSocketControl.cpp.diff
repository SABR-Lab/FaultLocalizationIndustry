# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/manager/ssl/CommonSocketControl.cpp
# Commit: b45bd4ea0000
# Full Hash: b45bd4ea0000e64e4b159cac01d09519d73166f7
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-17 09:39:01
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r 705439f1d269 -r b45bd4ea0000 security/manager/ssl/CommonSocketControl.cpp
--- a/security/manager/ssl/CommonSocketControl.cpp	Wed Nov 16 16:37:29 2022 +0000
+++ b/security/manager/ssl/CommonSocketControl.cpp	Wed Nov 16 16:37:29 2022 +0000
@@ -8,44 +8,127 @@
 
 #include "PublicKeyPinningService.h"
 #include "SharedCertVerifier.h"
+#include "SharedSSLState.h"
+#include "mozilla/ErrorResult.h"
+#include "mozilla/StaticPrefs_network.h"
+#include "mozilla/dom/Promise.h"
+#include "nsICertOverrideService.h"
+#include "nsISocketProvider.h"
+#include "nsITlsHandshakeListener.h"
 #include "nsNSSComponent.h"
-#include "SharedSSLState.h"
-#include "sslt.h"
+#include "nsNSSHelper.h"
 #include "ssl.h"
-#include "mozilla/StaticPrefs_network.h"
-#include "nsICertOverrideService.h"
-#include "nsITlsHandshakeListener.h"
+#include "sslt.h"
 
 using namespace mozilla;
 
 extern LazyLogModule gPIPNSSLog;
 
-NS_IMPL_ISUPPORTS_INHERITED(CommonSocketControl, TransportSecurityInfo,
-                            nsITLSSocketControl)
+NS_IMPL_ISUPPORTS(CommonSocketControl, nsITLSSocketControl)
 
-CommonSocketControl::CommonSocketControl(uint32_t aProviderFlags)
-    : mHandshakeCompleted(false),
+CommonSocketControl::CommonSocketControl(const nsCString& aHostName,
+                                         int32_t aPort, uint32_t aProviderFlags)
+    : mHostName(aHostName),
+      mPort(aPort),
+      mOriginAttributes(),
+      mCanceled(false),
+      mSessionCacheInfo(),
+      mHandshakeCompleted(false),
       mJoined(false),
       mSentClientCert(false),
       mFailedVerification(false),
       mSSLVersionUsed(nsITLSSocketControl::SSL_VERSION_UNKNOWN),
-      mProviderFlags(aProviderFlags) {}
+      mProviderFlags(aProviderFlags),
+      mSecurityState(0),
+      mErrorCode(0),
+      mFailedCertChain(),
+      mServerCert(nullptr),
+      mSucceededCertChain(),
+      mCipherSuite(),
+      mKeaGroupName(),
+      mSignatureSchemeName(),
+      mProtocolVersion(),
+      mCertificateTransparencyStatus(0),
+      mIsAcceptedEch(),
+      mIsDelegatedCredential(),
+      mOverridableErrorCategory(),
+      mMadeOCSPRequests(false),
+      mUsedPrivateDNS(false),
+      mIsEV(),
+      mNPNCompleted(false),
+      mNegotiatedNPN(),
+      mResumed(false),
+      mIsBuiltCertChainRootBuiltInRoot(false),
+      mPeerId() {
+#ifdef DEBUG
+  mOwningThread = PR_GetCurrentThread();
+#endif
+}
 
-NS_IMETHODIMP
-CommonSocketControl::GetNotificationCallbacks(
-    nsIInterfaceRequestor** aCallbacks) {
-  MutexAutoLock lock(mMutex);
-  *aCallbacks = mCallbacks;
-  NS_IF_ADDREF(*aCallbacks);
-  return NS_OK;
+void CommonSocketControl::SetStatusErrorBits(
+    const nsCOMPtr<nsIX509Cert>& cert,
+    nsITransportSecurityInfo::OverridableErrorCategory
+        overridableErrorCategory) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  SetServerCert(cert, mozilla::psm::EVStatus::NotEV);
+  mOverridableErrorCategory = Some(overridableErrorCategory);
+}
+
+static void CreateCertChain(nsTArray<RefPtr<nsIX509Cert>>& aOutput,
+                            nsTArray<nsTArray<uint8_t>>&& aCertList) {
+  nsTArray<nsTArray<uint8_t>> certList = std::move(aCertList);
+  aOutput.Clear();
+  for (auto& certBytes : certList) {
+    RefPtr<nsIX509Cert> cert = new nsNSSCertificate(std::move(certBytes));
+    aOutput.AppendElement(cert);
+  }
 }
 
-NS_IMETHODIMP
-CommonSocketControl::SetNotificationCallbacks(
-    nsIInterfaceRequestor* aCallbacks) {
-  MutexAutoLock lock(mMutex);
-  mCallbacks = aCallbacks;
-  return NS_OK;
+void CommonSocketControl::SetServerCert(
+    const nsCOMPtr<nsIX509Cert>& aServerCert,
+    mozilla::psm::EVStatus aEVStatus) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  mServerCert = aServerCert;
+  mIsEV = Some(aEVStatus == mozilla::psm::EVStatus::EV);
+}
+
+void CommonSocketControl::SetSucceededCertChain(
+    nsTArray<nsTArray<uint8_t>>&& aCertList) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  return CreateCertChain(mSucceededCertChain, std::move(aCertList));
+}
+
+void CommonSocketControl::SetFailedCertChain(
+    nsTArray<nsTArray<uint8_t>>&& aCertList) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  return CreateCertChain(mFailedCertChain, std::move(aCertList));
+}
+
+void CommonSocketControl::SetCanceled(PRErrorCode errorCode) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  MOZ_ASSERT(errorCode != 0);
+  if (errorCode == 0) {
+    errorCode = SEC_ERROR_LIBRARY_FAILURE;
+  }
+
+  mErrorCode = errorCode;
+  mCanceled = true;
+}
+
+// NB: GetErrorCode may be called before an error code is set (if ever). In that
+// case, this returns 0, which is treated as a successful value.
+int32_t CommonSocketControl::GetErrorCode() {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  // We're in an inconsistent state if we think we've been canceled but no error
+  // code was set or we haven't been canceled but an error code was set.
+  MOZ_ASSERT(
+      !((mCanceled && mErrorCode == 0) || (!mCanceled && mErrorCode != 0)));
+  if ((mCanceled && mErrorCode == 0) || (!mCanceled && mErrorCode != 0)) {
+    mCanceled = true;
+    mErrorCode = SEC_ERROR_LIBRARY_FAILURE;
+  }
+
+  return mErrorCode;
 }
 
 NS_IMETHODIMP
@@ -76,6 +159,7 @@
 CommonSocketControl::JoinConnection(const nsACString& npnProtocol,
                                     const nsACString& hostname, int32_t port,
                                     bool* _retval) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   nsresult rv = TestJoinConnection(npnProtocol, hostname, port, _retval);
   if (NS_SUCCEEDED(rv) && *_retval) {
     // All tests pass - this is joinable
@@ -88,15 +172,15 @@
 CommonSocketControl::TestJoinConnection(const nsACString& npnProtocol,
                                         const nsACString& hostname,
                                         int32_t port, bool* _retval) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *_retval = false;
 
   // Different ports may not be joined together
   if (port != GetPort()) return NS_OK;
 
-  {
-    MutexAutoLock lock(mMutex);
-    // Make sure NPN has been completed and matches requested npnProtocol
-    if (!mNPNCompleted || !mNegotiatedNPN.Equals(npnProtocol)) return NS_OK;
+  // Make sure NPN has been completed and matches requested npnProtocol
+  if (!mNPNCompleted || !mNegotiatedNPN.Equals(npnProtocol)) {
+    return NS_OK;
   }
 
   IsAcceptableForHost(hostname, _retval);  // sets _retval
@@ -106,6 +190,7 @@
 NS_IMETHODIMP
 CommonSocketControl::IsAcceptableForHost(const nsACString& hostname,
                                          bool* _retval) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   NS_ENSURE_ARG(_retval);
 
   *_retval = false;
@@ -138,9 +223,7 @@
   }
 
   // If the cert has error bits (e.g. it is untrusted) then do not join.
-  // The value of mHaveCertErrorBits is only reliable because we know that
-  // the handshake completed.
-  if (mHaveCertErrorBits) {
+  if (mOverridableErrorCategory.isSome()) {
     return NS_OK;
   }
 
@@ -152,10 +235,7 @@
   // Ensure that the server certificate covers the hostname that would
   // like to join this connection
 
-  nsCOMPtr<nsIX509Cert> cert;
-  if (NS_FAILED(GetServerCert(getter_AddRefs(cert)))) {
-    return NS_OK;
-  }
+  nsCOMPtr<nsIX509Cert> cert(GetServerCert());
   if (!cert) {
     return NS_OK;
   }
@@ -164,8 +244,6 @@
     return NS_OK;
   }
 
-  MutexAutoLock lock(mMutex);
-
   // An empty mSucceededCertChain means the server certificate verification
   // failed before, so don't join in this case.
   if (mSucceededCertChain.IsEmpty()) {
@@ -224,6 +302,7 @@
 }
 
 void CommonSocketControl::RebuildCertificateInfoFromSSLTokenCache() {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   if (!mSessionCacheInfo) {
     MOZ_LOG(
         gPIPNSSLog, LogLevel::Debug,
@@ -235,7 +314,8 @@
   mozilla::net::SessionCacheInfo& info = *mSessionCacheInfo;
   nsCOMPtr<nsIX509Cert> cert(
       new nsNSSCertificate(std::move(info.mServerCertBytes)));
-  if (info.mOverridableErrorCategory == OverridableErrorCategory::ERROR_UNSET) {
+  if (info.mOverridableErrorCategory ==
+      nsITransportSecurityInfo::OverridableErrorCategory::ERROR_UNSET) {
     SetServerCert(cert, info.mEVStatus);
   } else {
     SetStatusErrorBits(cert, info.mOverridableErrorCategory);
@@ -266,17 +346,14 @@
 
 NS_IMETHODIMP
 CommonSocketControl::GetProviderFlags(uint32_t* aProviderFlags) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *aProviderFlags = mProviderFlags;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-CommonSocketControl::GetProviderTlsFlags(uint32_t* aProviderTlsFlags) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
 CommonSocketControl::GetSSLVersionUsed(int16_t* aSSLVersionUsed) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *aSSLVersionUsed = mSSLVersionUsed;
   return NS_OK;
 }
@@ -297,12 +374,14 @@
 
 NS_IMETHODIMP
 CommonSocketControl::GetClientCertSent(bool* arg) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *arg = mSentClientCert;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CommonSocketControl::GetFailedVerification(bool* arg) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *arg = mFailedVerification;
   return NS_OK;
 }
@@ -340,3 +419,102 @@
 
 NS_IMETHODIMP
 CommonSocketControl::DisableEarlyData(void) { return NS_ERROR_NOT_IMPLEMENTED; }
+
+NS_IMETHODIMP
+CommonSocketControl::GetPeerId(nsACString& aResult) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  if (!mPeerId.IsEmpty()) {
+    aResult.Assign(mPeerId);
+    return NS_OK;
+  }
+
+  if (mProviderFlags &
+      nsISocketProvider::ANONYMOUS_CONNECT) {  // See bug 466080
+    mPeerId.AppendLiteral("anon:");
+  }
+  if (mProviderFlags & nsISocketProvider::NO_PERMANENT_STORAGE) {
+    mPeerId.AppendLiteral("private:");
+  }
+  if (mProviderFlags & nsISocketProvider::BE_CONSERVATIVE) {
+    mPeerId.AppendLiteral("beConservative:");
+  }
+
+  mPeerId.Append(mHostName);
+  mPeerId.Append(':');
+  mPeerId.AppendInt(GetPort());
+  nsAutoCString suffix;
+  mOriginAttributes.CreateSuffix(suffix);
+  mPeerId.Append(suffix);
+
+  aResult.Assign(mPeerId);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CommonSocketControl::GetSecurityInfo(nsITransportSecurityInfo** aSecurityInfo) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
+  // Make sure peerId is set.
+  nsAutoCString unused;
+  nsresult rv = GetPeerId(unused);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+  nsCOMPtr<nsITransportSecurityInfo> securityInfo(new TransportSecurityInfo(
+      mSecurityState, mErrorCode, mFailedCertChain.Clone(), mServerCert,
+      mSucceededCertChain.Clone(), mCipherSuite, mKeaGroupName,
+      mSignatureSchemeName, mProtocolVersion, mCertificateTransparencyStatus,
+      mIsAcceptedEch, mIsDelegatedCredential, mOverridableErrorCategory,
+      mMadeOCSPRequests, mUsedPrivateDNS, mIsEV, mNPNCompleted, mNegotiatedNPN,
+      mResumed, mIsBuiltCertChainRootBuiltInRoot, mPeerId));
+  securityInfo.forget(aSecurityInfo);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CommonSocketControl::AsyncGetSecurityInfo(JSContext* aCx,
+                                          mozilla::dom::Promise** aPromise) {
+  MOZ_RELEASE_ASSERT(NS_IsMainThread());
+  NS_ENSURE_ARG_POINTER(aCx);
+  NS_ENSURE_ARG_POINTER(aPromise);
+
+  nsIGlobalObject* globalObject = xpc::CurrentNativeGlobal(aCx);
+  if (!globalObject) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  ErrorResult result;
+  RefPtr<mozilla::dom::Promise> promise =
+      mozilla::dom::Promise::Create(globalObject, result);
+  if (result.Failed()) {
+    return result.StealNSResult();
+  }
+  nsCOMPtr<nsIRunnable> runnable(NS_NewRunnableFunction(
+      "CommonSocketControl::AsyncGetSecurityInfo",
+      [promise, self = RefPtr{this}]() mutable {
+        nsCOMPtr<nsITransportSecurityInfo> securityInfo;
+        nsresult rv = self->GetSecurityInfo(getter_AddRefs(securityInfo));
+        nsCOMPtr<nsIRunnable> runnable(NS_NewRunnableFunction(
+            "CommonSocketControl::AsyncGetSecurityInfoResolve",
+            [rv, promise = std::move(promise),
+             securityInfo = std::move(securityInfo)]() {
+              if (NS_FAILED(rv)) {
+                promise->MaybeReject(rv);
+              } else {
+                promise->MaybeResolve(securityInfo);
+              }
+            }));
+        NS_DispatchToMainThread(runnable.forget());
+      }));
+  nsCOMPtr<nsIEventTarget> target(
+      do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID));
+  if (!target) {
+    return NS_ERROR_FAILURE;
+  }
+  nsresult rv = target->Dispatch(runnable, NS_DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  promise.forget(aPromise);
+  return NS_OK;
+}