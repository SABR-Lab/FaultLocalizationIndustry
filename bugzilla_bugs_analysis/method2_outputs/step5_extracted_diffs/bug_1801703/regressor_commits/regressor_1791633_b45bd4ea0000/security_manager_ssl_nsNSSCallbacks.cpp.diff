# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: security/manager/ssl/nsNSSCallbacks.cpp
# Commit: b45bd4ea0000
# Full Hash: b45bd4ea0000e64e4b159cac01d09519d73166f7
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-17 09:39:01
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r 705439f1d269 -r b45bd4ea0000 security/manager/ssl/nsNSSCallbacks.cpp
--- a/security/manager/ssl/nsNSSCallbacks.cpp	Wed Nov 16 16:37:29 2022 +0000
+++ b/security/manager/ssl/nsNSSCallbacks.cpp	Wed Nov 16 16:37:29 2022 +0000
@@ -699,12 +699,15 @@
   return signatureName;
 }
 
-// call with shutdown prevention lock held
 static void PreliminaryHandshakeDone(PRFileDesc* fd) {
-  NSSSocketControl* infoObject = (NSSSocketControl*)fd->higher->secret;
-  if (!infoObject) {
+  NSSSocketControl* socketControl = (NSSSocketControl*)fd->higher->secret;
+  if (!socketControl) {
     return;
   }
+  if (socketControl->IsPreliminaryHandshakeDone()) {
+    return;
+  }
+
   SSLChannelInfo channelInfo;
   if (SSL_GetChannelInfo(fd, &channelInfo, sizeof(channelInfo)) != SECSuccess) {
     return;
@@ -714,17 +717,12 @@
                              sizeof(cipherInfo)) != SECSuccess) {
     return;
   }
-  infoObject->SetPreliminaryHandshakeInfo(channelInfo, cipherInfo);
-  infoObject->SetSSLVersionUsed(channelInfo.protocolVersion);
-  infoObject->SetEarlyDataAccepted(channelInfo.earlyDataAccepted);
-  infoObject->SetKEAUsed(channelInfo.keaType);
-  infoObject->SetKEAKeyBits(channelInfo.keaKeyBits);
-  infoObject->SetMACAlgorithmUsed(cipherInfo.macAlgorithm);
-
-  // Don't update NPN details on renegotiation.
-  if (infoObject->IsPreliminaryHandshakeDone()) {
-    return;
-  }
+  socketControl->SetPreliminaryHandshakeInfo(channelInfo, cipherInfo);
+  socketControl->SetSSLVersionUsed(channelInfo.protocolVersion);
+  socketControl->SetEarlyDataAccepted(channelInfo.earlyDataAccepted);
+  socketControl->SetKEAUsed(channelInfo.keaType);
+  socketControl->SetKEAKeyBits(channelInfo.keaKeyBits);
+  socketControl->SetMACAlgorithmUsed(cipherInfo.macAlgorithm);
 
   // Get the NPN value.
   SSLNextProtoState state;
@@ -736,17 +734,17 @@
       SECSuccess) {
     if (state == SSL_NEXT_PROTO_NEGOTIATED ||
         state == SSL_NEXT_PROTO_SELECTED) {
-      infoObject->SetNegotiatedNPN(BitwiseCast<char*, unsigned char*>(npnbuf),
-                                   npnlen);
+      socketControl->SetNegotiatedNPN(
+          BitwiseCast<char*, unsigned char*>(npnbuf), npnlen);
     } else {
-      infoObject->SetNegotiatedNPN(nullptr, 0);
+      socketControl->SetNegotiatedNPN(nullptr, 0);
     }
     mozilla::Telemetry::Accumulate(Telemetry::SSL_NPN_TYPE, state);
   } else {
-    infoObject->SetNegotiatedNPN(nullptr, 0);
+    socketControl->SetNegotiatedNPN(nullptr, 0);
   }
 
-  infoObject->SetPreliminaryHandshakeDone();
+  socketControl->SetPreliminaryHandshakeDone();
 }
 
 SECStatus CanFalseStartCallback(PRFileDesc* fd, void* client_data,
@@ -1059,8 +1057,6 @@
                                 : Telemetry::SSL_KEY_EXCHANGE_ALGORITHM_RESUMED,
                             channelInfo.keaType);
 
-      MOZ_ASSERT(infoObject->GetKEAUsed() == channelInfo.keaType);
-
       if (infoObject->IsFullHandshake()) {
         switch (channelInfo.keaType) {
           case ssl_kea_rsa:
@@ -1148,13 +1144,8 @@
     infoObject->RebuildCertificateInfoFromSSLTokenCache();
   }
 
-  nsITransportSecurityInfo::OverridableErrorCategory overridableErrorCategory;
-  // This returns NS_OK, so don't even bother checking the return value.
-  Unused << infoObject->GetOverridableErrorCategory(&overridableErrorCategory);
-  // If we're here, the TLS handshake has succeeded. Thus if any of these
-  // booleans are true, the user has added an override for a certificate error.
-  if (overridableErrorCategory !=
-      nsITransportSecurityInfo::OverridableErrorCategory::ERROR_UNSET) {
+  // Check if the user has added an override for a certificate error.
+  if (infoObject->HasUserOverriddenCertificateError()) {
     state |= nsIWebProgressListener::STATE_CERT_USER_OVERRIDDEN;
   }
 