# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/QuicSocketControl.cpp
# Commit: ee9744982673
# Full Hash: ee974498267381418f06efd6ab92c1f2c5f3735d
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-15 16:44:51
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r f5a4bfdaba40 -r ee9744982673 netwerk/protocol/http/QuicSocketControl.cpp
--- a/netwerk/protocol/http/QuicSocketControl.cpp	Tue Nov 15 05:34:40 2022 +0000
+++ b/netwerk/protocol/http/QuicSocketControl.cpp	Tue Nov 15 05:34:40 2022 +0000
@@ -11,7 +11,6 @@
 #include "nsISocketProvider.h"
 #include "nsIWebProgressListener.h"
 #include "nsNSSComponent.h"
-#include "nsWeakReference.h"
 #include "nsSocketTransportService2.h"
 #include "nsThreadUtils.h"
 #include "sslt.h"
@@ -20,19 +19,17 @@
 namespace mozilla {
 namespace net {
 
-NS_IMPL_ISUPPORTS_INHERITED(QuicSocketControl, TransportSecurityInfo,
-                            nsITLSSocketControl, QuicSocketControl)
-
-QuicSocketControl::QuicSocketControl(uint32_t aProviderFlags,
+QuicSocketControl::QuicSocketControl(const nsCString& aHostName, int32_t aPort,
+                                     uint32_t aProviderFlags,
                                      Http3Session* aHttp3Session)
-    : CommonSocketControl(aProviderFlags) {
-  MOZ_ASSERT(OnSocketThread());
+    : CommonSocketControl(aHostName, aPort, aProviderFlags) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   mHttp3Session = do_GetWeakReference(
       static_cast<nsISupportsWeakReference*>(aHttp3Session));
-  mSocketThread = NS_GetCurrentThread();
 }
 
 void QuicSocketControl::SetCertVerificationResult(PRErrorCode errorCode) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   SetUsedPrivateDNS(GetProviderFlags() & nsISocketProvider::USED_PRIVATE_DNS);
 
   if (errorCode) {
@@ -40,28 +37,18 @@
     SetCanceled(errorCode);
   }
 
-  if (OnSocketThread()) {
-    CallAuthenticated();
-  } else {
-    DebugOnly<nsresult> rv = gSocketTransportService->Dispatch(
-        NewRunnableMethod("QuicSocketControl::CallAuthenticated", this,
-                          &QuicSocketControl::CallAuthenticated),
-        NS_DISPATCH_NORMAL);
-  }
-}
-
-QuicSocketControl::~QuicSocketControl() {
-  NS_ProxyRelease("QuicSocketControl::~QuicSocketControl", mSocketThread,
-                  mHttp3Session.forget());
+  CallAuthenticated();
 }
 
 NS_IMETHODIMP
 QuicSocketControl::GetSSLVersionOffered(int16_t* aSSLVersionOffered) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   *aSSLVersionOffered = nsITLSSocketControl::TLS_VERSION_1_3;
   return NS_OK;
 }
 
 void QuicSocketControl::CallAuthenticated() {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   RefPtr<Http3Session> http3Session = do_QueryReferent(mHttp3Session);
   if (http3Session) {
     http3Session->Authenticated(GetErrorCode());
@@ -69,14 +56,15 @@
 }
 
 void QuicSocketControl::HandshakeCompleted() {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   uint32_t state = nsIWebProgressListener::STATE_IS_SECURE;
 
-  MutexAutoLock lock(mMutex);
-
   // If we're here, the TLS handshake has succeeded. If the overridable error
   // category is nonzero, the user has added an override for a certificate
   // error.
-  if (mOverridableErrorCategory != OverridableErrorCategory::ERROR_UNSET) {
+  if (mOverridableErrorCategory.isSome() &&
+      *mOverridableErrorCategory !=
+          nsITransportSecurityInfo::OverridableErrorCategory::ERROR_UNSET) {
     state |= nsIWebProgressListener::STATE_CERT_USER_OVERRIDDEN;
   }
 
@@ -85,64 +73,37 @@
 }
 
 void QuicSocketControl::SetNegotiatedNPN(const nsACString& aValue) {
-  MutexAutoLock lock(mMutex);
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   mNegotiatedNPN = aValue;
   mNPNCompleted = true;
 }
 
 void QuicSocketControl::SetInfo(uint16_t aCipherSuite,
-                                uint16_t aProtocolVersion, uint16_t aKeaGroup,
+                                uint16_t aProtocolVersion,
+                                uint16_t aKeaGroupName,
                                 uint16_t aSignatureScheme, bool aEchAccepted) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   SSLCipherSuiteInfo cipherInfo;
   if (SSL_GetCipherSuiteInfo(aCipherSuite, &cipherInfo, sizeof cipherInfo) ==
       SECSuccess) {
-    MutexAutoLock lock(mMutex);
-    mHaveCipherSuiteAndProtocol = true;
-    mCipherSuite = aCipherSuite;
-    mProtocolVersion = aProtocolVersion & 0xFF;
-    mKeaGroup = getKeaGroupName(aKeaGroup);
-    mSignatureSchemeName = getSignatureName(aSignatureScheme);
-    mIsAcceptedEch = aEchAccepted;
-  }
-}
-
-NS_IMETHODIMP QuicSocketControl::GetPeerId(nsACString& aResult) {
-  MutexAutoLock lock(mMutex);
-  if (!mPeerId.IsEmpty()) {
-    aResult.Assign(mPeerId);
-    return NS_OK;
+    mCipherSuite.emplace(aCipherSuite);
+    mProtocolVersion.emplace(aProtocolVersion & 0xFF);
+    mKeaGroupName.emplace(getKeaGroupName(aKeaGroupName));
+    mSignatureSchemeName.emplace(getSignatureName(aSignatureScheme));
+    mIsAcceptedEch.emplace(aEchAccepted);
   }
-
-  if (mProviderFlags &
-      nsISocketProvider::ANONYMOUS_CONNECT) {  // See bug 466080
-    mPeerId.AppendLiteral("anon:");
-  }
-  if (mProviderFlags & nsISocketProvider::NO_PERMANENT_STORAGE) {
-    mPeerId.AppendLiteral("private:");
-  }
-  if (mProviderFlags & nsISocketProvider::BE_CONSERVATIVE) {
-    mPeerId.AppendLiteral("beConservative:");
-  }
-
-  mPeerId.Append(mHostName);
-  mPeerId.Append(':');
-  mPeerId.AppendInt(GetPort());
-  nsAutoCString suffix;
-  mOriginAttributes.CreateSuffix(suffix);
-  mPeerId.Append(suffix);
-
-  aResult.Assign(mPeerId);
-  return NS_OK;
 }
 
 NS_IMETHODIMP
 QuicSocketControl::GetEchConfig(nsACString& aEchConfig) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   aEchConfig = mEchConfig;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 QuicSocketControl::SetEchConfig(const nsACString& aEchConfig) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   mEchConfig = aEchConfig;
   RefPtr<Http3Session> http3Session = do_QueryReferent(mHttp3Session);
   if (http3Session) {
@@ -153,11 +114,13 @@
 
 NS_IMETHODIMP
 QuicSocketControl::GetRetryEchConfig(nsACString& aEchConfig) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   aEchConfig = mRetryEchConfig;
   return NS_OK;
 }
 
 void QuicSocketControl::SetRetryEchConfig(const nsACString& aEchConfig) {
+  COMMON_SOCKET_CONTROL_ASSERT_ON_OWNING_THREAD();
   mRetryEchConfig = aEchConfig;
 }
 