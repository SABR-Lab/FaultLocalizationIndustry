# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/TLSTransportLayer.cpp
# Commit: ee9744982673
# Full Hash: ee974498267381418f06efd6ab92c1f2c5f3735d
# Author: Dana Keeler <dkeeler@mozilla.com>
# Date: 2022-11-15 16:44:51
# Regressor Bug: 1791633
# File Overlap Count: 1
# Description:
#   Bug 1791633 - separate nsITLSSocketControl from nsITransportSecurityInfo r=necko-reviewers,kershaw,jschanck
#   
#   Depends on D160311
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D160313
# ==============================================================================

diff -r f5a4bfdaba40 -r ee9744982673 netwerk/protocol/http/TLSTransportLayer.cpp
--- a/netwerk/protocol/http/TLSTransportLayer.cpp	Tue Nov 15 05:34:40 2022 +0000
+++ b/netwerk/protocol/http/TLSTransportLayer.cpp	Tue Nov 15 05:34:40 2022 +0000
@@ -139,8 +139,18 @@
   PRPollDesc pd;
   pd.fd = mTransport->mFD;
   pd.in_flags = PR_POLL_READ | PR_POLL_EXCEPT;
-  int32_t rv = PR_Poll(&pd, 1, PR_INTERVAL_NO_TIMEOUT);
-  LOG(("TLSTransportLayer::InputStreamWrapper::AsyncWait rv=%d", rv));
+  // Only run PR_Poll on the socket thread. Also, make sure this lives at least
+  // as long as that operation.
+  auto DoPoll = [self = RefPtr{this}, pd(pd)]() mutable {
+    int32_t rv = PR_Poll(&pd, 1, PR_INTERVAL_NO_TIMEOUT);
+    LOG(("TLSTransportLayer::InputStreamWrapper::AsyncWait rv=%d", rv));
+  };
+  if (OnSocketThread()) {
+    DoPoll();
+  } else {
+    gSocketTransportService->Dispatch(NS_NewRunnableFunction(
+        "TLSTransportLayer::InputStreamWrapper::AsyncWait", DoPoll));
+  }
   return NS_OK;
 }
 
@@ -313,6 +323,7 @@
 }
 
 TLSTransportLayer::~TLSTransportLayer() {
+  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
   LOG(("TLSTransportLayer dtor this=[%p]", this));
   if (mFD) {
     PR_Close(mFD);