# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/SynchronousTask.h
# Commit: 48b8fc8a0624
# Full Hash: 48b8fc8a06240933ac0013e36bf3df1367d298c7
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2022-11-08 21:36:02
# Regressor Bug: 1798651
# File Overlap Count: 1
# Description:
#   Bug 1798651 Part 1: Make SynchronousTask accept a wait interval, and return result. r=gfx-reviewers,nical
#   
#   This change preserves the existing looping behavior for the indefinite
#   wait.
#   
# ==============================================================================

diff -r 42894524431f -r 48b8fc8a0624 gfx/layers/ipc/SynchronousTask.h
--- a/gfx/layers/ipc/SynchronousTask.h	Tue Nov 08 15:53:07 2022 +0000
+++ b/gfx/layers/ipc/SynchronousTask.h	Tue Nov 08 15:53:35 2022 +0000
@@ -20,10 +20,21 @@
   explicit SynchronousTask(const char* name)
       : mMonitor(name), mAutoEnter(mMonitor), mDone(false) {}
 
-  void Wait() {
-    while (!mDone) {
+  nsresult Wait(PRIntervalTime aInterval = PR_INTERVAL_NO_TIMEOUT) {
+    // For indefinite timeouts, wait in a while loop to handle spurious
+    // wakeups.
+    while (aInterval == PR_INTERVAL_NO_TIMEOUT && !mDone) {
       mMonitor.Wait();
     }
+
+    // For finite timeouts, we only check once for completion, and otherwise
+    // rely on the ReentrantMonitor to manage the interval. If the monitor
+    // returns too early, we'll never know.
+    if (!mDone) {
+      return mMonitor.Wait(aInterval);
+    }
+
+    return NS_OK;
   }
 
  private:
