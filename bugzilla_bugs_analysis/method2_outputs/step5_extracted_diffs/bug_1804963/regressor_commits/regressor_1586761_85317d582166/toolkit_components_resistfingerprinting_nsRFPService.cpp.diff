# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/resistfingerprinting/nsRFPService.cpp
# Commit: 85317d582166
# Full Hash: 85317d5821665149ffa385e8b55b244565c9d4c4
# Author: Tom Tung <ttung@mozilla.com>
# Date: 2020-04-07 21:44:02
# Regressor Bug: 1586761
# File Overlap Count: 1
# Description:
#   Bug 1586761 - P2 - Introduce new TimerPrecisionTypes and a set of new Reduce methods to decide the TimerPrecisionType in the nsRFPService; r=tjr
#   
#   To support checking CrossOriginIsolated in performance.now(), we need to:
#   - Add new types to TimerPrecisionType for nsRFPService
#     - System, HighResAllowed are added
# ==============================================================================

diff -r b51663641450 -r 85317d582166 toolkit/components/resistfingerprinting/nsRFPService.cpp
--- a/toolkit/components/resistfingerprinting/nsRFPService.cpp	Wed Mar 25 13:53:46 2020 +0000
+++ b/toolkit/components/resistfingerprinting/nsRFPService.cpp	Wed Mar 25 14:09:55 2020 +0000
@@ -90,28 +90,12 @@
 double nsRFPService::TimerResolution() {
   double prefValue = StaticPrefs::
       privacy_resistFingerprinting_reduceTimerPrecision_microseconds();
-  if (nsRFPService::IsResistFingerprintingEnabled()) {
+  if (StaticPrefs::privacy_resistFingerprinting()) {
     return std::max(100000.0, prefValue);
   }
   return prefValue;
 }
 
-/* static */
-bool nsRFPService::IsResistFingerprintingEnabled() {
-  return StaticPrefs::privacy_resistFingerprinting();
-}
-
-/* static */
-bool nsRFPService::IsTimerPrecisionReductionEnabled(TimerPrecisionType aType) {
-  if (aType == TimerPrecisionType::RFPOnly) {
-    return IsResistFingerprintingEnabled();
-  }
-
-  return (StaticPrefs::privacy_reduceTimerPrecision() ||
-          IsResistFingerprintingEnabled()) &&
-         TimerResolution() > 0;
-}
-
 /*
  * The below is a simple time-based Least Recently Used cache used to store the
  * result of a cryptographic hash function. It has LRU_CACHE_SIZE slots, and
@@ -462,15 +446,16 @@
                                              double aResolutionUSec,
                                              int64_t aContextMixin,
                                              TimerPrecisionType aType) {
+  if (aType == TimerPrecisionType::DangerouslyNone) {
+    return aTime;
+  }
+
   // This boolean will serve as a flag indicating we are clamping the time
   // unconditionally. We do this when timer reduction preference is off; but we
   // still want to apply 20us clamping to al timestamps to avoid leaking
   // nano-second precision.
   bool unconditionalClamping = false;
-  if (!IsTimerPrecisionReductionEnabled(aType)) {
-    if (!StaticPrefs::privacy_reduceTimerPrecision_unconditional()) {
-      return aTime;
-    }
+  if (aType == UnconditionalAKAHighRes || TimerResolution() <= 0) {
     unconditionalClamping = true;
     aResolutionUSec = RFP_TIMER_UNCONDITIONAL_VALUE;  // 20 microseconds
     aContextMixin = 0;  // Just clarifies our logging statement at the end,
@@ -498,13 +483,14 @@
   // running a debug build _probably_ has an accurate clock, and if they don't,
   // they'll hopefully find this message and understand why things are crashing.
   const long long kFeb282008 = 1204233985000;
-  if (!unconditionalClamping && aContextMixin == 0 &&
-      aType == TimerPrecisionType::All && timeAsInt < kFeb282008) {
+  if (aContextMixin == 0 && timeAsInt < kFeb282008 && !unconditionalClamping &&
+      aType != TimerPrecisionType::RFP) {
+    nsAutoCString type;
+    TypeToText(aType, type);
     MOZ_LOG(
         gResistFingerprintingLog, LogLevel::Error,
         ("About to assert. aTime=%lli<%lli aContextMixin=%" PRId64 " aType=%s",
-         timeAsInt, kFeb282008, aContextMixin,
-         (aType == TimerPrecisionType::RFPOnly ? "RFPOnly" : "All")));
+         timeAsInt, kFeb282008, aContextMixin, type.get()));
     MOZ_ASSERT(
         false,
         "ReduceTimePrecisionImpl was given a relative time "
@@ -561,11 +547,52 @@
 }
 
 /* static */
-double nsRFPService::ReduceTimePrecisionAsUSecs(
-    double aTime, int64_t aContextMixin,
-    TimerPrecisionType aType /* = TimerPrecisionType::All */) {
+double nsRFPService::ReduceTimePrecisionAsUSecs(double aTime,
+                                                int64_t aContextMixin,
+                                                bool aIsSystemPrincipal,
+                                                bool aCrossOriginIsolated) {
+  const auto type =
+      GetTimerPrecisionType(aIsSystemPrincipal, aCrossOriginIsolated);
+  return nsRFPService::ReduceTimePrecisionImpl(
+      aTime, MicroSeconds, TimerResolution(), aContextMixin, type);
+}
+
+/* static */
+double nsRFPService::ReduceTimePrecisionAsMSecs(double aTime,
+                                                int64_t aContextMixin,
+                                                bool aIsSystemPrincipal,
+                                                bool aCrossOriginIsolated) {
+  const auto type =
+      GetTimerPrecisionType(aIsSystemPrincipal, aCrossOriginIsolated);
   return nsRFPService::ReduceTimePrecisionImpl(
-      aTime, MicroSeconds, TimerResolution(), aContextMixin, aType);
+      aTime, MilliSeconds, TimerResolution(), aContextMixin, type);
+}
+
+/* static */
+double nsRFPService::ReduceTimePrecisionAsMSecsRFP(double aTime,
+                                                   int64_t aContextMixin) {
+  return nsRFPService::ReduceTimePrecisionImpl(aTime, MilliSeconds,
+                                               TimerResolution(), aContextMixin,
+                                               TimerPrecisionType::RFP);
+}
+
+/* static */
+double nsRFPService::ReduceTimePrecisionAsSecs(double aTime,
+                                               int64_t aContextMixin,
+                                               bool aIsSystemPrincipal,
+                                               bool aCrossOriginIsolated) {
+  const auto type =
+      GetTimerPrecisionType(aIsSystemPrincipal, aCrossOriginIsolated);
+  return nsRFPService::ReduceTimePrecisionImpl(
+      aTime, Seconds, TimerResolution(), aContextMixin, type);
+}
+
+/* static */
+double nsRFPService::ReduceTimePrecisionAsSecsRFP(double aTime,
+                                                  int64_t aContextMixin) {
+  return nsRFPService::ReduceTimePrecisionImpl(aTime, Seconds,
+                                               TimerResolution(), aContextMixin,
+                                               TimerPrecisionType::RFP);
 }
 
 /* static */
@@ -574,23 +601,7 @@
       aTime, MicroSeconds, TimerResolution(),
       0, /* For absolute timestamps (all the JS engine does), supply zero
             context mixin */
-      TimerPrecisionType::All);
-}
-
-/* static */
-double nsRFPService::ReduceTimePrecisionAsMSecs(
-    double aTime, int64_t aContextMixin,
-    TimerPrecisionType aType /* = TimerPrecisionType::All */) {
-  return nsRFPService::ReduceTimePrecisionImpl(
-      aTime, MilliSeconds, TimerResolution(), aContextMixin, aType);
-}
-
-/* static */
-double nsRFPService::ReduceTimePrecisionAsSecs(
-    double aTime, int64_t aContextMixin,
-    TimerPrecisionType aType /* = TimerPrecisionType::All */) {
-  return nsRFPService::ReduceTimePrecisionImpl(
-      aTime, Seconds, TimerResolution(), aContextMixin, aType);
+      TimerPrecisionType::Normal);
 }
 
 /* static */
@@ -1064,6 +1075,55 @@
   return false;
 }
 
+/* static */
+TimerPrecisionType nsRFPService::GetTimerPrecisionType(
+    bool aIsSystemPrincipal, bool aCrossOriginIsolated) {
+  if (aIsSystemPrincipal) {
+    return DangerouslyNone;
+  }
+
+  if (StaticPrefs::privacy_resistFingerprinting()) {
+    return RFP;
+  }
+
+  if (StaticPrefs::privacy_reduceTimerPrecision() && aCrossOriginIsolated) {
+    return UnconditionalAKAHighRes;
+  }
+
+  if (StaticPrefs::privacy_reduceTimerPrecision()) {
+    return Normal;
+  }
+
+  if (StaticPrefs::privacy_reduceTimerPrecision_unconditional()) {
+    return UnconditionalAKAHighRes;
+  }
+
+  return DangerouslyNone;
+}
+
+/* static */
+void nsRFPService::TypeToText(TimerPrecisionType aType, nsACString& aText) {
+  switch (aType) {
+    case TimerPrecisionType::DangerouslyNone:
+      aText.AssignLiteral("DangerouslyNone");
+      return;
+    case TimerPrecisionType::Normal:
+      aText.AssignLiteral("Normal");
+      return;
+    case TimerPrecisionType::RFP:
+      aText.AssignLiteral("RFP");
+      return;
+    case TimerPrecisionType::UnconditionalAKAHighRes:
+      aText.AssignLiteral("UnconditionalAKAHighRes");
+      return;
+    default:
+      MOZ_ASSERT(false, "Shouldn't go here");
+      aText.AssignLiteral("Unknown Enum Value");
+      return;
+  }
+}
+}
+
 // static
 void nsRFPService::PrefChanged(const char* aPref, void* aSelf) {
   static_cast<nsRFPService*>(aSelf)->PrefChanged(aPref);