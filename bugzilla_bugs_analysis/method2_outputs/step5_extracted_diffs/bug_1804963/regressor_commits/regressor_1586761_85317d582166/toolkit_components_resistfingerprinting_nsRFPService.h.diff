# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/resistfingerprinting/nsRFPService.h
# Commit: 85317d582166
# Full Hash: 85317d5821665149ffa385e8b55b244565c9d4c4
# Author: Tom Tung <ttung@mozilla.com>
# Date: 2020-04-07 21:44:02
# Regressor Bug: 1586761
# File Overlap Count: 1
# Description:
#   Bug 1586761 - P2 - Introduce new TimerPrecisionTypes and a set of new Reduce methods to decide the TimerPrecisionType in the nsRFPService; r=tjr
#   
#   To support checking CrossOriginIsolated in performance.now(), we need to:
#   - Add new types to TimerPrecisionType for nsRFPService
#     - System, HighResAllowed are added
# ==============================================================================

diff -r b51663641450 -r 85317d582166 toolkit/components/resistfingerprinting/nsRFPService.h
--- a/toolkit/components/resistfingerprinting/nsRFPService.h	Wed Mar 25 13:53:46 2020 +0000
+++ b/toolkit/components/resistfingerprinting/nsRFPService.h	Wed Mar 25 14:09:55 2020 +0000
@@ -134,7 +134,12 @@
   nsString mKey;
 };
 
-enum TimerPrecisionType { All = 1, RFPOnly = 2 };
+enum TimerPrecisionType {
+  DangerouslyNone = 1,
+  UnconditionalAKAHighRes = 2,
+  Normal = 3,
+  RFP = 4,
+};
 
 class nsRFPService final : public nsIObserver {
  public:
@@ -142,22 +147,24 @@
   NS_DECL_NSIOBSERVER
 
   static nsRFPService* GetOrCreate();
-  static bool IsResistFingerprintingEnabled();
-  static bool IsTimerPrecisionReductionEnabled(TimerPrecisionType aType);
   static double TimerResolution();
 
   enum TimeScale { Seconds = 1, MilliSeconds = 1000, MicroSeconds = 1000000 };
 
   // The following Reduce methods can be called off main thread.
-  static double ReduceTimePrecisionAsUSecs(
-      double aTime, int64_t aContextMixin,
-      TimerPrecisionType aType = TimerPrecisionType::All);
-  static double ReduceTimePrecisionAsMSecs(
-      double aTime, int64_t aContextMixin,
-      TimerPrecisionType aType = TimerPrecisionType::All);
-  static double ReduceTimePrecisionAsSecs(
-      double aTime, int64_t aContextMixin,
-      TimerPrecisionType aType = TimerPrecisionType::All);
+  static double ReduceTimePrecisionAsUSecs(double aTime, int64_t aContextMixin,
+                                           bool aIsSystemPrincipal,
+                                           bool aCrossOriginIsolated);
+  static double ReduceTimePrecisionAsMSecs(double aTime, int64_t aContextMixin,
+                                           bool aIsSystemPrincipal,
+                                           bool aCrossOriginIsolated);
+  static double ReduceTimePrecisionAsMSecsRFP(double aTime,
+                                              int64_t aContextMixin);
+  static double ReduceTimePrecisionAsSecs(double aTime, int64_t aContextMixin,
+                                          bool aIsSystemPrincipal,
+                                          bool aCrossOriginIsolated);
+  static double ReduceTimePrecisionAsSecsRFP(double aTime,
+                                             int64_t aContextMixin);
 
   // Used by the JS Engine, as it doesn't know about the TimerPrecisionType enum
   static double ReduceTimePrecisionAsUSecsWrapper(double aTime);
@@ -259,6 +266,11 @@
   static nsDataHashtable<KeyboardHashKey, const SpoofingKeyboardCode*>*
       sSpoofingKeyboardCodes;
 
+  static TimerPrecisionType GetTimerPrecisionType(bool aIsSystemPrincipal,
+                                                  bool aCrossOriginIsolated);
+
+  static void TypeToText(TimerPrecisionType aType, nsACString& aText);
+
   nsCString mInitialTZValue;
 };
 