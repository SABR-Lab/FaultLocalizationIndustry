# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsFlexContainerFrame.cpp
# Commit: 42ed600d09bb
# Full Hash: 42ed600d09bbe21c0f30b07d68591758f052e314
# Author: Ting-Yu Lin <tlin@mozilla.com>
# Date: 2022-12-15 09:27:59
# Regressor Bug: 1803486
# File Overlap Count: 2
# Description:
#   Bug 1805522 - Construct SharedFlexData for incomplete flex containers, regardless of whether they have constrained BSize. r=dholbert
#   
#   This reverts part of Bug 1803486 Part 1.
#   
#   The crashtest was adapted from bug 1805522 comment 0. I use wpt printing test
# ==============================================================================

diff -r b581a525e26e -r 42ed600d09bb layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp	Wed Dec 14 19:41:58 2022 +0000
+++ b/layout/generic/nsFlexContainerFrame.cpp	Wed Dec 14 20:51:59 2022 +0000
@@ -4642,31 +4642,29 @@
     UpdateFlexLineAndItemInfo(*containerInfo, flr.mLines);
   }
 
-  if (aReflowInput.AvailableBSize() != NS_UNCONSTRAINEDSIZE) {
-    // If we are the first-in-flow, we want to store data for our next-in-flows,
-    // or clear the existing data if it is not needed.
-    if (!prevInFlow) {
-      SharedFlexData* sharedData = GetProperty(SharedFlexData::Prop());
-      if (!aStatus.IsFullyComplete()) {
-        if (!sharedData) {
-          sharedData = new SharedFlexData;
-          SetProperty(SharedFlexData::Prop(), sharedData);
-        }
-        sharedData->Update(std::move(flr));
-
-        SetProperty(SumOfChildrenBlockSizeProperty(), sumOfChildrenBlockSize);
-      } else if (sharedData && !GetNextInFlow()) {
-        // We are fully-complete, so no next-in-flow is needed. However, if we
-        // report SetInlineLineBreakBeforeAndReset() in an incremental reflow,
-        // our next-in-flow might still exist. It can be reflowed again before
-        // us if it is an overflow container. Delete the existing data only if
-        // we don't have a next-in-flow.
-        RemoveProperty(SharedFlexData::Prop());
-        RemoveProperty(SumOfChildrenBlockSizeProperty());
+  // If we are the first-in-flow, we want to store data for our next-in-flows,
+  // or clear the existing data if it is not needed.
+  if (!prevInFlow) {
+    SharedFlexData* sharedData = GetProperty(SharedFlexData::Prop());
+    if (!aStatus.IsFullyComplete()) {
+      if (!sharedData) {
+        sharedData = new SharedFlexData;
+        SetProperty(SharedFlexData::Prop(), sharedData);
       }
-    } else {
+      sharedData->Update(std::move(flr));
+
       SetProperty(SumOfChildrenBlockSizeProperty(), sumOfChildrenBlockSize);
+    } else if (sharedData && !GetNextInFlow()) {
+      // We are fully-complete, so no next-in-flow is needed. However, if we
+      // report SetInlineLineBreakBeforeAndReset() in an incremental reflow, our
+      // next-in-flow might still exist. It can be reflowed again before us if
+      // it is an overflow container. Delete the existing data only if we don't
+      // have a next-in-flow.
+      RemoveProperty(SharedFlexData::Prop());
+      RemoveProperty(SumOfChildrenBlockSizeProperty());
     }
+  } else {
+    SetProperty(SumOfChildrenBlockSizeProperty(), sumOfChildrenBlockSize);
   }
 }
 