# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 1e9e0b9b8536
# Full Hash: 1e9e0b9b8536b683f734c2ce537ccba67cb4b7da
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 09:46:07
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 6: Make `HTMLEditor::HandleHTMLIndentAtSelectionInternal` stop touching `Selection` directly and stop setting `mNewBlockElement` r=m_kato
#   
#   The change of expected assertion count in the crash test is caused by that the
#   test calls `execCommand` recursively from the legacy mutation event listeners.
#   Therefore, stopping updating `Selection` for each DOM tree change causes that
# ==============================================================================

diff -r fb89c04dccdc -r 1e9e0b9b8536 editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 03:53:05 2022 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 04:07:46 2022 +0000
@@ -4288,29 +4288,32 @@
     }
   }
 
-  if (IsSelectionRangeContainerNotContent()) {
+  AutoRangeArray selectionRanges(SelectionRef());
+
+  if (!selectionRanges.IsInContent()) {
     NS_WARNING("Mutation event listener might have changed the selection");
     return EditActionHandled(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
   if (IsCSSEnabled()) {
-    AutoRangeArray selectionRanges(SelectionRef());
     nsresult rv = HandleCSSIndentAroundRanges(selectionRanges, aEditingHost);
     if (NS_FAILED(rv)) {
       NS_WARNING("HTMLEditor::HandleCSSIndentAroundRanges() failed");
       return EditActionHandled(rv);
     }
-    rv = selectionRanges.ApplyTo(SelectionRef());
-    if (MOZ_UNLIKELY(Destroyed())) {
-      NS_WARNING("AutoRangeArray::ApplyTo() caused destroying the editor");
-      return EditActionHandled(NS_ERROR_EDITOR_DESTROYED);
-    }
-    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::ApplyTo() failed");
-    return EditActionHandled(rv);
-  }
-  rv = HandleHTMLIndentAtSelection(aEditingHost);
-  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
-                       "HTMLEditor::HandleHTMLIndent() failed");
+  } else {
+    nsresult rv = HandleHTMLIndentAroundRanges(selectionRanges, aEditingHost);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("HTMLEditor::HandleHTMLIndentAroundRanges() failed");
+      return EditActionHandled(rv);
+    }
+  }
+  rv = selectionRanges.ApplyTo(SelectionRef());
+  if (MOZ_UNLIKELY(Destroyed())) {
+    NS_WARNING("AutoRangeArray::ApplyTo() caused destroying the editor");
+    return EditActionHandled(NS_ERROR_EDITOR_DESTROYED);
+  }
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::ApplyTo() failed");
   return EditActionHandled(rv);
 }
 
@@ -4635,54 +4638,37 @@
   return rv;
 }
 
-nsresult HTMLEditor::HandleHTMLIndentAtSelection(const Element& aEditingHost) {
+nsresult HTMLEditor::HandleHTMLIndentAroundRanges(AutoRangeArray& aRanges,
+                                                  const Element& aEditingHost) {
   MOZ_ASSERT(IsEditActionDataAvailable());
-  MOZ_ASSERT(!IsSelectionRangeContainerNotContent());
-
-  // XXX Why do we do this only when there is only one selection range?
-  if (!SelectionRef().IsCollapsed() && SelectionRef().RangeCount() == 1u) {
+  MOZ_ASSERT(IsTopLevelEditSubActionDataAvailable());
+  MOZ_ASSERT(!aRanges.Ranges().IsEmpty());
+  MOZ_ASSERT(aRanges.IsInContent());
+
+  // XXX Why do we do this only when there is only one range?
+  if (!aRanges.IsCollapsed() && aRanges.Ranges().Length() == 1u) {
     Result<EditorRawDOMRange, nsresult> extendedRange =
         GetRangeExtendedToHardLineEdgesForBlockEditAction(
-            SelectionRef().GetRangeAt(0u), aEditingHost);
+            aRanges.FirstRangeRef(), aEditingHost);
     if (MOZ_UNLIKELY(extendedRange.isErr())) {
       NS_WARNING(
           "HTMLEditor::GetRangeExtendedToHardLineEdgesForBlockEditAction() "
           "failed");
       return extendedRange.unwrapErr();
     }
-    // Note that end point may be prior to start point.  So, we
-    // cannot use Selection::SetStartAndEndInLimit() here.
-    IgnoredErrorResult error;
-    SelectionRef().SetBaseAndExtentInLimiter(
-        extendedRange.inspect().StartRef().ToRawRangeBoundary(),
-        extendedRange.inspect().EndRef().ToRawRangeBoundary(), error);
-    if (NS_WARN_IF(Destroyed())) {
-      return NS_ERROR_EDITOR_DESTROYED;
-    }
-    if (error.Failed()) {
-      NS_WARNING("Selection::SetBaseAndExtentInLimiter() failed");
-      return error.StealNSResult();
-    }
-  }
-
-  // HandleHTMLIndentAtSelectionInternal() creates AutoSelectionRestorer.
-  // Therefore, even if it returns NS_OK, editor might have been destroyed
-  // at restoring Selection.
-  nsresult rv = HandleHTMLIndentAtSelectionInternal(aEditingHost);
-  if (NS_WARN_IF(Destroyed())) {
-    return NS_ERROR_EDITOR_DESTROYED;
-  }
-  NS_WARNING_ASSERTION(
-      NS_SUCCEEDED(rv),
-      "HTMLEditor::HandleHTMLIndentAtSelectionInternal() failed");
-  return rv;
-}
-
-nsresult HTMLEditor::HandleHTMLIndentAtSelectionInternal(
-    const Element& aEditingHost) {
-  MOZ_ASSERT(IsTopLevelEditSubActionDataAvailable());
-
-  AutoSelectionRestorer restoreSelectionLater(*this);
+    // Note that end point may be prior to start point.  So, we cannot use
+    // SetStartAndEnd() here.
+    nsresult rv = aRanges.SetBaseAndExtent(extendedRange.inspect().StartRef(),
+                                           extendedRange.inspect().EndRef());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("AutoRangeArray::SetBaseAndExtent() failed");
+      return rv;
+    }
+  }
+
+  if (NS_WARN_IF(!aRanges.SaveAndTrackRanges(*this))) {
+    return NS_ERROR_FAILURE;
+  }
 
   EditorDOMPoint pointToPutCaret;
 
@@ -4694,11 +4680,11 @@
   // use these ranges to construct a list of nodes to act on.
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
   {
-    AutoRangeArray extendedSelectionRanges(SelectionRef());
-    extendedSelectionRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
+    AutoRangeArray extendedRanges(aRanges);
+    extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
         EditSubAction::eIndent, aEditingHost);
     Result<EditorDOMPoint, nsresult> splitResult =
-        extendedSelectionRanges
+        extendedRanges
             .SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries(
                 *this);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
@@ -4711,7 +4697,7 @@
     if (splitResult.inspect().IsSet()) {
       pointToPutCaret = splitResult.unwrap();
     }
-    nsresult rv = extendedSelectionRanges.CollectEditTargetNodes(
+    nsresult rv = extendedRanges.CollectEditTargetNodes(
         *this, arrayOfContents, EditSubAction::eIndent,
         AutoRangeArray::CollectNonEditableNodes::Yes);
     if (NS_FAILED(rv)) {
@@ -4735,44 +4721,33 @@
     pointToPutCaret = splitAtBRElementsResult.unwrap();
   }
 
-  if (AllowsTransactionsToChangeSelection() && pointToPutCaret.IsSet()) {
-    nsresult rv = CollapseSelectionTo(pointToPutCaret);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("EditorBase::CollapseSelectionTo() failed");
-      return rv;
-    }
-  }
-
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
   if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
-    const auto atStartOfSelection =
-        EditorBase::GetFirstSelectionStartPoint<EditorDOMPoint>();
-    if (NS_WARN_IF(!atStartOfSelection.IsSet())) {
+    const EditorDOMPoint pointToInsertBlockquoteElement =
+        pointToPutCaret.IsSet()
+            ? std::move(pointToPutCaret)
+            : EditorBase::GetFirstSelectionStartPoint<EditorDOMPoint>();
+    if (NS_WARN_IF(!pointToInsertBlockquoteElement.IsSet())) {
       return NS_ERROR_FAILURE;
     }
 
     // Make sure we can put a block here.
-    CreateElementResult createNewBlockQuoteElementResult =
+    CreateElementResult createNewBlockquoteElementResult =
         InsertElementWithSplittingAncestorsWithTransaction(
-            *nsGkAtoms::blockquote, atStartOfSelection,
+            *nsGkAtoms::blockquote, pointToInsertBlockquoteElement,
             BRElementNextToSplitPoint::Keep, aEditingHost);
-    if (createNewBlockQuoteElementResult.isErr()) {
+    if (createNewBlockquoteElementResult.isErr()) {
       NS_WARNING(
           "HTMLEditor::InsertElementWithSplittingAncestorsWithTransaction("
           "nsGkAtoms::blockquote) failed");
-      return createNewBlockQuoteElementResult.unwrapErr();
-    }
-    // We'll update selection below after deleting the content nodes and nobody
-    // refers selection until then.  Therefore, we don't need to update
-    // selection here.
-    createNewBlockQuoteElementResult.IgnoreCaretPointSuggestion();
-    RefPtr<Element> newBlockQuoteElement =
-        createNewBlockQuoteElementResult.UnwrapNewNode();
-    MOZ_ASSERT(newBlockQuoteElement);
-    // remember our new block for postprocessing
-    TopLevelEditSubActionDataRef().mNewBlockElement = newBlockQuoteElement;
+      return createNewBlockquoteElementResult.unwrapErr();
+    }
+    createNewBlockquoteElementResult.IgnoreCaretPointSuggestion();
+    RefPtr<Element> newBlockquoteElement =
+        createNewBlockquoteElementResult.UnwrapNewNode();
+    MOZ_ASSERT(newBlockquoteElement);
     // delete anything that was in the list of nodes
     // XXX We don't need to remove the nodes from the array for performance.
     for (const OwningNonNull<nsIContent>& content : arrayOfContents) {
@@ -4784,17 +4759,48 @@
         return rv;
       }
     }
-    // Don't restore the selection
-    restoreSelectionLater.Abort();
-    nsresult rv = CollapseSelectionToStartOf(*newBlockQuoteElement);
+    aRanges.ClearSavedRanges();
+    TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+    nsresult rv = aRanges.Collapse(EditorRawDOMPoint(newBlockquoteElement, 0u));
     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                          "EditorBase::CollapseSelectionToStartOf() failed");
     return rv;
   }
 
+  RefPtr<Element> latestNewBlockElement;
+  auto RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside =
+      [&]() -> nsresult {
+    MOZ_ASSERT(aRanges.HasSavedRanges());
+    aRanges.RestoreFromSavedRanges();
+
+    if (!latestNewBlockElement || !aRanges.IsCollapsed() ||
+        aRanges.Ranges().IsEmpty()) {
+      return NS_OK;
+    }
+
+    const auto firstRangeStartRawPoint =
+        aRanges.GetFirstRangeStartPoint<EditorRawDOMPoint>();
+    if (MOZ_UNLIKELY(!firstRangeStartRawPoint.IsSet())) {
+      return NS_OK;
+    }
+    Result<EditorRawDOMPoint, nsresult> pointInNewBlockElementOrError =
+        HTMLEditUtils::ComputePointToPutCaretInElementIfOutside<
+            EditorRawDOMPoint>(*latestNewBlockElement, firstRangeStartRawPoint);
+    if (MOZ_UNLIKELY(pointInNewBlockElementOrError.isErr())) {
+      NS_WARNING(
+          "HTMLEditUtils::ComputePointToPutCaretInElementIfOutside() failed, "
+          "but ignored");
+      return NS_OK;
+    }
+    if (!pointInNewBlockElementOrError.inspect().IsSet()) {
+      return NS_OK;
+    }
+    return aRanges.Collapse(pointInNewBlockElementOrError.unwrap());
+  };
+
   // Ok, now go through all the nodes and put them in a blockquote,
   // or whatever is appropriate.  Wohoo!
-  RefPtr<Element> curList, curQuote, indentedLI;
+  RefPtr<Element> subListElement, blockquoteElement, indentedListItemElement;
   for (OwningNonNull<nsIContent>& content : arrayOfContents) {
     // Here's where we actually figure out what to do.
     EditorDOMPoint atContent(content);
@@ -4809,34 +4815,26 @@
     }
 
     if (HTMLEditUtils::IsAnyListElement(atContent.GetContainer())) {
-      const RefPtr<Element> listElement = curList;
+      const RefPtr<Element> oldSubListElement = subListElement;
       // MOZ_KnownLive because 'arrayOfContents' is guaranteed to
       // keep it alive.
       Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
-          IndentListChildWithTransaction(&curList, atContent,
+          IndentListChildWithTransaction(&subListElement, atContent,
                                          MOZ_KnownLive(content), aEditingHost);
       if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
         NS_WARNING("HTMLEditor::IndentListChildWithTransaction() failed");
         return pointToPutCaretOrError.unwrapErr();
       }
-      if (listElement != curList) {
+      if (oldSubListElement != subListElement) {
         // New list element is created, so we should put caret into the new list
         // element.
-        TopLevelEditSubActionDataRef().mNewBlockElement = curList;
-      }
-      if (AllowsTransactionsToChangeSelection() &&
-          pointToPutCaretOrError.inspect().IsSet()) {
-        nsresult rv = CollapseSelectionTo(pointToPutCaretOrError.inspect());
-        if (MOZ_UNLIKELY(rv == NS_ERROR_EDITOR_DESTROYED)) {
-          NS_WARNING("EditorBase::CollapseSelectionTo() failed");
-          return NS_ERROR_EDITOR_DESTROYED;
-        }
-        NS_WARNING_ASSERTION(
-            NS_SUCCEEDED(rv),
-            "EditorBase::CollapseSelectionTo() failed, but ignored");
-      }
-      // forget curQuote, if any
-      curQuote = nullptr;
+        latestNewBlockElement = subListElement;
+        TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+      }
+      if (pointToPutCaretOrError.inspect().IsSet()) {
+        pointToPutCaret = pointToPutCaretOrError.unwrap();
+      }
+      blockquoteElement = nullptr;
       continue;
     }
 
@@ -4851,18 +4849,19 @@
     if (RefPtr<Element> listItem =
             HTMLEditUtils::GetClosestAncestorListItemElement(content,
                                                              &aEditingHost)) {
-      if (indentedLI == listItem) {
+      if (indentedListItemElement == listItem) {
         // already indented this list item
         continue;
       }
-      // check to see if curList is still appropriate.  Which it is if
+      // check to see if subListElement is still appropriate.  Which it is if
       // content is still right after it in the same list.
       nsIContent* previousEditableSibling =
-          curList ? HTMLEditUtils::GetPreviousSibling(
-                        *listItem, {WalkTreeOption::IgnoreNonEditableNode})
-                  : nullptr;
-      if (!curList ||
-          (previousEditableSibling && previousEditableSibling != curList)) {
+          subListElement
+              ? HTMLEditUtils::GetPreviousSibling(
+                    *listItem, {WalkTreeOption::IgnoreNonEditableNode})
+              : nullptr;
+      if (!subListElement || (previousEditableSibling &&
+                              previousEditableSibling != subListElement)) {
         EditorDOMPoint atListItem(listItem);
         if (NS_WARN_IF(!listItem)) {
           return NS_ERROR_FAILURE;
@@ -4882,37 +4881,26 @@
                          .get());
           return createNewListElementResult.unwrapErr();
         }
-        nsresult rv = createNewListElementResult.SuggestCaretPointTo(
-            *this, {SuggestCaret::OnlyIfHasSuggestion,
-                    SuggestCaret::OnlyIfTransactionsAllowedToDoIt});
-        if (NS_FAILED(rv)) {
-          NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-          return rv;
+        if (createNewListElementResult.HasCaretPointSuggestion()) {
+          pointToPutCaret = createNewListElementResult.UnwrapCaretPoint();
         }
         MOZ_ASSERT(createNewListElementResult.GetNewNode());
-        curList = createNewListElementResult.UnwrapNewNode();
-      }
-
-      const MoveNodeResult moveListItemElementResult =
-          MoveNodeToEndWithTransaction(*listItem, *curList);
+        subListElement = createNewListElementResult.UnwrapNewNode();
+      }
+
+      MoveNodeResult moveListItemElementResult =
+          MoveNodeToEndWithTransaction(*listItem, *subListElement);
       if (moveListItemElementResult.isErr()) {
         NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
         return moveListItemElementResult.unwrapErr();
       }
-      nsresult rv = moveListItemElementResult.SuggestCaretPointTo(
-          *this, {SuggestCaret::OnlyIfHasSuggestion,
-                  SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                  SuggestCaret::AndIgnoreTrivialError});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-        return rv;
-      }
-      NS_WARNING_ASSERTION(
-          rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-          "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
-
-      // remember we indented this li
-      indentedLI = listItem;
+      if (moveListItemElementResult.HasCaretPointSuggestion()) {
+        pointToPutCaret = moveListItemElementResult.UnwrapCaretPoint();
+      }
+
+      // Remember the list item element which we indented now for ignoring its
+      // children to avoid using <blockquote> in it.
+      indentedListItemElement = std::move(listItem);
 
       continue;
     }
@@ -4921,70 +4909,67 @@
     // or if this node doesn't go in blockquote we used earlier.
     // One reason it might not go in prio blockquote is if we are now
     // in a different table cell.
-    if (curQuote &&
-        HTMLEditUtils::GetInclusiveAncestorAnyTableElement(*curQuote) !=
+    if (blockquoteElement &&
+        HTMLEditUtils::GetInclusiveAncestorAnyTableElement(
+            *blockquoteElement) !=
             HTMLEditUtils::GetInclusiveAncestorAnyTableElement(content)) {
-      curQuote = nullptr;
-    }
-
-    if (!curQuote) {
+      blockquoteElement = nullptr;
+    }
+
+    if (!blockquoteElement) {
       // First, check that our element can contain a blockquote.
       if (!HTMLEditUtils::CanNodeContain(*atContent.GetContainer(),
                                          *nsGkAtoms::blockquote)) {
-        return NS_OK;  // cancelled
-      }
-
-      CreateElementResult createNewBlockQuoteElementResult =
+        // XXX This is odd, why do we stop indenting remaining content nodes?
+        //     Perhaps, `continue` is better.
+        nsresult rv =
+            RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside();
+        NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
+                             "RestoreSavedRangesAndCollapseInLatestBlockElement"
+                             "IfOutside() failed");
+        return rv;
+      }
+
+      CreateElementResult createNewBlockquoteElementResult =
           InsertElementWithSplittingAncestorsWithTransaction(
               *nsGkAtoms::blockquote, atContent,
               BRElementNextToSplitPoint::Keep, aEditingHost);
-      if (createNewBlockQuoteElementResult.isErr()) {
+      if (createNewBlockquoteElementResult.isErr()) {
         NS_WARNING(
             "HTMLEditor::InsertElementWithSplittingAncestorsWithTransaction("
             "nsGkAtoms::blockquote) failed");
-        return createNewBlockQuoteElementResult.unwrapErr();
-      }
-      nsresult rv = createNewBlockQuoteElementResult.SuggestCaretPointTo(
-          *this, {SuggestCaret::OnlyIfHasSuggestion,
-                  SuggestCaret::OnlyIfTransactionsAllowedToDoIt});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-        return rv;
-      }
-
-      RefPtr<Element> newBlockQuoteElement =
-          createNewBlockQuoteElementResult.UnwrapNewNode();
-      MOZ_ASSERT(newBlockQuoteElement);
-      // remember our new block for postprocessing
-      TopLevelEditSubActionDataRef().mNewBlockElement = newBlockQuoteElement;
-      curQuote = std::move(newBlockQuoteElement);
-      // curQuote is now the correct thing to put curNode in
+        return createNewBlockquoteElementResult.unwrapErr();
+      }
+      if (createNewBlockquoteElementResult.HasCaretPointSuggestion()) {
+        pointToPutCaret = createNewBlockquoteElementResult.UnwrapCaretPoint();
+      }
+
+      MOZ_ASSERT(createNewBlockquoteElementResult.GetNewNode());
+      blockquoteElement = createNewBlockquoteElementResult.UnwrapNewNode();
+      latestNewBlockElement = blockquoteElement;
+      TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
     }
 
     // tuck the node into the end of the active blockquote
     // MOZ_KnownLive because 'arrayOfContents' is guaranteed to
     // keep it alive.
-    const MoveNodeResult moveNodeResult =
-        MoveNodeToEndWithTransaction(MOZ_KnownLive(content), *curQuote);
+    MoveNodeResult moveNodeResult = MoveNodeToEndWithTransaction(
+        MOZ_KnownLive(content), *blockquoteElement);
     if (moveNodeResult.isErr()) {
       NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
       return moveNodeResult.unwrapErr();
     }
-    nsresult rv = moveNodeResult.SuggestCaretPointTo(
-        *this, {SuggestCaret::OnlyIfHasSuggestion,
-                SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                SuggestCaret::AndIgnoreTrivialError});
-    if (NS_FAILED(rv)) {
-      NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-      return rv;
-    }
-    NS_WARNING_ASSERTION(
-        rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-        "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
-    // forget curList, if any
-    curList = nullptr;
-  }
-  return NS_OK;
+    if (moveNodeResult.HasCaretPointSuggestion()) {
+      pointToPutCaret = moveNodeResult.UnwrapCaretPoint();
+    }
+    subListElement = nullptr;
+  }
+
+  nsresult rv = RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside();
+  NS_WARNING_ASSERTION(
+      NS_SUCCEEDED(rv),
+      "RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside() failed");
+  return rv;
 }
 
 EditActionResult HTMLEditor::OutdentAsSubAction(const Element& aEditingHost) {