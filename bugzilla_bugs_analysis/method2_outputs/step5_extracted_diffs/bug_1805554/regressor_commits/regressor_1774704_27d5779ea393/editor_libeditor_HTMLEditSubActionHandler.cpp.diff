# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 27d5779ea393
# Full Hash: 27d5779ea393837b1e10b00725cbc58c2e5495ac
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 09:46:07
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 7-5: Make `HTMLEditor::AlignContentsAtSelectionWithEmptyDivElement` stop touching `Selection` directly and setting `mNewBlockElement` r=m_kato
#   
#   It's only caller is `HTMLEditor::AlignContentsAtSelection` which is called only
#   by `HTMLEditor::AlignAsSubAction` at almost last of it.  Therefore, it's safe
#   to handle `mNewBlockElement` at the caller of
# ==============================================================================

diff -r 808c433c7774 -r 27d5779ea393 editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 04:40:14 2022 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 04:53:54 2022 +0000
@@ -6125,19 +6125,24 @@
   }
 
   if (createEmptyDivElement) {
-    if (IsSelectionRangeContainerNotContent()) {
+    if (!SelectionRef().RangeCount() || IsSelectionRangeContainerNotContent()) {
       NS_WARNING("Mutaiton event listener might have changed the selection");
       return NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE;
     }
-    EditActionResult result =
-        AlignContentsAtSelectionWithEmptyDivElement(aAlignType);
-    NS_WARNING_ASSERTION(
-        result.Succeeded(),
-        "HTMLEditor::AlignContentsAtSelectionWithEmptyDivElement() failed");
-    if (result.Handled()) {
-      restoreSelectionLater.Abort();
-    }
-    return result.Rv();
+    const auto pointToInsertDivElement =
+        GetFirstSelectionStartPoint<EditorDOMPoint>();
+    CreateElementResult newDivElementOrError = InsertDivElementToAlignContents(
+        pointToInsertDivElement, aAlignType, aEditingHost);
+    if (newDivElementOrError.isErr()) {
+      NS_WARNING("HTMLEditor::InsertDivElementToAlignContents() failed");
+      return newDivElementOrError.unwrapErr();
+    }
+    restoreSelectionLater.Abort();
+    TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+    nsresult rv = newDivElementOrError.SuggestCaretPointTo(*this, {});
+    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
+                         "CreateElementResult::SuggestCaretPointTo() failed");
+    return rv;
   }
 
   nsresult rv = AlignNodesAndDescendants(arrayOfContents, aAlignType);
@@ -6146,44 +6151,33 @@
   return rv;
 }
 
-EditActionResult HTMLEditor::AlignContentsAtSelectionWithEmptyDivElement(
-    const nsAString& aAlignType) {
+CreateElementResult HTMLEditor::InsertDivElementToAlignContents(
+    const EditorDOMPoint& aPointToInsert, const nsAString& aAlignType,
+    const Element& aEditingHost) {
   MOZ_ASSERT(IsTopLevelEditSubActionDataAvailable());
   MOZ_ASSERT(!IsSelectionRangeContainerNotContent());
-
-  RefPtr<Element> editingHost = ComputeEditingHost();
-  if (MOZ_UNLIKELY(NS_WARN_IF(!editingHost))) {
-    return EditActionResult(NS_ERROR_FAILURE);
-  }
-
-  const nsRange* firstRange = SelectionRef().GetRangeAt(0);
-  if (NS_WARN_IF(!firstRange)) {
-    return EditActionResult(NS_ERROR_FAILURE);
-  }
-
-  EditorDOMPoint atStartOfSelection(firstRange->StartRef());
-  if (NS_WARN_IF(!atStartOfSelection.IsSet())) {
-    return EditActionResult(NS_ERROR_FAILURE);
+  MOZ_ASSERT(aPointToInsert.IsSetAndValid());
+
+  if (NS_WARN_IF(!aPointToInsert.IsSet())) {
+    return CreateElementResult(NS_ERROR_FAILURE);
   }
 
   CreateElementResult createNewDivElementResult =
       InsertElementWithSplittingAncestorsWithTransaction(
-          *nsGkAtoms::div, atStartOfSelection,
-          BRElementNextToSplitPoint::Delete, *editingHost);
+          *nsGkAtoms::div, aPointToInsert, BRElementNextToSplitPoint::Delete,
+          aEditingHost);
   if (createNewDivElementResult.isErr()) {
     NS_WARNING(
         "HTMLEditor::InsertElementWithSplittingAncestorsWithTransaction("
         "nsGkAtoms::div, BRElementNextToSplitPoint::Delete) failed");
-    return EditActionResult(createNewDivElementResult.unwrapErr());
-  }
-  // We'll update selection below and nobody refers selection until then.
-  // Therefore, we don't need to update selection here.
+    return createNewDivElementResult;
+  }
+  // We'll suggest start of the new <div>, so we don't need the suggested
+  // position.
   createNewDivElementResult.IgnoreCaretPointSuggestion();
 
+  MOZ_ASSERT(createNewDivElementResult.GetNewNode());
   RefPtr<Element> newDivElement = createNewDivElementResult.UnwrapNewNode();
-  MOZ_ASSERT(newDivElement);
-  // Remember our new block for postprocessing
-  TopLevelEditSubActionDataRef().mNewBlockElement = newDivElement;
   // Set up the alignment on the div, using HTML or CSS
   Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
       SetBlockElementAlign(*newDivElement, aAlignType,
@@ -6192,9 +6186,9 @@
     NS_WARNING(
         "HTMLEditor::SetBlockElementAlign(EditTarget::"
         "OnlyDescendantsExceptTable) failed");
-    return EditActionResult(pointToPutCaretOrError.unwrapErr());
-  }
-  // We don't need to put caret here because we'll put caret below.
+    return CreateElementResult(pointToPutCaretOrError.unwrapErr());
+  }
+  // We don't need the new suggested position too.
 
   // Put in a padding <br> element for empty last line so that it won't get
   // deleted.
@@ -6205,13 +6199,11 @@
     NS_WARNING(
         "HTMLEditor::InsertPaddingBRElementForEmptyLastLineWithTransaction() "
         "failed");
-    return EditActionResult(insertPaddingBRElementResult.unwrapErr());
+    return insertPaddingBRElementResult;
   }
   insertPaddingBRElementResult.IgnoreCaretPointSuggestion();
-  nsresult rv = CollapseSelectionToStartOf(*newDivElement);
-  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
-                       "EditorBase::CollapseSelectionToStartOf() failed");
-  return EditActionHandled(rv);
+
+  return CreateElementResult(newDivElement, EditorDOMPoint(newDivElement, 0u));
 }
 
 nsresult HTMLEditor::AlignNodesAndDescendants(