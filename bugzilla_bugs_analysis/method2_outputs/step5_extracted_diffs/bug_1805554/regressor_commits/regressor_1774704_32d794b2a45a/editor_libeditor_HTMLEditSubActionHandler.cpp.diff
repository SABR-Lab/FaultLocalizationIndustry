# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 32d794b2a45a
# Full Hash: 32d794b2a45a300cd0f5b07dcac5ab5a8a89fb23
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 09:46:07
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 4-4: Make `HTMLEditor::ChangeSelectedHardLinesToList` stop setting `TopLevelEditSubActionData::mNewBlockElement` r=m_kato
#   
#   With taking an `AutoRangeArray` which is initialized with `Selection`, it can
#   restore selection and check if it's collapsed and if collapsed in the expected
#   list element.  Then, its caller can apply the returned range to `Selection`
# ==============================================================================

diff -r 23d50b5617de -r 32d794b2a45a editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 02:12:03 2022 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 02:28:11 2022 +0000
@@ -3106,131 +3106,133 @@
     }
   }
 
-  // ChangeSelectedHardLinesToList() creates AutoSelectionRestorer.
-  // Therefore, even if it returns NS_OK, editor might have been destroyed
-  // at restoring Selection.
-  result = ChangeSelectedHardLinesToList(
-      MOZ_KnownLive(*listTagName), MOZ_KnownLive(*listItemTagName), aBulletType,
-      aSelectAllOfCurrentList, *editingHost);
+  AutoRangeArray selectionRanges(SelectionRef());
+  result = ConvertContentAroundRangesToList(
+      selectionRanges, MOZ_KnownLive(*listTagName),
+      MOZ_KnownLive(*listItemTagName), aBulletType, aSelectAllOfCurrentList,
+      *editingHost);
+  if (MOZ_UNLIKELY(result.Failed())) {
+    NS_WARNING("HTMLEditor::ConvertContentAroundRangesToList() failed");
+    // XXX Should we try to restore selection ranges in this case?
+    return result;
+  }
+
+  rv = selectionRanges.ApplyTo(SelectionRef());
   if (NS_WARN_IF(Destroyed())) {
     return EditActionResult(NS_ERROR_EDITOR_DESTROYED);
   }
-  NS_WARNING_ASSERTION(result.Succeeded(),
-                       "HTMLEditor::ChangeSelectedHardLinesToList() failed");
-  return result;
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::ApplyTo() failed");
+  return result.Ignored() ? EditActionCanceled(rv) : EditActionHandled(rv);
 }
 
-EditActionResult HTMLEditor::ChangeSelectedHardLinesToList(
-    nsAtom& aListElementTagName, nsAtom& aListItemElementTagName,
-    const nsAString& aBulletType,
+EditActionResult HTMLEditor::ConvertContentAroundRangesToList(
+    AutoRangeArray& aRanges, nsAtom& aListElementTagName,
+    nsAtom& aListItemElementTagName, const nsAString& aBulletType,
     SelectAllOfCurrentList aSelectAllOfCurrentList,
     const Element& aEditingHost) {
   MOZ_ASSERT(IsTopLevelEditSubActionDataAvailable());
   MOZ_ASSERT(!IsSelectionRangeContainerNotContent());
 
-  AutoSelectionRestorer restoreSelectionLater(*this);
+  if (NS_WARN_IF(!aRanges.SaveAndTrackRanges(*this))) {
+    return EditActionResult(NS_ERROR_FAILURE);
+  }
 
   AutoTArray<OwningNonNull<nsIContent>, 64> arrayOfContents;
 
-  {
-    AutoRangeArray selectionRanges(SelectionRef());
-    Element* parentListElement =
-        aSelectAllOfCurrentList == SelectAllOfCurrentList::Yes
-            ? selectionRanges.GetClosestAncestorAnyListElementOfRange()
-            : nullptr;
-    if (parentListElement) {
-      arrayOfContents.AppendElement(
-          OwningNonNull<nsIContent>(*parentListElement));
-    } else {
-      // TODO: We don't need AutoTransactionsConserveSelection here in the
-      //       normal cases, but removing this may cause the behavior with the
-      //       legacy mutation event listeners.  We should try to delete this in
-      //       a bug.
-      AutoTransactionsConserveSelection dontChangeMySelection(*this);
-
-      selectionRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
-          EditSubAction::eCreateOrChangeList, aEditingHost);
-      Result<EditorDOMPoint, nsresult> splitResult =
-          selectionRanges
-              .SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries(
-                  *this);
-      if (MOZ_UNLIKELY(splitResult.isErr())) {
-        NS_WARNING(
-            "AutoRangeArray::"
-            "SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries()"
-            " failed");
-        return EditActionResult(splitResult.unwrapErr());
-      }
-      nsresult rv = selectionRanges.CollectEditTargetNodes(
-          *this, arrayOfContents, EditSubAction::eCreateOrChangeList,
-          AutoRangeArray::CollectNonEditableNodes::No);
-      if (NS_FAILED(rv)) {
-        NS_WARNING(
-            "AutoRangeArray::CollectEditTargetNodes(EditSubAction::"
-            "eCreateOrChangeList, CollectNonEditableNodes::No) failed");
-        return EditActionResult(rv);
-      }
-
-      const Result<EditorDOMPoint, nsresult> splitAtBRElementsResult =
-          MaybeSplitElementsAtEveryBRElement(
-              arrayOfContents, EditSubAction::eCreateOrChangeList);
-      if (MOZ_UNLIKELY(splitAtBRElementsResult.isErr())) {
-        NS_WARNING(
-            "HTMLEditor::MaybeSplitElementsAtEveryBRElement(EditSubAction::"
-            "eCreateOrChangeList) failed");
-        return EditActionResult(splitAtBRElementsResult.inspectErr());
-      }
+  if (Element* parentListElement =
+          aSelectAllOfCurrentList == SelectAllOfCurrentList::Yes
+              ? aRanges.GetClosestAncestorAnyListElementOfRange()
+              : nullptr) {
+    arrayOfContents.AppendElement(
+        OwningNonNull<nsIContent>(*parentListElement));
+  } else {
+    AutoRangeArray extendedRanges(aRanges);
+
+    // TODO: We don't need AutoTransactionsConserveSelection here in the
+    //       normal cases, but removing this may cause the behavior with the
+    //       legacy mutation event listeners.  We should try to delete this in
+    //       a bug.
+    AutoTransactionsConserveSelection dontChangeMySelection(*this);
+
+    extendedRanges.ExtendRangesToWrapLinesToHandleBlockLevelEditAction(
+        EditSubAction::eCreateOrChangeList, aEditingHost);
+    Result<EditorDOMPoint, nsresult> splitResult =
+        extendedRanges
+            .SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries(
+                *this);
+    if (MOZ_UNLIKELY(splitResult.isErr())) {
+      NS_WARNING(
+          "AutoRangeArray::"
+          "SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries() "
+          "failed");
+      return EditActionResult(splitResult.unwrapErr());
+    }
+    nsresult rv = extendedRanges.CollectEditTargetNodes(
+        *this, arrayOfContents, EditSubAction::eCreateOrChangeList,
+        AutoRangeArray::CollectNonEditableNodes::No);
+    if (NS_FAILED(rv)) {
+      NS_WARNING(
+          "AutoRangeArray::CollectEditTargetNodes(EditSubAction::"
+          "eCreateOrChangeList, CollectNonEditableNodes::No) failed");
+      return EditActionResult(rv);
+    }
+
+    const Result<EditorDOMPoint, nsresult> splitAtBRElementsResult =
+        MaybeSplitElementsAtEveryBRElement(arrayOfContents,
+                                           EditSubAction::eCreateOrChangeList);
+    if (MOZ_UNLIKELY(splitAtBRElementsResult.isErr())) {
+      NS_WARNING(
+          "HTMLEditor::MaybeSplitElementsAtEveryBRElement(EditSubAction::"
+          "eCreateOrChangeList) failed");
+      return EditActionResult(splitAtBRElementsResult.inspectErr());
     }
   }
 
   // check if all our nodes are <br>s, or empty inlines
-  bool bOnlyBreaks = true;
-  for (auto& content : arrayOfContents) {
-    // if content is not a Break or empty inline, we're done
-    if (!content->IsHTMLElement(nsGkAtoms::br) &&
-        !HTMLEditUtils::IsEmptyInlineContainer(
-            content, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
-      bOnlyBreaks = false;
-      break;
-    }
-  }
+  auto IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements =
+      [](const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents) {
+        for (auto& content : aArrayOfContents) {
+          // if content is not a Break or empty inline, we're done
+          if (!content->IsHTMLElement(nsGkAtoms::br) &&
+              !HTMLEditUtils::IsEmptyInlineContainer(
+                  content, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+            return false;
+          }
+        }
+        return true;
+      };
 
   // if no nodes, we make empty list.  Ditto if the user tried to make a list
   // of some # of breaks.
-  if (arrayOfContents.IsEmpty() || bOnlyBreaks) {
+  if (IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements(arrayOfContents)) {
     // if only breaks, delete them
-    if (bOnlyBreaks) {
-      for (auto& content : arrayOfContents) {
-        // MOZ_KnownLive because 'arrayOfContents' is guaranteed to
-        // keep it alive.
-        nsresult rv = DeleteNodeWithTransaction(MOZ_KnownLive(*content));
-        if (NS_FAILED(rv)) {
-          NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
-          return EditActionResult(rv);
-        }
-      }
-    }
-
-    const nsRange* firstRange = SelectionRef().GetRangeAt(0);
-    if (NS_WARN_IF(!firstRange)) {
-      return EditActionResult(NS_ERROR_FAILURE);
-    }
-
-    EditorDOMPoint atStartOfSelection(firstRange->StartRef());
-    if (NS_WARN_IF(!atStartOfSelection.IsSet())) {
+    for (auto& content : arrayOfContents) {
+      // MOZ_KnownLive because 'arrayOfContents' is guaranteed to
+      // keep it alive.
+      nsresult rv = DeleteNodeWithTransaction(MOZ_KnownLive(*content));
+      if (NS_FAILED(rv)) {
+        NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
+        return EditActionResult(rv);
+      }
+    }
+
+    const auto firstRangeStartPoint =
+        aRanges.GetFirstRangeStartPoint<EditorDOMPoint>();
+    if (NS_WARN_IF(!firstRangeStartPoint.IsSet())) {
       return EditActionResult(NS_ERROR_FAILURE);
     }
 
     // Make sure we can put a list here.
-    if (!HTMLEditUtils::CanNodeContain(*atStartOfSelection.GetContainer(),
+    if (!HTMLEditUtils::CanNodeContain(*firstRangeStartPoint.GetContainer(),
                                        aListElementTagName)) {
+      aRanges.RestoreFromSavedRanges();
       return EditActionCanceled();
     }
 
     RefPtr<Element> newListItemElement;
     CreateElementResult createNewListElementResult =
         InsertElementWithSplittingAncestorsWithTransaction(
-            aListElementTagName, atStartOfSelection,
+            aListElementTagName, firstRangeStartPoint,
             BRElementNextToSplitPoint::Keep, aEditingHost,
             // MOZ_CAN_RUN_SCRIPT_BOUNDARY due to bug 1758868
             [&newListItemElement, &aListItemElementTagName](
@@ -3255,7 +3257,7 @@
                   // There is AutoSelectionRestorer in this method so that it'll
                   // be restored or updated with making it abort.  Therefore,
                   // we don't need to update selection here.
-                  // XXX I'd like to check restoreSelectionLater here, but it
+                  // XXX I'd like to check aRanges.HasSavedRanges() here, but it
                   //     requires ifdefs to avoid bustage of opt builds caused
                   //     by unused warning...
                   createNewListItemElementResult.IgnoreCaretPointSuggestion();
@@ -3275,14 +3277,12 @@
     }
     MOZ_ASSERT(createNewListElementResult.GetNewNode());
 
-    // remember our new block for postprocessing
-    TopLevelEditSubActionDataRef().mNewBlockElement = newListItemElement;
+    TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
     // Put selection in new list item and don't restore the Selection.
     createNewListElementResult.IgnoreCaretPointSuggestion();
-    restoreSelectionLater.Abort();
-    nsresult rv = CollapseSelectionToStartOf(*newListItemElement);
-    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
-                         "EditorBase::CollapseSelectionToStartOf() failed");
+    aRanges.ClearSavedRanges();
+    nsresult rv = aRanges.Collapse(EditorRawDOMPoint(newListItemElement, 0u));
+    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::Collapse() failed");
     return EditActionResult(rv);
   }
 
@@ -3307,14 +3307,14 @@
   }
 
   // Ok, now go through all the nodes and put then in the list,
-  // or whatever is approriate.  Wohoo!
+  // or whatever is appropriate.  Wohoo!
 
   uint32_t countOfCollectedContents = arrayOfContents.Length();
-  RefPtr<Element> curList, prevListItem;
+  RefPtr<Element> curList, prevListItem, listItemOrListToPutCaret;
 
   for (uint32_t i = 0; i < countOfCollectedContents; i++) {
     // here's where we actually figure out what to do
-    OwningNonNull<nsIContent> content = arrayOfContents[i];
+    const OwningNonNull<nsIContent> content = arrayOfContents[i];
 
     // make sure we don't assemble content that is in different table cells
     // into the same list.  respect table cell boundaries when listifying.
@@ -3351,37 +3351,21 @@
             MoveNodeToEndWithTransaction(*content, *curList);
         if (moveNodeResult.isErr()) {
           NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
-          return EditActionResult(moveNodeResult.unwrapErr());
-        }
-        nsresult rv = moveNodeResult.SuggestCaretPointTo(
-            *this, {SuggestCaret::OnlyIfHasSuggestion,
-                    SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                    SuggestCaret::AndIgnoreTrivialError});
-        if (NS_FAILED(rv)) {
-          NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-          return EditActionResult(rv);
-        }
-        NS_WARNING_ASSERTION(
-            rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-            "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
-        CreateElementResult convertListTypeResult =
+          return EditActionResult(moveNodeResult.inspectErr());
+        }
+        MOZ_ASSERT(aRanges.HasSavedRanges());
+        moveNodeResult.IgnoreCaretPointSuggestion();
+
+        const CreateElementResult convertListTypeResult =
             ChangeListElementType(MOZ_KnownLive(*content->AsElement()),
                                   aListElementTagName, aListItemElementTagName);
         if (convertListTypeResult.isErr()) {
           NS_WARNING("HTMLEditor::ChangeListElementType() failed");
-          return EditActionResult(convertListTypeResult.unwrapErr());
-        }
-        rv = convertListTypeResult.SuggestCaretPointTo(
-            *this, {SuggestCaret::OnlyIfHasSuggestion,
-                    SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                    SuggestCaret::AndIgnoreTrivialError});
-        if (NS_FAILED(rv)) {
-          NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-          return EditActionResult(rv);
-        }
-        NS_WARNING_ASSERTION(
-            rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-            "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+          return EditActionResult(convertListTypeResult.inspectErr());
+        }
+        MOZ_ASSERT(aRanges.HasSavedRanges());
+        convertListTypeResult.IgnoreCaretPointSuggestion();
+
         const Result<EditorDOMPoint, nsresult> unwrapNewListElementResult =
             RemoveBlockContainerWithTransaction(
                 MOZ_KnownLive(*convertListTypeResult.GetNewNode()));
@@ -3390,15 +3374,8 @@
               "HTMLEditor::RemoveBlockContainerWithTransaction() failed");
           return EditActionResult(unwrapNewListElementResult.inspectErr());
         }
-        const EditorDOMPoint& pointToPutCaret =
-            unwrapNewListElementResult.inspect();
-        if (AllowsTransactionsToChangeSelection() && pointToPutCaret.IsSet()) {
-          nsresult rv = CollapseSelectionTo(pointToPutCaret);
-          if (NS_FAILED(rv)) {
-            NS_WARNING("EditorBase::CollapseSelectionTo() failed");
-            return EditActionResult(rv);
-          }
-        }
+        MOZ_ASSERT(aRanges.HasSavedRanges());  // So, ignore the suggested point
+
         prevListItem = nullptr;
         continue;
       }
@@ -3412,17 +3389,9 @@
         NS_WARNING("HTMLEditor::ChangeListElementType() failed");
         return EditActionResult(convertListTypeResult.unwrapErr());
       }
-      nsresult rv = convertListTypeResult.SuggestCaretPointTo(
-          *this, {SuggestCaret::OnlyIfHasSuggestion,
-                  SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                  SuggestCaret::AndIgnoreTrivialError});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-        return EditActionResult(rv);
-      }
-      NS_WARNING_ASSERTION(
-          rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-          "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+      MOZ_ASSERT(aRanges.HasSavedRanges());
+      convertListTypeResult.IgnoreCaretPointSuggestion();
+      MOZ_ASSERT(convertListTypeResult.GetNewNode());
       curList = convertListTypeResult.UnwrapNewNode();
       prevListItem = nullptr;
       continue;
@@ -3435,25 +3404,25 @@
     MOZ_ASSERT(atContent.IsSetAndValid());
     if (HTMLEditUtils::IsListItem(content)) {
       // If current list item element is not in proper list element, we need
-      // to conver the list element.
+      // to convert the list element.
       if (!atContent.IsContainerHTMLElement(&aListElementTagName)) {
         // If we've not met a list element or current node is not in current
         // list element, insert a list element at current node and set
         // current list element to the new one.
         if (!curList || EditorUtils::IsDescendantOf(*content, *curList)) {
-          if (NS_WARN_IF(!atContent.GetContainerAsContent())) {
+          if (NS_WARN_IF(!atContent.IsInContentNode())) {
             return EditActionResult(NS_ERROR_FAILURE);
           }
           const SplitNodeResult splitListItemParentResult =
               SplitNodeWithTransaction(atContent);
           if (splitListItemParentResult.isErr()) {
             NS_WARNING("HTMLEditor::SplitNodeWithTransaction() failed");
-            return EditActionResult(splitListItemParentResult.unwrapErr());
+            return EditActionResult(splitListItemParentResult.inspectErr());
           }
           MOZ_ASSERT(splitListItemParentResult.DidSplit());
-          // We'll update selection after creating new list element below.
-          // Therefore, we don't need to handle selection now.
+          MOZ_ASSERT(aRanges.HasSavedRanges());
           splitListItemParentResult.IgnoreCaretPointSuggestion();
+
           CreateElementResult createNewListElementResult =
               CreateAndInsertElement(
                   WithTransaction::Yes, aListElementTagName,
@@ -3464,19 +3433,10 @@
                 "failed");
             return EditActionResult(createNewListElementResult.unwrapErr());
           }
-          nsresult rv = createNewListElementResult.SuggestCaretPointTo(
-              *this, {SuggestCaret::OnlyIfHasSuggestion,
-                      SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                      SuggestCaret::AndIgnoreTrivialError});
-          if (NS_FAILED(rv)) {
-            NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-            return EditActionResult(NS_ERROR_EDITOR_DESTROYED);
-          }
-          NS_WARNING_ASSERTION(
-              rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-              "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+          MOZ_ASSERT(aRanges.HasSavedRanges());
+          createNewListElementResult.IgnoreCaretPointSuggestion();
+          MOZ_ASSERT(createNewListElementResult.GetNewNode());
           curList = createNewListElementResult.UnwrapNewNode();
-          MOZ_ASSERT(curList);
         }
         // Then, move current node into current list element.
         const MoveNodeResult moveNodeResult =
@@ -3485,17 +3445,9 @@
           NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
           return EditActionResult(moveNodeResult.unwrapErr());
         }
-        nsresult rv = moveNodeResult.SuggestCaretPointTo(
-            *this, {SuggestCaret::OnlyIfHasSuggestion,
-                    SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                    SuggestCaret::AndIgnoreTrivialError});
-        if (NS_FAILED(rv)) {
-          NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-          return EditActionResult(rv);
-        }
-        NS_WARNING_ASSERTION(
-            rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-            "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
+        MOZ_ASSERT(aRanges.HasSavedRanges());
+        moveNodeResult.IgnoreCaretPointSuggestion();
+
         // Convert list item type if current node is different list item type.
         if (!content->IsHTMLElement(&aListItemElementTagName)) {
           const CreateElementResult newListItemElementOrError =
@@ -3506,17 +3458,8 @@
             NS_WARNING("HTMLEditor::ReplaceContainerWithTransaction() failed");
             return EditActionResult(newListItemElementOrError.inspectErr());
           }
-          nsresult rv = newListItemElementOrError.SuggestCaretPointTo(
-              *this, {SuggestCaret::OnlyIfHasSuggestion,
-                      SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                      SuggestCaret::AndIgnoreTrivialError});
-          if (NS_FAILED(rv)) {
-            NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-            return EditActionResult(rv);
-          }
-          NS_WARNING_ASSERTION(
-              rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-              "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+          MOZ_ASSERT(aRanges.HasSavedRanges());
+          newListItemElementOrError.IgnoreCaretPointSuggestion();
         }
       } else {
         // If we've not met a list element, set current list element to the
@@ -3534,19 +3477,10 @@
               MoveNodeToEndWithTransaction(*content, *curList);
           if (moveNodeResult.isErr()) {
             NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
-            return EditActionResult(moveNodeResult.unwrapErr());
+            return EditActionResult(moveNodeResult.inspectErr());
           }
-          nsresult rv = moveNodeResult.SuggestCaretPointTo(
-              *this, {SuggestCaret::OnlyIfHasSuggestion,
-                      SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                      SuggestCaret::AndIgnoreTrivialError});
-          if (NS_FAILED(rv)) {
-            NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-            return EditActionResult(rv);
-          }
-          NS_WARNING_ASSERTION(
-              rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-              "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
+          MOZ_ASSERT(aRanges.HasSavedRanges());
+          moveNodeResult.IgnoreCaretPointSuggestion();
         }
         // Then, if current list item element is not proper type for current
         // list element, convert list item element to proper element.
@@ -3559,17 +3493,8 @@
             NS_WARNING("HTMLEditor::ReplaceContainerWithTransaction() failed");
             return EditActionResult(newListItemElementOrError.inspectErr());
           }
-          nsresult rv = newListItemElementOrError.SuggestCaretPointTo(
-              *this, {SuggestCaret::OnlyIfHasSuggestion,
-                      SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                      SuggestCaret::AndIgnoreTrivialError});
-          if (NS_FAILED(rv)) {
-            NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-            return EditActionResult(rv);
-          }
-          NS_WARNING_ASSERTION(
-              rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-              "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+          MOZ_ASSERT(aRanges.HasSavedRanges());
+          newListItemElementOrError.IgnoreCaretPointSuggestion();
         }
       }
       Element* element = Element::FromNode(content);
@@ -3631,14 +3556,8 @@
         NS_WARNING("HTMLEditor::RemoveContainerWithTransaction() failed");
         return EditActionResult(unwrapDivElementResult.inspectErr());
       }
-      const EditorDOMPoint& pointToPutCaret = unwrapDivElementResult.inspect();
-      if (AllowsTransactionsToChangeSelection() && pointToPutCaret.IsSet()) {
-        nsresult rv = CollapseSelectionTo(pointToPutCaret);
-        if (NS_FAILED(rv)) {
-          NS_WARNING("EditorBase::CollapseSelectionTo() failed");
-          return EditActionResult(rv);
-        }
-      }
+      MOZ_ASSERT(aRanges.HasSavedRanges());  // So, ignore the suggested point
+
       // Extend the loop length to handle all children collected here.
       countOfCollectedContents = arrayOfContents.Length();
       continue;
@@ -3661,17 +3580,14 @@
                 .get());
         return EditActionResult(createNewListElementResult.unwrapErr());
       }
-      // We'll restore selection so that we don't need to update selection now.
+      MOZ_ASSERT(aRanges.HasSavedRanges());
       createNewListElementResult.IgnoreCaretPointSuggestion();
-      MOZ_ASSERT(restoreSelectionLater.MaybeRestoreSelectionLater());
 
       MOZ_ASSERT(createNewListElementResult.GetNewNode());
+      listItemOrListToPutCaret = createNewListElementResult.GetNewNode();
+      TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+
       curList = createNewListElementResult.UnwrapNewNode();
-      // Set new block element of top level edit sub-action to the new list
-      // element for setting selection into it.
-      // XXX This must be wrong.  If we're handling nested edit action,
-      //     we shouldn't overwrite the new block element.
-      TopLevelEditSubActionDataRef().mNewBlockElement = curList;
 
       // atContent is now referring the right node with mOffset but
       // referring the left node with mRef.  So, invalidate it now.
@@ -3687,17 +3603,8 @@
         NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
         return EditActionResult(moveInlineElementResult.unwrapErr());
       }
-      nsresult rv = moveInlineElementResult.SuggestCaretPointTo(
-          *this, {SuggestCaret::OnlyIfHasSuggestion,
-                  SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                  SuggestCaret::AndIgnoreTrivialError});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-        return EditActionResult(rv);
-      }
-      NS_WARNING_ASSERTION(
-          rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-          "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
+      MOZ_ASSERT(aRanges.HasSavedRanges());
+      moveInlineElementResult.IgnoreCaretPointSuggestion();
       continue;
     }
 
@@ -3712,61 +3619,39 @@
                                           aListItemElementTagName);
       if (newListItemElementOrError.isErr()) {
         NS_WARNING("HTMLEditor::ReplaceContainerWithTransaction() failed");
-        return EditActionResult(newListItemElementOrError.inspectErr());
-      }
-      // Collapse selection after moving the list item element.
+        return EditActionResult(newListItemElementOrError.unwrapErr());
+      }
+      MOZ_ASSERT(aRanges.HasSavedRanges());
       newListItemElementOrError.IgnoreCaretPointSuggestion();
-      const OwningNonNull<Element> newListItemElement =
-          newListItemElementOrError.UnwrapNewNode();
-      prevListItem = nullptr;
+      MOZ_ASSERT(newListItemElementOrError.GetNewNode());
+
       const MoveNodeResult moveListItemElementResult =
-          MoveNodeToEndWithTransaction(newListItemElement, *curList);
+          MoveNodeToEndWithTransaction(
+              MOZ_KnownLive(*newListItemElementOrError.GetNewNode()), *curList);
       if (moveListItemElementResult.isErr()) {
         NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
         return EditActionResult(moveListItemElementResult.unwrapErr());
       }
-      nsresult rv = moveListItemElementResult.SuggestCaretPointTo(
-          *this, {SuggestCaret::OnlyIfHasSuggestion,
-                  SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                  SuggestCaret::AndIgnoreTrivialError});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-        return EditActionResult(rv);
-      }
-      NS_WARNING_ASSERTION(
-          rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-          "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
+      MOZ_ASSERT(aRanges.HasSavedRanges());
+      moveListItemElementResult.IgnoreCaretPointSuggestion();
+
+      prevListItem = nullptr;
       // XXX Why don't we set `type` attribute here??
       continue;
     }
 
     // If current node is not a paragraph, wrap current node with new list
     // item element and move it into current list element.
-    const CreateElementResult wrapContentInListItemElementResult =
+    CreateElementResult wrapContentInListItemElementResult =
         InsertContainerWithTransaction(*content, aListItemElementTagName);
     if (wrapContentInListItemElementResult.isErr()) {
       NS_WARNING("HTMLEditor::InsertContainerWithTransaction() failed");
       return EditActionResult(wrapContentInListItemElementResult.unwrapErr());
     }
+    MOZ_ASSERT(aRanges.HasSavedRanges());
+    wrapContentInListItemElementResult.IgnoreCaretPointSuggestion();
     MOZ_ASSERT(wrapContentInListItemElementResult.GetNewNode());
-    nsresult rv = wrapContentInListItemElementResult.SuggestCaretPointTo(
-        *this, {SuggestCaret::OnlyIfHasSuggestion,
-                SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                SuggestCaret::AndIgnoreTrivialError});
-    if (NS_FAILED(rv)) {
-      NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-      return EditActionResult(rv);
-    }
-    NS_WARNING_ASSERTION(
-        rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-        "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
-    // If current node is not a block element, new list item should have
-    // following inline nodes too.
-    if (HTMLEditUtils::IsInlineElement(content)) {
-      prevListItem = wrapContentInListItemElementResult.GetNewNode();
-    } else {
-      prevListItem = nullptr;
-    }
+
     // MOZ_KnownLive(wrapContentInListItemElementResult.GetNewNode()): The
     // result is grabbed by wrapContentInListItemElementResult.
     const MoveNodeResult moveListItemElementResult =
@@ -3775,22 +3660,50 @@
             *curList);
     if (moveListItemElementResult.isErr()) {
       NS_WARNING("HTMLEditor::MoveNodeToEndWithTransaction() failed");
-      return EditActionResult(moveListItemElementResult.unwrapErr());
-    }
-    rv = moveListItemElementResult.SuggestCaretPointTo(
-        *this, {SuggestCaret::OnlyIfHasSuggestion,
-                SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                SuggestCaret::AndIgnoreTrivialError});
-    if (NS_FAILED(rv)) {
-      NS_WARNING("MoveNodeResult::SuggestCaretPointTo() failed");
-      return EditActionResult(rv);
-    }
-    NS_WARNING_ASSERTION(
-        rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-        "MoveNodeResult::SuggestCaretPointTo() failed, but ignored");
+      return EditActionResult(moveListItemElementResult.inspectErr());
+    }
+    MOZ_ASSERT(aRanges.HasSavedRanges());
+    moveListItemElementResult.IgnoreCaretPointSuggestion();
+
+    // If current node is not a block element, new list item should have
+    // following inline nodes too.
+    if (HTMLEditUtils::IsInlineElement(content)) {
+      prevListItem = wrapContentInListItemElementResult.UnwrapNewNode();
+    } else {
+      prevListItem = nullptr;
+    }
+
     // XXX Why don't we set `type` attribute here??
   }
 
+  MOZ_ASSERT(aRanges.HasSavedRanges());
+  aRanges.RestoreFromSavedRanges();
+
+  // If selection will be collapsed but not in listItemOrListToPutCaret, we need
+  // to adjust the caret position into it.
+  if (listItemOrListToPutCaret && aRanges.IsCollapsed() &&
+      aRanges.Ranges().Length()) {
+    const auto firstRangeStartPoint =
+        aRanges.GetFirstRangeStartPoint<EditorRawDOMPoint>();
+    if (MOZ_LIKELY(firstRangeStartPoint.IsSet())) {
+      const Result<EditorRawDOMPoint, nsresult> pointToPutCaretOrError =
+          HTMLEditUtils::ComputePointToPutCaretInElementIfOutside<
+              EditorRawDOMPoint>(*listItemOrListToPutCaret,
+                                 firstRangeStartPoint);
+      if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
+        NS_WARNING(
+            "HTMLEditUtils::ComputePointToPutCaretInElementIfOutside() "
+            "failed, but ignored");
+      } else if (pointToPutCaretOrError.inspect().IsSet()) {
+        DebugOnly<nsresult> rvIgnored =
+            aRanges.Collapse(pointToPutCaretOrError.inspect());
+        NS_WARNING_ASSERTION(
+            NS_SUCCEEDED(rvIgnored),
+            "EditorBase::CollapseSelectionTo() failed, but ignored");
+      }
+    }
+  }
+
   return EditActionHandled();
 }
 