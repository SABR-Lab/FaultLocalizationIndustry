# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 7f56b90bd017
# Full Hash: 7f56b90bd017610e724a68a5379e190cd951506f
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 09:46:07
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 7-6: Make `HTMLEditor::AlignContentsInAllTableCellsAndListItems` and `HTMLEditor::AlignBlockContentsWithDivElement` stop touching `Selection` directly r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D152979
# ==============================================================================

diff -r 27d5779ea393 -r 7f56b90bd017 editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 04:53:54 2022 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 05:00:38 2022 +0000
@@ -6337,12 +6337,21 @@
         //     we need to align contents in other type blocks?
         // MOZ_KnownLive(*listOrListItemElement): An element of aArrayOfContents
         // which is array of OwningNonNull.
-        nsresult rv = AlignContentsInAllTableCellsAndListItems(
-            MOZ_KnownLive(*listOrListItemElement), aAlignType);
-        if (NS_FAILED(rv)) {
+        Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
+            AlignContentsInAllTableCellsAndListItems(
+                MOZ_KnownLive(*listOrListItemElement), aAlignType);
+        if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
           NS_WARNING(
               "HTMLEditor::AlignContentsInAllTableCellsAndListItems() failed");
-          return rv;
+          return pointToPutCaretOrError.unwrapErr();
+        }
+        if (AllowsTransactionsToChangeSelection() &&
+            pointToPutCaretOrError.inspect().IsSet()) {
+          nsresult rv = CollapseSelectionTo(pointToPutCaretOrError.inspect());
+          if (NS_FAILED(rv)) {
+            NS_WARNING("EditorBase::CollapseSelectionTo() failed");
+            return rv;
+          }
         }
         createdDivElement = nullptr;
         continue;
@@ -6435,7 +6444,8 @@
   return NS_OK;
 }
 
-nsresult HTMLEditor::AlignContentsInAllTableCellsAndListItems(
+Result<EditorDOMPoint, nsresult>
+HTMLEditor::AlignContentsInAllTableCellsAndListItems(
     Element& aElement, const nsAString& aAlignType) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
@@ -6451,21 +6461,26 @@
       arrayOfTableCellsAndListItems);
 
   // Now that we have the list, align their contents as requested
+  EditorDOMPoint pointToPutCaret;
   for (auto& tableCellOrListItemElement : arrayOfTableCellsAndListItems) {
     // MOZ_KnownLive because 'arrayOfTableCellsAndListItems' is guaranteed to
     // keep it alive.
-    nsresult rv = AlignBlockContentsWithDivElement(
-        MOZ_KnownLive(tableCellOrListItemElement), aAlignType);
-    if (NS_FAILED(rv)) {
+    Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
+        AlignBlockContentsWithDivElement(
+            MOZ_KnownLive(tableCellOrListItemElement), aAlignType);
+    if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
       NS_WARNING("HTMLEditor::AlignBlockContentsWithDivElement() failed");
-      return rv;
-    }
-  }
-
-  return NS_OK;
+      return pointToPutCaretOrError;
+    }
+    if (pointToPutCaretOrError.inspect().IsSet()) {
+      pointToPutCaret = pointToPutCaretOrError.unwrap();
+    }
+  }
+
+  return pointToPutCaret;
 }
 
-nsresult HTMLEditor::AlignBlockContentsWithDivElement(
+Result<EditorDOMPoint, nsresult> HTMLEditor::AlignBlockContentsWithDivElement(
     Element& aBlockElement, const nsAString& aAlignType) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
@@ -6475,7 +6490,7 @@
       aBlockElement, {WalkTreeOption::IgnoreNonEditableNode});
   if (!firstEditableContent) {
     // This block has no editable content, nothing to align.
-    return NS_OK;
+    return EditorDOMPoint();
   }
 
   // If there is only one editable content and it's a `<div>` element,
@@ -6488,12 +6503,17 @@
         MOZ_KnownLive(firstEditableContent->AsElement()), nsGkAtoms::align,
         aAlignType, false);
     if (NS_WARN_IF(Destroyed())) {
-      return NS_ERROR_EDITOR_DESTROYED;
-    }
-    NS_WARNING_ASSERTION(
-        NS_SUCCEEDED(rv),
-        "EditorBase::SetAttributeOrEquivalent(nsGkAtoms::align) failed");
-    return rv;
+      NS_WARNING(
+          "EditorBase::SetAttributeOrEquivalent(nsGkAtoms::align) caused "
+          "destroying the editor");
+      return Err(NS_ERROR_EDITOR_DESTROYED);
+    }
+    if (NS_FAILED(rv)) {
+      NS_WARNING(
+          "EditorBase::SetAttributeOrEquivalent(nsGkAtoms::align) failed");
+      return Err(rv);
+    }
+    return EditorDOMPoint();
   }
 
   // Otherwise, we need to insert a `<div>` element to set `align` attribute.
@@ -6521,52 +6541,30 @@
     NS_WARNING(
         "HTMLEditor::CreateAndInsertElement(WithTransaction::Yes, "
         "nsGkAtoms::div) failed");
-    return createNewDivElementResult.unwrapErr();
-  }
-  nsresult rv = createNewDivElementResult.SuggestCaretPointTo(
-      *this, {SuggestCaret::OnlyIfHasSuggestion,
-              SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-              SuggestCaret::AndIgnoreTrivialError});
-  if (NS_FAILED(rv)) {
-    NS_WARNING("CreateElementResult::SuggestCaretPointTo() failed");
-    return rv;
-  }
-  NS_WARNING_ASSERTION(
-      rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-      "CreateElementResult::SuggestCaretPointTo() failed, but ignored");
+    return Err(createNewDivElementResult.unwrapErr());
+  }
+  EditorDOMPoint pointToPutCaret = createNewDivElementResult.UnwrapCaretPoint();
+
   RefPtr<Element> newDivElement = createNewDivElementResult.UnwrapNewNode();
   MOZ_ASSERT(newDivElement);
   // XXX This is tricky and does not work with mutation event listeners.
   //     But I'm not sure what we should do if new content is inserted.
   //     Anyway, I don't think that we should move editable contents
   //     over non-editable contents.  Chrome does no do that.
-  EditorDOMPoint pointToPutCaret;
   while (lastEditableContent && (lastEditableContent != newDivElement)) {
     MoveNodeResult moveNodeResult = MoveNodeWithTransaction(
         *lastEditableContent, EditorDOMPoint(newDivElement, 0u));
     if (moveNodeResult.isErr()) {
       NS_WARNING("HTMLEditor::MoveNodeWithTransaction() failed");
-      return moveNodeResult.unwrapErr();
-    }
-    moveNodeResult.MoveCaretPointTo(
-        pointToPutCaret, *this,
-        {SuggestCaret::OnlyIfHasSuggestion,
-         SuggestCaret::OnlyIfTransactionsAllowedToDoIt});
+      return Err(moveNodeResult.unwrapErr());
+    }
+    if (moveNodeResult.HasCaretPointSuggestion()) {
+      pointToPutCaret = moveNodeResult.UnwrapCaretPoint();
+    }
     lastEditableContent = HTMLEditUtils::GetLastChild(
         aBlockElement, {WalkTreeOption::IgnoreNonEditableNode});
   }
-  if (pointToPutCaret.IsSet()) {
-    nsresult rv = CollapseSelectionTo(pointToPutCaret);
-    if (MOZ_UNLIKELY(rv == NS_ERROR_EDITOR_DESTROYED)) {
-      NS_WARNING(
-          "EditorBase::CollapseSelectionTo() caused destroying the editor");
-      return NS_ERROR_EDITOR_DESTROYED;
-    }
-    NS_WARNING_ASSERTION(
-        NS_SUCCEEDED(rv),
-        "EditorBase::CollapseSelectionTo() failed, but ignored");
-  }
-  return NS_OK;
+  return pointToPutCaret;
 }
 
 Result<EditorRawDOMRange, nsresult>