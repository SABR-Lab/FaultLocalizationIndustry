# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 8896439912aa
# Full Hash: 8896439912aa17d8cf98646e47bbbdba864d923b
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 09:46:07
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 8: Make `HTMLEditor::SetSelectionToAbsoluteAsSubAction` stop setting `TopLevelEditSubActionData::mNewBlockElement` r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D152981
# ==============================================================================

diff -r c21c9ab7d617 -r 8896439912aa editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 05:11:17 2022 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Thu Aug 04 05:31:12 2022 +0000
@@ -10034,10 +10034,46 @@
     }
   }
 
+  auto EnsureCaretInElementIfCollapsedOutside =
+      [&](Element& aElement) MOZ_CAN_RUN_SCRIPT {
+        if (!SelectionRef().IsCollapsed() || !SelectionRef().RangeCount()) {
+          return NS_OK;
+        }
+        const auto firstRangeStartPoint =
+            GetFirstSelectionStartPoint<EditorRawDOMPoint>();
+        if (MOZ_UNLIKELY(!firstRangeStartPoint.IsSet())) {
+          return NS_OK;
+        }
+        const Result<EditorRawDOMPoint, nsresult> pointToPutCaretOrError =
+            HTMLEditUtils::ComputePointToPutCaretInElementIfOutside<
+                EditorRawDOMPoint>(aElement, firstRangeStartPoint);
+        if (MOZ_UNLIKELY(pointToPutCaretOrError.isErr())) {
+          NS_WARNING(
+              "HTMLEditUtils::ComputePointToPutCaretInElementIfOutside() "
+              "failed, but ignored");
+          return NS_OK;
+        }
+        if (!pointToPutCaretOrError.inspect().IsSet()) {
+          return NS_OK;
+        }
+        nsresult rv = CollapseSelectionTo(pointToPutCaretOrError.inspect());
+        if (MOZ_UNLIKELY(rv == NS_ERROR_EDITOR_DESTROYED)) {
+          NS_WARNING("EditorBase::CollapseSelectionTo() failed");
+          return NS_ERROR_EDITOR_DESTROYED;
+        }
+        NS_WARNING_ASSERTION(
+            NS_SUCCEEDED(rv),
+            "EditorBase::CollapseSelectionTo() failed, but ignored");
+        return NS_OK;
+      };
+
   RefPtr<Element> focusElement = GetSelectionContainerElement();
   if (focusElement && HTMLEditUtils::IsImage(focusElement)) {
-    TopLevelEditSubActionDataRef().mNewBlockElement = std::move(focusElement);
-    return EditActionHandled();
+    nsresult rv = EnsureCaretInElementIfCollapsedOutside(*focusElement);
+    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
+                         "EnsureCaretInElementIfCollapsedOutside() failed");
+    TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+    return EditActionHandled(rv);
   }
 
   // XXX Why do we do this only when there is only one selection range?
@@ -10103,10 +10139,15 @@
   if (NS_WARN_IF(Destroyed())) {
     return EditActionHandled(NS_ERROR_EDITOR_DESTROYED);
   }
+  if (NS_FAILED(rv)) {
+    NS_WARNING("HTMLEditor::SetPositionToAbsoluteOrStatic() failed");
+    return EditActionHandled(rv);
+  }
+
+  rv = EnsureCaretInElementIfCollapsedOutside(*divElement);
   NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
-                       "HTMLEditor::SetPositionToAbsoluteOrStatic() failed");
-
-  TopLevelEditSubActionDataRef().mNewBlockElement = std::move(divElement);
+                       "EnsureCaretInElementIfCollapsedOutside() failed");
+  TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
   return EditActionHandled(rv);
 }
 
