# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditUtils.cpp
# Commit: b9a3b6f27a8d
# Full Hash: b9a3b6f27a8d20c0b3ce38dc1a8f07cc4015afac
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 04:34:13
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 1: Make `HTMLEditor::EnsureCaretInBlockElement` only computes new caret point in the given element r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D152963
# ==============================================================================

diff -r d554ca7850eb -r b9a3b6f27a8d editor/libeditor/HTMLEditUtils.cpp
--- a/editor/libeditor/HTMLEditUtils.cpp	Thu Aug 04 00:21:53 2022 +0000
+++ b/editor/libeditor/HTMLEditUtils.cpp	Thu Aug 04 00:21:53 2022 +0000
@@ -15,6 +15,7 @@
 
 #include "mozilla/ArrayUtils.h"   // for ArrayLength
 #include "mozilla/Assertions.h"   // for MOZ_ASSERT, etc.
+#include "mozilla/RangeUtils.h"   // for RangeUtils
 #include "mozilla/dom/Element.h"  // for Element, nsINode
 #include "mozilla/dom/HTMLAnchorElement.h"
 #include "mozilla/dom/HTMLInputElement.h"
@@ -96,6 +97,19 @@
     const nsIContent& aContentToInsert, const EditorDOMPoint& aPointToInsert,
     const Element& aEditingHost);
 
+template Result<EditorDOMPoint, nsresult>
+HTMLEditUtils::ComputePointToPutCaretInElementIfOutside(
+    const Element& aElement, const EditorDOMPoint& aCurrentPoint);
+template Result<EditorRawDOMPoint, nsresult>
+HTMLEditUtils::ComputePointToPutCaretInElementIfOutside(
+    const Element& aElement, const EditorDOMPoint& aCurrentPoint);
+template Result<EditorDOMPoint, nsresult>
+HTMLEditUtils::ComputePointToPutCaretInElementIfOutside(
+    const Element& aElement, const EditorRawDOMPoint& aCurrentPoint);
+template Result<EditorRawDOMPoint, nsresult>
+HTMLEditUtils::ComputePointToPutCaretInElementIfOutside(
+    const Element& aElement, const EditorRawDOMPoint& aCurrentPoint);
+
 bool HTMLEditUtils::CanContentsBeJoined(const nsIContent& aLeftContent,
                                         const nsIContent& aRightContent,
                                         StyleDifference aStyleDifference) {
@@ -1794,6 +1808,69 @@
       .template PointAfterContent<EditorDOMPointType>();
 }
 
+//  static
+template <typename EditorDOMPointType, typename EditorDOMPointTypeInput>
+Result<EditorDOMPointType, nsresult>
+HTMLEditUtils::ComputePointToPutCaretInElementIfOutside(
+    const Element& aElement, const EditorDOMPointTypeInput& aCurrentPoint) {
+  MOZ_ASSERT(aCurrentPoint.IsSet());
+
+  // FYI: This was moved from
+  // https://searchfox.org/mozilla-central/rev/d3c2f51d89c3ca008ff0cb5a057e77ccd973443e/editor/libeditor/HTMLEditSubActionHandler.cpp#9193
+
+  // Use ranges and RangeUtils::CompareNodeToRange() to compare selection
+  // start to new block.
+  RefPtr<StaticRange> staticRange =
+      StaticRange::Create(aCurrentPoint.ToRawRangeBoundary(),
+                          aCurrentPoint.ToRawRangeBoundary(), IgnoreErrors());
+  if (MOZ_UNLIKELY(!staticRange)) {
+    NS_WARNING("StaticRange::Create() failed");
+    return Err(NS_ERROR_FAILURE);
+  }
+
+  bool nodeBefore, nodeAfter;
+  nsresult rv = RangeUtils::CompareNodeToRange(
+      const_cast<Element*>(&aElement), staticRange, &nodeBefore, &nodeAfter);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("RangeUtils::CompareNodeToRange() failed");
+    return Err(rv);
+  }
+
+  if (nodeBefore && nodeAfter) {
+    return EditorDOMPointType();  // aCurrentPoint is in aElement
+  }
+
+  if (nodeBefore) {
+    // selection is after block.  put at end of block.
+    const nsIContent* lastEditableContent = HTMLEditUtils::GetLastChild(
+        aElement, {WalkTreeOption::IgnoreNonEditableNode});
+    if (!lastEditableContent) {
+      lastEditableContent = &aElement;
+    }
+    if (lastEditableContent->IsText() ||
+        HTMLEditUtils::IsContainerNode(*lastEditableContent)) {
+      return EditorDOMPointType::AtEndOf(*lastEditableContent);
+    }
+    MOZ_ASSERT(lastEditableContent->GetParentNode());
+    return EditorDOMPointType::After(*lastEditableContent);
+  }
+
+  // selection is before block.  put at start of block.
+  const nsIContent* firstEditableContent = HTMLEditUtils::GetFirstChild(
+      aElement, {WalkTreeOption::IgnoreNonEditableNode});
+  if (!firstEditableContent) {
+    firstEditableContent = &aElement;
+  }
+  if (firstEditableContent->IsText() ||
+      HTMLEditUtils::IsContainerNode(*firstEditableContent)) {
+    MOZ_ASSERT(firstEditableContent->GetParentNode());
+    // XXX Shouldn't this be EditorDOMPointType(firstEditableContent, 0u)?
+    return EditorDOMPointType(firstEditableContent);
+  }
+  // XXX And shouldn't this be EditorDOMPointType(firstEditableContent)?
+  return EditorDOMPointType(firstEditableContent, 0u);
+}
+
 // static
 size_t HTMLEditUtils::CollectChildren(
     nsINode& aNode, nsTArray<OwningNonNull<nsIContent>>& aOutArrayOfContents,