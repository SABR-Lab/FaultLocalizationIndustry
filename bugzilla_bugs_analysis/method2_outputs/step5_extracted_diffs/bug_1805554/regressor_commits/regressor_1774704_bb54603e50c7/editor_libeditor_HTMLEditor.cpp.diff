# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditor.cpp
# Commit: bb54603e50c7
# Full Hash: bb54603e50c7ab95d798eaf37987d9b60752ca08
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2022-08-04 04:34:13
# Regressor Bug: 1774704
# File Overlap Count: 1
# Description:
#   Bug 1774704 - part 2: Make `CreateOrChangeBlockContainerElement`, `FormatBlockContainerWithTransaction` and `WrapContentsInBlockquoteElementsWithTransaction` stop setting `TopLevelEditSubActionData::mNewBlockElement` r=m_kato
#   
#   They set `TopLevelEditSubActionData::mNewBlockElement` and their root callers
#   in edit sub-action level are only `InsertParagraphSeparatorAsSubAction` and
#   `FormatBlockContainerAsSubAction`, and they are called each other.  Therefore,
# ==============================================================================

diff -r b9a3b6f27a8d -r bb54603e50c7 editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp	Thu Aug 04 00:21:53 2022 +0000
+++ b/editor/libeditor/HTMLEditor.cpp	Thu Aug 04 00:39:13 2022 +0000
@@ -2669,11 +2669,13 @@
     return NS_SUCCESS_DOM_NO_OPERATION;
   }
   AutoRangeArray selectionRanges(SelectionRef());
-  rv = FormatBlockContainerWithTransaction(selectionRanges, aTagName,
-                                           *editingHost);
-  if (NS_FAILED(rv)) {
+  Result<RefPtr<Element>, nsresult> suggestBlockElementToPutCaretOrError =
+      FormatBlockContainerWithTransaction(selectionRanges, aTagName,
+                                          *editingHost);
+  TopLevelEditSubActionDataRef().mNewBlockElement = nullptr;
+  if (suggestBlockElementToPutCaretOrError.isErr()) {
     NS_WARNING("HTMLEditor::FormatBlockContainerWithTransaction() failed");
-    return rv;
+    return suggestBlockElementToPutCaretOrError.unwrapErr();
   }
 
   if (selectionRanges.HasSavedRanges()) {
@@ -2694,6 +2696,39 @@
       NS_SUCCEEDED(rv),
       "HTMLEditor::MaybeInsertPaddingBRElementForEmptyLastLineAtSelection() "
       "failed");
+
+  if (!suggestBlockElementToPutCaretOrError.inspect() ||
+      !SelectionRef().IsCollapsed()) {
+    return rv;
+  }
+  const auto firstSelectionStartPoint =
+      GetFirstSelectionStartPoint<EditorRawDOMPoint>();
+  if (MOZ_UNLIKELY(!firstSelectionStartPoint.IsSet())) {
+    return rv;
+  }
+  Result<EditorRawDOMPoint, nsresult> pointInBlockElementOrError =
+      HTMLEditUtils::ComputePointToPutCaretInElementIfOutside<
+          EditorRawDOMPoint>(*suggestBlockElementToPutCaretOrError.inspect(),
+                             firstSelectionStartPoint);
+  if (MOZ_UNLIKELY(pointInBlockElementOrError.isErr())) {
+    NS_WARNING(
+        "HTMLEditUtils::ComputePointToPutCaretInElementIfOutside() failed, but "
+        "ignored");
+    return rv;
+  }
+  // Note that if the point is unset, it means that firstSelectionStartPoint is
+  // in the block element.
+  if (pointInBlockElementOrError.inspect().IsSet()) {
+    nsresult rvOfCollapseSelection =
+        CollapseSelectionTo(pointInBlockElementOrError.inspect());
+    if (MOZ_UNLIKELY(rvOfCollapseSelection == NS_ERROR_EDITOR_DESTROYED)) {
+      NS_WARNING("EditorBase::CollapseSelectionTo() failed");
+      return NS_ERROR_EDITOR_DESTROYED;
+    }
+    NS_WARNING_ASSERTION(
+        NS_SUCCEEDED(rvOfCollapseSelection),
+        "EditorBase::CollapseSelectionTo() failed, but ignored");
+  }
   return rv;
 }
 