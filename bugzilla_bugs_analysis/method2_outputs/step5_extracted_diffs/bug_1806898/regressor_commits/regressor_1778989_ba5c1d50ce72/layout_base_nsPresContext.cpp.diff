# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsPresContext.cpp
# Commit: ba5c1d50ce72
# Full Hash: ba5c1d50ce72828e54b397821429df63ef0c286f
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2022-08-09 21:31:27
# Regressor Bug: 1778989
# File Overlap Count: 1
# Description:
#   Bug 1778989 - Add some basic container query interleaving. r=dholbert
#   
#   This is far from fully perfect (specially when dealing with nested
#   containers, we need to be smarter when updating there), but it's
#   incremental progress.
# ==============================================================================

diff -r bf52569d96ca -r ba5c1d50ce72 layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp	Tue Aug 09 11:38:15 2022 +0000
+++ b/layout/base/nsPresContext.cpp	Tue Aug 09 11:44:39 2022 +0000
@@ -1001,6 +1001,84 @@
   }
 }
 
+struct QueryContainerState {
+  nsSize mSize;
+  WritingMode mWm;
+
+  nscoord GetInlineSize() const { return LogicalSize(mWm, mSize).ISize(mWm); }
+
+  bool Changed(const QueryContainerState& aNewState, StyleContainerType aType) {
+    if (aType & StyleContainerType::SIZE) {
+      return mSize != aNewState.mSize;
+    }
+    if (aType & StyleContainerType::INLINE_SIZE) {
+      return GetInlineSize() != aNewState.GetInlineSize();
+    }
+    return false;
+  }
+};
+NS_DECLARE_FRAME_PROPERTY_DELETABLE(ContainerState, QueryContainerState);
+
+void nsPresContext::RegisterContainerQueryFrame(nsIFrame* aFrame) {
+  mContainerQueryFrames.Insert(aFrame);
+}
+
+void nsPresContext::UnregisterContainerQueryFrame(nsIFrame* aFrame) {
+  mContainerQueryFrames.Remove(aFrame);
+}
+
+void nsPresContext::FinishedContainerQueryUpdate() {
+  mUpdatedContainerQueryContents.Clear();
+}
+
+bool nsPresContext::UpdateContainerQueryStyles() {
+  if (mContainerQueryFrames.IsEmpty()) {
+    return false;
+  }
+
+  PresShell()->DoFlushLayout(/* aInterruptible = */ false);
+
+  bool anyChanged = false;
+  for (nsIFrame* frame : mContainerQueryFrames) {
+    if (!frame->IsPrimaryFrame()) {
+      continue;
+    }
+
+    auto type = frame->StyleDisplay()->mContainerType;
+    MOZ_ASSERT(type, "Non-container frames shouldn't be in this type");
+
+    if (!mUpdatedContainerQueryContents.EnsureInserted(frame->GetContent())) {
+      continue;
+    }
+
+    const QueryContainerState newState{frame->GetSize(),
+                                       frame->GetWritingMode()};
+    QueryContainerState* oldState = frame->GetProperty(ContainerState());
+
+    const bool changed = !oldState || oldState->Changed(newState, type);
+
+    // Make sure to update the state regardless. It's cheap and it keeps tracks
+    // of both axes correctly even if only one axis is contained.
+    if (oldState) {
+      *oldState = newState;
+    } else {
+      frame->SetProperty(ContainerState(), new QueryContainerState(newState));
+    }
+
+    if (!changed) {
+      continue;
+    }
+
+    // TODO(emilio): More fine-grained invalidation rather than invalidating the
+    // whole subtree, probably!
+    RestyleManager()->PostRestyleEvent(frame->GetContent()->AsElement(),
+                                       RestyleHint::RestyleSubtree(),
+                                       nsChangeHint(0));
+    anyChanged = true;
+  }
+  return anyChanged;
+}
+
 void nsPresContext::DocumentCharSetChanged(NotNull<const Encoding*> aCharSet) {
   UpdateCharSet(aCharSet);
   FlushFontCache();