# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsIFrame.cpp
# Commit: c1e64e8e4665
# Full Hash: c1e64e8e466506d1d9a36d747df25527bd545b10
# Author: Martin Robinson <mrobinson@igalia.com>
# Date: 2022-12-01 16:18:29
# Regressor Bug: 1791759
# File Overlap Count: 1
# Description:
#   Bug 1791759 - Add support for `content-visibility: auto` r=emilio
#   
#   This change adds support for `content-visibilty: auto` as well as
#   showing and hiding content based on the relevancy of the content as
#   defined in the specification. Changes to relevancy are handled by
# ==============================================================================

diff -r 6d4d56f57b7b -r c1e64e8e4665 layout/generic/nsIFrame.cpp
--- a/layout/generic/nsIFrame.cpp	Thu Dec 01 01:23:08 2022 +0200
+++ b/layout/generic/nsIFrame.cpp	Wed Nov 30 18:00:27 2022 +0000
@@ -46,6 +46,7 @@
 #include "nsCOMPtr.h"
 #include "nsFieldSetFrame.h"
 #include "nsFlexContainerFrame.h"
+#include "nsFocusManager.h"
 #include "nsFrameList.h"
 #include "nsPlaceholderFrame.h"
 #include "nsIBaseWindow.h"
@@ -381,7 +382,12 @@
       return false;
     }
 
-    if (this != frame && frame->HidesContent()) {
+    // This method is used to determine if a frame is focusable, because it's
+    // called by nsIFrame::IsFocusable. `content-visibility: auto` should not
+    // force this frame to be unfocusable, so we only take into account
+    // `content-visibility: hidden` here.
+    if (this != frame &&
+        frame->HidesContent(IncludeContentVisibility::Hidden)) {
       return false;
     }
 
@@ -780,6 +786,16 @@
     UpdateVisibleDescendantsState();
   }
 
+  if (disp->IsContentVisibilityAuto() &&
+      IsContentVisibilityPropertyApplicable()) {
+    PresShell()->RegisterContentVisibilityAutoFrame(this);
+    auto* element = Element::FromNodeOrNull(GetContent());
+    MOZ_ASSERT(element);
+    PresContext()->Document()->ObserveForContentVisibility(*element);
+  } else if (auto* element = Element::FromNodeOrNull(GetContent())) {
+    element->ClearContentRelevancy();
+  }
+
   // TODO(mrobinson): Once bug 1765615 is fixed, this should be called on
   // layout changes. In addition, when `content-visibility: auto` is implemented
   // this should also be called when scrolling or focus causes content to be
@@ -855,6 +871,13 @@
     }
   }
 
+  if (disp->IsContentVisibilityAuto() &&
+      IsContentVisibilityPropertyApplicable()) {
+    if (auto* element = Element::FromNodeOrNull(GetContent())) {
+      PresContext()->Document()->UnobserveForContentVisibility(*element);
+    }
+  }
+
   // Disable visibility tracking. Note that we have to do this before we clear
   // frame properties and lose track of whether we were previously visible.
   // XXX(seth): It'd be ideal to assert that we're already marked nonvisible
@@ -6832,12 +6855,53 @@
   return element && element->IsDisabled();
 }
 
-bool nsIFrame::HidesContent() const {
-  if (!StyleDisplay()->IsContentVisibilityHidden()) {
+bool nsIFrame::IsContentVisibilityPropertyApplicable() const {
+  return GetContent() && GetContent()->IsElement() &&
+         (!StyleDisplay()->IsInlineFlow() ||
+          IsFrameOfType(nsIFrame::eReplaced));
+}
+
+bool nsIFrame::IsContentRelevant() const {
+  MOZ_ASSERT(IsContentVisibilityPropertyApplicable());
+  MOZ_ASSERT(StyleDisplay()->IsContentVisibilityAuto());
+
+  auto* element = Element::FromNodeOrNull(GetContent());
+  MOZ_ASSERT(element);
+
+  Maybe<ContentRelevancy> relevancy = element->GetContentRelevancy();
+  if (relevancy.isSome()) {
+    return !relevancy->isEmpty();
+  }
+
+  // If there is no relevancy set, then this frame still has not received had
+  // the initial visibility callback call. In that case, only rely on whether
+  // or not it is inside a top layer element which will never change for this
+  // frame and allows proper rendering of the top layer.
+  return IsDescendantOfTopLayerElement();
+}
+
+bool nsIFrame::HidesContent(
+    const EnumSet<IncludeContentVisibility>& aInclude) const {
+  const auto& disp = *StyleDisplay();
+  if (disp.IsContentVisibilityVisible()) {
     return false;
-  }
-
-  return IsFrameOfType(nsIFrame::eReplaced) || !StyleDisplay()->IsInlineFlow();
+  };
+
+  if (!IsContentVisibilityPropertyApplicable()) {
+    return false;
+  }
+
+  if (aInclude.contains(IncludeContentVisibility::Hidden) &&
+      disp.IsContentVisibilityHidden()) {
+    return true;
+  }
+
+  if (aInclude.contains(IncludeContentVisibility::Auto) &&
+      disp.IsContentVisibilityAuto()) {
+    return !IsContentRelevant();
+  }
+
+  return false;
 }
 
 bool nsIFrame::HidesContentForLayout() const {
@@ -6850,7 +6914,8 @@
          !(Style()->IsAnonBox() && !IsFrameOfType(nsIFrame::eLineParticipant));
 }
 
-bool nsIFrame::IsHiddenByContentVisibilityOnAnyAncestor() const {
+bool nsIFrame::IsHiddenByContentVisibilityOnAnyAncestor(
+    const EnumSet<IncludeContentVisibility>& aInclude) const {
   if (!StaticPrefs::layout_css_content_visibility_enabled()) {
     return false;
   }
@@ -6858,7 +6923,7 @@
   bool isAnonymousBlock =
       Style()->IsAnonBox() && !IsFrameOfType(nsIFrame::eLineParticipant);
   for (nsIFrame* cur = GetInFlowParent(); cur; cur = cur->GetInFlowParent()) {
-    if (!isAnonymousBlock && cur->HidesContent()) {
+    if (!isAnonymousBlock && cur->HidesContent(aInclude)) {
       return true;
     }
 
@@ -6871,6 +6936,111 @@
   return false;
 }
 
+bool nsIFrame::HasSelectionInSubtree() {
+  if (IsSelected()) {
+    return true;
+  }
+
+  RefPtr<nsFrameSelection> frameSelection = GetFrameSelection();
+  const Selection* selection =
+      frameSelection->GetSelection(SelectionType::eNormal);
+  if (!selection) {
+    return false;
+  }
+
+  for (uint32_t i = 0; i < selection->RangeCount(); i++) {
+    auto* range = selection->GetRangeAt(i);
+    MOZ_ASSERT(range);
+
+    const auto* commonAncestorNode =
+        range->GetRegisteredClosestCommonInclusiveAncestor();
+    if (commonAncestorNode->IsInclusiveDescendantOf(GetContent())) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool nsIFrame::IsDescendantOfTopLayerElement() const {
+  if (!GetContent()) {
+    return false;
+  }
+
+  nsTArray<dom::Element*> topLayer = PresContext()->Document()->GetTopLayer();
+  for (auto* element : topLayer) {
+    if (GetContent()->IsInclusiveFlatTreeDescendantOf(element)) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void nsIFrame::UpdateIsRelevantContent(
+    const ContentRelevancy& aRelevancyToUpdate) {
+  MOZ_ASSERT(IsContentVisibilityPropertyApplicable());
+  MOZ_ASSERT(StyleDisplay()->IsContentVisibilityAuto());
+
+  auto* element = Element::FromNodeOrNull(GetContent());
+  MOZ_ASSERT(element);
+
+  ContentRelevancy newRelevancy;
+  Maybe<ContentRelevancy> oldRelevancy = element->GetContentRelevancy();
+  if (oldRelevancy.isSome()) {
+    newRelevancy = *oldRelevancy;
+  }
+
+  auto setRelevancyValue = [&](ContentRelevancyReason reason, bool value) {
+    if (value) {
+      newRelevancy += reason;
+    } else {
+      newRelevancy -= reason;
+    }
+  };
+
+  if (!oldRelevancy ||
+      aRelevancyToUpdate.contains(ContentRelevancyReason::Visible)) {
+    Maybe<bool> visible = element->GetVisibleForContentVisibility();
+    if (visible.isSome()) {
+      setRelevancyValue(ContentRelevancyReason::Visible, *visible);
+    }
+  }
+
+  if (!oldRelevancy ||
+      aRelevancyToUpdate.contains(ContentRelevancyReason::FocusInSubtree)) {
+    setRelevancyValue(ContentRelevancyReason::FocusInSubtree,
+                      element->State().HasAtLeastOneOfStates(
+                          ElementState::FOCUS_WITHIN | ElementState::FOCUS));
+  }
+
+  if (!oldRelevancy ||
+      aRelevancyToUpdate.contains(ContentRelevancyReason::Selected)) {
+    setRelevancyValue(ContentRelevancyReason::Selected,
+                      HasSelectionInSubtree());
+  }
+
+  if (!oldRelevancy ||
+      aRelevancyToUpdate.contains(
+          ContentRelevancyReason::DescendantOfTopLayerElement)) {
+    setRelevancyValue(ContentRelevancyReason::DescendantOfTopLayerElement,
+                      IsDescendantOfTopLayerElement());
+  }
+
+  bool overallRelevancyChanged =
+      !oldRelevancy || oldRelevancy->isEmpty() != newRelevancy.isEmpty();
+  if (!oldRelevancy || *oldRelevancy != newRelevancy) {
+    element->SetContentRelevancy(newRelevancy);
+  }
+
+  if (overallRelevancyChanged) {
+    HandleLastRememberedSize();
+    PresShell()->FrameNeedsReflow(this, IntrinsicDirty::StyleChange,
+                                  NS_FRAME_IS_DIRTY);
+    InvalidateFrame();
+  }
+}
+
 nsresult nsIFrame::CharacterDataChanged(const CharacterDataChangeInfo&) {
   MOZ_ASSERT_UNREACHABLE("should only be called for text frames");
   return NS_OK;