# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/PersistentBufferProvider.cpp
# Commit: 220d6288fe81
# Full Hash: 220d6288fe8156df13e9582af79702ae5ef1f237
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2022-12-09 21:45:26
# Regressor Bug: 1795768
# File Overlap Count: 1
# Description:
#   Bug 1795768 - Do not use Direct2D canvas if willReadFrequently is set. r=jrmuizel
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D164364
# ==============================================================================

diff -r 5d43ff0044fe -r 220d6288fe81 gfx/layers/PersistentBufferProvider.cpp
--- a/gfx/layers/PersistentBufferProvider.cpp	Fri Dec 09 17:03:03 2022 +0000
+++ b/gfx/layers/PersistentBufferProvider.cpp	Fri Dec 09 17:03:03 2022 +0000
@@ -147,18 +147,22 @@
 
 static already_AddRefed<TextureClient> CreateTexture(
     KnowsCompositor* aKnowsCompositor, gfx::SurfaceFormat aFormat,
-    gfx::IntSize aSize) {
+    gfx::IntSize aSize, bool aWillReadFrequently) {
+  TextureAllocationFlags flags = ALLOC_DEFAULT;
+  if (aWillReadFrequently) {
+    flags = TextureAllocationFlags(flags | ALLOC_DO_NOT_ACCELERATE);
+  }
   return TextureClient::CreateForDrawing(
       aKnowsCompositor, aFormat, aSize, BackendSelector::Canvas,
-      TextureFlags::DEFAULT | TextureFlags::NON_BLOCKING_READ_LOCK,
-      TextureAllocationFlags::ALLOC_DEFAULT);
+      TextureFlags::DEFAULT | TextureFlags::NON_BLOCKING_READ_LOCK, flags);
 }
 
 // static
 already_AddRefed<PersistentBufferProviderShared>
 PersistentBufferProviderShared::Create(gfx::IntSize aSize,
                                        gfx::SurfaceFormat aFormat,
-                                       KnowsCompositor* aKnowsCompositor) {
+                                       KnowsCompositor* aKnowsCompositor,
+                                       bool aWillReadFrequently) {
   if (!aKnowsCompositor || !aKnowsCompositor->GetTextureForwarder() ||
       !aKnowsCompositor->GetTextureForwarder()->IPCOpen()) {
     return nullptr;
@@ -179,25 +183,27 @@
 #endif
 
   RefPtr<TextureClient> texture =
-      CreateTexture(aKnowsCompositor, aFormat, aSize);
+      CreateTexture(aKnowsCompositor, aFormat, aSize, aWillReadFrequently);
   if (!texture) {
     return nullptr;
   }
 
   RefPtr<PersistentBufferProviderShared> provider =
       new PersistentBufferProviderShared(aSize, aFormat, aKnowsCompositor,
-                                         texture);
+                                         texture, aWillReadFrequently);
   return provider.forget();
 }
 
 PersistentBufferProviderShared::PersistentBufferProviderShared(
     gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
-    KnowsCompositor* aKnowsCompositor, RefPtr<TextureClient>& aTexture)
+    KnowsCompositor* aKnowsCompositor, RefPtr<TextureClient>& aTexture,
+    bool aWillReadFrequently)
 
     : mSize(aSize),
       mFormat(aFormat),
       mKnowsCompositor(aKnowsCompositor),
-      mFront(Nothing()) {
+      mFront(Nothing()),
+      mWillReadFrequently(aWillReadFrequently) {
   MOZ_ASSERT(aKnowsCompositor);
   if (mTextures.append(aTexture)) {
     mBack = Some<uint32_t>(0);
@@ -253,7 +259,7 @@
 
     if (prevTexture) {
       RefPtr<TextureClient> newTexture =
-          CreateTexture(aKnowsCompositor, mFormat, mSize);
+          CreateTexture(aKnowsCompositor, mFormat, mSize, mWillReadFrequently);
 
       MOZ_ASSERT(newTexture);
       if (!newTexture) {
@@ -383,7 +389,7 @@
     }
 
     RefPtr<TextureClient> newTexture =
-        CreateTexture(mKnowsCompositor, mFormat, mSize);
+        CreateTexture(mKnowsCompositor, mFormat, mSize, mWillReadFrequently);
 
     MOZ_ASSERT(newTexture);
     if (newTexture) {
@@ -416,7 +422,8 @@
         // We are about to read lock a texture that is in use by the compositor
         // and has synchronization. To prevent possible future contention we
         // switch to using a permanent back buffer.
-        mPermanentBackBuffer = CreateTexture(mKnowsCompositor, mFormat, mSize);
+        mPermanentBackBuffer = CreateTexture(mKnowsCompositor, mFormat, mSize,
+                                             mWillReadFrequently);
         if (!mPermanentBackBuffer) {
           return nullptr;
         }
@@ -553,7 +560,8 @@
     // We are about to read lock a texture that is in use by the compositor and
     // has synchronization. To prevent possible future contention we switch to
     // using a permanent back buffer.
-    mPermanentBackBuffer = CreateTexture(mKnowsCompositor, mFormat, mSize);
+    mPermanentBackBuffer =
+        CreateTexture(mKnowsCompositor, mFormat, mSize, mWillReadFrequently);
     if (!mPermanentBackBuffer ||
         !mPermanentBackBuffer->Lock(OpenMode::OPEN_READ_WRITE)) {
       return nullptr;
@@ -646,5 +654,19 @@
   mTextures.clear();
 }
 
+bool PersistentBufferProviderShared::IsAccelerated() const {
+#ifdef XP_WIN
+  // Detect if we're using D2D canvas.
+  if (mWillReadFrequently || mTextures.empty()) {
+    return false;
+  }
+  TextureClient* texture = mTextures.front();
+  if (texture->GetInternalData()->AsD3D11TetxureData()) {
+    return true;
+  }
+#endif
+  return false;
+}
+
 }  // namespace layers
 }  // namespace mozilla