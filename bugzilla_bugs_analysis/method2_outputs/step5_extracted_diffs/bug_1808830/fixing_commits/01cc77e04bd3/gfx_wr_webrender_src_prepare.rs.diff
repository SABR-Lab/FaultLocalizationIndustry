# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/prepare.rs
# Commit: 01cc77e04bd3
# Full Hash: 01cc77e04bd33fe163fdbbc7332135cc4f34ade8
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2023-01-30 09:54:34
# Description:
#   Bug 1808830 - Fix a panic from an invalid cast in euclid r=gfx-reviewers,jrmuizel
#   
#   When the scale is very large, we need to adjust that before
#   doing the cast to integer units.
#   
# ==============================================================================

diff -r c75b59a8ae10 -r 01cc77e04bd3 gfx/wr/webrender/src/prepare.rs
--- a/gfx/wr/webrender/src/prepare.rs	Sun Jan 29 23:57:40 2023 +0000
+++ b/gfx/wr/webrender/src/prepare.rs	Mon Jan 30 00:12:15 2023 +0000
@@ -6,7 +6,6 @@
 //!
 //! TODO: document this!
 
-use std::cmp;
 use api::{ColorF, PremultipliedColorF, PropertyBinding};
 use api::{BoxShadowClipMode, BorderStyle, ClipMode};
 use api::units::*;
@@ -306,14 +305,17 @@
                 let world_scale = LayoutToWorldScale::new(scale_width.max(scale_height));
 
                 let scale_factor = world_scale * Scale::new(1.0);
-                let mut task_size = (LayoutSize::from_au(cache_key.size) * scale_factor).ceil().to_i32();
-                if task_size.width > MAX_LINE_DECORATION_RESOLUTION as i32 ||
-                   task_size.height > MAX_LINE_DECORATION_RESOLUTION as i32 {
-                     let max_extent = cmp::max(task_size.width, task_size.height);
-                     let task_scale_factor = Scale::new(MAX_LINE_DECORATION_RESOLUTION as f32 / max_extent as f32);
-                     task_size = (LayoutSize::from_au(cache_key.size) * scale_factor * task_scale_factor)
+                let task_size_f = (LayoutSize::from_au(cache_key.size) * scale_factor).ceil();
+                let mut task_size = if task_size_f.width > MAX_LINE_DECORATION_RESOLUTION as f32 ||
+                   task_size_f.height > MAX_LINE_DECORATION_RESOLUTION as f32 {
+                     let max_extent = task_size_f.width.max(task_size_f.height);
+                     let task_scale_factor = Scale::new(MAX_LINE_DECORATION_RESOLUTION as f32 / max_extent);
+                     let task_size = (LayoutSize::from_au(cache_key.size) * scale_factor * task_scale_factor)
                                     .ceil().to_i32();
-                }
+                    task_size
+                } else {
+                    task_size_f.to_i32()
+                };
 
                 // It's plausible, due to float accuracy issues that the line decoration may be considered
                 // visible even if the scale factors are ~0. However, the render task allocation below requires
