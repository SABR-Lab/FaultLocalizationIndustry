# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/prepare.rs
# Commit: 8c70bc92ad36
# Full Hash: 8c70bc92ad36beb61f2cd6031e80ace3793fe53b
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-02-24 03:51:41
# Regressor Bug: 1749380
# File Overlap Count: 1
# Description:
#   Bug 1749380 - Part 1 - Improve how WR handles bounding rects for off-screen surfaces r=gfx-reviewers
#   
#   This patch introduces a number of subtle but important changes
#   to how we deal with off-screen surfaces. The overall goals are:
#   
# ==============================================================================

diff -r c6f1243c3ba4 -r 8c70bc92ad36 gfx/wr/webrender/src/prepare.rs
--- a/gfx/wr/webrender/src/prepare.rs	Wed Feb 23 20:42:19 2022 +0000
+++ b/gfx/wr/webrender/src/prepare.rs	Wed Feb 23 20:49:26 2022 +0000
@@ -64,8 +64,6 @@
             frame_context.spatial_tree,
         );
 
-        frame_state.surfaces[pic_context.surface_index.0].opaque_rect = PictureRect::zero();
-
         for prim_instance_index in cluster.prim_range() {
             // First check for coarse visibility (if this primitive was completely off-screen)
             let prim_instance = &mut prim_instances[prim_instance_index];
@@ -127,14 +125,6 @@
                 prim_instances[prim_instance_index].clear_visibility();
             }
         }
-
-        if !cluster.opaque_rect.is_empty() {
-            let surface = &mut frame_state.surfaces[pic_context.surface_index.0];
-
-            if let Some(cluster_opaque_rect) = surface.map_local_to_surface.map_inner_bounds(&cluster.opaque_rect) {
-                surface.opaque_rect = crate::util::conservative_union_rect(&surface.opaque_rect, &cluster_opaque_rect);
-            }
-        }
     }
 }
 
@@ -159,9 +149,14 @@
     // For example, scrolling may affect the location of an item in
     // local space, which may force us to render this item on a larger
     // picture target, if being composited.
+    let mut is_passthrough = false;
     if let PrimitiveInstanceKind::Picture { pic_index, .. } = prim_instances[prim_instance_index].kind {
         let pic = &mut store.pictures[pic_index.0];
 
+        // TODO(gw): Plan to remove pictures with no composite mode, so that we don't need
+        //           to special case for pass through pictures.
+        is_passthrough = pic.composite_mode.is_none();
+
         match pic.take_context(
             pic_index,
             pic_context.surface_spatial_node_index,
@@ -203,32 +198,35 @@
 
     let prim_instance = &mut prim_instances[prim_instance_index];
 
-    let prim_rect = data_stores.get_local_prim_rect(
-        prim_instance,
-        store,
-    );
+    if !is_passthrough {
+        let prim_rect = data_stores.get_local_prim_rect(
+            prim_instance,
+            &store.pictures,
+            frame_state.surfaces,
+        );
 
-    if !update_clip_task(
-        prim_instance,
-        &prim_rect.min,
-        cluster.spatial_node_index,
-        pic_context.raster_spatial_node_index,
-        pic_context,
-        pic_state,
-        frame_context,
-        frame_state,
-        store,
-        data_stores,
-        scratch,
-    ) {
+        if !update_clip_task(
+            prim_instance,
+            &prim_rect.min,
+            cluster.spatial_node_index,
+            pic_context.raster_spatial_node_index,
+            pic_context,
+            pic_state,
+            frame_context,
+            frame_state,
+            store,
+            data_stores,
+            scratch,
+        ) {
+            if prim_instance.is_chased() {
+                info!("\tconsidered invisible");
+            }
+            return false;
+        }
+
         if prim_instance.is_chased() {
-            info!("\tconsidered invisible");
+            info!("\tconsidered visible and ready with local pos {:?}", prim_rect.min);
         }
-        return false;
-    }
-
-    if prim_instance.is_chased() {
-        info!("\tconsidered visible and ready with local pos {:?}", prim_rect.min);
     }
 
     #[cfg(debug_assertions)]
@@ -268,7 +266,6 @@
     let prim_spatial_node_index = cluster.spatial_node_index;
     let is_chased = prim_instance.is_chased();
     let device_pixel_scale = frame_state.surfaces[pic_context.surface_index.0].device_pixel_scale;
-    let mut is_opaque = false;
 
     match &mut prim_instance.kind {
         PrimitiveInstanceKind::LineDecoration { data_handle, ref mut render_task, .. } => {
@@ -289,9 +286,27 @@
             // If we have a cache key, it's a wavy / dashed / dotted line. Otherwise, it's
             // a simple solid line.
             if let Some(cache_key) = line_dec_data.cache_key.as_ref() {
-                // TODO(gw): Do we ever need / want to support scales for text decorations
-                //           based on the current transform?
-                let scale_factor = Scale::new(1.0) * device_pixel_scale;
+                // TODO(gw): These scale factors don't do a great job if the world transform
+                //           contains perspective
+                let scale = frame_context
+                    .spatial_tree
+                    .get_world_transform(prim_spatial_node_index)
+                    .scale_factors();
+
+                // Scale factors are normalized to a power of 2 to reduce the number of
+                // resolution changes.
+                // For frames with a changing scale transform round scale factors up to
+                // nearest power-of-2 boundary so that we don't keep having to redraw
+                // the content as it scales up and down. Rounding up to nearest
+                // power-of-2 boundary ensures we never scale up, only down --- avoiding
+                // jaggies. It also ensures we never scale down by more than a factor of
+                // 2, avoiding bad downscaling quality.
+                let scale_width = clamp_to_scale_factor(scale.0, false);
+                let scale_height = clamp_to_scale_factor(scale.1, false);
+                // Pick the maximum dimension as scale
+                let world_scale = LayoutToWorldScale::new(scale_width.max(scale_height));
+
+                let scale_factor = world_scale * device_pixel_scale;
                 let mut task_size = (LayoutSize::from_au(cache_key.size) * scale_factor).ceil().to_i32();
                 if task_size.width > MAX_LINE_DECORATION_RESOLUTION as i32 ||
                    task_size.height > MAX_LINE_DECORATION_RESOLUTION as i32 {
@@ -348,12 +363,7 @@
                 .into_fast_transform();
             let prim_offset = prim_data.common.prim_rect.min.to_vector() - run.reference_frame_relative_offset;
 
-            let pic = &store.pictures[pic_context.pic_index.0];
             let surface = &frame_state.surfaces[pic_context.surface_index.0];
-            let root_scaling_factor = match pic.raster_config {
-                Some(ref raster_config) => raster_config.root_scaling_factor,
-                None => 1.0
-            };
 
             // If subpixel AA is disabled due to the backing surface the glyphs
             // are being drawn onto, disable it (unless we are using the
@@ -391,7 +401,6 @@
                 &transform.to_transform().with_destination::<_>(),
                 surface,
                 prim_spatial_node_index,
-                root_scaling_factor,
                 allow_subpixel,
                 frame_context.fb_config.low_quality_pinch_zoom,
                 frame_state.resource_cache,
@@ -544,8 +553,6 @@
                 frame_context.scene_properties,
             );
 
-            is_opaque = prim_data.common.opacity.is_opaque;
-
             write_segment(
                 *segment_instance_index,
                 frame_state,
@@ -564,7 +571,6 @@
             let prim_data = &mut data_stores.yuv_image[*data_handle];
             let common_data = &mut prim_data.common;
             let yuv_image_data = &mut prim_data.kind;
-            is_opaque = true;
 
             common_data.may_need_repetition = false;
 
@@ -602,9 +608,6 @@
                 &mut prim_instance.vis,
             );
 
-            // common_data.opacity.is_opaque is computed in the above update call.
-            is_opaque = common_data.opacity.is_opaque;
-
             write_segment(
                 image_instance.segment_instance_index,
                 frame_state,
@@ -777,12 +780,15 @@
                 if let Picture3DContext::In { root_data: None, plane_splitter_index, .. } = pic.context_3d {
                     let dirty_rect = frame_state.current_dirty_region().combined;
                     let splitter = &mut frame_state.plane_splitters[plane_splitter_index.0];
+                    let surface_index = pic.raster_config.as_ref().unwrap().surface_index;
+                    let surface = &frame_state.surfaces[surface_index.0];
+                    let local_prim_rect = surface.local_rect.cast_unit();
 
                     PicturePrimitive::add_split_plane(
                         splitter,
                         frame_context.spatial_tree,
                         prim_spatial_node_index,
-                        pic.precise_local_rect,
+                        local_prim_rect,
                         &prim_instance.vis.combined_local_clip_rect,
                         dirty_rect,
                         plane_split_anchor,
@@ -842,26 +848,6 @@
             }
         }
     };
-
-    // If the primitive is opaque, see if it can contribut to it's picture surface's opaque rect.
-
-    is_opaque = is_opaque && {
-        let clip = prim_instance.vis.clip_task_index;
-        clip == ClipTaskIndex::INVALID
-    };
-
-    is_opaque = is_opaque && !frame_context.spatial_tree.is_relative_transform_complex(
-        prim_spatial_node_index,
-        pic_context.raster_spatial_node_index,
-    );
-
-    if is_opaque {
-        let prim_local_rect = data_stores.get_local_prim_rect(
-            prim_instance,
-            store,
-        );
-        cluster.opaque_rect = crate::util::conservative_union_rect(&cluster.opaque_rect, &prim_local_rect);
-    }
 }
 
 
@@ -1424,7 +1410,8 @@
     // in the instance and primitive template.
     let prim_local_rect = data_stores.get_local_prim_rect(
         instance,
-        prim_store,
+        &prim_store.pictures,
+        frame_state.surfaces,
     );
 
     let segment_instance_index = match instance.kind {