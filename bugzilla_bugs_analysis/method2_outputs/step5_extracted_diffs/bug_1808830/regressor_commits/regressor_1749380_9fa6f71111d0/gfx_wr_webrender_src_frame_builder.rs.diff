# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/frame_builder.rs
# Commit: 9fa6f71111d0
# Full Hash: 9fa6f71111d0d77477abc4502b721d8d4ba23604
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-02-20 21:58:21
# Regressor Bug: 1749380
# File Overlap Count: 1
# Description:
#   Bug 1749380 - Part 1 - Improve how WR handles bounding rects for off-screen surfaces r=gfx-reviewers
#   
#   This patch introduces a number of subtle but important changes
#   to how we deal with off-screen surfaces. The overall goals are:
#   
# ==============================================================================

diff -r 336a2aa0a29e -r 9fa6f71111d0 gfx/wr/webrender/src/frame_builder.rs
--- a/gfx/wr/webrender/src/frame_builder.rs	Sat Feb 19 23:27:02 2022 +0000
+++ b/gfx/wr/webrender/src/frame_builder.rs	Sun Feb 20 18:56:54 2022 +0000
@@ -32,7 +32,7 @@
 use crate::segment::SegmentBuilder;
 use std::{f32, mem};
 use crate::util::{VecHelper, Preallocator};
-use crate::visibility::{update_primitive_visibility, FrameVisibilityState, FrameVisibilityContext};
+use crate::visibility::{update_prim_visibility, FrameVisibilityState, FrameVisibilityContext};
 use plane_split::Splitter;
 
 
@@ -125,7 +125,7 @@
 
 pub struct FrameScratchBuffer {
     dirty_region_stack: Vec<DirtyRegion>,
-    surface_stack: Vec<SurfaceIndex>,
+    surface_stack: Vec<(PictureIndex, SurfaceIndex)>,
     clip_chain_stack: ClipChainStack,
 }
 
@@ -204,12 +204,13 @@
         &mut self,
         surface_index: SurfaceIndex,
         tasks: Vec<RenderTaskId>,
-        raster_rect: DeviceRect,
+        clipping_rect: PictureRect,
     ) {
         let surface = &mut self.surfaces[surface_index.0];
         assert!(surface.render_tasks.is_none());
         surface.render_tasks = Some(SurfaceRenderTasks::Tiled(tasks));
-        surface.raster_rect = Some(raster_rect);
+        // TODO(gw): Include the dirty rect here, to reduce child surface sizes
+        surface.clipping_rect = clipping_rect;
     }
 
     /// Initialize render tasks for a simple surface, that contains only a
@@ -219,12 +220,12 @@
         surface_index: SurfaceIndex,
         task_id: RenderTaskId,
         parent_surface_index: SurfaceIndex,
-        raster_rect: DeviceRect,
+        clipping_rect: PictureRect,
     ) {
         let surface = &mut self.surfaces[surface_index.0];
         assert!(surface.render_tasks.is_none());
         surface.render_tasks = Some(SurfaceRenderTasks::Simple(task_id));
-        surface.raster_rect = Some(raster_rect);
+        surface.clipping_rect = clipping_rect;
 
         self.add_child_render_task(
             parent_surface_index,
@@ -241,12 +242,12 @@
         root_task_id: RenderTaskId,
         port_task_id: RenderTaskId,
         parent_surface_index: SurfaceIndex,
-        raster_rect: DeviceRect,
+        clipping_rect: PictureRect,
     ) {
         let surface = &mut self.surfaces[surface_index.0];
         assert!(surface.render_tasks.is_none());
         surface.render_tasks = Some(SurfaceRenderTasks::Chained { root_task_id, port_task_id });
-        surface.raster_rect = Some(raster_rect);
+        surface.clipping_rect = clipping_rect;
 
         self.add_child_render_task(
             parent_surface_index,
@@ -375,7 +376,6 @@
                 global_device_pixel_scale,
                 spatial_tree,
                 global_screen_world_rect,
-                surfaces: &mut scene.surfaces,
                 debug_flags,
                 scene_properties,
                 config: scene.config,
@@ -405,8 +405,9 @@
                         // If we have a tile cache for this picture, see if any of the
                         // relative transforms have changed, which means we need to
                         // re-map the dependencies of any child primitives.
+                        let surface = &scene.surfaces[surface_index.0];
                         let world_culling_rect = tile_cache.pre_update(
-                            layout_rect_as_picture_rect(&pic.estimated_local_rect),
+                            surface.local_rect,
                             surface_index,
                             &visibility_context,
                             &mut visibility_state,
@@ -415,21 +416,23 @@
                         // Push a new surface, supplying the list of clips that should be
                         // ignored, since they are handled by clipping when drawing this surface.
                         visibility_state.push_surface(
+                            *pic_index,
                             surface_index,
                             &tile_cache.shared_clips,
                             frame_context.spatial_tree,
                         );
 
-                        update_primitive_visibility(
-                            &mut scene.prim_store,
+                        update_prim_visibility(
                             *pic_index,
                             None,
                             &world_culling_rect,
+                            &mut scene.prim_store,
+                            &mut scene.prim_instances,
+                            &mut scene.surfaces,
+                            true,
                             &visibility_context,
                             &mut visibility_state,
                             tile_cache,
-                            true,
-                            &mut scene.prim_instances,
                         );
 
                         // Build the dirty region(s) for this tile cache.