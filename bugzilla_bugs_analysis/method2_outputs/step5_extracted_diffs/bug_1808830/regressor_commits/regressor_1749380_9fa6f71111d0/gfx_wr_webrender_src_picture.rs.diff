# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/picture.rs
# Commit: 9fa6f71111d0
# Full Hash: 9fa6f71111d0d77477abc4502b721d8d4ba23604
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-02-20 21:58:21
# Regressor Bug: 1749380
# File Overlap Count: 1
# Description:
#   Bug 1749380 - Part 1 - Improve how WR handles bounding rects for off-screen surfaces r=gfx-reviewers
#   
#   This patch introduces a number of subtle but important changes
#   to how we deal with off-screen surfaces. The overall goals are:
#   
# ==============================================================================

diff -r 336a2aa0a29e -r 9fa6f71111d0 gfx/wr/webrender/src/picture.rs
--- a/gfx/wr/webrender/src/picture.rs	Sat Feb 19 23:27:02 2022 +0000
+++ b/gfx/wr/webrender/src/picture.rs	Sun Feb 20 18:56:54 2022 +0000
@@ -107,7 +107,7 @@
 use crate::composite::{ExternalSurfaceDescriptor, ExternalSurfaceDependency, CompositeTileDescriptor, CompositeTile};
 use crate::composite::{CompositorTransformIndex};
 use crate::debug_colors;
-use euclid::{vec2, vec3, Point2D, Scale, Vector2D, Box2D, SideOffsets2D};
+use euclid::{vec3, Point2D, Scale, Vector2D, Box2D};
 use euclid::approxeq::ApproxEq;
 use crate::filterdata::SFilterData;
 use crate::intern::ItemUid;
@@ -135,7 +135,7 @@
 use std::collections::hash_map::Entry;
 use std::ops::Range;
 use crate::picture_textures::PictureCacheTextureHandle;
-use crate::util::{MaxRect, VecHelper, MatrixHelpers, Recycler, raster_rect_to_device_pixels, ScaleOffset};
+use crate::util::{MaxRect, VecHelper, MatrixHelpers, Recycler, ScaleOffset};
 use crate::filterdata::{FilterDataHandle};
 use crate::tile_cache::{SliceDebugInfo, TileDebugInfo, DirtyTileDebugInfo};
 use crate::visibility::{PrimitiveVisibilityFlags, FrameVisibilityContext};
@@ -144,7 +144,7 @@
 
 // Maximum blur radius for blur filter (different than box-shadow blur).
 // Taken from FilterNodeSoftware.cpp in Gecko.
-pub const MAX_BLUR_RADIUS: f32 = 100.;
+const MAX_BLUR_RADIUS: f32 = 100.;
 
 /// Specify whether a surface allows subpixel AA text rendering.
 #[derive(Debug, Copy, Clone)]
@@ -1600,46 +1600,11 @@
             sub_slice_index,
         });
     }
-
-    // TODO(gw): This returns a heap allocated object. Perhaps we can simplify this
-    //           logic? Although - it's only used very rarely so it may not be an issue.
-    pub fn inflate(
-        &self,
-        inflate_amount: f32,
-        spatial_tree: &SpatialTree,
-    ) -> DirtyRegion {
-        let map_pic_to_world = SpaceMapper::new_with_target(
-            spatial_tree.root_reference_frame_index(),
-            self.spatial_node_index,
-            WorldRect::max_rect(),
-            spatial_tree,
-        );
-
-        let mut filters = Vec::with_capacity(self.filters.len());
-        let mut combined = WorldRect::zero();
-
-        for filter in &self.filters {
-            let rect_in_pic_space = filter.rect_in_pic_space.inflate(inflate_amount, inflate_amount);
-
-            let world_rect = map_pic_to_world
-                .map(&rect_in_pic_space)
-                .expect("bug");
-
-            combined = combined.union(&world_rect);
-            filters.push(BatchFilter {
-                rect_in_pic_space,
-                sub_slice_index: filter.sub_slice_index,
-            });
-        }
-
-        DirtyRegion {
-            filters,
-            combined,
-            spatial_node_index: self.spatial_node_index,
-        }
-    }
 }
 
+// TODO(gw): Tidy this up by:
+//      - Rename Clear variant to something more appropriate to what it does
+//      - Add an Other variant for things like opaque gradient backdrops
 #[derive(Debug, Copy, Clone)]
 pub enum BackdropKind {
     Color {
@@ -2958,14 +2923,15 @@
         pictures: &[PicturePrimitive],
         resource_cache: &mut ResourceCache,
         color_bindings: &ColorBindingStorage,
-        surface_stack: &[SurfaceIndex],
+        surface_stack: &[(PictureIndex, SurfaceIndex)],
         composite_state: &mut CompositeState,
         gpu_cache: &mut GpuCache,
         is_root_tile_cache: bool,
+        surfaces: &mut [SurfaceInfo],
     ) {
         // This primitive exists on the last element on the current surface stack.
         profile_scope!("update_prim_dependencies");
-        let prim_surface_index = *surface_stack.last().unwrap();
+        let prim_surface_index = surface_stack.last().unwrap().1;
         let prim_clip_chain = &prim_instance.vis.clip_chain;
 
         // If the primitive is directly drawn onto this picture cache surface, then
@@ -2983,17 +2949,17 @@
             // surface stack, mapping the primitive rect into each surface space, including
             // the inflation factor from each intermediate surface.
             let mut current_pic_coverage_rect = prim_clip_chain.pic_coverage_rect;
-            let mut current_spatial_node_index = frame_context
-                .surfaces[prim_surface_index.0]
+            let mut current_spatial_node_index = surfaces[prim_surface_index.0]
                 .surface_spatial_node_index;
 
-            for surface_index in surface_stack.iter().rev() {
-                let surface = &frame_context.surfaces[surface_index.0];
+            for (pic_index, surface_index) in surface_stack.iter().rev() {
+                let surface = &surfaces[surface_index.0];
+                let pic = &pictures[pic_index.0];
 
                 let map_local_to_surface = SpaceMapper::new_with_target(
                     surface.surface_spatial_node_index,
                     current_spatial_node_index,
-                    surface.rect,
+                    surface.local_rect,
                     frame_context.spatial_tree,
                 );
 
@@ -3002,7 +2968,15 @@
                 // just bail out from the dependencies and cull this primitive.
                 current_pic_coverage_rect = match map_local_to_surface.map(&current_pic_coverage_rect) {
                     Some(rect) => {
-                        rect.inflate(surface.inflation_factor, surface.inflation_factor)
+                        // TODO(gw): The casts here are a hack. We have some interface inconsistencies
+                        //           between layout/picture rects which don't really work with the
+                        //           current unit system, since sometimes the local rect of a picture
+                        //           is a LayoutRect, and sometimes it's a PictureRect. Consider how
+                        //           we can improve this?
+                        pic.composite_mode.as_ref().unwrap().get_coverage(
+                            surface,
+                            Some(rect.cast_unit()),
+                        ).cast_unit()
                     }
                     None => {
                         return;
@@ -3326,6 +3300,37 @@
         let sub_slice = &mut self.sub_slices[sub_slice_index];
 
         if let Some(mut backdrop_candidate) = backdrop_candidate {
+            // Update whether the surface that this primitive exists on
+            // can be considered opaque. Any backdrop kind other than
+            // a clear primitive (e.g. color, gradient, image) can be
+            // considered.
+            match backdrop_candidate.kind {
+                Some(BackdropKind::Color { .. }) | None => {
+                    let surface = &mut surfaces[prim_surface_index.0];
+
+                    let is_same_coord_system = frame_context.spatial_tree.is_matching_coord_system(
+                        prim_spatial_node_index,
+                        surface.surface_spatial_node_index,
+                    );
+
+                    // To be an opaque backdrop, it must:
+                    // - Be the same coordinate system (axis-aligned)
+                    // - Have no clip mask
+                    // - Have a rect that covers the surface local rect
+                    if is_same_coord_system &&
+                       !prim_clip_chain.needs_mask &&
+                       prim_clip_chain.pic_coverage_rect.contains_box(&surface.local_rect)
+                    {
+                        // Note that we use `prim_clip_chain.pic_clip_rect` here rather
+                        // than `backdrop_candidate.opaque_rect`. The former is in the
+                        // local space of the surface, the latter is in the local space
+                        // of the top level tile-cache.
+                        surface.is_opaque = true;
+                    }
+                }
+                Some(BackdropKind::Clear) => {}
+            }
+
             let is_suitable_backdrop = match backdrop_candidate.kind {
                 Some(BackdropKind::Clear) => {
                     // Clear prims are special - they always end up in their own slice,
@@ -3343,14 +3348,10 @@
                     //  - The primitive is on the main picture cache surface.
                     //  - Same coord system as picture cache (ensures rects are axis-aligned).
                     //  - No clip masks exist.
-                    let same_coord_system = {
-                        let prim_spatial_node = frame_context.spatial_tree
-                            .get_spatial_node(prim_spatial_node_index);
-                        let surface_spatial_node = &frame_context.spatial_tree
-                            .get_spatial_node(self.spatial_node_index);
-
-                        prim_spatial_node.coordinate_system_id == surface_spatial_node.coordinate_system_id
-                    };
+                    let same_coord_system = frame_context.spatial_tree.is_matching_coord_system(
+                        prim_spatial_node_index,
+                        self.spatial_node_index,
+                    );
 
                     same_coord_system && on_picture_surface
                 }
@@ -3688,9 +3689,12 @@
 pub struct SurfaceInfo {
     /// A local rect defining the size of this surface, in the
     /// coordinate system of the surface itself.
-    pub rect: PictureRect,
-    /// Part of the surface that we know to be opaque.
-    pub opaque_rect: PictureRect,
+    pub local_rect: PictureRect,
+    /// If true, we know this surface is completely opaque
+    pub is_opaque: bool,
+    /// The (conservative) valid part of this surface rect. Used
+    /// to reduce the size of render target allocation.
+    pub clipping_rect: PictureRect,
     /// Helper structs for mapping local rects in different
     /// coordinate systems into the surface coordinates.
     pub map_local_to_surface: SpaceMapper<LayoutPixel, PicturePixel>,
@@ -3700,25 +3704,20 @@
     pub surface_spatial_node_index: SpatialNodeIndex,
     /// This is set when the render task is created.
     pub render_tasks: Option<SurfaceRenderTasks>,
-    /// How much the local surface rect should be inflated (for blur radii).
-    pub inflation_factor: f32,
     /// The device pixel ratio specific to this surface.
     pub device_pixel_scale: DevicePixelScale,
     /// The scale factors of the surface to raster transform.
-    pub scale_factors: (f32, f32),
-    /// The allocated raster rect for this surface
-    pub raster_rect: Option<DeviceRect>,
+    pub parent_scale_factors: (f32, f32),
 }
 
 impl SurfaceInfo {
     pub fn new(
         surface_spatial_node_index: SpatialNodeIndex,
         raster_spatial_node_index: SpatialNodeIndex,
-        inflation_factor: f32,
         world_rect: WorldRect,
         spatial_tree: &SpatialTree,
         device_pixel_scale: DevicePixelScale,
-        scale_factors: (f32, f32),
+        parent_scale_factors: (f32, f32),
     ) -> Self {
         let map_surface_to_world = SpaceMapper::new_with_target(
             spatial_tree.root_reference_frame_index(),
@@ -3737,22 +3736,27 @@
         );
 
         SurfaceInfo {
-            rect: PictureRect::zero(),
-            opaque_rect: PictureRect::zero(),
+            local_rect: PictureRect::zero(),
+            is_opaque: false,
+            clipping_rect: PictureRect::zero(),
             map_local_to_surface,
             render_tasks: None,
             raster_spatial_node_index,
             surface_spatial_node_index,
-            inflation_factor,
             device_pixel_scale,
-            scale_factors,
-            raster_rect: None,
+            parent_scale_factors,
         }
     }
-
-    pub fn get_raster_rect(&self) -> DeviceRect {
-        self.raster_rect.expect("bug: queried before surface was initialized")
-    }
+}
+
+/// Information from `get_surface_rects` about the allocated size, UV sampling
+/// parameters etc for an off-screen surface
+struct SurfaceAllocInfo {
+    task_size: DeviceIntSize,
+    unclipped: DeviceRect,
+    clipped: DeviceRect,
+    clipped_local: PictureRect,
+    uv_rect_kind: UvRectKind,
 }
 
 #[derive(Debug)]
@@ -3760,24 +3764,11 @@
 pub struct RasterConfig {
     /// How this picture should be composited into
     /// the parent surface.
+    // TODO(gw): We should remove this and just use what is in PicturePrimitive
     pub composite_mode: PictureCompositeMode,
     /// Index to the surface descriptor for this
     /// picture.
     pub surface_index: SurfaceIndex,
-    /// Whether this picture establishes a rasterization root.
-    pub establishes_raster_root: bool,
-    /// Scaling factor applied to fit within MAX_SURFACE_SIZE when
-    /// establishing a raster root.
-    /// Most code doesn't need to know about it, since it is folded
-    /// into device_pixel_scale when the rendertask is set up.
-    /// However e.g. text rasterization uses it to ensure consistent
-    /// on-screen font size.
-    pub root_scaling_factor: f32,
-    /// The world rect of this picture clipped to the current culling
-    /// rect. This is used for determining the size of the render
-    /// target rect for this surface, and calculating raster scale
-    /// factors.
-    pub clipped_bounding_rect: WorldRect,
 }
 
 bitflags! {
@@ -3819,71 +3810,183 @@
 }
 
 impl PictureCompositeMode {
-    pub fn inflate_picture_rect(&self, picture_rect: PictureRect, scale_factors: (f32, f32)) -> PictureRect {
-        let mut result_rect = picture_rect;
+    pub fn get_rect(
+        &self,
+        surface: &SurfaceInfo,
+        sub_rect: Option<LayoutRect>,
+    ) -> LayoutRect {
+        let surface_rect = match sub_rect {
+            Some(sub_rect) => sub_rect,
+            None => surface.local_rect.cast_unit(),
+        };
+
         match self {
-            PictureCompositeMode::Filter(filter) => match filter {
-                Filter::Blur(width, height) => {
-                    let width_factor = clamp_blur_radius(*width, scale_factors).ceil() * BLUR_SAMPLE_SCALE;
-                    let height_factor = clamp_blur_radius(*height, scale_factors).ceil() * BLUR_SAMPLE_SCALE;
-                    result_rect = picture_rect.inflate(width_factor, height_factor);
-                },
-                Filter::DropShadows(shadows) => {
-                    let mut max_inflation: f32 = 0.0;
-                    for shadow in shadows {
-                        max_inflation = max_inflation.max(shadow.blur_radius);
-                    }
-                    max_inflation = clamp_blur_radius(max_inflation, scale_factors).ceil() * BLUR_SAMPLE_SCALE;
-                    result_rect = picture_rect.inflate(max_inflation, max_inflation);
-                },
-                _ => {}
+            PictureCompositeMode::Filter(Filter::Blur { width, height, should_inflate }) => {
+                if *should_inflate {
+                    let width_factor = clamp_blur_radius(*width, surface.parent_scale_factors).ceil() * BLUR_SAMPLE_SCALE;
+                    let height_factor = clamp_blur_radius(*height, surface.parent_scale_factors).ceil() * BLUR_SAMPLE_SCALE;
+
+                    surface_rect.inflate(width_factor, height_factor)
+                } else {
+                    surface_rect
+                }
+            }
+            PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
+                let mut max_blur_radius = 0.0;
+                for shadow in shadows {
+                    max_blur_radius = f32::max(max_blur_radius, shadow.blur_radius);
+                }
+
+                let max_blur_radius = clamp_blur_radius(
+                    max_blur_radius,
+                    surface.parent_scale_factors
+                ).ceil();
+                let blur_inflation = max_blur_radius * BLUR_SAMPLE_SCALE;
+
+                surface_rect.inflate(blur_inflation, blur_inflation)
             }
             PictureCompositeMode::SvgFilter(primitives, _) => {
+                let mut result_rect = surface_rect;
                 let mut output_rects = Vec::with_capacity(primitives.len());
+
                 for (cur_index, primitive) in primitives.iter().enumerate() {
                     let output_rect = match primitive.kind {
                         FilterPrimitiveKind::Blur(ref primitive) => {
-                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect);
+                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
                             let width_factor = primitive.width.round() * BLUR_SAMPLE_SCALE;
                             let height_factor = primitive.height.round() * BLUR_SAMPLE_SCALE;
                             input.inflate(width_factor, height_factor)
                         }
                         FilterPrimitiveKind::DropShadow(ref primitive) => {
                             let inflation_factor = primitive.shadow.blur_radius.ceil() * BLUR_SAMPLE_SCALE;
-                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect);
+                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
                             let shadow_rect = input.inflate(inflation_factor, inflation_factor);
                             input.union(&shadow_rect.translate(primitive.shadow.offset * Scale::new(1.0)))
                         }
                         FilterPrimitiveKind::Blend(ref primitive) => {
-                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect)
-                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect))
+                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect)
+                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect))
                         }
                         FilterPrimitiveKind::Composite(ref primitive) => {
-                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect)
-                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect))
+                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect)
+                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect))
                         }
                         FilterPrimitiveKind::Identity(ref primitive) =>
-                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect),
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
                         FilterPrimitiveKind::Opacity(ref primitive) =>
-                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect),
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
                         FilterPrimitiveKind::ColorMatrix(ref primitive) =>
-                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect),
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
                         FilterPrimitiveKind::ComponentTransfer(ref primitive) =>
-                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect),
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
                         FilterPrimitiveKind::Offset(ref primitive) => {
-                            let input_rect = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(picture_rect);
+                            let input_rect = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
                             input_rect.translate(primitive.offset * Scale::new(1.0))
                         },
 
-                        FilterPrimitiveKind::Flood(..) => picture_rect,
+                        FilterPrimitiveKind::Flood(..) => surface_rect,
                     };
                     output_rects.push(output_rect);
                     result_rect = result_rect.union(&output_rect);
                 }
+                result_rect
             }
-            _ => {},
+            _ => {
+                surface_rect
+            }
         }
-        result_rect
+    }
+
+    pub fn get_coverage(
+        &self,
+        surface: &SurfaceInfo,
+        sub_rect: Option<LayoutRect>,
+    ) -> LayoutRect {
+        let surface_rect = match sub_rect {
+            Some(sub_rect) => sub_rect,
+            None => surface.local_rect.cast_unit(),
+        };
+
+        match self {
+            PictureCompositeMode::Filter(Filter::Blur { width, height, should_inflate }) => {
+                if *should_inflate {
+                    let width_factor = clamp_blur_radius(*width, surface.parent_scale_factors).ceil() * BLUR_SAMPLE_SCALE;
+                    let height_factor = clamp_blur_radius(*height, surface.parent_scale_factors).ceil() * BLUR_SAMPLE_SCALE;
+
+                    surface_rect.inflate(width_factor, height_factor)
+                } else {
+                    surface_rect
+                }
+            }
+            PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
+                let mut rect = surface_rect;
+
+                for shadow in shadows {
+                    let blur_radius = clamp_blur_radius(
+                        shadow.blur_radius,
+                        surface.parent_scale_factors,
+                    ).ceil();
+                    let blur_inflation = blur_radius * BLUR_SAMPLE_SCALE;
+
+                    let shadow_rect = surface_rect
+                        .translate(shadow.offset)
+                        .inflate(blur_inflation, blur_inflation);
+                    rect = rect.union(&shadow_rect);
+                }
+
+                rect
+            }
+            PictureCompositeMode::SvgFilter(primitives, _) => {
+                let mut result_rect = surface_rect;
+                let mut output_rects = Vec::with_capacity(primitives.len());
+
+                for (cur_index, primitive) in primitives.iter().enumerate() {
+                    let output_rect = match primitive.kind {
+                        FilterPrimitiveKind::Blur(ref primitive) => {
+                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
+                            let width_factor = primitive.width.round() * BLUR_SAMPLE_SCALE;
+                            let height_factor = primitive.height.round() * BLUR_SAMPLE_SCALE;
+
+                            input.inflate(width_factor, height_factor)
+                        }
+                        FilterPrimitiveKind::DropShadow(ref primitive) => {
+                            let inflation_factor = primitive.shadow.blur_radius.ceil() * BLUR_SAMPLE_SCALE;
+                            let input = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
+                            let shadow_rect = input.inflate(inflation_factor, inflation_factor);
+                            input.union(&shadow_rect.translate(primitive.shadow.offset * Scale::new(1.0)))
+                        }
+                        FilterPrimitiveKind::Blend(ref primitive) => {
+                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect)
+                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect))
+                        }
+                        FilterPrimitiveKind::Composite(ref primitive) => {
+                            primitive.input1.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect)
+                                .union(&primitive.input2.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect))
+                        }
+                        FilterPrimitiveKind::Identity(ref primitive) =>
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
+                        FilterPrimitiveKind::Opacity(ref primitive) =>
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
+                        FilterPrimitiveKind::ColorMatrix(ref primitive) =>
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
+                        FilterPrimitiveKind::ComponentTransfer(ref primitive) =>
+                            primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect),
+                        FilterPrimitiveKind::Offset(ref primitive) => {
+                            let input_rect = primitive.input.to_index(cur_index).map(|index| output_rects[index]).unwrap_or(surface_rect);
+                            input_rect.translate(primitive.offset * Scale::new(1.0))
+                        },
+
+                        FilterPrimitiveKind::Flood(..) => surface_rect,
+                    };
+                    output_rects.push(output_rect);
+                    result_rect = result_rect.union(&output_rect);
+                }
+                result_rect
+            }
+            _ => {
+                surface_rect
+            }
+        }
     }
 }
 
@@ -4098,22 +4201,6 @@
     }
 }
 
-/// Defines configuration options for a given picture primitive.
-#[cfg_attr(feature = "capture", derive(Serialize))]
-pub struct PictureOptions {
-    /// If true, WR should inflate the bounding rect of primitives when
-    /// using a filter effect that requires inflation.
-    pub inflate_if_required: bool,
-}
-
-impl Default for PictureOptions {
-    fn default() -> Self {
-        PictureOptions {
-            inflate_if_required: true,
-        }
-    }
-}
-
 #[cfg_attr(feature = "capture", derive(Serialize))]
 pub struct PicturePrimitive {
     /// List of primitives, and associated info for this picture.
@@ -4150,24 +4237,10 @@
     /// composited into the parent picture.
     pub spatial_node_index: SpatialNodeIndex,
 
-    /// The conservative local rect of this picture. It is
-    /// built dynamically during the first picture traversal.
-    /// It is composed of already snapped primitives.
-    pub estimated_local_rect: LayoutRect,
-
-    /// The local rect of this picture. It is built
-    /// dynamically during the frame visibility update. It
-    /// differs from the estimated_local_rect because it
-    /// will not contain culled primitives, takes into
-    /// account surface inflation and the whole clip chain.
-    /// It is frequently the same, but may be quite
-    /// different depending on how much was culled.
-    pub precise_local_rect: LayoutRect,
-
-    /// Store the state of the previous precise local rect
+    /// Store the state of the previous local rect
     /// for this picture. We need this in order to know when
     /// to invalidate segments / drop-shadow gpu cache handles.
-    pub prev_precise_local_rect: LayoutRect,
+    pub prev_local_rect: LayoutRect,
 
     /// If false, this picture needs to (re)build segments
     /// if it supports segment rendering. This can occur
@@ -4175,9 +4248,6 @@
     /// transform animation and/or scrolling.
     pub segments_are_valid: bool,
 
-    /// The config options for this picture.
-    pub options: PictureOptions,
-
     /// Set to true if we know for sure the picture is fully opaque.
     pub is_opaque: bool,
 }
@@ -4191,8 +4261,6 @@
     ) {
         pt.new_level(format!("{:?}", self_index));
         pt.add_item(format!("cluster_count: {:?}", self.prim_list.clusters.len()));
-        pt.add_item(format!("estimated_local_rect: {:?}", self.estimated_local_rect));
-        pt.add_item(format!("precise_local_rect: {:?}", self.precise_local_rect));
         pt.add_item(format!("spatial_node_index: {:?}", self.spatial_node_index));
         pt.add_item(format!("raster_config: {:?}", self.raster_config));
         pt.add_item(format!("composite_mode: {:?}", self.composite_mode));
@@ -4264,10 +4332,6 @@
         true
     }
 
-    // TODO(gw): We have the PictureOptions struct available. We
-    //           should move some of the parameter list in this
-    //           method to be part of the PictureOptions, and
-    //           avoid adding new parameters here.
     pub fn new_image(
         composite_mode: Option<PictureCompositeMode>,
         context_3d: Picture3DContext<OrderedPictureChild>,
@@ -4275,7 +4339,6 @@
         flags: PrimitiveFlags,
         prim_list: PrimitiveList,
         spatial_node_index: SpatialNodeIndex,
-        options: PictureOptions,
     ) -> Self {
         PicturePrimitive {
             prim_list,
@@ -4288,10 +4351,7 @@
             apply_local_clip_rect,
             is_backface_visible: flags.contains(PrimitiveFlags::IS_BACKFACE_VISIBLE),
             spatial_node_index,
-            estimated_local_rect: LayoutRect::zero(),
-            precise_local_rect: LayoutRect::zero(),
-            prev_precise_local_rect: LayoutRect::zero(),
-            options,
+            prev_local_rect: LayoutRect::zero(),
             segments_are_valid: false,
             is_opaque: false,
         }
@@ -4321,7 +4381,7 @@
         // Extract the raster and surface spatial nodes from the raster
         // config, if this picture establishes a surface. Otherwise just
         // pass in the spatial node indices from the parent context.
-        let (raster_spatial_node_index, surface_spatial_node_index, surface_index, inflation_factor) = match self.raster_config {
+        let (raster_spatial_node_index, surface_spatial_node_index, surface_index) = match self.raster_config {
             Some(ref raster_config) => {
                 let surface = &frame_state.surfaces[raster_config.surface_index.0];
 
@@ -4329,7 +4389,6 @@
                     surface.raster_spatial_node_index,
                     self.spatial_node_index,
                     raster_config.surface_index,
-                    surface.inflation_factor,
                 )
             }
             None => {
@@ -4337,7 +4396,6 @@
                     raster_spatial_node_index,
                     surface_spatial_node_index,
                     parent_surface_index.expect("bug: no parent"),
-                    0.0,
                 )
             }
         };
@@ -4758,164 +4816,78 @@
                         );
                 }
 
-                // TODO(gw): Much of the SurfaceInfo related code assumes it is in device pixels, rather than
-                //           raster pixels. Fixing that in one go is too invasive for now, but we need to
-                //           start incrementally fixing up the unit types used around here.
-                let surface_raster_rect = map_pic_to_raster.map(&surface_local_rect).expect("bug: unable to map to raster");
-                let surface_device_rect = surface_raster_rect.cast_unit() * device_pixel_scale;
-
                 frame_state.init_surface_tiled(
                     surface_index,
                     surface_tasks,
-                    surface_device_rect,
+                    surface_local_rect,
                 );
             }
             Some(ref mut raster_config) => {
-                let pic_rect = self.precise_local_rect.cast_unit();
-                let parent_surface_index = parent_surface_index.expect("bug: no parent for child surface");
-
-                let mut device_pixel_scale = frame_state
-                    .surfaces[raster_config.surface_index.0]
-                    .device_pixel_scale;
-
-                let scale_factors = frame_state
+                let pic_rect = frame_state
                     .surfaces[raster_config.surface_index.0]
-                    .scale_factors;
-
-                // If the primitive has a filter that can sample with an offset, the clip rect has
-                // to take it into account.
-                let clip_inflation = match raster_config.composite_mode {
-                    PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
-                        let mut max_offset = vec2(0.0, 0.0);
-                        let mut min_offset = vec2(0.0, 0.0);
-                        for shadow in shadows {
-                            let offset = layout_vector_as_picture_vector(shadow.offset);
-                            max_offset = max_offset.max(offset);
-                            min_offset = min_offset.min(offset);
+                    .local_rect;
+
+                let parent_surface_index = parent_surface_index.expect("bug: no parent for child surface");
+
+                // Layout space for the picture is picture space from the
+                // perspective of its child primitives.
+                let local_rect = pic_rect * Scale::new(1.0);
+
+                // If the precise rect changed since last frame, we need to invalidate
+                // any segments and gpu cache handles for drop-shadows.
+                // TODO(gw): Requiring storage of the `prev_precise_local_rect` here
+                //           is a total hack. It's required because `prev_precise_local_rect`
+                //           gets written to twice (during initial vis pass and also during
+                //           prepare pass). The proper longer term fix for this is to make
+                //           use of the conservative picture rect for segmenting (which should
+                //           be done during scene building).
+                if local_rect != self.prev_local_rect {
+                    match raster_config.composite_mode {
+                        PictureCompositeMode::Filter(Filter::DropShadows(..)) => {
+                            for handle in &self.extra_gpu_data_handles {
+                                frame_state.gpu_cache.invalidate(handle);
+                            }
                         }
-
-                        // Get the shadow offsets in world space.
-                        let raster_min = map_pic_to_raster.map_vector(min_offset);
-                        let raster_max = map_pic_to_raster.map_vector(max_offset);
-                        let world_min = map_raster_to_world.map_vector(raster_min);
-                        let world_max = map_raster_to_world.map_vector(raster_max);
-
-                        // Grow the clip in the opposite direction of the shadow's offset.
-                        SideOffsets2D::from_vectors_outer(
-                            -world_max.max(vec2(0.0, 0.0)),
-                            -world_min.min(vec2(0.0, 0.0)),
-                        )
+                        _ => {}
                     }
-                    _ => SideOffsets2D::zero(),
-                };
-
-                let (mut clipped, mut unclipped) = match get_raster_rects(
-                    pic_rect,
-                    &map_pic_to_raster,
-                    &map_raster_to_world,
-                    raster_config.clipped_bounding_rect.outer_box(clip_inflation),
-                    device_pixel_scale,
+                    // Invalidate any segments built for this picture, since the local
+                    // rect has changed.
+                    self.segments_are_valid = false;
+                    self.prev_local_rect = local_rect;
+                }
+
+                let surface_rects = match get_surface_rects(
+                    raster_config.surface_index,
+                    &raster_config.composite_mode,
+                    parent_surface_index,
+                    &mut frame_state.surfaces,
+                    frame_context.spatial_tree,
                 ) {
-                    Some(info) => info,
-                    None => {
-                        return None
-                    }
+                    Some(rects) => rects,
+                    None => return None,
                 };
-                let transform = map_pic_to_raster.get_transform();
-
-                /// If the picture (raster_config) establishes a raster root,
-                /// its requested resolution won't be clipped by the parent or
-                /// viewport; so we need to make sure the requested resolution is
-                /// "reasonable", ie. <= MAX_SURFACE_SIZE.  If not, scale the
-                /// picture down until it fits that limit.  This results in a new
-                /// device_rect, a new unclipped rect, and a new device_pixel_scale.
-                ///
-                /// Since the adjusted device_pixel_scale is passed into the
-                /// RenderTask (and then the shader via RenderTaskData) this mostly
-                /// works transparently, reusing existing support for variable DPI
-                /// support.  The on-the-fly scaling can be seen as on-the-fly,
-                /// per-task DPI adjustment.  Logical pixels are unaffected.
-                ///
-                /// The scaling factor is returned to the caller; blur radius,
-                /// font size, etc. need to be scaled accordingly.
-                fn adjust_scale_for_max_surface_size(
-                    raster_config: &RasterConfig,
-                    max_target_size: i32,
-                    pic_rect: PictureRect,
-                    map_pic_to_raster: &SpaceMapper<PicturePixel, RasterPixel>,
-                    map_raster_to_world: &SpaceMapper<RasterPixel, WorldPixel>,
-                    clipped_prim_bounding_rect: WorldRect,
-                    device_pixel_scale : &mut DevicePixelScale,
-                    device_rect: &mut DeviceRect,
-                    unclipped: &mut DeviceRect) -> Option<f32>
-                {
-                    let limit = if raster_config.establishes_raster_root {
-                        MAX_SURFACE_SIZE
-                    } else {
-                        max_target_size as f32
-                    };
-                    if device_rect.width() > limit || device_rect.height() > limit {
-                        // round_out will grow by 1 integer pixel if origin is on a
-                        // fractional position, so keep that margin for error with -1:
-                        let scale = (limit as f32 - 1.0) /
-                                    (f32::max(device_rect.width(), device_rect.height()));
-                        *device_pixel_scale = *device_pixel_scale * Scale::new(scale);
-                        let new_device_rect = device_rect.to_f32() * Scale::new(scale);
-                        *device_rect = new_device_rect.round_out();
-
-                        *unclipped = match get_raster_rects(
-                            pic_rect,
-                            &map_pic_to_raster,
-                            &map_raster_to_world,
-                            clipped_prim_bounding_rect,
-                            *device_pixel_scale
-                        ) {
-                            Some(info) => info.1,
-                            None => {
-                                return None
-                            }
-                        };
-                        Some(scale)
-                    }
-                    else
-                    {
-                        None
-                    }
-                }
+
+                let device_pixel_scale = frame_state.surfaces[raster_config.surface_index.0].device_pixel_scale;
 
                 let primary_render_task_id;
                 match raster_config.composite_mode {
                     PictureCompositeMode::TileCache { .. } => {
                         unreachable!("handled above");
                     }
-                    PictureCompositeMode::Filter(Filter::Blur(width, height)) => {
-                        let width_std_deviation = clamp_blur_radius(width, scale_factors) * device_pixel_scale.0;
-                        let height_std_deviation = clamp_blur_radius(height, scale_factors) * device_pixel_scale.0;
-                        let mut blur_std_deviation = DeviceSize::new(
-                            width_std_deviation * scale_factors.0,
-                            height_std_deviation * scale_factors.1
+                    PictureCompositeMode::Filter(Filter::Blur { width, height, .. }) => {
+                        let surface = &frame_state.surfaces[raster_config.surface_index.0];
+                        let width = clamp_blur_radius(width, surface.parent_scale_factors);
+                        let height = clamp_blur_radius(height, surface.parent_scale_factors);
+
+                        let width_std_deviation = width * device_pixel_scale.0;
+                        let height_std_deviation = height * device_pixel_scale.0;
+                        let blur_std_deviation = DeviceSize::new(
+                            width_std_deviation,
+                            height_std_deviation,
                         );
-                        let mut device_rect = if self.options.inflate_if_required {
-                            let inflation_factor = frame_state.surfaces[raster_config.surface_index.0].inflation_factor;
-                            let inflation_factor = inflation_factor * device_pixel_scale.0;
-
-                            // The clipped field is the part of the picture that is visible
-                            // on screen. The unclipped field is the screen-space rect of
-                            // the complete picture, if no screen / clip-chain was applied
-                            // (this includes the extra space for blur region). To ensure
-                            // that we draw a large enough part of the picture to get correct
-                            // blur results, inflate that clipped area by the blur range, and
-                            // then intersect with the total screen rect, to minimize the
-                            // allocation size.
-                            clipped
-                                .inflate(inflation_factor * scale_factors.0, inflation_factor * scale_factors.1)
-                                .intersection(&unclipped)
-                                .unwrap()
-                        } else {
-                            clipped
-                        };
-
-                        let mut original_size = device_rect.size();
+
+                        let mut device_rect = surface_rects.clipped;
+                        let original_size = device_rect.size();
 
                         // Adjust the size to avoid introducing sampling errors during the down-scaling passes.
                         // what would be even better is to rasterize the picture at the down-scaled size
@@ -4926,32 +4898,12 @@
                         );
                         device_rect.set_size(adjusted_size);
 
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut device_rect, &mut unclipped,
-                        ) {
-                            blur_std_deviation = blur_std_deviation * scale;
-                            original_size = original_size.to_f32() * scale;
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &device_rect,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = device_rect.size().to_i32();
-
                         let picture_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
                                     device_rect.min,
                                     surface_spatial_node_index,
@@ -4960,7 +4912,7 @@
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         let blur_render_task_id = RenderTask::new_blur(
@@ -4979,7 +4931,7 @@
                             blur_render_task_id,
                             picture_task_id,
                             parent_surface_index,
-                            device_rect,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
@@ -4987,50 +4939,16 @@
                         for shadow in shadows {
                             max_std_deviation = f32::max(max_std_deviation, shadow.blur_radius);
                         }
-                        max_std_deviation = clamp_blur_radius(max_std_deviation, scale_factors) * device_pixel_scale.0;
-                        let max_blur_range = max_std_deviation * BLUR_SAMPLE_SCALE;
-
-                        // We cast clipped to f32 instead of casting unclipped to i32
-                        // because unclipped can overflow an i32.
-                        let mut device_rect = clipped
-                                .inflate(max_blur_range * scale_factors.0, max_blur_range * scale_factors.1)
-                                .intersection(&unclipped)
-                                .unwrap();
-
-                        let adjusted_size = BlurTask::adjusted_blur_source_size(
-                            device_rect.size(),
-                            DeviceSize::new(
-                                max_std_deviation * scale_factors.0,
-                                max_std_deviation * scale_factors.1
-                            ),
-                        );
-                        device_rect.set_size(adjusted_size);
-
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut device_rect, &mut unclipped,
-                        ) {
-                            // std_dev adjusts automatically from using device_pixel_scale
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &device_rect,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = device_rect.size().to_i32();
+                        let surface = &frame_state.surfaces[raster_config.surface_index.0];
+
+                        let device_rect = surface_rects.clipped;
 
                         let picture_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
                                     device_rect.min,
                                     surface_spatial_node_index,
@@ -5039,14 +4957,7 @@
                                     None,
                                     None,
                                 ),
-                            ).with_uv_rect_kind(uv_rect_kind)
-                        );
-
-                        // Add this content picture as a dependency of the parent surface, to
-                        // ensure it isn't free'd after the shadow uses it as an input.
-                        frame_state.add_child_render_task(
-                            parent_surface_index,
-                            picture_task_id,
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         let mut blur_tasks = BlurTaskCache::default();
@@ -5055,11 +4966,15 @@
 
                         let mut blur_render_task_id = picture_task_id;
                         for shadow in shadows {
-                            let blur_radius = clamp_blur_radius(shadow.blur_radius, scale_factors) * device_pixel_scale.0;
+                            let blur_radius = clamp_blur_radius(
+                                shadow.blur_radius,
+                                surface.parent_scale_factors,
+                            ) * device_pixel_scale.0;
+
                             blur_render_task_id = RenderTask::new_blur(
                                 DeviceSize::new(
-                                    blur_radius * scale_factors.0,
-                                    blur_radius * scale_factors.1,
+                                    blur_radius,
+                                    blur_radius,
                                 ),
                                 picture_task_id,
                                 frame_state.rg_builder,
@@ -5069,6 +4984,13 @@
                             );
                         }
 
+                        // Add this content picture as a dependency of the parent surface, to
+                        // ensure it isn't free'd after the shadow uses it as an input.
+                        frame_state.add_child_render_task(
+                            parent_surface_index,
+                            picture_task_id,
+                        );
+
                         primary_render_task_id = Some(blur_render_task_id);
                         self.secondary_render_task_id = Some(picture_task_id);
 
@@ -5077,7 +4999,7 @@
                             blur_render_task_id,
                             picture_task_id,
                             parent_surface_index,
-                            device_rect,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::MixBlend(mode) if BlendMode::from_mix_blend_mode(
@@ -5087,21 +5009,6 @@
                         frame_context.fb_config.dual_source_blending_is_enabled &&
                             frame_context.fb_config.dual_source_blending_is_supported,
                     ).is_none() => {
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut clipped, &mut unclipped,
-                        ) {
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &clipped,
-                            device_pixel_scale,
-                        );
 
                         let parent_surface = &frame_state.surfaces[parent_surface_index.0];
                         let parent_raster_spatial_node_index = parent_surface.raster_spatial_node_index;
@@ -5124,12 +5031,8 @@
 
                         // Apply device pixel ratio for parent surface to get into device
                         // pixels for that surface.
-                        let backdrop_rect = raster_rect_to_device_pixels(
-                            pic_in_raster_space,
-                            parent_device_pixel_scale,
-                        );
-
-                        let parent_surface_rect = parent_surface.get_raster_rect();
+                        let backdrop_rect = pic_in_raster_space.cast_unit() * parent_device_pixel_scale;
+                        let parent_surface_rect = parent_surface.clipping_rect.cast_unit() * parent_device_pixel_scale;
 
                         // If there is no available parent surface to read back from (for example, if
                         // the parent surface is affected by a clip that doesn't affect the child
@@ -5143,11 +5046,11 @@
                                 // from the primitive rect within the readback region. This is
                                 // 0..1 for aligned surfaces, but doing it this way allows
                                 // accurate sampling if the primitive bounds have fractional values.
+                                let available_rect = available_rect.round_out();
+
                                 let backdrop_uv = calculate_uv_rect_kind(
-                                    &pic_rect,
-                                    &map_pic_to_parent.get_transform(),
-                                    &available_rect,
-                                    parent_device_pixel_scale,
+                                    available_rect,
+                                    backdrop_rect,
                                 );
 
                                 frame_state.rg_builder.add().init(
@@ -5174,23 +5077,23 @@
 
                         self.secondary_render_task_id = Some(readback_task_id);
 
-                        let task_size = clipped.size().to_i32();
+                        let task_size = surface_rects.clipped.size().to_i32();
 
                         let render_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
                                 task_size,
                                 RenderTaskKind::new_picture(
                                     task_size,
-                                    unclipped.size(),
+                                    surface_rects.unclipped.size(),
                                     pic_index,
-                                    clipped.min,
+                                    surface_rects.clipped.min,
                                     surface_spatial_node_index,
                                     device_pixel_scale,
                                     None,
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         primary_render_task_id = Some(render_task_id);
@@ -5199,44 +5102,26 @@
                             raster_config.surface_index,
                             render_task_id,
                             parent_surface_index,
-                            clipped,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::Filter(..) => {
 
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut clipped, &mut unclipped,
-                        ) {
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &clipped,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = clipped.size().to_i32();
-
                         let render_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
-                                    clipped.min,
+                                    surface_rects.clipped.min,
                                     surface_spatial_node_index,
                                     device_pixel_scale,
                                     None,
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         primary_render_task_id = Some(render_task_id);
@@ -5245,43 +5130,26 @@
                             raster_config.surface_index,
                             render_task_id,
                             parent_surface_index,
-                            clipped,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::ComponentTransferFilter(..) => {
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut clipped, &mut unclipped,
-                        ) {
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &clipped,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = clipped.size().to_i32();
 
                         let render_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
-                                    clipped.min,
+                                    surface_rects.clipped.min,
                                     surface_spatial_node_index,
                                     device_pixel_scale,
                                     None,
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         primary_render_task_id = Some(render_task_id);
@@ -5290,44 +5158,27 @@
                             raster_config.surface_index,
                             render_task_id,
                             parent_surface_index,
-                            clipped,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::MixBlend(..) |
                     PictureCompositeMode::Blit(_) => {
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut clipped, &mut unclipped,
-                        ) {
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &clipped,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = clipped.size().to_i32();
 
                         let render_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
-                                    clipped.min,
+                                    surface_rects.clipped.min,
                                     surface_spatial_node_index,
                                     device_pixel_scale,
                                     None,
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         primary_render_task_id = Some(render_task_id);
@@ -5336,52 +5187,33 @@
                             raster_config.surface_index,
                             render_task_id,
                             parent_surface_index,
-                            clipped,
+                            surface_rects.clipped_local,
                         );
                     }
                     PictureCompositeMode::SvgFilter(ref primitives, ref filter_datas) => {
-
-                        if let Some(scale) = adjust_scale_for_max_surface_size(
-                            raster_config, frame_context.fb_config.max_target_size,
-                            pic_rect, &map_pic_to_raster, &map_raster_to_world,
-                            raster_config.clipped_bounding_rect,
-                            &mut device_pixel_scale, &mut clipped, &mut unclipped,
-                        ) {
-                            raster_config.root_scaling_factor = scale;
-                        }
-
-                        let uv_rect_kind = calculate_uv_rect_kind(
-                            &pic_rect,
-                            &transform,
-                            &clipped,
-                            device_pixel_scale,
-                        );
-
-                        let task_size = clipped.size().to_i32();
-
                         let picture_task_id = frame_state.rg_builder.add().init(
                             RenderTask::new_dynamic(
-                                task_size,
+                                surface_rects.task_size,
                                 RenderTaskKind::new_picture(
-                                    task_size,
-                                    unclipped.size(),
+                                    surface_rects.task_size,
+                                    surface_rects.unclipped.size(),
                                     pic_index,
-                                    clipped.min,
+                                    surface_rects.clipped.min,
                                     surface_spatial_node_index,
                                     device_pixel_scale,
                                     None,
                                     None,
                                     None,
                                 )
-                            ).with_uv_rect_kind(uv_rect_kind)
+                            ).with_uv_rect_kind(surface_rects.uv_rect_kind)
                         );
 
                         let filter_task_id = RenderTask::new_svg_filter(
                             primitives,
                             filter_datas,
                             frame_state.rg_builder,
-                            clipped.size().to_i32(),
-                            uv_rect_kind,
+                            surface_rects.clipped.size().to_i32(),
+                            surface_rects.uv_rect_kind,
                             picture_task_id,
                             device_pixel_scale,
                         );
@@ -5393,19 +5225,12 @@
                             filter_task_id,
                             picture_task_id,
                             parent_surface_index,
-                            clipped,
+                            surface_rects.clipped_local,
                         );
                     }
                 }
 
                 self.primary_render_task_id = primary_render_task_id;
-
-                // Update the device pixel ratio in the surface, in case it was adjusted due
-                // to the surface being too large. This ensures the correct scale is available
-                // in case it's used as input to a parent mix-blend-mode readback.
-                frame_state
-                    .surfaces[raster_config.surface_index.0]
-                    .device_pixel_scale = device_pixel_scale;
             }
             None => {}
         };
@@ -5428,15 +5253,6 @@
             dirty_region_count += 1;
         }
 
-        if inflation_factor > 0.0 {
-            let inflated_region = frame_state.current_dirty_region().inflate(
-                inflation_factor,
-                frame_context.spatial_tree,
-            );
-            frame_state.push_dirty_region(inflated_region);
-            dirty_region_count += 1;
-        }
-
         // Disallow subpixel AA if an intermediate surface is needed.
         // TODO(lsalzman): allow overriding parent if intermediate surface is opaque
         let subpixel_mode = match self.raster_config {
@@ -5668,37 +5484,28 @@
         &mut self,
         frame_context: &FrameBuildingContext,
         tile_caches: &mut FastHashMap<SliceId, Box<TileCacheInstance>>,
-        current_surface_index: Option<SurfaceIndex>,
         surfaces: &mut Vec<SurfaceInfo>,
-    ) -> SurfaceIndex {
+    ) -> Option<SurfaceIndex> {
         // Reset raster config in case we early out below.
         self.raster_config = None;
 
-        let surface_index = match self.composite_mode {
+        match self.composite_mode {
             Some(ref composite_mode) => {
-                // Retrieve the positioning node information for the parent surface.
-                let (parent_raster_node_index, parent_device_pixel_scale) = match current_surface_index {
-                    Some(index) => {
-                        let current_surface = &surfaces[index.0];
-                        (current_surface.raster_spatial_node_index, current_surface.device_pixel_scale)
-                    }
-                    None => {
-                        let root_spatial_node_index = frame_context.spatial_tree.root_reference_frame_index();
-                        (root_spatial_node_index, Scale::new(1.0))
-                    }
-                };
                 let surface_spatial_node_index = self.spatial_node_index;
 
-                let surface_to_parent_transform = frame_context.spatial_tree
-                    .get_relative_transform(surface_spatial_node_index, parent_raster_node_index);
-
                 // Currently, we ensure that the scaling factor is >= 1.0 as a smaller scale factor can result in blurry output.
-                let mut min_scale = 1.0;
+                let mut min_scale;
                 let mut max_scale = 1.0e32;
 
+                // If a raster root is established, this surface should be scaled based on the scale factors of the surface raster to parent raster transform.
+                // This scaling helps ensure that the content in this surface does not become blurry or pixelated when composited in the parent surface.
+
+                let world_transform = frame_context.spatial_tree.get_world_transform(self.spatial_node_index);
+                let scale_factors = world_transform.scale_factors();
+
                 // Check if there is perspective or if an SVG filter is applied, and thus whether a new
                 // rasterization root should be established.
-                let establishes_raster_root = match composite_mode {
+                let device_pixel_scale = match composite_mode {
                     PictureCompositeMode::TileCache { slice_id } => {
                         let tile_cache = tile_caches.get_mut(&slice_id).unwrap();
 
@@ -5732,86 +5539,28 @@
                             max_scale = tile_cache.current_raster_scale;
                         }
 
-                        // We know that picture cache tiles are always axis-aligned, but we want to establish
-                        // raster roots for them, so that we can easily control the scale factors used depending
-                        // on whether we want to zoom in high-performance or high-quality mode.
-                        true
+                        // Pick the largest scale factor of the transform for the scaling factor.
+                        let scaling_factor = scale_factors.0.max(scale_factors.1).max(min_scale).min(max_scale);
+
+                        let device_pixel_scale = Scale::new(scaling_factor);
+
+                        device_pixel_scale
                     }
-                    PictureCompositeMode::SvgFilter(..) => {
-                        // Filters must be applied before transforms, to do this, we can mark this picture as establishing a raster root.
-                        true
-                    }
-                    PictureCompositeMode::MixBlend(..) |
-                    PictureCompositeMode::Filter(..) |
-                    PictureCompositeMode::ComponentTransferFilter(..) |
-                    PictureCompositeMode::Blit(..) => {
-                        // TODO(gw): As follow ups, individually move each of these composite modes to create raster roots.
-                        surface_to_parent_transform.is_perspective()
+                    _ => {
+                        let min_scale = 1.0;
+
+                        let scaling_factor = scale_factors.0.max(scale_factors.1).max(min_scale);
+                        let device_pixel_scale = Scale::new(scaling_factor);
+
+                        device_pixel_scale
                     }
                 };
 
-                let (raster_spatial_node_index, device_pixel_scale) = if establishes_raster_root {
-                    // If a raster root is established, this surface should be scaled based on the scale factors of the surface raster to parent raster transform.
-                    // This scaling helps ensure that the content in this surface does not become blurry or pixelated when composited in the parent surface.
-                    let scale_factors = surface_to_parent_transform.scale_factors();
-
-                    // Pick the largest scale factor of the transform for the scaling factor.
-                    let scaling_factor = scale_factors.0.max(scale_factors.1).max(min_scale).min(max_scale);
-
-                    let device_pixel_scale = parent_device_pixel_scale * Scale::new(scaling_factor);
-                    (surface_spatial_node_index, device_pixel_scale)
-                } else {
-                    (parent_raster_node_index, parent_device_pixel_scale)
-                };
-
-                let scale_factors = frame_context
-                        .spatial_tree
-                        .get_relative_transform(surface_spatial_node_index, raster_spatial_node_index)
-                        .scale_factors();
-
-                // This inflation factor is to be applied to all primitives within the surface.
-                // Only inflate if the caller hasn't already inflated the bounding rects for this filter.
-                let mut inflation_factor = 0.0;
-                if self.options.inflate_if_required {
-                    match composite_mode {
-                        PictureCompositeMode::Filter(Filter::Blur(width, height)) => {
-                            let blur_radius = f32::max(clamp_blur_radius(*width, scale_factors), clamp_blur_radius(*height, scale_factors));
-                            // The amount of extra space needed for primitives inside
-                            // this picture to ensure the visibility check is correct.
-                            inflation_factor = blur_radius * BLUR_SAMPLE_SCALE;
-                        }
-                        PictureCompositeMode::SvgFilter(ref primitives, _) => {
-                            let mut max = 0.0;
-                            for primitive in primitives {
-                                if let FilterPrimitiveKind::Blur(ref blur) = primitive.kind {
-                                    max = f32::max(max, blur.width);
-                                    max = f32::max(max, blur.height);
-                                }
-                            }
-                            inflation_factor = clamp_blur_radius(max, scale_factors) * BLUR_SAMPLE_SCALE;
-                        }
-                        PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
-                            // TODO(gw): This is incorrect, since we don't consider the drop shadow
-                            //           offset. However, fixing that is a larger task, so this is
-                            //           an improvement on the current case (this at least works where
-                            //           the offset of the drop-shadow is ~0, which is often true).
-
-                            // Can't use max_by_key here since f32 isn't Ord
-                            let mut max_blur_radius: f32 = 0.0;
-                            for shadow in shadows {
-                                max_blur_radius = max_blur_radius.max(shadow.blur_radius);
-                            }
-
-                            inflation_factor = clamp_blur_radius(max_blur_radius, scale_factors) * BLUR_SAMPLE_SCALE;
-                        }
-                        _ => {}
-                    }
-                }
+                let raster_spatial_node_index = surface_spatial_node_index;
 
                 let surface = SurfaceInfo::new(
                     surface_spatial_node_index,
                     raster_spatial_node_index,
-                    inflation_factor,
                     frame_context.global_screen_world_rect,
                     &frame_context.spatial_tree,
                     device_pixel_scale,
@@ -5823,20 +5572,15 @@
 
                 self.raster_config = Some(RasterConfig {
                     composite_mode: composite_mode.clone(),
-                    establishes_raster_root,
                     surface_index,
-                    root_scaling_factor: 1.0,
-                    clipped_bounding_rect: WorldRect::zero(),
                 });
 
-                surface_index
+                Some(surface_index)
             }
             None => {
-                current_surface_index.expect("bug: pass-through picture without parent surface")
+                None
             }
-        };
-
-        surface_index
+        }
     }
 
     /// Called after updating child pictures during the initial
@@ -5949,7 +5693,7 @@
             // backface checks.
             cluster.flags.insert(ClusterFlags::IS_VISIBLE);
             if let Some(cluster_rect) = surface.map_local_to_surface.map(&cluster.bounding_rect) {
-                surface.rect = surface.rect.union(&cluster_rect);
+                surface.local_rect = surface.local_rect.union(&cluster_rect);
             }
         }
 
@@ -5957,42 +5701,24 @@
         // rect into the parent surface coordinate space, and propagate that up
         // to the parent.
         if let Some(ref mut raster_config) = self.raster_config {
-            // Inflate the local bounding rect if required by the filter effect.
-            if self.options.inflate_if_required {
-                surface.rect = raster_config.composite_mode.inflate_picture_rect(surface.rect, surface.scale_factors);
-            }
-
-            let mut surface_rect = surface.rect * Scale::new(1.0);
-
-            // Set the estimated and precise local rects. The precise local rect
-            // may be changed again during frame visibility.
-            self.estimated_local_rect = surface_rect;
-            self.precise_local_rect = surface_rect;
-
-            // Drop shadows draw both a content and shadow rect, so need to expand the local
-            // rect of any surfaces to be composited in parent surfaces correctly.
-            match raster_config.composite_mode {
-                PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
-                    for shadow in shadows {
-                        let shadow_rect = self.estimated_local_rect.translate(shadow.offset);
-                        surface_rect = surface_rect.union(&shadow_rect);
-                    }
-                }
-                _ => {}
-            }
-
             // Propagate up to parent surface, now that we know this surface's static rect
             if let Some(parent_surface_index) = parent_surface_index {
+                let surface_rect = raster_config.composite_mode.get_coverage(surface, None);
+
                 let parent_surface = &mut surfaces[parent_surface_index.0];
                 parent_surface.map_local_to_surface.set_target_spatial_node(
                     self.spatial_node_index,
                     frame_context.spatial_tree,
                 );
+
+                // Drop shadows draw both a content and shadow rect, so need to expand the local
+                // rect of any surfaces to be composited in parent surfaces correctly.
+
                 if let Some(parent_surface_rect) = parent_surface
                     .map_local_to_surface
                     .map(&surface_rect)
                 {
-                    parent_surface.rect = parent_surface.rect.union(&parent_surface_rect);
+                    parent_surface.local_rect = parent_surface.local_rect.union(&parent_surface_rect);
                 }
             }
         }
@@ -6030,22 +5756,33 @@
 
         match raster_config.composite_mode {
             PictureCompositeMode::TileCache { .. } => {}
-            PictureCompositeMode::Filter(Filter::Blur(..)) => {}
+            PictureCompositeMode::Filter(Filter::Blur { .. }) => {}
             PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
                 self.extra_gpu_data_handles.resize(shadows.len(), GpuCacheHandle::new());
                 for (shadow, extra_handle) in shadows.iter().zip(self.extra_gpu_data_handles.iter_mut()) {
                     if let Some(mut request) = frame_state.gpu_cache.request(extra_handle) {
+                        let surface = &frame_state.surfaces[raster_config.surface_index.0];
+                        let prim_rect = surface.local_rect.cast_unit();
+
                         // Basic brush primitive header is (see end of prepare_prim_for_render_inner in prim_store.rs)
                         //  [brush specific data]
                         //  [segment_rect, segment data]
-                        let shadow_rect = self.precise_local_rect.translate(shadow.offset);
+                        let blur_inflation = clamp_blur_radius(
+                            shadow.blur_radius,
+                            surface.parent_scale_factors,
+                        ) * BLUR_SAMPLE_SCALE;
+
+                        let shadow_rect = prim_rect.inflate(
+                            blur_inflation,
+                            blur_inflation
+                        ).translate(shadow.offset);
 
                         // ImageBrush colors
                         request.push(shadow.color.premultiplied());
                         request.push(PremultipliedColorF::WHITE);
                         request.push([
-                            self.precise_local_rect.width(),
-                            self.precise_local_rect.height(),
+                            shadow_rect.width(),
+                            shadow_rect.height(),
                             0.0,
                             0.0,
                         ]);
@@ -6092,67 +5829,6 @@
     }
 }
 
-// Calculate a single homogeneous screen-space UV for a picture.
-fn calculate_screen_uv(
-    local_pos: &PicturePoint,
-    transform: &PictureToRasterTransform,
-    rendered_rect: &DeviceRect,
-    device_pixel_scale: DevicePixelScale,
-) -> DeviceHomogeneousVector {
-    let raster_pos = transform.transform_point2d_homogeneous(*local_pos);
-
-    DeviceHomogeneousVector::new(
-        (raster_pos.x * device_pixel_scale.0 - rendered_rect.min.x * raster_pos.w) / rendered_rect.width(),
-        (raster_pos.y * device_pixel_scale.0 - rendered_rect.min.y * raster_pos.w) / rendered_rect.height(),
-        0.0,
-        raster_pos.w,
-    )
-}
-
-// Calculate a UV rect within an image based on the screen space
-// vertex positions of a picture.
-fn calculate_uv_rect_kind(
-    pic_rect: &PictureRect,
-    transform: &PictureToRasterTransform,
-    rendered_rect: &DeviceRect,
-    device_pixel_scale: DevicePixelScale,
-) -> UvRectKind {
-    let top_left = calculate_screen_uv(
-        &pic_rect.top_left(),
-        transform,
-        &rendered_rect,
-        device_pixel_scale,
-    );
-
-    let top_right = calculate_screen_uv(
-        &pic_rect.top_right(),
-        transform,
-        &rendered_rect,
-        device_pixel_scale,
-    );
-
-    let bottom_left = calculate_screen_uv(
-        &pic_rect.bottom_left(),
-        transform,
-        &rendered_rect,
-        device_pixel_scale,
-    );
-
-    let bottom_right = calculate_screen_uv(
-        &pic_rect.bottom_right(),
-        transform,
-        &rendered_rect,
-        device_pixel_scale,
-    );
-
-    UvRectKind::Quad {
-        top_left,
-        top_right,
-        bottom_left,
-        bottom_right,
-    }
-}
-
 fn create_raster_mappers(
     surface_spatial_node_index: SpatialNodeIndex,
     raster_spatial_node_index: SpatialNodeIndex,
@@ -6858,43 +6534,6 @@
     }
 }
 
-pub fn get_raster_rects(
-    pic_rect: PictureRect,
-    map_to_raster: &SpaceMapper<PicturePixel, RasterPixel>,
-    map_to_world: &SpaceMapper<RasterPixel, WorldPixel>,
-    prim_bounding_rect: WorldRect,
-    device_pixel_scale: DevicePixelScale,
-) -> Option<(DeviceRect, DeviceRect)> {
-    let unclipped_raster_rect = map_to_raster.map(&pic_rect)?;
-
-    let unclipped = raster_rect_to_device_pixels(
-        unclipped_raster_rect,
-        device_pixel_scale,
-    );
-
-    let unclipped_world_rect = map_to_world.map(&unclipped_raster_rect)?;
-    let clipped_world_rect = unclipped_world_rect.intersection(&prim_bounding_rect)?;
-
-    // We don't have to be able to do the back-projection from world into raster.
-    // Rendering only cares one way, so if that fails, we fall back to the full rect.
-    let clipped_raster_rect = match map_to_world.unmap(&clipped_world_rect) {
-        Some(rect) => rect.intersection(&unclipped_raster_rect)?,
-        None => return Some((unclipped, unclipped)),
-    };
-
-    let clipped = raster_rect_to_device_pixels(
-        clipped_raster_rect,
-        device_pixel_scale,
-    );
-
-    // Ensure that we won't try to allocate a zero-sized clip render task.
-    if clipped.is_empty() {
-        return None;
-    }
-
-    Some((clipped, unclipped))
-}
-
 fn get_relative_scale_offset(
     child_spatial_node_index: SpatialNodeIndex,
     parent_spatial_node_index: SpatialNodeIndex,
@@ -6919,3 +6558,170 @@
 
     scale_offset
 }
+
+fn calculate_screen_uv(
+    p: DevicePoint,
+    clipped: DeviceRect,
+) -> DeviceHomogeneousVector {
+    // TODO(gw): Switch to a simple mix, no bilerp / homogeneous vec needed anymore
+    DeviceHomogeneousVector::new(
+        (p.x - clipped.min.x) / (clipped.max.x - clipped.min.x),
+        (p.y - clipped.min.y) / (clipped.max.y - clipped.min.y),
+        0.0,
+        1.0,
+    )
+}
+
+fn get_surface_rects(
+    surface_index: SurfaceIndex,
+    composite_mode: &PictureCompositeMode,
+    parent_surface_index: SurfaceIndex,
+    surfaces: &mut [SurfaceInfo],
+    spatial_tree: &SpatialTree,
+) -> Option<SurfaceAllocInfo> {
+    let parent_surface = &surfaces[parent_surface_index.0];
+
+    let local_to_parent = SpaceMapper::new_with_target(
+        parent_surface.raster_spatial_node_index,
+        surfaces[surface_index.0].raster_spatial_node_index,
+        parent_surface.clipping_rect,
+        spatial_tree,
+    );
+
+    let local_clip_rect = local_to_parent
+        .unmap(&parent_surface.clipping_rect)
+        .unwrap_or(PictureRect::max_rect())
+        .cast_unit();
+
+    let surface = &mut surfaces[surface_index.0];
+
+    let (clipped_local, unclipped_local) = match composite_mode {
+        PictureCompositeMode::Filter(Filter::DropShadows(ref shadows)) => {
+            let local_prim_rect = surface.local_rect;
+
+            let mut required_local_rect = match local_prim_rect.intersection(&local_clip_rect) {
+                Some(rect) => rect,
+                None => return None,
+            };
+
+            for shadow in shadows {
+                let blur_radius = clamp_blur_radius(
+                    shadow.blur_radius,
+                    surface.parent_scale_factors
+                ).ceil();
+                let blur_inflation = blur_radius * BLUR_SAMPLE_SCALE;
+
+                let local_shadow_rect = local_prim_rect
+                    .translate(shadow.offset.cast_unit());
+
+                if let Some(clipped_shadow_rect) = local_clip_rect.intersection(&local_shadow_rect) {
+                    let required_shadow_rect = clipped_shadow_rect.inflate(blur_inflation, blur_inflation);
+
+                    let local_clipped_shadow_rect = required_shadow_rect.translate(-shadow.offset.cast_unit());
+
+                    required_local_rect = required_local_rect.union(&local_clipped_shadow_rect);
+                }
+            }
+
+            let unclipped = composite_mode.get_rect(surface, None);
+            let clipped = required_local_rect;
+
+            let clipped = match clipped.intersection(&unclipped.cast_unit()) {
+                Some(rect) => rect,
+                None => return None,
+            };
+
+            (clipped, unclipped)
+        }
+        _ => {
+            let surface_origin = surface.local_rect.min.to_vector().cast_unit();
+
+            let normalized_prim_rect = composite_mode
+                .get_rect(surface, None)
+                .translate(-surface_origin);
+
+            let normalized_clip_rect = local_clip_rect
+                .cast_unit()
+                .translate(-surface_origin);
+
+            let norm_clipped_rect = match normalized_prim_rect.intersection(&normalized_clip_rect) {
+                Some(rect) => rect,
+                None => return None,
+            };
+
+            let norm_clipped_rect = composite_mode.get_rect(surface, Some(norm_clipped_rect));
+
+            let norm_clipped_rect = match norm_clipped_rect.intersection(&normalized_prim_rect) {
+                Some(rect) => rect,
+                None => return None,
+            };
+
+            let unclipped = normalized_prim_rect.translate(surface_origin);
+            let clipped = norm_clipped_rect.translate(surface_origin);
+
+            (clipped.cast_unit(), unclipped.cast_unit())
+        }
+    };
+
+    let mut clipped = (clipped_local.cast_unit() * surface.device_pixel_scale).round_out();
+    let task_size_f = clipped.size();
+
+    if task_size_f.width > MAX_SURFACE_SIZE || task_size_f.height > MAX_SURFACE_SIZE {
+        let max_dimension = task_size_f.width.max(task_size_f.height);
+
+        surface.device_pixel_scale = Scale::new(MAX_SURFACE_SIZE / max_dimension);
+
+        clipped = (clipped_local.cast_unit() * surface.device_pixel_scale).round();
+    }
+
+    let unclipped = unclipped_local.cast_unit() * surface.device_pixel_scale;
+    let task_size = clipped.size().to_i32();
+
+    debug_assert!(task_size.width <= MAX_SURFACE_SIZE as i32);
+    debug_assert!(task_size.height <= MAX_SURFACE_SIZE as i32);
+
+    let uv_rect_kind = calculate_uv_rect_kind(
+        clipped,
+        unclipped,
+    );
+
+    Some(SurfaceAllocInfo {
+        task_size,
+        unclipped,
+        clipped,
+        clipped_local,
+        uv_rect_kind,
+    })
+}
+
+fn calculate_uv_rect_kind(
+    clipped: DeviceRect,
+    unclipped: DeviceRect,
+) -> UvRectKind {
+    let top_left = calculate_screen_uv(
+        unclipped.top_left().cast_unit(),
+        clipped,
+    );
+
+    let top_right = calculate_screen_uv(
+        unclipped.top_right().cast_unit(),
+        clipped,
+    );
+
+    let bottom_left = calculate_screen_uv(
+        unclipped.bottom_left().cast_unit(),
+        clipped,
+    );
+
+    let bottom_right = calculate_screen_uv(
+        unclipped.bottom_right().cast_unit(),
+        clipped,
+    );
+
+    UvRectKind::Quad {
+        top_left,
+        top_right,
+        bottom_left,
+        bottom_right,
+    }
+}