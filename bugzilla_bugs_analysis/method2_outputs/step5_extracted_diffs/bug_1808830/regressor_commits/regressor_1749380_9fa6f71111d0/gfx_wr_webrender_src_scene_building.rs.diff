# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/scene_building.rs
# Commit: 9fa6f71111d0
# Full Hash: 9fa6f71111d0d77477abc4502b721d8d4ba23604
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-02-20 21:58:21
# Regressor Bug: 1749380
# File Overlap Count: 1
# Description:
#   Bug 1749380 - Part 1 - Improve how WR handles bounding rects for off-screen surfaces r=gfx-reviewers
#   
#   This patch introduces a number of subtle but important changes
#   to how we deal with off-screen surfaces. The overall goals are:
#   
# ==============================================================================

diff -r 336a2aa0a29e -r 9fa6f71111d0 gfx/wr/webrender/src/scene_building.rs
--- a/gfx/wr/webrender/src/scene_building.rs	Sat Feb 19 23:27:02 2022 +0000
+++ b/gfx/wr/webrender/src/scene_building.rs	Sun Feb 20 18:56:54 2022 +0000
@@ -56,7 +56,7 @@
 use crate::hit_test::HitTestingScene;
 use crate::intern::Interner;
 use crate::internal_types::{FastHashMap, LayoutPrimitiveInfo, Filter, PlaneSplitter, PlaneSplitterIndex, PipelineInstanceId};
-use crate::picture::{Picture3DContext, PictureCompositeMode, PicturePrimitive, PictureOptions};
+use crate::picture::{Picture3DContext, PictureCompositeMode, PicturePrimitive};
 use crate::picture::{BlitReason, OrderedPictureChild, PrimitiveList, SurfaceInfo};
 use crate::picture_graph::PictureGraph;
 use crate::prim_store::{PrimitiveInstance, register_prim_chase_id};
@@ -268,7 +268,6 @@
         self,
         composite_mode: PictureCompositeMode,
         context_3d: Picture3DContext<OrderedPictureChild>,
-        options: PictureOptions,
         interners: &mut Interners,
         prim_store: &mut PrimitiveStore,
         prim_instances: &mut Vec<PrimitiveInstance>,
@@ -301,7 +300,6 @@
                 self.flags,
                 prim_list,
                 self.spatial_node_index,
-                options,
             ))
         );
 
@@ -346,7 +344,6 @@
                         self.flags,
                         prim_list,
                         self.spatial_node_index,
-                        PictureOptions::default(),
                     ))
                 );
 
@@ -2162,7 +2159,6 @@
                         stacking_context.prim_flags,
                         stacking_context.prim_list,
                         stacking_context.spatial_node_index,
-                        PictureOptions::default(),
                     ))
                 );
 
@@ -2201,7 +2197,6 @@
                             stacking_context.prim_flags,
                             stacking_context.prim_list,
                             stacking_context.spatial_node_index,
-                            PictureOptions::default(),
                         ))
                     );
 
@@ -2300,7 +2295,6 @@
                     stacking_context.prim_flags,
                     prim_list,
                     stacking_context.spatial_node_index,
-                    PictureOptions::default(),
                 ))
             );
 
@@ -2325,7 +2319,6 @@
             stacking_context.composite_ops.filters,
             stacking_context.composite_ops.filter_primitives,
             stacking_context.composite_ops.filter_datas,
-            true,
         );
 
         // Same for mix-blend-mode, except we can skip if this primitive is the first in the parent
@@ -2351,7 +2344,6 @@
                 source = source.add_picture(
                     composite_mode,
                     Picture3DContext::Out,
-                    PictureOptions::default(),
                     &mut self.interners,
                     &mut self.prim_store,
                     &mut self.prim_instances,
@@ -2708,7 +2700,11 @@
                     // Add any primitives that come after this shadow in the item
                     // list to this shadow.
                     let mut prim_list = PrimitiveList::empty();
-                    let blur_filter = Filter::Blur(std_deviation, std_deviation);
+                    let blur_filter = Filter::Blur {
+                        width: std_deviation,
+                        height: std_deviation,
+                        should_inflate: pending_shadow.should_inflate,
+                    };
                     let blur_is_noop = blur_filter.is_noop();
 
                     for item in &items {
@@ -2778,17 +2774,10 @@
                         // blur radius is 0, the code in Picture::prepare_for_render will
                         // detect this and mark the picture to be drawn directly into the
                         // parent picture, which avoids an intermediate surface and blur.
-                        let blur_filter = Filter::Blur(std_deviation, std_deviation);
                         assert!(!blur_filter.is_noop());
                         let composite_mode = Some(PictureCompositeMode::Filter(blur_filter));
                         let composite_mode_key = composite_mode.clone().into();
 
-                        // Pass through configuration information about whether WR should
-                        // do the bounding rect inflation for text shadows.
-                        let options = PictureOptions {
-                            inflate_if_required: pending_shadow.should_inflate,
-                        };
-
                         // Create the primitive to draw the shadow picture into the scene.
                         let shadow_pic_index = PictureIndex(self.prim_store.pictures
                             .alloc()
@@ -2799,7 +2788,6 @@
                                 PrimitiveFlags::IS_BACKFACE_VISIBLE,
                                 prim_list,
                                 pending_shadow.spatial_node_index,
-                                options,
                             ))
                         );
 
@@ -3495,9 +3483,6 @@
                     prim_flags,
                     prim_list,
                     backdrop_spatial_node_index,
-                    PictureOptions {
-                       inflate_if_required: false,
-                    },
                 ))
             );
 
@@ -3520,7 +3505,6 @@
             filters,
             filter_primitives,
             filter_datas,
-            false,
         );
 
         // Apply filters from all stacking contexts up to, but not including the backdrop root.
@@ -3539,7 +3523,6 @@
                 filters,
                 filter_primitives,
                 filter_datas,
-                false,
             );
         }
 
@@ -3620,7 +3603,6 @@
         mut filter_ops: Vec<Filter>,
         mut filter_primitives: Vec<FilterPrimitive>,
         filter_datas: Vec<FilterData>,
-        inflate_if_required: bool,
     ) -> PictureChainBuilder {
         // TODO(cbrewster): Currently CSS and SVG filters live side by side in WebRender, but unexpected results will
         // happen if they are used simulataneously. Gecko only provides either filter ops or filter primitives.
@@ -3672,7 +3654,6 @@
             source = source.add_picture(
                 composite_mode,
                 Picture3DContext::Out,
-                PictureOptions { inflate_if_required },
                 &mut self.interners,
                 &mut self.prim_store,
                 &mut self.prim_instances,
@@ -3709,7 +3690,6 @@
             source = source.add_picture(
                 composite_mode,
                 Picture3DContext::Out,
-                PictureOptions { inflate_if_required },
                 &mut self.interners,
                 &mut self.prim_store,
                 &mut self.prim_instances,
@@ -3872,7 +3852,6 @@
                 self.prim_flags,
                 mem::replace(&mut self.prim_list, PrimitiveList::empty()),
                 self.spatial_node_index,
-                PictureOptions::default(),
             ))
         );
 