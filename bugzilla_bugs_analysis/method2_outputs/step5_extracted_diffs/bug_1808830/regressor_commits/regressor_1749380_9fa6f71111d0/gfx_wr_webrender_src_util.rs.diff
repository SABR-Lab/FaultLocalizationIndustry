# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/util.rs
# Commit: 9fa6f71111d0
# Full Hash: 9fa6f71111d0d77477abc4502b721d8d4ba23604
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2022-02-20 21:58:21
# Regressor Bug: 1749380
# File Overlap Count: 1
# Description:
#   Bug 1749380 - Part 1 - Improve how WR handles bounding rects for off-screen surfaces r=gfx-reviewers
#   
#   This patch introduces a number of subtle but important changes
#   to how we deal with off-screen surfaces. The overall goals are:
#   
# ==============================================================================

diff -r 336a2aa0a29e -r 9fa6f71111d0 gfx/wr/webrender/src/util.rs
--- a/gfx/wr/webrender/src/util.rs	Sat Feb 19 23:27:02 2022 +0000
+++ b/gfx/wr/webrender/src/util.rs	Sun Feb 20 18:56:54 2022 +0000
@@ -4,7 +4,7 @@
 
 use api::BorderRadius;
 use api::units::*;
-use euclid::{Point2D, Rect, Box2D, Size2D, Vector2D, point2};
+use euclid::{Point2D, Rect, Box2D, Size2D, Vector2D};
 use euclid::{default, Transform2D, Transform3D, Scale};
 use malloc_size_of::{MallocShallowSizeOf, MallocSizeOf, MallocSizeOfOps};
 use plane_split::{Clipper, Polygon};
@@ -1551,142 +1551,6 @@
     }
 }
 
-// Find a rectangle that is contained by the sum of r1 and r2.
-pub fn conservative_union_rect<U>(r1: &Box2D<f32, U>, r2: &Box2D<f32, U>) -> Box2D<f32, U> {
-    //  +---+---+   +--+-+--+
-    //  |   |   |   |  | |  |
-    //  |   |   |   |  | |  |
-    //  +---+---+   +--+-+--+
-    if r1.min.y == r2.min.y && r1.max.y == r2.max.y {
-        if r2.min.x <= r1.max.x && r2.max.x >= r1.min.x {
-            let min_x = f32::min(r1.min.x, r2.min.x);
-            let max_x = f32::max(r1.max.x, r2.max.x);
-
-            return Box2D {
-                min: point2(min_x, r1.min.y),
-                max: point2(max_x, r1.max.y),
-            }
-        }
-    }
-
-    //  +----+    +----+
-    //  |    |    |    |
-    //  |    |    +----+
-    //  +----+    |    |
-    //  |    |    +----+
-    //  |    |    |    |
-    //  +----+    +----+
-    if r1.min.x == r2.min.x && r1.max.x == r2.max.x {
-        if r2.min.y <= r1.max.y && r2.max.y >= r1.min.y {
-            let min_y = f32::min(r1.min.y, r2.min.y);
-            let max_y = f32::max(r1.max.y, r2.max.y);
-
-            return Box2D {
-                min: point2(r1.min.x, min_y),
-                max: point2(r1.max.x, max_y),
-            }
-        }
-    }
-
-    if r1.area() >= r2.area() { *r1 } else {*r2 }
-}
-
-#[test]
-fn test_conservative_union_rect() {
-    // Adjacent, x axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(4.0, 2.0), max: point2(9.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(9.0, 6.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(4.0, 2.0), max: point2(9.0, 6.0) },
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(9.0, 6.0) });
-
-    // Averlapping adjacent, x axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(3.0, 2.0), max: point2(8.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(8.0, 6.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(5.0, 2.0), max: point2(8.0, 6.0) },
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(6.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(8.0, 6.0) });
-
-    // Adjacent but not touching, x axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(6.0, 2.0), max: point2(11.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(6.0, 2.0), max: point2(11.0, 6.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(-6.0, 2.0), max: point2(-5.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) });
-
-
-    // Adjacent, y axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(1.0, 6.0), max: point2(4.0, 10.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 10.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 5.0), max: point2(4.0, 9.0) },
-        &LayoutRect { min: point2(1.0, 1.0), max: point2(4.0, 5.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 1.0), max: point2(4.0, 9.0) });
-
-    // Averlapping adjacent, y axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(1.0, 3.0), max: point2(4.0, 7.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 7.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 4.0), max: point2(4.0, 8.0) },
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 8.0) });
-
-    // Adjacent but not touching, y axis
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(1.0, 10.0), max: point2(4.0, 15.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 10.0), max: point2(4.0, 15.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 5.0), max: point2(4.0, 9.0) },
-        &LayoutRect { min: point2(1.0, 0.0), max: point2(4.0, 3.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(1.0, 5.0), max: point2(4.0, 9.0) });
-
-
-    // Contained
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-        &LayoutRect { min: point2(0.0, 1.0), max: point2(10.0, 12.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(0.0, 1.0), max: point2(10.0, 12.0) });
-
-    let r = conservative_union_rect(
-        &LayoutRect { min: point2(0.0, 1.0), max: point2(10.0, 12.0) },
-        &LayoutRect { min: point2(1.0, 2.0), max: point2(4.0, 6.0) },
-    );
-    assert_eq!(r, LayoutRect { min: point2(0.0, 1.0), max: point2(10.0, 12.0) });
-}
-
 /// This is inspired by the `weak-table` crate.
 /// It holds a Vec of weak pointers that are garbage collected as the Vec
 pub struct WeakTable {