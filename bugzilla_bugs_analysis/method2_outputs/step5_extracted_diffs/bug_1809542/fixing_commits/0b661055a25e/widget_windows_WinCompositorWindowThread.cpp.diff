# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: widget/windows/WinCompositorWindowThread.cpp
# Commit: 0b661055a25e
# Full Hash: 0b661055a25ef73ff81c812b2fe671935aebd5f7
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2023-01-21 09:30:30
# Description:
#   Bug 1809542: Remove stack-allocated param to runnable. r=rkraesig
#   
#   This directly incorporates the synchronization primitives of the
#   SynchronousTask into the WinCompositorWindowThread object. This removes
#   the paramater to ShutdownTask and allows the wait to timeout correctly.
# ==============================================================================

diff -r d9154943e83f -r 0b661055a25e widget/windows/WinCompositorWindowThread.cpp
--- a/widget/windows/WinCompositorWindowThread.cpp	Fri Jan 20 19:21:40 2023 +0000
+++ b/widget/windows/WinCompositorWindowThread.cpp	Fri Jan 20 19:30:54 2023 +0000
@@ -58,9 +58,7 @@
 }
 
 WinCompositorWindowThread::WinCompositorWindowThread(base::Thread* aThread)
-    : mThread(aThread) {}
-
-WinCompositorWindowThread::~WinCompositorWindowThread() { delete mThread; }
+    : mThread(aThread), mMonitor("WinCompositorWindowThread") {}
 
 /* static */
 WinCompositorWindowThread* WinCompositorWindowThread::Get() {
@@ -70,14 +68,25 @@
 /* static */
 void WinCompositorWindowThread::Start() {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(!sWinCompositorWindowThread);
-
-  base::Thread* thread = new base::Thread("WinCompositor");
 
   base::Thread::Options options;
   // HWND requests ui thread.
   options.message_loop_type = MessageLoop::TYPE_UI;
 
+  if (sWinCompositorWindowThread) {
+    // Try to reuse the thread, which involves stopping and restarting it.
+    sWinCompositorWindowThread->mThread->Stop();
+    if (sWinCompositorWindowThread->mThread->StartWithOptions(options)) {
+      // Success!
+      return;
+    }
+    // Restart failed, so null out our sWinCompositorWindowThread and
+    // try again with a new thread. This will cause the old singleton
+    // instance to be deallocated, which will destroy its mThread as well.
+    sWinCompositorWindowThread = nullptr;
+  }
+
+  base::Thread* thread = new base::Thread("WinCompositor");
   if (!thread->StartWithOptions(options)) {
     delete thread;
     return;
@@ -91,28 +100,37 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(sWinCompositorWindowThread);
 
-  // Our shutdown task could hang. Since we're shutting down,
-  // that's not a critical problem. We set a reasonable amount
-  // of time to wait for shutdown, and if it succeeds within
-  // that time, we correctly stop our thread. If it times out,
-  // we just leak the memory and proceed.
-  static const PRIntervalTime TIMEOUT = PR_TicksPerSecond() * 2;
-  layers::SynchronousTask task("WinCompositorWindowThread");
-  RefPtr<Runnable> runnable = WrapRunnable(
-      RefPtr<WinCompositorWindowThread>(sWinCompositorWindowThread.get()),
-      &WinCompositorWindowThread::ShutDownTask, &task);
-  sWinCompositorWindowThread->Loop()->PostTask(runnable.forget());
-  nsresult rv = task.Wait(TIMEOUT);
-  if (rv == NS_OK) {
-    sWinCompositorWindowThread->mThread->Stop();
+  // Our thread could hang while we're waiting for it to stop.
+  // Since we're shutting down, that's not a critical problem.
+  // We set a reasonable amount of time to wait for shutdown,
+  // and if it succeeds within that time, we correctly stop
+  // our thread by nulling out the refptr, which will cause it
+  // to be deallocated and join the thread. If it times out,
+  // we do nothing, which means that the thread will not be
+  // joined and sWinCompositorWindowThread memory will leak.
+  static const TimeDuration TIMEOUT = TimeDuration::FromSeconds(2.0);
+  RefPtr<Runnable> runnable =
+      NewRunnableMethod("WinCompositorWindowThread::ShutDownTask",
+                        sWinCompositorWindowThread.get(),
+                        &WinCompositorWindowThread::ShutDownTask);
+  Loop()->PostTask(runnable.forget());
+
+  CVStatus status;
+  {
+    MonitorAutoLock lock(sWinCompositorWindowThread->mMonitor);
+    status = sWinCompositorWindowThread->mMonitor.Wait(TIMEOUT);
   }
 
-  sWinCompositorWindowThread = nullptr;
+  if (status == CVStatus::NoTimeout) {
+    sWinCompositorWindowThread = nullptr;
+  }
 }
 
-void WinCompositorWindowThread::ShutDownTask(layers::SynchronousTask* aTask) {
-  layers::AutoCompleteTask complete(aTask);
+void WinCompositorWindowThread::ShutDownTask() {
+  MonitorAutoLock lock(mMonitor);
+
   MOZ_ASSERT(IsInCompositorWindowThread());
+  mMonitor.NotifyAll();
 }
 
 /* static */