# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/WinCompositorWindowThread.cpp
# Commit: 9a1762f9ff3f
# Full Hash: 9a1762f9ff3f588dba50310cf30169e334bdd826
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2022-11-09 09:58:36
# Regressor Bug: 1798652
# File Overlap Count: 1
# Description:
#   Bug 1798652: Make WinCompositorWindowThread::ShutDown timeout after 2 seconds. r=sotaro
#   
#   This change also ensures that our thread is stopped, as long as shutdown
#   was successful.
#   
# ==============================================================================

diff -r b5ae3cd32554 -r 9a1762f9ff3f widget/windows/WinCompositorWindowThread.cpp
--- a/widget/windows/WinCompositorWindowThread.cpp	Wed Nov 09 04:21:47 2022 +0200
+++ b/widget/windows/WinCompositorWindowThread.cpp	Wed Nov 09 01:14:42 2022 +0000
@@ -55,12 +55,21 @@
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(sWinCompositorWindowThread);
 
+  // Our shutdown task could hang. Since we're shutting down,
+  // that's not a critical problem. We set a reasonable amount
+  // of time to wait for shutdown, and if it succeeds within
+  // that time, we correctly stop our thread. If it times out,
+  // we just leak the memory and proceed.
+  static const PRIntervalTime TIMEOUT = PR_TicksPerSecond() * 2;
   layers::SynchronousTask task("WinCompositorWindowThread");
   RefPtr<Runnable> runnable = WrapRunnable(
       RefPtr<WinCompositorWindowThread>(sWinCompositorWindowThread.get()),
       &WinCompositorWindowThread::ShutDownTask, &task);
   sWinCompositorWindowThread->Loop()->PostTask(runnable.forget());
-  task.Wait();
+  nsresult rv = task.Wait(TIMEOUT);
+  if (rv == NS_OK) {
+    sWinCompositorWindowThread->mThread->Stop();
+  }
 
   sWinCompositorWindowThread = nullptr;
 }
