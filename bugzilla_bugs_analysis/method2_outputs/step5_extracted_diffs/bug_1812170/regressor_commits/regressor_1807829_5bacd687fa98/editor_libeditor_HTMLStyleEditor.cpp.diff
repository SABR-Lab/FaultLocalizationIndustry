# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLStyleEditor.cpp
# Commit: 5bacd687fa98
# Full Hash: 5bacd687fa98b0e9a5dea9944f360fdc5a6770e6
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-01-17 16:13:02
# Regressor Bug: 1807829
# File Overlap Count: 2
# Description:
#   Bug 1807829 - Make `HTMLEditor::CreateStyleForInsertText` use same logic as `HTMLEditor::SetInlinePropertiesAsSubAction` to apply new style r=m_kato
#   
#   The problem in Yahoo mail is, when you apply new font size to:
#   ```
#   <div><font size="7">{}<br></font></div>
# ==============================================================================

diff -r a7465d2d89ba -r 5bacd687fa98 editor/libeditor/HTMLStyleEditor.cpp
--- a/editor/libeditor/HTMLStyleEditor.cpp	Mon Jan 16 23:14:12 2023 +0000
+++ b/editor/libeditor/HTMLStyleEditor.cpp	Tue Jan 17 05:26:14 2023 +0000
@@ -15,8 +15,8 @@
 #include "HTMLEditUtils.h"
 #include "PendingStyles.h"
 #include "SelectionState.h"
-
-#include "ErrorList.h"
+#include "WSRunObject.h"
+
 #include "mozilla/Assertions.h"
 #include "mozilla/ContentIterator.h"
 #include "mozilla/EditorForwards.h"
@@ -28,29 +28,29 @@
 #include "mozilla/dom/HTMLBRElement.h"
 #include "mozilla/dom/Selection.h"
 #include "mozilla/dom/Text.h"
+
 #include "nsAString.h"
+#include "nsAtom.h"
 #include "nsAttrName.h"
-#include "nsCOMPtr.h"
 #include "nsCaseTreatment.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
 #include "nsError.h"
 #include "nsGkAtoms.h"
-#include "nsAtom.h"
 #include "nsIContent.h"
-#include "nsNameSpaceManager.h"
 #include "nsINode.h"
 #include "nsIPrincipal.h"
 #include "nsISupportsImpl.h"
 #include "nsLiteralString.h"
+#include "nsNameSpaceManager.h"
 #include "nsRange.h"
 #include "nsReadableUtils.h"
 #include "nsString.h"
 #include "nsStringFwd.h"
 #include "nsStyledElement.h"
 #include "nsTArray.h"
+#include "nsTextNode.h"
 #include "nsUnicharUtils.h"
-#include "nscore.h"
 
 namespace mozilla {
 
@@ -66,6 +66,15 @@
 template nsresult HTMLEditor::SetInlinePropertiesAsSubAction(
     const AutoTArray<EditorInlineStyleAndValue, 32>& aStylesToSet);
 
+template nsresult HTMLEditor::SetInlinePropertiesAroundRanges(
+    AutoRangeArray& aRanges,
+    const AutoTArray<EditorInlineStyleAndValue, 1>& aStylesToSet,
+    const Element& aEditingHost);
+template nsresult HTMLEditor::SetInlinePropertiesAroundRanges(
+    AutoRangeArray& aRanges,
+    const AutoTArray<EditorInlineStyleAndValue, 32>& aStylesToSet,
+    const Element& aEditingHost);
+
 nsresult HTMLEditor::SetInlinePropertyAsAction(nsStaticAtom& aProperty,
                                                nsStaticAtom* aAttribute,
                                                const nsAString& aValue,
@@ -229,6 +238,12 @@
     }
   }
 
+  RefPtr<Element> const editingHost =
+      ComputeEditingHost(LimitInBodyElement::No);
+  if (NS_WARN_IF(!editingHost)) {
+    return NS_ERROR_FAILURE;
+  }
+
   AutoPlaceholderBatch treatAsOneTransaction(
       *this, ScrollSelectionIntoView::Yes, __FUNCTION__);
   IgnoredErrorResult ignoredError;
@@ -247,23 +262,44 @@
   AutoTransactionsConserveSelection dontChangeMySelection(*this);
 
   AutoRangeArray selectionRanges(SelectionRef());
+  nsresult rv = SetInlinePropertiesAroundRanges(selectionRanges, aStylesToSet,
+                                                *editingHost);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("HTMLEditor::SetInlinePropertiesAroundRanges() failed");
+    return rv;
+  }
+  MOZ_ASSERT(!selectionRanges.HasSavedRanges());
+  rv = selectionRanges.ApplyTo(SelectionRef());
+  if (NS_WARN_IF(Destroyed())) {
+    return NS_ERROR_EDITOR_DESTROYED;
+  }
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::ApplyTo() failed");
+  return rv;
+}
+
+template <size_t N>
+nsresult HTMLEditor::SetInlinePropertiesAroundRanges(
+    AutoRangeArray& aRanges,
+    const AutoTArray<EditorInlineStyleAndValue, N>& aStylesToSet,
+    const Element& aEditingHost) {
   for (const EditorInlineStyleAndValue& styleToSet : aStylesToSet) {
     if (!StaticPrefs::
-            editor_inline_style_range_compatible_with_the_other_browsers()) {
-      MOZ_ALWAYS_TRUE(selectionRanges.SaveAndTrackRanges(*this));
+            editor_inline_style_range_compatible_with_the_other_browsers() &&
+        !aRanges.IsCollapsed()) {
+      MOZ_ALWAYS_TRUE(aRanges.SaveAndTrackRanges(*this));
     }
     AutoInlineStyleSetter inlineStyleSetter(styleToSet);
-    for (OwningNonNull<nsRange>& selectionRange : selectionRanges.Ranges()) {
+    for (OwningNonNull<nsRange>& domRange : aRanges.Ranges()) {
       inlineStyleSetter.Reset();
       const EditorDOMRange range = [&]() {
-        if (selectionRanges.HasSavedRanges()) {
+        if (aRanges.HasSavedRanges()) {
           return EditorDOMRange(
               GetExtendedRangeWrappingEntirelySelectedElements(
-                  EditorRawDOMRange(selectionRange)));
+                  EditorRawDOMRange(domRange)));
         }
         Result<EditorRawDOMRange, nsresult> rangeOrError =
             inlineStyleSetter.ExtendOrShrinkRangeToApplyTheStyle(
-                *this, EditorDOMRange(selectionRange));
+                *this, EditorDOMRange(domRange), aEditingHost);
         if (MOZ_UNLIKELY(rangeOrError.isErr())) {
           NS_WARNING(
               "HTMLEditor::ExtendOrShrinkRangeToApplyTheStyle() failed, but "
@@ -276,11 +312,42 @@
         continue;
       }
 
+      // If the range is collapsed, we should insert new element there.
+      if (range.Collapsed()) {
+        Result<RefPtr<Text>, nsresult> emptyTextNodeOrError =
+            AutoInlineStyleSetter::GetEmptyTextNodeToApplyNewStyle(
+                *this, range.StartRef(), aEditingHost);
+        if (MOZ_UNLIKELY(emptyTextNodeOrError.isErr())) {
+          NS_WARNING(
+              "AutoInlineStyleSetter::GetEmptyTextNodeToApplyNewStyle() "
+              "failed");
+          return emptyTextNodeOrError.unwrapErr();
+        }
+        if (MOZ_UNLIKELY(!emptyTextNodeOrError.inspect())) {
+          continue;  // Couldn't insert text node there
+        }
+        RefPtr<Text> emptyTextNode = emptyTextNodeOrError.unwrap();
+        Result<CaretPoint, nsresult> caretPointOrError =
+            inlineStyleSetter
+                .ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle(
+                    *this, *emptyTextNode);
+        if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
+          NS_WARNING(
+              "AutoInlineStyleSetter::"
+              "ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle() failed");
+          return caretPointOrError.unwrapErr();
+        }
+        DebugOnly<nsresult> rvIgnored = domRange->CollapseTo(emptyTextNode, 0);
+        NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
+                             "nsRange::CollapseTo() failed, but ignored");
+        continue;
+      }
+
       // Use const_cast hack here for preventing the others to update the range.
       AutoTrackDOMRange trackRange(RangeUpdaterRef(),
                                    const_cast<EditorDOMRange*>(&range));
       auto UpdateSelectionRange = [&]() MOZ_CAN_RUN_SCRIPT {
-        if (selectionRanges.HasSavedRanges()) {
+        if (aRanges.HasSavedRanges()) {
           return;
         }
         // If inlineStyleSetter creates elements or setting styles, we should
@@ -303,7 +370,7 @@
                         EditorRawDOMPoint>(
                         *inlineStyleSetter.LastHandledPointRef()
                              .ContainerAs<nsIContent>());
-          nsresult rv = selectionRange->SetStartAndEnd(
+          nsresult rv = domRange->SetStartAndEnd(
               startPoint.ToRawRangeBoundary(), endPoint.ToRawRangeBoundary());
           if (NS_SUCCEEDED(rv)) {
             trackRange.StopTracking();
@@ -312,8 +379,8 @@
         }
         // Otherwise, use the range computed with the tracking original range.
         trackRange.FlushAndStopTracking();
-        selectionRange->SetStartAndEnd(range.StartRef().ToRawRangeBoundary(),
-                                       range.EndRef().ToRawRangeBoundary());
+        domRange->SetStartAndEnd(range.StartRef().ToRawRangeBoundary(),
+                                 range.EndRef().ToRawRangeBoundary());
       };
 
       // If range is in a text node, apply new style simply.
@@ -329,8 +396,8 @@
           NS_WARNING("HTMLEditor::SetInlinePropertyOnTextNode() failed");
           return wrapTextInStyledElementResult.unwrapErr();
         }
-        // There is AutoTransactionsConserveSelection, so we don't need to
-        // update selection here.
+        // The caller should handle the ranges as Selection if necessary, and we
+        // don't want to update aRanges with this result.
         wrapTextInStyledElementResult.inspect().IgnoreCaretPointSuggestion();
         UpdateSelectionRange();
         continue;
@@ -386,8 +453,8 @@
           NS_WARNING("HTMLEditor::SetInlinePropertyOnTextNode() failed");
           return wrapTextInStyledElementResult.unwrapErr();
         }
-        // There is AutoTransactionsConserveSelection, so we don't need to
-        // update selection here.
+        // The caller should handle the ranges as Selection if necessary, and we
+        // don't want to update aRanges with this result.
         wrapTextInStyledElementResult.inspect().IgnoreCaretPointSuggestion();
       }
 
@@ -404,8 +471,8 @@
               "ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle() failed");
           return pointToPutCaretOrError.unwrapErr();
         }
-        // There is AutoTransactionsConserveSelection, so we don't need to
-        // update selection here.
+        // The caller should handle the ranges as Selection if necessary, and we
+        // don't want to update aRanges with this result.
         pointToPutCaretOrError.inspect().IgnoreCaretPointSuggestion();
       }
 
@@ -424,24 +491,80 @@
           NS_WARNING("HTMLEditor::SetInlinePropertyOnTextNode() failed");
           return wrapTextInStyledElementResult.unwrapErr();
         }
-        // There is AutoTransactionsConserveSelection, so we don't need to
-        // update selection here.
+        // The caller should handle the ranges as Selection if necessary, and we
+        // don't want to update aRanges with this result.
         wrapTextInStyledElementResult.inspect().IgnoreCaretPointSuggestion();
       }
       UpdateSelectionRange();
     }
-    if (selectionRanges.HasSavedRanges()) {
-      selectionRanges.RestoreFromSavedRanges();
+    if (aRanges.HasSavedRanges()) {
+      aRanges.RestoreFromSavedRanges();
     }
   }
-
-  MOZ_ASSERT(!selectionRanges.HasSavedRanges());
-  nsresult rv = selectionRanges.ApplyTo(SelectionRef());
-  if (NS_WARN_IF(Destroyed())) {
-    return NS_ERROR_EDITOR_DESTROYED;
+  return NS_OK;
+}
+
+// static
+Result<RefPtr<Text>, nsresult>
+HTMLEditor::AutoInlineStyleSetter::GetEmptyTextNodeToApplyNewStyle(
+    HTMLEditor& aHTMLEditor, const EditorDOMPoint& aCandidatePointToInsert,
+    const Element& aEditingHost) {
+  auto pointToInsertNewText =
+      HTMLEditUtils::GetBetterCaretPositionToInsertText<EditorDOMPoint>(
+          aCandidatePointToInsert, aEditingHost);
+  if (MOZ_UNLIKELY(!pointToInsertNewText.IsSet())) {
+    return RefPtr<Text>();  // cannot insert text there
   }
-  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "AutoRangeArray::ApplyTo() failed");
-  return rv;
+  auto pointToInsertNewStyleOrError =
+      [&]() MOZ_CAN_RUN_SCRIPT -> Result<EditorDOMPoint, nsresult> {
+    if (!pointToInsertNewText.IsInTextNode()) {
+      return pointToInsertNewText;
+    }
+    if (!pointToInsertNewText.ContainerAs<Text>()->TextDataLength()) {
+      return pointToInsertNewText;  // Use it
+    }
+    if (pointToInsertNewText.IsStartOfContainer()) {
+      return pointToInsertNewText.ParentPoint();
+    }
+    if (pointToInsertNewText.IsEndOfContainer()) {
+      return EditorDOMPoint::After(*pointToInsertNewText.ContainerAs<Text>());
+    }
+    Result<SplitNodeResult, nsresult> splitTextNodeResult =
+        aHTMLEditor.SplitNodeWithTransaction(pointToInsertNewText);
+    if (MOZ_UNLIKELY(splitTextNodeResult.isErr())) {
+      NS_WARNING("HTMLEditor::SplitNodeWithTransaction() failed");
+      return splitTextNodeResult.propagateErr();
+    }
+    SplitNodeResult unwrappedSplitTextNodeResult = splitTextNodeResult.unwrap();
+    unwrappedSplitTextNodeResult.IgnoreCaretPointSuggestion();
+    return unwrappedSplitTextNodeResult.AtSplitPoint<EditorDOMPoint>();
+  }();
+  if (MOZ_UNLIKELY(pointToInsertNewStyleOrError.isErr())) {
+    return pointToInsertNewStyleOrError.propagateErr();
+  }
+
+  // If we already have empty text node which is available for placeholder in
+  // new styled element, let's use it.
+  if (pointToInsertNewStyleOrError.inspect().IsInTextNode()) {
+    return RefPtr<Text>(
+        pointToInsertNewStyleOrError.inspect().ContainerAs<Text>());
+  }
+
+  // Otherwise, we need an empty text node to create new inline style.
+  RefPtr<Text> newEmptyTextNode = aHTMLEditor.CreateTextNode(u""_ns);
+  if (MOZ_UNLIKELY(!newEmptyTextNode)) {
+    NS_WARNING("EditorBase::CreateTextNode() failed");
+    return Err(NS_ERROR_FAILURE);
+  }
+  Result<CreateTextResult, nsresult> insertNewTextNodeResult =
+      aHTMLEditor.InsertNodeWithTransaction<Text>(
+          *newEmptyTextNode, pointToInsertNewStyleOrError.inspect());
+  if (MOZ_UNLIKELY(insertNewTextNodeResult.isErr())) {
+    NS_WARNING("EditorBase::InsertNodeWithTransaction() failed");
+    return insertNewTextNodeResult.propagateErr();
+  }
+  insertNewTextNodeResult.inspect().IgnoreCaretPointSuggestion();
+  return newEmptyTextNode;
 }
 
 Result<bool, nsresult>
@@ -1646,7 +1769,8 @@
 
 Result<EditorRawDOMRange, nsresult>
 HTMLEditor::AutoInlineStyleSetter::ExtendOrShrinkRangeToApplyTheStyle(
-    const HTMLEditor& aHTMLEditor, const EditorDOMRange& aRange) const {
+    const HTMLEditor& aHTMLEditor, const EditorDOMRange& aRange,
+    const Element& aEditingHost) const {
   if (NS_WARN_IF(!aRange.IsPositioned())) {
     return Err(NS_ERROR_FAILURE);
   }
@@ -1654,43 +1778,70 @@
   // For avoiding assertion hits in the utility methods, check whether the
   // range is in same subtree, first. Even if the range crosses a subtree
   // boundary, it's not a bug of this module.
-  nsINode* const commonAncestor = aRange.GetClosestCommonInclusiveAncestor();
+  nsINode* commonAncestor = aRange.GetClosestCommonInclusiveAncestor();
   if (NS_WARN_IF(!commonAncestor)) {
     return Err(NS_ERROR_FAILURE);
   }
 
+  // If the range does not select only invisible <br> element, let's extend the
+  // range to contain the <br> element.
+  EditorDOMRange range(aRange);
+  if (range.EndRef().IsInContentNode()) {
+    WSScanResult nextContentData =
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
+                                                         range.EndRef());
+    if (nextContentData.ReachedInvisibleBRElement() &&
+        nextContentData.BRElementPtr()->GetParentElement() &&
+        HTMLEditUtils::IsInlineElement(
+            *nextContentData.BRElementPtr()->GetParentElement())) {
+      range.SetEnd(EditorDOMPoint::After(*nextContentData.BRElementPtr()));
+      MOZ_ASSERT(range.EndRef().IsSet());
+    }
+  }
+
+  // If the range is collapsed, we don't want to replace ancestors unless it's
+  // in an empty element.
+  if (range.Collapsed() && range.StartRef().GetContainer()->Length()) {
+    return EditorRawDOMRange(range);
+  }
+
   // First, shrink the given range to minimize new style applied contents.
   // However, we should not shrink the range into entirely selected element.
   // E.g., if `abc[<i>def</i>]ghi`, shouldn't shrink it as
   // `abc<i>[def]</i>ghi`.
-  ContentSubtreeIterator iter;
-  if (NS_FAILED(iter.Init(aRange.StartRef().ToRawRangeBoundary(),
-                          aRange.EndRef().ToRawRangeBoundary()))) {
-    NS_WARNING("ContentSubtreeIterator::Init() failed");
-    return Err(NS_ERROR_FAILURE);
-  }
-  nsIContent* const firstContentEntirelyInRange =
-      nsIContent::FromNodeOrNull(iter.GetCurrentNode());
-  nsIContent* const lastContentEntirelyInRange = [&]() {
-    iter.Last();
-    return nsIContent::FromNodeOrNull(iter.GetCurrentNode());
-  }();
-
-  // Compute the shrunken range boundaries.
-  EditorRawDOMPoint startPoint = GetShrunkenRangeStart(
-      aHTMLEditor, aRange, *commonAncestor, firstContentEntirelyInRange);
-  MOZ_ASSERT(startPoint.IsSet());
-  EditorRawDOMPoint endPoint = GetShrunkenRangeEnd(
-      aHTMLEditor, aRange, *commonAncestor, lastContentEntirelyInRange);
-  MOZ_ASSERT(endPoint.IsSet());
-
-  // If shrunken range is swapped, it could like this case:
-  // `abc[</span><span>]def`, starts at very end of a node and ends at
-  // very start of immediately next node.  In this case, we should use
-  // the original range instead.
-  if (MOZ_UNLIKELY(!startPoint.EqualsOrIsBefore(endPoint))) {
-    startPoint = aRange.StartRef().To<EditorRawDOMPoint>();
-    endPoint = aRange.EndRef().To<EditorRawDOMPoint>();
+  EditorRawDOMPoint startPoint, endPoint;
+  if (range.Collapsed()) {
+    startPoint = endPoint = range.StartRef().To<EditorRawDOMPoint>();
+  } else {
+    ContentSubtreeIterator iter;
+    if (NS_FAILED(iter.Init(range.StartRef().ToRawRangeBoundary(),
+                            range.EndRef().ToRawRangeBoundary()))) {
+      NS_WARNING("ContentSubtreeIterator::Init() failed");
+      return Err(NS_ERROR_FAILURE);
+    }
+    nsIContent* const firstContentEntirelyInRange =
+        nsIContent::FromNodeOrNull(iter.GetCurrentNode());
+    nsIContent* const lastContentEntirelyInRange = [&]() {
+      iter.Last();
+      return nsIContent::FromNodeOrNull(iter.GetCurrentNode());
+    }();
+
+    // Compute the shrunken range boundaries.
+    startPoint = GetShrunkenRangeStart(aHTMLEditor, range, *commonAncestor,
+                                       firstContentEntirelyInRange);
+    MOZ_ASSERT(startPoint.IsSet());
+    endPoint = GetShrunkenRangeEnd(aHTMLEditor, range, *commonAncestor,
+                                   lastContentEntirelyInRange);
+    MOZ_ASSERT(endPoint.IsSet());
+
+    // If shrunken range is swapped, it could like this case:
+    // `abc[</span><span>]def`, starts at very end of a node and ends at
+    // very start of immediately next node.  In this case, we should use
+    // the original range instead.
+    if (MOZ_UNLIKELY(!startPoint.EqualsOrIsBefore(endPoint))) {
+      startPoint = range.StartRef().To<EditorRawDOMPoint>();
+      endPoint = range.EndRef().To<EditorRawDOMPoint>();
+    }
   }
 
   // Then, we may need to extend the range to wrap parent inline elements