# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/workers/remoteworkers/RemoteWorkerManager.cpp
# Commit: 265ddb17e99d
# Full Hash: 265ddb17e99d408581fe681f9ab294520bba2ca1
# Author: Jens Stutte <jstutte@mozilla.com>
# Date: 2023-01-27 09:46:52
# Description:
#   Bug 1812490 - Check for shutdown when executing async launch request. r=asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D167904
# ==============================================================================

diff -r 481a72905445 -r 265ddb17e99d dom/workers/remoteworkers/RemoteWorkerManager.cpp
--- a/dom/workers/remoteworkers/RemoteWorkerManager.cpp	Thu Jan 26 17:40:14 2023 +0000
+++ b/dom/workers/remoteworkers/RemoteWorkerManager.cpp	Thu Jan 26 17:41:51 2023 +0000
@@ -419,7 +419,7 @@
     pending->mController = aController;
     pending->mData = aData;
 
-    // XXX: We do not check for failure here, should we?
+    // Launching is async, so we cannot check for failures right here.
     LaunchNewContentProcess(aData);
     return;
   }
@@ -639,7 +639,9 @@
 
   nsCOMPtr<nsISerialEventTarget> bgEventTarget = GetCurrentSerialEventTarget();
 
-  using CallbackParamType = ContentParent::LaunchPromise::ResolveOrRejectValue;
+  using LaunchPromiseType = ContentParent::LaunchPromise;
+  using LaunchErrorType = ContentParent::LaunchError;
+  using CallbackParamType = LaunchPromiseType::ResolveOrRejectValue;
 
   // A new content process must be requested on the main thread. On success,
   // the success callback will also run on the main thread. On failure, however,
@@ -693,28 +695,38 @@
         auto remoteType =
             workerRemoteType.IsEmpty() ? DEFAULT_REMOTE_TYPE : workerRemoteType;
 
-        // Request a process making sure to specify aPreferUsed=true.  For a
-        // given remoteType there's a pool size limit.  If we pass aPreferUsed
-        // here, then if there's any process in the pool already, we will use
-        // that.  If we pass false (which is the default if omitted), then this
-        // call will spawn a new process if the pool isn't at its limit yet.
-        //
-        // (Our intent is never to grow the pool size here.  Our logic gets here
-        // because our current logic on PBackground is only aware of
-        // RemoteWorkerServiceParent actors that have registered themselves,
-        // which is fundamentally unaware of processes that will match in the
-        // future when they register.  So we absolutely are fine with and want
-        // any existing processes.)
-        ContentParent::GetNewOrUsedBrowserProcessAsync(
-            /* aRemoteType = */ remoteType,
-            /* aGroup */ nullptr,
-            hal::ProcessPriority::PROCESS_PRIORITY_FOREGROUND,
-            /* aPreferUsed */ true)
-            ->Then(GetCurrentSerialEventTarget(), __func__,
-                   [callback = std::move(callback),
-                    remoteType](const CallbackParamType& aValue) mutable {
-                     callback(aValue, remoteType);
-                   });
+        RefPtr<LaunchPromiseType> onFinished;
+        if (!AppShutdown::IsInOrBeyond(ShutdownPhase::AppShutdownConfirmed)) {
+          // Request a process making sure to specify aPreferUsed=true.  For a
+          // given remoteType there's a pool size limit.  If we pass aPreferUsed
+          // here, then if there's any process in the pool already, we will use
+          // that.  If we pass false (which is the default if omitted), then
+          // this call will spawn a new process if the pool isn't at its limit
+          // yet.
+          //
+          // (Our intent is never to grow the pool size here.  Our logic gets
+          // here because our current logic on PBackground is only aware of
+          // RemoteWorkerServiceParent actors that have registered themselves,
+          // which is fundamentally unaware of processes that will match in the
+          // future when they register.  So we absolutely are fine with and want
+          // any existing processes.)
+          onFinished = ContentParent::GetNewOrUsedBrowserProcessAsync(
+              /* aRemoteType = */ remoteType,
+              /* aGroup */ nullptr,
+              hal::ProcessPriority::PROCESS_PRIORITY_FOREGROUND,
+              /* aPreferUsed */ true);
+        } else {
+          // We can find this event still in flight after having been asked to
+          // shutdown. Let's fake a failure to ensure our callback is called
+          // such that we clean up everything properly.
+          onFinished =
+              LaunchPromiseType::CreateAndReject(LaunchErrorType(), __func__);
+        }
+        onFinished->Then(GetCurrentSerialEventTarget(), __func__,
+                         [callback = std::move(callback),
+                          remoteType](const CallbackParamType& aValue) mutable {
+                           callback(aValue, remoteType);
+                         });
       });
 
   SchedulerGroup::Dispatch(TaskCategory::Other, r.forget());
