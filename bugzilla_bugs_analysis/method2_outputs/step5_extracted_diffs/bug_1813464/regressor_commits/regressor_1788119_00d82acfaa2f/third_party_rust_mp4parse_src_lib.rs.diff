# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/mp4parse/src/lib.rs
# Commit: 00d82acfaa2f
# Full Hash: 00d82acfaa2f56095e5033a6905427d43b95eccb
# Author: zaggy1024 <Zaggy1024@gmail.com>
# Date: 2023-01-28 21:11:06
# Regressor Bug: 1788119
# File Overlap Count: 1
# Description:
#   Bug 1788119 - Part 4 - Update mp4parse-rust for AVIS support. r=kinetik,glandium,supply-chain-reviewers
#   
#   Depends on D156652
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D156653
# ==============================================================================

diff -r 4ba88410cdf6 -r 00d82acfaa2f third_party/rust/mp4parse/src/lib.rs
--- a/third_party/rust/mp4parse/src/lib.rs	Fri Jan 27 18:35:14 2023 +0000
+++ b/third_party/rust/mp4parse/src/lib.rs	Fri Jan 27 18:35:14 2023 +0000
@@ -35,7 +35,7 @@
 mod macros;
 
 mod boxes;
-use boxes::{BoxType, FourCC};
+use crate::boxes::{BoxType, FourCC};
 
 // Unit tests.
 #[cfg(test)]
@@ -137,6 +137,7 @@
 impl<'a, T: Read> Read for OffsetReader<'a, T> {
     fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
         let bytes_read = self.reader.read(buf)?;
+        trace!("Read {} bytes at offset {}", bytes_read, self.offset);
         self.offset = self
             .offset
             .checked_add(bytes_read.to_u64())
@@ -164,7 +165,7 @@
 /// Any detail that needs to be communicated to the caller must be encoded here
 /// since the [`Error`] type's associated data is part of the FFI.
 #[repr(C)]
-#[derive(Clone, Copy, PartialEq, Debug)]
+#[derive(Clone, Copy, PartialEq, Eq, Debug)]
 pub enum Status {
     Ok = 0,
     BadArg = 1,
@@ -173,25 +174,108 @@
     Eof = 4,
     Io = 5,
     Oom = 6,
-    MissingBrand,
-    FtypNotFirst,
-    NoImage,
-    MultipleMoov,
-    NoMoov,
-    LselNoEssential,
+    A1lxEssential,
     A1opNoEssential,
-    A1lxEssential,
-    TxformNoEssential,
-    NoPrimaryItem,
+    AlacBadMagicCookieSize,
+    AlacFlagsNonzero,
+    Av1cMissing,
+    BitReaderError,
+    BoxBadSize,
+    BoxBadWideSize,
+    CheckParserStateErr,
+    ColrBadQuantity,
+    ColrBadSize,
+    ColrBadType,
+    ColrReservedNonzero,
+    ConstructionMethod,
+    CttsBadSize,
+    CttsBadVersion,
+    DflaBadMetadataBlockSize,
+    DflaFlagsNonzero,
+    DflaMissingMetadata,
+    DflaStreamInfoBadSize,
+    DflaStreamInfoNotFirst,
+    DopsChannelMappingWriteErr,
+    DopsOpusHeadWriteErr,
+    ElstBadVersion,
+    EsdsBadAudioSampleEntry,
+    EsdsBadDescriptor,
+    EsdsDecSpecificIntoTagQuantity,
+    FtypBadSize,
+    FtypNotFirst,
+    HdlrNameMultipleNul,
+    HdlrNameNoNul,
+    HdlrNameNotUtf8,
+    HdlrNotFirst,
+    HdlrPredefinedNonzero,
+    HdlrReservedNonzero,
+    HdlrTypeNotPict,
+    HdlrUnsupportedVersion,
+    HdrlBadQuantity,
+    IdatBadQuantity,
+    IdatMissing,
+    IinfBadChild,
+    IinfBadQuantity,
+    IlocBadConstructionMethod,
+    IlocBadExtent,
+    IlocBadExtentCount,
+    IlocBadFieldSize,
+    IlocBadQuantity,
+    IlocBadSize,
+    IlocDuplicateItemId,
+    IlocMissing,
+    IlocNotFound,
+    IlocOffsetOverflow,
     ImageItemType,
+    InfeFlagsNonzero,
+    InvalidUtf8,
+    IpcoIndexOverflow,
+    IpmaBadIndex,
+    IpmaBadItemOrder,
+    IpmaBadQuantity,
+    IpmaBadVersion,
+    IpmaDuplicateItemId,
+    IpmaFlagsNonzero,
+    IpmaIndexZeroNoEssential,
+    IpmaTooBig,
+    IpmaTooSmall,
+    IprpBadChild,
+    IprpBadQuantity,
+    IprpConflict,
+    IrefBadQuantity,
+    IrefRecursion,
+    IspeMissing,
     ItemTypeMissing,
-    ConstructionMethod,
-    ItemLocNotFound,
-    NoItemDataBox,
+    LselNoEssential,
+    MdhdBadTimescale,
+    MdhdBadVersion,
+    MehdBadVersion,
+    MetaBadQuantity,
+    MissingAvifOrAvisBrand,
+    MissingMif1Brand,
+    MoovBadQuantity,
+    MoovMissing,
+    MultipleAlpha,
+    MvhdBadTimescale,
+    MvhdBadVersion,
+    NoImage,
+    PitmBadQuantity,
+    PitmMissing,
+    PixiBadChannelCount,
+    PixiMissing,
+    PsshSizeOverflow,
+    ReadBufErr,
+    SchiQuantity,
+    StsdBadAudioSampleEntry,
+    StsdBadVideoSampleEntry,
+    TkhdBadVersion,
+    TxformBeforeIspe,
+    TxformNoEssential,
+    TxformOrder,
 }
 
 #[repr(C)]
-#[derive(Clone, Copy, Debug, PartialEq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub enum Feature {
     A1lx,
     A1op,
@@ -215,19 +299,14 @@
         match self {
             Self::Auxc
             | Self::Av1c
+            | Self::Avis
             | Self::Colr
             | Self::Imir
             | Self::Irot
             | Self::Ispe
             | Self::Pasp
             | Self::Pixi => true,
-            Self::A1lx
-            | Self::A1op
-            | Self::Clap
-            | Self::Grid
-            | Self::Ipro
-            | Self::Lsel
-            | Self::Avis => false,
+            Self::A1lx | Self::A1op | Self::Clap | Self::Grid | Self::Ipro | Self::Lsel => false,
         }
     }
 }
@@ -300,17 +379,15 @@
 impl<T> From<Status> for Result<T> {
     /// A convenience method to enable shortcuts like
     /// ```
-    /// # extern crate mp4parse;
     /// # use mp4parse::{Result,Status};
     /// # let _: Result<()> =
-    /// Status::MissingBrand.into();
+    /// Status::MissingAvifOrAvisBrand.into();
     /// ```
     /// instead of
     /// ```
-    /// # extern crate mp4parse;
     /// # use mp4parse::{Error,Result,Status};
     /// # let _: Result<()> =
-    /// Err(Error::from(Status::MissingBrand));
+    /// Err(Error::from(Status::MissingAvifOrAvisBrand));
     /// ```
     /// Note that `Status::Ok` can't be supported this way and will panic.
     fn from(parse_status: Status) -> Self {
@@ -333,23 +410,9 @@
             | Status::Eof
             | Status::Io
             | Status::Oom => {
-                panic!("Status -> Error is only for Status:InvalidDataDetail errors")
-            }
-            Status::MissingBrand
-            | Status::FtypNotFirst
-            | Status::NoImage
-            | Status::MultipleMoov
-            | Status::NoMoov
-            | Status::LselNoEssential
-            | Status::A1opNoEssential
-            | Status::A1lxEssential
-            | Status::TxformNoEssential
-            | Status::NoPrimaryItem
-            | Status::ImageItemType
-            | Status::ItemTypeMissing
-            | Status::ConstructionMethod
-            | Status::ItemLocNotFound
-            | Status::NoItemDataBox => Self::InvalidDataDetail(parse_status),
+                panic!("Status -> Error is only for Status:InvalidData errors")
+            }
+            _ => Self::InvalidData(parse_status),
         }
     }
 }
@@ -366,37 +429,346 @@
             | Status::Oom => {
                 panic!("Status -> Error is only for specific parsing errors")
             }
-            Status::MissingBrand => {
-                "The file shall list 'avif' or 'avis' in the compatible_brands field
-                 of the FileTypeBox \
-                 per https://aomediacodec.github.io/av1-avif/#file-constraints"
+            Status::A1lxEssential => {
+                "AV1LayeredImageIndexingProperty (a1lx) shall not be marked as essential \
+                 per https://aomediacodec.github.io/av1-avif/#layered-image-indexing-property-description"
+            }
+            Status::A1opNoEssential => {
+                "OperatingPointSelectorProperty (a1op) shall be marked as essential \
+                 per https://aomediacodec.github.io/av1-avif/#operating-point-selector-property-description"
+            }
+            Status::AlacBadMagicCookieSize => {
+                "ALACSpecificBox magic cookie is the wrong size"
+            }
+            Status::AlacFlagsNonzero => {
+                "no-zero alac (ALAC) flags"
+            }
+            Status::Av1cMissing => {
+                "One AV1 Item Configuration Property (av1C) is mandatory for an \
+                 image item of type 'av01' \
+                 per AVIF specification § 2.2.1"
+            }
+            Status::BitReaderError => {
+                "Bitwise read failed"
+            }
+            Status::BoxBadSize => {
+                "malformed size"
+            }
+            Status::BoxBadWideSize => {
+                "malformed wide size"
+            }
+            Status::CheckParserStateErr => {
+                "unread box content or bad parser sync"
+            }
+            Status::ColrBadQuantity => {
+                "Each item shall have at most one property association with a
+                 ColourInformationBox (colr) for a given value of colour_type \
+                 per HEIF (ISO/IEC DIS 23008-12) § 6.5.5.1"
+            }
+            Status::ColrBadSize => {
+                "Unexpected size for colr box"
+            }
+            Status::ColrBadType => {
+                "Unsupported colour_type for ColourInformationBox"
+            }
+            Status::ColrReservedNonzero => {
+                "The 7 reserved bits at the end of the ColourInformationBox \
+                 for colour_type == 'nclx' must be 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 12.1.5.2"
+            }
+            Status::ConstructionMethod => {
+                "construction_method shall be 0 (file) or 1 (idat) per MIAF (ISO 23000-22:2019) § 7.2.1.7"
+            }
+            Status::CttsBadSize => {
+                "insufficient data in 'ctts' box"
+            }
+            Status::CttsBadVersion => {
+                "unsupported version in 'ctts' box"
+            }
+            Status::DflaBadMetadataBlockSize => {
+                "FLACMetadataBlock larger than parent box"
+            }
+            Status::DflaFlagsNonzero => {
+                "no-zero dfLa (FLAC) flags"
+            }
+            Status::DflaMissingMetadata => {
+                "FLACSpecificBox missing metadata"
+            }
+            Status::DflaStreamInfoBadSize => {
+                "FLACSpecificBox STREAMINFO block is the wrong size"
+            }
+            Status::DflaStreamInfoNotFirst => {
+                "FLACSpecificBox must have STREAMINFO metadata first"
+            }
+            Status::DopsChannelMappingWriteErr => {
+                "Couldn't write channel mapping table data."
+            }
+            Status::DopsOpusHeadWriteErr => {
+                "Couldn't write OpusHead tag."
+            }
+            Status::ElstBadVersion => {
+                "unhandled elst version"
+            }
+            Status::EsdsBadAudioSampleEntry => {
+                "malformed audio sample entry"
+            }
+            Status::EsdsBadDescriptor => {
+                "Invalid descriptor."
+            }
+            Status::EsdsDecSpecificIntoTagQuantity => {
+                "There can be only one DecSpecificInfoTag descriptor"
+            }
+            Status::FtypBadSize => {
+                "invalid ftyp size"
             }
             Status::FtypNotFirst => {
                 "The FileTypeBox shall be placed as early as possible in the file \
                  per ISOBMFF (ISO 14496-12:2020) § 4.3.1"
             }
-            Status::NoImage => "No primary image or image sequence found",
-            Status::NoMoov => {
-                "No moov box found; \
-                 files with avis or msf1 brands shall contain exactly one moov box \
-                 per ISOBMFF (ISO 14496-12:2020) § 8.2.1.1"
-            }
-            Status::MultipleMoov => {
-                "Multiple moov boxes found; \
-                 files with avis or msf1 brands shall contain exactly one moov box \
-                 per ISOBMFF (ISO 14496-12:2020) § 8.2.1.1"
+            Status::HdlrNameMultipleNul => {
+                "The HandlerBox 'name' field shall have a NUL byte \
+                 only in the final position \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdlrNameNoNul => {
+                "The HandlerBox 'name' field shall be null-terminated \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdlrNameNotUtf8 => {
+                "The HandlerBox 'name' field shall be valid utf8 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdlrNotFirst => {
+                "The HandlerBox shall be the first contained box within the MetaBox \
+                 per MIAF (ISO 23000-22:2019) § 7.2.1.5"
+            }
+            Status::HdlrPredefinedNonzero => {
+                "The HandlerBox 'pre_defined' field shall be 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdlrReservedNonzero => {
+                "The HandlerBox 'reserved' fields shall be 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdlrTypeNotPict => {
+                "The HandlerBox handler_type must be 'pict' \
+                 per MIAF (ISO 23000-22:2019) § 7.2.1.5"
+            }
+            Status::HdlrUnsupportedVersion => {
+                "The HandlerBox version shall be 0 (zero) \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2"
+            }
+            Status::HdrlBadQuantity => {
+                "There shall be exactly one hdlr box \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.1"
+            }
+            Status::IdatBadQuantity => {
+                "There shall be zero or one idat boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.11"
+            }
+            Status::IdatMissing => {
+                "ItemLocationBox (iloc) construction_method indicates 1 (idat), \
+                 but no idat box is present."
+            }
+            Status::IinfBadChild => {
+                "iinf box shall contain only infe boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.6.2"
+            }
+            Status::IinfBadQuantity => {
+                "There shall be zero or one iinf boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.6.1"
+            }
+            Status::IlocBadConstructionMethod => {
+                "construction_method is taken from the set 0, 1 or 2 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3"
+            }
+            Status::IlocBadExtent => {
+                "extent_count != 1 requires explicit offset and length \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3"
+            }
+            Status::IlocBadExtentCount => {
+                "extent_count must have a value 1 or greater \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3"
+            }
+            Status::IlocBadFieldSize => {
+                "value must be in the set {0, 4, 8}"
+            }
+            Status::IlocBadQuantity => {
+                "There shall be zero or one iloc boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.3.1"
+            }
+            Status::IlocBadSize => {
+                "invalid iloc size"
+            }
+            Status::IlocDuplicateItemId => {
+                "duplicate item_ID in iloc"
+            }
+            Status::IlocMissing => {
+                "iloc missing"
+            }
+            Status::IlocNotFound => {
+                "ItemLocationBox (iloc) contains an extent not present in any mdat or idat box"
+            }
+            Status::IlocOffsetOverflow => {
+                "offset calculation overflow"
+            }
+            Status::ImageItemType => {
+                "Image item type is neither 'av01' nor 'grid'"
+            }
+            Status::InfeFlagsNonzero => {
+                "'infe' flags field shall be 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.6.2"
+            }
+            Status::InvalidUtf8 => {
+                "invalid utf8"
+            }
+            Status::IpcoIndexOverflow => {
+                "ipco index overflow"
+            }
+            Status::IpmaBadIndex => {
+                "Invalid property index in ipma"
+            }
+            Status::IpmaBadItemOrder => {
+                "Each ItemPropertyAssociation box shall be ordered by increasing item_ID"
+            }
+            Status::IpmaBadQuantity => {
+                "There shall be at most one ItemPropertyAssociationbox with a given pair of \
+                 values of version and flags \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"
+            }
+            Status::IpmaBadVersion => {
+                "The ipma version 0 should be used unless 32-bit item_ID values are needed \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"
+            }
+            Status::IpmaDuplicateItemId => {
+                "There shall be at most one occurrence of a given item_ID, \
+                 in the set of ItemPropertyAssociationBox boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"
+            }
+            Status::IpmaFlagsNonzero => {
+                "Unless there are more than 127 properties in the ItemPropertyContainerBox, \
+                 flags should be equal to 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"
+            }
+            Status::IpmaIndexZeroNoEssential => {
+                "the essential indicator shall be 0 for property index 0 \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.3"
+            }
+            Status::IpmaTooBig => {
+                "ipma box exceeds maximum size for entry_count"
+            }
+            Status::IpmaTooSmall => {
+                "ipma box below minimum size for entry_count"
+            }
+            Status::IprpBadChild => {
+                "unexpected iprp child"
+            }
+            Status::IprpBadQuantity => {
+                "There shall be zero or one iprp boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"
+            }
+            Status::IprpConflict => {
+                "conflicting item property values"
+            }
+            Status::IrefBadQuantity => {
+                "There shall be zero or one iref boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.12.1"
+            }
+            Status::IrefRecursion => {
+                "from_item_id and to_item_id must be different"
+            }
+            Status::IspeMissing => {
+                "Missing 'ispe' property for image item, required \
+                 per HEIF (ISO/IEC 23008-12:2017) § 6.5.3.1"
+            }
+            Status::ItemTypeMissing => {
+                "No ItemInfoEntry for item_ID"
             }
             Status::LselNoEssential => {
                 "LayerSelectorProperty (lsel) shall be marked as essential \
                  per HEIF (ISO/IEC 23008-12:2017) § 6.5.11.1"
             }
-            Status::A1opNoEssential => {
-                "OperatingPointSelectorProperty (a1op) shall be marked as essential \
-                 per https://aomediacodec.github.io/av1-avif/#operating-point-selector-property-description"
-            }
-            Status::A1lxEssential => {
-                "AV1LayeredImageIndexingProperty (a1lx) shall not be marked as essential \
-                 per https://aomediacodec.github.io/av1-avif/#layered-image-indexing-property-description"
+            Status::MdhdBadTimescale => {
+                "zero timescale in mdhd"
+            }
+            Status::MdhdBadVersion => {
+                "unhandled mdhd version"
+            }
+            Status::MehdBadVersion => {
+                "unhandled mehd version"
+            }
+            Status::MetaBadQuantity => {
+                "There should be zero or one meta boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.1.1"
+            }
+            Status::MissingAvifOrAvisBrand => {
+                "The file shall list 'avif' or 'avis' in the compatible_brands field
+                 of the FileTypeBox \
+                 per https://aomediacodec.github.io/av1-avif/#file-constraints"
+            }
+            Status::MissingMif1Brand => {
+                "The FileTypeBox should contain 'mif1' in the compatible_brands list \
+                 per MIAF (ISO 23000-22:2019/Amd. 2:2021) § 7.2.1.2"
+            }
+            Status::MoovBadQuantity => {
+                "Multiple moov boxes found; \
+                 files with avis or msf1 brands shall contain exactly one moov box \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.2.1.1"
+            }
+            Status::MoovMissing => {
+                "No moov box found; \
+                 files with avis or msf1 brands shall contain exactly one moov box \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.2.1.1"
+            }
+            Status::MultipleAlpha => {
+                "multiple alpha planes"
+            }
+            Status::MvhdBadTimescale => {
+                "zero timescale in mvhd"
+            }
+            Status::MvhdBadVersion => {
+                "unhandled mvhd version"
+            }
+            Status::NoImage => "No primary image or image sequence found",
+            Status::PitmBadQuantity => {
+                "There shall be zero or one pitm boxes \
+                 per ISOBMFF (ISO 14496-12:2020) § 8.11.4.1"
+            }
+            Status::PitmMissing => {
+                "Missing required PrimaryItemBox (pitm), required \
+                 per HEIF (ISO/IEC 23008-12:2017) § 10.2.1"
+            }
+            Status::PixiBadChannelCount => {
+                "invalid num_channels"
+            }
+            Status::PixiMissing => {
+                "The pixel information property shall be associated with every image \
+                 that is displayable (not hidden) \
+                 per MIAF (ISO/IEC 23000-22:2019) specification § 7.3.6.6"
+            }
+            Status::PsshSizeOverflow => {
+                "overflow in read_pssh"
+            }
+            Status::ReadBufErr => {
+                "failed buffer read"
+            }
+            Status::SchiQuantity => {
+                "tenc box should be only one at most in sinf box"
+            }
+            Status::StsdBadAudioSampleEntry => {
+                "malformed audio sample entry"
+            }
+            Status::StsdBadVideoSampleEntry => {
+                "malformed video sample entry"
+            }
+            Status::TkhdBadVersion => {
+                "unhandled tkhd version"
+            }
+            Status::TxformBeforeIspe => {
+                "Every image item shall be associated with one property of \
+                 type ImageSpatialExtentsProperty (ispe), prior to the \
+                 association of all transformative properties. \
+                 per HEIF (ISO/IEC 23008-12:2017) § 6.5.3.1"
             }
             Status::TxformNoEssential => {
                 "All transformative properties associated with coded and \
@@ -404,25 +776,11 @@
                  document shall be marked as essential \
                  per MIAF (ISO 23000-22:2019) § 7.3.9"
             }
-            Status::NoPrimaryItem => {
-                "Missing required PrimaryItemBox (pitm), required \
-                 per HEIF (ISO/IEC 23008-12:2017) § 10.2.1"
-            }
-            Status::ImageItemType => {
-                "Image item type is neither 'av01' nor 'grid'"
-            }
-            Status::ItemTypeMissing => {
-                "No ItemInfoEntry for item_ID"
-            }
-            Status::ConstructionMethod => {
-                "construction_method shall be 0 (file) or 1 (idat) per MIAF (ISO 23000-22:2019) § 7.2.1.7"
-            }
-            Status::ItemLocNotFound => {
-                "ItemLocationBox (iloc) contains an extent not present in any mdat or idat box"
-            }
-            Status::NoItemDataBox => {
-                "ItemLocationBox (iloc) construction_method indicates 1 (idat), \
-                 but no idat box is present."
+            Status::TxformOrder => {
+                "These properties, if used, shall be indicated to be applied \
+                 in the following order: clean aperture first, then rotation, \
+                 then mirror. \
+                 per MIAF (ISO/IEC 23000-22:2019) § 7.3.6.7"
             }
         }
     }
@@ -431,9 +789,8 @@
 impl From<Error> for Status {
     fn from(error: Error) -> Self {
         match error {
-            Error::InvalidData(_) => Self::Invalid,
             Error::Unsupported(_) => Self::Unsupported,
-            Error::InvalidDataDetail(parse_status) => parse_status,
+            Error::InvalidData(parse_status) => parse_status,
             Error::UnexpectedEOF => Self::Eof,
             Error::Io(_) => {
                 // Getting std::io::ErrorKind::UnexpectedEof is normal
@@ -441,7 +798,7 @@
                 // those to our Error::UnexpectedEOF variant.
                 Self::Io
             }
-            Error::NoMoov => Self::NoMoov,
+            Error::MoovMissing => Self::MoovMissing,
             Error::OutOfMemory => Self::Oom,
         }
     }
@@ -485,11 +842,8 @@
 #[derive(Debug)]
 pub enum Error {
     /// Parse error caused by corrupt or malformed data.
-    InvalidData(&'static str),
-    /// Similar to [`Self::InvalidData`], but for errors that have a specific
-    /// [`Status`] variant for communicating the detail across FFI.
     /// See the helper [`From<Status> for Error`](enum.Error.html#impl-From<Status>)
-    InvalidDataDetail(Status),
+    InvalidData(Status),
     /// Parse error caused by limited parser support rather than invalid data.
     Unsupported(&'static str),
     /// Reflect `std::io::ErrorKind::UnexpectedEof` for short data.
@@ -497,7 +851,7 @@
     /// Propagate underlying errors from `std::io`.
     Io(std::io::Error),
     /// read_mp4 terminated without detecting a moov box.
-    NoMoov,
+    MoovMissing,
     /// Out of memory
     OutOfMemory,
 }
@@ -512,7 +866,7 @@
 
 impl From<bitreader::BitReaderError> for Error {
     fn from(_: bitreader::BitReaderError) -> Error {
-        Error::InvalidData("invalid data")
+        Status::BitReaderError.into()
     }
 }
 
@@ -527,13 +881,13 @@
 
 impl From<std::string::FromUtf8Error> for Error {
     fn from(_: std::string::FromUtf8Error) -> Error {
-        Error::InvalidData("invalid utf8")
+        Status::InvalidUtf8.into()
     }
 }
 
 impl From<std::str::Utf8Error> for Error {
     fn from(_: std::str::Utf8Error) -> Error {
-        Error::InvalidData("invalid utf8")
+        Status::InvalidUtf8.into()
     }
 }
 
@@ -546,7 +900,6 @@
 impl From<Error> for std::io::Error {
     fn from(err: Error) -> Self {
         let kind = match err {
-            Error::InvalidData(_) => std::io::ErrorKind::InvalidData,
             Error::UnexpectedEOF => std::io::ErrorKind::UnexpectedEof,
             Error::Io(io_err) => return io_err,
             _ => std::io::ErrorKind::Other,
@@ -742,6 +1095,29 @@
     Unknown,
 }
 
+#[derive(Debug)]
+pub struct TrackReferenceBox {
+    pub references: TryVec<TrackReferenceEntry>,
+}
+
+impl TrackReferenceBox {
+    pub fn has_auxl_reference(&self, track_id: u32) -> bool {
+        self.references.iter().any(|entry| match entry {
+            TrackReferenceEntry::Auxiliary(aux_entry) => aux_entry.track_ids.contains(&track_id),
+        })
+    }
+}
+
+#[derive(Debug)]
+pub enum TrackReferenceEntry {
+    Auxiliary(TrackReference),
+}
+
+#[derive(Debug)]
+pub struct TrackReference {
+    pub track_ids: TryVec<u32>,
+}
+
 /// An Elementary Stream Descriptor
 /// See MPEG-4 Systems (ISO 14496-1:2010) § 7.2.6.5
 #[allow(non_camel_case_types)]
@@ -1146,10 +1522,10 @@
 
 /// An ISOBMFF item as described by an iloc box. For the sake of avoiding copies,
 /// this can either be represented by the `Location` variant, which indicates
-/// where the data exists within a `MediaDataBox` stored separately, or the
-/// `Data` variant which owns the data. Unfortunately, it's not simple to
-/// represent this as a [`std::borrow::Cow`], or other reference-based type, because
-/// multiple instances may references different parts of the same [`MediaDataBox`]
+/// where the data exists within a `DataBox` stored separately, or the `Data`
+/// variant which owns the data. Unfortunately, it's not simple to represent
+/// this as a [`std::borrow::Cow`], or other reference-based type, because
+/// multiple instances may references different parts of the same [`DataBox`]
 /// and we want to avoid the copy that splitting the storage would entail.
 enum IsobmffItem {
     MdatLocation(Extent),
@@ -1192,12 +1568,17 @@
     }
 }
 
-#[derive(Debug)]
+#[derive(Default, Debug)]
 pub struct AvifContext {
     /// Level of deviation from the specification before failing the parse
     strictness: ParseStrictness,
-    /// Referred to by the `IsobmffItem::*Location` variants of the `AvifItem`s in this struct
-    media_storage: TryVec<MediaDataBox>,
+    /// Storage elements which can be located anywhere within the "file" identified by
+    /// [`BoxType::ItemLocationBox`]es using [`ConstructionMethod::File`].
+    /// Referred to by the [`IsobmffItem`]`::*Location` variants of the `AvifItem`s in this struct
+    media_storage: TryVec<DataBox>,
+    /// Similar to `media_storage`, but for a single optional chunk of storage within the
+    /// MetaBox itentified by [`BoxType::ItemLocationBox`]es using [`ConstructionMethod::Idat`].
+    item_data_box: Option<DataBox>,
     /// The item indicated by the `pitm` box, See ISOBMFF (ISO 14496-12:2020) § 8.11.4
     /// May be `None` in the pure image sequence case.
     primary_item: Option<AvifItem>,
@@ -1211,13 +1592,17 @@
     /// Should probably only ever be [`AVIF_BRAND`] or [`AVIS_BRAND`], but other values
     /// are legal as long as one of the two is the `compatible_brand` list.
     pub major_brand: FourCC,
-    /// True if a `moov` box is present
-    pub has_sequence: bool,
+    /// Information on the sequence contained in the image, or None if not present
+    pub sequence: Option<MediaContext>,
     /// A collection of unsupported features encountered during the parse
     pub unsupported_features: UnsupportedFeatures,
 }
 
 impl AvifContext {
+    pub fn primary_item_is_present(&self) -> bool {
+        self.primary_item.is_some()
+    }
+
     pub fn primary_item_coded_data(&self) -> Option<&[u8]> {
         self.primary_item
             .as_ref()
@@ -1230,6 +1615,10 @@
             .map(|item| self.image_bits_per_channel(item.id))
     }
 
+    pub fn alpha_item_is_present(&self) -> bool {
+        self.alpha_item.is_some()
+    }
+
     pub fn alpha_item_coded_data(&self) -> Option<&[u8]> {
         self.alpha_item
             .as_ref()
@@ -1262,9 +1651,9 @@
                 Some(ItemProperty::ImageSpatialExtents(ispe)) => Ok(ispe),
                 Some(other_property) => panic!("property key mismatch: {:?}", other_property),
                 None => {
-                    fail_if(
+                    fail_with_status_if(
                         self.strictness != ParseStrictness::Permissive,
-                        "ispe is a mandatory property",
+                        Status::IspeMissing,
                     )?;
                     Ok(std::ptr::null())
                 }
@@ -1376,10 +1765,15 @@
                     }
                 }
                 unreachable!(
-                    "IsobmffItem::Location requires the location exists in AvifContext::media_storage"
+                    "IsobmffItem::MdatLocation requires the location exists in AvifContext::media_storage"
                 );
             }
-            IsobmffItem::IdatLocation(_) => unimplemented!(),
+            IsobmffItem::IdatLocation(extent) => {
+                self.item_data_box
+                    .as_ref()
+                    .and_then(|idat| idat.get(extent))
+                    .unwrap_or_else(|| unreachable!("IsobmffItem::IdatLocation equires the location exists in AvifContext::item_data_box"))
+            }
             IsobmffItem::Data(data) => data.as_slice(),
         }
     }
@@ -1393,29 +1787,31 @@
     primary_item_id: Option<ItemId>,
     item_infos: TryVec<ItemInfoEntry>,
     iloc_items: TryHashMap<ItemId, ItemLocationBoxItem>,
-    item_data_box: Option<ItemDataBox>,
-}
-
-/// An Item Data Box
-/// See ISOBMFF (ISO 14496-12:2020) § 8.11.11
-struct ItemDataBox {
+    item_data_box: Option<DataBox>,
+}
+
+#[derive(Debug)]
+enum DataBoxMetadata {
+    Idat,
+    Mdat {
+        /// Offset of `data` from the beginning of the "file". See ConstructionMethod::File.
+        /// Note: the file may not be an actual file, read_avif supports any `&mut impl Read`
+        /// source for input. However we try to match the terminology used in the spec.
+        file_offset: u64,
+    },
+}
+
+/// Represents either an Item Data Box (ISOBMFF (ISO 14496-12:2020) § 8.11.11)
+/// Or a Media Data Box (ISOBMFF (ISO 14496-12:2020) § 8.1.1)
+struct DataBox {
+    metadata: DataBoxMetadata,
     data: TryVec<u8>,
 }
 
-/// A Media Data Box
-/// See ISOBMFF (ISO 14496-12:2020) § 8.1.1
-struct MediaDataBox {
-    /// Offset of `data` from the beginning of the "file". See ConstructionMethod::File.
-    /// Note: the file may not be an actual file, read_avif supports any `&mut impl Read`
-    /// source for input. However we try to match the terminology used in the spec.
-    file_offset: u64,
-    data: TryVec<u8>,
-}
-
-impl fmt::Debug for MediaDataBox {
+impl fmt::Debug for DataBox {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        f.debug_struct("MediaDataBox")
-            .field("file_offset", &self.file_offset)
+        f.debug_struct("DataBox")
+            .field("metadata", &self.metadata)
             .field("data", &format_args!("{} bytes", self.data.len()))
             .finish()
     }
@@ -1431,18 +1827,49 @@
     }
 }
 
-/// Generalizes the different data boxes a [`ItemLocationBoxItem`] can refer to
-trait DataBox {
-    fn data(&self) -> &[u8];
+impl DataBox {
+    fn from_mdat(file_offset: u64, data: TryVec<u8>) -> Self {
+        Self {
+            metadata: DataBoxMetadata::Mdat { file_offset },
+            data,
+        }
+    }
+
+    fn from_idat(data: TryVec<u8>) -> Self {
+        Self {
+            metadata: DataBoxMetadata::Idat,
+            data,
+        }
+    }
+
+    fn data(&self) -> &[u8] {
+        &self.data
+    }
 
     /// Convert an absolute offset to an offset relative to the beginning of the
     /// slice [`DataBox::data`] returns. Returns None if the offset would be
     /// negative or if the offset would overflow a `usize`.
-    fn start(&self, offset: u64) -> Option<usize>;
+    fn start(&self, offset: u64) -> Option<usize> {
+        match self.metadata {
+            DataBoxMetadata::Idat => u64_to_usize_logged(offset),
+            DataBoxMetadata::Mdat { file_offset } => {
+                let start = offset.checked_sub(file_offset);
+                if start.is_none() {
+                    error!("Overflow subtracting {} + {}", offset, file_offset);
+                }
+                u64_to_usize_logged(start?)
+            }
+        }
+    }
 
     /// Returns an appropriate variant of [`IsobmffItem`] to describe the extent
     /// referencing data within this type of box.
-    fn location(&self, extent: &Extent) -> IsobmffItem;
+    fn location(&self, extent: &Extent) -> IsobmffItem {
+        match self.metadata {
+            DataBoxMetadata::Idat => IsobmffItem::IdatLocation(extent.clone()),
+            DataBoxMetadata::Mdat { .. } => IsobmffItem::MdatLocation(extent.clone()),
+        }
+    }
 
     /// Return a slice from the DataBox specified by the provided `extent`.
     /// Returns `None` if the extent isn't fully contained by the DataBox or if
@@ -1466,46 +1893,14 @@
     }
 }
 
-impl DataBox for ItemDataBox {
-    fn data(&self) -> &[u8] {
-        &self.data
-    }
-
-    fn start(&self, offset: u64) -> Option<usize> {
-        u64_to_usize_logged(offset)
-    }
-
-    fn location(&self, extent: &Extent) -> IsobmffItem {
-        IsobmffItem::IdatLocation(extent.clone())
-    }
-}
-
-impl DataBox for MediaDataBox {
-    fn data(&self) -> &[u8] {
-        &self.data
-    }
-
-    fn start(&self, offset: u64) -> Option<usize> {
-        let start = offset.checked_sub(self.file_offset);
-        if start.is_none() {
-            error!("Overflow subtracting {} + {}", offset, self.file_offset);
-        }
-        u64_to_usize_logged(start?)
-    }
-
-    fn location(&self, extent: &Extent) -> IsobmffItem {
-        IsobmffItem::MdatLocation(extent.clone())
-    }
-}
-
 #[cfg(test)]
 mod media_data_box_tests {
     use super::*;
 
-    impl MediaDataBox {
+    impl DataBox {
         fn at_offset(file_offset: u64, data: std::vec::Vec<u8>) -> Self {
-            MediaDataBox {
-                file_offset,
+            DataBox {
+                metadata: DataBoxMetadata::Mdat { file_offset },
                 data: data.into(),
             }
         }
@@ -1513,7 +1908,7 @@
 
     #[test]
     fn extent_with_length_before_mdat_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength { offset: 0, len: 2 };
 
         assert!(mdat.get(&extent).is_none());
@@ -1521,7 +1916,7 @@
 
     #[test]
     fn extent_to_end_before_mdat_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::ToEnd { offset: 0 };
 
         assert!(mdat.get(&extent).is_none());
@@ -1529,7 +1924,7 @@
 
     #[test]
     fn extent_with_length_crossing_front_mdat_boundary_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength { offset: 99, len: 3 };
 
         assert!(mdat.get(&extent).is_none());
@@ -1537,7 +1932,7 @@
 
     #[test]
     fn extent_with_length_which_is_subset_of_mdat() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength {
             offset: 101,
             len: 2,
@@ -1548,7 +1943,7 @@
 
     #[test]
     fn extent_to_end_which_is_subset_of_mdat() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::ToEnd { offset: 101 };
 
         assert_eq!(mdat.get(&extent), Some(&[1, 1, 1, 1][..]));
@@ -1556,7 +1951,7 @@
 
     #[test]
     fn extent_with_length_which_is_all_of_mdat() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength {
             offset: 100,
             len: 5,
@@ -1567,7 +1962,7 @@
 
     #[test]
     fn extent_to_end_which_is_all_of_mdat() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::ToEnd { offset: 100 };
 
         assert_eq!(mdat.get(&extent), Some(mdat.data.as_slice()));
@@ -1575,7 +1970,7 @@
 
     #[test]
     fn extent_with_length_crossing_back_mdat_boundary_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength {
             offset: 103,
             len: 3,
@@ -1586,7 +1981,7 @@
 
     #[test]
     fn extent_with_length_after_mdat_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::WithLength {
             offset: 200,
             len: 2,
@@ -1597,7 +1992,7 @@
 
     #[test]
     fn extent_to_end_after_mdat_returns_none() {
-        let mdat = MediaDataBox::at_offset(100, vec![1; 5]);
+        let mdat = DataBox::at_offset(100, vec![1; 5]);
         let extent = Extent::ToEnd { offset: 200 };
 
         assert!(mdat.get(&extent).is_none());
@@ -1605,7 +2000,7 @@
 
     #[test]
     fn extent_with_length_which_overflows_usize() {
-        let mdat = MediaDataBox::at_offset(std::u64::MAX - 1, vec![1; 5]);
+        let mdat = DataBox::at_offset(std::u64::MAX - 1, vec![1; 5]);
         let extent = Extent::WithLength {
             offset: std::u64::MAX,
             len: std::usize::MAX,
@@ -1618,7 +2013,7 @@
     // because the range end is unbounded, we don't calculate it.
     #[test]
     fn extent_to_end_which_overflows_usize() {
-        let mdat = MediaDataBox::at_offset(std::u64::MAX - 1, vec![1; 5]);
+        let mdat = DataBox::at_offset(std::u64::MAX - 1, vec![1; 5]);
         let extent = Extent::ToEnd {
             offset: std::u64::MAX,
         };
@@ -1661,7 +2056,7 @@
 
 /// Potential sizes (in bytes) of variable-sized fields of the 'iloc' box
 /// See ISOBMFF (ISO 14496-12:2020) § 8.11.3
-#[derive(Debug, Clone, Copy, PartialEq)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 enum IlocFieldSize {
     Zero,
     Four,
@@ -1686,12 +2081,12 @@
             0 => Ok(Self::Zero),
             4 => Ok(Self::Four),
             8 => Ok(Self::Eight),
-            _ => Err(Error::InvalidData("value must be in the set {0, 4, 8}")),
+            _ => Status::IlocBadFieldSize.into(),
         }
     }
 }
 
-#[derive(Debug, PartialEq)]
+#[derive(Debug, PartialEq, Eq)]
 enum IlocVersion {
     Zero,
     One,
@@ -1728,7 +2123,7 @@
 /// > MIAF image items are constrained as follows:<br />
 /// > — `construction_method` shall be equal to 0 for MIAF image items that are coded image items.<br />
 /// > — `construction_method` shall be equal to 0 or 1 for MIAF image items that are derived image items.
-#[derive(Clone, Copy, Debug, PartialEq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
 enum ConstructionMethod {
     File = 0,
     Idat = 1,
@@ -1737,7 +2132,7 @@
 
 /// Describes a region where a item specified by an `ItemLocationBoxItem` is stored.
 /// The offset is `u64` since that's the maximum possible size and since the relative
-/// nature of `MediaDataBox` means this can still possibly succeed even in the case
+/// nature of `DataBox` means this can still possibly succeed even in the case
 /// that the raw value exceeds std::usize::MAX on platforms where that type is smaller
 /// than u64. However, `len` is stored as a `usize` since no value larger than
 /// `std::usize::MAX` can be used in a successful indexing operation in rust.
@@ -1749,10 +2144,12 @@
     ToEnd { offset: u64 },
 }
 
-#[derive(Debug, PartialEq)]
+#[derive(Debug, PartialEq, Eq)]
 pub enum TrackType {
     Audio,
     Video,
+    Picture,
+    AuxiliaryVideo,
     Metadata,
     Unknown,
 }
@@ -1766,25 +2163,21 @@
 // This type is used by mp4parse_capi since it needs to be passed from FFI consumers
 // The C-visible struct is renamed via mp4parse_capi/cbindgen.toml to match naming conventions
 #[repr(C)]
-#[derive(Clone, Copy, Debug, PartialEq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub enum ParseStrictness {
     Permissive, // Error only on ambiguous inputs
     Normal,     // Error on "shall" directives, log warnings for "should"
     Strict,     // Error on "should" directives
 }
 
-/// Prefer [`fail_with_error_if`] so all the explanatory strings can be collected
-/// in `From<Status> for &str`.
-fn fail_if(violation: bool, message: &'static str) -> Result<()> {
-    if violation {
-        Err(Error::InvalidData(message))
-    } else {
-        warn!("{}", message);
-        Ok(())
-    }
-}
-
-fn fail_with_error_if(violation: bool, error: Error) -> Result<()> {
+impl Default for ParseStrictness {
+    fn default() -> Self {
+        ParseStrictness::Normal
+    }
+}
+
+fn fail_with_status_if(violation: bool, status: Status) -> Result<()> {
+    let error = Error::from(status);
     if violation {
         Err(error)
     } else {
@@ -1793,7 +2186,7 @@
     }
 }
 
-#[derive(Debug, Clone, Copy, PartialEq)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum CodecType {
     Unknown,
     MP3,
@@ -1823,21 +2216,21 @@
 }
 
 /// The media's global (mvhd) timescale in units per second.
-#[derive(Debug, Copy, Clone, PartialEq)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub struct MediaTimeScale(pub u64);
 
 /// A time to be scaled by the media's global (mvhd) timescale.
-#[derive(Debug, Copy, Clone, PartialEq)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub struct MediaScaledTime(pub u64);
 
 /// The track's local (mdhd) timescale.
 /// Members are timescale units per second and the track id.
-#[derive(Debug, Copy, Clone, PartialEq)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub struct TrackTimeScale<T: Num>(pub T, pub usize);
 
 /// A time to be scaled by the track's local (mdhd) timescale.
 /// Members are time in scale units and the track id.
-#[derive(Debug, Copy, Clone, PartialEq)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub struct TrackScaledTime<T>(pub T, pub usize);
 
 impl<T> std::ops::Add for TrackScaledTime<T>
@@ -1868,6 +2261,7 @@
     pub stco: Option<ChunkOffsetBox>, // It is for stco or co64.
     pub stss: Option<SyncSampleBox>,
     pub ctts: Option<CompositionOffsetBox>,
+    pub tref: Option<TrackReferenceBox>,
 }
 
 impl Track {
@@ -1965,17 +2359,18 @@
         1 => {
             let size64 = be_u64(src)?;
             if size64 < BoxHeader::MIN_LARGE_SIZE {
-                return Err(Error::InvalidData("malformed wide size"));
+                return Status::BoxBadWideSize.into();
             }
             size64
         }
         _ => {
             if u64::from(size32) < BoxHeader::MIN_SIZE {
-                return Err(Error::InvalidData("malformed size"));
+                return Status::BoxBadSize.into();
             }
             u64::from(size32)
         }
     };
+    trace!("read_box_header: name: {:?}, size: {}", name, size);
     let mut offset = match size32 {
         1 => BoxHeader::MIN_LARGE_SIZE,
         _ => BoxHeader::MIN_SIZE,
@@ -2081,8 +2476,6 @@
 
 /// Read the contents of an AVIF file
 pub fn read_avif<T: Read>(f: &mut T, strictness: ParseStrictness) -> Result<AvifContext> {
-    let _ = env_logger::try_init();
-
     debug!("read_avif(strictness: {:?})", strictness);
 
     let mut f = OffsetReader::new(f);
@@ -2115,21 +2508,16 @@
             debug!("expected_image_type: {:?}", expected_image_type);
 
             if primary_image_expected && !has_mif1_brand {
-                // This mandatory inclusion of this brand is in the process of being changed
-                // to optional. In anticipation of that, only give an error in strict mode
-                // See https://github.com/MPEGGroup/MIAF/issues/5
-                // and https://github.com/MPEGGroup/FileFormat/issues/23
-                fail_if(
+                fail_with_status_if(
                     strictness == ParseStrictness::Strict,
-                    "The FileTypeBox should contain 'mif1' in the compatible_brands list \
-                     per MIAF (ISO 23000-22:2019) § 7.2.1.2",
+                    Status::MissingMif1Brand,
                 )?;
             }
 
             if !has_avif_brand && !has_avis_brand {
-                fail_with_error_if(
+                fail_with_status_if(
                     strictness != ParseStrictness::Permissive,
-                    Status::MissingBrand.into(),
+                    Status::MissingAvifOrAvisBrand,
                 )?;
             }
 
@@ -2141,10 +2529,6 @@
         return Status::FtypNotFirst.into();
     };
 
-    if major_brand == AVIS_BRAND {
-        unsupported_features.insert(Feature::Avis);
-    }
-
     let mut meta = None;
     let mut image_sequence = None;
     let mut media_storage = TryVec::new();
@@ -2154,9 +2538,7 @@
         match b.head.name {
             BoxType::MetadataBox => {
                 if meta.is_some() {
-                    return Err(Error::InvalidData(
-                        "There should be zero or one meta boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.1.1",
-                    ));
+                    return Status::MetaBadQuantity.into();
                 }
                 meta = Some(read_avif_meta(
                     &mut b,
@@ -2166,16 +2548,14 @@
             }
             BoxType::MovieBox if expected_image_type.has_sequence() => {
                 if image_sequence.is_some() {
-                    return Status::MultipleMoov.into();
+                    return Status::MoovBadQuantity.into();
                 }
                 image_sequence = Some(read_moov(&mut b, None)?);
             }
             BoxType::MediaDataBox => {
-                if b.bytes_left() > 0 {
-                    let file_offset = b.offset();
-                    let data = b.read_into_try_vec()?;
-                    media_storage.push(MediaDataBox { file_offset, data })?;
-                }
+                let file_offset = b.offset();
+                let data = b.read_into_try_vec()?;
+                media_storage.push(DataBox::from_mdat(file_offset, data))?;
             }
             _ => skip_box_content(&mut b)?,
         }
@@ -2190,7 +2570,7 @@
         item_infos,
         iloc_items,
         item_data_box,
-    } = meta.ok_or(Error::InvalidData("missing meta"))?;
+    } = meta.ok_or_else(|| Error::from(Status::MetaBadQuantity))?;
 
     let (alpha_item_id, premultiplied_alpha) = if let Some(primary_item_id) = primary_item_id {
         let mut alpha_item_ids = item_references
@@ -2206,7 +2586,7 @@
             .filter(|&item_id| item_properties.is_alpha(item_id));
         let alpha_item_id = alpha_item_ids.next();
         if alpha_item_ids.next().is_some() {
-            return Err(Error::InvalidData("multiple alpha planes"));
+            return Status::MultipleAlpha.into();
         }
 
         let premultiplied_alpha = alpha_item_id.map_or(false, |alpha_item_id| {
@@ -2254,7 +2634,7 @@
 
         // Generalize the process of connecting items to their data; returns
         // true if the extent is successfully added to the AvifItem
-        let mut find_and_add_to_item = |extent: &Extent, dat: &dyn DataBox| -> Result<bool> {
+        let mut find_and_add_to_item = |extent: &Extent, dat: &DataBox| -> Result<bool> {
             if let Some(extent_slice) = dat.get(extent) {
                 match item {
                     None => {
@@ -2294,7 +2674,7 @@
                     }
 
                     if !found {
-                        return Status::ItemLocNotFound.into();
+                        return Status::IlocNotFound.into();
                     }
                 }
             }
@@ -2303,17 +2683,17 @@
                     for extent in loc.extents {
                         let found = find_and_add_to_item(&extent, idat)?;
                         if !found {
-                            return Status::ItemLocNotFound.into();
+                            return Status::IlocNotFound.into();
                         }
                     }
                 } else {
-                    return Status::NoItemDataBox.into();
+                    return Status::IdatMissing.into();
                 }
             }
             ConstructionMethod::Item => {
-                fail_with_error_if(
+                fail_with_status_if(
                     strictness != ParseStrictness::Permissive,
-                    Status::ConstructionMethod.into(),
+                    Status::ConstructionMethod,
                 )?;
             }
         }
@@ -2325,18 +2705,18 @@
     assert!(alpha_item.is_none() || alpha_item_id.is_some());
 
     if expected_image_type.has_primary() && primary_item_id.is_none() {
-        fail_with_error_if(
+        fail_with_status_if(
             strictness != ParseStrictness::Permissive,
-            Status::NoPrimaryItem.into(),
+            Status::PitmMissing,
         )?;
     }
 
     // Lacking a brand that requires them, it's fine for moov boxes to exist in
     // BMFF files; they're simply ignored
     if expected_image_type.has_sequence() && image_sequence.is_none() {
-        fail_with_error_if(
+        fail_with_status_if(
             strictness != ParseStrictness::Permissive,
-            Status::NoMoov.into(),
+            Status::MoovMissing,
         )?;
     }
 
@@ -2349,15 +2729,6 @@
         })
     };
 
-    // TODO: add ispe check for alpha https://github.com/mozilla/mp4parse-rust/issues/353
-    if missing_property_for(primary_item_id, BoxType::ImageSpatialExtentsProperty) {
-        fail_if(
-            strictness != ParseStrictness::Permissive,
-            "Missing 'ispe' property for primary item, required \
-             per HEIF (ISO/IEC 23008-12:2017) § 6.5.3.1",
-        )?;
-    }
-
     // Generalize the property checks so we can apply them to primary and alpha items
     let mut check_image_item = |item: &mut Option<AvifItem>| -> Result<()> {
         let item_id = item.as_ref().map(|item| item.id);
@@ -2371,11 +2742,9 @@
         match item_type.map(u32::to_be_bytes).as_ref() {
             Some(b"av01") => {
                 if missing_property_for(item_id, BoxType::AV1CodecConfigurationBox) {
-                    fail_if(
+                    fail_with_status_if(
                         strictness != ParseStrictness::Permissive,
-                        "One AV1 Item Configuration Property (av1C) is mandatory for an \
-                         image item of type 'av01' \
-                         per AVIF specification § 2.2.1",
+                        Status::Av1cMissing,
                     )?;
                 }
 
@@ -2384,15 +2753,20 @@
                     // to allowing its omission to imply a default value. In anticipation
                     // of that, only give an error in strict mode
                     // See https://github.com/MPEGGroup/MIAF/issues/9
-                    fail_if(
+                    fail_with_status_if(
                         if cfg!(feature = "missing-pixi-permitted") {
                             strictness == ParseStrictness::Strict
                         } else {
                             strictness != ParseStrictness::Permissive
                         },
-                        "The pixel information property shall be associated with every image \
-                         that is displayable (not hidden) \
-                         per MIAF (ISO/IEC 23000-22:2019) specification § 7.3.6.6",
+                        Status::PixiMissing,
+                    )?;
+                }
+
+                if missing_property_for(item_id, BoxType::ImageSpatialExtentsProperty) {
+                    fail_with_status_if(
+                        strictness != ParseStrictness::Permissive,
+                        Status::IspeMissing,
                     )?;
                 }
             }
@@ -2425,12 +2799,13 @@
     Ok(AvifContext {
         strictness,
         media_storage,
+        item_data_box,
         primary_item,
         alpha_item,
         premultiplied_alpha,
         item_properties,
         major_brand,
-        has_sequence: image_sequence.is_some(),
+        sequence: image_sequence,
         unsupported_features,
     })
 }
@@ -2463,63 +2838,53 @@
         trace!("read_avif_meta parsing {:?} box", b.head.name);
 
         if !read_handler_box && b.head.name != BoxType::HandlerBox {
-            fail_if(
+            fail_with_status_if(
                 strictness != ParseStrictness::Permissive,
-                "The HandlerBox shall be the first contained box within the MetaBox \
-                 per MIAF (ISO 23000-22:2019) § 7.2.1.5",
+                Status::HdlrNotFirst,
             )?;
         }
 
         match b.head.name {
             BoxType::HandlerBox => {
                 if read_handler_box {
-                    return Err(Error::InvalidData(
-                        "There shall be exactly one hdlr box per ISOBMFF (ISO 14496-12:2020) § 8.4.3.1",
-                    ));
+                    return Status::HdrlBadQuantity.into();
                 }
                 let HandlerBox { handler_type } = read_hdlr(&mut b, strictness)?;
                 if handler_type != b"pict" {
-                    fail_if(
+                    fail_with_status_if(
                         strictness != ParseStrictness::Permissive,
-                        "The HandlerBox handler_type must be 'pict' \
-                         per MIAF (ISO 23000-22:2019) § 7.2.1.5",
+                        Status::HdlrTypeNotPict,
                     )?;
                 }
                 read_handler_box = true;
             }
             BoxType::ItemInfoBox => {
                 if item_infos.is_some() {
-                    return Err(Error::InvalidData(
-                        "There shall be zero or one iinf boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.6.1",
-                    ));
+                    return Status::IinfBadQuantity.into();
                 }
                 item_infos = Some(read_iinf(&mut b, strictness, unsupported_features)?);
             }
             BoxType::ItemLocationBox => {
                 if iloc_items.is_some() {
-                    return Err(Error::InvalidData(
-                        "There shall be zero or one iloc boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.3.1",
-                    ));
+                    return Status::IlocBadQuantity.into();
                 }
                 iloc_items = Some(read_iloc(&mut b)?);
             }
             BoxType::PrimaryItemBox => {
                 if primary_item_id.is_some() {
-                    return Err(Error::InvalidData(
-                        "There shall be zero or one pitm boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.4.1",
-                    ));
+                    return Status::PitmBadQuantity.into();
                 }
                 primary_item_id = Some(read_pitm(&mut b)?);
             }
             BoxType::ItemReferenceBox => {
                 if item_references.is_some() {
-                    return Err(Error::InvalidData("There shall be zero or one iref boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.12.1"));
+                    return Status::IrefBadQuantity.into();
                 }
                 item_references = Some(read_iref(&mut b)?);
             }
             BoxType::ItemPropertiesBox => {
                 if item_properties.is_some() {
-                    return Err(Error::InvalidData("There shall be zero or one iprp boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1"));
+                    return Status::IprpBadQuantity.into();
                 }
                 item_properties = Some(read_iprp(
                     &mut b,
@@ -2530,13 +2895,10 @@
             }
             BoxType::ItemDataBox => {
                 if item_data_box.is_some() {
-                    return Err(Error::InvalidData(
-                        "There shall be zero or one idat boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.11",
-                    ));
+                    return Status::IdatBadQuantity.into();
                 }
-                item_data_box = Some(ItemDataBox {
-                    data: b.read_into_try_vec()?,
-                });
+                let data = b.read_into_try_vec()?;
+                item_data_box = Some(DataBox::from_idat(data));
             }
             _ => skip_box_content(&mut b)?,
         }
@@ -2549,7 +2911,7 @@
         item_references: item_references.unwrap_or_default(),
         primary_item_id,
         item_infos: item_infos.unwrap_or_default(),
-        iloc_items: iloc_items.ok_or(Error::InvalidData("iloc missing"))?,
+        iloc_items: iloc_items.ok_or_else(|| Error::from(Status::IlocMissing))?,
         item_data_box,
     })
 }
@@ -2592,9 +2954,7 @@
     let mut iter = src.box_iter();
     while let Some(mut b) = iter.next_box()? {
         if b.head.name != BoxType::ItemInfoEntry {
-            return Err(Error::InvalidData(
-                "iinf box shall contain only infe boxes per ISOBMFF (ISO 14496-12:2020) § 8.11.6.2",
-            ));
+            return Status::IinfBadChild.into();
         }
 
         if let Some(infe) = read_infe(&mut b, strictness, unsupported_features)? {
@@ -2633,10 +2993,9 @@
     // least one sample AVIF image has a nonzero value.
     // See https://github.com/AOMediaCodec/av1-avif/issues/146
     if flags != 0 {
-        fail_if(
+        fail_with_status_if(
             strictness == ParseStrictness::Strict,
-            "'infe' flags field shall be 0 \
-             per ISOBMFF (ISO 14496-12:2020) § 8.11.6.2",
+            Status::InfeFlagsNonzero,
         )?;
     }
 
@@ -2681,9 +3040,7 @@
         for _ in 0..reference_count {
             let to_item_id = ItemId::read(&mut b, version)?;
             if from_item_id == to_item_id {
-                return Err(Error::InvalidData(
-                    "from_item_id and to_item_id must be different",
-                ));
+                return Status::IrefRecursion.into();
             }
             item_references.push(SingleItemTypeReferenceBox {
                 item_type: b.head.name.into(),
@@ -2701,7 +3058,7 @@
 
 /// Parse an Item Properties Box
 ///
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14)
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14)
 ///
 /// Note: HEIF (ISO 23008-12:2017) § 9.3.1 also defines the `iprp` box and
 /// related types, but lacks additional requirements specified in 14496-12:2020.
@@ -2722,7 +3079,7 @@
         Some(mut b) if b.head.name == BoxType::ItemPropertyContainerBox => {
             read_ipco(&mut b, strictness)
         }
-        Some(_) => Err(Error::InvalidData("unexpected iprp child")),
+        Some(_) => Status::IprpBadChild.into(),
         None => Err(Error::UnexpectedEOF),
     }?;
 
@@ -2732,24 +3089,20 @@
 
     while let Some(mut b) = iter.next_box()? {
         if b.head.name != BoxType::ItemPropertyAssociationBox {
-            return Err(Error::InvalidData("unexpected iprp child"));
+            return Status::IprpBadChild.into();
         }
 
         let (version, flags) = read_fullbox_extra(&mut b)?;
         if ipma_version_and_flag_values_seen.contains(&(version, flags)) {
-            fail_if(
+            fail_with_status_if(
                 strictness != ParseStrictness::Permissive,
-                "There shall be at most one ItemPropertyAssociationbox with a given pair of \
-                 values of version and flags \
-                 per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1",
+                Status::IpmaBadQuantity,
             )?;
         }
         if flags != 0 && properties.len() <= 127 {
-            fail_if(
+            fail_with_status_if(
                 strictness == ParseStrictness::Strict,
-                "Unless there are more than 127 properties in the ItemPropertyContainerBox, \
-                 flags should be equal to 0 \
-                 per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1",
+                Status::IpmaFlagsNonzero,
             )?;
         }
         ipma_version_and_flag_values_seen.push((version, flags))?;
@@ -2772,19 +3125,11 @@
                 // It's technically possible to make sense of this situation by merging ipma
                 // boxes, but this is a "shall" requirement, so we'd only do it in
                 // ParseStrictness::Permissive mode, and this hasn't shown up in the wild
-                return Err(Error::InvalidData(
-                    "There shall be at most one occurrence of a given item_ID, \
-                     in the set of ItemPropertyAssociationBox boxes \
-                     per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1",
-                ));
-            }
-
-            const TRANSFORM_ORDER_ERROR: &str =
-                "These properties, if used, shall be indicated to be applied \
-                 in the following order: clean aperture first, then rotation, \
-                 then mirror. \
-                 per MIAF (ISO/IEC 23000-22:2019) § 7.3.6.7";
+                return Status::IpmaDuplicateItemId.into();
+            }
+
             const TRANSFORM_ORDER: &[BoxType] = &[
+                BoxType::ImageSpatialExtentsProperty,
                 BoxType::CleanApertureBox,
                 BoxType::ImageRotation,
                 BoxType::ImageMirror,
@@ -2797,10 +3142,9 @@
             for a in &association_entry.associations {
                 if a.property_index == PropertyIndex(0) {
                     if a.essential {
-                        fail_if(
+                        fail_with_status_if(
                             strictness != ParseStrictness::Permissive,
-                            "the essential indicator shall be 0 for property index 0 \
-                             per ISOBMFF (ISO 14496-12:2020 § 8.11.14.3",
+                            Status::IpmaIndexZeroNoEssential,
                         )?;
                     }
                     continue;
@@ -2850,9 +3194,9 @@
                                 // This is a "shall", but it is likely to change, so only
                                 // fail if using strict parsing.
                                 // See https://github.com/mozilla/mp4parse-rust/issues/284
-                                fail_with_error_if(
+                                fail_with_status_if(
                                     strictness == ParseStrictness::Strict,
-                                    Status::TxformNoEssential.into(),
+                                    Status::TxformNoEssential,
                                 )?;
                             }
                         }
@@ -2869,11 +3213,9 @@
                                     a.property_index,
                                     prev_colr_index
                                 );
-                                fail_if(
+                                fail_with_status_if(
                                     strictness != ParseStrictness::Permissive,
-                                    "Each item shall have at most one property association with a
-                                     ColourInformationBox (colr) for a given value of colour_type \
-                                     per HEIF (ISO/IEC DIS 23008-12) § 6.5.5.1",
+                                    Status::ColrBadQuantity,
                                 )?;
                             } else {
                                 colour_type_indexes.insert(colour_type, a.property_index)?;
@@ -2885,9 +3227,9 @@
                         ItemProperty::LayeredImageIndexing => {
                             assert!(feature.is_ok() && unsupported_features.contains(feature?));
                             if a.essential {
-                                fail_with_error_if(
+                                fail_with_status_if(
                                     strictness != ParseStrictness::Permissive,
-                                    Status::A1lxEssential.into(),
+                                    Status::A1lxEssential,
                                 )?;
                             }
                         }
@@ -2900,9 +3242,9 @@
                                         || strictness == ParseStrictness::Permissive
                                 );
                             } else {
-                                fail_with_error_if(
+                                fail_with_status_if(
                                     strictness != ParseStrictness::Permissive,
-                                    Status::LselNoEssential.into(),
+                                    Status::LselNoEssential,
                                 )?;
                             }
                         }
@@ -2915,9 +3257,9 @@
                                         || strictness == ParseStrictness::Permissive
                                 );
                             } else {
-                                fail_with_error_if(
+                                fail_with_status_if(
                                     strictness != ParseStrictness::Permissive,
-                                    Status::A1opNoEssential.into(),
+                                    Status::A1opNoEssential,
                                 )?;
                             }
                         }
@@ -2934,10 +3276,19 @@
                         if let Some(prev) = prev_transform_index {
                             if prev >= transform_index {
                                 error!(
-                                    "{:?} after {:?}",
+                                    "Invalid property order: {:?} after {:?}",
                                     TRANSFORM_ORDER[transform_index], TRANSFORM_ORDER[prev]
                                 );
-                                return Err(Error::InvalidData(TRANSFORM_ORDER_ERROR));
+                                fail_with_status_if(
+                                    strictness != ParseStrictness::Permissive,
+                                    if TRANSFORM_ORDER[transform_index]
+                                        == BoxType::ImageSpatialExtentsProperty
+                                    {
+                                        Status::TxformBeforeIspe
+                                    } else {
+                                        Status::TxformOrder
+                                    },
+                                )?;
                             }
                         }
                         prev_transform_index = Some(transform_index);
@@ -2947,9 +3298,9 @@
                         "Missing property at {:?} for {:?}",
                         a.property_index, association_entry.item_id
                     );
-                    fail_if(
+                    fail_with_status_if(
                         strictness != ParseStrictness::Permissive,
-                        "Invalid property index in ipma",
+                        Status::IpmaBadIndex,
                     )?;
                 }
             }
@@ -2968,7 +3319,7 @@
     Ok(iprp)
 }
 
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 /// Variants with no associated data are recognized but not necessarily supported.
 /// See [`Feature`] to determine support.
 #[derive(Debug)]
@@ -3016,14 +3367,14 @@
 }
 
 /// For storing ItemPropertyAssociation data
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 #[derive(Debug)]
 struct Association {
     essential: bool,
     property_index: PropertyIndex,
 }
 
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 ///
 /// The properties themselves are stored in `properties`, but the items they're
 /// associated with are stored in `association_entries`. It's necessary to
@@ -3077,7 +3428,7 @@
                     property_type, multiple_values
                 );
                 // TODO: add test
-                Err(Error::InvalidData("conflicting item property values"))
+                Status::IprpConflict.into()
             }
         }
     }
@@ -3158,7 +3509,7 @@
 }
 
 mod bounded_uints {
-    use UpperBounded;
+    use crate::UpperBounded;
 
     impl_bounded!(U8, u8);
     impl_bounded!(U16, u16);
@@ -3173,7 +3524,7 @@
     }
 }
 
-use bounded_uints::*;
+use crate::bounded_uints::*;
 
 /// Implement the multiplication operator for $lhs * $rhs giving $output, which
 /// is internally represented as $inner. The operation is statically checked
@@ -3184,8 +3535,13 @@
             type Output = $output;
 
             fn mul(self, rhs: $rhs) -> Self::Output {
-                static_assertions::const_assert!(<$output>::MAX <= <$inner>::MAX as u64);
-                static_assertions::const_assert!(<$lhs>::MAX * <$rhs>::MAX <= <$output>::MAX);
+                static_assertions::const_assert!(
+                    <$output as UpperBounded>::MAX <= <$inner>::MAX as u64
+                );
+                static_assertions::const_assert!(
+                    <$lhs as UpperBounded>::MAX * <$rhs as UpperBounded>::MAX
+                        <= <$output as UpperBounded>::MAX
+                );
 
                 let lhs: $inner = self.get().into();
                 let rhs: $inner = rhs.get().into();
@@ -3219,7 +3575,7 @@
 /// types implementing the UpperBounded trait. Types are declared explicitly to
 /// show there isn't any accidental inference to primitive types.
 ///
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 fn calculate_ipma_total_associations(
     version: u8,
     bytes_left: u64,
@@ -3236,9 +3592,7 @@
             // All the storage for the `essential` and `property_index` parts (assuming a valid ipma box size)
             difference
         } else {
-            return Err(Error::InvalidData(
-                "ipma box below minimum size for entry_count",
-            ));
+            return Status::IpmaTooSmall.into();
         };
 
     let max_association_bytes_per_entry: U16 = MAX_IPMA_ASSOCIATION_COUNT * num_association_bytes;
@@ -3246,9 +3600,7 @@
     let max_bytes_left: U64 = total_non_association_bytes + max_total_association_bytes;
 
     if bytes_left > max_bytes_left.get() {
-        return Err(Error::InvalidData(
-            "ipma box exceeds maximum size for entry_count",
-        ));
+        return Status::IpmaTooBig.into();
     }
 
     let total_associations: u64 = total_association_bytes / u64::from(num_association_bytes.get());
@@ -3258,7 +3610,7 @@
 
 /// Parse an ItemPropertyAssociation box
 ///
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 fn read_ipma<T: Read>(
     src: &mut BMFFBox<T>,
     strictness: ParseStrictness,
@@ -3290,11 +3642,9 @@
         if let Some(previous_association) = entries.last() {
             #[allow(clippy::comparison_chain)]
             if previous_association.item_id > item_id {
-                return Err(Error::InvalidData(
-                    "Each ItemPropertyAssociation box shall be ordered by increasing item_ID",
-                ));
+                return Status::IpmaBadItemOrder.into();
             } else if previous_association.item_id == item_id {
-                return Err(Error::InvalidData("There shall be at most one association box for each item_ID, in any ItemPropertyAssociation box"));
+                return Status::IpmaDuplicateItemId.into();
             }
         }
 
@@ -3329,10 +3679,9 @@
         }) = entries.last()
         {
             if *max_item_id <= ItemId(u16::MAX.into()) {
-                fail_if(
+                fail_with_status_if(
                     strictness == ParseStrictness::Strict,
-                    "The ipma version 0 should be used unless 32-bit item_ID values are needed \
-                     per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1",
+                    Status::IpmaBadVersion,
                 )?;
             }
         }
@@ -3345,7 +3694,7 @@
 
 /// Parse an ItemPropertyContainerBox
 ///
-/// See ISOBMFF (ISO 14496-12:2020 § 8.11.14.1
+/// See ISOBMFF (ISO 14496-12:2020) § 8.11.14.1
 fn read_ipco<T: Read>(
     src: &mut BMFFBox<T>,
     strictness: ParseStrictness,
@@ -3391,7 +3740,7 @@
             index
                 .0
                 .checked_add(1) // must include ignored properties to have correct indexes
-                .ok_or(Error::InvalidData("ipco index overflow"))?,
+                .ok_or_else(|| Error::from(Status::IpcoIndexOverflow))?,
         );
 
         check_parser_state!(b.content);
@@ -3401,7 +3750,7 @@
 }
 
 #[repr(C)]
-#[derive(Clone, Copy, Debug, PartialEq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub struct ImageSpatialExtentsProperty {
     image_width: u32,
     image_height: u32,
@@ -3463,7 +3812,7 @@
     let num_channels_read = src.try_read_to_end(&mut bits_per_channel)?;
 
     if u8::try_from(num_channels_read)? != num_channels {
-        return Err(Error::InvalidData("invalid num_channels"));
+        return Status::PixiBadChannelCount.into();
     }
 
     check_parser_state!(src.content);
@@ -3539,14 +3888,12 @@
                     NUM_RESERVED_BITS,
                     bit_reader.remaining()
                 );
-                return Err(Error::InvalidData("Unexpected size for colr box"));
+                return Status::ColrBadSize.into();
             }
             if bit_reader.read_u8(NUM_RESERVED_BITS)? != 0 {
-                fail_if(
+                fail_with_status_if(
                     strictness != ParseStrictness::Permissive,
-                    "The 7 reserved bits at the end of the ColourInformationBox \
-                     for colour_type == 'nclx' must be 0 \
-                     per ISOBMFF (ISO 14496-12:2020) § 12.1.5.2",
+                    Status::ColrReservedNonzero,
                 )?;
             }
 
@@ -3565,9 +3912,7 @@
         )),
         _ => {
             error!("read_colr colour_type: {:?}", colour_type);
-            Err(Error::InvalidData(
-                "Unsupported colour_type for ColourInformationBox",
-            ))
+            Status::ColrBadType.into()
         }
     }
 }
@@ -3676,7 +4021,7 @@
     if let Some(nul_byte_pos) = aux.iter().position(|&b| b == b'\0') {
         let (a, b) = aux.as_slice().split_at(nul_byte_pos);
         aux_type = a.try_into()?;
-        aux_subtype = (&b[1..]).try_into()?;
+        aux_subtype = (b[1..]).try_into()?;
     } else {
         aux_type = aux;
         aux_subtype = TryVec::new();
@@ -3734,7 +4079,7 @@
                     0 => ConstructionMethod::File,
                     1 => ConstructionMethod::Idat,
                     2 => ConstructionMethod::Item,
-                    _ => return Err(Error::InvalidData("construction_method is taken from the set 0, 1 or 2 per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3"))
+                    _ => return Status::IlocBadConstructionMethod.into(),
                 }
             }
         };
@@ -3749,9 +4094,7 @@
         let extent_count = iloc.read_u16(16)?;
 
         if extent_count < 1 {
-            return Err(Error::InvalidData(
-                "extent_count must have a value 1 or greater per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3",
-            ));
+            return Status::IlocBadExtentCount.into();
         }
 
         // "If only one extent is used (extent_count = 1) then either or both of the
@@ -3759,9 +4102,7 @@
         if extent_count != 1
             && (offset_size == IlocFieldSize::Zero || length_size == IlocFieldSize::Zero)
         {
-            return Err(Error::InvalidData(
-                "extent_count != 1 requires explicit offset and length per ISOBMFF (ISO 14496-12:2020) § 8.11.3.3",
-            ));
+            return Status::IlocBadExtent.into();
         }
 
         let mut extents = TryVec::with_capacity(extent_count.to_usize())?;
@@ -3787,7 +4128,7 @@
             //  the source is implied" (ibid)
             let offset = base_offset
                 .checked_add(extent_offset)
-                .ok_or(Error::InvalidData("offset calculation overflow"))?;
+                .ok_or_else(|| Error::from(Status::IlocOffsetOverflow))?;
             let extent = if extent_length == 0 {
                 Extent::ToEnd { offset }
             } else {
@@ -3806,14 +4147,14 @@
         };
 
         if items.insert(item_id, loc)?.is_some() {
-            return Err(Error::InvalidData("duplicate item_ID in iloc"));
+            return Status::IlocDuplicateItemId.into();
         }
     }
 
     if iloc.remaining() == 0 {
         Ok(items)
     } else {
-        Err(Error::InvalidData("invalid iloc size"))
+        Status::IlocBadSize.into()
     }
 }
 
@@ -3873,7 +4214,7 @@
     // XXX(kinetik): This isn't perfect, as a "moov" with no contents is
     // treated as okay but we haven't found anything useful.  Needs more
     // thought for clearer behaviour here.
-    context.ok_or(Error::NoMoov)
+    context.ok_or(Error::MoovMissing)
 }
 
 /// Parse a Movie Header Box
@@ -3882,7 +4223,7 @@
     let mvhd = read_mvhd(f)?;
     debug!("{:?}", mvhd);
     if mvhd.timescale == 0 {
-        return Err(Error::InvalidData("zero timescale in mdhd"));
+        return Status::MvhdBadTimescale.into();
     }
     let timescale = Some(MediaTimeScale(u64::from(mvhd.timescale)));
     Ok(timescale)
@@ -3961,9 +4302,15 @@
 
         let mut kid = TryVec::<ByteData>::new();
         if version > 0 {
-            let count = be_u32(pssh)?;
+            const KID_ELEMENT_SIZE: usize = 16;
+            let count = be_u32(pssh)?.to_usize();
+            kid.reserve(
+                count
+                    .checked_mul(KID_ELEMENT_SIZE)
+                    .ok_or_else(|| Error::from(Status::PsshSizeOverflow))?,
+            )?;
             for _ in 0..count {
-                let item = read_buf(pssh, 16)?;
+                let item = read_buf(pssh, KID_ELEMENT_SIZE.to_u64())?;
                 kid.push(item)?;
             }
         }
@@ -4009,7 +4356,7 @@
     let fragment_duration = match version {
         1 => be_u64(src)?,
         0 => u64::from(be_u32(src)?),
-        _ => return Err(Error::InvalidData("unhandled mehd version")),
+        _ => return Status::MehdBadVersion.into(),
     };
     Ok(MediaScaledTime(fragment_duration))
 }
@@ -4028,6 +4375,7 @@
             }
             BoxType::EditBox => read_edts(&mut b, track)?,
             BoxType::MediaBox => read_mdia(&mut b, track)?,
+            BoxType::TrackReferenceBox => track.tref = Some(read_tref(&mut b)?),
             _ => skip_box_content(&mut b)?,
         };
         check_parser_state!(b.content);
@@ -4091,7 +4439,7 @@
         duration => Some(TrackScaledTime::<u64>(duration, track.id)),
     };
     if mdhd.timescale == 0 {
-        return Err(Error::InvalidData("zero timescale in mdhd"));
+        return Status::MdhdBadTimescale.into();
     }
     let timescale = Some(TrackTimeScale::<u64>(u64::from(mdhd.timescale), track.id));
     Ok((mdhd, duration, timescale))
@@ -4112,6 +4460,8 @@
 
                 match hdlr.handler_type.value.as_ref() {
                     b"vide" => track.track_type = TrackType::Video,
+                    b"pict" => track.track_type = TrackType::Picture,
+                    b"auxv" => track.track_type = TrackType::AuxiliaryVideo,
                     b"soun" => track.track_type = TrackType::Audio,
                     b"meta" => track.track_type = TrackType::Metadata,
                     _ => (),
@@ -4126,6 +4476,32 @@
     Ok(())
 }
 
+fn read_tref<T: Read>(f: &mut BMFFBox<T>) -> Result<TrackReferenceBox> {
+    // Will likely only see trefs with one auxl
+    let mut references = TryVec::with_capacity(1)?;
+    let mut iter = f.box_iter();
+    while let Some(mut b) = iter.next_box()? {
+        match b.head.name {
+            BoxType::AuxiliaryBox => {
+                references.push(TrackReferenceEntry::Auxiliary(read_tref_auxl(&mut b)?))?
+            }
+            _ => skip_box_content(&mut b)?,
+        };
+        check_parser_state!(b.content);
+    }
+    Ok(TrackReferenceBox { references })
+}
+
+fn read_tref_auxl<T: Read>(f: &mut BMFFBox<T>) -> Result<TrackReference> {
+    let num_track_ids = (f.bytes_left() / std::mem::size_of::<u32>().to_u64()).try_into()?;
+    let mut track_ids = TryVec::with_capacity(num_track_ids)?;
+    for _ in 0..num_track_ids {
+        track_ids.push(be_u32(f)?)?;
+    }
+
+    Ok(TrackReference { track_ids })
+}
+
 fn read_minf<T: Read>(f: &mut BMFFBox<T>, track: &mut Track) -> Result<()> {
     let mut iter = f.box_iter();
     while let Some(mut b) = iter.next_box()? {
@@ -4196,7 +4572,7 @@
     let minor = be_u32(src)?;
     let bytes_left = src.bytes_left();
     if bytes_left % 4 != 0 {
-        return Err(Error::InvalidData("invalid ftyp size"));
+        return Status::FtypBadSize.into();
     }
     // Is a brand_count of zero valid?
     let brand_count = bytes_left / 4;
@@ -4223,7 +4599,7 @@
         0 => {
             skip(src, 8)?;
         }
-        _ => return Err(Error::InvalidData("unhandled mvhd version")),
+        _ => return Status::MvhdBadVersion.into(),
     }
     let timescale = be_u32(src)?;
     let duration = match version {
@@ -4236,7 +4612,7 @@
                 u64::from(d)
             }
         }
-        _ => return Err(Error::InvalidData("unhandled mvhd version")),
+        _ => unreachable!("Should have returned Status::MvhdBadVersion"),
     };
     // Skip remaining fields.
     skip(src, 80)?;
@@ -4259,14 +4635,14 @@
         0 => {
             skip(src, 8)?;
         }
-        _ => return Err(Error::InvalidData("unhandled tkhd version")),
+        _ => return Status::TkhdBadVersion.into(),
     }
     let track_id = be_u32(src)?;
     skip(src, 4)?;
     let duration = match version {
         1 => be_u64(src)?,
         0 => u64::from(be_u32(src)?),
-        _ => return Err(Error::InvalidData("unhandled tkhd version")),
+        _ => unreachable!("Should have returned Status::TkhdBadVersion"),
     };
     // Skip uninteresting fields.
     skip(src, 16)?;
@@ -4311,7 +4687,7 @@
                 // 32 bit segment duration and media times.
                 (u64::from(be_u32(src)?), i64::from(be_i32(src)?))
             }
-            _ => return Err(Error::InvalidData("unhandled elst version")),
+            _ => return Status::ElstBadVersion.into(),
         };
         let media_rate_integer = be_i16(src)?;
         let media_rate_fraction = be_i16(src)?;
@@ -4359,7 +4735,7 @@
             };
             (timescale, duration)
         }
-        _ => return Err(Error::InvalidData("unhandled mdhd version")),
+        _ => return Status::MdhdBadVersion.into(),
     };
 
     // Skip uninteresting fields.
@@ -4453,7 +4829,7 @@
         .checked_mul(8)
         .map_or(true, |bytes| u64::from(bytes) > src.bytes_left())
     {
-        return Err(Error::InvalidData("insufficient data in 'ctts' box"));
+        return Status::CttsBadSize.into();
     }
 
     let mut offsets = TryVec::with_capacity(counts.to_usize())?;
@@ -4468,7 +4844,7 @@
                 (count, offset)
             }
             _ => {
-                return Err(Error::InvalidData("unsupported version in 'ctts' box"));
+                return Status::CttsBadVersion.into();
             }
         };
         offsets.push(TimeOffset {
@@ -4652,9 +5028,7 @@
     let block_type = temp & 0x7f;
     let length = be_u24(src)?.into();
     if length > src.bytes_left() {
-        return Err(Error::InvalidData(
-            "FLACMetadataBlock larger than parent box",
-        ));
+        return Status::DflaBadMetadataBlockSize.into();
     }
     let data = read_buf(src, length)?;
     Ok(FLACMetadataBlock { block_type, data })
@@ -4694,7 +5068,7 @@
         }
 
         if end.to_usize() > remains.len() || u64::from(end) < des.position() {
-            return Err(Error::InvalidData("Invalid descriptor."));
+            return Status::EsdsBadDescriptor.into();
         }
 
         let descriptor = &remains[des.position().try_into()?..end.to_usize()];
@@ -4889,9 +5263,7 @@
             esds.audio_sample_rate = Some(sample_frequency_value);
             esds.audio_channel_count = Some(channel_counts);
             if !esds.decoder_specific_data.is_empty() {
-                return Err(Error::InvalidData(
-                    "There can be only one DecSpecificInfoTag descriptor",
-                ));
+                return Status::EsdsDecSpecificIntoTagQuantity.into();
             }
             esds.decoder_specific_data.extend_from_slice(data)?;
 
@@ -4995,7 +5367,7 @@
         return Err(Error::Unsupported("unknown dfLa (FLAC) version"));
     }
     if flags != 0 {
-        return Err(Error::InvalidData("no-zero dfLa (FLAC) flags"));
+        return Status::DflaFlagsNonzero.into();
     }
     let mut blocks = TryVec::new();
     while src.bytes_left() > 0 {
@@ -5005,15 +5377,11 @@
     // The box must have at least one meta block, and the first block
     // must be the METADATA_BLOCK_STREAMINFO
     if blocks.is_empty() {
-        return Err(Error::InvalidData("FLACSpecificBox missing metadata"));
+        return Status::DflaMissingMetadata.into();
     } else if blocks[0].block_type != 0 {
-        return Err(Error::InvalidData(
-            "FLACSpecificBox must have STREAMINFO metadata first",
-        ));
+        return Status::DflaStreamInfoNotFirst.into();
     } else if blocks[0].data.len() != 34 {
-        return Err(Error::InvalidData(
-            "FLACSpecificBox STREAMINFO block is the wrong size",
-        ));
+        return Status::DflaStreamInfoBadSize.into();
     }
     Ok(FLACSpecificBox { version, blocks })
 }
@@ -5071,7 +5439,7 @@
         Err(e) => return Err(Error::from(e)),
         Ok(bytes) => {
             if bytes != 8 {
-                return Err(Error::InvalidData("Couldn't write OpusHead tag."));
+                return Status::DopsOpusHeadWriteErr.into();
             }
         }
     }
@@ -5094,9 +5462,7 @@
                 Err(e) => return Err(Error::from(e)),
                 Ok(bytes) => {
                     if bytes != table.channel_mapping.len() {
-                        return Err(Error::InvalidData(
-                            "Couldn't write channel mapping table data.",
-                        ));
+                        return Status::DopsChannelMappingWriteErr.into();
                     }
                 }
             }
@@ -5112,15 +5478,13 @@
         return Err(Error::Unsupported("unknown alac (ALAC) version"));
     }
     if flags != 0 {
-        return Err(Error::InvalidData("no-zero alac (ALAC) flags"));
+        return Status::AlacFlagsNonzero.into();
     }
 
     let length = match src.bytes_left() {
         x @ 24 | x @ 48 => x,
         _ => {
-            return Err(Error::InvalidData(
-                "ALACSpecificBox magic cookie is the wrong size",
-            ))
+            return Status::AlacBadMagicCookieSize.into();
         }
     };
     let data = read_buf(src, length)?;
@@ -5133,15 +5497,14 @@
 /// See [\[ISOBMFF\]: reserved (field = 0;) handling is ambiguous](https://github.com/MPEGGroup/FileFormat/issues/36)
 fn read_hdlr<T: Read>(src: &mut BMFFBox<T>, strictness: ParseStrictness) -> Result<HandlerBox> {
     if read_fullbox_version_no_flags(src)? != 0 {
-        return Err(Error::Unsupported("hdlr version"));
+        return Status::HdlrUnsupportedVersion.into();
     }
 
     let pre_defined = be_u32(src)?;
     if pre_defined != 0 {
-        fail_if(
+        fail_with_status_if(
             strictness == ParseStrictness::Strict,
-            "The HandlerBox 'pre_defined' field shall be 0 \
-             per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2",
+            Status::HdlrPredefinedNonzero,
         )?;
     }
 
@@ -5150,10 +5513,9 @@
     for _ in 1..=3 {
         let reserved = be_u32(src)?;
         if reserved != 0 {
-            fail_if(
+            fail_with_status_if(
                 strictness == ParseStrictness::Strict,
-                "The HandlerBox 'reserved' fields shall be 0 \
-                 per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2",
+                Status::HdlrReservedNonzero,
             )?;
         }
     }
@@ -5161,29 +5523,25 @@
     match std::str::from_utf8(src.read_into_try_vec()?.as_slice()) {
         Ok(name) => {
             match name.bytes().filter(|&b| b == b'\0').count() {
-                0 => fail_if(
+                0 => fail_with_status_if(
                     strictness != ParseStrictness::Permissive,
-                    "The HandlerBox 'name' field shall be null-terminated \
-                     per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2",
+                    Status::HdlrNameNoNul,
                 )?,
                 1 => (),
                 n =>
                 // See https://github.com/MPEGGroup/FileFormat/issues/35
                 {
                     error!("Found {} nul bytes in {:x?}", n, name);
-                    fail_if(
+                    fail_with_status_if(
                         strictness == ParseStrictness::Strict,
-                        "The HandlerBox 'name' field shall have a NUL byte \
-                         only in the final position \
-                         per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2",
+                        Status::HdlrNameMultipleNul,
                     )?
                 }
             }
         }
-        Err(_) => fail_if(
+        Err(_) => fail_with_status_if(
             strictness != ParseStrictness::Permissive,
-            "The HandlerBox 'name' field shall be valid utf8 \
-             per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2",
+            Status::HdlrNameNotUtf8,
         )?,
     }
 
@@ -5233,7 +5591,7 @@
                     && name != BoxType::ProtectedVisualSampleEntry)
                     || codec_specific.is_some()
                 {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 let avcc_size = b
                     .head
@@ -5247,7 +5605,7 @@
             }
             BoxType::H263SpecificBox => {
                 if (name != BoxType::H263SampleEntry) || codec_specific.is_some() {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 let h263_dec_spec_struc_size = b
                     .head
@@ -5266,21 +5624,21 @@
                     && name != BoxType::ProtectedVisualSampleEntry)
                     || codec_specific.is_some()
                 {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 let vpcc = read_vpcc(&mut b)?;
                 codec_specific = Some(VideoCodecSpecific::VPxConfig(vpcc));
             }
             BoxType::AV1CodecConfigurationBox => {
                 if name != BoxType::AV1SampleEntry && name != BoxType::ProtectedVisualSampleEntry {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 let av1c = read_av1c(&mut b)?;
                 codec_specific = Some(VideoCodecSpecific::AV1Config(av1c));
             }
             BoxType::ESDBox => {
                 if name != BoxType::MP4VideoSampleEntry || codec_specific.is_some() {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 #[cfg(not(feature = "mp4v"))]
                 {
@@ -5298,7 +5656,7 @@
                 #[cfg(feature = "mp4v")]
                 {
                     // Read ES_Descriptor inside an esds box.
-                    // See ISOBMFF (ISO 14496-1:2010 §7.2.6.5)
+                    // See ISOBMFF (ISO 14496-1:2010) § 7.2.6.5
                     let esds = read_esds(&mut b)?;
                     codec_specific =
                         Some(VideoCodecSpecific::ESDSConfig(esds.decoder_specific_data));
@@ -5306,7 +5664,7 @@
             }
             BoxType::ProtectionSchemeInfoBox => {
                 if name != BoxType::ProtectedVisualSampleEntry {
-                    return Err(Error::InvalidData("malformed video sample entry"));
+                    return Status::StsdBadVideoSampleEntry.into();
                 }
                 let sinf = read_sinf(&mut b)?;
                 debug!("{:?} (sinf)", sinf);
@@ -5347,7 +5705,7 @@
         }
     }
 
-    codec_specific.ok_or(Error::InvalidData("malformed audio sample entry"))
+    codec_specific.ok_or_else(|| Error::from(Status::EsdsBadAudioSampleEntry))
 }
 
 /// Parse an audio description inside an stsd box.
@@ -5424,7 +5782,7 @@
                     && name != BoxType::ProtectedAudioSampleEntry)
                     || codec_specific.is_some()
                 {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let esds = read_esds(&mut b)?;
                 codec_type = esds.audio_codec;
@@ -5434,7 +5792,7 @@
                 if (name != BoxType::FLACSampleEntry && name != BoxType::ProtectedAudioSampleEntry)
                     || codec_specific.is_some()
                 {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let dfla = read_dfla(&mut b)?;
                 codec_type = CodecType::FLAC;
@@ -5444,7 +5802,7 @@
                 if (name != BoxType::OpusSampleEntry && name != BoxType::ProtectedAudioSampleEntry)
                     || codec_specific.is_some()
                 {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let dops = read_dops(&mut b)?;
                 codec_type = CodecType::Opus;
@@ -5452,7 +5810,7 @@
             }
             BoxType::ALACSpecificBox => {
                 if name != BoxType::ALACSpecificBox || codec_specific.is_some() {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let alac = read_alac(&mut b)?;
                 codec_type = CodecType::ALAC;
@@ -5465,7 +5823,7 @@
             }
             BoxType::ProtectionSchemeInfoBox => {
                 if name != BoxType::ProtectedAudioSampleEntry {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let sinf = read_sinf(&mut b)?;
                 debug!("{:?} (sinf)", sinf);
@@ -5475,7 +5833,7 @@
             #[cfg(feature = "3gpp")]
             BoxType::AMRSpecificBox => {
                 if codec_type != CodecType::AMRNB && codec_type != CodecType::AMRWB {
-                    return Err(Error::InvalidData("malformed audio sample entry"));
+                    return Status::StsdBadAudioSampleEntry.into();
                 }
                 let amr_dec_spec_struc_size = b
                     .head
@@ -5513,16 +5871,25 @@
 /// See ISOBMFF (ISO 14496-12:2020) § 8.5.2
 /// See MP4 (ISO 14496-14:2020) § 6.7.2
 fn read_stsd<T: Read>(src: &mut BMFFBox<T>, track: &mut Track) -> Result<SampleDescriptionBox> {
-    let (_, _) = read_fullbox_extra(src)?;
-
-    let description_count = be_u32(src)?;
-    let mut descriptions = TryVec::new();
-
-    {
-        let mut iter = src.box_iter();
-        while let Some(mut b) = iter.next_box()? {
+    let (_, flags) = read_fullbox_extra(src)?;
+
+    if flags != 0 {
+        warn!(
+            "Unexpected `flags` value for SampleDescriptionBox (stsd): {}",
+            flags
+        );
+    }
+
+    let description_count = be_u32(src)?.to_usize();
+    let mut descriptions = TryVec::with_capacity(description_count)?;
+
+    let mut iter = src.box_iter();
+    while descriptions.len() < description_count {
+        if let Some(mut b) = iter.next_box()? {
             let description = match track.track_type {
                 TrackType::Video => read_video_sample_entry(&mut b),
+                TrackType::Picture => read_video_sample_entry(&mut b),
+                TrackType::AuxiliaryVideo => read_video_sample_entry(&mut b),
                 TrackType::Audio => read_audio_sample_entry(&mut b),
                 TrackType::Metadata => Err(Error::Unsupported("metadata track")),
                 TrackType::Unknown => Err(Error::Unsupported("unknown track type")),
@@ -5541,9 +5908,8 @@
             };
             descriptions.push(description)?;
             check_parser_state!(b.content);
-            if descriptions.len() == description_count.to_usize() {
-                break;
-            }
+        } else {
+            break;
         }
     }
 
@@ -5584,9 +5950,7 @@
         match b.head.name {
             BoxType::TrackEncryptionBox => {
                 if tenc.is_some() {
-                    return Err(Error::InvalidData(
-                        "tenc box should be only one at most in sinf box",
-                    ));
+                    return Status::SchiQuantity.into();
                 }
                 tenc = Some(read_tenc(&mut b)?);
             }
@@ -5777,7 +6141,7 @@
             BoxType::CompilationEntry => meta.compilation = read_ilst_bool_data(&mut b)?,
             BoxType::AdvisoryEntry => {
                 meta.advisory = read_ilst_u8_data(&mut b)?.and_then(|rtng| {
-                    Some(match rtng.get(0)? {
+                    Some(match rtng.first()? {
                         2 => AdvisoryRating::Clean,
                         0 => AdvisoryRating::Inoffensive,
                         r => AdvisoryRating::Explicit(*r),
@@ -5786,7 +6150,7 @@
             }
             BoxType::MediaTypeEntry => {
                 meta.media_type = read_ilst_u8_data(&mut b)?.and_then(|stik| {
-                    Some(match stik.get(0)? {
+                    Some(match stik.first()? {
                         0 => MediaType::Movie,
                         1 => MediaType::Normal,
                         2 => MediaType::AudioBook,
@@ -5817,7 +6181,7 @@
 }
 
 fn read_ilst_bool_data<T: Read>(src: &mut BMFFBox<T>) -> Result<Option<bool>> {
-    Ok(read_ilst_u8_data(src)?.and_then(|d| Some(d.get(0)? == &1)))
+    Ok(read_ilst_u8_data(src)?.and_then(|d| Some(d.first()? == &1)))
 }
 
 fn read_ilst_string_data<T: Read>(src: &mut BMFFBox<T>) -> Result<Option<TryString>> {
@@ -5861,7 +6225,7 @@
 fn read_buf<T: Read>(src: &mut T, size: u64) -> Result<TryVec<u8>> {
     let buf = src.take(size).read_into_try_vec()?;
     if buf.len().to_u64() != size {
-        return Err(Error::InvalidData("failed buffer read"));
+        return Status::ReadBufErr.into();
     }
 
     Ok(buf)