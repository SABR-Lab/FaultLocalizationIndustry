# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/generic/LocalAccessible.cpp
# Commit: 227139b26cc2
# Full Hash: 227139b26cc266da35f3e9a9da9f61e18c9d0248
# Author: Morgan Rae Reschenberg <mreschenberg@mozilla.com>
# Date: 2023-02-01 09:43:56
# Regressor Bug: 1809836
# File Overlap Count: 1
# Description:
#   Bug 1809836: Avoid adding scroll offsets when computing bounds for position:fixed accs r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D166730
# ==============================================================================

diff -r 8bd422f41771 -r 227139b26cc2 accessible/generic/LocalAccessible.cpp
--- a/accessible/generic/LocalAccessible.cpp	Tue Jan 31 23:49:06 2023 +0000
+++ b/accessible/generic/LocalAccessible.cpp	Wed Feb 01 01:23:10 2023 +0000
@@ -601,6 +601,11 @@
 
 nsIFrame* LocalAccessible::FindNearestAccessibleAncestorFrame() {
   nsIFrame* frame = GetFrame();
+  if (frame->StyleDisplay()->mPosition == StylePositionProperty::Fixed &&
+      nsLayoutUtils::IsReallyFixedPos(frame)) {
+    return mDoc->PresShellPtr()->GetRootFrame();
+  }
+
   if (IsDoc()) {
     // We bound documents by their own frame, which is their PresShell's root
     // frame. We cache the document offset elsewhere in BundleFieldsForCache
@@ -650,15 +655,23 @@
       }
     }
 
+    if (frame->StyleDisplay()->mPosition == StylePositionProperty::Fixed &&
+        nsLayoutUtils::IsReallyFixedPos(frame)) {
+      // If we're dealing with a fixed position frame, we've already made it
+      // relative to the document which should have gotten rid of its scroll
+      // offset.
+      return result;
+    }
+
     if (nsIScrollableFrame* sf =
             mParent == mDoc
                 ? mDoc->PresShellPtr()->GetRootScrollFrameAsScrollable()
                 : boundingFrame->GetScrollTargetFrame()) {
       // If boundingFrame has a scroll position, result is currently relative
       // to that. Instead, we want result to remain the same regardless of
-      // scrolling. We then subtract the scroll position later when calculating
-      // absolute bounds. We do this because we don't want to push cache
-      // updates for the bounds of all descendants every time we scroll.
+      // scrolling. We then subtract the scroll position later when
+      // calculating absolute bounds. We do this because we don't want to push
+      // cache updates for the bounds of all descendants every time we scroll.
       nsPoint scrollPos = sf->GetScrollPosition().ApplyResolution(
           mDoc->PresShellPtr()->GetResolution());
       result.MoveBy(scrollPos.x, scrollPos.y);
@@ -3592,6 +3605,14 @@
     } else if (aUpdateType == CacheUpdateType::Update) {
       fields->SetAttribute(nsGkAtoms::opacity, DeleteEntry());
     }
+
+    if (frame &&
+        frame->StyleDisplay()->mPosition == StylePositionProperty::Fixed &&
+        nsLayoutUtils::IsReallyFixedPos(frame)) {
+      fields->SetAttribute(nsGkAtoms::position, nsGkAtoms::fixed);
+    } else if (aUpdateType != CacheUpdateType::Initial) {
+      fields->SetAttribute(nsGkAtoms::position, DeleteEntry());
+    }
   }
 
   if (aCacheDomain & CacheDomain::Table) {
@@ -3812,6 +3833,19 @@
       mDoc->QueueCacheUpdate(this, CacheDomain::Style);
     }
 
+    nsAutoCString oldPosition, newPosition;
+    mOldComputedStyle->GetComputedPropertyValue(eCSSProperty_position,
+                                                oldPosition);
+    newStyle->GetComputedPropertyValue(eCSSProperty_position, newPosition);
+
+    if (oldPosition != newPosition) {
+      RefPtr<nsAtom> oldAtom = NS_Atomize(oldPosition);
+      RefPtr<nsAtom> newAtom = NS_Atomize(newPosition);
+      if (oldAtom == nsGkAtoms::fixed || newAtom == nsGkAtoms::fixed) {
+        mDoc->QueueCacheUpdate(this, CacheDomain::Style);
+      }
+    }
+
     bool newHasValidTransformStyle =
         newStyle->StyleDisplay()->HasTransform(frame);
     bool oldHasValidTransformStyle =