# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/tests/browser/scroll/browser_test_scroll_bounds.js
# Commit: 227139b26cc2
# Full Hash: 227139b26cc266da35f3e9a9da9f61e18c9d0248
# Author: Morgan Rae Reschenberg <mreschenberg@mozilla.com>
# Date: 2023-02-01 09:43:56
# Regressor Bug: 1809836
# File Overlap Count: 1
# Description:
#   Bug 1809836: Avoid adding scroll offsets when computing bounds for position:fixed accs r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D166730
# ==============================================================================

diff -r 8bd422f41771 -r 227139b26cc2 accessible/tests/browser/scroll/browser_test_scroll_bounds.js
--- a/accessible/tests/browser/scroll/browser_test_scroll_bounds.js	Tue Jan 31 23:49:06 2023 +0000
+++ b/accessible/tests/browser/scroll/browser_test_scroll_bounds.js	Wed Feb 01 01:23:10 2023 +0000
@@ -6,6 +6,7 @@
 
 /* import-globals-from ../../mochitest/layout.js */
 loadScripts({ name: "layout.js", dir: MOCHITESTS_DIR });
+requestLongerTimeout(2);
 
 const appUnitsPerDevPixel = 60;
 
@@ -146,3 +147,170 @@
   },
   { iframe: true, remoteIframe: true }
 );
+
+/**
+ * Test scroll offset fixed-pos acc accs
+ */
+addAccessibleTask(
+  `
+  <div style="margin-top: 100px; margin-left: 75px; border: 1px solid;">
+    <div id="d" style="position:fixed;">
+      <button id="top">top</button>
+    </div>
+  </div>
+  `,
+  async function(browser, docAcc) {
+    const origTopBounds = await testBoundsWithContent(docAcc, "top", browser);
+    const origDBounds = await testBoundsWithContent(docAcc, "d", browser);
+    const e = waitForEvent(EVENT_REORDER, docAcc);
+    await invokeContentTask(browser, [], () => {
+      for (let i = 0; i < 1000; ++i) {
+        const div = content.document.createElement("div");
+        div.innerHTML = "<button>${i}</button>";
+        content.document.body.append(div);
+      }
+    });
+    await e;
+
+    await invokeContentTask(browser, [], () => {
+      // scroll to the bottom of the page
+      content.window.scrollTo(0, content.document.body.scrollHeight);
+    });
+
+    await waitForContentPaint(browser);
+
+    let newTopBounds = await testBoundsWithContent(docAcc, "top", browser);
+    let newDBounds = await testBoundsWithContent(docAcc, "d", browser);
+    is(
+      origTopBounds[0],
+      newTopBounds[0],
+      "x of fixed elem is unaffected by scrolling"
+    );
+    is(
+      origTopBounds[1],
+      newTopBounds[1],
+      "y of fixed elem is unaffected by scrolling"
+    );
+    is(
+      origTopBounds[2],
+      newTopBounds[2],
+      "width of fixed elem is unaffected by scrolling"
+    );
+    is(
+      origTopBounds[3],
+      newTopBounds[3],
+      "height of fixed elem is unaffected by scrolling"
+    );
+    is(
+      origDBounds[0],
+      newTopBounds[0],
+      "x of fixed elem container is unaffected by scrolling"
+    );
+    is(
+      origDBounds[1],
+      newDBounds[1],
+      "y of fixed elem container is unaffected by scrolling"
+    );
+    is(
+      origDBounds[2],
+      newDBounds[2],
+      "width of fixed container elem is unaffected by scrolling"
+    );
+    is(
+      origDBounds[3],
+      newDBounds[3],
+      "height of fixed container elem is unaffected by scrolling"
+    );
+
+    await invokeContentTask(browser, [], () => {
+      // remove position styling
+      content.document.getElementById("d").style = "";
+    });
+
+    await waitForContentPaint(browser);
+
+    newTopBounds = await testBoundsWithContent(docAcc, "top", browser);
+    newDBounds = await testBoundsWithContent(docAcc, "d", browser);
+    is(
+      origTopBounds[0],
+      newTopBounds[0],
+      "x of non-fixed element remains accurate."
+    );
+    ok(newTopBounds[1] < 0, "y coordinate shows item scrolled off page");
+    is(
+      origTopBounds[2],
+      newTopBounds[2],
+      "width of non-fixed element remains accurate."
+    );
+    is(
+      origTopBounds[3],
+      newTopBounds[3],
+      "height of non-fixed element remains accurate."
+    );
+    is(
+      origDBounds[0],
+      newDBounds[0],
+      "x of non-fixed container element remains accurate."
+    );
+    ok(newDBounds[1] < 0, "y coordinate shows container scrolled off page");
+    // Removing the position styling on this acc causes it to be bound by
+    // its parent's bounding box, which alters its width as a block element.
+    // We don't particularly care about width in this test, so skip it.
+    is(
+      origDBounds[3],
+      newDBounds[3],
+      "height of non-fixed container element remains accurate."
+    );
+
+    await invokeContentTask(browser, [], () => {
+      // re-add position styling
+      content.document.getElementById("d").style = "position:fixed;";
+    });
+
+    await waitForContentPaint(browser);
+
+    newTopBounds = await testBoundsWithContent(docAcc, "top", browser);
+    newDBounds = await testBoundsWithContent(docAcc, "d", browser);
+    is(
+      origTopBounds[0],
+      newTopBounds[0],
+      "x correct when position:fixed is added."
+    );
+    is(
+      origTopBounds[1],
+      newTopBounds[1],
+      "y correct when position:fixed is added."
+    );
+    is(
+      origTopBounds[2],
+      newTopBounds[2],
+      "width correct when position:fixed is added."
+    );
+    is(
+      origTopBounds[3],
+      newTopBounds[3],
+      "height correct when position:fixed is added."
+    );
+    is(
+      origDBounds[0],
+      newDBounds[0],
+      "x of container correct when position:fixed is added."
+    );
+    is(
+      origDBounds[1],
+      newDBounds[1],
+      "y of container correct when position:fixed is added."
+    );
+    is(
+      origDBounds[2],
+      newDBounds[2],
+      "width of container correct when position:fixed is added."
+    );
+    is(
+      origDBounds[3],
+      newDBounds[3],
+      "height of container correct when position:fixed is added."
+    );
+  },
+  { chrome: true, iframe: true, remoteIframe: true }
+);