# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/xul/XULButtonElement.h
# Commit: 47c002d36372
# Full Hash: 47c002d3637247e71ee901f32421deaecc9d8ea3
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-01-05 03:40:49
# Regressor Bug: 1805414
# File Overlap Count: 2
# Description:
#   Bug 1805414 - Remove nsMenuFrame and nsMenuParent. r=smaug,Jamie,desktop-theme-reviewers,settings-reviewers,dao
#   
#   Move most the event handling stuff to the DOM. I've left nsMenuBarFrame
#   for now, but I will be removing that in the future.
#   
# ==============================================================================

diff -r 0c989b2bcd78 -r 47c002d36372 dom/xul/XULButtonElement.h
--- a/dom/xul/XULButtonElement.h	Wed Jan 04 18:28:34 2023 +0000
+++ b/dom/xul/XULButtonElement.h	Wed Jan 04 19:01:13 2023 +0000
@@ -7,25 +7,114 @@
 #ifndef dom_xul_XULButtonElement_h__
 #define dom_xul_XULButtonElement_h__
 
+#include "mozilla/Attributes.h"
+#include "nsINode.h"
 #include "nsXULElement.h"
 
+class nsMenuBarFrame;
+class nsMenuPopupFrame;
+class nsXULMenuCommandEvent;
+
 namespace mozilla::dom {
 
-class XULButtonElement final : public nsXULElement {
+class KeyboardEvent;
+class XULPopupElement;
+class XULMenuParentElement;
+
+class XULButtonElement : public nsXULElement {
  public:
   explicit XULButtonElement(
-      already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo)
-      : nsXULElement(std::move(aNodeInfo)) {}
+      already_AddRefed<mozilla::dom::NodeInfo>&& aNodeInfo);
+
+  ~XULButtonElement() override;
 
   MOZ_CAN_RUN_SCRIPT_BOUNDARY bool MouseClicked(WidgetGUIEvent&);
   MOZ_CAN_RUN_SCRIPT nsresult PostHandleEvent(EventChainPostVisitor&) override;
+  MOZ_CAN_RUN_SCRIPT void PostHandleEventForMenus(EventChainPostVisitor&);
+  MOZ_CAN_RUN_SCRIPT void HandleEnterKeyPress(WidgetEvent&);
+
+  void PopupOpened();
+  MOZ_CAN_RUN_SCRIPT void PopupClosed(bool aDeselectMenu);
+
+  XULPopupElement* GetContainingPopupElement() const;
+  nsMenuPopupFrame* GetContainingPopupWithoutFlushing() const;
+  MOZ_CAN_RUN_SCRIPT void ToggleMenuState();
+  bool IsMenuPopupOpen();
+
+  bool IsMenuItem() const { return NodeInfo()->Equals(nsGkAtoms::menuitem); }
+  bool IsMenuList() const { return NodeInfo()->Equals(nsGkAtoms::menulist); }
+  bool IsMenuActive() const;
+  MOZ_CAN_RUN_SCRIPT void OpenMenuPopup(bool aSelectFirstItem);
+  void CloseMenuPopup(bool aDeselectMenu);
+
+  bool IsOnMenu() const;
+  bool IsOnMenuList() const;
+  bool IsOnMenuBar() const;
+  bool IsOnContextMenu() const;
+
+  XULMenuParentElement* GetMenuParent() const;
+
+  void UnbindFromTree(bool aNullParent) override;
+
+  MOZ_CAN_RUN_SCRIPT bool HandleKeyPress(KeyboardEvent& keyEvent);
+  MOZ_CAN_RUN_SCRIPT bool OpenedWithKey();
+  // Called to execute our command handler.
+  MOZ_CAN_RUN_SCRIPT void ExecuteMenu(WidgetEvent&);
+  MOZ_CAN_RUN_SCRIPT void ExecuteMenu(Modifiers, int16_t aButton,
+                                      bool aIsTrusted);
+
+  // Whether we are a menu/menulist/menuitem element.
+  bool IsAlwaysMenu() const { return mIsAlwaysMenu; }
+  // Whether we should behave like a menu. This is the above plus buttons with
+  // type=menu attribute.
+  bool IsMenu() const;
 
   nsChangeHint GetAttributeChangeHint(const nsAtom* aAttribute,
                                       int32_t aModType) const override;
+  nsresult AfterSetAttr(int32_t aNamespaceID, nsAtom* aName,
+                        const nsAttrValue* aValue, const nsAttrValue* aOldValue,
+                        nsIPrincipal* aSubjectPrincipal, bool aNotify) override;
+
+  NS_IMPL_FROMNODE_HELPER(XULButtonElement,
+                          IsAnyOfXULElements(nsGkAtoms::checkbox,
+                                             nsGkAtoms::radio, nsGkAtoms::thumb,
+                                             nsGkAtoms::button, nsGkAtoms::menu,
+                                             nsGkAtoms::menulist,
+                                             nsGkAtoms::menuitem,
+                                             nsGkAtoms::toolbarbutton,
+                                             nsGkAtoms::toolbarpaletteitem,
+                                             nsGkAtoms::scrollbarbutton))
+
+  nsMenuPopupFrame* GetMenuPopup(FlushType aFlushType);
+  nsMenuPopupFrame* GetMenuPopupWithoutFlushing() const;
+  XULPopupElement* GetMenuPopupContent() const;
+  int32_t MenuOpenCloseDelay() const;
+
+  bool IsDisabled() const { return GetXULBoolAttr(nsGkAtoms::disabled); }
 
  private:
   void Blurred();
+  nsMenuBarFrame* GetMenuBar(FlushType aFlushType);
+  enum class MenuType {
+    Checkbox,
+    Radio,
+    Normal,
+  };
+  Maybe<MenuType> GetMenuType() const;
+
+  void UncheckRadioSiblings();
+  void StopBlinking();
+  MOZ_CAN_RUN_SCRIPT void StartBlinking();
+  void KillMenuOpenTimer();
+  MOZ_CAN_RUN_SCRIPT void PassMenuCommandEventToPopupManager();
+
   bool mIsHandlingKeyEvent = false;
+
+  // Whether this is a XULMenuElement.
+  const bool mIsAlwaysMenu;
+  RefPtr<nsXULMenuCommandEvent> mDelayedMenuCommandEvent;
+  nsCOMPtr<nsITimer> mMenuOpenTimer;
+  nsCOMPtr<nsITimer> mMenuBlinkTimer;
 };
 
 }  // namespace mozilla::dom