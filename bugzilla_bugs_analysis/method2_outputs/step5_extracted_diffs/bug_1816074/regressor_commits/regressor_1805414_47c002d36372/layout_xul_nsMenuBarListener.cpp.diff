# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/xul/nsMenuBarListener.cpp
# Commit: 47c002d36372
# Full Hash: 47c002d3637247e71ee901f32421deaecc9d8ea3
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-01-05 03:40:49
# Regressor Bug: 1805414
# File Overlap Count: 2
# Description:
#   Bug 1805414 - Remove nsMenuFrame and nsMenuParent. r=smaug,Jamie,desktop-theme-reviewers,settings-reviewers,dao
#   
#   Move most the event handling stuff to the DOM. I've left nsMenuBarFrame
#   for now, but I will be removing that in the future.
#   
# ==============================================================================

diff -r 0c989b2bcd78 -r 47c002d36372 layout/xul/nsMenuBarListener.cpp
--- a/layout/xul/nsMenuBarListener.cpp	Wed Jan 04 18:28:34 2023 +0000
+++ b/layout/xul/nsMenuBarListener.cpp	Wed Jan 04 19:01:13 2023 +0000
@@ -5,9 +5,13 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMenuBarListener.h"
+#include "XULButtonElement.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/XULButtonElement.h"
 #include "nsMenuBarFrame.h"
 #include "nsMenuPopupFrame.h"
 #include "nsPIWindowRoot.h"
+#include "nsISound.h"
 
 // Drag & Drop, Clipboard
 #include "nsWidgetsCID.h"
@@ -24,6 +28,8 @@
 #include "mozilla/dom/EventBinding.h"
 #include "mozilla/dom/KeyboardEvent.h"
 #include "mozilla/dom/KeyboardEventBinding.h"
+#include "mozilla/dom/XULMenuParentElement.h"
+#include "nsXULPopupManager.h"
 
 using namespace mozilla;
 using mozilla::dom::Event;
@@ -43,12 +49,13 @@
 nsMenuBarListener::nsMenuBarListener(nsMenuBarFrame* aMenuBarFrame,
                                      nsIContent* aMenuBarContent)
     : mMenuBarFrame(aMenuBarFrame),
-      mEventTarget(aMenuBarContent ? aMenuBarContent->GetComposedDoc()
-                                   : nullptr),
+      mContent(dom::XULMenuParentElement::FromNode(aMenuBarContent)),
+      mEventTarget(aMenuBarContent->GetComposedDoc()),
       mTopWindowEventTarget(nullptr),
       mAccessKeyDown(false),
       mAccessKeyDownCanceled(false) {
   MOZ_ASSERT(mEventTarget);
+  MOZ_ASSERT(mContent);
 
   // Hook up the menubar as a key listener on the whole document.  This will
   // see every keypress that occurs, but after everyone else does.
@@ -152,12 +159,12 @@
 }
 
 void nsMenuBarListener::ToggleMenuActiveState() {
-  nsMenuFrame* closemenu = mMenuBarFrame->ToggleMenuActiveState();
-  nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-  if (pm && closemenu) {
-    nsMenuPopupFrame* popupFrame = closemenu->GetPopup();
-    if (popupFrame)
-      pm->HidePopup(popupFrame->GetContent(), false, false, true, false);
+  if (mMenuBarFrame->IsActive()) {
+    mMenuBarFrame->SetActive(false);
+  } else {
+    RefPtr content = mContent;
+    mMenuBarFrame->SetActive(true);
+    content->SelectFirstItem();
   }
 }
 
@@ -199,8 +206,7 @@
       // First, close all existing popups because other popups shouldn't
       // handle key events when menubar is active and IME should be
       // disabled.
-      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-      if (pm) {
+      if (nsXULPopupManager* pm = nsXULPopupManager::GetInstance()) {
         pm->Rollup(0, false, nullptr, nullptr);
       }
       // If menubar active state is changed or the menubar is destroyed
@@ -260,7 +266,7 @@
 #ifndef XP_MACOSX
     // Need to handle F10 specially on Non-Mac platform.
     if (nativeKeyEvent->mMessage == eKeyPress && keyCode == NS_VK_F10) {
-      if ((GetModifiersForAccessKey(keyEvent) & ~MODIFIER_CONTROL) == 0) {
+      if ((GetModifiersForAccessKey(*keyEvent) & ~MODIFIER_CONTROL) == 0) {
         // If the keyboard event should activate the menubar and will be
         // sent to a remote process, it should be executed with reply
         // event from the focused remote process.  Note that if the menubar
@@ -279,8 +285,9 @@
 
         if (mMenuBarFrame->IsActive()) {
 #  ifdef MOZ_WIDGET_GTK
+          RefPtr child = mContent->GetActiveMenuChild();
           // In GTK, this also opens the first menu.
-          mMenuBarFrame->GetCurrentMenuItem()->OpenMenu(false);
+          child->OpenMenuPopup(false);
 #  endif
           aKeyEvent->StopPropagation();
           aKeyEvent->PreventDefault();
@@ -291,8 +298,20 @@
     }
 #endif  // !XP_MACOSX
 
-    nsMenuFrame* menuFrameForKey = GetMenuForKeyEvent(keyEvent, false);
-    if (!menuFrameForKey) {
+    RefPtr menuForKey = GetMenuForKeyEvent(*keyEvent);
+    if (!menuForKey) {
+#ifdef XP_WIN
+      // Behavior on Windows - this item is on the menu bar, beep and deactivate
+      // the menu bar.
+      // TODO(emilio): This is rather odd, and I cannot get the beep to work,
+      // but this matches what old code was doing...
+      if (mMenuBarFrame->IsActive()) {
+        if (nsCOMPtr<nsISound> sound = do_GetService("@mozilla.org/sound;1")) {
+          sound->Beep();
+        }
+        mMenuBarFrame->SetActive(false);
+      }
+#endif
       return NS_OK;
     }
 
@@ -310,7 +329,7 @@
 
     mMenuBarFrame->SetActiveByKeyboard();
     mMenuBarFrame->SetActive(true);
-    menuFrameForKey->OpenMenu(true);
+    menuForKey->OpenMenuPopup(true);
 
     // The opened menu will listen next keyup event.
     // Therefore, we should clear the keydown flags here.
@@ -323,7 +342,7 @@
   return NS_OK;
 }
 
-bool nsMenuBarListener::IsAccessKeyPressed(KeyboardEvent* aKeyEvent) {
+bool nsMenuBarListener::IsAccessKeyPressed(KeyboardEvent& aKeyEvent) {
   InitAccessKey();
   // No other modifiers are allowed to be down except for Shift.
   uint32_t modifiers = GetModifiersForAccessKey(aKeyEvent);
@@ -333,41 +352,39 @@
 }
 
 Modifiers nsMenuBarListener::GetModifiersForAccessKey(
-    KeyboardEvent* aKeyEvent) {
-  WidgetInputEvent* inputEvent = aKeyEvent->WidgetEventPtr()->AsInputEvent();
+    KeyboardEvent& aKeyEvent) {
+  WidgetInputEvent* inputEvent = aKeyEvent.WidgetEventPtr()->AsInputEvent();
   MOZ_ASSERT(inputEvent);
 
   static const Modifiers kPossibleModifiersForAccessKey =
       (MODIFIER_SHIFT | MODIFIER_CONTROL | MODIFIER_ALT | MODIFIER_META |
        MODIFIER_OS);
-  return (inputEvent->mModifiers & kPossibleModifiersForAccessKey);
+  return inputEvent->mModifiers & kPossibleModifiersForAccessKey;
 }
 
-nsMenuFrame* nsMenuBarListener::GetMenuForKeyEvent(KeyboardEvent* aKeyEvent,
-                                                   bool aPeek) {
+dom::XULButtonElement* nsMenuBarListener::GetMenuForKeyEvent(
+    KeyboardEvent& aKeyEvent) {
   if (!IsAccessKeyPressed(aKeyEvent)) {
     return nullptr;
   }
 
-  uint32_t charCode = aKeyEvent->CharCode();
+  uint32_t charCode = aKeyEvent.CharCode();
   bool hasAccessKeyCandidates = charCode != 0;
   if (!hasAccessKeyCandidates) {
     WidgetKeyboardEvent* nativeKeyEvent =
-        aKeyEvent->WidgetEventPtr()->AsKeyboardEvent();
-
+        aKeyEvent.WidgetEventPtr()->AsKeyboardEvent();
     AutoTArray<uint32_t, 10> keys;
     nativeKeyEvent->GetAccessKeyCandidates(keys);
     hasAccessKeyCandidates = !keys.IsEmpty();
   }
 
-  if (hasAccessKeyCandidates) {
-    // Do shortcut navigation.
-    // A letter was pressed. We want to see if a shortcut gets matched. If
-    // so, we'll know the menu got activated.
-    return mMenuBarFrame->FindMenuWithShortcut(aKeyEvent, aPeek);
+  if (!hasAccessKeyCandidates) {
+    return nullptr;
   }
-
-  return nullptr;
+  // Do shortcut navigation.
+  // A letter was pressed. We want to see if a shortcut gets matched. If
+  // so, we'll know the menu got activated.
+  return mMenuBarFrame->MenubarElement().FindMenuWithShortcut(aKeyEvent);
 }
 
 void nsMenuBarListener::ReserveKeyIfNeeded(Event* aKeyEvent) {
@@ -399,7 +416,7 @@
 
 #ifndef XP_MACOSX
   if (capturing && !mAccessKeyDown && theChar == NS_VK_F10 &&
-      (GetModifiersForAccessKey(keyEvent) & ~MODIFIER_CONTROL) == 0) {
+      (GetModifiersForAccessKey(*keyEvent) & ~MODIFIER_CONTROL) == 0) {
     ReserveKeyIfNeeded(aKeyEvent);
   }
 #endif
@@ -412,7 +429,7 @@
     // enhanced 102-key keyboards if we don't check this.
     bool isAccessKeyDownEvent =
         ((theChar == (uint32_t)mAccessKey) &&
-         (GetModifiersForAccessKey(keyEvent) & ~mAccessKeyMask) == 0);
+         (GetModifiersForAccessKey(*keyEvent) & ~mAccessKeyMask) == 0);
 
     if (!capturing && !mAccessKeyDown) {
       // If accesskey isn't being pressed and the key isn't the accesskey,
@@ -440,8 +457,7 @@
   }
 
   if (capturing && mAccessKey) {
-    nsMenuFrame* menuFrameForKey = GetMenuForKeyEvent(keyEvent, true);
-    if (menuFrameForKey) {
+    if (GetMenuForKeyEvent(*keyEvent)) {
       ReserveKeyIfNeeded(aKeyEvent);
     }
   }
@@ -452,7 +468,7 @@
 ////////////////////////////////////////////////////////////////////////
 
 nsresult nsMenuBarListener::Blur(Event* aEvent) {
-  if (!mMenuBarFrame->IsMenuOpen() && mMenuBarFrame->IsActive()) {
+  if (!IsMenuOpen() && mMenuBarFrame->IsActive()) {
     ToggleMenuActiveState();
     mAccessKeyDown = false;
     mAccessKeyDownCanceled = false;
@@ -470,6 +486,11 @@
   return NS_OK;  // means I am NOT consuming event
 }
 
+bool nsMenuBarListener::IsMenuOpen() const {
+  auto* activeChild = mContent->GetActiveMenuChild();
+  return activeChild && activeChild->IsMenuPopupOpen();
+}
+
 ////////////////////////////////////////////////////////////////////////
 nsresult nsMenuBarListener::MouseDown(Event* aMouseEvent) {
   // NOTE: MouseDown method listens all phases
@@ -486,8 +507,9 @@
     return NS_OK;
   }
 
-  if (!mMenuBarFrame->IsMenuOpen() && mMenuBarFrame->IsActive())
+  if (!IsMenuOpen() && mMenuBarFrame->IsActive()) {
     ToggleMenuActiveState();
+  }
 
   return NS_OK;  // means I am NOT consuming event
 }
@@ -502,7 +524,8 @@
 }
 
 ////////////////////////////////////////////////////////////////////////
-nsresult nsMenuBarListener::HandleEvent(Event* aEvent) {
+MOZ_CAN_RUN_SCRIPT_BOUNDARY nsresult
+nsMenuBarListener::HandleEvent(Event* aEvent) {
   // If the menu bar is collapsed, don't do anything.
   if (!mMenuBarFrame->StyleVisibility()->IsVisible()) {
     return NS_OK;