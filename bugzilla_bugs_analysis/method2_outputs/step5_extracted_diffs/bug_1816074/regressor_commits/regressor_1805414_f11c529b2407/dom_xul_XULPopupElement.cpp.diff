# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/xul/XULPopupElement.cpp
# Commit: f11c529b2407
# Full Hash: f11c529b240799df93c4dd8c17ecd8636f9b10de
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-01-04 09:43:05
# Regressor Bug: 1805414
# File Overlap Count: 2
# Description:
#   Bug 1805414 - Remove nsMenuFrame and nsMenuParent. r=smaug,Jamie,desktop-theme-reviewers,settings-reviewers,dao
#   
#   Move most the event handling stuff to the DOM. I've left nsMenuBarFrame
#   for now, but I will be removing that in the future.
#   
# ==============================================================================

diff -r 11d72eaa9cd9 -r f11c529b2407 dom/xul/XULPopupElement.cpp
--- a/dom/xul/XULPopupElement.cpp	Tue Jan 03 21:55:14 2023 +0000
+++ b/dom/xul/XULPopupElement.cpp	Tue Jan 03 22:06:01 2023 +0000
@@ -4,18 +4,23 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "XULMenuParentElement.h"
 #include "nsCOMPtr.h"
 #include "nsIContent.h"
+#include "nsMenuBarListener.h"
 #include "nsNameSpaceManager.h"
 #include "nsGkAtoms.h"
 #include "nsMenuPopupFrame.h"
 #include "nsView.h"
 #include "mozilla/AppUnits.h"
+#include "mozilla/AsyncEventDispatcher.h"
 #include "mozilla/dom/DOMRect.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/XULPopupElement.h"
+#include "mozilla/dom/XULButtonElement.h"
+#include "mozilla/dom/XULMenuElement.h"
 #include "mozilla/dom/XULPopupElementBinding.h"
 #ifdef MOZ_WAYLAND
 #  include "mozilla/WidgetUtilsGtk.h"
@@ -35,6 +40,12 @@
   return XULPopupElement_Binding::Wrap(aCx, this, aGivenProto);
 }
 
+nsMenuPopupFrame* XULPopupElement::GetFrame(FlushType aFlushType) {
+  nsIFrame* f = GetPrimaryFrame(aFlushType);
+  MOZ_ASSERT(!f || f->IsMenuPopupFrame());
+  return static_cast<nsMenuPopupFrame*>(f);
+}
+
 void XULPopupElement::OpenPopup(Element* aAnchorElement,
                                 const StringOrOpenPopupOptions& aOptions,
                                 int32_t aXPos, int32_t aYPos,
@@ -59,9 +70,8 @@
     // are specified, open the popup with ShowMenu instead of ShowPopup so that
     // the popup is aligned with the menu.
     if (!aAnchorElement && position.IsEmpty() && GetPrimaryFrame()) {
-      nsMenuFrame* menu = do_QueryFrame(GetPrimaryFrame()->GetParent());
-      if (menu) {
-        pm->ShowMenu(menu->GetContent(), false);
+      if (auto* menu = GetContainingMenu()) {
+        pm->ShowMenu(menu, false);
         return;
       }
     }
@@ -118,6 +128,36 @@
   return modifiers;
 }
 
+XULButtonElement* XULPopupElement::GetContainingMenu() const {
+  auto* button = XULButtonElement::FromNodeOrNull(GetParent());
+  if (!button || !button->IsMenu()) {
+    return nullptr;
+  }
+  return button;
+}
+
+void XULPopupElement::PopupOpened(bool aSelectFirstItem) {
+  if (aSelectFirstItem) {
+    SelectFirstItem();
+  }
+  if (RefPtr button = GetContainingMenu()) {
+    if (RefPtr parent = button->GetMenuParent()) {
+      parent->SetActiveMenuChild(button);
+    }
+  }
+}
+
+void XULPopupElement::PopupClosed(bool aDeselectMenu) {
+  LockMenuUntilClosed(false);
+  SetActiveMenuChild(nullptr);
+  auto dispatcher = MakeRefPtr<AsyncEventDispatcher>(
+      this, u"DOMMenuInactive"_ns, CanBubble::eYes, ChromeOnlyDispatch::eNo);
+  dispatcher->PostDOMEvent();
+  if (RefPtr button = GetContainingMenu()) {
+    button->PopupClosed(aDeselectMenu);
+  }
+}
+
 void XULPopupElement::ActivateItem(Element& aItemElement,
                                    const ActivateMenuItemOptions& aOptions,
                                    ErrorResult& aRv) {
@@ -135,19 +175,29 @@
     }
   }
 
-  // Used only to flush frames.
-  GetPrimaryFrame(FlushType::Frames);
+  auto* item = XULButtonElement::FromNode(aItemElement);
+  if (!item || !item->IsMenu()) {
+    return aRv.ThrowInvalidStateError("Not a menu item");
+  }
 
-  nsMenuFrame* itemFrame = do_QueryFrame(aItemElement.GetPrimaryFrame());
-  if (!itemFrame) {
-    return aRv.ThrowInvalidStateError("Menu item is not visible");
+  if (!item->GetPrimaryFrame(FlushType::Frames)) {
+    return aRv.ThrowInvalidStateError("Menu item is hidden");
   }
 
-  if (!itemFrame->GetMenuParent() || !itemFrame->GetMenuParent()->IsOpen()) {
-    return aRv.ThrowInvalidStateError("Menu is closed");
+  auto* popup = item->GetContainingPopupElement();
+  if (!popup) {
+    return aRv.ThrowInvalidStateError("No popup");
   }
 
-  itemFrame->ActivateItem(modifiers, aOptions.mButton);
+  nsMenuPopupFrame* frame = popup->GetFrame(FlushType::None);
+  if (!frame || !frame->IsOpen()) {
+    return aRv.ThrowInvalidStateError("Popup is not open");
+  }
+
+  // This is a chrome-only API, so we're trusted.
+  const bool trusted = true;
+  // KnownLive because item is aItemElement.
+  MOZ_KnownLive(item)->ExecuteMenu(modifiers, aOptions.mButton, trusted);
 }
 
 void XULPopupElement::MoveTo(int32_t aLeft, int32_t aTop) {
@@ -160,7 +210,7 @@
 void XULPopupElement::MoveToAnchor(Element* aAnchorElement,
                                    const nsAString& aPosition, int32_t aXPos,
                                    int32_t aYPos, bool aAttributesOverride) {
-  nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetPrimaryFrame());
+  nsMenuPopupFrame* menuPopupFrame = GetFrame(FlushType::None);
   if (menuPopupFrame && menuPopupFrame->IsVisibleOrShowing()) {
     menuPopupFrame->MoveToAnchor(aAnchorElement, aPosition, aXPos, aYPos,
                                  aAttributesOverride);