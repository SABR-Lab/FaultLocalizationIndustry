# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/nsNativeThemeWin.cpp
# Commit: f11c529b2407
# Full Hash: f11c529b240799df93c4dd8c17ecd8636f9b10de
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-01-04 09:43:05
# Regressor Bug: 1805414
# File Overlap Count: 2
# Description:
#   Bug 1805414 - Remove nsMenuFrame and nsMenuParent. r=smaug,Jamie,desktop-theme-reviewers,settings-reviewers,dao
#   
#   Move most the event handling stuff to the DOM. I've left nsMenuBarFrame
#   for now, but I will be removing that in the future.
#   
# ==============================================================================

diff -r 11d72eaa9cd9 -r f11c529b2407 widget/windows/nsNativeThemeWin.cpp
--- a/widget/windows/nsNativeThemeWin.cpp	Tue Jan 03 21:55:14 2023 +0000
+++ b/widget/windows/nsNativeThemeWin.cpp	Tue Jan 03 22:06:01 2023 +0000
@@ -20,6 +20,7 @@
 #include "mozilla/StaticPrefs_layout.h"
 #include "mozilla/StaticPrefs_widget.h"
 #include "mozilla/WindowsVersion.h"
+#include "mozilla/dom/XULButtonElement.h"
 #include "nsColor.h"
 #include "nsComboboxControlFrame.h"
 #include "nsDeviceContext.h"
@@ -29,7 +30,6 @@
 #include "nsIFrame.h"
 #include "nsLayoutUtils.h"
 #include "nsLookAndFeel.h"
-#include "nsMenuFrame.h"
 #include "nsNameSpaceManager.h"
 #include "Theme.h"
 #include "nsPresContext.h"
@@ -132,12 +132,8 @@
 }
 
 static bool IsTopLevelMenu(nsIFrame* aFrame) {
-  bool isTopLevel(false);
-  nsMenuFrame* menuFrame = do_QueryFrame(aFrame);
-  if (menuFrame) {
-    isTopLevel = menuFrame->IsOnMenuBar();
-  }
-  return isTopLevel;
+  auto* menu = dom::XULButtonElement::FromNodeOrNull(aFrame->GetContent());
+  return menu && menu->IsOnMenuBar();
 }
 
 static MARGINS GetCheckboxMargins(HANDLE theme, HDC hdc) {
@@ -1167,14 +1163,12 @@
       return NS_OK;
     }
     case StyleAppearance::MozMenulistArrowButton: {
-      bool isHTML = IsHTMLContent(aFrame);
-      nsIFrame* parentFrame = aFrame->GetParent();
-      bool isMenulist = !isHTML && parentFrame->IsMenuFrame();
       bool isOpen = false;
 
       // HTML select and XUL menulist dropdown buttons get state from the
       // parent.
-      if (isHTML || isMenulist) aFrame = parentFrame;
+      nsIFrame* parentFrame = aFrame->GetParent();
+      aFrame = parentFrame;
 
       ElementState elementState = GetContentState(aFrame, aAppearance);
       aPart = CBP_DROPMARKER_VISTA;
@@ -1182,22 +1176,18 @@
       // For HTML controls with author styling, we should fall
       // back to the old dropmarker style to avoid clashes with
       // author-specified backgrounds and borders (bug #441034)
-      if (isHTML && IsWidgetStyled(aFrame->PresContext(), aFrame,
-                                   StyleAppearance::Menulist))
+      if (IsWidgetStyled(aFrame->PresContext(), aFrame,
+                         StyleAppearance::Menulist)) {
         aPart = CBP_DROPMARKER;
+      }
 
       if (elementState.HasState(ElementState::DISABLED)) {
         aState = TS_DISABLED;
         return NS_OK;
       }
 
-      if (isHTML) {
-        nsComboboxControlFrame* ccf = do_QueryFrame(aFrame);
-        isOpen = (ccf && ccf->IsDroppedDown());
-      } else
-        isOpen = IsOpenButton(aFrame);
-
-      if (isHTML) {
+      if (nsComboboxControlFrame* ccf = do_QueryFrame(aFrame)) {
+        isOpen = ccf->IsDroppedDown();
         if (isOpen) {
           /* Hover is propagated, but we need to know whether we're hovering
            * just the combobox frame, not the dropdown frame. But, we can't get
@@ -1214,6 +1204,7 @@
          * hover effect. When the frame isn't isn't HTML content, we cheat and
          * force the dropdown state to be normal. (Bug 430434)
          */
+        isOpen = IsOpenButton(aFrame);
         aState = TS_NORMAL;
         return NS_OK;
       }
@@ -1222,7 +1213,7 @@
 
       // Dropdown button active state doesn't need :hover.
       if (elementState.HasState(ElementState::ACTIVE)) {
-        if (isOpen && (isHTML || isMenulist)) {
+        if (isOpen) {
           // XXX Button should look active until the mouse is released, but
           //     without making it look active when the popup is clicked.
           return NS_OK;
@@ -1248,17 +1239,13 @@
     case StyleAppearance::Menuitem:
     case StyleAppearance::Checkmenuitem:
     case StyleAppearance::Radiomenuitem: {
-      bool isTopLevel = false;
-      bool isOpen = false;
-      bool isHover = false;
-      nsMenuFrame* menuFrame = do_QueryFrame(aFrame);
       ElementState elementState = GetContentState(aFrame, aAppearance);
 
-      isTopLevel = IsTopLevelMenu(aFrame);
-
-      if (menuFrame) isOpen = menuFrame->IsOpen();
-
-      isHover = IsMenuActive(aFrame, aAppearance);
+      auto* menu = dom::XULButtonElement::FromNodeOrNull(aFrame->GetContent());
+
+      const bool isTopLevel = IsTopLevelMenu(aFrame);
+      const bool isOpen = menu && menu->IsMenuPopupOpen();
+      const bool isHover = IsMenuActive(aFrame, aAppearance);
 
       if (isTopLevel) {
         aPart = MENU_BARITEM;
@@ -2794,35 +2781,33 @@
     case StyleAppearance::Menuitem:
     case StyleAppearance::Checkmenuitem:
     case StyleAppearance::Radiomenuitem: {
-      bool isTopLevel = false;
-      bool isOpen = false;
-      nsMenuFrame* menuFrame = do_QueryFrame(aFrame);
       ElementState elementState = GetContentState(aFrame, aAppearance);
 
+      auto* menu = dom::XULButtonElement::FromNodeOrNull(aFrame->GetContent());
+
+      const bool isTopLevel = IsTopLevelMenu(aFrame);
+      const bool isOpen = menu && menu->IsMenuPopupOpen();
+
       // We indicate top-level-ness using aPart. 0 is a normal menu item,
       // 1 is a top-level menu item. The state of the item is composed of
       // DFCS_* flags only.
       aPart = 0;
       aState = 0;
 
-      if (menuFrame) {
-        // If this is a real menu item, we should check if it is part of the
-        // main menu bar or not, and if it is a container, as these affect
-        // rendering.
-        isTopLevel = menuFrame->IsOnMenuBar();
-        isOpen = menuFrame->IsOpen();
-      }
-
       if (elementState.HasState(ElementState::DISABLED)) {
         aState |= DFCS_INACTIVE;
       }
 
       if (isTopLevel) {
         aPart = 1;
-        if (isOpen) aState |= DFCS_PUSHED;
+        if (isOpen) {
+          aState |= DFCS_PUSHED;
+        }
       }
 
-      if (IsMenuActive(aFrame, aAppearance)) aState |= DFCS_HOT;
+      if (IsMenuActive(aFrame, aAppearance)) {
+        aState |= DFCS_HOT;
+      }
 
       return NS_OK;
     }
@@ -2873,13 +2858,9 @@
       aState = DFCS_SCROLLCOMBOBOX;
 
       nsIFrame* parentFrame = aFrame->GetParent();
-      bool isHTML = IsHTMLContent(aFrame);
-      bool isMenulist = !isHTML && parentFrame->IsMenuFrame();
-      bool isOpen = false;
-
       // HTML select and XUL menulist dropdown buttons get state from the
       // parent.
-      if (isHTML || isMenulist) aFrame = parentFrame;
+      aFrame = parentFrame;
 
       ElementState elementState = GetContentState(aFrame, aAppearance);
 
@@ -2888,15 +2869,18 @@
         return NS_OK;
       }
 
-      if (isHTML) {
-        nsComboboxControlFrame* ccf = do_QueryFrame(aFrame);
-        isOpen = (ccf && ccf->IsDroppedDown());
-      } else
+      bool isOpen = false;
+      if (nsComboboxControlFrame* ccf = do_QueryFrame(aFrame)) {
+        isOpen = ccf->IsDroppedDown();
+      } else {
         isOpen = IsOpenButton(aFrame);
+      }
 
       // XXX Button should look active until the mouse is released, but
       //     without making it look active when the popup is clicked.
-      if (isOpen && (isHTML || isMenulist)) return NS_OK;
+      if (isOpen) {
+        return NS_OK;
+      }
 
       // Dropdown button active state doesn't need :hover.
       if (elementState.HasState(ElementState::ACTIVE))
