# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/BodyStream.cpp
# Commit: 68fbd6ac34b2
# Full Hash: 68fbd6ac34b27ff6c7c836852623f5a358b7ff5b
# Author: Kagami Sascha Rosylight <krosylight@mozilla.com>
# Date: 2023-02-21 21:26:48
# Regressor Bug: 1813011
# File Overlap Count: 1
# Description:
#   Bug 1813011 - Part 2: Return unsettled promise from BodyStream::PullCallbackImpl r=smaug
#   
#   ... and resolve it after successful enqueue. Note that this never rejects it since ErrorNative will do it for us.
#   
#   eWaiting/eReading/eWriting is merged into eInitialized and the state assertions now use promise state.
# ==============================================================================

diff -r 79f6624bf44c -r 68fbd6ac34b2 dom/base/BodyStream.cpp
--- a/dom/base/BodyStream.cpp	Tue Feb 21 12:37:00 2023 +0000
+++ b/dom/base/BodyStream.cpp	Tue Feb 21 12:37:38 2023 +0000
@@ -191,35 +191,16 @@
 
   MOZ_DIAGNOSTIC_ASSERT(mOwningEventTarget->IsOnCurrentThread());
 
-  MOZ_DIAGNOSTIC_ASSERT(mState == eInitializing || mState == eWaiting ||
-                        mState == eChecking || mState == eReading);
-
-  RefPtr<Promise> resolvedWithUndefinedPromise =
-      Promise::CreateResolvedWithUndefined(aController.GetParentObject(), aRv);
-  if (aRv.Failed()) {
-    return nullptr;
-  }
-
-  if (mState == eReading) {
-    // We are already reading data.
-    return resolvedWithUndefinedPromise.forget();
-  }
-
-  if (mState == eChecking) {
-    // If we are looking for more data, there is nothing else we should do:
-    // let's move this checking operation in a reading.
-    MOZ_ASSERT(mInputStream);
-    mState = eReading;
-
-    return resolvedWithUndefinedPromise.forget();
-  }
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitializing || mState == eInitialized);
+  MOZ_ASSERT(!mPullPromise);
+  mPullPromise = Promise::CreateInfallible(aController.GetParentObject());
 
   if (mState == eInitializing) {
     // The stream has been used for the first time.
     mStreamHolder->MarkAsRead();
   }
 
-  mState = eReading;
+  mState = eInitialized;
 
   if (!mInputStream) {
     // This is the first use of the stream. Let's convert the
@@ -241,6 +222,10 @@
   MOZ_DIAGNOSTIC_ASSERT(mInputStream);
   MOZ_DIAGNOSTIC_ASSERT(!mOriginalInputStream);
 
+  // Cancel previous wait if we were observing closure, because waiting twice
+  // may cause an error for some streams
+  mInputStream->AsyncWait(nullptr, 0, 0, nullptr);
+  // And then wait for data
   nsresult rv = mInputStream->AsyncWait(this, 0, 0, mOwningEventTarget);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ErrorPropagation(aCx, stream, rv);
@@ -249,7 +234,7 @@
   mAsyncWaitWorkerRef = mWorkerRef;
 
   // All good.
-  return resolvedWithUndefinedPromise.forget();
+  return do_AddRef(mPullPromise);
 }
 
 void BodyStream::WriteIntoReadRequestBuffer(JSContext* aCx,
@@ -263,8 +248,9 @@
   MOZ_DIAGNOSTIC_ASSERT(mOwningEventTarget->IsOnCurrentThread());
 
   MOZ_DIAGNOSTIC_ASSERT(mInputStream);
-  MOZ_DIAGNOSTIC_ASSERT(mState == eWriting);
-  mState = eChecking;
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitialized);
+  MOZ_DIAGNOSTIC_ASSERT(mPullPromise->State() ==
+                        Promise::PromiseState::Pending);
 
   uint32_t written;
   nsresult rv;
@@ -297,7 +283,8 @@
     return;
   }
 
-  rv = mInputStream->AsyncWait(this, 0, 0, mOwningEventTarget);
+  rv = mInputStream->AsyncWait(this, nsIAsyncOutputStream::WAIT_CLOSURE_ONLY, 0,
+                               mOwningEventTarget);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ErrorPropagation(aCx, aStream, rv);
     return;
@@ -454,7 +441,7 @@
   AutoEntryScript aes(mGlobal, "fetch body data available");
 
   MOZ_DIAGNOSTIC_ASSERT(mInputStream);
-  MOZ_DIAGNOSTIC_ASSERT(mState == eReading || mState == eChecking);
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitialized);
 
   JSContext* cx = aes.cx();
   ReadableStream* stream = mStreamHolder->GetReadableStreamBody();
@@ -464,11 +451,7 @@
 
   uint64_t size = 0;
   nsresult rv = mInputStream->Available(&size);
-  if (NS_SUCCEEDED(rv) && size == 0) {
-    // In theory this should not happen. If size is 0, the stream should be
-    // considered closed.
-    rv = NS_BASE_STREAM_CLOSED;
-  }
+  MOZ_ASSERT_IF(NS_SUCCEEDED(rv), size > 0);
 
   // No warning for stream closed.
   if (rv == NS_BASE_STREAM_CLOSED || NS_WARN_IF(NS_FAILED(rv))) {
@@ -476,13 +459,15 @@
     return NS_OK;
   }
 
-  // This extra checking is completed. Let's wait for the next read request.
-  if (mState == eChecking) {
-    mState = eWaiting;
+  // Not having a promise means we are pinged by stream closure, but here we
+  // still have more data to read. Let's wait for the next read request in that
+  // case.
+  if (!mPullPromise) {
     return NS_OK;
   }
 
-  mState = eWriting;
+  MOZ_DIAGNOSTIC_ASSERT(mPullPromise->State() ==
+                        Promise::PromiseState::Pending);
 
   ErrorResult errorResult;
   EnqueueChunkWithSizeIntoStream(cx, stream, size, errorResult);
@@ -492,6 +477,9 @@
     return NS_OK;
   }
 
+  mPullPromise->MaybeResolveWithUndefined();
+  mPullPromise = nullptr;
+
   // The previous call can execute JS (even up to running a nested event
   // loop), so |mState| can't be asserted to have any particular value, even
   // if the previous call succeeds.
@@ -576,6 +564,10 @@
 
   mWorkerRef = nullptr;
   mGlobal = nullptr;
+  // It's okay to leave a potentially unsettled promise as-is as this is only
+  // used to prevent reentrant to PullCallback. CloseNative() or ErrorNative()
+  // will settle the read requests for us.
+  mPullPromise = nullptr;
 
   RefPtr<BodyStream> self = mStreamHolder->TakeBodyStream();
   mStreamHolder->NullifyStream();