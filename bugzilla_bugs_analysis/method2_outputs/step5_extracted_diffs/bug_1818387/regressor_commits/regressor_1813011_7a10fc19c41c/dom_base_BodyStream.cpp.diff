# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/BodyStream.cpp
# Commit: 7a10fc19c41c
# Full Hash: 7a10fc19c41c3e8d61443237892c7f45ddceea00
# Author: Kagami Sascha Rosylight <krosylight@mozilla.com>
# Date: 2023-02-18 04:50:51
# Regressor Bug: 1813011
# File Overlap Count: 1
# Description:
#   Bug 1813011 - Part 2: Return unsettled promise from BodyStream::PullCallbackImpl r=smaug
#   
#   ... and resolve it after successful enqueue. Note that this never rejects it since ErrorNative will do it for us.
#   
#   eWaiting/eReading/eWriting is merged into eInitialized and the state assertions now use promise state.
# ==============================================================================

diff -r acb4e003bfae -r 7a10fc19c41c dom/base/BodyStream.cpp
--- a/dom/base/BodyStream.cpp	Fri Feb 17 18:32:24 2023 +0000
+++ b/dom/base/BodyStream.cpp	Fri Feb 17 18:32:25 2023 +0000
@@ -191,26 +191,16 @@
 
   MOZ_DIAGNOSTIC_ASSERT(mOwningEventTarget->IsOnCurrentThread());
 
-  MOZ_DIAGNOSTIC_ASSERT(mState == eInitializing || mState == eWaiting ||
-                        mState == eReading);
-
-  RefPtr<Promise> resolvedWithUndefinedPromise =
-      Promise::CreateResolvedWithUndefined(aController.GetParentObject(), aRv);
-  if (aRv.Failed()) {
-    return nullptr;
-  }
-
-  if (mState == eReading) {
-    // We are already reading data.
-    return resolvedWithUndefinedPromise.forget();
-  }
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitializing || mState == eInitialized);
+  MOZ_ASSERT(!mPullPromise);
+  mPullPromise = Promise::CreateInfallible(aController.GetParentObject());
 
   if (mState == eInitializing) {
     // The stream has been used for the first time.
     mStreamHolder->MarkAsRead();
   }
 
-  mState = eReading;
+  mState = eInitialized;
 
   if (!mInputStream) {
     // This is the first use of the stream. Let's convert the
@@ -240,7 +230,7 @@
   mAsyncWaitWorkerRef = mWorkerRef;
 
   // All good.
-  return resolvedWithUndefinedPromise.forget();
+  return do_AddRef(mPullPromise);
 }
 
 void BodyStream::WriteIntoReadRequestBuffer(JSContext* aCx,
@@ -254,7 +244,9 @@
   MOZ_DIAGNOSTIC_ASSERT(mOwningEventTarget->IsOnCurrentThread());
 
   MOZ_DIAGNOSTIC_ASSERT(mInputStream);
-  MOZ_DIAGNOSTIC_ASSERT(mState == eWriting);
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitialized);
+  MOZ_DIAGNOSTIC_ASSERT(mPullPromise->State() ==
+                        Promise::PromiseState::Pending);
 
   uint32_t written;
   nsresult rv;
@@ -437,7 +429,9 @@
   AutoEntryScript aes(mGlobal, "fetch body data available");
 
   MOZ_DIAGNOSTIC_ASSERT(mInputStream);
-  MOZ_DIAGNOSTIC_ASSERT(mState == eReading);
+  MOZ_DIAGNOSTIC_ASSERT(mState == eInitialized);
+  MOZ_DIAGNOSTIC_ASSERT(mPullPromise->State() ==
+                        Promise::PromiseState::Pending);
 
   JSContext* cx = aes.cx();
   ReadableStream* stream = mStreamHolder->GetReadableStreamBody();
@@ -455,8 +449,6 @@
     return NS_OK;
   }
 
-  mState = eWriting;
-
   ErrorResult errorResult;
   EnqueueChunkWithSizeIntoStream(cx, stream, size, errorResult);
   errorResult.WouldReportJSException();
@@ -465,7 +457,8 @@
     return NS_OK;
   }
 
-  mState = eWaiting;
+  mPullPromise->MaybeResolveWithUndefined();
+  mPullPromise = nullptr;
 
   // The previous call can execute JS (even up to running a nested event
   // loop), so |mState| can't be asserted to have any particular value, even
@@ -551,6 +544,10 @@
 
   mWorkerRef = nullptr;
   mGlobal = nullptr;
+  // It's okay to leave a potentially unsettled promise as-is as this is only
+  // used to prevent reentrant to PullCallback. CloseNative() or ErrorNative()
+  // will settle the read requests for us.
+  mPullPromise = nullptr;
 
   RefPtr<BodyStream> self = mStreamHolder->TakeBodyStream();
   mStreamHolder->NullifyStream();