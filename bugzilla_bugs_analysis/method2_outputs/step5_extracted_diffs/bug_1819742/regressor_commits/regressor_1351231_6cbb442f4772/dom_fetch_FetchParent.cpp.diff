# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/fetch/FetchParent.cpp
# Commit: 6cbb442f4772
# Full Hash: 6cbb442f477260469cab9f1d81e33fcaede82029
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2023-01-18 09:51:31
# Regressor Bug: 1351231
# File Overlap Count: 1
# Description:
#   Bug 1351231 - FetchService integration for PFetch. r=dom-worker-reviewers,jesup
#   
#   Depends on D142436
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D142437
# ==============================================================================

diff -r dbdca4661a35 -r 6cbb442f4772 dom/fetch/FetchParent.cpp
--- a/dom/fetch/FetchParent.cpp	Tue Jan 17 15:13:45 2023 +0000
+++ b/dom/fetch/FetchParent.cpp	Tue Jan 17 15:13:46 2023 +0000
@@ -4,6 +4,7 @@
 
 #include "FetchLog.h"
 #include "FetchParent.h"
+#include "FetchService.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
 #include "mozilla/SchedulerGroup.h"
@@ -79,7 +80,6 @@
 
 FetchParent::~FetchParent() {
   FETCH_LOG(("FetchParent::~FetchParent [%p]", this));
-  AssertIsOnBackgroundThread();
   MOZ_ASSERT(!mBackgroundEventTarget);
   MOZ_ASSERT(!mResponsePromises);
   MOZ_ASSERT(mActorDestroyed && mIsDone);
@@ -101,6 +101,7 @@
   if (aArgs.controller().isSome()) {
     mController = Some(ServiceWorkerDescriptor(aArgs.controller().ref()));
   }
+  mCookieJarSettings = aArgs.cookieJarSettings();
   mNeedOnDataAvailable = aArgs.needOnDataAvailable();
   mHasCSPEventListener = aArgs.hasCSPEventListener();
 
@@ -119,8 +120,16 @@
         FETCH_LOG(
             ("FetchParent::RecvFetchOp [%p] Success Callback", self.get()));
         AssertIsOnBackgroundThread();
+        self->mPromise = nullptr;
+        if (self->mIsDone) {
+          FETCH_LOG(("FetchParent::RecvFetchOp [%p] Fetch has already aborted",
+                     self.get()));
+          Unused << NS_WARN_IF(
+              !self->Send__delete__(self, NS_ERROR_DOM_ABORT_ERR));
+          return;
+        }
         self->mIsDone = true;
-        if (!self->mActorDestroyed) {
+        if (!self->mActorDestroyed && !self->mExtendForCSPEventListener) {
           FETCH_LOG(("FetchParent::RecvFetchOp [%p] Send__delete__(NS_OK)",
                      self.get()));
           Unused << NS_WARN_IF(!self->Send__delete__(self, NS_OK));
@@ -131,6 +140,7 @@
             ("FetchParent::RecvFetchOp [%p] Failure Callback", self.get()));
         AssertIsOnBackgroundThread();
         self->mIsDone = true;
+        self->mPromise = nullptr;
         if (!self->mActorDestroyed) {
           FETCH_LOG(("FetchParent::RecvFetchOp [%p] Send__delete__(aErr)",
                      self.get()));
@@ -138,7 +148,7 @@
         }
       });
 
-  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__, [self]() mutable {
+  RefPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__, [self]() mutable {
     FETCH_LOG(
         ("FetchParent::RecvFetchOp [%p], Main Thread Runnable", self.get()));
     AssertIsOnMainThread();
@@ -152,8 +162,31 @@
       self->mPromise->Reject(NS_ERROR_DOM_ABORT_ERR, __func__);
       return;
     }
-    // TODO: Initialize a fetch through FetchService::Fetch, and saving
-    //       returned promises into mResponsePromises
+    RefPtr<FetchService> fetchService = FetchService::GetInstance();
+    MOZ_ASSERT(fetchService);
+    MOZ_ASSERT(!self->mResponsePromises);
+    self->mResponsePromises =
+        fetchService->Fetch(AsVariant(FetchService::WorkerFetchArgs(
+            {self->mRequest.clonePtr(), self->mPrincipalInfo,
+             self->mWorkerScript, self->mClientInfo, self->mController,
+             self->mCookieJarSettings, self->mNeedOnDataAvailable,
+             self->mCSPEventListener, self->mBackgroundEventTarget,
+             self->mID})));
+
+    self->mResponsePromises->GetResponseEndPromise()->Then(
+        self->mBackgroundEventTarget, __func__,
+        [self](ResponseEndArgs&& aArgs) mutable {
+          MOZ_ASSERT(self->mPromise);
+          self->mPromise->Resolve(true, __func__);
+          self->mResponsePromises = nullptr;
+          self->mPromise = nullptr;
+        },
+        [self](CopyableErrorResult&& aErr) mutable {
+          MOZ_ASSERT(self->mPromise);
+          self->mPromise->Reject(aErr.StealNSResult(), __func__);
+          self->mResponsePromises = nullptr;
+          self->mPromise = nullptr;
+        });
   });
 
   MOZ_ALWAYS_SUCCEEDS(
@@ -188,13 +221,73 @@
   return IPC_OK();
 }
 
+void FetchParent::OnResponseAvailableInternal(
+    SafeRefPtr<InternalResponse>&& aResponse) {
+  FETCH_LOG(("FetchParent::OnResponseAvailableInternal [%p]", this));
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aResponse);
+  MOZ_ASSERT(!mActorDestroyed);
+
+  if (mIsDone && aResponse->Type() != ResponseType::Error) {
+    FETCH_LOG(
+        ("FetchParent::OnResponseAvailableInternal [%p] "
+         "Fetch has already aborted",
+         this));
+    return;
+  }
+
+  // To monitor the stream status between processes, response's body can not be
+  // serialized as RemoteLazyInputStream. Such that stream close can be
+  // propagated to FetchDriver in the parent process.
+  aResponse->SetSerializeAsLazy(false);
+
+  // CSP violation notification is asynchronous. Extending the FetchParent's
+  // life cycle for the notificaiton.
+  if (aResponse->Type() == ResponseType::Error &&
+      aResponse->GetErrorCode() == NS_ERROR_CONTENT_BLOCKED &&
+      mCSPEventListener) {
+    FETCH_LOG(
+        ("FetchParent::OnResponseAvailableInternal [%p] "
+         "NS_ERROR_CONTENT_BLOCKED",
+         this));
+    mExtendForCSPEventListener = true;
+  }
+
+  Unused << SendOnResponseAvailableInternal(
+      aResponse->ToParentToChildInternalResponse(WrapNotNull(Manager())));
+}
+
+void FetchParent::OnResponseEnd(const ResponseEndArgs& aArgs) {
+  FETCH_LOG(("FetchParent::OnResponseEnd [%p]", this));
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(!mActorDestroyed);
+
+  if (mIsDone && aArgs.endReason() != FetchDriverObserver::eAborted) {
+    FETCH_LOG(
+        ("FetchParent::OnResponseEnd [%p] "
+         "Fetch has already aborted",
+         this));
+    return;
+  }
+
+  Unused << SendOnResponseEnd(aArgs);
+}
+
+void FetchParent::OnDataAvailable() {
+  FETCH_LOG(("FetchParent::OnDataAvailable [%p]", this));
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(!mActorDestroyed);
+
+  Unused << SendOnDataAvailable();
+}
+
 void FetchParent::OnFlushConsoleReport(
-    nsTArray<net::ConsoleReportCollected>&& aReports) {
+    const nsTArray<net::ConsoleReportCollected>& aReports) {
   FETCH_LOG(("FetchParent::OnFlushConsoleReport [%p]", this));
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(!mActorDestroyed);
 
-  Unused << SendOnFlushConsoleReport(std::move(aReports));
+  Unused << SendOnFlushConsoleReport(aReports);
 }
 
 void FetchParent::ActorDestroy(ActorDestroyReason aReason) {