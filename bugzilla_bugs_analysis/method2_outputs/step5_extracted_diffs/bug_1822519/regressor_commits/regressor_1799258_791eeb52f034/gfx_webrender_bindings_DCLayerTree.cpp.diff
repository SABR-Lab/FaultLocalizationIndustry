# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/webrender_bindings/DCLayerTree.cpp
# Commit: 791eeb52f034
# Full Hash: 791eeb52f0346565055cd9c9a881661b1ca688c5
# Author: Kelsey Gilbert <kelsey.gilbert@mozilla.com>
# Date: 2023-01-24 09:30:00
# Regressor Bug: 1799258
# File Overlap Count: 1
# Description:
#   Bug 1799258 - Do color-management on Windows+DComp via IDCompositionFilterEffects. r=sotaro
#   
#   + Add gfx.color_management.rec709_gamma_as_srgb:true. :'(
#   
#   In particular, rec709(16/255) -> srgb(31/255). Even though it's
# ==============================================================================

diff -r 353ef4721bba -r 791eeb52f034 gfx/webrender_bindings/DCLayerTree.cpp
--- a/gfx/webrender_bindings/DCLayerTree.cpp	Mon Jan 23 22:13:16 2023 +0000
+++ b/gfx/webrender_bindings/DCLayerTree.cpp	Mon Jan 23 22:13:17 2023 +0000
@@ -6,6 +6,7 @@
 
 #include "DCLayerTree.h"
 
+#include "gfxWindowsPlatform.h"
 #include "GLContext.h"
 #include "GLContextEGL.h"
 #include "mozilla/gfx/DeviceManagerDx.h"
@@ -28,6 +29,10 @@
 #undef NTDDI_VERSION
 #define NTDDI_VERSION NTDDI_WINBLUE
 
+// We also need this, or dcomp.h won't give us e.g. IDCompositionFilterEffect:
+#undef _WIN32_WINNT_WINTHRESHOLD
+#define _WIN32_WINNT_WINTHRESHOLD _WIN32_WINNT
+
 #include <d3d11.h>
 #include <d3d11_1.h>
 #include <dcomp.h>
@@ -567,6 +572,16 @@
   }
 }
 
+template <class ToT>
+struct QI {
+  template <class FromT>
+  [[nodiscard]] static inline RefPtr<ToT> From(FromT* const from) {
+    RefPtr<ToT> to;
+    (void)from->QueryInterface(static_cast<ToT**>(getter_AddRefs(to)));
+    return to;
+  }
+};
+
 DCSurface* DCExternalSurfaceWrapper::EnsureSurfaceForExternalImage(
     wr::ExternalImageId aExternalImage) {
   if (mSurface) {
@@ -591,14 +606,117 @@
       mSurface = nullptr;
     }
   }
-
-  if (mSurface) {
-    // Add surface's visual which will contain video data to our root visual.
-    mVisual->AddVisual(mSurface->GetVisual(), TRUE, nullptr);
-  } else {
+  if (!mSurface) {
     gfxCriticalNote << "Failed to create a surface for external image: "
                     << gfx::hexa(texture);
+    return nullptr;
   }
+  const auto textureSwgl = texture->AsRenderTextureHostSWGL();
+  MOZ_ASSERT(textureSwgl);  // Covered above.
+
+  // Add surface's visual which will contain video data to our root visual.
+  const auto surfaceVisual = mSurface->GetVisual();
+  mVisual->AddVisual(surfaceVisual, true, nullptr);
+
+  // -
+  // Apply color management.
+
+  [&]() {
+    const auto cmsMode = GfxColorManagementMode();
+    if (cmsMode == CMSMode::Off) return;
+
+    const auto dcomp = mDCLayerTree->GetCompositionDevice();
+    const auto dcomp3 = QI<IDCompositionDevice3>::From(dcomp);
+    if (!dcomp3) {
+      NS_WARNING(
+          "No IDCompositionDevice3, cannot use dcomp for color management.");
+      return;
+    }
+
+    // -
+
+    const auto cspace = [&]() {
+      const auto rangedCspace = textureSwgl->GetYUVColorSpace();
+      const auto info = FromYUVRangedColorSpace(rangedCspace);
+      auto ret = ToColorSpace2(info.space);
+      if (ret == gfx::ColorSpace2::Display && cmsMode == CMSMode::All) {
+        ret = gfx::ColorSpace2::SRGB;
+      }
+      return ret;
+    }();
+
+    const bool rec709GammaAsSrgb =
+        StaticPrefs::gfx_color_management_rec709_gamma_as_srgb();
+    const bool rec2020GammaAsRec709 =
+        StaticPrefs::gfx_color_management_rec2020_gamma_as_rec709();
+
+    auto cspaceDesc = color::ColorspaceDesc{};
+    switch (cspace) {
+      case gfx::ColorSpace2::Display:
+        return;  // No color management needed!
+      case gfx::ColorSpace2::SRGB:
+        cspaceDesc.chrom = color::Chromaticities::Srgb();
+        cspaceDesc.tf = color::PiecewiseGammaDesc::Srgb();
+        break;
+
+      case gfx::ColorSpace2::DISPLAY_P3:
+        cspaceDesc.chrom = color::Chromaticities::DisplayP3();
+        cspaceDesc.tf = color::PiecewiseGammaDesc::DisplayP3();
+        break;
+
+      case gfx::ColorSpace2::BT601_525:
+        cspaceDesc.chrom = color::Chromaticities::Rec601_525_Ntsc();
+        if (rec709GammaAsSrgb) {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Srgb();
+        } else {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Rec709();
+        }
+        break;
+
+      case gfx::ColorSpace2::BT709:
+        cspaceDesc.chrom = color::Chromaticities::Rec709();
+        if (rec709GammaAsSrgb) {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Srgb();
+        } else {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Rec709();
+        }
+        break;
+
+      case gfx::ColorSpace2::BT2020:
+        cspaceDesc.chrom = color::Chromaticities::Rec2020();
+        if (rec2020GammaAsRec709 && rec709GammaAsSrgb) {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Srgb();
+        } else if (rec2020GammaAsRec709) {
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Rec709();
+        } else {
+          // Just Rec709 with slightly more precision.
+          cspaceDesc.tf = color::PiecewiseGammaDesc::Rec2020_12bit();
+        }
+        break;
+    }
+
+    const auto cprofileIn = color::ColorProfileDesc::From(cspaceDesc);
+    auto cprofileOut = mDCLayerTree->OutputColorProfile();
+    bool pretendSrgb = StaticPrefs::gfx_color_management_native_srgb();
+    if (pretendSrgb) {
+      cprofileOut = color::ColorProfileDesc::From({
+          color::Chromaticities::Srgb(),
+          color::PiecewiseGammaDesc::Srgb(),
+      });
+    }
+    const auto conversion = color::ColorProfileConversionDesc::From({
+        .src = cprofileIn,
+        .dst = cprofileOut,
+    });
+
+    // -
+
+    auto chain = ColorManagementChain::From(*dcomp3, conversion);
+    mCManageChain = Some(chain);
+
+    surfaceVisual->SetEffect(mCManageChain->last.get());
+  }();
+
   return mSurface.get();
 }
 
@@ -1591,6 +1709,114 @@
   }
 }
 
+// -
+
+color::ColorProfileDesc DCLayerTree::QueryOutputColorProfile() {
+  // GPU process can't simply init gfxPlatform, (and we don't need most of it)
+  // but we do need gfxPlatform::GetCMSOutputProfile().
+  // So we steal what we need through the window:
+  const auto outputProfileData =
+      gfxWindowsPlatform::GetPlatformCMSOutputProfileData_Impl();
+
+  const auto qcmsProfile = qcms_profile_from_memory(
+      outputProfileData.Elements(), outputProfileData.Length());
+  MOZ_ASSERT(qcmsProfile);
+  const auto release =
+      MakeScopeExit([&]() { qcms_profile_release(qcmsProfile); });
+
+  const auto ret = color::ColorProfileDesc::From(*qcmsProfile);
+  bool print = gfxEnv::MOZ_GL_SPEW();
+  if (print) {
+    const auto gammaGuess = color::GuessGamma(ret.linearFromTf.r);
+    printf_stderr(
+        "Display profile:\n"
+        "  Approx Gamma: %f\n"
+        "  XYZ-D65 Red  : %f, %f, %f\n"
+        "  XYZ-D65 Green: %f, %f, %f\n"
+        "  XYZ-D65 Blue : %f, %f, %f\n",
+        gammaGuess, ret.xyzd65FromLinearRgb.at(0, 0),
+        ret.xyzd65FromLinearRgb.at(0, 1), ret.xyzd65FromLinearRgb.at(0, 2),
+
+        ret.xyzd65FromLinearRgb.at(1, 0), ret.xyzd65FromLinearRgb.at(1, 1),
+        ret.xyzd65FromLinearRgb.at(1, 2),
+
+        ret.xyzd65FromLinearRgb.at(2, 0), ret.xyzd65FromLinearRgb.at(2, 1),
+        ret.xyzd65FromLinearRgb.at(2, 2));
+  }
+
+  return ret;
+}
+
+inline D2D1_MATRIX_5X4_F to_D2D1_MATRIX_5X4_F(const color::mat4& m) {
+  return D2D1_MATRIX_5X4_F{{{
+      m.rows[0][0],
+      m.rows[1][0],
+      m.rows[2][0],
+      m.rows[3][0],
+      m.rows[0][1],
+      m.rows[1][1],
+      m.rows[2][1],
+      m.rows[3][1],
+      m.rows[0][2],
+      m.rows[1][2],
+      m.rows[2][2],
+      m.rows[3][2],
+      m.rows[0][3],
+      m.rows[1][3],
+      m.rows[2][3],
+      m.rows[3][3],
+      0,
+      0,
+      0,
+      0,
+  }}};
+}
+
+ColorManagementChain ColorManagementChain::From(
+    IDCompositionDevice3& dcomp,
+    const color::ColorProfileConversionDesc& conv) {
+  auto ret = ColorManagementChain{};
+
+  const auto Append = [&](const RefPtr<IDCompositionFilterEffect>& afterLast) {
+    if (ret.last) {
+      afterLast->SetInput(0, ret.last, 0);
+    }
+    ret.last = afterLast;
+  };
+
+  const auto MaybeAppendColorMatrix = [&](const color::mat4& m) {
+    RefPtr<IDCompositionColorMatrixEffect> e;
+    if (approx(m, color::mat4::Identity())) return e;
+    dcomp.CreateColorMatrixEffect(getter_AddRefs(e));
+    MOZ_ASSERT(e);
+    if (!e) return e;
+    e->SetMatrix(to_D2D1_MATRIX_5X4_F(m));
+    Append(e);
+    return e;
+  };
+  const auto MaybeAppendTableTransfer = [&](const color::RgbTransferTables& t) {
+    RefPtr<IDCompositionTableTransferEffect> e;
+    if (!t.r.size() && !t.g.size() && !t.b.size()) return e;
+    dcomp.CreateTableTransferEffect(getter_AddRefs(e));
+    MOZ_ASSERT(e);
+    if (!e) return e;
+    e->SetRedTable(t.r.data(), t.r.size());
+    e->SetGreenTable(t.g.data(), t.g.size());
+    e->SetBlueTable(t.b.data(), t.b.size());
+    Append(e);
+    return e;
+  };
+
+  ret.srcRgbFromSrcYuv = MaybeAppendColorMatrix(conv.srcRgbFromSrcYuv);
+  ret.srcLinearFromSrcTf = MaybeAppendTableTransfer(conv.srcLinearFromSrcTf);
+  ret.dstLinearFromSrcLinear =
+      MaybeAppendColorMatrix(color::mat4(conv.dstLinearFromSrcLinear));
+  ret.dstTfFromDstLinear = MaybeAppendTableTransfer(conv.dstTfFromDstLinear);
+  return ret;
+}
+
+ColorManagementChain::~ColorManagementChain() = default;
+
 }  // namespace wr
 }  // namespace mozilla
 