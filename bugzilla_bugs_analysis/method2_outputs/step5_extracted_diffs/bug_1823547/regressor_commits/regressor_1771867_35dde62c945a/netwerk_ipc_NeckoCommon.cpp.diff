# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/NeckoCommon.cpp
# Commit: 35dde62c945a
# Full Hash: 35dde62c945ab7f66f6fd48a8b4cf706c3f78fb2
# Author: Manuel Bucher <manuel@mozilla.com>
# Date: 2022-12-03 09:24:59
# Regressor Bug: 1771867
# File Overlap Count: 1
# Description:
#   Bug 1771867 - Early Hints Phase 2 - Part 12: Redirect EarlyHint preload channel to content process r=necko-reviewers,kershaw,valentin
#   
#   Similar to how DocumentLoadListener redirects the document to the content process.
#   
#   This fixes the race conditions in early hint architecture fixing intermittent
# ==============================================================================

diff -r ca2681b0f792 -r 35dde62c945a netwerk/ipc/NeckoCommon.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netwerk/ipc/NeckoCommon.cpp	Fri Dec 02 16:15:57 2022 +0000
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "NeckoCommon.h"
+
+#include "nsIInputStream.h"
+#include "nsIMultiPartChannel.h"
+#include "nsIParentChannel.h"
+#include "nsStringStream.h"
+
+namespace mozilla::net {
+
+nsresult ForwardStreamListenerFunctions(
+    nsTArray<StreamListenerFunction>& aCalls, nsIStreamListener* aParent) {
+  nsresult rv = NS_OK;
+  for (auto& variant : aCalls) {
+    variant.match(
+        [&](const OnStartRequestParams& aParams) {
+          rv = aParent->OnStartRequest(aParams.request);
+          if (NS_FAILED(rv)) {
+            aParams.request->Cancel(rv);
+          }
+        },
+        [&](const OnDataAvailableParams& aParams) {
+          // Don't deliver OnDataAvailable if we've
+          // already failed.
+          if (NS_FAILED(rv)) {
+            return;
+          }
+          nsCOMPtr<nsIInputStream> stringStream;
+          rv = NS_NewByteInputStream(
+              getter_AddRefs(stringStream),
+              Span<const char>(aParams.data.get(), aParams.count),
+              NS_ASSIGNMENT_DEPEND);
+          if (NS_SUCCEEDED(rv)) {
+            rv = aParent->OnDataAvailable(aParams.request, stringStream,
+                                          aParams.offset, aParams.count);
+          }
+          if (NS_FAILED(rv)) {
+            aParams.request->Cancel(rv);
+          }
+        },
+        [&](const OnStopRequestParams& aParams) {
+          if (NS_SUCCEEDED(rv)) {
+            aParent->OnStopRequest(aParams.request, aParams.status);
+          } else {
+            aParent->OnStopRequest(aParams.request, rv);
+          }
+          rv = NS_OK;
+        },
+        [&](const OnAfterLastPartParams& aParams) {
+          nsCOMPtr<nsIMultiPartChannelListener> multiListener =
+              do_QueryInterface(aParent);
+          if (multiListener) {
+            if (NS_SUCCEEDED(rv)) {
+              multiListener->OnAfterLastPart(aParams.status);
+            } else {
+              multiListener->OnAfterLastPart(rv);
+            }
+          }
+        });
+  }
+  return rv;
+}
+
+}  // namespace mozilla::net