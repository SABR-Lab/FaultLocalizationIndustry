# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/ipc/DocumentLoadListener.cpp
# Commit: 8575cd92e1d8
# Full Hash: 8575cd92e1d8cd783e6cca3f6feadef11f0c4cc8
# Author: Manuel Bucher <manuel@mozilla.com>
# Date: 2022-12-03 09:24:59
# Regressor Bug: 1771867
# File Overlap Count: 1
# Description:
#   Bug 1771867 - Early Hints Phase 2 - Part 8: Add list of open channels from OngoingEarlyHints to RedirectToRealChannelArgs r=necko-reviewers,valentin,kershaw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D161179
# ==============================================================================

diff -r ce8f0a8fa688 -r 8575cd92e1d8 netwerk/ipc/DocumentLoadListener.cpp
--- a/netwerk/ipc/DocumentLoadListener.cpp	Fri Dec 02 16:15:55 2022 +0000
+++ b/netwerk/ipc/DocumentLoadListener.cpp	Fri Dec 02 16:15:56 2022 +0000
@@ -1203,8 +1203,8 @@
   // Don't cancel ongoing early hints when continuing to load the web page.
   // Early hints are loaded earlier in the code and shouldn't get cancelled
   // here. See also: Bug 1765652
-  if (GetLoadingBrowsingContext() && !aContinueNavigating) {
-    GetLoadingBrowsingContext()->mEarlyHintsService.Cancel();
+  if (!aContinueNavigating) {
+    mEarlyHintsService.Cancel();
   }
 
   if (auto* ctx = GetDocumentBrowsingContext()) {
@@ -1486,10 +1486,11 @@
 
 void DocumentLoadListener::SerializeRedirectData(
     RedirectToRealChannelArgs& aArgs, bool aIsCrossProcess,
-    uint32_t aRedirectFlags, uint32_t aLoadFlags,
-    ContentParent* aParent) const {
+    uint32_t aRedirectFlags, uint32_t aLoadFlags, ContentParent* aParent,
+    nsTArray<EarlyHintConnectArgs>&& aEarlyHints) const {
   aArgs.uri() = GetChannelCreationURI();
   aArgs.loadIdentifier() = mLoadIdentifier;
+  aArgs.earlyHints() = std::move(aEarlyHints);
 
   // I previously used HttpBaseChannel::CloneLoadInfoForRedirect, but that
   // clears the principal to inherit, which fails tests (probably because this
@@ -2120,9 +2121,12 @@
           CreateAndReject(ipc::ResponseRejectReason::SendError, __func__);
     }
 
+    nsTArray<EarlyHintConnectArgs> ehArgs;
+    mEarlyHintsService.RegisterLinksAndGetConnectArgs(ehArgs);
+
     RedirectToRealChannelArgs args;
     SerializeRedirectData(args, /* aIsCrossProcess */ true, aRedirectFlags,
-                          aLoadFlags, cp);
+                          aLoadFlags, cp, std::move(ehArgs));
     if (mTiming) {
       mTiming->Anonymize(args.uri());
       args.timing() = Some(std::move(mTiming));
@@ -2158,10 +2162,14 @@
   auto promise =
       MakeRefPtr<PDocumentChannelParent::RedirectToRealChannelPromise::Private>(
           __func__);
-  mOpenPromise->Resolve(
-      OpenPromiseSucceededType({std::move(aStreamFilterEndpoints),
-                                aRedirectFlags, aLoadFlags, promise}),
-      __func__);
+
+  nsTArray<EarlyHintConnectArgs> ehArgs;
+  mEarlyHintsService.RegisterLinksAndGetConnectArgs(ehArgs);
+
+  mOpenPromise->Resolve(OpenPromiseSucceededType(
+                            {std::move(aStreamFilterEndpoints), aRedirectFlags,
+                             aLoadFlags, std::move(ehArgs), promise}),
+                        __func__);
 
   // There is no way we could come back here if the promise had been resolved
   // previously. But for clarity and to avoid all doubt, we set this boolean to
@@ -2576,15 +2584,12 @@
     }
   }
 
-  if (GetLoadingBrowsingContext()) {
-    if (httpChannel) {
-      uint32_t responseStatus;
-      Unused << httpChannel->GetResponseStatus(&responseStatus);
-      GetLoadingBrowsingContext()->mEarlyHintsService.FinalResponse(
-          responseStatus);
-    } else {
-      GetLoadingBrowsingContext()->mEarlyHintsService.Cancel();
-    }
+  if (httpChannel) {
+    uint32_t responseStatus = 0;
+    Unused << httpChannel->GetResponseStatus(&responseStatus);
+    mEarlyHintsService.FinalResponse(responseStatus);
+  } else {
+    mEarlyHintsService.Cancel();
   }
 
   // If we're going to be delivering this channel to a remote content
@@ -2804,19 +2809,23 @@
     return NS_OK;
   }
 
+  // Cancel cross origin redirects as described by whatwg:
+  // > Note: [The early hint reponse] is discarded if it is succeeded by a
+  // > cross-origin redirect.
+  // https://html.spec.whatwg.org/multipage/semantics.html#early-hints
+  nsCOMPtr<nsIURI> oldURI;
+  aOldChannel->GetURI(getter_AddRefs(oldURI));
+  nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+  nsresult rv = ssm->CheckSameOriginURI(oldURI, uri, false, false);
+  if (NS_FAILED(rv)) {
+    mEarlyHintsService.Cancel();
+  }
+
   if (GetDocumentBrowsingContext()) {
-    nsCOMPtr<nsIURI> oldURI;
-    aOldChannel->GetURI(getter_AddRefs(oldURI));
     if (!net::ChannelIsPost(aOldChannel)) {
       AddURIVisit(aOldChannel, 0);
       nsDocShell::SaveLastVisit(aNewChannel, oldURI, aFlags);
     }
-
-    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
-    nsresult rv = ssm->CheckSameOriginURI(oldURI, uri, false, false);
-    if (NS_FAILED(rv)) {
-      GetLoadingBrowsingContext()->mEarlyHintsService.Cancel();
-    }
   }
   mHaveVisibleRedirect |= true;
 
@@ -2949,10 +2958,7 @@
 
 NS_IMETHODIMP DocumentLoadListener::EarlyHint(const nsACString& linkHeader) {
   LOG(("DocumentLoadListener::EarlyHint.\n"));
-  if (GetLoadingBrowsingContext()) {
-    GetLoadingBrowsingContext()->mEarlyHintsService.EarlyHint(
-        linkHeader, GetChannelCreationURI(), mChannel);
-  }
+  mEarlyHintsService.EarlyHint(linkHeader, GetChannelCreationURI(), mChannel);
   return NS_OK;
 }
 