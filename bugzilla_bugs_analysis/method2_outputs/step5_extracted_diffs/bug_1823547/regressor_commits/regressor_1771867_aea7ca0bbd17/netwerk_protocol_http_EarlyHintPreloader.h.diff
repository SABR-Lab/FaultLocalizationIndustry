# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/EarlyHintPreloader.h
# Commit: aea7ca0bbd17
# Full Hash: aea7ca0bbd17e31625ac66bbb1815858ff135c35
# Author: Manuel Bucher <manuel@mozilla.com>
# Date: 2022-12-02 21:26:33
# Regressor Bug: 1771867
# File Overlap Count: 1
# Description:
#   Bug 1771867 - Early Hints Phase 2 - Part 12: Redirect EarlyHint preload channel to content process r=necko-reviewers,kershaw,valentin
#   
#   Similar to how DocumentLoadListener redirects the document to the content process.
#   
#   This fixes the race conditions in early hint architecture fixing intermittent
# ==============================================================================

diff -r 2fe2afdee09d -r aea7ca0bbd17 netwerk/protocol/http/EarlyHintPreloader.h
--- a/netwerk/protocol/http/EarlyHintPreloader.h	Fri Dec 02 09:45:28 2022 +0000
+++ b/netwerk/protocol/http/EarlyHintPreloader.h	Fri Dec 02 09:45:28 2022 +0000
@@ -7,12 +7,15 @@
 
 #include "mozilla/Maybe.h"
 #include "mozilla/PreloadHashKey.h"
+#include "NeckoCommon.h"
+#include "mozilla/net/NeckoChannelParams.h"
+#include "nsHashtablesFwd.h"
 #include "nsIChannelEventSink.h"
 #include "nsIInterfaceRequestor.h"
+#include "nsIMultiPartChannel.h"
 #include "nsIRedirectResultListener.h"
 #include "nsIStreamListener.h"
 #include "nsNetUtil.h"
-#include "nsRefPtrHashtable.h"
 
 class nsAttrValue;
 class nsICookieJarSettings;
@@ -23,13 +26,13 @@
 
 class EarlyHintPreloader;
 class EarlyHintConnectArgs;
+class ParentChannelListener;
 struct LinkHeader;
 
 // class keeping track of all ongoing early hints
 class OngoingEarlyHints final {
  public:
   NS_INLINE_DECL_REFCOUNTING(OngoingEarlyHints)
-  MOZ_DECLARE_REFCOUNTED_TYPENAME(OngoingEarlyHints)
 
   OngoingEarlyHints() = default;
 
@@ -45,17 +48,23 @@
 
  private:
   ~OngoingEarlyHints() = default;
-  nsRefPtrHashtable<PreloadHashKey, EarlyHintPreloader> mOngoingPreloads;
 
-  // keep track of all preloads in the order they were specified in the early
-  // hint header
-  nsTArray<EarlyHintConnectArgs> mLinks;
+  // We need to do two things requiring two separate variables to keep track of
+  // preloads:
+  //  - deduplicate Link headers when starting preloads, therefore we store them
+  //    hashset with PreloadHashKey to look up whether we started the preload
+  //    already
+  //  - pass link headers in order they were received when passing all started
+  //    preloads to the content process, therefore we store them in a nsTArray
+  nsTHashSet<PreloadHashKey> mStartedPreloads;
+  nsTArray<RefPtr<EarlyHintPreloader>> mPreloaders;
 };
 
 class EarlyHintPreloader final : public nsIStreamListener,
                                  public nsIChannelEventSink,
                                  public nsIRedirectResultListener,
-                                 public nsIInterfaceRequestor {
+                                 public nsIInterfaceRequestor,
+                                 public nsIMultiPartChannelListener {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIREQUESTOBSERVER
@@ -63,6 +72,7 @@
   NS_DECL_NSICHANNELEVENTSINK
   NS_DECL_NSIREDIRECTRESULTLISTENER
   NS_DECL_NSIINTERFACEREQUESTOR
+  NS_DECL_NSIMULTIPARTCHANNELLISTENER
 
  public:
   // Create and insert a preload into OngoingEarlyHints if the same preload
@@ -72,14 +82,21 @@
       nsIURI* aBaseURI, nsIPrincipal* aPrincipal,
       nsICookieJarSettings* aCookieJarSettings);
 
-  // Should be called by the preloader service when the preload is not needed
-  // after all, because the final response returns a non-2xx status code.
+  // register Channel to EarlyHintRegistrar returns connect arguments
+  EarlyHintConnectArgs Register();
+
+  // Should be called by the preloader service when the preload is not
+  // needed after all, because the final response returns a non-2xx status
+  // code.
   nsresult CancelChannel(nsresult aStatus);
 
   void OnParentReady(nsIParentChannel* aParent, uint64_t aChannelId);
 
  private:
-  explicit EarlyHintPreloader(nsIURI* aURI);
+  void SetParentChannel();
+  bool InvokeStreamListenerFunctions();
+
+  EarlyHintPreloader();
   ~EarlyHintPreloader() = default;
 
   static Maybe<PreloadHashKey> GenerateHashKey(ASDestination aAs, nsIURI* aURI,
@@ -92,16 +109,38 @@
                                               bool aIsModule);
 
   // call to start the preload
-  nsresult OpenChannel(nsIPrincipal* aPrincipal, nsSecurityFlags aSecurityFlags,
+  nsresult OpenChannel(nsIURI* aURI, nsIPrincipal* aPrincipal,
+                       nsSecurityFlags aSecurityFlags,
                        nsContentPolicyType aContentPolicyType,
                        nsIReferrerInfo* aReferrerInfo,
                        nsICookieJarSettings* aCookieJarSettings);
+  void SetLinkHeader(const LinkHeader& aLinkHeader);
 
   static void CollectResourcesTypeTelemetry(ASDestination aASDestination);
-  // keep opening uri to not preload cross origins on redirects for now
-  nsCOMPtr<nsIURI> mURI;
   nsCOMPtr<nsIChannel> mChannel;
   nsCOMPtr<nsIChannel> mRedirectChannel;
+  uint64_t mChannelId = 0;
+
+  EarlyHintConnectArgs mConnectArgs;
+
+  // Copy behavior from DocumentLoadListener.h:
+  // https://searchfox.org/mozilla-central/rev/c0bed29d643393af6ebe77aa31455f283f169202/netwerk/ipc/DocumentLoadListener.h#487-512
+  // The set of nsIStreamListener functions that got called on this
+  // listener, so that we can replay them onto the replacement channel's
+  // listener. This should generally only be OnStartRequest, since we
+  // Suspend() the channel at that point, but it can fail sometimes
+  // so we have to support holding a list.
+  nsTArray<StreamListenerFunction> mStreamListenerFunctions;
+
+  // Set to true once OnStartRequest is called and we suspend our mChannel
+  bool mSuspended = false;
+  nsCOMPtr<nsIParentChannel> mParent;
+  // Set to true after we've received the last OnStopRequest, and shouldn't
+  // setup a reference from the ParentChannelListener to the replacement
+  // channel.
+  bool mIsFinished = false;
+
+  RefPtr<ParentChannelListener> mParentListener;
 };
 
 inline nsISupports* ToSupports(EarlyHintPreloader* aObj) {
