# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpChannelParent.cpp
# Commit: b4b920f24bed
# Full Hash: b4b920f24bed3d02a7000892e9594c515970e1f6
# Author: Manuel Bucher <manuel@mozilla.com>
# Date: 2022-12-03 09:24:59
# Regressor Bug: 1771867
# File Overlap Count: 1
# Description:
#   Bug 1771867 - Early Hints Phase 2 - Part 3: Add mechanism to notify EarlyHintPreloader that HttpChannelParent is ready to complete the redirect r=necko-reviewers,kershaw,valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D161178
# ==============================================================================

diff -r 13a9f4631369 -r b4b920f24bed netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp	Fri Dec 02 16:15:53 2022 +0000
+++ b/netwerk/protocol/http/HttpChannelParent.cpp	Fri Dec 02 16:15:54 2022 +0000
@@ -5,10 +5,12 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // HttpLog.h should generally be included first
+#include "ErrorList.h"
 #include "HttpLog.h"
 
 #include "mozilla/ConsoleReportCollector.h"
 #include "mozilla/ipc/IPCStreamUtils.h"
+#include "mozilla/net/EarlyHintRegistrar.h"
 #include "mozilla/net/HttpChannelParent.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ContentProcessManager.h"
@@ -24,6 +26,7 @@
 #include "mozilla/Unused.h"
 #include "HttpBackgroundChannelParent.h"
 #include "ParentChannelListener.h"
+#include "nsDebug.h"
 #include "nsICacheInfoChannel.h"
 #include "nsHttpHandler.h"
 #include "nsNetCID.h"
@@ -138,7 +141,7 @@
           a.launchServiceWorkerEnd(), a.dispatchFetchEventStart(),
           a.dispatchFetchEventEnd(), a.handleFetchEventStart(),
           a.handleFetchEventEnd(), a.forceMainDocumentChannel(),
-          a.navigationStartTimeStamp());
+          a.navigationStartTimeStamp(), a.earlyHintPreloaderId());
     }
     case HttpChannelCreationArgs::THttpChannelConnectArgs: {
       const HttpChannelConnectArgs& cArgs = aArgs.get_HttpChannelConnectArgs();
@@ -351,6 +354,26 @@
   }
 }
 
+void HttpChannelParent::InvokeEarlyHintPreloader(nsresult rv,
+                                                 uint64_t aEarlyHintPreloaderId,
+                                                 uint64_t aChannelId) {
+  LOG(("HttpChannelParent::InvokeEarlyHintPreloader [this=%p rv=%" PRIx32 "]\n",
+       this, static_cast<uint32_t>(rv)));
+  MOZ_ASSERT(NS_IsMainThread());
+
+  RefPtr<EarlyHintRegistrar> ehr = EarlyHintRegistrar::GetOrCreate();
+  if (NS_SUCCEEDED(rv)) {
+    rv = ehr->LinkParentChannel(aEarlyHintPreloaderId, this, aChannelId)
+             ? NS_OK
+             : NS_ERROR_FAILURE;
+  }
+
+  if (NS_FAILED(rv)) {
+    ehr->DeleteEntry(aEarlyHintPreloaderId);
+    AsyncOpenFailed(NS_ERROR_FAILURE);
+  }
+}
+
 bool HttpChannelParent::DoAsyncOpen(
     nsIURI* aURI, nsIURI* aOriginalURI, nsIURI* aDocURI,
     nsIReferrerInfo* aReferrerInfo, nsIURI* aAPIRedirectToURI,
@@ -381,9 +404,31 @@
     const TimeStamp& aHandleFetchEventStart,
     const TimeStamp& aHandleFetchEventEnd,
     const bool& aForceMainDocumentChannel,
-    const TimeStamp& aNavigationStartTimeStamp) {
+    const TimeStamp& aNavigationStartTimeStamp,
+    const uint64_t& aEarlyHintPreloaderId) {
   MOZ_ASSERT(aURI, "aURI should not be NULL");
 
+  if (aEarlyHintPreloaderId) {
+    // Wait for HttpBackgrounChannel to continue the async open procedure.
+    mEarlyHintPreloaderId = aEarlyHintPreloaderId;
+    RefPtr<HttpChannelParent> self = this;
+    WaitForBgParent(aChannelId)
+        ->Then(
+            GetMainThreadSerialEventTarget(), __func__,
+            [self, aEarlyHintPreloaderId, aChannelId]() {
+              self->mRequest.Complete();
+              self->InvokeEarlyHintPreloader(NS_OK, aEarlyHintPreloaderId,
+                                             aChannelId);
+            },
+            [self, aEarlyHintPreloaderId, aChannelId](nsresult aStatus) {
+              self->mRequest.Complete();
+              self->InvokeEarlyHintPreloader(aStatus, aEarlyHintPreloaderId,
+                                             aChannelId);
+            })
+        ->Track(mRequest);
+    return true;
+  }
+
   if (!aURI) {
     // this check is neccessary to prevent null deref
     // in opt builds
@@ -570,7 +615,7 @@
   // Wait for HttpBackgrounChannel to continue the async open procedure.
   ++mAsyncOpenBarrier;
   RefPtr<HttpChannelParent> self = this;
-  WaitForBgParent()
+  WaitForBgParent(mChannel->ChannelId())
       ->Then(
           GetMainThreadSerialEventTarget(), __func__,
           [self]() {
@@ -585,11 +630,12 @@
   return true;
 }
 
-RefPtr<GenericNonExclusivePromise> HttpChannelParent::WaitForBgParent() {
+RefPtr<GenericNonExclusivePromise> HttpChannelParent::WaitForBgParent(
+    uint64_t aChannelId) {
   LOG(("HttpChannelParent::WaitForBgParent [this=%p]\n", this));
   MOZ_ASSERT(!mBgParent);
 
-  if (!mChannel) {
+  if (!mChannel && !mEarlyHintPreloaderId) {
     return GenericNonExclusivePromise::CreateAndReject(NS_ERROR_FAILURE,
                                                        __func__);
   }
@@ -597,7 +643,7 @@
   nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
       BackgroundChannelRegistrar::GetOrCreate();
   MOZ_ASSERT(registrar);
-  registrar->LinkHttpChannel(mChannel->ChannelId(), this);
+  registrar->LinkHttpChannel(aChannelId, this);
 
   if (mBgParent) {
     return GenericNonExclusivePromise::CreateAndResolve(true, __func__);
@@ -652,7 +698,7 @@
   MOZ_ASSERT(mPromise.IsEmpty());
   // Waiting for background channel
   RefPtr<HttpChannelParent> self = this;
-  WaitForBgParent()
+  WaitForBgParent(mChannel->ChannelId())
       ->Then(
           GetMainThreadSerialEventTarget(), __func__,
           [self]() { self->mRequest.Complete(); },
@@ -897,13 +943,14 @@
 
   // Otherwise, wait for the background channel.
   nsCOMPtr<nsIAsyncVerifyRedirectReadyCallback> callback = aCallback;
-  WaitForBgParent()->Then(
-      GetMainThreadSerialEventTarget(), __func__,
-      [callback]() { callback->ReadyToVerify(NS_OK); },
-      [callback](const nsresult& aResult) {
-        NS_ERROR("failed to establish the background channel");
-        callback->ReadyToVerify(aResult);
-      });
+  WaitForBgParent(mChannel->ChannelId())
+      ->Then(
+          GetMainThreadSerialEventTarget(), __func__,
+          [callback]() { callback->ReadyToVerify(NS_OK); },
+          [callback](const nsresult& aResult) {
+            NS_ERROR("failed to establish the background channel");
+            callback->ReadyToVerify(aResult);
+          });
   return NS_OK;
 }
 
@@ -2031,6 +2078,17 @@
                      &HttpBackgroundChannelParent::DetachStreamFilters);
 }
 
+void HttpChannelParent::SetHttpChannelFromEarlyHintPreloader(
+    HttpBaseChannel* aChannel) {
+  MOZ_ASSERT(aChannel);
+  if (mChannel) {
+    MOZ_ASSERT(false, "SetHttpChannel called with mChannel aready set");
+    return;
+  }
+
+  mChannel = aChannel;
+}
+
 void HttpChannelParent::SetCookie(nsCString&& aCookie) {
   LOG(("HttpChannelParent::SetCookie [this=%p]", this));
   MOZ_ASSERT(!mAfterOnStartRequestBegun);