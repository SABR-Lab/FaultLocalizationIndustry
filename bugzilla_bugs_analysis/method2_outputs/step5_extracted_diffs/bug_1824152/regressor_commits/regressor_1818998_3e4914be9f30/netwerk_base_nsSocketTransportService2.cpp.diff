# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/nsSocketTransportService2.cpp
# Commit: 3e4914be9f30
# Full Hash: 3e4914be9f30f747091ed2a4bccbd8a56e40a0e6
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2023-05-26 21:54:33
# Regressor Bug: 1818998
# File Overlap Count: 1
# Description:
#   Bug 1834640 - Part 2: Properly shutdown nsSocketTransportService during xpcom-shutdown-threads, r=jesup,necko-reviewers
#   
#   This also cleans up some of the unnecessary flags & memebrs which were held
#   during the changes in bug 1818998. mSelf was unncessary as the runnable
#   reference will be keeping the instance alive for the same lifetime, and
# ==============================================================================

diff -r f762e1cce59c -r 3e4914be9f30 netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp	Fri May 26 16:50:22 2023 +0000
+++ b/netwerk/base/nsSocketTransportService2.cpp	Fri May 26 16:50:22 2023 +0000
@@ -253,7 +253,6 @@
 nsSocketTransportService::~nsSocketTransportService() {
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
   NS_ASSERTION(!mInitialized, "not shutdown properly");
-  MOZ_ASSERT(mSocketThreadShutDown);
 
   gSocketTransportService = nullptr;
 }
@@ -414,7 +413,7 @@
     reported900FDLimit = true;
     Telemetry::Accumulate(Telemetry::NETWORK_SESSION_AT_900FD, true);
   }
-  MOZ_ASSERT(!mSocketThreadShutDown);
+  MOZ_ASSERT(mInitialized);
   return rv;
 }
 
@@ -753,8 +752,6 @@
     nsresult rv = NS_NewNamedThread("Socket Thread", getter_AddRefs(thread),
                                     this, {.stackSize = GetThreadStackSize()});
     NS_ENSURE_SUCCESS(rv, rv);
-    // Since ::Run() will assume it can access this->*, hold a ref for it
-    mSelf = this;
   } else {
     // In the child process, we just want a regular nsThread with no socket
     // polling. So we don't want to run the nsSocketTransportService runnable on
@@ -775,9 +772,9 @@
     // Install our mThread, protecting against concurrent readers
     thread.swap(mThread);
     mDirectTaskDispatcher = do_QueryInterface(mThread);
-  MOZ_DIAGNOSTIC_ASSERT(
-      mDirectTaskDispatcher,
-      "Underlying thread must support direct task dispatching");
+    MOZ_DIAGNOSTIC_ASSERT(
+        mDirectTaskDispatcher,
+        "Underlying thread must support direct task dispatching");
   }
 
   Preferences::RegisterCallbacks(UpdatePrefs, gCallbackPrefs, this);
@@ -819,23 +816,22 @@
       observer->Observe();
     }
   }
-  if (!XRE_IsContentProcess() ||
-      StaticPrefs::network_allow_raw_sockets_in_content_processes_AtStartup()) {
-    // signal the socket thread to shutdown, it will do a runnable
-    // back to MainThread to call ShutdownThread()
-    mShuttingDown = true;
+
+  mShuttingDown = true;
 
-    {
-      MutexAutoLock lock(mLock);
+  {
+    MutexAutoLock lock(mLock);
 
-      if (mPollableEvent) {
-        mPollableEvent->Signal();
-      }
+    if (mPollableEvent) {
+      mPollableEvent->Signal();
     }
-  } else {
-    // Not running the 'real' socket thread, just shut it down.
+  }
+
+  // If we're shutting down due to going offline (rather than due to XPCOM
+  // shutdown), also tear down the thread. The thread will be shutdown during
+  // xpcom-shutdown-threads if during xpcom-shutdown proper.
+  if (!aXpcomShutdown) {
     ShutdownThread();
-    mSocketThreadShutDown = true;
   }
 
   return NS_OK;
@@ -1257,10 +1253,6 @@
   MOZ_ASSERT(mPollList.Length() == 1);
   MOZ_ASSERT(mActiveList.IsEmpty());
   MOZ_ASSERT(mIdleList.IsEmpty());
-  mSocketThreadShutDown = true;
-  NS_DispatchToMainThread(NS_NewRunnableFunction(
-      "nsSocketTransportService::mSelf",
-      [self = RefPtr{mSelf.forget()}]() { self->ShutdownThread(); }));
 
   return NS_OK;
 }
@@ -1625,7 +1617,7 @@
                               nsITimer::TYPE_ONE_SHOT);
     }
   } else if (!strcmp(topic, "xpcom-shutdown-threads")) {
-    Shutdown(true);
+    ShutdownThread();
   } else if (!strcmp(topic, NS_NETWORK_LINK_TOPIC)) {
     mLastNetworkLinkChangeTime = PR_IntervalNow();
   }