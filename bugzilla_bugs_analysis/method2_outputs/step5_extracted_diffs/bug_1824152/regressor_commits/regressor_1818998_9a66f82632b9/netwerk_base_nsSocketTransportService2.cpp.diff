# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/nsSocketTransportService2.cpp
# Commit: 9a66f82632b9
# Full Hash: 9a66f82632b9654596487b4c9d327b6141dcf685
# Author: Randell Jesup <rjesup@wgate.com>
# Date: 2023-03-16 09:26:07
# Regressor Bug: 1818998
# File Overlap Count: 1
# Description:
#   Bug 1818998: Convert nsSocketTransportService polling arrays to nsTArrays r=valentin,necko-reviewers,kershaw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D171043
# ==============================================================================

diff -r be11e4da5db3 -r 9a66f82632b9 netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp	Wed Mar 15 22:13:36 2023 +0000
+++ b/netwerk/base/nsSocketTransportService2.cpp	Wed Mar 15 22:13:36 2023 +0000
@@ -75,7 +75,7 @@
 
 void nsSocketTransportService::SocketContext::EnsureTimeout(
     PRIntervalTime now) {
-  SOCKET_LOG(("SocketContext::EnsureTimeout socket=%p", mHandler));
+  SOCKET_LOG(("SocketContext::EnsureTimeout socket=%p", mHandler.get()));
   if (!mPollStartEpoch) {
     SOCKET_LOG(("  engaging"));
     mPollStartEpoch = now;
@@ -83,13 +83,13 @@
 }
 
 void nsSocketTransportService::SocketContext::DisengageTimeout() {
-  SOCKET_LOG(("SocketContext::DisengageTimeout socket=%p", mHandler));
+  SOCKET_LOG(("SocketContext::DisengageTimeout socket=%p", mHandler.get()));
   mPollStartEpoch = 0;
 }
 
 PRIntervalTime nsSocketTransportService::SocketContext::TimeoutIn(
     PRIntervalTime now) const {
-  SOCKET_LOG(("SocketContext::TimeoutIn socket=%p, timeout=%us", mHandler,
+  SOCKET_LOG(("SocketContext::TimeoutIn socket=%p, timeout=%us", mHandler.get(),
               mHandler->mPollTimeout));
 
   if (mHandler->mPollTimeout == UINT16_MAX || !mPollStartEpoch) {
@@ -125,15 +125,14 @@
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
 
   PR_CallOnce(&gMaxCountInitOnce, DiscoverMaxCount);
-  mActiveList =
-      (SocketContext*)moz_xmalloc(sizeof(SocketContext) * mActiveListSize);
-  mIdleList =
-      (SocketContext*)moz_xmalloc(sizeof(SocketContext) * mIdleListSize);
-  mPollList =
-      (PRPollDesc*)moz_xmalloc(sizeof(PRPollDesc) * (mActiveListSize + 1));
 
   NS_ASSERTION(!gSocketTransportService, "must not instantiate twice");
   gSocketTransportService = this;
+
+  // The Poll list always has an entry at [0].   The rest of the
+  // list is a duplicate of the Active list's PRFileDesc file descriptors.
+  PRPollDesc entry = {nullptr, PR_POLL_READ | PR_POLL_EXCEPT, 0};
+  mPollList.InsertElementAt(0, entry);
 }
 
 void nsSocketTransportService::ApplyPortRemap(uint16_t* aPort) {
@@ -255,9 +254,6 @@
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
   NS_ASSERTION(!mInitialized, "not shutdown properly");
 
-  free(mActiveList);
-  free(mIdleList);
-  free(mPollList);
   gSocketTransportService = nullptr;
 }
 
@@ -393,14 +389,10 @@
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  SocketContext sock{};
-  sock.mFD = fd;
-  sock.mHandler = handler;
-  sock.mPollStartEpoch = 0;
+  SocketContext sock{fd, handler, 0};
 
-  nsresult rv = AddToIdleList(&sock);
-  if (NS_SUCCEEDED(rv)) NS_ADDREF(handler);
-  return rv;
+  AddToIdleList(&sock);
+  return NS_OK;
 }
 
 // the number of sockets that can be attached at any given time is
@@ -412,7 +404,7 @@
 bool nsSocketTransportService::CanAttachSocket() {
   static bool reported900FDLimit = false;
 
-  uint32_t total = mActiveCount + mIdleCount;
+  uint32_t total = mActiveList.Length() + mIdleList.Length();
   bool rv = total < gMaxCount;
 
   if (Telemetry::CanRecordPrereleaseData() &&
@@ -424,11 +416,11 @@
   return rv;
 }
 
-nsresult nsSocketTransportService::DetachSocket(SocketContext* listHead,
+nsresult nsSocketTransportService::DetachSocket(SocketContextList& listHead,
                                                 SocketContext* sock) {
   SOCKET_LOG(("nsSocketTransportService::DetachSocket [handler=%p]\n",
-              sock->mHandler));
-  MOZ_ASSERT((listHead == mActiveList) || (listHead == mIdleList),
+              sock->mHandler.get()));
+  MOZ_ASSERT((&listHead == &mActiveList) || (&listHead == &mIdleList),
              "DetachSocket invalid head");
 
   {
@@ -440,9 +432,8 @@
 
   // cleanup
   sock->mFD = nullptr;
-  NS_RELEASE(sock->mHandler);
 
-  if (listHead == mActiveList) {
+  if (&listHead == &mActiveList) {
     RemoveFromPollList(sock);
   } else {
     RemoveFromIdleList(sock);
@@ -467,141 +458,109 @@
   return NS_OK;
 }
 
-nsresult nsSocketTransportService::AddToPollList(SocketContext* sock) {
-  MOZ_ASSERT(!(static_cast<uint32_t>(sock - mActiveList) < mActiveListSize),
+// Returns the index of a SocketContext within a list, or -1 if it's
+// not a pointer to a list element
+// NOTE: this could be supplied by nsTArray<>
+int64_t nsSocketTransportService::SockIndex(SocketContextList& aList,
+                                            SocketContext* aSock) {
+  ptrdiff_t index = -1;
+  if (!aList.IsEmpty()) {
+    index = aSock - &aList[0];
+    if (index < 0 || (size_t)index + 1 > aList.Length()) {
+      index = -1;
+    }
+  }
+  return (int64_t)index;
+}
+
+void nsSocketTransportService::AddToPollList(SocketContext* sock) {
+  MOZ_ASSERT(SockIndex(mActiveList, sock) == -1,
              "AddToPollList Socket Already Active");
 
-  SOCKET_LOG(("nsSocketTransportService::AddToPollList [handler=%p]\n",
-              sock->mHandler));
-  if (mActiveCount == mActiveListSize) {
-    SOCKET_LOG(("  Active List size of %d met\n", mActiveCount));
-    if (!GrowActiveList()) {
-      NS_ERROR("too many active sockets");
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
+  SOCKET_LOG(("nsSocketTransportService::AddToPollList %p [handler=%p]\n", sock,
+              sock->mHandler.get()));
+
+  sock->EnsureTimeout(PR_IntervalNow());
+  PRPollDesc poll;
+  poll.fd = sock->mFD;
+  poll.in_flags = sock->mHandler->mPollFlags;
+  poll.out_flags = 0;
+  if (ChaosMode::isActive(ChaosFeature::NetworkScheduling)) {
+    auto newSocketIndex = mActiveList.Length();
+    newSocketIndex = ChaosMode::randomUint32LessThan(newSocketIndex + 1);
+    mActiveList.InsertElementAt(newSocketIndex, *sock);
+    // mPollList is offset by 1
+    mPollList.InsertElementAt(newSocketIndex + 1, poll);
+  } else {
+    // Avoid refcount bump/decrease
+    mActiveList.EmplaceBack(sock->mFD, sock->mHandler.forget(),
+                            sock->mPollStartEpoch);
+    mPollList.AppendElement(poll);
   }
 
-  uint32_t newSocketIndex = mActiveCount;
-  if (ChaosMode::isActive(ChaosFeature::NetworkScheduling)) {
-    newSocketIndex = ChaosMode::randomUint32LessThan(mActiveCount + 1);
-    PodMove(mActiveList + newSocketIndex + 1, mActiveList + newSocketIndex,
-            mActiveCount - newSocketIndex);
-    PodMove(mPollList + newSocketIndex + 2, mPollList + newSocketIndex + 1,
-            mActiveCount - newSocketIndex);
-  }
-
-  sock->EnsureTimeout(PR_IntervalNow());
-  mActiveList[newSocketIndex] = *sock;
-  mActiveCount++;
-
-  mPollList[newSocketIndex + 1].fd = sock->mFD;
-  mPollList[newSocketIndex + 1].in_flags = sock->mHandler->mPollFlags;
-  mPollList[newSocketIndex + 1].out_flags = 0;
-
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
-  return NS_OK;
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::RemoveFromPollList(SocketContext* sock) {
-  SOCKET_LOG(("nsSocketTransportService::RemoveFromPollList [handler=%p]\n",
-              sock->mHandler));
+  SOCKET_LOG(("nsSocketTransportService::RemoveFromPollList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
 
-  uint32_t index = sock - mActiveList;
-  MOZ_ASSERT(index < mActiveListSize, "invalid index");
-
-  SOCKET_LOG(("  index=%u mActiveCount=%u\n", index, mActiveCount));
+  auto index = SockIndex(mActiveList, sock);
+  MOZ_RELEASE_ASSERT(index != -1, "invalid index");
 
-  if (index != mActiveCount - 1) {
-    mActiveList[index] = mActiveList[mActiveCount - 1];
-    mPollList[index + 1] = mPollList[mActiveCount];
-  }
-  mActiveCount--;
+  SOCKET_LOG(("  index=%" PRId64 " mActiveList.Length()=%zu\n", index,
+              mActiveList.Length()));
+  mActiveList.UnorderedRemoveElementAt(index);
+  // mPollList is offset by 1
+  mPollList.UnorderedRemoveElementAt(index + 1);
 
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
-nsresult nsSocketTransportService::AddToIdleList(SocketContext* sock) {
-  MOZ_ASSERT(!(static_cast<uint32_t>(sock - mIdleList) < mIdleListSize),
+void nsSocketTransportService::AddToIdleList(SocketContext* sock) {
+  MOZ_ASSERT(SockIndex(mIdleList, sock) == -1,
              "AddToIdlelList Socket Already Idle");
 
-  SOCKET_LOG(("nsSocketTransportService::AddToIdleList [handler=%p]\n",
-              sock->mHandler));
-  if (mIdleCount == mIdleListSize) {
-    SOCKET_LOG(("  Idle List size of %d met\n", mIdleCount));
-    if (!GrowIdleList()) {
-      NS_ERROR("too many idle sockets");
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
+  SOCKET_LOG(("nsSocketTransportService::AddToIdleList %p [handler=%p]\n", sock,
+              sock->mHandler.get()));
 
-  mIdleList[mIdleCount] = *sock;
-  mIdleCount++;
+  // Avoid refcount bump/decrease
+  mIdleList.EmplaceBack(sock->mFD, sock->mHandler.forget(),
+                        sock->mPollStartEpoch);
 
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
-  return NS_OK;
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::RemoveFromIdleList(SocketContext* sock) {
   SOCKET_LOG(("nsSocketTransportService::RemoveFromIdleList [handler=%p]\n",
-              sock->mHandler));
-
-  uint32_t index = sock - mIdleList;
-  NS_ASSERTION(index < mIdleListSize, "invalid index in idle list");
+              sock->mHandler.get()));
+  auto index = SockIndex(mIdleList, sock);
+  MOZ_RELEASE_ASSERT(index != -1);
+  mIdleList.UnorderedRemoveElementAt(index);
 
-  if (index != mIdleCount - 1) mIdleList[index] = mIdleList[mIdleCount - 1];
-  mIdleCount--;
-
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::MoveToIdleList(SocketContext* sock) {
-  nsresult rv = AddToIdleList(sock);
-  if (NS_FAILED(rv)) {
-    DetachSocket(mActiveList, sock);
-  } else {
-    RemoveFromPollList(sock);
-  }
+  SOCKET_LOG(("nsSocketTransportService::MoveToIdleList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
+  MOZ_ASSERT(SockIndex(mIdleList, sock) == -1);
+  MOZ_ASSERT(SockIndex(mActiveList, sock) != -1);
+  AddToIdleList(sock);
+  RemoveFromPollList(sock);
 }
 
 void nsSocketTransportService::MoveToPollList(SocketContext* sock) {
-  nsresult rv = AddToPollList(sock);
-  if (NS_FAILED(rv)) {
-    DetachSocket(mIdleList, sock);
-  } else {
-    RemoveFromIdleList(sock);
-  }
-}
-
-bool nsSocketTransportService::GrowActiveList() {
-  int32_t toAdd = gMaxCount - mActiveListSize;
-  if (toAdd > 100) {
-    toAdd = 100;
-  } else if (toAdd < 1) {
-    MOZ_ASSERT(false, "CanAttachSocket() should prevent this");
-    return false;
-  }
-
-  mActiveListSize += toAdd;
-  mActiveList = (SocketContext*)moz_xrealloc(
-      mActiveList, sizeof(SocketContext) * mActiveListSize);
-  mPollList = (PRPollDesc*)moz_xrealloc(
-      mPollList, sizeof(PRPollDesc) * (mActiveListSize + 1));
-  return true;
-}
-
-bool nsSocketTransportService::GrowIdleList() {
-  int32_t toAdd = gMaxCount - mIdleListSize;
-  if (toAdd > 100) {
-    toAdd = 100;
-  } else if (toAdd < 1) {
-    MOZ_ASSERT(false, "CanAttachSocket() should prevent this");
-    return false;
-  }
-
-  mIdleListSize += toAdd;
-  mIdleList = (SocketContext*)moz_xrealloc(
-      mIdleList, sizeof(SocketContext) * mIdleListSize);
-  return true;
+  SOCKET_LOG(("nsSocketTransportService::MoveToPollList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
+  MOZ_ASSERT(SockIndex(mIdleList, sock) != -1);
+  MOZ_ASSERT(SockIndex(mActiveList, sock) == -1);
+  AddToPollList(sock);
+  RemoveFromIdleList(sock);
 }
 
 void nsSocketTransportService::ApplyPortRemapPreference(
@@ -615,13 +574,13 @@
 }
 
 PRIntervalTime nsSocketTransportService::PollTimeout(PRIntervalTime now) {
-  if (mActiveCount == 0) {
+  if (mActiveList.IsEmpty()) {
     return NS_SOCKET_POLL_TIMEOUT;
   }
 
   // compute minimum time before any socket timeout expires.
   PRIntervalTime minR = NS_SOCKET_POLL_TIMEOUT;
-  for (uint32_t i = 0; i < mActiveCount; ++i) {
+  for (uint32_t i = 0; i < mActiveList.Length(); ++i) {
     const SocketContext& s = mActiveList[i];
     PRIntervalTime r = s.TimeoutIn(now);
     if (r < minR) {
@@ -639,7 +598,7 @@
 int32_t nsSocketTransportService::Poll(TimeDuration* pollDuration,
                                        PRIntervalTime ts) {
   MOZ_ASSERT(IsOnCurrentThread());
-  PRPollDesc* pollList;
+  PRPollDesc* firstPollEntry;
   uint32_t pollCount;
   PRIntervalTime pollTimeout;
   *pollDuration = nullptr;
@@ -651,16 +610,16 @@
 
   if (mPollList[0].fd) {
     mPollList[0].out_flags = 0;
-    pollList = mPollList;
-    pollCount = mActiveCount + 1;
+    firstPollEntry = &mPollList[0];
+    pollCount = mActiveList.Length() + 1;
     pollTimeout = pendingEvents ? PR_INTERVAL_NO_WAIT : PollTimeout(ts);
   } else {
     // no pollable event, so busy wait...
-    pollCount = mActiveCount;
+    pollCount = mActiveList.Length();
     if (pollCount) {
-      pollList = &mPollList[1];
+      firstPollEntry = &mPollList[1];
     } else {
-      pollList = nullptr;
+      firstPollEntry = nullptr;
     }
     pollTimeout =
         pendingEvents ? PR_INTERVAL_NO_WAIT : PR_MillisecondsToInterval(25);
@@ -695,7 +654,7 @@
     }
 #endif
 
-    rv = PR_Poll(pollList, pollCount, pollTimeout);
+    rv = PR_Poll(firstPollEntry, pollCount, pollTimeout);
 
 #ifdef MOZ_GECKO_PROFILER
     if (pollTimeout != PR_INTERVAL_NO_WAIT) {
@@ -1140,9 +1099,10 @@
       SOCKET_LOG(("running socket transport thread without a pollable event"));
     }
 
-    mPollList[0].fd = mPollableEvent ? mPollableEvent->PollableFD() : nullptr;
-    mPollList[0].in_flags = PR_POLL_READ | PR_POLL_EXCEPT;
-    mPollList[0].out_flags = 0;
+    PRPollDesc entry = {mPollableEvent ? mPollableEvent->PollableFD() : nullptr,
+                        PR_POLL_READ | PR_POLL_EXCEPT, 0};
+    SOCKET_LOG(("Setting entry 0"));
+    mPollList[0] = entry;
   }
 
   mRawThread = NS_GetCurrentThread();
@@ -1293,24 +1253,27 @@
   return NS_OK;
 }
 
-void nsSocketTransportService::DetachSocketWithGuard(bool aGuardLocals,
-                                                     SocketContext* socketList,
-                                                     int32_t index) {
+void nsSocketTransportService::DetachSocketWithGuard(
+    bool aGuardLocals, SocketContextList& socketList, int32_t index) {
   bool isGuarded = false;
   if (aGuardLocals) {
     socketList[index].mHandler->IsLocal(&isGuarded);
-    if (!isGuarded) socketList[index].mHandler->KeepWhenOffline(&isGuarded);
+    if (!isGuarded) {
+      socketList[index].mHandler->KeepWhenOffline(&isGuarded);
+    }
   }
-  if (!isGuarded) DetachSocket(socketList, &socketList[index]);
+  if (!isGuarded) {
+    DetachSocket(socketList, &socketList[index]);
+  }
 }
 
 void nsSocketTransportService::Reset(bool aGuardLocals) {
   // detach any sockets
   int32_t i;
-  for (i = mActiveCount - 1; i >= 0; --i) {
+  for (i = mActiveList.Length() - 1; i >= 0; --i) {
     DetachSocketWithGuard(aGuardLocals, mActiveList, i);
   }
-  for (i = mIdleCount - 1; i >= 0; --i) {
+  for (i = mIdleList.Length() - 1; i >= 0; --i) {
     DetachSocketWithGuard(aGuardLocals, mIdleList, i);
   }
 }
@@ -1320,6 +1283,7 @@
 
   PRIntervalTime now = PR_IntervalNow();
 
+  // We can't have more than int32_max sockets in use
   int32_t i, count;
   //
   // poll loop
@@ -1329,12 +1293,12 @@
   // should become active.  take care to check only idle sockets that
   // were idle to begin with ;-)
   //
-  count = mIdleCount;
-  for (i = mActiveCount - 1; i >= 0; --i) {
+  count = mIdleList.Length();
+  for (i = mActiveList.Length() - 1; i >= 0; --i) {
     //---
     SOCKET_LOG(("  active [%u] { handler=%p condition=%" PRIx32
                 " pollflags=%hu }\n",
-                i, mActiveList[i].mHandler,
+                i, mActiveList[i].mHandler.get(),
                 static_cast<uint32_t>(mActiveList[i].mHandler->mCondition),
                 mActiveList[i].mHandler->mPollFlags));
     //---
@@ -1356,7 +1320,7 @@
     //---
     SOCKET_LOG(("  idle [%u] { handler=%p condition=%" PRIx32
                 " pollflags=%hu }\n",
-                i, mIdleList[i].mHandler,
+                i, mIdleList[i].mHandler.get(),
                 static_cast<uint32_t>(mIdleList[i].mHandler->mCondition),
                 mIdleList[i].mHandler->mPollFlags));
     //---
@@ -1381,14 +1345,14 @@
     }
   }
 
-  SOCKET_LOG(
-      ("  calling PR_Poll [active=%u idle=%u]\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(("  calling PR_Poll [active=%zu idle=%zu]\n", mActiveList.Length(),
+              mIdleList.Length()));
 
 #if defined(XP_WIN)
   // 30 active connections is the historic limit before firefox 7's 256. A few
   //  windows systems have troubles with the higher limit, so actively probe a
   // limit the first time we exceed 30.
-  if ((mActiveCount > 30) && !mProbedMaxCount) ProbeMaxCount();
+  if ((mActiveList.Length() > 30) && !mProbedMaxCount) ProbeMaxCount();
 #endif
 
   // Measures seconds spent while blocked on PR_Poll
@@ -1415,14 +1379,14 @@
     //
     // service "active" sockets...
     //
-    for (i = 0; i < int32_t(mActiveCount); ++i) {
+    for (i = 0; i < int32_t(mActiveList.Length()); ++i) {
       PRPollDesc& desc = mPollList[i + 1];
       SocketContext& s = mActiveList[i];
       if (n > 0 && desc.out_flags != 0) {
         s.DisengageTimeout();
         s.mHandler->OnSocketReady(desc.fd, desc.out_flags);
       } else if (s.IsTimedOut(now)) {
-        SOCKET_LOG(("socket %p timed out", s.mHandler));
+        SOCKET_LOG(("socket %p timed out", s.mHandler.get()));
         s.DisengageTimeout();
         s.mHandler->OnSocketReady(desc.fd, -1);
       } else {
@@ -1433,7 +1397,7 @@
     // check for "dead" sockets and remove them (need to do this in
     // reverse order obviously).
     //
-    for (i = mActiveCount - 1; i >= 0; --i) {
+    for (i = mActiveList.Length() - 1; i >= 0; --i) {
       if (NS_FAILED(mActiveList[i].mHandler->mCondition)) {
         DetachSocket(mActiveList, &mActiveList[i]);
       }
@@ -1578,10 +1542,10 @@
               mKeepaliveEnabledPref ? "enabled" : "disabled"));
 
   // Notify each socket that keepalive has been en/disabled globally.
-  for (int32_t i = mActiveCount - 1; i >= 0; --i) {
+  for (int32_t i = mActiveList.Length() - 1; i >= 0; --i) {
     NotifyKeepaliveEnabledPrefChange(&mActiveList[i]);
   }
-  for (int32_t i = mIdleCount - 1; i >= 0; --i) {
+  for (int32_t i = mIdleList.Length() - 1; i >= 0; --i) {
     NotifyKeepaliveEnabledPrefChange(&mIdleList[i]);
   }
 }
@@ -1660,12 +1624,12 @@
 void nsSocketTransportService::ClosePrivateConnections() {
   MOZ_ASSERT(IsOnCurrentThread(), "Must be called on the socket thread");
 
-  for (int32_t i = mActiveCount - 1; i >= 0; --i) {
+  for (int32_t i = mActiveList.Length() - 1; i >= 0; --i) {
     if (mActiveList[i].mHandler->mIsPrivate) {
       DetachSocket(mActiveList, &mActiveList[i]);
     }
   }
-  for (int32_t i = mIdleCount - 1; i >= 0; --i) {
+  for (int32_t i = mIdleList.Length() - 1; i >= 0; --i) {
     if (mIdleList[i].mHandler->mIsPrivate) {
       DetachSocket(mIdleList, &mIdleList[i]);
     }
@@ -1800,7 +1764,7 @@
 
 // Used to return connection info to Dashboard.cpp
 void nsSocketTransportService::AnalyzeConnection(nsTArray<SocketInfo>* data,
-                                                 struct SocketContext* context,
+                                                 SocketContext* context,
                                                  bool aActive) {
   if (context->mHandler->mIsPrivate) {
     return;
@@ -1866,10 +1830,10 @@
 void nsSocketTransportService::GetSocketConnections(
     nsTArray<SocketInfo>* data) {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
-  for (uint32_t i = 0; i < mActiveCount; i++) {
+  for (uint32_t i = 0; i < mActiveList.Length(); i++) {
     AnalyzeConnection(data, &mActiveList[i], true);
   }
-  for (uint32_t i = 0; i < mIdleCount; i++) {
+  for (uint32_t i = 0; i < mIdleList.Length(); i++) {
     AnalyzeConnection(data, &mIdleList[i], false);
   }
 }