# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/base/nsSocketTransportService2.cpp
# Commit: dc84799cb093
# Full Hash: dc84799cb093c1d8668e7fbb3b3db085135d0c2e
# Author: Randell Jesup <rjesup@wgate.com>
# Date: 2023-03-22 09:41:36
# Regressor Bug: 1818998
# File Overlap Count: 1
# Description:
#   Bug 1818998: Convert nsSocketTransportService polling arrays to nsTArrays r=valentin,necko-reviewers,kershaw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D171043
# ==============================================================================

diff -r b26f6387c979 -r dc84799cb093 netwerk/base/nsSocketTransportService2.cpp
--- a/netwerk/base/nsSocketTransportService2.cpp	Tue Mar 21 15:18:34 2023 +0000
+++ b/netwerk/base/nsSocketTransportService2.cpp	Tue Mar 21 15:22:17 2023 +0000
@@ -18,16 +18,16 @@
 #include "mozilla/ReverseIterator.h"
 #include "mozilla/Services.h"
 #include "mozilla/StaticPrefs_network.h"
+#include "mozilla/Tokenizer.h"
 #include "mozilla/Telemetry.h"
-#include "mozilla/Tokenizer.h"
 #include "nsASocketHandler.h"
 #include "nsError.h"
 #include "nsIFile.h"
+#include "nsINetworkLinkService.h"
 #include "nsIOService.h"
 #include "nsIObserverService.h"
 #include "nsIWidget.h"
 #include "nsServiceManagerUtils.h"
-#include "nsINetworkLinkService.h"
 #include "nsSocketTransport2.h"
 #include "nsThreadUtils.h"
 #include "prerror.h"
@@ -75,7 +75,7 @@
 
 void nsSocketTransportService::SocketContext::EnsureTimeout(
     PRIntervalTime now) {
-  SOCKET_LOG(("SocketContext::EnsureTimeout socket=%p", mHandler));
+  SOCKET_LOG(("SocketContext::EnsureTimeout socket=%p", mHandler.get()));
   if (!mPollStartEpoch) {
     SOCKET_LOG(("  engaging"));
     mPollStartEpoch = now;
@@ -83,13 +83,13 @@
 }
 
 void nsSocketTransportService::SocketContext::DisengageTimeout() {
-  SOCKET_LOG(("SocketContext::DisengageTimeout socket=%p", mHandler));
+  SOCKET_LOG(("SocketContext::DisengageTimeout socket=%p", mHandler.get()));
   mPollStartEpoch = 0;
 }
 
 PRIntervalTime nsSocketTransportService::SocketContext::TimeoutIn(
     PRIntervalTime now) const {
-  SOCKET_LOG(("SocketContext::TimeoutIn socket=%p, timeout=%us", mHandler,
+  SOCKET_LOG(("SocketContext::TimeoutIn socket=%p, timeout=%us", mHandler.get(),
               mHandler->mPollTimeout));
 
   if (mHandler->mPollTimeout == UINT16_MAX || !mPollStartEpoch) {
@@ -125,15 +125,14 @@
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
 
   PR_CallOnce(&gMaxCountInitOnce, DiscoverMaxCount);
-  mActiveList =
-      (SocketContext*)moz_xmalloc(sizeof(SocketContext) * mActiveListSize);
-  mIdleList =
-      (SocketContext*)moz_xmalloc(sizeof(SocketContext) * mIdleListSize);
-  mPollList =
-      (PRPollDesc*)moz_xmalloc(sizeof(PRPollDesc) * (mActiveListSize + 1));
 
   NS_ASSERTION(!gSocketTransportService, "must not instantiate twice");
   gSocketTransportService = this;
+
+  // The Poll list always has an entry at [0].   The rest of the
+  // list is a duplicate of the Active list's PRFileDesc file descriptors.
+  PRPollDesc entry = {nullptr, PR_POLL_READ | PR_POLL_EXCEPT, 0};
+  mPollList.InsertElementAt(0, entry);
 }
 
 void nsSocketTransportService::ApplyPortRemap(uint16_t* aPort) {
@@ -254,10 +253,8 @@
 nsSocketTransportService::~nsSocketTransportService() {
   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
   NS_ASSERTION(!mInitialized, "not shutdown properly");
+  MOZ_ASSERT(mSocketThreadShutDown);
 
-  free(mActiveList);
-  free(mIdleList);
-  free(mPollList);
   gSocketTransportService = nullptr;
 }
 
@@ -393,14 +390,10 @@
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  SocketContext sock{};
-  sock.mFD = fd;
-  sock.mHandler = handler;
-  sock.mPollStartEpoch = 0;
+  SocketContext sock{fd, handler, 0};
 
-  nsresult rv = AddToIdleList(&sock);
-  if (NS_SUCCEEDED(rv)) NS_ADDREF(handler);
-  return rv;
+  AddToIdleList(&sock);
+  return NS_OK;
 }
 
 // the number of sockets that can be attached at any given time is
@@ -412,7 +405,8 @@
 bool nsSocketTransportService::CanAttachSocket() {
   static bool reported900FDLimit = false;
 
-  uint32_t total = mActiveCount + mIdleCount;
+  MOZ_ASSERT(!mShuttingDown);
+  uint32_t total = mActiveList.Length() + mIdleList.Length();
   bool rv = total < gMaxCount;
 
   if (Telemetry::CanRecordPrereleaseData() &&
@@ -420,15 +414,15 @@
     reported900FDLimit = true;
     Telemetry::Accumulate(Telemetry::NETWORK_SESSION_AT_900FD, true);
   }
-
+  MOZ_ASSERT(!mSocketThreadShutDown);
   return rv;
 }
 
-nsresult nsSocketTransportService::DetachSocket(SocketContext* listHead,
+nsresult nsSocketTransportService::DetachSocket(SocketContextList& listHead,
                                                 SocketContext* sock) {
   SOCKET_LOG(("nsSocketTransportService::DetachSocket [handler=%p]\n",
-              sock->mHandler));
-  MOZ_ASSERT((listHead == mActiveList) || (listHead == mIdleList),
+              sock->mHandler.get()));
+  MOZ_ASSERT((&listHead == &mActiveList) || (&listHead == &mIdleList),
              "DetachSocket invalid head");
 
   {
@@ -440,9 +434,8 @@
 
   // cleanup
   sock->mFD = nullptr;
-  NS_RELEASE(sock->mHandler);
 
-  if (listHead == mActiveList) {
+  if (&listHead == &mActiveList) {
     RemoveFromPollList(sock);
   } else {
     RemoveFromIdleList(sock);
@@ -467,141 +460,109 @@
   return NS_OK;
 }
 
-nsresult nsSocketTransportService::AddToPollList(SocketContext* sock) {
-  MOZ_ASSERT(!(static_cast<uint32_t>(sock - mActiveList) < mActiveListSize),
+// Returns the index of a SocketContext within a list, or -1 if it's
+// not a pointer to a list element
+// NOTE: this could be supplied by nsTArray<>
+int64_t nsSocketTransportService::SockIndex(SocketContextList& aList,
+                                            SocketContext* aSock) {
+  ptrdiff_t index = -1;
+  if (!aList.IsEmpty()) {
+    index = aSock - &aList[0];
+    if (index < 0 || (size_t)index + 1 > aList.Length()) {
+      index = -1;
+    }
+  }
+  return (int64_t)index;
+}
+
+void nsSocketTransportService::AddToPollList(SocketContext* sock) {
+  MOZ_ASSERT(SockIndex(mActiveList, sock) == -1,
              "AddToPollList Socket Already Active");
 
-  SOCKET_LOG(("nsSocketTransportService::AddToPollList [handler=%p]\n",
-              sock->mHandler));
-  if (mActiveCount == mActiveListSize) {
-    SOCKET_LOG(("  Active List size of %d met\n", mActiveCount));
-    if (!GrowActiveList()) {
-      NS_ERROR("too many active sockets");
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
+  SOCKET_LOG(("nsSocketTransportService::AddToPollList %p [handler=%p]\n", sock,
+              sock->mHandler.get()));
+
+  sock->EnsureTimeout(PR_IntervalNow());
+  PRPollDesc poll;
+  poll.fd = sock->mFD;
+  poll.in_flags = sock->mHandler->mPollFlags;
+  poll.out_flags = 0;
+  if (ChaosMode::isActive(ChaosFeature::NetworkScheduling)) {
+    auto newSocketIndex = mActiveList.Length();
+    newSocketIndex = ChaosMode::randomUint32LessThan(newSocketIndex + 1);
+    mActiveList.InsertElementAt(newSocketIndex, *sock);
+    // mPollList is offset by 1
+    mPollList.InsertElementAt(newSocketIndex + 1, poll);
+  } else {
+    // Avoid refcount bump/decrease
+    mActiveList.EmplaceBack(sock->mFD, sock->mHandler.forget(),
+                            sock->mPollStartEpoch);
+    mPollList.AppendElement(poll);
   }
 
-  uint32_t newSocketIndex = mActiveCount;
-  if (ChaosMode::isActive(ChaosFeature::NetworkScheduling)) {
-    newSocketIndex = ChaosMode::randomUint32LessThan(mActiveCount + 1);
-    PodMove(mActiveList + newSocketIndex + 1, mActiveList + newSocketIndex,
-            mActiveCount - newSocketIndex);
-    PodMove(mPollList + newSocketIndex + 2, mPollList + newSocketIndex + 1,
-            mActiveCount - newSocketIndex);
-  }
-
-  sock->EnsureTimeout(PR_IntervalNow());
-  mActiveList[newSocketIndex] = *sock;
-  mActiveCount++;
-
-  mPollList[newSocketIndex + 1].fd = sock->mFD;
-  mPollList[newSocketIndex + 1].in_flags = sock->mHandler->mPollFlags;
-  mPollList[newSocketIndex + 1].out_flags = 0;
-
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
-  return NS_OK;
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::RemoveFromPollList(SocketContext* sock) {
-  SOCKET_LOG(("nsSocketTransportService::RemoveFromPollList [handler=%p]\n",
-              sock->mHandler));
+  SOCKET_LOG(("nsSocketTransportService::RemoveFromPollList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
 
-  uint32_t index = sock - mActiveList;
-  MOZ_ASSERT(index < mActiveListSize, "invalid index");
-
-  SOCKET_LOG(("  index=%u mActiveCount=%u\n", index, mActiveCount));
+  auto index = SockIndex(mActiveList, sock);
+  MOZ_RELEASE_ASSERT(index != -1, "invalid index");
 
-  if (index != mActiveCount - 1) {
-    mActiveList[index] = mActiveList[mActiveCount - 1];
-    mPollList[index + 1] = mPollList[mActiveCount];
-  }
-  mActiveCount--;
+  SOCKET_LOG(("  index=%" PRId64 " mActiveList.Length()=%zu\n", index,
+              mActiveList.Length()));
+  mActiveList.UnorderedRemoveElementAt(index);
+  // mPollList is offset by 1
+  mPollList.UnorderedRemoveElementAt(index + 1);
 
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
-nsresult nsSocketTransportService::AddToIdleList(SocketContext* sock) {
-  MOZ_ASSERT(!(static_cast<uint32_t>(sock - mIdleList) < mIdleListSize),
-             "AddToIdlelList Socket Already Idle");
+void nsSocketTransportService::AddToIdleList(SocketContext* sock) {
+  MOZ_ASSERT(SockIndex(mIdleList, sock) == -1,
+             "AddToIdleList Socket Already Idle");
+
+  SOCKET_LOG(("nsSocketTransportService::AddToIdleList %p [handler=%p]\n", sock,
+              sock->mHandler.get()));
 
-  SOCKET_LOG(("nsSocketTransportService::AddToIdleList [handler=%p]\n",
-              sock->mHandler));
-  if (mIdleCount == mIdleListSize) {
-    SOCKET_LOG(("  Idle List size of %d met\n", mIdleCount));
-    if (!GrowIdleList()) {
-      NS_ERROR("too many idle sockets");
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
+  // Avoid refcount bump/decrease
+  mIdleList.EmplaceBack(sock->mFD, sock->mHandler.forget(),
+                        sock->mPollStartEpoch);
 
-  mIdleList[mIdleCount] = *sock;
-  mIdleCount++;
-
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
-  return NS_OK;
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::RemoveFromIdleList(SocketContext* sock) {
   SOCKET_LOG(("nsSocketTransportService::RemoveFromIdleList [handler=%p]\n",
-              sock->mHandler));
-
-  uint32_t index = sock - mIdleList;
-  NS_ASSERTION(index < mIdleListSize, "invalid index in idle list");
+              sock->mHandler.get()));
+  auto index = SockIndex(mIdleList, sock);
+  MOZ_RELEASE_ASSERT(index != -1);
+  mIdleList.UnorderedRemoveElementAt(index);
 
-  if (index != mIdleCount - 1) mIdleList[index] = mIdleList[mIdleCount - 1];
-  mIdleCount--;
-
-  SOCKET_LOG(("  active=%u idle=%u\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(
+      ("  active=%zu idle=%zu\n", mActiveList.Length(), mIdleList.Length()));
 }
 
 void nsSocketTransportService::MoveToIdleList(SocketContext* sock) {
-  nsresult rv = AddToIdleList(sock);
-  if (NS_FAILED(rv)) {
-    DetachSocket(mActiveList, sock);
-  } else {
-    RemoveFromPollList(sock);
-  }
+  SOCKET_LOG(("nsSocketTransportService::MoveToIdleList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
+  MOZ_ASSERT(SockIndex(mIdleList, sock) == -1);
+  MOZ_ASSERT(SockIndex(mActiveList, sock) != -1);
+  AddToIdleList(sock);
+  RemoveFromPollList(sock);
 }
 
 void nsSocketTransportService::MoveToPollList(SocketContext* sock) {
-  nsresult rv = AddToPollList(sock);
-  if (NS_FAILED(rv)) {
-    DetachSocket(mIdleList, sock);
-  } else {
-    RemoveFromIdleList(sock);
-  }
-}
-
-bool nsSocketTransportService::GrowActiveList() {
-  int32_t toAdd = gMaxCount - mActiveListSize;
-  if (toAdd > 100) {
-    toAdd = 100;
-  } else if (toAdd < 1) {
-    MOZ_ASSERT(false, "CanAttachSocket() should prevent this");
-    return false;
-  }
-
-  mActiveListSize += toAdd;
-  mActiveList = (SocketContext*)moz_xrealloc(
-      mActiveList, sizeof(SocketContext) * mActiveListSize);
-  mPollList = (PRPollDesc*)moz_xrealloc(
-      mPollList, sizeof(PRPollDesc) * (mActiveListSize + 1));
-  return true;
-}
-
-bool nsSocketTransportService::GrowIdleList() {
-  int32_t toAdd = gMaxCount - mIdleListSize;
-  if (toAdd > 100) {
-    toAdd = 100;
-  } else if (toAdd < 1) {
-    MOZ_ASSERT(false, "CanAttachSocket() should prevent this");
-    return false;
-  }
-
-  mIdleListSize += toAdd;
-  mIdleList = (SocketContext*)moz_xrealloc(
-      mIdleList, sizeof(SocketContext) * mIdleListSize);
-  return true;
+  SOCKET_LOG(("nsSocketTransportService::MoveToPollList %p [handler=%p]\n",
+              sock, sock->mHandler.get()));
+  MOZ_ASSERT(SockIndex(mIdleList, sock) != -1);
+  MOZ_ASSERT(SockIndex(mActiveList, sock) == -1);
+  AddToPollList(sock);
+  RemoveFromIdleList(sock);
 }
 
 void nsSocketTransportService::ApplyPortRemapPreference(
@@ -615,13 +576,13 @@
 }
 
 PRIntervalTime nsSocketTransportService::PollTimeout(PRIntervalTime now) {
-  if (mActiveCount == 0) {
+  if (mActiveList.IsEmpty()) {
     return NS_SOCKET_POLL_TIMEOUT;
   }
 
   // compute minimum time before any socket timeout expires.
   PRIntervalTime minR = NS_SOCKET_POLL_TIMEOUT;
-  for (uint32_t i = 0; i < mActiveCount; ++i) {
+  for (uint32_t i = 0; i < mActiveList.Length(); ++i) {
     const SocketContext& s = mActiveList[i];
     PRIntervalTime r = s.TimeoutIn(now);
     if (r < minR) {
@@ -639,7 +600,7 @@
 int32_t nsSocketTransportService::Poll(TimeDuration* pollDuration,
                                        PRIntervalTime ts) {
   MOZ_ASSERT(IsOnCurrentThread());
-  PRPollDesc* pollList;
+  PRPollDesc* firstPollEntry;
   uint32_t pollCount;
   PRIntervalTime pollTimeout;
   *pollDuration = nullptr;
@@ -651,16 +612,16 @@
 
   if (mPollList[0].fd) {
     mPollList[0].out_flags = 0;
-    pollList = mPollList;
-    pollCount = mActiveCount + 1;
+    firstPollEntry = &mPollList[0];
+    pollCount = mPollList.Length();
     pollTimeout = pendingEvents ? PR_INTERVAL_NO_WAIT : PollTimeout(ts);
   } else {
     // no pollable event, so busy wait...
-    pollCount = mActiveCount;
+    pollCount = mActiveList.Length();
     if (pollCount) {
-      pollList = &mPollList[1];
+      firstPollEntry = &mPollList[1];
     } else {
-      pollList = nullptr;
+      firstPollEntry = nullptr;
     }
     pollTimeout =
         pendingEvents ? PR_INTERVAL_NO_WAIT : PR_MillisecondsToInterval(25);
@@ -695,7 +656,7 @@
     }
 #endif
 
-    rv = PR_Poll(pollList, pollCount, pollTimeout);
+    rv = PR_Poll(firstPollEntry, pollCount, pollTimeout);
 
 #ifdef MOZ_GECKO_PROFILER
     if (pollTimeout != PR_INTERVAL_NO_WAIT) {
@@ -792,6 +753,8 @@
     nsresult rv = NS_NewNamedThread("Socket Thread", getter_AddRefs(thread),
                                     this, {.stackSize = GetThreadStackSize()});
     NS_ENSURE_SUCCESS(rv, rv);
+    // Since ::Run() will assume it can access this->*, hold a ref for it
+    mSelf = this;
   } else {
     // In the child process, we just want a regular nsThread with no socket
     // polling. So we don't want to run the nsSocketTransportService runnable on
@@ -860,20 +823,22 @@
       observer->Observe();
     }
   }
+  if (!XRE_IsContentProcess()) {
+    // signal the socket thread to shutdown, it will do a runnable
+    // back to MainThread to call ShutdownThread()
+    mShuttingDown = true;
 
-  // signal the socket thread to shutdown
-  mShuttingDown = true;
-
-  {
-    MutexAutoLock lock(mLock);
+    {
+      MutexAutoLock lock(mLock);
 
-    if (mPollableEvent) {
-      mPollableEvent->Signal();
+      if (mPollableEvent) {
+        mPollableEvent->Signal();
+      }
     }
-  }
-
-  if (!aXpcomShutdown) {
-    return ShutdownThread();
+  } else {
+    // Not running the 'real' socket thread, just shut it down.
+    ShutdownThread();
+    mSocketThreadShutDown = true;
   }
 
   return NS_OK;
@@ -884,7 +849,7 @@
 
   NS_ENSURE_STATE(NS_IsMainThread());
 
-  if (!mInitialized || !mShuttingDown) {
+  if (!mInitialized) {
     return NS_OK;
   }
 
@@ -1140,9 +1105,10 @@
       SOCKET_LOG(("running socket transport thread without a pollable event"));
     }
 
-    mPollList[0].fd = mPollableEvent ? mPollableEvent->PollableFD() : nullptr;
-    mPollList[0].in_flags = PR_POLL_READ | PR_POLL_EXCEPT;
-    mPollList[0].out_flags = 0;
+    PRPollDesc entry = {mPollableEvent ? mPollableEvent->PollableFD() : nullptr,
+                        PR_POLL_READ | PR_POLL_EXCEPT, 0};
+    SOCKET_LOG(("Setting entry 0"));
+    mPollList[0] = entry;
   }
 
   mRawThread = NS_GetCurrentThread();
@@ -1281,7 +1247,7 @@
   Reset(false);
 
   // We don't clear gSocketThread so that OnSocketThread() won't be a false
-  // alarm for events generated by stopping the SLL threads during shutdown.
+  // alarm for events generated by stopping the SSL threads during shutdown.
   psm::StopSSLServerCertVerificationThreads();
 
   // Final pass over the event queue. This makes sure that events posted by
@@ -1289,28 +1255,38 @@
   NS_ProcessPendingEvents(mRawThread);
 
   SOCKET_LOG(("STS thread exit\n"));
+  MOZ_ASSERT(mPollList.Length() == 1);
+  MOZ_ASSERT(mActiveList.IsEmpty());
+  MOZ_ASSERT(mIdleList.IsEmpty());
+  mSocketThreadShutDown = true;
+  NS_DispatchToMainThread(NS_NewRunnableFunction(
+      "nsSocketTransportService::mSelf",
+      [self = RefPtr{mSelf.forget()}]() { self->ShutdownThread(); }));
 
   return NS_OK;
 }
 
-void nsSocketTransportService::DetachSocketWithGuard(bool aGuardLocals,
-                                                     SocketContext* socketList,
-                                                     int32_t index) {
+void nsSocketTransportService::DetachSocketWithGuard(
+    bool aGuardLocals, SocketContextList& socketList, int32_t index) {
   bool isGuarded = false;
   if (aGuardLocals) {
     socketList[index].mHandler->IsLocal(&isGuarded);
-    if (!isGuarded) socketList[index].mHandler->KeepWhenOffline(&isGuarded);
+    if (!isGuarded) {
+      socketList[index].mHandler->KeepWhenOffline(&isGuarded);
+    }
   }
-  if (!isGuarded) DetachSocket(socketList, &socketList[index]);
+  if (!isGuarded) {
+    DetachSocket(socketList, &socketList[index]);
+  }
 }
 
 void nsSocketTransportService::Reset(bool aGuardLocals) {
   // detach any sockets
   int32_t i;
-  for (i = mActiveCount - 1; i >= 0; --i) {
+  for (i = mActiveList.Length() - 1; i >= 0; --i) {
     DetachSocketWithGuard(aGuardLocals, mActiveList, i);
   }
-  for (i = mIdleCount - 1; i >= 0; --i) {
+  for (i = mIdleList.Length() - 1; i >= 0; --i) {
     DetachSocketWithGuard(aGuardLocals, mIdleList, i);
   }
 }
@@ -1320,6 +1296,7 @@
 
   PRIntervalTime now = PR_IntervalNow();
 
+  // We can't have more than int32_max sockets in use
   int32_t i, count;
   //
   // poll loop
@@ -1329,12 +1306,12 @@
   // should become active.  take care to check only idle sockets that
   // were idle to begin with ;-)
   //
-  count = mIdleCount;
-  for (i = mActiveCount - 1; i >= 0; --i) {
+  count = mIdleList.Length();
+  for (i = mActiveList.Length() - 1; i >= 0; --i) {
     //---
     SOCKET_LOG(("  active [%u] { handler=%p condition=%" PRIx32
                 " pollflags=%hu }\n",
-                i, mActiveList[i].mHandler,
+                i, mActiveList[i].mHandler.get(),
                 static_cast<uint32_t>(mActiveList[i].mHandler->mCondition),
                 mActiveList[i].mHandler->mPollFlags));
     //---
@@ -1356,7 +1333,7 @@
     //---
     SOCKET_LOG(("  idle [%u] { handler=%p condition=%" PRIx32
                 " pollflags=%hu }\n",
-                i, mIdleList[i].mHandler,
+                i, mIdleList[i].mHandler.get(),
                 static_cast<uint32_t>(mIdleList[i].mHandler->mCondition),
                 mIdleList[i].mHandler->mPollFlags));
     //---
@@ -1381,14 +1358,14 @@
     }
   }
 
-  SOCKET_LOG(
-      ("  calling PR_Poll [active=%u idle=%u]\n", mActiveCount, mIdleCount));
+  SOCKET_LOG(("  calling PR_Poll [active=%zu idle=%zu]\n", mActiveList.Length(),
+              mIdleList.Length()));
 
 #if defined(XP_WIN)
   // 30 active connections is the historic limit before firefox 7's 256. A few
   //  windows systems have troubles with the higher limit, so actively probe a
   // limit the first time we exceed 30.
-  if ((mActiveCount > 30) && !mProbedMaxCount) ProbeMaxCount();
+  if ((mActiveList.Length() > 30) && !mProbedMaxCount) ProbeMaxCount();
 #endif
 
   // Measures seconds spent while blocked on PR_Poll
@@ -1415,14 +1392,14 @@
     //
     // service "active" sockets...
     //
-    for (i = 0; i < int32_t(mActiveCount); ++i) {
+    for (i = 0; i < int32_t(mActiveList.Length()); ++i) {
       PRPollDesc& desc = mPollList[i + 1];
       SocketContext& s = mActiveList[i];
       if (n > 0 && desc.out_flags != 0) {
         s.DisengageTimeout();
         s.mHandler->OnSocketReady(desc.fd, desc.out_flags);
       } else if (s.IsTimedOut(now)) {
-        SOCKET_LOG(("socket %p timed out", s.mHandler));
+        SOCKET_LOG(("socket %p timed out", s.mHandler.get()));
         s.DisengageTimeout();
         s.mHandler->OnSocketReady(desc.fd, -1);
       } else {
@@ -1433,7 +1410,7 @@
     // check for "dead" sockets and remove them (need to do this in
     // reverse order obviously).
     //
-    for (i = mActiveCount - 1; i >= 0; --i) {
+    for (i = mActiveList.Length() - 1; i >= 0; --i) {
       if (NS_FAILED(mActiveList[i].mHandler->mCondition)) {
         DetachSocket(mActiveList, &mActiveList[i]);
       }
@@ -1578,10 +1555,10 @@
               mKeepaliveEnabledPref ? "enabled" : "disabled"));
 
   // Notify each socket that keepalive has been en/disabled globally.
-  for (int32_t i = mActiveCount - 1; i >= 0; --i) {
+  for (int32_t i = mActiveList.Length() - 1; i >= 0; --i) {
     NotifyKeepaliveEnabledPrefChange(&mActiveList[i]);
   }
-  for (int32_t i = mIdleCount - 1; i >= 0; --i) {
+  for (int32_t i = mIdleList.Length() - 1; i >= 0; --i) {
     NotifyKeepaliveEnabledPrefChange(&mIdleList[i]);
   }
 }
@@ -1649,7 +1626,7 @@
                               nsITimer::TYPE_ONE_SHOT);
     }
   } else if (!strcmp(topic, "xpcom-shutdown-threads")) {
-    ShutdownThread();
+    Shutdown(true);
   } else if (!strcmp(topic, NS_NETWORK_LINK_TOPIC)) {
     mLastNetworkLinkChangeTime = PR_IntervalNow();
   }
@@ -1660,12 +1637,12 @@
 void nsSocketTransportService::ClosePrivateConnections() {
   MOZ_ASSERT(IsOnCurrentThread(), "Must be called on the socket thread");
 
-  for (int32_t i = mActiveCount - 1; i >= 0; --i) {
+  for (int32_t i = mActiveList.Length() - 1; i >= 0; --i) {
     if (mActiveList[i].mHandler->mIsPrivate) {
       DetachSocket(mActiveList, &mActiveList[i]);
     }
   }
-  for (int32_t i = mIdleCount - 1; i >= 0; --i) {
+  for (int32_t i = mIdleList.Length() - 1; i >= 0; --i) {
     if (mIdleList[i].mHandler->mIsPrivate) {
       DetachSocket(mIdleList, &mIdleList[i]);
     }
@@ -1800,7 +1777,7 @@
 
 // Used to return connection info to Dashboard.cpp
 void nsSocketTransportService::AnalyzeConnection(nsTArray<SocketInfo>* data,
-                                                 struct SocketContext* context,
+                                                 SocketContext* context,
                                                  bool aActive) {
   if (context->mHandler->mIsPrivate) {
     return;
@@ -1866,10 +1843,10 @@
 void nsSocketTransportService::GetSocketConnections(
     nsTArray<SocketInfo>* data) {
   MOZ_ASSERT(OnSocketThread(), "not on socket thread");
-  for (uint32_t i = 0; i < mActiveCount; i++) {
+  for (uint32_t i = 0; i < mActiveList.Length(); i++) {
     AnalyzeConnection(data, &mActiveList[i], true);
   }
-  for (uint32_t i = 0; i < mIdleCount; i++) {
+  for (uint32_t i = 0; i < mIdleList.Length(); i++) {
     AnalyzeConnection(data, &mIdleList[i], false);
   }
 }