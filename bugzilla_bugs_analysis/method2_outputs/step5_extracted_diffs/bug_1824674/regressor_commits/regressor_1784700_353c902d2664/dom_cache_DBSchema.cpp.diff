# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/cache/DBSchema.cpp
# Commit: 353c902d2664
# Full Hash: 353c902d2664f7065a08aafe32092ef851e31dba
# Author: Harveer Singh <hsingh@mozilla.com>
# Date: 2022-09-17 09:35:37
# Regressor Bug: 1784700
# File Overlap Count: 1
# Description:
#   Bug 1784700: Fixed a bug where deleting cache could leak files; as a result they never get purged. r=dom-storage-reviewers,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D156184
# ==============================================================================

diff -r a94fe0d54965 -r 353c902d2664 dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp	Fri Sep 16 18:56:51 2022 +0000
+++ b/dom/cache/DBSchema.cpp	Fri Sep 16 19:42:12 2022 +0000
@@ -202,7 +202,7 @@
 // End schema definition
 // ---------
 
-const int32_t kMaxEntriesPerStatement = 255;
+const uint32_t kMaxEntriesPerStatement = 255;
 
 const uint32_t kPageSize = 4 * 1024;
 
@@ -372,6 +372,11 @@
               nsresult>
 DeleteEntries(mozIStorageConnection& aConn,
               const nsTArray<EntryId>& aEntryIdList);
+
+static Result<std::tuple<nsTArray<nsID>, AutoTArray<IdCount, 16>, int64_t>,
+              nsresult>
+DeleteAllCacheEntries(mozIStorageConnection& aConn, CacheId& aCacheId);
+
 static Result<int32_t, nsresult> InsertSecurityInfo(
     mozIStorageConnection& aConn, nsICryptoHash& aCrypto,
     nsITransportSecurityInfo* aSecurityInfo);
@@ -390,12 +395,9 @@
 static Result<SavedRequest, nsresult> ReadRequest(mozIStorageConnection& aConn,
                                                   EntryId aEntryId);
 
-static void AppendListParamsToQuery(nsACString& aQuery,
-                                    const nsTArray<EntryId>& aEntryIdList,
-                                    uint32_t aPos, int32_t aLen);
+static void AppendListParamsToQuery(nsACString& aQuery, size_t aLen);
 static nsresult BindListParamsToQuery(mozIStorageStatement& aState,
-                                      const nsTArray<EntryId>& aEntryIdList,
-                                      uint32_t aPos, int32_t aLen);
+                                      const Span<const EntryId>& aEntryIdList);
 static nsresult BindId(mozIStorageStatement& aState, const nsACString& aName,
                        const nsID* aId);
 static Result<nsID, nsresult> ExtractId(mozIStorageStatement& aState,
@@ -627,15 +629,10 @@
                                              CacheId aCacheId) {
   MOZ_ASSERT(!NS_IsMainThread());
 
-  // Delete the bodies explicitly as we need to read out the body IDs
-  // anyway.  These body IDs must be deleted one-by-one as content may
-  // still be referencing them invidivually.
-  QM_TRY_INSPECT(const auto& matches, QueryAll(aConn, aCacheId));
-
   // XXX only deletedBodyIdList needs to be non-const
   QM_TRY_UNWRAP(
       (auto [deletedBodyIdList, deletedSecurityIdList, deletedPaddingSize]),
-      DeleteEntries(aConn, matches));
+      DeleteAllCacheEntries(aConn, aCacheId));
 
   QM_TRY(MOZ_TO_RESULT(DeleteSecurityInfoList(aConn, deletedSecurityIdList)));
 
@@ -1201,48 +1198,11 @@
   return varyHeadersMatch;
 }
 
-static nsresult DeleteEntriesInternal(
-    mozIStorageConnection& aConn, const nsTArray<EntryId>& aEntryIdList,
+static nsresult SelectAndDeleteEntriesInternal(
+    mozIStorageConnection& aConn, const Span<const EntryId>& aEntryIdList,
     nsTArray<nsID>& aDeletedBodyIdListOut,
     nsTArray<IdCount>& aDeletedSecurityIdListOut,
-    int64_t* aDeletedPaddingSizeOut, uint32_t aPos, uint32_t aLen) {
-  MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_DIAGNOSTIC_ASSERT(aDeletedPaddingSizeOut);
-
-  if (aEntryIdList.IsEmpty()) {
-    return NS_OK;
-  }
-
-  MOZ_DIAGNOSTIC_ASSERT(aPos < aEntryIdList.Length());
-
-  // Sqlite limits the number of entries allowed for an IN clause,
-  // so split up larger operations.
-  if (aLen > kMaxEntriesPerStatement) {
-    int64_t overallDeletedPaddingSize = 0;
-    uint32_t curPos = aPos;
-    int32_t remaining = aLen;
-    while (remaining > 0) {
-      int64_t deletedPaddingSize = 0;
-      int32_t max = kMaxEntriesPerStatement;
-      int32_t curLen = std::min(max, remaining);
-      nsresult rv = DeleteEntriesInternal(
-          aConn, aEntryIdList, aDeletedBodyIdListOut, aDeletedSecurityIdListOut,
-          &deletedPaddingSize, curPos, curLen);
-      if (NS_FAILED(rv)) {
-        return rv;
-      }
-
-      MOZ_DIAGNOSTIC_ASSERT(INT64_MAX - deletedPaddingSize >=
-                            overallDeletedPaddingSize);
-      overallDeletedPaddingSize += deletedPaddingSize;
-      curPos += curLen;
-      remaining -= curLen;
-    }
-
-    *aDeletedPaddingSizeOut += overallDeletedPaddingSize;
-    return NS_OK;
-  }
-
+    int64_t& aDeletedPaddingSizeOut) {
   nsAutoCString query(
       "SELECT "
       "request_body_id, "
@@ -1250,15 +1210,15 @@
       "response_security_info_id, "
       "response_padding_size "
       "FROM entries WHERE id IN (");
-  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+
+  AppendListParamsToQuery(query, aEntryIdList.Length());
   query.AppendLiteral(")");
 
   QM_TRY_INSPECT(const auto& state, MOZ_TO_RESULT_INVOKE_MEMBER_TYPED(
                                         nsCOMPtr<mozIStorageStatement>, aConn,
                                         CreateStatement, query));
 
-  QM_TRY(
-      MOZ_TO_RESULT(BindListParamsToQuery(*state, aEntryIdList, aPos, aLen)));
+  QM_TRY(MOZ_TO_RESULT(BindListParamsToQuery(*state, aEntryIdList)));
 
   int64_t overallPaddingSize = 0;
 
@@ -1324,12 +1284,12 @@
         return Ok{};
       }));
 
-  *aDeletedPaddingSizeOut = overallPaddingSize;
+  aDeletedPaddingSizeOut += overallPaddingSize;
 
   // Dependent records removed via ON DELETE CASCADE
 
   query = "DELETE FROM entries WHERE id IN ("_ns;
-  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  AppendListParamsToQuery(query, aEntryIdList.Length());
   query.AppendLiteral(")");
 
   {
@@ -1337,8 +1297,7 @@
                                           nsCOMPtr<mozIStorageStatement>, aConn,
                                           CreateStatement, query));
 
-    QM_TRY(
-        MOZ_TO_RESULT(BindListParamsToQuery(*state, aEntryIdList, aPos, aLen)));
+    QM_TRY(MOZ_TO_RESULT(BindListParamsToQuery(*state, aEntryIdList)));
 
     QM_TRY(MOZ_TO_RESULT(state->Execute()));
   }
@@ -1346,14 +1305,148 @@
   return NS_OK;
 }
 
+static nsresult DeleteEntriesInternal(
+    mozIStorageConnection& aConn, const nsTArray<EntryId>& aEntryIdList,
+    nsTArray<nsID>& aDeletedBodyIdListOut,
+    nsTArray<IdCount>& aDeletedSecurityIdListOut,
+    int64_t& aDeletedPaddingSizeOut, uint32_t aPos, uint32_t aLen) {
+  MOZ_ASSERT(!NS_IsMainThread());
+
+  if (aEntryIdList.IsEmpty()) {
+    return NS_OK;
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(aPos < aEntryIdList.Length());
+
+  auto remaining = aLen;
+  uint32_t currPos = 0;
+
+  do {
+    // Sqlite limits the number of entries allowed for an IN clause,
+    // so split up larger operations.
+    auto currLen = std::min(kMaxEntriesPerStatement, remaining);
+
+    SelectAndDeleteEntriesInternal(
+        aConn, Span<const EntryId>(aEntryIdList.Elements() + currPos, currLen),
+        aDeletedBodyIdListOut, aDeletedSecurityIdListOut,
+        aDeletedPaddingSizeOut);
+
+    remaining -= currLen;
+    currPos += currLen;
+
+  } while (remaining > 0);
+
+  return NS_OK;
+}
+
 Result<std::tuple<nsTArray<nsID>, AutoTArray<IdCount, 16>, int64_t>, nsresult>
 DeleteEntries(mozIStorageConnection& aConn,
               const nsTArray<EntryId>& aEntryIdList) {
   auto result =
       std::make_tuple(nsTArray<nsID>{}, AutoTArray<IdCount, 16>{}, int64_t{0});
+
   QM_TRY(MOZ_TO_RESULT(DeleteEntriesInternal(
       aConn, aEntryIdList, std::get<0>(result), std::get<1>(result),
-      &std::get<2>(result), 0, aEntryIdList.Length())));
+      std::get<2>(result), 0, aEntryIdList.Length())));
+
+  return result;
+}
+
+Result<std::tuple<nsTArray<nsID>, AutoTArray<IdCount, 16>, int64_t>, nsresult>
+DeleteAllCacheEntries(mozIStorageConnection& aConn, CacheId& aCacheId) {
+  auto result =
+      std::make_tuple(nsTArray<nsID>{}, AutoTArray<IdCount, 16>{}, int64_t{0});
+  auto& deletedBodyIdList = std::get<0>(result);
+  auto& deletedSecurityIdList = std::get<1>(result);
+  auto& deletedPaddingSize = std::get<2>(result);
+
+  nsAutoCString query(
+      "SELECT "
+      "request_body_id, "
+      "response_body_id, "
+      "response_security_info_id, "
+      "response_padding_size "
+      "FROM entries WHERE cache_id=:cache_id ORDER BY id;"_ns);
+
+  QM_TRY_INSPECT(const auto& state, MOZ_TO_RESULT_INVOKE_MEMBER_TYPED(
+                                        nsCOMPtr<mozIStorageStatement>, aConn,
+                                        CreateStatement, query));
+
+  QM_TRY(MOZ_TO_RESULT(state->BindInt64ByName("cache_id"_ns, aCacheId)));
+
+  QM_TRY(quota::CollectWhileHasResult(
+      *state,
+      [&deletedPaddingSize, &deletedBodyIdList,
+       &deletedSecurityIdList](auto& stmt) -> Result<Ok, nsresult> {
+        // extract 0 to 2 nsID structs per row
+        for (uint32_t i = 0; i < 2; ++i) {
+          QM_TRY_INSPECT(const bool& isNull,
+                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetIsNull, i));
+
+          if (!isNull) {
+            QM_TRY_INSPECT(const auto& id, ExtractId(stmt, i));
+
+            deletedBodyIdList.AppendElement(id);
+          }
+        }
+
+        {  // and then a possible third entry for the security id
+          QM_TRY_INSPECT(const bool& isNull,
+                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetIsNull, 2));
+
+          if (!isNull) {
+            QM_TRY_INSPECT(const int32_t& securityId,
+                           MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt32, 2));
+
+            // XXXtt: Consider using map for aDeletedSecuityIdListOut.
+            auto foundIt = std::find_if(
+                deletedSecurityIdList.begin(), deletedSecurityIdList.end(),
+                [securityId](const auto& deletedSecurityId) {
+                  return deletedSecurityId.mId == securityId;
+                });
+
+            if (foundIt == deletedSecurityIdList.end()) {
+              // Add a new entry for this ID with a count of 1, if it's not in
+              // the list
+              deletedSecurityIdList.AppendElement(IdCount(securityId));
+            } else {
+              // Otherwise, increment the count for this ID
+              foundIt->mCount += 1;
+            }
+          }
+        }
+
+        {
+          // It's possible to have null padding size for non-opaque response
+          QM_TRY_INSPECT(const bool& isNull,
+                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetIsNull, 3));
+
+          if (!isNull) {
+            QM_TRY_INSPECT(const int64_t& paddingSize,
+                           MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt64, 3));
+
+            MOZ_DIAGNOSTIC_ASSERT(paddingSize >= 0);
+            MOZ_DIAGNOSTIC_ASSERT(paddingSize + deletedPaddingSize <= INT_MAX);
+
+            deletedPaddingSize += paddingSize;
+          }
+        }
+
+        return Ok{};
+      }));
+
+  // Dependent records removed via ON DELETE CASCADE
+
+  query = "DELETE FROM entries WHERE cache_id=:cache_id"_ns;
+
+  {
+    QM_TRY_INSPECT(const auto& state, MOZ_TO_RESULT_INVOKE_MEMBER_TYPED(
+                                          nsCOMPtr<mozIStorageStatement>, aConn,
+                                          CreateStatement, query));
+
+    QM_TRY(MOZ_TO_RESULT(state->BindInt64ByName("cache_id"_ns, aCacheId)));
+    QM_TRY(MOZ_TO_RESULT(state->Execute()));
+  }
 
   return result;
 }
@@ -2071,28 +2164,19 @@
   return savedRequest;
 }
 
-void AppendListParamsToQuery(nsACString& aQuery,
-                             const nsTArray<EntryId>& aEntryIdList,
-                             uint32_t aPos, int32_t aLen) {
+void AppendListParamsToQuery(nsACString& aQuery, size_t aLen) {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_DIAGNOSTIC_ASSERT((aPos + aLen) <= aEntryIdList.Length());
-
-  // XXX This seems to be quite inefficient. Can't we do a BulkWrite?
-  for (int32_t i = aPos; i < aLen; ++i) {
-    if (i == 0) {
-      aQuery.AppendLiteral("?");
-    } else {
-      aQuery.AppendLiteral(",?");
-    }
+
+  aQuery.AppendLiteral("?");
+  for (size_t i = 1; i < aLen; ++i) {
+    aQuery.AppendLiteral(",?");
   }
 }
 
 nsresult BindListParamsToQuery(mozIStorageStatement& aState,
-                               const nsTArray<EntryId>& aEntryIdList,
-                               uint32_t aPos, int32_t aLen) {
+                               const Span<const EntryId>& aEntryIdList) {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_DIAGNOSTIC_ASSERT((aPos + aLen) <= aEntryIdList.Length());
-  for (int32_t i = aPos; i < aLen; ++i) {
+  for (size_t i = 0, n = aEntryIdList.Length(); i < n; ++i) {
     QM_TRY(MOZ_TO_RESULT(aState.BindInt32ByIndex(i, aEntryIdList[i])));
   }
   return NS_OK;
