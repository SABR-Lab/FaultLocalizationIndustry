# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/ScriptLoader.cpp
# Commit: 40b8abaf1c0b
# Full Hash: 40b8abaf1c0b4e4041d5974de350b9c6e2b1ec0d
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2022-12-15 09:27:59
# Regressor Bug: 1247687
# File Overlap Count: 1
# Description:
#   Bug 1247687 - Handle cancellation of long running modules; r=jonco
#   
#   This is a slightly annoying thing that can happen. When we abruptly cancel (such as an infinitely
#   running script being forcibly terminated) we will be in a state where the EvaluateModule call will
#   finish _after_ the loader is destroyed. So, instead we track if there has been a forcible
# ==============================================================================

diff -r 0c9650a1ac48 -r 40b8abaf1c0b dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp	Wed Dec 14 14:55:37 2022 +0000
+++ b/dom/workers/ScriptLoader.cpp	Wed Dec 14 14:55:37 2022 +0000
@@ -755,7 +755,9 @@
   MOZ_ASSERT(global);
 
   while (!mLoadedRequests.isEmpty()) {
-    RefPtr<ScriptLoadRequest> req = mLoadedRequests.StealFirst();
+    // Take a reference, but do not remove it from the list yet. There is a
+    // possibility that this will need to be cancelled.
+    RefPtr<ScriptLoadRequest> req = mLoadedRequests.getFirst();
     // We don't have a ProcessRequest method (like we do on the DOM), as there
     // isn't much processing that we need to do per request that isn't related
     // to evaluation (the processsing done for the DOM is handled in
@@ -769,6 +771,8 @@
       mLoadedRequests.CancelRequestsAndClear();
       break;
     }
+    // remove the element from the list.
+    mLoadedRequests.Remove(req);
   }
 
   TryShutdown();
@@ -1070,6 +1074,9 @@
           : EvaluateSourceBuffer(aCx, options,
                                  maybeSource.ref<JS::SourceText<char16_t>>());
 
+  if (aRequest->IsCanceled()) {
+    return false;
+  }
   if (!successfullyEvaluated) {
     mRv.StealExceptionFromJSContext(aCx);
     return false;