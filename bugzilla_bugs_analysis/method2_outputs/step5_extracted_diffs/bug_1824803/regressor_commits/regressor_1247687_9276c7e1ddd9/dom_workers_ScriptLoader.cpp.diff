# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/ScriptLoader.cpp
# Commit: 9276c7e1ddd9
# Full Hash: 9276c7e1ddd98ccc725dbbe43353a8d988f8f454
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2022-12-15 09:27:59
# Regressor Bug: 1247687
# File Overlap Count: 1
# Description:
#   Bug 1247687 - Implement initial Static Module Loading for Workers; r=jonco
#   
#   This is the first pass of getting static module loading to work. This roughly implements
#   https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-worklet/module-worker-script-graph --
#   without some of the settings objects correctly set.
# ==============================================================================

diff -r 6ee318df6641 -r 9276c7e1ddd9 dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp	Wed Dec 14 14:55:35 2022 +0000
+++ b/dom/workers/ScriptLoader.cpp	Wed Dec 14 14:55:35 2022 +0000
@@ -265,6 +265,17 @@
     return;
   }
 
+  if (aIsMainScript) {
+    // Module Load
+    RefPtr<JS::loader::ScriptLoadRequest> mainScript = loader->GetMainScript();
+    if (mainScript && mainScript->IsModuleRequest()) {
+      if (NS_FAILED(mainScript->AsModuleRequest()->StartModuleLoad())) {
+        return;
+      }
+      syncLoop.Run();
+      return;
+    }
+  }
   if (loader->DispatchLoadScripts()) {
     syncLoop.Run();
   }
@@ -371,6 +382,10 @@
 
   virtual bool PreRun(WorkerPrivate* aWorkerPrivate) override;
 
+  bool ProcessModuleScript(JSContext* aCx, WorkerPrivate* aWorkerPrivate);
+
+  bool ProcessClassicScripts(JSContext* aCx, WorkerPrivate* aWorkerPrivate);
+
   virtual bool WorkerRun(JSContext* aCx,
                          WorkerPrivate* aWorkerPrivate) override;
 
@@ -424,6 +439,15 @@
   }
 }
 
+ScriptLoadRequest* WorkerScriptLoader::GetMainScript() {
+  mWorkerRef->Private()->AssertIsOnWorkerThread();
+  ScriptLoadRequest* request = mLoadingRequests.getFirst();
+  if (request->GetWorkerLoadContext()->IsTopLevel()) {
+    return request;
+  }
+  return nullptr;
+}
+
 void WorkerScriptLoader::InitModuleLoader() {
   mWorkerRef->Private()->AssertIsOnWorkerThread();
   RefPtr<WorkerModuleLoader> moduleLoader =
@@ -435,14 +459,15 @@
 bool WorkerScriptLoader::CreateScriptRequests(
     const nsTArray<nsString>& aScriptURLs,
     const mozilla::Encoding* aDocumentEncoding, bool aIsMainScript) {
-  // If a worker has been loaded as a module worker, ImportScripts calls are
-  // disallowed -- then the operation is invalid.
-  //
-  // 10.3.1 Importing scripts and libraries.
-  // Step 1. If worker global scope's type is "module", throw a TypeError
-  //         exception.
-  if (!aIsMainScript &&
-      mWorkerRef->Private()->WorkerType() == WorkerType::Module) {
+  mWorkerRef->Private()->AssertIsOnWorkerThread();
+  if (mWorkerRef->Private()->WorkerType() == WorkerType::Module &&
+      !aIsMainScript) {
+    // If a worker has been loaded as a module worker, ImportScripts calls are
+    // disallowed -- then the operation is invalid.
+    //
+    // 10.3.1 Importing scripts and libraries.
+    // Step 1. If worker global scope's type is "module", throw a TypeError
+    //         exception.
     mRv.ThrowTypeError(
         "Using `ImportScripts` inside a Module Worker is "
         "disallowed.");
@@ -472,6 +497,7 @@
 already_AddRefed<ScriptLoadRequest> WorkerScriptLoader::CreateScriptLoadRequest(
     const nsString& aScriptURL, const mozilla::Encoding* aDocumentEncoding,
     bool aIsMainScript) {
+  mWorkerRef->Private()->AssertIsOnWorkerThread();
   WorkerLoadContext::Kind kind =
       WorkerLoadContext::GetKind(aIsMainScript, IsDebuggerScript());
 
@@ -497,13 +523,33 @@
     loadContext->mLoadResult = rv;
   }
 
-  RefPtr<ScriptFetchOptions> fetchOptions =
-      new ScriptFetchOptions(CORSMode::CORS_NONE, referrerPolicy, nullptr);
+  RefPtr<ScriptLoadRequest> request;
+  if (mWorkerRef->Private()->WorkerType() == WorkerType::Classic) {
+    RefPtr<ScriptFetchOptions> fetchOptions =
+        new ScriptFetchOptions(CORSMode::CORS_NONE, referrerPolicy, nullptr);
+
+    request = new ScriptLoadRequest(ScriptKind::eClassic, uri, fetchOptions,
+                                    SRIMetadata(), nullptr, /* = aReferrer */
+                                    loadContext);
+  } else {
+    // Implements part of "To fetch a worklet/module worker script graph"
+    // including, setting up the request with a credentials mode (TODO),
+    // destination (CSP, TODO).
 
-  RefPtr<ScriptLoadRequest> request =
-      new ScriptLoadRequest(ScriptKind::eClassic, uri, fetchOptions,
-                            SRIMetadata(), nullptr, /* = aReferrer */
-                            loadContext);
+    // Step 1. Let options be a script fetch options. TODO: credentials mode.
+    RefPtr<ScriptFetchOptions> fetchOptions =
+        new ScriptFetchOptions(CORSMode::CORS_NONE, referrerPolicy, nullptr);
+
+    // Part of Step 2. This sets the Top-level flag to true
+    RefPtr<WorkerModuleLoader::ModuleLoaderBase> moduleLoader =
+        static_cast<WorkerGlobalScopeBase*>(GetGlobal())->GetModuleLoader();
+    request = new ModuleLoadRequest(
+        uri, fetchOptions, SRIMetadata(), nullptr, loadContext,
+        true,  /* is top level */
+        false, /* is dynamic import */
+        moduleLoader, ModuleLoadRequest::NewVisitedSetForTopLevelImport(uri),
+        nullptr);
+  }
 
   // Set the mURL, it will be used for error handling and debugging.
   request->mURL = NS_ConvertUTF16toUTF8(aScriptURL);
@@ -595,7 +641,11 @@
 
 void WorkerScriptLoader::MaybeMoveToLoadedList(ScriptLoadRequest* aRequest) {
   mWorkerRef->Private()->AssertIsOnWorkerThread();
-  aRequest->SetReady();
+  // Only set to ready for regular scripts. Module loader will set the script to
+  // ready if it is a Module Request.
+  if (!aRequest->IsModuleRequest()) {
+    aRequest->SetReady();
+  }
 
   // If the request is not in a list, we are in an illegal state.
   MOZ_RELEASE_ASSERT(aRequest->isInList());
@@ -894,6 +944,25 @@
     mWorkerRef->Private()->ExecutionReady();
   }
 
+  if (aRequest->IsModuleRequest()) {
+    // Only the top level module of the module graph will be executed from here,
+    // the rest will be executed from SpiderMonkey as part of the execution of
+    // the module graph.
+    MOZ_ASSERT(aRequest->IsTopLevel());
+    ModuleLoadRequest* request = aRequest->AsModuleRequest();
+    if (!request->mModuleScript) {
+      return false;
+    }
+    // Implements To fetch a worklet/module worker script graph
+    // Step 5. Fetch the descendants of and link result.
+    if (!request->InstantiateModuleGraph()) {
+      return false;
+    }
+
+    nsresult rv = request->EvaluateModule();
+    return NS_SUCCEEDED(rv);
+  }
+
   JS::CompileOptions options(aCx);
   // The introduction script is used by the DOM script loader as a way
   // to fill the Debugger Metadata for the JS Execution context. We don't use
@@ -1282,10 +1351,48 @@
   return mScriptLoader->StoreCSP();
 }
 
-bool ScriptExecutorRunnable::WorkerRun(JSContext* aCx,
-                                       WorkerPrivate* aWorkerPrivate) {
-  aWorkerPrivate->AssertIsOnWorkerThread();
+bool ScriptExecutorRunnable::ProcessModuleScript(
+    JSContext* aCx, WorkerPrivate* aWorkerPrivate) {
+  // We should only ever have one script when processing modules
+  MOZ_ASSERT(mLoadedRequests.Length() == 1);
+  RefPtr<ScriptLoadRequest> request;
+  {
+    // There is a possibility that we cleaned up while this task was waiting to
+    // run. If this has happened, return and exit.
+    MutexAutoLock lock(mScriptLoader->CleanUpLock());
+    if (mScriptLoader->CleanedUp()) {
+      return true;
+    }
+
+    const auto& requestHandle = mLoadedRequests.begin()->get();
+    // The request must be valid.
+    MOZ_ASSERT(!requestHandle->IsEmpty());
+
+    // Release the request to the worker. From this point on, the Request Handle
+    // is empty.
+    request = requestHandle->ReleaseRequest();
 
+    // release lock. We will need it later if we cleanup.
+  }
+
+  MOZ_ASSERT(request->IsModuleRequest());
+
+  WorkerLoadContext* loadContext = request->GetWorkerLoadContext();
+  ModuleLoadRequest* moduleRequest = request->AsModuleRequest();
+  if (NS_FAILED(loadContext->mLoadResult)) {
+    if (!moduleRequest->IsTopLevel()) {
+      moduleRequest->Cancel();
+    } else {
+      moduleRequest->LoadFailed();
+    }
+  }
+
+  moduleRequest->OnFetchComplete(loadContext->mLoadResult);
+  return true;
+}
+
+bool ScriptExecutorRunnable::ProcessClassicScripts(
+    JSContext* aCx, WorkerPrivate* aWorkerPrivate) {
   // There is a possibility that we cleaned up while this task was waiting to
   // run. If this has happened, return and exit.
   {
@@ -1294,11 +1401,6 @@
       return true;
     }
 
-    // We must be on the same worker as we started on.
-    MOZ_ASSERT(
-        mScriptLoader->mSyncLoopTarget == mSyncLoopTarget,
-        "Unexpected SyncLoopTarget. Check if the sync loop was closed early");
-
     for (const auto& requestHandle : mLoadedRequests) {
       // The request must be valid.
       MOZ_ASSERT(!requestHandle->IsEmpty());
@@ -1306,13 +1408,28 @@
       // Release the request to the worker. From this point on, the Request
       // Handle is empty.
       RefPtr<ScriptLoadRequest> request = requestHandle->ReleaseRequest();
-
       mScriptLoader->MaybeMoveToLoadedList(request);
     }
   }
   return mScriptLoader->ProcessPendingRequests(aCx);
 }
 
+bool ScriptExecutorRunnable::WorkerRun(JSContext* aCx,
+                                       WorkerPrivate* aWorkerPrivate) {
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  // We must be on the same worker as we started on.
+  MOZ_ASSERT(
+      mScriptLoader->mSyncLoopTarget == mSyncLoopTarget,
+      "Unexpected SyncLoopTarget. Check if the sync loop was closed early");
+
+  if (aWorkerPrivate->WorkerType() == WorkerType::Module) {
+    return ProcessModuleScript(aCx, aWorkerPrivate);
+  }
+
+  return ProcessClassicScripts(aCx, aWorkerPrivate);
+}
+
 nsresult ScriptExecutorRunnable::Cancel() {
   // We need to check first if cancel is called twice
   nsresult rv = MainThreadWorkerSyncRunnable::Cancel();