# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/ScriptLoader.cpp
# Commit: a1900e8b640c
# Full Hash: a1900e8b640c845614da76612f92b76b3f199a75
# Author: Yulia Startsev <ystartsev@mozilla.com>
# Date: 2023-01-19 04:46:07
# Regressor Bug: 1247687
# File Overlap Count: 1
# Description:
#   Bug 1247687 - Handle cancellation of long running modules; r=jonco
#   
#   This is a slightly annoying thing that can happen. When we abruptly cancel (such as an infinitely
#   running script being forcibly terminated) we will be in a state where the EvaluateModule call will
#   finish _after_ the loader is destroyed. So, instead we track if there has been a forcible
# ==============================================================================

diff -r c585aea29f0c -r a1900e8b640c dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp	Wed Jan 18 13:46:32 2023 +0000
+++ b/dom/workers/ScriptLoader.cpp	Wed Jan 18 13:46:32 2023 +0000
@@ -761,7 +761,9 @@
   MOZ_ASSERT(global);
 
   while (!mLoadedRequests.isEmpty()) {
-    RefPtr<ScriptLoadRequest> req = mLoadedRequests.StealFirst();
+    // Take a reference, but do not remove it from the list yet. There is a
+    // possibility that this will need to be cancelled.
+    RefPtr<ScriptLoadRequest> req = mLoadedRequests.getFirst();
     // We don't have a ProcessRequest method (like we do on the DOM), as there
     // isn't much processing that we need to do per request that isn't related
     // to evaluation (the processsing done for the DOM is handled in
@@ -775,6 +777,8 @@
       mLoadedRequests.CancelRequestsAndClear();
       break;
     }
+    // remove the element from the list.
+    mLoadedRequests.Remove(req);
   }
 
   TryShutdown();
@@ -1076,6 +1080,9 @@
           : EvaluateSourceBuffer(aCx, options,
                                  maybeSource.ref<JS::SourceText<char16_t>>());
 
+  if (aRequest->IsCanceled()) {
+    return false;
+  }
   if (!successfullyEvaluated) {
     mRv.StealExceptionFromJSContext(aCx);
     return false;