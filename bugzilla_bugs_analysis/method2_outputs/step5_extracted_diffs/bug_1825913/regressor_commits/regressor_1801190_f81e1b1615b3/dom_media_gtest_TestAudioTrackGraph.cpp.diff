# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/gtest/TestAudioTrackGraph.cpp
# Commit: f81e1b1615b3
# Full Hash: f81e1b1615b3a9c5ef6c62a291f79029b3807dde
# Author: Karl Tomlinson <karlt+@karlt.net>
# Date: 2023-03-31 09:51:00
# Regressor Bug: 1801190
# File Overlap Count: 1
# Description:
#   Bug 1801190 do not reset mAudioStreamState to None on state changes from an old cubeb_stream r=pehrsons
#   
#   Such resets were preventing transitions to Running for new streams and allowing
#   MaybeStartAudioStream() to start another stream.
#   
# ==============================================================================

diff -r 9592d9865f5a -r f81e1b1615b3 dom/media/gtest/TestAudioTrackGraph.cpp
--- a/dom/media/gtest/TestAudioTrackGraph.cpp	Fri Mar 31 02:23:14 2023 +0300
+++ b/dom/media/gtest/TestAudioTrackGraph.cpp	Thu Mar 30 23:18:44 2023 +0000
@@ -1162,7 +1162,8 @@
   //
   // We open an input through this track so that there's something triggering
   // EnsureNextIteration on the fallback driver after the callback driver has
-  // gotten the error.
+  // gotten the error, and to check that a replacement cubeb_stream receives
+  // output from the graph.
   RefPtr<AudioProcessingTrack> processingTrack;
   RefPtr<AudioInputProcessing> listener;
   auto started = Invoke([&] {
@@ -1176,6 +1177,7 @@
     processingTrack->ConnectDeviceInput(deviceId, listener,
                                         PRINCIPAL_HANDLE_NONE);
     EXPECT_EQ(processingTrack->DeviceId().value(), deviceId);
+    processingTrack->AddAudioOutput(reinterpret_cast<void*>(1));
     return graph->NotifyWhenDeviceStarted(processingTrack);
   });
 
@@ -1186,17 +1188,18 @@
   // Force a cubeb state_callback error and see that we don't crash.
   DispatchFunction([&] { stream->ForceError(); });
 
-  // Wait for both the error to take effect, and the driver to restart.
-  bool errored = false, init = false;
+  // Wait for the error to take effect, and the driver to restart and receive
+  // output.
+  bool errored = false;
   MediaEventListener errorListener = stream->ErrorForcedEvent().Connect(
       AbstractThread::GetCurrent(), [&] { errored = true; });
-  MediaEventListener initListener = cubeb->StreamInitEvent().Connect(
-      AbstractThread::GetCurrent(), [&] { init = true; });
-  SpinEventLoopUntil<ProcessFailureBehavior::IgnoreAndContinue>(
-      "TEST(TestAudioTrackGraph, ErrorCallback)"_ns,
-      [&] { return errored && init; });
+  stream = WaitFor(cubeb->StreamInitEvent());
+  WaitFor(stream->FramesVerifiedEvent());
+  // The error event is notified after CUBEB_STATE_ERROR triggers other
+  // threads to init a new cubeb_stream, so there is a theoretical chance that
+  // `errored` might not be set when `stream` is set.
   errorListener.Disconnect();
-  initListener.Disconnect();
+  EXPECT_TRUE(errored);
 
   // Clean up.
   DispatchFunction([&] {