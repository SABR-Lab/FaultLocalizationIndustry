# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/TextLeafRange.cpp
# Commit: 5e92b9c7d479
# Full Hash: 5e92b9c7d4794af1d7ab0fb5c278c2e681a18fc6
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2023-01-28 21:11:06
# Regressor Bug: 1811092
# File Overlap Count: 1
# Description:
#   Bug 1811092 - P1: Add new async add/set text selection message. r=Jamie
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D167201
# ==============================================================================

diff -r 7cebaa85f4ff -r 5e92b9c7d479 accessible/base/TextLeafRange.cpp
--- a/accessible/base/TextLeafRange.cpp	Fri Jan 27 20:03:06 2023 +0000
+++ b/accessible/base/TextLeafRange.cpp	Fri Jan 27 20:15:11 2023 +0000
@@ -20,6 +20,7 @@
 #include "mozilla/intl/Segmenter.h"
 #include "mozilla/intl/WordBreaker.h"
 #include "mozilla/StaticPrefs_layout.h"
+#include "mozilla/TextEditor.h"
 #include "nsAccessibilityService.h"
 #include "nsAccUtils.h"
 #include "nsBlockFrame.h"
@@ -57,8 +58,9 @@
                                        uint32_t aRenderedOffset) {
   nsTextFrame* frame = do_QueryFrame(aAcc->GetFrame());
   if (!frame) {
-    MOZ_ASSERT(!aAcc->HasOwnContent(),
-               "No text frame because this is a XUL label[value] text leaf.");
+    MOZ_ASSERT(!aAcc->HasOwnContent() || aAcc->IsHTMLBr(),
+               "No text frame because this is a XUL label[value] text leaf or "
+               "a BR element.");
     return static_cast<int32_t>(aRenderedOffset);
   }
 
@@ -468,6 +470,95 @@
   return domRanges;
 }
 
+/**
+ * Given two DOM nodes get DOM Selection object that is common
+ * to both of them.
+ */
+static dom::Selection* GetDOMSelection(const nsIContent* aStartContent,
+                                       const nsIContent* aEndContent) {
+  nsIFrame* startFrame = aStartContent->GetPrimaryFrame();
+  const nsFrameSelection* startFrameSel =
+      startFrame ? startFrame->GetConstFrameSelection() : nullptr;
+  nsIFrame* endFrame = aEndContent->GetPrimaryFrame();
+  const nsFrameSelection* endFrameSel =
+      endFrame ? endFrame->GetConstFrameSelection() : nullptr;
+
+  if (startFrameSel != endFrameSel) {
+    // Start and end point don't share the same selection state.
+    // This could happen when both points aren't in the same editable.
+    return nullptr;
+  }
+
+  return startFrameSel ? startFrameSel->GetSelection(SelectionType::eNormal)
+                       : nullptr;
+}
+
+/**
+ * Translate given TextLeafPoint into a DOM point that is kosher
+ * for text selection.
+ */
+MOZ_CAN_RUN_SCRIPT static std::pair<nsIContent*, int32_t> DOMPointForSelection(
+    const TextLeafPoint& aPoint) {
+  if (!aPoint || !aPoint.mAcc->IsLocal()) {
+    MOZ_ASSERT_UNREACHABLE("Invalid point");
+    return {nullptr, 0};
+  }
+
+  nsIContent* content = aPoint.mAcc->AsLocal()->GetContent();
+  nsIFrame* frame = content ? content->GetPrimaryFrame() : nullptr;
+  MOZ_ASSERT(frame);
+
+  if (frame && frame->IsGeneratedContentFrame()) {
+    // List markers accessibles represent the generated content element,
+    // before/after text accessibles represent the child text nodes.
+    auto generatedElement = content->IsGeneratedContentContainerForMarker()
+                                ? content
+                                : content->GetParentElement();
+    auto parent = generatedElement ? generatedElement->GetParent() : nullptr;
+    MOZ_ASSERT(parent);
+    if (parent) {
+      if (generatedElement->IsGeneratedContentContainerForAfter()) {
+        // Use the end offset of the parent element for trailing generated
+        // content.
+        return {parent, parent->GetChildCount()};
+      }
+
+      if (generatedElement->IsGeneratedContentContainerForBefore() ||
+          generatedElement->IsGeneratedContentContainerForMarker()) {
+        // Use the start offset of the parent element for leading generated
+        // content.
+        return {parent, 0};
+      }
+
+      MOZ_ASSERT_UNREACHABLE("Unknown generated content type!");
+    }
+  }
+
+  if (!aPoint.mAcc->IsTextLeaf() && !aPoint.mAcc->IsHTMLBr() &&
+      !aPoint.mAcc->HasChildren()) {
+    // If this is not a text leaf it can be an empty editable container,
+    // whitespace, or an empty doc. In any case, the offset inside should be 0.
+    MOZ_ASSERT(aPoint.mOffset == 0);
+
+    if (RefPtr<TextControlElement> textControlElement =
+            TextControlElement::FromNodeOrNull(content)) {
+      // This is an empty input, use the shadow root's element.
+      if (RefPtr<TextEditor> textEditor = textControlElement->GetTextEditor()) {
+        if (textEditor->IsEmpty()) {
+          MOZ_ASSERT(aPoint.mOffset == 0);
+          return {textEditor->GetRoot(), 0};
+        }
+      }
+    }
+
+    MOZ_ASSERT(aPoint.mAcc->IsDoc() || content->HasFlag(NODE_IS_EDITABLE));
+    return {content, 0};
+  }
+
+  return {content,
+          RenderedToContentOffset(aPoint.mAcc->AsLocal(), aPoint.mOffset)};
+}
+
 /*** TextLeafPoint ***/
 
 TextLeafPoint::TextLeafPoint(Accessible* aAcc, int32_t aOffset) {
@@ -1530,6 +1621,71 @@
   return result;
 }
 
+bool TextLeafRange::SetSelection(int32_t aSelectionNum) const {
+  if (!mStart || !mEnd || mStart.mAcc->IsLocal() != mEnd.mAcc->IsLocal()) {
+    return false;
+  }
+
+  if (mStart.mAcc->IsRemote()) {
+    DocAccessibleParent* doc = mStart.mAcc->AsRemote()->Document();
+    if (doc != mEnd.mAcc->AsRemote()->Document()) {
+      return false;
+    }
+
+    Unused << doc->SendSetTextSelection(mStart.mAcc->ID(), mStart.mOffset,
+                                        mEnd.mAcc->ID(), mEnd.mOffset,
+                                        aSelectionNum);
+    return true;
+  }
+
+  bool reversed = mEnd < mStart;
+  auto [startContent, startContentOffset] =
+      DOMPointForSelection(!reversed ? mStart : mEnd);
+  auto [endContent, endContentOffset] =
+      DOMPointForSelection(!reversed ? mEnd : mStart);
+
+  if (!startContent || !endContent) {
+    return false;
+  }
+
+  RefPtr<dom::Selection> domSel = GetDOMSelection(startContent, endContent);
+  if (!domSel) {
+    return false;
+  }
+
+  uint32_t rangeCount = domSel->RangeCount();
+  RefPtr<nsRange> domRange = nullptr;
+  if (aSelectionNum == static_cast<int32_t>(rangeCount) || aSelectionNum < 0) {
+    domRange = nsRange::Create(startContent);
+  } else {
+    domRange = domSel->GetRangeAt(AssertedCast<uint32_t>(aSelectionNum));
+  }
+  if (!domRange) {
+    return false;
+  }
+
+  domRange->SetStart(startContent, startContentOffset);
+  domRange->SetEnd(endContent, endContentOffset);
+
+  // If this is not a new range, notify selection listeners that the existing
+  // selection range has changed. Otherwise, just add the new range.
+  if (aSelectionNum != static_cast<int32_t>(rangeCount)) {
+    domSel->RemoveRangeAndUnselectFramesAndNotifyListeners(*domRange,
+                                                           IgnoreErrors());
+  }
+
+  IgnoredErrorResult err;
+  domSel->AddRangeAndSelectFramesAndNotifyListeners(*domRange, err);
+  if (!err.Failed()) {
+    // Changing the direction of the selection assures that the caret
+    // will be at the logical end of the selection.
+    domSel->SetDirection(reversed ? eDirPrevious : eDirNext);
+    return true;
+  }
+
+  return false;
+}
+
 TextLeafRange::Iterator TextLeafRange::Iterator::BeginIterator(
     const TextLeafRange& aRange) {
   Iterator result(aRange);