# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/html/HTMLInputElement.cpp
# Commit: 7c1ae2ab6596
# Full Hash: 7c1ae2ab65966ae06c7e539015fbc1f2d852dd4a
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-05-16 04:24:30
# Regressor Bug: 1833181
# File Overlap Count: 2
# Description:
#   Bug 1833181 - Avoid attr lookups to check whether input value is empty. r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D178078
# ==============================================================================

diff -r 08a8f6b67ccf -r 7c1ae2ab6596 dom/html/HTMLInputElement.cpp
--- a/dom/html/HTMLInputElement.cpp	Mon May 15 17:13:37 2023 +0000
+++ b/dom/html/HTMLInputElement.cpp	Mon May 15 17:16:41 2023 +0000
@@ -1035,7 +1035,7 @@
   // until someone calls UpdateEditableState on us, apparently!  Also
   // by default we don't have to show validity UI and so forth.
   AddStatesSilently(ElementState::ENABLED | ElementState::OPTIONAL_ |
-                    ElementState::VALID);
+                    ElementState::VALID | ElementState::VALUE_EMPTY);
   UpdateApzAwareFlag();
 }
 
@@ -1571,16 +1571,6 @@
   }
 }
 
-bool HTMLInputElement::IsValueEmpty() const {
-  if (GetValueMode() == VALUE_MODE_VALUE && IsSingleLineTextControl(false)) {
-    return !mInputData.mState->HasNonEmptyValue();
-  }
-
-  nsAutoString value;
-  GetNonFileValueInternal(value);
-  return value.IsEmpty();
-}
-
 void HTMLInputElement::ClearFiles(bool aSetValueChanged) {
   nsTArray<OwningFileOrDirectory> data;
   SetFilesOrDirectories(data, aSetValueChanged);
@@ -2668,6 +2658,12 @@
         SetValueChanged(true);
       }
 
+      if (value.IsEmpty()) {
+        AddStates(ElementState::VALUE_EMPTY);
+      } else {
+        RemoveStates(ElementState::VALUE_EMPTY);
+      }
+
       if (IsSingleLineTextControl(false)) {
         // Note that if aOptions includes
         // ValueSetterOption::BySetUserInputAPI, "input" event is automatically
@@ -2711,7 +2707,7 @@
           }
         }
         if (mDoneCreating) {
-          OnValueChanged(ValueChangeKind::Internal);
+          OnValueChanged(ValueChangeKind::Internal, value.IsEmpty(), &value);
         }
         // else DoneCreatingElement calls us again once mDoneCreating is true
       }
@@ -2727,7 +2723,7 @@
 
       // This call might be useless in some situations because if the element is
       // a single line text control, TextControlState::SetValue will call
-      // nsHTMLInputElement::OnValueChanged which is going to call UpdateState()
+      // HTMLInputElement::OnValueChanged which is going to call UpdateState()
       // if the element is focused. This bug 665547.
       if (PlaceholderApplies() && HasAttr(nsGkAtoms::placeholder)) {
         UpdateState(true);
@@ -5729,11 +5725,15 @@
   return SetValueInternal(resetVal, ValueSetterOption::ByInternalAPI);
 }
 
-void HTMLInputElement::SetDirectionFromValue(bool aNotify) {
+void HTMLInputElement::SetDirectionFromValue(bool aNotify,
+                                             const nsAString* aKnownValue) {
   if (IsSingleLineTextControl(true)) {
     nsAutoString value;
-    GetValue(value, CallerType::System);
-    SetDirectionalityFromValue(this, value, aNotify);
+    if (!aKnownValue) {
+      GetValue(value, CallerType::System);
+      aKnownValue = &value;
+    }
+    SetDirectionalityFromValue(this, *aKnownValue, aNotify);
   }
 }
 
@@ -5888,7 +5888,7 @@
 static nsTArray<FileContentData> SaveFileContentData(
     const nsTArray<OwningFileOrDirectory>& aArray) {
   nsTArray<FileContentData> res(aArray.Length());
-  for (auto& it : aArray) {
+  for (const auto& it : aArray) {
     if (it.IsFile()) {
       RefPtr<BlobImpl> impl = it.GetAsFile()->Impl();
       res.AppendElement(std::move(impl));
@@ -6089,11 +6089,9 @@
     }
   }
 
-  if (mType != FormControlType::InputFile && IsValueEmpty()) {
-    state |= ElementState::VALUE_EMPTY;
-    if (PlaceholderApplies() && HasAttr(nsGkAtoms::placeholder)) {
-      state |= ElementState::PLACEHOLDER_SHOWN;
-    }
+  if (IsValueEmpty() && PlaceholderApplies() &&
+      HasAttr(nsGkAtoms::placeholder)) {
+    state |= ElementState::PLACEHOLDER_SHOWN;
   }
 
   return state;
@@ -6102,7 +6100,7 @@
 static nsTArray<OwningFileOrDirectory> RestoreFileContentData(
     nsPIDOMWindowInner* aWindow, const nsTArray<FileContentData>& aData) {
   nsTArray<OwningFileOrDirectory> res(aData.Length());
-  for (auto& it : aData) {
+  for (const auto& it : aData) {
     if (it.type() == FileContentData::TBlobImpl) {
       if (!it.get_BlobImpl()) {
         // Serialization failed, skip this file.
@@ -6810,19 +6808,27 @@
   }
 }
 
-void HTMLInputElement::OnValueChanged(ValueChangeKind aKind) {
+void HTMLInputElement::OnValueChanged(ValueChangeKind aKind,
+                                      bool aNewValueEmpty,
+                                      const nsAString* aKnownNewValue) {
+  MOZ_ASSERT_IF(aKnownNewValue, aKnownNewValue->IsEmpty() == aNewValueEmpty);
   if (aKind != ValueChangeKind::Internal) {
     mLastValueChangeWasInteractive = aKind == ValueChangeKind::UserInteraction;
   }
 
+  if (aNewValueEmpty) {
+    AddStates(ElementState::VALUE_EMPTY);
+  } else {
+    RemoveStates(ElementState::VALUE_EMPTY);
+  }
+
   UpdateAllValidityStates(true);
 
   if (HasDirAuto()) {
-    SetDirectionFromValue(true);
-  }
-
-  // :placeholder-shown and value-empty pseudo-class may change when the value
-  // changes.
+    SetDirectionFromValue(true, aKnownNewValue);
+  }
+
+  // :placeholder-shown pseudo-class may change when the value changes.
   UpdateState(true);
 }
 