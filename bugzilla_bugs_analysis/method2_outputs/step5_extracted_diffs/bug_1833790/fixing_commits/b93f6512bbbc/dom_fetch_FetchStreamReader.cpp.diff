# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/fetch/FetchStreamReader.cpp
# Commit: b93f6512bbbc
# Full Hash: b93f6512bbbc6433d09a482acf2f138f2f6677e0
# Author: Jens Stutte <jstutte@mozilla.com>
# Date: 2023-06-07 03:30:33
# Description:
#   Bug 1833790 - Ignore StrongWorkerRef callback if mWorkerRef is already cleared. r=dom-worker-reviewers,asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D180072
# ==============================================================================

diff -r 34efca17c445 -r b93f6512bbbc dom/fetch/FetchStreamReader.cpp
--- a/dom/fetch/FetchStreamReader.cpp	Tue Jun 06 15:46:48 2023 +0000
+++ b/dom/fetch/FetchStreamReader.cpp	Tue Jun 06 16:02:52 2023 +0000
@@ -75,11 +75,18 @@
     RefPtr<StrongWorkerRef> workerRef = StrongWorkerRef::Create(
         workerPrivate, "FetchStreamReader", [streamReader]() {
           MOZ_ASSERT(streamReader);
-          MOZ_ASSERT(streamReader->mWorkerRef);
 
-          streamReader->CloseAndRelease(
-              streamReader->mWorkerRef->Private()->GetJSContext(),
-              NS_ERROR_DOM_INVALID_STATE_ERR);
+          // mAsyncWaitWorkerRef may keep the (same) StrongWorkerRef alive even
+          // when mWorkerRef has already been nulled out by a previous call to
+          // CloseAndRelease, we can just safely ignore this callback then
+          // (as would the CloseAndRelease do on a second call).
+          if (streamReader->mWorkerRef) {
+            streamReader->CloseAndRelease(
+                streamReader->mWorkerRef->Private()->GetJSContext(),
+                NS_ERROR_DOM_INVALID_STATE_ERR);
+          } else {
+            MOZ_DIAGNOSTIC_ASSERT(streamReader->mAsyncWaitWorkerRef);
+          }
         });
 
     if (NS_WARN_IF(!workerRef)) {
