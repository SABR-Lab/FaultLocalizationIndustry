# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/file/FileReader.cpp
# Commit: 682576598147
# Full Hash: 68257659814773dd5ce01d8dc9962eb3cd2313c9
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2022-08-03 03:42:48
# Regressor Bug: 1770630
# File Overlap Count: 1
# Description:
#   Bug 1770630 - Worker stream readers should contribute to busy count. r=dom-worker-reviewers,jstutte
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D149185
# ==============================================================================

diff -r 08d3ed24aab9 -r 682576598147 dom/file/FileReader.cpp
--- a/dom/file/FileReader.cpp	Wed Aug 03 00:26:29 2022 +0000
+++ b/dom/file/FileReader.cpp	Wed Aug 03 00:36:01 2022 +0000
@@ -624,15 +624,15 @@
 // InputStreamCallback
 NS_IMETHODIMP
 FileReader::OnInputStreamReady(nsIAsyncInputStream* aStream) {
-  if (mReadyState != LOADING || aStream != mAsyncStream) {
-    return NS_OK;
-  }
-
   // We use this class to decrease the busy counter at the end of this method.
   // In theory we can do it immediatelly but, for debugging reasons, we want to
   // be 100% sure we have a workerRef when OnLoadEnd() is called.
   FileReaderDecreaseBusyCounter RAII(this);
 
+  if (mReadyState != LOADING || aStream != mAsyncStream) {
+    return NS_OK;
+  }
+
   uint64_t count;
   nsresult rv = aStream->Available(&count);
 
@@ -731,14 +731,7 @@
 
   MOZ_ASSERT(mReadyState == LOADING);
 
-  ClearProgressEventTimer();
-
-  if (mAsyncWaitRunnable) {
-    mAsyncWaitRunnable->Cancel();
-    mAsyncWaitRunnable = nullptr;
-  }
-
-  mReadyState = DONE;
+  Cleanup();
 
   // XXX The spec doesn't say this
   mError = DOMException::Create(NS_ERROR_DOM_ABORT_ERR);
@@ -747,30 +740,12 @@
   SetDOMStringToNull(mResult);
   mResultArrayBuffer = nullptr;
 
-  // If we have the stream and the busy-count is not 0, it means that we are
-  // waiting for an OnInputStreamReady() call. Let's abort the current
-  // AsyncWait() calling it again with a nullptr callback. See
-  // nsIAsyncInputStream.idl.
-  if (mAsyncStream && mBusyCount) {
-    mAsyncStream->AsyncWait(/* callback */ nullptr,
-                            /* aFlags*/ 0,
-                            /* aRequestedCount */ 0, mTarget);
-    DecreaseBusyCounter();
-    MOZ_ASSERT(mBusyCount == 0);
-
-    mAsyncStream->Close();
-  }
-
-  mAsyncStream = nullptr;
   mBlob = nullptr;
 
-  // Clean up memory buffer
-  FreeFileData();
-
   // Dispatch the events
   DispatchProgressEvent(nsLiteralString(ABORT_STR));
   DispatchProgressEvent(nsLiteralString(LOADEND_STR));
-}  // namespace dom
+}
 
 nsresult FileReader::IncreaseBusyCounter() {
   if (mWeakWorkerRef && mBusyCount++ == 0) {
@@ -800,7 +775,7 @@
   }
 }
 
-void FileReader::Shutdown() {
+void FileReader::Cleanup() {
   mReadyState = DONE;
 
   if (mAsyncWaitRunnable) {
@@ -816,11 +791,12 @@
   ClearProgressEventTimer();
   FreeFileData();
   mResultArrayBuffer = nullptr;
+}
 
-  if (mWeakWorkerRef && mBusyCount != 0) {
-    mStrongWorkerRef = nullptr;
+void FileReader::Shutdown() {
+  Cleanup();
+  if (mWeakWorkerRef) {
     mWeakWorkerRef = nullptr;
-    mBusyCount = 0;
   }
 }
 