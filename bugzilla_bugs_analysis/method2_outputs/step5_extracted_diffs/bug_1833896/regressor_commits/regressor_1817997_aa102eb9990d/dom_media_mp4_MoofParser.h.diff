# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mp4/MoofParser.h
# Commit: aa102eb9990d
# Full Hash: aa102eb9990d6edbd5cf7473c5017082340764ff
# Author: Paul Adenot <paul@paul.cx>
# Date: 2023-05-24 21:42:08
# Regressor Bug: 1817997
# File Overlap Count: 3
# Description:
#   Bug 1817997 - Update the MP4 demuxer to use TimeUnit based on the internal MP4 time base. r=alwu
#   
#   This still gets the initial time value from mp4parse-rust, that is in
#   microseconds. mp4parse-rust has been updated to expose real time, and will be
#   updated later.
# ==============================================================================

diff -r 5c1b6ce71ca1 -r aa102eb9990d dom/media/mp4/MoofParser.h
--- a/dom/media/mp4/MoofParser.h	Wed May 24 13:18:40 2023 +0000
+++ b/dom/media/mp4/MoofParser.h	Wed May 24 13:18:40 2023 +0000
@@ -6,6 +6,7 @@
 #define MOOF_PARSER_H_
 
 #include "mozilla/ResultExtensions.h"
+#include "TimeUnits.h"
 #include "mozilla/Variant.h"
 #include "Atom.h"
 #include "AtomType.h"
@@ -16,8 +17,6 @@
 
 namespace mozilla {
 
-typedef int64_t Microseconds;
-
 class Box;
 class BoxContext;
 class BoxReader;
@@ -27,10 +26,10 @@
 // in the preceeding Moof, so that we can smooth tracks' timestamps
 // across Moofs.
 struct TrackEndCts {
-  TrackEndCts(uint32_t aTrackId, Microseconds aCtsEndTime)
+  TrackEndCts(uint32_t aTrackId, const media::TimeUnit& aCtsEndTime)
       : mTrackId(aTrackId), mCtsEndTime(aCtsEndTime) {}
   uint32_t mTrackId;
-  Microseconds mCtsEndTime;
+  media::TimeUnit mCtsEndTime;
 };
 
 class Mvhd : public Atom {
@@ -39,14 +38,12 @@
       : mCreationTime(0), mModificationTime(0), mTimescale(0), mDuration(0) {}
   explicit Mvhd(Box& aBox);
 
-  Result<Microseconds, nsresult> ToMicroseconds(int64_t aTimescaleUnits) {
+  Result<media::TimeUnit, nsresult> ToTimeUnit(int64_t aTimescaleUnits) {
     if (!mTimescale) {
       NS_WARNING("invalid mTimescale");
       return Err(NS_ERROR_FAILURE);
     }
-    int64_t major = aTimescaleUnits / mTimescale;
-    int64_t remainder = aTimescaleUnits % mTimescale;
-    return major * 1000000ll + remainder * 1000000ll / mTimescale;
+    return media::TimeUnit(aTimescaleUnits, mTimescale);
   }
 
   uint64_t mCreationTime;
@@ -124,7 +121,9 @@
 
 class Edts : public Atom {
  public:
-  Edts() : mMediaStart(0), mEmptyOffset(0) {}
+  Edts()
+      : mMediaStart(0),
+        mEmptyOffset(0) {}
   explicit Edts(Box& aBox);
   virtual bool IsValid() override {
     // edts is optional
@@ -141,8 +140,8 @@
 struct Sample {
   mozilla::MediaByteRange mByteRange;
   mozilla::MediaByteRange mCencRange;
-  Microseconds mDecodeTime;
-  MP4Interval<Microseconds> mCompositionRange;
+  media::TimeUnit mDecodeTime;
+  MP4Interval<media::TimeUnit> mCompositionRange;
   bool mSync;
 };
 
@@ -251,7 +250,7 @@
 
   mozilla::MediaByteRange mRange;
   mozilla::MediaByteRange mMdatRange;
-  MP4Interval<Microseconds> mTimeRange;
+  MP4Interval<media::TimeUnit> mTimeRange;
   FallibleTArray<Sample> mIndex;
 
   FallibleTArray<CencSampleEncryptionInfoEntry>
@@ -279,7 +278,7 @@
   // from that standard. I.e. this function is used to handle up auxiliary
   // information from the cenc and cbcs schemes.
   bool ProcessCencAuxInfo(AtomType aScheme);
-  uint64_t mMaxRoundingError;
+  media::TimeUnit mMaxRoundingError;
 };
 
 DDLoggedTypeDeclName(MoofParser);
@@ -308,7 +307,7 @@
   bool RebuildFragmentedIndex(const mozilla::MediaByteRangeSet& aByteRanges,
                               bool* aCanEvict);
   bool RebuildFragmentedIndex(BoxContext& aContext);
-  MP4Interval<Microseconds> GetCompositionRange(
+  MP4Interval<media::TimeUnit> GetCompositionRange(
       const mozilla::MediaByteRangeSet& aByteRanges);
   bool ReachedEnd();
   void ParseMoov(Box& aBox);