# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: 910dabb8545d
# Full Hash: 910dabb8545dfdea0c2b9385e347857042606bd7
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2023-06-07 03:30:33
# Regressor Bug: 1800659
# File Overlap Count: 1
# Description:
#   Bug 1800659 - P1 Adding log for Worker. r=asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D176915
# ==============================================================================

diff -r 9458874d5cf9 -r 910dabb8545d dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Tue Jun 06 06:28:14 2023 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Tue Jun 06 06:36:50 2023 +0000
@@ -123,7 +123,11 @@
 #ifdef LOG
 #  undef LOG
 #endif
+#ifdef LOGV
+#  undef LOGV
+#endif
 #define LOG(log, _args) MOZ_LOG(log, LogLevel::Debug, _args);
+#define LOGV(args) MOZ_LOG(sWorkerPrivateLog, LogLevel::Verbose, args);
 
 namespace mozilla {
 
@@ -929,6 +933,7 @@
 
   NS_IMETHOD
   Run() override {
+    LOG(WorkerLog(), ("CancelingRunnable::Run [%p]", this));
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
     workerPrivate->AssertIsOnWorkerThread();
@@ -1576,10 +1581,14 @@
     const MutexAutoLock& aProofOfLock) {
   // May be called on any thread!
   RefPtr<WorkerRunnable> runnable(aRunnable);
+  LOGV(("WorkerPrivate::DispatchLockHeld [%p] runnable: %p", this,
+        runnable.get()));
 
   MOZ_ASSERT_IF(aSyncLoopTarget, mThread);
 
   if (mStatus == Dead || (!aSyncLoopTarget && ParentStatus() > Running)) {
+    LOGV(("WorkerPrivate::DispatchLockHeld [%p] runnable %p, parent status: %u",
+          this, runnable.get(), (uint8_t)(ParentStatus())));
     NS_WARNING(
         "A runnable was posted to a worker that is already shutting "
         "down!");
@@ -1594,6 +1603,10 @@
 
   if (!mThread) {
     if (ParentStatus() == Pending || mStatus == Pending) {
+      LOGV(
+          ("WorkerPrivate::DispatchLockHeld [%p] runnable %p is queued in "
+           "mPreStartRunnables",
+           this, runnable.get()));
       mPreStartRunnables.AppendElement(runnable);
       return NS_OK;
     }
@@ -1606,12 +1619,20 @@
 
   nsresult rv;
   if (aSyncLoopTarget) {
+    LOGV(
+        ("WorkerPrivate::DispatchLockHeld [%p] runnable %p dispatch to a "
+         "SyncLoop(%p)",
+         this, runnable.get(), aSyncLoopTarget));
     rv = aSyncLoopTarget->Dispatch(runnable.forget(), NS_DISPATCH_NORMAL);
   } else {
     // WorkerDebuggeeRunnables don't need any special treatment here. True,
     // they should not be delivered to a frozen worker. But frozen workers
     // aren't drawing from the thread's main event queue anyway, only from
     // mControlQueue.
+    LOGV(
+        ("WorkerPrivate::DispatchLockHeld [%p] runnable %p dispatch to the "
+         "main event queue",
+         this, runnable.get()));
     rv = mThread->DispatchAnyThread(WorkerThreadFriendKey(), runnable.forget());
   }
 
@@ -1652,6 +1673,9 @@
   RefPtr<WorkerControlRunnable> runnable(aWorkerControlRunnable);
   MOZ_ASSERT(runnable);
 
+  LOG(WorkerLog(), ("WorkerPrivate::DispatchControlRunnable [%p] runnable %p",
+                    this, runnable.get()));
+
   {
     MutexAutoLock lock(mMutex);
 
@@ -1707,6 +1731,9 @@
   nsCOMPtr<nsIRunnable> runnable(aRunnable);
   MOZ_ASSERT(runnable);
 
+  LOGV(("WorkerPrivate::MaybeWrapAsWorkerRunnable [%p] runnable: %p", this,
+        runnable.get()));
+
   RefPtr<WorkerRunnable> workerRunnable =
       WorkerRunnable::FromRunnable(runnable);
   if (workerRunnable) {
@@ -1726,6 +1753,7 @@
 
 bool WorkerPrivate::Start() {
   // May be called on any thread!
+  LOG(WorkerLog(), ("WorkerPrivate::Start [%p]", this));
   {
     MutexAutoLock lock(mMutex);
     NS_ASSERTION(mParentStatus != Running, "How can this be?!");
@@ -2364,6 +2392,7 @@
       mIsPrivilegedAddonGlobal(false),
       mTopLevelWorkerFinishedRunnableCount(0),
       mWorkerFinishedRunnableCount(0) {
+  LOG(WorkerLog(), ("WorkerPrivate::WorkerPrivate [%p]", this));
   MOZ_ASSERT_IF(!IsDedicatedWorker(), NS_IsMainThread());
 
   if (aParent) {
@@ -3095,6 +3124,7 @@
 }
 
 void WorkerPrivate::RunLoopNeverRan() {
+  LOG(WorkerLog(), ("WorkerPrivate::RunLoopNeverRan [%p]", this));
   {
     MutexAutoLock lock(mMutex);
 
@@ -3117,6 +3147,7 @@
 }
 
 void WorkerPrivate::UnrootGlobalScopes() {
+  LOG(WorkerLog(), ("WorkerPrivate::UnrootGlobalScopes [%p]", this));
   auto data = mWorkerThreadAccessible.Access();
 
   RefPtr<WorkerDebuggerGlobalScope> debugScope = data->mDebuggerScope.forget();
@@ -3130,6 +3161,7 @@
 }
 
 void WorkerPrivate::DoRunLoop(JSContext* aCx) {
+  LOG(WorkerLog(), ("WorkerPrivate::DoRunLoop [%p]", this));
   auto data = mWorkerThreadAccessible.Access();
   MOZ_RELEASE_ASSERT(!GetExecutionManager());
 
@@ -3928,6 +3960,9 @@
 }
 
 void WorkerPrivate::ClearMainEventQueue(WorkerRanOrNot aRanOrNot) {
+  LOG(WorkerLog(),
+      ("WorkerPrivate::ClearMainEventQueue [%p] aRanOrNot: %s", this,
+       aRanOrNot == WorkerNeverRan ? "WorkerNeverRan" : "WorkerRan"));
   AssertIsOnWorkerThread();
 
   MOZ_ASSERT((mPostSyncLoopOperations & ePendingEventQueueClearing)
@@ -3961,6 +3996,10 @@
     nsIThread* currentThread = NS_GetCurrentThread();
     MOZ_ASSERT(currentThread);
 
+    LOG(WorkerLog(),
+        ("WorkerPrivate::ClearMainEventQueue [%p] has pending events: %s", this,
+         NS_HasPendingEvents(currentThread) ? "true" : "false"));
+
     NS_ProcessPendingEvents(currentThread);
   }
 
@@ -4109,6 +4148,11 @@
   {
     MutexAutoLock lock(mMutex);
 
+    LOG(WorkerLog(),
+        ("WorkerPrivate::AddWorkerRef [%p] mStatus: %u, aFailStatus: (%u)",
+         this, static_cast<uint8_t>(mStatus),
+         static_cast<uint8_t>(aFailStatus)));
+
     if (mStatus >= aFailStatus) {
       return false;
     }
@@ -4160,6 +4204,9 @@
 
   NS_ASSERTION(aStatus > Closing, "Bad status!");
 
+  LOG(WorkerLog(), ("WorkerPrivate::NotifyWorkerRefs [%p] aStatus: %u", this,
+                    static_cast<uint8_t>(aStatus)));
+
   for (auto* workerRef : data->mWorkerRefs.ForwardRange()) {
     workerRef->Notify();
   }
@@ -4268,6 +4315,9 @@
       aFailStatus >= Canceling,
       "Sync loops can be created when the worker is in Running/Closing state!");
 
+  LOG(WorkerLog(), ("WorkerPrivate::CreateNewSyncLoop [%p] failstatus: %u",
+                    this, static_cast<uint8_t>(aFailStatus)));
+
   ThreadEventQueue* queue = nullptr;
   {
     MutexAutoLock lock(mMutex);
@@ -4299,6 +4349,7 @@
 
 nsresult WorkerPrivate::RunCurrentSyncLoop() {
   AssertIsOnWorkerThread();
+  LOG(WorkerLog(), ("WorkerPrivate::RunCurrentSyncLoop [%p]", this));
   RefPtr<WorkerThread> thread;
   JSContext* cx = GetJSContext();
   MOZ_ASSERT(cx);
@@ -4402,6 +4453,9 @@
   MOZ_ASSERT(!mSyncLoopStack.IsEmpty());
   MOZ_ASSERT(mSyncLoopStack.Length() - 1 == aLoopIndex);
 
+  LOG(WorkerLog(),
+      ("WorkerPrivate::DestroySyncLoop [%p] aLoopIndex: %u", this, aLoopIndex));
+
   AutoYieldJSThreadExecution yield;
 
   // We're about to delete the loop, stash its event target and result.
@@ -4430,6 +4484,9 @@
     }
 
     if ((mPostSyncLoopOperations & eDispatchCancelingRunnable)) {
+      LOG(WorkerLog(),
+          ("WorkerPrivate::DestroySyncLoop [%p] Dispatching CancelingRunnables",
+           this));
       DispatchCancelingRunnable();
     }
 
@@ -4455,6 +4512,8 @@
   // is finished. We cannot use a WorkerRunnable because they are not
   // accepted any more by the worker, and we do not want to use a
   // WorkerControlRunnable because they are immediately executed.
+
+  LOG(WorkerLog(), ("WorkerPrivate::DispatchCancelingRunnable [%p]", this));
   RefPtr<CancelingRunnable> r = new CancelingRunnable();
   {
     MutexAutoLock lock(mMutex);
@@ -4464,6 +4523,9 @@
   // At the same time, we want to be sure that we interrupt infinite loops.
   // The following runnable starts a timer that cancel the worker, from the
   // parent thread, after CANCELING_TIMEOUT millseconds.
+  LOG(WorkerLog(), ("WorkerPrivate::DispatchCancelingRunnable [%p] Setup a "
+                    "timeout canceling",
+                    this));
   RefPtr<CancelingWithTimeoutOnParentRunnable> rr =
       new CancelingWithTimeoutOnParentRunnable(this);
   rr->Dispatch();
@@ -4782,6 +4844,10 @@
   {
     MutexAutoLock lock(mMutex);
 
+    LOG(WorkerLog(),
+        ("WorkerPrivate::NotifyInternal [%p] mStatus: %u, aStatus: %u", this,
+         static_cast<uint8_t>(mStatus), static_cast<uint8_t>(aStatus)));
+
     if (mStatus >= aStatus) {
       return true;
     }
@@ -4847,6 +4913,9 @@
   // current JS frame is executed.
   if (aStatus == Closing) {
     if (!mSyncLoopStack.IsEmpty()) {
+      LOG(WorkerLog(), ("WorkerPrivate::NotifyInternal [%p] request to "
+                        "dispatch canceling runnables...",
+                        this));
       mPostSyncLoopOperations |= eDispatchCancelingRunnable;
     } else {
       DispatchCancelingRunnable();
@@ -4856,6 +4925,8 @@
 
   MOZ_ASSERT(aStatus == Canceling || aStatus == Killing);
 
+  LOG(WorkerLog(), ("WorkerPrivate::NotifyInternal [%p] abort script", this));
+
   // Always abort the script.
   return false;
 }
@@ -5472,6 +5543,8 @@
 
 void WorkerPrivate::SetWorkerPrivateInWorkerThread(
     WorkerThread* const aThread) {
+  LOG(WorkerLog(),
+      ("WorkerPrivate::SetWorkerPrivateInWorkerThread [%p]", this));
   MutexAutoLock lock(mMutex);
 
   MOZ_ASSERT(!mThread);
@@ -5490,6 +5563,8 @@
 }
 
 void WorkerPrivate::ResetWorkerPrivateInWorkerThread() {
+  LOG(WorkerLog(),
+      ("WorkerPrivate::ResetWorkerPrivateInWorkerThread [%p]", this));
   RefPtr<WorkerThread> doomedThread;
 
   // Release the mutex before doomedThread.