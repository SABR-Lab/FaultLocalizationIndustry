# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/ProcessExecutableMemory.cpp
# Commit: 9d31a829691c
# Full Hash: 9d31a829691ccf798375446e7ef04109e2662175
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2023-06-07 03:30:33
# Regressor Bug: 1835876
# File Overlap Count: 1
# Description:
#   Bug 1835876 part 2 - Disable code write protection in content processes. r=nbp
#   
#   We've worked with the security and performance teams to re-evaluate the W^X policy
#   we have in place to mark JIT code memory pages as either writable or executable
#   (but not both).
# ==============================================================================

diff -r 1ce5ad17da6b -r 9d31a829691c js/src/jit/ProcessExecutableMemory.cpp
--- a/js/src/jit/ProcessExecutableMemory.cpp	Tue Jun 06 12:16:46 2023 +0000
+++ b/js/src/jit/ProcessExecutableMemory.cpp	Tue Jun 06 12:16:46 2023 +0000
@@ -384,6 +384,9 @@
 }
 
 static DWORD ProtectionSettingToFlags(ProtectionSetting protection) {
+  if (!JitOptions.writeProtectCode) {
+    return PAGE_EXECUTE_READWRITE;
+  }
   switch (protection) {
     case ProtectionSetting::Writable:
       return PAGE_READWRITE;
@@ -496,6 +499,9 @@
 }
 
 static unsigned ProtectionSettingToFlags(ProtectionSetting protection) {
+  if (!JitOptions.writeProtectCode) {
+    return PROT_READ | PROT_WRITE | PROT_EXEC;
+  }
 #  ifdef MOZ_VALGRIND
   // If we're configured for Valgrind and running on it, use a slacker
   // scheme that doesn't change execute permissions, since doing so causes
@@ -890,6 +896,10 @@
 #else
   std::atomic_thread_fence(std::memory_order_seq_cst);
 
+  if (!JitOptions.writeProtectCode) {
+    return true;
+  }
+
 #  ifdef XP_WIN
   DWORD flags = ProtectionSettingToFlags(protection);
   // This is a essentially a VirtualProtect, but with lighter impact on