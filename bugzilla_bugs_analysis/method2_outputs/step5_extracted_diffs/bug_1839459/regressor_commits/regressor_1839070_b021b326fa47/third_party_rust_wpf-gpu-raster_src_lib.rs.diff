# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/wpf-gpu-raster/src/lib.rs
# Commit: b021b326fa47
# Full Hash: b021b326fa47eb57e14f858078ab5daaa6cd2274
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-06-20 03:53:45
# Regressor Bug: 1839070
# File Overlap Count: 6
# Description:
#   Bug 1839070 - Emit a start point if close is called immediately after move_to. r=jrmuizel
#   
#   wpf-gpu-raster would blindly modify the last point type in a path when call was closed, even
#   if move_to preceded it directly and outputted no actual point type. In this case, we need to
#   ensure that we emit a start point if close is called immediately after move_to.
# ==============================================================================

diff -r 4c4b0b9db374 -r b021b326fa47 third_party/rust/wpf-gpu-raster/src/lib.rs
--- a/third_party/rust/wpf-gpu-raster/src/lib.rs	Mon Jun 19 19:34:31 2023 +0000
+++ b/third_party/rust/wpf-gpu-raster/src/lib.rs	Mon Jun 19 19:54:24 2023 +0000
@@ -177,6 +177,16 @@
         self.curve_to(c1x, c1y, c2x, c2y, x, y);
     }
     pub fn close(&mut self) {
+        if !self.in_shape {
+            match self.initial_point {
+                Some(initial_point) => {
+                    self.types.push(PathPointTypeStart);
+                    self.add_point(initial_point.X, initial_point.Y);
+                    self.in_shape = true;
+                }
+                None => return,
+            }
+        }
         if let Some(last) = self.types.last_mut() {
             *last |= PathPointTypeCloseSubpath;
         }
@@ -666,4 +676,17 @@
         assert_eq!(result.len(), 279);
         assert_eq!(calculate_hash(&rasterize_to_mask(&result, 70, 40)), 0xbd2eec3cfe9bd30b);
     }
+
+    #[test]
+    fn close_after_move_to() {
+        let mut p = PathBuilder::new();
+        p.move_to(0., 0.);
+        p.line_to(0., 10.);
+        p.line_to(10., 10.);
+        p.move_to(10., 0.);
+        p.close();
+        let result = p.rasterize_to_tri_list(0, 0, 20, 20);
+        assert_eq!(result.len(), 27);
+        assert_eq!(dbg!(calculate_hash(&result)), 0xecfdf5bdfa25a1dd);
+    }
 }