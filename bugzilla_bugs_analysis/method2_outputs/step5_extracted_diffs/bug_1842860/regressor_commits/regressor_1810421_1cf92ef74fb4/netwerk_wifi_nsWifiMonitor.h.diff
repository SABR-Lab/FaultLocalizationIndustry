# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/wifi/nsWifiMonitor.h
# Commit: 1cf92ef74fb4
# Full Hash: 1cf92ef74fb45d3f5b62eb3f7b0fd7c35a2d4f4f
# Author: David Parks <daparks@mozilla.com>
# Date: 2023-05-11 04:06:39
# Regressor Bug: 1810421
# File Overlap Count: 2
# Description:
#   Bug 1810421: Only scan wifi when the network changes or when on mobile r=necko-reviewers,kershaw
#   
#   Simplifies the concurrent operations of wifi scanning and reduces the
#   frequency in common cases.  Wifi scanning when on mobile is reduced from
#   every 5 seconds to every minute.  Wifi scans will also happen whenever
# ==============================================================================

diff -r afd62e82fe83 -r 1cf92ef74fb4 netwerk/wifi/nsWifiMonitor.h
--- a/netwerk/wifi/nsWifiMonitor.h	Wed May 10 19:46:29 2023 +0000
+++ b/netwerk/wifi/nsWifiMonitor.h	Wed May 10 19:46:29 2023 +0000
@@ -18,14 +18,19 @@
 #include "nsIObserver.h"
 #include "nsTArray.h"
 #include "mozilla/Attributes.h"
+#include "mozilla/Monitor.h"
 #include "WifiScanner.h"
 
+namespace mozilla {
+class TestWifiMonitor;
+}
+
 extern mozilla::LazyLogModule gWifiMonitorLog;
-#define LOG(args) MOZ_LOG(gWifiMonitorLog, mozilla::LogLevel::Debug, args)
 
 class nsWifiAccessPoint;
 
-#define kDefaultWifiScanInterval 5 /* seconds */
+// Period between scans when on mobile network.
+#define WIFI_SCAN_INTERVAL_MS_PREF "network.wifi.scanning_period"
 
 #ifdef XP_MACOSX
 // Use a larger stack size for the monitor thread on macOS 13+
@@ -33,48 +38,86 @@
 #  define kMacOS13MonitorStackSize (512 * 1024)
 #endif
 
-class nsWifiListener {
- public:
-  explicit nsWifiListener(nsMainThreadPtrHolder<nsIWifiListener>* aListener) {
-    mListener = aListener;
-    mHasSentData = false;
-  }
-  ~nsWifiListener() = default;
+struct WifiListenerHolder {
+  RefPtr<nsIWifiListener> mListener;
+  bool mShouldPoll;
+  bool mHasSentData = false;
 
-  nsMainThreadPtrHandle<nsIWifiListener> mListener;
-  bool mHasSentData;
+  explicit WifiListenerHolder(nsIWifiListener* aListener,
+                              bool aShouldPoll = false)
+      : mListener(aListener), mShouldPoll(aShouldPoll) {}
 };
 
-class nsWifiMonitor final : nsIRunnable, nsIWifiMonitor, nsIObserver {
+class nsWifiMonitor final : public nsIWifiMonitor, public nsIObserver {
  public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIWIFIMONITOR
-  NS_DECL_NSIRUNNABLE
   NS_DECL_NSIOBSERVER
 
   explicit nsWifiMonitor(
       mozilla::UniquePtr<mozilla::WifiScanner>&& aScanner = nullptr);
 
  private:
-  ~nsWifiMonitor() = default;
+  friend class mozilla::TestWifiMonitor;
+
+  ~nsWifiMonitor();
 
+  nsresult DispatchScanToBackgroundThread(uint64_t aPollingId = 0,
+                                          uint32_t aWaitMs = 0);
+
+  void Scan(uint64_t aPollingId);
   nsresult DoScan();
 
-  nsresult CallWifiListeners(const nsCOMArray<nsWifiAccessPoint>& aAccessPoints,
-                             bool aAccessPointsChanged);
+  nsresult CallWifiListeners(
+      nsTArray<RefPtr<nsIWifiAccessPoint>>&& aAccessPoints,
+      bool aAccessPointsChanged);
 
-  uint32_t GetMonitorThreadStackSize();
+  nsresult PassErrorToWifiListeners(nsresult rv);
+
+  void Close();
+
+  bool IsBackgroundThread();
 
-  mozilla::Atomic<bool> mKeepGoing;
-  mozilla::Atomic<bool> mThreadComplete;
-  nsCOMPtr<nsIThread> mThread;  // only accessed on MainThread
+  bool ShouldPoll() {
+    MOZ_ASSERT(!IsBackgroundThread());
+    return (mShouldPollForCurrentNetwork && !mListeners.IsEmpty()) ||
+           mNumPollingListeners > 0;
+  };
 
-  // Background thread only (except in test).
+#ifdef ENABLE_TESTS
+  // Test-only function that confirms we "should" be polling.  May be wrong
+  // if somehow the polling tasks are not set to run on the background
+  // thread.
+  bool IsPolling() { return mThread && mPollingId; }
+#endif
+
+  // Main thread only.
+  nsCOMPtr<nsIThread> mThread;
+
+  // Main thread only.
+  nsTArray<WifiListenerHolder> mListeners;
+
+  // Background thread only.
   mozilla::UniquePtr<mozilla::WifiScanner> mWifiScanner;
 
-  nsTArray<nsWifiListener> mListeners MOZ_GUARDED_BY(mReentrantMonitor);
+  // Background thread only.  Sorted.
+  nsTArray<RefPtr<nsIWifiAccessPoint>> mLastAccessPoints;
+
+  // Wifi-scanning requests may poll, meaning they will run repeatedly on
+  // a scheduled time period.  If this value is 0 then polling is not running,
+  // otherwise, it indicates the "ID" of the polling that is running.  if some
+  // other polling (with different ID) is running, it will stop, not iterate.
+  mozilla::Atomic<uint64_t> mPollingId;
 
-  mozilla::ReentrantMonitor mReentrantMonitor;
+  // Number of current listeners that requested that the wifi scan poll
+  // periodically.
+  // Main thread only.
+  uint32_t mNumPollingListeners = 0;
+
+  // True if the current network type is one that requires polling
+  // (i.e. a "mobile" network type).
+  // Main thread only.
+  bool mShouldPollForCurrentNetwork = false;
 };
 
 #endif