# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/wifi/nsWifiMonitor.cpp
# Commit: 35c408b9531d
# Full Hash: 35c408b9531db01c71dee288cab0a02a633fb535
# Author: David Parks <daparks@mozilla.com>
# Date: 2023-05-13 21:42:25
# Regressor Bug: 1810421
# File Overlap Count: 2
# Description:
#   Bug 1810421: Refactor wifi scanning to consolidate generic code r=necko-reviewers,kershaw,valentin
#   
#   Reorganizes the wifi-scanning code and makes more of it platform-generic
#   to ease the transition from polling the wifi to usually scanning only on
#   network changes.  This is essentially just moving files/code around and
# ==============================================================================

diff -r 029be11fa3d8 -r 35c408b9531d netwerk/wifi/nsWifiMonitor.cpp
--- a/netwerk/wifi/nsWifiMonitor.cpp	Sat May 13 00:11:51 2023 +0000
+++ b/netwerk/wifi/nsWifiMonitor.cpp	Sat May 13 00:36:00 2023 +0000
@@ -19,8 +19,25 @@
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/Services.h"
 
-#ifdef XP_MACOSX
+#if defined(XP_WIN)
+#  include "WinWifiScanner.h"
+#endif
+
+#if defined(XP_MACOSX)
 #  include "nsCocoaFeatures.h"
+#  include "MacWifiScanner.h"
+#endif
+
+#if defined(__DragonFly__) || defined(__FreeBSD__)
+#  include "FreeBsdWifiScanner.h"
+#endif
+
+#if defined(XP_SOLARIS)
+#  include "SolarisWifiScanner.h"
+#endif
+
+#if defined(NECKO_WIFI_DBUS)
+#  include "DbusWifiScanner.h"
 #endif
 
 using namespace mozilla;
@@ -29,10 +46,14 @@
 
 NS_IMPL_ISUPPORTS(nsWifiMonitor, nsIRunnable, nsIObserver, nsIWifiMonitor)
 
-nsWifiMonitor::nsWifiMonitor()
+nsWifiMonitor::nsWifiMonitor(UniquePtr<mozilla::WifiScanner>&& aScanner)
     : mKeepGoing(true),
       mThreadComplete(false),
+      mWifiScanner(std::move(aScanner)),
       mReentrantMonitor("nsWifiMonitor.mReentrantMonitor") {
+  LOG(("Creating nsWifiMonitor"));
+  MOZ_ASSERT(NS_IsMainThread());
+
   nsCOMPtr<nsIObserverService> obsSvc = mozilla::services::GetObserverService();
   if (obsSvc) obsSvc->AddObserver(this, "xpcom-shutdown", false);
 
@@ -194,6 +215,51 @@
   return NS_OK;
 }
 
+nsresult nsWifiMonitor::DoScan() {
+  if (!mWifiScanner) {
+    mWifiScanner = MakeUnique<mozilla::WifiScannerImpl>();
+    if (!mWifiScanner) {
+      // TODO: Probably return OOM error
+      return NS_ERROR_FAILURE;
+    }
+  }
+
+  // Regularly get the access point data.
+  nsCOMArray<nsWifiAccessPoint> lastAccessPoints;
+  nsTArray<RefPtr<nsIWifiAccessPoint>> accessPointsArray;
+
+  do {
+    accessPointsArray.Clear();
+    nsresult rv = mWifiScanner->GetAccessPointsFromWLAN(accessPointsArray);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    nsCOMArray<nsWifiAccessPoint> accessPoints;
+
+    for (auto& ap : accessPointsArray) {
+      accessPoints.AppendObject(static_cast<nsWifiAccessPoint*>(ap.get()));
+    }
+
+    bool accessPointsChanged =
+        !AccessPointsEqual(accessPoints, lastAccessPoints);
+    ReplaceArray(lastAccessPoints, accessPoints);
+
+    rv = CallWifiListeners(lastAccessPoints, accessPointsChanged);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // wait for some reasonable amount of time.  pref?
+    LOG(("waiting on monitor\n"));
+
+    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+    if (mKeepGoing) {
+      mon.Wait(PR_SecondsToInterval(kDefaultWifiScanInterval));
+    }
+  } while (mKeepGoing);
+
+  return NS_OK;
+}
+
 class nsCallWifiListeners final : public nsIRunnable {
  public:
   NS_DECL_THREADSAFE_ISUPPORTS