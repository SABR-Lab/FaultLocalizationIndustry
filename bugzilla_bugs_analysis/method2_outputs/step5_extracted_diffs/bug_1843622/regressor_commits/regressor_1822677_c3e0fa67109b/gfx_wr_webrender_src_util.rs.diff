# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/util.rs
# Commit: c3e0fa67109b
# Full Hash: c3e0fa67109b8ca34a940c559ae264b3994b4802
# Author: Glenn Watson <git@intuitionlibrary.com>
# Date: 2023-07-10 09:40:14
# Regressor Bug: 1822677
# File Overlap Count: 1
# Description:
#   Bug 1822677 - Improve handling invalid ScaleOffset during inverse. r=gfx-reviewers,lsalzman
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D182427
# ==============================================================================

diff -r 50d6377ff840 -r c3e0fa67109b gfx/wr/webrender/src/util.rs
--- a/gfx/wr/webrender/src/util.rs	Sun Jul 09 19:09:27 2023 +0000
+++ b/gfx/wr/webrender/src/util.rs	Sun Jul 09 20:33:21 2023 +0000
@@ -5,7 +5,7 @@
 use api::BorderRadius;
 use api::units::*;
 use euclid::{Point2D, Rect, Box2D, Size2D, Vector2D, point2, point3};
-use euclid::{default, Transform2D, Transform3D, Scale};
+use euclid::{default, Transform2D, Transform3D, Scale, approxeq::ApproxEq};
 use malloc_size_of::{MallocShallowSizeOf, MallocSizeOf, MallocSizeOfOps};
 use plane_split::{Clipper, Polygon};
 use std::{i32, f32, fmt, ptr};
@@ -197,6 +197,15 @@
     }
 
     pub fn inverse(&self) -> Self {
+        // If either of the scale factors is 0, all we can do is
+        // return identity.
+        // TODO(gw): Consider making this return Option<Self> in future
+        //           so that callers can detect and handle when inverse
+        //           fails here.
+        if self.scale.x.approx_eq(&0.0) || self.scale.y.approx_eq(&0.0) {
+            return ScaleOffset::identity();
+        }
+
         ScaleOffset {
             scale: Vector2D::new(
                 1.0 / self.scale.x,
@@ -855,6 +864,17 @@
     }
 
     #[test]
+    fn scale_offset_invalid_scale() {
+        let s0 = ScaleOffset::new(0.0, 1.0, 10.0, 20.0);
+        let i0 = s0.inverse();
+        assert_eq!(i0, ScaleOffset::identity());
+
+        let s1 = ScaleOffset::new(1.0, 0.0, 10.0, 20.0);
+        let i1 = s1.inverse();
+        assert_eq!(i1, ScaleOffset::identity());
+    }
+
+    #[test]
     fn inverse_project_2d_origin() {
         let mut m = Transform3D::identity();
         assert_eq!(m.inverse_project_2d_origin(), Some(Point2D::zero()));
