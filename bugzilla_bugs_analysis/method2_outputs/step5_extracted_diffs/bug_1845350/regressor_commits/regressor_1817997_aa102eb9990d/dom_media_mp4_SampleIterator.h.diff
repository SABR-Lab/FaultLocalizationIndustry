# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/mp4/SampleIterator.h
# Commit: aa102eb9990d
# Full Hash: aa102eb9990d6edbd5cf7473c5017082340764ff
# Author: Paul Adenot <paul@paul.cx>
# Date: 2023-05-24 21:42:08
# Regressor Bug: 1817997
# File Overlap Count: 1
# Description:
#   Bug 1817997 - Update the MP4 demuxer to use TimeUnit based on the internal MP4 time base. r=alwu
#   
#   This still gets the initial time value from mp4parse-rust, that is in
#   microseconds. mp4parse-rust has been updated to expose real time, and will be
#   updated later.
# ==============================================================================

diff -r 5c1b6ce71ca1 -r aa102eb9990d dom/media/mp4/SampleIterator.h
--- a/dom/media/mp4/SampleIterator.h	Wed May 24 13:18:40 2023 +0000
+++ b/dom/media/mp4/SampleIterator.h	Wed May 24 13:18:40 2023 +0000
@@ -21,16 +21,14 @@
 class MP4SampleIndex;
 struct Sample;
 
-typedef int64_t Microseconds;
-
 class SampleIterator {
  public:
   explicit SampleIterator(MP4SampleIndex* aIndex);
   ~SampleIterator();
   bool HasNext();
   already_AddRefed<mozilla::MediaRawData> GetNext();
-  void Seek(Microseconds aTime);
-  Microseconds GetNextKeyframeTime();
+  void Seek(const media::TimeUnit& aTime);
+  media::TimeUnit GetNextKeyframeTime();
 
  private:
   Sample* Get();
@@ -97,7 +95,7 @@
     uint32_t mIndex;
     int64_t mStartOffset;
     int64_t mEndOffset;
-    MP4Interval<Microseconds> mTime;
+    MP4Interval<media::TimeUnit> mTime;
   };
 
   MP4SampleIndex(const mozilla::IndiceWrapper& aIndices, ByteStream* aSource,
@@ -106,11 +104,11 @@
   void UpdateMoofIndex(const mozilla::MediaByteRangeSet& aByteRanges,
                        bool aCanEvict);
   void UpdateMoofIndex(const mozilla::MediaByteRangeSet& aByteRanges);
-  Microseconds GetEndCompositionIfBuffered(
+  media::TimeUnit GetEndCompositionIfBuffered(
       const mozilla::MediaByteRangeSet& aByteRanges);
   mozilla::media::TimeIntervals ConvertByteRangesToTimeRanges(
       const mozilla::MediaByteRangeSet& aByteRanges);
-  uint64_t GetEvictionOffset(Microseconds aTime);
+  uint64_t GetEvictionOffset(const media::TimeUnit& aTime);
   bool IsFragmented() { return !!mMoofParser; }
 
   friend class SampleIterator;
