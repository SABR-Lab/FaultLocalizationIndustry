# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/TLSTransportLayer.cpp
# Commit: 970422f6006c
# Full Hash: 970422f6006c712e04ad97a1712a217677a7a01a
# Author: Kershaw Chang <kershaw@mozilla.com>
# Date: 2023-08-17 08:54:42
# Description:
#   Bug 1848999 - Always release TLSTransportLayer on socket thread, r=necko-reviewers,valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D186388
# ==============================================================================

diff -r 44ba8ebd6477 -r 970422f6006c netwerk/protocol/http/TLSTransportLayer.cpp
--- a/netwerk/protocol/http/TLSTransportLayer.cpp	Thu Aug 17 00:55:25 2023 +0000
+++ b/netwerk/protocol/http/TLSTransportLayer.cpp	Thu Aug 17 01:59:11 2023 +0000
@@ -319,8 +319,41 @@
 static PRIOMethods sTLSTransportLayerMethods;
 static PRIOMethods* sTLSTransportLayerMethodsPtr = nullptr;
 
+bool TLSTransportLayer::DispatchRelease() {
+  if (OnSocketThread()) {
+    return false;
+  }
+
+  gSocketTransportService->Dispatch(
+      NewNonOwningRunnableMethod("net::TLSTransportLayer::Release", this,
+                                 &TLSTransportLayer::Release),
+      NS_DISPATCH_NORMAL);
+
+  return true;
+}
+
 NS_IMPL_ADDREF(TLSTransportLayer)
-NS_IMPL_RELEASE(TLSTransportLayer)
+NS_IMETHODIMP_(MozExternalRefCountType)
+TLSTransportLayer::Release() {
+  nsrefcnt count = mRefCnt - 1;
+  if (DispatchRelease()) {
+    // Redispatched to the socket thread.
+    return count;
+  }
+
+  MOZ_ASSERT(0 != mRefCnt, "dup release");
+  count = --mRefCnt;
+  NS_LOG_RELEASE(this, count, "TLSTransportLayer");
+
+  if (0 == count) {
+    mRefCnt = 1;
+    delete (this);
+    return 0;
+  }
+
+  return count;
+}
+
 NS_INTERFACE_MAP_BEGIN(TLSTransportLayer)
   NS_INTERFACE_MAP_ENTRY(nsISocketTransport)
   NS_INTERFACE_MAP_ENTRY(nsITransport)
@@ -342,28 +375,13 @@
 }
 
 TLSTransportLayer::~TLSTransportLayer() {
+  MOZ_ASSERT(OnSocketThread(), "not on socket thread");
   LOG(("TLSTransportLayer dtor this=[%p]", this));
-
-  auto closeSocket = [fd = mFD, socketControl = std::move(mTLSSocketControl)] {
-    MOZ_ASSERT(OnSocketThread(), "not on socket thread");
-    if (fd) {
-      PR_Close(fd);
-    }
-    // mTLSSocketControl must be released after closing fd
-  };
-
-  if (OnSocketThread()) {
-    closeSocket();
-    return;
+  if (mFD) {
+    PR_Close(mFD);
+    mFD = nullptr;
   }
-
-  if (mFD) {
-    gSocketTransportService->Dispatch(NS_NewRunnableFunction(
-        "TLSTransportLayer::~TLSTransportLayer", std::move(closeSocket)));
-    return;
-  }
-
-  // mTLSSocketControl is released when closeSocket goes out of scope
+  mTLSSocketControl = nullptr;
 }
 
 bool TLSTransportLayer::Init(const char* aTLSHost, int32_t aTLSPort) {