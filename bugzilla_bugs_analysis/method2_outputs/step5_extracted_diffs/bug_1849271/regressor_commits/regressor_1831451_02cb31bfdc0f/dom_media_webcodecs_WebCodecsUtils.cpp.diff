# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/WebCodecsUtils.cpp
# Commit: 02cb31bfdc0f
# Full Hash: 02cb31bfdc0f4a15397b3a4e0725c408d738b34c
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-30 04:06:43
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Implement VideoDecoder::IsConfigSupported r=padenot
#   
#   This patch implements the isConfigSupported method for WebCodecs'
#   VideoDecoder.
#   
# ==============================================================================

diff -r 77b0f5226ed8 -r 02cb31bfdc0f dom/media/webcodecs/WebCodecsUtils.cpp
--- a/dom/media/webcodecs/WebCodecsUtils.cpp	Thu Jun 29 22:33:11 2023 +0000
+++ b/dom/media/webcodecs/WebCodecsUtils.cpp	Thu Jun 29 22:33:11 2023 +0000
@@ -6,6 +6,8 @@
 
 #include "WebCodecsUtils.h"
 
+#include "VideoUtils.h"
+#include "js/experimental/TypedData.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/CheckedInt.h"
 #include "nsDebug.h"
@@ -13,6 +15,30 @@
 namespace mozilla::dom {
 
 /*
+ * The followings are helpers for VideoDecoder methods
+ */
+
+nsTArray<nsCString> GuessContainers(const nsString& aCodec) {
+  if (IsAV1CodecString(aCodec)) {
+    return {"mp4"_ns, "webm"_ns};
+  }
+
+  if (IsVP9CodecString(aCodec)) {
+    return {"mp4"_ns, "webm"_ns, "ogg"_ns};
+  }
+
+  if (IsVP8CodecString(aCodec)) {
+    return {"webm"_ns, "ogg"_ns, "3gpp"_ns, "3gpp2"_ns, "3gp2"_ns};
+  }
+
+  if (IsH264CodecString(aCodec)) {
+    return {"mp4"_ns, "3gpp"_ns, "3gpp2"_ns, "3gp2"_ns};
+  }
+
+  return {};
+}
+
+/*
  * The below are helpers to operate ArrayBuffer or ArrayBufferView.
  */
 template <class T>
@@ -49,4 +75,58 @@
   return GetArrayBufferData(aBuffer.GetAsArrayBuffer());
 }
 
+static std::tuple<JS::ArrayBufferOrView, size_t, size_t> GetArrayBufferInfo(
+    JSContext* aCx,
+    const OwningMaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer& aBuffer) {
+  if (aBuffer.IsArrayBuffer()) {
+    const ArrayBuffer& buffer = aBuffer.GetAsArrayBuffer();
+    buffer.ComputeState();
+    CheckedInt<size_t> byteLength(buffer.Length());
+    byteLength *= sizeof(JS::ArrayBuffer::DataType);
+    return byteLength.isValid()
+               ? std::make_tuple(
+                     JS::ArrayBufferOrView::fromObject(buffer.Obj()), (size_t)0,
+                     byteLength.value())
+               : std::make_tuple(JS::ArrayBufferOrView::fromObject(nullptr),
+                                 (size_t)0, (size_t)0);
+  }
+
+  MOZ_ASSERT(aBuffer.IsArrayBufferView());
+  const ArrayBufferView& view = aBuffer.GetAsArrayBufferView();
+  bool isSharedMemory;
+  JS::Rooted<JSObject*> obj(aCx, view.Obj());
+  return std::make_tuple(
+      JS::ArrayBufferOrView::fromObject(
+          JS_GetArrayBufferViewBuffer(aCx, obj, &isSharedMemory)),
+      JS_GetTypedArrayByteOffset(obj), JS_GetTypedArrayByteLength(obj));
+}
+
+Result<OwningMaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer, nsresult>
+CloneBuffer(
+    JSContext* aCx,
+    const OwningMaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer& aBuffer) {
+  std::tuple<JS::ArrayBufferOrView, size_t, size_t> info =
+      GetArrayBufferInfo(aCx, aBuffer);
+  const JS::ArrayBufferOrView& bufOrView = std::get<0>(info);
+  size_t offset = std::get<1>(info);
+  size_t len = std::get<2>(info);
+  if (NS_WARN_IF(!bufOrView)) {
+    return Err(NS_ERROR_UNEXPECTED);
+  }
+
+  JS::Rooted<JSObject*> obj(aCx, bufOrView.asObject());
+  JS::Rooted<JSObject*> cloned(aCx,
+                               JS::ArrayBufferClone(aCx, obj, offset, len));
+  if (NS_WARN_IF(!cloned)) {
+    return Err(NS_ERROR_OUT_OF_MEMORY);
+  }
+
+  JS::Rooted<JS::Value> value(aCx, JS::ObjectValue(*cloned));
+  OwningMaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer clonedBufOrView;
+  if (NS_WARN_IF(!clonedBufOrView.Init(aCx, value))) {
+    return Err(NS_ERROR_UNEXPECTED);
+  }
+  return clonedBufOrView;
+}
+
 }  // namespace mozilla::dom