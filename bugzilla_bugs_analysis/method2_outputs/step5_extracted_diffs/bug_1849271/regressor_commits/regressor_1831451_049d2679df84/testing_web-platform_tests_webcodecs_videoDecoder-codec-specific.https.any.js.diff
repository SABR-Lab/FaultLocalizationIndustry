# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js
# Commit: 049d2679df84
# Full Hash: 049d2679df8446aeece4556f8416ac7e68b5d9c5
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-30 04:06:43
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Schedule to report error in Close() r=padenot
#   
#   This patch completes the implementation for close method.
#   
#   By Close VideoDecoder algorithm [1], the error callback is invoked in a
# ==============================================================================

diff -r 30eaff96a933 -r 049d2679df84 testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js
--- a/testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js	Thu Jun 29 22:33:14 2023 +0000
+++ b/testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js	Thu Jun 29 22:33:14 2023 +0000
@@ -363,7 +363,10 @@
   const callbacks = {};
 
   let errors = 0;
-  callbacks.error = e => errors++;
+  let gotError = new Promise(resolve => callbacks.error = e => {
+    errors++;
+    resolve(e);
+  });
   callbacks.output = frame => { frame.close(); };
 
   const decoder = createVideoDecoder(t, callbacks);
@@ -372,9 +375,16 @@
   decoder.decode(new EncodedVideoChunk(
       {type: 'key', timestamp: 1, data: new ArrayBuffer(0)}));
 
-  await promise_rejects_dom(t, 'EncodingError', decoder.flush());
+  await promise_rejects_dom(t, "EncodingError",
+    decoder.flush().catch((e) => {
+      assert_equals(errors, 0);
+      throw e;
+    })
+  );
 
-  assert_equals(errors, 1, 'errors');
+  let e = await gotError;
+  assert_true(e instanceof DOMException);
+  assert_equals(e.name, 'EncodingError');
   assert_equals(decoder.state, 'closed', 'state');
 }, 'Decode empty frame');
 
@@ -384,7 +394,10 @@
   const callbacks = {};
 
   let errors = 0;
-  callbacks.error = e => errors++;
+  let gotError = new Promise(resolve => callbacks.error = e => {
+    errors++;
+    resolve(e);
+  });
 
   let outputs = 0;
   callbacks.output = frame => {
@@ -397,10 +410,17 @@
   decoder.decode(CHUNKS[0]);  // Decode keyframe first.
   decoder.decode(createCorruptChunk(2));
 
-  await promise_rejects_dom(t, 'EncodingError', decoder.flush());
+  await promise_rejects_dom(t, "EncodingError",
+    decoder.flush().catch((e) => {
+      assert_equals(errors, 0);
+      throw e;
+    })
+  );
 
   assert_less_than_equal(outputs, 1);
-  assert_equals(errors, 1, 'errors');
+  let e = await gotError;
+  assert_true(e instanceof DOMException);
+  assert_equals(e.name, 'EncodingError');
   assert_equals(decoder.state, 'closed', 'state');
 }, 'Decode corrupt frame');
 
