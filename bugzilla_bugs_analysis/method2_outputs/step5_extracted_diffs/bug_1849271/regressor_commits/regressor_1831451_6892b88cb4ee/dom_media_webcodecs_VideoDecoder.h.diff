# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/VideoDecoder.h
# Commit: 6892b88cb4ee
# Full Hash: 6892b88cb4ee2f4598c2f264cec6aa4497123518
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-29 15:31:45
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Create a class for ControlMessage r=alwu
#   
#   This patch replaces the `using ControlMessage = Variant<...>` by a
#   `class ControlMessage`, which wraps the common interfaces and variables
#   of the classes within the above `Variant` into a class.
# ==============================================================================

diff -r ecb08baa7f0e -r 6892b88cb4ee dom/media/webcodecs/VideoDecoder.h
--- a/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:04 2023 +0000
+++ b/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:04 2023 +0000
@@ -54,34 +54,23 @@
 
 namespace mozilla::dom {
 
-struct ConfigureMessage final {
-  explicit ConfigureMessage(UniquePtr<VideoDecoderConfig>&& aConfig);
-  const nsCString mTitle;  // Used to identify the message in the logs.
-  MozPromiseRequestHolder<DecoderAgent::ConfigurePromise> mRequest;
-  UniquePtr<VideoDecoderConfig> mConfig;
-};
-
-struct DecodeMessage final {
-  using Id = size_t;
+class ConfigureMessage;
+class DecodeMessage;
+class FlushMessage;
 
-  // ChunkData extracts necessary data in EncodedVideoChunk and hand it over
-  // to DecoderAgent.
-  struct ChunkData;
-  DecodeMessage(Id aId, UniquePtr<ChunkData>&& aData);
+class ControlMessage {
+ public:
+  explicit ControlMessage(const nsACString& aTitle);
+  virtual ~ControlMessage() = default;
+  virtual void Cancel() = 0;
+  virtual bool IsProcessing() = 0;
+
+  virtual const nsCString& ToString() const { return mTitle; }
+  virtual ConfigureMessage* AsConfigureMessage() { return nullptr; }
+  virtual DecodeMessage* AsDecodeMessage() { return nullptr; }
+  virtual FlushMessage* AsFlushMessage() { return nullptr; }
+
   const nsCString mTitle;  // Used to identify the message in the logs.
-  MozPromiseRequestHolder<DecoderAgent::DecodePromise> mRequest;
-  const Id mId;  // A unique id shown in log.
-  UniquePtr<ChunkData> mData;
-};
-
-struct FlushMessage final {
-  using Id = size_t;
-
-  FlushMessage(Id aId, Promise* aPromise);
-  const nsCString mTitle;  // Used to identify the message in the logs.
-  MozPromiseRequestHolder<DecoderAgent::DecodePromise> mRequest;
-  const Id mId;  // A unique id shown in log.
-  RefPtr<Promise> mPromise;
 };
 
 class VideoDecoder final : public DOMEventTargetHelper {
@@ -147,20 +136,22 @@
 
   void ScheduleDequeueEvent();
 
-  void SchedulePromiseResolveOrReject(Promise* aPromise,
+  void SchedulePromiseResolveOrReject(already_AddRefed<Promise> aPromise,
                                       const nsresult& aResult);
 
   void ProcessControlMessageQueue();
   void CancelPendingControlMessages(const nsresult& aResult);
 
-  using ControlMessage = Variant<ConfigureMessage, DecodeMessage, FlushMessage>;
   enum class MessageProcessedResult { NotProcessed, Processed };
 
-  MessageProcessedResult ProcessConfigureMessage(ControlMessage& aMessage);
+  MessageProcessedResult ProcessConfigureMessage(
+      UniquePtr<ControlMessage>& aMessage);
 
-  MessageProcessedResult ProcessDecodeMessage(ControlMessage& aMessage);
+  MessageProcessedResult ProcessDecodeMessage(
+      UniquePtr<ControlMessage>& aMessage);
 
-  MessageProcessedResult ProcessFlushMessage(ControlMessage& aMessage);
+  MessageProcessedResult ProcessFlushMessage(
+      UniquePtr<ControlMessage>& aMessage);
 
   // Returns true when mAgent can be created.
   bool CreateDecoderAgent(UniquePtr<VideoDecoderConfig>&& aConfig,
@@ -175,8 +166,8 @@
   bool mKeyChunkRequired;
 
   bool mMessageQueueBlocked;
-  std::queue<ControlMessage> mControlMessageQueue;
-  Maybe<ControlMessage> mProcessingMessage;
+  std::queue<UniquePtr<ControlMessage>> mControlMessageQueue;
+  UniquePtr<ControlMessage> mProcessingMessage;
 
   // DecoderAgent will be created every time "configure" is being processed, and
   // will be destroyed when "reset" or another "configure" is called (spec
@@ -186,8 +177,12 @@
   uint32_t mDecodeQueueSize;
   bool mDequeueEventScheduled;
 
-  DecodeMessage::Id mDecodeMessageCounter;
-  FlushMessage::Id mFlushMessageCounter;
+  // Tracking how many decode data has been enqueued and this number will be
+  // used as the DecodeMessage's Id.
+  size_t mDecodeCounter;
+  // Tracking how many flush request has been enqueued and this number will be
+  // used as the FlushMessage's Id.
+  size_t mFlushCounter;
 
   // Used to add a nsIAsyncShutdownBlocker on main thread to block
   // xpcom-shutdown before the underlying MediaDataDecoder is created. The
