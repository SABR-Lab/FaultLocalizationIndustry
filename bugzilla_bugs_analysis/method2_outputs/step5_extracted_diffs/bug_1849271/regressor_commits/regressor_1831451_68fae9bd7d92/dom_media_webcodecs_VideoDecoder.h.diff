# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/VideoDecoder.h
# Commit: 68fae9bd7d92
# Full Hash: 68fae9bd7d921366d02d255a1fe6369848b6562d
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-29 15:31:45
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Implement VideoDecoder::Configure r=padenot
#   
#   This patch implements configure method [1] for WebCodecs' VideoDecoder
#   interface. The configure job is via DecoderAgent's Configure().
#   
# ==============================================================================

diff -r 0fca9e6c2ef6 -r 68fae9bd7d92 dom/media/webcodecs/VideoDecoder.h
--- a/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:02 2023 +0000
+++ b/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:02 2023 +0000
@@ -7,24 +7,35 @@
 #ifndef mozilla_dom_VideoDecoder_h
 #define mozilla_dom_VideoDecoder_h
 
+#include <queue>
+
 #include "js/TypeDecls.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/DOMEventTargetHelper.h"
+#include "mozilla/DecoderAgent.h"
 #include "mozilla/ErrorResult.h"
+#include "mozilla/Maybe.h"
+#include "mozilla/RefPtr.h"
 #include "mozilla/Result.h"
+#include "mozilla/UniquePtr.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsStringFwd.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
+
+class TrackInfo;
+
 namespace dom {
 
 class EncodedVideoChunk;
 class EventHandlerNonNull;
 class GlobalObject;
 class Promise;
+class ThreadSafeWorkerRef;
 class VideoFrameOutputCallback;
 class WebCodecsErrorCallback;
 enum class CodecState : uint8_t;
@@ -32,10 +43,22 @@
 struct VideoDecoderInit;
 
 }  // namespace dom
+
+namespace media {
+class ShutdownBlockingTicket;
+}
+
 }  // namespace mozilla
 
 namespace mozilla::dom {
 
+struct ConfigureMessage final {
+  explicit ConfigureMessage(UniquePtr<VideoDecoderConfig>&& aConfig);
+  const nsCString mTitle;  // Used to identify the message in the logs.
+  MozPromiseRequestHolder<DecoderAgent::ConfigurePromise> mRequest;
+  UniquePtr<VideoDecoderConfig> mConfig;
+};
+
 class VideoDecoder final : public DOMEventTargetHelper {
  public:
   NS_DECL_ISUPPORTS_INHERITED
@@ -65,7 +88,8 @@
 
   void SetOndequeue(EventHandlerNonNull* arg);
 
-  void Configure(const VideoDecoderConfig& config, ErrorResult& aRv);
+  MOZ_CAN_RUN_SCRIPT void Configure(const VideoDecoderConfig& aConfig,
+                                    ErrorResult& aRv);
 
   void Decode(EncodedVideoChunk& chunk, ErrorResult& aRv);
 
@@ -88,11 +112,58 @@
 
   MOZ_CAN_RUN_SCRIPT void ReportError(const nsresult& aResult);
 
+  MOZ_CAN_RUN_SCRIPT void ProcessControlMessageQueue();
+  void CancelPendingControlMessages();
+
+  enum class MessageProcessedResult { NotProcessed, Processed };
+  MOZ_CAN_RUN_SCRIPT MessageProcessedResult
+  ProcessConfigureMessage(ConfigureMessage& aMessage);
+
+  // Returns true when mAgent can be created.
+  bool CreateDecoderAgent(UniquePtr<VideoDecoderConfig>&& aConfig,
+                          UniquePtr<TrackInfo>&& aInfo);
+  void DestroyDecoderAgentIfAny();
+
   // Constant in practice, only set in ::Constructor.
   RefPtr<WebCodecsErrorCallback> mErrorCallback;
   RefPtr<VideoFrameOutputCallback> mOutputCallback;
 
   CodecState mState;
+
+  bool mMessageQueueBlocked;
+  std::queue<ConfigureMessage> mControlMessageQueue;
+  Maybe<ConfigureMessage> mProcessingMessage;
+
+  // DecoderAgent will be created every time "configure" is being processed, and
+  // will be destroyed when "reset" or another "configure" is called (spec
+  // allows calling two "configure" without a "reset" in between).
+  RefPtr<DecoderAgent> mAgent;
+  UniquePtr<VideoDecoderConfig> mActiveConfig;
+
+  // Used to add a nsIAsyncShutdownBlocker on main thread to block
+  // xpcom-shutdown before the underlying MediaDataDecoder is created. The
+  // blocker will be held until the underlying MediaDataDecoder has been shut
+  // down. This blocker guarantees RemoteDecoderManagerChild's thread, where the
+  // underlying RemoteMediaDataDecoder is on, outlives the
+  // RemoteMediaDataDecoder, since the thread releasing, which happens on main
+  // thread when getting a xpcom-shutdown signal, is blocked by the added
+  // blocker. As a result, RemoteMediaDataDecoder can safely work on worker
+  // thread with a holding blocker (otherwise, if RemoteDecoderManagerChild
+  // releases its thread on main thread before RemoteMediaDataDecoder's
+  // Shutdown() task run on worker thread, RemoteMediaDataDecoder has no thread
+  // to run).
+  UniquePtr<media::ShutdownBlockingTicket> mShutdownBlocker;
+
+  // Held to make sure the dispatched tasks can be done before worker is going
+  // away. As long as this worker-ref is held somewhere, the tasks dispatched to
+  // the worker can be executed (otherwise the tasks would be canceled). This
+  // ref should be activated as long as the underlying MediaDataDecoder is
+  // alive, and should keep alive until mShutdownBlocker is dropped, so all
+  // MediaDataDecoder's tasks and mShutdownBlocker-releasing task can be
+  // executed.
+  // TODO: Use StrongWorkerRef instead if this is always used in the same
+  // thread?
+  RefPtr<dom::ThreadSafeWorkerRef> mWorkerRef;
 };
 
 }  // namespace mozilla::dom