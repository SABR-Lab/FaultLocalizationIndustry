# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/VideoDecoder.h
# Commit: c8fdb24dd953
# Full Hash: c8fdb24dd9534d70efd09e3bc04c0725bb2db599
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-29 15:31:45
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Implement VideoDecoder::Decode r=padenot
#   
#   This patch implements the decode method [1] for WebCodecs' VideoDecoder
#   interface, and add some code that reset method needs.
#   
# ==============================================================================

diff -r 06f1008127bb -r c8fdb24dd953 dom/media/webcodecs/VideoDecoder.h
--- a/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:02 2023 +0000
+++ b/dom/media/webcodecs/VideoDecoder.h	Thu Jun 29 04:15:02 2023 +0000
@@ -27,7 +27,9 @@
 
 namespace mozilla {
 
+class MediaData;
 class TrackInfo;
+class VideoInfo;
 
 namespace dom {
 
@@ -59,6 +61,19 @@
   UniquePtr<VideoDecoderConfig> mConfig;
 };
 
+struct DecodeMessage final {
+  using Id = size_t;
+
+  // ChunkData extracts necessary data in EncodedVideoChunk and hand it over
+  // to DecoderAgent.
+  struct ChunkData;
+  DecodeMessage(Id aId, UniquePtr<ChunkData>&& aData);
+  const nsCString mTitle;  // Used to identify the message in the logs.
+  MozPromiseRequestHolder<DecoderAgent::DecodePromise> mRequest;
+  const Id mId;  // A unique id shown in log.
+  UniquePtr<ChunkData> mData;
+};
+
 class VideoDecoder final : public DOMEventTargetHelper {
  public:
   NS_DECL_ISUPPORTS_INHERITED
@@ -91,7 +106,7 @@
   MOZ_CAN_RUN_SCRIPT void Configure(const VideoDecoderConfig& aConfig,
                                     ErrorResult& aRv);
 
-  void Decode(EncodedVideoChunk& chunk, ErrorResult& aRv);
+  MOZ_CAN_RUN_SCRIPT void Decode(EncodedVideoChunk& aChunk, ErrorResult& aRv);
 
   already_AddRefed<Promise> Flush(ErrorResult& aRv);
 
@@ -111,13 +126,25 @@
   MOZ_CAN_RUN_SCRIPT Result<Ok, nsresult> Close(const nsresult& aResult);
 
   MOZ_CAN_RUN_SCRIPT void ReportError(const nsresult& aResult);
+  MOZ_CAN_RUN_SCRIPT void OutputVideoFrames(
+      nsTArray<RefPtr<MediaData>>&& aData);
+
+  class OutputRunnable;
+  void ScheduleOutputVideoFrames(nsTArray<RefPtr<MediaData>>&& aData,
+                                 const nsACString& aLabel);
+
+  void ScheduleClose(const nsresult& aResult);
 
   MOZ_CAN_RUN_SCRIPT void ProcessControlMessageQueue();
   void CancelPendingControlMessages();
 
+  using ControlMessage = Variant<ConfigureMessage, DecodeMessage>;
   enum class MessageProcessedResult { NotProcessed, Processed };
+
   MOZ_CAN_RUN_SCRIPT MessageProcessedResult
-  ProcessConfigureMessage(ConfigureMessage& aMessage);
+  ProcessConfigureMessage(ControlMessage& aMessage);
+
+  MessageProcessedResult ProcessDecodeMessage(ControlMessage& aMessage);
 
   // Returns true when mAgent can be created.
   bool CreateDecoderAgent(UniquePtr<VideoDecoderConfig>&& aConfig,
@@ -129,16 +156,19 @@
   RefPtr<VideoFrameOutputCallback> mOutputCallback;
 
   CodecState mState;
+  bool mKeyChunkRequired;
 
   bool mMessageQueueBlocked;
-  std::queue<ConfigureMessage> mControlMessageQueue;
-  Maybe<ConfigureMessage> mProcessingMessage;
+  std::queue<ControlMessage> mControlMessageQueue;
+  Maybe<ControlMessage> mProcessingMessage;
 
   // DecoderAgent will be created every time "configure" is being processed, and
   // will be destroyed when "reset" or another "configure" is called (spec
   // allows calling two "configure" without a "reset" in between).
   RefPtr<DecoderAgent> mAgent;
   UniquePtr<VideoDecoderConfig> mActiveConfig;
+  uint32_t mDecodeQueueSize;
+  DecodeMessage::Id mDecodeMessageCounter;
 
   // Used to add a nsIAsyncShutdownBlocker on main thread to block
   // xpcom-shutdown before the underlying MediaDataDecoder is created. The
