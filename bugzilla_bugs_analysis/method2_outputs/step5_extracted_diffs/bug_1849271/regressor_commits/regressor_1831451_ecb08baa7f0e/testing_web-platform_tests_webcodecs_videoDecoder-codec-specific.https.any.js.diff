# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js
# Commit: ecb08baa7f0e
# Full Hash: ecb08baa7f0ef9cc68b6049afcc358eddc0d096c
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-29 15:31:45
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Schedule to report error in Close() r=padenot
#   
#   This patch completes the implementation for close method.
#   
#   By Close VideoDecoder algorithm [1], the error callback is invoked in a
# ==============================================================================

diff -r f1b3b6d3186b -r ecb08baa7f0e testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js
--- a/testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js	Thu Jun 29 04:15:04 2023 +0000
+++ b/testing/web-platform/tests/webcodecs/videoDecoder-codec-specific.https.any.js	Thu Jun 29 04:15:04 2023 +0000
@@ -363,7 +363,10 @@
   const callbacks = {};
 
   let errors = 0;
-  callbacks.error = e => errors++;
+  let gotError = new Promise(resolve => callbacks.error = e => {
+    errors++;
+    resolve(e);
+  });
   callbacks.output = frame => { frame.close(); };
 
   const decoder = createVideoDecoder(t, callbacks);
@@ -372,9 +375,16 @@
   decoder.decode(new EncodedVideoChunk(
       {type: 'key', timestamp: 1, data: new ArrayBuffer(0)}));
 
-  await promise_rejects_dom(t, 'EncodingError', decoder.flush());
+  await promise_rejects_dom(t, "EncodingError",
+    decoder.flush().catch((e) => {
+      assert_equals(errors, 0);
+      throw e;
+    })
+  );
 
-  assert_equals(errors, 1, 'errors');
+  let e = await gotError;
+  assert_true(e instanceof DOMException);
+  assert_equals(e.name, 'EncodingError');
   assert_equals(decoder.state, 'closed', 'state');
 }, 'Decode empty frame');
 
@@ -384,7 +394,10 @@
   const callbacks = {};
 
   let errors = 0;
-  callbacks.error = e => errors++;
+  let gotError = new Promise(resolve => callbacks.error = e => {
+    errors++;
+    resolve(e);
+  });
 
   let outputs = 0;
   callbacks.output = frame => {
@@ -397,10 +410,17 @@
   decoder.decode(CHUNKS[0]);  // Decode keyframe first.
   decoder.decode(createCorruptChunk(2));
 
-  await promise_rejects_dom(t, 'EncodingError', decoder.flush());
+  await promise_rejects_dom(t, "EncodingError",
+    decoder.flush().catch((e) => {
+      assert_equals(errors, 0);
+      throw e;
+    })
+  );
 
   assert_less_than_equal(outputs, 1);
-  assert_equals(errors, 1, 'errors');
+  let e = await gotError;
+  assert_true(e instanceof DOMException);
+  assert_equals(e.name, 'EncodingError');
   assert_equals(decoder.state, 'closed', 'state');
 }, 'Decode corrupt frame');
 
