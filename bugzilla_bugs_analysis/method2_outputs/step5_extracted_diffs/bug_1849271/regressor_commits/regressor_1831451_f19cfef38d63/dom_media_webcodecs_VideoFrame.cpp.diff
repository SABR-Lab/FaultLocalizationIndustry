# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/VideoFrame.cpp
# Commit: f19cfef38d63
# Full Hash: f19cfef38d63df3cd02b0413e2eea2f81075e649
# Author: Chun-Min Chang <chun.m.chang@gmail.com>
# Date: 2023-06-29 15:31:45
# Regressor Bug: 1831451
# File Overlap Count: 1
# Description:
#   Bug 1831451 - Allow constructing VideoFrame without pixel format r=padenot
#   
#   Depends on D171166
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D171518
# ==============================================================================

diff -r 1cf50ce36a73 -r f19cfef38d63 dom/media/webcodecs/VideoFrame.cpp
--- a/dom/media/webcodecs/VideoFrame.cpp	Thu Jun 29 04:15:03 2023 +0000
+++ b/dom/media/webcodecs/VideoFrame.cpp	Thu Jun 29 04:15:03 2023 +0000
@@ -40,8 +40,21 @@
 #include "nsIPrincipal.h"
 #include "nsIURI.h"
 
+extern mozilla::LazyLogModule gWebCodecsLog;
+
 namespace mozilla::dom {
 
+#ifdef LOG_INTERNAL
+#  undef LOG_INTERNAL
+#endif  // LOG_INTERNAL
+#define LOG_INTERNAL(level, msg, ...) \
+  MOZ_LOG(gWebCodecsLog, LogLevel::level, (msg, ##__VA_ARGS__))
+
+#ifdef LOGW
+#  undef LOGW
+#endif  // LOGW
+#define LOGW(msg, ...) LOG_INTERNAL(Warning, msg, ##__VA_ARGS__)
+
 // Only needed for refcounted objects.
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(VideoFrame, mParent)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(VideoFrame)
@@ -354,9 +367,12 @@
 
 // https://w3c.github.io/webcodecs/#videoframe-verify-rect-offset-alignment
 static Result<Ok, nsCString> VerifyRectOffsetAlignment(
-    const VideoFrame::Format& aFormat, const gfx::IntRect& aRect) {
-  for (const VideoFrame::Format::Plane& p : aFormat.Planes()) {
-    const gfx::IntSize sample = aFormat.SampleSize(p);
+    const Maybe<VideoFrame::Format>& aFormat, const gfx::IntRect& aRect) {
+  if (!aFormat) {
+    return Ok();
+  }
+  for (const VideoFrame::Format::Plane& p : aFormat->Planes()) {
+    const gfx::IntSize sample = aFormat->SampleSize(p);
     if (aRect.X() % sample.Width() != 0) {
       return Err(nsCString("Mismatch between format and given left offset"));
     }
@@ -383,7 +399,7 @@
     rect = *aOverrideRect;
   }
 
-  MOZ_TRY(VerifyRectOffsetAlignment(aFormat, rect));
+  MOZ_TRY(VerifyRectOffsetAlignment(Some(aFormat), rect));
 
   return rect;
 }
@@ -629,7 +645,7 @@
 // https://w3c.github.io/webcodecs/#validate-videoframeinit
 static Result<std::pair<Maybe<gfx::IntRect>, Maybe<gfx::IntSize>>, nsCString>
 ValidateVideoFrameInit(const VideoFrameInit& aInit,
-                       const VideoFrame::Format& aFormat,
+                       const Maybe<VideoFrame::Format>& aFormat,
                        const gfx::IntSize& aCodedSize) {
   if (aCodedSize.Width() <= 0 || aCodedSize.Height() <= 0) {
     return Err(nsCString("codedWidth and codedHeight must be positive"));
@@ -942,7 +958,7 @@
   // TODO: Spec should assign aInit.mFormat to inner format value:
   // https://github.com/w3c/webcodecs/issues/509.
   // This comment should be removed once the issue is resolved.
-  return MakeRefPtr<VideoFrame>(aGlobal, data, aInit.mFormat, codedSize,
+  return MakeRefPtr<VideoFrame>(aGlobal, data, Some(aInit.mFormat), codedSize,
                                 parsedRect,
                                 displaySize ? *displaySize : parsedRect.Size(),
                                 duration, aInit.mTimestamp, colorSpace);
@@ -1001,20 +1017,18 @@
           .map([](const VideoPixelFormat& aFormat) {
             return VideoFrame::Format(aFormat);
           });
-  // TODO: Handle `SurfaceFormatToVideoPixelFormat` failure.
-  if (NS_WARN_IF(!format)) {
-    return Err(nsCString("This image has unsupport format"));
-  }
 
   std::pair<Maybe<gfx::IntRect>, Maybe<gfx::IntSize>> init;
-  MOZ_TRY_VAR(init,
-              ValidateVideoFrameInit(aInit, format.ref(), image->GetSize()));
+  MOZ_TRY_VAR(init, ValidateVideoFrameInit(aInit, format, image->GetSize()));
   Maybe<gfx::IntRect> visibleRect = init.first;
   Maybe<gfx::IntSize> displaySize = init.second;
 
-  if (aInit.mAlpha == AlphaOption::Discard) {
+  if (format && aInit.mAlpha == AlphaOption::Discard) {
     format->MakeOpaque();
     // Keep the alpha data in image for now until it's being rendered.
+    // TODO: The alpha will still be rendered if the format is unrecognized
+    // since no additional flag keeping this request. Should spec address what
+    // to do in this case?
   }
 
   InitializeVisibleRectAndDisplaySize(visibleRect, displaySize,
@@ -1026,10 +1040,10 @@
 
   // TODO: WPT will fail if we guess a VideoColorSpace here.
   const VideoColorSpaceInit colorSpace{};
-  return MakeAndAddRef<VideoFrame>(aGlobal, image, format->PixelFormat(),
-                                   image->GetSize(), visibleRect.value(),
-                                   displaySize.value(), duration,
-                                   aInit.mTimestamp.Value(), colorSpace);
+  return MakeAndAddRef<VideoFrame>(
+      aGlobal, image, format ? Some(format->PixelFormat()) : Nothing(),
+      image->GetSize(), visibleRect.value(), displaySize.value(), duration,
+      aInit.mTimestamp.Value(), colorSpace);
 }
 
 // https://w3c.github.io/webcodecs/#videoframe-initialize-frame-from-other-frame
@@ -1039,10 +1053,14 @@
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aData.mImage);
 
-  VideoFrame::Format format(aData.mFormat);
-  if (aInit.mAlpha == AlphaOption::Discard) {
-    format.MakeOpaque();
+  Maybe<VideoFrame::Format> format =
+      aData.mFormat ? Some(VideoFrame::Format(*aData.mFormat)) : Nothing();
+  if (format && aInit.mAlpha == AlphaOption::Discard) {
+    format->MakeOpaque();
     // Keep the alpha data in image for now until it's being rendered.
+    // TODO: The alpha will still be rendered if the format is unrecognized
+    // since no additional flag keeping this request. Should spec address what
+    // to do in this case?
   }
 
   std::pair<Maybe<gfx::IntRect>, Maybe<gfx::IntSize>> init;
@@ -1061,8 +1079,9 @@
                                                    : aData.mTimestamp;
 
   return MakeAndAddRef<VideoFrame>(
-      aGlobal, aData.mImage, format.PixelFormat(), aData.mImage->GetSize(),
-      *visibleRect, *displaySize, duration, timestamp, aData.mColorSpace);
+      aGlobal, aData.mImage, format ? Some(format->PixelFormat()) : Nothing(),
+      aData.mImage->GetSize(), *visibleRect, *displaySize, duration, timestamp,
+      aData.mColorSpace);
 }
 
 /*
@@ -1070,7 +1089,7 @@
  */
 
 VideoFrameData::VideoFrameData(layers::Image* aImage,
-                               const VideoPixelFormat& aFormat,
+                               const Maybe<VideoPixelFormat>& aFormat,
                                gfx::IntRect aVisibleRect,
                                gfx::IntSize aDisplaySize,
                                Maybe<uint64_t> aDuration, int64_t aTimestamp,
@@ -1084,7 +1103,7 @@
       mColorSpace(aColorSpace) {}
 
 VideoFrameSerializedData::VideoFrameSerializedData(
-    layers::Image* aImage, const VideoPixelFormat& aFormat,
+    layers::Image* aImage, const Maybe<VideoPixelFormat>& aFormat,
     gfx::IntSize aCodedSize, gfx::IntRect aVisibleRect,
     gfx::IntSize aDisplaySize, Maybe<uint64_t> aDuration, int64_t aTimestamp,
     const VideoColorSpaceInit& aColorSpace,
@@ -1097,15 +1116,14 @@
 /*
  * W3C Webcodecs VideoFrame implementation
  */
-
 VideoFrame::VideoFrame(nsIGlobalObject* aParent,
                        const RefPtr<layers::Image>& aImage,
-                       const VideoPixelFormat& aFormat, gfx::IntSize aCodedSize,
-                       gfx::IntRect aVisibleRect, gfx::IntSize aDisplaySize,
+                       const Maybe<VideoPixelFormat>& aFormat,
+                       gfx::IntSize aCodedSize, gfx::IntRect aVisibleRect,
+                       gfx::IntSize aDisplaySize,
                        const Maybe<uint64_t>& aDuration, int64_t aTimestamp,
                        const VideoColorSpaceInit& aColorSpace)
     : mParent(aParent),
-      mResource(Some(Resource(aImage, VideoFrame::Format(aFormat)))),
       mCodedSize(aCodedSize),
       mVisibleRect(aVisibleRect),
       mDisplaySize(aDisplaySize),
@@ -1113,6 +1131,13 @@
       mTimestamp(aTimestamp),
       mColorSpace(aColorSpace) {
   MOZ_ASSERT(mParent);
+  mResource.emplace(
+      Resource(aImage, aFormat.map([](const VideoPixelFormat& aPixelFormat) {
+        return VideoFrame::Format(aPixelFormat);
+      })));
+  if (!mResource->mFormat) {
+    LOGW("Create a VideoFrame with an unrecognized image format");
+  }
 }
 
 VideoFrame::VideoFrame(const VideoFrame& aOther)
@@ -1345,15 +1370,11 @@
   const ImageUtils imageUtils(image);
   Maybe<VideoPixelFormat> format =
       ImageBitmapFormatToVideoPixelFormat(imageUtils.GetFormat());
-  if (!format) {
-    aRv.ThrowTypeError("The video's image is in unsupported format");
-    return nullptr;
-  }
 
   // TODO: Retrive/infer the duration, and colorspace.
   auto r = InitializeFrameFromOtherFrame(
       global.get(),
-      VideoFrameData(image.get(), format.ref(), image->GetPictureRect(),
+      VideoFrameData(image.get(), format, image->GetPictureRect(),
                      image->GetSize(), Nothing(),
                      static_cast<int64_t>(aVideoElement.CurrentTime()), {}),
       aInit);
@@ -1490,7 +1511,7 @@
   auto r = InitializeFrameFromOtherFrame(
       global.get(),
       VideoFrameData(aVideoFrame.mResource->mImage.get(),
-                     aVideoFrame.mResource->mFormat.PixelFormat(),
+                     aVideoFrame.mResource->TryPixelFormat(),
                      aVideoFrame.mVisibleRect, aVideoFrame.mDisplaySize,
                      aVideoFrame.mDuration, aVideoFrame.mTimestamp,
                      aVideoFrame.mColorSpace),
@@ -1523,8 +1544,8 @@
 Nullable<VideoPixelFormat> VideoFrame::GetFormat() const {
   AssertIsOnOwningThread();
 
-  return mResource
-             ? Nullable<VideoPixelFormat>(mResource->mFormat.PixelFormat())
+  return mResource && mResource->mFormat
+             ? Nullable<VideoPixelFormat>(mResource->mFormat->PixelFormat())
              : Nullable<VideoPixelFormat>();
 }
 
@@ -1610,8 +1631,13 @@
     return 0;
   }
 
+  if (!mResource->mFormat) {
+    aRv.ThrowAbortError("The VideoFrame image format is not VideoPixelFormat");
+    return 0;
+  }
+
   auto r = ParseVideoFrameCopyToOptions(aOptions, mVisibleRect, mCodedSize,
-                                        mResource->mFormat);
+                                        mResource->mFormat.ref());
   if (r.isErr()) {
     // TODO: Should throw layout.
     aRv.ThrowTypeError(r.unwrapErr());
@@ -1633,6 +1659,11 @@
     return nullptr;
   }
 
+  if (!mResource->mFormat) {
+    aRv.ThrowNotSupportedError("VideoFrame's image format is unrecognized");
+    return nullptr;
+  }
+
   RefPtr<Promise> p = Promise::Create(mParent.get(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return p.forget();
@@ -1640,7 +1671,7 @@
 
   CombinedBufferLayout layout;
   auto r1 = ParseVideoFrameCopyToOptions(aOptions, mVisibleRect, mCodedSize,
-                                         mResource->mFormat);
+                                         mResource->mFormat.ref());
   if (r1.isErr()) {
     // TODO: Should reject with layout.
     p->MaybeRejectWithTypeError(r1.unwrapErr());
@@ -1662,7 +1693,7 @@
 
   Sequence<PlaneLayout> planeLayouts;
 
-  nsTArray<Format::Plane> planes = mResource->mFormat.Planes();
+  nsTArray<Format::Plane> planes = mResource->mFormat->Planes();
   MOZ_ASSERT(layout.mComputedLayouts.Length() == planes.Length());
 
   // TODO: These jobs can be run in a thread pool (bug 1780656) to unblock the
@@ -1682,17 +1713,17 @@
     // Copy pixels of `size` starting from `origin` on planes[i] to
     // `aDestination`.
     gfx::IntPoint origin(
-        l.mSourceLeftBytes / mResource->mFormat.SampleBytes(planes[i]),
+        l.mSourceLeftBytes / mResource->mFormat->SampleBytes(planes[i]),
         l.mSourceTop);
     gfx::IntSize size(
-        l.mSourceWidthBytes / mResource->mFormat.SampleBytes(planes[i]),
+        l.mSourceWidthBytes / mResource->mFormat->SampleBytes(planes[i]),
         l.mSourceHeight);
     if (!mResource->CopyTo(planes[i], {origin, size},
                            buffer.From(destinationOffset),
                            static_cast<size_t>(l.mDestinationStride))) {
       p->MaybeRejectWithTypeError(
           nsPrintfCString("Failed to copy image data in %s plane",
-                          mResource->mFormat.PlaneName(planes[i])));
+                          mResource->mFormat->PlaneName(planes[i])));
       return p.forget();
     }
   }
@@ -1771,7 +1802,7 @@
   // The serialization is limited to the same process scope so it's ok to
   // serialize a reference instead of a copy.
   aHolder->VideoFrames().AppendElement(VideoFrameSerializedData(
-      image.get(), mResource->mFormat.PixelFormat(), mCodedSize, mVisibleRect,
+      image.get(), mResource->TryPixelFormat(), mCodedSize, mVisibleRect,
       mDisplaySize, mDuration, mTimestamp, mColorSpace, GetPrincipalURI()));
 
   return !NS_WARN_IF(!JS_WriteUint32Pair(aWriter, SCTAG_DOM_VIDEOFRAME, index));
@@ -1787,7 +1818,7 @@
 
   Resource r = mResource.extract();
   auto frame = MakeUnique<TransferredData>(
-      r.mImage.get(), r.mFormat.PixelFormat(), mCodedSize, mVisibleRect,
+      r.mImage.get(), r.TryPixelFormat(), mCodedSize, mVisibleRect,
       mDisplaySize, mDuration, mTimestamp, mColorSpace, GetPrincipalURI());
   Close();
   return frame;
@@ -2111,7 +2142,7 @@
  */
 
 VideoFrame::Resource::Resource(const RefPtr<layers::Image>& aImage,
-                               const class Format& aFormat)
+                               Maybe<class Format>&& aFormat)
     : mImage(aImage), mFormat(aFormat) {
   MOZ_ASSERT(mImage);
 }
@@ -2121,12 +2152,18 @@
   MOZ_ASSERT(mImage);
 }
 
+Maybe<VideoPixelFormat> VideoFrame::Resource::TryPixelFormat() const {
+  return mFormat ? Some(mFormat->PixelFormat()) : Nothing();
+}
+
 uint32_t VideoFrame::Resource::Stride(const Format::Plane& aPlane) const {
+  MOZ_RELEASE_ASSERT(mFormat);
+
   CheckedInt<uint32_t> width(mImage->GetSize().Width());
   switch (aPlane) {
     case Format::Plane::Y:  // and RGBA
     case Format::Plane::A:
-      switch (mFormat.PixelFormat()) {
+      switch (mFormat->PixelFormat()) {
         case VideoPixelFormat::I420:
         case VideoPixelFormat::I420A:
         case VideoPixelFormat::I422:
@@ -2136,20 +2173,20 @@
         case VideoPixelFormat::RGBX:
         case VideoPixelFormat::BGRA:
         case VideoPixelFormat::BGRX:
-          return (width * mFormat.SampleBytes(aPlane)).value();
+          return (width * mFormat->SampleBytes(aPlane)).value();
         case VideoPixelFormat::EndGuard_:
           MOZ_ASSERT_UNREACHABLE("invalid format");
       }
       return 0;
     case Format::Plane::U:  // and UV
     case Format::Plane::V:
-      switch (mFormat.PixelFormat()) {
+      switch (mFormat->PixelFormat()) {
         case VideoPixelFormat::I420:
         case VideoPixelFormat::I420A:
         case VideoPixelFormat::I422:
         case VideoPixelFormat::I444:
         case VideoPixelFormat::NV12:
-          return (((width + 1) / 2) * mFormat.SampleBytes(aPlane)).value();
+          return (((width + 1) / 2) * mFormat->SampleBytes(aPlane)).value();
         case VideoPixelFormat::RGBA:
         case VideoPixelFormat::RGBX:
         case VideoPixelFormat::BGRA:
@@ -2167,18 +2204,22 @@
                                   const gfx::IntRect& aRect,
                                   Span<uint8_t>&& aPlaneDest,
                                   size_t aDestinationStride) const {
+  if (!mFormat) {
+    return false;
+  }
+
   auto copyPlane = [&](const uint8_t* aPlaneData) {
     MOZ_ASSERT(aPlaneData);
 
     CheckedInt<size_t> offset(aRect.Y());
     offset *= Stride(aPlane);
-    offset += aRect.X() * mFormat.SampleBytes(aPlane);
+    offset += aRect.X() * mFormat->SampleBytes(aPlane);
     if (!offset.isValid()) {
       return false;
     }
 
     CheckedInt<size_t> elementsBytes(aRect.Width());
-    elementsBytes *= mFormat.SampleBytes(aPlane);
+    elementsBytes *= mFormat->SampleBytes(aPlane);
     if (!elementsBytes.isValid()) {
       return false;
     }
@@ -2223,7 +2264,7 @@
       // BGRA). To get the data in the matched format, we create a temp buffer
       // holding the image data in that format and then copy them to
       // `aDestination`.
-      const gfx::SurfaceFormat f = mFormat.ToSurfaceFormat();
+      const gfx::SurfaceFormat f = mFormat->ToSurfaceFormat();
       MOZ_ASSERT(f == gfx::SurfaceFormat::R8G8B8A8 ||
                  f == gfx::SurfaceFormat::R8G8B8X8 ||
                  f == gfx::SurfaceFormat::B8G8R8A8 ||
@@ -2266,7 +2307,7 @@
       case Format::Plane::V:
         return copyPlane(mImage->AsPlanarYCbCrImage()->GetData()->mCrChannel);
       case Format::Plane::A:
-        MOZ_ASSERT(mFormat.PixelFormat() == VideoPixelFormat::I420A);
+        MOZ_ASSERT(mFormat->PixelFormat() == VideoPixelFormat::I420A);
         MOZ_ASSERT(mImage->AsPlanarYCbCrImage()->GetData()->mAlpha);
         return copyPlane(
             mImage->AsPlanarYCbCrImage()->GetData()->mAlpha->mChannel);
@@ -2286,7 +2327,13 @@
     }
   }
 
+  // TODO: ImageFormat::MAC_IOSURFACE or ImageFormat::DMABUF
+  LOGW("Cannot copy image data of an unrecognized format");
+
   return false;
 }
 
+#undef LOGW
+#undef LOG_INTERNAL
+
 }  // namespace mozilla::dom