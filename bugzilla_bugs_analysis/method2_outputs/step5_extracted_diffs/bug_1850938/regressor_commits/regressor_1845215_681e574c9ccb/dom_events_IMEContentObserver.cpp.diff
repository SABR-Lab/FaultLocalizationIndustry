# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/IMEContentObserver.cpp
# Commit: 681e574c9ccb
# Full Hash: 681e574c9ccbf20f4dca7bba773c99db36ec4c65
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-08-10 04:42:07
# Regressor Bug: 1845215
# File Overlap Count: 2
# Description:
#   Bug 1845215 - part 2: Make `ContentEventHandler::NodePosition` inherits `RawRangeBoundary` instead of `RangeBoundary` r=smaug
#   
#   It's used for tying a set of node and offset in it in short time and
#   `ContentEventHandler` does not flush pending things in most paths.
#   Therefore, it can avoid using `RangeBoundary` for solving its performance
# ==============================================================================

diff -r 3601308f553b -r 681e574c9ccb dom/events/IMEContentObserver.cpp
--- a/dom/events/IMEContentObserver.cpp	Thu Aug 10 00:59:28 2023 +0000
+++ b/dom/events/IMEContentObserver.cpp	Thu Aug 10 00:59:28 2023 +0000
@@ -37,8 +37,8 @@
 
 namespace mozilla {
 
-using NodePosition = ContentEventHandler::NodePosition;
-using NodePositionBefore = ContentEventHandler::NodePositionBefore;
+using RawNodePosition = ContentEventHandler::RawNodePosition;
+using RawNodePositionBefore = ContentEventHandler::RawNodePositionBefore;
 
 using namespace dom;
 using namespace widget;
@@ -49,14 +49,14 @@
 
 // This method determines the node to use for the point before the current node.
 // If you have the following aContent and aContainer, and want to represent the
-// following point for `NodePosition` or `RangeBoundary`:
+// following point for `RawNodePosition` or `RawRangeBoundary`:
 //
 // <parent> {node} {node} | {node} </parent>
 //  ^                     ^     ^
 // aContainer           point  aContent
 //
 // This function will shift `aContent` to the left into the format which
-// `NodePosition` and `RangeBoundary` use:
+// `RawNodePosition` and `RawRangeBoundary` use:
 //
 // <parent> {node} {node} | {node} </parent>
 //  ^               ^     ^
@@ -871,8 +871,8 @@
   uint32_t offset = 0;
   // get offsets of change and fire notification
   nsresult rv = ContentEventHandler::GetFlatTextLengthInRange(
-      NodePosition(mRootElement, 0u),
-      NodePosition(aContent, aInfo.mChangeStart), mRootElement, &offset,
+      RawNodePosition(mRootElement, 0u),
+      RawNodePosition(aContent, aInfo.mChangeStart), mRootElement, &offset,
       LINE_BREAK_TYPE_NATIVE);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
@@ -948,8 +948,9 @@
                                   aFirstContent->GetPreviousSibling())) {
     mEndOfAddedTextCache.Clear();
     rv = ContentEventHandler::GetFlatTextLengthInRange(
-        NodePosition(mRootElement, 0u),
-        NodePositionBefore(aContainer, PointBefore(aContainer, aFirstContent)),
+        RawNodePosition(mRootElement, 0u),
+        RawNodePositionBefore(aContainer,
+                              PointBefore(aContainer, aFirstContent)),
         mRootElement, &offset, LINE_BREAK_TYPE_NATIVE);
     if (NS_WARN_IF(NS_FAILED((rv)))) {
       return;
@@ -961,8 +962,8 @@
   // get offset at the end of the last added node
   uint32_t addingLength = 0;
   rv = ContentEventHandler::GetFlatTextLengthInRange(
-      NodePositionBefore(aContainer, PointBefore(aContainer, aFirstContent)),
-      NodePosition(aContainer, aLastContent), mRootElement, &addingLength,
+      RawNodePositionBefore(aContainer, PointBefore(aContainer, aFirstContent)),
+      RawNodePosition(aContainer, aLastContent), mRootElement, &addingLength,
       LINE_BREAK_TYPE_NATIVE);
   if (NS_WARN_IF(NS_FAILED((rv)))) {
     mEndOfAddedTextCache.Clear();
@@ -1016,8 +1017,8 @@
     // by open tag of aContainer.  Be careful when aPreviousSibling is nullptr.
 
     rv = ContentEventHandler::GetFlatTextLengthInRange(
-        NodePosition(mRootElement, 0u),
-        NodePosition(containerNode, aPreviousSibling), mRootElement, &offset,
+        RawNodePosition(mRootElement, 0u),
+        RawNodePosition(containerNode, aPreviousSibling), mRootElement, &offset,
         LINE_BREAK_TYPE_NATIVE);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mStartOfRemovingTextRangeCache.Clear();
@@ -1035,8 +1036,8 @@
     textLength = ContentEventHandler::GetNativeTextLength(*textNode);
   } else {
     nsresult rv = ContentEventHandler::GetFlatTextLengthInRange(
-        NodePositionBefore(aChild, 0u),
-        NodePosition(aChild, aChild->GetChildCount()), mRootElement,
+        RawNodePositionBefore(aChild, 0u),
+        RawNodePosition(aChild, aChild->GetChildCount()), mRootElement,
         &textLength, LINE_BREAK_TYPE_NATIVE, true);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mStartOfRemovingTextRangeCache.Clear();
@@ -1117,9 +1118,9 @@
   // editor.
   uint32_t offset;
   nsresult rv = ContentEventHandler::GetFlatTextLengthInRange(
-      NodePosition(mRootElement, 0u),
-      NodePosition(mFirstAddedContainer,
-                   PointBefore(mFirstAddedContainer, mFirstAddedContent)),
+      RawNodePosition(mRootElement, 0u),
+      RawNodePosition(mFirstAddedContainer,
+                      PointBefore(mFirstAddedContainer, mFirstAddedContent)),
       mRootElement, &offset, LINE_BREAK_TYPE_NATIVE);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ClearAddedNodesDuringDocumentChange();
@@ -1129,9 +1130,9 @@
   // Next, compute the text length of added nodes.
   uint32_t length;
   rv = ContentEventHandler::GetFlatTextLengthInRange(
-      NodePosition(mFirstAddedContainer,
-                   PointBefore(mFirstAddedContainer, mFirstAddedContent)),
-      NodePosition(mLastAddedContainer, mLastAddedContent), mRootElement,
+      RawNodePosition(mFirstAddedContainer,
+                      PointBefore(mFirstAddedContainer, mFirstAddedContent)),
+      RawNodePosition(mLastAddedContainer, mLastAddedContent), mRootElement,
       &length, LINE_BREAK_TYPE_NATIVE);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ClearAddedNodesDuringDocumentChange();