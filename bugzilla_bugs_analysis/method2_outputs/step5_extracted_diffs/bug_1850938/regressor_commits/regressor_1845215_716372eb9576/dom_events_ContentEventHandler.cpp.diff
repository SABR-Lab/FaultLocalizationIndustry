# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/ContentEventHandler.cpp
# Commit: 716372eb9576
# Full Hash: 716372eb957627ff4b49013af76de135d93134f0
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-08-10 04:42:07
# Regressor Bug: 1845215
# File Overlap Count: 2
# Description:
#   Bug 1845215 - part 4: Make `ContentEventHandler` stop using strong pointers if safe r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D184467
# ==============================================================================

diff -r d0a2d3fc1837 -r 716372eb9576 dom/events/ContentEventHandler.cpp
--- a/dom/events/ContentEventHandler.cpp	Thu Aug 10 00:59:28 2023 +0000
+++ b/dom/events/ContentEventHandler.cpp	Thu Aug 10 00:59:29 2023 +0000
@@ -95,6 +95,24 @@
 #endif  // #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
 }
 
+template <>
+ContentEventHandler::RawRangeBase<RefPtr<nsINode>, RangeBoundary>::RawRangeBase(
+    RawRangeBase<RefPtr<nsINode>, RangeBoundary>&& aOther) noexcept
+    : mRoot(std::move(aOther.GetRoot())),
+      mStart(std::move(aOther.mStart)),
+      mEnd(std::move(aOther.mEnd)) {}
+
+template <>
+ContentEventHandler::RawRangeBase<nsINode*, RawRangeBoundary>::RawRangeBase(
+    RawRangeBase<nsINode*, RawRangeBoundary>&& aOther) noexcept
+    : mRoot(std::move(aOther.GetRoot())),
+      mStart(std::move(aOther.mStart)),
+      mEnd(std::move(aOther.mEnd)) {
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+  mAssertNoGC.emplace();
+#endif  // #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+}
+
 #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
 template <>
 ContentEventHandler::RawRangeBase<RefPtr<nsINode>,
@@ -475,7 +493,7 @@
   // should initialize the event with the cached value.
   if (aEvent->mInput.mRelativeToInsertionPoint) {
     MOZ_ASSERT(selectionType == SelectionType::eNormal);
-    RefPtr<TextComposition> composition =
+    TextComposition* composition =
         IMEStateManager::GetTextCompositionFor(aEvent->mWidget);
     if (composition) {
       uint32_t compositionStart = composition->NativeOffsetOfStartComposition();
@@ -1132,29 +1150,25 @@
   return NS_OK;
 }
 
-nsresult ContentEventHandler::SetRawRangeFromFlatTextOffset(
-    UnsafeRawRange* aRawRange, uint32_t aOffset, uint32_t aLength,
-    LineBreakType aLineBreakType, bool aExpandToClusterBoundaries,
-    uint32_t* aNewOffset, Text** aLastTextNode) {
-  if (aNewOffset) {
-    *aNewOffset = aOffset;
-  }
-  if (aLastTextNode) {
-    *aLastTextNode = nullptr;
-  }
+Result<ContentEventHandler::DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+ContentEventHandler::ConvertFlatTextOffsetToDOMRange(
+    uint32_t aOffset, uint32_t aLength, LineBreakType aLineBreakType,
+    bool aExpandToClusterBoundaries) {
+  DOMRangeAndAdjustedOffsetInFlattenedText result;
+  result.mAdjustedOffset = aOffset;
 
   // Special case like <br contenteditable>
   if (!mRootElement->HasChildren()) {
-    nsresult rv = aRawRange->CollapseTo(RawRangeBoundary(mRootElement, 0u));
+    nsresult rv = result.mRange.CollapseTo(RawRangeBoundary(mRootElement, 0u));
     if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
+      return Err(rv);
     }
   }
 
   UnsafePreContentIterator preOrderIter;
   nsresult rv = preOrderIter.Init(mRootElement);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+    return Err(rv);
   }
 
   uint32_t offset = 0;
@@ -1172,9 +1186,8 @@
     nsIContent* const content = node->AsContent();
     Text* const contentAsText = Text::FromNode(content);
 
-    if (aLastTextNode && contentAsText) {
-      NS_IF_RELEASE(*aLastTextNode);
-      NS_ADDREF(*aLastTextNode = contentAsText);
+    if (contentAsText) {
+      result.mLastTextNode = contentAsText;
     }
 
     uint32_t textLength = contentAsText
@@ -1203,12 +1216,10 @@
           nsresult rv =
               ExpandToClusterBoundary(*contentAsText, false, &xpOffset);
           if (NS_WARN_IF(NS_FAILED(rv))) {
-            return rv;
+            return Err(rv);
           }
-          if (aNewOffset) {
-            // This is correct since a cluster shouldn't include line break.
-            *aNewOffset -= (oldXPOffset - xpOffset);
-          }
+          // This is correct since a cluster shouldn't include line break.
+          result.mAdjustedOffset -= (oldXPOffset - xpOffset);
         }
         startNode = contentAsText;
         startNodeOffset = Some(xpOffset);
@@ -1216,23 +1227,23 @@
         // Rule #1.2 [<element>
         startNode = content->GetParent();
         if (NS_WARN_IF(!startNode)) {
-          return NS_ERROR_FAILURE;
+          return Err(NS_ERROR_FAILURE);
         }
         startNodeOffset = startNode->ComputeIndexOf(content);
-        if (MOZ_UNLIKELY(NS_WARN_IF(startNodeOffset.isNothing()))) {
+        if (NS_WARN_IF(startNodeOffset.isNothing())) {
           // The content is being removed from the parent!
-          return NS_ERROR_FAILURE;
+          return Err(NS_ERROR_FAILURE);
         }
       } else if (!content->HasChildren()) {
         // Rule #1.3: <element/>[
         startNode = content->GetParent();
         if (NS_WARN_IF(!startNode)) {
-          return NS_ERROR_FAILURE;
+          return Err(NS_ERROR_FAILURE);
         }
         startNodeOffset = startNode->ComputeIndexOf(content);
-        if (MOZ_UNLIKELY(NS_WARN_IF(startNodeOffset.isNothing()))) {
+        if (NS_WARN_IF(startNodeOffset.isNothing())) {
           // The content is being removed from the parent!
-          return NS_ERROR_FAILURE;
+          return Err(NS_ERROR_FAILURE);
         }
         MOZ_ASSERT(*startNodeOffset != UINT32_MAX);
         ++(*startNodeOffset);
@@ -1244,18 +1255,18 @@
       NS_ASSERTION(startNode, "startNode must not be nullptr");
       MOZ_ASSERT(startNodeOffset.isSome(),
                  "startNodeOffset must not be Nothing");
-      rv = aRawRange->SetStart(startNode, *startNodeOffset);
+      rv = result.mRange.SetStart(startNode, *startNodeOffset);
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
+        return Err(rv);
       }
       startSet = true;
 
       if (!aLength) {
-        rv = aRawRange->SetEnd(startNode, *startNodeOffset);
+        rv = result.mRange.SetEnd(startNode, *startNodeOffset);
         if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
+          return Err(rv);
         }
-        return NS_OK;
+        return result;
       }
     }
 
@@ -1287,15 +1298,15 @@
           nsresult rv =
               ExpandToClusterBoundary(*contentAsText, true, &xpOffset);
           if (NS_WARN_IF(NS_FAILED(rv))) {
-            return rv;
+            return Err(rv);
           }
         }
         NS_ASSERTION(xpOffset <= INT32_MAX, "The end node offset is too large");
-        nsresult rv = aRawRange->SetEnd(contentAsText, xpOffset);
+        nsresult rv = result.mRange.SetEnd(contentAsText, xpOffset);
         if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
+          return Err(rv);
         }
-        return NS_OK;
+        return result;
       }
 
       if (endOffset == offset) {
@@ -1306,35 +1317,35 @@
         MOZ_ASSERT(false,
                    "This case should've already been handled at "
                    "the last node which caused some text");
-        return NS_ERROR_FAILURE;
+        return Err(NS_ERROR_FAILURE);
       }
 
       if (content->HasChildren() &&
           ShouldBreakLineBefore(*content, mRootElement)) {
         // Rule #2.3: </element>]
-        rv = aRawRange->SetEnd(content, 0);
+        rv = result.mRange.SetEnd(content, 0);
         if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
+          return Err(rv);
         }
-        return NS_OK;
+        return result;
       }
 
       // Rule #2.4: <element/>]
       nsINode* endNode = content->GetParent();
       if (NS_WARN_IF(!endNode)) {
-        return NS_ERROR_FAILURE;
+        return Err(NS_ERROR_FAILURE);
       }
       const Maybe<uint32_t> indexInParent = endNode->ComputeIndexOf(content);
-      if (MOZ_UNLIKELY(NS_WARN_IF(indexInParent.isNothing()))) {
+      if (NS_WARN_IF(indexInParent.isNothing())) {
         // The content is being removed from the parent!
-        return NS_ERROR_FAILURE;
+        return Err(NS_ERROR_FAILURE);
       }
       MOZ_ASSERT(*indexInParent != UINT32_MAX);
-      rv = aRawRange->SetEnd(endNode, *indexInParent + 1);
+      rv = result.mRange.SetEnd(endNode, *indexInParent + 1);
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
+        return Err(rv);
       }
-      return NS_OK;
+      return result;
     }
 
     offset += textLength;
@@ -1347,34 +1358,32 @@
       // should be start of the root node since clicking on such editor (e.g.,
       // <div contenteditable><span></span></div>) sets caret to the start of
       // the editor (i.e., before <span> in the example).
-      rv = aRawRange->SetStart(mRootElement, 0);
+      rv = result.mRange.SetStart(mRootElement, 0);
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
+        return Err(rv);
       }
       if (!aLength) {
-        rv = aRawRange->SetEnd(mRootElement, 0);
+        rv = result.mRange.SetEnd(mRootElement, 0);
         if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
+          return Err(rv);
         }
-        return NS_OK;
+        return result;
       }
     } else {
       // Rule #1.5: [</root>
-      rv = aRawRange->SetStart(mRootElement, mRootElement->GetChildCount());
+      rv = result.mRange.SetStart(mRootElement, mRootElement->GetChildCount());
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
+        return result;
       }
     }
-    if (aNewOffset) {
-      *aNewOffset = offset;
-    }
+    result.mAdjustedOffset = offset;
   }
   // Rule #2.5: ]</root>
-  rv = aRawRange->SetEnd(mRootElement, mRootElement->GetChildCount());
+  rv = result.mRange.SetEnd(mRootElement, mRootElement->GetChildCount());
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+    return Err(rv);
   }
-  return NS_OK;
+  return result;
 }
 
 /* static */
@@ -1577,28 +1586,31 @@
 
   LineBreakType lineBreakType = GetLineBreakType(aEvent);
 
-  UnsafeRawRange rawRange;
-  uint32_t startOffset = 0;
-  if (NS_WARN_IF(NS_FAILED(SetRawRangeFromFlatTextOffset(
-          &rawRange, aEvent->mInput.mOffset, aEvent->mInput.mLength,
-          lineBreakType, false, &startOffset)))) {
+  Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+      domRangeAndAdjustedOffsetOrError = ConvertFlatTextOffsetToDOMRange(
+          aEvent->mInput.mOffset, aEvent->mInput.mLength, lineBreakType, false);
+  if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+    NS_WARNING("ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
     return NS_ERROR_FAILURE;
   }
+  const DOMRangeAndAdjustedOffsetInFlattenedText domRangeAndAdjustedOffset =
+      domRangeAndAdjustedOffsetOrError.unwrap();
 
   nsString textInRange;
-  if (NS_WARN_IF(NS_FAILED(
-          GenerateFlatTextContent(rawRange, textInRange, lineBreakType)))) {
+  if (NS_WARN_IF(NS_FAILED(GenerateFlatTextContent(
+          domRangeAndAdjustedOffset.mRange, textInRange, lineBreakType)))) {
     return NS_ERROR_FAILURE;
   }
 
-  aEvent->mReply->mOffsetAndData.emplace(startOffset, textInRange,
-                                         OffsetAndDataFor::EditorString);
+  aEvent->mReply->mOffsetAndData.emplace(
+      domRangeAndAdjustedOffset.mAdjustedOffset, textInRange,
+      OffsetAndDataFor::EditorString);
 
   if (aEvent->mWithFontRanges) {
     uint32_t fontRangeLength;
-    if (NS_WARN_IF(NS_FAILED(
-            GenerateFlatFontRanges(rawRange, aEvent->mReply->mFontRanges,
-                                   fontRangeLength, lineBreakType)))) {
+    if (NS_WARN_IF(NS_FAILED(GenerateFlatFontRanges(
+            domRangeAndAdjustedOffset.mRange, aEvent->mReply->mFontRanges,
+            fontRangeLength, lineBreakType)))) {
       return NS_ERROR_FAILURE;
     }
 
@@ -2064,14 +2076,16 @@
   nsAutoString flattenedAllText;
   flattenedAllText.SetIsVoid(true);
   while (offset < kEndOffset) {
-    RefPtr<Text> lastTextNode;
-    UnsafeRawRange rawRange;
-    nsresult rv =
-        SetRawRangeFromFlatTextOffset(&rawRange, offset, 1, lineBreakType, true,
-                                      nullptr, getter_AddRefs(lastTextNode));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
+    Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+        domRangeAndAdjustedOffsetOrError =
+            ConvertFlatTextOffsetToDOMRange(offset, 1, lineBreakType, true);
+    if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+      NS_WARNING(
+          "ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
+      return domRangeAndAdjustedOffsetOrError.unwrapErr();
     }
+    const DOMRangeAndAdjustedOffsetInFlattenedText domRangeAndAdjustedOffset =
+        domRangeAndAdjustedOffsetOrError.unwrap();
 
     // TODO: When we crossed parent block boundary now, we should fill pending
     //       character rects with caret rect after the last visible character
@@ -2079,12 +2093,13 @@
 
     // If the range is collapsed, offset has already reached the end of the
     // contents.
-    if (rawRange.Collapsed()) {
+    if (domRangeAndAdjustedOffset.mRange.Collapsed()) {
       break;
     }
 
     // Get the first frame which causes some text after the offset.
-    FrameAndNodeOffset firstFrame = GetFirstFrameInRangeForTextRect(rawRange);
+    FrameAndNodeOffset firstFrame =
+        GetFirstFrameInRangeForTextRect(domRangeAndAdjustedOffset.mRange);
 
     // If GetFirstFrameInRangeForTextRect() does not return valid frame, that
     // means that the offset reached the end of contents or there is no visible
@@ -2108,22 +2123,24 @@
       // Otherwise, if the node follows a block boundary of a parent block, we
       // can use caret rect at previous visible frame causing flattened text.
       const uint32_t remainingLengthInCurrentRange = [&]() {
-        if (lastTextNode) {
-          if (rawRange.GetStartContainer() == lastTextNode) {
-            if (rawRange.StartOffset() < lastTextNode->TextDataLength()) {
-              return lastTextNode->TextDataLength() - rawRange.StartOffset();
+        if (domRangeAndAdjustedOffset.mLastTextNode) {
+          if (domRangeAndAdjustedOffset.RangeStartsFromLastTextNode()) {
+            if (!domRangeAndAdjustedOffset.RangeStartsFromEndOfContainer()) {
+              return domRangeAndAdjustedOffset.mLastTextNode->TextDataLength() -
+                     domRangeAndAdjustedOffset.mRange.StartOffset();
             }
             return 0u;
           }
           // Must be there are not nodes which may cause generating text.
           // Therefore, we can skip all nodes before the last found text node
           // and all text in the last text node.
-          return lastTextNode->TextDataLength();
+          return domRangeAndAdjustedOffset.mLastTextNode->TextDataLength();
         }
-        if (rawRange.GetStartContainer() &&
-            rawRange.GetStartContainer()->IsContent() &&
-            ShouldBreakLineBefore(*rawRange.GetStartContainer()->AsContent(),
-                                  mRootElement)) {
+        if (domRangeAndAdjustedOffset.RangeStartsFromContent() &&
+            ShouldBreakLineBefore(
+                *domRangeAndAdjustedOffset.mRange.GetStartContainer()
+                     ->AsContent(),
+                mRootElement)) {
           if (kBRLength != 1u && offset - aEvent->mInput.mOffset < kBRLength) {
             // Don't return kBRLength if start position is less than the length
             // of a line-break because the offset may be between CRLF on
@@ -2175,17 +2192,23 @@
         // same as the start of query range, the query range starts from
         // between a line breaker (i.e., the range starts between "\r" and
         // "\n").
-        UnsafeRawRange rawRangeToPrevOffset;
-        nsresult rv = SetRawRangeFromFlatTextOffset(&rawRangeToPrevOffset,
-                                                    aEvent->mInput.mOffset - 1,
-                                                    1, lineBreakType, true);
-        if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
+        Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+            domRangeAndAdjustedOffsetOrError = ConvertFlatTextOffsetToDOMRange(
+                aEvent->mInput.mOffset - 1, 1, lineBreakType, true);
+        if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+          NS_WARNING(
+              "ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
+          return domRangeAndAdjustedOffsetOrError.unwrapErr();
         }
+        const DOMRangeAndAdjustedOffsetInFlattenedText
+            domRangeAndAdjustedOffsetOfPreviousChar =
+                domRangeAndAdjustedOffsetOrError.unwrap();
         startsBetweenLineBreaker =
-            rawRange.GetStartContainer() ==
-                rawRangeToPrevOffset.GetStartContainer() &&
-            rawRange.StartOffset() == rawRangeToPrevOffset.StartOffset();
+            domRangeAndAdjustedOffset.mRange.GetStartContainer() ==
+                domRangeAndAdjustedOffsetOfPreviousChar.mRange
+                    .GetStartContainer() &&
+            domRangeAndAdjustedOffset.mRange.StartOffset() ==
+                domRangeAndAdjustedOffsetOfPreviousChar.mRange.StartOffset();
       }
     }
     // Other contents should cause a line breaker rect before it.
@@ -2234,15 +2257,17 @@
       // If it's not a <br> frame and it's the first character rect at the
       // queried range, we need the previous character rect of the start of
       // the queried range if there is a visible text node.
-      else if (!firstFrame->IsBrFrame() && lastTextNode &&
-               lastTextNode->GetPrimaryFrame()) {
+      else if (!firstFrame->IsBrFrame() &&
+               domRangeAndAdjustedOffset.mLastTextNode &&
+               domRangeAndAdjustedOffset.mLastTextNode->GetPrimaryFrame()) {
         FrameRelativeRect brRectRelativeToLastTextFrame =
-            GuessLineBreakerRectAfter(*lastTextNode);
+            GuessLineBreakerRectAfter(*domRangeAndAdjustedOffset.mLastTextNode);
         if (NS_WARN_IF(!brRectRelativeToLastTextFrame.IsValid())) {
           return NS_ERROR_FAILURE;
         }
-        // Look for the last text frame for lastTextNode.
-        nsIFrame* primaryFrame = lastTextNode->GetPrimaryFrame();
+        // Look for the last text frame for the last text node.
+        nsIFrame* primaryFrame =
+            domRangeAndAdjustedOffset.mLastTextNode->GetPrimaryFrame();
         if (NS_WARN_IF(!primaryFrame)) {
           return NS_ERROR_FAILURE;
         }
@@ -2272,13 +2297,19 @@
         // the first frame for the start of query range are same, that means
         // the start offset is between the first line breaker (i.e., the range
         // starts between "\r" and "\n").
-        nsresult rv = SetRawRangeFromFlatTextOffset(
-            &rawRange, aEvent->mInput.mOffset - 1, 1, lineBreakType, true);
-        if (NS_WARN_IF(NS_FAILED(rv))) {
+        Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+            domRangeAndAdjustedOffsetOrError = ConvertFlatTextOffsetToDOMRange(
+                aEvent->mInput.mOffset - 1, 1, lineBreakType, true);
+        if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+          NS_WARNING(
+              "ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
           return NS_ERROR_UNEXPECTED;
         }
+        const DOMRangeAndAdjustedOffsetInFlattenedText
+            domRangeAndAdjustedOffset =
+                domRangeAndAdjustedOffsetOrError.unwrap();
         FrameAndNodeOffset frameForPrevious =
-            GetFirstFrameInRangeForTextRect(rawRange);
+            GetFirstFrameInRangeForTextRect(domRangeAndAdjustedOffset.mRange);
         startsBetweenLineBreaker = frameForPrevious.mFrame == firstFrame.mFrame;
       }
     } else {
@@ -2439,31 +2470,35 @@
   MOZ_ASSERT(aEvent->mReply->mOffsetAndData.isNothing());
 
   LineBreakType lineBreakType = GetLineBreakType(aEvent);
-  UnsafeRawRange rawRange;
-  RefPtr<Text> lastTextNode;
-  uint32_t startOffset = 0;
-  if (NS_WARN_IF(NS_FAILED(SetRawRangeFromFlatTextOffset(
-          &rawRange, aEvent->mInput.mOffset, aEvent->mInput.mLength,
-          lineBreakType, true, &startOffset, getter_AddRefs(lastTextNode))))) {
+  Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+      domRangeAndAdjustedOffsetOrError = ConvertFlatTextOffsetToDOMRange(
+          aEvent->mInput.mOffset, aEvent->mInput.mLength, lineBreakType, true);
+  if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+    NS_WARNING("ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
     return NS_ERROR_FAILURE;
   }
+  DOMRangeAndAdjustedOffsetInFlattenedText domRangeAndAdjustedOffset =
+      domRangeAndAdjustedOffsetOrError.unwrap();
   nsString string;
-  if (NS_WARN_IF(NS_FAILED(
-          GenerateFlatTextContent(rawRange, string, lineBreakType)))) {
+  if (NS_WARN_IF(NS_FAILED(GenerateFlatTextContent(
+          domRangeAndAdjustedOffset.mRange, string, lineBreakType)))) {
     return NS_ERROR_FAILURE;
   }
-  aEvent->mReply->mOffsetAndData.emplace(startOffset, string,
-                                         OffsetAndDataFor::EditorString);
+  aEvent->mReply->mOffsetAndData.emplace(
+      domRangeAndAdjustedOffset.mAdjustedOffset, string,
+      OffsetAndDataFor::EditorString);
 
   // used to iterate over all contents and their frames
   UnsafePostContentIterator postOrderIter;
-  rv = postOrderIter.Init(rawRange.Start().AsRaw(), rawRange.End().AsRaw());
+  rv = postOrderIter.Init(domRangeAndAdjustedOffset.mRange.Start().AsRaw(),
+                          domRangeAndAdjustedOffset.mRange.End().AsRaw());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_FAILURE;
   }
 
   // Get the first frame which causes some text after the offset.
-  FrameAndNodeOffset firstFrame = GetFirstFrameInRangeForTextRect(rawRange);
+  FrameAndNodeOffset firstFrame =
+      GetFirstFrameInRangeForTextRect(domRangeAndAdjustedOffset.mRange);
 
   // If GetFirstFrameInRangeForTextRect() does not return valid frame, that
   // means that there are no visible frames having text or the offset reached
@@ -2482,12 +2517,13 @@
     }
 
     // Look for the last frame which should be included text rects.
-    rv = rawRange.SelectNodeContents(mRootElement);
+    rv = domRangeAndAdjustedOffset.mRange.SelectNodeContents(mRootElement);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return NS_ERROR_UNEXPECTED;
     }
     nsRect rect;
-    FrameAndNodeOffset lastFrame = GetLastFrameInRangeForTextRect(rawRange);
+    FrameAndNodeOffset lastFrame =
+        GetLastFrameInRangeForTextRect(domRangeAndAdjustedOffset.mRange);
     // If there is at least one frame which can be used for computing a rect
     // for a character or a line breaker, we should use it for guessing the
     // caret rect at the end of the contents.
@@ -2607,10 +2643,11 @@
   // Therefore, if the first frame isn't a <br> frame and there is a visible
   // text node before the first node in the queried range, we should compute the
   // first rect with the previous character's rect.
-  else if (!firstFrame->IsBrFrame() && lastTextNode &&
-           lastTextNode->GetPrimaryFrame()) {
+  else if (!firstFrame->IsBrFrame() &&
+           domRangeAndAdjustedOffset.mLastTextNode &&
+           domRangeAndAdjustedOffset.mLastTextNode->GetPrimaryFrame()) {
     FrameRelativeRect brRectAfterLastChar =
-        GuessLineBreakerRectAfter(*lastTextNode);
+        GuessLineBreakerRectAfter(*domRangeAndAdjustedOffset.mLastTextNode);
     if (NS_WARN_IF(!brRectAfterLastChar.IsValid())) {
       return NS_ERROR_FAILURE;
     }
@@ -2646,7 +2683,8 @@
   EnsureNonEmptyRect(rect);
 
   // Get the last frame which causes some text in the range.
-  FrameAndNodeOffset lastFrame = GetLastFrameInRangeForTextRect(rawRange);
+  FrameAndNodeOffset lastFrame =
+      GetLastFrameInRangeForTextRect(domRangeAndAdjustedOffset.mRange);
   if (NS_WARN_IF(!lastFrame.IsValid())) {
     return NS_ERROR_FAILURE;
   }
@@ -3343,16 +3381,21 @@
   Maybe<uint32_t> startNodeOffset;
   Maybe<uint32_t> endNodeOffset;
   {
-    UnsafeRawRange rawRange;
-    rv = SetRawRangeFromFlatTextOffset(
-        &rawRange, aEvent->mOffset, aEvent->mLength, GetLineBreakType(aEvent),
-        aEvent->mExpandToClusterBoundary);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    startNode = rawRange.GetStartContainer();
-    endNode = rawRange.GetEndContainer();
-    startNodeOffset = Some(rawRange.StartOffset());
-    endNodeOffset = Some(rawRange.EndOffset());
+    Result<DOMRangeAndAdjustedOffsetInFlattenedText, nsresult>
+        domRangeAndAdjustedOffsetOrError = ConvertFlatTextOffsetToDOMRange(
+            aEvent->mOffset, aEvent->mLength, GetLineBreakType(aEvent),
+            aEvent->mExpandToClusterBoundary);
+    if (MOZ_UNLIKELY(domRangeAndAdjustedOffsetOrError.isErr())) {
+      NS_WARNING(
+          "ContentEventHandler::ConvertFlatTextOffsetToDOMRange() failed");
+      return domRangeAndAdjustedOffsetOrError.unwrapErr();
+    }
+    const DOMRangeAndAdjustedOffsetInFlattenedText domRangeAndAdjustedOffset =
+        domRangeAndAdjustedOffsetOrError.unwrap();
+    startNode = domRangeAndAdjustedOffset.mRange.GetStartContainer();
+    endNode = domRangeAndAdjustedOffset.mRange.GetEndContainer();
+    startNodeOffset = Some(domRangeAndAdjustedOffset.mRange.StartOffset());
+    endNodeOffset = Some(domRangeAndAdjustedOffset.mRange.EndOffset());
     AdjustRangeForSelection(mRootElement, &startNode, &startNodeOffset);
     AdjustRangeForSelection(mRootElement, &endNode, &endNodeOffset);
     if (NS_WARN_IF(!startNode) || NS_WARN_IF(!endNode) ||