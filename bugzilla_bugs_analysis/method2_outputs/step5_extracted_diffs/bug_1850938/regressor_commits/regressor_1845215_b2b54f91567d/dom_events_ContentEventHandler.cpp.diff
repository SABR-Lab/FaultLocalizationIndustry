# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/ContentEventHandler.cpp
# Commit: b2b54f91567d
# Full Hash: b2b54f91567d2de224314e03fc81ba6e815e2fa7
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-08-10 04:42:07
# Regressor Bug: 1845215
# File Overlap Count: 2
# Description:
#   Bug 1845215 - part 5: Rename `ContentEventHandler::*RawRange*` to `*SimpleRange*` r=smaug
#   
#   `RawRange` sounds like related to `RawRangeBoundary`, but it now has
#   `RangeBoundary` members and `UnsafeRawRange` has `RawRangeBoundary`s.
#   
# ==============================================================================

diff -r 716372eb9576 -r b2b54f91567d dom/events/ContentEventHandler.cpp
--- a/dom/events/ContentEventHandler.cpp	Thu Aug 10 00:59:29 2023 +0000
+++ b/dom/events/ContentEventHandler.cpp	Thu Aug 10 00:59:29 2023 +0000
@@ -59,14 +59,15 @@
 using namespace widget;
 
 /******************************************************************/
-/* ContentEventHandler::RawRangeBase                                  */
+/* ContentEventHandler::SimpleRangeBase                           */
 /******************************************************************/
 template <>
-ContentEventHandler::RawRangeBase<RefPtr<nsINode>,
-                                  RangeBoundary>::RawRangeBase() = default;
+ContentEventHandler::SimpleRangeBase<
+    RefPtr<nsINode>, RangeBoundary>::SimpleRangeBase() = default;
 
 template <>
-ContentEventHandler::RawRangeBase<nsINode*, RawRangeBoundary>::RawRangeBase()
+ContentEventHandler::SimpleRangeBase<nsINode*,
+                                     RawRangeBoundary>::SimpleRangeBase()
     : mRoot(nullptr) {
 #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
   mAssertNoGC.emplace();
@@ -75,8 +76,9 @@
 
 template <>
 template <typename OtherNodeType, typename OtherRangeBoundaryType>
-ContentEventHandler::RawRangeBase<RefPtr<nsINode>, RangeBoundary>::RawRangeBase(
-    const RawRangeBase<OtherNodeType, OtherRangeBoundaryType>& aOther)
+ContentEventHandler::SimpleRangeBase<RefPtr<nsINode>, RangeBoundary>::
+    SimpleRangeBase(
+        const SimpleRangeBase<OtherNodeType, OtherRangeBoundaryType>& aOther)
     : mRoot(aOther.GetRoot()),
       mStart{aOther.Start().AsRaw()},
       mEnd{aOther.End().AsRaw()}
@@ -85,8 +87,9 @@
 
 template <>
 template <typename OtherNodeType, typename OtherRangeBoundaryType>
-ContentEventHandler::RawRangeBase<nsINode*, RawRangeBoundary>::RawRangeBase(
-    const RawRangeBase<OtherNodeType, OtherRangeBoundaryType>& aOther)
+ContentEventHandler::SimpleRangeBase<nsINode*, RawRangeBoundary>::
+    SimpleRangeBase(
+        const SimpleRangeBase<OtherNodeType, OtherRangeBoundaryType>& aOther)
     : mRoot(aOther.GetRoot()),
       mStart{aOther.Start().AsRaw()},
       mEnd{aOther.End().AsRaw()} {
@@ -96,15 +99,17 @@
 }
 
 template <>
-ContentEventHandler::RawRangeBase<RefPtr<nsINode>, RangeBoundary>::RawRangeBase(
-    RawRangeBase<RefPtr<nsINode>, RangeBoundary>&& aOther) noexcept
+ContentEventHandler::SimpleRangeBase<RefPtr<nsINode>, RangeBoundary>::
+    SimpleRangeBase(
+        SimpleRangeBase<RefPtr<nsINode>, RangeBoundary>&& aOther) noexcept
     : mRoot(std::move(aOther.GetRoot())),
       mStart(std::move(aOther.mStart)),
       mEnd(std::move(aOther.mEnd)) {}
 
 template <>
-ContentEventHandler::RawRangeBase<nsINode*, RawRangeBoundary>::RawRangeBase(
-    RawRangeBase<nsINode*, RawRangeBoundary>&& aOther) noexcept
+ContentEventHandler::SimpleRangeBase<nsINode*, RawRangeBoundary>::
+    SimpleRangeBase(
+        SimpleRangeBase<nsINode*, RawRangeBoundary>&& aOther) noexcept
     : mRoot(std::move(aOther.GetRoot())),
       mStart(std::move(aOther.mStart)),
       mEnd(std::move(aOther.mEnd)) {
@@ -115,17 +120,18 @@
 
 #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
 template <>
-ContentEventHandler::RawRangeBase<RefPtr<nsINode>,
-                                  RangeBoundary>::~RawRangeBase() = default;
+ContentEventHandler::SimpleRangeBase<
+    RefPtr<nsINode>, RangeBoundary>::~SimpleRangeBase() = default;
 
 template <>
-ContentEventHandler::RawRangeBase<nsINode*, RawRangeBoundary>::~RawRangeBase() {
+ContentEventHandler::SimpleRangeBase<nsINode*,
+                                     RawRangeBoundary>::~SimpleRangeBase() {
   MOZ_DIAGNOSTIC_ASSERT(!mMutationGuard.Mutated(0));
 }
 #endif  // #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
 
 template <typename NodeType, typename RangeBoundaryType>
-void ContentEventHandler::RawRangeBase<
+void ContentEventHandler::SimpleRangeBase<
     NodeType, RangeBoundaryType>::AssertStartIsBeforeOrEqualToEnd() {
   MOZ_ASSERT(
       *nsContentUtils::ComparePoints(
@@ -139,7 +145,7 @@
 
 template <typename NodeType, typename RangeBoundaryType>
 nsresult
-ContentEventHandler::RawRangeBase<NodeType, RangeBoundaryType>::SetStart(
+ContentEventHandler::SimpleRangeBase<NodeType, RangeBoundaryType>::SetStart(
     const RawRangeBoundary& aStart) {
   nsINode* newRoot = RangeUtils::ComputeRootNode(aStart.Container());
   if (!newRoot) {
@@ -164,7 +170,8 @@
 }
 
 template <typename NodeType, typename RangeBoundaryType>
-nsresult ContentEventHandler::RawRangeBase<NodeType, RangeBoundaryType>::SetEnd(
+nsresult
+ContentEventHandler::SimpleRangeBase<NodeType, RangeBoundaryType>::SetEnd(
     const RawRangeBoundary& aEnd) {
   nsINode* newRoot = RangeUtils::ComputeRootNode(aEnd.Container());
   if (!newRoot) {
@@ -190,13 +197,13 @@
 
 template <typename NodeType, typename RangeBoundaryType>
 nsresult
-ContentEventHandler::RawRangeBase<NodeType, RangeBoundaryType>::SetEndAfter(
+ContentEventHandler::SimpleRangeBase<NodeType, RangeBoundaryType>::SetEndAfter(
     nsINode* aEndContainer) {
   return SetEnd(RangeUtils::GetRawRangeBoundaryAfter(aEndContainer));
 }
 
 template <typename NodeType, typename RangeBoundaryType>
-void ContentEventHandler::RawRangeBase<
+void ContentEventHandler::SimpleRangeBase<
     NodeType, RangeBoundaryType>::SetStartAndEnd(const nsRange* aRange) {
   DebugOnly<nsresult> rv =
       SetStartAndEnd(aRange->StartRef().AsRaw(), aRange->EndRef().AsRaw());
@@ -204,9 +211,9 @@
 }
 
 template <typename NodeType, typename RangeBoundaryType>
-nsresult
-ContentEventHandler::RawRangeBase<NodeType, RangeBoundaryType>::SetStartAndEnd(
-    const RawRangeBoundary& aStart, const RawRangeBoundary& aEnd) {
+nsresult ContentEventHandler::SimpleRangeBase<
+    NodeType, RangeBoundaryType>::SetStartAndEnd(const RawRangeBoundary& aStart,
+                                                 const RawRangeBoundary& aEnd) {
   nsINode* newStartRoot = RangeUtils::ComputeRootNode(aStart.Container());
   if (!newStartRoot) {
     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
@@ -252,7 +259,7 @@
 }
 
 template <typename NodeType, typename RangeBoundaryType>
-nsresult ContentEventHandler::RawRangeBase<NodeType, RangeBoundaryType>::
+nsresult ContentEventHandler::SimpleRangeBase<NodeType, RangeBoundaryType>::
     SelectNodeContents(const nsINode* aNodeToSelectContents) {
   nsINode* const newRoot =
       RangeUtils::ComputeRootNode(const_cast<nsINode*>(aNodeToSelectContents));
@@ -409,7 +416,7 @@
 
   mSelection = nullptr;
   mRootElement = nullptr;
-  mFirstSelectedRawRange.Clear();
+  mFirstSelectedSimpleRange.Clear();
 
   nsresult rv = InitBasic(aRequireFlush);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -443,7 +450,7 @@
   }
 
   if (mSelection->RangeCount()) {
-    mFirstSelectedRawRange.SetStartAndEnd(mSelection->GetRangeAt(0));
+    mFirstSelectedSimpleRange.SetStartAndEnd(mSelection->GetRangeAt(0));
     return NS_OK;
   }
 
@@ -451,13 +458,13 @@
   // is a special selection or we're handling eQuerySelectedText.
   if (aSelectionType != SelectionType::eNormal ||
       aEventMessage == eQuerySelectedText) {
-    MOZ_ASSERT(!mFirstSelectedRawRange.IsPositioned());
+    MOZ_ASSERT(!mFirstSelectedSimpleRange.IsPositioned());
     return NS_OK;
   }
 
   // But otherwise, we need to assume that there is a selection range at the
   // beginning of the root content if aSelectionType is eNormal.
-  rv = mFirstSelectedRawRange.CollapseTo(RawRangeBoundary(mRootElement, 0u));
+  rv = mFirstSelectedSimpleRange.CollapseTo(RawRangeBoundary(mRootElement, 0u));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_UNEXPECTED;
   }
@@ -503,7 +510,7 @@
     } else {
       LineBreakType lineBreakType = GetLineBreakType(aEvent);
       uint32_t selectionStart = 0;
-      rv = GetStartOffset(mFirstSelectedRawRange, &selectionStart,
+      rv = GetStartOffset(mFirstSelectedSimpleRange, &selectionStart,
                           lineBreakType);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return NS_ERROR_FAILURE;
@@ -841,7 +848,7 @@
     const Element* aElement, nsString& aString, LineBreakType aLineBreakType) {
   MOZ_ASSERT(aString.IsEmpty());
 
-  UnsafeRawRange rawRange;
+  UnsafeSimpleRange rawRange;
   nsresult rv = rawRange.SelectNodeContents(aElement);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
@@ -850,30 +857,30 @@
 }
 
 nsresult ContentEventHandler::GenerateFlatTextContent(
-    const UnsafeRawRange& aRawRange, nsString& aString,
+    const UnsafeSimpleRange& aSimpleRange, nsString& aString,
     LineBreakType aLineBreakType) {
   MOZ_ASSERT(aString.IsEmpty());
 
-  if (aRawRange.Collapsed()) {
+  if (aSimpleRange.Collapsed()) {
     return NS_OK;
   }
 
-  nsINode* startNode = aRawRange.GetStartContainer();
-  nsINode* endNode = aRawRange.GetEndContainer();
+  nsINode* startNode = aSimpleRange.GetStartContainer();
+  nsINode* endNode = aSimpleRange.GetEndContainer();
   if (NS_WARN_IF(!startNode) || NS_WARN_IF(!endNode)) {
     return NS_ERROR_FAILURE;
   }
 
   if (startNode == endNode && startNode->IsText()) {
-    AppendSubString(aString, *startNode->AsText(), aRawRange.StartOffset(),
-                    aRawRange.EndOffset() - aRawRange.StartOffset());
+    AppendSubString(aString, *startNode->AsText(), aSimpleRange.StartOffset(),
+                    aSimpleRange.EndOffset() - aSimpleRange.StartOffset());
     ConvertToNativeNewlines(aString);
     return NS_OK;
   }
 
   UnsafePreContentIterator preOrderIter;
-  nsresult rv =
-      preOrderIter.Init(aRawRange.Start().AsRaw(), aRawRange.End().AsRaw());
+  nsresult rv = preOrderIter.Init(aSimpleRange.Start().AsRaw(),
+                                  aSimpleRange.End().AsRaw());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
@@ -888,10 +895,10 @@
 
     if (const Text* textNode = Text::FromNode(node)) {
       if (textNode == startNode) {
-        AppendSubString(aString, *textNode, aRawRange.StartOffset(),
-                        textNode->TextLength() - aRawRange.StartOffset());
+        AppendSubString(aString, *textNode, aSimpleRange.StartOffset(),
+                        textNode->TextLength() - aSimpleRange.StartOffset());
       } else if (textNode == endNode) {
-        AppendSubString(aString, *textNode, 0, aRawRange.EndOffset());
+        AppendSubString(aString, *textNode, 0, aSimpleRange.EndOffset());
       } else {
         AppendString(aString, *textNode);
       }
@@ -1022,16 +1029,16 @@
 }
 
 nsresult ContentEventHandler::GenerateFlatFontRanges(
-    const UnsafeRawRange& aRawRange, FontRangeArray& aFontRanges,
+    const UnsafeSimpleRange& aSimpleRange, FontRangeArray& aFontRanges,
     uint32_t& aLength, LineBreakType aLineBreakType) {
   MOZ_ASSERT(aFontRanges.IsEmpty(), "aRanges must be empty array");
 
-  if (aRawRange.Collapsed()) {
+  if (aSimpleRange.Collapsed()) {
     return NS_OK;
   }
 
-  nsINode* startNode = aRawRange.GetStartContainer();
-  nsINode* endNode = aRawRange.GetEndContainer();
+  nsINode* startNode = aSimpleRange.GetStartContainer();
+  nsINode* endNode = aSimpleRange.GetEndContainer();
   if (NS_WARN_IF(!startNode) || NS_WARN_IF(!endNode)) {
     return NS_ERROR_FAILURE;
   }
@@ -1039,8 +1046,8 @@
   // baseOffset is the flattened offset of each content node.
   uint32_t baseOffset = 0;
   UnsafePreContentIterator preOrderIter;
-  nsresult rv =
-      preOrderIter.Init(aRawRange.Start().AsRaw(), aRawRange.End().AsRaw());
+  nsresult rv = preOrderIter.Init(aSimpleRange.Start().AsRaw(),
+                                  aSimpleRange.End().AsRaw());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
@@ -1056,9 +1063,9 @@
 
     if (const Text* textNode = Text::FromNode(content)) {
       const uint32_t startOffset =
-          textNode != startNode ? 0 : aRawRange.StartOffset();
-      const uint32_t endOffset =
-          textNode != endNode ? textNode->TextLength() : aRawRange.EndOffset();
+          textNode != startNode ? 0 : aSimpleRange.StartOffset();
+      const uint32_t endOffset = textNode != endNode ? textNode->TextLength()
+                                                     : aSimpleRange.EndOffset();
       AppendFontRanges(aFontRanges, *textNode, baseOffset, startOffset,
                        endOffset, aLineBreakType);
       baseOffset += GetTextLengthInRange(*textNode, startOffset, endOffset,
@@ -1484,7 +1491,7 @@
 
   MOZ_ASSERT(aEvent->mReply->mOffsetAndData.isNothing());
 
-  if (!mFirstSelectedRawRange.IsPositioned()) {
+  if (!mFirstSelectedSimpleRange.IsPositioned()) {
     MOZ_ASSERT(aEvent->mReply->mOffsetAndData.isNothing());
     MOZ_ASSERT_IF(mSelection, !mSelection->RangeCount());
     // This is special case that `mReply` is emplaced, but mOffsetAndData is
@@ -1493,9 +1500,9 @@
     return NS_OK;
   }
 
-  UnsafeRawRange firstSelectedRawRange(mFirstSelectedRawRange);
-  nsINode* const startNode = firstSelectedRawRange.GetStartContainer();
-  nsINode* const endNode = firstSelectedRawRange.GetEndContainer();
+  const UnsafeSimpleRange firstSelectedSimpleRange(mFirstSelectedSimpleRange);
+  nsINode* const startNode = firstSelectedSimpleRange.GetStartContainer();
+  nsINode* const endNode = firstSelectedSimpleRange.GetEndContainer();
 
   // Make sure the selection is within the root content range.
   if (!startNode->IsInclusiveDescendantOf(mRootElement) ||
@@ -1505,17 +1512,17 @@
 
   LineBreakType lineBreakType = GetLineBreakType(aEvent);
   uint32_t startOffset = 0;
-  if (NS_WARN_IF(NS_FAILED(GetStartOffset(firstSelectedRawRange, &startOffset,
-                                          lineBreakType)))) {
+  if (NS_WARN_IF(NS_FAILED(GetStartOffset(firstSelectedSimpleRange,
+                                          &startOffset, lineBreakType)))) {
     return NS_ERROR_FAILURE;
   }
 
   const RawRangeBoundary anchorRef = mSelection->RangeCount() > 0
                                          ? mSelection->AnchorRef().AsRaw()
-                                         : firstSelectedRawRange.Start();
+                                         : firstSelectedSimpleRange.Start();
   const RawRangeBoundary focusRef = mSelection->RangeCount() > 0
                                         ? mSelection->FocusRef().AsRaw()
-                                        : firstSelectedRawRange.End();
+                                        : firstSelectedSimpleRange.End();
   if (NS_WARN_IF(!anchorRef.IsSet()) || NS_WARN_IF(!focusRef.IsSet())) {
     return NS_ERROR_FAILURE;
   }
@@ -1542,9 +1549,9 @@
     }
 
     nsString selectedString;
-    if (!firstSelectedRawRange.Collapsed() &&
+    if (!firstSelectedSimpleRange.Collapsed() &&
         NS_WARN_IF(NS_FAILED(GenerateFlatTextContent(
-            firstSelectedRawRange, selectedString, lineBreakType)))) {
+            firstSelectedSimpleRange, selectedString, lineBreakType)))) {
       return NS_ERROR_FAILURE;
     }
     aEvent->mReply->mOffsetAndData.emplace(startOffset, selectedString,
@@ -1636,11 +1643,11 @@
 
 ContentEventHandler::FrameAndNodeOffset
 ContentEventHandler::GetFirstFrameInRangeForTextRect(
-    const UnsafeRawRange& aRawRange) {
+    const UnsafeSimpleRange& aSimpleRange) {
   RawNodePosition nodePosition;
   UnsafePreContentIterator preOrderIter;
-  nsresult rv =
-      preOrderIter.Init(aRawRange.Start().AsRaw(), aRawRange.End().AsRaw());
+  nsresult rv = preOrderIter.Init(aSimpleRange.Start().AsRaw(),
+                                  aSimpleRange.End().AsRaw());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return FrameAndNodeOffset();
   }
@@ -1665,8 +1672,8 @@
     if (auto* textNode = Text::FromNode(content)) {
       // If the range starts at the end of a text node, we need to find
       // next node which causes text.
-      const uint32_t offsetInNode = textNode == aRawRange.GetStartContainer()
-                                        ? aRawRange.StartOffset()
+      const uint32_t offsetInNode = textNode == aSimpleRange.GetStartContainer()
+                                        ? aSimpleRange.StartOffset()
                                         : 0u;
       if (offsetInNode < textNode->TextDataLength()) {
         nodePosition = {textNode, offsetInNode};
@@ -1700,16 +1707,16 @@
 
 ContentEventHandler::FrameAndNodeOffset
 ContentEventHandler::GetLastFrameInRangeForTextRect(
-    const UnsafeRawRange& aRawRange) {
+    const UnsafeSimpleRange& aSimpleRange) {
   RawNodePosition nodePosition;
   UnsafePreContentIterator preOrderIter;
-  nsresult rv =
-      preOrderIter.Init(aRawRange.Start().AsRaw(), aRawRange.End().AsRaw());
+  nsresult rv = preOrderIter.Init(aSimpleRange.Start().AsRaw(),
+                                  aSimpleRange.End().AsRaw());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return FrameAndNodeOffset();
   }
 
-  const RawRangeBoundary& endPoint = aRawRange.End();
+  const RawRangeBoundary& endPoint = aSimpleRange.End();
   MOZ_ASSERT(endPoint.IsSetAndValid());
   // If the end point is start of a text node or specified by its parent and
   // index, the node shouldn't be included into the range.  For example,
@@ -1726,15 +1733,15 @@
   // caller will return too tall rect which includes 2 lines in this case isn't
   // expected by native IME  (e.g., popup of IME will be positioned at bottom
   // of "d" instead of right-bottom of "c").  Therefore, this method shouldn't
-  // include the last frame when its content isn't really in aRawRange.
+  // include the last frame when its content isn't really in aSimpleRange.
   nsINode* nextNodeOfRangeEnd = nullptr;
   if (endPoint.Container()->IsText()) {
-    // Don't set nextNodeOfRangeEnd to the start node of aRawRange because if
+    // Don't set nextNodeOfRangeEnd to the start node of aSimpleRange because if
     // the container of the end is same as start node of the range, the text
     // node shouldn't be next of range end even if the offset is 0.  This
     // could occur with empty text node.
     if (endPoint.IsStartOfContainer() &&
-        aRawRange.GetStartContainer() != endPoint.Container()) {
+        aSimpleRange.GetStartContainer() != endPoint.Container()) {
       nextNodeOfRangeEnd = endPoint.Container();
     }
   } else if (endPoint.IsSetAndValid()) {
@@ -1764,8 +1771,8 @@
     }
 
     if (auto* textNode = Text::FromNode(node)) {
-      nodePosition = {textNode, textNode == aRawRange.GetEndContainer()
-                                    ? aRawRange.EndOffset()
+      nodePosition = {textNode, textNode == aSimpleRange.GetEndContainer()
+                                    ? aSimpleRange.EndOffset()
                                     : textNode->TextDataLength()};
 
       // If the text node is empty or the last node of the range but the index
@@ -2820,7 +2827,7 @@
     nsIFrame* caretFrame = nsCaret::GetGeometry(mSelection, &caretRect);
     if (caretFrame) {
       uint32_t offset;
-      rv = GetStartOffset(mFirstSelectedRawRange, &offset,
+      rv = GetStartOffset(mFirstSelectedSimpleRange, &offset,
                           GetLineBreakType(aEvent));
       NS_ENSURE_SUCCESS(rv, rv);
       if (offset == aEvent->mInput.mOffset) {
@@ -3097,8 +3104,8 @@
       return rv;
     }
   } else {
-    RawRange prevRawRange;
-    nsresult rv = prevRawRange.SetStart(aStartPosition.AsRaw());
+    SimpleRange prevSimpleRange;
+    nsresult rv = prevSimpleRange.SetStart(aStartPosition.AsRaw());
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
@@ -3133,23 +3140,23 @@
 
     if (endPosition.IsSetAndValid()) {
       // Offset is within node's length; set end of range to that offset
-      rv = prevRawRange.SetEnd(endPosition.AsRaw());
+      rv = prevSimpleRange.SetEnd(endPosition.AsRaw());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
-      rv = preOrderIter.Init(prevRawRange.Start().AsRaw(),
-                             prevRawRange.End().AsRaw());
+      rv = preOrderIter.Init(prevSimpleRange.Start().AsRaw(),
+                             prevSimpleRange.End().AsRaw());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     } else if (endPosition.Container() != aRootElement) {
       // Offset is past node's length; set end of range to end of node
-      rv = prevRawRange.SetEndAfter(endPosition.Container());
+      rv = prevSimpleRange.SetEndAfter(endPosition.Container());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
-      rv = preOrderIter.Init(prevRawRange.Start().AsRaw(),
-                             prevRawRange.End().AsRaw());
+      rv = preOrderIter.Init(prevSimpleRange.Start().AsRaw(),
+                             prevSimpleRange.End().AsRaw());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
@@ -3203,10 +3210,10 @@
   return NS_OK;
 }
 
-template <typename RawRangeType>
-nsresult ContentEventHandler::GetStartOffset(const RawRangeType& aRawRange,
-                                             uint32_t* aOffset,
-                                             LineBreakType aLineBreakType) {
+template <typename SimpleRangeType>
+nsresult ContentEventHandler::GetStartOffset(
+    const SimpleRangeType& aSimpleRange, uint32_t* aOffset,
+    LineBreakType aLineBreakType) {
   // To match the "no skip start" hack in ContentIterator::Init, when range
   // offset is 0 and the range node is not a container, we have to assume the
   // range _includes_ the node, which means the start offset should _not_
@@ -3220,34 +3227,34 @@
   // range does _not_ include the linebreak from <p> because <p> is a container,
   // so the start offset _should_ include <p>, and the start offset should be 1.
 
-  nsINode* startNode = aRawRange.GetStartContainer();
+  nsINode* startNode = aSimpleRange.GetStartContainer();
   bool startIsContainer = true;
   if (startNode->IsHTMLElement()) {
     nsAtom* name = startNode->NodeInfo()->NameAtom();
     startIsContainer =
         nsHTMLElement::IsContainer(nsHTMLTags::AtomTagToId(name));
   }
-  RawNodePosition startPos(startNode, aRawRange.StartOffset());
+  RawNodePosition startPos(startNode, aSimpleRange.StartOffset());
   startPos.mAfterOpenTag = startIsContainer;
   return GetFlatTextLengthInRange(RawNodePosition(mRootElement, 0u), startPos,
                                   mRootElement, aOffset, aLineBreakType);
 }
 
 nsresult ContentEventHandler::AdjustCollapsedRangeMaybeIntoTextNode(
-    RawRange& aRawRange) {
-  MOZ_ASSERT(aRawRange.Collapsed());
-
-  if (!aRawRange.Collapsed()) {
+    SimpleRange& aSimpleRange) {
+  MOZ_ASSERT(aSimpleRange.Collapsed());
+
+  if (!aSimpleRange.Collapsed()) {
     return NS_ERROR_INVALID_ARG;
   }
 
-  const RangeBoundary& startPoint = aRawRange.Start();
+  const RangeBoundary& startPoint = aSimpleRange.Start();
   if (NS_WARN_IF(!startPoint.IsSet())) {
     return NS_ERROR_INVALID_ARG;
   }
 
   // If the node does not have children like a text node, we don't need to
-  // modify aRawRange.
+  // modify aSimpleRange.
   if (!startPoint.Container()->HasChildren()) {
     return NS_OK;
   }
@@ -3261,7 +3268,7 @@
     if (!startPoint.Container()->GetFirstChild()->IsText()) {
       return NS_OK;
     }
-    nsresult rv = aRawRange.CollapseTo(
+    nsresult rv = aSimpleRange.CollapseTo(
         RawRangeBoundary(startPoint.Container()->GetFirstChild(), 0u));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
@@ -3278,7 +3285,7 @@
   if (!startPoint.Ref()->IsText()) {
     return NS_OK;
   }
-  nsresult rv = aRawRange.CollapseTo(
+  nsresult rv = aSimpleRange.CollapseTo(
       RawRangeBoundary(startPoint.Ref(), startPoint.Ref()->Length()));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;