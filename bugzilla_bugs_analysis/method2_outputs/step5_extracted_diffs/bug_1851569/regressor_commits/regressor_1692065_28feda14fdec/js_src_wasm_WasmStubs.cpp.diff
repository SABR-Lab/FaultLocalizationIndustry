# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmStubs.cpp
# Commit: 28feda14fdec
# Full Hash: 28feda14fdec962ea68c26a0570ea69042a5ad27
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 3
# Description:
#   Bug 1692065 - wasm: Add tagging for JSString* in AnyRef. r=yury
#   
#   Before this commit we would need to box a JSString* in WasmValueBox
#   when we received one from JS and converted to an AnyRef.
#   
# ==============================================================================

diff -r 85605041672d -r 28feda14fdec js/src/wasm/WasmStubs.cpp
--- a/js/src/wasm/WasmStubs.cpp	Fri Aug 04 14:06:50 2023 +0000
+++ b/js/src/wasm/WasmStubs.cpp	Fri Aug 04 14:06:50 2023 +0000
@@ -348,21 +348,6 @@
   return StackArgBytesForWasmABI(args);
 }
 
-static void Move64(MacroAssembler& masm, const Address& src,
-                   const Address& dest, Register scratch) {
-#if JS_BITS_PER_WORD == 32
-  MOZ_RELEASE_ASSERT(src.base != scratch && dest.base != scratch);
-  masm.load32(LowWord(src), scratch);
-  masm.store32(scratch, LowWord(dest));
-  masm.load32(HighWord(src), scratch);
-  masm.store32(scratch, HighWord(dest));
-#else
-  Register64 scratch64(scratch);
-  masm.load64(src, scratch64);
-  masm.store64(scratch64, dest);
-#endif
-}
-
 static void SetupABIArguments(MacroAssembler& masm, const FuncExport& fe,
                               const FuncType& funcType, Register argv,
                               Register scratch) {
@@ -435,7 +420,7 @@
             break;
           case MIRType::Int64: {
             RegisterOrSP sp = masm.getStackPointer();
-            Move64(masm, src, Address(sp, iter->offsetFromArgBase()), scratch);
+            masm.copy64(src, Address(sp, iter->offsetFromArgBase()), scratch);
             break;
           }
           case MIRType::WasmAnyRef:
@@ -611,107 +596,6 @@
   }
 }
 
-STATIC_ASSERT_ANYREF_IS_JSOBJECT;  // Strings are currently boxed
-
-// Unboxing is branchy and contorted because of Spectre mitigations - we don't
-// have enough scratch registers.  Were it not for the spectre mitigations in
-// branchTestObjClass, the branch nest below would be restructured significantly
-// by inverting branches and using fewer registers.
-
-// Unbox an anyref in src (clobbering src in the process) and then re-box it as
-// a Value in *dst.  See the definition of AnyRef for a discussion of pointer
-// representation.
-static void UnboxAnyrefIntoValue(MacroAssembler& masm, Register instance,
-                                 Register src, const Address& dst,
-                                 Register scratch) {
-  MOZ_ASSERT(src != scratch);
-
-  // Not actually the value we're passing, but we've no way of
-  // decoding anything better.
-  GenPrintPtr(DebugChannel::Import, masm, src);
-
-  Label notNull, mustUnbox, done;
-  masm.branchTestPtr(Assembler::NonZero, src, src, &notNull);
-  masm.storeValue(NullValue(), dst);
-  masm.jump(&done);
-
-  masm.bind(&notNull);
-  // The type test will clear src if the test fails, so store early.
-  masm.storeValue(JSVAL_TYPE_OBJECT, src, dst);
-  // Spectre mitigations: see comment above about efficiency.
-  masm.branchTestObjClass(Assembler::Equal, src,
-                          Address(instance, Instance::offsetOfValueBoxClass()),
-                          scratch, src, &mustUnbox);
-  masm.jump(&done);
-
-  masm.bind(&mustUnbox);
-  Move64(masm, Address(src, AnyRef::valueBoxOffsetOfValue()), dst, scratch);
-
-  masm.bind(&done);
-}
-
-// Unbox an anyref in src and then re-box it as a Value in dst.
-// See the definition of AnyRef for a discussion of pointer representation.
-static void UnboxAnyrefIntoValueReg(MacroAssembler& masm, Register instance,
-                                    Register src, ValueOperand dst,
-                                    Register scratch) {
-  MOZ_ASSERT(src != scratch);
-#if JS_BITS_PER_WORD == 32
-  MOZ_ASSERT(dst.typeReg() != scratch);
-  MOZ_ASSERT(dst.payloadReg() != scratch);
-#else
-  MOZ_ASSERT(dst.valueReg() != scratch);
-#endif
-
-  // Not actually the value we're passing, but we've no way of
-  // decoding anything better.
-  GenPrintPtr(DebugChannel::Import, masm, src);
-
-  Label notNull, mustUnbox, done;
-  masm.branchTestPtr(Assembler::NonZero, src, src, &notNull);
-  masm.moveValue(NullValue(), dst);
-  masm.jump(&done);
-
-  masm.bind(&notNull);
-  // The type test will clear src if the test fails, so store early.
-  masm.moveValue(TypedOrValueRegister(MIRType::Object, AnyRegister(src)), dst);
-  // Spectre mitigations: see comment above about efficiency.
-  masm.branchTestObjClass(Assembler::Equal, src,
-                          Address(instance, Instance::offsetOfValueBoxClass()),
-                          scratch, src, &mustUnbox);
-  masm.jump(&done);
-
-  masm.bind(&mustUnbox);
-  masm.loadValue(Address(src, AnyRef::valueBoxOffsetOfValue()), dst);
-
-  masm.bind(&done);
-}
-
-// Box the Value in src as an anyref in dest.  src and dest must not overlap.
-// See the definition of AnyRef for a discussion of pointer representation.
-static void BoxValueIntoAnyref(MacroAssembler& masm, ValueOperand src,
-                               Register dest, Label* oolConvert) {
-  Label nullValue, objectValue, done;
-  {
-    ScratchTagScope tag(masm, src);
-    masm.splitTagForTest(src, tag);
-    masm.branchTestObject(Assembler::Equal, tag, &objectValue);
-    masm.branchTestNull(Assembler::Equal, tag, &nullValue);
-    masm.jump(oolConvert);
-  }
-
-  masm.bind(&nullValue);
-  // See the definition of AnyRef for a discussion of pointer representation.
-  static_assert(wasm::NULLREF_VALUE == 0);
-  masm.xorPtr(dest, dest);
-  masm.jump(&done);
-
-  masm.bind(&objectValue);
-  masm.unboxObject(src, dest);
-
-  masm.bind(&done);
-}
-
 // Generate a stub that enters wasm from a C++ caller via the native ABI. The
 // signature of the entry point is Module::ExportFuncPtr. The exported wasm
 // function has an ABI derived from its specific signature, so this function
@@ -1191,14 +1075,7 @@
       case ValType::Ref: {
         // Guarded against by temporarilyUnsupportedReftypeForEntry()
         MOZ_RELEASE_ASSERT(funcType.args()[i].refType().isExtern());
-        ScratchTagScope tag(masm, scratchV);
-        masm.splitTagForTest(scratchV, tag);
-
-        // For object inputs, we handle object and null inline, everything
-        // else requires an actual box and we go out of line to allocate
-        // that.
-        masm.branchTestObject(Assembler::Equal, tag, &next);
-        masm.branchTestNull(Assembler::Equal, tag, &next);
+        masm.branchValueConvertsToWasmAnyRefInline(scratchV, &next);
         masm.jump(&oolCall);
         break;
       }
@@ -1276,8 +1153,18 @@
         break;
       }
       case MIRType::WasmAnyRef: {
+        ValueOperand src = ScratchValIonEntry;
         Register target = isStackArg ? ScratchIonEntry : iter->gpr();
-        masm.unboxObjectOrNull(argv, target);
+        masm.loadValue(argv, src);
+        // The loop before should ensure that all values that require boxing
+        // have been taken care of.
+        Label join;
+        Label fail;
+        masm.convertValueToWasmAnyRef(src, target, &fail);
+        masm.jump(&join);
+        masm.bind(&fail);
+        masm.breakpoint();
+        masm.bind(&join);
         GenPrintPtr(DebugChannel::Function, masm, target);
         if (isStackArg) {
           masm.storePtr(target, Address(sp, iter->offsetFromArgBase()));
@@ -1364,12 +1251,12 @@
         MOZ_CRASH("unexpected return type when calling from ion to wasm");
       }
       case ValType::Ref: {
-        STATIC_ASSERT_ANYREF_IS_JSOBJECT;
         // Per comment above, the call may have clobbered the instance
         // register, so reload since unboxing will need it.
         GenerateJitEntryLoadInstance(masm);
-        UnboxAnyrefIntoValueReg(masm, InstanceReg, ReturnReg, JSReturnOperand,
-                                WasmJitEntryReturnScratch);
+        GenPrintPtr(DebugChannel::Import, masm, ReturnReg);
+        masm.convertWasmAnyRefToValue(InstanceReg, ReturnReg, JSReturnOperand,
+                                      WasmJitEntryReturnScratch);
         break;
       }
     }
@@ -1647,10 +1534,11 @@
         GenPrintF64(DebugChannel::Function, masm, ReturnDoubleReg);
         break;
       case wasm::ValType::Ref:
+        GenPrintPtr(DebugChannel::Import, masm, ReturnReg);
         // The call to wasm above preserves the InstanceReg, we don't
         // need to reload it here.
-        UnboxAnyrefIntoValueReg(masm, InstanceReg, ReturnReg, JSReturnOperand,
-                                WasmJitEntryReturnScratch);
+        masm.convertWasmAnyRefToValue(InstanceReg, ReturnReg, JSReturnOperand,
+                                      WasmJitEntryReturnScratch);
         break;
       case wasm::ValType::V128:
         MOZ_CRASH("unexpected return type when calling from ion to wasm");
@@ -1850,7 +1738,8 @@
           // This works also for FuncRef because it is distinguishable from
           // a boxed AnyRef.
           masm.movePtr(i->gpr(), scratch2);
-          UnboxAnyrefIntoValue(masm, instance, scratch2, dst, scratch);
+          GenPrintPtr(DebugChannel::Import, masm, scratch2);
+          masm.convertWasmAnyRefToValue(instance, scratch2, dst, scratch);
         } else if (type == MIRType::StackResults) {
           MOZ_CRASH("Multi-result exit to JIT unimplemented");
         } else {
@@ -1914,7 +1803,8 @@
           // This works also for FuncRef because it is distinguishable from a
           // boxed AnyRef.
           masm.loadPtr(src, scratch);
-          UnboxAnyrefIntoValue(masm, instance, scratch, dst, scratch2);
+          GenPrintPtr(DebugChannel::Import, masm, scratch);
+          masm.convertWasmAnyRefToValue(instance, scratch, dst, scratch2);
         } else if (IsFloatingPointType(type)) {
           ScratchDoubleScope dscratch(masm);
           FloatRegister fscratch = dscratch.asSingle();
@@ -2198,7 +2088,6 @@
         GenPrintF64(DebugChannel::Import, masm, ReturnDoubleReg);
         break;
       case ValType::Ref:
-        STATIC_ASSERT_ANYREF_IS_JSOBJECT;
         masm.loadPtr(argv, ReturnReg);
         GenPrintf(DebugChannel::Import, masm, "wasm-import[%u]; returns ",
                   funcImportIndex);
@@ -2399,7 +2288,7 @@
       case ValType::Ref:
         // Guarded by temporarilyUnsupportedReftypeForExit()
         MOZ_RELEASE_ASSERT(results[0].refType().isExtern());
-        BoxValueIntoAnyref(masm, JSReturnOperand, ReturnReg, &oolConvert);
+        masm.convertValueToWasmAnyRef(JSReturnOperand, ReturnReg, &oolConvert);
         GenPrintPtr(DebugChannel::Import, masm, ReturnReg);
         break;
     }
@@ -2498,7 +2387,7 @@
           // Guarded by temporarilyUnsupportedReftypeForExit()
           MOZ_RELEASE_ASSERT(results[0].refType().isExtern());
           masm.call(SymbolicAddress::BoxValue_Anyref);
-          masm.branchTestPtr(Assembler::Zero, ReturnReg, ReturnReg, throwLabel);
+          masm.branchWasmAnyRefIsNull(true, ReturnReg, throwLabel);
           break;
         default:
           MOZ_CRASH("Unsupported convert type");
