# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/StoreBuffer.h
# Commit: 662cb63c42d7
# Full Hash: 662cb63c42d7874a79256a6edf1a03d83e43a014
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 2
# Description:
#   Bug 1692065 - wasm: Create a unique wasm::AnyRef type. r=yury,jonco
#   
#   Right now wasm references area represented as a JSObject*. This is assumed in
#   many places in SpiderMonkey, most prominently in our GC integration
#   around tracing, the store buffer, and write barriers. This will cause issues
# ==============================================================================

diff -r 8b506ab41451 -r 662cb63c42d7 js/src/gc/StoreBuffer.h
--- a/js/src/gc/StoreBuffer.h	Fri Aug 04 13:54:57 2023 +0000
+++ b/js/src/gc/StoreBuffer.h	Fri Aug 04 14:06:49 2023 +0000
@@ -21,6 +21,7 @@
 #include "js/AllocPolicy.h"
 #include "js/UniquePtr.h"
 #include "threading/Mutex.h"
+#include "wasm/WasmAnyRef.h"
 
 namespace JS {
 struct GCSizes;
@@ -398,6 +399,36 @@
     };
   };
 
+  struct WasmAnyRefEdge {
+    wasm::AnyRef* edge;
+
+    WasmAnyRefEdge() : edge(nullptr) {}
+    explicit WasmAnyRefEdge(wasm::AnyRef* v) : edge(v) {}
+    bool operator==(const WasmAnyRefEdge& other) const {
+      return edge == other.edge;
+    }
+    bool operator!=(const WasmAnyRefEdge& other) const {
+      return edge != other.edge;
+    }
+
+    Cell* deref() const {
+      return edge->isGCThing() ? static_cast<Cell*>(edge->toGCThing())
+                               : nullptr;
+      return nullptr;
+    }
+
+    bool maybeInRememberedSet(const Nursery& nursery) const {
+      MOZ_ASSERT(IsInsideNursery(deref()));
+      return !nursery.isInside(edge);
+    }
+
+    void trace(TenuringTracer& mover) const;
+
+    explicit operator bool() const { return edge != nullptr; }
+
+    using Hasher = PointerEdgeHasher<WasmAnyRefEdge>;
+  };
+
 #ifdef DEBUG
   void checkAccess() const;
 #else
@@ -433,6 +464,7 @@
   MonoTypeBuffer<BigIntPtrEdge> bufBigIntCell;
   MonoTypeBuffer<ObjectPtrEdge> bufObjCell;
   MonoTypeBuffer<SlotsEdge> bufferSlot;
+  MonoTypeBuffer<WasmAnyRefEdge> bufferWasmAnyRef;
   WholeCellBuffer bufferWholeCell;
   GenericBuffer bufferGeneric;
 
@@ -495,6 +527,13 @@
     }
   }
 
+  void putWasmAnyRef(wasm::AnyRef* vp) {
+    put(bufferWasmAnyRef, WasmAnyRefEdge(vp));
+  }
+  void unputWasmAnyRef(wasm::AnyRef* vp) {
+    unput(bufferWasmAnyRef, WasmAnyRefEdge(vp));
+  }
+
   inline void putWholeCell(Cell* cell);
   inline void putWholeCellDontCheckLast(Cell* cell);
   const void* addressOfLastBufferedWholeCell() {
@@ -517,6 +556,9 @@
     bufObjCell.trace(mover);
   }
   void traceSlots(TenuringTracer& mover) { bufferSlot.trace(mover); }
+  void traceWasmAnyRefs(TenuringTracer& mover) {
+    bufferWasmAnyRef.trace(mover);
+  }
   void traceWholeCells(TenuringTracer& mover) { bufferWholeCell.trace(mover); }
   void traceGenericEntries(JSTracer* trc) { bufferGeneric.trace(trc); }
 