# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Tenuring.cpp
# Commit: 662cb63c42d7
# Full Hash: 662cb63c42d7874a79256a6edf1a03d83e43a014
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 2
# Description:
#   Bug 1692065 - wasm: Create a unique wasm::AnyRef type. r=yury,jonco
#   
#   Right now wasm references area represented as a JSObject*. This is assumed in
#   many places in SpiderMonkey, most prominently in our GC integration
#   around tracing, the store buffer, and write barriers. This will cause issues
# ==============================================================================

diff -r 8b506ab41451 -r 662cb63c42d7 js/src/gc/Tenuring.cpp
--- a/js/src/gc/Tenuring.cpp	Fri Aug 04 13:54:57 2023 +0000
+++ b/js/src/gc/Tenuring.cpp	Fri Aug 04 14:06:49 2023 +0000
@@ -169,6 +169,31 @@
   }
 }
 
+void TenuringTracer::traverse(wasm::AnyRef* thingp) {
+  MOZ_ASSERT(!nursery().isInside(thingp));
+
+  wasm::AnyRef value = *thingp;
+  CheckTracedThing(this, value);
+
+  wasm::AnyRef post = wasm::AnyRef::invalid();
+  switch (value.kind()) {
+    case wasm::AnyRefKind::Object: {
+      JSObject* obj = &value.toJSObject();
+      onObjectEdge(&obj, "value");
+      post = wasm::AnyRef::fromJSObject(*obj);
+      break;
+    }
+    case wasm::AnyRefKind::Null: {
+      // This function must only be called for GC things.
+      MOZ_CRASH();
+    }
+  }
+
+  if (post != value) {
+    *thingp = post;
+  }
+}
+
 template <typename T>
 void js::gc::StoreBuffer::MonoTypeBuffer<T>::trace(TenuringTracer& mover) {
   mozilla::ReentrancyGuard g(*owner_);
@@ -186,6 +211,8 @@
     TenuringTracer&);
 template void StoreBuffer::MonoTypeBuffer<StoreBuffer::SlotsEdge>::trace(
     TenuringTracer&);
+template void StoreBuffer::MonoTypeBuffer<StoreBuffer::WasmAnyRefEdge>::trace(
+    TenuringTracer&);
 template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::StringPtrEdge>;
 template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::BigIntPtrEdge>;
 template struct StoreBuffer::MonoTypeBuffer<StoreBuffer::ObjectPtrEdge>;
@@ -412,6 +439,12 @@
   }
 }
 
+void js::gc::StoreBuffer::WasmAnyRefEdge::trace(TenuringTracer& mover) const {
+  if (deref()) {
+    mover.traverse(edge);
+  }
+}
+
 // Visit all object children of the object and trace them.
 void js::gc::TenuringTracer::traceObject(JSObject* obj) {
   const JSClass* clasp = obj->getClass();