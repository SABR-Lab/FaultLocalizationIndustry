# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmAnyRef.cpp
# Commit: 662cb63c42d7
# Full Hash: 662cb63c42d7874a79256a6edf1a03d83e43a014
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 2
# Description:
#   Bug 1692065 - wasm: Create a unique wasm::AnyRef type. r=yury,jonco
#   
#   Right now wasm references area represented as a JSObject*. This is assumed in
#   many places in SpiderMonkey, most prominently in our GC integration
#   around tracing, the store buffer, and write barriers. This will cause issues
# ==============================================================================

diff -r 8b506ab41451 -r 662cb63c42d7 js/src/wasm/WasmAnyRef.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/js/src/wasm/WasmAnyRef.cpp	Fri Aug 04 14:06:49 2023 +0000
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=8 sts=2 et sw=2 tw=80:
+ *
+ * Copyright 2023 Mozilla Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wasm/WasmAnyRef.h"
+
+#include "vm/JSContext.h"
+#include "vm/JSObject.h"
+#include "vm/NativeObject.h"
+
+#include "vm/JSObject-inl.h"
+
+using namespace js;
+using namespace js::wasm;
+
+class WasmValueBox : public NativeObject {
+ public:
+  static const unsigned VALUE_SLOT = 0;
+  static const unsigned RESERVED_SLOTS = 1;
+  static const JSClass class_;
+
+  static WasmValueBox* create(JSContext* cx, HandleValue value);
+  Value value() const { return getFixedSlot(VALUE_SLOT); }
+};
+
+const JSClass WasmValueBox::class_ = {
+    "WasmValueBox", JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS)};
+
+WasmValueBox* WasmValueBox::create(JSContext* cx, HandleValue value) {
+  WasmValueBox* obj = NewObjectWithGivenProto<WasmValueBox>(cx, nullptr);
+  if (!obj) {
+    return nullptr;
+  }
+  obj->setFixedSlot(VALUE_SLOT, value);
+  return obj;
+}
+
+const JSClass* AnyRef::valueBoxClass() { return &WasmValueBox::class_; }
+
+size_t AnyRef::valueBoxOffsetOfValue() {
+  return NativeObject::getFixedSlotOffset(WasmValueBox::VALUE_SLOT);
+}
+
+bool AnyRef::fromJSValue(JSContext* cx, HandleValue value,
+                         MutableHandleAnyRef result) {
+  if (value.isNull()) {
+    result.set(AnyRef::null());
+    return true;
+  }
+
+  if (value.isObject()) {
+    JSObject& obj = value.toObject();
+    MOZ_ASSERT(!obj.is<WasmValueBox>());
+    MOZ_ASSERT(obj.compartment() == cx->compartment());
+    result.set(AnyRef::fromJSObject(obj));
+    return true;
+  }
+
+  JSObject* box = AnyRef::boxValue(cx, value);
+  if (!box) {
+    return false;
+  }
+  result.set(AnyRef::fromJSObject(*box));
+  return true;
+}
+
+JSObject* AnyRef::boxValue(JSContext* cx, HandleValue value) {
+  MOZ_ASSERT(AnyRef::valueNeedsBoxing(value));
+  return WasmValueBox::create(cx, value);
+}
+
+Value wasm::AnyRef::toJSValue() const {
+  // If toJSValue needs to allocate then we need a more complicated API, and
+  // we need to root the value in the callers, see comments in callExport().
+  Value value;
+  if (isNull()) {
+    value.setNull();
+  } else {
+    JSObject& obj = toJSObject();
+    if (obj.is<WasmValueBox>()) {
+      value = obj.as<WasmValueBox>().value();
+    } else {
+      value.setObject(obj);
+    }
+  }
+  return value;
+}