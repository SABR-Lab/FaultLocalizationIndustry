# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmTable.cpp
# Commit: 662cb63c42d7
# Full Hash: 662cb63c42d7874a79256a6edf1a03d83e43a014
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 2
# Description:
#   Bug 1692065 - wasm: Create a unique wasm::AnyRef type. r=yury,jonco
#   
#   Right now wasm references area represented as a JSObject*. This is assumed in
#   many places in SpiderMonkey, most prominently in our GC integration
#   around tracing, the store buffer, and write barriers. This will cause issues
# ==============================================================================

diff -r 8b506ab41451 -r 662cb63c42d7 js/src/wasm/WasmTable.cpp
--- a/js/src/wasm/WasmTable.cpp	Fri Aug 04 13:54:57 2023 +0000
+++ b/js/src/wasm/WasmTable.cpp	Fri Aug 04 14:06:49 2023 +0000
@@ -221,19 +221,13 @@
 
 AnyRef Table::getAnyRef(uint32_t index) const {
   MOZ_ASSERT(!isFunction());
-  // TODO/AnyRef-boxing: With boxed immediates and strings, the write barrier
-  // is going to have to be more complicated.
-  ASSERT_ANYREF_IS_JSOBJECT;
-  return AnyRef::fromJSObject(objects_[index]);
+  return objects_[index];
 }
 
 void Table::fillAnyRef(uint32_t index, uint32_t fillCount, AnyRef ref) {
   MOZ_ASSERT(!isFunction());
-  // TODO/AnyRef-boxing: With boxed immediates and strings, the write barrier
-  // is going to have to be more complicated.
-  ASSERT_ANYREF_IS_JSOBJECT;
   for (uint32_t i = index, end = index + fillCount; i != end; i++) {
-    objects_[i] = ref.asJSObject();
+    objects_[i] = ref;
   }
 }
 
@@ -321,7 +315,7 @@
             // OOM, so just pass it on.
             return false;
           }
-          fillAnyRef(dstIndex, 1, AnyRef::fromJSObject(fun));
+          fillAnyRef(dstIndex, 1, AnyRef::fromJSObject(*fun));
           break;
         }
       }