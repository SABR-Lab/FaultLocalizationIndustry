# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmValue.cpp
# Commit: 662cb63c42d7
# Full Hash: 662cb63c42d7874a79256a6edf1a03d83e43a014
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 2
# Description:
#   Bug 1692065 - wasm: Create a unique wasm::AnyRef type. r=yury,jonco
#   
#   Right now wasm references area represented as a JSObject*. This is assumed in
#   many places in SpiderMonkey, most prominently in our GC integration
#   around tracing, the store buffer, and write barriers. This will cause issues
# ==============================================================================

diff -r 8b506ab41451 -r 662cb63c42d7 js/src/wasm/WasmValue.cpp
--- a/js/src/wasm/WasmValue.cpp	Fri Aug 04 13:54:57 2023 +0000
+++ b/js/src/wasm/WasmValue.cpp	Fri Aug 04 14:06:49 2023 +0000
@@ -63,11 +63,6 @@
   MOZ_CRASH();
 }
 
-void Val::readFromRootedLocation(const void* loc) {
-  memset(&cell_, 0, sizeof(Cell));
-  memcpy(&cell_, loc, type_.size());
-}
-
 void Val::initFromRootedLocation(ValType type, const void* loc) {
   MOZ_ASSERT(!type_.isValid());
   type_ = type;
@@ -94,10 +89,8 @@
 }
 
 void Val::writeToHeapLocation(void* loc) const {
-  if (type_.isRefRepr()) {
-    // TODO/AnyRef-boxing: With boxed immediates and strings, the write
-    // barrier is going to have to be more complicated.
-    *((GCPtr<JSObject*>*)loc) = cell_.ref_.asJSObject();
+  if (isAnyRef()) {
+    *((GCPtr<AnyRef>*)loc) = toAnyRef();
     return;
   }
   memcpy(loc, &cell_, type_.size());
@@ -116,11 +109,8 @@
 }
 
 void Val::trace(JSTracer* trc) const {
-  if (isJSObject()) {
-    // TODO/AnyRef-boxing: With boxed immediates and strings, the write
-    // barrier is going to have to be more complicated.
-    ASSERT_ANYREF_IS_JSOBJECT;
-    TraceManuallyBarrieredEdge(trc, asJSObjectAddress(), "wasm val");
+  if (isAnyRef()) {
+    TraceManuallyBarrieredEdge(trc, &toAnyRef(), "anyref");
   }
 }
 
@@ -137,7 +127,7 @@
     case RefType::Func:
       return CheckFuncRefValue(cx, v, fnval);
     case RefType::Extern:
-      return BoxAnyRef(cx, v, refval);
+      return AnyRef::fromJSValue(cx, v, refval);
     case RefType::Any:
       return CheckAnyRefValue(cx, v, refval);
     case RefType::NoFunc:
@@ -195,7 +185,7 @@
   if (v.isObject()) {
     JSObject& obj = v.toObject();
     if (obj.is<WasmGcObject>()) {
-      vp.set(AnyRef::fromJSObject(&obj.as<WasmGcObject>()));
+      vp.set(AnyRef::fromJSObject(obj.as<WasmGcObject>()));
       return true;
     }
   }
@@ -250,7 +240,7 @@
   if (v.isObject()) {
     JSObject& obj = v.toObject();
     if (obj.is<WasmGcObject>()) {
-      vp.set(AnyRef::fromJSObject(&obj.as<WasmGcObject>()));
+      vp.set(AnyRef::fromJSObject(obj.as<WasmGcObject>()));
       return true;
     }
   }
@@ -270,7 +260,7 @@
   if (v.isObject()) {
     JSObject& obj = v.toObject();
     if (obj.is<WasmStructObject>()) {
-      vp.set(AnyRef::fromJSObject(&obj.as<WasmStructObject>()));
+      vp.set(AnyRef::fromJSObject(obj.as<WasmStructObject>()));
       return true;
     }
   }
@@ -290,7 +280,7 @@
   if (v.isObject()) {
     JSObject& obj = v.toObject();
     if (obj.is<WasmArrayObject>()) {
-      vp.set(AnyRef::fromJSObject(&obj.as<WasmArrayObject>()));
+      vp.set(AnyRef::fromJSObject(obj.as<WasmArrayObject>()));
       return true;
     }
   }
@@ -311,13 +301,13 @@
     JSObject& obj = v.toObject();
     if (obj.is<WasmGcObject>() &&
         obj.as<WasmGcObject>().isRuntimeSubtypeOf(typeDef)) {
-      vp.set(AnyRef::fromJSObject(&obj.as<WasmGcObject>()));
+      vp.set(AnyRef::fromJSObject(obj.as<WasmGcObject>()));
       return true;
     }
     if (obj.is<JSFunction>() && obj.as<JSFunction>().isWasm()) {
       JSFunction& funcObj = obj.as<JSFunction>();
       if (TypeDef::isSubTypeOf(funcObj.wasmTypeDef(), typeDef)) {
-        vp.set(AnyRef::fromJSObject(&funcObj));
+        vp.set(AnyRef::fromJSObject(funcObj));
         return true;
       }
     }
@@ -442,7 +432,7 @@
 bool ToWebAssemblyValue_externref(JSContext* cx, HandleValue val, void** loc,
                                   bool mustWrite64) {
   RootedAnyRef result(cx, AnyRef::null());
-  if (!BoxAnyRef(cx, val, &result)) {
+  if (!AnyRef::fromJSValue(cx, val, &result)) {
     return false;
   }
   loc[0] = result.get().forCompiledCode();
@@ -752,14 +742,14 @@
 
 template <typename Debug = NoDebug>
 bool ToJSValue_externref(JSContext* cx, void* src, MutableHandleValue dst) {
-  dst.set(UnboxAnyRef(AnyRef::fromCompiledCode(src)));
+  dst.set(AnyRef::fromCompiledCode(src).toJSValue());
   Debug::print(src);
   return true;
 }
 
 template <typename Debug = NoDebug>
 bool ToJSValue_anyref(JSContext* cx, void* src, MutableHandleValue dst) {
-  dst.set(UnboxAnyRef(AnyRef::fromCompiledCode(src)));
+  dst.set(AnyRef::fromCompiledCode(src).toJSValue());
   Debug::print(src);
   return true;
 }
@@ -832,79 +822,10 @@
   return wasm::ToJSValue(cx, src, FieldType(type.packed()), dst, level);
 }
 
-void AnyRef::trace(JSTracer* trc) {
-  if (value_) {
-    TraceManuallyBarrieredEdge(trc, &value_, "wasm anyref referent");
-  }
-}
-
-const JSClass WasmValueBox::class_ = {
-    "WasmValueBox", JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS)};
-
-WasmValueBox* WasmValueBox::create(JSContext* cx, HandleValue val) {
-  WasmValueBox* obj = NewObjectWithGivenProto<WasmValueBox>(cx, nullptr);
-  if (!obj) {
-    return nullptr;
-  }
-  obj->setFixedSlot(VALUE_SLOT, val);
-  return obj;
-}
-
-bool wasm::BoxAnyRef(JSContext* cx, HandleValue val,
-                     MutableHandleAnyRef result) {
-  if (val.isNull()) {
-    result.set(AnyRef::null());
-    return true;
-  }
-
-  if (val.isObject()) {
-    JSObject* obj = &val.toObject();
-    MOZ_ASSERT(!obj->is<WasmValueBox>());
-    MOZ_ASSERT(obj->compartment() == cx->compartment());
-    result.set(AnyRef::fromJSObject(obj));
-    return true;
-  }
-
-  WasmValueBox* box = WasmValueBox::create(cx, val);
-  if (!box) return false;
-  result.set(AnyRef::fromJSObject(box));
-  return true;
-}
-
-JSObject* wasm::BoxBoxableValue(JSContext* cx, HandleValue val) {
-  MOZ_ASSERT(!val.isNull() && !val.isObject());
-  return WasmValueBox::create(cx, val);
-}
-
-Value wasm::UnboxAnyRef(AnyRef val) {
-  // If UnboxAnyRef needs to allocate then we need a more complicated API, and
-  // we need to root the value in the callers, see comments in callExport().
-  JSObject* obj = val.asJSObject();
-  Value result;
-  if (obj == nullptr) {
-    result.setNull();
-  } else if (obj->is<WasmValueBox>()) {
-    result = obj->as<WasmValueBox>().value();
-  } else {
-    result.setObjectOrNull(obj);
-  }
-  return result;
-}
-
 /* static */
 wasm::FuncRef wasm::FuncRef::fromAnyRefUnchecked(AnyRef p) {
-#ifdef DEBUG
-  Value v = UnboxAnyRef(p);
-  if (v.isNull()) {
-    return FuncRef(nullptr);
-  }
-  if (v.toObject().is<JSFunction>()) {
-    return FuncRef(&v.toObject().as<JSFunction>());
-  }
-  MOZ_CRASH("Bad value");
-#else
-  return FuncRef(&p.asJSObject()->as<JSFunction>());
-#endif
+  MOZ_ASSERT(p.isJSObject() && p.toJSObject().is<JSFunction>());
+  return FuncRef(&p.toJSObject().as<JSFunction>());
 }
 
 void wasm::FuncRef::trace(JSTracer* trc) const {