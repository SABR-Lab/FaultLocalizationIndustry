# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit-test/tests/wasm/gc/js-boundary.js
# Commit: 72bf9c871ded
# Full Hash: 72bf9c871ded006f56f09b24d0723365516445bb
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 5
# Description:
#   Bug 1692065 - wasm: Add tagging for 31-bit integers and i31ref. r=yury
#   
#   This commit adds a tag 0x1 for 31-bit integers in AnyRef. Any JS value
#   that is losslessly representable (without coercion) in this range is
#   stored without boxing. This is chosen to line up exactly with how the
# ==============================================================================

diff -r 28feda14fdec -r 72bf9c871ded js/src/jit-test/tests/wasm/gc/js-boundary.js
--- a/js/src/jit-test/tests/wasm/gc/js-boundary.js	Fri Aug 04 14:06:50 2023 +0000
+++ b/js/src/jit-test/tests/wasm/gc/js-boundary.js	Fri Aug 04 14:06:50 2023 +0000
@@ -1,7 +1,7 @@
 // |jit-test| skip-if: !wasmGcEnabled()
 
 // Tests of dynamic type checks
-test('anyref', WasmAnyrefValues, WasmNonAnyrefValues);
+test('anyref', WasmAnyrefValues, []);
 test('eqref', WasmEqrefValues, WasmNonAnyrefValues);
 test('structref', WasmStructrefValues, WasmNonAnyrefValues);
 test('arrayref', WasmArrayrefValues, WasmNonAnyrefValues);
@@ -100,26 +100,24 @@
       TypeError,
       CheckError);
   }
-
-  // 5. Verify that GC objects are opaque
-  for (const val of validValues) {
-    if (!val) continue;
+}
 
-    assertEq(Reflect.getPrototypeOf(val), null);
-    assertEq(Reflect.setPrototypeOf(val, null), true);
-    assertEq(Reflect.setPrototypeOf(val, {}), false);
-    assertEq(Reflect.isExtensible(val), false);
-    assertEq(Reflect.preventExtensions(val), false);
-    assertEq(Reflect.getOwnPropertyDescriptor(val, "anything"), undefined);
-    assertEq(Reflect.defineProperty(val, "anything", { value: 42 }), false);
-    assertEq(Reflect.has(val, "anything"), false);
-    assertEq(Reflect.get(val, "anything"), undefined);
-    assertErrorMessage(() => { Reflect.set(val, "anything", 3); }, TypeError, /can't modify/);
-    assertErrorMessage(() => { Reflect.deleteProperty(val, "anything"); }, TypeError, /can't modify/);
-    assertEq(Reflect.ownKeys(val).length, 0, `gc objects should not have keys, but this one had: ${Reflect.ownKeys(val)}`);
-    for (const i in val) {
-      throw new Error(`GC objects should have no enumerable properties, but had ${i}`);
-    }
-    assertEq(val[Symbol.iterator], undefined, "GC objects should not be iterable");
+// Verify that GC objects are opaque
+for (const val of WasmGcObjectValues) {
+  assertEq(Reflect.getPrototypeOf(val), null);
+  assertEq(Reflect.setPrototypeOf(val, null), true);
+  assertEq(Reflect.setPrototypeOf(val, {}), false);
+  assertEq(Reflect.isExtensible(val), false);
+  assertEq(Reflect.preventExtensions(val), false);
+  assertEq(Reflect.getOwnPropertyDescriptor(val, "anything"), undefined);
+  assertEq(Reflect.defineProperty(val, "anything", { value: 42 }), false);
+  assertEq(Reflect.has(val, "anything"), false);
+  assertEq(Reflect.get(val, "anything"), undefined);
+  assertErrorMessage(() => { Reflect.set(val, "anything", 3); }, TypeError, /can't modify/);
+  assertErrorMessage(() => { Reflect.deleteProperty(val, "anything"); }, TypeError, /can't modify/);
+  assertEq(Reflect.ownKeys(val).length, 0, `gc objects should not have keys, but this one had: ${Reflect.ownKeys(val)}`);
+  for (const i in val) {
+    throw new Error(`GC objects should have no enumerable properties, but had ${i}`);
   }
+  assertEq(val[Symbol.iterator], undefined, "GC objects should not be iterable");
 }