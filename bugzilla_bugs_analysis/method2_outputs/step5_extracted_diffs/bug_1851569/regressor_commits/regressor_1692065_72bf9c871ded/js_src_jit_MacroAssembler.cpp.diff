# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/MacroAssembler.cpp
# Commit: 72bf9c871ded
# Full Hash: 72bf9c871ded006f56f09b24d0723365516445bb
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 5
# Description:
#   Bug 1692065 - wasm: Add tagging for 31-bit integers and i31ref. r=yury
#   
#   This commit adds a tag 0x1 for 31-bit integers in AnyRef. Any JS value
#   that is losslessly representable (without coercion) in this range is
#   stored without boxing. This is chosen to line up exactly with how the
# ==============================================================================

diff -r 28feda14fdec -r 72bf9c871ded js/src/jit/MacroAssembler.cpp
--- a/js/src/jit/MacroAssembler.cpp	Fri Aug 04 14:06:50 2023 +0000
+++ b/js/src/jit/MacroAssembler.cpp	Fri Aug 04 14:06:50 2023 +0000
@@ -5538,6 +5538,13 @@
     return;
   }
 
+  if (destType.isI31()) {
+    branchWasmAnyRefIsI31(true, ref, successLabel);
+    jump(failLabel);
+    bind(&fallthrough);
+    return;
+  }
+
   // 'type' is now 'eq' or lower, which currently will always be a gc object.
   // Test for non-gc objects.
   MOZ_ASSERT(scratch1 != Register::Invalid());
@@ -5752,6 +5759,12 @@
   branchTestPtr(isNull ? Assembler::Zero : Assembler::NonZero, src, src, label);
 }
 
+void MacroAssembler::branchWasmAnyRefIsI31(bool isI31, Register src,
+                                           Label* label) {
+  branchTestPtr(isI31 ? Assembler::NonZero : Assembler::Zero, src,
+                Imm32(int32_t(wasm::AnyRefTag::I31)), label);
+}
+
 void MacroAssembler::branchWasmAnyRefIsObjectOrNull(bool isObject, Register src,
                                                     Label* label) {
   branchTestPtr(isObject ? Assembler::Zero : Assembler::NonZero, src,
@@ -5760,46 +5773,138 @@
 
 void MacroAssembler::branchWasmAnyRefIsGCThing(bool isGCThing, Register src,
                                                Label* label) {
-  // The only non-GC thing in anyref currently is 'null'.
-  branchWasmAnyRefIsNull(!isGCThing, src, label);
-}
-
-void MacroAssembler::branchWasmAnyRefIsNurseryCell(Condition cond, Register src,
+  Label fallthrough;
+  Label* isGCThingLabel = isGCThing ? label : &fallthrough;
+  Label* isNotGCThingLabel = isGCThing ? &fallthrough : label;
+
+  // A null value or i31 value are not GC things.
+  branchWasmAnyRefIsNull(true, src, isNotGCThingLabel);
+  branchWasmAnyRefIsI31(true, src, isNotGCThingLabel);
+  jump(isGCThingLabel);
+  bind(&fallthrough);
+}
+
+void MacroAssembler::branchWasmAnyRefIsNurseryCell(bool isNurseryCell, Register src,
                                                    Register temp,
                                                    Label* label) {
-  MOZ_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
-
   Label done;
   branchWasmAnyRefIsGCThing(false, src,
-                            cond == Assembler::Equal ? &done : label);
+                            isNurseryCell ? &done : label);
 
   getWasmAnyRefGCThingChunk(src, temp);
-  branchPtr(InvertCondition(cond), Address(temp, gc::ChunkStoreBufferOffset),
+  branchPtr(isNurseryCell ? Assembler::NotEqual : Assembler::Equal,
+            Address(temp, gc::ChunkStoreBufferOffset),
             ImmWord(0), label);
   bind(&done);
 }
 
+void MacroAssembler::truncate32ToWasmI31Ref(Register src, Register dest) {
+  // This will either zero-extend or sign-extend the high 32-bits on 64-bit
+  // platforms (see comments on invariants in MacroAssembler.h). Either case
+  // is fine, as we won't use this bits.
+  move32(src, dest);
+  // Move the payload of the integer over by 1 to make room for the tag. This
+  // will perform the truncation required by the spec.
+  lshift32(Imm32(1), dest);
+  // Add the i31 tag to the integer.
+  orPtr(Imm32(int32_t(wasm::AnyRefTag::I31)), dest);
+}
+
+void MacroAssembler::convertWasmI31RefTo32Signed(Register src, Register dest) {
+  // This will either zero-extend or sign-extend the high 32-bits on 64-bit
+  // platforms (see comments on invariants in MacroAssembler.h). Either case
+  // is fine, as we won't use this bits.
+  move32(src, dest);
+  // Shift the payload back (clobbering the tag). This will sign-extend, giving
+  // us the unsigned behavior we want.
+  rshift32Arithmetic(Imm32(1), dest);
+}
+
+void MacroAssembler::convertWasmI31RefTo32Unsigned(Register src,
+                                                   Register dest) {
+  // This will either zero-extend or sign-extend the high 32-bits on 64-bit
+  // platforms (see comments on invariants in MacroAssembler.h). Either case
+  // is fine, as we won't use this bits.
+  move32(src, dest);
+  // Shift the payload back (clobbering the tag). This will zero-extend, giving
+  // us the unsigned behavior we want.
+  rshift32(Imm32(1), dest);
+}
+
 void MacroAssembler::branchValueConvertsToWasmAnyRefInline(
-    ValueOperand src, Label* label) {
+    ValueOperand src, Register scratchInt, FloatRegister scratchFloat, Label* label) {
+  // We can convert objects, strings, 31-bit integers and null without boxing.
+  Label checkInt32;
+  Label checkDouble;
+  Label fallthrough;
   ScratchTagScope tag(*this, src);
   splitTagForTest(src, tag);
   branchTestObject(Assembler::Equal, tag, label);
   branchTestString(Assembler::Equal, tag, label);
   branchTestNull(Assembler::Equal, tag, label);
+  branchTestInt32(Assembler::Equal, tag, &checkInt32);
+  branchTestDouble(Assembler::Equal, tag, &checkDouble);
+  jump(&fallthrough);
+
+  bind(&checkInt32);
+  unboxInt32(src, scratchInt);
+  branch32(Assembler::GreaterThan, scratchInt, Imm32(wasm::AnyRef::MaxI31Value),
+           &fallthrough);
+  branch32(Assembler::LessThan, scratchInt, Imm32(wasm::AnyRef::MinI31Value),
+           &fallthrough);
+  jump(label);
+
+  bind(&checkDouble);
+  {
+    ScratchTagScopeRelease _(&tag);
+    convertValueToInt32(src, scratchFloat, scratchInt, &fallthrough, true,
+                        IntConversionInputKind::NumbersOnly);
+  }
+  branch32(Assembler::GreaterThan, scratchInt, Imm32(wasm::AnyRef::MaxI31Value),
+           &fallthrough);
+  branch32(Assembler::LessThan, scratchInt, Imm32(wasm::AnyRef::MinI31Value),
+           &fallthrough);
+  jump(label);
+
+  bind(&fallthrough);
 }
 
 void MacroAssembler::convertValueToWasmAnyRef(ValueOperand src, Register dest,
+                                              FloatRegister scratchFloat,
                                               Label* oolConvert) {
-  Label nullValue, stringValue, objectValue, done;
+  Label doubleValue, int32Value, nullValue, stringValue, objectValue, done;
   {
     ScratchTagScope tag(*this, src);
     splitTagForTest(src, tag);
     branchTestObject(Assembler::Equal, tag, &objectValue);
     branchTestString(Assembler::Equal, tag, &stringValue);
     branchTestNull(Assembler::Equal, tag, &nullValue);
+    branchTestInt32(Assembler::Equal, tag, &int32Value);
+    branchTestDouble(Assembler::Equal, tag, &doubleValue);
     jump(oolConvert);
   }
 
+  bind(&doubleValue);
+  convertValueToInt32(src, scratchFloat, dest, oolConvert, true,
+                      IntConversionInputKind::NumbersOnly);
+  branch32(Assembler::GreaterThan, dest, Imm32(wasm::AnyRef::MaxI31Value),
+           oolConvert);
+  branch32(Assembler::LessThan, dest, Imm32(wasm::AnyRef::MinI31Value),
+           oolConvert);
+  lshiftPtr(Imm32(1), dest);
+  orPtr(Imm32((int32_t)wasm::AnyRefTag::I31), dest);
+  jump(&done);
+
+  bind(&int32Value);
+  unboxInt32(src, dest);
+  branch32(Assembler::GreaterThan, dest, Imm32(wasm::AnyRef::MaxI31Value),
+           oolConvert);
+  branch32(Assembler::LessThan, dest, Imm32(wasm::AnyRef::MinI31Value),
+           oolConvert);
+  lshiftPtr(Imm32(1), dest);
+  orPtr(Imm32((int32_t)wasm::AnyRefTag::I31), dest);
+  jump(&done);
+
   bind(&nullValue);
   static_assert(wasm::AnyRef::NullRefValue == 0);
   xorPtr(dest, dest);
@@ -5861,17 +5966,26 @@
   MOZ_ASSERT(dst.valueReg() != scratch);
 #endif
 
-  Label isObjectOrNull, isObject, isWasmValueBox, done;
-
-  // Check for the object or null tag first
+  Label isI31, isObjectOrNull, isObject, isWasmValueBox, done;
+
+  // Check for if this is an i31 value first
+  branchTest32(Assembler::NonZero, src, Imm32(int32_t(wasm::AnyRefTag::I31)),
+               &isI31);
+  // Then check for the object or null tag
   branchTest32(Assembler::Zero, src, Imm32(wasm::AnyRef::TagMask), &isObjectOrNull);
 
-  // If we're not object or null, we must be a string
+  // If we're not i31, object, or null, we must be a string
   rshiftPtr(Imm32(wasm::AnyRef::TagShift), src);
   lshiftPtr(Imm32(wasm::AnyRef::TagShift), src);
   moveValue(TypedOrValueRegister(MIRType::String, AnyRegister(src)), dst);
   jump(&done);
 
+  // This is an i31 value, convert to an int32 JS value
+  bind(&isI31);
+  rshift32Arithmetic(Imm32(1), src);
+  moveValue(TypedOrValueRegister(MIRType::Int32, AnyRegister(src)), dst);
+  jump(&done);
+
   // Check for the null value
   bind(&isObjectOrNull);
   branchTestPtr(Assembler::NonZero, src, src, &isObject);
@@ -5901,17 +6015,26 @@
                                               Register scratch) {
   MOZ_ASSERT(src != scratch);
 
-  Label isObjectOrNull, isObject, isWasmValueBox, done;
-
-  // Check for the object or null tag first
+  Label isI31, isObjectOrNull, isObject, isWasmValueBox, done;
+
+  // Check for if this is an i31 value first
+  branchTest32(Assembler::NonZero, src, Imm32(int32_t(wasm::AnyRefTag::I31)),
+               &isI31);
+  // Then check for the object or null tag
   branchTest32(Assembler::Zero, src, Imm32(wasm::AnyRef::TagMask), &isObjectOrNull);
 
-  // If we're not object or null, we must be a string
+  // If we're not i31, object, or null, we must be a string
   rshiftPtr(Imm32(wasm::AnyRef::TagShift), src);
   lshiftPtr(Imm32(wasm::AnyRef::TagShift), src);
   storeValue(JSVAL_TYPE_STRING, src, dst);
   jump(&done);
 
+  // This is an i31 value, convert to an int32 JS value
+  bind(&isI31);
+  rshift32Arithmetic(Imm32(1), src);
+  storeValue(JSVAL_TYPE_INT32, src, dst);
+  jump(&done);
+
   // Check for the null value
   bind(&isObjectOrNull);
   branchTestPtr(Assembler::NonZero, src, src, &isObject);