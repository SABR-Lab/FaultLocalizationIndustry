# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmBaselineCompile.cpp
# Commit: 72bf9c871ded
# Full Hash: 72bf9c871ded006f56f09b24d0723365516445bb
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 5
# Description:
#   Bug 1692065 - wasm: Add tagging for 31-bit integers and i31ref. r=yury
#   
#   This commit adds a tag 0x1 for 31-bit integers in AnyRef. Any JS value
#   that is losslessly representable (without coercion) in this range is
#   stored without boxing. This is chosen to line up exactly with how the
# ==============================================================================

diff -r 28feda14fdec -r 72bf9c871ded js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp	Fri Aug 04 14:06:50 2023 +0000
+++ b/js/src/wasm/WasmBaselineCompile.cpp	Fri Aug 04 14:06:50 2023 +0000
@@ -6527,10 +6527,6 @@
                                       RegPtr valueAddr, RegRef value,
                                       PreBarrierKind preBarrierKind,
                                       PostBarrierKind postBarrierKind) {
-  // TODO/AnyRef-boxing: With boxed immediates and strings, the write
-  // barrier is going to have to be more complicated.
-  ASSERT_ANYREF_IS_JSOBJECT;
-
   // The pre-barrier preserves all allocated registers.
   if (preBarrierKind == PreBarrierKind::Normal) {
     emitPreBarrier(valueAddr);
@@ -7471,6 +7467,40 @@
   return emitInstanceCall(SASigArrayCopy);
 }
 
+bool BaseCompiler::emitI31New() {
+  Nothing value;
+  if (!iter_.readConversion(ValType::I32, ValType(RefType::i31()), &value)) {
+    return false;
+  }
+
+  RegI32 intValue = popI32();
+  RegRef i31Value = needRef();
+  masm.truncate32ToWasmI31Ref(intValue, i31Value);
+  freeI32(intValue);
+  pushRef(i31Value);
+  return true;
+}
+
+bool BaseCompiler::emitI31Get(FieldWideningOp wideningOp) {
+  MOZ_ASSERT(wideningOp != FieldWideningOp::None);
+
+  Nothing value;
+  if (!iter_.readConversion(ValType(RefType::i31()), ValType::I32, &value)) {
+    return false;
+  }
+
+  RegRef i31Value = popRef();
+  RegI32 intValue = needI32();
+  if (wideningOp == FieldWideningOp::Signed) {
+    masm.convertWasmI31RefTo32Signed(i31Value, intValue);
+  } else {
+    masm.convertWasmI31RefTo32Unsigned(i31Value, intValue);
+  }
+  freeRef(i31Value);
+  pushI32(intValue);
+  return true;
+}
+
 void BaseCompiler::emitRefTestCommon(RefType sourceType, RefType destType) {
   Label success;
   Label join;
@@ -9955,6 +9985,12 @@
             CHECK_NEXT(emitArrayLen(/*decodeIgnoredTypeIndex=*/false));
           case uint32_t(GcOp::ArrayCopy):
             CHECK_NEXT(emitArrayCopy());
+          case uint32_t(GcOp::I31New):
+            CHECK_NEXT(emitI31New());
+          case uint32_t(GcOp::I31GetS):
+            CHECK_NEXT(emitI31Get(FieldWideningOp::Signed));
+          case uint32_t(GcOp::I31GetU):
+            CHECK_NEXT(emitI31Get(FieldWideningOp::Unsigned));
           case uint32_t(GcOp::RefTestV5):
             CHECK_NEXT(emitRefTestV5());
           case uint32_t(GcOp::RefCastV5):