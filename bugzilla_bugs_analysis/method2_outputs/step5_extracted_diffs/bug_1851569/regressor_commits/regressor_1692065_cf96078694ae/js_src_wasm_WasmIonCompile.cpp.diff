# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmIonCompile.cpp
# Commit: cf96078694ae
# Full Hash: cf96078694aea74cae4557f683a76c6de6ba9cf1
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2023-08-05 09:19:01
# Regressor Bug: 1692065
# File Overlap Count: 3
# Description:
#   Bug 1692065 - wasm: Rename MIRType::RefOrNull to 'WasmAnyRef'. r=yury
#   
#   This is a mechanical change. The previous name 'RefOrNull' was too
#   generic, and it wasn't clear that the type was actually a wasm::AnyRef
#   type.
# ==============================================================================

diff -r 662cb63c42d7 -r cf96078694ae js/src/wasm/WasmIonCompile.cpp
--- a/js/src/wasm/WasmIonCompile.cpp	Fri Aug 04 14:06:49 2023 +0000
+++ b/js/src/wasm/WasmIonCompile.cpp	Fri Aug 04 14:06:49 2023 +0000
@@ -844,7 +844,7 @@
     if (!nullVal) {
       return nullptr;
     }
-    return compare(value, nullVal, compareOp, MCompare::Compare_RefOrNull);
+    return compare(value, nullVal, compareOp, MCompare::Compare_WasmAnyRef);
   }
 
   [[nodiscard]] bool refAsNonNull(MDefinition* value) {
@@ -1697,10 +1697,10 @@
       curBlock_->add(valueAddr);
 
       // Handle a store to a ref-typed field specially
-      if (v->type() == MIRType::RefOrNull) {
+      if (v->type() == MIRType::WasmAnyRef) {
         // Load the previous value for the post-write barrier
         auto* prevValue =
-            MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
+            MWasmLoadGlobalCell::New(alloc(), MIRType::WasmAnyRef, valueAddr);
         curBlock_->add(prevValue);
 
         // Store the new value
@@ -1721,7 +1721,7 @@
     // Or else store the value directly in Instance::globalArea.
 
     // Handle a store to a ref-typed field specially
-    if (v->type() == MIRType::RefOrNull) {
+    if (v->type() == MIRType::WasmAnyRef) {
       // Compute the address of the ref-typed global
       auto* valueAddr = MWasmDerivedPointer::New(
           alloc(), instancePointer_,
@@ -1730,7 +1730,7 @@
 
       // Load the previous value for the post-write barrier
       auto* prevValue =
-          MWasmLoadGlobalCell::New(alloc(), MIRType::RefOrNull, valueAddr);
+          MWasmLoadGlobalCell::New(alloc(), MIRType::WasmAnyRef, valueAddr);
       curBlock_->add(prevValue);
 
       // Store the new value
@@ -2045,8 +2045,8 @@
         def = MWasmFloatRegisterResult::New(alloc(), type, ReturnSimd128Reg);
         break;
 #endif
-      case MIRType::RefOrNull:
-        def = MWasmRegisterResult::New(alloc(), MIRType::RefOrNull, ReturnReg);
+      case MIRType::WasmAnyRef:
+        def = MWasmRegisterResult::New(alloc(), MIRType::WasmAnyRef, ReturnReg);
         break;
       default:
         MOZ_CRASH("unexpected MIRType result for builtin call");
@@ -2104,7 +2104,7 @@
                                                 result.fpr());
             break;
           case wasm::ValType::Ref:
-            def = MWasmRegisterResult::New(alloc(), MIRType::RefOrNull,
+            def = MWasmRegisterResult::New(alloc(), MIRType::WasmAnyRef,
                                            result.gpr());
             break;
           case wasm::ValType::V128:
@@ -2924,7 +2924,7 @@
 
   MDefinition* loadTag(uint32_t tagIndex) {
     MWasmLoadInstanceDataField* tag = MWasmLoadInstanceDataField::New(
-        alloc(), MIRType::RefOrNull,
+        alloc(), MIRType::WasmAnyRef,
         moduleEnv_.offsetOfTagInstanceData(tagIndex), true, instancePointer_);
     curBlock_->add(tag);
     return tag;
@@ -2933,12 +2933,12 @@
   void loadPendingExceptionState(MInstruction** exception, MInstruction** tag) {
     *exception = MWasmLoadInstance::New(
         alloc(), instancePointer_, wasm::Instance::offsetOfPendingException(),
-        MIRType::RefOrNull, AliasSet::Load(AliasSet::WasmPendingException));
+        MIRType::WasmAnyRef, AliasSet::Load(AliasSet::WasmPendingException));
     curBlock_->add(*exception);
 
     *tag = MWasmLoadInstance::New(
         alloc(), instancePointer_,
-        wasm::Instance::offsetOfPendingExceptionTag(), MIRType::RefOrNull,
+        wasm::Instance::offsetOfPendingExceptionTag(), MIRType::WasmAnyRef,
         AliasSet::Load(AliasSet::WasmPendingException));
     curBlock_->add(*tag);
   }
@@ -3215,7 +3215,7 @@
     // block's tag.
     MDefinition* catchTag = loadTag(tagIndex);
     MDefinition* matchesCatchTag =
-        compare(exceptionTag, catchTag, JSOp::Eq, MCompare::Compare_RefOrNull);
+        compare(exceptionTag, catchTag, JSOp::Eq, MCompare::Compare_WasmAnyRef);
     curBlock_->end(
         MTest::New(alloc(), matchesCatchTag, catchBlock, fallthroughBlock));
 
@@ -3463,8 +3463,8 @@
     size_t exnSlotPosition = pad->nslots() - 2;
     MDefinition* tag = pad->getSlot(exnSlotPosition + 1);
     MDefinition* exception = pad->getSlot(exnSlotPosition);
-    MOZ_ASSERT(exception->type() == MIRType::RefOrNull &&
-               tag->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(exception->type() == MIRType::WasmAnyRef &&
+               tag->type() == MIRType::WasmAnyRef);
     return throwFrom(exception, tag);
   }
 
@@ -3657,7 +3657,7 @@
       AliasSet::Flag aliasBitset, MDefinition* value, MDefinition* base,
       uint32_t offset, bool needsTrapInfo, WasmPreBarrierKind preBarrierKind) {
     MOZ_ASSERT(aliasBitset != 0);
-    MOZ_ASSERT(keepAlive->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(keepAlive->type() == MIRType::WasmAnyRef);
     MOZ_ASSERT(fieldType.widenToValType().toMIRType() == value->type());
     MNarrowingOp narrowingOp = fieldStoreInfoToMIR(fieldType);
 
@@ -3710,7 +3710,7 @@
       AliasSet::Flag aliasBitset, MDefinition* value, MDefinition* base,
       uint32_t scale, MDefinition* index, WasmPreBarrierKind preBarrierKind) {
     MOZ_ASSERT(aliasBitset != 0);
-    MOZ_ASSERT(keepAlive->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(keepAlive->type() == MIRType::WasmAnyRef);
     MOZ_ASSERT(fieldType.widenToValType().toMIRType() == value->type());
     MOZ_ASSERT(scale == 1 || scale == 2 || scale == 4 || scale == 8 ||
                scale == 16);
@@ -3742,7 +3742,7 @@
       MDefinition* keepAlive, AliasSet::Flag aliasBitset, MDefinition* base,
       uint32_t offset, bool needsTrapInfo) {
     MOZ_ASSERT(aliasBitset != 0);
-    MOZ_ASSERT(keepAlive->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(keepAlive->type() == MIRType::WasmAnyRef);
     MIRType mirType;
     MWideningOp mirWideningOp;
     fieldLoadInfoToMIR(fieldType, fieldWideningOp, &mirType, &mirWideningOp);
@@ -3769,7 +3769,7 @@
       MDefinition* keepAlive, AliasSet::Flag aliasBitset, MDefinition* base,
       uint32_t scale, MDefinition* index) {
     MOZ_ASSERT(aliasBitset != 0);
-    MOZ_ASSERT(keepAlive->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(keepAlive->type() == MIRType::WasmAnyRef);
     MOZ_ASSERT(scale == 1 || scale == 2 || scale == 4 || scale == 8 ||
                scale == 16);
 
@@ -4020,7 +4020,7 @@
   // Adds trap site info for the null check.
   [[nodiscard]] MDefinition* getWasmArrayObjectNumElements(
       MDefinition* arrayObject) {
-    MOZ_ASSERT(arrayObject->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(arrayObject->type() == MIRType::WasmAnyRef);
 
     auto* numElements = MWasmLoadField::New(
         alloc(), arrayObject, WasmArrayObject::offsetOfNumElements(),
@@ -4038,7 +4038,7 @@
   // Given `arrayObject`, the address of a WasmArrayObject, generate MIR to
   // return the contents of the WasmArrayObject::data_ field.
   [[nodiscard]] MDefinition* getWasmArrayObjectData(MDefinition* arrayObject) {
-    MOZ_ASSERT(arrayObject->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(arrayObject->type() == MIRType::WasmAnyRef);
 
     auto* data = MWasmLoadField::New(
         alloc(), arrayObject, WasmArrayObject::offsetOfData(),
@@ -4112,7 +4112,7 @@
   // The returned value is for the OOL object pointer.
   [[nodiscard]] MDefinition* setupForArrayAccess(MDefinition* arrayObject,
                                                  MDefinition* index) {
-    MOZ_ASSERT(arrayObject->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(arrayObject->type() == MIRType::WasmAnyRef);
     MOZ_ASSERT(index->type() == MIRType::Int32);
 
     // Check for null is done in getWasmArrayObjectNumElements.
@@ -4384,7 +4384,7 @@
     // reftyped.
     MOZ_RELEASE_ASSERT(values.length() > 0);
     MDefinition* ref = values.back();
-    MOZ_ASSERT(ref->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(ref->type() == MIRType::WasmAnyRef);
 
     MDefinition* success = isRefSubtypeOf(ref, sourceType, destType);
     if (!success) {
@@ -4426,7 +4426,7 @@
     }
 
     MOZ_ASSERT(values.length() > 0);
-    MOZ_ASSERT(values.back()->type() == MIRType::RefOrNull);
+    MOZ_ASSERT(values.back()->type() == MIRType::WasmAnyRef);
 
     MGoto* jump = MGoto::New(alloc(), fallthroughBlock);
     if (!jump) {
@@ -6623,7 +6623,7 @@
     return false;
   }
   f.iter().setResult(
-      f.compare(input, nullVal, JSOp::Eq, MCompare::Compare_RefOrNull));
+      f.compare(input, nullVal, JSOp::Eq, MCompare::Compare_WasmAnyRef));
   return true;
 }
 
@@ -8054,7 +8054,7 @@
           return f.iter().unrecognizedOpcode(&op);
         }
         CHECK(EmitComparison(f, RefType::eq(), JSOp::Eq,
-                             MCompare::Compare_RefOrNull));
+                             MCompare::Compare_WasmAnyRef));
 #endif
       case uint16_t(Op::RefFunc):
         CHECK(EmitRefFunc(f));