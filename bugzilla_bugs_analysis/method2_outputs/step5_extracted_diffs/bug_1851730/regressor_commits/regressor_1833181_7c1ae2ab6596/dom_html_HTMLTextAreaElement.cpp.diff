# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/html/HTMLTextAreaElement.cpp
# Commit: 7c1ae2ab6596
# Full Hash: 7c1ae2ab65966ae06c7e539015fbc1f2d852dd4a
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2023-05-16 04:24:30
# Regressor Bug: 1833181
# File Overlap Count: 1
# Description:
#   Bug 1833181 - Avoid attr lookups to check whether input value is empty. r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D178078
# ==============================================================================

diff -r 08a8f6b67ccf -r 7c1ae2ab6596 dom/html/HTMLTextAreaElement.cpp
--- a/dom/html/HTMLTextAreaElement.cpp	Mon May 15 17:13:37 2023 +0000
+++ b/dom/html/HTMLTextAreaElement.cpp	Mon May 15 17:16:41 2023 +0000
@@ -69,7 +69,7 @@
   // until someone calls UpdateEditableState on us, apparently!  Also
   // by default we don't have to show validity UI and so forth.
   AddStatesSilently(ElementState::ENABLED | ElementState::OPTIONAL_ |
-                    ElementState::VALID);
+                    ElementState::VALID | ElementState::VALUE_EMPTY);
 }
 
 HTMLTextAreaElement::~HTMLTextAreaElement() {
@@ -784,7 +784,7 @@
     }
   }
 
-  if (HasAttr(nsGkAtoms::placeholder) && IsValueEmpty()) {
+  if (IsValueEmpty() && HasAttr(nsGkAtoms::placeholder)) {
     state |= ElementState::PLACEHOLDER_SHOWN;
   }
 
@@ -948,13 +948,6 @@
   return (!HasAttr(kNameSpaceID_None, nsGkAtoms::readonly) && !IsDisabled());
 }
 
-bool HTMLTextAreaElement::IsValueEmpty() const {
-  nsAutoString value;
-  GetValueInternal(value, true);
-
-  return value.IsEmpty();
-}
-
 void HTMLTextAreaElement::SetCustomValidity(const nsAString& aError) {
   ConstraintValidation::SetCustomValidity(aError);
 
@@ -1001,7 +994,6 @@
   if (!Required() || !IsMutable()) {
     return false;
   }
-
   return IsValueEmpty();
 }
 
@@ -1121,18 +1113,28 @@
   mState->InitializeKeyboardEventListeners();
 }
 
-void HTMLTextAreaElement::OnValueChanged(ValueChangeKind aKind) {
+void HTMLTextAreaElement::OnValueChanged(ValueChangeKind aKind,
+                                         bool aNewValueEmpty,
+                                         const nsAString*) {
   if (aKind != ValueChangeKind::Internal) {
     mLastValueChangeWasInteractive = aKind == ValueChangeKind::UserInteraction;
   }
 
+  const bool emptyBefore = IsValueEmpty();
+  if (aNewValueEmpty) {
+    AddStates(ElementState::VALUE_EMPTY);
+  } else {
+    RemoveStates(ElementState::VALUE_EMPTY);
+  }
+
   // Update the validity state
-  bool validBefore = IsValid();
+  const bool validBefore = IsValid();
   UpdateTooLongValidityState();
   UpdateTooShortValidityState();
   UpdateValueMissingValidityState();
 
-  if (validBefore != IsValid() || HasAttr(nsGkAtoms::placeholder)) {
+  if (validBefore != IsValid() ||
+      (emptyBefore != IsValueEmpty() && HasAttr(nsGkAtoms::placeholder))) {
     UpdateState(true);
   }
 }