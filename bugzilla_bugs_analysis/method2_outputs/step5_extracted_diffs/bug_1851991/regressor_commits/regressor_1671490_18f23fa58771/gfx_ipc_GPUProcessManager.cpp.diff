# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/ipc/GPUProcessManager.cpp
# Commit: 18f23fa58771
# Full Hash: 18f23fa5877125926953f6d53a9e2c881d0b9be2
# Author: Florian Queze <florian@queze.net>
# Date: 2022-11-14 21:44:03
# Regressor Bug: 1671490
# File Overlap Count: 1
# Description:
#   Bug 1671490 - Mark the GPU process as being in the foreground whenever the parent process is in the foreground to make their priorities (and priority boosts) match, r=bas.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D161065
# ==============================================================================

diff -r c1fef68a839f -r 18f23fa58771 gfx/ipc/GPUProcessManager.cpp
--- a/gfx/ipc/GPUProcessManager.cpp	Mon Nov 14 11:03:18 2022 -0500
+++ b/gfx/ipc/GPUProcessManager.cpp	Mon Nov 14 16:05:34 2022 +0000
@@ -466,6 +466,11 @@
 
   mGPUChild = mProcess->GetActor();
   mProcessToken = mProcess->GetProcessToken();
+#if defined(XP_WIN)
+  if (mAppInForeground) {
+    SetProcessIsForeground();
+  }
+#endif
 
   ipc::Endpoint<PVsyncBridgeParent> vsyncParent;
   ipc::Endpoint<PVsyncBridgeChild> vsyncChild;
@@ -824,7 +829,11 @@
   // Except on Android if the app is in the background, where we want to wait
   // until the app is in the foreground again.
   if (gfxConfig::IsEnabled(Feature::GPU_PROCESS)) {
+#ifdef MOZ_WIDGET_ANDROID
     if (mAppInForeground) {
+#else
+    {
+#endif
       Unused << LaunchGPUProcess();
     }
   } else {
@@ -1393,6 +1402,57 @@
   return new GPUMemoryReporter();
 }
 
+void GPUProcessManager::SetAppInForeground(bool aInForeground) {
+  if (mAppInForeground == aInForeground) {
+    return;
+  }
+
+  mAppInForeground = aInForeground;
+#if defined(XP_WIN)
+  SetProcessIsForeground();
+#endif
+}
+
+#if defined(XP_WIN)
+void GPUProcessManager::SetProcessIsForeground() {
+  NTSTATUS WINAPI NtSetInformationProcess(
+      IN HANDLE process_handle, IN ULONG info_class,
+      IN PVOID process_information, IN ULONG information_length);
+  constexpr unsigned int NtProcessInformationForeground = 25;
+
+  static bool alreadyInitialized = false;
+  static decltype(NtSetInformationProcess)* setInformationProcess = nullptr;
+  if (!alreadyInitialized) {
+    alreadyInitialized = true;
+    nsModuleHandle module(LoadLibrary(L"ntdll.dll"));
+    if (module) {
+      setInformationProcess =
+          (decltype(NtSetInformationProcess)*)GetProcAddress(
+              module, "NtSetInformationProcess");
+    }
+  }
+  if (MOZ_UNLIKELY(!setInformationProcess)) {
+    return;
+  }
+
+  unsigned pid = GPUProcessPid();
+  if (pid <= 0) {
+    return;
+  }
+  // Using the handle from mProcess->GetChildProcessHandle() fails;
+  // the PROCESS_SET_INFORMATION permission is probably missing.
+  nsAutoHandle processHandle(
+      ::OpenProcess(PROCESS_SET_INFORMATION, FALSE, pid));
+  if (!processHandle) {
+    return;
+  }
+
+  BOOLEAN foreground = mAppInForeground;
+  setInformationProcess(processHandle, NtProcessInformationForeground,
+                        (PVOID)&foreground, sizeof(foreground));
+}
+#endif
+
 RefPtr<PGPUChild::TestTriggerMetricsPromise>
 GPUProcessManager::TestTriggerMetrics() {
   if (!NS_WARN_IF(!mGPUChild)) {