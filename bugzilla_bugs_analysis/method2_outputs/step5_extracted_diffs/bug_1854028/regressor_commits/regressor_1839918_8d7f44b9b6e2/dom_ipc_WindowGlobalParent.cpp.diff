# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/WindowGlobalParent.cpp
# Commit: 8d7f44b9b6e2
# Full Hash: 8d7f44b9b6e2debb08256460bc77355551e5d3c8
# Author: Paul Zuehlcke <pbz@mozilla.com>
# Date: 2023-09-19 03:53:26
# Regressor Bug: 1839918
# File Overlap Count: 3
# Description:
#   Bug 1839918 - Create SetCookies variant for document.cookie on PWindowGlobal. r=bvandersloot,cookie-reviewers,valentin
#   
#   Using PWindowGlobal for SetCookies calls from content to parent process means we can get
#   the BrowsingContext the cookies are set for. The current implementation in PCookieService
#   drops this relationship.
# ==============================================================================

diff -r 7a28b63b4fc3 -r 8d7f44b9b6e2 dom/ipc/WindowGlobalParent.cpp
--- a/dom/ipc/WindowGlobalParent.cpp	Mon Sep 18 11:55:09 2023 +0000
+++ b/dom/ipc/WindowGlobalParent.cpp	Mon Sep 18 11:55:09 2023 +0000
@@ -36,12 +36,15 @@
 #include "mozilla/StaticPrefs_network.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/Variant.h"
+#include "mozilla/ipc/ProtocolUtils.h"
 #include "nsContentUtils.h"
 #include "nsDocShell.h"
 #include "nsDocShellLoadState.h"
 #include "nsError.h"
 #include "nsFrameLoader.h"
 #include "nsFrameLoaderOwner.h"
+#include "nsICookieManager.h"
+#include "nsICookieService.h"
 #include "nsQueryObject.h"
 #include "nsNetUtil.h"
 #include "nsSandboxFlags.h"
@@ -63,6 +66,10 @@
 #include "mozilla/dom/JSWindowActorBinding.h"
 #include "mozilla/dom/JSWindowActorParent.h"
 
+#include "mozilla/net/NeckoParent.h"
+#include "mozilla/net/PCookieServiceParent.h"
+#include "mozilla/net/CookieServiceParent.h"
+
 #include "SessionStoreFunctions.h"
 #include "nsIXPConnect.h"
 #include "nsImportModule.h"
@@ -1612,6 +1619,57 @@
   }
 }
 
+IPCResult WindowGlobalParent::RecvSetCookies(
+    const nsCString& aBaseDomain, const OriginAttributes& aOriginAttributes,
+    nsIURI* aHost, bool aFromHttp, const nsTArray<CookieStruct>& aCookies) {
+  // Get CookieServiceParent via
+  // ContentParent->NeckoParent->CookieServiceParent.
+  ContentParent* contentParent = GetContentParent();
+  if (!contentParent) {
+    return IPC_FAIL_NO_REASON(this);
+  }
+
+  net::PNeckoParent* neckoParent =
+      LoneManagedOrNullAsserts(contentParent->ManagedPNeckoParent());
+  if (!neckoParent) {
+    return IPC_FAIL_NO_REASON(this);
+  }
+  net::PCookieServiceParent* csParent =
+      LoneManagedOrNullAsserts(neckoParent->ManagedPCookieServiceParent());
+  if (!csParent) {
+    return IPC_FAIL_NO_REASON(this);
+  }
+  auto* cs = static_cast<net::CookieServiceParent*>(csParent);
+
+  dom::BrowsingContext* browsingContext = GetBrowsingContext();
+  if (!browsingContext) {
+    return IPC_FAIL_NO_REASON(this);
+  }
+
+  // Check if the cookies being set are third-party to the top level. We do this
+  // by comparing the top level principals base domain with aBaseDomain.
+  bool isThirdPartyCookie = false;
+  if (!browsingContext->IsTop()) {
+    dom::BrowsingContext* topBC = browsingContext->Top();
+    MOZ_ASSERT(topBC);
+
+    RefPtr<WindowGlobalParent> topWGP =
+        topBC->Canonical()->GetEmbedderWindowGlobal();
+    NS_ENSURE_TRUE(topWGP, IPC_FAIL_NO_REASON(this));
+
+    nsCOMPtr<nsIPrincipal> topPrincipal = topWGP->DocumentPrincipal();
+    MOZ_ASSERT(topPrincipal);
+    nsAutoCString topBaseDomain;
+    nsresult rv = topPrincipal->GetBaseDomain(topBaseDomain);
+    NS_ENSURE_SUCCESS(rv, IPC_FAIL_NO_REASON(this));
+
+    isThirdPartyCookie = aBaseDomain.Equals(topBaseDomain);
+  }
+
+  return cs->SetCookies(aBaseDomain, aOriginAttributes, aHost, aFromHttp,
+                        aCookies, browsingContext->Id(), isThirdPartyCookie);
+}
+
 NS_IMPL_CYCLE_COLLECTION_INHERITED(WindowGlobalParent, WindowContext,
                                    mPageUseCountersWindow)
 