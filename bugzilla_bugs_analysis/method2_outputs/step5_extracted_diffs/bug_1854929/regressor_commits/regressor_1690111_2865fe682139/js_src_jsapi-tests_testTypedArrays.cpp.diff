# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jsapi-tests/testTypedArrays.cpp
# Commit: 2865fe682139
# Full Hash: 2865fe682139450ad7574810366f980d771412c2
# Author: Steve Fink <sfink@mozilla.com>
# Date: 2023-09-12 04:12:49
# Regressor Bug: 1690111
# File Overlap Count: 1
# Description:
#   Bug 1690111 - Implement the ability to pin lengths (prevent changes to length, eg via detaching) for ArrayBuffers and their views. r=jonco
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D131301
# ==============================================================================

diff -r 9dcd2416f8a5 -r 2865fe682139 js/src/jsapi-tests/testTypedArrays.cpp
--- a/js/src/jsapi-tests/testTypedArrays.cpp	Mon Sep 11 12:52:18 2023 +0000
+++ b/js/src/jsapi-tests/testTypedArrays.cpp	Mon Sep 11 12:52:19 2023 +0000
@@ -107,6 +107,62 @@
   return ok;
 }
 
+// Test pinning a view's length.
+bool TestViewLengthPinning(Handle<JSObject*> view) {
+  // Pin the length of an inline view. (Fails if shared memory.)
+  bool isShared = view.as<NativeObject>()->isSharedMemory();
+  CHECK(JS::PinArrayBufferOrViewLength(view, true) == !isShared);
+
+  // Fail to pin an already-pinned length.
+  CHECK(!JS::PinArrayBufferOrViewLength(view, true));
+
+  // Extract an ArrayBuffer. This may cause it to be created, in which case it
+  // will inherit the pinned status from the view.
+  bool bufferIsShared;
+  Rooted<JSObject*> buffer(
+      cx, JS_GetArrayBufferViewBuffer(cx, view, &bufferIsShared));
+  CHECK(isShared == bufferIsShared);
+
+  // Cannot pin the buffer, since it is already pinned.
+  CHECK(!JS::PinArrayBufferOrViewLength(buffer, true));
+
+  // Should fail to be detached, since its length is pinned.
+  CHECK(!JS::DetachArrayBuffer(cx, buffer));
+  CHECK(cx->isExceptionPending());
+  cx->clearPendingException();
+
+  // Unpin (fails if shared memory).
+  CHECK(JS::PinArrayBufferOrViewLength(view, false) == !isShared);
+
+  // Fail to unpin when already unpinned.
+  CHECK(!JS::PinArrayBufferOrViewLength(view, false));
+
+  return true;
+}
+
+// Test pinning the length of an ArrayBuffer or SharedArrayBuffer.
+bool TestBufferLengthPinning(Handle<JSObject*> buffer) {
+  // Pin the length of an inline view. (Fails if shared memory.)
+  bool isShared = !buffer->is<ArrayBufferObject>();
+  CHECK(JS::PinArrayBufferOrViewLength(buffer, true) == !isShared);
+
+  // Fail to pin an already-pinned length.
+  CHECK(!JS::PinArrayBufferOrViewLength(buffer, true));
+
+  // Should fail to be detached, since its length is pinned.
+  CHECK(!JS::DetachArrayBuffer(cx, buffer));
+  CHECK(cx->isExceptionPending());
+  cx->clearPendingException();
+
+  // Unpin (fails if shared memory).
+  CHECK(JS::PinArrayBufferOrViewLength(buffer, false) == !isShared);
+
+  // Fail to unpin when already unpinned.
+  CHECK(!JS::PinArrayBufferOrViewLength(buffer, false));
+
+  return true;
+}
+
 // Shared memory can only be mapped by a TypedArray by creating the
 // TypedArray with a SharedArrayBuffer explicitly, so no tests here.
 
@@ -130,6 +186,8 @@
   CHECK_EQUAL(JS_GetTypedArrayByteOffset(array), 0u);
   CHECK_EQUAL(JS_GetTypedArrayByteLength(array), sizeof(Element) * 7);
 
+  TestViewLengthPinning(array);
+
   {
     JS::AutoCheckCannotGC nogc;
     Element* data;
@@ -159,6 +217,9 @@
   size_t nbytes = elts * sizeof(Element);
   RootedObject buffer(cx, Shared ? JS::NewSharedArrayBuffer(cx, nbytes)
                                  : JS::NewArrayBuffer(cx, nbytes));
+
+  TestBufferLengthPinning(buffer);
+
   {
     JS::AutoCheckCannotGC nogc;
     bool isShared;
@@ -185,6 +246,8 @@
     CHECK_EQUAL(Shared, isShared);
   }
 
+  TestViewLengthPinning(array);
+
   {
     JS::AutoCheckCannotGC nogc;
     Element* data;