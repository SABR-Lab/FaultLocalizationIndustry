# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/apz/util/APZEventState.cpp
# Commit: e974d872becd
# Full Hash: e974d872becd4fae0214738cdf27173a994d0f59
# Author: Dan Robertson <drobertson@mozilla.com>
# Date: 2023-08-30 21:27:31
# Regressor Bug: 1816473
# File Overlap Count: 1
# Description:
#   Bug 1816473 - Do not delay dispatching synthesized mouse events. r=botond,edgar
#   
#   Do not delay dispatching synthesized mouse events for a single tap
#   gesture.
#   
# ==============================================================================

diff -r 1b272e14e402 -r e974d872becd gfx/layers/apz/util/APZEventState.cpp
--- a/gfx/layers/apz/util/APZEventState.cpp	Wed Aug 30 12:06:41 2023 +0000
+++ b/gfx/layers/apz/util/APZEventState.cpp	Wed Aug 30 12:49:22 2023 +0000
@@ -106,7 +106,6 @@
       mTouchEndCancelled(false),
       mReceivedNonTouchStart(false),
       mTouchStartPrevented(false),
-      mSingleTapsPendingTargetInfo(),
       mLastTouchIdentifier(0) {
   nsresult rv;
   mWidget = do_GetWeakReference(aWidget, &rv);
@@ -117,65 +116,6 @@
 
 APZEventState::~APZEventState() = default;
 
-RefPtr<DelayedFireSingleTapEvent> DelayedFireSingleTapEvent::Create(
-    Maybe<SingleTapTargetInfo>&& aTargetInfo) {
-  nsCOMPtr<nsITimer> timer = NS_NewTimer();
-  RefPtr<DelayedFireSingleTapEvent> event =
-      new DelayedFireSingleTapEvent(std::move(aTargetInfo), timer);
-  nsresult rv = timer->InitWithCallback(
-      event, StaticPrefs::ui_touch_activation_duration_ms(),
-      nsITimer::TYPE_ONE_SHOT);
-  if (NS_FAILED(rv)) {
-    event->ClearTimer();
-    event = nullptr;
-  }
-  return event;
-}
-
-NS_IMETHODIMP DelayedFireSingleTapEvent::Notify(nsITimer*) {
-  APZES_LOG("DelayedFireSingeTapEvent notification ready=%d",
-            mTargetInfo.isSome());
-  // If the required information to fire the synthesized events has not
-  // been populated yet, we have not received the touch-end. In this case
-  // we should not fire the synthesized events here. The synthesized events
-  // will be fired on touch-end in this case.
-  if (mTargetInfo.isSome()) {
-    FireSingleTapEvent();
-  }
-  mTimer = nullptr;
-  return NS_OK;
-}
-
-NS_IMETHODIMP DelayedFireSingleTapEvent::GetName(nsACString& aName) {
-  aName.AssignLiteral("DelayedFireSingleTapEvent");
-  return NS_OK;
-}
-
-void DelayedFireSingleTapEvent::PopulateTargetInfo(
-    SingleTapTargetInfo&& aTargetInfo) {
-  MOZ_ASSERT(!mTargetInfo.isSome());
-  mTargetInfo = Some(std::move(aTargetInfo));
-  // If the timer no longer exists, we have surpassed the minimum elapsed
-  // time to delay the synthesized click. We can immediately fire the
-  // synthesized events in this case.
-  if (!mTimer) {
-    FireSingleTapEvent();
-  }
-}
-
-void DelayedFireSingleTapEvent::FireSingleTapEvent() {
-  MOZ_ASSERT(mTargetInfo.isSome());
-  nsCOMPtr<nsIWidget> widget = do_QueryReferent(mTargetInfo->mWidget);
-  if (widget) {
-    widget::nsAutoRollup rollup(mTargetInfo->mTouchRollup.get());
-    APZCCallbackHelper::FireSingleTapEvent(mTargetInfo->mPoint,
-                                           mTargetInfo->mModifiers,
-                                           mTargetInfo->mClickCount, widget);
-  }
-}
-
-NS_IMPL_ISUPPORTS(DelayedFireSingleTapEvent, nsITimerCallback, nsINamed)
-
 void APZEventState::ProcessSingleTap(const CSSPoint& aPoint,
                                      const CSSToLayoutDeviceScale& aScale,
                                      Modifiers aModifiers, int32_t aClickCount,
@@ -195,24 +135,14 @@
     return;
   }
 
-  SingleTapTargetInfo targetInfo(mWidget, aPoint * aScale, aModifiers,
-                                 aClickCount, touchRollup);
-
-  auto delayedEvent = mSingleTapsPendingTargetInfo.find(aInputBlockId);
-  if (delayedEvent != mSingleTapsPendingTargetInfo.end()) {
-    APZES_LOG("Found tap for block=%" PRIu64, aInputBlockId);
+  nsCOMPtr<nsIWidget> localWidget = do_QueryReferent(mWidget);
+  if (localWidget) {
+    widget::nsAutoRollup rollup(touchRollup);
+    APZCCallbackHelper::FireSingleTapEvent(aPoint * aScale, aModifiers,
+                                           aClickCount, localWidget);
+  }
 
-    // With the target info populated, the event will be fired as
-    // soon as the delay timer expires (or now, if it has already expired).
-    delayedEvent->second->PopulateTargetInfo(std::move(targetInfo));
-    mSingleTapsPendingTargetInfo.erase(delayedEvent);
-  } else {
-    APZES_LOG("Scheduling timer for click event\n");
-
-    // We don't need to keep a reference to the event, because the
-    // event and its timer keep each other alive until the timer expires
-    DelayedFireSingleTapEvent::Create(Some(std::move(targetInfo)));
-  }
+  mActiveElementManager->ProcessSingleTap();
 }
 
 PreventDefaultResult APZEventState::FireContextmenuEvents(
@@ -578,17 +508,11 @@
       bool canBePan = aArg;
       mActiveElementManager->HandleTouchStart(canBePan);
       // If this is a non-scrollable content, set a timer for the amount of
-      // time specified by ui.touch_activation.duration_ms to fire the
-      // synthesized click and mouse events.
+      // time specified by ui.touch_activation.duration_ms to clear the
+      // active element state.
       APZES_LOG("%s: can-be-pan=%d", __FUNCTION__, aArg);
       if (!canBePan) {
         MOZ_ASSERT(aInputBlockId.isSome());
-        RefPtr<DelayedFireSingleTapEvent> delayedEvent =
-            DelayedFireSingleTapEvent::Create(Nothing());
-        DebugOnly<bool> insertResult =
-            mSingleTapsPendingTargetInfo.emplace(*aInputBlockId, delayedEvent)
-                .second;
-        MOZ_ASSERT(insertResult, "Failed to insert delayed tap event.");
       }
       break;
     }
@@ -605,6 +529,8 @@
   }
 }
 
+void APZEventState::Destroy() { mActiveElementManager->Destroy(); }
+
 void APZEventState::SendPendingTouchPreventedResponse(bool aPreventDefault) {
   if (mPendingTouchPreventedResponse) {
     APZES_LOG("Sending response %d for pending guid: %s block id: %" PRIu64