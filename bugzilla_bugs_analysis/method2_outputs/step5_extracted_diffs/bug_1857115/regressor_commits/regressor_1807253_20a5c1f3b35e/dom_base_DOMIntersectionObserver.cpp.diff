# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DOMIntersectionObserver.cpp
# Commit: 20a5c1f3b35e
# Full Hash: 20a5c1f3b35e80849e0b98ffbe3f9488d703717b
# Author: Frederic Wang <fred.wang@free.fr>
# Date: 2023-11-22 21:50:37
# Regressor Bug: 1807253
# File Overlap Count: 1
# Description:
#   Bug 1807253 - unreliable timing for content-visibility:auto, r=emilio
#   
#   Rewrite implementation of content-visibility: auto as defined in
#   https://github.com/w3c/csswg-drafts/issues/8542
#   
# ==============================================================================

diff -r b90083f581e1 -r 20a5c1f3b35e dom/base/DOMIntersectionObserver.cpp
--- a/dom/base/DOMIntersectionObserver.cpp	Mon Nov 20 11:33:16 2023 +0000
+++ b/dom/base/DOMIntersectionObserver.cpp	Wed Nov 22 13:00:36 2023 +0000
@@ -160,20 +160,6 @@
   }
 }
 
-static void ContentVisibilityCallback(
-    const Sequence<OwningNonNull<DOMIntersectionObserverEntry>>& aEntries) {
-  for (const auto& entry : aEntries) {
-    entry->Target()->SetVisibleForContentVisibility(entry->IsIntersecting());
-
-    if (RefPtr<Document> doc = entry->Target()->GetComposedDoc()) {
-      if (RefPtr<PresShell> presShell = doc->GetPresShell()) {
-        presShell->ScheduleContentRelevancyUpdate(
-            ContentRelevancyReason::Visible);
-      }
-    }
-  }
-}
-
 static LengthPercentage PrefMargin(float aValue, bool aIsPercentage) {
   return aIsPercentage ? LengthPercentage::FromPercentage(aValue / 100.0f)
                        : LengthPercentage::FromPixels(aValue);
@@ -205,25 +191,6 @@
   return observer.forget();
 }
 
-already_AddRefed<DOMIntersectionObserver>
-DOMIntersectionObserver::CreateContentVisibilityObserver(Document& aDocument) {
-  RefPtr<DOMIntersectionObserver> observer =
-      new DOMIntersectionObserver(aDocument, ContentVisibilityCallback);
-
-  observer->mThresholds.AppendElement(0.0f);
-
-  auto margin = LengthPercentage::FromPercentage(
-      StaticPrefs::layout_css_content_visibility_relevant_content_margin() /
-      100.0f);
-
-  observer->mRootMargin.Get(eSideTop) = margin;
-  observer->mRootMargin.Get(eSideRight) = margin;
-  observer->mRootMargin.Get(eSideBottom) = margin;
-  observer->mRootMargin.Get(eSideLeft) = margin;
-
-  return observer.forget();
-}
-
 bool DOMIntersectionObserver::SetRootMargin(const nsACString& aString) {
   return Servo_IntersectionObserverRootMargin_Parse(&aString, &mRootMargin);
 }
@@ -348,8 +315,8 @@
 static Maybe<nsRect> ComputeTheIntersection(
     nsIFrame* aTarget, nsIFrame* aRoot, const nsRect& aRootBounds,
     const Maybe<nsRect>& aRemoteDocumentVisibleRect,
-    DOMIntersectionObserver::IsContentVisibilityObserver
-        aIsContentVisibilityObserver) {
+    DOMIntersectionObserver::IsForProximityToViewport
+        aIsForProximityToViewport) {
   nsIFrame* target = aTarget;
   // 1. Let intersectionRect be the result of running the
   // getBoundingClientRect() algorithm on the target.
@@ -359,8 +326,8 @@
       target, target, nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS);
   // For content-visibility, we need to observe the overflow clip edge,
   // https://drafts.csswg.org/css-contain-2/#close-to-the-viewport
-  if (aIsContentVisibilityObserver ==
-      DOMIntersectionObserver::IsContentVisibilityObserver::Yes) {
+  if (aIsForProximityToViewport ==
+      DOMIntersectionObserver::IsForProximityToViewport::Yes) {
     const auto& disp = *target->StyleDisplay();
     auto clipAxes = target->ShouldApplyOverflowClipping(&disp);
     if (clipAxes != PhysicalAxes::None) {
@@ -648,7 +615,7 @@
 // (steps 2.1 - 2.5)
 IntersectionOutput DOMIntersectionObserver::Intersect(
     const IntersectionInput& aInput, const Element& aTarget,
-    IsContentVisibilityObserver aIsContentVisibilityObserver) {
+    IsForProximityToViewport aIsForProximityToViewport) {
   const bool isSimilarOrigin = SimilarOrigin(aTarget, aInput.mRootNode) ==
                                BrowsingContextOrigin::Similar;
   nsIFrame* targetFrame = aTarget.GetPrimaryFrame();
@@ -663,9 +630,9 @@
   // https://drafts.csswg.org/css-contain/#cv-notes
   //
   // Skip the intersection if the element is hidden, unless this is the
-  // DOMIntersectionObserver used specifically to track the visibility of
+  // specifically to determine the proximity to the viewport for
   // `content-visibility: auto` elements.
-  if (aIsContentVisibilityObserver == IsContentVisibilityObserver::No &&
+  if (aIsForProximityToViewport == IsForProximityToViewport::No &&
       targetFrame->IsHiddenByContentVisibilityOnAnyAncestor()) {
     return {isSimilarOrigin};
   }
@@ -699,7 +666,7 @@
   nsRect targetRect = targetFrame->GetBoundingClientRect();
   // For content-visibility, we need to observe the overflow clip edge,
   // https://drafts.csswg.org/css-contain-2/#close-to-the-viewport
-  if (aIsContentVisibilityObserver == IsContentVisibilityObserver::Yes) {
+  if (aIsForProximityToViewport == IsForProximityToViewport::Yes) {
     const auto& disp = *targetFrame->StyleDisplay();
     auto clipAxes = targetFrame->ShouldApplyOverflowClipping(&disp);
     if (clipAxes != PhysicalAxes::None) {
@@ -713,7 +680,7 @@
   // intersection algorithm on target and observer’s intersection root.
   Maybe<nsRect> intersectionRect = ComputeTheIntersection(
       targetFrame, aInput.mRootFrame, rootBounds,
-      aInput.mRemoteDocumentVisibleRect, aIsContentVisibilityObserver);
+      aInput.mRemoteDocumentVisibleRect, aIsForProximityToViewport);
 
   return {isSimilarOrigin, rootBounds, targetRect, intersectionRect};
 }
@@ -737,20 +704,11 @@
                                      DOMHighResTimeStamp time) {
   auto input = ComputeInput(aDocument, mRoot, &mRootMargin);
 
-  // If this observer is used to determine content relevancy for
-  // `content-visiblity: auto` content, then do not skip intersection
-  // for content that is hidden by `content-visibility: auto`.
-  IsContentVisibilityObserver isContentVisibilityObserver =
-      aDocument.GetContentVisibilityObserver() == this
-          ? IsContentVisibilityObserver::Yes
-          : IsContentVisibilityObserver::No;
-
   // 2. For each target in observer’s internal [[ObservationTargets]] slot,
   // processed in the same order that observe() was called on each target:
   for (Element* target : mObservationTargets) {
     // 2.1 - 2.4.
-    IntersectionOutput output =
-        Intersect(input, *target, isContentVisibilityObserver);
+    IntersectionOutput output = Intersect(input, *target);
 
     // 2.5. Let targetArea be targetRect’s area.
     int64_t targetArea = (int64_t)output.mTargetRect.Width() *
@@ -803,16 +761,8 @@
       }
     }
 
-    // If descendantScrolledIntoView, it means the target is with c-v: auto, and
-    // the content relevancy value has been set to visible before
-    // scrollIntoView. Here, we need to generate entries for them, so that the
-    // content relevancy value could be checked in the callback.
-    const bool temporarilyVisibleForScrolledIntoView =
-        isContentVisibilityObserver == IsContentVisibilityObserver::Yes &&
-        target->TemporarilyVisibleForScrolledIntoViewDescendant();
     // Steps 2.10 - 2.15.
-    if (target->UpdateIntersectionObservation(this, thresholdIndex) ||
-        temporarilyVisibleForScrolledIntoView) {
+    if (target->UpdateIntersectionObservation(this, thresholdIndex)) {
       // See https://github.com/w3c/IntersectionObserver/issues/432 about
       // why we use thresholdIndex > 0 rather than isIntersecting for the
       // entry's isIntersecting value.
@@ -821,10 +771,6 @@
           output.mIsSimilarOrigin ? Some(output.mRootBounds) : Nothing(),
           output.mTargetRect, output.mIntersectionRect, thresholdIndex > 0,
           intersectionRatio);
-
-      if (temporarilyVisibleForScrolledIntoView) {
-        target->SetTemporarilyVisibleForScrolledIntoViewDescendant(false);
-      }
     }
   }
 }