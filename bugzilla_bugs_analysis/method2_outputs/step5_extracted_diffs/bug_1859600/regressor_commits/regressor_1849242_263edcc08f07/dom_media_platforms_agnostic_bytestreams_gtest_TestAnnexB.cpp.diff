# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/agnostic/bytestreams/gtest/TestAnnexB.cpp
# Commit: 263edcc08f07
# Full Hash: 263edcc08f0766b68a76a2dbed5e7a765923952d
# Author: alwu <alwu@mozilla.com>
# Date: 2023-08-31 09:20:08
# Regressor Bug: 1849242
# File Overlap Count: 1
# Description:
#   Bug 1849242 - part2 : add HVCCConfig to access box's attributes easily. r=media-playback-reviewers,padenot
#   
#   Instead of directly accessing `mExtraData`, parsing them into a new
#   config class would be clearer.
#   
# ==============================================================================

diff -r fcaa03e6a475 -r 263edcc08f07 dom/media/platforms/agnostic/bytestreams/gtest/TestAnnexB.cpp
--- a/dom/media/platforms/agnostic/bytestreams/gtest/TestAnnexB.cpp	Wed Aug 30 17:52:44 2023 +0000
+++ b/dom/media/platforms/agnostic/bytestreams/gtest/TestAnnexB.cpp	Wed Aug 30 17:52:44 2023 +0000
@@ -9,6 +9,7 @@
 #include "AnnexB.h"
 #include "ByteWriter.h"
 #include "H264.h"
+#include "H265.h"
 
 namespace mozilla {
 
@@ -200,4 +201,117 @@
   }
 }
 
+TEST(H265, HVCCParsingSuccess)
+{
+  auto extradata = MakeRefPtr<mozilla::MediaByteBuffer>();
+  uint8_t hvccBytesBuffer[] = {
+      1 /* version */,
+      1 /* general_profile_space/general_tier_flag/general_profile_idc */,
+      0x60 /* general_profile_compatibility_flags 1/4 */,
+      0 /* general_profile_compatibility_flags 2/4 */,
+      0 /* general_profile_compatibility_flags 3/4 */,
+      0 /* general_profile_compatibility_flags 4/4 */,
+      0x90 /* general_constraint_indicator_flags 1/6 */,
+      0 /* general_constraint_indicator_flags 2/6 */,
+      0 /* general_constraint_indicator_flags 3/6 */,
+      0 /* general_constraint_indicator_flags 4/6 */,
+      0 /* general_constraint_indicator_flags 5/6 */,
+      0 /* general_constraint_indicator_flags 6/6 */,
+      0x5A /* general_level_idc */,
+      0 /* min_spatial_segmentation_idc 1/2 */,
+      0 /* min_spatial_segmentation_idc 2/2 */,
+      0 /* parallelismType */,
+      1 /* chroma_format_idc */,
+      0 /* bit_depth_luma_minus8 */,
+      0 /* bit_depth_chroma_minus8 */,
+      0 /* avgFrameRate 1/2 */,
+      0 /* avgFrameRate 2/2 */,
+      0x0F /* constantFrameRate/numTemporalLayers/temporalIdNested/lengthSizeMinusOne
+            */
+      ,
+      0 /* numOfArrays */,
+  };
+  extradata->AppendElements(hvccBytesBuffer, ArrayLength(hvccBytesBuffer));
+  auto rv = HVCCConfig::Parse(extradata);
+  EXPECT_TRUE(rv.isOk());
+  auto hvcc = rv.unwrap();
+  EXPECT_EQ(hvcc.mConfigurationVersion, 1);
+  EXPECT_EQ(hvcc.mGeneralProfileSpace, 0);
+  EXPECT_EQ(hvcc.mGeneralTierFlag, false);
+  EXPECT_EQ(hvcc.mGeneralProfileIdc, 1);
+  EXPECT_EQ(hvcc.mGeneralProfileCompatibilityFlags, (uint32_t)0x60000000);
+  EXPECT_EQ(hvcc.mGeneralConstraintIndicatorFlags, (uint64_t)0x900000000000);
+  EXPECT_EQ(hvcc.mGeneralLevelIdc, 0x5A);
+  EXPECT_EQ(hvcc.mMinSpatialSegmentationIdc, 0);
+  EXPECT_EQ(hvcc.mParallelismType, 0);
+  EXPECT_EQ(hvcc.mChromaFormatIdc, 1);
+  EXPECT_EQ(hvcc.mBitDepthLumaMinus8, 0);
+  EXPECT_EQ(hvcc.mBitDepthChromaMinus8, 0);
+  EXPECT_EQ(hvcc.mAvgFrameRate, 0);
+  EXPECT_EQ(hvcc.mConstantFrameRate, 0);
+  EXPECT_EQ(hvcc.mNumTemporalLayers, 1);
+  EXPECT_EQ(hvcc.mTemporalIdNested, true);
+  EXPECT_EQ(hvcc.NALUSize(), 4);
+}
+
+TEST(H265, HVCCParsingFailure)
+{
+  {
+    // Incorrect version
+    auto extradata = MakeRefPtr<mozilla::MediaByteBuffer>();
+    uint8_t hvccBytesBuffer[] = {
+        2 /* version */,
+        1 /* general_profile_space/general_tier_flag/general_profile_idc */,
+        0x60 /* general_profile_compatibility_flags 1/4 */,
+        0 /* general_profile_compatibility_flags 2/4 */,
+        0 /* general_profile_compatibility_flags 3/4 */,
+        0 /* general_profile_compatibility_flags 4/4 */,
+        0x90 /* general_constraint_indicator_flags 1/6 */,
+        0 /* general_constraint_indicator_flags 2/6 */,
+        0 /* general_constraint_indicator_flags 3/6 */,
+        0 /* general_constraint_indicator_flags 4/6 */,
+        0 /* general_constraint_indicator_flags 5/6 */,
+        0 /* general_constraint_indicator_flags 6/6 */,
+        0x5A /* general_level_idc */,
+        0 /* min_spatial_segmentation_idc 1/2 */,
+        0 /* min_spatial_segmentation_idc 2/2 */,
+        0 /* parallelismType */,
+        1 /* chroma_format_idc */,
+        0 /* bit_depth_luma_minus8 */,
+        0 /* bit_depth_chroma_minus8 */,
+        0 /* avgFrameRate 1/2 */,
+        0 /* avgFrameRate 2/2 */,
+        0x0F /* constantFrameRate/numTemporalLayers/temporalIdNested/lengthSizeMinusOne
+              */
+        ,
+        0 /* numOfArrays */,
+    };
+    extradata->AppendElements(hvccBytesBuffer, ArrayLength(hvccBytesBuffer));
+    auto avcc = HVCCConfig::Parse(extradata);
+    EXPECT_TRUE(avcc.isErr());
+  }
+  {
+    // Insuffient data
+    auto extradata = MakeRefPtr<mozilla::MediaByteBuffer>();
+    uint8_t hvccBytesBuffer[] = {
+        1 /* version */,
+        1 /* general_profile_space/general_tier_flag/general_profile_idc */,
+        0x60 /* general_profile_compatibility_flags 1/4 */,
+        0 /* general_profile_compatibility_flags 2/4 */,
+        0 /* general_profile_compatibility_flags 3/4 */,
+        0 /* general_profile_compatibility_flags 4/4 */,
+        0x90 /* general_constraint_indicator_flags 1/6 */,
+        0 /* general_constraint_indicator_flags 2/6 */,
+        0 /* general_constraint_indicator_flags 3/6 */,
+        0 /* general_constraint_indicator_flags 4/6 */,
+        0 /* general_constraint_indicator_flags 5/6 */,
+        0 /* general_constraint_indicator_flags 6/6 */,
+        0x5A /* general_level_idc */
+    };
+    extradata->AppendElements(hvccBytesBuffer, ArrayLength(hvccBytesBuffer));
+    auto avcc = HVCCConfig::Parse(extradata);
+    EXPECT_TRUE(avcc.isErr());
+  }
+}
+
 }  // namespace mozilla