# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webgpu/Device.cpp
# Commit: f214290956c1
# Full Hash: f214290956c1c17ab7da33be0868521198ad3112
# Author: Brad Werth <bwerth@mozilla.com>
# Date: 2023-10-17 03:58:35
# Regressor Bug: 1838693
# File Overlap Count: 2
# Description:
#   Bug 1838693 Part 2: Rationalize GPUDevice lost promise handling. r=webgpu-reviewers,nical
#   
#   This ensures that both internal and external triggers of "lose the
#   device" resolve the lost promise using the same code path.
#   
# ==============================================================================

diff -r 843c7d19787b -r f214290956c1 dom/webgpu/Device.cpp
--- a/dom/webgpu/Device.cpp	Mon Oct 16 15:31:59 2023 +0000
+++ b/dom/webgpu/Device.cpp	Mon Oct 16 15:32:00 2023 +0000
@@ -69,14 +69,6 @@
   if (mBridge) {
     mBridge->UnregisterDevice(mId);
   }
-
-  // Cycle collection may have disconnected the promise object.
-  if (mLostPromise && mLostPromise->PromiseObj() != nullptr) {
-    auto info = MakeRefPtr<DeviceLostInfo>(GetParentObject(),
-                                           dom::GPUDeviceLostReason::Destroyed,
-                                           u"Device destroyed"_ns);
-    mLostPromise->MaybeResolve(info);
-  }
 }
 
 void Device::CleanupUnregisteredInParent() {
@@ -86,13 +78,19 @@
   mValid = false;
 }
 
-bool Device::IsLost() const { return !mBridge || !mBridge->CanSend(); }
+bool Device::IsLost() const {
+  return !mBridge || !mBridge->CanSend() ||
+         (mLostPromise &&
+          (mLostPromise->State() != dom::Promise::PromiseState::Pending));
+}
+
+bool Device::IsBridgeAlive() const { return mBridge && mBridge->CanSend(); }
 
 // Generate an error on the Device timeline for this device.
 //
 // aMessage is interpreted as UTF-8.
 void Device::GenerateValidationError(const nsCString& aMessage) {
-  if (IsLost()) {
+  if (!IsBridgeAlive()) {
     return;  // Just drop it?
   }
   mBridge->SendGenerateError(Some(mId), dom::GPUErrorFilter::Validation,
@@ -116,8 +114,28 @@
 
 void Device::ResolveLost(Maybe<dom::GPUDeviceLostReason> aReason,
                          const nsAString& aMessage) {
-  // TODO(BJW): rationalize this with all the other stuff that deals with
-  // the mLostPromise.
+  ErrorResult rv;
+  dom::Promise* lostPromise = GetLost(rv);
+  if (!lostPromise) {
+    // Promise doesn't exist? Maybe out of memory.
+    return;
+  }
+  if (lostPromise->State() != dom::Promise::PromiseState::Pending) {
+    // lostPromise was already resolved or rejected.
+    return;
+  }
+  if (!lostPromise->PromiseObj()) {
+    // The underlying JS object is gone.
+    return;
+  }
+
+  RefPtr<DeviceLostInfo> info;
+  if (aReason.isSome()) {
+    info = MakeRefPtr<DeviceLostInfo>(GetParentObject(), *aReason, aMessage);
+  } else {
+    info = MakeRefPtr<DeviceLostInfo>(GetParentObject(), aMessage);
+  }
+  lostPromise->MaybeResolve(info);
 }
 
 already_AddRefed<Buffer> Device::CreateBuffer(
@@ -344,7 +362,7 @@
 }
 
 void Device::PushErrorScope(const dom::GPUErrorFilter& aFilter) {
-  if (IsLost()) {
+  if (!IsBridgeAlive()) {
     return;
   }
   mBridge->SendDevicePushErrorScope(mId, aFilter);
@@ -363,7 +381,7 @@
     return nullptr;
   }
 
-  if (IsLost()) {
+  if (!IsBridgeAlive()) {
     WebGPUChild::JsWarning(
         GetOwnerGlobal(),
         "popErrorScope resolving to null because device is already lost."_ns);