# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/agnostic/bytestreams/AnnexB.cpp
# Commit: fd44d547e093
# Full Hash: fd44d547e0931ddcb25e9dde2691ad9e99ec2e05
# Author: alwu <alwu@mozilla.com>
# Date: 2023-10-26 09:13:45
# Description:
#   Bug 1860840 - return error for invalid hvcc config when converting sample. r=media-playback-reviewers,padenot
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D191794
# ==============================================================================

diff -r 691148c77012 -r fd44d547e093 dom/media/platforms/agnostic/bytestreams/AnnexB.cpp
--- a/dom/media/platforms/agnostic/bytestreams/AnnexB.cpp	Wed Oct 25 21:14:33 2023 +0300
+++ b/dom/media/platforms/agnostic/bytestreams/AnnexB.cpp	Wed Oct 25 17:10:46 2023 +0000
@@ -457,33 +457,36 @@
 }
 
 /* static */
-bool AnnexB::ConvertSampleToHVCC(mozilla::MediaRawData* aSample) {
+Result<mozilla::Ok, nsresult> AnnexB::ConvertSampleToHVCC(
+    mozilla::MediaRawData* aSample) {
   if (IsHVCC(aSample)) {
-    return ConvertHVCCTo4BytesHVCC(aSample).isOk();
+    return ConvertHVCCTo4BytesHVCC(aSample);
   }
   if (!IsAnnexB(aSample)) {
     // Not AnnexB, nothing to convert.
-    return true;
+    return Ok();
   }
 
   nsTArray<uint8_t> nalu;
   ByteWriter<BigEndian> writer(nalu);
   BufferReader reader(aSample->Data(), aSample->Size());
-  if (ParseNALUnits(writer, reader).isErr()) {
+  if (auto rv = ParseNALUnits(writer, reader); rv.isErr()) {
     LOG("Failed fo parse AnnexB NALU for HVCC");
-    return false;
+    return rv;
   }
   UniquePtr<MediaRawDataWriter> samplewriter(aSample->CreateWriter());
   if (!samplewriter->Replace(nalu.Elements(), nalu.Length())) {
     LOG("Failed fo replace NALU");
-    return false;
+    return Err(NS_ERROR_OUT_OF_MEMORY);
   }
-  MOZ_DIAGNOSTIC_ASSERT_IF(aSample->mExtraData,
-                           HVCCConfig::Parse(aSample).isOk());
+  if (aSample->mExtraData && HVCCConfig::Parse(aSample).isErr()) {
+    LOG("Failed to parse invalid hvcc extradata");
+    return Err(NS_ERROR_DOM_MEDIA_METADATA_ERR);
+  }
   // TODO : currently we don't set the fake header because we expect the sample
   // already has a valid extradata. (set by the media change monitor) We can
   // support setting a specific/fake header if we want to support HEVC encoding.
-  return true;
+  return Ok();
 }
 
 /* static */