# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/agnostic/bytestreams/gtest/TestByteStreams.cpp
# Commit: 412f97da1656
# Full Hash: 412f97da16567da3a0c2a6adc6dbde27a28dea22
# Author: alwu <alwu@mozilla.com>
# Date: 2023-10-11 09:22:03
# Regressor Bug: 1852333
# File Overlap Count: 4
# Description:
#   Bug 1852333 - part2 : detect config change for HEVC stream. r=media-playback-reviewers,padenot
#   
#   This patch detects inband change for the HEVC playback so that we can
#   recreate decoder if the new config is different from the previous one.
#   
# ==============================================================================

diff -r b15b2e7c785a -r 412f97da1656 dom/media/platforms/agnostic/bytestreams/gtest/TestByteStreams.cpp
--- a/dom/media/platforms/agnostic/bytestreams/gtest/TestByteStreams.cpp	Wed Oct 11 00:57:39 2023 +0000
+++ b/dom/media/platforms/agnostic/bytestreams/gtest/TestByteStreams.cpp	Wed Oct 11 00:57:40 2023 +0000
@@ -11,6 +11,7 @@
 #include "ByteWriter.h"
 #include "H264.h"
 #include "H265.h"
+#include "mozilla/Types.h"
 
 namespace mozilla {
 
@@ -54,6 +55,62 @@
   return rawData.forget();
 }
 
+static const uint8_t sHvccBytesBuffer[] = {
+    1 /* version */,
+    1 /* general_profile_space/general_tier_flag/general_profile_idc */,
+    0x60 /* general_profile_compatibility_flags 1/4 */,
+    0 /* general_profile_compatibility_flags 2/4 */,
+    0 /* general_profile_compatibility_flags 3/4 */,
+    0 /* general_profile_compatibility_flags 4/4 */,
+    0x90 /* general_constraint_indicator_flags 1/6 */,
+    0 /* general_constraint_indicator_flags 2/6 */,
+    0 /* general_constraint_indicator_flags 3/6 */,
+    0 /* general_constraint_indicator_flags 4/6 */,
+    0 /* general_constraint_indicator_flags 5/6 */,
+    0 /* general_constraint_indicator_flags 6/6 */,
+    0x5A /* general_level_idc */,
+    0 /* min_spatial_segmentation_idc 1/2 */,
+    0 /* min_spatial_segmentation_idc 2/2 */,
+    0 /* parallelismType */,
+    1 /* chroma_format_idc */,
+    0 /* bit_depth_luma_minus8 */,
+    0 /* bit_depth_chroma_minus8 */,
+    0 /* avgFrameRate 1/2 */,
+    0 /* avgFrameRate 2/2 */,
+    0x0F /* constantFrameRate/numTemporalLayers/temporalIdNested/lengthSizeMinusOne
+          */
+    ,
+    2 /* numOfArrays */,
+    /* SPS Array */
+    0x21 /* NAL_unit_type (SPS) */,
+    0 /* numNalus 1/2 */,
+    1 /* numNalus 2/2 */,
+
+    /* SPS */
+    0 /* nalUnitLength 1/2 */,
+    8 /* nalUnitLength 2/2 (header + rsbp) */,
+    0x42 /* NALU header 1/2 */,
+    0 /* NALU header 2/2 */,
+    0 /* rbsp 1/6 */,
+    0 /* rbsp 2/6 */,
+    0 /* rbsp 3/6 */,
+    0 /* rbsp 4/6 */,
+    0 /* rbsp 5/6 */,
+    0 /* rbsp 6/6 */,
+
+    /* PPS Array */
+    0x22 /* NAL_unit_type (PPS) */,
+    0 /* numNalus 1/2 */,
+    1 /* numNalus 2/2 */,
+
+    /* PPS */
+    0 /* nalUnitLength 1/2 */,
+    3 /* nalUnitLength 2/2 (header + rsbp) */,
+    0x44 /* NALU header 1/2 */,
+    0 /* NALU header 2/2 */,
+    0 /* rbsp */,
+};
+
 // Create a HVCC sample, which contain fake data, in given size.
 static already_AddRefed<MediaRawData> GetHVCCSample(uint32_t aSampleSize) {
   if (aSampleSize < 4) {
@@ -61,62 +118,7 @@
     EXPECT_FALSE(true) << "Samples should be requested with sane sizes";
   }
   auto extradata = MakeRefPtr<mozilla::MediaByteBuffer>();
-  uint8_t hvccBytesBuffer[] = {
-      1 /* version */,
-      1 /* general_profile_space/general_tier_flag/general_profile_idc */,
-      0x60 /* general_profile_compatibility_flags 1/4 */,
-      0 /* general_profile_compatibility_flags 2/4 */,
-      0 /* general_profile_compatibility_flags 3/4 */,
-      0 /* general_profile_compatibility_flags 4/4 */,
-      0x90 /* general_constraint_indicator_flags 1/6 */,
-      0 /* general_constraint_indicator_flags 2/6 */,
-      0 /* general_constraint_indicator_flags 3/6 */,
-      0 /* general_constraint_indicator_flags 4/6 */,
-      0 /* general_constraint_indicator_flags 5/6 */,
-      0 /* general_constraint_indicator_flags 6/6 */,
-      0x5A /* general_level_idc */,
-      0 /* min_spatial_segmentation_idc 1/2 */,
-      0 /* min_spatial_segmentation_idc 2/2 */,
-      0 /* parallelismType */,
-      1 /* chroma_format_idc */,
-      0 /* bit_depth_luma_minus8 */,
-      0 /* bit_depth_chroma_minus8 */,
-      0 /* avgFrameRate 1/2 */,
-      0 /* avgFrameRate 2/2 */,
-      0x0F /* constantFrameRate/numTemporalLayers/temporalIdNested/lengthSizeMinusOne
-            */
-      ,
-      2 /* numOfArrays */,
-      /* SPS Array */
-      0x21 /* NAL_unit_type (SPS) */,
-      0 /* numNalus 1/2 */,
-      1 /* numNalus 2/2 */,
-
-      /* SPS */
-      0 /* nalUnitLength 1/2 */,
-      8 /* nalUnitLength 2/2 (header + rsbp) */,
-      0x42 /* NALU header 1/2 */,
-      0 /* NALU header 2/2 */,
-      0 /* rbsp 1/6 */,
-      0 /* rbsp 2/6 */,
-      0 /* rbsp 3/6 */,
-      0 /* rbsp 4/6 */,
-      0 /* rbsp 5/6 */,
-      0 /* rbsp 6/6 */,
-
-      /* PPS Array */
-      0x22 /* NAL_unit_type (PPS) */,
-      0 /* numNalus 1/2 */,
-      1 /* numNalus 2/2 */,
-
-      /* PPS */
-      0 /* nalUnitLength 1/2 */,
-      3 /* nalUnitLength 2/2 (header + rsbp) */,
-      0x44 /* NALU header 1/2 */,
-      0 /* NALU header 2/2 */,
-      0 /* rbsp */,
-  };
-  extradata->AppendElements(hvccBytesBuffer, ArrayLength(hvccBytesBuffer));
+  extradata->AppendElements(sHvccBytesBuffer, ArrayLength(sHvccBytesBuffer));
 
   // Write the NAL size.
   nsTArray<uint8_t> sampleData;
@@ -135,6 +137,30 @@
   return rawData.forget();
 }
 
+// Create a HVCC sample by using given data in given size.
+static already_AddRefed<MediaRawData> GetHVCCSample(
+    const uint8_t* aData, const uint32_t aDataLength) {
+  if (aDataLength < 4) {
+    // Stop tests asking for insane samples.
+    EXPECT_FALSE(true) << "Samples should be requested with sane sizes";
+  }
+  auto extradata = MakeRefPtr<mozilla::MediaByteBuffer>();
+  extradata->AppendElements(sHvccBytesBuffer, ArrayLength(sHvccBytesBuffer));
+
+  // Write the NAL size.
+  nsTArray<uint8_t> sampleData;
+  ByteWriter<BigEndian> writer(sampleData);
+  EXPECT_TRUE(writer.WriteU32(aDataLength));  // Assume it's a 4 bytes NALU
+  sampleData.AppendElements(aData, aDataLength);
+
+  RefPtr<MediaRawData> rawData =
+      new MediaRawData{sampleData.Elements(), sampleData.Length()};
+  EXPECT_NE(rawData->Data(), nullptr);
+  EXPECT_EQ(rawData->Size(), aDataLength + 4);
+  rawData->mExtraData = extradata;
+  return rawData.forget();
+}
+
 // Test that conversion from AVCC to AnnexB works as expected.
 TEST(AnnexB, AVCCToAnnexBConversion)
 {
@@ -658,4 +684,104 @@
   EXPECT_EQ(pps.mNALU.Length(), 3u);
 }
 
+TEST(H265, AnnexBToHVCC)
+{
+  RefPtr<MediaRawData> rawData{GetHVCCSample(128)};
+  RefPtr<MediaRawData> rawDataClone = rawData->Clone();
+  Result<Ok, nsresult> result =
+      AnnexB::ConvertHVCCSampleToAnnexB(rawDataClone, /* aAddSps */ false);
+  EXPECT_TRUE(result.isOk()) << "HVCC to AnnexB Conversion should succeed";
+  EXPECT_TRUE(AnnexB::IsAnnexB(rawDataClone))
+      << "The sample should be AnnexB following conversion";
+
+  auto rv = AnnexB::ConvertSampleToHVCC(rawDataClone);
+  EXPECT_TRUE(rv) << "AnnexB to HVCC Conversion should succeed";
+  EXPECT_TRUE(AnnexB::IsHVCC(rawDataClone))
+      << "The sample should be HVCC following conversion";
+}
+
+// This is SPS from 'hevc_white_frame.mp4'
+static const uint8_t sSps[] = {
+    0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00,
+    0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5d, 0xa0, 0x02, 0x00, 0x80,
+    0x30, 0x16, 0x59, 0x59, 0xa4, 0x93, 0x2b, 0xc0, 0x5a, 0x02, 0x00,
+    0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x3c, 0x10};
+
+TEST(H265, ExtractHVCCExtraData)
+{
+  RefPtr<MediaRawData> rawData{GetHVCCSample(sSps, ArrayLength(sSps))};
+  RefPtr<MediaByteBuffer> extradata = H265::ExtractHVCCExtraData(rawData);
+  EXPECT_TRUE(extradata);
+  auto rv = HVCCConfig::Parse(extradata);
+  EXPECT_TRUE(rv.isOk());
+  auto hvcc = rv.unwrap();
+  EXPECT_EQ(hvcc.mNALUs.Length(), 1u);
+  EXPECT_EQ(hvcc.mNALUs[0].mNalUnitType, H265NALU::NAL_TYPES::SPS_NUT);
+  EXPECT_EQ(hvcc.mNALUs[0].mNuhLayerId, 0u);
+  EXPECT_EQ(hvcc.mNALUs[0].mNuhTemporalIdPlus1, 1);
+  EXPECT_EQ(hvcc.mNALUs[0].IsSPS(), true);
+  EXPECT_EQ(hvcc.mNALUs[0].mNALU.Length(), 43u);
+}
+
+TEST(H265, DecodeSPSFromSPSNALU)
+{
+  H265NALU nalu{sSps, ArrayLength(sSps)};
+  auto rv = H265::DecodeSPSFromSPSNALU(nalu);
+  EXPECT_TRUE(rv.isOk());
+  auto sps = rv.unwrap();
+  // Examine the value by using HEVCESBrowser.
+  EXPECT_EQ(sps.sps_video_parameter_set_id, 0u);
+  EXPECT_EQ(sps.sps_max_sub_layers_minus1, 0u);
+  EXPECT_EQ(sps.sps_temporal_id_nesting_flag, 1);
+  EXPECT_EQ(sps.profile_tier_level.general_profile_space, 0u);
+  EXPECT_EQ(sps.profile_tier_level.general_tier_flag, false);
+  EXPECT_EQ(sps.profile_tier_level.general_profile_idc, 1u);
+  EXPECT_EQ(sps.profile_tier_level.general_profile_compatibility_flags,
+            0x60000000u);
+  EXPECT_EQ(sps.profile_tier_level.general_progressive_source_flag, true);
+  EXPECT_EQ(sps.profile_tier_level.general_interlaced_source_flag, false);
+  EXPECT_EQ(sps.profile_tier_level.general_non_packed_constraint_flag, false);
+  EXPECT_EQ(sps.profile_tier_level.general_frame_only_constraint_flag, true);
+  EXPECT_EQ(sps.profile_tier_level.general_level_idc, 93u);
+  EXPECT_EQ(sps.sps_seq_parameter_set_id, 0u);
+  EXPECT_EQ(sps.chroma_format_idc, 1u);
+  EXPECT_EQ(sps.separate_colour_plane_flag, false);
+  EXPECT_EQ(sps.pic_width_in_luma_samples, 1024u);
+  EXPECT_EQ(sps.pic_height_in_luma_samples, 768u);
+  EXPECT_EQ(sps.conformance_window_flag, false);
+  EXPECT_EQ(sps.bit_depth_luma_minus8, 0u);
+  EXPECT_EQ(sps.bit_depth_chroma_minus8, 0u);
+  EXPECT_EQ(sps.log2_max_pic_order_cnt_lsb_minus4, 4u);
+  EXPECT_EQ(sps.sps_sub_layer_ordering_info_present_flag, true);
+  EXPECT_EQ(sps.sps_max_dec_pic_buffering_minus1[0], 4u);
+  EXPECT_EQ(sps.sps_max_num_reorder_pics[0], 2u);
+  EXPECT_EQ(sps.sps_max_latency_increase_plus1[0], 5u);
+  EXPECT_EQ(sps.log2_min_luma_coding_block_size_minus3, 0u);
+  EXPECT_EQ(sps.log2_diff_max_min_luma_coding_block_size, 3u);
+  EXPECT_EQ(sps.log2_min_luma_transform_block_size_minus2, 0u);
+  EXPECT_EQ(sps.log2_diff_max_min_luma_transform_block_size, 3u);
+  EXPECT_EQ(sps.max_transform_hierarchy_depth_inter, 0u);
+  EXPECT_EQ(sps.max_transform_hierarchy_depth_inter, 0u);
+  EXPECT_EQ(sps.pcm_enabled_flag, false);
+  EXPECT_EQ(sps.num_short_term_ref_pic_sets, 0u);
+  EXPECT_EQ(sps.sps_temporal_mvp_enabled_flag, true);
+  EXPECT_EQ(sps.strong_intra_smoothing_enabled_flag, true);
+  EXPECT_TRUE(sps.vui_parameters);
+  EXPECT_EQ(sps.vui_parameters->video_full_range_flag, false);
+
+  // Test public methods
+  EXPECT_EQ(sps.BitDepthLuma(), 8u);
+  EXPECT_EQ(sps.BitDepthChroma(), 8u);
+  const auto imgSize = sps.GetImageSize();
+  EXPECT_EQ(imgSize.Width(), 1024);
+  EXPECT_EQ(imgSize.Height(), 768);
+  const auto disSize = sps.GetDisplaySize();
+  EXPECT_EQ(disSize, imgSize);
+  EXPECT_EQ(sps.ColorDepth(), gfx::ColorDepth::COLOR_8);
+  EXPECT_EQ(sps.ColorSpace(), gfx::YUVColorSpace::BT709);
+  EXPECT_EQ(sps.IsFullColorRange(), false);
+  EXPECT_EQ(sps.ColorPrimaries(), 2u);
+  EXPECT_EQ(sps.TransferFunction(), 2u);
+}
+
 }  // namespace mozilla