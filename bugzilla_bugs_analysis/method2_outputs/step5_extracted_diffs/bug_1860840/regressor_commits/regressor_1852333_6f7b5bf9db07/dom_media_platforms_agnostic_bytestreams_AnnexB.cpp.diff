# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/platforms/agnostic/bytestreams/AnnexB.cpp
# Commit: 6f7b5bf9db07
# Full Hash: 6f7b5bf9db07f4b0e5ff088257b10772f1486340
# Author: alwu <alwu@mozilla.com>
# Date: 2023-10-06 15:27:33
# Regressor Bug: 1852333
# File Overlap Count: 4
# Description:
#   Bug 1852333 - part2 : detect config change for HEVC stream. r=media-playback-reviewers,padenot
#   
#   This patch detects inband change for the HEVC playback so that we can
#   recreate decoder if the new config is different from the previous one.
#   
# ==============================================================================

diff -r 1de872081cfc -r 6f7b5bf9db07 dom/media/platforms/agnostic/bytestreams/AnnexB.cpp
--- a/dom/media/platforms/agnostic/bytestreams/AnnexB.cpp	Thu Oct 05 21:07:14 2023 +0000
+++ b/dom/media/platforms/agnostic/bytestreams/AnnexB.cpp	Thu Oct 05 21:07:15 2023 +0000
@@ -457,6 +457,36 @@
 }
 
 /* static */
+bool AnnexB::ConvertSampleToHVCC(mozilla::MediaRawData* aSample) {
+  if (IsHVCC(aSample)) {
+    return ConvertHVCCTo4BytesHVCC(aSample).isOk();
+  }
+  if (!IsAnnexB(aSample)) {
+    // Not AnnexB, nothing to convert.
+    return true;
+  }
+
+  nsTArray<uint8_t> nalu;
+  ByteWriter<BigEndian> writer(nalu);
+  BufferReader reader(aSample->Data(), aSample->Size());
+  if (ParseNALUnits(writer, reader).isErr()) {
+    LOG("Failed fo parse AnnexB NALU for HVCC");
+    return false;
+  }
+  UniquePtr<MediaRawDataWriter> samplewriter(aSample->CreateWriter());
+  if (!samplewriter->Replace(nalu.Elements(), nalu.Length())) {
+    LOG("Failed fo replace NALU");
+    return false;
+  }
+  MOZ_DIAGNOSTIC_ASSERT_IF(aSample->mExtraData,
+                           HVCCConfig::Parse(aSample).isOk());
+  // TODO : currently we don't set the fake header because we expect the sample
+  // already has a valid extradata. (set by the media change monitor) We can
+  // support setting a specific/fake header if we want to support HEVC encoding.
+  return true;
+}
+
+/* static */
 Result<mozilla::Ok, nsresult> AnnexB::ConvertAVCCTo4BytesAVCC(
     mozilla::MediaRawData* aSample) {
   auto avcc = AVCCConfig::Parse(aSample);