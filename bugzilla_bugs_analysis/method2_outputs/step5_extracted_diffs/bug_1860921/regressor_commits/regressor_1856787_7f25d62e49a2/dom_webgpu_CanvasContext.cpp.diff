# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webgpu/CanvasContext.cpp
# Commit: 7f25d62e49a2
# Full Hash: 7f25d62e49a2325004433386f09955d3c2f64c3c
# Author: sotaro <sotaro.ikeda.g@gmail.com>
# Date: 2023-10-24 09:38:27
# Regressor Bug: 1856787
# File Overlap Count: 2
# Description:
#   Bug 1856787 - Add a capability to present WebGPU without readback on Windows r=webgpu-reviewers,nical
#   
#   For presenting WebGPU without readback, wgpu does rendering to ExternalTexture. Then the ExternalTexture is pushed to RemoteTextureMap for present.
#   
#   With DX12, ExternalTextureD3D11 is implemented for gecko side implementation. ExternalTextureWgpu holds necessary resource that is necessary by wgpu. ExternalTextureWgpu is created and destroyed by gecko side's ExternalTexture.
# ==============================================================================

diff -r ed56525c65bc -r 7f25d62e49a2 dom/webgpu/CanvasContext.cpp
--- a/dom/webgpu/CanvasContext.cpp	Tue Oct 24 03:54:42 2023 +0000
+++ b/dom/webgpu/CanvasContext.cpp	Tue Oct 24 04:04:07 2023 +0000
@@ -121,9 +121,9 @@
       wgpu_client_use_external_texture_in_swapChain(
           aConfig.mDevice->mId,
           WebGPUChild::ConvertTextureFormat(aConfig.mFormat));
-  mTexture = aConfig.mDevice->InitSwapChain(aConfig, *mRemoteTextureOwnerId,
-                                            mUseExternalTextureInSwapChain,
-                                            mGfxFormat, mCanvasSize);
+  mTexture = aConfig.mDevice->InitSwapChain(
+      mConfig.get(), mRemoteTextureOwnerId.ref(),
+      mUseExternalTextureInSwapChain, mGfxFormat, mCanvasSize);
   if (!mTexture) {
     Unconfigure();
     return;
@@ -166,6 +166,17 @@
     aRv.ThrowOperationError("Canvas not configured");
     return nullptr;
   }
+
+  MOZ_ASSERT(mConfig);
+  MOZ_ASSERT(mRemoteTextureOwnerId.isSome());
+
+  if (mNewTextureRequested) {
+    mNewTextureRequested = false;
+
+    mTexture = mConfig->mDevice->CreateTextureForSwapChain(
+        mConfig.get(), mCanvasSize, mRemoteTextureOwnerId.ref());
+    mTexture->mTargetContext = this;
+  }
   return mTexture;
 }
 
@@ -189,6 +200,10 @@
   mLastRemoteTextureId = Some(layers::RemoteTextureId::GetNext());
   mBridge->SwapChainPresent(mTexture->mId, *mLastRemoteTextureId,
                             *mRemoteTextureOwnerId);
+  if (mUseExternalTextureInSwapChain) {
+    mTexture->Destroy();
+    mNewTextureRequested = true;
+  }
 }
 
 bool CanvasContext::UpdateWebRenderCanvasData(