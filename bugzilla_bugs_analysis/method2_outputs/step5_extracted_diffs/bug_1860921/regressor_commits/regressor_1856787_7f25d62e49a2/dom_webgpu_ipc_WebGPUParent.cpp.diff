# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webgpu/ipc/WebGPUParent.cpp
# Commit: 7f25d62e49a2
# Full Hash: 7f25d62e49a2325004433386f09955d3c2f64c3c
# Author: sotaro <sotaro.ikeda.g@gmail.com>
# Date: 2023-10-24 09:38:27
# Regressor Bug: 1856787
# File Overlap Count: 2
# Description:
#   Bug 1856787 - Add a capability to present WebGPU without readback on Windows r=webgpu-reviewers,nical
#   
#   For presenting WebGPU without readback, wgpu does rendering to ExternalTexture. Then the ExternalTexture is pushed to RemoteTextureMap for present.
#   
#   With DX12, ExternalTextureD3D11 is implemented for gecko side implementation. ExternalTextureWgpu holds necessary resource that is necessary by wgpu. ExternalTextureWgpu is created and destroyed by gecko side's ExternalTexture.
# ==============================================================================

diff -r ed56525c65bc -r 7f25d62e49a2 dom/webgpu/ipc/WebGPUParent.cpp
--- a/dom/webgpu/ipc/WebGPUParent.cpp	Tue Oct 24 03:54:42 2023 +0000
+++ b/dom/webgpu/ipc/WebGPUParent.cpp	Tue Oct 24 04:04:07 2023 +0000
@@ -10,6 +10,7 @@
 #include "mozilla/layers/CompositorThread.h"
 #include "mozilla/layers/ImageDataSerializer.h"
 #include "mozilla/layers/RemoteTextureMap.h"
+#include "mozilla/layers/TextureClientSharedSurface.h"
 #include "mozilla/layers/TextureHost.h"
 #include "mozilla/layers/WebRenderImageHost.h"
 #include "mozilla/layers/WebRenderTextureHost.h"
@@ -31,26 +32,25 @@
   return parent->UseExternalTextureForSwapChain(aSwapChainId);
 }
 
-extern bool wgpu_server_create_external_texture_for_swap_chain(
+extern bool wgpu_server_ensure_external_texture_for_swap_chain(
     void* aParam, WGPUSwapChainId aSwapChainId, WGPUDeviceId aDeviceId,
     WGPUTextureId aTextureId, uint32_t aWidth, uint32_t aHeight,
     struct WGPUTextureFormat aFormat) {
   auto* parent = static_cast<WebGPUParent*>(aParam);
 
-  return parent->CreateExternalTextureForSwapChain(
+  return parent->EnsureExternalTextureForSwapChain(
       aSwapChainId, aDeviceId, aTextureId, aWidth, aHeight, aFormat);
 }
 
-extern void* wgpu_server_get_external_texture_handle(void* aParam,
-                                                     WGPUTextureId aId) {
+extern WGPUTextureRaw* wgpu_server_get_external_texture_raw(void* aParam,
+                                                            WGPUTextureId aId) {
   auto* parent = static_cast<WebGPUParent*>(aParam);
-
   auto externalTexture = parent->GetExternalTexture(aId);
   if (!externalTexture) {
     MOZ_ASSERT_UNREACHABLE("unexpected to be called");
     return nullptr;
   }
-  return externalTexture->GetExternalTextureHandle();
+  return externalTexture->GetTextureRaw();
 }
 
 }  // namespace ffi
@@ -144,6 +144,9 @@
   const RawId mDeviceId;
   const RawId mQueueId;
   const layers::RGBDescriptor mDesc;
+
+  std::deque<std::shared_ptr<ExternalTexture>> mRecycledExternalTextures;
+
   const uint32_t mSourcePitch;
   std::vector<RawId> mUnassignedBufferIds MOZ_GUARDED_BY(mBuffersLock);
   std::vector<RawId> mAvailableBufferIds MOZ_GUARDED_BY(mBuffersLock);
@@ -1034,6 +1037,41 @@
   return IPC_OK();
 }
 
+void WebGPUParent::PostExternalTexture(
+    const std::shared_ptr<ExternalTexture>&& aExternalTexture,
+    const layers::RemoteTextureId aRemoteTextureId,
+    const layers::RemoteTextureOwnerId aOwnerId) {
+  const auto& lookup = mPresentationDataMap.find(aOwnerId);
+  if (lookup == mPresentationDataMap.end() || !mRemoteTextureOwner ||
+      !mRemoteTextureOwner->IsRegistered(aOwnerId)) {
+    NS_WARNING("WebGPU presenting on a destroyed swap chain!");
+    return;
+  }
+
+  const auto surfaceFormat = gfx::SurfaceFormat::B8G8R8A8;
+  const auto size = aExternalTexture->GetSize();
+  Maybe<layers::SurfaceDescriptor> desc =
+      aExternalTexture->ToSurfaceDescriptor();
+  if (!desc) {
+    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+    return;
+  }
+
+  auto textureData =
+      MakeUnique<layers::SharedSurfaceTextureData>(*desc, surfaceFormat, size);
+
+  mRemoteTextureOwner->PushTexture(aRemoteTextureId, aOwnerId,
+                                   std::move(textureData), aExternalTexture);
+
+  RefPtr<PresentationData> data = lookup->second.get();
+
+  auto recycledTexture =
+      mRemoteTextureOwner->GetRecycledExternalTexture(aOwnerId);
+  if (recycledTexture) {
+    data->mRecycledExternalTextures.push_back(recycledTexture);
+  }
+}
+
 ipc::IPCResult WebGPUParent::RecvSwapChainPresent(
     RawId aTextureId, RawId aCommandEncoderId,
     const layers::RemoteTextureId& aRemoteTextureId,
@@ -1047,6 +1085,20 @@
   }
 
   RefPtr<PresentationData> data = lookup->second.get();
+
+  if (data->mUseExternalTextureInSwapChain) {
+    auto it = mExternalTextures.find(aTextureId);
+    if (it == mExternalTextures.end()) {
+      MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+      return IPC_OK();
+    }
+    std::shared_ptr<ExternalTexture> externalTexture = it->second;
+    mExternalTextures.erase(it);
+
+    PostExternalTexture(std::move(externalTexture), aRemoteTextureId, aOwnerId);
+    return IPC_OK();
+  }
+
   RawId bufferId = 0;
   const auto& size = data->mDesc.size();
   const auto bufferSize = data->mDesc.size().height * data->mSourcePitch;
@@ -1338,7 +1390,7 @@
   return data->mUseExternalTextureInSwapChain;
 }
 
-bool WebGPUParent::CreateExternalTextureForSwapChain(
+bool WebGPUParent::EnsureExternalTextureForSwapChain(
     ffi::WGPUSwapChainId aSwapChainId, ffi::WGPUDeviceId aDeviceId,
     ffi::WGPUTextureId aTextureId, uint32_t aWidth, uint32_t aHeight,
     struct ffi::WGPUTextureFormat aFormat) {
@@ -1355,6 +1407,20 @@
     return false;
   }
 
+  // Recycled ExternalTexture if it exists.
+  if (!data->mRecycledExternalTextures.empty()) {
+    std::shared_ptr<ExternalTexture> texture =
+        data->mRecycledExternalTextures.front();
+    // Check if the texture is recyclable.
+    if (texture->mWidth == aWidth && texture->mHeight == aHeight &&
+        texture->mFormat.tag == aFormat.tag) {
+      data->mRecycledExternalTextures.pop_front();
+      mExternalTextures.emplace(aTextureId, texture);
+      return true;
+    }
+    data->mRecycledExternalTextures.clear();
+  }
+
   auto externalTexture =
       CreateExternalTexture(aDeviceId, aTextureId, aWidth, aHeight, aFormat);
   if (!externalTexture) {
@@ -1372,11 +1438,28 @@
   UniquePtr<ExternalTexture> texture =
       ExternalTexture::Create(aWidth, aHeight, aFormat);
   if (!texture) {
+    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+    return nullptr;
+  }
+
+  auto* sharedHandle = texture->GetExternalTextureHandle();
+  if (!sharedHandle) {
+    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+    gfxCriticalNoteOnce << "Failed to get shared handle";
     return nullptr;
   }
 
+  auto* textureRaw = wgpu_server_create_external_texture_raw(
+      mContext.get(), aDeviceId, sharedHandle);
+  if (!textureRaw) {
+    MOZ_ASSERT_UNREACHABLE("unexpected to be called");
+    gfxCriticalNoteOnce << "Failed to create TextureRaw";
+    return nullptr;
+  }
+
+  texture->SetTextureRaw(textureRaw);
+
   std::shared_ptr<ExternalTexture> shared(texture.release());
-
   mExternalTextures.emplace(aTextureId, shared);
 
   return shared;