# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wgpu_bindings/src/server.rs
# Commit: 7f25d62e49a2
# Full Hash: 7f25d62e49a2325004433386f09955d3c2f64c3c
# Author: sotaro <sotaro.ikeda.g@gmail.com>
# Date: 2023-10-24 09:38:27
# Regressor Bug: 1856787
# File Overlap Count: 2
# Description:
#   Bug 1856787 - Add a capability to present WebGPU without readback on Windows r=webgpu-reviewers,nical
#   
#   For presenting WebGPU without readback, wgpu does rendering to ExternalTexture. Then the ExternalTexture is pushed to RemoteTextureMap for present.
#   
#   With DX12, ExternalTextureD3D11 is implemented for gecko side implementation. ExternalTextureWgpu holds necessary resource that is necessary by wgpu. ExternalTextureWgpu is created and destroyed by gecko side's ExternalTexture.
# ==============================================================================

diff -r ed56525c65bc -r 7f25d62e49a2 gfx/wgpu_bindings/src/server.rs
--- a/gfx/wgpu_bindings/src/server.rs	Tue Oct 24 03:54:42 2023 +0000
+++ b/gfx/wgpu_bindings/src/server.rs	Tue Oct 24 04:04:07 2023 +0000
@@ -16,6 +16,7 @@
 
 use std::borrow::Cow;
 use std::os::raw::c_void;
+use std::ptr;
 use std::slice;
 use std::sync::atomic::{AtomicU32, Ordering};
 
@@ -446,6 +447,62 @@
     gfx_select!(self_id => global.buffer_drop(self_id, false));
 }
 
+/// Owns gpu resource that can be used by the wgpu implementation.
+/// It is created and destroyed by gecko side's ExternalTexture.
+#[repr(transparent)]
+pub struct TextureRaw {
+    #[cfg(target_os = "windows")]
+    d3d12_resource: d3d12::Resource,
+    #[cfg(not(target_os = "windows"))]
+    _dummy: bool, // FFI requests field
+}
+
+#[allow(unused_variables)]
+#[no_mangle]
+pub extern "C" fn wgpu_server_create_external_texture_raw(
+    global: &mut Global,
+    device_id: id::DeviceId,
+    shared_texture_handle: *mut c_void,
+) -> *mut TextureRaw {
+    assert!(device_id.backend() == wgt::Backend::Dx12);
+
+    #[cfg(target_os = "windows")]
+    if device_id.backend() == wgt::Backend::Dx12 {
+        let mut resource = d3d12::Resource::null();
+
+        let dx12_device = unsafe {
+            global.device_as_hal::<wgc::api::Dx12, _, d3d12::Device>(device_id, |hal_device| {
+                hal_device.unwrap().raw_device().clone()
+            })
+        };
+
+        let hr = unsafe {
+            dx12_device.OpenSharedHandle(
+                shared_texture_handle,
+                &d3d12_ty::ID3D12Resource::uuidof(),
+                resource.mut_void(),
+            )
+        };
+
+        if hr != 0 {
+            return ptr::null_mut();
+        }
+
+        let texture = TextureRaw {
+            d3d12_resource: resource,
+        };
+
+        return Box::into_raw(Box::new(texture));
+    }
+
+    ptr::null_mut()
+}
+
+#[no_mangle]
+pub unsafe extern "C" fn wgpu_server_destroy_external_texture_raw(texture: *mut TextureRaw) {
+    let _ = Box::from_raw(texture);
+}
+
 extern "C" {
     #[allow(dead_code)]
     fn wgpu_server_use_external_texture_for_swap_chain(
@@ -453,7 +510,7 @@
         swap_chain_id: SwapChainId,
     ) -> bool;
     #[allow(dead_code)]
-    fn wgpu_server_create_external_texture_for_swap_chain(
+    fn wgpu_server_ensure_external_texture_for_swap_chain(
         param: *mut c_void,
         swap_chain_id: SwapChainId,
         device_id: id::DeviceId,
@@ -463,10 +520,10 @@
         format: wgt::TextureFormat,
     ) -> bool;
     #[allow(dead_code)]
-    fn wgpu_server_get_external_texture_handle(
+    fn wgpu_server_get_external_texture_raw(
         param: *mut c_void,
         id: id::TextureId,
-    ) -> *mut c_void;
+    ) -> *mut TextureRaw;
 }
 
 impl Global {
@@ -507,7 +564,7 @@
 
                     if use_external_texture && self_id.backend() == wgt::Backend::Dx12 {
                         let ret = unsafe {
-                            wgpu_server_create_external_texture_for_swap_chain(
+                            wgpu_server_ensure_external_texture_for_swap_chain(
                                 self.owner,
                                 swap_chain_id.unwrap(),
                                 self_id,
@@ -522,41 +579,20 @@
                                 message: "Failed to create external texture",
                                 r#type: ErrorBufferType::Internal,
                             });
+                            return;
                         }
-
-                        let dx12_device = unsafe {
-                            self.device_as_hal::<wgc::api::Dx12, _, d3d12::Device>(
-                                self_id,
-                                |hal_device| hal_device.unwrap().raw_device().clone(),
-                            )
-                        };
-
-                        let handle =
-                            unsafe { wgpu_server_get_external_texture_handle(self.owner, id) };
-                        if handle.is_null() {
+                        let texture_wgpu =
+                            unsafe { wgpu_server_get_external_texture_raw(self.owner, id) };
+                        if texture_wgpu.is_null() {
                             error_buf.init(ErrMsg {
-                                message: "Failed to get external texture handle",
+                                message: "Failed to get external texture wgpu",
                                 r#type: ErrorBufferType::Internal,
                             });
+                            return;
                         }
-                        let mut resource = d3d12::Resource::null();
-                        let hr = unsafe {
-                            dx12_device.OpenSharedHandle(
-                                handle,
-                                &d3d12_ty::ID3D12Resource::uuidof(),
-                                resource.mut_void(),
-                            )
-                        };
-                        if hr != 0 {
-                            error_buf.init(ErrMsg {
-                                message: "Failed to open shared handle",
-                                r#type: ErrorBufferType::Internal,
-                            });
-                        }
-
                         let hal_texture = unsafe {
                             <wgh::api::Dx12 as wgh::Api>::Device::texture_from_raw(
-                                resource,
+                                (*texture_wgpu).d3d12_resource.clone(),
                                 wgt::TextureFormat::Bgra8Unorm,
                                 wgt::TextureDimension::D2,
                                 desc.size,
