# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/svg/SVGUtils.cpp
# Commit: 98bea2812b17
# Full Hash: 98bea2812b17ee0294eb90b5e37de904412e659b
# Author: Robert Longson <longsonr@gmail.com>
# Date: 2023-10-24 03:54:44
# Regressor Bug: 1765202
# File Overlap Count: 1
# Description:
#   Bug 1765202 part 1 - Have determineMaskUsage return its result r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D190766
# ==============================================================================

diff -r 79f439bc112c -r 98bea2812b17 layout/svg/SVGUtils.cpp
--- a/layout/svg/SVGUtils.cpp	Mon Oct 23 20:00:05 2023 +0000
+++ b/layout/svg/SVGUtils.cpp	Mon Oct 23 20:11:10 2023 +0000
@@ -408,11 +408,13 @@
   return styleEffects->mOpacity;
 }
 
-void SVGUtils::DetermineMaskUsage(const nsIFrame* aFrame, bool aHandleOpacity,
-                                  MaskUsage& aUsage) {
+SVGUtils::MaskUsage SVGUtils::DetermineMaskUsage(const nsIFrame* aFrame,
+                                                 bool aHandleOpacity) {
+  MaskUsage usage;
+
   using ClipPathType = StyleClipPath::Tag;
 
-  aUsage.opacity = ComputeOpacity(aFrame, aHandleOpacity);
+  usage.opacity = ComputeOpacity(aFrame, aHandleOpacity);
 
   nsIFrame* firstFrame =
       nsLayoutUtils::FirstContinuationOrIBSplitSibling(aFrame);
@@ -422,7 +424,7 @@
   nsTArray<SVGMaskFrame*> maskFrames;
   // XXX check return value?
   SVGObserverUtils::GetAndObserveMasks(firstFrame, &maskFrames);
-  aUsage.shouldGenerateMaskLayer = (maskFrames.Length() > 0);
+  usage.shouldGenerateMaskLayer = (maskFrames.Length() > 0);
 
   SVGClipPathFrame* clipPathFrame;
   // XXX check return value?
@@ -433,25 +435,26 @@
     case ClipPathType::Url:
       if (clipPathFrame) {
         if (clipPathFrame->IsTrivial()) {
-          aUsage.shouldApplyClipPath = true;
+          usage.shouldApplyClipPath = true;
         } else {
-          aUsage.shouldGenerateClipMaskLayer = true;
+          usage.shouldGenerateClipMaskLayer = true;
         }
       }
       break;
     case ClipPathType::Shape:
     case ClipPathType::Box:
-      aUsage.shouldApplyBasicShapeOrPath = true;
+      usage.shouldApplyBasicShapeOrPath = true;
       break;
     case ClipPathType::None:
-      MOZ_ASSERT(!aUsage.shouldGenerateClipMaskLayer &&
-                 !aUsage.shouldApplyClipPath &&
-                 !aUsage.shouldApplyBasicShapeOrPath);
+      MOZ_ASSERT(!usage.shouldGenerateClipMaskLayer &&
+                 !usage.shouldApplyClipPath &&
+                 !usage.shouldApplyBasicShapeOrPath);
       break;
     default:
       MOZ_ASSERT_UNREACHABLE("Unsupported clip-path type.");
       break;
   }
+  return usage;
 }
 
 class MixModeBlender {
@@ -566,8 +569,7 @@
     return;
   }
 
-  MaskUsage maskUsage;
-  DetermineMaskUsage(aFrame, true, maskUsage);
+  MaskUsage maskUsage = DetermineMaskUsage(aFrame, true);
   if (maskUsage.opacity == 0.0f) {
     return;
   }