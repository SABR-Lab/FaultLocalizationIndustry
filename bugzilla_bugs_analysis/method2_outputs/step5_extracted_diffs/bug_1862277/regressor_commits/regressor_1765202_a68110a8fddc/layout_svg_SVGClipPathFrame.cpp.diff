# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/svg/SVGClipPathFrame.cpp
# Commit: a68110a8fddc
# Full Hash: a68110a8fddc7b6daa1ae5f2503e68c98a7cfd8a
# Author: Robert Longson <longsonr@gmail.com>
# Date: 2023-10-24 03:54:44
# Regressor Bug: 1765202
# File Overlap Count: 1
# Description:
#   Bug 1765202 part 2 - refactor MaskUsage so that its members are private r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D191513
# ==============================================================================

diff -r 98bea2812b17 -r a68110a8fddc layout/svg/SVGClipPathFrame.cpp
--- a/layout/svg/SVGClipPathFrame.cpp	Mon Oct 23 20:11:10 2023 +0000
+++ b/layout/svg/SVGClipPathFrame.cpp	Mon Oct 23 20:11:11 2023 +0000
@@ -105,10 +105,10 @@
   SVGUtils::MaskUsage maskUsage = SVGUtils::DetermineMaskUsage(this, true);
 
   gfxGroupForBlendAutoSaveRestore autoGroupForBlend(&aMaskContext);
-  if (maskUsage.shouldApplyClipPath) {
+  if (maskUsage.ShouldApplyClipPath()) {
     clipPathThatClipsClipPath->ApplyClipPath(aMaskContext, aClippedFrame,
                                              aMatrix);
-  } else if (maskUsage.shouldGenerateClipMaskLayer) {
+  } else if (maskUsage.ShouldGenerateClipMaskLayer()) {
     RefPtr<SourceSurface> maskSurface = clipPathThatClipsClipPath->GetClipMask(
         aMaskContext, aClippedFrame, aMatrix);
     // We want the mask to be untransformed so use the inverse of the current
@@ -124,7 +124,7 @@
     PaintFrameIntoMask(kid, aClippedFrame, aMaskContext);
   }
 
-  if (maskUsage.shouldApplyClipPath) {
+  if (maskUsage.ShouldApplyClipPath()) {
     aMaskContext.PopClip();
   }
 }
@@ -182,11 +182,11 @@
 
   SVGUtils::MaskUsage maskUsage = SVGUtils::DetermineMaskUsage(aFrame, true);
   gfxGroupForBlendAutoSaveRestore autoGroupForBlend(&aTarget);
-  if (maskUsage.shouldApplyClipPath) {
+  if (maskUsage.ShouldApplyClipPath()) {
     clipPathThatClipsChild->ApplyClipPath(
         aTarget, aClippedFrame,
         SVGUtils::GetTransformMatrixInUserSpace(aFrame) * mMatrixForChildren);
-  } else if (maskUsage.shouldGenerateClipMaskLayer) {
+  } else if (maskUsage.ShouldGenerateClipMaskLayer()) {
     RefPtr<SourceSurface> maskSurface = clipPathThatClipsChild->GetClipMask(
         aTarget, aClippedFrame,
         SVGUtils::GetTransformMatrixInUserSpace(aFrame) * mMatrixForChildren);
@@ -216,7 +216,7 @@
   // only the geometry (opaque black) if set.
   frame->PaintSVG(aTarget, toChildsUserSpace, imgParams);
 
-  if (maskUsage.shouldApplyClipPath) {
+  if (maskUsage.ShouldApplyClipPath()) {
     aTarget.PopClip();
   }
 }