# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/svg/SVGIntegrationUtils.cpp
# Commit: a68110a8fddc
# Full Hash: a68110a8fddc7b6daa1ae5f2503e68c98a7cfd8a
# Author: Robert Longson <longsonr@gmail.com>
# Date: 2023-10-24 03:54:44
# Regressor Bug: 1765202
# File Overlap Count: 1
# Description:
#   Bug 1765202 part 2 - refactor MaskUsage so that its members are private r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D191513
# ==============================================================================

diff -r 98bea2812b17 -r a68110a8fddc layout/svg/SVGIntegrationUtils.cpp
--- a/layout/svg/SVGIntegrationUtils.cpp	Mon Oct 23 20:11:10 2023 +0000
+++ b/layout/svg/SVGIntegrationUtils.cpp	Mon Oct 23 20:11:11 2023 +0000
@@ -644,7 +644,7 @@
 
   SVGUtils::MaskUsage maskUsage =
       SVGUtils::DetermineMaskUsage(aParams.frame, aParams.handleOpacity);
-  if (!maskUsage.shouldDoSomething()) {
+  if (!maskUsage.ShouldDoSomething()) {
     return false;
   }
 
@@ -656,9 +656,7 @@
   gfxContext& ctx = aParams.ctx;
   RefPtr<DrawTarget> maskTarget = ctx.GetDrawTarget();
 
-  if (maskUsage.shouldGenerateMaskLayer &&
-      (maskUsage.shouldGenerateClipMaskLayer ||
-       maskUsage.shouldApplyClipPath)) {
+  if (maskUsage.ShouldGenerateMaskLayer() && maskUsage.HasSVGClip()) {
     // We will paint both mask of positioned mask and clip-path into
     // maskTarget.
     //
@@ -675,25 +673,24 @@
   SVGObserverUtils::GetAndObserveMasks(firstFrame, &maskFrames);
 
   gfxGroupForBlendAutoSaveRestore autoPop(&ctx);
-  bool shouldPushOpacity =
-      (maskUsage.opacity != 1.0) && (maskFrames.Length() != 1);
+  bool shouldPushOpacity = !maskUsage.IsOpaque() && maskFrames.Length() != 1;
   if (shouldPushOpacity) {
     autoPop.PushGroupForBlendBack(gfxContentType::COLOR_ALPHA,
-                                  maskUsage.opacity);
+                                  maskUsage.Opacity());
   }
 
   gfxContextMatrixAutoSaveRestore matSR;
 
   // Paint clip-path-basic-shape onto ctx
   gfxContextAutoSaveRestore basicShapeSR;
-  if (maskUsage.shouldApplyBasicShapeOrPath) {
+  if (maskUsage.ShouldApplyBasicShapeOrPath()) {
     matSR.SetContext(&ctx);
 
     MoveContextOriginToUserSpace(firstFrame, aParams);
 
     basicShapeSR.SetContext(&ctx);
     gfxMatrix mat = SVGUtils::GetCSSPxToDevPxMatrix(frame);
-    if (!maskUsage.shouldGenerateMaskLayer) {
+    if (!maskUsage.ShouldGenerateMaskLayer()) {
       // Only have basic-shape clip-path effect. Fill clipped region by
       // opaque white.
       ctx.SetDeviceColor(DeviceColor::MaskOpaqueWhite());
@@ -710,7 +707,7 @@
   }
 
   // Paint mask into maskTarget.
-  if (maskUsage.shouldGenerateMaskLayer) {
+  if (maskUsage.ShouldGenerateMaskLayer()) {
     matSR.Restore();
     matSR.SetContext(&ctx);
 
@@ -718,12 +715,12 @@
     maskTarget->SetTransform(maskTarget->GetTransform().PreTranslate(
         ToPoint(offsets.offsetToUserSpaceInDevPx)));
     aOutIsMaskComplete = PaintMaskSurface(
-        aParams, maskTarget, shouldPushOpacity ? 1.0 : maskUsage.opacity,
+        aParams, maskTarget, shouldPushOpacity ? 1.0f : maskUsage.Opacity(),
         firstFrame->Style(), maskFrames, offsets.offsetToUserSpace);
   }
 
   // Paint clip-path onto ctx.
-  if (maskUsage.shouldGenerateClipMaskLayer || maskUsage.shouldApplyClipPath) {
+  if (maskUsage.HasSVGClip()) {
     matSR.Restore();
     matSR.SetContext(&ctx);
 
@@ -735,7 +732,7 @@
     // XXX check return value?
     SVGObserverUtils::GetAndObserveClipPath(firstFrame, &clipPathFrame);
     RefPtr<SourceSurface> maskSurface =
-        maskUsage.shouldGenerateMaskLayer ? maskTarget->Snapshot() : nullptr;
+        maskUsage.ShouldGenerateMaskLayer() ? maskTarget->Snapshot() : nullptr;
     clipPathFrame->PaintClipMask(ctx, frame, cssPxToDevPxMatrix, maskSurface);
   }
 
@@ -770,7 +767,7 @@
   SVGUtils::MaskUsage maskUsage =
       SVGUtils::DetermineMaskUsage(aParams.frame, aParams.handleOpacity);
 
-  if (maskUsage.opacity == 0.0f) {
+  if (maskUsage.IsTransparent()) {
     return;
   }
 
@@ -790,22 +787,19 @@
 
   gfxMatrix cssPxToDevPxMatrix = SVGUtils::GetCSSPxToDevPxMatrix(frame);
 
-  bool shouldGenerateMask =
-      (maskUsage.opacity != 1.0f || maskUsage.shouldGenerateClipMaskLayer ||
-       maskUsage.shouldGenerateMaskLayer);
   bool shouldPushMask = false;
 
   gfxGroupForBlendAutoSaveRestore autoGroupForBlend(&context);
 
   /* Check if we need to do additional operations on this child's
    * rendering, which necessitates rendering into another surface. */
-  if (shouldGenerateMask) {
+  if (maskUsage.ShouldGenerateMask()) {
     gfxContextMatrixAutoSaveRestore matSR;
 
     RefPtr<SourceSurface> maskSurface;
     bool opacityApplied = false;
 
-    if (maskUsage.shouldGenerateMaskLayer) {
+    if (maskUsage.ShouldGenerateMaskLayer()) {
       matSR.SetContext(&context);
 
       // For css-mask, we want to generate a mask for each continuation frame,
@@ -813,7 +807,7 @@
       // instead of the first continuation frame.
       EffectOffsets offsets = MoveContextOriginToUserSpace(frame, aParams);
       MaskPaintResult paintResult = CreateAndPaintMaskSurface(
-          aParams, maskUsage.opacity, firstFrame->Style(), maskFrames,
+          aParams, maskUsage.Opacity(), firstFrame->Style(), maskFrames,
           offsets.offsetToUserSpace);
 
       if (paintResult.transparentBlackMask) {
@@ -828,7 +822,7 @@
       }
     }
 
-    if (maskUsage.shouldGenerateClipMaskLayer) {
+    if (maskUsage.ShouldGenerateClipMaskLayer()) {
       matSR.Restore();
       matSR.SetContext(&context);
 
@@ -848,9 +842,8 @@
     }
 
     // opacity != 1.0f.
-    if (!maskUsage.shouldGenerateClipMaskLayer &&
-        !maskUsage.shouldGenerateMaskLayer) {
-      MOZ_ASSERT(maskUsage.opacity != 1.0f);
+    if (!maskUsage.ShouldGenerateLayer()) {
+      MOZ_ASSERT(!maskUsage.IsOpaque());
 
       matSR.SetContext(&context);
       MoveContextOriginToUserSpace(firstFrame, aParams);
@@ -865,7 +858,7 @@
 
       autoGroupForBlend.PushGroupForBlendBack(
           gfxContentType::COLOR_ALPHA,
-          opacityApplied ? 1.0f : maskUsage.opacity, maskSurface,
+          opacityApplied ? 1.0f : maskUsage.Opacity(), maskSurface,
           maskTransform);
     }
   }
@@ -873,14 +866,15 @@
   /* If this frame has only a trivial clipPath, set up cairo's clipping now so
    * we can just do normal painting and get it clipped appropriately.
    */
-  if (maskUsage.shouldApplyClipPath || maskUsage.shouldApplyBasicShapeOrPath) {
+  if (maskUsage.ShouldApplyClipPath() ||
+      maskUsage.ShouldApplyBasicShapeOrPath()) {
     gfxContextMatrixAutoSaveRestore matSR(&context);
 
     MoveContextOriginToUserSpace(firstFrame, aParams);
 
-    MOZ_ASSERT(!maskUsage.shouldApplyClipPath ||
-               !maskUsage.shouldApplyBasicShapeOrPath);
-    if (maskUsage.shouldApplyClipPath) {
+    MOZ_ASSERT(!maskUsage.ShouldApplyClipPath() ||
+               !maskUsage.ShouldApplyBasicShapeOrPath());
+    if (maskUsage.ShouldApplyClipPath()) {
       clipPathFrame->ApplyClipPath(context, frame, cssPxToDevPxMatrix);
     } else {
       CSSClipPathInstance::ApplyBasicShapeOrPathClip(context, frame,
@@ -900,14 +894,13 @@
         aParams.borderArea, frame->PresContext()->AppUnitsPerDevPixel());
     context.SnappedRectangle(drawingRect);
     sRGBColor overlayColor(0.0f, 0.0f, 0.0f, 0.8f);
-    if (maskUsage.shouldGenerateMaskLayer) {
+    if (maskUsage.ShouldGenerateMaskLayer()) {
       overlayColor.r = 1.0f;  // red represents css positioned mask.
     }
-    if (maskUsage.shouldApplyClipPath ||
-        maskUsage.shouldGenerateClipMaskLayer) {
+    if (maskUsage.HasSVGClip()) {
       overlayColor.g = 1.0f;  // green represents clip-path:<clip-source>.
     }
-    if (maskUsage.shouldApplyBasicShapeOrPath) {
+    if (maskUsage.ShouldApplyBasicShapeOrPath()) {
       overlayColor.b = 1.0f;  // blue represents
                               // clip-path:<basic-shape>||<geometry-box>.
     }
@@ -916,7 +909,8 @@
     context.Fill();
   }
 
-  if (maskUsage.shouldApplyClipPath || maskUsage.shouldApplyBasicShapeOrPath) {
+  if (maskUsage.ShouldApplyClipPath() ||
+      maskUsage.ShouldApplyBasicShapeOrPath()) {
     context.PopClip();
   }
 }