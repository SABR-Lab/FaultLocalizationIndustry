# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/svg/SVGUtils.cpp
# Commit: a68110a8fddc
# Full Hash: a68110a8fddc7b6daa1ae5f2503e68c98a7cfd8a
# Author: Robert Longson <longsonr@gmail.com>
# Date: 2023-10-24 03:54:44
# Regressor Bug: 1765202
# File Overlap Count: 1
# Description:
#   Bug 1765202 part 2 - refactor MaskUsage so that its members are private r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D191513
# ==============================================================================

diff -r 98bea2812b17 -r a68110a8fddc layout/svg/SVGUtils.cpp
--- a/layout/svg/SVGUtils.cpp	Mon Oct 23 20:11:10 2023 +0000
+++ b/layout/svg/SVGUtils.cpp	Mon Oct 23 20:11:11 2023 +0000
@@ -414,7 +414,7 @@
 
   using ClipPathType = StyleClipPath::Tag;
 
-  usage.opacity = ComputeOpacity(aFrame, aHandleOpacity);
+  usage.mOpacity = ComputeOpacity(aFrame, aHandleOpacity);
 
   nsIFrame* firstFrame =
       nsLayoutUtils::FirstContinuationOrIBSplitSibling(aFrame);
@@ -424,7 +424,7 @@
   nsTArray<SVGMaskFrame*> maskFrames;
   // XXX check return value?
   SVGObserverUtils::GetAndObserveMasks(firstFrame, &maskFrames);
-  usage.shouldGenerateMaskLayer = (maskFrames.Length() > 0);
+  usage.mShouldGenerateMaskLayer = (maskFrames.Length() > 0);
 
   SVGClipPathFrame* clipPathFrame;
   // XXX check return value?
@@ -435,20 +435,20 @@
     case ClipPathType::Url:
       if (clipPathFrame) {
         if (clipPathFrame->IsTrivial()) {
-          usage.shouldApplyClipPath = true;
+          usage.mShouldApplyClipPath = true;
         } else {
-          usage.shouldGenerateClipMaskLayer = true;
+          usage.mShouldGenerateClipMaskLayer = true;
         }
       }
       break;
     case ClipPathType::Shape:
     case ClipPathType::Box:
-      usage.shouldApplyBasicShapeOrPath = true;
+      usage.mShouldApplyBasicShapeOrPath = true;
       break;
     case ClipPathType::None:
-      MOZ_ASSERT(!usage.shouldGenerateClipMaskLayer &&
-                 !usage.shouldApplyClipPath &&
-                 !usage.shouldApplyBasicShapeOrPath);
+      MOZ_ASSERT(!usage.mShouldGenerateClipMaskLayer &&
+                 !usage.mShouldApplyClipPath &&
+                 !usage.mShouldApplyBasicShapeOrPath);
       break;
     default:
       MOZ_ASSERT_UNREACHABLE("Unsupported clip-path type.");
@@ -570,7 +570,7 @@
   }
 
   MaskUsage maskUsage = DetermineMaskUsage(aFrame, true);
-  if (maskUsage.opacity == 0.0f) {
+  if (maskUsage.IsTransparent()) {
     return;
   }
 
@@ -625,25 +625,22 @@
 
   /* Check if we need to do additional operations on this child's
    * rendering, which necessitates rendering into another surface. */
-  bool shouldGenerateMask =
-      (maskUsage.opacity != 1.0f || maskUsage.shouldGenerateClipMaskLayer ||
-       maskUsage.shouldGenerateMaskLayer);
   bool shouldPushMask = false;
 
-  if (shouldGenerateMask) {
+  if (maskUsage.ShouldGenerateMask()) {
     RefPtr<SourceSurface> maskSurface;
 
-    // maskFrame can be nullptr even if maskUsage.shouldGenerateMaskLayer is
+    // maskFrame can be nullptr even if maskUsage.ShouldGenerateMaskLayer() is
     // true. That happens when a user gives an unresolvable mask-id, such as
     //   mask:url()
     //   mask:url(#id-which-does-not-exist)
     // Since we only uses SVGUtils with SVG elements, not like mask on an
     // HTML element, we should treat an unresolvable mask as no-mask here.
-    if (maskUsage.shouldGenerateMaskLayer && maskFrame) {
+    if (maskUsage.ShouldGenerateMaskLayer() && maskFrame) {
       StyleMaskMode maskMode =
           aFrame->StyleSVGReset()->mMask.mLayers[0].mMaskMode;
       SVGMaskFrame::MaskParams params(aContext.GetDrawTarget(), aFrame,
-                                      aTransform, maskUsage.opacity, maskMode,
+                                      aTransform, maskUsage.Opacity(), maskMode,
                                       aImgParams);
 
       maskSurface = maskFrame->GetMaskForMaskedFrame(params);
@@ -656,7 +653,7 @@
       shouldPushMask = true;
     }
 
-    if (maskUsage.shouldGenerateClipMaskLayer) {
+    if (maskUsage.ShouldGenerateClipMaskLayer()) {
       RefPtr<SourceSurface> clipMaskSurface =
           clipPathFrame->GetClipMask(aContext, aFrame, aTransform, maskSurface);
       if (clipMaskSurface) {
@@ -669,8 +666,7 @@
       shouldPushMask = true;
     }
 
-    if (!maskUsage.shouldGenerateClipMaskLayer &&
-        !maskUsage.shouldGenerateMaskLayer) {
+    if (!maskUsage.ShouldGenerateLayer()) {
       shouldPushMask = true;
     }
 
@@ -682,7 +678,7 @@
       Matrix maskTransform = aContext.CurrentMatrix();
       maskTransform.Invert();
       target->PushGroupForBlendBack(gfxContentType::COLOR_ALPHA,
-                                    maskFrame ? 1.0 : maskUsage.opacity,
+                                    maskFrame ? 1.0f : maskUsage.Opacity(),
                                     maskSurface, maskTransform);
     }
   }
@@ -690,8 +686,9 @@
   /* If this frame has only a trivial clipPath, set up cairo's clipping now so
    * we can just do normal painting and get it clipped appropriately.
    */
-  if (maskUsage.shouldApplyClipPath || maskUsage.shouldApplyBasicShapeOrPath) {
-    if (maskUsage.shouldApplyClipPath) {
+  if (maskUsage.ShouldApplyClipPath() ||
+      maskUsage.ShouldApplyBasicShapeOrPath()) {
+    if (maskUsage.ShouldApplyClipPath()) {
       clipPathFrame->ApplyClipPath(aContext, aFrame, aTransform);
     } else {
       CSSClipPathInstance::ApplyBasicShapeOrPathClip(aContext, aFrame,
@@ -735,7 +732,8 @@
     svgFrame->PaintSVG(*target, aTransform, aImgParams);
   }
 
-  if (maskUsage.shouldApplyClipPath || maskUsage.shouldApplyBasicShapeOrPath) {
+  if (maskUsage.ShouldApplyClipPath() ||
+      maskUsage.ShouldApplyBasicShapeOrPath()) {
     aContext.PopClip();
   }
 