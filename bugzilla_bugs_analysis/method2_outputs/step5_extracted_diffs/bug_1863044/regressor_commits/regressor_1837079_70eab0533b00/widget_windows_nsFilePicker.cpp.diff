# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/nsFilePicker.cpp
# Commit: 70eab0533b00
# Full Hash: 70eab0533b00cee4ac31f7e3250d78d2a9a09758
# Author: Ray Kraesig <rkraesig@mozilla.com>
# Date: 2023-09-16 09:14:45
# Regressor Bug: 1837079
# File Overlap Count: 1
# Description:
#   Bug 1837079 - [7/10] Open Windows file picker out-of-process  r=gstoll,handyman,ipc-reviewers,nika
#   
#   When opening a new Windows file dialog, open it out-of-process if
#   possible. Fall back to opening it in-process if that fails. (This
#   behavior is configurable with a pref.)
# ==============================================================================

diff -r 488707a84723 -r 70eab0533b00 widget/windows/nsFilePicker.cpp
--- a/widget/windows/nsFilePicker.cpp	Fri Sep 15 18:10:01 2023 +0000
+++ b/widget/windows/nsFilePicker.cpp	Fri Sep 15 18:10:01 2023 +0000
@@ -9,23 +9,29 @@
 #include <shlobj.h>
 #include <shlwapi.h>
 #include <cderr.h>
+#include <winerror.h>
+#include <utility>
 
 #include "mozilla/Assertions.h"
 #include "mozilla/BackgroundHangMonitor.h"
+#include "mozilla/Logging.h"
+#include "mozilla/ipc/UtilityProcessManager.h"
 #include "mozilla/ProfilerLabels.h"
+#include "mozilla/StaticPrefs_widget.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WindowsVersion.h"
-#include "nsReadableUtils.h"
+#include "nsCRT.h"
+#include "nsEnumeratorUtils.h"
 #include "nsNetUtil.h"
-#include "nsWindow.h"
-#include "nsEnumeratorUtils.h"
-#include "nsCRT.h"
+#include "nsPIDOMWindow.h"
+#include "nsReadableUtils.h"
 #include "nsString.h"
 #include "nsToolkit.h"
+#include "nsWindow.h"
 #include "WinUtils.h"
-#include "nsPIDOMWindow.h"
 
 #include "mozilla/widget/filedialog/WinFileDialogCommands.h"
+#include "mozilla/widget/filedialog/WinFileDialogParent.h"
 
 using mozilla::Maybe;
 using mozilla::Result;
@@ -36,6 +42,9 @@
 UniquePtr<char16_t[], nsFilePicker::FreeDeleter>
     nsFilePicker::sLastUsedUnicodeDirectory;
 
+using mozilla::LogLevel;
+static mozilla::LazyLogModule sLogFileDialog("FileDialog");
+
 #define MAX_EXTENSION_LENGTH 10
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -80,6 +89,163 @@
   return nsBaseFilePicker::Init(aParent, aTitle, aMode);
 }
 
+namespace mozilla::detail {
+namespace {
+// Commit crimes against asynchrony.
+//
+// More specifically, drive a MozPromise to completion (resolution or rejection)
+// on the main thread. This is only even vaguely acceptable in the context of
+// the Windows file picker because a) this is essentially what `IFileDialog`'s
+// `ShowModal()` will do if we open it in-process anyway, and b) there exist
+// concrete plans [0] to remove this, making the Windows file picker fully
+// asynchronous.
+//
+// Do not take this as a model for use in other contexts; SpinEventLoopUntil
+// alone is bad enough.
+//
+// [0] Although see, _e.g._, http://www.thecodelesscode.com/case/234.
+//
+template <typename T, typename E, bool B>
+static auto ImmorallyDrivePromiseToCompletion(
+    RefPtr<MozPromise<T, E, B>>&& promise) -> Result<T, E> {
+  Maybe<Result<T, E>> val = Nothing();
+
+  AssertIsOnMainThread();
+  promise->Then(
+      mozilla::GetMainThreadSerialEventTarget(), "DrivePromiseToCompletion",
+      [&](T ret) { val = Some(std::move(ret)); },
+      [&](E error) { val = Some(Err(error)); });
+
+  SpinEventLoopUntil("DrivePromiseToCompletion"_ns,
+                     [&]() -> bool { return val.isSome(); });
+
+  MOZ_RELEASE_ASSERT(val.isSome());
+  return val.extract();
+}
+
+// Boilerplate for remotely showing a file dialog.
+template <typename ActionType,
+          typename ReturnType = typename decltype(std::declval<ActionType>()(
+              nullptr))::element_type::ResolveValueType>
+static auto ShowRemote(ActionType&& action)
+    -> RefPtr<MozPromise<ReturnType, HRESULT, false>> {
+  using RetPromise = MozPromise<ReturnType, HRESULT, false>;
+
+  constexpr static const auto fail = []() {
+    return RetPromise::CreateAndReject(E_FAIL, __PRETTY_FUNCTION__);
+  };
+
+  auto mgr = mozilla::ipc::UtilityProcessManager::GetSingleton();
+  if (!mgr) {
+    MOZ_ASSERT(false);
+    return fail();
+  }
+
+  auto wfda = mgr->CreateWinFileDialogAsync();
+  if (!wfda) {
+    return fail();
+  }
+
+  return wfda->Then(
+      mozilla::GetMainThreadSerialEventTarget(),
+      "nsFilePicker ShowRemote acquire",
+      [action = std::forward<ActionType>(action)](
+          RefPtr<filedialog::WinFileDialogParent> p) -> RefPtr<RetPromise> {
+        MOZ_LOG(sLogFileDialog, LogLevel::Info,
+                ("nsFilePicker ShowRemote first callback: p = [%p]", p.get()));
+        return action(p)->Then(
+            mozilla::GetMainThreadSerialEventTarget(),
+            "nsFilePicker ShowRemote call",
+            [p](ReturnType ret) {
+              return RetPromise::CreateAndResolve(std::move(ret),
+                                                  __PRETTY_FUNCTION__);
+            },
+            [](mozilla::ipc::ResponseRejectReason error) {
+              MOZ_LOG(sLogFileDialog, LogLevel::Error,
+                      ("IPC call rejected: %zu", size_t(error)));
+              return fail();
+            });
+      },
+      [](nsresult error) -> RefPtr<RetPromise> {
+        MOZ_LOG(sLogFileDialog, LogLevel::Error,
+                ("could not acquire WinFileDialog: %zu", size_t(error)));
+        return fail();
+      });
+}
+}  // namespace
+}  // namespace mozilla::detail
+
+Result<Maybe<filedialog::Results>, HRESULT> nsFilePicker::ShowFilePickerImpl(
+    HWND parent, filedialog::FileDialogType type,
+    nsTArray<filedialog::Command> const& commands) {
+  int32_t const pref =
+      mozilla::StaticPrefs::widget_windows_utility_process_file_picker();
+
+  switch (pref) {
+#ifndef NIGHTLY_BUILD
+    default:  // remain local-only on release and beta, for now
+#endif
+    case -1:
+      return ShowFilePickerLocal(parent, type, commands);
+    case 2:
+      return ShowFilePickerRemote(parent, type, commands);
+#ifdef NIGHTLY_BUILD
+    default:  // fall back to local on failure on Nightly builds
+#endif
+    case 1:
+      return ShowFilePickerRemote(parent, type, commands)
+          .orElse([&](HRESULT err) {
+            return ShowFilePickerLocal(parent, type, commands);
+          });
+  }
+}
+
+Result<Maybe<nsString>, HRESULT> nsFilePicker::ShowFolderPickerImpl(
+    HWND parent, nsTArray<filedialog::Command> const& commands) {
+  int32_t const pref =
+      mozilla::StaticPrefs::widget_windows_utility_process_file_picker();
+
+  switch (pref) {
+    case -1:
+      return ShowFolderPickerLocal(parent, commands);
+    case 2:
+      return ShowFolderPickerRemote(parent, commands);
+    default:
+    case 1:
+    case 0:
+      return ShowFolderPickerRemote(parent, commands).orElse([&](HRESULT err) {
+        return ShowFolderPickerLocal(parent, commands);
+      });
+  }
+}
+
+/* static */
+Result<Maybe<filedialog::Results>, HRESULT> nsFilePicker::ShowFilePickerRemote(
+    HWND parent, filedialog::FileDialogType type,
+    nsTArray<filedialog::Command> const& commands) {
+  auto promise =
+      mozilla::detail::ShowRemote([parent, type, commands = commands.Clone()](
+                                      filedialog::WinFileDialogParent* p) {
+        MOZ_LOG(sLogFileDialog, LogLevel::Info,
+                ("%s: p = [%p]", __PRETTY_FUNCTION__, p));
+        return p->SendShowFileDialog((uintptr_t)parent, type, commands);
+      });
+
+  return mozilla::detail::ImmorallyDrivePromiseToCompletion(std::move(promise));
+}
+
+/* static */
+Result<Maybe<nsString>, HRESULT> nsFilePicker::ShowFolderPickerRemote(
+    HWND parent, nsTArray<filedialog::Command> const& commands) {
+  auto promise =
+      mozilla::detail::ShowRemote([parent, commands = commands.Clone()](
+                                      filedialog::WinFileDialogParent* p) {
+        return p->SendShowFolderDialog((uintptr_t)parent, commands);
+      });
+
+  return mozilla::detail::ImmorallyDrivePromiseToCompletion(std::move(promise));
+}
+
 /* static */
 Result<Maybe<filedialog::Results>, HRESULT> nsFilePicker::ShowFilePickerLocal(
     HWND parent, filedialog::FileDialogType type,
@@ -168,7 +334,7 @@
     AutoWidgetPickerState awps(mParentWidget);
 
     mozilla::BackgroundHangMonitor().NotifyWait();
-    auto res = ShowFolderPickerLocal(shim.get(), commands);
+    auto res = ShowFolderPickerImpl(shim.get(), commands);
     if (res.isErr()) {
       NS_WARNING("ShowFolderPickerImpl failed");
       return false;
@@ -286,7 +452,7 @@
     AutoWidgetPickerState awps(mParentWidget);
 
     mozilla::BackgroundHangMonitor().NotifyWait();
-    auto res = ShowFilePickerLocal(
+    auto res = ShowFilePickerImpl(
         shim.get(),
         mMode == modeSave ? FileDialogType::Save : FileDialogType::Open,
         commands);