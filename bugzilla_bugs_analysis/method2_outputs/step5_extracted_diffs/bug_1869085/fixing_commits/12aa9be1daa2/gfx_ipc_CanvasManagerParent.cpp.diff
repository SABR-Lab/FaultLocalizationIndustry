# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/ipc/CanvasManagerParent.cpp
# Commit: 12aa9be1daa2
# Full Hash: 12aa9be1daa25a0f455c799f62cb5391971792d3
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2023-12-10 09:36:11
# Description:
#   Bug 1869085 - Make CanvasManagerParent use content parent ID for recording textures. r=bobowen
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D195957
# ==============================================================================

diff -r 19967878c4b0 -r 12aa9be1daa2 gfx/ipc/CanvasManagerParent.cpp
--- a/gfx/ipc/CanvasManagerParent.cpp	Sat Dec 09 19:49:22 2023 +0000
+++ b/gfx/ipc/CanvasManagerParent.cpp	Sat Dec 09 20:16:02 2023 +0000
@@ -13,6 +13,7 @@
 #include "mozilla/ipc/Endpoint.h"
 #include "mozilla/layers/CanvasTranslator.h"
 #include "mozilla/layers/CompositorThread.h"
+#include "mozilla/layers/ISurfaceAllocator.h"
 #include "mozilla/webgpu/WebGPUParent.h"
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
@@ -128,7 +129,8 @@
 
   StaticMonitorAutoLock lock(sReplayTexturesMonitor);
   sReplayTextures.AppendElement(
-      ReplayTexture{aOwner, aTextureId, std::move(desc)});
+      ReplayTexture{std::move(desc), aOwner->GetContentId(), aTextureId,
+                    aOwner->GetManagerId()});
   lock.NotifyAll();
 }
 
@@ -140,7 +142,9 @@
   while (i > 0) {
     --i;
     const auto& texture = sReplayTextures[i];
-    if (texture.mOwner == aOwner && texture.mId == aTextureId) {
+    if (texture.mContentId == aOwner->GetContentId() &&
+        texture.mTextureId == aTextureId) {
+      MOZ_ASSERT(texture.mManagerId == aOwner->GetManagerId());
       sReplayTextures.RemoveElementAt(i);
       break;
     }
@@ -155,14 +159,15 @@
   while (i > 0) {
     --i;
     const auto& texture = sReplayTextures[i];
-    if (texture.mOwner == aOwner) {
+    if (texture.mContentId == aOwner->GetContentId() &&
+        texture.mManagerId == aOwner->GetManagerId()) {
       sReplayTextures.RemoveElementAt(i);
     }
   }
 }
 
 /* static */ UniquePtr<layers::SurfaceDescriptor>
-CanvasManagerParent::TakeReplayTexture(base::ProcessId aOtherPid,
+CanvasManagerParent::TakeReplayTexture(const dom::ContentParentId& aContentId,
                                        int64_t aTextureId) {
   // While in theory this could be relatively expensive, the array is most
   // likely very small as the textures are removed during each composite.
@@ -170,7 +175,7 @@
   while (i > 0) {
     --i;
     const auto& texture = sReplayTextures[i];
-    if (texture.mOwner->OtherPid() == aOtherPid && texture.mId == aTextureId) {
+    if (texture.mContentId == aContentId && texture.mTextureId == aTextureId) {
       UniquePtr<layers::SurfaceDescriptor> desc =
           std::move(sReplayTextures[i].mDesc);
       sReplayTextures.RemoveElementAt(i);
@@ -181,16 +186,27 @@
 }
 
 /* static */ UniquePtr<layers::SurfaceDescriptor>
-CanvasManagerParent::WaitForReplayTexture(base::ProcessId aOtherPid,
+CanvasManagerParent::WaitForReplayTexture(layers::HostIPCAllocator* aAllocator,
                                           int64_t aTextureId) {
+  MOZ_ASSERT(!CanvasRenderThread::IsInCanvasRenderThread());
+
   StaticMonitorAutoLock lock(sReplayTexturesMonitor);
 
+  dom::ContentParentId contentId = aAllocator->GetContentId();
+
   UniquePtr<layers::SurfaceDescriptor> desc;
-  while (!(desc = TakeReplayTexture(aOtherPid, aTextureId))) {
+  while (!(desc = TakeReplayTexture(contentId, aTextureId))) {
     if (NS_WARN_IF(!sReplayTexturesEnabled)) {
       return nullptr;
     }
 
+    if (NS_WARN_IF(!aAllocator->IPCOpen())) {
+      // We don't know exactly which CanvasManagerParent/CanvasTranslator this
+      // is for, but we do know that the allocator points to the same process.
+      // Use this as a proxy to detect if the process was shutdown.
+      return nullptr;
+    }
+
     TimeDuration timeout = TimeDuration::FromMilliseconds(
         StaticPrefs::gfx_canvas_remote_texture_timeout_ms());
     CVStatus status = lock.Wait(timeout);
@@ -215,6 +231,13 @@
     return;
   }
 
+#ifdef DEBUG
+  for (CanvasManagerParent* i : sManagers) {
+    MOZ_ASSERT_IF(i->mContentId == mContentId,
+                  i->OtherPidMaybeInvalid() == OtherPidMaybeInvalid());
+  }
+#endif
+
   sManagers.Insert(this);
 }
 
@@ -249,7 +272,8 @@
 
 already_AddRefed<layers::PCanvasParent>
 CanvasManagerParent::AllocPCanvasParent() {
-  return MakeAndAddRef<layers::CanvasTranslator>();
+  MOZ_RELEASE_ASSERT(mId != 0);
+  return MakeAndAddRef<layers::CanvasTranslator>(mContentId, mId);
 }
 
 mozilla::ipc::IPCResult CanvasManagerParent::RecvGetSnapshot(
@@ -262,8 +286,7 @@
 
   IProtocol* actor = nullptr;
   for (CanvasManagerParent* i : sManagers) {
-    if (i->OtherPidMaybeInvalid() == OtherPidMaybeInvalid() &&
-        i->mId == aManagerId) {
+    if (i->mContentId == mContentId && i->mId == aManagerId) {
       actor = i->Lookup(aProtocolId);
       break;
     }