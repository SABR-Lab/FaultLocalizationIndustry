# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.h
# Commit: 2b56c2b2837a
# Full Hash: 2b56c2b2837adfd7c49b599771cfea2d9e3d687b
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2023-11-22 21:50:37
# Regressor Bug: 1863914
# File Overlap Count: 2
# Description:
#   Bug 1863914: Use multiple shmem buffers for remote canvas recording. r=aosmond
#   
#   This replaces the use of a single large ring buffer.
#   The buffers are still processed in parallel and are recycled to reduce
#   allocation. Events that do not fit in the default sized buffer have a separate
# ==============================================================================

diff -r ed311995cd70 -r 2b56c2b2837a gfx/layers/ipc/CanvasTranslator.h
--- a/gfx/layers/ipc/CanvasTranslator.h	Wed Nov 22 14:06:43 2023 +0200
+++ b/gfx/layers/ipc/CanvasTranslator.h	Wed Nov 22 11:52:08 2023 +0000
@@ -11,6 +11,8 @@
 #include <vector>
 
 #include "mozilla/gfx/InlineTranslator.h"
+#include "mozilla/gfx/RecordedEvent.h"
+#include "CanvasChild.h"
 #include "mozilla/layers/CanvasDrawEventRecorder.h"
 #include "mozilla/layers/LayersSurfaces.h"
 #include "mozilla/layers/PCanvasParent.h"
@@ -19,6 +21,8 @@
 #include "mozilla/UniquePtr.h"
 
 namespace mozilla {
+
+using EventType = gfx::RecordedEvent::EventType;
 class TaskQueue;
 
 namespace layers {
@@ -52,40 +56,49 @@
    * CanvasEventRingBuffer.
    *
    * @param aTextureType the TextureType the translator will create
-   * @param aReadHandle handle to the shared memory for the
-   *        CanvasEventRingBuffer
+   * @param aHeaderHandle handle for the control header
+   * @param aBufferHandles handles for the initial buffers for translation
+   * @param aBufferSize size of buffers and the default size
    * @param aReaderSem reading blocked semaphore for the CanvasEventRingBuffer
    * @param aWriterSem writing blocked semaphore for the CanvasEventRingBuffer
    * @param aUseIPDLThread if true, use the IPDL thread instead of the worker
    *        pool for translation requests
    */
-  ipc::IPCResult RecvInitTranslator(
-      const TextureType& aTextureType,
-      ipc::SharedMemoryBasic::Handle&& aReadHandle,
-      CrossProcessSemaphoreHandle&& aReaderSem,
-      CrossProcessSemaphoreHandle&& aWriterSem, const bool& aUseIPDLThread);
+  ipc::IPCResult RecvInitTranslator(const TextureType& aTextureType,
+                                    Handle&& aReadHandle,
+                                    nsTArray<Handle>&& aBufferHandles,
+                                    uint64_t aBufferSize,
+                                    CrossProcessSemaphoreHandle&& aReaderSem,
+                                    CrossProcessSemaphoreHandle&& aWriterSem,
+                                    bool aUseIPDLThread);
+
+  /**
+   * Restart the translation from a Stopped state.
+   */
+  ipc::IPCResult RecvRestartTranslation();
 
   /**
-   * New buffer to resume translation after it has been stopped by writer.
+   * Adds a new buffer to be translated. The current buffer will be recycled if
+   * it is of the default size. The translation will then be restarted.
    */
-  ipc::IPCResult RecvNewBuffer(ipc::SharedMemoryBasic::Handle&& aReadHandle);
+  ipc::IPCResult RecvAddBuffer(Handle&& aBufferHandle, uint64_t aBufferSize);
 
   /**
-   * Used to tell the CanvasTranslator to start translating again after it has
-   * stopped due to a timeout waiting for events.
+   * Sets the shared memory to be used for readback.
    */
-  ipc::IPCResult RecvResumeTranslation();
+  ipc::IPCResult RecvSetDataSurfaceBuffer(Handle&& aBufferHandle,
+                                          uint64_t aBufferSize);
 
   void ActorDestroy(ActorDestroyReason why) final;
 
+  void CheckAndSignalWriter();
+
   /**
    * Translates events until no more are available or the end of a transaction
    * If this returns false the caller of this is responsible for re-calling
    * this function.
-   *
-   * @returns true if all events are processed and false otherwise.
    */
-  bool TranslateRecording();
+  void TranslateRecording();
 
   /**
    * Marks the beginning of rendering for a transaction. While in a transaction
@@ -111,18 +124,6 @@
   void DeviceChangeAcknowledged();
 
   /**
-   * Used to send data back to the writer. This is done through the same shared
-   * memory so the writer must wait and read the response after it has submitted
-   * the event that uses this.
-   *
-   * @param aData the data to be written back to the writer
-   * @param aSize the number of chars to write
-   */
-  void ReturnWrite(const char* aData, size_t aSize) {
-    mStream->ReturnWrite(aData, aSize);
-  }
-
-  /**
    * Set the texture ID that will be used as a lookup for the texture created by
    * the next CreateDrawTarget.
    */
@@ -156,6 +157,10 @@
    */
   TextureData* LookupTextureData(int64_t aTextureId);
 
+  void CheckpointReached();
+
+  void PauseTranslation();
+
   /**
    * Removes the texture and other objects associated with a texture ID.
    *
@@ -244,12 +249,24 @@
   UniquePtr<gfx::DataSourceSurface::ScopedMap> GetPreparedMap(
       gfx::ReferencePtr aSurface);
 
+  void RecycleBuffer();
+
+  void NextBuffer();
+
+  void GetDataSurface(uint64_t aSurfaceRef);
+
  private:
   ~CanvasTranslator();
 
-  void Bind(Endpoint<PCanvasParent>&& aEndpoint);
+  void AddBuffer(Handle&& aBufferHandle, size_t aBufferSize);
+
+  void SetDataSurfaceBuffer(Handle&& aBufferHandle, size_t aBufferSize);
 
-  void StartTranslation();
+  bool ReadNextEvent(EventType& aEventType);
+
+  bool HasPendingEvent();
+
+  bool ReadPendingEvent(EventType& aEventType);
 
   void FinishShutdown();
 
@@ -273,9 +290,30 @@
 #if defined(XP_WIN)
   RefPtr<ID3D11Device> mDevice;
 #endif
-  // We hold the ring buffer as a UniquePtr so we can drop it once
-  // mTranslationTaskQueue has shutdown to break a RefPtr cycle.
-  UniquePtr<CanvasEventRingBuffer> mStream;
+
+  size_t mDefaultBufferSize;
+  uint32_t mMaxSpinCount;
+  TimeDuration mNextEventTimeout;
+
+  using State = CanvasDrawEventRecorder::State;
+  using Header = CanvasDrawEventRecorder::Header;
+
+  RefPtr<ipc::SharedMemoryBasic> mHeaderShmem;
+  Header* mHeader = nullptr;
+
+  struct CanvasShmem {
+    RefPtr<ipc::SharedMemoryBasic> shmem;
+    auto Size() { return shmem->Size(); }
+    MemReader CreateMemReader() {
+      return {static_cast<char*>(shmem->memory()), Size()};
+    }
+  };
+  std::queue<CanvasShmem> mCanvasShmems;
+  CanvasShmem mCurrentShmem;
+  MemReader mCurrentMemReader{0, 0};
+  RefPtr<ipc::SharedMemoryBasic> mDataSurfaceShmem;
+  UniquePtr<CrossProcessSemaphore> mWriterSemaphore;
+  UniquePtr<CrossProcessSemaphore> mReaderSemaphore;
   TextureType mTextureType = TextureType::Unknown;
   UniquePtr<TextureData> mReferenceTextureData;
   // Sometimes during device reset our reference DrawTarget can be null, so we