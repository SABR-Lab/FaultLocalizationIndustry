# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.cpp
# Commit: 8839a3ba6243
# Full Hash: 8839a3ba62436bd0ea7e5bd07e2b63a8d45b8609
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2023-12-09 09:33:28
# Regressor Bug: 1863914
# File Overlap Count: 1
# Description:
#   Bug 1863914: Use multiple shmem buffers for remote canvas recording. r=aosmond
#   
#   This replaces the use of a single large ring buffer.
#   The buffers are still processed in parallel and are recycled to reduce
#   allocation. Events that do not fit in the default sized buffer have a separate
# ==============================================================================

diff -r f088b7a21045 -r 8839a3ba6243 gfx/layers/ipc/CanvasTranslator.cpp
--- a/gfx/layers/ipc/CanvasTranslator.cpp	Fri Dec 08 15:56:39 2023 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.cpp	Fri Dec 08 16:11:27 2023 +0000
@@ -14,8 +14,10 @@
 #include "mozilla/gfx/GPUParent.h"
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/ipc/Endpoint.h"
+#include "mozilla/layers/CanvasTranslator.h"
 #include "mozilla/layers/SharedSurfacesParent.h"
 #include "mozilla/layers/TextureClient.h"
+#include "mozilla/StaticPrefs_gfx.h"
 #include "mozilla/SyncRunnable.h"
 #include "mozilla/TaskQueue.h"
 #include "mozilla/Telemetry.h"
@@ -29,25 +31,6 @@
 namespace mozilla {
 namespace layers {
 
-// When in a transaction we wait for a short time because we're expecting more
-// events from the content process. We don't want to wait for too long in case
-// other content processes are waiting for events to process.
-static const TimeDuration kReadEventTimeout = TimeDuration::FromMilliseconds(5);
-
-class RingBufferReaderServices final
-    : public CanvasEventRingBuffer::ReaderServices {
- public:
-  explicit RingBufferReaderServices(RefPtr<CanvasTranslator> aCanvasTranslator)
-      : mCanvasTranslator(std::move(aCanvasTranslator)) {}
-
-  ~RingBufferReaderServices() final = default;
-
-  bool WriterClosed() final { return !mCanvasTranslator->CanSend(); }
-
- private:
-  RefPtr<CanvasTranslator> mCanvasTranslator;
-};
-
 TextureData* CanvasTranslator::CreateTextureData(TextureType aTextureType,
                                                  const gfx::IntSize& aSize,
                                                  gfx::SurfaceFormat aFormat) {
@@ -68,6 +51,10 @@
 }
 
 CanvasTranslator::CanvasTranslator() {
+  mMaxSpinCount = StaticPrefs::gfx_canvas_remote_max_spin_count();
+  mNextEventTimeout = TimeDuration::FromMilliseconds(
+      StaticPrefs::gfx_canvas_remote_event_timeout_ms());
+
   // Track when remote canvas has been activated.
   Telemetry::ScalarAdd(Telemetry::ScalarID::GFX_CANVAS_REMOTE_ACTIVATED, 1);
 }
@@ -95,31 +82,49 @@
   return gfx::CanvasRenderThread::IsInCanvasRenderThread();
 }
 
+static bool CreateAndMapShmem(RefPtr<ipc::SharedMemoryBasic>& aShmem,
+                              Handle&& aHandle,
+                              ipc::SharedMemory::OpenRights aOpenRights,
+                              size_t aSize) {
+  auto shmem = MakeRefPtr<ipc::SharedMemoryBasic>();
+  if (!shmem->SetHandle(std::move(aHandle), aOpenRights) ||
+      !shmem->Map(aSize)) {
+    return false;
+  }
+
+  shmem->CloseHandle();
+  aShmem = shmem.forget();
+  return true;
+}
+
 mozilla::ipc::IPCResult CanvasTranslator::RecvInitTranslator(
-    const TextureType& aTextureType,
-    ipc::SharedMemoryBasic::Handle&& aReadHandle,
+    const TextureType& aTextureType, Handle&& aReadHandle,
+    nsTArray<Handle>&& aBufferHandles, uint64_t aBufferSize,
     CrossProcessSemaphoreHandle&& aReaderSem,
-    CrossProcessSemaphoreHandle&& aWriterSem, const bool& aUseIPDLThread) {
-  if (mStream) {
+    CrossProcessSemaphoreHandle&& aWriterSem, bool aUseIPDLThread) {
+  if (mHeaderShmem) {
     return IPC_FAIL(this, "RecvInitTranslator called twice.");
   }
 
   mTextureType = aTextureType;
 
-  // We need to initialize the stream first, because it might be used to
-  // communicate other failures back to the writer.
-  mStream = MakeUnique<CanvasEventRingBuffer>();
-  if (!mStream->InitReader(std::move(aReadHandle), std::move(aReaderSem),
-                           std::move(aWriterSem),
-                           MakeUnique<RingBufferReaderServices>(this))) {
-    mStream = nullptr;
-    return IPC_FAIL(this, "Failed to initialize ring buffer reader.");
+  mHeaderShmem = MakeAndAddRef<ipc::SharedMemoryBasic>();
+  if (!CreateAndMapShmem(mHeaderShmem, std::move(aReadHandle),
+                         ipc::SharedMemory::RightsReadWrite, sizeof(Header))) {
+    return IPC_FAIL(this, "Failed.");
   }
 
+  mHeader = static_cast<Header*>(mHeaderShmem->memory());
+
+  mWriterSemaphore.reset(CrossProcessSemaphore::Create(std::move(aWriterSem)));
+  mWriterSemaphore->CloseHandle();
+
+  mReaderSemaphore.reset(CrossProcessSemaphore::Create(std::move(aReaderSem)));
+  mReaderSemaphore->CloseHandle();
+
 #if defined(XP_WIN)
   if (!CheckForFreshCanvasDevice(__LINE__)) {
     gfxCriticalNote << "GFX: CanvasTranslator failed to get device";
-    mStream = nullptr;
     return IPC_OK();
   }
 #endif
@@ -127,56 +132,157 @@
   if (!aUseIPDLThread) {
     mTranslationTaskQueue = gfx::CanvasRenderThread::CreateWorkerTaskQueue();
   }
-  return RecvResumeTranslation();
+
+  // Use the first buffer as our current buffer.
+  mDefaultBufferSize = aBufferSize;
+  auto handleIter = aBufferHandles.begin();
+  if (!CreateAndMapShmem(mCurrentShmem.shmem, std::move(*handleIter),
+                         ipc::SharedMemory::RightsReadOnly, aBufferSize)) {
+    return IPC_FAIL(this, "Failed.");
+  }
+  mCurrentMemReader = mCurrentShmem.CreateMemReader();
+
+  // Add all other buffers to our recycled CanvasShmems.
+  for (handleIter++; handleIter < aBufferHandles.end(); handleIter++) {
+    CanvasShmem newShmem;
+    if (!CreateAndMapShmem(newShmem.shmem, std::move(*handleIter),
+                           ipc::SharedMemory::RightsReadOnly, aBufferSize)) {
+      return IPC_FAIL(this, "Failed.");
+    }
+    mCanvasShmems.emplace(std::move(newShmem));
+  }
+
+  DispatchToTaskQueue(NewRunnableMethod("CanvasTranslator::TranslateRecording",
+                                        this,
+                                        &CanvasTranslator::TranslateRecording));
+  return IPC_OK();
 }
 
-ipc::IPCResult CanvasTranslator::RecvNewBuffer(
-    ipc::SharedMemoryBasic::Handle&& aReadHandle) {
-  if (!mStream) {
-    return IPC_FAIL(this, "RecvNewBuffer before RecvInitTranslator.");
+ipc::IPCResult CanvasTranslator::RecvRestartTranslation() {
+  if (mDeactivated) {
+    // The other side might have sent a message before we deactivated.
+    return IPC_OK();
   }
-  // We need to set the new buffer on the translation queue to be sure that the
-  // drop buffer event has been processed.
-  DispatchToTaskQueue(NS_NewRunnableFunction(
-      "CanvasTranslator SetNewBuffer",
-      [self = RefPtr(this), readHandle = std::move(aReadHandle)]() mutable {
-        self->mStream->SetNewBuffer(std::move(readHandle));
-      }));
-  return RecvResumeTranslation();
+
+  DispatchToTaskQueue(NewRunnableMethod("CanvasTranslator::TranslateRecording",
+                                        this,
+                                        &CanvasTranslator::TranslateRecording));
+
+  return IPC_OK();
 }
 
-ipc::IPCResult CanvasTranslator::RecvResumeTranslation() {
-  if (!mStream) {
-    return IPC_FAIL(this, "RecvResumeTranslation before RecvInitTranslator.");
-  }
-  if (CheckDeactivated()) {
+ipc::IPCResult CanvasTranslator::RecvAddBuffer(
+    ipc::SharedMemoryBasic::Handle&& aBufferHandle, uint64_t aBufferSize) {
+  if (mDeactivated) {
     // The other side might have sent a resume message before we deactivated.
     return IPC_OK();
   }
 
-  DispatchToTaskQueue(NewRunnableMethod("CanvasTranslator::StartTranslation",
-                                        this,
-                                        &CanvasTranslator::StartTranslation));
+  DispatchToTaskQueue(
+      NewRunnableMethod<ipc::SharedMemoryBasic::Handle&&, size_t>(
+          "CanvasTranslator::AddBuffer", this, &CanvasTranslator::AddBuffer,
+          std::move(aBufferHandle), aBufferSize));
+
+  return IPC_OK();
+}
+
+void CanvasTranslator::AddBuffer(ipc::SharedMemoryBasic::Handle&& aBufferHandle,
+                                 size_t aBufferSize) {
+  MOZ_ASSERT(IsInTaskQueue());
+  MOZ_RELEASE_ASSERT(mHeader->readerState == State::Paused);
+
+  // Default sized buffers will have been queued for recycling.
+  if (mCurrentShmem.Size() == mDefaultBufferSize) {
+    mCanvasShmems.emplace(std::move(mCurrentShmem));
+  }
+
+  CanvasShmem newShmem;
+  if (!CreateAndMapShmem(newShmem.shmem, std::move(aBufferHandle),
+                         ipc::SharedMemory::RightsReadOnly, aBufferSize)) {
+    return;
+  }
+
+  mCurrentShmem = std::move(newShmem);
+  mCurrentMemReader = mCurrentShmem.CreateMemReader();
+
+  TranslateRecording();
+}
+
+ipc::IPCResult CanvasTranslator::RecvSetDataSurfaceBuffer(
+    ipc::SharedMemoryBasic::Handle&& aBufferHandle, uint64_t aBufferSize) {
+  if (mDeactivated) {
+    // The other side might have sent a resume message before we deactivated.
+    return IPC_OK();
+  }
+
+  DispatchToTaskQueue(
+      NewRunnableMethod<ipc::SharedMemoryBasic::Handle&&, size_t>(
+          "CanvasTranslator::SetDataSurfaceBuffer", this,
+          &CanvasTranslator::SetDataSurfaceBuffer, std::move(aBufferHandle),
+          aBufferSize));
+
   return IPC_OK();
 }
 
-void CanvasTranslator::StartTranslation() {
-  MOZ_RELEASE_ASSERT(mStream->IsValid(),
-                     "StartTranslation called before buffer has been set.");
+void CanvasTranslator::SetDataSurfaceBuffer(
+    ipc::SharedMemoryBasic::Handle&& aBufferHandle, size_t aBufferSize) {
+  MOZ_ASSERT(IsInTaskQueue());
+  MOZ_RELEASE_ASSERT(mHeader->readerState == State::Paused);
+
+  if (!CreateAndMapShmem(mDataSurfaceShmem, std::move(aBufferHandle),
+                         ipc::SharedMemory::RightsReadWrite, aBufferSize)) {
+    return;
+  }
+
+  TranslateRecording();
+}
 
-  if (!TranslateRecording() && CanSend()) {
-    DispatchToTaskQueue(NewRunnableMethod("CanvasTranslator::StartTranslation",
-                                          this,
-                                          &CanvasTranslator::StartTranslation));
+void CanvasTranslator::GetDataSurface(uint64_t aSurfaceRef) {
+  MOZ_ASSERT(IsInTaskQueue());
+
+  ReferencePtr surfaceRef = reinterpret_cast<void*>(aSurfaceRef);
+  gfx::SourceSurface* surface = LookupSourceSurface(surfaceRef);
+  if (!surface) {
+    return;
+  }
+
+  UniquePtr<gfx::DataSourceSurface::ScopedMap> map = GetPreparedMap(surfaceRef);
+  if (!map) {
+    return;
   }
 
-  // If the stream has been marked as bad and the Writer hasn't failed,
-  // deactivate remote canvas.
-  if (!mStream->good() && !mStream->WriterFailed()) {
-    Telemetry::ScalarAdd(
-        Telemetry::ScalarID::GFX_CANVAS_REMOTE_DEACTIVATED_BAD_STREAM, 1);
-    Deactivate();
+  auto dstSize = surface->GetSize();
+  auto srcSize = map->GetSurface()->GetSize();
+  int32_t dataFormatWidth = dstSize.width * BytesPerPixel(surface->GetFormat());
+  int32_t srcStride = map->GetStride();
+  if (dataFormatWidth > srcStride || srcSize != dstSize) {
+    return;
+  }
+
+  auto requiredSize = dataFormatWidth * dstSize.height;
+  if (requiredSize <= 0 || size_t(requiredSize) > mDataSurfaceShmem->Size()) {
+    return;
   }
+
+  char* dst = static_cast<char*>(mDataSurfaceShmem->memory());
+  const char* src = reinterpret_cast<char*>(map->GetData());
+  const char* endSrc = src + (srcSize.height * srcStride);
+  while (src < endSrc) {
+    memcpy(dst, src, dataFormatWidth);
+    src += srcStride;
+    dst += dataFormatWidth;
+  }
+}
+
+void CanvasTranslator::RecycleBuffer() {
+  mCanvasShmems.emplace(std::move(mCurrentShmem));
+  NextBuffer();
+}
+
+void CanvasTranslator::NextBuffer() {
+  mCurrentShmem = std::move(mCanvasShmems.front());
+  mCanvasShmems.pop();
+  mCurrentMemReader = mCurrentShmem.CreateMemReader();
 }
 
 void CanvasTranslator::ActorDestroy(ActorDestroyReason why) {
@@ -196,12 +302,6 @@
 
 void CanvasTranslator::FinishShutdown() {
   MOZ_ASSERT(gfx::CanvasRenderThread::IsInCanvasRenderThread());
-
-  // mTranslationTaskQueue has shutdown we can safely drop the ring buffer to
-  // break the cycle caused by RingBufferReaderServices.
-  mStream = nullptr;
-
-  gfx::CanvasManagerParent::RemoveReplayTextures(this);
 }
 
 bool CanvasTranslator::CheckDeactivated() {
@@ -221,10 +321,10 @@
     return;
   }
   mDeactivated = true;
+  mHeader->readerState = State::Failed;
 
   // We need to tell the other side to deactivate. Make sure the stream is
   // marked as bad so that the writing side won't wait for space to write.
-  mStream->SetIsBad();
   gfx::CanvasRenderThread::Dispatch(
       NewRunnableMethod("CanvasTranslator::SendDeactivate", this,
                         &CanvasTranslator::SendDeactivate));
@@ -238,20 +338,101 @@
   gfx::CanvasManagerParent::DisableRemoteCanvas();
 }
 
-bool CanvasTranslator::TranslateRecording() {
-  MOZ_ASSERT(IsInTaskQueue());
+void CanvasTranslator::CheckAndSignalWriter() {
+  do {
+    switch (mHeader->writerState) {
+      case State::Processing:
+        return;
+      case State::AboutToWait:
+        // The writer is making a decision about whether to wait. So, we must
+        // wait until it has decided to avoid races. Check if the writer is
+        // closed to avoid hangs.
+        if (!CanSend()) {
+          return;
+        }
+        continue;
+      case State::Waiting:
+        if (mHeader->processedCount >= mHeader->writerWaitCount) {
+          mHeader->writerState = State::Processing;
+          mWriterSemaphore->Signal();
+        }
+        return;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Invalid waiting state.");
+        return;
+    }
+  } while (true);
+}
 
-  if (!mStream) {
+bool CanvasTranslator::HasPendingEvent() {
+  return mHeader->processedCount < mHeader->eventCount;
+}
+
+bool CanvasTranslator::ReadPendingEvent(EventType& aEventType) {
+  ReadElementConstrained(mCurrentMemReader, aEventType,
+                         EventType::DRAWTARGETCREATION, LAST_CANVAS_EVENT_TYPE);
+  return mCurrentMemReader.good();
+}
+
+bool CanvasTranslator::ReadNextEvent(EventType& aEventType) {
+  if (mHeader->readerState == State::Paused) {
+    Flush();
     return false;
   }
 
-  uint8_t eventType = mStream->ReadNextEvent();
-  while (mStream->good() && eventType != kDropBufferEventType) {
-    bool success = RecordedEvent::DoWithEventFromStream(
-        *mStream, static_cast<RecordedEvent::EventType>(eventType),
+  uint32_t spinCount = mMaxSpinCount;
+  do {
+    if (HasPendingEvent()) {
+      return ReadPendingEvent(aEventType);
+    }
+  } while (--spinCount != 0);
+
+  Flush();
+  mHeader->readerState = State::AboutToWait;
+  if (HasPendingEvent()) {
+    mHeader->readerState = State::Processing;
+    return ReadPendingEvent(aEventType);
+  }
+
+  if (!mIsInTransaction) {
+    mHeader->readerState = State::Stopped;
+    return false;
+  }
+
+  // When in a transaction we wait for a short time because we're expecting more
+  // events from the content process. We don't want to wait for too long in case
+  // other content processes are waiting for events to process.
+  mHeader->readerState = State::Waiting;
+  if (mReaderSemaphore->Wait(Some(mNextEventTimeout))) {
+    MOZ_RELEASE_ASSERT(HasPendingEvent());
+    MOZ_RELEASE_ASSERT(mHeader->readerState == State::Processing);
+    return ReadPendingEvent(aEventType);
+  }
+
+  // We have to use compareExchange here because the writer can change our
+  // state if we are waiting.
+  if (!mHeader->readerState.compareExchange(State::Waiting, State::Stopped)) {
+    MOZ_RELEASE_ASSERT(HasPendingEvent());
+    MOZ_RELEASE_ASSERT(mHeader->readerState == State::Processing);
+    // The writer has just signaled us, so consume it before returning
+    MOZ_ALWAYS_TRUE(mReaderSemaphore->Wait());
+    return ReadPendingEvent(aEventType);
+  }
+
+  return false;
+}
+
+void CanvasTranslator::TranslateRecording() {
+  MOZ_ASSERT(IsInTaskQueue());
+
+  mHeader->readerState = State::Processing;
+  EventType eventType;
+  while (ReadNextEvent(eventType)) {
+    bool success = RecordedEvent::DoWithEventFromReader(
+        mCurrentMemReader, eventType,
         [&](RecordedEvent* recordedEvent) -> bool {
           // Make sure that the whole event was read from the stream.
-          if (!mStream->good()) {
+          if (!mCurrentMemReader.good()) {
             if (!CanSend()) {
               // The other side has closed only warn about read failure.
               gfxWarning() << "Failed to read event type: "
@@ -267,8 +448,8 @@
         });
 
     // Check the stream is good here or we will log the issue twice.
-    if (!mStream->good()) {
-      return true;
+    if (!mCurrentMemReader.good()) {
+      return;
     }
 
     if (!success && !HandleExtensionEvent(eventType)) {
@@ -279,34 +460,16 @@
       } else {
         gfxCriticalNote << "Failed to play canvas event type: " << eventType;
       }
-      if (!mStream->good()) {
-        return true;
-      }
-    }
-
-    if (!mIsInTransaction) {
-      return mStream->StopIfEmpty();
     }
 
-    if (!mStream->HasDataToRead()) {
-      // We're going to wait for the next event, so take the opportunity to
-      // flush the rendering.
-      Flush();
-      if (!mStream->WaitForDataToRead(kReadEventTimeout, 0)) {
-        return true;
-      }
-    }
-
-    eventType = mStream->ReadNextEvent();
+    mHeader->processedCount++;
   }
-
-  return true;
 }
 
 #define READ_AND_PLAY_CANVAS_EVENT_TYPE(_typeenum, _class)             \
   case _typeenum: {                                                    \
-    auto e = _class(*mStream);                                         \
-    if (!mStream->good()) {                                            \
+    auto e = _class(mCurrentMemReader);                                \
+    if (!mCurrentMemReader.good()) {                                   \
       if (!CanSend()) {                                                \
         /* The other side has closed only warn about read failure. */  \
         gfxWarning() << "Failed to read event type: " << _typeenum;    \
@@ -475,6 +638,12 @@
   return SharedSurfacesParent::Get(wr::ToExternalImageId(aKey));
 }
 
+void CanvasTranslator::CheckpointReached() { CheckAndSignalWriter(); }
+
+void CanvasTranslator::PauseTranslation() {
+  mHeader->readerState = State::Paused;
+}
+
 already_AddRefed<gfx::GradientStops> CanvasTranslator::GetOrCreateGradientStops(
     gfx::GradientStop* aRawStops, uint32_t aNumStops,
     gfx::ExtendMode aExtendMode) {