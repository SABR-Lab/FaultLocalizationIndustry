# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/PersistentBufferProvider.cpp
# Commit: 31935f164ef0
# Full Hash: 31935f164ef0d6c4668f211482c139847dcab7f2
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-13 00:43:26
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 13c9bf69085f -r 31935f164ef0 gfx/layers/PersistentBufferProvider.cpp
--- a/gfx/layers/PersistentBufferProvider.cpp	Tue Dec 12 07:35:02 2023 +0000
+++ b/gfx/layers/PersistentBufferProvider.cpp	Tue Dec 12 07:35:03 2023 +0000
@@ -6,6 +6,7 @@
 
 #include "PersistentBufferProvider.h"
 
+#include "mozilla/layers/RemoteTextureMap.h"
 #include "mozilla/layers/TextureClient.h"
 #include "mozilla/layers/TextureForwarder.h"
 #include "mozilla/gfx/gfxVars.h"
@@ -96,65 +97,149 @@
   return provider.forget();
 }
 
+static already_AddRefed<TextureClient> CreateTexture(
+    KnowsCompositor* aKnowsCompositor, gfx::SurfaceFormat aFormat,
+    gfx::IntSize aSize, bool aWillReadFrequently = false,
+    Maybe<RemoteTextureOwnerId> aRemoteTextureOwnerId = {}) {
+  TextureAllocationFlags flags = ALLOC_DEFAULT;
+  if (aWillReadFrequently) {
+    flags = TextureAllocationFlags(flags | ALLOC_DO_NOT_ACCELERATE);
+  }
+  if (aRemoteTextureOwnerId) {
+    flags = TextureAllocationFlags(flags | ALLOC_FORCE_REMOTE);
+  }
+  RefPtr<TextureClient> tc = TextureClient::CreateForDrawing(
+      aKnowsCompositor, aFormat, aSize, BackendSelector::Canvas,
+      TextureFlags::DEFAULT | TextureFlags::NON_BLOCKING_READ_LOCK, flags);
+  if (tc && aRemoteTextureOwnerId) {
+    if (TextureData* td = tc->GetInternalData()) {
+      td->SetRemoteTextureOwnerId(*aRemoteTextureOwnerId);
+    }
+  }
+  return tc.forget();
+}
+
+// static
+already_AddRefed<PersistentBufferProviderAccelerated>
+PersistentBufferProviderAccelerated::Create(gfx::IntSize aSize,
+                                            gfx::SurfaceFormat aFormat,
+                                            KnowsCompositor* aKnowsCompositor) {
+  if (!DrawTargetWebgl::CanCreate(aSize, aFormat)) {
+    return nullptr;
+  }
+
+  if (!aKnowsCompositor || !aKnowsCompositor->GetTextureForwarder() ||
+      !aKnowsCompositor->GetTextureForwarder()->IPCOpen()) {
+    return nullptr;
+  }
+
+  auto remoteTextureOwnerId = RemoteTextureOwnerId::GetNext();
+
+  RefPtr<TextureClient> texture = CreateTexture(
+      aKnowsCompositor, aFormat, aSize, false, Some(remoteTextureOwnerId));
+  if (!texture) {
+    return nullptr;
+  }
+
+  RefPtr<PersistentBufferProviderAccelerated> provider =
+      new PersistentBufferProviderAccelerated(texture);
+  return provider.forget();
+}
+
 PersistentBufferProviderAccelerated::PersistentBufferProviderAccelerated(
-    DrawTarget* aDt)
-    : PersistentBufferProviderBasic(aDt) {
+    const RefPtr<TextureClient>& aTexture)
+    : mTexture(aTexture) {
   MOZ_COUNT_CTOR(PersistentBufferProviderAccelerated);
-  MOZ_ASSERT(aDt->GetBackendType() == BackendType::WEBGL);
 }
 
 PersistentBufferProviderAccelerated::~PersistentBufferProviderAccelerated() {
   MOZ_COUNT_DTOR(PersistentBufferProviderAccelerated);
+  Destroy();
 }
 
-inline gfx::DrawTargetWebgl*
-PersistentBufferProviderAccelerated::GetDrawTargetWebgl() const {
-  return static_cast<gfx::DrawTargetWebgl*>(mDrawTarget.get());
-}
+void PersistentBufferProviderAccelerated::Destroy() {
+  mSnapshot = nullptr;
+  mDrawTarget = nullptr;
 
-Maybe<layers::SurfaceDescriptor>
-PersistentBufferProviderAccelerated::GetFrontBuffer() {
-  return GetDrawTargetWebgl()->GetFrontBuffer();
+  if (mTexture) {
+    if (mTexture->IsLocked()) {
+      MOZ_ASSERT(false);
+      mTexture->Unlock();
+    }
+    mTexture = nullptr;
+  }
 }
 
 already_AddRefed<gfx::DrawTarget>
 PersistentBufferProviderAccelerated::BorrowDrawTarget(
     const gfx::IntRect& aPersistedRect) {
-  GetDrawTargetWebgl()->BeginFrame(aPersistedRect);
-  return PersistentBufferProviderBasic::BorrowDrawTarget(aPersistedRect);
+  if (!mDrawTarget) {
+    if (!mTexture->Lock(OpenMode::OPEN_READ_WRITE)) {
+      return nullptr;
+    }
+    mDrawTarget = mTexture->BorrowDrawTarget();
+    if (mDrawTarget) {
+      mDrawTarget->ClearRect(Rect(0, 0, 0, 0));
+      if (!mDrawTarget->IsValid()) {
+        mDrawTarget = nullptr;
+      }
+    }
+  }
+  return do_AddRef(mDrawTarget);
 }
 
 bool PersistentBufferProviderAccelerated::ReturnDrawTarget(
     already_AddRefed<gfx::DrawTarget> aDT) {
-  bool result = PersistentBufferProviderBasic::ReturnDrawTarget(std::move(aDT));
-  GetDrawTargetWebgl()->EndFrame();
-  return result;
+  {
+    RefPtr<gfx::DrawTarget> dt(aDT);
+    MOZ_ASSERT(mDrawTarget == dt);
+    if (!mDrawTarget) {
+      return false;
+    }
+    mDrawTarget = nullptr;
+  }
+  mTexture->Unlock();
+  return true;
 }
 
 already_AddRefed<gfx::SourceSurface>
 PersistentBufferProviderAccelerated::BorrowSnapshot(gfx::DrawTarget* aTarget) {
-  mSnapshot = GetDrawTargetWebgl()->GetOptimizedSnapshot(aTarget);
+  if (mDrawTarget) {
+    MOZ_ASSERT(mTexture->IsLocked());
+  } else {
+    if (mTexture->IsLocked()) {
+      MOZ_ASSERT(false);
+      return nullptr;
+    }
+    if (!mTexture->Lock(OpenMode::OPEN_READ)) {
+      return nullptr;
+    }
+  }
+  mSnapshot = mTexture->BorrowSnapshot();
   return do_AddRef(mSnapshot);
 }
 
+void PersistentBufferProviderAccelerated::ReturnSnapshot(
+    already_AddRefed<gfx::SourceSurface> aSnapshot) {
+  RefPtr<SourceSurface> snapshot = aSnapshot;
+  MOZ_ASSERT(!snapshot || snapshot == mSnapshot);
+  snapshot = nullptr;
+  mTexture->ReturnSnapshot(mSnapshot.forget());
+  if (!mDrawTarget) {
+    mTexture->Unlock();
+  }
+}
+
+Maybe<SurfaceDescriptor> PersistentBufferProviderAccelerated::GetFrontBuffer() {
+  SurfaceDescriptor desc;
+  if (mTexture->GetInternalData()->Serialize(desc)) {
+    return Some(desc);
+  }
+  return Nothing();
+}
+
 bool PersistentBufferProviderAccelerated::RequiresRefresh() const {
-  return GetDrawTargetWebgl()->RequiresRefresh();
-}
-
-void PersistentBufferProviderAccelerated::OnMemoryPressure() {
-  GetDrawTargetWebgl()->OnMemoryPressure();
-}
-
-static already_AddRefed<TextureClient> CreateTexture(
-    KnowsCompositor* aKnowsCompositor, gfx::SurfaceFormat aFormat,
-    gfx::IntSize aSize, bool aWillReadFrequently) {
-  TextureAllocationFlags flags = ALLOC_DEFAULT;
-  if (aWillReadFrequently) {
-    flags = TextureAllocationFlags(flags | ALLOC_DO_NOT_ACCELERATE);
-  }
-  return TextureClient::CreateForDrawing(
-      aKnowsCompositor, aFormat, aSize, BackendSelector::Canvas,
-      TextureFlags::DEFAULT | TextureFlags::NON_BLOCKING_READ_LOCK, flags);
+  return mTexture->GetInternalData()->RequiresRefresh();
 }
 
 // static
@@ -198,7 +283,6 @@
     gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
     KnowsCompositor* aKnowsCompositor, RefPtr<TextureClient>& aTexture,
     bool aWillReadFrequently)
-
     : mSize(aSize),
       mFormat(aFormat),
       mKnowsCompositor(aKnowsCompositor),