# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/client/TextureClient.cpp
# Commit: 31935f164ef0
# Full Hash: 31935f164ef0d6c4668f211482c139847dcab7f2
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-13 00:43:26
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 13c9bf69085f -r 31935f164ef0 gfx/layers/client/TextureClient.cpp
--- a/gfx/layers/client/TextureClient.cpp	Tue Dec 12 07:35:02 2023 +0000
+++ b/gfx/layers/client/TextureClient.cpp	Tue Dec 12 07:35:03 2023 +0000
@@ -319,6 +319,36 @@
 }
 
 /* static */
+TextureData* TextureData::Create(TextureType aTextureType,
+                                 gfx::SurfaceFormat aFormat,
+                                 const gfx::IntSize& aSize,
+                                 TextureAllocationFlags aAllocFlags,
+                                 gfx::BackendType aBackendType) {
+  switch (aTextureType) {
+#ifdef XP_WIN
+    case TextureType::D3D11:
+      return D3D11TextureData::Create(aSize, aFormat, aAllocFlags);
+#endif
+
+#ifdef MOZ_WIDGET_GTK
+    case TextureType::DMABUF:
+      return DMABUFTextureData::Create(aSize, aFormat, aBackendType);
+#endif
+
+#ifdef XP_MACOSX
+    case TextureType::MacIOSurface:
+      return MacIOSurfaceTextureData::Create(aSize, aFormat, aBackendType);
+#endif
+#ifdef MOZ_WIDGET_ANDROID
+    case TextureType::AndroidNativeWindow:
+      return AndroidNativeWindowTextureData::Create(aSize, aFormat);
+#endif
+    default:
+      return nullptr;
+  }
+}
+
+/* static */
 TextureData* TextureData::Create(TextureForwarder* aAllocator,
                                  gfx::SurfaceFormat aFormat, gfx::IntSize aSize,
                                  KnowsCompositor* aKnowsCompositor,
@@ -328,45 +358,33 @@
   TextureType textureType =
       GetTextureType(aFormat, aSize, aKnowsCompositor, aSelector, aAllocFlags);
 
-  if (ShouldRemoteTextureType(textureType, aSelector)) {
+  if ((aAllocFlags & ALLOC_FORCE_REMOTE) ||
+      ShouldRemoteTextureType(textureType, aSelector)) {
     RefPtr<CanvasChild> canvasChild = aAllocator->GetCanvasChild();
     if (canvasChild) {
       return new RecordedTextureData(canvasChild.forget(), aSize, aFormat,
                                      textureType);
     }
+    if (aAllocFlags & ALLOC_FORCE_REMOTE) {
+      // If we must be remote, but there is no canvas child, then falling back
+      // is not possible.
+      return nullptr;
+    }
 
     // We don't have a CanvasChild, but are supposed to be remote.
     // Fall back to software.
     textureType = TextureType::Unknown;
   }
 
+  gfx::BackendType moz2DBackend = gfx::BackendType::NONE;
+
 #if defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
-  gfx::BackendType moz2DBackend = BackendTypeForBackendSelector(
+  moz2DBackend = BackendTypeForBackendSelector(
       aKnowsCompositor->GetCompositorBackendType(), aSelector);
 #endif
 
-  switch (textureType) {
-#ifdef XP_WIN
-    case TextureType::D3D11:
-      return D3D11TextureData::Create(aSize, aFormat, aAllocFlags);
-#endif
-
-#ifdef MOZ_WIDGET_GTK
-    case TextureType::DMABUF:
-      return DMABUFTextureData::Create(aSize, aFormat, moz2DBackend);
-#endif
-
-#ifdef XP_MACOSX
-    case TextureType::MacIOSurface:
-      return MacIOSurfaceTextureData::Create(aSize, aFormat, moz2DBackend);
-#endif
-#ifdef MOZ_WIDGET_ANDROID
-    case TextureType::AndroidNativeWindow:
-      return AndroidNativeWindowTextureData::Create(aSize, aFormat);
-#endif
-    default:
-      return nullptr;
-  }
+  return TextureData::Create(textureType, aFormat, aSize, aAllocFlags,
+                             moz2DBackend);
 }
 
 /* static */
@@ -515,6 +533,7 @@
   }
 
   mBorrowedDrawTarget = nullptr;
+  mBorrowedSnapshot = false;
   mReadLock = nullptr;
 
   RefPtr<TextureChild> actor = mActor;
@@ -670,6 +689,7 @@
 
     mBorrowedDrawTarget = nullptr;
   }
+  mBorrowedSnapshot = false;
 
   if (mOpenMode & OpenMode::OPEN_WRITE) {
     mUpdated = true;
@@ -806,6 +826,7 @@
   MOZ_ASSERT(mBorrowedDrawTarget->refCount() <= mExpectedDtRefs);
 
   mBorrowedDrawTarget = nullptr;
+  mBorrowedSnapshot = false;
   mData->EndDraw();
 }
 
@@ -813,7 +834,9 @@
   MOZ_ASSERT(mIsLocked);
 
   RefPtr<gfx::SourceSurface> surface = mData->BorrowSnapshot();
-  if (!surface) {
+  if (surface) {
+    mBorrowedSnapshot = true;
+  } else {
     RefPtr<gfx::DrawTarget> drawTarget = BorrowDrawTarget();
     if (!drawTarget) {
       return nullptr;
@@ -824,6 +847,15 @@
   return surface.forget();
 }
 
+void TextureClient::ReturnSnapshot(
+    already_AddRefed<gfx::SourceSurface> aSnapshot) {
+  RefPtr<gfx::SourceSurface> snapshot = aSnapshot;
+  if (mBorrowedSnapshot) {
+    mData->ReturnSnapshot(snapshot.forget());
+    mBorrowedSnapshot = false;
+  }
+}
+
 bool TextureClient::BorrowMappedData(MappedTextureData& aMap) {
   MOZ_ASSERT(IsValid());
 
@@ -1160,6 +1192,10 @@
   if (data) {
     return MakeAndAddRef<TextureClient>(data, aTextureFlags, aAllocator);
   }
+  if (aAllocFlags & ALLOC_FORCE_REMOTE) {
+    // If we must be remote, but allocation failed, then don't fall back.
+    return nullptr;
+  }
 
   // Can't do any better than a buffer texture client.
   return TextureClient::CreateForRawBufferAccess(aAllocator, aFormat, aSize,