# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasChild.cpp
# Commit: 31935f164ef0
# Full Hash: 31935f164ef0d6c4668f211482c139847dcab7f2
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-13 00:43:26
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 13c9bf69085f -r 31935f164ef0 gfx/layers/ipc/CanvasChild.cpp
--- a/gfx/layers/ipc/CanvasChild.cpp	Tue Dec 12 07:35:02 2023 +0000
+++ b/gfx/layers/ipc/CanvasChild.cpp	Tue Dec 12 07:35:03 2023 +0000
@@ -15,6 +15,7 @@
 #include "mozilla/ipc/Endpoint.h"
 #include "mozilla/ipc/ProcessChild.h"
 #include "mozilla/layers/CanvasDrawEventRecorder.h"
+#include "mozilla/layers/ImageDataSerializer.h"
 #include "mozilla/layers/SourceSurfaceSharedData.h"
 #include "mozilla/Maybe.h"
 #include "nsIObserverService.h"
@@ -30,22 +31,22 @@
 
   ~RecorderHelpers() override = default;
 
-  bool InitTranslator(const TextureType& aTextureType, Handle&& aReadHandle,
-                      nsTArray<Handle>&& aBufferHandles,
-                      const uint64_t& aBufferSize,
+  bool InitTranslator(TextureType aTextureType, gfx::BackendType aBackendType,
+                      Handle&& aReadHandle, nsTArray<Handle>&& aBufferHandles,
+                      uint64_t aBufferSize,
                       CrossProcessSemaphoreHandle&& aReaderSem,
                       CrossProcessSemaphoreHandle&& aWriterSem,
-                      const bool& aUseIPDLThread) override {
+                      bool aUseIPDLThread) override {
     if (!mCanvasChild) {
       return false;
     }
     return mCanvasChild->SendInitTranslator(
-        aTextureType, std::move(aReadHandle), std::move(aBufferHandles),
-        aBufferSize, std::move(aReaderSem), std::move(aWriterSem),
-        aUseIPDLThread);
+        aTextureType, aBackendType, std::move(aReadHandle),
+        std::move(aBufferHandles), aBufferSize, std::move(aReaderSem),
+        std::move(aWriterSem), aUseIPDLThread);
   }
 
-  bool AddBuffer(Handle&& aBufferHandle, const uint64_t& aBufferSize) override {
+  bool AddBuffer(Handle&& aBufferHandle, uint64_t aBufferSize) override {
     if (!mCanvasChild) {
       return false;
     }
@@ -75,10 +76,11 @@
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(SourceSurfaceCanvasRecording, final)
 
   SourceSurfaceCanvasRecording(
-      const RefPtr<gfx::SourceSurface>& aRecordedSuface,
+      int64_t aTextureId, const RefPtr<gfx::SourceSurface>& aRecordedSuface,
       CanvasChild* aCanvasChild,
       const RefPtr<CanvasDrawEventRecorder>& aRecorder)
-      : mRecordedSurface(aRecordedSuface),
+      : mTextureId(aTextureId),
+        mRecordedSurface(aRecordedSuface),
         mCanvasChild(aCanvasChild),
         mRecorder(aRecorder) {
     // It's important that AddStoredObject is called first because that will
@@ -119,11 +121,14 @@
     return do_AddRef(mDataSourceSurface);
   }
 
+  void DrawTargetWillChange() { mDetached = true; }
+
  private:
   void EnsureDataSurfaceOnMainThread() {
     // The data can only be retrieved on the main thread.
     if (!mDataSourceSurface && NS_IsMainThread()) {
-      mDataSourceSurface = mCanvasChild->GetDataSurface(mRecordedSurface);
+      mDataSourceSurface =
+          mCanvasChild->GetDataSurface(mTextureId, mRecordedSurface, mDetached);
     }
   }
 
@@ -141,10 +146,12 @@
     aRecorder = nullptr;
   }
 
+  int64_t mTextureId;
   RefPtr<gfx::SourceSurface> mRecordedSurface;
   RefPtr<CanvasChild> mCanvasChild;
   RefPtr<CanvasDrawEventRecorder> mRecorder;
   RefPtr<gfx::DataSourceSurface> mDataSourceSurface;
+  bool mDetached = false;
 };
 
 CanvasChild::CanvasChild() = default;
@@ -176,11 +183,21 @@
   return IPC_OK();
 }
 
+ipc::IPCResult CanvasChild::RecvBlockCanvas() {
+  if (auto* cm = gfx::CanvasManagerChild::Get()) {
+    cm->BlockCanvas();
+  }
+  return IPC_OK();
+}
+
 void CanvasChild::EnsureRecorder(gfx::IntSize aSize, gfx::SurfaceFormat aFormat,
                                  TextureType aTextureType) {
   if (!mRecorder) {
+    gfx::BackendType backendType =
+        gfxPlatform::GetPlatform()->GetPreferredCanvasBackend();
     auto recorder = MakeRefPtr<CanvasDrawEventRecorder>();
-    if (!recorder->Init(aTextureType, MakeUnique<RecorderHelpers>(this))) {
+    if (!recorder->Init(aTextureType, backendType,
+                        MakeUnique<RecorderHelpers>(this))) {
       return;
     }
 
@@ -276,19 +293,26 @@
 }
 
 already_AddRefed<gfx::DrawTarget> CanvasChild::CreateDrawTarget(
-    gfx::IntSize aSize, gfx::SurfaceFormat aFormat) {
+    int64_t aTextureId, gfx::IntSize aSize, gfx::SurfaceFormat aFormat) {
   RefPtr<gfx::DrawTarget> dummyDt = gfx::Factory::CreateDrawTarget(
       gfx::BackendType::SKIA, gfx::IntSize(1, 1), aFormat);
   RefPtr<gfx::DrawTarget> dt = MakeAndAddRef<gfx::DrawTargetRecording>(
       mRecorder, dummyDt, gfx::IntRect(gfx::IntPoint(0, 0), aSize));
+
+  mTextureInfo.insert({aTextureId, {}});
+
   return dt.forget();
 }
 
 bool CanvasChild::EnsureDataSurfaceShmem(gfx::IntSize aSize,
                                          gfx::SurfaceFormat aFormat) {
-  size_t dataFormatWidth = aSize.width * BytesPerPixel(aFormat);
   size_t sizeRequired =
-      ipc::SharedMemory::PageAlignedSize(dataFormatWidth * aSize.height);
+      ImageDataSerializer::ComputeRGBBufferSize(aSize, aFormat);
+  if (!sizeRequired) {
+    return false;
+  }
+  sizeRequired = ipc::SharedMemory::PageAlignedSize(sizeRequired);
+
   if (!mDataSurfaceShmemAvailable || mDataSurfaceShmem->Size() < sizeRequired) {
     RecordEvent(RecordedPauseTranslation());
     auto dataSurfaceShmem = MakeRefPtr<ipc::SharedMemoryBasic>();
@@ -328,7 +352,7 @@
 }
 
 already_AddRefed<gfx::DataSourceSurface> CanvasChild::GetDataSurface(
-    const gfx::SourceSurface* aSurface) {
+    int64_t aTextureId, const gfx::SourceSurface* aSurface, bool aDetached) {
   MOZ_DIAGNOSTIC_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aSurface);
 
@@ -344,6 +368,26 @@
     return nullptr;
   }
 
+  // Shmem is only valid if the surface is the latest snapshot (not detached).
+  if (!aDetached) {
+    // If there is a shmem associated with this snapshot id, then we want to try
+    // use that directly without having to allocate a new shmem for retrieval.
+    auto it = mTextureInfo.find(aTextureId);
+    if (it != mTextureInfo.end() && it->second.mSnapshotShmem.IsReadable()) {
+      ipc::Shmem& shmem = it->second.mSnapshotShmem;
+      mRecorder->RecordEvent(RecordedPrepareShmem(aTextureId));
+      uint32_t checkpoint = mRecorder->CreateCheckpoint();
+      mRecorder->WaitForCheckpoint(checkpoint);
+      gfx::IntSize size = aSurface->GetSize();
+      gfx::SurfaceFormat format = aSurface->GetFormat();
+      auto stride = ImageDataSerializer::ComputeRGBStride(format, size.width);
+      RefPtr<gfx::DataSourceSurface> dataSurface =
+          gfx::Factory::CreateWrappingDataSourceSurface(shmem.get<uint8_t>(),
+                                                        stride, size, format);
+      return dataSurface.forget();
+    }
+  }
+
   RecordEvent(RecordedPrepareDataForSurface(aSurface));
 
   gfx::IntSize ssSize = aSurface->GetSize();
@@ -362,11 +406,11 @@
 
   auto* data = static_cast<uint8_t*>(mDataSurfaceShmem->memory());
   auto* closure = new DataShmemHolder{do_AddRef(mDataSurfaceShmem), this};
-  auto dataFormatWidth = ssSize.width * BytesPerPixel(ssFormat);
+  auto stride = ImageDataSerializer::ComputeRGBStride(ssFormat, ssSize.width);
 
   RefPtr<gfx::DataSourceSurface> dataSurface =
       gfx::Factory::CreateWrappingDataSourceSurface(
-          data, dataFormatWidth, ssSize, ssFormat,
+          data, stride, ssSize, ssFormat,
           [](void* aClosure) {
             auto* shmemHolder = static_cast<DataShmemHolder*>(aClosure);
             shmemHolder->canvasChild->ReturnDataSurfaceShmem(
@@ -380,12 +424,13 @@
 }
 
 already_AddRefed<gfx::SourceSurface> CanvasChild::WrapSurface(
-    const RefPtr<gfx::SourceSurface>& aSurface) {
+    const RefPtr<gfx::SourceSurface>& aSurface, int64_t aTextureId) {
   if (!aSurface) {
     return nullptr;
   }
 
-  return MakeAndAddRef<SourceSurfaceCanvasRecording>(aSurface, this, mRecorder);
+  return MakeAndAddRef<SourceSurfaceCanvasRecording>(aTextureId, aSurface, this,
+                                                     mRecorder);
 }
 
 void CanvasChild::ReturnDataSurfaceShmem(
@@ -398,5 +443,44 @@
   }
 }
 
+void CanvasChild::DetachSurface(const RefPtr<gfx::SourceSurface>& aSurface) {
+  if (auto* surface =
+          static_cast<SourceSurfaceCanvasRecording*>(aSurface.get())) {
+    surface->DrawTargetWillChange();
+  }
+}
+
+ipc::IPCResult CanvasChild::RecvNotifyRequiresRefresh(int64_t aTextureId) {
+  auto it = mTextureInfo.find(aTextureId);
+  if (it != mTextureInfo.end()) {
+    it->second.mRequiresRefresh = true;
+  }
+  return IPC_OK();
+}
+
+bool CanvasChild::RequiresRefresh(int64_t aTextureId) const {
+  auto it = mTextureInfo.find(aTextureId);
+  if (it != mTextureInfo.end()) {
+    return it->second.mRequiresRefresh;
+  }
+  return false;
+}
+
+ipc::IPCResult CanvasChild::RecvSnapshotShmem(
+    int64_t aTextureId, Shmem&& aShmem, SnapshotShmemResolver&& aResolve) {
+  auto it = mTextureInfo.find(aTextureId);
+  if (it != mTextureInfo.end()) {
+    it->second.mSnapshotShmem = std::move(aShmem);
+    aResolve(true);
+  } else {
+    aResolve(false);
+  }
+  return IPC_OK();
+}
+
+void CanvasChild::CleanupTexture(int64_t aTextureId) {
+  mTextureInfo.erase(aTextureId);
+}
+
 }  // namespace layers
 }  // namespace mozilla