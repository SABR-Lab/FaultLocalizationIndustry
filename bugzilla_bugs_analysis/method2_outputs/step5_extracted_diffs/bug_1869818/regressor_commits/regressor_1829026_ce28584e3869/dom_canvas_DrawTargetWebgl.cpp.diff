# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.cpp
# Commit: ce28584e3869
# Full Hash: ce28584e386976fc6df815260cdfebd8e6ffbadd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-19 05:06:09
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r bb4029ea69bb -r ce28584e3869 dom/canvas/DrawTargetWebgl.cpp
--- a/dom/canvas/DrawTargetWebgl.cpp	Mon Dec 18 18:10:46 2023 +0000
+++ b/dom/canvas/DrawTargetWebgl.cpp	Mon Dec 18 18:10:46 2023 +0000
@@ -239,12 +239,9 @@
 DrawTargetWebgl::~DrawTargetWebgl() {
   ClearSnapshot(false);
   if (mSharedContext) {
-    if (mShmem.IsWritable()) {
-      // Force any Skia snapshots to copy the shmem before it deallocs.
+    // Force any Skia snapshots to copy the shmem before it deallocs.
+    if (mSkia) {
       mSkia->DetachAllSnapshots();
-      if (mShmemAllocator && mShmemAllocator->CanSend()) {
-        mShmemAllocator->DeallocShmem(mShmem);
-      }
     }
     mSharedContext->ClearLastTexture(true);
     mClipMask = nullptr;
@@ -373,7 +370,6 @@
 // Try to initialize a new WebGL context. Verifies that the requested size does
 // not exceed the available texture limits and that shader creation succeeded.
 bool DrawTargetWebgl::Init(const IntSize& size, const SurfaceFormat format,
-                           ipc::IProtocol* aShmemAllocator,
                            const RefPtr<SharedContextWebgl>& aSharedContext) {
   MOZ_ASSERT(format == SurfaceFormat::B8G8R8A8 ||
              format == SurfaceFormat::B8G8R8X8);
@@ -398,24 +394,32 @@
     return false;
   }
 
-  mShmemAllocator = aShmemAllocator;
-  if (mShmemAllocator && mShmemAllocator->CanSend()) {
-    size_t byteSize = layers::ImageDataSerializer::ComputeRGBBufferSize(
-        mSize, SurfaceFormat::B8G8R8A8);
-    if (byteSize) {
-      (void)mShmemAllocator->AllocUnsafeShmem(byteSize, &mShmem);
-    }
-  }
+  size_t byteSize = layers::ImageDataSerializer::ComputeRGBBufferSize(
+      mSize, SurfaceFormat::B8G8R8A8);
+  if (byteSize == 0) {
+    return false;
+  }
+
+  size_t shmemSize = mozilla::ipc::SharedMemory::PageAlignedSize(byteSize);
+  if (NS_WARN_IF(shmemSize > UINT32_MAX)) {
+    MOZ_ASSERT_UNREACHABLE("Buffer too big?");
+    return false;
+  }
+
+  auto shmem = MakeRefPtr<mozilla::ipc::SharedMemoryBasic>();
+  if (NS_WARN_IF(!shmem->Create(shmemSize)) ||
+      NS_WARN_IF(!shmem->Map(shmemSize))) {
+    return false;
+  }
+
+  mShmem = std::move(shmem);
+  mShmemSize = shmemSize;
 
   mSkia = new DrawTargetSkia;
-  if (mShmem.IsWritable()) {
-    auto stride = layers::ImageDataSerializer::ComputeRGBStride(
-        SurfaceFormat::B8G8R8A8, size.width);
-    if (!mSkia->Init(mShmem.get<uint8_t>(), size, stride,
-                     SurfaceFormat::B8G8R8A8, true)) {
-      return false;
-    }
-  } else if (!mSkia->Init(size, SurfaceFormat::B8G8R8A8)) {
+  auto stride = layers::ImageDataSerializer::ComputeRGBStride(
+      SurfaceFormat::B8G8R8A8, size.width);
+  if (!mSkia->Init(reinterpret_cast<uint8_t*>(mShmem->memory()), size, stride,
+                   SurfaceFormat::B8G8R8A8, true)) {
     return false;
   }
 
@@ -858,7 +862,6 @@
 
 already_AddRefed<DrawTargetWebgl> DrawTargetWebgl::Create(
     const IntSize& aSize, SurfaceFormat aFormat,
-    ipc::IProtocol* aShmemAllocator,
     const RefPtr<SharedContextWebgl>& aSharedContext) {
   // Validate the size and format.
   if (!CanCreate(aSize, aFormat)) {
@@ -866,8 +869,7 @@
   }
 
   RefPtr<DrawTargetWebgl> dt = new DrawTargetWebgl;
-  if (!dt->Init(aSize, aFormat, aShmemAllocator, aSharedContext) ||
-      !dt->IsValid()) {
+  if (!dt->Init(aSize, aFormat, aSharedContext) || !dt->IsValid()) {
     return nullptr;
   }
 