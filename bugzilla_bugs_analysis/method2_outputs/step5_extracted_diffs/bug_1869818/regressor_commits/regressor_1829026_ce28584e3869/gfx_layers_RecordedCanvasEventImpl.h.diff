# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/RecordedCanvasEventImpl.h
# Commit: ce28584e3869
# Full Hash: ce28584e386976fc6df815260cdfebd8e6ffbadd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-19 05:06:09
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r bb4029ea69bb -r ce28584e3869 gfx/layers/RecordedCanvasEventImpl.h
--- a/gfx/layers/RecordedCanvasEventImpl.h	Mon Dec 18 18:10:46 2023 +0000
+++ b/gfx/layers/RecordedCanvasEventImpl.h	Mon Dec 18 18:10:46 2023 +0000
@@ -44,7 +44,8 @@
 const EventType PAUSE_TRANSLATION = EventType(EventType::LAST + 14);
 const EventType RECYCLE_BUFFER = EventType(EventType::LAST + 15);
 const EventType DROP_BUFFER = EventType(EventType::LAST + 16);
-const EventType LAST_CANVAS_EVENT_TYPE = DROP_BUFFER;
+const EventType PREPARE_SHMEM = EventType(EventType::LAST + 17);
+const EventType LAST_CANVAS_EVENT_TYPE = PREPARE_SHMEM;
 
 class RecordedCanvasBeginTransaction final
     : public RecordedEventDerived<RecordedCanvasBeginTransaction> {
@@ -138,10 +139,12 @@
 class RecordedTextureLock final
     : public RecordedEventDerived<RecordedTextureLock> {
  public:
-  RecordedTextureLock(int64_t aTextureId, const OpenMode aMode)
+  RecordedTextureLock(int64_t aTextureId, const OpenMode aMode,
+                      RemoteTextureId aId)
       : RecordedEventDerived(TEXTURE_LOCK),
         mTextureId(aTextureId),
-        mMode(aMode) {}
+        mMode(aMode),
+        mLastRemoteTextureId(aId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedTextureLock(S& aStream);
@@ -156,16 +159,14 @@
  private:
   int64_t mTextureId;
   OpenMode mMode;
+  RemoteTextureId mLastRemoteTextureId;
 };
 
 inline bool RecordedTextureLock::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  TextureData* textureData = aTranslator->LookupTextureData(mTextureId);
-  if (!textureData) {
+  if (!aTranslator->LockTexture(mTextureId, mMode, mLastRemoteTextureId)) {
     return false;
   }
-
-  textureData->Lock(mMode);
   return true;
 }
 
@@ -173,6 +174,7 @@
 void RecordedTextureLock::Record(S& aStream) const {
   WriteElement(aStream, mTextureId);
   WriteElement(aStream, mMode);
+  WriteElement(aStream, mLastRemoteTextureId.mId);
 }
 
 template <class S>
@@ -181,13 +183,16 @@
   ReadElement(aStream, mTextureId);
   ReadElementConstrained(aStream, mMode, OpenMode::OPEN_NONE,
                          OpenMode::OPEN_READ_WRITE_ASYNC);
+  ReadElement(aStream, mLastRemoteTextureId.mId);
 }
 
 class RecordedTextureUnlock final
     : public RecordedEventDerived<RecordedTextureUnlock> {
  public:
-  explicit RecordedTextureUnlock(int64_t aTextureId)
-      : RecordedEventDerived(TEXTURE_UNLOCK), mTextureId(aTextureId) {}
+  explicit RecordedTextureUnlock(int64_t aTextureId, RemoteTextureId aId)
+      : RecordedEventDerived(TEXTURE_UNLOCK),
+        mTextureId(aTextureId),
+        mLastRemoteTextureId(aId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedTextureUnlock(S& aStream);
@@ -201,28 +206,28 @@
 
  private:
   int64_t mTextureId;
+  RemoteTextureId mLastRemoteTextureId;
 };
 
 inline bool RecordedTextureUnlock::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  TextureData* textureData = aTranslator->LookupTextureData(mTextureId);
-  if (!textureData) {
+  if (!aTranslator->UnlockTexture(mTextureId, mLastRemoteTextureId)) {
     return false;
   }
-
-  textureData->Unlock();
   return true;
 }
 
 template <class S>
 void RecordedTextureUnlock::Record(S& aStream) const {
   WriteElement(aStream, mTextureId);
+  WriteElement(aStream, mLastRemoteTextureId.mId);
 }
 
 template <class S>
 RecordedTextureUnlock::RecordedTextureUnlock(S& aStream)
     : RecordedEventDerived(TEXTURE_UNLOCK) {
   ReadElement(aStream, mTextureId);
+  ReadElement(aStream, mLastRemoteTextureId.mId);
 }
 
 class RecordedCacheDataSurface final
@@ -486,8 +491,11 @@
 class RecordedNextTextureId final
     : public RecordedEventDerived<RecordedNextTextureId> {
  public:
-  explicit RecordedNextTextureId(int64_t aNextTextureId)
-      : RecordedEventDerived(NEXT_TEXTURE_ID), mNextTextureId(aNextTextureId) {}
+  RecordedNextTextureId(int64_t aNextTextureId,
+                        RemoteTextureOwnerId aRemoteTextureOwnerId)
+      : RecordedEventDerived(NEXT_TEXTURE_ID),
+        mNextTextureId(aNextTextureId),
+        mRemoteTextureOwnerId(aRemoteTextureOwnerId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedNextTextureId(S& aStream);
@@ -500,24 +508,28 @@
   std::string GetName() const final { return "RecordedNextTextureId"; }
 
  private:
-  int64_t mNextTextureId;
+  int64_t mNextTextureId = 0;
+  RemoteTextureOwnerId mRemoteTextureOwnerId;
+  RemoteTextureId mRemoteTextureId;
 };
 
 inline bool RecordedNextTextureId::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  aTranslator->SetNextTextureId(mNextTextureId);
+  aTranslator->SetNextTextureId(mNextTextureId, mRemoteTextureOwnerId);
   return true;
 }
 
 template <class S>
 void RecordedNextTextureId::Record(S& aStream) const {
   WriteElement(aStream, mNextTextureId);
+  WriteElement(aStream, mRemoteTextureOwnerId.mId);
 }
 
 template <class S>
 RecordedNextTextureId::RecordedNextTextureId(S& aStream)
     : RecordedEventDerived(NEXT_TEXTURE_ID) {
   ReadElement(aStream, mNextTextureId);
+  ReadElement(aStream, mRemoteTextureOwnerId.mId);
 }
 
 class RecordedTextureDestruction final
@@ -537,7 +549,7 @@
   std::string GetName() const final { return "RecordedTextureDestruction"; }
 
  private:
-  int64_t mTextureId;
+  int64_t mTextureId = 0;
 };
 
 inline bool RecordedTextureDestruction::PlayCanvasEvent(
@@ -638,6 +650,43 @@
   std::string GetName() const final { return "RecordedDropAndMoveNextBuffer"; }
 };
 
+class RecordedPrepareShmem final
+    : public RecordedEventDerived<RecordedPrepareShmem> {
+ public:
+  explicit RecordedPrepareShmem(int64_t aTextureId)
+      : RecordedEventDerived(PREPARE_SHMEM), mTextureId(aTextureId) {}
+
+  template <class S>
+  MOZ_IMPLICIT RecordedPrepareShmem(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template <class S>
+  void Record(S& aStream) const;
+
+  std::string GetName() const final { return "RecordedPrepareShmem"; }
+
+ private:
+  int64_t mTextureId = 0;
+};
+
+inline bool RecordedPrepareShmem::PlayCanvasEvent(
+    CanvasTranslator* aTranslator) const {
+  aTranslator->PrepareShmem(mTextureId);
+  return true;
+}
+
+template <class S>
+void RecordedPrepareShmem::Record(S& aStream) const {
+  WriteElement(aStream, mTextureId);
+}
+
+template <class S>
+RecordedPrepareShmem::RecordedPrepareShmem(S& aStream)
+    : RecordedEventDerived(PREPARE_SHMEM) {
+  ReadElement(aStream, mTextureId);
+}
+
 #define FOR_EACH_CANVAS_EVENT(f)                                   \
   f(CANVAS_BEGIN_TRANSACTION, RecordedCanvasBeginTransaction);     \
   f(CANVAS_END_TRANSACTION, RecordedCanvasEndTransaction);         \
@@ -655,7 +704,8 @@
   f(CHECKPOINT, RecordedCheckpoint);                               \
   f(PAUSE_TRANSLATION, RecordedPauseTranslation);                  \
   f(RECYCLE_BUFFER, RecordedRecycleBuffer);                        \
-  f(DROP_BUFFER, RecordedDropBuffer);
+  f(DROP_BUFFER, RecordedDropBuffer);                              \
+  f(PREPARE_SHMEM, RecordedPrepareShmem);
 
 }  // namespace layers
 }  // namespace mozilla