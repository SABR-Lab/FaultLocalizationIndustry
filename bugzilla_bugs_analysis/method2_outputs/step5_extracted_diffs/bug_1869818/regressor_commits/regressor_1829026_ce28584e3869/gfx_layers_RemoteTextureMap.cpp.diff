# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/RemoteTextureMap.cpp
# Commit: ce28584e3869
# Full Hash: ce28584e386976fc6df815260cdfebd8e6ffbadd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-19 05:06:09
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r bb4029ea69bb -r ce28584e3869 gfx/layers/RemoteTextureMap.cpp
--- a/gfx/layers/RemoteTextureMap.cpp	Mon Dec 18 18:10:46 2023 +0000
+++ b/gfx/layers/RemoteTextureMap.cpp	Mon Dec 18 18:10:46 2023 +0000
@@ -217,7 +217,7 @@
   }
 }
 
-RemoteTextureMap::RemoteTextureMap() : mMonitor("D3D11TextureMap::mMonitor") {}
+RemoteTextureMap::RemoteTextureMap() : mMonitor("RemoteTextureMap::mMonitor") {}
 
 RemoteTextureMap::~RemoteTextureMap() = default;
 
@@ -314,17 +314,7 @@
       // used by WebRender anymore.
       if (front->mTextureHost &&
           front->mTextureHost->NumCompositableRefs() == 0) {
-        // Recycle SharedTexture
-        if (front->mResourceWrapper) {
-          owner->mRecycledSharedTextures.push(
-              std::move(front->mResourceWrapper));
-        }
-        // Recycle BufferTextureData
-        if (!(front->mTextureHost->GetFlags() & TextureFlags::DUMMY_TEXTURE) &&
-            (front->mTextureData &&
-             front->mTextureData->AsBufferTextureData())) {
-          owner->mRecycledTextures.push(std::move(front->mTextureData));
-        }
+        owner->mReleasingTextureDataHolders.push_back(std::move(front));
         owner->mUsingTextureDataHolders.pop_front();
       } else if (front->mTextureHost &&
                  front->mTextureHost->NumCompositableRefs() >= 0) {
@@ -335,6 +325,19 @@
         owner->mUsingTextureDataHolders.pop_front();
       }
     }
+    while (!owner->mReleasingTextureDataHolders.empty()) {
+      auto& front = owner->mReleasingTextureDataHolders.front();
+      // Recycle SharedTexture
+      if (front->mResourceWrapper) {
+        owner->mRecycledSharedTextures.push(std::move(front->mResourceWrapper));
+      }
+      // Recycle BufferTextureData
+      if (!(front->mTextureHost->GetFlags() & TextureFlags::DUMMY_TEXTURE) &&
+          (front->mTextureData && front->mTextureData->AsBufferTextureData())) {
+        owner->mRecycledTextures.push(std::move(front->mTextureData));
+      }
+      owner->mReleasingTextureDataHolders.pop_front();
+    }
   }
 
   const auto info = RemoteTextureInfo(aTextureId, aOwnerId, aForPid);
@@ -445,8 +448,7 @@
     // SharedResourceWrapper/TextureData alive while the TextureHost is alive.
     if (holder->mTextureHost &&
         holder->mTextureHost->NumCompositableRefs() >= 0) {
-      RefPtr<nsISerialEventTarget> eventTarget =
-          MessageLoop::current()->SerialEventTarget();
+      RefPtr<nsISerialEventTarget> eventTarget = GetCurrentSerialEventTarget();
       RefPtr<Runnable> runnable = NS_NewRunnableFunction(
           "RemoteTextureMap::UnregisterTextureOwner::Runnable",
           [data = std::move(holder->mTextureData),
@@ -511,6 +513,9 @@
     KeepTextureDataAliveForTextureHostIfNecessary(
         lock, it->second->mUsingTextureDataHolders);
 
+    KeepTextureDataAliveForTextureHostIfNecessary(
+        lock, it->second->mReleasingTextureDataHolders);
+
     releasingOwner = std::move(it->second);
     mTextureOwners.erase(it);
 
@@ -577,6 +582,9 @@
       KeepTextureDataAliveForTextureHostIfNecessary(
           lock, it->second->mUsingTextureDataHolders);
 
+      KeepTextureDataAliveForTextureHostIfNecessary(
+          lock, it->second->mReleasingTextureDataHolders);
+
       releasingOwners.push_back(std::move(it->second));
       mTextureOwners.erase(it);
     }
@@ -657,6 +665,19 @@
 
     UniquePtr<TextureDataHolder> holder = std::move(front);
     aOwner->mWaitingTextureDataHolders.pop_front();
+    // If there are textures not being used by the compositor that will be
+    // obsoleted by this new texture, then queue them for removal later on
+    // the creating thread.
+    while (!aOwner->mUsingTextureDataHolders.empty()) {
+      auto& back = aOwner->mUsingTextureDataHolders.back();
+      if (back->mTextureHost &&
+          back->mTextureHost->NumCompositableRefs() == 0) {
+        aOwner->mReleasingTextureDataHolders.push_back(std::move(back));
+        aOwner->mUsingTextureDataHolders.pop_back();
+        continue;
+      }
+      break;
+    }
     aOwner->mUsingTextureDataHolders.push_back(std::move(holder));
   }
 }
@@ -696,7 +717,8 @@
 
 bool RemoteTextureMap::GetRemoteTextureForDisplayList(
     RemoteTextureHostWrapper* aTextureHostWrapper,
-    std::function<void(const RemoteTextureInfo&)>&& aReadyCallback) {
+    std::function<void(const RemoteTextureInfo&)>&& aReadyCallback,
+    bool aWaitForRemoteTextureOwner) {
   MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());
   MOZ_ASSERT(aTextureHostWrapper);
 
@@ -714,8 +736,23 @@
     MonitorAutoLock lock(mMonitor);
 
     auto* owner = GetTextureOwner(lock, ownerId, forPid);
-    if (!owner) {
-      return false;
+    // If there is no texture owner yet, then we might need to wait for one to
+    // be created, if allowed. If so, we must also wait for an initial texture
+    // host to be created so we can use it.
+    if (!owner || (aWaitForRemoteTextureOwner && !owner->mLatestTextureHost &&
+                   owner->mWaitingTextureDataHolders.empty())) {
+      if (!aWaitForRemoteTextureOwner) {
+        return false;
+      }
+      const TimeDuration timeout = TimeDuration::FromMilliseconds(10000);
+      while (!owner || (!owner->mLatestTextureHost &&
+                        owner->mWaitingTextureDataHolders.empty())) {
+        CVStatus status = mMonitor.Wait(timeout);
+        if (status == CVStatus::Timeout) {
+          return false;
+        }
+        owner = GetTextureOwner(lock, ownerId, forPid);
+      }
     }
 
     UpdateTexture(lock, owner, textureId);