# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.cpp
# Commit: ce28584e3869
# Full Hash: ce28584e386976fc6df815260cdfebd8e6ffbadd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-19 05:06:09
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r bb4029ea69bb -r ce28584e3869 gfx/layers/ipc/CanvasTranslator.cpp
--- a/gfx/layers/ipc/CanvasTranslator.cpp	Mon Dec 18 18:10:46 2023 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.cpp	Mon Dec 18 18:10:46 2023 +0000
@@ -10,17 +10,21 @@
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/CanvasManagerParent.h"
 #include "mozilla/gfx/CanvasRenderThread.h"
+#include "mozilla/gfx/DrawTargetWebgl.h"
 #include "mozilla/gfx/gfxVars.h"
 #include "mozilla/gfx/GPUParent.h"
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/ipc/Endpoint.h"
+#include "mozilla/layers/BufferTexture.h"
 #include "mozilla/layers/CanvasTranslator.h"
+#include "mozilla/layers/ImageDataSerializer.h"
 #include "mozilla/layers/SharedSurfacesParent.h"
 #include "mozilla/layers/TextureClient.h"
 #include "mozilla/StaticPrefs_gfx.h"
 #include "mozilla/SyncRunnable.h"
 #include "mozilla/TaskQueue.h"
 #include "mozilla/Telemetry.h"
+#include "GLContext.h"
 #include "RecordedCanvasEventImpl.h"
 
 #if defined(XP_WIN)
@@ -32,6 +36,7 @@
 namespace layers {
 
 TextureData* CanvasTranslator::CreateTextureData(TextureType aTextureType,
+                                                 gfx::BackendType aBackendType,
                                                  const gfx::IntSize& aSize,
                                                  gfx::SurfaceFormat aFormat) {
   TextureData* textureData = nullptr;
@@ -43,8 +48,16 @@
       break;
     }
 #endif
+    case TextureType::Unknown:
+      textureData = BufferTextureData::Create(
+          aSize, aFormat, gfx::BackendType::SKIA, LayersBackend::LAYERS_WR,
+          TextureFlags::DEALLOCATE_CLIENT | TextureFlags::REMOTE_TEXTURE,
+          ALLOC_CLEAR_BUFFER, nullptr);
+      break;
     default:
-      MOZ_CRASH("Unsupported TextureType for CanvasTranslator.");
+      textureData = TextureData::Create(aTextureType, aFormat, aSize,
+                                        ALLOC_CLEAR_BUFFER, aBackendType);
+      break;
   }
 
   return textureData;
@@ -64,12 +77,7 @@
   Telemetry::ScalarAdd(Telemetry::ScalarID::GFX_CANVAS_REMOTE_ACTIVATED, 1);
 }
 
-CanvasTranslator::~CanvasTranslator() {
-  // The textures need to be the last thing holding their DrawTargets, so that
-  // they can destroy them within a lock.
-  mDrawTargets.Clear();
-  mBaseDT = nullptr;
-}
+CanvasTranslator::~CanvasTranslator() = default;
 
 void CanvasTranslator::DispatchToTaskQueue(
     already_AddRefed<nsIRunnable> aRunnable) {
@@ -102,16 +110,30 @@
   return true;
 }
 
+bool CanvasTranslator::EnsureSharedContextWebgl() {
+  if (!mSharedContext || mSharedContext->IsContextLost()) {
+    mSharedContext = gfx::SharedContextWebgl::Create();
+    if (!mSharedContext || mSharedContext->IsContextLost()) {
+      mSharedContext = nullptr;
+      BlockCanvas();
+      return false;
+    }
+  }
+  return true;
+}
+
 mozilla::ipc::IPCResult CanvasTranslator::RecvInitTranslator(
-    const TextureType& aTextureType, Handle&& aReadHandle,
-    nsTArray<Handle>&& aBufferHandles, uint64_t aBufferSize,
-    CrossProcessSemaphoreHandle&& aReaderSem,
+    TextureType aTextureType, gfx::BackendType aBackendType,
+    Handle&& aReadHandle, nsTArray<Handle>&& aBufferHandles,
+    uint64_t aBufferSize, CrossProcessSemaphoreHandle&& aReaderSem,
     CrossProcessSemaphoreHandle&& aWriterSem, bool aUseIPDLThread) {
   if (mHeaderShmem) {
     return IPC_FAIL(this, "RecvInitTranslator called twice.");
   }
 
   mTextureType = aTextureType;
+  mBackendType = aBackendType;
+  mOtherPid = OtherPid();
 
   mHeaderShmem = MakeAndAddRef<ipc::SharedMemoryBasic>();
   if (!CreateAndMapShmem(mHeaderShmem, std::move(aReadHandle),
@@ -127,12 +149,15 @@
   mReaderSemaphore.reset(CrossProcessSemaphore::Create(std::move(aReaderSem)));
   mReaderSemaphore->CloseHandle();
 
-#if defined(XP_WIN)
   if (!CheckForFreshCanvasDevice(__LINE__)) {
     gfxCriticalNote << "GFX: CanvasTranslator failed to get device";
     return IPC_OK();
   }
-#endif
+
+  if (gfx::gfxVars::UseAcceleratedCanvas2D() && !EnsureSharedContextWebgl()) {
+    gfxCriticalNote
+        << "GFX: CanvasTranslator failed creating WebGL shared context";
+  }
 
   if (!aUseIPDLThread) {
     mTranslationTaskQueue = gfx::CanvasRenderThread::CreateWorkerTaskQueue();
@@ -269,24 +294,29 @@
 
   auto dstSize = surface->GetSize();
   auto srcSize = map->GetSurface()->GetSize();
-  int32_t dataFormatWidth = dstSize.width * BytesPerPixel(surface->GetFormat());
+  gfx::SurfaceFormat format = surface->GetFormat();
+  int32_t bpp = BytesPerPixel(format);
+  int32_t dataFormatWidth = dstSize.width * bpp;
   int32_t srcStride = map->GetStride();
   if (dataFormatWidth > srcStride || srcSize != dstSize) {
     return;
   }
 
-  auto requiredSize = dataFormatWidth * dstSize.height;
+  int32_t dstStride =
+      ImageDataSerializer::ComputeRGBStride(format, dstSize.width);
+  auto requiredSize =
+      ImageDataSerializer::ComputeRGBBufferSize(dstSize, format);
   if (requiredSize <= 0 || size_t(requiredSize) > mDataSurfaceShmem->Size()) {
     return;
   }
 
-  char* dst = static_cast<char*>(mDataSurfaceShmem->memory());
-  const char* src = reinterpret_cast<char*>(map->GetData());
-  const char* endSrc = src + (srcSize.height * srcStride);
+  uint8_t* dst = static_cast<uint8_t*>(mDataSurfaceShmem->memory());
+  const uint8_t* src = map->GetData();
+  const uint8_t* endSrc = src + (srcSize.height * srcStride);
   while (src < endSrc) {
     memcpy(dst, src, dataFormatWidth);
     src += srcStride;
-    dst += dataFormatWidth;
+    dst += dstStride;
   }
 }
 
@@ -318,6 +348,9 @@
 
 void CanvasTranslator::FinishShutdown() {
   MOZ_ASSERT(gfx::CanvasRenderThread::IsInCanvasRenderThread());
+
+  ClearTextureInfo();
+
   gfx::CanvasManagerParent::RemoveReplayTextures(this);
 }
 
@@ -326,7 +359,8 @@
     return true;
   }
 
-  if (NS_WARN_IF(!gfx::gfxVars::RemoteCanvasEnabled())) {
+  if (NS_WARN_IF(!gfx::gfxVars::RemoteCanvasEnabled() &&
+                 !gfx::gfxVars::UseAcceleratedCanvas2D())) {
     Deactivate();
   }
 
@@ -347,18 +381,31 @@
                         &CanvasTranslator::SendDeactivate));
 
   // Unlock all of our textures.
-  for (auto const& entry : mTextureDatas) {
-    entry.second->Unlock();
+  for (auto const& entry : mTextureInfo) {
+    if (entry.second.mTextureData) {
+      entry.second.mTextureData->Unlock();
+    }
   }
 
   // Disable remote canvas for all.
   gfx::CanvasManagerParent::DisableRemoteCanvas();
 }
 
+void CanvasTranslator::BlockCanvas() {
+  if (mDeactivated || mBlocked) {
+    return;
+  }
+  mBlocked = true;
+  gfx::CanvasRenderThread::Dispatch(
+      NewRunnableMethod("CanvasTranslator::SendBlockCanvas", this,
+                        &CanvasTranslator::SendBlockCanvas));
+}
+
 void CanvasTranslator::CheckAndSignalWriter() {
   do {
     switch (mHeader->writerState) {
       case State::Processing:
+      case State::Failed:
         return;
       case State::AboutToWait:
         // The writer is making a decision about whether to wait. So, we must
@@ -442,6 +489,15 @@
 void CanvasTranslator::TranslateRecording() {
   MOZ_ASSERT(IsInTaskQueue());
 
+  if (mSharedContext && EnsureSharedContextWebgl()) {
+    mSharedContext->EnterTlsScope();
+  }
+  auto exitTlsScope = MakeScopeExit([&] {
+    if (mSharedContext) {
+      mSharedContext->ExitTlsScope();
+    }
+  });
+
   mHeader->readerState = State::Processing;
   EventType eventType;
   while (ReadNextEvent(eventType)) {
@@ -543,25 +599,33 @@
     mReferenceTextureData->Unlock();
   }
 
-  mReferenceTextureData.reset(CreateTextureData(
-      mTextureType, gfx::IntSize(1, 1), gfx::SurfaceFormat::B8G8R8A8));
-  if (!mReferenceTextureData) {
+  mReferenceTextureData.reset(CreateTextureData(mTextureType, mBackendType,
+                                                gfx::IntSize(1, 1),
+                                                gfx::SurfaceFormat::B8G8R8A8));
+  if (!mReferenceTextureData ||
+      NS_WARN_IF(!mReferenceTextureData->Lock(OpenMode::OPEN_READ_WRITE))) {
+    mReferenceTextureData.reset();
     return false;
   }
 
-  mReferenceTextureData->Lock(OpenMode::OPEN_READ_WRITE);
   mBaseDT = mReferenceTextureData->BorrowDrawTarget();
+
   if (!mBaseDT) {
     // We might get a null draw target due to a device failure, just return
     // false so that we can recover.
     return false;
   }
 
-  mBackendType = mBaseDT->GetBackendType();
   return true;
 }
 
 bool CanvasTranslator::CheckForFreshCanvasDevice(int aLineNumber) {
+  // If not on D3D11, we are not dependent on a fresh device for DT creation if
+  // one already exists.
+  if (mBaseDT && mTextureType != TextureType::D3D11) {
+    return false;
+  }
+
 #if defined(XP_WIN)
   // If a new device has already been created, use that one.
   RefPtr<ID3D11Device> device = gfx::DeviceManagerDx::Get()->GetCanvasDevice();
@@ -601,11 +665,9 @@
     Deactivate();
     return false;
   }
+#endif
 
   return CreateReferenceTexture();
-#else
-  return false;
-#endif
 }
 
 void CanvasTranslator::NotifyDeviceChanged() {
@@ -615,29 +677,120 @@
                         &CanvasTranslator::SendNotifyDeviceChanged));
 }
 
+gfx::DrawTargetWebgl* CanvasTranslator::GetDrawTargetWebgl(
+    int64_t aTextureId) const {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result != mTextureInfo.end() && result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    return static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+  }
+  return nullptr;
+}
+
+void CanvasTranslator::NotifyRequiresRefresh(int64_t aTextureId,
+                                             bool aDispatch) {
+  if (aDispatch) {
+    DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
+        "CanvasTranslator::NotifyRequiresRefresh", this,
+        &CanvasTranslator::NotifyRequiresRefresh, aTextureId, false));
+    return;
+  }
+
+  if (mTextureInfo.find(aTextureId) != mTextureInfo.end()) {
+    Unused << SendNotifyRequiresRefresh(aTextureId);
+  }
+}
+
+void CanvasTranslator::CacheSnapshotShmem(int64_t aTextureId, bool aDispatch) {
+  if (aDispatch) {
+    DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
+        "CanvasTranslator::CacheSnapshotShmem", this,
+        &CanvasTranslator::CacheSnapshotShmem, aTextureId, false));
+    return;
+  }
+
+  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId)) {
+    if (auto shmemHandle = webgl->TakeShmemHandle()) {
+      // Lock the DT so that it doesn't get removed while shmem is in transit.
+      mTextureInfo[aTextureId].mLocked++;
+      nsCOMPtr<nsIThread> thread =
+          gfx::CanvasRenderThread::GetCanvasRenderThread();
+      RefPtr<CanvasTranslator> translator = this;
+      SendSnapshotShmem(aTextureId, std::move(shmemHandle),
+                        webgl->GetShmemSize())
+          ->Then(
+              thread, __func__,
+              [=](bool) { translator->RemoveTexture(aTextureId); },
+              [=](ipc::ResponseRejectReason) {
+                translator->RemoveTexture(aTextureId);
+              });
+    }
+  }
+}
+
+void CanvasTranslator::PrepareShmem(int64_t aTextureId) {
+  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId)) {
+    webgl->PrepareData();
+  }
+}
+
 already_AddRefed<gfx::DrawTarget> CanvasTranslator::CreateDrawTarget(
     gfx::ReferencePtr aRefPtr, const gfx::IntSize& aSize,
     gfx::SurfaceFormat aFormat) {
+  MOZ_DIAGNOSTIC_ASSERT(mNextTextureId >= 0, "No texture ID set");
   RefPtr<gfx::DrawTarget> dt;
-  do {
-    TextureData* textureData = CreateTextureData(mTextureType, aSize, aFormat);
-    if (textureData) {
-      MOZ_DIAGNOSTIC_ASSERT(mNextTextureId >= 0, "No texture ID set");
-      textureData->Lock(OpenMode::OPEN_READ_WRITE);
-      mTextureDatas[mNextTextureId] = UniquePtr<TextureData>(textureData);
-      gfx::CanvasManagerParent::AddReplayTexture(this, mNextTextureId,
-                                                 textureData);
-      dt = textureData->BorrowDrawTarget();
+  if (mNextRemoteTextureOwnerId.IsValid()) {
+    if (EnsureSharedContextWebgl()) {
+      mSharedContext->EnterTlsScope();
+    }
+    if (RefPtr<gfx::DrawTargetWebgl> webgl =
+            gfx::DrawTargetWebgl::Create(aSize, aFormat, mSharedContext)) {
+      webgl->BeginFrame(gfx::IntRect());
+      dt = webgl.forget().downcast<gfx::DrawTarget>();
+      if (dt) {
+        TextureInfo& info = mTextureInfo[mNextTextureId];
+        info.mDrawTarget = dt;
+        info.mRemoteTextureOwnerId = mNextRemoteTextureOwnerId;
+        CacheSnapshotShmem(mNextTextureId);
+      }
+    }
+    if (!dt) {
+      NotifyRequiresRefresh(mNextTextureId);
     }
-  } while (!dt && CheckForFreshCanvasDevice(__LINE__));
+  }
+
+  if (!dt) {
+    do {
+      TextureData* textureData =
+          CreateTextureData(mTextureType, mBackendType, aSize, aFormat);
+      if (textureData) {
+        TextureInfo& info = mTextureInfo[mNextTextureId];
+        info.mTextureData = UniquePtr<TextureData>(textureData);
+        info.mRemoteTextureOwnerId = mNextRemoteTextureOwnerId;
+        if (NS_WARN_IF(!textureData->Lock(OpenMode::OPEN_READ_WRITE))) {
+          continue;
+        }
+        dt = textureData->BorrowDrawTarget();
+      }
+    } while (!dt && CheckForFreshCanvasDevice(__LINE__));
+  }
+
   AddDrawTarget(aRefPtr, dt);
   mNextTextureId = -1;
+  mNextRemoteTextureOwnerId = RemoteTextureOwnerId();
 
   return dt.forget();
 }
 
 void CanvasTranslator::RemoveTexture(int64_t aTextureId) {
-  mTextureDatas.erase(aTextureId);
+  {
+    // Don't erase the texture if still in use
+    auto result = mTextureInfo.find(aTextureId);
+    if (result == mTextureInfo.end() || --result->second.mLocked > 0) {
+      return;
+    }
+    mTextureInfo.erase(result);
+  }
 
   // It is possible that the texture from the content process has never been
   // forwarded from the GPU process, so make sure its descriptor is removed.
@@ -645,11 +798,112 @@
 }
 
 TextureData* CanvasTranslator::LookupTextureData(int64_t aTextureId) {
-  TextureMap::const_iterator result = mTextureDatas.find(aTextureId);
-  if (result == mTextureDatas.end()) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
     return nullptr;
   }
-  return result->second.get();
+  return result->second.mTextureData.get();
+}
+
+bool CanvasTranslator::LockTexture(int64_t aTextureId, OpenMode aMode,
+                                   RemoteTextureId aId) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
+    return false;
+  }
+  if (result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    gfx::DrawTargetWebgl* webgl =
+        static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+    webgl->BeginFrame(webgl->GetRect());
+  } else if (TextureData* data = result->second.mTextureData.get()) {
+    if (!data->Lock(aMode)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool CanvasTranslator::UnlockTexture(int64_t aTextureId, RemoteTextureId aId) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
+    return false;
+  }
+  RemoteTextureOwnerId ownerId = result->second.mRemoteTextureOwnerId;
+  if (result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    gfx::DrawTargetWebgl* webgl =
+        static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+    webgl->EndFrame();
+    webgl->CopyToSwapChain(aId, ownerId, mOtherPid);
+    if (!result->second.mNotifiedRequiresRefresh && webgl->RequiresRefresh()) {
+      result->second.mNotifiedRequiresRefresh = true;
+      NotifyRequiresRefresh(aTextureId);
+    }
+  } else if (TextureData* data = result->second.mTextureData.get()) {
+    if (aId.IsValid()) {
+      PushRemoteTexture(data, aId, ownerId);
+      data->Unlock();
+    } else {
+      data->Unlock();
+      gfx::CanvasManagerParent::AddReplayTexture(this, aTextureId, data);
+    }
+  }
+  return true;
+}
+
+bool CanvasTranslator::PushRemoteTexture(TextureData* aData,
+                                         RemoteTextureId aId,
+                                         RemoteTextureOwnerId aOwnerId) {
+  if (!mRemoteTextureOwner) {
+    mRemoteTextureOwner = new RemoteTextureOwnerClient(mOtherPid);
+  }
+  if (!mRemoteTextureOwner->IsRegistered(aOwnerId)) {
+    mRemoteTextureOwner->RegisterTextureOwner(
+        aOwnerId,
+        /* aIsSyncMode */ gfx::gfxVars::WebglOopAsyncPresentForceSync());
+  }
+  TextureData::Info info;
+  aData->FillInfo(info);
+  UniquePtr<TextureData> dstData;
+  if (mTextureType == TextureType::Unknown) {
+    dstData = mRemoteTextureOwner->CreateOrRecycleBufferTextureData(
+        aOwnerId, info.size, info.format);
+  } else {
+    dstData.reset(
+        CreateTextureData(mTextureType, mBackendType, info.size, info.format));
+  }
+  bool success = false;
+  // Source data is already locked.
+  if (dstData && dstData->Lock(OpenMode::OPEN_WRITE)) {
+    if (RefPtr<gfx::DrawTarget> dstDT = dstData->BorrowDrawTarget()) {
+      if (RefPtr<gfx::DrawTarget> srcDT = aData->BorrowDrawTarget()) {
+        if (RefPtr<gfx::SourceSurface> snapshot = srcDT->Snapshot()) {
+          dstDT->CopySurface(snapshot, snapshot->GetRect(),
+                             gfx::IntPoint(0, 0));
+          success = true;
+        }
+      }
+    }
+    dstData->Unlock();
+  }
+  if (success) {
+    mRemoteTextureOwner->PushTexture(aId, aOwnerId, std::move(dstData));
+  } else {
+    mRemoteTextureOwner->PushDummyTexture(aId, aOwnerId);
+  }
+  return success;
+}
+
+void CanvasTranslator::ClearTextureInfo() {
+  mTextureInfo.clear();
+  mDrawTargets.Clear();
+  mSharedContext = nullptr;
+  mBaseDT = nullptr;
+  if (mRemoteTextureOwner) {
+    mRemoteTextureOwner->UnregisterAllTextureOwners();
+    mRemoteTextureOwner = nullptr;
+  }
 }
 
 already_AddRefed<gfx::SourceSurface> CanvasTranslator::LookupExternalSurface(