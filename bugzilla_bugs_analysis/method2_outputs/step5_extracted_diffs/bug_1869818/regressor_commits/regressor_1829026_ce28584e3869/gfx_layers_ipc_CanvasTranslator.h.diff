# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.h
# Commit: ce28584e3869
# Full Hash: ce28584e386976fc6df815260cdfebd8e6ffbadd
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-19 05:06:09
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r bb4029ea69bb -r ce28584e3869 gfx/layers/ipc/CanvasTranslator.h
--- a/gfx/layers/ipc/CanvasTranslator.h	Mon Dec 18 18:10:46 2023 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.h	Mon Dec 18 18:10:46 2023 +0000
@@ -17,6 +17,7 @@
 #include "mozilla/layers/CanvasDrawEventRecorder.h"
 #include "mozilla/layers/LayersSurfaces.h"
 #include "mozilla/layers/PCanvasParent.h"
+#include "mozilla/layers/RemoteTextureMap.h"
 #include "mozilla/ipc/CrossProcessSemaphore.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/UniquePtr.h"
@@ -26,6 +27,11 @@
 using EventType = gfx::RecordedEvent::EventType;
 class TaskQueue;
 
+namespace gfx {
+class DrawTargetWebgl;
+class SharedContextWebgl;
+}  // namespace gfx
+
 namespace layers {
 
 class SharedSurfacesHolder;
@@ -63,6 +69,7 @@
    * CanvasEventRingBuffer.
    *
    * @param aTextureType the TextureType the translator will create
+   * @param aBackendType the BackendType for texture data
    * @param aHeaderHandle handle for the control header
    * @param aBufferHandles handles for the initial buffers for translation
    * @param aBufferSize size of buffers and the default size
@@ -71,13 +78,11 @@
    * @param aUseIPDLThread if true, use the IPDL thread instead of the worker
    *        pool for translation requests
    */
-  ipc::IPCResult RecvInitTranslator(const TextureType& aTextureType,
-                                    Handle&& aReadHandle,
-                                    nsTArray<Handle>&& aBufferHandles,
-                                    uint64_t aBufferSize,
-                                    CrossProcessSemaphoreHandle&& aReaderSem,
-                                    CrossProcessSemaphoreHandle&& aWriterSem,
-                                    bool aUseIPDLThread);
+  ipc::IPCResult RecvInitTranslator(
+      TextureType aTextureType, gfx::BackendType aBackendType,
+      Handle&& aReadHandle, nsTArray<Handle>&& aBufferHandles,
+      uint64_t aBufferSize, CrossProcessSemaphoreHandle&& aReaderSem,
+      CrossProcessSemaphoreHandle&& aWriterSem, bool aUseIPDLThread);
 
   /**
    * Restart the translation from a Stopped state.
@@ -134,8 +139,9 @@
    * Set the texture ID that will be used as a lookup for the texture created by
    * the next CreateDrawTarget.
    */
-  void SetNextTextureId(int64_t aNextTextureId) {
+  void SetNextTextureId(int64_t aNextTextureId, RemoteTextureOwnerId aOwnerId) {
     mNextTextureId = aNextTextureId;
+    mNextRemoteTextureOwnerId = aOwnerId;
   }
 
   /**
@@ -175,6 +181,12 @@
    */
   void RemoveTexture(int64_t aTextureId);
 
+  bool LockTexture(int64_t aTextureId, OpenMode aMode, RemoteTextureId aId);
+  bool UnlockTexture(int64_t aTextureId, RemoteTextureId aId);
+
+  bool PushRemoteTexture(TextureData* aData, RemoteTextureId aId,
+                         RemoteTextureOwnerId aOwnerId);
+
   /**
    * Overriden to remove any DataSourceSurfaces associated with the RefPtr.
    *
@@ -256,6 +268,8 @@
   UniquePtr<gfx::DataSourceSurface::ScopedMap> GetPreparedMap(
       gfx::ReferencePtr aSurface);
 
+  void PrepareShmem(int64_t aTextureId);
+
   void RecycleBuffer();
 
   void NextBuffer();
@@ -281,11 +295,14 @@
 
   void Deactivate();
 
+  void BlockCanvas();
+
   TextureData* CreateTextureData(TextureType aTextureType,
+                                 gfx::BackendType aBackendType,
                                  const gfx::IntSize& aSize,
                                  gfx::SurfaceFormat aFormat);
 
-  void AddSurfaceDescriptor(int64_t aTextureId, TextureData* atextureData);
+  void ClearTextureInfo();
 
   bool HandleExtensionEvent(int32_t aType);
 
@@ -293,11 +310,18 @@
   bool CheckForFreshCanvasDevice(int aLineNumber);
   void NotifyDeviceChanged();
 
+  bool EnsureSharedContextWebgl();
+  gfx::DrawTargetWebgl* GetDrawTargetWebgl(int64_t aTextureId) const;
+  void NotifyRequiresRefresh(int64_t aTextureId, bool aDispatch = true);
+  void CacheSnapshotShmem(int64_t aTextureId, bool aDispatch = true);
+
   RefPtr<TaskQueue> mTranslationTaskQueue;
   RefPtr<SharedSurfacesHolder> mSharedSurfacesHolder;
 #if defined(XP_WIN)
   RefPtr<ID3D11Device> mDevice;
 #endif
+  RefPtr<gfx::SharedContextWebgl> mSharedContext;
+  RefPtr<RemoteTextureOwnerClient> mRemoteTextureOwner;
 
   size_t mDefaultBufferSize = 0;
   uint32_t mMaxSpinCount;
@@ -329,13 +353,23 @@
   // Sometimes during device reset our reference DrawTarget can be null, so we
   // hold the BackendType separately.
   gfx::BackendType mBackendType = gfx::BackendType::NONE;
-  typedef std::unordered_map<int64_t, UniquePtr<TextureData>> TextureMap;
-  TextureMap mTextureDatas;
+  base::ProcessId mOtherPid = base::kInvalidProcessId;
+  struct TextureInfo {
+    UniquePtr<TextureData> mTextureData;
+    RefPtr<gfx::DrawTarget> mDrawTarget;
+    RemoteTextureOwnerId mRemoteTextureOwnerId;
+    bool mNotifiedRequiresRefresh = false;
+    // Ref-count of how active uses of the DT. Avoids deletion when locked.
+    int32_t mLocked = 1;
+  };
+  std::unordered_map<int64_t, TextureInfo> mTextureInfo;
   int64_t mNextTextureId = -1;
+  RemoteTextureOwnerId mNextRemoteTextureOwnerId;
   nsRefPtrHashtable<nsPtrHashKey<void>, gfx::DataSourceSurface> mDataSurfaces;
   gfx::ReferencePtr mMappedSurface;
   UniquePtr<gfx::DataSourceSurface::ScopedMap> mPreparedMap;
   Atomic<bool> mDeactivated{false};
+  Atomic<bool> mBlocked{false};
   bool mIsInTransaction = false;
   bool mDeviceResetInProgress = false;
 };