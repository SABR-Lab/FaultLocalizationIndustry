# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/CanvasDrawEventRecorder.cpp
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/CanvasDrawEventRecorder.cpp
--- a/gfx/layers/CanvasDrawEventRecorder.cpp	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/CanvasDrawEventRecorder.cpp	Tue Dec 05 09:37:03 2023 +0000
@@ -423,6 +423,7 @@
   do {
     switch (mWrite->state) {
       case State::Processing:
+      case State::Failed:
         return;
       case State::AboutToWait:
         // The writer is making a decision about whether to wait. So, we must
@@ -498,7 +499,7 @@
   return mWrite->count - mOurCount;
 }
 
-void CanvasEventRingBuffer::ReturnWrite(const char* aData, size_t aSize) {
+void CanvasEventRingBuffer::ReturnWrite(const uint8_t* aData, size_t aSize) {
   uint32_t writeCount = mRead->returnCount;
   uint32_t bufPos = writeCount % StreamSize();
   uint32_t bufRemaining = StreamSize() - bufPos;
@@ -526,7 +527,13 @@
   mRead->returnCount = writeCount;
 }
 
-void CanvasEventRingBuffer::ReturnRead(char* aOut, size_t aSize) {
+void CanvasEventRingBuffer::ReturnRead(uint8_t* aOut, const gfx::IntSize& aSize,
+                                       size_t aBPP, size_t aStride) {
+  if (aSize.IsEmpty()) {
+    return;
+  }
+  aStride = std::max(aStride, aBPP * size_t(aSize.width));
+
   // First wait for the event returning the data to be read.
   WaitForCheckpoint(mOurCount);
   uint32_t readCount = mWrite->returnCount;
@@ -542,29 +549,28 @@
     }
   }
 
-  uint32_t bufPos = readCount % StreamSize();
-  uint32_t bufRemaining = StreamSize() - bufPos;
-  uint32_t availableToRead =
-      std::min(bufRemaining, (mRead->returnCount - readCount));
-  while (availableToRead < aSize) {
-    if (availableToRead) {
-      memcpy(aOut, mBuf + bufPos, availableToRead);
-      readCount += availableToRead;
-      mWrite->returnCount = readCount;
-      bufPos = readCount % StreamSize();
-      bufRemaining = StreamSize() - bufPos;
-      aOut += availableToRead;
-      aSize -= availableToRead;
-    } else if (mWriterServices->ReaderClosed()) {
-      return;
+  uint8_t* outRow = aOut;
+  for (int32_t row = 0; row < aSize.height; row++) {
+    uint8_t* outPos = outRow;
+    uint32_t remainingRow = aSize.width * aBPP;
+    while (remainingRow > 0) {
+      uint32_t bufPos = readCount % StreamSize();
+      uint32_t bufRemaining = StreamSize() - bufPos;
+      uint32_t availableToRead =
+          std::min(bufRemaining, (mRead->returnCount - readCount));
+      if (availableToRead > 0) {
+        uint32_t availableRow = std::min(availableToRead, remainingRow);
+        memcpy(outPos, mBuf + bufPos, availableRow);
+        readCount += availableRow;
+        mWrite->returnCount = readCount;
+        outPos += availableRow;
+        remainingRow -= availableRow;
+      } else if (mWriterServices->ReaderClosed()) {
+        return;
+      }
     }
-
-    availableToRead = std::min(bufRemaining, (mRead->returnCount - readCount));
+    outRow += aStride;
   }
-
-  memcpy(aOut, mBuf + bufPos, aSize);
-  readCount += aSize;
-  mWrite->returnCount = readCount;
 }
 
 void CanvasDrawEventRecorder::StoreSourceSurfaceRecording(