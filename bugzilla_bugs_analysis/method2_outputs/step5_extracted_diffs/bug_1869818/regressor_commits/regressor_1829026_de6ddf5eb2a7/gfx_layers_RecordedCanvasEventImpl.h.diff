# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/RecordedCanvasEventImpl.h
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/RecordedCanvasEventImpl.h
--- a/gfx/layers/RecordedCanvasEventImpl.h	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/RecordedCanvasEventImpl.h	Tue Dec 05 09:37:03 2023 +0000
@@ -40,6 +40,7 @@
 const EventType DEVICE_CHANGE_ACKNOWLEDGED = EventType(EventType::LAST + 10);
 const EventType NEXT_TEXTURE_ID = EventType(EventType::LAST + 11);
 const EventType TEXTURE_DESTRUCTION = EventType(EventType::LAST + 12);
+const EventType PREPARE_SHMEM = EventType(EventType::LAST + 13);
 
 class RecordedCanvasBeginTransaction final
     : public RecordedEventDerived<RecordedCanvasBeginTransaction> {
@@ -133,10 +134,12 @@
 class RecordedTextureLock final
     : public RecordedEventDerived<RecordedTextureLock> {
  public:
-  RecordedTextureLock(int64_t aTextureId, const OpenMode aMode)
+  RecordedTextureLock(int64_t aTextureId, const OpenMode aMode,
+                      RemoteTextureId aId)
       : RecordedEventDerived(TEXTURE_LOCK),
         mTextureId(aTextureId),
-        mMode(aMode) {}
+        mMode(aMode),
+        mLastRemoteTextureId(aId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedTextureLock(S& aStream);
@@ -151,16 +154,14 @@
  private:
   int64_t mTextureId;
   OpenMode mMode;
+  RemoteTextureId mLastRemoteTextureId;
 };
 
 inline bool RecordedTextureLock::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  TextureData* textureData = aTranslator->LookupTextureData(mTextureId);
-  if (!textureData) {
+  if (!aTranslator->LockTexture(mTextureId, mMode, mLastRemoteTextureId)) {
     return false;
   }
-
-  textureData->Lock(mMode);
   return true;
 }
 
@@ -168,6 +169,7 @@
 void RecordedTextureLock::Record(S& aStream) const {
   WriteElement(aStream, mTextureId);
   WriteElement(aStream, mMode);
+  WriteElement(aStream, mLastRemoteTextureId.mId);
 }
 
 template <class S>
@@ -176,13 +178,16 @@
   ReadElement(aStream, mTextureId);
   ReadElementConstrained(aStream, mMode, OpenMode::OPEN_NONE,
                          OpenMode::OPEN_READ_WRITE_ASYNC);
+  ReadElement(aStream, mLastRemoteTextureId.mId);
 }
 
 class RecordedTextureUnlock final
     : public RecordedEventDerived<RecordedTextureUnlock> {
  public:
-  explicit RecordedTextureUnlock(int64_t aTextureId)
-      : RecordedEventDerived(TEXTURE_UNLOCK), mTextureId(aTextureId) {}
+  explicit RecordedTextureUnlock(int64_t aTextureId, RemoteTextureId aId)
+      : RecordedEventDerived(TEXTURE_UNLOCK),
+        mTextureId(aTextureId),
+        mLastRemoteTextureId(aId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedTextureUnlock(S& aStream);
@@ -196,28 +201,28 @@
 
  private:
   int64_t mTextureId;
+  RemoteTextureId mLastRemoteTextureId;
 };
 
 inline bool RecordedTextureUnlock::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  TextureData* textureData = aTranslator->LookupTextureData(mTextureId);
-  if (!textureData) {
+  if (!aTranslator->UnlockTexture(mTextureId, mLastRemoteTextureId)) {
     return false;
   }
-
-  textureData->Unlock();
   return true;
 }
 
 template <class S>
 void RecordedTextureUnlock::Record(S& aStream) const {
   WriteElement(aStream, mTextureId);
+  WriteElement(aStream, mLastRemoteTextureId.mId);
 }
 
 template <class S>
 RecordedTextureUnlock::RecordedTextureUnlock(S& aStream)
     : RecordedEventDerived(TEXTURE_UNLOCK) {
   ReadElement(aStream, mTextureId);
+  ReadElement(aStream, mLastRemoteTextureId.mId);
 }
 
 class RecordedCacheDataSurface final
@@ -325,8 +330,11 @@
 class RecordedGetDataForSurface final
     : public RecordedEventDerived<RecordedGetDataForSurface> {
  public:
-  explicit RecordedGetDataForSurface(const gfx::SourceSurface* aSurface)
-      : RecordedEventDerived(GET_DATA_FOR_SURFACE), mSurface(aSurface) {}
+  RecordedGetDataForSurface(const gfx::SourceSurface* aSurface,
+                            const gfx::IntRect& aRect)
+      : RecordedEventDerived(GET_DATA_FOR_SURFACE),
+        mSurface(aSurface),
+        mRect(aRect) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedGetDataForSurface(S& aStream);
@@ -340,6 +348,7 @@
 
  private:
   ReferencePtr mSurface;
+  gfx::IntRect mRect;
 };
 
 inline bool RecordedGetDataForSurface::PlayCanvasEvent(
@@ -349,21 +358,25 @@
     return false;
   }
 
+  if (!surface->GetRect().Contains(mRect)) {
+    return false;
+  }
+
   UniquePtr<gfx::DataSourceSurface::ScopedMap> map =
       aTranslator->GetPreparedMap(mSurface);
   if (!map) {
     return false;
   }
 
-  int32_t dataFormatWidth =
-      surface->GetSize().width * BytesPerPixel(surface->GetFormat());
+  int32_t bpp = BytesPerPixel(surface->GetFormat());
+  int32_t dataFormatWidth = mRect.width * bpp;
   int32_t srcStride = map->GetStride();
   if (dataFormatWidth > srcStride) {
     return false;
   }
 
-  char* src = reinterpret_cast<char*>(map->GetData());
-  char* endSrc = src + (map->GetSurface()->GetSize().height * srcStride);
+  uint8_t* src = map->GetData() + mRect.y * srcStride + mRect.x * bpp;
+  uint8_t* endSrc = src + mRect.height * srcStride;
   while (src < endSrc) {
     aTranslator->ReturnWrite(src, dataFormatWidth);
     src += srcStride;
@@ -375,12 +388,14 @@
 template <class S>
 void RecordedGetDataForSurface::Record(S& aStream) const {
   WriteElement(aStream, mSurface);
+  WriteElement(aStream, mRect);
 }
 
 template <class S>
 RecordedGetDataForSurface::RecordedGetDataForSurface(S& aStream)
     : RecordedEventDerived(GET_DATA_FOR_SURFACE) {
   ReadElement(aStream, mSurface);
+  ReadElement(aStream, mRect);
 }
 
 class RecordedAddSurfaceAlias final
@@ -505,8 +520,11 @@
 class RecordedNextTextureId final
     : public RecordedEventDerived<RecordedNextTextureId> {
  public:
-  explicit RecordedNextTextureId(int64_t aNextTextureId)
-      : RecordedEventDerived(NEXT_TEXTURE_ID), mNextTextureId(aNextTextureId) {}
+  RecordedNextTextureId(int64_t aNextTextureId,
+                        RemoteTextureOwnerId aRemoteTextureOwnerId)
+      : RecordedEventDerived(NEXT_TEXTURE_ID),
+        mNextTextureId(aNextTextureId),
+        mRemoteTextureOwnerId(aRemoteTextureOwnerId) {}
 
   template <class S>
   MOZ_IMPLICIT RecordedNextTextureId(S& aStream);
@@ -519,24 +537,28 @@
   std::string GetName() const final { return "RecordedNextTextureId"; }
 
  private:
-  int64_t mNextTextureId;
+  int64_t mNextTextureId = 0;
+  RemoteTextureOwnerId mRemoteTextureOwnerId;
+  RemoteTextureId mRemoteTextureId;
 };
 
 inline bool RecordedNextTextureId::PlayCanvasEvent(
     CanvasTranslator* aTranslator) const {
-  aTranslator->SetNextTextureId(mNextTextureId);
+  aTranslator->SetNextTextureId(mNextTextureId, mRemoteTextureOwnerId);
   return true;
 }
 
 template <class S>
 void RecordedNextTextureId::Record(S& aStream) const {
   WriteElement(aStream, mNextTextureId);
+  WriteElement(aStream, mRemoteTextureOwnerId.mId);
 }
 
 template <class S>
 RecordedNextTextureId::RecordedNextTextureId(S& aStream)
     : RecordedEventDerived(NEXT_TEXTURE_ID) {
   ReadElement(aStream, mNextTextureId);
+  ReadElement(aStream, mRemoteTextureOwnerId.mId);
 }
 
 class RecordedTextureDestruction final
@@ -556,7 +578,7 @@
   std::string GetName() const final { return "RecordedTextureDestruction"; }
 
  private:
-  int64_t mTextureId;
+  int64_t mTextureId = 0;
 };
 
 inline bool RecordedTextureDestruction::PlayCanvasEvent(
@@ -576,6 +598,43 @@
   ReadElement(aStream, mTextureId);
 }
 
+class RecordedPrepareShmem final
+    : public RecordedEventDerived<RecordedPrepareShmem> {
+ public:
+  explicit RecordedPrepareShmem(int64_t aTextureId)
+      : RecordedEventDerived(PREPARE_SHMEM), mTextureId(aTextureId) {}
+
+  template <class S>
+  MOZ_IMPLICIT RecordedPrepareShmem(S& aStream);
+
+  bool PlayCanvasEvent(CanvasTranslator* aTranslator) const;
+
+  template <class S>
+  void Record(S& aStream) const;
+
+  std::string GetName() const final { return "RecordedPrepareShmem"; }
+
+ private:
+  int64_t mTextureId = 0;
+};
+
+inline bool RecordedPrepareShmem::PlayCanvasEvent(
+    CanvasTranslator* aTranslator) const {
+  aTranslator->PrepareShmem(mTextureId);
+  return true;
+}
+
+template <class S>
+void RecordedPrepareShmem::Record(S& aStream) const {
+  WriteElement(aStream, mTextureId);
+}
+
+template <class S>
+RecordedPrepareShmem::RecordedPrepareShmem(S& aStream)
+    : RecordedEventDerived(PREPARE_SHMEM) {
+  ReadElement(aStream, mTextureId);
+}
+
 #define FOR_EACH_CANVAS_EVENT(f)                                   \
   f(CANVAS_BEGIN_TRANSACTION, RecordedCanvasBeginTransaction);     \
   f(CANVAS_END_TRANSACTION, RecordedCanvasEndTransaction);         \
@@ -589,7 +648,8 @@
   f(REMOVE_SURFACE_ALIAS, RecordedRemoveSurfaceAlias);             \
   f(DEVICE_CHANGE_ACKNOWLEDGED, RecordedDeviceChangeAcknowledged); \
   f(NEXT_TEXTURE_ID, RecordedNextTextureId);                       \
-  f(TEXTURE_DESTRUCTION, RecordedTextureDestruction);
+  f(TEXTURE_DESTRUCTION, RecordedTextureDestruction);              \
+  f(PREPARE_SHMEM, RecordedPrepareShmem);
 
 }  // namespace layers
 }  // namespace mozilla