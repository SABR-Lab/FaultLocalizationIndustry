# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/client/TextureClient.cpp
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/client/TextureClient.cpp
--- a/gfx/layers/client/TextureClient.cpp	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/client/TextureClient.cpp	Tue Dec 05 09:37:03 2023 +0000
@@ -319,6 +319,36 @@
 }
 
 /* static */
+TextureData* TextureData::Create(TextureType aTextureType,
+                                 gfx::SurfaceFormat aFormat,
+                                 const gfx::IntSize& aSize,
+                                 TextureAllocationFlags aAllocFlags,
+                                 gfx::BackendType aBackendType) {
+  switch (aTextureType) {
+#ifdef XP_WIN
+    case TextureType::D3D11:
+      return D3D11TextureData::Create(aSize, aFormat, aAllocFlags);
+#endif
+
+#ifdef MOZ_WIDGET_GTK
+    case TextureType::DMABUF:
+      return DMABUFTextureData::Create(aSize, aFormat, aBackendType);
+#endif
+
+#ifdef XP_MACOSX
+    case TextureType::MacIOSurface:
+      return MacIOSurfaceTextureData::Create(aSize, aFormat, aBackendType);
+#endif
+#ifdef MOZ_WIDGET_ANDROID
+    case TextureType::AndroidNativeWindow:
+      return AndroidNativeWindowTextureData::Create(aSize, aFormat);
+#endif
+    default:
+      return nullptr;
+  }
+}
+
+/* static */
 TextureData* TextureData::Create(TextureForwarder* aAllocator,
                                  gfx::SurfaceFormat aFormat, gfx::IntSize aSize,
                                  KnowsCompositor* aKnowsCompositor,
@@ -328,45 +358,33 @@
   TextureType textureType =
       GetTextureType(aFormat, aSize, aKnowsCompositor, aSelector, aAllocFlags);
 
-  if (ShouldRemoteTextureType(textureType, aSelector)) {
+  if ((aAllocFlags & ALLOC_FORCE_REMOTE) ||
+      ShouldRemoteTextureType(textureType, aSelector)) {
     RefPtr<CanvasChild> canvasChild = aAllocator->GetCanvasChild();
     if (canvasChild) {
       return new RecordedTextureData(canvasChild.forget(), aSize, aFormat,
                                      textureType);
     }
+    if (aAllocFlags & ALLOC_FORCE_REMOTE) {
+      // If we must be remote, but there is no canvas child, then falling back
+      // is not possible.
+      return nullptr;
+    }
 
     // We don't have a CanvasChild, but are supposed to be remote.
     // Fall back to software.
     textureType = TextureType::Unknown;
   }
 
+  gfx::BackendType moz2DBackend = gfx::BackendType::NONE;
+
 #if defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
-  gfx::BackendType moz2DBackend = BackendTypeForBackendSelector(
+  moz2DBackend = BackendTypeForBackendSelector(
       aKnowsCompositor->GetCompositorBackendType(), aSelector);
 #endif
 
-  switch (textureType) {
-#ifdef XP_WIN
-    case TextureType::D3D11:
-      return D3D11TextureData::Create(aSize, aFormat, aAllocFlags);
-#endif
-
-#ifdef MOZ_WIDGET_GTK
-    case TextureType::DMABUF:
-      return DMABUFTextureData::Create(aSize, aFormat, moz2DBackend);
-#endif
-
-#ifdef XP_MACOSX
-    case TextureType::MacIOSurface:
-      return MacIOSurfaceTextureData::Create(aSize, aFormat, moz2DBackend);
-#endif
-#ifdef MOZ_WIDGET_ANDROID
-    case TextureType::AndroidNativeWindow:
-      return AndroidNativeWindowTextureData::Create(aSize, aFormat);
-#endif
-    default:
-      return nullptr;
-  }
+  return TextureData::Create(textureType, aFormat, aSize, aAllocFlags,
+                             moz2DBackend);
 }
 
 /* static */
@@ -1159,6 +1177,10 @@
   if (data) {
     return MakeAndAddRef<TextureClient>(data, aTextureFlags, aAllocator);
   }
+  if (aAllocFlags & ALLOC_FORCE_REMOTE) {
+    // If we must be remote, but allocation failed, then don't fall back.
+    return nullptr;
+  }
 
   // Can't do any better than a buffer texture client.
   return TextureClient::CreateForRawBufferAccess(aAllocator, aFormat, aSize,