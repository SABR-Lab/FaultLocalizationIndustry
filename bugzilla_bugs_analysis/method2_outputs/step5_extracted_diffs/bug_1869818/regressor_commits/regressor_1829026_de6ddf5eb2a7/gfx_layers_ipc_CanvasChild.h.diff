# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasChild.h
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/ipc/CanvasChild.h
--- a/gfx/layers/ipc/CanvasChild.h	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/ipc/CanvasChild.h	Tue Dec 05 09:37:03 2023 +0000
@@ -44,6 +44,13 @@
 
   ipc::IPCResult RecvDeactivate();
 
+  ipc::IPCResult RecvBlockCanvas();
+
+  ipc::IPCResult RecvNotifyRequiresRefresh(int64_t aTextureId);
+
+  ipc::IPCResult RecvSnapshotShmem(int64_t aTextureId, Shmem&& aShmem,
+                                   SnapshotShmemResolver&& aResolve);
+
   /**
    * Ensures that the DrawEventRecorder has been created.
    *
@@ -98,12 +105,13 @@
 
   /**
    * Create a DrawTargetRecording for a canvas texture.
+   * @param aTextureId the id of the new texture
    * @param aSize size for the DrawTarget
    * @param aFormat SurfaceFormat for the DrawTarget
    * @returns newly created DrawTargetRecording
    */
   already_AddRefed<gfx::DrawTarget> CreateDrawTarget(
-      gfx::IntSize aSize, gfx::SurfaceFormat aFormat);
+      int64_t aTextureId, gfx::IntSize aSize, gfx::SurfaceFormat aFormat);
 
   /**
    * Record an event for processing by the CanvasParent's CanvasTranslator.
@@ -115,21 +123,37 @@
    * Wrap the given surface, so that we can provide a DataSourceSurface if
    * required.
    * @param aSurface the SourceSurface to wrap
+   * @param aTextureId the texture id of the source TextureData
    * @returns a SourceSurface that can provide a DataSourceSurface if required
    */
   already_AddRefed<gfx::SourceSurface> WrapSurface(
-      const RefPtr<gfx::SourceSurface>& aSurface);
+      const RefPtr<gfx::SourceSurface>& aSurface, int64_t aTextureId);
+
+  /**
+   * The DrawTargetRecording is about to change, so detach the old snapshot.
+   */
+  void DetachSurface(const RefPtr<gfx::SourceSurface>& aSurface);
 
   /**
    * Get DataSourceSurface from the translated equivalent version of aSurface in
    * the GPU process.
+   * @param aTextureId the source TextureData to read from
    * @param aSurface the SourceSurface in this process for which we need a
    *                 DataSourceSurface
+   * @param aDetached whether the surface is old
    * @returns a DataSourceSurface created from data for aSurface retrieve from
    *          GPU process
    */
   already_AddRefed<gfx::DataSourceSurface> GetDataSurface(
-      const gfx::SourceSurface* aSurface);
+      int64_t aTextureId, const gfx::SourceSurface* aSurface, bool aDetached);
+
+  bool ReadInto(int64_t aTextureId, const gfx::SourceSurface* aSurface,
+                gfx::DataSourceSurface* aDataSurface, const gfx::IntRect& aRect,
+                bool aDetached);
+
+  bool RequiresRefresh(int64_t aTextureId) const;
+
+  void CleanupTexture(int64_t aTextureId);
 
  protected:
   void ActorDestroy(ActorDestroyReason aWhy) final;
@@ -149,6 +173,11 @@
   uint32_t mLastWriteLockCheckpoint = 0;
   uint32_t mTransactionsSinceGetDataSurface = kCacheDataSurfaceThreshold;
   std::vector<RefPtr<gfx::SourceSurface>> mLastTransactionExternalSurfaces;
+  struct TextureInfo {
+    ipc::Shmem mSnapshotShmem;
+    bool mRequiresRefresh = false;
+  };
+  std::unordered_map<int64_t, TextureInfo> mTextureInfo;
   bool mIsInTransaction = false;
   bool mHasOutstandingWriteLock = false;
 };