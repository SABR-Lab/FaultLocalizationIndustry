# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.cpp
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/ipc/CanvasTranslator.cpp
--- a/gfx/layers/ipc/CanvasTranslator.cpp	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.cpp	Tue Dec 05 09:37:03 2023 +0000
@@ -7,18 +7,22 @@
 #include "CanvasTranslator.h"
 
 #include "gfxGradientCache.h"
+#include "gfxPlatform.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/CanvasManagerParent.h"
 #include "mozilla/gfx/CanvasRenderThread.h"
+#include "mozilla/gfx/DrawTargetWebgl.h"
 #include "mozilla/gfx/gfxVars.h"
 #include "mozilla/gfx/GPUParent.h"
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/ipc/Endpoint.h"
+#include "mozilla/layers/BufferTexture.h"
 #include "mozilla/layers/SharedSurfacesParent.h"
 #include "mozilla/layers/TextureClient.h"
 #include "mozilla/SyncRunnable.h"
 #include "mozilla/TaskQueue.h"
 #include "mozilla/Telemetry.h"
+#include "GLContext.h"
 #include "RecordedCanvasEventImpl.h"
 
 #if defined(XP_WIN)
@@ -49,6 +53,7 @@
 };
 
 TextureData* CanvasTranslator::CreateTextureData(TextureType aTextureType,
+                                                 gfx::BackendType aBackendType,
                                                  const gfx::IntSize& aSize,
                                                  gfx::SurfaceFormat aFormat) {
   TextureData* textureData = nullptr;
@@ -60,8 +65,17 @@
       break;
     }
 #endif
+    case TextureType::Unknown:
+      textureData = BufferTextureData::Create(
+          aSize, aFormat, gfx::BackendType::SKIA, LayersBackend::LAYERS_WR,
+          TextureFlags::DEALLOCATE_CLIENT | TextureFlags::REMOTE_TEXTURE,
+          ALLOC_CLEAR_BUFFER, nullptr);
+      break;
+
     default:
-      MOZ_CRASH("Unsupported TextureType for CanvasTranslator.");
+      textureData = TextureData::Create(aTextureType, aFormat, aSize,
+                                        ALLOC_CLEAR_BUFFER, aBackendType);
+      break;
   }
 
   return textureData;
@@ -72,12 +86,7 @@
   Telemetry::ScalarAdd(Telemetry::ScalarID::GFX_CANVAS_REMOTE_ACTIVATED, 1);
 }
 
-CanvasTranslator::~CanvasTranslator() {
-  // The textures need to be the last thing holding their DrawTargets, so that
-  // they can destroy them within a lock.
-  mDrawTargets.Clear();
-  mBaseDT = nullptr;
-}
+CanvasTranslator::~CanvasTranslator() = default;
 
 void CanvasTranslator::DispatchToTaskQueue(
     already_AddRefed<nsIRunnable> aRunnable) {
@@ -95,8 +104,20 @@
   return gfx::CanvasRenderThread::IsInCanvasRenderThread();
 }
 
+bool CanvasTranslator::EnsureSharedContextWebgl() {
+  if (!mSharedContext || mSharedContext->IsContextLost()) {
+    mSharedContext = gfx::SharedContextWebgl::Create();
+    if (!mSharedContext || mSharedContext->IsContextLost()) {
+      mSharedContext = nullptr;
+      BlockCanvas();
+      return false;
+    }
+  }
+  return true;
+}
+
 mozilla::ipc::IPCResult CanvasTranslator::RecvInitTranslator(
-    const TextureType& aTextureType,
+    const TextureType& aTextureType, const gfx::BackendType& aBackendType,
     ipc::SharedMemoryBasic::Handle&& aReadHandle,
     CrossProcessSemaphoreHandle&& aReaderSem,
     CrossProcessSemaphoreHandle&& aWriterSem, const bool& aUseIPDLThread) {
@@ -105,6 +126,7 @@
   }
 
   mTextureType = aTextureType;
+  mBackendType = aBackendType;
 
   // We need to initialize the stream first, because it might be used to
   // communicate other failures back to the writer.
@@ -116,13 +138,16 @@
     return IPC_FAIL(this, "Failed to initialize ring buffer reader.");
   }
 
-#if defined(XP_WIN)
   if (!CheckForFreshCanvasDevice(__LINE__)) {
     gfxCriticalNote << "GFX: CanvasTranslator failed to get device";
     mStream = nullptr;
     return IPC_OK();
   }
-#endif
+
+  if (gfx::gfxVars::UseAcceleratedCanvas2D() && !EnsureSharedContextWebgl()) {
+    gfxCriticalNote
+        << "GFX: CanvasTranslator failed creating WebGL shared context";
+  }
 
   if (!aUseIPDLThread) {
     mTranslationTaskQueue = gfx::CanvasRenderThread::CreateWorkerTaskQueue();
@@ -201,6 +226,8 @@
   // break the cycle caused by RingBufferReaderServices.
   mStream = nullptr;
 
+  ClearTextureInfo();
+
   gfx::CanvasManagerParent::RemoveReplayTextures(this);
 }
 
@@ -209,7 +236,8 @@
     return true;
   }
 
-  if (NS_WARN_IF(!gfx::gfxVars::RemoteCanvasEnabled())) {
+  if (NS_WARN_IF(!gfx::gfxVars::RemoteCanvasEnabled() &&
+                 !gfx::gfxVars::UseAcceleratedCanvas2D())) {
     Deactivate();
   }
 
@@ -230,14 +258,26 @@
                         &CanvasTranslator::SendDeactivate));
 
   // Unlock all of our textures.
-  for (auto const& entry : mTextureDatas) {
-    entry.second->Unlock();
+  for (auto const& entry : mTextureInfo) {
+    if (entry.second.mTextureData) {
+      entry.second.mTextureData->Unlock();
+    }
   }
 
   // Disable remote canvas for all.
   gfx::CanvasManagerParent::DisableRemoteCanvas();
 }
 
+void CanvasTranslator::BlockCanvas() {
+  if (mDeactivated || mBlocked) {
+    return;
+  }
+  mBlocked = true;
+  gfx::CanvasRenderThread::Dispatch(
+      NewRunnableMethod("CanvasTranslator::SendBlockCanvas", this,
+                        &CanvasTranslator::SendBlockCanvas));
+}
+
 bool CanvasTranslator::TranslateRecording() {
   MOZ_ASSERT(IsInTaskQueue());
 
@@ -245,6 +285,15 @@
     return false;
   }
 
+  if (mSharedContext && EnsureSharedContextWebgl()) {
+    mSharedContext->EnterTlsScope();
+  }
+  auto exitTlsScope = MakeScopeExit([&] {
+    if (mSharedContext) {
+      mSharedContext->ExitTlsScope();
+    }
+  });
+
   uint8_t eventType = mStream->ReadNextEvent();
   while (mStream->good() && eventType != kDropBufferEventType) {
     bool success = RecordedEvent::DoWithEventFromStream(
@@ -361,25 +410,32 @@
     mReferenceTextureData->Unlock();
   }
 
-  mReferenceTextureData.reset(CreateTextureData(
-      mTextureType, gfx::IntSize(1, 1), gfx::SurfaceFormat::B8G8R8A8));
+  mReferenceTextureData.reset(CreateTextureData(mTextureType, mBackendType,
+                                                gfx::IntSize(1, 1),
+                                                gfx::SurfaceFormat::B8G8R8A8));
   if (!mReferenceTextureData) {
     return false;
   }
 
   mReferenceTextureData->Lock(OpenMode::OPEN_READ_WRITE);
   mBaseDT = mReferenceTextureData->BorrowDrawTarget();
+
   if (!mBaseDT) {
     // We might get a null draw target due to a device failure, just return
     // false so that we can recover.
     return false;
   }
 
-  mBackendType = mBaseDT->GetBackendType();
   return true;
 }
 
 bool CanvasTranslator::CheckForFreshCanvasDevice(int aLineNumber) {
+  // If not on D3D11, we are not dependent on a fresh device for DT creation if
+  // one already exists.
+  if (mBaseDT && mTextureType != TextureType::D3D11) {
+    return false;
+  }
+
 #if defined(XP_WIN)
   // If a new device has already been created, use that one.
   RefPtr<ID3D11Device> device = gfx::DeviceManagerDx::Get()->GetCanvasDevice();
@@ -419,11 +475,9 @@
     Deactivate();
     return false;
   }
+#endif
 
   return CreateReferenceTexture();
-#else
-  return false;
-#endif
 }
 
 void CanvasTranslator::NotifyDeviceChanged() {
@@ -433,29 +487,117 @@
                         &CanvasTranslator::SendNotifyDeviceChanged));
 }
 
+gfx::DrawTargetWebgl* CanvasTranslator::GetDrawTargetWebgl(
+    int64_t aTextureId) const {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result != mTextureInfo.end() && result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    return static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+  }
+  return nullptr;
+}
+
+void CanvasTranslator::NotifyRequiresRefresh(int64_t aTextureId,
+                                             bool aDispatch) {
+  if (aDispatch) {
+    DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
+        "CanvasTranslator::NotifyRequiresRefresh", this,
+        &CanvasTranslator::NotifyRequiresRefresh, aTextureId, false));
+    return;
+  }
+
+  if (mTextureInfo.find(aTextureId) != mTextureInfo.end()) {
+    Unused << SendNotifyRequiresRefresh(aTextureId);
+  }
+}
+
+void CanvasTranslator::CacheSnapshotShmem(int64_t aTextureId, bool aDispatch) {
+  if (aDispatch) {
+    DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
+        "CanvasTranslator::CacheSnapshotShmem", this,
+        &CanvasTranslator::CacheSnapshotShmem, aTextureId, false));
+    return;
+  }
+
+  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId)) {
+    if (Maybe<Shmem> shmem = webgl->GetShmem()) {
+      // Lock the DT so that it doesn't get removed while shmem is in transit.
+      mTextureInfo[aTextureId].mLocked++;
+      nsCOMPtr<nsIThread> thread =
+          gfx::CanvasRenderThread::GetCanvasRenderThread();
+      RefPtr<CanvasTranslator> translator = this;
+      SendSnapshotShmem(aTextureId, std::move(*shmem))
+          ->Then(
+              thread, __func__,
+              [=](bool) { translator->RemoveTexture(aTextureId); },
+              [=](ipc::ResponseRejectReason) {
+                translator->RemoveTexture(aTextureId);
+              });
+    }
+  }
+}
+
+void CanvasTranslator::PrepareShmem(int64_t aTextureId) {
+  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId)) {
+    webgl->PrepareData();
+  }
+}
+
 already_AddRefed<gfx::DrawTarget> CanvasTranslator::CreateDrawTarget(
     gfx::ReferencePtr aRefPtr, const gfx::IntSize& aSize,
     gfx::SurfaceFormat aFormat) {
+  MOZ_DIAGNOSTIC_ASSERT(mNextTextureId >= 0, "No texture ID set");
   RefPtr<gfx::DrawTarget> dt;
-  do {
-    TextureData* textureData = CreateTextureData(mTextureType, aSize, aFormat);
-    if (textureData) {
-      MOZ_DIAGNOSTIC_ASSERT(mNextTextureId >= 0, "No texture ID set");
-      textureData->Lock(OpenMode::OPEN_READ_WRITE);
-      mTextureDatas[mNextTextureId] = UniquePtr<TextureData>(textureData);
-      gfx::CanvasManagerParent::AddReplayTexture(this, mNextTextureId,
-                                                 textureData);
-      dt = textureData->BorrowDrawTarget();
+  if (mNextRemoteTextureOwnerId.IsValid()) {
+    if (EnsureSharedContextWebgl()) {
+      mSharedContext->EnterTlsScope();
+    }
+    if (RefPtr<gfx::DrawTargetWebgl> webgl = gfx::DrawTargetWebgl::Create(
+            aSize, aFormat, this, mSharedContext)) {
+      webgl->BeginFrame(gfx::IntRect());
+      dt = webgl.forget().downcast<gfx::DrawTarget>();
+      if (dt) {
+        TextureInfo& info = mTextureInfo[mNextTextureId];
+        info.mDrawTarget = dt;
+        info.mRemoteTextureOwnerId = mNextRemoteTextureOwnerId;
+        CacheSnapshotShmem(mNextTextureId);
+      }
     }
-  } while (!dt && CheckForFreshCanvasDevice(__LINE__));
+    if (!dt) {
+      NotifyRequiresRefresh(mNextTextureId);
+    }
+  }
+
+  if (!dt) {
+    do {
+      TextureData* textureData =
+          CreateTextureData(mTextureType, mBackendType, aSize, aFormat);
+      if (textureData) {
+        TextureInfo& info = mTextureInfo[mNextTextureId];
+        info.mTextureData = UniquePtr<TextureData>(textureData);
+        info.mRemoteTextureOwnerId = mNextRemoteTextureOwnerId;
+        if (textureData->Lock(OpenMode::OPEN_READ_WRITE)) {
+          dt = textureData->BorrowDrawTarget();
+        }
+      }
+    } while (!dt && CheckForFreshCanvasDevice(__LINE__));
+  }
   AddDrawTarget(aRefPtr, dt);
   mNextTextureId = -1;
+  mNextRemoteTextureOwnerId = RemoteTextureOwnerId();
 
   return dt.forget();
 }
 
 void CanvasTranslator::RemoveTexture(int64_t aTextureId) {
-  mTextureDatas.erase(aTextureId);
+  {
+    // Don't erase the texture if still in use
+    auto result = mTextureInfo.find(aTextureId);
+    if (result == mTextureInfo.end() || --result->second.mLocked > 0) {
+      return;
+    }
+    mTextureInfo.erase(result);
+  }
 
   // It is possible that the texture from the content process has never been
   // forwarded from the GPU process, so make sure its descriptor is removed.
@@ -463,16 +605,117 @@
 }
 
 TextureData* CanvasTranslator::LookupTextureData(int64_t aTextureId) {
-  TextureMap::const_iterator result = mTextureDatas.find(aTextureId);
-  if (result == mTextureDatas.end()) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
     return nullptr;
   }
-  return result->second.get();
+  return result->second.mTextureData.get();
+}
+
+bool CanvasTranslator::LockTexture(int64_t aTextureId, OpenMode aMode,
+                                   RemoteTextureId aId) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
+    return false;
+  }
+  if (result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    gfx::DrawTargetWebgl* webgl =
+        static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+    webgl->BeginFrame(webgl->GetRect());
+  } else if (TextureData* data = result->second.mTextureData.get()) {
+    if (!data->Lock(aMode)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool CanvasTranslator::UnlockTexture(int64_t aTextureId, RemoteTextureId aId) {
+  auto result = mTextureInfo.find(aTextureId);
+  if (result == mTextureInfo.end()) {
+    return false;
+  }
+  RemoteTextureOwnerId ownerId = result->second.mRemoteTextureOwnerId;
+  if (result->second.mDrawTarget &&
+      result->second.mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
+    gfx::DrawTargetWebgl* webgl =
+        static_cast<gfx::DrawTargetWebgl*>(result->second.mDrawTarget.get());
+    webgl->EndFrame();
+    webgl->CopyToSwapChain(aId, ownerId, OtherPid());
+    if (!result->second.mNotifiedRequiresRefresh && webgl->RequiresRefresh()) {
+      result->second.mNotifiedRequiresRefresh = true;
+      NotifyRequiresRefresh(aTextureId);
+    }
+  } else if (TextureData* data = result->second.mTextureData.get()) {
+    if (aId.IsValid()) {
+      PushRemoteTexture(data, aId, ownerId);
+      data->Unlock();
+    } else {
+      data->Unlock();
+      gfx::CanvasManagerParent::AddReplayTexture(this, aTextureId, data);
+    }
+  }
+  return true;
+}
+
+bool CanvasTranslator::PushRemoteTexture(TextureData* aData,
+                                         RemoteTextureId aId,
+                                         RemoteTextureOwnerId aOwnerId) {
+  if (!mRemoteTextureOwner) {
+    mRemoteTextureOwner = new RemoteTextureOwnerClient(OtherPid());
+  }
+  if (!mRemoteTextureOwner->IsRegistered(aOwnerId)) {
+    mRemoteTextureOwner->RegisterTextureOwner(
+        aOwnerId,
+        /* aIsSyncMode */ gfx::gfxVars::WebglOopAsyncPresentForceSync());
+  }
+  TextureData::Info info;
+  aData->FillInfo(info);
+  UniquePtr<TextureData> dstData;
+  if (mTextureType == TextureType::Unknown) {
+    dstData = mRemoteTextureOwner->CreateOrRecycleBufferTextureData(
+        aOwnerId, info.size, info.format);
+  } else {
+    dstData.reset(
+        CreateTextureData(mTextureType, mBackendType, info.size, info.format));
+  }
+  bool success = false;
+  // Source data is already locked.
+  if (dstData && dstData->Lock(OpenMode::OPEN_WRITE)) {
+    if (RefPtr<gfx::DrawTarget> dstDT = dstData->BorrowDrawTarget()) {
+      if (RefPtr<gfx::DrawTarget> srcDT = aData->BorrowDrawTarget()) {
+        if (RefPtr<gfx::SourceSurface> snapshot = srcDT->Snapshot()) {
+          dstDT->CopySurface(snapshot, snapshot->GetRect(),
+                             gfx::IntPoint(0, 0));
+          success = true;
+        }
+      }
+    }
+    dstData->Unlock();
+  }
+  if (success) {
+    mRemoteTextureOwner->PushTexture(aId, aOwnerId, std::move(dstData));
+  } else {
+    mRemoteTextureOwner->PushDummyTexture(aId, aOwnerId);
+  }
+  return success;
+}
+
+void CanvasTranslator::ClearTextureInfo() {
+  mTextureInfo.clear();
+  mDrawTargets.Clear();
+  mSharedContext = nullptr;
+  mBaseDT = nullptr;
+  if (mRemoteTextureOwner) {
+    mRemoteTextureOwner->UnregisterAllTextureOwners();
+    mRemoteTextureOwner = nullptr;
+  }
 }
 
 already_AddRefed<gfx::SourceSurface> CanvasTranslator::LookupExternalSurface(
     uint64_t aKey) {
-  return SharedSurfacesParent::Get(wr::ToExternalImageId(aKey));
+  return SharedSurfacesParent::Get(wr::ToExternalImageId(aKey), true);
 }
 
 already_AddRefed<gfx::GradientStops> CanvasTranslator::GetOrCreateGradientStops(