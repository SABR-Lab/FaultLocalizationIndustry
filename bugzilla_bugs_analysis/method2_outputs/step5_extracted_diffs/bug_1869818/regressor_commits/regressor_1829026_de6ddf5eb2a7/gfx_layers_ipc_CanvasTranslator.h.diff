# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.h
# Commit: de6ddf5eb2a7
# Full Hash: de6ddf5eb2a7bd3d8a2f58636760e0aa16c584b9
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2023-12-05 21:29:44
# Regressor Bug: 1829026
# File Overlap Count: 1
# Description:
#   Bug 1829026 - Update CanvasTranslator to work with DrawTargetWebgl. r=aosmond
#   
#   This adds the necessary infrastructure for CanvasTranslator to allocate DrawTargetWebgl
#   instead of just allocating TextureData, and to use RemoteTextureMap to handle sending
#   the DrawTargetWebgl frames to the compositor.
# ==============================================================================

diff -r 773e7b31ac6e -r de6ddf5eb2a7 gfx/layers/ipc/CanvasTranslator.h
--- a/gfx/layers/ipc/CanvasTranslator.h	Tue Dec 05 09:37:03 2023 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.h	Tue Dec 05 09:37:03 2023 +0000
@@ -14,6 +14,7 @@
 #include "mozilla/layers/CanvasDrawEventRecorder.h"
 #include "mozilla/layers/LayersSurfaces.h"
 #include "mozilla/layers/PCanvasParent.h"
+#include "mozilla/layers/RemoteTextureMap.h"
 #include "mozilla/ipc/CrossProcessSemaphore.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/UniquePtr.h"
@@ -21,6 +22,11 @@
 namespace mozilla {
 class TaskQueue;
 
+namespace gfx {
+class DrawTargetWebgl;
+class SharedContextWebgl;
+}  // namespace gfx
+
 namespace layers {
 
 class TextureData;
@@ -52,6 +58,7 @@
    * CanvasEventRingBuffer.
    *
    * @param aTextureType the TextureType the translator will create
+   * @param aBackendType the BackendType for texture data
    * @param aReadHandle handle to the shared memory for the
    *        CanvasEventRingBuffer
    * @param aReaderSem reading blocked semaphore for the CanvasEventRingBuffer
@@ -60,7 +67,7 @@
    *        pool for translation requests
    */
   ipc::IPCResult RecvInitTranslator(
-      const TextureType& aTextureType,
+      const TextureType& aTextureType, const gfx::BackendType& aBackendType,
       ipc::SharedMemoryBasic::Handle&& aReadHandle,
       CrossProcessSemaphoreHandle&& aReaderSem,
       CrossProcessSemaphoreHandle&& aWriterSem, const bool& aUseIPDLThread);
@@ -118,7 +125,7 @@
    * @param aData the data to be written back to the writer
    * @param aSize the number of chars to write
    */
-  void ReturnWrite(const char* aData, size_t aSize) {
+  void ReturnWrite(const uint8_t* aData, size_t aSize) {
     mStream->ReturnWrite(aData, aSize);
   }
 
@@ -126,8 +133,9 @@
    * Set the texture ID that will be used as a lookup for the texture created by
    * the next CreateDrawTarget.
    */
-  void SetNextTextureId(int64_t aNextTextureId) {
+  void SetNextTextureId(int64_t aNextTextureId, RemoteTextureOwnerId aOwnerId) {
     mNextTextureId = aNextTextureId;
+    mNextRemoteTextureOwnerId = aOwnerId;
   }
 
   /**
@@ -163,6 +171,12 @@
    */
   void RemoveTexture(int64_t aTextureId);
 
+  bool LockTexture(int64_t aTextureId, OpenMode aMode, RemoteTextureId aId);
+  bool UnlockTexture(int64_t aTextureId, RemoteTextureId aId);
+
+  bool PushRemoteTexture(TextureData* aData, RemoteTextureId aId,
+                         RemoteTextureOwnerId aOwnerId);
+
   /**
    * Overriden to remove any DataSourceSurfaces associated with the RefPtr.
    *
@@ -244,6 +258,8 @@
   UniquePtr<gfx::DataSourceSurface::ScopedMap> GetPreparedMap(
       gfx::ReferencePtr aSurface);
 
+  void PrepareShmem(int64_t aTextureId);
+
  private:
   ~CanvasTranslator();
 
@@ -257,11 +273,14 @@
 
   void Deactivate();
 
+  void BlockCanvas();
+
   TextureData* CreateTextureData(TextureType aTextureType,
+                                 gfx::BackendType aBackendType,
                                  const gfx::IntSize& aSize,
                                  gfx::SurfaceFormat aFormat);
 
-  void AddSurfaceDescriptor(int64_t aTextureId, TextureData* atextureData);
+  void ClearTextureInfo();
 
   bool HandleExtensionEvent(int32_t aType);
 
@@ -269,10 +288,17 @@
   bool CheckForFreshCanvasDevice(int aLineNumber);
   void NotifyDeviceChanged();
 
+  bool EnsureSharedContextWebgl();
+  gfx::DrawTargetWebgl* GetDrawTargetWebgl(int64_t aTextureId) const;
+  void NotifyRequiresRefresh(int64_t aTextureId, bool aDispatch = true);
+  void CacheSnapshotShmem(int64_t aTextureId, bool aDispatch = true);
+
   RefPtr<TaskQueue> mTranslationTaskQueue;
 #if defined(XP_WIN)
   RefPtr<ID3D11Device> mDevice;
 #endif
+  RefPtr<gfx::SharedContextWebgl> mSharedContext;
+  RefPtr<RemoteTextureOwnerClient> mRemoteTextureOwner;
   // We hold the ring buffer as a UniquePtr so we can drop it once
   // mTranslationTaskQueue has shutdown to break a RefPtr cycle.
   UniquePtr<CanvasEventRingBuffer> mStream;
@@ -281,13 +307,22 @@
   // Sometimes during device reset our reference DrawTarget can be null, so we
   // hold the BackendType separately.
   gfx::BackendType mBackendType = gfx::BackendType::NONE;
-  typedef std::unordered_map<int64_t, UniquePtr<TextureData>> TextureMap;
-  TextureMap mTextureDatas;
+  struct TextureInfo {
+    UniquePtr<TextureData> mTextureData;
+    RefPtr<gfx::DrawTarget> mDrawTarget;
+    RemoteTextureOwnerId mRemoteTextureOwnerId;
+    bool mNotifiedRequiresRefresh = false;
+    // Ref-count of how active uses of the DT. Avoids deletion when locked.
+    int32_t mLocked = 1;
+  };
+  std::unordered_map<int64_t, TextureInfo> mTextureInfo;
   int64_t mNextTextureId = -1;
+  RemoteTextureOwnerId mNextRemoteTextureOwnerId;
   nsRefPtrHashtable<nsPtrHashKey<void>, gfx::DataSourceSurface> mDataSurfaces;
   gfx::ReferencePtr mMappedSurface;
   UniquePtr<gfx::DataSourceSurface::ScopedMap> mPreparedMap;
   Atomic<bool> mDeactivated{false};
+  Atomic<bool> mBlocked{false};
   bool mIsInTransaction = false;
   bool mDeviceResetInProgress = false;
 };