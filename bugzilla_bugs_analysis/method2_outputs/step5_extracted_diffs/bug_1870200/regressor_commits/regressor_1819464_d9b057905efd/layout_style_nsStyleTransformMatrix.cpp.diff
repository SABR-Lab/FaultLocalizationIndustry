# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/nsStyleTransformMatrix.cpp
# Commit: d9b057905efd
# Full Hash: d9b057905efd5a2feedf354ea5b8a039a042ae09
# Author: Boris Chiou <boris.chiou@gmail.com>
# Date: 2023-08-23 04:21:33
# Regressor Bug: 1819464
# File Overlap Count: 1
# Description:
#   Bug 1819464 - Part 3: Refactor TransformReferenceBox. r=emilio
#   
#   Refactor this structure to match spec and make us easier to support
#   content-box and stroke-box.
#   
# ==============================================================================

diff -r 473ebe5ec7aa -r d9b057905efd layout/style/nsStyleTransformMatrix.cpp
--- a/layout/style/nsStyleTransformMatrix.cpp	Tue Aug 22 19:49:03 2023 +0000
+++ b/layout/style/nsStyleTransformMatrix.cpp	Tue Aug 22 19:49:03 2023 +0000
@@ -13,6 +13,7 @@
 #include "nsPresContext.h"
 #include "mozilla/MotionPathUtils.h"
 #include "mozilla/ServoBindings.h"
+#include "mozilla/StaticPrefs_layout.h"
 #include "mozilla/StyleAnimationValue.h"
 #include "mozilla/SVGUtils.h"
 #include "gfxMatrix.h"
@@ -38,6 +39,53 @@
 // and consequently get the wrong value.
 // #define UNIFIED_CONTINUATIONS
 
+static nsRect GetSVGBox(const nsIFrame* aFrame) {
+  auto computeViewBox = [&]() {
+    // Percentages in transforms resolve against the width/height of the
+    // nearest viewport (or its viewBox if one is applied), and the
+    // transform is relative to {0,0} in current user space.
+    CSSSize size = CSSSize::FromUnknownSize(SVGUtils::GetContextSize(aFrame));
+    return nsRect(-aFrame->GetPosition(), CSSPixel::ToAppUnits(size));
+  };
+
+  // For SVG elements without associated CSS layout box, the used value for
+  // content-box is fill-box and for border-box is stroke-box.
+  // https://drafts.csswg.org/css-transforms-1/#transform-box
+  switch (aFrame->StyleDisplay()->mTransformBox) {
+    case StyleTransformBox::ContentBox:
+      // TODO: Implement this in the following patches.
+      return {};
+    case StyleTransformBox::FillBox: {
+      // Percentages in transforms resolve against the SVG bbox, and the
+      // transform is relative to the top-left of the SVG bbox.
+      nsRect bboxInAppUnits = nsLayoutUtils::ComputeGeometryBox(
+          const_cast<nsIFrame*>(aFrame), StyleGeometryBox::FillBox);
+      // The mRect of an SVG nsIFrame is its user space bounds *including*
+      // stroke and markers, whereas bboxInAppUnits is its user space bounds
+      // including fill only.  We need to note the offset of the reference box
+      // from the frame's mRect in mX/mY.
+      return {bboxInAppUnits.x - aFrame->GetPosition().x,
+              bboxInAppUnits.y - aFrame->GetPosition().y, bboxInAppUnits.width,
+              bboxInAppUnits.height};
+    }
+    case StyleTransformBox::BorderBox:
+      if (!StaticPrefs::layout_css_transform_box_content_stroke_enabled()) {
+        // If stroke-box is disabled, we shouldn't use it and fall back to
+        // view-box.
+        return computeViewBox();
+      }
+      [[fallthrough]];
+    case StyleTransformBox::StrokeBox:
+      // TODO: Implement this in the following patches.
+      return {};
+    case StyleTransformBox::ViewBox:
+      return computeViewBox();
+  }
+
+  MOZ_ASSERT_UNREACHABLE("All transform box should be handled.");
+  return {};
+}
+
 void TransformReferenceBox::EnsureDimensionsAreCached() {
   if (mIsCached) {
     return;
@@ -45,82 +93,53 @@
 
   MOZ_ASSERT(mFrame);
 
-  const auto box = mFrame->StyleDisplay()->mTransformBox;
-  if (box == StyleTransformBox::ContentBox ||
-      box == StyleTransformBox::StrokeBox) {
-    // TODO: Implement this in the following patches.
-    return;
-  }
-
   mIsCached = true;
 
   if (mFrame->HasAnyStateBits(NS_FRAME_SVG_LAYOUT)) {
-    if (box == StyleTransformBox::FillBox) {
-      // Percentages in transforms resolve against the SVG bbox, and the
-      // transform is relative to the top-left of the SVG bbox.
-      nsRect bboxInAppUnits = nsLayoutUtils::ComputeGeometryBox(
-          const_cast<nsIFrame*>(mFrame), StyleGeometryBox::FillBox);
-      // The mRect of an SVG nsIFrame is its user space bounds *including*
-      // stroke and markers, whereas bboxInAppUnits is its user space bounds
-      // including fill only.  We need to note the offset of the reference box
-      // from the frame's mRect in mX/mY.
-      mX = bboxInAppUnits.x - mFrame->GetPosition().x;
-      mY = bboxInAppUnits.y - mFrame->GetPosition().y;
-      mWidth = bboxInAppUnits.width;
-      mHeight = bboxInAppUnits.height;
-    } else {
-      // The value 'border-box' is treated as 'view-box' for SVG content.
-      MOZ_ASSERT(box == StyleTransformBox::ViewBox ||
-                     box == StyleTransformBox::BorderBox,
-                 "Unexpected value for 'transform-box'");
-      // Percentages in transforms resolve against the width/height of the
-      // nearest viewport (or its viewBox if one is applied), and the
-      // transform is relative to {0,0} in current user space.
-      mX = -mFrame->GetPosition().x;
-      mY = -mFrame->GetPosition().y;
-      Size contextSize = SVGUtils::GetContextSize(mFrame);
-      mWidth = nsPresContext::CSSPixelsToAppUnits(contextSize.width);
-      mHeight = nsPresContext::CSSPixelsToAppUnits(contextSize.height);
-    }
+    mBox = GetSVGBox(mFrame);
     return;
   }
 
-  // If UNIFIED_CONTINUATIONS is not defined, this is simply the frame's
-  // bounding rectangle, translated to the origin.  Otherwise, it is the
-  // smallest rectangle containing a frame and all of its continuations.  For
-  // example, if there is a <span> element with several continuations split
-  // over several lines, this function will return the rectangle containing all
-  // of those continuations.
+  // For elements with associated CSS layout box, the used value for fill-box is
+  // content-box and for stroke-box and view-box is border-box.
+  // https://drafts.csswg.org/css-transforms-1/#transform-box
+  switch (mFrame->StyleDisplay()->mTransformBox) {
+    case StyleTransformBox::FillBox:
+    case StyleTransformBox::ContentBox: {
+      // TODO: Implement this in the following patches.
+      return;
+    }
+    case StyleTransformBox::StrokeBox:
+      // TODO: Implement this in the following patches.
+      return;
+    case StyleTransformBox::ViewBox:
+    case StyleTransformBox::BorderBox: {
+      // If UNIFIED_CONTINUATIONS is not defined, this is simply the frame's
+      // bounding rectangle, translated to the origin.  Otherwise, it is the
+      // smallest rectangle containing a frame and all of its continuations. For
+      // example, if there is a <span> element with several continuations split
+      // over several lines, this function will return the rectangle containing
+      // all of those continuations.
 
-  nsRect rect;
+      nsRect rect;
 
 #ifndef UNIFIED_CONTINUATIONS
-  rect = mFrame->GetRect();
+      rect = mFrame->GetRect();
 #else
-  // Iterate the continuation list, unioning together the bounding rects:
-  for (const nsIFrame* currFrame = mFrame->FirstContinuation();
-       currFrame != nullptr; currFrame = currFrame->GetNextContinuation()) {
-    // Get the frame rect in local coordinates, then translate back to the
-    // original coordinates:
-    rect.UnionRect(
-        result, nsRect(currFrame->GetOffsetTo(mFrame), currFrame->GetSize()));
-  }
+      // Iterate the continuation list, unioning together the bounding rects:
+      for (const nsIFrame* currFrame = mFrame->FirstContinuation();
+           currFrame != nullptr; currFrame = currFrame->GetNextContinuation()) {
+        // Get the frame rect in local coordinates, then translate back to the
+        // original coordinates:
+        rect.UnionRect(result, nsRect(currFrame->GetOffsetTo(mFrame),
+                                      currFrame->GetSize()));
+      }
 #endif
 
-  mX = 0;
-  mY = 0;
-  mWidth = rect.Width();
-  mHeight = rect.Height();
-}
-
-void TransformReferenceBox::Init(const nsRect& aDimensions) {
-  MOZ_ASSERT(!mFrame && !mIsCached);
-
-  mX = aDimensions.x;
-  mY = aDimensions.y;
-  mWidth = aDimensions.width;
-  mHeight = aDimensions.height;
-  mIsCached = true;
+      mBox = {0, 0, rect.Width(), rect.Height()};
+      return;
+    }
+  }
 }
 
 float ProcessTranslatePart(