# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/2d/RecordedEvent.h
# Commit: 8839a3ba6243
# Full Hash: 8839a3ba62436bd0ea7e5bd07e2b63a8d45b8609
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2023-12-09 09:33:28
# Regressor Bug: 1863914
# File Overlap Count: 1
# Description:
#   Bug 1863914: Use multiple shmem buffers for remote canvas recording. r=aosmond
#   
#   This replaces the use of a single large ring buffer.
#   The buffers are still processed in parallel and are recycled to reduce
#   allocation. Events that do not fit in the default sized buffer have a separate
# ==============================================================================

diff -r f088b7a21045 -r 8839a3ba6243 gfx/2d/RecordedEvent.h
--- a/gfx/2d/RecordedEvent.h	Fri Dec 08 15:56:39 2023 +0000
+++ b/gfx/2d/RecordedEvent.h	Fri Dec 08 16:11:27 2023 +0000
@@ -214,7 +214,7 @@
 };
 
 struct MemWriter {
-  explicit MemWriter(char* aPtr) : mPtr(aPtr) {}
+  constexpr explicit MemWriter(char* aPtr) : mPtr(aPtr) {}
   void write(const char* aData, size_t aSize) {
     memcpy(mPtr, aData, aSize);
     mPtr += aSize;
@@ -222,13 +222,52 @@
   char* mPtr;
 };
 
-// This is a simple interface for an EventRingBuffer, so we can use it in the
-// RecordedEvent reading and writing machinery.
-class EventRingBuffer {
+// An istream like class for reading from memory
+struct MemReader {
+  constexpr MemReader(char* aData, size_t aLen)
+      : mData(aData), mEnd(aData + aLen) {}
+  void read(char* s, std::streamsize n) {
+    if (n <= (mEnd - mData)) {
+      memcpy(s, mData, n);
+      mData += n;
+    } else {
+      // We've requested more data than is available
+      // set the Reader into an eof state
+      SetIsBad();
+    }
+  }
+  bool eof() { return mData > mEnd; }
+  bool good() { return !eof(); }
+  void SetIsBad() { mData = mEnd + 1; }
+
+  char* mData;
+  char* mEnd;
+};
+
+class ContiguousBuffer {
+ public:
+  ContiguousBuffer(char* aStart, size_t aSize)
+      : mWriter(aStart), mEnd(aStart + aSize) {}
+
+  constexpr MOZ_IMPLICIT ContiguousBuffer(std::nullptr_t) : mWriter(nullptr) {}
+
+  MemWriter& Writer() { return mWriter; }
+
+  size_t SizeRemaining() { return mWriter.mPtr ? mEnd - mWriter.mPtr : 0; }
+
+  bool IsValid() { return !!mWriter.mPtr; }
+
+ private:
+  MemWriter mWriter;
+  char* mEnd = nullptr;
+};
+
+// Allows a derived class to provide guaranteed contiguous buffer.
+class ContiguousBufferStream {
  public:
   /**
-   * Templated RecordEvent function so that when we have enough contiguous
-   * space we can record into the buffer quickly using MemWriter.
+   * Templated RecordEvent function so that we can record into the buffer
+   * quickly using MemWriter.
    *
    * @param aRecordedEvent the event to record
    */
@@ -237,56 +276,25 @@
     SizeCollector size;
     WriteElement(size, aRecordedEvent->GetType());
     aRecordedEvent->Record(size);
-    if (size.mTotalSize > mAvailable) {
-      WaitForAndRecalculateAvailableSpace();
+    auto& buffer = GetContiguousBuffer(size.mTotalSize);
+    if (!buffer.IsValid()) {
+      return;
     }
-    if (size.mTotalSize <= mAvailable) {
-      MemWriter writer(mBufPos);
-      WriteElement(writer, aRecordedEvent->GetType());
-      aRecordedEvent->Record(writer);
-      UpdateWriteTotalsBy(size.mTotalSize);
-    } else {
-      WriteElement(*this, aRecordedEvent->GetType());
-      aRecordedEvent->Record(*this);
-    }
-  }
 
-  /**
-   * Simple write function required by WriteElement.
-   *
-   * @param aData the data to be written to the buffer
-   * @param aSize the number of chars to write
-   */
-  virtual void write(const char* const aData, const size_t aSize) = 0;
+    MOZ_ASSERT(size.mTotalSize <= buffer.SizeRemaining());
 
-  /**
-   * Simple read function required by ReadElement.
-   *
-   * @param aOut the pointer to read into
-   * @param aSize the number of chars to read
-   */
-  virtual void read(char* const aOut, const size_t aSize) = 0;
-
-  virtual bool good() const = 0;
-
-  virtual void SetIsBad() = 0;
+    WriteElement(buffer.Writer(), aRecordedEvent->GetType());
+    aRecordedEvent->Record(buffer.Writer());
+    IncrementEventCount();
+  }
 
  protected:
   /**
-   * Wait until space is available for writing and then set mBufPos and
-   * mAvailable.
+   * Provide a contiguous buffer with at least aSize remaining.
    */
-  virtual bool WaitForAndRecalculateAvailableSpace() = 0;
+  virtual ContiguousBuffer& GetContiguousBuffer(size_t aSize) = 0;
 
-  /**
-   * Update write count, mBufPos and mAvailable.
-   *
-   * @param aCount number of bytes written
-   */
-  virtual void UpdateWriteTotalsBy(uint32_t aCount) = 0;
-
-  char* mBufPos = nullptr;
-  uint32_t mAvailable = 0;
+  virtual void IncrementEventCount() = 0;
 };
 
 struct MemStream {
@@ -430,7 +438,7 @@
 
   virtual void RecordToStream(std::ostream& aStream) const = 0;
   virtual void RecordToStream(EventStream& aStream) const = 0;
-  virtual void RecordToStream(EventRingBuffer& aStream) const = 0;
+  virtual void RecordToStream(ContiguousBufferStream& aStream) const = 0;
   virtual void RecordToStream(MemStream& aStream) const = 0;
 
   virtual void OutputSimpleEventInfo(std::stringstream& aStringStream) const {}
@@ -460,8 +468,8 @@
   static bool DoWithEventFromStream(
       EventStream& aStream, EventType aType,
       const std::function<bool(RecordedEvent*)>& aAction);
-  static bool DoWithEventFromStream(
-      EventRingBuffer& aStream, EventType aType,
+  static bool DoWithEventFromReader(
+      MemReader& aReader, EventType aType,
       const std::function<bool(RecordedEvent*)>& aAction);
 
   EventType GetType() const { return (EventType)mType; }
@@ -495,7 +503,7 @@
     WriteElement(aStream, this->mType);
     static_cast<const Derived*>(this)->Record(aStream);
   }
-  void RecordToStream(EventRingBuffer& aStream) const final {
+  void RecordToStream(ContiguousBufferStream& aStream) const final {
     aStream.RecordEvent(static_cast<const Derived*>(this));
   }
   void RecordToStream(MemStream& aStream) const override {