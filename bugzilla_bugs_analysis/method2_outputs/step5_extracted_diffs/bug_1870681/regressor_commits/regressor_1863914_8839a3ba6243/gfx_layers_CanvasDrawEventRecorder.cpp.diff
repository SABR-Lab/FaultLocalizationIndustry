# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/CanvasDrawEventRecorder.cpp
# Commit: 8839a3ba6243
# Full Hash: 8839a3ba62436bd0ea7e5bd07e2b63a8d45b8609
# Author: Bob Owen <bobowencode@gmail.com>
# Date: 2023-12-09 09:33:28
# Regressor Bug: 1863914
# File Overlap Count: 1
# Description:
#   Bug 1863914: Use multiple shmem buffers for remote canvas recording. r=aosmond
#   
#   This replaces the use of a single large ring buffer.
#   The buffers are still processed in parallel and are recycled to reduce
#   allocation. Events that do not fit in the default sized buffer have a separate
# ==============================================================================

diff -r f088b7a21045 -r 8839a3ba6243 gfx/layers/CanvasDrawEventRecorder.cpp
--- a/gfx/layers/CanvasDrawEventRecorder.cpp	Fri Dec 08 15:56:39 2023 +0000
+++ b/gfx/layers/CanvasDrawEventRecorder.cpp	Fri Dec 08 16:11:27 2023 +0000
@@ -9,294 +9,268 @@
 #include <string.h>
 
 #include "mozilla/layers/SharedSurfacesChild.h"
-#include "nsThreadUtils.h"
+#include "mozilla/StaticPrefs_gfx.h"
+#include "RecordedCanvasEventImpl.h"
 
 namespace mozilla {
 namespace layers {
 
-static const uint32_t kMaxSpinCount = 200;
-
-static const TimeDuration kTimeout = TimeDuration::FromMilliseconds(100);
-static const int32_t kTimeoutRetryCount = 50;
+struct ShmemAndHandle {
+  RefPtr<ipc::SharedMemoryBasic> shmem;
+  Handle handle;
+};
 
-static const uint32_t kCacheLineSize = 64;
-static const uint32_t kSmallStreamSize = 64 * 1024;
-static const uint32_t kLargeStreamSize = 2048 * 1024;
+static Maybe<ShmemAndHandle> CreateAndMapShmem(size_t aSize) {
+  auto shmem = MakeRefPtr<ipc::SharedMemoryBasic>();
+  if (!shmem->Create(aSize) || !shmem->Map(aSize)) {
+    return Nothing();
+  }
 
-static_assert((static_cast<uint64_t>(UINT32_MAX) + 1) % kSmallStreamSize == 0,
-              "kSmallStreamSize must be a power of two.");
-static_assert((static_cast<uint64_t>(UINT32_MAX) + 1) % kLargeStreamSize == 0,
-              "kLargeStreamSize must be a power of two.");
+  auto shmemHandle = shmem->TakeHandle();
+  if (!shmemHandle) {
+    return Nothing();
+  }
 
-uint32_t CanvasEventRingBuffer::StreamSize() {
-  return mLargeStream ? kLargeStreamSize : kSmallStreamSize;
+  return Some(ShmemAndHandle{shmem.forget(), std::move(shmemHandle)});
 }
 
-bool CanvasEventRingBuffer::InitBuffer(
-    base::ProcessId aOtherPid, ipc::SharedMemoryBasic::Handle* aReadHandle) {
-  size_t shmemSize = StreamSize() + (2 * kCacheLineSize);
-  mSharedMemory = MakeAndAddRef<ipc::SharedMemoryBasic>();
-  if (NS_WARN_IF(!mSharedMemory->Create(shmemSize)) ||
-      NS_WARN_IF(!mSharedMemory->Map(shmemSize))) {
-    mGood = false;
-    return false;
-  }
+CanvasDrawEventRecorder::CanvasDrawEventRecorder() {
+  mDefaultBufferSize = ipc::SharedMemory::PageAlignedSize(
+      StaticPrefs::gfx_canvas_remote_default_buffer_size());
+  mMaxSpinCount = StaticPrefs::gfx_canvas_remote_max_spin_count();
+  mDropBufferLimit = StaticPrefs::gfx_canvas_remote_drop_buffer_limit();
+  mDropBufferOnZero = mDropBufferLimit;
+}
 
-  *aReadHandle = mSharedMemory->TakeHandle();
-  if (NS_WARN_IF(!*aReadHandle)) {
-    mGood = false;
+bool CanvasDrawEventRecorder::Init(TextureType aTextureType,
+                                   UniquePtr<Helpers> aHelpers) {
+  mHelpers = std::move(aHelpers);
+
+  MOZ_ASSERT(mTextureType == TextureType::Unknown);
+  auto header = CreateAndMapShmem(sizeof(Header));
+  if (NS_WARN_IF(header.isNothing())) {
     return false;
   }
 
-  mBuf = static_cast<char*>(mSharedMemory->memory());
-  mBufPos = mBuf;
-  mAvailable = StreamSize();
-
-  static_assert(sizeof(ReadFooter) <= kCacheLineSize,
-                "ReadFooter must fit in kCacheLineSize.");
-  mRead = reinterpret_cast<ReadFooter*>(mBuf + StreamSize());
-  mRead->count = 0;
-  mRead->returnCount = 0;
-  mRead->state = State::Processing;
+  mHeader = static_cast<Header*>(header->shmem->memory());
+  mHeader->eventCount = 0;
+  mHeader->writerWaitCount = 0;
+  mHeader->writerState = State::Processing;
+  mHeader->processedCount = 0;
+  mHeader->readerState = State::Processing;
 
-  static_assert(sizeof(WriteFooter) <= kCacheLineSize,
-                "WriteFooter must fit in kCacheLineSize.");
-  mWrite = reinterpret_cast<WriteFooter*>(mBuf + StreamSize() + kCacheLineSize);
-  mWrite->count = 0;
-  mWrite->returnCount = 0;
-  mWrite->requiredDifference = 0;
-  mWrite->state = State::Processing;
-  mOurCount = 0;
+  // We always keep at least two buffers. This means that when we
+  // have to add a new buffer, there is at least a full buffer that requires
+  // translating while the handle is sent over.
+  AutoTArray<Handle, 2> bufferHandles;
+  auto buffer = CreateAndMapShmem(mDefaultBufferSize);
+  if (NS_WARN_IF(buffer.isNothing())) {
+    return false;
+  }
+  mCurrentBuffer = CanvasBuffer(std::move(buffer->shmem));
+  bufferHandles.AppendElement(std::move(buffer->handle));
 
-  return true;
-}
+  buffer = CreateAndMapShmem(mDefaultBufferSize);
+  if (NS_WARN_IF(buffer.isNothing())) {
+    return false;
+  }
+  mRecycledBuffers.emplace(buffer->shmem.forget(), 0);
+  bufferHandles.AppendElement(std::move(buffer->handle));
 
-bool CanvasEventRingBuffer::InitWriter(
-    base::ProcessId aOtherPid, ipc::SharedMemoryBasic::Handle* aReadHandle,
-    CrossProcessSemaphoreHandle* aReaderSem,
-    CrossProcessSemaphoreHandle* aWriterSem,
-    UniquePtr<WriterServices> aWriterServices) {
-  if (!InitBuffer(aOtherPid, aReadHandle)) {
+  mWriterSemaphore.reset(CrossProcessSemaphore::Create("CanvasRecorder", 0));
+  auto writerSem = mWriterSemaphore->CloneHandle();
+  mWriterSemaphore->CloseHandle();
+  if (!IsHandleValid(writerSem)) {
     return false;
   }
 
-  mReaderSemaphore.reset(
-      CrossProcessSemaphore::Create("SharedMemoryStreamParent", 0));
-  *aReaderSem = mReaderSemaphore->CloneHandle();
+  mReaderSemaphore.reset(CrossProcessSemaphore::Create("CanvasTranslator", 0));
+  auto readerSem = mReaderSemaphore->CloneHandle();
   mReaderSemaphore->CloseHandle();
-  if (!IsHandleValid(*aReaderSem)) {
-    return false;
-  }
-  mWriterSemaphore.reset(
-      CrossProcessSemaphore::Create("SharedMemoryStreamChild", 0));
-  *aWriterSem = mWriterSemaphore->CloneHandle();
-  mWriterSemaphore->CloseHandle();
-  if (!IsHandleValid(*aWriterSem)) {
+  if (!IsHandleValid(readerSem)) {
     return false;
   }
 
-  mWriterServices = std::move(aWriterServices);
-
-  mGood = true;
-  return true;
-}
-
-bool CanvasEventRingBuffer::InitReader(
-    ipc::SharedMemoryBasic::Handle aReadHandle,
-    CrossProcessSemaphoreHandle aReaderSem,
-    CrossProcessSemaphoreHandle aWriterSem,
-    UniquePtr<ReaderServices> aReaderServices) {
-  if (!SetNewBuffer(std::move(aReadHandle))) {
-    return false;
-  }
-
-  mReaderSemaphore.reset(CrossProcessSemaphore::Create(std::move(aReaderSem)));
-  mReaderSemaphore->CloseHandle();
-  mWriterSemaphore.reset(CrossProcessSemaphore::Create(std::move(aWriterSem)));
-  mWriterSemaphore->CloseHandle();
-
-  mReaderServices = std::move(aReaderServices);
-
-  mGood = true;
-  return true;
-}
-
-bool CanvasEventRingBuffer::SetNewBuffer(
-    ipc::SharedMemoryBasic::Handle aReadHandle) {
-  MOZ_RELEASE_ASSERT(
-      !mSharedMemory,
-      "Shared memory should have been dropped before new buffer is sent.");
-
-  size_t shmemSize = StreamSize() + (2 * kCacheLineSize);
-  mSharedMemory = MakeAndAddRef<ipc::SharedMemoryBasic>();
-  if (NS_WARN_IF(!mSharedMemory->SetHandle(
-          std::move(aReadHandle), ipc::SharedMemory::RightsReadWrite)) ||
-      NS_WARN_IF(!mSharedMemory->Map(shmemSize))) {
-    mGood = false;
+  if (!mHelpers->InitTranslator(aTextureType, std::move(header->handle),
+                                std::move(bufferHandles), mDefaultBufferSize,
+                                std::move(readerSem), std::move(writerSem),
+                                /* aUseIPDLThread */ false)) {
     return false;
   }
 
-  mSharedMemory->CloseHandle();
-
-  mBuf = static_cast<char*>(mSharedMemory->memory());
-  mRead = reinterpret_cast<ReadFooter*>(mBuf + StreamSize());
-  mWrite = reinterpret_cast<WriteFooter*>(mBuf + StreamSize() + kCacheLineSize);
-  mOurCount = 0;
-  return true;
-}
-
-bool CanvasEventRingBuffer::WaitForAndRecalculateAvailableSpace() {
-  if (!good()) {
-    return false;
-  }
-
-  uint32_t bufPos = mOurCount % StreamSize();
-  uint32_t maxToWrite = StreamSize() - bufPos;
-  mAvailable = std::min(maxToWrite, WaitForBytesToWrite());
-  if (!mAvailable) {
-    mBufPos = nullptr;
-    return false;
-  }
-
-  mBufPos = mBuf + bufPos;
+  mTextureType = aTextureType;
+  mHeaderShmem = header->shmem;
   return true;
 }
 
-void CanvasEventRingBuffer::write(const char* const aData, const size_t aSize) {
-  const char* curDestPtr = aData;
-  size_t remainingToWrite = aSize;
-  if (remainingToWrite > mAvailable) {
-    if (!WaitForAndRecalculateAvailableSpace()) {
-      return;
+void CanvasDrawEventRecorder::RecordEvent(const gfx::RecordedEvent& aEvent) {
+  aEvent.RecordToStream(*this);
+}
+
+int64_t CanvasDrawEventRecorder::CreateCheckpoint() {
+  int64_t checkpoint = mHeader->eventCount;
+  RecordEvent(RecordedCheckpoint());
+  return checkpoint;
+}
+
+bool CanvasDrawEventRecorder::WaitForCheckpoint(int64_t aCheckpoint) {
+  uint32_t spinCount = mMaxSpinCount;
+  do {
+    if (mHeader->processedCount >= aCheckpoint) {
+      return true;
+    }
+  } while (--spinCount != 0);
+
+  mHeader->writerState = State::AboutToWait;
+  if (mHeader->processedCount >= aCheckpoint) {
+    mHeader->writerState = State::Processing;
+    return true;
+  }
+
+  mHeader->writerWaitCount = aCheckpoint;
+  mHeader->writerState = State::Waiting;
+
+  // Wait unless we detect the reading side has closed.
+  while (!mHelpers->ReaderClosed() && mHeader->readerState != State::Failed) {
+    if (mWriterSemaphore->Wait(Some(TimeDuration::FromMilliseconds(100)))) {
+      MOZ_ASSERT(mHeader->processedCount >= aCheckpoint);
+      return true;
     }
   }
 
-  if (remainingToWrite <= mAvailable) {
-    memcpy(mBufPos, curDestPtr, remainingToWrite);
-    UpdateWriteTotalsBy(remainingToWrite);
-    return;
+  // Either the reader has failed or we're stopping writing for some other
+  // reason (e.g. shutdown), so mark us as failed so the reader is aware.
+  mHeader->writerState = State::Failed;
+  return false;
+}
+
+void CanvasDrawEventRecorder::WriteInternalEvent(EventType aEventType) {
+  MOZ_ASSERT(mCurrentBuffer.SizeRemaining() > 0);
+
+  WriteElement(mCurrentBuffer.Writer(), aEventType);
+  IncrementEventCount();
+}
+
+gfx::ContiguousBuffer& CanvasDrawEventRecorder::GetContiguousBuffer(
+    size_t aSize) {
+  // We make sure that our buffer can hold aSize + 1 to ensure we always have
+  // room for the end of buffer event.
+
+  // Check if there is enough room is our current buffer.
+  if (mCurrentBuffer.SizeRemaining() > aSize) {
+    return mCurrentBuffer;
   }
 
-  do {
-    memcpy(mBufPos, curDestPtr, mAvailable);
-    IncrementWriteCountBy(mAvailable);
-    curDestPtr += mAvailable;
-    remainingToWrite -= mAvailable;
-    if (!WaitForAndRecalculateAvailableSpace()) {
-      return;
+  // If the next recycled buffer is big enough and free use that.
+  if (mRecycledBuffers.front().Capacity() > aSize &&
+      mRecycledBuffers.front().eventCount <= mHeader->processedCount) {
+    // Only queue default size buffers for recycling.
+    if (mCurrentBuffer.Capacity() == mDefaultBufferSize) {
+      WriteInternalEvent(RECYCLE_BUFFER);
+      mRecycledBuffers.emplace(std::move(mCurrentBuffer.shmem),
+                               mHeader->eventCount);
+    } else {
+      WriteInternalEvent(DROP_BUFFER);
+    }
+
+    mCurrentBuffer = CanvasBuffer(std::move(mRecycledBuffers.front().shmem));
+    mRecycledBuffers.pop();
+
+    // If we have more than one recycled buffers free a configured number of
+    // times in a row then drop one.
+    if (mRecycledBuffers.size() > 1 &&
+        mRecycledBuffers.front().eventCount < mHeader->processedCount) {
+      if (--mDropBufferOnZero == 0) {
+        WriteInternalEvent(DROP_BUFFER);
+        mCurrentBuffer =
+            CanvasBuffer(std::move(mRecycledBuffers.front().shmem));
+        mRecycledBuffers.pop();
+        mDropBufferOnZero = 1;
+      }
+    } else {
+      mDropBufferOnZero = mDropBufferLimit;
     }
-  } while (remainingToWrite > mAvailable);
+
+    return mCurrentBuffer;
+  }
+
+  // We don't have a buffer free or it is not big enough, so create a new one.
+  WriteInternalEvent(PAUSE_TRANSLATION);
+
+  // Only queue default size buffers for recycling.
+  if (mCurrentBuffer.Capacity() == mDefaultBufferSize) {
+    mRecycledBuffers.emplace(std::move(mCurrentBuffer.shmem),
+                             mHeader->eventCount);
+  }
 
-  memcpy(mBufPos, curDestPtr, remainingToWrite);
-  UpdateWriteTotalsBy(remainingToWrite);
+  size_t bufferSize = std::max(mDefaultBufferSize,
+                               ipc::SharedMemory::PageAlignedSize(aSize + 1));
+  auto newBuffer = CreateAndMapShmem(bufferSize);
+  if (NS_WARN_IF(newBuffer.isNothing())) {
+    mHeader->writerState = State::Failed;
+    mCurrentBuffer = CanvasBuffer(nullptr);
+    return mCurrentBuffer;
+  }
+
+  if (!mHelpers->AddBuffer(std::move(newBuffer->handle), bufferSize)) {
+    mHeader->writerState = State::Failed;
+    mCurrentBuffer = CanvasBuffer(nullptr);
+    return mCurrentBuffer;
+  }
+
+  mCurrentBuffer = CanvasBuffer(std::move(newBuffer->shmem));
+  return mCurrentBuffer;
 }
 
-void CanvasEventRingBuffer::IncrementWriteCountBy(uint32_t aCount) {
-  mOurCount += aCount;
-  mWrite->count = mOurCount;
-  if (mRead->state != State::Processing) {
-    CheckAndSignalReader();
+void CanvasDrawEventRecorder::DropFreeBuffers() {
+  while (mRecycledBuffers.size() > 1 &&
+         mRecycledBuffers.front().eventCount < mHeader->processedCount) {
+    WriteInternalEvent(DROP_BUFFER);
+    mCurrentBuffer = CanvasBuffer(std::move(mRecycledBuffers.front().shmem));
+    mRecycledBuffers.pop();
   }
 }
 
-void CanvasEventRingBuffer::UpdateWriteTotalsBy(uint32_t aCount) {
-  IncrementWriteCountBy(aCount);
-  mBufPos += aCount;
-  mAvailable -= aCount;
-}
-
-bool CanvasEventRingBuffer::WaitForAndRecalculateAvailableData() {
-  if (!good()) {
-    return false;
-  }
-
-  uint32_t bufPos = mOurCount % StreamSize();
-  uint32_t maxToRead = StreamSize() - bufPos;
-  mAvailable = std::min(maxToRead, WaitForBytesToRead());
-  if (!mAvailable) {
-    SetIsBad();
-    mBufPos = nullptr;
-    return false;
-  }
-
-  mBufPos = mBuf + bufPos;
-  return true;
+void CanvasDrawEventRecorder::IncrementEventCount() {
+  mHeader->eventCount++;
+  CheckAndSignalReader();
 }
 
-void CanvasEventRingBuffer::read(char* const aOut, const size_t aSize) {
-  char* curSrcPtr = aOut;
-  size_t remainingToRead = aSize;
-  if (remainingToRead > mAvailable) {
-    if (!WaitForAndRecalculateAvailableData()) {
-      return;
-    }
-  }
-
-  if (remainingToRead <= mAvailable) {
-    memcpy(curSrcPtr, mBufPos, remainingToRead);
-    UpdateReadTotalsBy(remainingToRead);
-    return;
-  }
-
+void CanvasDrawEventRecorder::CheckAndSignalReader() {
   do {
-    memcpy(curSrcPtr, mBufPos, mAvailable);
-    IncrementReadCountBy(mAvailable);
-    curSrcPtr += mAvailable;
-    remainingToRead -= mAvailable;
-    if (!WaitForAndRecalculateAvailableData()) {
-      return;
-    }
-  } while (remainingToRead > mAvailable);
-
-  memcpy(curSrcPtr, mBufPos, remainingToRead);
-  UpdateReadTotalsBy(remainingToRead);
-}
-
-void CanvasEventRingBuffer::IncrementReadCountBy(uint32_t aCount) {
-  mOurCount += aCount;
-  mRead->count = mOurCount;
-  if (mWrite->state != State::Processing) {
-    CheckAndSignalWriter();
-  }
-}
-
-void CanvasEventRingBuffer::UpdateReadTotalsBy(uint32_t aCount) {
-  IncrementReadCountBy(aCount);
-  mBufPos += aCount;
-  mAvailable -= aCount;
-}
-
-void CanvasEventRingBuffer::CheckAndSignalReader() {
-  do {
-    switch (mRead->state) {
+    switch (mHeader->readerState) {
       case State::Processing:
+      case State::Paused:
       case State::Failed:
         return;
       case State::AboutToWait:
         // The reader is making a decision about whether to wait. So, we must
         // wait until it has decided to avoid races. Check if the reader is
         // closed to avoid hangs.
-        if (mWriterServices->ReaderClosed()) {
+        if (mHelpers->ReaderClosed()) {
           return;
         }
         continue;
       case State::Waiting:
-        if (mRead->count != mOurCount) {
+        if (mHeader->processedCount < mHeader->eventCount) {
           // We have to use compareExchange here because the reader can change
           // from Waiting to Stopped.
-          if (mRead->state.compareExchange(State::Waiting, State::Processing)) {
+          if (mHeader->readerState.compareExchange(State::Waiting,
+                                                   State::Processing)) {
             mReaderSemaphore->Signal();
             return;
           }
 
-          MOZ_ASSERT(mRead->state == State::Stopped);
+          MOZ_ASSERT(mHeader->readerState == State::Stopped);
           continue;
         }
         return;
       case State::Stopped:
-        if (mRead->count != mOurCount) {
-          mRead->state = State::Processing;
-          mWriterServices->ResumeReader();
+        if (mHeader->processedCount < mHeader->eventCount) {
+          mHeader->readerState = State::Processing;
+          if (!mHelpers->RestartReader()) {
+            mHeader->writerState = State::Failed;
+          }
         }
         return;
       default:
@@ -306,267 +280,6 @@
   } while (true);
 }
 
-bool CanvasEventRingBuffer::HasDataToRead() {
-  return (mWrite->count != mOurCount);
-}
-
-bool CanvasEventRingBuffer::StopIfEmpty() {
-  // Double-check that the writer isn't waiting.
-  CheckAndSignalWriter();
-  mRead->state = State::AboutToWait;
-  if (HasDataToRead()) {
-    mRead->state = State::Processing;
-    return false;
-  }
-
-  mRead->state = State::Stopped;
-  return true;
-}
-
-bool CanvasEventRingBuffer::WaitForDataToRead(TimeDuration aTimeout,
-                                              int32_t aRetryCount) {
-  uint32_t spinCount = kMaxSpinCount;
-  do {
-    if (HasDataToRead()) {
-      return true;
-    }
-  } while (--spinCount != 0);
-
-  // Double-check that the writer isn't waiting.
-  CheckAndSignalWriter();
-  mRead->state = State::AboutToWait;
-  if (HasDataToRead()) {
-    mRead->state = State::Processing;
-    return true;
-  }
-
-  mRead->state = State::Waiting;
-  do {
-    if (mReaderSemaphore->Wait(Some(aTimeout))) {
-      MOZ_RELEASE_ASSERT(HasDataToRead());
-      return true;
-    }
-
-    if (mReaderServices->WriterClosed()) {
-      // Something has gone wrong on the writing side, just return false so
-      // that we can hopefully recover.
-      return false;
-    }
-  } while (aRetryCount-- > 0);
-
-  // We have to use compareExchange here because the writer can change our
-  // state if we are waiting. signaled
-  if (!mRead->state.compareExchange(State::Waiting, State::Stopped)) {
-    MOZ_RELEASE_ASSERT(HasDataToRead());
-    MOZ_RELEASE_ASSERT(mRead->state == State::Processing);
-    // The writer has just signaled us, so consume it before returning
-    MOZ_ALWAYS_TRUE(mReaderSemaphore->Wait());
-    return true;
-  }
-
-  return false;
-}
-
-uint8_t CanvasEventRingBuffer::ReadNextEvent() {
-  uint8_t nextEvent;
-  ReadElement(*this, nextEvent);
-  while (nextEvent == kCheckpointEventType && good()) {
-    ReadElement(*this, nextEvent);
-  }
-
-  if (nextEvent == kDropBufferEventType) {
-    // Writer is switching to a different sized buffer.
-    mBuf = nullptr;
-    mBufPos = nullptr;
-    mRead = nullptr;
-    mWrite = nullptr;
-    mAvailable = 0;
-    mSharedMemory = nullptr;
-    // We always toggle between smaller and larger stream sizes.
-    mLargeStream = !mLargeStream;
-  }
-
-  return nextEvent;
-}
-
-uint32_t CanvasEventRingBuffer::CreateCheckpoint() {
-  WriteElement(*this, kCheckpointEventType);
-  return mOurCount;
-}
-
-bool CanvasEventRingBuffer::WaitForCheckpoint(uint32_t aCheckpoint) {
-  return WaitForReadCount(aCheckpoint, kTimeout);
-}
-
-bool CanvasEventRingBuffer::SwitchBuffer(
-    base::ProcessId aOtherPid, ipc::SharedMemoryBasic::Handle* aReadHandle) {
-  WriteElement(*this, kDropBufferEventType);
-
-  // Make sure the drop buffer event has been read before continuing. We can't
-  // write an actual checkpoint because there will be no buffer to read from.
-  if (!WaitForCheckpoint(mOurCount)) {
-    return false;
-  }
-
-  mBuf = nullptr;
-  mBufPos = nullptr;
-  mRead = nullptr;
-  mWrite = nullptr;
-  mAvailable = 0;
-  mSharedMemory = nullptr;
-  // We always toggle between smaller and larger stream sizes.
-  mLargeStream = !mLargeStream;
-  return InitBuffer(aOtherPid, aReadHandle);
-}
-
-void CanvasEventRingBuffer::CheckAndSignalWriter() {
-  do {
-    switch (mWrite->state) {
-      case State::Processing:
-        return;
-      case State::AboutToWait:
-        // The writer is making a decision about whether to wait. So, we must
-        // wait until it has decided to avoid races. Check if the writer is
-        // closed to avoid hangs.
-        if (mReaderServices->WriterClosed()) {
-          return;
-        }
-        continue;
-      case State::Waiting:
-        if (mWrite->count - mOurCount <= mWrite->requiredDifference) {
-          mWrite->state = State::Processing;
-          mWriterSemaphore->Signal();
-        }
-        return;
-      default:
-        MOZ_ASSERT_UNREACHABLE("Invalid waiting state.");
-        return;
-    }
-  } while (true);
-}
-
-bool CanvasEventRingBuffer::WaitForReadCount(uint32_t aReadCount,
-                                             TimeDuration aTimeout) {
-  uint32_t requiredDifference = mOurCount - aReadCount;
-  uint32_t spinCount = kMaxSpinCount;
-  do {
-    if (mOurCount - mRead->count <= requiredDifference) {
-      return true;
-    }
-  } while (--spinCount != 0);
-
-  // Double-check that the reader isn't waiting.
-  CheckAndSignalReader();
-  mWrite->state = State::AboutToWait;
-  if (mOurCount - mRead->count <= requiredDifference) {
-    mWrite->state = State::Processing;
-    return true;
-  }
-
-  mWrite->requiredDifference = requiredDifference;
-  mWrite->state = State::Waiting;
-
-  // Wait unless we detect the reading side has closed.
-  while (!mWriterServices->ReaderClosed() && mRead->state != State::Failed) {
-    if (mWriterSemaphore->Wait(Some(aTimeout))) {
-      MOZ_ASSERT(mOurCount - mRead->count <= requiredDifference);
-      return true;
-    }
-  }
-
-  // Either the reader has failed or we're stopping writing for some other
-  // reason (e.g. shutdown), so mark us as failed so the reader is aware.
-  mWrite->state = State::Failed;
-  mGood = false;
-  return false;
-}
-
-uint32_t CanvasEventRingBuffer::WaitForBytesToWrite() {
-  uint32_t streamFullReadCount = mOurCount - StreamSize();
-  if (!WaitForReadCount(streamFullReadCount + 1, kTimeout)) {
-    return 0;
-  }
-
-  return mRead->count - streamFullReadCount;
-}
-
-uint32_t CanvasEventRingBuffer::WaitForBytesToRead() {
-  if (!WaitForDataToRead(kTimeout, kTimeoutRetryCount)) {
-    return 0;
-  }
-
-  return mWrite->count - mOurCount;
-}
-
-void CanvasEventRingBuffer::ReturnWrite(const char* aData, size_t aSize) {
-  uint32_t writeCount = mRead->returnCount;
-  uint32_t bufPos = writeCount % StreamSize();
-  uint32_t bufRemaining = StreamSize() - bufPos;
-  uint32_t availableToWrite =
-      std::min(bufRemaining, (mWrite->returnCount + StreamSize() - writeCount));
-  while (availableToWrite < aSize) {
-    if (availableToWrite) {
-      memcpy(mBuf + bufPos, aData, availableToWrite);
-      writeCount += availableToWrite;
-      mRead->returnCount = writeCount;
-      bufPos = writeCount % StreamSize();
-      bufRemaining = StreamSize() - bufPos;
-      aData += availableToWrite;
-      aSize -= availableToWrite;
-    } else if (mReaderServices->WriterClosed()) {
-      return;
-    }
-
-    availableToWrite = std::min(
-        bufRemaining, (mWrite->returnCount + StreamSize() - writeCount));
-  }
-
-  memcpy(mBuf + bufPos, aData, aSize);
-  writeCount += aSize;
-  mRead->returnCount = writeCount;
-}
-
-void CanvasEventRingBuffer::ReturnRead(char* aOut, size_t aSize) {
-  // First wait for the event returning the data to be read.
-  WaitForCheckpoint(mOurCount);
-  uint32_t readCount = mWrite->returnCount;
-
-  // If the event sending back data fails to play then it will ReturnWrite
-  // nothing. So, wait until something has been written or the reader has
-  // stopped processing.
-  while (readCount == mRead->returnCount) {
-    // We recheck the count, because the other side can write all the data and
-    // started waiting in between these two lines.
-    if (mRead->state != State::Processing && readCount == mRead->returnCount) {
-      return;
-    }
-  }
-
-  uint32_t bufPos = readCount % StreamSize();
-  uint32_t bufRemaining = StreamSize() - bufPos;
-  uint32_t availableToRead =
-      std::min(bufRemaining, (mRead->returnCount - readCount));
-  while (availableToRead < aSize) {
-    if (availableToRead) {
-      memcpy(aOut, mBuf + bufPos, availableToRead);
-      readCount += availableToRead;
-      mWrite->returnCount = readCount;
-      bufPos = readCount % StreamSize();
-      bufRemaining = StreamSize() - bufPos;
-      aOut += availableToRead;
-      aSize -= availableToRead;
-    } else if (mWriterServices->ReaderClosed()) {
-      return;
-    }
-
-    availableToRead = std::min(bufRemaining, (mRead->returnCount - readCount));
-  }
-
-  memcpy(aOut, mBuf + bufPos, aSize);
-  readCount += aSize;
-  mWrite->returnCount = readCount;
-}
-
 void CanvasDrawEventRecorder::StoreSourceSurfaceRecording(
     gfx::SourceSurface* aSurface, const char* aReason) {
   wr::ExternalImageId extId{};