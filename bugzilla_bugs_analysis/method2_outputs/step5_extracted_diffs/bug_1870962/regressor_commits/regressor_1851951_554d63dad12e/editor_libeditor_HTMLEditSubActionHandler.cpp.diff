# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditSubActionHandler.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLEditSubActionHandler.cpp
--- a/editor/libeditor/HTMLEditSubActionHandler.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLEditSubActionHandler.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -686,7 +686,8 @@
         if (!ancestor->IsHTMLElement() ||
             !HTMLEditUtils::IsRemovableFromParentNode(*ancestor) ||
             !HTMLEditUtils::IsEmptyInlineContainer(
-                *ancestor, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+                *ancestor, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+                BlockInlineCheck::UseComputedDisplayStyle)) {
           break;
         }
         mostDistantEmptyInlineAncestor = ancestor;
@@ -862,8 +863,9 @@
     return NS_OK;
   }
 
-  nsIContent* previousBRElement =
-      HTMLEditUtils::GetPreviousContent(atSelectionStart, {}, editingHost);
+  nsIContent* previousBRElement = HTMLEditUtils::GetPreviousContent(
+      atSelectionStart, {}, BlockInlineCheck::UseComputedDisplayStyle,
+      editingHost);
   if (!previousBRElement || !previousBRElement->IsHTMLElement(nsGkAtoms::br) ||
       !previousBRElement->GetParent() ||
       !EditorUtils::IsEditableContent(*previousBRElement->GetParent(),
@@ -875,10 +877,12 @@
   const RefPtr<const Element> blockElementAtSelectionStart =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *atSelectionStart.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestBlockElement);
+          HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
   const RefPtr<const Element> parentBlockElementOfBRElement =
-      HTMLEditUtils::GetAncestorElement(*previousBRElement,
-                                        HTMLEditUtils::ClosestBlockElement);
+      HTMLEditUtils::GetAncestorElement(
+          *previousBRElement, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
 
   if (!blockElementAtSelectionStart ||
       blockElementAtSelectionStart != parentBlockElementOfBRElement) {
@@ -928,7 +932,8 @@
        child = child->GetNextSibling()) {
     if (EditorUtils::IsPaddingBRElementForEmptyEditor(*child) ||
         !isRootEditable || EditorUtils::IsEditableContent(*child, editorType) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayStyle)) {
       return NS_OK;
     }
   }
@@ -1578,7 +1583,8 @@
     WSScanResult backwardScanFromBeforeBRElementResult =
         WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
             editingHost,
-            EditorDOMPoint(unwrappedInsertBRElementResult.GetNewNode()));
+            EditorDOMPoint(unwrappedInsertBRElementResult.GetNewNode()),
+            BlockInlineCheck::UseComputedDisplayStyle);
     if (MOZ_UNLIKELY(backwardScanFromBeforeBRElementResult.Failed())) {
       NS_WARNING(
           "WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary() failed");
@@ -1586,8 +1592,9 @@
     }
 
     WSScanResult forwardScanFromAfterBRElementResult =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(editingHost,
-                                                         pointToPutCaret);
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            editingHost, pointToPutCaret,
+            BlockInlineCheck::UseComputedDisplayStyle);
     if (MOZ_UNLIKELY(forwardScanFromAfterBRElementResult.Failed())) {
       NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
       return Err(NS_ERROR_FAILURE);
@@ -1862,7 +1869,8 @@
         // element.
         if (!HTMLEditUtils::IsSplittableNode(*aEditableBlockElement)) {
           return aDefaultParagraphSeparator == ParagraphSeparator::br ||
-                 !HTMLEditUtils::CanElementContainParagraph(aEditingHost) ||
+                 !HTMLEditUtils::CanElementContainParagraph(
+                     *aEditableBlockElement) ||
                  HTMLEditUtils::ShouldInsertLinefeedCharacter(
                      aCandidatePointToSplit, aEditingHost);
         }
@@ -1880,7 +1888,8 @@
              editableBlockAncestor;
              editableBlockAncestor = HTMLEditUtils::GetAncestorElement(
                  *editableBlockAncestor,
-                 HTMLEditUtils::ClosestEditableBlockElementOrButtonElement)) {
+                 HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+                 BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
           if (HTMLEditUtils::CanElementContainParagraph(
                   *editableBlockAncestor)) {
             return false;
@@ -1895,7 +1904,8 @@
   RefPtr<Element> editableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *pointToInsert.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestEditableBlockElementOrButtonElement);
+          HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   // If we cannot insert a <p>/<div> element at the selection, we should insert
   // a <br> element or a linefeed instead.
@@ -2003,7 +2013,8 @@
 
     editableBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
         *pointToInsert.ContainerAs<nsIContent>(),
-        HTMLEditUtils::ClosestEditableBlockElementOrButtonElement);
+        HTMLEditUtils::ClosestEditableBlockElementOrButtonElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (NS_WARN_IF(!editableBlockElement)) {
       return Err(NS_ERROR_UNEXPECTED);
     }
@@ -2044,7 +2055,8 @@
   RefPtr<Element> insertedPaddingBRElement;
   if (HTMLEditUtils::IsEmptyBlockElement(
           *editableBlockElement,
-          {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+          {EmptyCheckOption::TreatSingleBRElementAsVisible},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     Result<CreateElementResult, nsresult> insertBRElementResult =
         InsertBRElement(WithTransaction::Yes,
                         EditorDOMPoint::AtEndOf(*editableBlockElement));
@@ -2207,7 +2219,8 @@
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   const bool editingHostIsEmpty = HTMLEditUtils::IsEmptyNode(aEditingHost);
-  WSRunScanner wsRunScanner(&aEditingHost, aPointToBreak);
+  WSRunScanner wsRunScanner(&aEditingHost, aPointToBreak,
+                            BlockInlineCheck::UseComputedDisplayStyle);
   WSScanResult backwardScanResult =
       wsRunScanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(aPointToBreak);
   if (MOZ_UNLIKELY(backwardScanResult.Failed())) {
@@ -2332,8 +2345,9 @@
   }
 
   WSScanResult forwardScanFromAfterBRElementResult =
-      WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                       afterBRElement);
+      WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+          &aEditingHost, afterBRElement,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(forwardScanFromAfterBRElementResult.Failed())) {
     NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
     return Err(NS_ERROR_FAILURE);
@@ -2386,8 +2400,9 @@
   // node.  Then we stick to the left to avoid an uber caret.
   nsIContent* nextSiblingOfBRElement = brElement->GetNextSibling();
   afterBRElement.SetInterlinePosition(
-      nextSiblingOfBRElement &&
-              HTMLEditUtils::IsBlockElement(*nextSiblingOfBRElement)
+      nextSiblingOfBRElement && HTMLEditUtils::IsBlockElement(
+                                    *nextSiblingOfBRElement,
+                                    BlockInlineCheck::UseComputedDisplayStyle)
           ? InterlinePosition::EndOfLine
           : InterlinePosition::StartOfNextLine);
   return CreateElementResult(std::move(brElement), afterBRElement);
@@ -2472,7 +2487,8 @@
   //     for doing it, we need more work, e.g., updating serializer, deleting
   //     unnecessary padding <br> element at modifying the last line.
   if (pointToPutCaret.IsInContentNode() && pointToPutCaret.IsEndOfContainer()) {
-    WSRunScanner wsScannerAtCaret(&aEditingHost, pointToPutCaret);
+    WSRunScanner wsScannerAtCaret(&aEditingHost, pointToPutCaret,
+                                  BlockInlineCheck::UseComputedDisplayStyle);
     if (wsScannerAtCaret.StartsFromPreformattedLineBreak() &&
         wsScannerAtCaret.EndsByBlockBoundary() &&
         HTMLEditUtils::CanNodeContain(*wsScannerAtCaret.GetEndReasonContent(),
@@ -2555,8 +2571,8 @@
     // user if they click there and start typing, because being in the
     // mailquote may affect wrapping behavior, or font color, etc.
     WSScanResult forwardScanFromPointToSplitResult =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                         pointToSplit);
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, pointToSplit, BlockInlineCheck::UseHTMLDefaultStyle);
     if (forwardScanFromPointToSplitResult.Failed()) {
       return Err(NS_ERROR_FAILURE);
     }
@@ -2659,7 +2675,8 @@
   // also just after it.  If we don't have another br or block boundary
   // adjacent, then we will need a 2nd br added to achieve blank line that user
   // expects.
-  if (HTMLEditUtils::IsInlineElement(aMailCiteElement)) {
+  if (HTMLEditUtils::IsInlineContent(
+          aMailCiteElement, BlockInlineCheck::UseComputedDisplayStyle)) {
     nsresult rvOfInsertingBRElement = [&]() MOZ_CAN_RUN_SCRIPT {
       EditorDOMPoint pointToCreateNewBRElement(
           unwrappedInsertBRElementResult.GetNewNode());
@@ -2669,7 +2686,8 @@
       //     resultOfInsertingBRElement.inspect()?
       WSScanResult backwardScanFromPointToCreateNewBRElementResult =
           WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
-              &aEditingHost, pointToCreateNewBRElement);
+              &aEditingHost, pointToCreateNewBRElement,
+              BlockInlineCheck::UseComputedDisplayStyle);
       if (MOZ_UNLIKELY(
               backwardScanFromPointToCreateNewBRElementResult.Failed())) {
         NS_WARNING(
@@ -2686,7 +2704,8 @@
       WSScanResult forwardScanFromPointAfterNewBRElementResult =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
               &aEditingHost,
-              EditorRawDOMPoint::After(pointToCreateNewBRElement));
+              EditorRawDOMPoint::After(pointToCreateNewBRElement),
+              BlockInlineCheck::UseComputedDisplayStyle);
       if (MOZ_UNLIKELY(forwardScanFromPointAfterNewBRElementResult.Failed())) {
         NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
         return NS_ERROR_FAILURE;
@@ -2757,7 +2776,8 @@
   }
   const auto previousCharPoint =
       WSRunScanner::GetPreviousEditableCharPoint<EditorRawDOMPointInText>(
-          ComputeEditingHost(), aPoint);
+          ComputeEditingHost(), aPoint,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (!previousCharPoint.IsSet()) {
     return CharPointData::InDifferentTextNode(CharPointType::TextEnd);
   }
@@ -2775,7 +2795,8 @@
   }
   const auto nextCharPoint =
       WSRunScanner::GetInclusiveNextEditableCharPoint<EditorRawDOMPointInText>(
-          ComputeEditingHost(), aPoint);
+          ComputeEditingHost(), aPoint,
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (!nextCharPoint.IsSet()) {
     return CharPointData::InDifferentTextNode(CharPointType::TextEnd);
   }
@@ -2874,10 +2895,12 @@
   // adjacent text node's first or last character information in some cases.
   Element* editingHost = ComputeEditingHost();
   const EditorDOMPointInText precedingCharPoint =
-      WSRunScanner::GetPreviousEditableCharPoint(editingHost, aStartToDelete);
+      WSRunScanner::GetPreviousEditableCharPoint(
+          editingHost, aStartToDelete,
+          BlockInlineCheck::UseComputedDisplayStyle);
   const EditorDOMPointInText followingCharPoint =
-      WSRunScanner::GetInclusiveNextEditableCharPoint(editingHost,
-                                                      aEndToDelete);
+      WSRunScanner::GetInclusiveNextEditableCharPoint(
+          editingHost, aEndToDelete, BlockInlineCheck::UseComputedDisplayStyle);
   // Blink-compat: Normalize white-spaces in first node only when not removing
   //               its last character or no text nodes follow the first node.
   //               If removing last character of first node and there are
@@ -3179,15 +3202,18 @@
     if (const Element* editableBlockElementOrInlineEditingHost =
             HTMLEditUtils::GetInclusiveAncestorElement(
                 *newCaretPosition.ContainerAs<nsIContent>(),
-                HTMLEditUtils::
-                    ClosestEditableBlockElementOrInlineEditingHost)) {
+                HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                BlockInlineCheck::UseComputedDisplayStyle)) {
       Element* editingHost = ComputeEditingHost();
       // Try to put caret next to immediately after previous editable leaf.
       nsIContent* previousContent =
           HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
               newCaretPosition, *editableBlockElementOrInlineEditingHost,
-              {LeafNodeType::LeafNodeOrNonEditableNode}, editingHost);
-      if (previousContent && !HTMLEditUtils::IsBlockElement(*previousContent)) {
+              {LeafNodeType::LeafNodeOrNonEditableNode},
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost);
+      if (previousContent &&
+          !HTMLEditUtils::IsBlockElement(
+              *previousContent, BlockInlineCheck::UseComputedDisplayStyle)) {
         newCaretPosition =
             previousContent->IsText() ||
                     HTMLEditUtils::IsContainerNode(*previousContent)
@@ -3201,6 +3227,7 @@
                        newCaretPosition,
                        *editableBlockElementOrInlineEditingHost,
                        {LeafNodeType::LeafNodeOrNonEditableNode},
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        editingHost)) {
         newCaretPosition = nextContent->IsText() ||
                                    HTMLEditUtils::IsContainerNode(*nextContent)
@@ -3254,7 +3281,8 @@
   // If container of the point is not in a block, we don't need to put a
   // `<br>` element here.
   if (!HTMLEditUtils::IsBlockElement(
-          *aPointToInsert.ContainerAs<nsIContent>())) {
+          *aPointToInsert.ContainerAs<nsIContent>(),
+          BlockInlineCheck::UseComputedDisplayStyle)) {
     return CaretPoint(EditorDOMPoint());
   }
 
@@ -3263,7 +3291,8 @@
     return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
-  WSRunScanner wsRunScanner(ComputeEditingHost(), aPointToInsert);
+  WSRunScanner wsRunScanner(ComputeEditingHost(), aPointToInsert,
+                            BlockInlineCheck::UseComputedDisplayStyle);
   // If the point is not start of a hard line, we don't need to put a `<br>`
   // element here.
   if (!wsRunScanner.StartsFromHardLineBreak()) {
@@ -3561,7 +3590,7 @@
       EditSubAction::eCreateOrChangeList, aEditingHost);
   Result<EditorDOMPoint, nsresult> splitResult =
       extendedRanges.SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-          aHTMLEditor, aEditingHost);
+          aHTMLEditor, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
@@ -3599,7 +3628,8 @@
     // XXX Should we handle line breaks in preformatted text node?
     if (!content->IsHTMLElement(nsGkAtoms::br) &&
         !HTMLEditUtils::IsEmptyInlineContainer(
-            content, {EmptyCheckOption::TreatSingleBRElementAsVisible})) {
+            content, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       return false;
     }
   }
@@ -3689,8 +3719,9 @@
     if (Element* deepestDivBlockquoteOrListElement =
             HTMLEditUtils::GetInclusiveDeepestFirstChildWhichHasOneChild(
                 aArrayOfContents[0], {WalkTreeOption::IgnoreNonEditableNode},
-                nsGkAtoms::div, nsGkAtoms::blockquote, nsGkAtoms::ul,
-                nsGkAtoms::ol, nsGkAtoms::dl)) {
+                BlockInlineCheck::UseHTMLDefaultStyle, nsGkAtoms::div,
+                nsGkAtoms::blockquote, nsGkAtoms::ul, nsGkAtoms::ol,
+                nsGkAtoms::dl)) {
       if (deepestDivBlockquoteOrListElement->IsAnyOfHTMLElements(
               nsGkAtoms::div, nsGkAtoms::blockquote)) {
         aArrayOfContents.Clear();
@@ -3738,8 +3769,8 @@
   if (EditorUtils::IsEditableContent(aHandlingContent, EditorType::HTML) &&
       (aHandlingContent.IsHTMLElement(nsGkAtoms::br) ||
        HTMLEditUtils::IsEmptyInlineContainer(
-           aHandlingContent,
-           {EmptyCheckOption::TreatSingleBRElementAsVisible}))) {
+           aHandlingContent, {EmptyCheckOption::TreatSingleBRElementAsVisible},
+           BlockInlineCheck::UseHTMLDefaultStyle))) {
     nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(aHandlingContent);
     if (NS_FAILED(rv)) {
       NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
@@ -3803,9 +3834,8 @@
 
   // If we meet an inline content, we want to move it to previously used list
   // item element or new list item element.
-  // XXX Despite the name, HTMLEditUtils::IsInlineElement() returns true for
-  // non-element content nodes too.
-  if (HTMLEditUtils::IsInlineElement(aHandlingContent)) {
+  if (HTMLEditUtils::IsInlineContent(aHandlingContent,
+                                     BlockInlineCheck::UseHTMLDefaultStyle)) {
     nsresult rv =
         HandleChildInlineContent(aHTMLEditor, aHandlingContent, aState);
     NS_WARNING_ASSERTION(
@@ -4284,7 +4314,8 @@
 nsresult HTMLEditor::AutoListElementCreator::HandleChildInlineContent(
     HTMLEditor& aHTMLEditor, nsIContent& aHandlingInlineContent,
     AutoHandlingState& aState) const {
-  MOZ_ASSERT(HTMLEditUtils::IsInlineElement(aHandlingInlineContent));
+  MOZ_ASSERT(HTMLEditUtils::IsInlineContent(
+      aHandlingInlineContent, BlockInlineCheck::UseHTMLDefaultStyle));
 
   // If we're currently handling contents of a list item and current node
   // is not a block element, move current node into the list item.
@@ -4355,7 +4386,8 @@
 
   // If current node is not a block element, new list item should have
   // following inline nodes too.
-  if (HTMLEditUtils::IsInlineElement(aHandlingContent)) {
+  if (HTMLEditUtils::IsInlineContent(aHandlingContent,
+                                     BlockInlineCheck::UseHTMLDefaultStyle)) {
     aState.mPreviousListItemElement =
         unwrappedWrapContentInListItemElementResult.UnwrapNewNode();
   } else {
@@ -4465,7 +4497,7 @@
       Result<EditorDOMPoint, nsresult> splitResult =
           extendedSelectionRanges
               .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                  *this, aEditingHost);
+                  *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
       if (MOZ_UNLIKELY(splitResult.isErr())) {
         NS_WARNING(
             "AutoRangeArray::"
@@ -4576,7 +4608,7 @@
   Result<EditorDOMPoint, nsresult> splitResult =
       aSelectionRanges
           .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-              *this, aEditingHost);
+              *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
@@ -4606,7 +4638,8 @@
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     if (NS_WARN_IF(aSelectionRanges.Ranges().IsEmpty())) {
       return Err(NS_ERROR_FAILURE);
     }
@@ -4624,7 +4657,8 @@
       const RefPtr<Element> editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *pointToInsertBlock.ContainerAs<nsIContent>(),
-              HTMLEditUtils::ClosestEditableBlockElement);
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseHTMLDefaultStyle);
       if (!editableBlockElement) {
         NS_WARNING(
             "HTMLEditor::FormatBlockContainerWithTransaction() couldn't find "
@@ -4640,7 +4674,7 @@
       // which is visually bad.
       if (nsCOMPtr<nsIContent> brContent = HTMLEditUtils::GetNextContent(
               pointToInsertBlock, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         if (brContent && brContent->IsHTMLElement(nsGkAtoms::br)) {
           AutoEditorDOMPointChildInvalidator lockOffset(pointToInsertBlock);
           nsresult rv = DeleteNodeWithTransaction(*brContent);
@@ -4686,7 +4720,7 @@
             pointToInsertBlock,
             {WalkTreeOption::IgnoreNonEditableNode,
              WalkTreeOption::StopAtBlockBoundary},
-            &aEditingHost)) {
+            BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
       if (maybeBRContent->IsHTMLElement(nsGkAtoms::br)) {
         AutoEditorDOMPointChildInvalidator lockOffset(pointToInsertBlock);
         nsresult rv = DeleteNodeWithTransaction(*maybeBRContent);
@@ -4759,7 +4793,8 @@
   }
   if (&blockType == nsGkAtoms::normal || &blockType == nsGkAtoms::_empty) {
     Result<EditorDOMPoint, nsresult> removeBlockContainerElementsResult =
-        RemoveBlockContainerElementsWithTransaction(arrayOfContents);
+        RemoveBlockContainerElementsWithTransaction(
+            arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle);
     if (MOZ_UNLIKELY(removeBlockContainerElementsResult.isErr())) {
       NS_WARNING(
           "HTMLEditor::RemoveBlockContainerElementsWithTransaction() failed");
@@ -5085,7 +5120,8 @@
     Element* const editableBlockElement =
         HTMLEditUtils::GetInclusiveAncestorElement(
             *atCaret.ContainerAs<nsIContent>(),
-            HTMLEditUtils::ClosestEditableBlockElement);
+            HTMLEditUtils::ClosestEditableBlockElement,
+            BlockInlineCheck::UseHTMLDefaultStyle);
     if (editableBlockElement &&
         HTMLEditUtils::IsListItem(editableBlockElement)) {
       arrayOfContents.AppendElement(*editableBlockElement);
@@ -5101,7 +5137,7 @@
       Result<EditorDOMPoint, nsresult> splitResult =
           extendedRanges
               .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                  *this, aEditingHost);
+                  *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
       if (MOZ_UNLIKELY(splitResult.isErr())) {
         NS_WARNING(
             "AutoRangeArray::"
@@ -5139,7 +5175,8 @@
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const EditorDOMPoint pointToInsertDivElement =
         pointToPutCaret.IsSet()
             ? std::move(pointToPutCaret)
@@ -5264,7 +5301,8 @@
 
     // Not a list item.
 
-    if (HTMLEditUtils::IsBlockElement(content)) {
+    if (HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle)) {
       Result<EditorDOMPoint, nsresult> pointToPutCaretOrError =
           ChangeMarginStart(MOZ_KnownLive(*content->AsElement()),
                             ChangeMargin::Increase, aEditingHost);
@@ -5405,7 +5443,7 @@
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
@@ -5444,7 +5482,8 @@
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const EditorDOMPoint pointToInsertBlockquoteElement =
         pointToPutCaret.IsSet()
             ? std::move(pointToPutCaret)
@@ -6002,7 +6041,8 @@
 
     // If we're using CSS and the node is a block element, check its start
     // margin whether it's indented with CSS.
-    if (useCSS && HTMLEditUtils::IsBlockElement(content)) {
+    if (useCSS && HTMLEditUtils::IsBlockElement(
+                      content, BlockInlineCheck::UseHTMLDefaultStyle)) {
       nsStaticAtom& marginProperty =
           MarginPropertyAtomForIndent(MOZ_KnownLive(content));
       if (NS_WARN_IF(Destroyed())) {
@@ -6342,20 +6382,20 @@
 Result<SplitRangeOffFromNodeResult, nsresult>
 HTMLEditor::RemoveBlockContainerElementWithTransactionBetween(
     Element& aBlockContainerElement, nsIContent& aStartOfRange,
-    nsIContent& aEndOfRange) {
+    nsIContent& aEndOfRange, BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   EditorDOMPoint pointToPutCaret;
   Result<SplitRangeOffFromNodeResult, nsresult> splitResult =
-      SplitRangeOffFromBlock(aBlockContainerElement, aStartOfRange,
-                             aEndOfRange);
+      SplitRangeOffFromElement(aBlockContainerElement, aStartOfRange,
+                               aEndOfRange);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     if (splitResult.inspectErr() == NS_ERROR_EDITOR_DESTROYED) {
-      NS_WARNING("HTMLEditor::SplitRangeOffFromBlock() failed");
+      NS_WARNING("HTMLEditor::SplitRangeOffFromElement() failed");
       return splitResult;
     }
     NS_WARNING(
-        "HTMLEditor::SplitRangeOffFromBlock() failed, but might be ignored");
+        "HTMLEditor::SplitRangeOffFromElement() failed, but might be ignored");
     return SplitRangeOffFromNodeResult(nullptr, nullptr, nullptr);
   }
   SplitRangeOffFromNodeResult unwrappedSplitResult = splitResult.unwrap();
@@ -6393,20 +6433,21 @@
 }
 
 Result<SplitRangeOffFromNodeResult, nsresult>
-HTMLEditor::SplitRangeOffFromBlock(Element& aBlockElement,
-                                   nsIContent& aStartOfMiddleElement,
-                                   nsIContent& aEndOfMiddleElement) {
+HTMLEditor::SplitRangeOffFromElement(Element& aElementToSplit,
+                                     nsIContent& aStartOfMiddleElement,
+                                     nsIContent& aEndOfMiddleElement) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   // aStartOfMiddleElement and aEndOfMiddleElement must be exclusive
-  // descendants of aBlockElement.
-  MOZ_ASSERT(EditorUtils::IsDescendantOf(aStartOfMiddleElement, aBlockElement));
-  MOZ_ASSERT(EditorUtils::IsDescendantOf(aEndOfMiddleElement, aBlockElement));
+  // descendants of aElementToSplit.
+  MOZ_ASSERT(
+      EditorUtils::IsDescendantOf(aStartOfMiddleElement, aElementToSplit));
+  MOZ_ASSERT(EditorUtils::IsDescendantOf(aEndOfMiddleElement, aElementToSplit));
 
   EditorDOMPoint pointToPutCaret;
   // Split at the start.
   Result<SplitNodeResult, nsresult> splitAtStartResult =
-      SplitNodeDeepWithTransaction(aBlockElement,
+      SplitNodeDeepWithTransaction(aElementToSplit,
                                    EditorDOMPoint(&aStartOfMiddleElement),
                                    SplitAtEdges::eDoNotCreateEmptyContainer);
   if (MOZ_UNLIKELY(splitAtStartResult.isErr())) {
@@ -6427,9 +6468,9 @@
   Element* rightElement =
       splitAtStartResult.isOk() && splitAtStartResult.inspect().DidSplit()
           ? splitAtStartResult.inspect().GetNextContentAs<Element>()
-          : &aBlockElement;
+          : &aElementToSplit;
   // MOZ_KnownLive(rightElement) because it's grabbed by splitAtStartResult or
-  // aBlockElement whose lifetime is guaranteed by the caller.
+  // aElementToSplit whose lifetime is guaranteed by the caller.
   Result<SplitNodeResult, nsresult> splitAtEndResult =
       SplitNodeDeepWithTransaction(MOZ_KnownLive(*rightElement), atAfterEnd,
                                    SplitAtEdges::eDoNotCreateEmptyContainer);
@@ -6469,7 +6510,7 @@
         splitAtEndResult.inspect().GetNextContent(),
         std::move(pointToPutCaret));
   }
-  return SplitRangeOffFromNodeResult(nullptr, &aBlockElement, nullptr,
+  return SplitRangeOffFromNodeResult(nullptr, &aElementToSplit, nullptr,
                                      std::move(pointToPutCaret));
 }
 
@@ -6480,9 +6521,9 @@
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   Result<SplitRangeOffFromNodeResult, nsresult> splitResult =
-      SplitRangeOffFromBlock(aBlockElement, aStartOfOutdent, aEndOfOutdent);
+      SplitRangeOffFromElement(aBlockElement, aStartOfOutdent, aEndOfOutdent);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
-    NS_WARNING("HTMLEditor::SplitRangeOffFromBlock() failed");
+    NS_WARNING("HTMLEditor::SplitRangeOffFromElement() failed");
     return splitResult;
   }
 
@@ -6490,7 +6531,7 @@
   Element* middleElement = unwrappedSplitResult.GetMiddleContentAs<Element>();
   if (MOZ_UNLIKELY(!middleElement)) {
     NS_WARNING(
-        "HTMLEditor::SplitRangeOffFromBlock() didn't return middle content");
+        "HTMLEditor::SplitRangeOffFromElement() didn't return middle content");
     unwrappedSplitResult.IgnoreCaretPointSuggestion();
     return Err(NS_ERROR_FAILURE);
   }
@@ -6942,7 +6983,7 @@
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
@@ -6984,7 +7025,9 @@
   if (arrayOfContents.Length() == 1) {
     OwningNonNull<nsIContent>& content = arrayOfContents[0];
 
-    if (HTMLEditUtils::SupportsAlignAttr(content)) {
+    if (HTMLEditUtils::SupportsAlignAttr(content) &&
+        HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle)) {
       // The node is a table element, an hr, a paragraph, a div or a section
       // header; in HTML 4, it can directly carry the ALIGN attribute and we
       // don't need to make a div! If we are in CSS mode, all the work is done
@@ -7526,7 +7569,14 @@
 
   // Is there any intervening visible white-space?  If so we can't push
   // selection past that, it would visibly change meaning of users selection.
-  WSRunScanner wsScannerAtEnd(&aEditingHost, endPoint);
+  WSRunScanner wsScannerAtEnd(
+      &aEditingHost, endPoint,
+      // We should refer only the default style of HTML because we need to wrap
+      // any elements with a specific HTML element.  So we should not refer
+      // actual style.  For example, we want to reformat parent HTML block
+      // element even if selected in a blocked phrase element or
+      // non-HTMLelement.
+      BlockInlineCheck::UseHTMLDefaultStyle);
   WSScanResult scanResultAtEnd =
       wsScannerAtEnd.ScanPreviousVisibleNodeOrBlockBoundaryFrom(endPoint);
   if (scanResultAtEnd.Failed()) {
@@ -7541,7 +7591,8 @@
       // endpoint is just after the close of a block.
       if (nsIContent* child = HTMLEditUtils::GetLastLeafContent(
               *wsScannerAtEnd.StartReasonOtherBlockElementPtr(),
-              {LeafNodeType::LeafNodeOrChildBlock})) {
+              {LeafNodeType::LeafNodeOrChildBlock},
+              BlockInlineCheck::UseHTMLDefaultStyle)) {
         newRange.SetEnd(EditorRawDOMPoint::After(*child));
       }
       // else block is empty - we can leave selection alone here, i think.
@@ -7549,7 +7600,7 @@
       // endpoint is just after start of this block
       if (nsIContent* child = HTMLEditUtils::GetPreviousContent(
               endPoint, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         newRange.SetEnd(EditorRawDOMPoint::After(*child));
       }
       // else block is empty - we can leave selection alone here, i think.
@@ -7562,7 +7613,8 @@
 
   // Is there any intervening visible white-space?  If so we can't push
   // selection past that, it would visibly change meaning of users selection.
-  WSRunScanner wsScannerAtStart(&aEditingHost, startPoint);
+  WSRunScanner wsScannerAtStart(&aEditingHost, startPoint,
+                                BlockInlineCheck::UseHTMLDefaultStyle);
   WSScanResult scanResultAtStart =
       wsScannerAtStart.ScanNextVisibleNodeOrBlockBoundaryFrom(startPoint);
   if (scanResultAtStart.Failed()) {
@@ -7576,7 +7628,8 @@
       // startpoint is just before the start of a block.
       if (nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
               *wsScannerAtStart.EndReasonOtherBlockElementPtr(),
-              {LeafNodeType::LeafNodeOrChildBlock})) {
+              {LeafNodeType::LeafNodeOrChildBlock},
+              BlockInlineCheck::UseHTMLDefaultStyle)) {
         newRange.SetStart(EditorRawDOMPoint(child));
       }
       // else block is empty - we can leave selection alone here, i think.
@@ -7584,7 +7637,7 @@
       // startpoint is just before end of this block
       if (nsIContent* child = HTMLEditUtils::GetNextContent(
               startPoint, {WalkTreeOption::IgnoreNonEditableNode},
-              &aEditingHost)) {
+              BlockInlineCheck::UseHTMLDefaultStyle, &aEditingHost)) {
         newRange.SetStart(EditorRawDOMPoint(child));
       }
       // else block is empty - we can leave selection alone here, i think.
@@ -7728,9 +7781,10 @@
     case EditSubAction::eIndent:
     case EditSubAction::eOutdent: {
       EditorDOMPoint pointToPutCaret;
-      for (int32_t i = aArrayOfContents.Length() - 1; i >= 0; i--) {
-        OwningNonNull<nsIContent>& content = aArrayOfContents[i];
-        if (HTMLEditUtils::IsInlineElement(content) &&
+      for (size_t index : Reversed(IntegerRange(aArrayOfContents.Length()))) {
+        OwningNonNull<nsIContent>& content = aArrayOfContents[index];
+        if (HTMLEditUtils::IsInlineContent(
+                content, BlockInlineCheck::UseHTMLDefaultStyle) &&
             HTMLEditUtils::IsContainerNode(content) && !content->IsText()) {
           AutoTArray<OwningNonNull<nsIContent>, 24> arrayOfInlineContents;
           // MOZ_KnownLive because 'aArrayOfContents' is guaranteed to keep it
@@ -7746,8 +7800,8 @@
             pointToPutCaret = splitResult.unwrap();
           }
           // Put these nodes in aArrayOfContents, replacing the current node
-          aArrayOfContents.RemoveElementAt(i);
-          aArrayOfContents.InsertElementsAt(i, arrayOfInlineContents);
+          aArrayOfContents.RemoveElementAt(index);
+          aArrayOfContents.InsertElementsAt(index, arrayOfInlineContents);
         }
       }
       return pointToPutCaret;
@@ -7758,8 +7812,9 @@
 }
 
 Result<EditorDOMPoint, nsresult>
-HTMLEditor::SplitParentInlineElementsAtRangeBoundaries(
-    RangeItem& aRangeItem, const Element& aEditingHost,
+HTMLEditor::SplitInlineAncestorsAtRangeBoundaries(
+    RangeItem& aRangeItem, BlockInlineCheck aBlockInlineCheck,
+    const Element& aEditingHost,
     const nsIContent* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
@@ -7768,8 +7823,8 @@
       aRangeItem.mEndContainer->IsContent()) {
     nsCOMPtr<nsIContent> mostAncestorInlineContentAtEnd =
         HTMLEditUtils::GetMostDistantAncestorInlineElement(
-            *aRangeItem.mEndContainer->AsContent(), &aEditingHost,
-            aAncestorLimiter);
+            *aRangeItem.mEndContainer->AsContent(), aBlockInlineCheck,
+            &aEditingHost, aAncestorLimiter);
 
     if (mostAncestorInlineContentAtEnd) {
       Result<SplitNodeResult, nsresult> splitEndInlineResult =
@@ -7814,8 +7869,8 @@
 
   nsCOMPtr<nsIContent> mostAncestorInlineContentAtStart =
       HTMLEditUtils::GetMostDistantAncestorInlineElement(
-          *aRangeItem.mStartContainer->AsContent(), &aEditingHost,
-          aAncestorLimiter);
+          *aRangeItem.mStartContainer->AsContent(), aBlockInlineCheck,
+          &aEditingHost, aAncestorLimiter);
 
   if (mostAncestorInlineContentAtStart) {
     Result<SplitNodeResult, nsresult> splitStartInlineResult =
@@ -8009,7 +8064,9 @@
   MOZ_ASSERT(rightHeadingElement,
              "SplitNodeResult::GetNextContent() should return something if "
              "DidSplit() returns true");
-  if (!HTMLEditUtils::IsEmptyBlockElement(*rightHeadingElement, {})) {
+  if (!HTMLEditUtils::IsEmptyBlockElement(
+          *rightHeadingElement, {},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     return InsertParagraphResult(rightHeadingElement,
                                  EditorDOMPoint(rightHeadingElement, 0u));
   }
@@ -8339,13 +8396,14 @@
     //     moving to the caret, but I think that this could be handled in fewer
     //     cases than this.
     brElement = HTMLBRElement::FromNodeOrNull(HTMLEditUtils::GetPreviousContent(
-        pointToSplit, {WalkTreeOption::IgnoreNonEditableNode}, &aEditingHost));
+        pointToSplit, {WalkTreeOption::IgnoreNonEditableNode},
+        BlockInlineCheck::Unused, &aEditingHost));
     if (!brElement || HTMLEditUtils::IsInvisibleBRElement(*brElement) ||
         EditorUtils::IsPaddingBRElementForEmptyLastLine(*brElement)) {
       // is there a BR after it?
       brElement = HTMLBRElement::FromNodeOrNull(HTMLEditUtils::GetNextContent(
           pointToSplit, {WalkTreeOption::IgnoreNonEditableNode},
-          &aEditingHost));
+          BlockInlineCheck::Unused, &aEditingHost));
       if (!brElement || HTMLEditUtils::IsInvisibleBRElement(*brElement) ||
           EditorUtils::IsPaddingBRElementForEmptyLastLine(*brElement)) {
         // If insertParagraph does not create a new paragraph, default to
@@ -8467,7 +8525,8 @@
   // also behaves so.
   auto InsertBRElementIfEmptyBlockElement =
       [&](Element& aElement) MOZ_CAN_RUN_SCRIPT {
-        if (!HTMLEditUtils::IsBlockElement(aElement)) {
+        if (!HTMLEditUtils::IsBlockElement(
+                aElement, BlockInlineCheck::UseComputedDisplayStyle)) {
           return NS_OK;
         }
 
@@ -8514,7 +8573,9 @@
           for (Element* maybeDeepestInlineContainer =
                    Element::FromNodeOrNull(aBlockElement.GetFirstChild());
                maybeDeepestInlineContainer &&
-               HTMLEditUtils::IsInlineElement(*maybeDeepestInlineContainer) &&
+               HTMLEditUtils::IsInlineContent(
+                   *maybeDeepestInlineContainer,
+                   BlockInlineCheck::UseComputedDisplayStyle) &&
                HTMLEditUtils::IsContainerNode(*maybeDeepestInlineContainer);
                maybeDeepestInlineContainer =
                    maybeDeepestInlineContainer->GetFirstElementChild()) {
@@ -8573,7 +8634,8 @@
 
   // Let's put caret at start of the first leaf container.
   nsIContent* child = HTMLEditUtils::GetFirstLeafContent(
-      *rightDivOrParagraphElement, {LeafNodeType::LeafNodeOrChildBlock});
+      *rightDivOrParagraphElement, {LeafNodeType::LeafNodeOrChildBlock},
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(!child)) {
     return SplitNodeResult(std::move(unwrappedSplitDivOrPResult),
                            EditorDOMPoint(rightDivOrParagraphElement, 0u));
@@ -8594,7 +8656,9 @@
 
   // If aListItemElement is empty, then we want to outdent its content.
   if (&aEditingHost != aListItemElement.GetParentElement() &&
-      HTMLEditUtils::IsEmptyBlockElement(aListItemElement, {})) {
+      HTMLEditUtils::IsEmptyBlockElement(
+          aListItemElement, {},
+          BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
     RefPtr<Element> leftListElement = aListItemElement.GetParentElement();
     // If the given list item element is not the last list item element of
     // its parent nor not followed by sub list elements, split the parent
@@ -8802,7 +8866,8 @@
   // the element is proper position.
   WSScanResult forwardScanFromStartOfListItemResult =
       WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-          &aEditingHost, EditorRawDOMPoint(&rightListItemElement, 0u));
+          &aEditingHost, EditorRawDOMPoint(&rightListItemElement, 0u),
+          BlockInlineCheck::UseComputedDisplayStyle);
   if (MOZ_UNLIKELY(forwardScanFromStartOfListItemResult.Failed())) {
     NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
     return Err(NS_ERROR_FAILURE);
@@ -8934,7 +8999,8 @@
 
 Result<EditorDOMPoint, nsresult>
 HTMLEditor::RemoveBlockContainerElementsWithTransaction(
-    const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents) {
+    const nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
+    BlockInlineCheck aBlockInlineCheck) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   // Intent of this routine is to be used for converting to/from headers,
@@ -8943,14 +9009,14 @@
   RefPtr<Element> blockElement;
   nsCOMPtr<nsIContent> firstContent, lastContent;
   EditorDOMPoint pointToPutCaret;
-  for (auto& content : aArrayOfContents) {
+  for (const auto& content : aArrayOfContents) {
     // If curNode is an <address>, <p>, <hn>, or <pre>, remove it.
     if (HTMLEditUtils::IsFormatNode(content)) {
       // Process any partial progress saved
       if (blockElement) {
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
@@ -8987,7 +9053,7 @@
       if (blockElement) {
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
@@ -9005,7 +9071,8 @@
       AutoTArray<OwningNonNull<nsIContent>, 24> childContents;
       HTMLEditUtils::CollectAllChildren(*content, childContents);
       Result<EditorDOMPoint, nsresult> removeBlockContainerElementsResult =
-          RemoveBlockContainerElementsWithTransaction(childContents);
+          RemoveBlockContainerElementsWithTransaction(childContents,
+                                                      aBlockInlineCheck);
       if (MOZ_UNLIKELY(removeBlockContainerElementsResult.isErr())) {
         NS_WARNING(
             "HTMLEditor::RemoveBlockContainerElementsWithTransaction() failed");
@@ -9017,7 +9084,7 @@
       continue;
     }
 
-    if (HTMLEditUtils::IsInlineElement(content)) {
+    if (HTMLEditUtils::IsInlineContent(content, aBlockInlineCheck)) {
       if (blockElement) {
         // If so, is this node a descendant?
         if (EditorUtils::IsDescendantOf(*content, *blockElement)) {
@@ -9030,7 +9097,7 @@
         // contains [firstContent - lastContent].
         Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
             RemoveBlockContainerElementWithTransactionBetween(
-                *blockElement, *firstContent, *lastContent);
+                *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
         if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
           NS_WARNING(
               "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
@@ -9043,7 +9110,8 @@
         // Fall out and handle content
       }
       blockElement = HTMLEditUtils::GetAncestorElement(
-          content, HTMLEditUtils::ClosestEditableBlockElement);
+          content, HTMLEditUtils::ClosestEditableBlockElement,
+          aBlockInlineCheck);
       if (!blockElement || !HTMLEditUtils::IsFormatNode(blockElement) ||
           !HTMLEditUtils::IsRemovableNode(*blockElement)) {
         // Not a block kind that we care about.
@@ -9059,7 +9127,7 @@
       // any partial progress saved.
       Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
           RemoveBlockContainerElementWithTransactionBetween(
-              *blockElement, *firstContent, *lastContent);
+              *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
       if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
         NS_WARNING(
             "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
@@ -9076,7 +9144,7 @@
   if (blockElement) {
     Result<SplitRangeOffFromNodeResult, nsresult> unwrapBlockElementResult =
         RemoveBlockContainerElementWithTransactionBetween(
-            *blockElement, *firstContent, *lastContent);
+            *blockElement, *firstContent, *lastContent, aBlockInlineCheck);
     if (MOZ_UNLIKELY(unwrapBlockElementResult.isErr())) {
       NS_WARNING(
           "HTMLEditor::RemoveBlockContainerElementWithTransactionBetween() "
@@ -9115,7 +9183,8 @@
     // Is it already the right kind of block, or an uneditable block?
     if (content->IsHTMLElement(&aBlockTag) ||
         (!EditorUtils::IsEditableContent(content, EditorType::HTML) &&
-         HTMLEditUtils::IsBlockElement(content))) {
+         HTMLEditUtils::IsBlockElement(
+             content, BlockInlineCheck::UseHTMLDefaultStyle))) {
       // Forget any previous block used for previous inline nodes
       curBlock = nullptr;
       // Do nothing to this block
@@ -9262,11 +9331,12 @@
       continue;
     }
 
-    if (HTMLEditUtils::IsInlineElement(content)) {
+    if (HTMLEditUtils::IsInlineContent(content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle)) {
       // If content is inline, pull it into curBlock.  Note: it's assumed that
       // consecutive inline nodes in aNodeArray are actually members of the
       // same block parent.  This happens to be true now as a side effect of
-      // how aNodeArray is contructed, but some additional logic should be
+      // how aNodeArray is constructed, but some additional logic should be
       // added here if that should change
       //
       // If content is a non editable, drop it if we are going to <pre>.
@@ -9429,7 +9499,7 @@
             splitPoint,
             {WalkTreeOption::IgnoreNonEditableNode,
              WalkTreeOption::StopAtBlockBoundary},
-            &aEditingHost)) {
+            BlockInlineCheck::UseComputedDisplayOutsideStyle, &aEditingHost)) {
       if (maybeBRContent->IsHTMLElement(nsGkAtoms::br) &&
           splitPoint.GetChild()) {
         // Making use of html structure... if next node after where we are
@@ -9438,7 +9508,9 @@
         if (nsIContent* nextEditableSibling = HTMLEditUtils::GetNextSibling(
                 *splitPoint.GetChild(),
                 {WalkTreeOption::IgnoreNonEditableNode})) {
-          if (!HTMLEditUtils::IsBlockElement(*nextEditableSibling)) {
+          if (!HTMLEditUtils::IsBlockElement(
+                  *nextEditableSibling,
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
             AutoEditorDOMPointChildInvalidator lockOffset(splitPoint);
             nsresult rv = DeleteNodeWithTransaction(*maybeBRContent);
             if (NS_FAILED(rv)) {
@@ -9624,7 +9696,9 @@
     };
     for (Element* const inclusiveAncestor :
          aElement.InclusiveAncestorsOfType<Element>()) {
-      if (HTMLEditUtils::IsBlockElement(*inclusiveAncestor) ||
+      if (HTMLEditUtils::IsBlockElement(
+              *inclusiveAncestor,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
           (givenElementIsEditable &&
            !HTMLEditUtils::IsSimplyEditableNode(*inclusiveAncestor))) {
         break;
@@ -9907,7 +9981,7 @@
                 atCaret,
                 {WalkTreeOption::IgnoreNonEditableNode,
                  WalkTreeOption::StopAtBlockBoundary},
-                editingHost)) {
+                BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
       if (previousEditableContentInBlock->IsHTMLElement(nsGkAtoms::br)) {
         DebugOnly<nsresult> rvIgnored = SelectionRef().SetInterlinePosition(
             InterlinePosition::StartOfNextLine);
@@ -9931,7 +10005,9 @@
   if (nsIContent* previousEditableContentInBlockAtCaret =
           HTMLEditUtils::GetPreviousSibling(
               *atCaret.GetChild(), {WalkTreeOption::IgnoreNonEditableNode})) {
-    if (HTMLEditUtils::IsBlockElement(*previousEditableContentInBlockAtCaret)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *previousEditableContentInBlockAtCaret,
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       DebugOnly<nsresult> rvIgnored = SelectionRef().SetInterlinePosition(
           InterlinePosition::StartOfNextLine);
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
@@ -9948,7 +10024,9 @@
   if (nsIContent* nextEditableContentInBlockAtCaret =
           HTMLEditUtils::GetNextSibling(
               *atCaret.GetChild(), {WalkTreeOption::IgnoreNonEditableNode})) {
-    if (HTMLEditUtils::IsBlockElement(*nextEditableContentInBlockAtCaret)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *nextEditableContentInBlockAtCaret,
+            BlockInlineCheck::UseComputedDisplayStyle)) {
       DebugOnly<nsresult> rvIgnored =
           SelectionRef().SetInterlinePosition(InterlinePosition::EndOfLine);
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
@@ -9984,7 +10062,8 @@
   if (Element* const editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *point.ContainerAs<nsIContent>(),
-              HTMLEditUtils::ClosestEditableBlockElement)) {
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayStyle)) {
     if (editableBlockElement &&
         HTMLEditUtils::IsEmptyNode(
             *editableBlockElement,
@@ -10045,17 +10124,20 @@
 
   if (nsCOMPtr<nsIContent> previousEditableContent =
           HTMLEditUtils::GetPreviousContent(
-              point, {WalkTreeOption::IgnoreNonEditableNode}, editingHost)) {
+              point, {WalkTreeOption::IgnoreNonEditableNode},
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     // If caret and previous editable content are in same block element
     // (even if it's a non-editable element), we should put a padding <br>
     // element at end of the block.
     const Element* const blockElementContainingCaret =
         HTMLEditUtils::GetInclusiveAncestorElement(
             *point.ContainerAs<nsIContent>(),
-            HTMLEditUtils::ClosestBlockElement);
+            HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayStyle);
     const Element* const blockElementContainingPreviousEditableContent =
-        HTMLEditUtils::GetAncestorElement(*previousEditableContent,
-                                          HTMLEditUtils::ClosestBlockElement);
+        HTMLEditUtils::GetAncestorElement(
+            *previousEditableContent, HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayStyle);
     // If previous editable content of caret is in same block and a `<br>`
     // element, we need to adjust interline position.
     if (blockElementContainingCaret &&
@@ -10095,6 +10177,7 @@
                        *previousEditableContent,
                        {WalkTreeOption::IgnoreNonEditableNode,
                         WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        editingHost)) {
         if (EditorUtils::IsPaddingBRElementForEmptyLastLine(
                 *nextEditableContentInBlock)) {
@@ -10118,7 +10201,7 @@
               point,
               {WalkTreeOption::IgnoreNonEditableNode,
                WalkTreeOption::StopAtBlockBoundary},
-              editingHost)) {
+              BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     if (previousEditableContentInBlock->IsHTMLElement(nsGkAtoms::br) ||
         previousEditableContentInBlock->IsText() ||
         HTMLEditUtils::IsImage(previousEditableContentInBlock) ||
@@ -10129,11 +10212,11 @@
 
   // If next editable content in same block is `<br>`, text node, `<img>` or
   // `<hr>`, current caret position is fine.
-  if (nsIContent* nextEditableContentInBlock =
-          HTMLEditUtils::GetNextContent(point,
-                                        {WalkTreeOption::IgnoreNonEditableNode,
-                                         WalkTreeOption::StopAtBlockBoundary},
-                                        editingHost)) {
+  if (nsIContent* nextEditableContentInBlock = HTMLEditUtils::GetNextContent(
+          point,
+          {WalkTreeOption::IgnoreNonEditableNode,
+           WalkTreeOption::StopAtBlockBoundary},
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost)) {
     if (nextEditableContentInBlock->IsText() ||
         nextEditableContentInBlock->IsAnyOfHTMLElements(
             nsGkAtoms::br, nsGkAtoms::img, nsGkAtoms::hr)) {
@@ -10226,7 +10309,8 @@
       }
       EmptyCheckOptions options = {EmptyCheckOption::TreatListItemAsVisible,
                                    EmptyCheckOption::TreatTableCellAsVisible};
-      if (!HTMLEditUtils::IsBlockElement(*content)) {
+      if (!HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseComputedDisplayStyle)) {
         options += EmptyCheckOption::TreatSingleBRElementAsVisible;
       }
       if (!HTMLEditUtils::IsEmptyNode(*content, options)) {
@@ -10417,9 +10501,9 @@
 
   // if it's first or last list item, don't need to split the list
   // otherwise we do.
-  bool isFirstListItem = HTMLEditUtils::IsFirstChild(
+  const bool isFirstListItem = HTMLEditUtils::IsFirstChild(
       aListItemElement, {WalkTreeOption::IgnoreNonEditableNode});
-  bool isLastListItem = HTMLEditUtils::IsLastChild(
+  const bool isLastListItem = HTMLEditUtils::IsLastChild(
       aListItemElement, {WalkTreeOption::IgnoreNonEditableNode});
 
   Element* leftListElement = aListItemElement.GetParentElement();
@@ -10685,7 +10769,8 @@
     Element& aElement) {
   MOZ_ASSERT(IsEditActionDataAvailable());
 
-  if (!HTMLEditUtils::IsBlockElement(aElement)) {
+  if (!HTMLEditUtils::IsBlockElement(
+          aElement, BlockInlineCheck::UseComputedDisplayStyle)) {
     return NS_OK;
   }
 
@@ -10813,7 +10898,8 @@
       continue;
     }
 
-    if (!HTMLEditUtils::IsBlockElement(*content) &&
+    if (!HTMLEditUtils::IsBlockElement(*content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle) &&
         !content->IsHTMLElement(nsGkAtoms::hr)) {
       continue;
     }
@@ -10896,7 +10982,8 @@
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*firstEditableChild) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *firstEditableChild, BlockInlineCheck::UseComputedDisplayStyle) ||
       firstEditableChild->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
@@ -10907,7 +10994,9 @@
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*previousEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *previousEditableContent,
+          BlockInlineCheck::UseComputedDisplayStyle) ||
       previousEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
@@ -10931,7 +11020,8 @@
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*firstEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *firstEditableContent, BlockInlineCheck::UseComputedDisplayStyle) ||
       firstEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
@@ -10942,7 +11032,8 @@
     return CreateElementResult::NotHandled();
   }
 
-  if (HTMLEditUtils::IsBlockElement(*nextEditableContent) ||
+  if (HTMLEditUtils::IsBlockElement(
+          *nextEditableContent, BlockInlineCheck::UseComputedDisplayStyle) ||
       nextEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     return CreateElementResult::NotHandled();
   }
@@ -10959,7 +11050,8 @@
     Element& aBlockOrHRElement, const nsAString& aAlignType,
     EditTarget aEditTarget) {
   MOZ_ASSERT(IsEditActionDataAvailable());
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aBlockOrHRElement) ||
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+                 aBlockOrHRElement, BlockInlineCheck::UseHTMLDefaultStyle) ||
              aBlockOrHRElement.IsHTMLElement(nsGkAtoms::hr));
   MOZ_ASSERT(IsCSSEnabled() ||
              HTMLEditUtils::SupportsAlignAttr(aBlockOrHRElement));
@@ -11283,7 +11375,7 @@
     Result<EditorDOMPoint, nsresult> splitResult =
         extendedSelectionRanges
             .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-                *this, aEditingHost);
+                *this, BlockInlineCheck::UseHTMLDefaultStyle, aEditingHost);
     if (MOZ_UNLIKELY(splitResult.isErr())) {
       NS_WARNING(
           "AutoRangeArray::"
@@ -11330,7 +11422,8 @@
   // If there is no visible and editable nodes in the edit targets, make an
   // empty block.
   // XXX Isn't this odd if there are only non-editable visible nodes?
-  if (HTMLEditUtils::IsEmptyOneHardLine(arrayOfContents)) {
+  if (HTMLEditUtils::IsEmptyOneHardLine(
+          arrayOfContents, BlockInlineCheck::UseHTMLDefaultStyle)) {
     const auto atCaret =
         EditorBase::GetFirstSelectionStartPoint<EditorDOMPoint>();
     if (NS_WARN_IF(!atCaret.IsSet())) {