# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditUtils.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLEditUtils.cpp
--- a/editor/libeditor/HTMLEditUtils.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLEditUtils.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -15,11 +15,14 @@
 #include "HTMLEditHelpers.h"  // for EditorInlineStyle
 #include "WSRunObject.h"      // for WSRunScanner
 
-#include "mozilla/ArrayUtils.h"   // for ArrayLength
-#include "mozilla/Assertions.h"   // for MOZ_ASSERT, etc.
-#include "mozilla/RangeUtils.h"   // for RangeUtils
-#include "mozilla/dom/Element.h"  // for Element, nsINode
+#include "mozilla/ArrayUtils.h"           // for ArrayLength
+#include "mozilla/Assertions.h"           // for MOZ_ASSERT, etc.
+#include "mozilla/StaticPrefs_editor.h"   // for StaticPrefs::editor_
+#include "mozilla/RangeUtils.h"           // for RangeUtils
+#include "mozilla/dom/DocumentInlines.h"  // for GetBodyElement()
+#include "mozilla/dom/Element.h"          // for Element, nsINode
 #include "mozilla/dom/HTMLAnchorElement.h"
+#include "mozilla/dom/HTMLBodyElement.h"
 #include "mozilla/dom/HTMLInputElement.h"
 #include "mozilla/ServoCSSParser.h"  // for ServoCSSParser
 #include "mozilla/dom/StaticRange.h"
@@ -52,28 +55,28 @@
 
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorRawDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorRawDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorRawDOMPoint& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 template nsIContent* HTMLEditUtils::GetNextContent(
     const EditorRawDOMPointInText& aPoint, const WalkTreeOptions& aOptions,
-    const Element* aAncestorLimiter);
+    BlockInlineCheck aBlockInlineCheck, const Element* aAncestorLimiter);
 
 template EditorDOMPoint HTMLEditUtils::GetPreviousEditablePoint(
     nsIContent& aContent, const Element* aAncestorLimiter,
@@ -189,12 +192,13 @@
                                                      *rightStyledElement);
 }
 
-bool HTMLEditUtils::IsBlockElement(const nsIContent& aContent) {
-  if (!aContent.IsElement()) {
+static bool IsHTMLBlockElementByDefault(const nsIContent& aContent) {
+  if (!aContent.IsHTMLElement()) {
     return false;
   }
   if (aContent.IsHTMLElement(nsGkAtoms::br)) {  // shortcut for TextEditor
-    MOZ_ASSERT(!nsHTMLElement::IsBlock(nsHTMLTags::AtomTagToId(nsGkAtoms::br)));
+    MOZ_ASSERT(!nsHTMLElement::IsBlock(
+        nsHTMLTags::CaseSensitiveAtomTagToId(nsGkAtoms::br)));
     return false;
   }
   // We want to treat these as block nodes even though nsHTMLElement says
@@ -207,7 +211,90 @@
   }
 
   return nsHTMLElement::IsBlock(
-      nsHTMLTags::AtomTagToId(aContent.NodeInfo()->NameAtom()));
+      nsHTMLTags::CaseSensitiveAtomTagToId(aContent.NodeInfo()->NameAtom()));
+}
+
+bool HTMLEditUtils::IsBlockElement(const nsIContent& aContent,
+                                   BlockInlineCheck aBlockInlineCheck) {
+  MOZ_ASSERT(aBlockInlineCheck != BlockInlineCheck::Unused);
+
+  if (MOZ_UNLIKELY(!aContent.IsElement())) {
+    return false;
+  }
+  if (!StaticPrefs::editor_block_inline_check_use_computed_style() ||
+      aBlockInlineCheck == BlockInlineCheck::UseHTMLDefaultStyle) {
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  // Let's treat the document element and the body element is a block to avoid
+  // complicated things which may be detected by fuzzing.
+  if (aContent.OwnerDoc()->GetDocumentElement() == &aContent ||
+      (aContent.IsHTMLElement(nsGkAtoms::body) &&
+       aContent.OwnerDoc()->GetBodyElement() == &aContent)) {
+    return true;
+  }
+  RefPtr<const ComputedStyle> elementStyle =
+      nsComputedDOMStyle::GetComputedStyleNoFlush(aContent.AsElement());
+  if (MOZ_UNLIKELY(!elementStyle)) {  // If aContent is not in the composed tree
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  const nsStyleDisplay* styleDisplay = elementStyle->StyleDisplay();
+  if (MOZ_UNLIKELY(styleDisplay->mDisplay == StyleDisplay::None)) {
+    // Typically, we should not keep handling editing in invisible nodes, but if
+    // we reach here, let's fallback to the default style for protecting the
+    // structure as far as possible.
+    return IsHTMLBlockElementByDefault(aContent);
+  }
+  // Both Blink and WebKit treat ruby style as a block, see IsEnclosingBlock()
+  // in Chromium or isBlock() in WebKit.
+  if (styleDisplay->IsRubyDisplayType()) {
+    return true;
+  }
+  // If the outside is not inline, treat it as block.
+  if (!styleDisplay->IsInlineOutsideStyle()) {
+    return true;
+  }
+  // If we're checking display-inside, inline-block, etc should be a block too.
+  return aBlockInlineCheck == BlockInlineCheck::UseComputedDisplayStyle &&
+         styleDisplay->DisplayInside() == StyleDisplayInside::FlowRoot &&
+         // Treat widgets as inline since they won't hide collapsible
+         // white-spaces around them.
+         styleDisplay->EffectiveAppearance() == StyleAppearance::None;
+}
+
+bool HTMLEditUtils::IsInlineContent(const nsIContent& aContent,
+                                    BlockInlineCheck aBlockInlineCheck) {
+  MOZ_ASSERT(aBlockInlineCheck != BlockInlineCheck::Unused);
+
+  if (!aContent.IsElement()) {
+    return true;
+  }
+  if (!StaticPrefs::editor_block_inline_check_use_computed_style() ||
+      aBlockInlineCheck == BlockInlineCheck::UseHTMLDefaultStyle) {
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  // Let's treat the document element and the body element is a block to avoid
+  // complicated things which may be detected by fuzzing.
+  if (aContent.OwnerDoc()->GetDocumentElement() == &aContent ||
+      (aContent.IsHTMLElement(nsGkAtoms::body) &&
+       aContent.OwnerDoc()->GetBodyElement() == &aContent)) {
+    return false;
+  }
+  RefPtr<const ComputedStyle> elementStyle =
+      nsComputedDOMStyle::GetComputedStyleNoFlush(aContent.AsElement());
+  if (MOZ_UNLIKELY(!elementStyle)) {  // If aContent is not in the composed tree
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  const nsStyleDisplay* styleDisplay = elementStyle->StyleDisplay();
+  if (MOZ_UNLIKELY(styleDisplay->mDisplay == StyleDisplay::None)) {
+    // Similar to IsBlockElement, let's fallback to refer the default style.
+    // Note that if you change here, you may need to check the parent element
+    // style if aContent.
+    return !IsHTMLBlockElementByDefault(aContent);
+  }
+  // Different block IsBlockElement, when the display-outside is inline, it's
+  // simply an inline element.
+  return styleDisplay->IsInlineOutsideStyle() ||
+         styleDisplay->IsRubyDisplayType();
 }
 
 bool HTMLEditUtils::IsVisibleElementEvenIfLeafNode(const nsIContent& aContent) {
@@ -218,7 +305,9 @@
   if (!aContent.IsHTMLElement()) {
     return true;
   }
-  if (HTMLEditUtils::IsBlockElement(aContent)) {
+  // XXX Should we return false if the element is display:none?
+  if (HTMLEditUtils::IsBlockElement(
+          aContent, BlockInlineCheck::UseComputedDisplayStyle)) {
     return true;
   }
   if (aContent.IsAnyOfHTMLElements(nsGkAtoms::applet, nsGkAtoms::iframe,
@@ -530,7 +619,8 @@
   // First, we get a block container.  This is not designed for reaching
   // no block boundaries in the tree.
   Element* maybeNonEditableAncestorBlock = HTMLEditUtils::GetAncestorElement(
-      aContent, HTMLEditUtils::ClosestBlockElement);
+      aContent, HTMLEditUtils::ClosestBlockElement,
+      BlockInlineCheck::UseComputedDisplayStyle);
   if (NS_WARN_IF(!maybeNonEditableAncestorBlock)) {
     return nullptr;
   }
@@ -542,11 +632,13 @@
                      aContent,
                      {WalkTreeOption::IgnoreDataNodeExceptText,
                       WalkTreeOption::StopAtBlockBoundary},
+                     BlockInlineCheck::UseComputedDisplayStyle,
                      maybeNonEditableAncestorBlock)
                : HTMLEditUtils::GetPreviousContent(
                      aContent,
                      {WalkTreeOption::IgnoreDataNodeExceptText,
                       WalkTreeOption::StopAtBlockBoundary},
+                     BlockInlineCheck::UseComputedDisplayStyle,
                      maybeNonEditableAncestorBlock);
   };
 
@@ -556,7 +648,8 @@
        nextContent = getNextContent(*nextContent)) {
     if (nextContent->IsElement()) {
       // Break is right before a child block, it's not visible
-      if (HTMLEditUtils::IsBlockElement(*nextContent)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *nextContent, BlockInlineCheck::UseComputedDisplayStyle)) {
         return nextContent->AsElement();
       }
 
@@ -646,20 +739,24 @@
                                                      leafNodeOrNonEditableNode)
                  : HTMLEditUtils::GetPreviousContent(
                        aBlockElement, onlyPrecedingLine,
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        aBlockElement.GetParentElement());
          content;
          content =
              aScanLineBreak == ScanLineBreak::AtEndOfBlock
                  ? HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
-                       *content, aBlockElement, leafNodeOrNonEditableNode)
+                       *content, aBlockElement, leafNodeOrNonEditableNode,
+                       BlockInlineCheck::UseComputedDisplayStyle)
                  : HTMLEditUtils::GetPreviousContent(
                        *content, onlyPrecedingLine,
+                       BlockInlineCheck::UseComputedDisplayStyle,
                        aBlockElement.GetParentElement())) {
       // If we're scanning preceding <br> element of aBlockElement, we don't
       // need to look for a line break in another block because the caller
       // needs to handle only preceding <br> element of aBlockElement.
       if (aScanLineBreak == ScanLineBreak::BeforeBlock &&
-          HTMLEditUtils::IsBlockElement(*content)) {
+          HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseComputedDisplayStyle)) {
         return nullptr;
       }
       if (Text* textNode = Text::FromNode(content)) {
@@ -717,15 +814,19 @@
       LeafNodeType::LeafNodeOrNonEditableNode,
       LeafNodeType::LeafNodeOrChildBlock};
   const Element* blockElement = HTMLEditUtils::GetAncestorElement(
-      *lastLineBreakContent, HTMLEditUtils::ClosestBlockElement);
+      *lastLineBreakContent, HTMLEditUtils::ClosestBlockElement,
+      BlockInlineCheck::UseComputedDisplayStyle);
   for (nsIContent* content =
            HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
                *lastLineBreakContent, *blockElement,
-               leafNodeOrNonEditableNodeOrChildBlock);
+               leafNodeOrNonEditableNodeOrChildBlock,
+               BlockInlineCheck::UseComputedDisplayStyle);
        content;
        content = HTMLEditUtils::GetPreviousLeafContentOrPreviousBlockElement(
-           *content, *blockElement, leafNodeOrNonEditableNodeOrChildBlock)) {
-    if (HTMLEditUtils::IsBlockElement(*content) ||
+           *content, *blockElement, leafNodeOrNonEditableNodeOrChildBlock,
+           BlockInlineCheck::UseComputedDisplayStyle)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *content, BlockInlineCheck::UseComputedDisplayStyle) ||
         (content->IsElement() && !content->IsHTMLElement())) {
       // Now, must found <div>...<div>...</div><br></div>
       //                                       ^^^^
@@ -907,7 +1008,8 @@
   Element* closestEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
           *aPointToInsert.ContainerAs<nsIContent>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   // If and only if the nearest block is the editing host or its parent,
   // and the outer display value of the editing host is inline, and new
@@ -1297,6 +1399,7 @@
 template <typename PT, typename CT>
 nsIContent* HTMLEditUtils::GetPreviousContent(
     const EditorDOMPointBase<PT, CT>& aPoint, const WalkTreeOptions& aOptions,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   NS_WARNING_ASSERTION(
@@ -1310,18 +1413,18 @@
     if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
         aPoint.IsInContentNode() &&
         HTMLEditUtils::IsBlockElement(
-            *aPoint.template ContainerAs<nsIContent>())) {
+            *aPoint.template ContainerAs<nsIContent>(), aBlockInlineCheck)) {
       // If we aren't allowed to cross blocks, don't look before this block.
       return nullptr;
     }
-    return HTMLEditUtils::GetPreviousContent(*aPoint.GetContainer(), aOptions,
-                                             aAncestorLimiter);
+    return HTMLEditUtils::GetPreviousContent(
+        *aPoint.GetContainer(), aOptions, aBlockInlineCheck, aAncestorLimiter);
   }
 
   // else look before the child at 'aOffset'
   if (aPoint.GetChild()) {
-    return HTMLEditUtils::GetPreviousContent(*aPoint.GetChild(), aOptions,
-                                             aAncestorLimiter);
+    return HTMLEditUtils::GetPreviousContent(
+        *aPoint.GetChild(), aOptions, aBlockInlineCheck, aAncestorLimiter);
   }
 
   // unless there isn't one, in which case we are at the end of the node
@@ -1330,7 +1433,8 @@
       *aPoint.GetContainer(),
       {aOptions.contains(WalkTreeOption::StopAtBlockBoundary)
            ? LeafNodeType::LeafNodeOrChildBlock
-           : LeafNodeType::OnlyLeafNode});
+           : LeafNodeType::OnlyLeafNode},
+      aBlockInlineCheck);
   if (!lastLeafContent) {
     return nullptr;
   }
@@ -1341,13 +1445,14 @@
 
   // restart the search from the non-editable node we just found
   return HTMLEditUtils::GetPreviousContent(*lastLeafContent, aOptions,
-                                           aAncestorLimiter);
+                                           aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
 template <typename PT, typename CT>
 nsIContent* HTMLEditUtils::GetNextContent(
     const EditorDOMPointBase<PT, CT>& aPoint, const WalkTreeOptions& aOptions,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(aPoint.IsSetAndValid());
   NS_WARNING_ASSERTION(
@@ -1367,7 +1472,7 @@
 
   if (point.GetChild()) {
     if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-        HTMLEditUtils::IsBlockElement(*point.GetChild())) {
+        HTMLEditUtils::IsBlockElement(*point.GetChild(), aBlockInlineCheck)) {
       return point.GetChild();
     }
 
@@ -1375,7 +1480,8 @@
         *point.GetChild(),
         {aOptions.contains(WalkTreeOption::StopAtBlockBoundary)
              ? LeafNodeType::LeafNodeOrChildBlock
-             : LeafNodeType::OnlyLeafNode});
+             : LeafNodeType::OnlyLeafNode},
+        aBlockInlineCheck);
     if (!firstLeafContent) {
       return point.GetChild();
     }
@@ -1394,27 +1500,27 @@
 
     // restart the search from the non-editable node we just found
     return HTMLEditUtils::GetNextContent(*firstLeafContent, aOptions,
-                                         aAncestorLimiter);
+                                         aBlockInlineCheck, aAncestorLimiter);
   }
 
   // unless there isn't one, in which case we are at the end of the node
   // and want the next one.
   if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
       point.IsInContentNode() &&
-      HTMLEditUtils::IsBlockElement(
-          *point.template ContainerAs<nsIContent>())) {
+      HTMLEditUtils::IsBlockElement(*point.template ContainerAs<nsIContent>(),
+                                    aBlockInlineCheck)) {
     // don't cross out of parent block
     return nullptr;
   }
 
   return HTMLEditUtils::GetNextContent(*point.GetContainer(), aOptions,
-                                       aAncestorLimiter);
+                                       aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
 nsIContent* HTMLEditUtils::GetAdjacentLeafContent(
     const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-    const WalkTreeOptions& aOptions,
+    const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   // called only by GetPriorNode so we don't need to check params.
   MOZ_ASSERT(&aNode != aAncestorLimiter);
@@ -1429,9 +1535,12 @@
                               ? node->GetNextSibling()
                               : node->GetPreviousSibling();
     if (sibling) {
+      // XXX If `sibling` belongs to siblings of inclusive ancestors of aNode,
+      //     perhaps, we need to use
+      //     IgnoreInsideBlockBoundary(aBlockInlineCheck) here.
       if (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-          HTMLEditUtils::IsBlockElement(*sibling)) {
-        // don't look inside prevsib, since it is a block
+          HTMLEditUtils::IsBlockElement(*sibling, aBlockInlineCheck)) {
+        // don't look inside previous sibling, since it is a block
         return sibling;
       }
       const LeafNodeTypes leafNodeTypes = {
@@ -1440,8 +1549,10 @@
               : LeafNodeType::OnlyLeafNode};
       nsIContent* leafContent =
           aWalkTreeDirection == WalkTreeDirection::Forward
-              ? HTMLEditUtils::GetFirstLeafContent(*sibling, leafNodeTypes)
-              : HTMLEditUtils::GetLastLeafContent(*sibling, leafNodeTypes);
+              ? HTMLEditUtils::GetFirstLeafContent(*sibling, leafNodeTypes,
+                                                   aBlockInlineCheck)
+              : HTMLEditUtils::GetLastLeafContent(*sibling, leafNodeTypes,
+                                                  aBlockInlineCheck);
       return leafContent ? leafContent : sibling;
     }
 
@@ -1452,7 +1563,7 @@
 
     if (parent == aAncestorLimiter ||
         (aOptions.contains(WalkTreeOption::StopAtBlockBoundary) &&
-         HTMLEditUtils::IsBlockElement(*parent))) {
+         HTMLEditUtils::IsBlockElement(*parent, aBlockInlineCheck))) {
       return nullptr;
     }
 
@@ -1466,7 +1577,7 @@
 // static
 nsIContent* HTMLEditUtils::GetAdjacentContent(
     const nsINode& aNode, WalkTreeDirection aWalkTreeDirection,
-    const WalkTreeOptions& aOptions,
+    const WalkTreeOptions& aOptions, BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   if (&aNode == aAncestorLimiter) {
     // Don't allow traversal above the root node! This helps
@@ -1476,7 +1587,7 @@
   }
 
   nsIContent* leafContent = HTMLEditUtils::GetAdjacentLeafContent(
-      aNode, aWalkTreeDirection, aOptions, aAncestorLimiter);
+      aNode, aWalkTreeDirection, aOptions, aBlockInlineCheck, aAncestorLimiter);
   if (!leafContent) {
     return nullptr;
   }
@@ -1486,7 +1597,8 @@
   }
 
   return HTMLEditUtils::GetAdjacentContent(*leafContent, aWalkTreeDirection,
-                                           aOptions, aAncestorLimiter);
+                                           aOptions, aBlockInlineCheck,
+                                           aAncestorLimiter);
 }
 
 // static
@@ -1718,6 +1830,7 @@
 // static
 Element* HTMLEditUtils::GetAncestorElement(
     const nsIContent& aContent, const AncestorTypes& aAncestorTypes,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(
       aAncestorTypes.contains(AncestorType::ClosestBlockElement) ||
@@ -1751,9 +1864,9 @@
       return false;
     }
     return (lookingForClosestBlockElement &&
-            HTMLEditUtils::IsBlockElement(aContent)) ||
+            HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck)) ||
            (lookingForMostDistantInlineElementInBlock &&
-            HTMLEditUtils::IsInlineElement(aContent)) ||
+            HTMLEditUtils::IsInlineContent(aContent, aBlockInlineCheck)) ||
            (lookingForButtonElement &&
             aContent.IsHTMLElement(nsGkAtoms::button));
   };
@@ -1773,12 +1886,13 @@
     if (lookingForButtonElement && element->IsHTMLElement(nsGkAtoms::button)) {
       return element;  // closest button element
     }
-    if (HTMLEditUtils::IsBlockElement(*element)) {
+    if (HTMLEditUtils::IsBlockElement(*element, aBlockInlineCheck)) {
       if (lookingForClosestBlockElement) {
         return element;  // closest block element
       }
       MOZ_ASSERT_IF(lastAncestorElement,
-                    HTMLEditUtils::IsInlineElement(*lastAncestorElement));
+                    HTMLEditUtils::IsInlineContent(*lastAncestorElement,
+                                                   aBlockInlineCheck));
       return lastAncestorElement;  // the last inline element which we found
     }
     if (element == aAncestorLimiter || element == theBodyElement ||
@@ -1795,6 +1909,7 @@
 // static
 Element* HTMLEditUtils::GetInclusiveAncestorElement(
     const nsIContent& aContent, const AncestorTypes& aAncestorTypes,
+    BlockInlineCheck aBlockInlineCheck,
     const Element* aAncestorLimiter /* = nullptr */) {
   MOZ_ASSERT(
       aAncestorTypes.contains(AncestorType::ClosestBlockElement) ||
@@ -1823,9 +1938,9 @@
       return false;
     }
     return (lookingForClosestBlockElement &&
-            HTMLEditUtils::IsBlockElement(aContent)) ||
+            HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck)) ||
            (lookingForMostDistantInlineElementInBlock &&
-            HTMLEditUtils::IsInlineElement(aContent)) ||
+            HTMLEditUtils::IsInlineContent(aContent, aBlockInlineCheck)) ||
            (lookingForButtonElement &&
             aContent.IsHTMLElement(nsGkAtoms::button));
   };
@@ -1847,7 +1962,7 @@
   // Consider the result right now.
   if ((lookingForClosestBlockElement ||
        lookingForMostDistantInlineElementInBlock) &&
-      HTMLEditUtils::IsBlockElement(aContent) &&
+      HTMLEditUtils::IsBlockElement(aContent, aBlockInlineCheck) &&
       !(ignoreHRElement && aContent.IsHTMLElement(nsGkAtoms::hr))) {
     return IsSearchingElementType(aContent)
                ? const_cast<Element*>(aContent.AsElement())
@@ -1861,7 +1976,8 @@
       (editableElementOnly && !EditorUtils::IsEditableContent(
                                   *aContent.GetParent(), EditorType::HTML)) ||
       (!lookingForClosestBlockElement &&
-       HTMLEditUtils::IsBlockElement(*aContent.GetParent()) &&
+       HTMLEditUtils::IsBlockElement(*aContent.GetParent(),
+                                     aBlockInlineCheck) &&
        !(ignoreHRElement &&
          aContent.GetParent()->IsHTMLElement(nsGkAtoms::hr)))) {
     return IsSearchingElementType(aContent)
@@ -1874,7 +1990,7 @@
   }
 
   return HTMLEditUtils::GetAncestorElement(aContent, aAncestorTypes,
-                                           aAncestorLimiter);
+                                           aBlockInlineCheck, aAncestorLimiter);
 }
 
 // static
@@ -2016,7 +2132,9 @@
   }
   for (auto point = aPoint.template To<EditorRawDOMPoint>(); point.IsSet();) {
     WSScanResult nextVisibleThing =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost, point);
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, point,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (nextVisibleThing.InVisibleOrCollapsibleCharacters()) {
       return nextVisibleThing.TextPtr();
     }
@@ -2058,12 +2176,14 @@
 
   // If the node to insert is not a block level element, we can insert it
   // at any point.
-  if (!HTMLEditUtils::IsBlockElement(aContentToInsert)) {
+  if (!HTMLEditUtils::IsBlockElement(
+          aContentToInsert, BlockInlineCheck::UseComputedDisplayStyle)) {
     return pointToInsert;
   }
 
-  WSRunScanner wsScannerForPointToInsert(const_cast<Element*>(&aEditingHost),
-                                         pointToInsert);
+  WSRunScanner wsScannerForPointToInsert(
+      const_cast<Element*>(&aEditingHost), pointToInsert,
+      BlockInlineCheck::UseComputedDisplayStyle);
 
   // If the insertion position is after the last visible item in a line,
   // i.e., the insertion position is just before a visible line break <br>,
@@ -2116,7 +2236,8 @@
     return EditorDOMPointType(aPoint.GetChild(), 0u);
   }
   if (aPoint.IsEndOfContainer()) {
-    WSRunScanner scanner(&aEditingHost, aPoint);
+    WSRunScanner scanner(&aEditingHost, aPoint,
+                         BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult previousThing =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(aPoint);
     if (previousThing.InVisibleOrCollapsibleCharacters()) {
@@ -2265,10 +2386,11 @@
 size_t HTMLEditUtils::CollectEmptyInlineContainerDescendants(
     const nsINode& aNode,
     nsTArray<OwningNonNull<nsIContent>>& aOutArrayOfContents,
-    const EmptyCheckOptions& aOptions) {
+    const EmptyCheckOptions& aOptions, BlockInlineCheck aBlockInlineCheck) {
   size_t numberOfFoundElements = 0;
   for (Element* element = aNode.GetFirstElementChild(); element;) {
-    if (HTMLEditUtils::IsEmptyInlineContainer(*element, aOptions)) {
+    if (HTMLEditUtils::IsEmptyInlineContainer(*element, aOptions,
+                                              aBlockInlineCheck)) {
       aOutArrayOfContents.AppendElement(*element);
       numberOfFoundElements++;
       nsIContent* nextContent = element->GetNextNonChildNode(&aNode);