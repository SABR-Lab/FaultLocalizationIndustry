# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditor.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLEditor.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -30,6 +30,7 @@
 #include "mozilla/DebugOnly.h"
 #include "mozilla/EditorForwards.h"
 #include "mozilla/Encoding.h"  // for Encoding
+#include "mozilla/FlushType.h"
 #include "mozilla/IMEStateManager.h"
 #include "mozilla/IntegerRange.h"  // for IntegerRange
 #include "mozilla/InternalMutationEvent.h"
@@ -1104,7 +1105,7 @@
            *editingHost,
            {LeafNodeType::LeafNodeOrNonEditableNode,
             LeafNodeType::LeafNodeOrChildBlock},
-           editingHost);
+           BlockInlineCheck::UseComputedDisplayStyle, editingHost);
        leafContent;) {
     // If we meet a non-editable node first, we should move caret to start
     // of the container block or editing host.
@@ -1115,8 +1116,8 @@
       if (const Element* editableBlockElementOrInlineEditingHost =
               HTMLEditUtils::GetAncestorElement(
                   *leafContent,
-                  HTMLEditUtils::
-                      ClosestEditableBlockElementOrInlineEditingHost)) {
+                  HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+                  BlockInlineCheck::UseComputedDisplayStyle)) {
         nsresult rv = CollapseSelectionTo(
             EditorDOMPoint(editableBlockElementOrInlineEditingHost, 0));
         NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
@@ -1132,18 +1133,21 @@
     // <div contenteditable><span></span><b><br></b></div>
     // then, we should put caret at the <br> element.  So, let's check if found
     // node is an empty inline container element.
-    if (leafContent->IsElement() &&
-        HTMLEditUtils::IsInlineElement(*leafContent) &&
-        !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafContent) &&
-        HTMLEditUtils::CanNodeContain(*leafContent, *nsGkAtoms::textTagName)) {
-      // Chromium collaps selection to start of the editing host when this is
-      // the last leaf content.  So, we don't need special handling here.
-      leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
-          *leafContent, *editingHost,
-          {LeafNodeType::LeafNodeOrNonEditableNode,
-           LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
-      continue;
+    if (Element* leafElement = Element::FromNode(leafContent)) {
+      if (HTMLEditUtils::IsInlineContent(
+              *leafElement, BlockInlineCheck::UseComputedDisplayStyle) &&
+          !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafElement) &&
+          HTMLEditUtils::CanNodeContain(*leafElement,
+                                        *nsGkAtoms::textTagName)) {
+        // Chromium collapses selection to start of the editing host when this
+        // is the last leaf content.  So, we don't need special handling here.
+        leafContent = HTMLEditUtils::GetNextLeafContentOrNextBlockElement(
+            *leafElement, *editingHost,
+            {LeafNodeType::LeafNodeOrNonEditableNode,
+             LeafNodeType::LeafNodeOrChildBlock},
+            BlockInlineCheck::UseComputedDisplayStyle, editingHost);
+        continue;
+      }
     }
 
     if (Text* text = leafContent->GetAsText()) {
@@ -1151,7 +1155,8 @@
       // the visible character.
       WSScanResult scanResultInTextNode =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-              editingHost, EditorRawDOMPoint(text, 0));
+              editingHost, EditorRawDOMPoint(text, 0),
+              BlockInlineCheck::UseComputedDisplayStyle);
       if ((scanResultInTextNode.InVisibleOrCollapsibleCharacters() ||
            scanResultInTextNode.ReachedPreformattedLineBreak()) &&
           scanResultInTextNode.TextPtr() == text) {
@@ -1166,7 +1171,7 @@
           *leafContent, *editingHost,
           {LeafNodeType::LeafNodeOrNonEditableNode,
            LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost);
       continue;
     }
 
@@ -1192,7 +1197,8 @@
     }
 
     // If we meet non-empty block element, we need to scan its child too.
-    if (HTMLEditUtils::IsBlockElement(*leafContent) &&
+    if (HTMLEditUtils::IsBlockElement(
+            *leafContent, BlockInlineCheck::UseComputedDisplayStyle) &&
         !HTMLEditUtils::IsEmptyNode(
             *leafContent, {EmptyCheckOption::TreatSingleBRElementAsVisible}) &&
         !HTMLEditUtils::IsNeverElementContentsEditableByUser(*leafContent)) {
@@ -1200,7 +1206,7 @@
           *leafContent,
           {LeafNodeType::LeafNodeOrNonEditableNode,
            LeafNodeType::LeafNodeOrChildBlock},
-          editingHost);
+          BlockInlineCheck::UseComputedDisplayStyle, editingHost);
       continue;
     }
 
@@ -1210,7 +1216,7 @@
         *leafContent, *editingHost,
         {LeafNodeType::LeafNodeOrNonEditableNode,
          LeafNodeType::LeafNodeOrChildBlock},
-        editingHost);
+        BlockInlineCheck::UseComputedDisplayStyle, editingHost);
   }
 
   // If there is no visible/editable node except another block element in
@@ -1239,7 +1245,7 @@
   MOZ_ASSERT(IsEditActionDataAvailable());
 
   if (!SavedSelectionRef().RangeCount()) {
-    // XXX Returing error when it does not store is odd because no selection
+    // XXX Returning error when it does not store is odd because no selection
     //     ranges is not illegal case in general.
     return NS_ERROR_FAILURE;
   }
@@ -1374,7 +1380,8 @@
       const Element* editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
               *startContainer->AsContent(),
-              HTMLEditUtils::ClosestEditableBlockElement);
+              HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (!editableBlockElement) {
         break;
       }
@@ -1469,8 +1476,23 @@
 }
 
 NS_IMETHODIMP HTMLEditor::NodeIsBlock(nsINode* aNode, bool* aIsBlock) {
-  *aIsBlock = aNode && aNode->IsContent() &&
-              HTMLEditUtils::IsBlockElement(*aNode->AsContent());
+  if (NS_WARN_IF(!aNode)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  if (MOZ_UNLIKELY(!aNode->IsElement())) {
+    *aIsBlock = false;
+    return NS_OK;
+  }
+  // If the node is in composed doc, we'll refer its style.  If we don't flush
+  // pending style here, another API call may change the style.  Therefore,
+  // let's flush the pending style changes right now.
+  if (aNode->IsInComposedDoc()) {
+    if (RefPtr<PresShell> presShell = GetPresShell()) {
+      presShell->FlushPendingNotifications(FlushType::Style);
+    }
+  }
+  *aIsBlock = HTMLEditUtils::IsBlockElement(
+      *aNode->AsElement(), BlockInlineCheck::UseComputedDisplayOutsideStyle);
   return NS_OK;
 }
 
@@ -2136,7 +2158,8 @@
   }
 
   if (aDeleteSelection) {
-    if (!HTMLEditUtils::IsBlockElement(*aElement)) {
+    if (!HTMLEditUtils::IsBlockElement(
+            *aElement, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       // E.g., inserting an image.  In this case we don't need to delete any
       // inline wrappers before we do the insertion.  Otherwise we let
       // DeleteSelectionAndPrepareToCreateNode do the deletion for us, which
@@ -2585,14 +2608,16 @@
     // should ignore the editing host boundaries.
     Element* const closestBlockElement =
         HTMLEditUtils::GetInclusiveAncestorElement(
-            *contentToExamine, HTMLEditUtils::ClosestBlockElement);
+            *contentToExamine, HTMLEditUtils::ClosestBlockElement,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (NS_WARN_IF(!closestBlockElement)) {
       return NS_OK;
     }
 
     for (RefPtr<Element> blockElement = closestBlockElement; blockElement;) {
       RefPtr<Element> nextBlockElement = HTMLEditUtils::GetAncestorElement(
-          *blockElement, HTMLEditUtils::ClosestBlockElement);
+          *blockElement, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       DebugOnly<nsresult> rvIgnored = CSSEditUtils::GetComputedProperty(
           *blockElement, *nsGkAtoms::backgroundColor, aOutColor);
       if (NS_WARN_IF(Destroyed())) {
@@ -2601,7 +2626,8 @@
       if (MayHaveMutationEventListeners() &&
           NS_WARN_IF(nextBlockElement !=
                      HTMLEditUtils::GetAncestorElement(
-                         *blockElement, HTMLEditUtils::ClosestBlockElement))) {
+                         *blockElement, HTMLEditUtils::ClosestBlockElement,
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle))) {
         return NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE;
       }
       NS_WARNING_ASSERTION(NS_SUCCEEDED(rvIgnored),
@@ -2638,7 +2664,8 @@
              contentToExamine->GetAsElementOrParentElement();
          element; element = element->GetParentElement()) {
       // is the node to examine a block ?
-      if (HTMLEditUtils::IsBlockElement(*element)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *element, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         // yes it is a block; in that case, the text background color is
         // transparent
         aOutColor.AssignLiteral("transparent");
@@ -3817,7 +3844,9 @@
     return NS_ERROR_FAILURE;
   }
 
-  if (&aContent == editingHost || HTMLEditUtils::IsBlockElement(aContent) ||
+  if (&aContent == editingHost ||
+      HTMLEditUtils::IsBlockElement(
+          aContent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
       !EditorUtils::IsEditableContent(aContent, EditorType::HTML) ||
       !aContent.GetParent()) {
     return NS_OK;
@@ -3829,7 +3858,8 @@
   //     even if it's only child of the block element.
   {
     const Element* editableBlockElement = HTMLEditUtils::GetAncestorElement(
-        aContent, HTMLEditUtils::ClosestEditableBlockElement);
+        aContent, HTMLEditUtils::ClosestEditableBlockElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (!editableBlockElement ||
         HTMLEditUtils::IsEmptyNode(
             *editableBlockElement,
@@ -3840,7 +3870,8 @@
 
   OwningNonNull<nsIContent> content = aContent;
   for (nsIContent* parentContent : aContent.AncestorsOfType<nsIContent>()) {
-    if (HTMLEditUtils::IsBlockElement(*parentContent) ||
+    if (HTMLEditUtils::IsBlockElement(
+            *parentContent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         parentContent->Length() != 1 ||
         !EditorUtils::IsEditableContent(*parentContent, EditorType::HTML) ||
         parentContent == editingHost) {
@@ -4829,9 +4860,12 @@
 
     if (nsIContent* previousSibling = HTMLEditUtils::GetPreviousSibling(
             aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-      if (!HTMLEditUtils::IsBlockElement(*previousSibling) &&
+      if (!HTMLEditUtils::IsBlockElement(
+              *previousSibling,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
           !previousSibling->IsHTMLElement(nsGkAtoms::br) &&
-          !HTMLEditUtils::IsBlockElement(*child)) {
+          !HTMLEditUtils::IsBlockElement(
+              *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         // Insert br node
         Result<CreateElementResult, nsresult> insertBRElementResult =
             InsertBRElement(WithTransaction::Yes,
@@ -4857,10 +4891,14 @@
 
     if (nsIContent* nextSibling = HTMLEditUtils::GetNextSibling(
             aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-      if (nextSibling && !HTMLEditUtils::IsBlockElement(*nextSibling)) {
+      if (nextSibling &&
+          !HTMLEditUtils::IsBlockElement(
+              *nextSibling, BlockInlineCheck::UseComputedDisplayStyle)) {
         if (nsIContent* lastChild = HTMLEditUtils::GetLastChild(
-                aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-          if (!HTMLEditUtils::IsBlockElement(*lastChild) &&
+                aElement, {WalkTreeOption::IgnoreNonEditableNode},
+                BlockInlineCheck::Unused)) {
+          if (!HTMLEditUtils::IsBlockElement(
+                  *lastChild, BlockInlineCheck::UseComputedDisplayStyle) &&
               !lastChild->IsHTMLElement(nsGkAtoms::br)) {
             Result<CreateElementResult, nsresult> insertBRElementResult =
                 InsertBRElement(WithTransaction::Yes,
@@ -4887,11 +4925,13 @@
     // 3) following sibling of aNode is a block, OR
     // 4) following sibling of aNode is a br OR
     // 5) either is null
-    if (!HTMLEditUtils::IsBlockElement(*previousSibling) &&
+    if (!HTMLEditUtils::IsBlockElement(
+            *previousSibling, BlockInlineCheck::UseComputedDisplayStyle) &&
         !previousSibling->IsHTMLElement(nsGkAtoms::br)) {
       if (nsIContent* nextSibling = HTMLEditUtils::GetNextSibling(
               aElement, {WalkTreeOption::IgnoreNonEditableNode})) {
-        if (!HTMLEditUtils::IsBlockElement(*nextSibling) &&
+        if (!HTMLEditUtils::IsBlockElement(
+                *nextSibling, BlockInlineCheck::UseComputedDisplayStyle) &&
             !nextSibling->IsHTMLElement(nsGkAtoms::br)) {
           Result<CreateElementResult, nsresult> insertBRElementResult =
               InsertBRElement(WithTransaction::Yes,
@@ -6212,7 +6252,8 @@
         const RefPtr<nsStyledElement> editableBlockStyledElement =
             nsStyledElement::FromNodeOrNull(HTMLEditUtils::GetAncestorElement(
                 *range.StartRef().ContainerAs<Text>(),
-                HTMLEditUtils::ClosestEditableBlockElement));
+                HTMLEditUtils::ClosestEditableBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle));
         if (!editableBlockStyledElement ||
             !EditorElementStyle::BGColor().IsCSSSettable(
                 *editableBlockStyledElement)) {
@@ -6268,7 +6309,8 @@
             nsStyledElement::FromNodeOrNull(
                 HTMLEditUtils::GetInclusiveAncestorElement(
                     *range.StartRef().GetChild(),
-                    HTMLEditUtils::ClosestEditableBlockElement));
+                    HTMLEditUtils::ClosestEditableBlockElement,
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
         if (!editableBlockStyledElement ||
             !EditorElementStyle::BGColor().IsCSSSettable(
                 *editableBlockStyledElement)) {
@@ -6325,7 +6367,8 @@
                                        EditorType::HTML)) {
       Element* const editableBlockElement = HTMLEditUtils::GetAncestorElement(
           *range.StartRef().ContainerAs<Text>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         handledBlockParent = editableBlockElement;
         nsStyledElement* const blockStyledElement =
@@ -6356,7 +6399,8 @@
     for (OwningNonNull<nsIContent>& content : arrayOfContents) {
       Element* const editableBlockElement =
           HTMLEditUtils::GetInclusiveAncestorElement(
-              content, HTMLEditUtils::ClosestEditableBlockElement);
+              content, HTMLEditUtils::ClosestEditableBlockElement,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         handledBlockParent = editableBlockElement;
         nsStyledElement* const blockStyledElement =
@@ -6389,7 +6433,8 @@
                                        EditorType::HTML)) {
       Element* const editableBlockElement = HTMLEditUtils::GetAncestorElement(
           *range.EndRef().ContainerAs<Text>(),
-          HTMLEditUtils::ClosestEditableBlockElement);
+          HTMLEditUtils::ClosestEditableBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (editableBlockElement && handledBlockParent != editableBlockElement) {
         const RefPtr<nsStyledElement> blockStyledElement =
             nsStyledElement::FromNode(editableBlockElement);
@@ -6495,7 +6540,7 @@
          deepestEditableContent->IsHTMLElement(nsGkAtoms::br)) {
     deepestEditableContent = HTMLEditUtils::GetPreviousContent(
         *deepestEditableContent, {WalkTreeOption::IgnoreNonEditableNode},
-        &aEditingHost);
+        BlockInlineCheck::UseComputedDisplayOutsideStyle, &aEditingHost);
   }
   if (!deepestEditableContent) {
     return EditorDOMPoint(&aNewBlock, 0u);