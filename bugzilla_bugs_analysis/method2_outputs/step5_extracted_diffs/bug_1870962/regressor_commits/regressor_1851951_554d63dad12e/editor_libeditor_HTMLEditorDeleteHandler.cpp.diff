# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditorDeleteHandler.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLEditorDeleteHandler.cpp
--- a/editor/libeditor/HTMLEditorDeleteHandler.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLEditorDeleteHandler.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -1305,7 +1305,9 @@
                                           EditorType::HTML)) {
         return NS_SUCCESS_DOM_NO_OPERATION;
       }
-      WSRunScanner wsRunScannerAtCaret(editingHost, caretPoint);
+      WSRunScanner wsRunScannerAtCaret(
+          editingHost, caretPoint,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult scanFromCaretPointResult =
           aDirectionAndAmount == nsIEditor::eNext
               ? wsRunScannerAtCaret.ScanNextVisibleNodeOrBlockBoundaryFrom(
@@ -1602,7 +1604,9 @@
               *caretPoint.ref().ContainerAs<nsIContent>(), EditorType::HTML)) {
         return EditActionResult::CanceledResult();
       }
-      WSRunScanner wsRunScannerAtCaret(&aEditingHost, caretPoint.ref());
+      WSRunScanner wsRunScannerAtCaret(
+          &aEditingHost, caretPoint.ref(),
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult scanFromCaretPointResult =
           aDirectionAndAmount == nsIEditor::eNext
               ? wsRunScannerAtCaret.ScanNextVisibleNodeOrBlockBoundaryFrom(
@@ -1658,7 +1662,9 @@
                   NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT)) {
             // Let's check whether there is new invisible `<br>` element
             // for avoiding infinite recursive calls.
-            WSRunScanner wsRunScannerAtCaret(&aEditingHost, caretPoint.ref());
+            WSRunScanner wsRunScannerAtCaret(
+                &aEditingHost, caretPoint.ref(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle);
             WSScanResult scanFromCaretPointResult =
                 aDirectionAndAmount == nsIEditor::eNext
                     ? wsRunScannerAtCaret
@@ -2397,13 +2403,13 @@
   if (aDirectionAndAmount == nsIEditor::ePrevious) {
     mLeafContentInOtherBlock = HTMLEditUtils::GetLastLeafContent(
         aOtherBlockElement, {LeafNodeType::OnlyEditableLeafNode},
-        &aOtherBlockElement);
+        BlockInlineCheck::Unused, &aOtherBlockElement);
     mLeftContent = mLeafContentInOtherBlock;
     mRightContent = aCaretPoint.GetContainerAs<nsIContent>();
   } else {
     mLeafContentInOtherBlock = HTMLEditUtils::GetFirstLeafContent(
         aOtherBlockElement, {LeafNodeType::OnlyEditableLeafNode},
-        &aOtherBlockElement);
+        BlockInlineCheck::Unused, &aOtherBlockElement);
     mLeftContent = aCaretPoint.GetContainerAs<nsIContent>();
     mRightContent = mLeafContentInOtherBlock;
   }
@@ -2453,7 +2459,8 @@
             aHTMLEditor.GetEditAction())) {
       return EditorDOMPoint();
     }
-    WSRunScanner scanner(&aEditingHost, EditorRawDOMPoint(mBRElement));
+    WSRunScanner scanner(&aEditingHost, EditorRawDOMPoint(mBRElement),
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(
             EditorRawDOMPoint(mBRElement));
@@ -2846,10 +2853,10 @@
         aDirectionAndAmount == nsIEditor::ePrevious
             ? HTMLEditUtils::GetPreviousContent(
                   aCurrentBlockElement, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost)
+                  BlockInlineCheck::Unused, editingHost)
             : HTMLEditUtils::GetNextContent(
                   aCurrentBlockElement, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost);
+                  BlockInlineCheck::Unused, editingHost);
     // If found content is an invisible text node, let's scan visible things.
     auto IsIgnorableDataNode = [](nsIContent* aContent) {
       return aContent && HTMLEditUtils::IsRemovableNode(*aContent) &&
@@ -2866,18 +2873,22 @@
              aDirectionAndAmount == nsIEditor::ePrevious
                  ? HTMLEditUtils::GetPreviousContent(
                        *targetContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)
                  : HTMLEditUtils::GetNextContent(
                        *targetContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost);
          adjacentContent;
          adjacentContent =
              aDirectionAndAmount == nsIEditor::ePrevious
                  ? HTMLEditUtils::GetPreviousContent(
                        *adjacentContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)
                  : HTMLEditUtils::GetNextContent(
                        *adjacentContent, {WalkTreeOption::StopAtBlockBoundary},
+                       BlockInlineCheck::UseComputedDisplayOutsideStyle,
                        editingHost)) {
       // If non-editable element is found, we should not skip it to avoid
       // joining too far nodes.
@@ -2885,7 +2896,9 @@
         break;
       }
       // If block element is found, we should join last leaf content in it.
-      if (HTMLEditUtils::IsBlockElement(*adjacentContent)) {
+      if (HTMLEditUtils::IsBlockElement(
+              *adjacentContent,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         nsIContent* leafContent =
             aDirectionAndAmount == nsIEditor::ePrevious
                 ? HTMLEditUtils::GetLastLeafContent(
@@ -3353,10 +3366,12 @@
 
   mLeftContent = HTMLEditUtils::GetInclusiveAncestorElement(
       *aRangesToDelete.FirstRangeRef()->GetStartContainer()->AsContent(),
-      HTMLEditUtils::ClosestEditableBlockElement);
+      HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   mRightContent = HTMLEditUtils::GetInclusiveAncestorElement(
       *aRangesToDelete.FirstRangeRef()->GetEndContainer()->AsContent(),
-      HTMLEditUtils::ClosestEditableBlockElement);
+      HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   // Note that mLeftContent and/or mRightContent can be nullptr if editing host
   // is an inline element.  If both editable ancestor block is exactly same
   // one or one reaches an inline editing host, we can just delete the content
@@ -3374,7 +3389,7 @@
     return true;
   }
 
-  // If left block and right block are adjuscent siblings and they are same
+  // If left block and right block are adjacent siblings and they are same
   // type of elements, we can merge them after deleting the selected contents.
   // MOOSE: this could conceivably screw up a table.. fix me.
   if (mLeftContent->GetParentNode() == mRightContent->GetParentNode() &&
@@ -3420,10 +3435,12 @@
                                    ->GetEndContainer()
                                    ->IsInclusiveDescendantOf(mRightContent));
   MOZ_ASSERT_IF(!mLeftContent,
-                HTMLEditUtils::IsInlineElement(*aRangesToDelete.FirstRangeRef()
-                                                    ->GetStartContainer()
-                                                    ->AsContent()
-                                                    ->GetEditingHost()));
+                HTMLEditUtils::IsInlineContent(
+                    *aRangesToDelete.FirstRangeRef()
+                         ->GetStartContainer()
+                         ->AsContent()
+                         ->GetEditingHost(),
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   nsresult rv =
       mDeleteRangesHandlerConst.ComputeRangesToDeleteRangesWithTransaction(
@@ -3463,10 +3480,12 @@
                                    ->GetEndContainer()
                                    ->IsInclusiveDescendantOf(mRightContent));
   MOZ_ASSERT_IF(!mLeftContent,
-                HTMLEditUtils::IsInlineElement(*aRangesToDelete.FirstRangeRef()
-                                                    ->GetStartContainer()
-                                                    ->AsContent()
-                                                    ->GetEditingHost()));
+                HTMLEditUtils::IsInlineContent(
+                    *aRangesToDelete.FirstRangeRef()
+                         ->GetStartContainer()
+                         ->AsContent()
+                         ->GetEditingHost(),
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   // XXX This is also odd.  We do we simply use
   //     `DeleteRangesWithTransaction()` only when **first** range is in
@@ -3622,7 +3641,8 @@
   // node because the other browsers insert following inputs into there.
   if (MayEditActionDeleteAroundCollapsedSelection(
           aHTMLEditor.GetEditAction())) {
-    WSRunScanner scanner(&aEditingHost, startOfRightContent);
+    WSRunScanner scanner(&aEditingHost, startOfRightContent,
+                         BlockInlineCheck::UseComputedDisplayOutsideStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(startOfRightContent);
     if (maybePreviousText.IsContentEditable() &&
@@ -4184,7 +4204,8 @@
 
   // First, check there is visible contents before the point in current block.
   RefPtr<Element> editingHost = aHTMLEditor.ComputeEditingHost();
-  WSRunScanner wsScannerForPoint(editingHost, aPoint);
+  WSRunScanner wsScannerForPoint(
+      editingHost, aPoint, BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (!wsScannerForPoint.StartsFromCurrentBlockBoundary()) {
     // If there is visible node before the point, we shouldn't remove the
     // parent block.
@@ -4230,8 +4251,10 @@
     if (wsScannerForPoint.GetEndReasonContent()->GetNextSibling()) {
       WSScanResult scanResult =
           WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
-              editingHost, EditorRawDOMPoint::After(
-                               *wsScannerForPoint.GetEndReasonContent()));
+              editingHost,
+              EditorRawDOMPoint::After(
+                  *wsScannerForPoint.GetEndReasonContent()),
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (scanResult.Failed()) {
         NS_WARNING("WSRunScanner::ScanNextVisibleNodeOrBlockBoundary() failed");
         return NS_ERROR_FAILURE;
@@ -4371,7 +4394,7 @@
         caretPoint.IsStartOfContainer()) {
       nsIContent* previousEditableContent = HTMLEditUtils::GetPreviousContent(
           *caretPoint.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
-          editingHost);
+          BlockInlineCheck::Unused, editingHost);
       if (!previousEditableContent) {
         continue;
       }
@@ -4394,7 +4417,7 @@
         caretPoint.IsEndOfContainer()) {
       nsIContent* nextEditableContent = HTMLEditUtils::GetNextContent(
           *caretPoint.GetContainer(), {WalkTreeOption::IgnoreNonEditableNode},
-          editingHost);
+          BlockInlineCheck::Unused, editingHost);
       if (!nextEditableContent) {
         continue;
       }
@@ -4431,10 +4454,10 @@
                 EditorBase::HowToHandleCollapsedRange::ExtendBackward
             ? HTMLEditUtils::GetPreviousContent(
                   caretPoint, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost)
+                  BlockInlineCheck::Unused, editingHost)
             : HTMLEditUtils::GetNextContent(
                   caretPoint, {WalkTreeOption::IgnoreNonEditableNode},
-                  editingHost);
+                  BlockInlineCheck::Unused, editingHost);
     if (!editableContent) {
       continue;
     }
@@ -4445,10 +4468,10 @@
                   EditorBase::HowToHandleCollapsedRange::ExtendBackward
               ? HTMLEditUtils::GetPreviousContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-                    editingHost)
+                    BlockInlineCheck::Unused, editingHost)
               : HTMLEditUtils::GetNextContent(
                     *editableContent, {WalkTreeOption::IgnoreNonEditableNode},
-                    editingHost);
+                    BlockInlineCheck::Unused, editingHost);
     }
     if (!editableContent) {
       continue;
@@ -4500,7 +4523,8 @@
         TreatEmptyTextNodes::RemoveAllEmptyInlineAncestors) {
       Element* emptyParentElementToRemove =
           HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-              nodeToRemove, editingHost);
+              nodeToRemove, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              editingHost);
       if (emptyParentElementToRemove) {
         nodeToRemove = *emptyParentElementToRemove;
       }
@@ -4702,10 +4726,12 @@
         const HTMLEditor& aHTMLEditor, const Element& aEditingHost) {
   mLeftBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
       mInclusiveDescendantOfLeftBlockElement,
-      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement);
+      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   mRightBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
       mInclusiveDescendantOfRightBlockElement,
-      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement);
+      HTMLEditUtils::ClosestEditableBlockElementExceptHRElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
 
   if (NS_WARN_IF(!IsSet())) {
     mCanJoinBlocks = false;
@@ -4782,7 +4808,8 @@
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            EditorDOMPoint::AtEndOf(mLeftBlockElement));
+            EditorDOMPoint::AtEndOf(mLeftBlockElement),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement()`
     // returns ignored when:
@@ -4812,7 +4839,8 @@
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            mPointContainingTheOtherBlockElement);
+            mPointContainingTheOtherBlockElement,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement()`
     // returns ignored when:
@@ -4847,7 +4875,8 @@
     mPrecedingInvisibleBRElement =
         WSRunScanner::GetPrecedingBRElementUnlessVisibleContentFound(
             aHTMLEditor.ComputeEditingHost(),
-            EditorDOMPoint::AtEndOf(mLeftBlockElement));
+            EditorDOMPoint::AtEndOf(mLeftBlockElement),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     // `WhiteSpaceVisibilityKeeper::
     // MergeFirstLineOfRightBlockElementIntoLeftBlockElement()` always
     // return "handled".
@@ -4909,6 +4938,7 @@
                     *atStart.ContainerAs<nsIContent>(),
                     {WalkTreeOption::IgnoreDataNodeExceptText,
                      WalkTreeOption::StopAtBlockBoundary},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     editingHost)
               : nullptr;
       if (!nextContent || nextContent != range.StartRef().GetChild()) {
@@ -5057,7 +5087,8 @@
   // Then, users can type text into it like the other browsers.
   if (MayEditActionDeleteAroundCollapsedSelection(
           aHTMLEditor.GetEditAction())) {
-    WSRunScanner scanner(&aEditingHost, startOfRightContent);
+    WSRunScanner scanner(&aEditingHost, startOfRightContent,
+                         BlockInlineCheck::UseComputedDisplayStyle);
     WSScanResult maybePreviousText =
         scanner.ScanPreviousVisibleNodeOrBlockBoundaryFrom(startOfRightContent);
     if (maybePreviousText.IsContentEditable() &&
@@ -5099,7 +5130,8 @@
       if (const Element* blockElement =
               HTMLEditUtils::GetInclusiveAncestorElement(
                   *childContent->GetParent(),
-                  HTMLEditUtils::ClosestBlockElement)) {
+                  HTMLEditUtils::ClosestBlockElement,
+                  BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         if (HTMLEditUtils::IsEmptyNode(*blockElement)) {
           return false;
         }
@@ -5168,13 +5200,15 @@
       aPointInHardLine.IsInContentNode()
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *aPointInHardLine.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestBlockElement)
+                HTMLEditUtils::ClosestBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)
           : nullptr;
   mDestInclusiveAncestorBlock =
       mPointToInsert.IsInContentNode()
           ? HTMLEditUtils::GetInclusiveAncestorElement(
                 *mPointToInsert.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestBlockElement)
+                HTMLEditUtils::ClosestBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)
           : nullptr;
   mMovingToParentBlock =
       mDestInclusiveAncestorBlock && mSrcInclusiveAncestorBlock &&
@@ -5211,7 +5245,8 @@
   Result<EditorDOMPoint, nsresult> splitResult =
       rangesToWrapTheLine
           .SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries(
-              aHTMLEditor, aEditingHost, &aNewContainer);
+              aHTMLEditor, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              aEditingHost, &aNewContainer);
   if (MOZ_UNLIKELY(splitResult.isErr())) {
     NS_WARNING(
         "AutoRangeArray::"
@@ -5239,7 +5274,8 @@
     GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement(
         Element& aBlockElement, const Element& aAncestorElement) {
   MOZ_ASSERT(aBlockElement.IsInclusiveDescendantOf(&aAncestorElement));
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aBlockElement));
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+      aBlockElement, BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   if (&aBlockElement == &aAncestorElement) {
     return nullptr;
@@ -5250,7 +5286,9 @@
     if (element == &aAncestorElement) {
       return lastBlockAncestor;
     }
-    if (HTMLEditUtils::IsBlockElement(*lastBlockAncestor)) {
+    if (HTMLEditUtils::IsBlockElement(
+            *lastBlockAncestor,
+            BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       lastBlockAncestor = element;
     }
   }
@@ -5363,7 +5401,8 @@
       AutoEditorDOMRangeChildrenInvalidator lockOffsets(movedContentRange);
       // If the content is a block element, move all children of it to the
       // new container, and then, remove the (probably) empty block element.
-      if (HTMLEditUtils::IsBlockElement(content)) {
+      if (HTMLEditUtils::IsBlockElement(
+              content, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         Result<MoveNodeResult, nsresult> moveChildrenResult =
             aHTMLEditor.MoveChildrenWithTransaction(
                 MOZ_KnownLive(*content->AsElement()), pointToInsert,
@@ -5390,13 +5429,15 @@
       // don't want it to appear in the dist paragraph.
       else if (content->IsComment() ||
                HTMLEditUtils::IsEmptyInlineContainer(
-                   content, {EmptyCheckOption::TreatSingleBRElementAsVisible,
-                             EmptyCheckOption::TreatListItemAsVisible,
-                             EmptyCheckOption::TreatTableCellAsVisible})) {
+                   content,
+                   {EmptyCheckOption::TreatSingleBRElementAsVisible,
+                    EmptyCheckOption::TreatListItemAsVisible,
+                    EmptyCheckOption::TreatTableCellAsVisible},
+                   BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
         nsCOMPtr<nsIContent> emptyContent =
             HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-                content, &aEditingHost,
-                pointToInsert.ContainerAs<nsIContent>());
+                content, BlockInlineCheck::UseComputedDisplayOutsideStyle,
+                &aEditingHost, pointToInsert.ContainerAs<nsIContent>());
         if (!emptyContent) {
           emptyContent = content;
         }
@@ -5491,6 +5532,7 @@
               ? HTMLEditUtils::GetPreviousContent(
                     *mTopmostSrcAncestorBlockInDestBlock,
                     {WalkTreeOption::StopAtBlockBoundary},
+                    BlockInlineCheck::UseComputedDisplayOutsideStyle,
                     mDestInclusiveAncestorBlock)
               : HTMLEditUtils::GetLastLeafContent(
                     *mDestInclusiveAncestorBlock,
@@ -5513,7 +5555,9 @@
       if (textNodeEndingWithUnnecessaryLineBreak->TextDataLength() == 1u) {
         const RefPtr<Element> inlineElement =
             HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-                *textNodeEndingWithUnnecessaryLineBreak, &aEditingHost);
+                *textNodeEndingWithUnnecessaryLineBreak,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle,
+                &aEditingHost);
         nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(
             inlineElement ? static_cast<nsIContent&>(*inlineElement)
                           : static_cast<nsIContent&>(
@@ -5593,7 +5637,9 @@
   // should remove the parent too.
   if (const RefPtr<Element> inlineElement =
           HTMLEditUtils::GetMostDistantAncestorEditableEmptyInlineElement(
-              *lastLineBreakContent, &aEditingHost)) {
+              *lastLineBreakContent,
+              BlockInlineCheck::UseComputedDisplayOutsideStyle,
+              &aEditingHost)) {
     nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(*inlineElement);
     NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
                          "EditorBase::DeleteNodeWithTransaction() failed");
@@ -6083,7 +6129,8 @@
   // Note: do NOT delete table elements this way.
   // Note: do NOT delete non-editable block element.
   Element* editableBlockElement = HTMLEditUtils::GetInclusiveAncestorElement(
-      aStartContent, HTMLEditUtils::ClosestEditableBlockElement);
+      aStartContent, HTMLEditUtils::ClosestEditableBlockElement,
+      BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (!editableBlockElement) {
     return nullptr;
   }
@@ -6108,7 +6155,8 @@
     mEmptyInclusiveAncestorBlockElement = editableBlockElement;
     editableBlockElement = HTMLEditUtils::GetAncestorElement(
         *mEmptyInclusiveAncestorBlockElement,
-        HTMLEditUtils::ClosestEditableBlockElement);
+        HTMLEditUtils::ClosestEditableBlockElement,
+        BlockInlineCheck::UseComputedDisplayOutsideStyle);
   }
   if (!mEmptyInclusiveAncestorBlockElement) {
     return nullptr;
@@ -6268,7 +6316,8 @@
           EditorDOMPoint::After(mEmptyInclusiveAncestorBlockElement));
       MOZ_ASSERT(afterEmptyBlock.IsSet());
       if (nsIContent* nextContentOfEmptyBlock = HTMLEditUtils::GetNextContent(
-              afterEmptyBlock, {}, aHTMLEditor.ComputeEditingHost())) {
+              afterEmptyBlock, {}, BlockInlineCheck::Unused,
+              aHTMLEditor.ComputeEditingHost())) {
         EditorDOMPoint pt = HTMLEditUtils::GetGoodCaretPointFor<EditorDOMPoint>(
             *nextContentOfEmptyBlock, aDirectionAndAmount);
         if (!pt.IsSet()) {
@@ -6291,7 +6340,7 @@
       if (nsIContent* previousContentOfEmptyBlock =
               HTMLEditUtils::GetPreviousContent(
                   atEmptyBlock, {WalkTreeOption::IgnoreNonEditableNode},
-                  aHTMLEditor.ComputeEditingHost())) {
+                  BlockInlineCheck::Unused, aHTMLEditor.ComputeEditingHost())) {
         EditorDOMPoint pt = HTMLEditUtils::GetGoodCaretPointFor<EditorDOMPoint>(
             *previousContentOfEmptyBlock, aDirectionAndAmount);
         if (!pt.IsSet()) {
@@ -6471,7 +6520,8 @@
   // because the following code checks editing host too.
   const Element* const maybeNonEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
-          *commonAncestor, HTMLEditUtils::ClosestBlockElement);
+          *commonAncestor, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
   if (NS_WARN_IF(!maybeNonEditableBlockElement)) {
     return Err(NS_ERROR_FAILURE);
   }
@@ -6516,12 +6566,14 @@
     for (;;) {
       WSScanResult backwardScanFromStartResult =
           WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
-              editingHost, rangeToDelete.StartRef());
+              editingHost, rangeToDelete.StartRef(),
+              BlockInlineCheck::UseComputedDisplayOutsideStyle);
       if (!backwardScanFromStartResult.ReachedCurrentBlockBoundary()) {
         break;
       }
       MOZ_ASSERT(backwardScanFromStartResult.GetContent() ==
-                 WSRunScanner(editingHost, rangeToDelete.StartRef())
+                 WSRunScanner(editingHost, rangeToDelete.StartRef(),
+                              BlockInlineCheck::UseComputedDisplayOutsideStyle)
                      .GetStartReasonContent());
       // We want to keep looking up.  But stop if we are crossing table
       // element boundaries, or if we hit the root.
@@ -6559,7 +6611,9 @@
   if (rangeToDelete.EndRef().GetContainer() != maybeNonEditableBlockElement &&
       rangeToDelete.EndRef().GetContainer() != editingHost) {
     for (;;) {
-      WSRunScanner wsScannerAtEnd(editingHost, rangeToDelete.EndRef());
+      WSRunScanner wsScannerAtEnd(
+          editingHost, rangeToDelete.EndRef(),
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
       WSScanResult forwardScanFromEndResult =
           wsScannerAtEnd.ScanNextVisibleNodeOrBlockBoundaryFrom(
               rangeToDelete.EndRef());
@@ -6630,7 +6684,8 @@
     if (const RefPtr<const Element> editableBlockContainingBRElement =
             HTMLEditUtils::GetInclusiveAncestorElement(
                 *atFirstInvisibleBRElement.ContainerAs<nsIContent>(),
-                HTMLEditUtils::ClosestEditableBlockElement)) {
+                HTMLEditUtils::ClosestEditableBlockElement,
+                BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       if (rangeToDelete.Contains(
               EditorRawDOMPoint(editableBlockContainingBRElement))) {
         return rangeToDelete;