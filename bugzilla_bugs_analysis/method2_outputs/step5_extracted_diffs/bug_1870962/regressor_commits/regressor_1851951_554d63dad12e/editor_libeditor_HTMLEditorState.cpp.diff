# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditorState.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLEditorState.cpp
--- a/editor/libeditor/HTMLEditorState.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLEditorState.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -283,14 +283,14 @@
            atStartOfSelection.Offset() == atBodyOrDocumentElement.Offset()) {
     editTargetContent = HTMLEditUtils::GetNextContent(
         atStartOfSelection, {WalkTreeOption::IgnoreNonEditableNode},
-        aHTMLEditor.ComputeEditingHost());
+        BlockInlineCheck::Unused, aHTMLEditor.ComputeEditingHost());
     if (NS_WARN_IF(!editTargetContent)) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
   }
   // Otherwise, use first selected node.
-  // XXX Only for retreiving it, the following block treats all selected
+  // XXX Only for retrieving it, the following block treats all selected
   //     ranges.  `HTMLEditor` should have
   //     `GetFirstSelectionRangeExtendedToHardLineStartAndEnd()`.
   else {
@@ -330,7 +330,8 @@
 
   const RefPtr<dom::Element> maybeNonEditableBlockElement =
       HTMLEditUtils::GetInclusiveAncestorElement(
-          *editTargetContent, HTMLEditUtils::ClosestBlockElement);
+          *editTargetContent, HTMLEditUtils::ClosestBlockElement,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   if (NS_WARN_IF(!maybeNonEditableBlockElement)) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
@@ -487,10 +488,10 @@
   // We need to append descendant format block if block nodes are not format
   // block.  This is so we only have to look "up" the hierarchy to find
   // format nodes, instead of both up and down.
-  for (int32_t i = arrayOfContents.Length() - 1; i >= 0; i--) {
-    auto& content = arrayOfContents[i];
-    nsAutoString format;
-    if (HTMLEditUtils::IsBlockElement(content) &&
+  for (size_t index : Reversed(IntegerRange(arrayOfContents.Length()))) {
+    OwningNonNull<nsIContent>& content = arrayOfContents[index];
+    if (HTMLEditUtils::IsBlockElement(content,
+                                      BlockInlineCheck::UseHTMLDefaultStyle) &&
         !HTMLEditUtils::IsFormatNode(content)) {
       // XXX This RemoveObject() call has already been commented out and
       //     the above comment explained we're trying to replace non-format
@@ -527,9 +528,10 @@
       MOZ_ASSERT(content->NodeInfo()->NameAtom());
       paragraphStateOfNode = content->NodeInfo()->NameAtom();
     }
-    // Ignore non-format block node since its children have been appended
+    // Ignore inline contents since its children have been appended
     // the list above so that we'll handle this descendants later.
-    else if (HTMLEditUtils::IsBlockElement(content)) {
+    else if (HTMLEditUtils::IsBlockElement(
+                 content, BlockInlineCheck::UseHTMLDefaultStyle)) {
       continue;
     }
     // If we meet an inline node, let's get its parent format.
@@ -566,7 +568,8 @@
 void ParagraphStateAtSelection::AppendDescendantFormatNodesAndFirstInlineNode(
     nsTArray<OwningNonNull<nsIContent>>& aArrayOfContents,
     dom::Element& aNonFormatBlockElement) {
-  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(aNonFormatBlockElement));
+  MOZ_ASSERT(HTMLEditUtils::IsBlockElement(
+      aNonFormatBlockElement, BlockInlineCheck::UseHTMLDefaultStyle));
   MOZ_ASSERT(!HTMLEditUtils::IsFormatNode(&aNonFormatBlockElement));
 
   // We only need to place any one inline inside this node onto
@@ -576,8 +579,9 @@
   bool foundInline = false;
   for (nsIContent* childContent = aNonFormatBlockElement.GetFirstChild();
        childContent; childContent = childContent->GetNextSibling()) {
-    bool isBlock = HTMLEditUtils::IsBlockElement(*childContent);
-    bool isFormat = HTMLEditUtils::IsFormatNode(childContent);
+    const bool isBlock = HTMLEditUtils::IsBlockElement(
+        *childContent, BlockInlineCheck::UseHTMLDefaultStyle);
+    const bool isFormat = HTMLEditUtils::IsFormatNode(childContent);
     // If the child is a non-format block element, let's check its children
     // recursively.
     if (isBlock && !isFormat) {
@@ -627,12 +631,12 @@
   }
 
   // Pre-process our list of nodes
-  for (int32_t i = aArrayOfContents.Length() - 1; i >= 0; i--) {
-    OwningNonNull<nsIContent> content = aArrayOfContents[i];
+  for (size_t index : Reversed(IntegerRange(aArrayOfContents.Length()))) {
+    OwningNonNull<nsIContent> content = aArrayOfContents[index];
 
     // Remove all non-editable nodes.  Leave them be.
     if (!EditorUtils::IsEditableContent(content, EditorType::HTML)) {
-      aArrayOfContents.RemoveElementAt(i);
+      aArrayOfContents.RemoveElementAt(index);
       continue;
     }
 
@@ -642,9 +646,9 @@
     if (HTMLEditUtils::IsAnyTableElement(content) ||
         HTMLEditUtils::IsAnyListElement(content) ||
         HTMLEditUtils::IsListItem(content)) {
-      aArrayOfContents.RemoveElementAt(i);
+      aArrayOfContents.RemoveElementAt(index);
       HTMLEditUtils::CollectChildren(
-          content, aArrayOfContents, i,
+          content, aArrayOfContents, index,
           {CollectChildrenOption::CollectListChildren,
            CollectChildrenOption::CollectTableChildren});
     }