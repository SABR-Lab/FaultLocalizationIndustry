# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLStyleEditor.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/HTMLStyleEditor.cpp
--- a/editor/libeditor/HTMLStyleEditor.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/HTMLStyleEditor.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -768,7 +768,9 @@
   // E.g., we don't want to create new <span> when
   // `<p>{  <span>abc</span>  }</p>`.
   if (aStyledElement.GetParentElement() &&
-      HTMLEditUtils::IsBlockElement(*aStyledElement.GetParentElement())) {
+      HTMLEditUtils::IsBlockElement(
+          *aStyledElement.GetParentElement(),
+          BlockInlineCheck::UseComputedDisplayStyle)) {
     for (nsIContent* previousSibling = aStyledElement.GetPreviousSibling();
          previousSibling;
          previousSibling = previousSibling->GetPreviousSibling()) {
@@ -1499,7 +1501,9 @@
       if (parent == aLimiter ||
           !EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
           (parent->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*parent->AsElement()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *parent->AsElement(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(*parent->AsElement())))) {
         return nullptr;
       }
@@ -1512,7 +1516,9 @@
   return nextContentInRange &&
                  EditorUtils::IsEditableContent(*nextContentInRange,
                                                 EditorType::HTML) &&
-                 !HTMLEditUtils::IsBlockElement(*nextContentInRange)
+                 !HTMLEditUtils::IsBlockElement(
+                     *nextContentInRange,
+                     BlockInlineCheck::UseComputedDisplayOutsideStyle)
              ? nextContentInRange
              : nullptr;
 }
@@ -1525,7 +1531,9 @@
       if (parent == aLimiter ||
           !EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
           (parent->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*parent->AsElement()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *parent->AsElement(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(*parent->AsElement())))) {
         return nullptr;
       }
@@ -1538,7 +1546,9 @@
   return previousContentInRange &&
                  EditorUtils::IsEditableContent(*previousContentInRange,
                                                 EditorType::HTML) &&
-                 !HTMLEditUtils::IsBlockElement(*previousContentInRange)
+                 !HTMLEditUtils::IsBlockElement(
+                     *previousContentInRange,
+                     BlockInlineCheck::UseComputedDisplayOutsideStyle)
              ? previousContentInRange
              : nullptr;
 }
@@ -1581,7 +1591,8 @@
   while (nsIContent* child = startPoint.GetChild()) {
     // We shouldn't cross editable and block boundary.
     if (!EditorUtils::IsEditableContent(*child, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       break;
     }
     // If we reach a text node, the minimized range starts from start of it.
@@ -1654,7 +1665,8 @@
   while (nsIContent* child = endPoint.GetPreviousSiblingOfChild()) {
     // We shouldn't cross editable and block boundary.
     if (!EditorUtils::IsEditableContent(*child, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*child)) {
+        HTMLEditUtils::IsBlockElement(
+            *child, BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       break;
     }
     // If we reach a text node, the minimized range starts from start of it.
@@ -1712,7 +1724,8 @@
   for (Element* parent :
        startPoint.GetContainer()->InclusiveAncestorsOfType<Element>()) {
     if (!EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*parent) ||
+        HTMLEditUtils::IsBlockElement(
+            *parent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         HTMLEditUtils::IsDisplayInsideFlowRoot(*parent)) {
       break;
     }
@@ -1757,7 +1770,8 @@
   for (Element* parent :
        endPoint.GetContainer()->InclusiveAncestorsOfType<Element>()) {
     if (!EditorUtils::IsEditableContent(*parent, EditorType::HTML) ||
-        HTMLEditUtils::IsBlockElement(*parent) ||
+        HTMLEditUtils::IsBlockElement(
+            *parent, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
         HTMLEditUtils::IsDisplayInsideFlowRoot(*parent)) {
       break;
     }
@@ -1800,7 +1814,8 @@
               *aStartPoint.ContainerAs<nsIContent>(), EditorType::HTML) ||
           (aStartPoint.ContainerAs<nsIContent>()->IsElement() &&
            (HTMLEditUtils::IsBlockElement(
-                *aStartPoint.ContainerAs<Element>()) ||
+                *aStartPoint.ContainerAs<Element>(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(
                 *aStartPoint.ContainerAs<Element>())))) {
         break;
@@ -1813,7 +1828,9 @@
       if (!EditorUtils::IsEditableContent(*aEndPoint.ContainerAs<nsIContent>(),
                                           EditorType::HTML) ||
           (aEndPoint.ContainerAs<nsIContent>()->IsElement() &&
-           (HTMLEditUtils::IsBlockElement(*aEndPoint.ContainerAs<Element>()) ||
+           (HTMLEditUtils::IsBlockElement(
+                *aEndPoint.ContainerAs<Element>(),
+                BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
             HTMLEditUtils::IsDisplayInsideFlowRoot(
                 *aEndPoint.ContainerAs<Element>())))) {
         break;
@@ -1862,7 +1879,8 @@
              *aStartPoint.ChildAs<nsStyledElement>())) &&
         // but don't cross block boundary at climbing up the tree
         !HTMLEditUtils::IsBlockElement(
-            *aStartPoint.ContainerAs<nsIContent>()) &&
+            *aStartPoint.ContainerAs<nsIContent>(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
         // and the container is a good editable element to set CSS style
         aStartPoint.GetContainerAs<nsStyledElement>() &&
         ElementIsGoodContainerToSetStyle(
@@ -1879,7 +1897,9 @@
          !ElementIsGoodContainerToSetStyle(
              *aEndPoint.GetPreviousSiblingOfChildAs<nsStyledElement>())) &&
         // but don't cross block boundary at climbing up the tree
-        !HTMLEditUtils::IsBlockElement(*aEndPoint.ContainerAs<nsIContent>()) &&
+        !HTMLEditUtils::IsBlockElement(
+            *aEndPoint.ContainerAs<nsIContent>(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle) &&
         // and the container is a good editable element to set CSS style
         aEndPoint.GetContainerAs<nsStyledElement>() &&
         ElementIsGoodContainerToSetStyle(
@@ -1913,12 +1933,14 @@
   EditorDOMRange range(aRange);
   if (range.EndRef().IsInContentNode()) {
     WSScanResult nextContentData =
-        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(&aEditingHost,
-                                                         range.EndRef());
+        WSRunScanner::ScanNextVisibleNodeOrBlockBoundary(
+            &aEditingHost, range.EndRef(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
     if (nextContentData.ReachedInvisibleBRElement() &&
         nextContentData.BRElementPtr()->GetParentElement() &&
-        HTMLEditUtils::IsInlineElement(
-            *nextContentData.BRElementPtr()->GetParentElement())) {
+        HTMLEditUtils::IsInlineContent(
+            *nextContentData.BRElementPtr()->GetParentElement(),
+            BlockInlineCheck::UseComputedDisplayOutsideStyle)) {
       range.SetEnd(EditorDOMPoint::After(*nextContentData.BRElementPtr()));
       MOZ_ASSERT(range.EndRef().IsSet());
     }
@@ -2123,7 +2145,9 @@
   AutoTArray<OwningNonNull<Element>, 24> arrayOfParents;
   for (Element* element :
        aPointToSplit.GetContainer()->InclusiveAncestorsOfType<Element>()) {
-    if (HTMLEditUtils::IsBlockElement(*element) || !element->GetParent() ||
+    if (HTMLEditUtils::IsBlockElement(
+            *element, BlockInlineCheck::UseComputedDisplayOutsideStyle) ||
+        !element->GetParent() ||
         !EditorUtils::IsEditableContent(*element->GetParent(),
                                         EditorType::HTML)) {
       break;
@@ -2529,7 +2553,8 @@
             emptyInlineContainerElements,
             {EmptyCheckOption::TreatSingleBRElementAsVisible,
              EmptyCheckOption::TreatListItemAsVisible,
-             EmptyCheckOption::TreatTableCellAsVisible});
+             EmptyCheckOption::TreatTableCellAsVisible},
+            BlockInlineCheck::UseComputedDisplayOutsideStyle);
         for (const OwningNonNull<nsIContent>& emptyInlineContainerElement :
              emptyInlineContainerElements) {
           // MOZ_KnownLive(emptyInlineContainerElement) due to bug 1622253.