# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/WSRunObject.h
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/libeditor/WSRunObject.h
--- a/editor/libeditor/WSRunObject.h	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/libeditor/WSRunObject.h	Wed Sep 27 03:01:26 2023 +0000
@@ -11,8 +11,8 @@
 #include "EditorForwards.h"
 #include "EditorDOMPoint.h"  // for EditorDOMPoint
 #include "EditorUtils.h"     // for CaretPoint
+#include "HTMLEditHelpers.h"
 #include "HTMLEditor.h"
-
 #include "HTMLEditUtils.h"
 
 #include "mozilla/Assertions.h"
@@ -93,19 +93,22 @@
 
  public:
   WSScanResult() = delete;
-  MOZ_NEVER_INLINE_DEBUG WSScanResult(nsIContent* aContent, WSType aReason)
+  MOZ_NEVER_INLINE_DEBUG WSScanResult(nsIContent* aContent, WSType aReason,
+                                      BlockInlineCheck aBlockInlineCheck)
       : mContent(aContent), mReason(aReason) {
-    AssertIfInvalidData();
+    AssertIfInvalidData(aBlockInlineCheck);
   }
   MOZ_NEVER_INLINE_DEBUG WSScanResult(const EditorDOMPoint& aPoint,
-                                      WSType aReason)
+                                      WSType aReason,
+                                      BlockInlineCheck aBlockInlineCheck)
       : mContent(aPoint.GetContainerAs<nsIContent>()),
         mOffset(Some(aPoint.Offset())),
         mReason(aReason) {
-    AssertIfInvalidData();
+    AssertIfInvalidData(aBlockInlineCheck);
   }
 
-  MOZ_NEVER_INLINE_DEBUG void AssertIfInvalidData() const {
+  MOZ_NEVER_INLINE_DEBUG void AssertIfInvalidData(
+      BlockInlineCheck aBlockInlineCheck) const {
 #ifdef DEBUG
     MOZ_ASSERT(mReason == WSType::UnexpectedError ||
                mReason == WSType::NonCollapsibleCharacters ||
@@ -126,11 +129,13 @@
                       EditorUtils::IsNewLinePreformatted(*mContent));
     MOZ_ASSERT_IF(
         mReason == WSType::SpecialContent,
-        mContent && ((mContent->IsText() && !mContent->IsEditable()) ||
-                     (!mContent->IsHTMLElement(nsGkAtoms::br) &&
-                      !HTMLEditUtils::IsBlockElement(*mContent))));
+        mContent &&
+            ((mContent->IsText() && !mContent->IsEditable()) ||
+             (!mContent->IsHTMLElement(nsGkAtoms::br) &&
+              !HTMLEditUtils::IsBlockElement(*mContent, aBlockInlineCheck))));
     MOZ_ASSERT_IF(mReason == WSType::OtherBlockBoundary,
-                  mContent && HTMLEditUtils::IsBlockElement(*mContent));
+                  mContent && HTMLEditUtils::IsBlockElement(*mContent,
+                                                            aBlockInlineCheck));
     // If mReason is WSType::CurrentBlockBoundary, mContent can be any content.
     // In most cases, it's current block element which is editable.  However, if
     // there is no editable block parent, this is topmost editable inline
@@ -139,8 +144,9 @@
     MOZ_ASSERT_IF(
         mReason == WSType::CurrentBlockBoundary,
         !mContent || !mContent->GetParentElement() ||
-            HTMLEditUtils::IsBlockElement(*mContent) ||
-            HTMLEditUtils::IsBlockElement(*mContent->GetParentElement()) ||
+            HTMLEditUtils::IsBlockElement(*mContent, aBlockInlineCheck) ||
+            HTMLEditUtils::IsBlockElement(*mContent->GetParentElement(),
+                                          aBlockInlineCheck) ||
             !mContent->GetParentElement()->IsEditable());
 #endif  // #ifdef DEBUG
   }
@@ -324,10 +330,13 @@
 
   template <typename EditorDOMPointType>
   WSRunScanner(const Element* aEditingHost,
-               const EditorDOMPointType& aScanStartPoint)
+               const EditorDOMPointType& aScanStartPoint,
+               BlockInlineCheck aBlockInlineCheck)
       : mScanStartPoint(aScanStartPoint.template To<EditorDOMPoint>()),
         mEditingHost(const_cast<Element*>(aEditingHost)),
-        mTextFragmentDataAtStart(mScanStartPoint, mEditingHost) {}
+        mTextFragmentDataAtStart(mScanStartPoint, mEditingHost,
+                                 aBlockInlineCheck),
+        mBlockInlineCheck(aBlockInlineCheck) {}
 
   // ScanNextVisibleNodeOrBlockBoundaryForwardFrom() returns the first visible
   // node after aPoint.  If there is no visible nodes after aPoint, returns
@@ -338,8 +347,9 @@
       const EditorDOMPointBase<PT, CT>& aPoint) const;
   template <typename PT, typename CT>
   static WSScanResult ScanNextVisibleNodeOrBlockBoundary(
-      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
-    return WSRunScanner(aEditingHost, aPoint)
+      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .ScanNextVisibleNodeOrBlockBoundaryFrom(aPoint);
   }
 
@@ -352,8 +362,9 @@
       const EditorDOMPointBase<PT, CT>& aPoint) const;
   template <typename PT, typename CT>
   static WSScanResult ScanPreviousVisibleNodeOrBlockBoundary(
-      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
-    return WSRunScanner(aEditingHost, aPoint)
+      const Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .ScanPreviousVisibleNodeOrBlockBoundaryFrom(aPoint);
   }
 
@@ -365,14 +376,15 @@
   template <typename EditorDOMPointType = EditorDOMPointInText, typename PT,
             typename CT>
   static EditorDOMPointType GetInclusiveNextEditableCharPoint(
-      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
+      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     if (aPoint.IsInTextNode() && !aPoint.IsEndOfContainer() &&
         HTMLEditUtils::IsSimplyEditableNode(
             *aPoint.template ContainerAs<Text>())) {
       return EditorDOMPointType(aPoint.template ContainerAs<Text>(),
                                 aPoint.Offset());
     }
-    return WSRunScanner(aEditingHost, aPoint)
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .GetInclusiveNextEditableCharPoint<EditorDOMPointType>(aPoint);
   }
 
@@ -383,14 +395,15 @@
   template <typename EditorDOMPointType = EditorDOMPointInText, typename PT,
             typename CT>
   static EditorDOMPointType GetPreviousEditableCharPoint(
-      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint) {
+      Element* aEditingHost, const EditorDOMPointBase<PT, CT>& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     if (aPoint.IsInTextNode() && !aPoint.IsStartOfContainer() &&
         HTMLEditUtils::IsSimplyEditableNode(
             *aPoint.template ContainerAs<Text>())) {
       return EditorDOMPointType(aPoint.template ContainerAs<Text>(),
                                 aPoint.Offset() - 1);
     }
-    return WSRunScanner(aEditingHost, aPoint)
+    return WSRunScanner(aEditingHost, aPoint, aBlockInlineCheck)
         .GetPreviousEditableCharPoint<EditorDOMPointType>(aPoint);
   }
 
@@ -483,7 +496,8 @@
   template <typename EditorDOMPointType>
   MOZ_NEVER_INLINE_DEBUG static HTMLBRElement*
   GetPrecedingBRElementUnlessVisibleContentFound(
-      Element* aEditingHost, const EditorDOMPointType& aPoint) {
+      Element* aEditingHost, const EditorDOMPointType& aPoint,
+      BlockInlineCheck aBlockInlineCheck) {
     MOZ_ASSERT(aPoint.IsSetAndValid());
     // XXX This method behaves differently even in similar point.
     //     If aPoint is in a text node following `<br>` element, reaches the
@@ -497,7 +511,7 @@
     }
     // TODO: Scan for end boundary is redundant in this case, we should optimize
     //       it.
-    TextFragmentData textFragmentData(aPoint, aEditingHost);
+    TextFragmentData textFragmentData(aPoint, aEditingHost, aBlockInlineCheck);
     return textFragmentData.StartsFromBRElement()
                ? textFragmentData.StartReasonBRElementPtr()
                : nullptr;
@@ -819,7 +833,8 @@
       static BoundaryData ScanCollapsibleWhiteSpaceStartFrom(
           const EditorDOMPointType& aPoint,
           const Element& aEditableBlockParentOrTopmostEditableInlineElement,
-          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData);
+          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
       /**
        * ScanCollapsibleWhiteSpaceEndFrom() returns end boundary data of
@@ -840,9 +855,10 @@
       static BoundaryData ScanCollapsibleWhiteSpaceEndFrom(
           const EditorDOMPointType& aPoint,
           const Element& aEditableBlockParentOrTopmostEditableInlineElement,
-          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData);
+          const Element* aEditingHost, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
-      BoundaryData() : mReason(WSType::NotInitialized) {}
+      BoundaryData() = default;
       template <typename EditorDOMPointType>
       BoundaryData(const EditorDOMPointType& aPoint, nsIContent& aReasonContent,
                    WSType aReason)
@@ -898,10 +914,12 @@
        */
       template <typename EditorDOMPointType>
       static Maybe<BoundaryData> ScanCollapsibleWhiteSpaceStartInTextNode(
-          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData);
+          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
       template <typename EditorDOMPointType>
       static Maybe<BoundaryData> ScanCollapsibleWhiteSpaceEndInTextNode(
-          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData);
+          const EditorDOMPointType& aPoint, NoBreakingSpaceData* aNBSPData,
+          BlockInlineCheck aBlockInlineCheck);
 
       nsCOMPtr<nsIContent> mReasonContent;
       EditorDOMPoint mPoint;
@@ -909,7 +927,7 @@
       // WSType::NonCollapsibleCharacters, WSType::SpecialContent,
       // WSType::BRElement, WSType::CurrentBlockBoundary or
       // WSType::OtherBlockBoundary.
-      WSType mReason;
+      WSType mReason = WSType::NotInitialized;
     };
 
     class MOZ_STACK_CLASS NoBreakingSpaceData final {
@@ -943,8 +961,14 @@
    public:
     TextFragmentData() = delete;
     template <typename EditorDOMPointType>
+    TextFragmentData(const WSRunScanner& aWSRunScanner,
+                     const EditorDOMPointType& aPoint)
+        : TextFragmentData(aPoint, aWSRunScanner.mEditingHost,
+                           aWSRunScanner.mBlockInlineCheck) {}
+    template <typename EditorDOMPointType>
     TextFragmentData(const EditorDOMPointType& aPoint,
-                     const Element* aEditingHost);
+                     const Element* aEditingHost,
+                     BlockInlineCheck aBlockInlineCheck);
 
     bool IsInitialized() const {
       return mStart.Initialized() && mEnd.Initialized();
@@ -1298,6 +1322,7 @@
     mutable Maybe<EditorDOMRange> mLeadingWhiteSpaceRange;
     mutable Maybe<EditorDOMRange> mTrailingWhiteSpaceRange;
     mutable Maybe<VisibleWhiteSpacesData> mVisibleWhiteSpacesData;
+    BlockInlineCheck mBlockInlineCheck;
   };
 
   const TextFragmentData& TextFragmentDataAtStartRef() const {
@@ -1329,6 +1354,8 @@
 
   TextFragmentData mTextFragmentDataAtStart;
 
+  const BlockInlineCheck mBlockInlineCheck;
+
   friend class WhiteSpaceVisibilityKeeper;
 };
 