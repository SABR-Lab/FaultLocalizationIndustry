# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/spellchecker/TextServicesDocument.cpp
# Commit: 554d63dad12e
# Full Hash: 554d63dad12e4d1f2560e99de1fafac9a97da026
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-09-27 09:02:41
# Regressor Bug: 1851951
# File Overlap Count: 1
# Description:
#   Bug 1851951 - Make `HTMLEditor` refer computed `display` instead of the HTML default style at considering block or inline element r=m_kato
#   
#   Blink [1] and WebKit [2] refers `display-outside` value when they consider whether an
#   element is a block or an inline.
#   
# ==============================================================================

diff -r 97dc7be3b93c -r 554d63dad12e editor/spellchecker/TextServicesDocument.cpp
--- a/editor/spellchecker/TextServicesDocument.cpp	Wed Sep 27 02:50:33 2023 +0000
+++ b/editor/spellchecker/TextServicesDocument.cpp	Wed Sep 27 03:01:26 2023 +0000
@@ -8,6 +8,7 @@
 #include "EditorBase.h"               // for EditorBase
 #include "EditorUtils.h"              // for AutoTransactionBatchExternal
 #include "FilteredContentIterator.h"  // for FilteredContentIterator
+#include "HTMLEditHelpers.h"          // for BlockInlineCheck
 #include "HTMLEditUtils.h"            // for HTMLEditUtils
 #include "JoinSplitNodeDirection.h"   // for JoinNodesDirection
 
@@ -1653,11 +1654,13 @@
   const Element* editableBlockElementOrInlineEditingHost1 =
       HTMLEditUtils::GetAncestorElement(
           aTextNode1,
-          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost);
+          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   const Element* editableBlockElementOrInlineEditingHost2 =
       HTMLEditUtils::GetAncestorElement(
           aTextNode2,
-          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost);
+          HTMLEditUtils::ClosestEditableBlockElementOrInlineEditingHost,
+          BlockInlineCheck::UseHTMLDefaultStyle);
   return editableBlockElementOrInlineEditingHost1 &&
          editableBlockElementOrInlineEditingHost1 ==
              editableBlockElementOrInlineEditingHost2;
@@ -2307,8 +2310,11 @@
         aFilteredIter->GetCurrentNode()->IsContent()
             ? aFilteredIter->GetCurrentNode()->AsContent()
             : nullptr;
+    // We don't observe layout updates, therefore, we should consider whether
+    // block or inline only with the default definition of the element.
     if (lastTextNode && content &&
-        (HTMLEditUtils::IsBlockElement(*content) ||
+        (HTMLEditUtils::IsBlockElement(*content,
+                                       BlockInlineCheck::UseHTMLDefaultStyle) ||
          content->IsHTMLElement(nsGkAtoms::br))) {
       break;
     }
@@ -2387,9 +2393,13 @@
           break;
         }
         previousTextNode = content->AsText();
-      } else if (!crossedBlockBoundary &&
-                 (HTMLEditUtils::IsBlockElement(*content) ||
-                  content->IsHTMLElement(nsGkAtoms::br))) {
+      }
+      // We don't observe layout updates, therefore, we should consider whether
+      // block or inline only with the default definition of the element.
+      else if (!crossedBlockBoundary &&
+               (HTMLEditUtils::IsBlockElement(
+                    *content, BlockInlineCheck::UseHTMLDefaultStyle) ||
+                content->IsHTMLElement(nsGkAtoms::br))) {
         crossedBlockBoundary = true;
       }
     }
@@ -2517,7 +2527,10 @@
             aFilteredIter.GetCurrentNode()->IsContent()
                 ? aFilteredIter.GetCurrentNode()->AsContent()
                 : nullptr) {
-      if (HTMLEditUtils::IsBlockElement(*content) ||
+      // We don't observe layout updates, therefore, we should consider whether
+      // block or inline only with the default definition of the element.
+      if (HTMLEditUtils::IsBlockElement(
+              *content, BlockInlineCheck::UseHTMLDefaultStyle) ||
           content->IsHTMLElement(nsGkAtoms::br)) {
         break;
       }