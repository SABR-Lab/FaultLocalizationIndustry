# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/animation/KeyframeEffect.cpp
# Commit: 63603267402e
# Full Hash: 63603267402ee93d6551ef60c35191d99aaee06b
# Author: Zach Hoffman <zach@zrhoffman.net>
# Date: 2023-12-18 17:17:57
# Regressor Bug: 1846516
# File Overlap Count: 3
# Description:
#   Bug 1846516 - [css-properties-values-api] Introduce AnimatedPropertyID/AnimatedPropertIDSet. r=firefox-animation-reviewers,firefox-style-system-reviewers,layout-reviewers,emilio,hiro
#   
#   This will make possible to animate custom properties on Gecko side. For now, the
#   animation code keeps only dealing with nsCSSPropertyID, so behavior is unchanged.
#   
# ==============================================================================

diff -r 753bc39f59ff -r 63603267402e dom/animation/KeyframeEffect.cpp
--- a/dom/animation/KeyframeEffect.cpp	Mon Dec 18 09:24:07 2023 +0000
+++ b/dom/animation/KeyframeEffect.cpp	Mon Dec 18 09:24:08 2023 +0000
@@ -288,7 +288,7 @@
   // Check that the value we are about to substitute in is actually for the
   // same property.
   if (Servo_AnimationValue_GetPropertyId(aStartValue.mServo) !=
-      mProperties[0].mProperty) {
+      mProperties[0].mProperty.mID) {
     return;
   }
 
@@ -309,14 +309,14 @@
                                                     mTarget.mPseudoType));
 
   for (const AnimationProperty& property : mProperties) {
-    if (aProperty != property.mProperty) {
+    if (aProperty != property.mProperty.mID) {
       continue;
     }
 
     const AnimationProperty* result = nullptr;
     // Only include the property if it is not overridden by !important rules in
     // the transitions level.
-    if (IsEffectiveProperty(aEffects, property.mProperty)) {
+    if (IsEffectiveProperty(aEffects, property.mProperty.mID)) {
       result = &property;
     }
     return result;
@@ -327,8 +327,8 @@
 bool KeyframeEffect::HasEffectiveAnimationOfPropertySet(
     const nsCSSPropertyIDSet& aPropertySet, const EffectSet& aEffectSet) const {
   for (const AnimationProperty& property : mProperties) {
-    if (aPropertySet.HasProperty(property.mProperty) &&
-        IsEffectiveProperty(aEffectSet, property.mProperty)) {
+    if (aPropertySet.HasProperty(property.mProperty.mID) &&
+        IsEffectiveProperty(aEffectSet, property.mProperty.mID)) {
       return true;
     }
   }
@@ -355,26 +355,27 @@
   AnimationPerformanceWarning::Type dummyWarning;
 
   for (const AnimationProperty& property : mProperties) {
-    if (!compositorAnimatables.HasProperty(property.mProperty)) {
+    if (!compositorAnimatables.HasProperty(property.mProperty.mID)) {
       continue;
     }
 
     // Transform-like properties are combined together on the compositor so we
     // need to evaluate them as a group. We build up a separate set here then
     // evaluate it as a separate step below.
-    if (transformLikeProperties.HasProperty(property.mProperty)) {
-      transformSet.AddProperty(property.mProperty);
+    if (transformLikeProperties.HasProperty(property.mProperty.mID)) {
+      transformSet.AddProperty(property.mProperty.mID);
       continue;
     }
 
-    KeyframeEffect::MatchForCompositor matchResult = IsMatchForCompositor(
-        nsCSSPropertyIDSet{property.mProperty}, aFrame, aEffects, dummyWarning);
+    KeyframeEffect::MatchForCompositor matchResult =
+        IsMatchForCompositor(nsCSSPropertyIDSet{property.mProperty.mID}, aFrame,
+                             aEffects, dummyWarning);
     if (matchResult ==
             KeyframeEffect::MatchForCompositor::NoAndBlockThisProperty ||
         matchResult == KeyframeEffect::MatchForCompositor::No) {
       continue;
     }
-    properties.AddProperty(property.mProperty);
+    properties.AddProperty(property.mProperty.mID);
   }
 
   if (!transformSet.IsEmpty()) {
@@ -389,8 +390,8 @@
   return properties;
 }
 
-nsCSSPropertyIDSet KeyframeEffect::GetPropertySet() const {
-  nsCSSPropertyIDSet result;
+AnimatedPropertyIDSet KeyframeEffect::GetPropertySet() const {
+  AnimatedPropertyIDSet result;
 
   for (const AnimationProperty& property : mProperties) {
     result.AddProperty(property.mProperty);
@@ -455,7 +456,7 @@
 
   for (const AnimationProperty& property : mProperties) {
     if (property.mIsRunningOnCompositor) {
-      runningOnCompositorProperties.AddProperty(property.mProperty);
+      runningOnCompositorProperties.AddProperty(property.mProperty.mID);
     }
   }
 
@@ -465,7 +466,7 @@
   mCumulativeChanges = {};
   for (AnimationProperty& property : mProperties) {
     property.mIsRunningOnCompositor =
-        runningOnCompositorProperties.HasProperty(property.mProperty);
+        runningOnCompositorProperties.HasProperty(property.mProperty.mID);
     CalculateCumulativeChangesForProperty(property);
   }
 
@@ -551,7 +552,7 @@
         // delay on the compositor.
         return aTimeline && aTimeline->IsScrollTimeline() &&
                nsCSSPropertyIDSet::CompositorAnimatables().HasProperty(
-                   aProperty.mProperty) &&
+                   aProperty.mProperty.mID) &&
                (timing.Delay() > zeroDuration ||
                 timing.EndDelay() > zeroDuration);
       };
@@ -586,9 +587,9 @@
   }
   RefPtr<StyleAnimationValue> baseValue =
       Servo_ComputedValues_ExtractAnimationValue(aBaseComputedStyle,
-                                                 aProperty.mProperty)
+                                                 aProperty.mProperty.mID)
           .Consume();
-  mBaseValues.InsertOrUpdate(aProperty.mProperty, std::move(baseValue));
+  mBaseValues.InsertOrUpdate(aProperty.mProperty.mID, std::move(baseValue));
 }
 
 void KeyframeEffect::WillComposeStyle() {
@@ -603,9 +604,10 @@
                                       const ComputedTiming& aComputedTiming) {
   auto* opaqueTable =
       reinterpret_cast<RawServoAnimationValueTable*>(&mBaseValues);
-  Servo_AnimationCompose(&aAnimationValues, opaqueTable, aProperty.mProperty,
-                         &aSegment, &aProperty.mSegments.LastElement(),
-                         &aComputedTiming, mEffectOptions.mIterationComposite);
+  Servo_AnimationCompose(&aAnimationValues, opaqueTable,
+                         aProperty.mProperty.mID, &aSegment,
+                         &aProperty.mSegments.LastElement(), &aComputedTiming,
+                         mEffectOptions.mIterationComposite);
 }
 
 void KeyframeEffect::ComposeStyle(StyleAnimationValueMap& aComposeResult,
@@ -626,7 +628,7 @@
     MOZ_ASSERT(prop.mSegments[prop.mSegments.Length() - 1].mToKey == 1.0,
                "incorrect last to key");
 
-    if (aPropertiesToSkip.HasProperty(prop.mProperty)) {
+    if (aPropertiesToSkip.HasProperty(prop.mProperty.mID)) {
       continue;
     }
 
@@ -690,7 +692,7 @@
       "Property being animated on compositor is a recognized "
       "compositor-animatable property");
   for (AnimationProperty& property : mProperties) {
-    if (property.mProperty == aProperty) {
+    if (property.mProperty.mID == aProperty) {
       property.mIsRunningOnCompositor = aIsRunning;
       // We currently only set a performance warning message when animations
       // cannot be run on the compositor, so if this animation is running
@@ -708,8 +710,8 @@
 void KeyframeEffect::SetIsRunningOnCompositor(
     const nsCSSPropertyIDSet& aPropertySet, bool aIsRunning) {
   for (AnimationProperty& property : mProperties) {
-    if (aPropertySet.HasProperty(property.mProperty)) {
-      MOZ_ASSERT(nsCSSProps::PropHasFlags(property.mProperty,
+    if (aPropertySet.HasProperty(property.mProperty.mID)) {
+      MOZ_ASSERT(nsCSSProps::PropHasFlags(property.mProperty.mID,
                                           CSSPropFlags::CanAnimateOnCompositor),
                  "Property being animated on compositor is a recognized "
                  "compositor-animatable property");
@@ -1036,7 +1038,8 @@
     const StylePerDocumentStyleData* aRawData,
     nsTArray<AnimationProperty>& aAnimationProperties) {
   for (auto& p : aAnimationProperties) {
-    printf("%s\n", nsCString(nsCSSProps::GetStringValue(p.mProperty)).get());
+    printf("%s\n",
+           nsCString(nsCSSProps::GetStringValue(p.mProperty.mID)).get());
     for (auto& s : p.mSegments) {
       nsAutoCString fromValue, toValue;
       s.mFromValue.SerializeSpecifiedValue(p.mProperty, aRawData, fromValue);
@@ -1120,7 +1123,7 @@
 }
 
 static void CreatePropertyValue(
-    nsCSSPropertyID aProperty, float aOffset,
+    const AnimatedPropertyID& aProperty, float aOffset,
     const Maybe<StyleComputedTimingFunction>& aTimingFunction,
     const AnimationValue& aValue, dom::CompositeOperation aComposite,
     const StylePerDocumentStyleData* aRawData,
@@ -1150,8 +1153,7 @@
 
   for (const AnimationProperty& property : mProperties) {
     AnimationPropertyDetails propertyDetails;
-    propertyDetails.mProperty =
-        NS_ConvertASCIItoUTF16(nsCSSProps::GetStringValue(property.mProperty));
+    property.mProperty.ToString(propertyDetails.mProperty);
     propertyDetails.mRunningOnCompositor = property.mIsRunningOnCompositor;
 
     nsAutoString localizedString;
@@ -1475,7 +1477,7 @@
     }
 
     MOZ_ASSERT(nsCSSPropertyIDSet::CompositorAnimatables().HasProperty(
-                   property.mProperty),
+                   property.mProperty.mID),
                "The property should be able to run on the compositor");
     if (!effectSet) {
       effectSet = EffectSet::Get(mTarget.mElement, mTarget.mPseudoType);
@@ -1483,12 +1485,14 @@
                  "CanThrottle should be called on an effect "
                  "associated with a target element");
     }
-    MOZ_ASSERT(HasEffectiveAnimationOfProperty(property.mProperty, *effectSet),
-               "There should be an effective animation of the property while "
-               "it is marked as being run on the compositor");
+    MOZ_ASSERT(
+        HasEffectiveAnimationOfProperty(property.mProperty.mID, *effectSet),
+        "There should be an effective animation of the property while "
+        "it is marked as being run on the compositor");
 
     DisplayItemType displayItemType =
-        LayerAnimationInfo::GetDisplayItemTypeForProperty(property.mProperty);
+        LayerAnimationInfo::GetDisplayItemTypeForProperty(
+            property.mProperty.mID);
 
     // Note that AnimationInfo::GetGenarationFromFrame() is supposed to work
     // with the primary frame instead of the style frame.
@@ -1714,14 +1718,14 @@
     // !important rules.
     if (effectSet &&
         effectSet->PropertiesWithImportantRules().HasProperty(
-            property.mProperty) &&
+            property.mProperty.mID) &&
         effectSet->PropertiesForAnimationsLevel().HasProperty(
-            property.mProperty)) {
+            property.mProperty.mID)) {
       continue;
     }
     // Check for geometric properties
     if (enableMainthreadSynchronizationWithGeometricAnimations &&
-        IsGeometricProperty(property.mProperty)) {
+        IsGeometricProperty(property.mProperty.mID)) {
       aPerformanceWarning =
           AnimationPerformanceWarning::Type::TransformWithGeometricProperties;
       return true;
@@ -1729,7 +1733,7 @@
 
     // Check for unsupported transform animations
     if (LayerAnimationInfo::GetCSSPropertiesFor(DisplayItemType::TYPE_TRANSFORM)
-            .HasProperty(property.mProperty)) {
+            .HasProperty(property.mProperty.mID)) {
       if (!CanAnimateTransformOnCompositor(aFrame, aPerformanceWarning)) {
         return true;
       }
@@ -1737,7 +1741,7 @@
 
     // If there are any offset-path animations whose animation values are url(),
     // we have to sync with the main thread when resolving it.
-    if (property.mProperty == eCSSProperty_offset_path) {
+    if (property.mProperty.mID == eCSSProperty_offset_path) {
       for (const auto& seg : property.mSegments) {
         if (seg.mFromValue.IsOffsetPathUrl() ||
             seg.mToValue.IsOffsetPathUrl()) {
@@ -1752,7 +1756,7 @@
 
 bool KeyframeEffect::HasGeometricProperties() const {
   for (const AnimationProperty& property : mProperties) {
-    if (IsGeometricProperty(property.mProperty)) {
+    if (IsGeometricProperty(property.mProperty.mID)) {
       return true;
     }
   }
@@ -1765,11 +1769,11 @@
     const AnimationPerformanceWarning& aWarning) {
   nsCSSPropertyIDSet curr = aPropertySet;
   for (AnimationProperty& property : mProperties) {
-    if (!curr.HasProperty(property.mProperty)) {
+    if (!curr.HasProperty(property.mProperty.mID)) {
       continue;
     }
     property.SetPerformanceWarning(aWarning, mTarget.mElement);
-    curr.RemoveProperty(property.mProperty);
+    curr.RemoveProperty(property.mProperty.mID);
     if (curr.IsEmpty()) {
       return;
     }
@@ -1778,19 +1782,24 @@
 
 void KeyframeEffect::CalculateCumulativeChangesForProperty(
     const AnimationProperty& aProperty) {
+  if (aProperty.mProperty.IsCustom()) {
+    // Custom properties don't affect rendering on their own.
+    return;
+  }
+
   constexpr auto kInterestingFlags =
       CSSPropFlags::AffectsLayout | CSSPropFlags::AffectsOverflow;
-  if (aProperty.mProperty == eCSSProperty_opacity) {
+  if (aProperty.mProperty.mID == eCSSProperty_opacity) {
     mCumulativeChanges.mOpacity = true;
     return;  // We know opacity is visual-only.
   }
 
-  if (aProperty.mProperty == eCSSProperty_visibility) {
+  if (aProperty.mProperty.mID == eCSSProperty_visibility) {
     mCumulativeChanges.mVisibility = true;
     return;  // We know visibility is visual-only.
   }
 
-  if (aProperty.mProperty == eCSSProperty_background_color) {
+  if (aProperty.mProperty.mID == eCSSProperty_background_color) {
     if (!mCumulativeChanges.mHasBackgroundColorCurrentColor) {
       mCumulativeChanges.mHasBackgroundColorCurrentColor =
           HasCurrentColor(aProperty.mSegments);
@@ -1798,7 +1807,7 @@
     return;  // We know background-color is visual-only.
   }
 
-  auto flags = nsCSSProps::PropFlags(aProperty.mProperty);
+  auto flags = nsCSSProps::PropFlags(aProperty.mProperty.mID);
   if (!(flags & kInterestingFlags)) {
     return;  // Property is visual-only.
   }
@@ -1906,9 +1915,9 @@
   }
 
   for (const AnimationProperty& prop : mProperties) {
-    if (prop.mProperty != eCSSProperty_transform &&
-        prop.mProperty != eCSSProperty_scale &&
-        prop.mProperty != eCSSProperty_rotate) {
+    if (prop.mProperty.mID != eCSSProperty_transform &&
+        prop.mProperty.mID != eCSSProperty_scale &&
+        prop.mProperty.mID != eCSSProperty_rotate) {
       continue;
     }
 