# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/GC.cpp
# Commit: 7da8f779dc24
# Full Hash: 7da8f779dc24489bd423f647c1d60530e9deb24e
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2020-12-17 21:49:27
# Regressor Bug: 1681533
# File Overlap Count: 2
# Description:
#   Bug 1681533 - Only collect the nursery when necessary in major GC r=sfink
#   
#   This rearranges a few things so that we can run a minor GC inside a major GC
#   slice, so we don't have to be conservative about collecting the nursery at the
#   start of a slice.
# ==============================================================================

diff -r bc20cf2a3ad8 -r 7da8f779dc24 js/src/gc/GC.cpp
--- a/js/src/gc/GC.cpp	Thu Dec 17 17:39:25 2020 +0000
+++ b/js/src/gc/GC.cpp	Thu Dec 17 17:57:33 2020 +0000
@@ -1504,6 +1504,10 @@
       return nursery().capacity();
     case JSGC_NUMBER:
       return uint32_t(number);
+    case JSGC_MAJOR_GC_NUMBER:
+      return uint32_t(majorGCNumber);
+    case JSGC_MINOR_GC_NUMBER:
+      return uint32_t(minorGCNumber);
     case JSGC_MODE:
       return uint32_t(mode);
     case JSGC_UNUSED_CHUNKS:
@@ -4083,12 +4087,6 @@
 bool GCRuntime::beginPreparePhase(JS::GCReason reason, AutoGCSession& session) {
   gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::PREPARE);
 
-#ifdef DEBUG
-  if (fullCompartmentChecks) {
-    checkForCompartmentMismatches();
-  }
-#endif
-
   if (!prepareZonesForCollection(reason, &isFull.ref())) {
     return false;
   }
@@ -4285,6 +4283,12 @@
       }
     }
   }
+
+#ifdef DEBUG
+  if (fullCompartmentChecks) {
+    checkForCompartmentMismatches();
+  }
+#endif
 }
 
 void GCRuntime::beginMarkPhase(AutoGCSession& session) {
@@ -6440,6 +6444,10 @@
     zone->notifyObservingDebuggers();
   }
 
+#ifdef JS_GC_ZEAL
+  clearSelectedForMarking();
+#endif
+
   auto currentTime = ReallyNow();
   schedulingState.updateHighFrequencyMode(lastGCEndTime_, currentTime,
                                           tunables);
@@ -6535,7 +6543,9 @@
 AutoHeapSession::AutoHeapSession(GCRuntime* gc, JS::HeapState heapState)
     : gc(gc), prevState(gc->heapState_) {
   MOZ_ASSERT(CurrentThreadCanAccessRuntime(gc->rt));
-  MOZ_ASSERT(prevState == JS::HeapState::Idle);
+  MOZ_ASSERT(prevState == JS::HeapState::Idle ||
+             (prevState == JS::HeapState::MajorCollecting &&
+              heapState == JS::HeapState::MinorCollecting));
   MOZ_ASSERT(heapState != JS::HeapState::Idle);
 
   gc->heapState_ = heapState;
@@ -6721,11 +6731,23 @@
   return reason != JS::GCReason::DESTROY_RUNTIME && CanUseExtraThreads();
 }
 
+static bool NeedToCollectNursery(GCRuntime* gc) {
+  return !gc->nursery().isEmpty() || !gc->storeBuffer().isEmpty();
+}
+
 void GCRuntime::incrementalSlice(SliceBudget& budget,
                                  const MaybeInvocationKind& gckind,
-                                 JS::GCReason reason, AutoGCSession& session) {
+                                 JS::GCReason reason) {
   AutoSetThreadIsPerformingGC performingGC;
 
+  AutoGCSession session(this, JS::HeapState::MajorCollecting);
+
+  // We don't allow off-thread parsing to start while we're doing an
+  // incremental GC of the atoms zone.
+  if (rt->activeGCInAtomsZone()) {
+    session.maybeCheckAtomsAccess.emplace(rt);
+  }
+
   bool destroyingRuntime = (reason == JS::GCReason::DESTROY_RUNTIME);
 
   initialState = incrementalState;
@@ -6755,14 +6777,6 @@
 
   isIncremental = !budget.isUnlimited();
 
-  /*
-   * Non-incremental collection expects that the nursery is empty.
-   */
-  if (!isIncremental && !isIncrementalGCInProgress()) {
-    MOZ_ASSERT(nursery().isEmpty());
-    storeBuffer().checkEmpty();
-  }
-
   if (useZeal && hasIncrementalTwoSliceZealMode()) {
     /*
      * Yields between slices occurs at predetermined points in these modes;
@@ -6772,8 +6786,6 @@
     budget.makeUnlimited();
   }
 
-  incGcSliceNumber();
-
   switch (incrementalState) {
     case State::NotActive:
       invocationKind = gckind.valueOr(GC_NORMAL);
@@ -6794,7 +6806,7 @@
       incrementalState = State::Prepare;
       if (!beginPreparePhase(reason, session)) {
         incrementalState = State::NotActive;
-        return;
+        break;
       }
 
       if (isIncremental && useZeal &&
@@ -6810,15 +6822,19 @@
         break;
       }
 
-      endPreparePhase(reason);
       incrementalState = State::MarkRoots;
       [[fallthrough]];
 
     case State::MarkRoots:
+      if (NeedToCollectNursery(this)) {
+        collectNurseryFromMajorGC(gckind, reason);
+      }
+
+      endPreparePhase(reason);
+
       beginMarkPhase(session);
 
-      /* If we needed delayed marking for gray roots, then collect until done.
-       */
+      // If we needed delayed marking for gray roots, then collect until done.
       if (isIncremental && !hasValidGrayRootsBuffer()) {
         budget.makeUnlimited();
         isIncremental = false;
@@ -6886,6 +6902,10 @@
       [[fallthrough]];
 
     case State::Sweep:
+      if (storeBuffer().mayHavePointersToDeadCells()) {
+        collectNurseryFromMajorGC(gckind, reason);
+      }
+
       if (initialState == State::Sweep) {
         rt->mainContextFromOwnThread()->traceWrapperGCRooters(&marker);
       }
@@ -6929,7 +6949,10 @@
 
     case State::Compact:
       if (isCompacting) {
-        MOZ_ASSERT(nursery().isEmpty());
+        if (NeedToCollectNursery(this)) {
+          collectNurseryFromMajorGC(gckind, reason);
+        }
+
         storeBuffer().checkEmpty();
         if (!startedCompacting) {
           beginCompactPhase();
@@ -6967,6 +6990,12 @@
   MOZ_ASSERT(marker.markColor() == MarkColor::Black);
 }
 
+void GCRuntime::collectNurseryFromMajorGC(const MaybeInvocationKind& gckind,
+                                          JS::GCReason reason) {
+  collectNursery(gckind.valueOr(GC_NORMAL), reason,
+                 gcstats::PhaseKind::EVICT_NURSERY_FOR_MAJOR_GC);
+}
+
 bool GCRuntime::hasForegroundWork() const {
   switch (incrementalState) {
     case State::NotActive:
@@ -7063,20 +7092,22 @@
     return resetIncrementalGC(GCAbortReason::AbortRequested);
   }
 
-  GCAbortReason unsafeReason = IsIncrementalGCUnsafe(rt);
-  if (unsafeReason == GCAbortReason::None) {
-    if (reason == JS::GCReason::COMPARTMENT_REVIVED) {
-      unsafeReason = GCAbortReason::CompartmentRevived;
-    } else if (mode != JSGC_MODE_INCREMENTAL &&
-               mode != JSGC_MODE_ZONE_INCREMENTAL) {
-      unsafeReason = GCAbortReason::ModeChange;
-    }
-  }
-
-  if (unsafeReason != GCAbortReason::None) {
-    budget.makeUnlimited();
-    stats().nonincremental(unsafeReason);
-    return resetIncrementalGC(unsafeReason);
+  if (!budget.isUnlimited()) {
+    GCAbortReason unsafeReason = IsIncrementalGCUnsafe(rt);
+    if (unsafeReason == GCAbortReason::None) {
+      if (reason == JS::GCReason::COMPARTMENT_REVIVED) {
+        unsafeReason = GCAbortReason::CompartmentRevived;
+      } else if (mode != JSGC_MODE_INCREMENTAL &&
+                 mode != JSGC_MODE_ZONE_INCREMENTAL) {
+        unsafeReason = GCAbortReason::ModeChange;
+      }
+    }
+
+    if (unsafeReason != GCAbortReason::None) {
+      budget.makeUnlimited();
+      stats().nonincremental(unsafeReason);
+      return resetIncrementalGC(unsafeReason);
+    }
   }
 
   GCAbortReason resetReason = GCAbortReason::None;
@@ -7253,6 +7284,17 @@
   // they are operating on zones which will not be collected from here.
   MOZ_ASSERT(!rt->mainContextFromOwnThread()->suppressGC);
 
+  // This reason is used internally. See below.
+  MOZ_ASSERT(reason != JS::GCReason::RESET);
+
+  // Background finalization and decommit are finished by definition before we
+  // can start a new major GC.  Background allocation may still be running, but
+  // that's OK because chunk pools are protected by the GC lock.
+  if (!isIncrementalGCInProgress()) {
+    assertBackgroundSweepingFinished();
+    MOZ_ASSERT(decommitTask.isIdle());
+  }
+
   // Note that GC callbacks are allowed to re-enter GC.
   AutoCallGCCallbacks callCallbacks(*this, reason);
 
@@ -7264,7 +7306,8 @@
   gcstats::AutoGCSlice agc(stats(), scanZonesBeforeGC(),
                            gckind.valueOr(invocationKind), budget, reason);
 
-  auto result = budgetIncrementalGC(nonincrementalByAPI, reason, budget);
+  IncrementalResult result =
+      budgetIncrementalGC(nonincrementalByAPI, reason, budget);
   if (result == IncrementalResult::ResetIncremental) {
     if (incrementalState == State::NotActive) {
       // The collection was reset and has finished.
@@ -7275,95 +7318,38 @@
     reason = JS::GCReason::RESET;
   }
 
-  if (shouldCollectNurseryForSlice(nonincrementalByAPI, budget)) {
-    collectNursery(gckind.valueOr(GC_NORMAL), reason,
-                   gcstats::PhaseKind::EVICT_NURSERY_FOR_MAJOR_GC);
-  } else {
-    ++number;  // This otherwise happens in Nursery::collect().
-  }
-
-  AutoGCSession session(this, JS::HeapState::MajorCollecting);
-
   majorGCTriggerReason = JS::GCReason::NO_REASON;
   MOZ_ASSERT(!stats().hasTrigger());
 
-  {
-    gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::WAIT_BACKGROUND_THREAD);
-
-    // Background finalization and decommit are finished by defininition
-    // before we can start a new GC session.
-    if (!isIncrementalGCInProgress()) {
-      assertBackgroundSweepingFinished();
-      MOZ_ASSERT(decommitTask.isIdle());
-    }
-
-    // We must also wait for background allocation to finish so we can
-    // avoid taking the GC lock when manipulating the chunks during the GC.
-    // The background alloc task can run between slices, so we must wait
-    // for it at the start of every slice.
-    allocTask.cancelAndWait();
-  }
-
-  // We don't allow off-thread parsing to start while we're doing an
-  // incremental GC of the atoms zone.
-  if (rt->activeGCInAtomsZone()) {
-    session.maybeCheckAtomsAccess.emplace(rt);
-  }
+  incGcNumber();
+  incGcSliceNumber();
 
   gcprobes::MajorGCStart();
-
-  incrementalSlice(budget, gckind, reason, session);
-
-#ifdef JS_GC_ZEAL
-  clearSelectedForMarking();
-#endif
-
+  incrementalSlice(budget, gckind, reason);
   gcprobes::MajorGCEnd();
 
   MOZ_ASSERT_IF(result == IncrementalResult::ResetIncremental,
                 !isIncrementalGCInProgress());
-
   return result;
 }
 
-bool GCRuntime::shouldCollectNurseryForSlice(bool nonincrementalByAPI,
-                                             SliceBudget& budget) {
-  if (!nursery().isEnabled()) {
-    return false;
-  }
-
-  if (nursery().shouldCollect()) {
-    return true;
-  }
-
-  bool nonIncremental = nonincrementalByAPI || budget.isUnlimited();
-
-  bool shouldCollectForSweeping = storeBuffer().mayHavePointersToDeadCells();
-
-  switch (incrementalState) {
-    case State::NotActive:
-      return true;
-    case State::Prepare:
-      return true;
-    case State::Mark:
-      return (mightSweepInThisSlice(nonIncremental) &&
-              shouldCollectForSweeping) ||
-             mightCompactInThisSlice(nonIncremental);
-    case State::Sweep:
-      return shouldCollectForSweeping ||
-             mightCompactInThisSlice(nonIncremental);
-    case State::Finalize:
-      return mightCompactInThisSlice(nonIncremental);
-    case State::Compact:
-      return true;
-    case State::Decommit:
-    case State::Finish:
-      return false;
-    default:
-      MOZ_CRASH("Unexpected GC state");
-  }
-
-  return false;
+void GCRuntime::waitForBackgroundTasksBeforeSlice() {
+  gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::WAIT_BACKGROUND_THREAD);
+
+  // Background finalization and decommit are finished by definition before we
+  // can start a new major GC.
+  if (!isIncrementalGCInProgress()) {
+    assertBackgroundSweepingFinished();
+    MOZ_ASSERT(decommitTask.isIdle());
+  }
+
+  // We must also wait for background allocation to finish so we can avoid
+  // taking the GC lock when manipulating the chunks during the GC.  The
+  // background alloc task can run between slices, so we must wait for it at the
+  // start of every slice.
+  //
+  // TODO: Is this still necessary?
+  allocTask.cancelAndWait();
 }
 
 inline bool GCRuntime::mightSweepInThisSlice(bool nonIncremental) {
@@ -7371,11 +7357,6 @@
   return nonIncremental || lastMarkSlice || hasIncrementalTwoSliceZealMode();
 }
 
-inline bool GCRuntime::mightCompactInThisSlice(bool nonIncremental) {
-  MOZ_ASSERT(incrementalState < State::Compact);
-  return isCompacting && (nonIncremental || hasIncrementalTwoSliceZealMode());
-}
-
 #ifdef JS_GC_ZEAL
 static bool IsDeterministicGCReason(JS::GCReason reason) {
   switch (reason) {
@@ -7738,8 +7719,17 @@
     return;
   }
 
+  incGcNumber();
+
   collectNursery(GC_NORMAL, reason, phase);
 
+#ifdef JS_GC_ZEAL
+  if (hasZealMode(ZealMode::CheckHeapAfterGC)) {
+    gcstats::AutoPhase ap(stats(), phase);
+    CheckHeapAfterGC(rt);
+  }
+#endif
+
   for (ZonesIter zone(this, WithAtoms); !zone.done(); zone.next()) {
     maybeTriggerGCAfterAlloc(zone);
     maybeTriggerGCAfterMalloc(zone);
@@ -7769,12 +7759,6 @@
   MOZ_ASSERT(nursery().isEmpty());
 
   startBackgroundFreeAfterMinorGC();
-
-#ifdef JS_GC_ZEAL
-  if (hasZealMode(ZealMode::CheckHeapAfterGC)) {
-    CheckHeapAfterGC(rt);
-  }
-#endif
 }
 
 void GCRuntime::startBackgroundFreeAfterMinorGC() {