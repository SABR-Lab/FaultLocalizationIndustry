# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit-test/tests/gc/bug-1505622.js
# Commit: 982a80b202c3
# Full Hash: 982a80b202c370876dafc72ac31be7a12ebeae58
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2021-01-08 03:45:03
# Regressor Bug: 1681533
# File Overlap Count: 2
# Description:
#   Bug 1681533 - Only collect the nursery when necessary in major GC r=sfink
#   
#   This rearranges a few things so that we can run a minor GC inside a major GC
#   slice, so we don't have to be conservative about collecting the nursery at the
#   start of a slice.
# ==============================================================================

diff -r 83f3726c41f9 -r 982a80b202c3 js/src/jit-test/tests/gc/bug-1505622.js
--- a/js/src/jit-test/tests/gc/bug-1505622.js	Thu Jan 07 15:57:41 2021 +0000
+++ b/js/src/jit-test/tests/gc/bug-1505622.js	Mon Jan 04 17:01:50 2021 +0000
@@ -1,30 +1,39 @@
 // Test that we don't repeatedly trigger last-ditch GCs.
 
-function allocUntilFail() {
-    gc();
-    let initGCNumber = gcparam("gcNumber");
-    let error;
-    try {
-        let a = [];
-        while (true) {
-            a.push(Symbol()); // Symbols are tenured.
-        }
-    } catch(err) {
-        error = err;
-    }
-    let finalGCNumber = gcparam("gcNumber");
-    gc();
-    assertEq(error, "out of memory");
-    return finalGCNumber - initGCNumber;
-}
-
 // Turn of any zeal which will disrupt GC number checks.
 gczeal(0);
 
-// Set a small heap limit.
+// Get initial heap size and limit.
 gc();
-let currentSize = gcparam("gcBytes");
-gcparam("maxBytes", currentSize + 16 * 1024);
+const initialSize = gcparam("gcBytes");
+const initialMaxSize = gcparam("maxBytes");
+
+function allocUntilFail() {
+  gc();
+  const initGCNumber = gcparam("majorGCNumber");
+
+  // Set a small heap limit.
+  gcparam("maxBytes", initialSize + 16 * 1024);
+
+  let error;
+  try {
+    let a = [];
+    while (true) {
+      a.push(Symbol()); // Symbols are tenured.
+    }
+  } catch(err) {
+    error = err;
+  }
+
+  const finalGCNumber = gcparam("majorGCNumber");
+
+  // Resetore heap limit.
+  gcparam("maxBytes", initialMaxSize);
+
+  gc();
+  assertEq(error, "out of memory");
+  return finalGCNumber - initGCNumber;
+}
 
 // Set the time limit for skipping last ditch GCs to 5 seconds.
 gcparam("minLastDitchGCPeriod", 5);