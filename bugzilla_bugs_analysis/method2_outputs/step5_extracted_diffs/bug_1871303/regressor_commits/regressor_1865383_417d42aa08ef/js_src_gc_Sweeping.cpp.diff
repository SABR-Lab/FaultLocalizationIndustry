# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/gc/Sweeping.cpp
# Commit: 417d42aa08ef
# Full Hash: 417d42aa08efdd20ba112e3ff1e633338fba111d
# Author: Jon Coppeard <jcoppeard@mozilla.com>
# Date: 2024-07-12 22:06:45
# Regressor Bug: 1865383
# File Overlap Count: 3
# Description:
#   Bug 1871303 - Ensure there is no more marking at the start of sweeping r=sfink
#   
#   There are two issues here. The first is that there unexpected marking work at
#   the start of sweeping after entering from the mark phase without yielding. We
#   previously called assertNoMarkingWork() after markUntilBudgetExhausted() in the
# ==============================================================================

diff -r 3396a3835684 -r 417d42aa08ef js/src/gc/Sweeping.cpp
--- a/js/src/gc/Sweeping.cpp	Fri Jul 12 09:30:34 2024 +0000
+++ b/js/src/gc/Sweeping.cpp	Fri Jul 12 09:33:13 2024 +0000
@@ -2347,7 +2347,26 @@
   return sweepActions != nullptr;
 }
 
+void GCRuntime::prepareForSweepSlice(JS::GCReason reason) {
+  // Work that must be done at the start of each slice where we sweep.
+  //
+  // Since this must happen at the start of the slice, it must be called in
+  // marking slices before any sweeping happens. Therefore it is called
+  // conservatively since we may not always transition to sweeping from marking.
+
+  // Clear out whole cell store buffer entries to unreachable cells.
+  if (storeBuffer().mayHavePointersToDeadCells()) {
+    collectNurseryFromMajorGC(reason);
+  }
+
+  // Trace wrapper rooters before marking if we might start sweeping in
+  // this slice.
+  rt->mainContextFromOwnThread()->traceWrapperGCRooters(marker().tracer());
+}
+
 IncrementalProgress GCRuntime::performSweepActions(SliceBudget& budget) {
+  MOZ_ASSERT(!storeBuffer().mayHavePointersToDeadCells());
+
   AutoMajorGCProfilerEntry s(this);
   gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::SWEEP);
 
@@ -2361,26 +2380,19 @@
   // Drain the mark stack, possibly in a parallel task if we're in a part of
   // sweeping that allows it.
   //
-  // In the first sweep slice where we must not yield to the mutator until we've
-  // starting sweeping a sweep group but in that case the stack must be empty
-  // already.
-
-#ifdef DEBUG
+  // The first time we enter the sweep phase we must not yield to the mutator
+  // until we've starting sweeping a sweep group but in that case the stack must
+  // be empty already.
+
   MOZ_ASSERT(initialState <= State::Sweep);
-  if (initialState != State::Sweep) {
+  bool startOfSweeping = initialState < State::Sweep;
+
+  if (startOfSweeping) {
     assertNoMarkingWork();
-  }
-#endif
-
-  if (initialState == State::Sweep) {
+  } else {
     if (markDuringSweeping(gcx, budget) == NotFinished) {
       return NotFinished;
     }
-  } else {
-    budget.forceCheck();
-    if (budget.isOverBudget()) {
-      return NotFinished;
-    }
   }
 
   // Then continue running sweep actions.
