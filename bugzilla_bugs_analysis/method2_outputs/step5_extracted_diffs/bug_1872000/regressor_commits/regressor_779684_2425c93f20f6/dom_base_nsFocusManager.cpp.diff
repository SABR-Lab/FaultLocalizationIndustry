# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsFocusManager.cpp
# Commit: 2425c93f20f6
# Full Hash: 2425c93f20f61b806df955141332d7cb553c6efb
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2024-01-17 04:08:25
# Regressor Bug: 779684
# File Overlap Count: 1
# Description:
#   Bug 1872301 - Make `nsFocusManager::GetSelectionLocation` never fail when found text node has no frame r=NeilDeakin
#   
#   In the test case, `nsFocusManager::GetSelectionLocation` is called with
#   collapsed selection at end of the `<svg>` which ends with collapsible
#   white-spaces.  Therefore, it reaches the white-space only text node and it
# ==============================================================================

diff -r ad6d17afc267 -r 2425c93f20f6 dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp	Wed Jan 17 00:18:05 2024 +0000
+++ b/dom/base/nsFocusManager.cpp	Wed Jan 17 00:25:04 2024 +0000
@@ -3185,10 +3185,10 @@
   return NS_OK;
 }
 
-nsresult nsFocusManager::GetSelectionLocation(Document* aDocument,
-                                              PresShell* aPresShell,
-                                              nsIContent** aStartContent,
-                                              nsIContent** aEndContent) {
+void nsFocusManager::GetSelectionLocation(Document* aDocument,
+                                          PresShell* aPresShell,
+                                          nsIContent** aStartContent,
+                                          nsIContent** aEndContent) {
   *aStartContent = *aEndContent = nullptr;
 
   nsPresContext* presContext = aPresShell->GetPresContext();
@@ -3197,12 +3197,12 @@
   RefPtr<Selection> domSelection =
       aPresShell->ConstFrameSelection()->GetSelection(SelectionType::eNormal);
   if (!domSelection) {
-    return NS_OK;
+    return;
   }
 
   const nsRange* domRange = domSelection->GetRangeAt(0);
   if (!domRange || !domRange->IsPositioned()) {
-    return NS_OK;
+    return;
   }
   nsIContent* start = nsIContent::FromNode(domRange->GetStartContainer());
   nsIContent* end = nsIContent::FromNode(domRange->GetEndContainer());
@@ -3216,17 +3216,16 @@
   // Next check to see if our caret is at the very end of a text node. If so,
   // the caret is actually sitting in front of the next logical frame's primary
   // node - so for this case we need to change the content to that node.
+  // Note that if the text does not have text frame, we do not need to retreive
+  // caret frame.  This could occur if text frame has only collapsisble white-
+  // spaces and is around a block boundary or an ancestor of it is invisible.
+  // XXX If there is a visible text sibling, should we return it in the former
+  // case?
   if (auto* text = Text::FromNodeOrNull(start);
-      text && text->TextDataLength() == domRange->StartOffset() &&
+      text && text->GetPrimaryFrame() &&
+      text->TextDataLength() == domRange->StartOffset() &&
       domSelection->IsCollapsed()) {
     nsIFrame* startFrame = start->GetPrimaryFrame();
-    // FIXME: If the text node is empty or only collapsible white-spaces next
-    // to a block boundary, it may not have frame, however, we don't know how to
-    // reproduce this.
-    MOZ_ASSERT(startFrame);
-    if (MOZ_UNLIKELY(!startFrame)) {
-      return NS_ERROR_FAILURE;
-    }
     // Yes, indeed we were at the end of the last node
     nsIFrame* limiter =
         domSelection && domSelection->GetAncestorLimiter()
@@ -3282,8 +3281,6 @@
 
   NS_IF_ADDREF(*aStartContent = start);
   NS_IF_ADDREF(*aEndContent = end);
-
-  return NS_OK;
 }
 
 nsresult nsFocusManager::DetermineElementToMoveFocus(