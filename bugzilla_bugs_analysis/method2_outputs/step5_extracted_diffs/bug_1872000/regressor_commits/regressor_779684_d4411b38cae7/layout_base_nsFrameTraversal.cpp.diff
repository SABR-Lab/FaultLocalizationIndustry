# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsFrameTraversal.cpp
# Commit: d4411b38cae7
# Full Hash: d4411b38cae7216ffc57a9b8b246806acf0a3717
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-12-24 09:09:23
# Regressor Bug: 779684
# File Overlap Count: 1
# Description:
#   Bug 779684 - part 1: Get rid of `nsIFrameEnumerator` interface r=emilio
#   
#   It's inherited only by `nsFrameIterator`, and `nsFrameIterator` can be declared
#   in a header file. So, the interface is not required and removing it can avoid
#   virtual calls.
# ==============================================================================

diff -r bda7c9e66417 -r d4411b38cae7 layout/base/nsFrameTraversal.cpp
--- a/layout/base/nsFrameTraversal.cpp	Sat Dec 23 19:02:04 2023 +0000
+++ b/layout/base/nsFrameTraversal.cpp	Sun Dec 24 06:01:19 2023 +0000
@@ -19,97 +19,6 @@
 using namespace mozilla;
 using namespace mozilla::dom;
 
-class nsFrameIterator : public nsIFrameEnumerator {
- public:
-  NS_DECL_ISUPPORTS
-
-  virtual void First() override;
-  virtual void Next() override;
-  virtual nsIFrame* CurrentItem() override;
-  virtual bool IsDone() override;
-
-  virtual void Last() override;
-  virtual void Prev() override;
-
-  nsFrameIterator(nsPresContext* aPresContext, nsIFrame* aStart,
-                  nsIteratorType aType, bool aLockScroll, bool aFollowOOFs,
-                  bool aSkipPopupChecks, nsIFrame* aLimiter);
-
- protected:
-  virtual ~nsFrameIterator() = default;
-
-  void setCurrent(nsIFrame* aFrame) { mCurrent = aFrame; }
-  nsIFrame* getCurrent() { return mCurrent; }
-  nsIFrame* getStart() { return mStart; }
-  nsIFrame* getLast() { return mLast; }
-  void setLast(nsIFrame* aFrame) { mLast = aFrame; }
-  int8_t getOffEdge() { return mOffEdge; }
-  void setOffEdge(int8_t aOffEdge) { mOffEdge = aOffEdge; }
-
-  /*
-   Our own versions of the standard frame tree navigation
-   methods, which, if the iterator is following out-of-flows,
-   apply the following rules for placeholder frames:
-
-   - If a frame HAS a placeholder frame, getting its parent
-   gets the placeholder's parent.
-
-   - If a frame's first child or next/prev sibling IS a
-   placeholder frame, then we instead return the real frame.
-
-   - If a frame HAS a placeholder frame, getting its next/prev
-   sibling gets the placeholder frame's next/prev sibling.
-
-   These are all applied recursively to support multiple levels of
-   placeholders.
-   */
-
-  nsIFrame* GetParentFrame(nsIFrame* aFrame);
-  // like GetParentFrame but returns null once a popup frame is reached
-  nsIFrame* GetParentFrameNotPopup(nsIFrame* aFrame);
-
-  nsIFrame* GetFirstChild(nsIFrame* aFrame);
-  nsIFrame* GetLastChild(nsIFrame* aFrame);
-
-  nsIFrame* GetNextSibling(nsIFrame* aFrame);
-  nsIFrame* GetPrevSibling(nsIFrame* aFrame);
-
-  /*
-   These methods are overridden by the bidi visual iterator to have the
-   semantics of "get first child in visual order", "get last child in visual
-   order", "get next sibling in visual order" and "get previous sibling in
-   visual order".
-  */
-
-  virtual nsIFrame* GetFirstChildInner(nsIFrame* aFrame);
-  virtual nsIFrame* GetLastChildInner(nsIFrame* aFrame);
-
-  virtual nsIFrame* GetNextSiblingInner(nsIFrame* aFrame);
-  virtual nsIFrame* GetPrevSiblingInner(nsIFrame* aFrame);
-
-  /**
-   * Return the placeholder frame for aFrame if it has one, otherwise return
-   * aFrame itself.
-   */
-  nsIFrame* GetPlaceholderFrame(nsIFrame* aFrame);
-  bool IsPopupFrame(nsIFrame* aFrame);
-
-  bool IsInvokerOpenPopoverFrame(nsIFrame* aFrame);
-
-  nsPresContext* const mPresContext;
-  const bool mLockScroll;
-  const bool mFollowOOFs;
-  const bool mSkipPopupChecks;
-  const nsIteratorType mType;
-
- private:
-  nsIFrame* const mStart;
-  nsIFrame* mCurrent;
-  nsIFrame* mLast;  // the last one that was in current;
-  nsIFrame* mLimiter;
-  int8_t mOffEdge;  // 0= no -1 to far prev, 1 to far next;
-};
-
 // Bidi visual iterator
 class nsVisualIterator : public nsFrameIterator {
  public:
@@ -138,7 +47,7 @@
   return NS_OK;
 }
 
-nsresult NS_NewFrameTraversal(nsIFrameEnumerator** aEnumerator,
+nsresult NS_NewFrameTraversal(nsFrameIterator** aEnumerator,
                               nsPresContext* aPresContext, nsIFrame* aStart,
                               nsIteratorType aType, bool aVisual,
                               bool aLockInScrollView, bool aFollowOOFs,
@@ -149,7 +58,7 @@
     aStart = nsPlaceholderFrame::GetRealFrameFor(aStart);
   }
 
-  nsCOMPtr<nsIFrameEnumerator> trav;
+  RefPtr<nsFrameIterator> trav;
   if (aVisual) {
     trav = new nsVisualIterator(aPresContext, aStart, aType, aLockInScrollView,
                                 aFollowOOFs, aSkipPopupChecks, aLimiter);
@@ -168,7 +77,7 @@
 NS_IMPL_ISUPPORTS(nsFrameTraversal, nsIFrameTraversal)
 
 NS_IMETHODIMP
-nsFrameTraversal::NewFrameTraversal(nsIFrameEnumerator** aEnumerator,
+nsFrameTraversal::NewFrameTraversal(nsFrameIterator** aEnumerator,
                                     nsPresContext* aPresContext,
                                     nsIFrame* aStart, int32_t aType,
                                     bool aVisual, bool aLockInScrollView,
@@ -181,8 +90,6 @@
 
 // nsFrameIterator implementation
 
-NS_IMPL_ISUPPORTS(nsFrameIterator, nsIFrameEnumerator)
-
 nsFrameIterator::nsFrameIterator(nsPresContext* aPresContext, nsIFrame* aStart,
                                  nsIteratorType aType, bool aLockInScrollView,
                                  bool aFollowOOFs, bool aSkipPopupChecks,
@@ -215,7 +122,7 @@
 
 void nsFrameIterator::Last() {
   nsIFrame* result;
-  nsIFrame* parent = getCurrent();
+  nsIFrame* parent = GetCurrent();
   // If the current frame is a popup, don't move farther up the tree.
   // Otherwise, get the nearest root frame or popup.
   if (mSkipPopupChecks || !parent->IsMenuPopupFrame()) {
@@ -227,15 +134,15 @@
     parent = result;
   }
 
-  setCurrent(parent);
-  if (!parent) setOffEdge(1);
+  SetCurrent(parent);
+  if (!parent) SetOffEdge(1);
 }
 
 void nsFrameIterator::Next() {
   // recursive-oid method to get next frame
   nsIFrame* result = nullptr;
-  nsIFrame* parent = getCurrent();
-  if (!parent) parent = getLast();
+  nsIFrame* parent = GetCurrent();
+  if (!parent) parent = GetLast();
 
   if (mType == eLeaf) {
     // Drill down to first leaf
@@ -247,7 +154,7 @@
     if (result) parent = result;
   }
 
-  if (parent != getCurrent()) {
+  if (parent != GetCurrent()) {
     result = parent;
   } else {
     while (parent) {
@@ -275,18 +182,18 @@
     }
   }
 
-  setCurrent(result);
+  SetCurrent(result);
   if (!result) {
-    setOffEdge(1);
-    setLast(parent);
+    SetOffEdge(1);
+    SetLast(parent);
   }
 }
 
 void nsFrameIterator::Prev() {
   // recursive-oid method to get prev frame
   nsIFrame* result = nullptr;
-  nsIFrame* parent = getCurrent();
-  if (!parent) parent = getLast();
+  nsIFrame* parent = GetCurrent();
+  if (!parent) parent = GetLast();
 
   if (mType == eLeaf) {
     // Drill down to last leaf
@@ -298,7 +205,7 @@
     if (result) parent = result;
   }
 
-  if (parent != getCurrent()) {
+  if (parent != GetCurrent()) {
     result = parent;
   } else {
     while (parent) {
@@ -326,10 +233,10 @@
     }
   }
 
-  setCurrent(result);
+  SetCurrent(result);
   if (!result) {
-    setOffEdge(-1);
-    setLast(parent);
+    SetOffEdge(-1);
+    SetLast(parent);
   }
 }
 