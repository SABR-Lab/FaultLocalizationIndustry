# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsFrameTraversal.h
# Commit: d4411b38cae7
# Full Hash: d4411b38cae7216ffc57a9b8b246806acf0a3717
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2023-12-24 09:09:23
# Regressor Bug: 779684
# File Overlap Count: 1
# Description:
#   Bug 779684 - part 1: Get rid of `nsIFrameEnumerator` interface r=emilio
#   
#   It's inherited only by `nsFrameIterator`, and `nsFrameIterator` can be declared
#   in a header file. So, the interface is not required and removing it can avoid
#   virtual calls.
# ==============================================================================

diff -r bda7c9e66417 -r d4411b38cae7 layout/base/nsFrameTraversal.h
--- a/layout/base/nsFrameTraversal.h	Sat Dec 23 19:02:04 2023 +0000
+++ b/layout/base/nsFrameTraversal.h	Sun Dec 24 06:01:19 2023 +0000
@@ -12,7 +12,107 @@
 
 class nsIFrame;
 
-nsresult NS_NewFrameTraversal(nsIFrameEnumerator** aEnumerator,
+class nsFrameIterator {
+  NS_INLINE_DECL_REFCOUNTING(nsFrameIterator)
+
+ public:
+  void First();
+  void Next();
+  nsIFrame* CurrentItem();
+  bool IsDone();
+
+  void Last();
+  void Prev();
+
+  inline nsIFrame* Traverse(bool aForward) {
+    if (aForward) {
+      Next();
+    } else {
+      Prev();
+    }
+    return CurrentItem();
+  };
+
+  nsFrameIterator(nsPresContext* aPresContext, nsIFrame* aStart,
+                  nsIteratorType aType, bool aLockScroll, bool aFollowOOFs,
+                  bool aSkipPopupChecks, nsIFrame* aLimiter);
+
+ protected:
+  virtual ~nsFrameIterator() = default;
+
+  void SetCurrent(nsIFrame* aFrame) { mCurrent = aFrame; }
+  nsIFrame* GetCurrent() { return mCurrent; }
+  nsIFrame* GetStart() { return mStart; }
+  nsIFrame* GetLast() { return mLast; }
+  void SetLast(nsIFrame* aFrame) { mLast = aFrame; }
+  int8_t GetOffEdge() { return mOffEdge; }
+  void SetOffEdge(int8_t aOffEdge) { mOffEdge = aOffEdge; }
+
+  /*
+   Our own versions of the standard frame tree navigation
+   methods, which, if the iterator is following out-of-flows,
+   apply the following rules for placeholder frames:
+
+   - If a frame HAS a placeholder frame, getting its parent
+   gets the placeholder's parent.
+
+   - If a frame's first child or next/prev sibling IS a
+   placeholder frame, then we instead return the real frame.
+
+   - If a frame HAS a placeholder frame, getting its next/prev
+   sibling gets the placeholder frame's next/prev sibling.
+
+   These are all applied recursively to support multiple levels of
+   placeholders.
+   */
+
+  nsIFrame* GetParentFrame(nsIFrame* aFrame);
+  // like GetParentFrame but returns null once a popup frame is reached
+  nsIFrame* GetParentFrameNotPopup(nsIFrame* aFrame);
+
+  nsIFrame* GetFirstChild(nsIFrame* aFrame);
+  nsIFrame* GetLastChild(nsIFrame* aFrame);
+
+  nsIFrame* GetNextSibling(nsIFrame* aFrame);
+  nsIFrame* GetPrevSibling(nsIFrame* aFrame);
+
+  /*
+   These methods are overridden by the bidi visual iterator to have the
+   semantics of "get first child in visual order", "get last child in visual
+   order", "get next sibling in visual order" and "get previous sibling in
+   visual order".
+  */
+
+  virtual nsIFrame* GetFirstChildInner(nsIFrame* aFrame);
+  virtual nsIFrame* GetLastChildInner(nsIFrame* aFrame);
+
+  virtual nsIFrame* GetNextSiblingInner(nsIFrame* aFrame);
+  virtual nsIFrame* GetPrevSiblingInner(nsIFrame* aFrame);
+
+  /**
+   * Return the placeholder frame for aFrame if it has one, otherwise return
+   * aFrame itself.
+   */
+  nsIFrame* GetPlaceholderFrame(nsIFrame* aFrame);
+  bool IsPopupFrame(nsIFrame* aFrame);
+
+  bool IsInvokerOpenPopoverFrame(nsIFrame* aFrame);
+
+  nsPresContext* const mPresContext;
+  const bool mLockScroll;
+  const bool mFollowOOFs;
+  const bool mSkipPopupChecks;
+  const nsIteratorType mType;
+
+ private:
+  nsIFrame* const mStart;
+  nsIFrame* mCurrent;
+  nsIFrame* mLast;  // the last one that was in current;
+  nsIFrame* mLimiter;
+  int8_t mOffEdge;  // 0= no -1 to far prev, 1 to far next;
+};
+
+nsresult NS_NewFrameTraversal(nsFrameIterator** aEnumerator,
                               nsPresContext* aPresContext, nsIFrame* aStart,
                               nsIteratorType aType, bool aVisual,
                               bool aLockInScrollView, bool aFollowOOFs,
@@ -27,7 +127,7 @@
 
   NS_DECL_ISUPPORTS
 
-  NS_IMETHOD NewFrameTraversal(nsIFrameEnumerator** aEnumerator,
+  NS_IMETHOD NewFrameTraversal(nsFrameIterator** aEnumerator,
                                nsPresContext* aPresContext, nsIFrame* aStart,
                                int32_t aType, bool aVisual,
                                bool aLockInScrollView, bool aFollowOOFs,