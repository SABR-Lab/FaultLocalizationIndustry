# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.h
# Commit: 21be69951c96
# Full Hash: 21be69951c962d3833d7117f56c2909b20b3d841
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2024-01-14 09:31:25
# Regressor Bug: 1874534
# File Overlap Count: 2
# Description:
#   Bug 1874534 - Fix DrawTargetWebgl and RemoteTextureMap context loss handling. r=aosmond
#   
#   When a context loss occurs on DrawTargetWebgl, this may result in a fallback TextureData
#   being created. Each of these are currently managed by two different RemoteTextureOwnerClients.
#   This is not really safe at all.
# ==============================================================================

diff -r 0930954b46bb -r 21be69951c96 dom/canvas/DrawTargetWebgl.h
--- a/dom/canvas/DrawTargetWebgl.h	Sat Jan 13 18:00:25 2024 +0000
+++ b/dom/canvas/DrawTargetWebgl.h	Sat Jan 13 18:19:24 2024 +0000
@@ -39,6 +39,10 @@
 class GLContext;
 }  // namespace gl
 
+namespace layers {
+class RemoteTextureOwnerClient;
+}  // namespace layers
+
 namespace gfx {
 
 class DataSourceSurface;
@@ -448,6 +452,9 @@
   }
   BackendType GetBackendType() const override { return BackendType::WEBGL; }
   IntSize GetSize() const override { return mSize; }
+  const RefPtr<SharedContextWebgl>& GetSharedContext() const {
+    return mSharedContext;
+  }
 
   bool HasDataSnapshot() const;
   void PrepareData();
@@ -564,9 +571,9 @@
   void SetTransform(const Matrix& aTransform) override;
   void* GetNativeSurface(NativeSurfaceType aType) override;
 
-  void CopyToSwapChain(layers::RemoteTextureId aId,
-                       layers::RemoteTextureOwnerId aOwnerId,
-                       base::ProcessId aPid = base::kInvalidProcessId);
+  void CopyToSwapChain(
+      layers::RemoteTextureId aId, layers::RemoteTextureOwnerId aOwnerId,
+      layers::RemoteTextureOwnerClient* aOwnerClient = nullptr);
 
   void OnMemoryPressure() { mSharedContext->OnMemoryPressure(); }
 