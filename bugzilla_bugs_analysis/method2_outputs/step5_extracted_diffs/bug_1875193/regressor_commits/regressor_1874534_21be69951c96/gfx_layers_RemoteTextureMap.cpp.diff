# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/RemoteTextureMap.cpp
# Commit: 21be69951c96
# Full Hash: 21be69951c962d3833d7117f56c2909b20b3d841
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2024-01-14 09:31:25
# Regressor Bug: 1874534
# File Overlap Count: 2
# Description:
#   Bug 1874534 - Fix DrawTargetWebgl and RemoteTextureMap context loss handling. r=aosmond
#   
#   When a context loss occurs on DrawTargetWebgl, this may result in a fallback TextureData
#   being created. Each of these are currently managed by two different RemoteTextureOwnerClients.
#   This is not really safe at all.
# ==============================================================================

diff -r 0930954b46bb -r 21be69951c96 gfx/layers/RemoteTextureMap.cpp
--- a/gfx/layers/RemoteTextureMap.cpp	Sat Jan 13 18:00:25 2024 +0000
+++ b/gfx/layers/RemoteTextureMap.cpp	Sat Jan 13 18:19:24 2024 +0000
@@ -84,18 +84,40 @@
                                                  mSharedRecycleBin);
 }
 
-void RemoteTextureOwnerClient::NotifyContextLost() {
-  if (mOwnerIds.empty()) {
+void RemoteTextureOwnerClient::NotifyContextLost(
+    const RemoteTextureOwnerIdSet* aOwnerIds) {
+  if (aOwnerIds) {
+    for (const auto& id : *aOwnerIds) {
+      if (mOwnerIds.find(id) == mOwnerIds.end()) {
+        MOZ_ASSERT_UNREACHABLE("owner id not registered by client");
+        return;
+      }
+    }
+  } else {
+    aOwnerIds = &mOwnerIds;
+  }
+  if (aOwnerIds->empty()) {
     return;
   }
-  RemoteTextureMap::Get()->NotifyContextLost(mOwnerIds, mForPid);
+  RemoteTextureMap::Get()->NotifyContextLost(*aOwnerIds, mForPid);
 }
 
-void RemoteTextureOwnerClient::NotifyContextRestored() {
-  if (mOwnerIds.empty()) {
+void RemoteTextureOwnerClient::NotifyContextRestored(
+    const RemoteTextureOwnerIdSet* aOwnerIds) {
+  if (aOwnerIds) {
+    for (const auto& id : *aOwnerIds) {
+      if (mOwnerIds.find(id) == mOwnerIds.end()) {
+        MOZ_ASSERT_UNREACHABLE("owner id not registered by client");
+        return;
+      }
+    }
+  } else {
+    aOwnerIds = &mOwnerIds;
+  }
+  if (aOwnerIds->empty()) {
     return;
   }
-  RemoteTextureMap::Get()->NotifyContextRestored(mOwnerIds, mForPid);
+  RemoteTextureMap::Get()->NotifyContextRestored(*aOwnerIds, mForPid);
 }
 
 void RemoteTextureOwnerClient::PushTexture(
@@ -663,9 +685,7 @@
 }
 
 void RemoteTextureMap::UnregisterTextureOwners(
-    const std::unordered_set<RemoteTextureOwnerId,
-                             RemoteTextureOwnerId::HashFn>& aOwnerIds,
-    const base::ProcessId aForPid) {
+    const RemoteTextureOwnerIdSet& aOwnerIds, const base::ProcessId aForPid) {
   std::vector<UniquePtr<TextureOwner>>
       releasingOwners;  // Release outside the monitor
   std::vector<RefPtr<TextureHost>>
@@ -770,9 +790,7 @@
 }
 
 void RemoteTextureMap::ClearRecycledTextures(
-    const std::unordered_set<RemoteTextureOwnerId,
-                             RemoteTextureOwnerId::HashFn>& aOwnerIds,
-    const base::ProcessId aForPid,
+    const RemoteTextureOwnerIdSet& aOwnerIds, const base::ProcessId aForPid,
     const RefPtr<RemoteTextureRecycleBin>& aRecycleBin) {
   std::list<RemoteTextureRecycleBin::RecycledTextureHolder>
       releasingTextures;  // Release outside the monitor
@@ -800,9 +818,7 @@
 }
 
 void RemoteTextureMap::NotifyContextLost(
-    const std::unordered_set<RemoteTextureOwnerId,
-                             RemoteTextureOwnerId::HashFn>& aOwnerIds,
-    const base::ProcessId aForPid) {
+    const RemoteTextureOwnerIdSet& aOwnerIds, const base::ProcessId aForPid) {
   MonitorAutoLock lock(mMonitor);
 
   for (const auto& id : aOwnerIds) {
@@ -820,9 +836,7 @@
 }
 
 void RemoteTextureMap::NotifyContextRestored(
-    const std::unordered_set<RemoteTextureOwnerId,
-                             RemoteTextureOwnerId::HashFn>& aOwnerIds,
-    const base::ProcessId aForPid) {
+    const RemoteTextureOwnerIdSet& aOwnerIds, const base::ProcessId aForPid) {
   MonitorAutoLock lock(mMonitor);
 
   for (const auto& id : aOwnerIds) {