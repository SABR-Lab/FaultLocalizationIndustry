# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/layers/ipc/CanvasTranslator.cpp
# Commit: 21be69951c96
# Full Hash: 21be69951c962d3833d7117f56c2909b20b3d841
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2024-01-14 09:31:25
# Regressor Bug: 1874534
# File Overlap Count: 2
# Description:
#   Bug 1874534 - Fix DrawTargetWebgl and RemoteTextureMap context loss handling. r=aosmond
#   
#   When a context loss occurs on DrawTargetWebgl, this may result in a fallback TextureData
#   being created. Each of these are currently managed by two different RemoteTextureOwnerClients.
#   This is not really safe at all.
# ==============================================================================

diff -r 0930954b46bb -r 21be69951c96 gfx/layers/ipc/CanvasTranslator.cpp
--- a/gfx/layers/ipc/CanvasTranslator.cpp	Sat Jan 13 18:00:25 2024 +0000
+++ b/gfx/layers/ipc/CanvasTranslator.cpp	Sat Jan 13 18:19:24 2024 +0000
@@ -112,10 +112,12 @@
 
 bool CanvasTranslator::EnsureSharedContextWebgl() {
   if (!mSharedContext || mSharedContext->IsContextLost()) {
+    if (mSharedContext) {
+      ForceDrawTargetWebglFallback();
+    }
     mSharedContext = gfx::SharedContextWebgl::Create();
     if (!mSharedContext || mSharedContext->IsContextLost()) {
       mSharedContext = nullptr;
-      ForceDrawTargetWebglFallback();
       BlockCanvas();
       return false;
     }
@@ -388,9 +390,9 @@
   gfx::CanvasManagerParent::DisableRemoteCanvas();
 }
 
-inline gfx::DrawTargetWebgl* CanvasTranslator::TextureInfo::GetDrawTargetWebgl()
-    const {
-  if (!mTextureData && mDrawTarget &&
+inline gfx::DrawTargetWebgl* CanvasTranslator::TextureInfo::GetDrawTargetWebgl(
+    bool aCheckForFallback) const {
+  if ((!mTextureData || !aCheckForFallback) && mDrawTarget &&
       mDrawTarget->GetBackendType() == gfx::BackendType::WEBGL) {
     return static_cast<gfx::DrawTargetWebgl*>(mDrawTarget.get());
   }
@@ -401,22 +403,31 @@
   // This looks for any DrawTargetWebgls that have a cached data snapshot that
   // can be used to recover a fallback TextureData in the event of a context
   // loss.
+  RemoteTextureOwnerIdSet lost;
   for (const auto& entry : mTextureInfo) {
     const auto& info = entry.second;
     if (gfx::DrawTargetWebgl* webgl = info.GetDrawTargetWebgl()) {
-      if (!webgl->HasDataSnapshot()) {
-        continue;
+      NotifyRequiresRefresh(entry.first);
+      if (webgl->HasDataSnapshot()) {
+        if (RefPtr<gfx::DrawTarget> dt = CreateFallbackDrawTarget(
+                info.mRefPtr, entry.first, info.mRemoteTextureOwnerId,
+                webgl->GetSize(), webgl->GetFormat())) {
+          webgl->CopyToFallback(dt);
+          AddDrawTarget(info.mRefPtr, dt);
+          continue;
+        }
       }
-      RefPtr<gfx::DrawTarget> dt = CreateFallbackDrawTarget(
-          info.mRefPtr, entry.first, info.mRemoteTextureOwnerId,
-          webgl->GetSize(), webgl->GetFormat());
-      if (!dt) {
-        continue;
+      // No fallback could be created, so we need to notify the compositor the
+      // texture won't be pushed.
+      if (mRemoteTextureOwner &&
+          mRemoteTextureOwner->IsRegistered(info.mRemoteTextureOwnerId)) {
+        lost.insert(info.mRemoteTextureOwnerId);
       }
-      webgl->CopyToFallback(dt);
-      AddDrawTarget(info.mRefPtr, dt);
     }
   }
+  if (!lost.empty()) {
+    mRemoteTextureOwner->NotifyContextLost(&lost);
+  }
 }
 
 void CanvasTranslator::BlockCanvas() {
@@ -717,10 +728,10 @@
 }
 
 gfx::DrawTargetWebgl* CanvasTranslator::GetDrawTargetWebgl(
-    int64_t aTextureId) const {
+    int64_t aTextureId, bool aCheckForFallback) const {
   auto result = mTextureInfo.find(aTextureId);
   if (result != mTextureInfo.end()) {
-    return result->second.GetDrawTargetWebgl();
+    return result->second.GetDrawTargetWebgl(aCheckForFallback);
   }
   return nullptr;
 }
@@ -728,9 +739,13 @@
 void CanvasTranslator::NotifyRequiresRefresh(int64_t aTextureId,
                                              bool aDispatch) {
   if (aDispatch) {
-    DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
-        "CanvasTranslator::NotifyRequiresRefresh", this,
-        &CanvasTranslator::NotifyRequiresRefresh, aTextureId, false));
+    auto& info = mTextureInfo[aTextureId];
+    if (!info.mNotifiedRequiresRefresh) {
+      info.mNotifiedRequiresRefresh = true;
+      DispatchToTaskQueue(NewRunnableMethod<int64_t, bool>(
+          "CanvasTranslator::NotifyRequiresRefresh", this,
+          &CanvasTranslator::NotifyRequiresRefresh, aTextureId, false));
+    }
     return;
   }
 
@@ -767,8 +782,20 @@
 }
 
 void CanvasTranslator::PrepareShmem(int64_t aTextureId) {
-  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId)) {
-    webgl->PrepareData();
+  if (gfx::DrawTargetWebgl* webgl = GetDrawTargetWebgl(aTextureId, false)) {
+    if (const auto& fallback = mTextureInfo[aTextureId].mTextureData) {
+      // If there was a fallback, copy the fallback to the software framebuffer
+      // shmem for reading.
+      if (RefPtr<gfx::DrawTarget> dt = fallback->BorrowDrawTarget()) {
+        if (RefPtr<gfx::SourceSurface> snapshot = dt->Snapshot()) {
+          webgl->CopySurface(snapshot, snapshot->GetRect(),
+                             gfx::IntPoint(0, 0));
+        }
+      }
+    } else {
+      // Otherwise, just ensure the software framebuffer is up to date.
+      webgl->PrepareData();
+    }
   }
 }
 
@@ -955,8 +982,7 @@
   if (gfx::DrawTargetWebgl* webgl = info.GetDrawTargetWebgl()) {
     if (info.mTextureLockMode & OpenMode::OPEN_WRITE) {
       webgl->EndFrame();
-      if (!info.mNotifiedRequiresRefresh && webgl->RequiresRefresh()) {
-        info.mNotifiedRequiresRefresh = true;
+      if (webgl->RequiresRefresh()) {
         NotifyRequiresRefresh(aTextureId);
       }
     }
@@ -972,10 +998,20 @@
   }
   auto& info = result->second;
   RemoteTextureOwnerId ownerId = info.mRemoteTextureOwnerId;
+  if (gfx::DrawTargetWebgl* webgl = info.GetDrawTargetWebgl()) {
+    EnsureRemoteTextureOwner(ownerId);
+    // Check for context loss to avoid CopyToSwapChain becoming a no-op.
+    if (webgl->IsValid()) {
+      webgl->CopyToSwapChain(aId, ownerId, mRemoteTextureOwner);
+      if (webgl->IsValid()) {
+        return true;
+      }
+    }
+    // If the context was lost, try to create a fallback to push instead.
+    EnsureSharedContextWebgl();
+  }
   if (TextureData* data = info.mTextureData.get()) {
     PushRemoteTexture(aTextureId, data, aId, ownerId);
-  } else if (gfx::DrawTargetWebgl* webgl = info.GetDrawTargetWebgl()) {
-    webgl->CopyToSwapChain(aId, ownerId, mOtherPid);
   }
   return true;
 }
@@ -984,7 +1020,7 @@
   if (!mRemoteTextureOwner) {
     mRemoteTextureOwner = new RemoteTextureOwnerClient(mOtherPid);
   }
-  if (!mRemoteTextureOwner->IsRegistered(aOwnerId)) {
+  if (aOwnerId.IsValid() && !mRemoteTextureOwner->IsRegistered(aOwnerId)) {
     mRemoteTextureOwner->RegisterTextureOwner(aOwnerId,
                                               /* aSharedRecycling */ true);
   }