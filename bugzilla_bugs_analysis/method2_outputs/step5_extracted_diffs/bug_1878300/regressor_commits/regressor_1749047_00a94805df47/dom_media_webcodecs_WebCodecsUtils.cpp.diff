# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/WebCodecsUtils.cpp
# Commit: 00a94805df47
# Full Hash: 00a94805df47d668512f6404361887704f23bb00
# Author: Paul Adenot <paul@paul.cx>
# Date: 2023-12-23 09:52:03
# Regressor Bug: 1749047
# File Overlap Count: 3
# Description:
#   Bug 1749047 - Allow diffing and producing a configuration change list between two encoder configuration. r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D195707
# ==============================================================================

diff -r e3395cf67e5c -r 00a94805df47 dom/media/webcodecs/WebCodecsUtils.cpp
--- a/dom/media/webcodecs/WebCodecsUtils.cpp	Fri Dec 22 21:39:07 2023 +0000
+++ b/dom/media/webcodecs/WebCodecsUtils.cpp	Fri Dec 22 21:39:07 2023 +0000
@@ -322,5 +322,189 @@
 #endif
 }
 
-} // namespace mozilla::dom
+template <typename T>
+nsCString MaybeToString(const Maybe<T>& aMaybe) {
+  return nsPrintfCString(
+      "%s", aMaybe.isSome() ? ToString(aMaybe.value()).c_str() : "nothing");
+}
+
+struct ConfigurationChangeToString {
+  nsCString operator()(const CodecChange& aCodecChange) {
+    return nsPrintfCString("Codec: %s",
+                           NS_ConvertUTF16toUTF8(aCodecChange.get()).get());
+  }
+  nsCString operator()(const DimensionsChange& aDimensionChange) {
+    return nsPrintfCString("Dimensions: %dx%d", aDimensionChange.get().width,
+                           aDimensionChange.get().height);
+  }
+  nsCString operator()(const DisplayDimensionsChange& aDisplayDimensionChange) {
+    if (aDisplayDimensionChange.get().isNothing()) {
+      return nsPrintfCString("Display dimensions: nothing");
+    }
+    gfx::IntSize displayDimensions = aDisplayDimensionChange.get().value();
+    return nsPrintfCString("Dimensions: %dx%d", displayDimensions.width,
+                           displayDimensions.height);
+  }
+  nsCString operator()(const BitrateChange& aBitrateChange) {
+    return nsPrintfCString("Bitrate: %skbps",
+                           MaybeToString(aBitrateChange.get()).get());
+  }
+  nsCString operator()(const FramerateChange& aFramerateChange) {
+    return nsPrintfCString("Framerate: %sHz",
+                           MaybeToString(aFramerateChange.get()).get());
+  }
+  nsCString operator()(
+      const HardwareAccelerationChange& aHardwareAccelerationChange) {
+    return nsPrintfCString("HW acceleration: %s",
+                           dom::HardwareAccelerationValues::GetString(
+                               aHardwareAccelerationChange.get())
+                               .data());
+  }
+  nsCString operator()(const AlphaChange& aAlphaChange) {
+    return nsPrintfCString(
+        "Alpha: %s",
+        dom::AlphaOptionValues::GetString(aAlphaChange.get()).data());
+  }
+  nsCString operator()(const ScalabilityModeChange& aScalabilityModeChange) {
+    if (aScalabilityModeChange.get().isNothing()) {
+      return nsCString("Scalability mode: nothing");
+    }
+    return nsPrintfCString(
+        "Scalability mode: %s",
+        NS_ConvertUTF16toUTF8(aScalabilityModeChange.get().value()).get());
+  }
+  nsCString operator()(const BitrateModeChange& aBitrateModeChange) {
+    return nsPrintfCString(
+        "Bitrate mode: %s",
+        dom::VideoEncoderBitrateModeValues::GetString(aBitrateModeChange.get())
+            .data());
+  }
+  nsCString operator()(const LatencyModeChange& aLatencyModeChange) {
+    return nsPrintfCString(
+        "Latency mode: %s",
+        dom::LatencyModeValues::GetString(aLatencyModeChange.get()).data());
+  }
+  nsCString operator()(const ContentHintChange& aContentHintChange) {
+    return nsPrintfCString("Content hint: %s",
+                           MaybeToString(aContentHintChange.get()).get());
+  }
+  template <typename T>
+  nsCString operator()(const T& aNewBitrate) {
+    return nsPrintfCString("Not implemented");
+  }
+};
+
+nsString WebCodecsConfigurationChangeList::ToString() const {
+  nsString rv;
+  for (const WebCodecsEncoderConfigurationItem& change : mChanges) {
+    nsCString str = change.match(ConfigurationChangeToString());
+    rv.AppendPrintf("- %s\n", str.get());
+  }
+  return rv;
+}
 
+using CodecChange = StrongTypedef<nsString, struct CodecChangeTypeWebCodecs>;
+using DimensionsChange = StrongTypedef<gfx::IntSize, struct DimensionsChangeTypeWebCodecs>;
+using DisplayDimensionsChange = StrongTypedef<Maybe<gfx::IntSize>, struct DisplayDimensionsChangeTypeWebCodecs>;
+using BitrateChange = StrongTypedef<Maybe<uint32_t>, struct BitrateChangeTypeWebCodecs>;
+using FramerateChange =
+    StrongTypedef<Maybe<double>, struct FramerateChangeTypeWebCodecs>;
+using HardwareAccelerationChange =
+    StrongTypedef<dom::HardwareAcceleration,
+                  struct HardwareAccelerationChangeTypeWebCodecs>;
+using AlphaChange = StrongTypedef<dom::AlphaOption, struct AlphaChangeTypeWebCodecs>;
+using ScalabilityModeChange =
+    StrongTypedef<Maybe<nsString>, struct ScalabilityModeChangeTypeWebCodecs>;
+using BitrateModeChange =
+    StrongTypedef<dom::VideoEncoderBitrateMode, struct BitrateModeChangeTypeWebCodecs>;
+using LatencyModeChange =
+    StrongTypedef<dom::LatencyMode, struct LatencyModeTypeChangeTypeWebCodecs>;
+using ContentHintChange =
+    StrongTypedef<Maybe<nsString>, struct ContentHintTypeTypeWebCodecs>;
+
+bool WebCodecsConfigurationChangeList::CanAttemptReconfigure() const {
+  for (const auto& change : mChanges) {
+    if (change.is<CodecChange>() ||
+        change.is<HardwareAccelerationChange>() ||
+        change.is<AlphaChange>() ||
+        change.is<ScalabilityModeChange>()) {
+      return false;
+    }
+  }
+  return true;
+}
+
+RefPtr<EncoderConfigurationChangeList>
+WebCodecsConfigurationChangeList::ToPEMChangeList() const {
+  auto rv = MakeRefPtr<EncoderConfigurationChangeList>();
+  MOZ_ASSERT(CanAttemptReconfigure());
+  for (const auto& change : mChanges) {
+    if (change.is<dom::DimensionsChange>()) {
+      rv->Push(mozilla::DimensionsChange(change.as<DimensionsChange>().get()));
+    } else if (change.is<dom::DisplayDimensionsChange>()) {
+      rv->Push(mozilla::DisplayDimensionsChange(change.as<DisplayDimensionsChange>().get()));
+    } else if (change.is<dom::BitrateChange>()) {
+      rv->Push(mozilla::BitrateChange(change.as<BitrateChange>().get()));
+    } else if (change.is<FramerateChange>()) {
+      rv->Push(mozilla::FramerateChange(change.as<FramerateChange>().get()));
+    } else if (change.is<dom::BitrateModeChange>()) {
+      MediaDataEncoder::BitrateMode mode;
+      if (change.as<dom::BitrateModeChange>().get() == dom::VideoEncoderBitrateMode::Constant) {
+        mode = MediaDataEncoder::BitrateMode::Constant;
+      } else if (change.as<BitrateModeChange>().get() == dom::VideoEncoderBitrateMode::Variable) {
+        mode = MediaDataEncoder::BitrateMode::Variable;
+      } else {
+        // Quantizer, not underlying support yet.
+        mode = MediaDataEncoder::BitrateMode::Variable;
+      }
+      rv->Push(mozilla::BitrateModeChange(mode));
+    } else if (change.is<LatencyModeChange>()) {
+      MediaDataEncoder::Usage usage;
+      if (change.as<LatencyModeChange>().get() == dom::LatencyMode::Quality) {
+        usage = MediaDataEncoder::Usage::Record;
+      } else {
+        usage = MediaDataEncoder::Usage::Realtime;
+      }
+      rv->Push(UsageChange(usage));
+    } else if (change.is<ContentHintChange>()) {
+      rv->Push(mozilla::ContentHintChange(change.as<ContentHintChange>().get()));
+    }
+  }
+  return rv.forget();
+}
+
+#define ENUM_TO_STRING(enumType, enumValue) \
+  enumType##Values::GetString(enumValue).data()
+
+nsCString ColorSpaceInitToString(
+    const dom::VideoColorSpaceInit& aColorSpaceInit) {
+  nsCString rv("VideoColorSpace");
+
+  if (!aColorSpaceInit.mFullRange.IsNull()) {
+    rv.AppendPrintf(" range: %s",
+                    aColorSpaceInit.mFullRange.Value() ? "true" : "false");
+  }
+  if (!aColorSpaceInit.mMatrix.IsNull()) {
+    rv.AppendPrintf(" matrix: %s",
+                    ENUM_TO_STRING(dom::VideoMatrixCoefficients,
+                                   aColorSpaceInit.mMatrix.Value()));
+  }
+  if (!aColorSpaceInit.mTransfer.IsNull()) {
+    rv.AppendPrintf(" transfer: %s",
+                    ENUM_TO_STRING(dom::VideoTransferCharacteristics,
+                                   aColorSpaceInit.mTransfer.Value()));
+  }
+  if (!aColorSpaceInit.mPrimaries.IsNull()) {
+    rv.AppendPrintf(" primaries: %s",
+                    ENUM_TO_STRING(dom::VideoColorPrimaries,
+                                   aColorSpaceInit.mPrimaries.Value()));
+  }
+
+  return rv;
+}
+
+RefPtr<TaskQueue> GetWebCodecsEncoderTaskQueue() {
+  return TaskQueue::Create(
+      GetMediaThreadPool(MediaThreadType::PLATFORM_ENCODER),
+      "WebCodecs encoding", false);
+}