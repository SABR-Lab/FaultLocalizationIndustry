# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/WebCodecsUtils.h
# Commit: 00a94805df47
# Full Hash: 00a94805df47d668512f6404361887704f23bb00
# Author: Paul Adenot <paul@paul.cx>
# Date: 2023-12-23 09:52:03
# Regressor Bug: 1749047
# File Overlap Count: 3
# Description:
#   Bug 1749047 - Allow diffing and producing a configuration change list between two encoder configuration. r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D195707
# ==============================================================================

diff -r e3395cf67e5c -r 00a94805df47 dom/media/webcodecs/WebCodecsUtils.h
--- a/dom/media/webcodecs/WebCodecsUtils.h	Fri Dec 22 21:39:07 2023 +0000
+++ b/dom/media/webcodecs/WebCodecsUtils.h	Fri Dec 22 21:39:07 2023 +0000
@@ -150,6 +150,76 @@
 
 bool IsOnAndroid();
 bool IsOnMacOS();
+
+
+// Wrap a type to make it unique. This allows using ergonomically in the Variant
+// below. Simply aliasing with `using` isn't enough, because typedefs in C++
+// don't produce strong types, so two integer variants result in
+// the same type, making it ambiguous to the Variant code.
+// T is the type to be wrapped. Phantom is a type that is only used to
+// disambiguate and should be unique in the program.
+template <typename T, typename Phantom>
+class StrongTypedef
+{
+  public:
+    explicit StrongTypedef(T const& value) : mValue(value) {}
+    explicit StrongTypedef(T&& value) : mValue(std::move(value)) {}
+    T& get() { return mValue; }
+    T const& get() const {return mValue; }
+private:
+    T mValue;
+};
+
+using CodecChange = StrongTypedef<nsString, struct CodecChangeTypeWebCodecs>;
+using DimensionsChange = StrongTypedef<gfx::IntSize, struct DimensionsChangeTypeWebCodecs>;
+using DisplayDimensionsChange = StrongTypedef<Maybe<gfx::IntSize>, struct DisplayDimensionsChangeTypeWebCodecs>;
+using BitrateChange = StrongTypedef<Maybe<uint32_t>, struct BitrateChangeTypeWebCodecs>;
+using FramerateChange =
+    StrongTypedef<Maybe<double>, struct FramerateChangeTypeWebCodecs>;
+using HardwareAccelerationChange =
+    StrongTypedef<dom::HardwareAcceleration,
+                  struct HardwareAccelerationChangeTypeWebCodecs>;
+using AlphaChange = StrongTypedef<dom::AlphaOption, struct AlphaChangeTypeWebCodecs>;
+using ScalabilityModeChange =
+    StrongTypedef<Maybe<nsString>, struct ScalabilityModeChangeTypeWebCodecs>;
+using BitrateModeChange =
+    StrongTypedef<dom::VideoEncoderBitrateMode, struct BitrateModeChangeTypeWebCodecs>;
+using LatencyModeChange =
+    StrongTypedef<dom::LatencyMode, struct LatencyModeTypeChangeTypeWebCodecs>;
+using ContentHintChange =
+    StrongTypedef<Maybe<nsString>, struct ContentHintTypeTypeWebCodecs>;
+
+using WebCodecsEncoderConfigurationItem =
+    Variant<CodecChange, DimensionsChange, DisplayDimensionsChange,
+            BitrateModeChange, BitrateChange, FramerateChange,
+            HardwareAccelerationChange, AlphaChange, ScalabilityModeChange,
+            LatencyModeChange, ContentHintChange>;
+
+struct WebCodecsConfigurationChangeList {
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(WebCodecsConfigurationChangeList)
+  bool Empty() const {
+    return mChanges.IsEmpty();
+  }
+  template<typename T>
+  void Push(const T& aItem) {
+    mChanges.AppendElement(aItem);
+  }
+  // This returns true if it should be possible to attempt to reconfigure the
+  // encoder on the fly. It can fail, in which case the encoder will be flushed
+  // and a new one will be created with the new set of parameters.
+  bool CanAttemptReconfigure() const;
+
+  // Convert this to the format the underlying PEM can understand
+  RefPtr<EncoderConfigurationChangeList> ToPEMChangeList() const;
+  nsString ToString() const;
+
+  nsTArray<WebCodecsEncoderConfigurationItem> mChanges;
+ private:
+  ~WebCodecsConfigurationChangeList() = default;
+};
+
+nsCString ColorSpaceInitToString(const dom::VideoColorSpaceInit& aColorSpaceInit);
+
 RefPtr<TaskQueue> GetWebCodecsEncoderTaskQueue();
 
 } // namespace dom
