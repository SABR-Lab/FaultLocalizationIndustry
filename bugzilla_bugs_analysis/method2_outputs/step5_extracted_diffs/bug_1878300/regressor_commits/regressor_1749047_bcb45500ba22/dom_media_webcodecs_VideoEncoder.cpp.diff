# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/VideoEncoder.cpp
# Commit: bcb45500ba22
# Full Hash: bcb45500ba2223a5e21bcc29922c1260d350694f
# Author: Paul Adenot <paul@paul.cx>
# Date: 2023-12-23 09:52:03
# Regressor Bug: 1749047
# File Overlap Count: 3
# Description:
#   Bug 1749047 - Wire up more codecs from VideoEncoder to the new FFmpeg PEM. r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D196108
# ==============================================================================

diff -r a78bb8799ef4 -r bcb45500ba22 dom/media/webcodecs/VideoEncoder.cpp
--- a/dom/media/webcodecs/VideoEncoder.cpp	Fri Dec 22 21:39:12 2023 +0000
+++ b/dom/media/webcodecs/VideoEncoder.cpp	Fri Dec 22 21:39:13 2023 +0000
@@ -216,7 +216,13 @@
              mozilla::dom::HardwareAcceleration::Prefer_software) {
     hwPref = MediaDataEncoder::HardwarePreference::RequireSoftware;
   }
-  CodecType codecType = CodecType::H264;
+  CodecType codecType;
+  auto maybeCodecType = CodecStringToCodecType(mCodec);
+  if (maybeCodecType.isSome()) {
+    codecType = maybeCodecType.value();
+  } else {
+    MOZ_CRASH("The string should always contain a valid codec at this point.");
+  }
   Maybe<EncoderConfig::CodecSpecific> specific;
   if (codecType == CodecType::H264) {
     uint8_t profile, constraints, level;
@@ -231,6 +237,19 @@
     ExtractH264CodecDetails(mCodec, profile, constraints, level);
     specific.emplace(H264Specific(static_cast<H264_PROFILE>(profile), format));
   }
+  // Only for vp9, not vp8
+  if (codecType == CodecType::VP9) {
+    uint8_t profile, level, bitdepth, chromasubsampling;
+    mozilla::VideoColorSpace colorspace;
+    DebugOnly<bool> rv = ExtractVPXCodecDetails(
+        mCodec, profile, level, bitdepth, chromasubsampling, colorspace);
+#ifdef DEBUG
+    if (!rv) {
+      LOGE("Error extracting VPX codec details, non fatal");
+    }
+#endif
+    specific.emplace(VP9Specific());
+  }
   return EncoderConfig(
       codecType, {mWidth, mHeight}, usage, ImageBitmapFormat::RGBA32, ImageBitmapFormat::RGBA32,
       AssertedCast<uint8_t>(mFramerate.refOr(0.f)), 0, mBitrate.refOr(0),