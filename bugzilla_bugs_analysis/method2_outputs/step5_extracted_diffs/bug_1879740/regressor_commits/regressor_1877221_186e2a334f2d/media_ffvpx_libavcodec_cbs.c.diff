# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/cbs.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/cbs.c
--- a/media/ffvpx/libavcodec/cbs.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/cbs.c	Thu Feb 08 10:39:54 2024 +0000
@@ -28,6 +28,7 @@
 #include "avcodec.h"
 #include "cbs.h"
 #include "cbs_internal.h"
+#include "refstruct.h"
 
 
 static const CodedBitstreamType *const cbs_type_table[] = {
@@ -49,6 +50,9 @@
 #if CONFIG_CBS_MPEG2
     &ff_cbs_type_mpeg2,
 #endif
+#if CONFIG_CBS_VP8
+    &ff_cbs_type_vp8,
+#endif
 #if CONFIG_CBS_VP9
     &ff_cbs_type_vp9,
 #endif
@@ -73,6 +77,9 @@
 #if CONFIG_CBS_MPEG2
     AV_CODEC_ID_MPEG2VIDEO,
 #endif
+#if CONFIG_CBS_VP8
+    AV_CODEC_ID_VP8,
+#endif
 #if CONFIG_CBS_VP9
     AV_CODEC_ID_VP9,
 #endif
@@ -117,8 +124,9 @@
 
     ctx->decompose_unit_types = NULL;
 
-    ctx->trace_enable = 0;
-    ctx->trace_level  = AV_LOG_TRACE;
+    ctx->trace_enable  = 0;
+    ctx->trace_level   = AV_LOG_TRACE;
+    ctx->trace_context = ctx;
 
     *ctx_ptr = ctx;
     return 0;
@@ -151,7 +159,7 @@
 
 static void cbs_unit_uninit(CodedBitstreamUnit *unit)
 {
-    av_buffer_unref(&unit->content_ref);
+    ff_refstruct_unref(&unit->content_ref);
     unit->content = NULL;
 
     av_buffer_unref(&unit->data_ref);
@@ -199,7 +207,7 @@
                 continue;
         }
 
-        av_buffer_unref(&unit->content_ref);
+        ff_refstruct_unref(&unit->content_ref);
         unit->content = NULL;
 
         av_assert0(unit->data && unit->data_ref);
@@ -213,7 +221,7 @@
             av_log(ctx->log_ctx, AV_LOG_VERBOSE,
                    "Skipping decomposition of unit %d "
                    "(type %"PRIu32").\n", i, unit->type);
-            av_buffer_unref(&unit->content_ref);
+            ff_refstruct_unref(&unit->content_ref);
             unit->content = NULL;
         } else if (err < 0) {
             av_log(ctx->log_ctx, AV_LOG_ERROR, "Failed to read unit %d "
@@ -496,19 +504,27 @@
     av_log(ctx->log_ctx, ctx->trace_level, "%s\n", name);
 }
 
-void ff_cbs_trace_syntax_element(CodedBitstreamContext *ctx, int position,
-                                 const char *str, const int *subscripts,
-                                 const char *bits, int64_t value)
+void ff_cbs_trace_read_log(void *trace_context,
+                           GetBitContext *gbc, int length,
+                           const char *str, const int *subscripts,
+                           int64_t value)
 {
+    CodedBitstreamContext *ctx = trace_context;
     char name[256];
+    char bits[256];
     size_t name_len, bits_len;
     int pad, subs, i, j, k, n;
-
-    if (!ctx->trace_enable)
-        return;
+    int position;
 
     av_assert0(value >= INT_MIN && value <= UINT32_MAX);
 
+    position = get_bits_count(gbc);
+
+    av_assert0(length < 256);
+    for (i = 0; i < length; i++)
+        bits[i] = get_bits1(gbc) ? '1' : '0';
+    bits[length] = 0;
+
     subs = subscripts ? subscripts[0] : 0;
     n = 0;
     for (i = j = 0; str[i];) {
@@ -535,7 +551,7 @@
     av_assert0(n == subs);
 
     name_len = strlen(name);
-    bits_len = strlen(bits);
+    bits_len = length;
 
     if (name_len + bits_len > 60)
         pad = bits_len + 2;
@@ -546,6 +562,36 @@
            position, name, pad, bits, value);
 }
 
+void ff_cbs_trace_write_log(void *trace_context,
+                            PutBitContext *pbc, int length,
+                            const char *str, const int *subscripts,
+                            int64_t value)
+{
+    CodedBitstreamContext *ctx = trace_context;
+
+    // Ensure that the syntax element is written to the output buffer,
+    // make a GetBitContext pointed at the start position, then call the
+    // read log function which can read the bits back to log them.
+
+    GetBitContext gbc;
+    int position;
+
+    if (length > 0) {
+        PutBitContext flush;
+        flush = *pbc;
+        flush_put_bits(&flush);
+    }
+
+    position = put_bits_count(pbc);
+    av_assert0(position >= length);
+
+    init_get_bits(&gbc, pbc->buf, position);
+
+    skip_bits_long(&gbc, position - length);
+
+    ff_cbs_trace_read_log(ctx, &gbc, length, str, subscripts, value);
+}
+
 static av_always_inline int cbs_read_unsigned(CodedBitstreamContext *ctx,
                                               GetBitContext *gbc,
                                               int width, const char *name,
@@ -555,7 +601,8 @@
                                               uint32_t range_max)
 {
     uint32_t value;
-    int position;
+
+    CBS_TRACE_READ_START();
 
     av_assert0(width > 0 && width <= 32);
 
@@ -565,21 +612,9 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (ctx->trace_enable)
-        position = get_bits_count(gbc);
-
     value = get_bits_long(gbc, width);
 
-    if (ctx->trace_enable) {
-        char bits[33];
-        int i;
-        for (i = 0; i < width; i++)
-            bits[i] = value >> (width - i - 1) & 1 ? '1' : '0';
-        bits[i] = 0;
-
-        ff_cbs_trace_syntax_element(ctx, position, name, subscripts,
-                                    bits, value);
-    }
+    CBS_TRACE_READ_END();
 
     if (value < range_min || value > range_max) {
         av_log(ctx->log_ctx, AV_LOG_ERROR, "%s out of range: "
@@ -613,6 +648,8 @@
                           const int *subscripts, uint32_t value,
                           uint32_t range_min, uint32_t range_max)
 {
+    CBS_TRACE_WRITE_START();
+
     av_assert0(width > 0 && width <= 32);
 
     if (value < range_min || value > range_max) {
@@ -625,22 +662,13 @@
     if (put_bits_left(pbc) < width)
         return AVERROR(ENOSPC);
 
-    if (ctx->trace_enable) {
-        char bits[33];
-        int i;
-        for (i = 0; i < width; i++)
-            bits[i] = value >> (width - i - 1) & 1 ? '1' : '0';
-        bits[i] = 0;
-
-        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),
-                                    name, subscripts, bits, value);
-    }
-
     if (width < 32)
         put_bits(pbc, width, value);
     else
         put_bits32(pbc, value);
 
+    CBS_TRACE_WRITE_END();
+
     return 0;
 }
 
@@ -657,7 +685,8 @@
                        int32_t range_min, int32_t range_max)
 {
     int32_t value;
-    int position;
+
+    CBS_TRACE_READ_START();
 
     av_assert0(width > 0 && width <= 32);
 
@@ -667,21 +696,9 @@
         return AVERROR_INVALIDDATA;
     }
 
-    if (ctx->trace_enable)
-        position = get_bits_count(gbc);
-
     value = get_sbits_long(gbc, width);
 
-    if (ctx->trace_enable) {
-        char bits[33];
-        int i;
-        for (i = 0; i < width; i++)
-            bits[i] = value & (1U << (width - i - 1)) ? '1' : '0';
-        bits[i] = 0;
-
-        ff_cbs_trace_syntax_element(ctx, position, name, subscripts,
-                                    bits, value);
-    }
+    CBS_TRACE_READ_END();
 
     if (value < range_min || value > range_max) {
         av_log(ctx->log_ctx, AV_LOG_ERROR, "%s out of range: "
@@ -699,6 +716,8 @@
                         const int *subscripts, int32_t value,
                         int32_t range_min, int32_t range_max)
 {
+    CBS_TRACE_WRITE_START();
+
     av_assert0(width > 0 && width <= 32);
 
     if (value < range_min || value > range_max) {
@@ -711,22 +730,13 @@
     if (put_bits_left(pbc) < width)
         return AVERROR(ENOSPC);
 
-    if (ctx->trace_enable) {
-        char bits[33];
-        int i;
-        for (i = 0; i < width; i++)
-            bits[i] = value & (1U << (width - i - 1)) ? '1' : '0';
-        bits[i] = 0;
-
-        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),
-                                    name, subscripts, bits, value);
-    }
-
     if (width < 32)
         put_sbits(pbc, width, value);
     else
         put_bits32(pbc, value);
 
+    CBS_TRACE_WRITE_END();
+
     return 0;
 }
 
@@ -773,28 +783,22 @@
                                int position,
                                CodedBitstreamUnitType type,
                                void *content,
-                               AVBufferRef *content_buf)
+                               void *content_ref)
 {
     CodedBitstreamUnit *unit;
-    AVBufferRef *content_ref;
     int err;
 
     if (position == -1)
         position = frag->nb_units;
     av_assert0(position >= 0 && position <= frag->nb_units);
 
-    if (content_buf) {
-        content_ref = av_buffer_ref(content_buf);
-        if (!content_ref)
-            return AVERROR(ENOMEM);
-    } else {
-        content_ref = NULL;
-    }
+    err = cbs_insert_unit(frag, position);
+    if (err < 0)
+        return err;
 
-    err = cbs_insert_unit(frag, position);
-    if (err < 0) {
-        av_buffer_unref(&content_ref);
-        return err;
+    if (content_ref) {
+        // Create our own reference out of the user-supplied one.
+        content_ref = ff_refstruct_ref(content_ref);
     }
 
     unit = &frag->units[position];
@@ -868,15 +872,14 @@
                 (frag->nb_units - position) * sizeof(*frag->units));
 }
 
-static void cbs_default_free_unit_content(void *opaque, uint8_t *data)
+static void cbs_default_free_unit_content(FFRefStructOpaque opaque, void *content)
 {
-    const CodedBitstreamUnitTypeDescriptor *desc = opaque;
+    const CodedBitstreamUnitTypeDescriptor *desc = opaque.c;
 
     for (int i = 0; i < desc->type.ref.nb_offsets; i++) {
-        void **ptr = (void**)(data + desc->type.ref.offsets[i]);
+        void **ptr = (void**)((char*)content + desc->type.ref.offsets[i]);
         av_buffer_unref((AVBufferRef**)(ptr + 1));
     }
-    av_free(data);
 }
 
 static const CodedBitstreamUnitTypeDescriptor
@@ -907,6 +910,15 @@
     return NULL;
 }
 
+static void *cbs_alloc_content(const CodedBitstreamUnitTypeDescriptor *desc)
+{
+    return ff_refstruct_alloc_ext_c(desc->content_size, 0,
+                                    (FFRefStructOpaque){ .c = desc },
+                                    desc->content_type == CBS_CONTENT_TYPE_COMPLEX
+                                            ? desc->type.complex.content_free
+                                            : cbs_default_free_unit_content);
+}
+
 int ff_cbs_alloc_unit_content(CodedBitstreamContext *ctx,
                               CodedBitstreamUnit *unit)
 {
@@ -918,27 +930,17 @@
     if (!desc)
         return AVERROR(ENOSYS);
 
-    unit->content = av_mallocz(desc->content_size);
-    if (!unit->content)
+    unit->content_ref = cbs_alloc_content(desc);
+    if (!unit->content_ref)
         return AVERROR(ENOMEM);
-
-    unit->content_ref =
-        av_buffer_create(unit->content, desc->content_size,
-                         desc->content_type == CBS_CONTENT_TYPE_COMPLEX
-                                            ? desc->type.complex.content_free
-                                            : cbs_default_free_unit_content,
-                         (void*)desc, 0);
-    if (!unit->content_ref) {
-        av_freep(&unit->content);
-        return AVERROR(ENOMEM);
-    }
+    unit->content = unit->content_ref;
 
     return 0;
 }
 
-static int cbs_clone_internal_refs_unit_content(AVBufferRef **clone_ref,
-                                                const CodedBitstreamUnit *unit,
-                                                const CodedBitstreamUnitTypeDescriptor *desc)
+static int cbs_clone_noncomplex_unit_content(void **clonep,
+                                             const CodedBitstreamUnit *unit,
+                                             const CodedBitstreamUnitTypeDescriptor *desc)
 {
     const uint8_t *src;
     uint8_t *copy;
@@ -947,9 +949,15 @@
     av_assert0(unit->content);
     src = unit->content;
 
-    copy = av_memdup(src, desc->content_size);
+    copy = cbs_alloc_content(desc);
     if (!copy)
         return AVERROR(ENOMEM);
+    memcpy(copy, src, desc->content_size);
+    for (int i = 0; i < desc->type.ref.nb_offsets; i++) {
+        void **ptr = (void**)(copy + desc->type.ref.offsets[i]);
+        /* Zero all the AVBufferRefs as they are owned by src. */
+        *(ptr + 1) = NULL;
+    }
 
     for (i = 0; i < desc->type.ref.nb_offsets; i++) {
         const uint8_t *const *src_ptr = (const uint8_t* const*)(src + desc->type.ref.offsets[i]);
@@ -975,22 +983,12 @@
             goto fail;
         }
     }
-
-    *clone_ref = av_buffer_create(copy, desc->content_size,
-                                  cbs_default_free_unit_content,
-                                  (void*)desc, 0);
-    if (!*clone_ref) {
-        err = AVERROR(ENOMEM);
-        goto fail;
-    }
+    *clonep = copy;
 
     return 0;
 
 fail:
-    for (--i; i >= 0; i--)
-        av_buffer_unref((AVBufferRef**)(copy + desc->type.ref.offsets[i]));
-    av_freep(&copy);
-    *clone_ref = NULL;
+    ff_refstruct_unref(&copy);
     return err;
 }
 
@@ -1003,7 +1001,7 @@
                                   CodedBitstreamUnit *unit)
 {
     const CodedBitstreamUnitTypeDescriptor *desc;
-    AVBufferRef *ref;
+    void *new_content;
     int err;
 
     desc = cbs_find_unit_type_desc(ctx, unit);
@@ -1012,13 +1010,13 @@
 
     switch (desc->content_type) {
     case CBS_CONTENT_TYPE_INTERNAL_REFS:
-        err = cbs_clone_internal_refs_unit_content(&ref, unit, desc);
+        err = cbs_clone_noncomplex_unit_content(&new_content, unit, desc);
         break;
 
     case CBS_CONTENT_TYPE_COMPLEX:
         if (!desc->type.complex.content_clone)
             return AVERROR_PATCHWELCOME;
-        err = desc->type.complex.content_clone(&ref, unit);
+        err = desc->type.complex.content_clone(&new_content, unit);
         break;
 
     default:
@@ -1028,8 +1026,8 @@
     if (err < 0)
         return err;
 
-    unit->content_ref = ref;
-    unit->content     = ref->data;
+    unit->content_ref = new_content;
+    unit->content     = new_content;
     return 0;
 }
 
@@ -1045,17 +1043,17 @@
 int ff_cbs_make_unit_writable(CodedBitstreamContext *ctx,
                               CodedBitstreamUnit *unit)
 {
-    AVBufferRef *ref = unit->content_ref;
+    void *ref = unit->content_ref;
     int err;
 
     av_assert0(unit->content);
-    if (ref && av_buffer_is_writable(ref))
+    if (ref && ff_refstruct_exclusive(ref))
         return 0;
 
     err = cbs_clone_unit_content(ctx, unit);
     if (err < 0)
         return err;
-    av_buffer_unref(&ref);
+    ff_refstruct_unref(&ref);
     return 0;
 }
 