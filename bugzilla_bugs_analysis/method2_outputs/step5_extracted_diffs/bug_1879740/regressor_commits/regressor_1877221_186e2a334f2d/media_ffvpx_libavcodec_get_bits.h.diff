# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/get_bits.h
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/get_bits.h
--- a/media/ffvpx/libavcodec/get_bits.h	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/get_bits.h	Thu Feb 08 10:39:54 2024 +0000
@@ -93,6 +93,8 @@
 #define init_get_bits8      bits_init8
 #define align_get_bits      bits_align
 #define get_vlc2            bits_read_vlc
+#define get_vlc_multi       bits_read_vlc_multi
+#define get_leb             bits_read_leb
 
 #define init_get_bits8_le(s, buffer, byte_size) bits_init8_le((BitstreamContextLE*)s, buffer, byte_size)
 #define get_bits_le(s, n)                       bits_read_le((BitstreamContextLE*)s, n)
@@ -186,21 +188,28 @@
 
 #define CLOSE_READER(name, gb) (gb)->index = name ## _index
 
+#define UPDATE_CACHE_BE_EXT(name, gb, bits, dst_bits) name ## _cache = \
+    AV_RB ## bits((gb)->buffer + (name ## _index >> 3)) << (name ## _index & 7) >> (bits - dst_bits)
+
+#define UPDATE_CACHE_LE_EXT(name, gb, bits, dst_bits) name ## _cache = \
+    (uint ## dst_bits ## _t)(AV_RL ## bits((gb)->buffer + (name ## _index >> 3)) >> (name ## _index & 7))
+
+/* Using these two macros ensures that 32 bits are available. */
+# define UPDATE_CACHE_LE_32(name, gb) UPDATE_CACHE_LE_EXT(name, (gb), 64, 32)
+
+# define UPDATE_CACHE_BE_32(name, gb) UPDATE_CACHE_BE_EXT(name, (gb), 64, 32)
+
 # ifdef LONG_BITSTREAM_READER
 
-# define UPDATE_CACHE_LE(name, gb) name ## _cache = \
-      AV_RL64((gb)->buffer + (name ## _index >> 3)) >> (name ## _index & 7)
+# define UPDATE_CACHE_LE(name, gb) UPDATE_CACHE_LE_32(name, (gb))
 
-# define UPDATE_CACHE_BE(name, gb) name ## _cache = \
-      AV_RB64((gb)->buffer + (name ## _index >> 3)) >> (32 - (name ## _index & 7))
+# define UPDATE_CACHE_BE(name, gb) UPDATE_CACHE_BE_32(name, (gb))
 
 #else
 
-# define UPDATE_CACHE_LE(name, gb) name ## _cache = \
-      AV_RL32((gb)->buffer + (name ## _index >> 3)) >> (name ## _index & 7)
+# define UPDATE_CACHE_LE(name, gb) UPDATE_CACHE_LE_EXT(name, (gb), 32, 32)
 
-# define UPDATE_CACHE_BE(name, gb) name ## _cache = \
-      AV_RB32((gb)->buffer + (name ## _index >> 3)) << (name ## _index & 7)
+# define UPDATE_CACHE_BE(name, gb) UPDATE_CACHE_BE_EXT(name, (gb), 32, 32)
 
 #endif
 
@@ -208,12 +217,14 @@
 #ifdef BITSTREAM_READER_LE
 
 # define UPDATE_CACHE(name, gb) UPDATE_CACHE_LE(name, gb)
+# define UPDATE_CACHE_32(name, gb) UPDATE_CACHE_LE_32(name, (gb))
 
 # define SKIP_CACHE(name, gb, num) name ## _cache >>= (num)
 
 #else
 
 # define UPDATE_CACHE(name, gb) UPDATE_CACHE_BE(name, gb)
+# define UPDATE_CACHE_32(name, gb) UPDATE_CACHE_BE_32(name, (gb))
 
 # define SKIP_CACHE(name, gb, num) name ## _cache <<= (num)
 
@@ -413,9 +424,19 @@
     av_assert2(n>=0 && n<=32);
     if (!n) {
         return 0;
-    } else if (n <= MIN_CACHE_BITS) {
+    } else if ((!HAVE_FAST_64BIT || av_builtin_constant_p(n <= MIN_CACHE_BITS))
+               && n <= MIN_CACHE_BITS) {
         return get_bits(s, n);
     } else {
+#if HAVE_FAST_64BIT
+        unsigned tmp;
+        OPEN_READER(re, s);
+        UPDATE_CACHE_32(re, s);
+        tmp = SHOW_UBITS(re, s, n);
+        LAST_SKIP_BITS(re, s, n);
+        CLOSE_READER(re, s);
+        return tmp;
+#else
 #ifdef BITSTREAM_READER_LE
         unsigned ret = get_bits(s, 16);
         return ret | (get_bits(s, n - 16) << 16);
@@ -423,6 +444,7 @@
         unsigned ret = get_bits(s, 16) << (n - 16);
         return ret | get_bits(s, n - 16);
 #endif
+#endif
     }
 }
 
@@ -622,7 +644,7 @@
 /**
  * Parse a vlc code.
  * @param bits is the number of bits which will be read at once, must be
- *             identical to nb_bits in init_vlc()
+ *             identical to nb_bits in vlc_init()
  * @param max_depth is the number of times bits bits must be read to completely
  *                  read the longest vlc code
  *                  = (max_vlc_length + bits - 1) / bits
@@ -643,6 +665,15 @@
     return code;
 }
 
+static inline int get_vlc_multi(GetBitContext *s, uint8_t *dst,
+                                const VLC_MULTI_ELEM *const Jtable,
+                                const VLCElem *const table,
+                                const int bits, const int max_depth)
+{
+    dst[0] = get_vlc2(s, table, bits, max_depth);
+    return 1;
+}
+
 static inline int decode012(GetBitContext *gb)
 {
     int n;
@@ -680,6 +711,29 @@
     return 0;
 }
 
+/**
+ * Read a unsigned integer coded as a variable number of up to eight
+ * little-endian bytes, where the MSB in a byte signals another byte
+ * must be read.
+ * All coded bits are read, but values > UINT_MAX are truncated.
+ */
+static inline unsigned get_leb(GetBitContext *s) {
+    int more, i = 0;
+    unsigned leb = 0;
+
+    do {
+        int byte = get_bits(s, 8);
+        unsigned bits = byte & 0x7f;
+        more = byte & 0x80;
+        if (i <= 4)
+            leb |= bits << (i * 7);
+        if (++i == 8)
+            break;
+    } while (more);
+
+    return leb;
+}
+
 #endif // CACHED_BITSTREAM_READER
 
 #endif /* AVCODEC_GET_BITS_H */