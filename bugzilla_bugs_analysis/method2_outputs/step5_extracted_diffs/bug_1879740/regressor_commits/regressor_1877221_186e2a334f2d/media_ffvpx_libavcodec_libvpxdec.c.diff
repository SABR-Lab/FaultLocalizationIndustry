# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/libvpxdec.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/libvpxdec.c
--- a/media/ffvpx/libavcodec/libvpxdec.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/libvpxdec.c	Thu Feb 08 10:39:54 2024 +0000
@@ -127,26 +127,26 @@
     switch (img->fmt) {
     case VPX_IMG_FMT_I420:
         if (avctx->codec_id == AV_CODEC_ID_VP9)
-            avctx->profile = FF_PROFILE_VP9_0;
+            avctx->profile = AV_PROFILE_VP9_0;
         avctx->pix_fmt =
             has_alpha_channel ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
         return 0;
 #if CONFIG_LIBVPX_VP9_DECODER
     case VPX_IMG_FMT_I422:
-        avctx->profile = FF_PROFILE_VP9_1;
+        avctx->profile = AV_PROFILE_VP9_1;
         avctx->pix_fmt = AV_PIX_FMT_YUV422P;
         return 0;
     case VPX_IMG_FMT_I440:
-        avctx->profile = FF_PROFILE_VP9_1;
+        avctx->profile = AV_PROFILE_VP9_1;
         avctx->pix_fmt = AV_PIX_FMT_YUV440P;
         return 0;
     case VPX_IMG_FMT_I444:
-        avctx->profile = FF_PROFILE_VP9_1;
+        avctx->profile = AV_PROFILE_VP9_1;
         avctx->pix_fmt = avctx->colorspace == AVCOL_SPC_RGB ?
                          AV_PIX_FMT_GBRP : AV_PIX_FMT_YUV444P;
         return 0;
     case VPX_IMG_FMT_I42016:
-        avctx->profile = FF_PROFILE_VP9_2;
+        avctx->profile = AV_PROFILE_VP9_2;
         if (img->bit_depth == 10) {
             avctx->pix_fmt = AV_PIX_FMT_YUV420P10;
             return 0;
@@ -157,7 +157,7 @@
             return AVERROR_INVALIDDATA;
         }
     case VPX_IMG_FMT_I42216:
-        avctx->profile = FF_PROFILE_VP9_3;
+        avctx->profile = AV_PROFILE_VP9_3;
         if (img->bit_depth == 10) {
             avctx->pix_fmt = AV_PIX_FMT_YUV422P10;
             return 0;
@@ -168,7 +168,7 @@
             return AVERROR_INVALIDDATA;
         }
     case VPX_IMG_FMT_I44016:
-        avctx->profile = FF_PROFILE_VP9_3;
+        avctx->profile = AV_PROFILE_VP9_3;
         if (img->bit_depth == 10) {
             avctx->pix_fmt = AV_PIX_FMT_YUV440P10;
             return 0;
@@ -179,7 +179,7 @@
             return AVERROR_INVALIDDATA;
         }
     case VPX_IMG_FMT_I44416:
-        avctx->profile = FF_PROFILE_VP9_3;
+        avctx->profile = AV_PROFILE_VP9_3;
         if (img->bit_depth == 10) {
             avctx->pix_fmt = avctx->colorspace == AVCOL_SPC_RGB ?
                              AV_PIX_FMT_GBRP10 : AV_PIX_FMT_YUV444P10;
@@ -317,10 +317,8 @@
                 return AVERROR(ENOMEM);
             if (ctx->has_alpha_channel) {
                 picture->buf[1] = av_buffer_ref(img_alpha->fb_priv);
-                if (!picture->buf[1]) {
-                    av_frame_unref(picture);
+                if (!picture->buf[1])
                     return AVERROR(ENOMEM);
-                }
             }
             for (int i = 0; i < 4; i++) {
                 picture->data[i] = planes[i];
@@ -329,8 +327,8 @@
         } else {
             if ((ret = ff_get_buffer(avctx, picture, 0)) < 0)
                 return ret;
-            av_image_copy(picture->data, picture->linesize, (const uint8_t**)planes,
-                          linesizes, avctx->pix_fmt, img->d_w, img->d_h);
+            av_image_copy2(picture->data, picture->linesize, planes,
+                           linesizes, avctx->pix_fmt, img->d_w, img->d_h);
         }
         *got_frame           = 1;
     }