# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/vaapi_av1.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/vaapi_av1.c
--- a/media/ffvpx/libavcodec/vaapi_av1.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/vaapi_av1.c	Thu Feb 08 10:39:54 2024 +0000
@@ -75,19 +75,13 @@
     VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
 
     ctx->tmp_frame = av_frame_alloc();
-    if (!ctx->tmp_frame) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Failed to allocate frame.\n");
+    if (!ctx->tmp_frame)
         return AVERROR(ENOMEM);
-    }
 
     for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
         ctx->ref_tab[i].frame = av_frame_alloc();
-        if (!ctx->ref_tab[i].frame) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Failed to allocate reference table frame %d.\n", i);
+        if (!ctx->ref_tab[i].frame)
             return AVERROR(ENOMEM);
-        }
         ctx->ref_tab[i].valid = 0;
     }
 
@@ -98,15 +92,10 @@
 {
     VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
 
-    if (ctx->tmp_frame->buf[0])
-        ff_thread_release_buffer(avctx, ctx->tmp_frame);
     av_frame_free(&ctx->tmp_frame);
 
-    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
-        if (ctx->ref_tab[i].frame->buf[0])
-            ff_thread_release_buffer(avctx, ctx->ref_tab[i].frame);
+    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++)
         av_frame_free(&ctx->ref_tab[i].frame);
-    }
 
     return ff_vaapi_decode_uninit(avctx);
 }
@@ -137,7 +126,7 @@
 
     if (apply_grain) {
         if (ctx->tmp_frame->buf[0])
-            ff_thread_release_buffer(avctx, ctx->tmp_frame);
+            av_frame_unref(ctx->tmp_frame);
         err = ff_thread_get_buffer(avctx, ctx->tmp_frame, AV_GET_BUFFER_FLAG_REF);
         if (err < 0)
             goto fail;
@@ -382,7 +371,7 @@
     for (int i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         if (header->refresh_frame_flags & (1 << i)) {
             if (ctx->ref_tab[i].frame->buf[0])
-                ff_thread_release_buffer(avctx, ctx->ref_tab[i].frame);
+                av_frame_unref(ctx->ref_tab[i].frame);
 
             if (apply_grain) {
                 ret = av_frame_ref(ctx->ref_tab[i].frame, ctx->tmp_frame);