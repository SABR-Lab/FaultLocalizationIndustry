# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/vlc.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/vlc.c
--- a/media/ffvpx/libavcodec/vlc.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/vlc.c	Thu Feb 08 10:39:54 2024 +0000
@@ -30,6 +30,7 @@
 #include "libavutil/avassert.h"
 #include "libavutil/error.h"
 #include "libavutil/internal.h"
+#include "libavutil/intreadwrite.h"
 #include "libavutil/log.h"
 #include "libavutil/macros.h"
 #include "libavutil/mem.h"
@@ -63,7 +64,7 @@
     vlc->table_size += size;
     if (vlc->table_size > vlc->table_allocated) {
         if (use_static)
-            abort(); // cannot do anything, init_vlc() is used with too little memory
+            abort(); // cannot do anything, vlc_init() is used with too little memory
         vlc->table_allocated += (1 << vlc->bits);
         vlc->table = av_realloc_f(vlc->table, vlc->table_allocated, sizeof(*vlc->table));
         if (!vlc->table) {
@@ -99,7 +100,7 @@
 {
     vlc->bits = nb_bits;
     vlc->table_size = 0;
-    if (flags & INIT_VLC_USE_NEW_STATIC) {
+    if (flags & VLC_INIT_USE_STATIC) {
         av_assert0(nb_codes <= LOCALBUF_ELEMS);
     } else {
         vlc->table           = NULL;
@@ -143,7 +144,7 @@
     if (table_nb_bits > 30)
        return AVERROR(EINVAL);
     table_size = 1 << table_nb_bits;
-    table_index = alloc_table(vlc, table_size, flags & INIT_VLC_USE_NEW_STATIC);
+    table_index = alloc_table(vlc, table_size, flags & VLC_INIT_USE_STATIC);
     ff_dlog(NULL, "new table index=%d size=%d\n", table_index, table_size);
     if (table_index < 0)
         return table_index;
@@ -161,7 +162,7 @@
             int  nb = 1 << (table_nb_bits - n);
             int inc = 1;
 
-            if (flags & INIT_VLC_OUTPUT_LE) {
+            if (flags & VLC_INIT_OUTPUT_LE) {
                 j = bitswap_32(code);
                 inc = 1 << n;
             }
@@ -199,7 +200,7 @@
                 subtable_bits = FFMAX(subtable_bits, n);
             }
             subtable_bits = FFMIN(subtable_bits, table_nb_bits);
-            j = (flags & INIT_VLC_OUTPUT_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;
+            j = (flags & VLC_INIT_OUTPUT_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;
             table[j].len = -subtable_bits;
             ff_dlog(NULL, "%4x: n=%d (subtable)\n",
                     j, codes[i].bits + table_nb_bits);
@@ -230,9 +231,9 @@
 {
     int ret = build_table(vlc, nb_bits, nb_codes, codes, flags);
 
-    if (flags & INIT_VLC_USE_NEW_STATIC) {
+    if (flags & VLC_INIT_USE_STATIC) {
         if (vlc->table_size != vlc->table_allocated &&
-            !(flags & (INIT_VLC_STATIC_OVERLONG & ~INIT_VLC_USE_NEW_STATIC)))
+            !(flags & (VLC_INIT_STATIC_OVERLONG & ~VLC_INIT_USE_STATIC)))
             av_log(NULL, AV_LOG_ERROR, "needed %d had %d\n", vlc->table_size, vlc->table_allocated);
         av_assert0(ret >= 0);
     } else {
@@ -246,30 +247,7 @@
     return 0;
 }
 
-/* Build VLC decoding tables suitable for use with get_vlc().
-
-   'nb_bits' sets the decoding table size (2^nb_bits) entries. The
-   bigger it is, the faster is the decoding. But it should not be too
-   big to save memory and L1 cache. '9' is a good compromise.
-
-   'nb_codes' : number of vlcs codes
-
-   'bits' : table which gives the size (in bits) of each vlc code.
-
-   'codes' : table which gives the bit pattern of of each vlc code.
-
-   'symbols' : table which gives the values to be returned from get_vlc().
-
-   'xxx_wrap' : give the number of bytes between each entry of the
-   'bits' or 'codes' tables.
-
-   'xxx_size' : gives the number of bytes of each entry of the 'bits'
-   or 'codes' tables. Currently 1,2 and 4 are supported.
-
-   'wrap' and 'size' make it possible to use any memory configuration and types
-   (byte/word/long) to store the 'bits', 'codes', and 'symbols' tables.
-*/
-int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,
+int ff_vlc_init_sparse(VLC *vlc, int nb_bits, int nb_codes,
                        const void *bits, int bits_wrap, int bits_size,
                        const void *codes, int codes_wrap, int codes_size,
                        const void *symbols, int symbols_wrap, int symbols_size,
@@ -291,7 +269,7 @@
         if (!(condition))                                                   \
             continue;                                                       \
         if (len > 3*nb_bits || len > 32) {                                  \
-            av_log(NULL, AV_LOG_ERROR, "Too long VLC (%u) in init_vlc\n", len);\
+            av_log(NULL, AV_LOG_ERROR, "Too long VLC (%u) in vlc_init\n", len);\
             if (buf != localbuf)                                            \
                 av_free(buf);                                               \
             return AVERROR(EINVAL);                                         \
@@ -300,12 +278,12 @@
         GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);            \
         if (buf[j].code >= (1LL<<buf[j].bits)) {                            \
             av_log(NULL, AV_LOG_ERROR, "Invalid code %"PRIx32" for %d in "  \
-                   "init_vlc\n", buf[j].code, i);                           \
+                   "vlc_init\n", buf[j].code, i);                           \
             if (buf != localbuf)                                            \
                 av_free(buf);                                               \
             return AVERROR(EINVAL);                                         \
         }                                                                   \
-        if (flags & INIT_VLC_INPUT_LE)                                      \
+        if (flags & VLC_INIT_INPUT_LE)                                      \
             buf[j].code = bitswap_32(buf[j].code);                          \
         else                                                                \
             buf[j].code <<= 32 - buf[j].bits;                               \
@@ -316,7 +294,7 @@
         j++;                                                                \
     }
     COPY(len > nb_bits);
-    // qsort is the slowest part of init_vlc, and could probably be improved or avoided
+    // qsort is the slowest part of vlc_init, and could probably be improved or avoided
     AV_QSORT(buf, j, struct VLCcode, compare_vlcspec);
     COPY(len && len <= nb_bits);
     nb_codes = j;
@@ -325,7 +303,7 @@
                           flags, localbuf);
 }
 
-int ff_init_vlc_from_lengths(VLC *vlc, int nb_bits, int nb_codes,
+int ff_vlc_init_from_lengths(VLC *vlc, int nb_bits, int nb_codes,
                              const int8_t *lens, int lens_wrap,
                              const void *symbols, int symbols_wrap, int symbols_size,
                              int offset, int flags, void *logctx)
@@ -372,7 +350,231 @@
     return AVERROR_INVALIDDATA;
 }
 
-void ff_free_vlc(VLC *vlc)
+av_cold void ff_vlc_init_table_from_lengths(VLCElem table[], int table_size,
+                                            int nb_bits, int nb_codes,
+                                            const int8_t *lens, int lens_wrap,
+                                            const void *symbols, int symbols_wrap, int symbols_size,
+                                            int offset, int flags)
+{
+    VLC vlc = { .table = table, .table_allocated = table_size };
+
+    ff_vlc_init_from_lengths(&vlc, nb_bits, nb_codes, lens, lens_wrap,
+                             symbols, symbols_wrap, symbols_size,
+                             offset, flags | VLC_INIT_USE_STATIC, NULL);
+}
+
+av_cold const VLCElem *ff_vlc_init_tables_from_lengths(VLCInitState *state,
+                                                       int nb_bits, int nb_codes,
+                                                       const int8_t *lens, int lens_wrap,
+                                                       const void *symbols, int symbols_wrap, int symbols_size,
+                                                       int offset, int flags)
+{
+    VLC vlc = { .table = state->table, .table_allocated = state->size };
+
+    ff_vlc_init_from_lengths(&vlc, nb_bits, nb_codes, lens, lens_wrap,
+                             symbols, symbols_wrap, symbols_size,
+                             offset, flags | VLC_INIT_STATIC_OVERLONG, NULL);
+
+    state->table += vlc.table_size;
+    state->size  -= vlc.table_size;
+
+    return vlc.table;
+}
+
+av_cold void ff_vlc_init_table_sparse(VLCElem table[], int table_size,
+                                      int nb_bits, int nb_codes,
+                                      const void *bits, int bits_wrap, int bits_size,
+                                      const void *codes, int codes_wrap, int codes_size,
+                                      const void *symbols, int symbols_wrap, int symbols_size,
+                                      int flags)
+{
+    VLC vlc = { .table = table, .table_allocated = table_size };
+
+    ff_vlc_init_sparse(&vlc, nb_bits, nb_codes,
+                       bits, bits_wrap, bits_size,
+                       codes, codes_wrap, codes_size,
+                       symbols, symbols_wrap, symbols_size,
+                       flags | VLC_INIT_USE_STATIC);
+}
+
+av_cold const VLCElem *ff_vlc_init_tables_sparse(VLCInitState *state,
+                                                 int nb_bits, int nb_codes,
+                                                 const void *bits, int bits_wrap, int bits_size,
+                                                 const void *codes, int codes_wrap, int codes_size,
+                                                 const void *symbols, int symbols_wrap, int symbols_size,
+                                                 int flags)
+{
+    VLC vlc = { .table = state->table, .table_allocated = state->size };
+
+    ff_vlc_init_sparse(&vlc, nb_bits, nb_codes,
+                       bits, bits_wrap, bits_size,
+                       codes, codes_wrap, codes_size,
+                       symbols, symbols_wrap, symbols_size,
+                       flags | VLC_INIT_STATIC_OVERLONG);
+
+    state->table += vlc.table_size;
+    state->size  -= vlc.table_size;
+
+    return vlc.table;
+}
+
+static void add_level(VLC_MULTI_ELEM *table, const int is16bit,
+                      const int num, const int numbits,
+                      const VLCcode *buf,
+                      uint32_t curcode, int curlen,
+                      int curlimit, int curlevel,
+                      const int minlen, const int max,
+                      unsigned* levelcnt, VLC_MULTI_ELEM info)
+{
+    int max_symbols = VLC_MULTI_MAX_SYMBOLS >> is16bit;
+    for (int i = num-1; i >= max; i--) {
+        for (int j = 0; j < 2; j++) {
+            int newlimit, sym;
+            int t = j ? i-1 : i;
+            int l = buf[t].bits;
+            uint32_t code;
+
+            sym = buf[t].symbol;
+            if (l >= curlimit)
+                return;
+            code = curcode + (buf[t].code >> curlen);
+            newlimit = curlimit - l;
+            l  += curlen;
+            if (is16bit) AV_WN16(info.val+2*curlevel, sym);
+            else info.val[curlevel] = sym&0xFF;
+
+            if (curlevel) { // let's not add single entries
+                uint32_t val = code >> (32 - numbits);
+                uint32_t  nb = val + (1U << (numbits - l));
+                info.len = l;
+                info.num = curlevel+1;
+                for (; val < nb; val++)
+                    AV_COPY64(table+val, &info);
+                levelcnt[curlevel-1]++;
+            }
+
+            if (curlevel+1 < max_symbols && newlimit >= minlen) {
+                add_level(table, is16bit, num, numbits, buf,
+                          code, l, newlimit, curlevel+1,
+                          minlen, max, levelcnt, info);
+            }
+        }
+    }
+}
+
+static int vlc_multi_gen(VLC_MULTI_ELEM *table, const VLC *single,
+                         const int is16bit, const int nb_codes, const int numbits,
+                         VLCcode *buf, void *logctx)
+{
+    int minbits, maxbits, max;
+    unsigned count[VLC_MULTI_MAX_SYMBOLS-1] = { 0, };
+    VLC_MULTI_ELEM info = { { 0, }, 0, 0, };
+    int count0 = 0;
+
+    for (int j = 0; j < 1<<numbits; j++) {
+        if (single->table[j].len > 0) {
+            count0 ++;
+            j += (1 << (numbits - single->table[j].len)) - 1;
+        }
+    }
+
+    minbits = 32;
+    maxbits = 0;
+
+    for (int n = nb_codes - count0; n < nb_codes; n++) {
+        minbits = FFMIN(minbits, buf[n].bits);
+        maxbits = FFMAX(maxbits, buf[n].bits);
+    }
+    av_assert0(maxbits <= numbits);
+
+    for (max = nb_codes; max > nb_codes - count0; max--) {
+        // We can only add a code that fits with the shortest other code into the table
+        // We assume the table is sorted by bits and we skip subtables which from our
+        // point of view are basically random corrupted entries
+        // If we have not a single useable vlc we end with max = nb_codes
+        if (buf[max - 1].bits+minbits > numbits)
+            break;
+    }
+
+    for (int j = 0; j < 1<<numbits; j++) {
+        table[j].len = single->table[j].len;
+        table[j].num = single->table[j].len > 0 ? 1 : 0;
+        AV_WN16(table[j].val, single->table[j].sym);
+    }
+
+    add_level(table, is16bit, nb_codes, numbits, buf,
+              0, 0, FFMIN(maxbits, numbits), 0, minbits, max, count, info);
+
+    av_log(logctx, AV_LOG_DEBUG, "Joint: %d/%d/%d/%d/%d codes min=%ubits max=%u\n",
+           count[0], count[1], count[2], count[3], count[4], minbits, max);
+
+    return 0;
+}
+
+int ff_vlc_init_multi_from_lengths(VLC *vlc, VLC_MULTI *multi, int nb_bits, int nb_elems,
+                                   int nb_codes, const int8_t *lens, int lens_wrap,
+                                   const void *symbols, int symbols_wrap, int symbols_size,
+                                   int offset, int flags, void *logctx)
+{
+    VLCcode localbuf[LOCALBUF_ELEMS], *buf = localbuf;
+    uint64_t code;
+    int ret, j, len_max = FFMIN(32, 3 * nb_bits);
+
+    ret = vlc_common_init(vlc, nb_bits, nb_codes, &buf, flags);
+    if (ret < 0)
+        return ret;
+
+    multi->table = av_malloc(sizeof(*multi->table) << nb_bits);
+    if (!multi->table)
+        return AVERROR(ENOMEM);
+
+    j = code = 0;
+    for (int i = 0; i < nb_codes; i++, lens += lens_wrap) {
+        int len = *lens;
+        if (len > 0) {
+            unsigned sym;
+
+            buf[j].bits = len;
+            if (symbols)
+                GET_DATA(sym, symbols, i, symbols_wrap, symbols_size)
+            else
+                sym = i;
+            buf[j].symbol = sym + offset;
+            buf[j++].code = code;
+        } else if (len <  0) {
+            len = -len;
+        } else
+            continue;
+        if (len > len_max || code & ((1U << (32 - len)) - 1)) {
+            av_log(logctx, AV_LOG_ERROR, "Invalid VLC (length %u)\n", len);
+            goto fail;
+        }
+        code += 1U << (32 - len);
+        if (code > UINT32_MAX + 1ULL) {
+            av_log(logctx, AV_LOG_ERROR, "Overdetermined VLC tree\n");
+            goto fail;
+        }
+    }
+    ret = vlc_common_end(vlc, nb_bits, j, buf, flags, buf);
+    if (ret < 0)
+        goto fail;
+    ret = vlc_multi_gen(multi->table, vlc, nb_elems > 256, j, nb_bits, buf, logctx);
+    if (buf != localbuf)
+        av_free(buf);
+    return ret;
+fail:
+    if (buf != localbuf)
+        av_free(buf);
+    ff_vlc_free_multi(multi);
+    return AVERROR_INVALIDDATA;
+}
+
+void ff_vlc_free_multi(VLC_MULTI *vlc)
 {
     av_freep(&vlc->table);
 }
+
+void ff_vlc_free(VLC *vlc)
+{
+    av_freep(&vlc->table);
+}