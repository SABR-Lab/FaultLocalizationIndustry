# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavcodec/vp8.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavcodec/vp8.c
--- a/media/ffvpx/libavcodec/vp8.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavcodec/vp8.c	Thu Feb 08 10:39:54 2024 +0000
@@ -34,6 +34,7 @@
 #include "hwaccel_internal.h"
 #include "hwconfig.h"
 #include "mathops.h"
+#include "refstruct.h"
 #include "thread.h"
 #include "threadframe.h"
 #include "vp8.h"
@@ -105,51 +106,39 @@
     if ((ret = ff_thread_get_ext_buffer(s->avctx, &f->tf,
                                         ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)
         return ret;
-    if (!(f->seg_map = av_buffer_allocz(s->mb_width * s->mb_height))) {
-        ret = AVERROR(ENOMEM);
+    if (!(f->seg_map = ff_refstruct_allocz(s->mb_width * s->mb_height)))
         goto fail;
-    }
-    ret = ff_hwaccel_frame_priv_alloc(s->avctx, &f->hwaccel_picture_private,
-                                      &f->hwaccel_priv_buf);
+    ret = ff_hwaccel_frame_priv_alloc(s->avctx, &f->hwaccel_picture_private);
     if (ret < 0)
         goto fail;
 
     return 0;
 
 fail:
-    av_buffer_unref(&f->seg_map);
-    ff_thread_release_ext_buffer(s->avctx, &f->tf);
+    ff_refstruct_unref(&f->seg_map);
+    ff_thread_release_ext_buffer(&f->tf);
     return ret;
 }
 
-static void vp8_release_frame(VP8Context *s, VP8Frame *f)
+static void vp8_release_frame(VP8Frame *f)
 {
-    av_buffer_unref(&f->seg_map);
-    av_buffer_unref(&f->hwaccel_priv_buf);
-    f->hwaccel_picture_private = NULL;
-    ff_thread_release_ext_buffer(s->avctx, &f->tf);
+    ff_refstruct_unref(&f->seg_map);
+    ff_refstruct_unref(&f->hwaccel_picture_private);
+    ff_thread_release_ext_buffer(&f->tf);
 }
 
 #if CONFIG_VP8_DECODER
-static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, const VP8Frame *src)
+static int vp8_ref_frame(VP8Frame *dst, const VP8Frame *src)
 {
     int ret;
 
-    vp8_release_frame(s, dst);
+    vp8_release_frame(dst);
 
     if ((ret = ff_thread_ref_frame(&dst->tf, &src->tf)) < 0)
         return ret;
-    if (src->seg_map &&
-        !(dst->seg_map = av_buffer_ref(src->seg_map))) {
-        vp8_release_frame(s, dst);
-        return AVERROR(ENOMEM);
-    }
-    if (src->hwaccel_picture_private) {
-        dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);
-        if (!dst->hwaccel_priv_buf)
-            return AVERROR(ENOMEM);
-        dst->hwaccel_picture_private = dst->hwaccel_priv_buf->data;
-    }
+    ff_refstruct_replace(&dst->seg_map, src->seg_map);
+    ff_refstruct_replace(&dst->hwaccel_picture_private,
+                          src->hwaccel_picture_private);
 
     return 0;
 }
@@ -161,7 +150,7 @@
     int i;
 
     for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
-        vp8_release_frame(s, &s->frames[i]);
+        vp8_release_frame(&s->frames[i]);
     memset(s->framep, 0, sizeof(s->framep));
 
     if (free_mem)
@@ -195,7 +184,7 @@
         abort();
     }
     if (frame->tf.f->buf[0])
-        vp8_release_frame(s, frame);
+        vp8_release_frame(frame);
 
     return frame;
 }
@@ -469,7 +458,7 @@
         for (j = 0; j < 8; j++)
             for (k = 0; k < 3; k++)
                 for (l = 0; l < NUM_DCT_TOKENS-1; l++)
-                    if (vpx_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l])) {
+                    if (vpx_rac_get_prob_branchy(c, ff_vp8_token_update_probs[i][j][k][l])) {
                         int prob = vp89_rac_get_uint(c, 8);
                         for (m = 0; vp8_coeff_band_indexes[j][m] >= 0; m++)
                             s->prob->token[i][vp8_coeff_band_indexes[j][m]][k][l] = prob;
@@ -2334,9 +2323,9 @@
             if (mb_y == 0)
                 AV_WN32A((mb - s->mb_width - 1)->intra4x4_pred_mode_top,
                          DC_PRED * 0x01010101);
-            decode_mb_mode(s, &s->mv_bounds, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
+            decode_mb_mode(s, &s->mv_bounds, mb, mb_x, mb_y, curframe->seg_map + mb_xy,
                            prev_frame && prev_frame->seg_map ?
-                           prev_frame->seg_map->data + mb_xy : NULL, 1, is_vp7);
+                           prev_frame->seg_map + mb_xy : NULL, 1, is_vp7);
             s->mv_bounds.mv_min.x -= 64;
             s->mv_bounds.mv_max.x -= 64;
         }
@@ -2467,9 +2456,9 @@
                          dst[2] - dst[1], 2);
 
         if (!s->mb_layout)
-            decode_mb_mode(s, &td->mv_bounds, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
+            decode_mb_mode(s, &td->mv_bounds, mb, mb_x, mb_y, curframe->seg_map + mb_xy,
                            prev_frame && prev_frame->seg_map ?
-                           prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7);
+                           prev_frame->seg_map + mb_xy : NULL, 0, is_vp7);
 
         prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_PREVIOUS);
 
@@ -2710,7 +2699,7 @@
             &s->frames[i] != s->framep[VP8_FRAME_PREVIOUS] &&
             &s->frames[i] != s->framep[VP8_FRAME_GOLDEN]   &&
             &s->frames[i] != s->framep[VP8_FRAME_ALTREF])
-            vp8_release_frame(s, &s->frames[i]);
+            vp8_release_frame(&s->frames[i]);
 
     curframe = s->framep[VP8_FRAME_CURRENT] = vp8_find_free_buffer(s);
 
@@ -2961,7 +2950,7 @@
 
     for (i = 0; i < FF_ARRAY_ELEMS(s_src->frames); i++) {
         if (s_src->frames[i].tf.f->buf[0]) {
-            int ret = vp8_ref_frame(s, &s->frames[i], &s_src->frames[i]);
+            int ret = vp8_ref_frame(&s->frames[i], &s_src->frames[i]);
             if (ret < 0)
                 return ret;
         }