# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: media/ffvpx/libavutil/imgutils.c
# Commit: 186e2a334f2d
# Full Hash: 186e2a334f2deb37b29f44b28bc8c83babeeb9a4
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-09 09:37:17
# Regressor Bug: 1877221
# File Overlap Count: 1
# Description:
#   Bug 1877221 - Pull in new ffmpeg code, reapply patch. r=media-playback-reviewers,chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D199909
# ==============================================================================

diff -r c5920de78d16 -r 186e2a334f2d media/ffvpx/libavutil/imgutils.c
--- a/media/ffvpx/libavutil/imgutils.c	Thu Feb 08 10:39:53 2024 +0000
+++ b/media/ffvpx/libavutil/imgutils.c	Thu Feb 08 10:39:54 2024 +0000
@@ -378,8 +378,8 @@
     image_copy_plane(dst, dst_linesize, src, src_linesize, bytewidth, height);
 }
 
-static void image_copy(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4],
-                       const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4],
+static void image_copy(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4],
+                       const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4],
                        enum AVPixelFormat pix_fmt, int width, int height,
                        void (*copy_plane)(uint8_t *, ptrdiff_t, const uint8_t *,
                                           ptrdiff_t, ptrdiff_t, int))
@@ -419,8 +419,8 @@
     }
 }
 
-void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4],
-                   const uint8_t *src_data[4], const int src_linesizes[4],
+void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4],
+                   const uint8_t * const src_data[4], const int src_linesizes[4],
                    enum AVPixelFormat pix_fmt, int width, int height)
 {
     ptrdiff_t dst_linesizes1[4], src_linesizes1[4];
@@ -435,8 +435,8 @@
                width, height, image_copy_plane);
 }
 
-void av_image_copy_uc_from(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4],
-                           const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4],
+void av_image_copy_uc_from(uint8_t * const dst_data[4], const ptrdiff_t dst_linesizes[4],
+                           const uint8_t * const src_data[4], const ptrdiff_t src_linesizes[4],
                            enum AVPixelFormat pix_fmt, int width, int height)
 {
     image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt,
@@ -579,46 +579,24 @@
 // if it's a subsampled packed format).
 #define MAX_BLOCK_SIZE 32
 
-int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4],
-                        enum AVPixelFormat pix_fmt, enum AVColorRange range,
-                        int width, int height)
+int av_image_fill_color(uint8_t * const dst_data[4], const ptrdiff_t dst_linesize[4],
+                        enum AVPixelFormat pix_fmt, const uint32_t color[4],
+                        int width, int height, int flags)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
     int nb_planes = av_pix_fmt_count_planes(pix_fmt);
-    // A pixel or a group of pixels on each plane, with a value that represents black.
+    // A pixel or a group of pixels on each plane, with a value that represents the color.
     // Consider e.g. AV_PIX_FMT_UYVY422 for non-trivial cases.
     uint8_t clear_block[4][MAX_BLOCK_SIZE] = {{0}}; // clear padding with 0
     int clear_block_size[4] = {0};
     ptrdiff_t plane_line_bytes[4] = {0};
-    int rgb, limited;
+    int bitstream;
     int plane, c;
 
     if (!desc || nb_planes < 1 || nb_planes > 4 || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)
         return AVERROR(EINVAL);
 
-    rgb = !!(desc->flags & AV_PIX_FMT_FLAG_RGB);
-    limited = !rgb && range != AVCOL_RANGE_JPEG;
-
-    if (desc->flags & AV_PIX_FMT_FLAG_BITSTREAM) {
-        ptrdiff_t bytewidth = av_image_get_linesize(pix_fmt, width, 0);
-        uint8_t *data;
-        int mono = pix_fmt == AV_PIX_FMT_MONOWHITE || pix_fmt == AV_PIX_FMT_MONOBLACK;
-        int fill = pix_fmt == AV_PIX_FMT_MONOWHITE ? 0xFF : 0;
-        if (nb_planes != 1 || !(rgb || mono) || bytewidth < 1)
-            return AVERROR(EINVAL);
-
-        if (!dst_data)
-            return 0;
-
-        data = dst_data[0];
-
-        // (Bitstream + alpha will be handled incorrectly - it'll remain transparent.)
-        for (;height > 0; height--) {
-            memset(data, fill, bytewidth);
-            data += dst_linesize[0];
-        }
-        return 0;
-    }
+    bitstream = !!(desc->flags & AV_PIX_FMT_FLAG_BITSTREAM);
 
     for (c = 0; c < desc->nb_components; c++) {
         const AVComponentDescriptor comp = desc->comp[c];
@@ -635,36 +613,24 @@
     for (c = 0; c < desc->nb_components; c++) {
         const AVComponentDescriptor comp = desc->comp[c];
         // (Multiple pixels happen e.g. with AV_PIX_FMT_UYVY422.)
-        int w = clear_block_size[comp.plane] / comp.step;
+        int w = (bitstream ? 8 : 1) * clear_block_size[comp.plane] / comp.step;
         uint8_t *c_data[4];
         const int c_linesize[4] = {0};
-        uint16_t src_array[MAX_BLOCK_SIZE];
-        uint16_t src = 0;
+        uint32_t src_array[MAX_BLOCK_SIZE];
         int x;
 
-        if (comp.depth > 16)
-            return AVERROR(EINVAL);
-        if (!rgb && comp.depth < 8)
+        if (comp.depth > 32)
             return AVERROR(EINVAL);
         if (w < 1)
             return AVERROR(EINVAL);
 
-        if (c == 0 && limited) {
-            src = 16 << (comp.depth - 8);
-        } else if ((c == 1 || c == 2) && !rgb) {
-            src = 128 << (comp.depth - 8);
-        } else if (c == 3) {
-            // (Assume even limited YUV uses full range alpha.)
-            src = (1 << comp.depth) - 1;
-        }
-
         for (x = 0; x < w; x++)
-            src_array[x] = src;
+            src_array[x] = color[c];
 
         for (x = 0; x < 4; x++)
             c_data[x] = &clear_block[x][0];
 
-        av_write_image_line(src_array, c_data, c_linesize, desc, 0, 0, c, w);
+        av_write_image_line2(src_array, c_data, c_linesize, desc, 0, 0, c, w, 4);
     }
 
     for (plane = 0; plane < nb_planes; plane++) {
@@ -690,3 +656,62 @@
 
     return 0;
 }
+
+int av_image_fill_black(uint8_t * const dst_data[4], const ptrdiff_t dst_linesize[4],
+                        enum AVPixelFormat pix_fmt, enum AVColorRange range,
+                        int width, int height)
+{
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
+    int nb_planes = av_pix_fmt_count_planes(pix_fmt);
+    int rgb, xyz, pal, limited, alpha, fltp;
+    uint32_t colors[4] = {0};
+
+    if (!desc || nb_planes < 1 || nb_planes > 4 || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)
+        return AVERROR(EINVAL);
+
+    rgb = !!(desc->flags & AV_PIX_FMT_FLAG_RGB);
+    xyz = !!(desc->flags & AV_PIX_FMT_FLAG_XYZ);
+    pal = !!(desc->flags & AV_PIX_FMT_FLAG_PAL);
+    limited = !rgb && !xyz && !pal && range != AVCOL_RANGE_JPEG;
+    alpha = !pal && !!(desc->flags & AV_PIX_FMT_FLAG_ALPHA);
+    fltp = !!(desc->flags & AV_PIX_FMT_FLAG_FLOAT);
+
+    for (int c = 0; c < desc->nb_components; c++) {
+        const AVComponentDescriptor comp = desc->comp[c];
+        uint32_t color = 0;
+
+        if (comp.depth > 32)
+            return AVERROR(EINVAL);
+
+        if (pix_fmt == AV_PIX_FMT_MONOWHITE) {
+            color = 1;
+        } else if (c + 1 == desc->nb_components && alpha) {
+            // (Assume even limited YUV uses full range alpha.)
+            if (fltp) {
+                if (comp.depth != 16 && comp.depth != 32)
+                    return AVERROR(EINVAL);
+                color = (comp.depth == 16 ? 0x3C00 : 0x3F800000); // 1.0
+             } else {
+                color = (comp.depth == 32 ? 0 : (1 << comp.depth)) - 1;
+             }
+        } else if (c == 0 && limited && comp.depth > 1) {
+            if (comp.depth < 8 || (fltp && comp.depth != 16 && comp.depth != 32))
+                return AVERROR(EINVAL);
+            if (fltp)
+                color = (comp.depth == 16 ? 0x2C00 : 0x3D800000); // 0.0625
+            else
+                color = 16 << (comp.depth - 8);
+        } else if ((c == 1 || c == 2) && !rgb && !xyz) {
+            if (comp.depth < 8 || fltp && comp.depth != 16 && comp.depth != 32)
+                return AVERROR(EINVAL);
+            if (fltp)
+                color = (comp.depth == 16 ? 0x3800 : 0x3F000000); // 0.5
+            else
+                color = 128 << (comp.depth - 8);
+        }
+
+        colors[c] = color;
+    }
+
+    return av_image_fill_color(dst_data, dst_linesize, pix_fmt, colors, width, height, 0);
+}