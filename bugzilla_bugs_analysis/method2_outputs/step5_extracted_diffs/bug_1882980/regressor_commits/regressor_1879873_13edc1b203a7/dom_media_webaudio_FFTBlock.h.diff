# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webaudio/FFTBlock.h
# Commit: 13edc1b203a7
# Full Hash: 13edc1b203a76bf9d3bc00ba19a7f3b167a2ac45
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-27 04:32:10
# Regressor Bug: 1879873
# File Overlap Count: 1
# Description:
#   Bug 1879873 - Directly use tx instead of the older avfft interface. r=karlt,media-playback-reviewers
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202156
# ==============================================================================

diff -r 71824d88e1cd -r 13edc1b203a7 dom/media/webaudio/FFTBlock.h
--- a/dom/media/webaudio/FFTBlock.h	Mon Feb 26 16:07:08 2024 +0000
+++ b/dom/media/webaudio/FFTBlock.h	Mon Feb 26 16:07:09 2024 +0000
@@ -9,8 +9,8 @@
 
 #include "AlignedTArray.h"
 #include "AudioNodeEngine.h"
-#include "FFmpegRDFTTypes.h"
 #include "FFVPXRuntimeLinker.h"
+#include "ffvpx/tx.h"
 
 namespace mozilla {
 
@@ -28,12 +28,11 @@
  public:
   static void MainThreadInit() {
     FFVPXRuntimeLinker::Init();
-    if (!sRDFTFuncs.init) {
-      FFVPXRuntimeLinker::GetRDFTFuncs(&sRDFTFuncs);
+    if (!sFFTFuncs.init) {
+      FFVPXRuntimeLinker::GetFFTFuncs(&sFFTFuncs);
     }
   }
-
-  explicit FFTBlock(uint32_t aFFTSize) : mAvRDFT(nullptr), mAvIRDFT(nullptr) {
+  explicit FFTBlock(uint32_t aFFTSize) {
     MOZ_COUNT_CTOR(FFTBlock);
     SetFFTSize(aFFTSize);
   }
@@ -55,10 +54,12 @@
     }
 
     PodCopy(mOutputBuffer.Elements()->f, aData, mFFTSize);
-    sRDFTFuncs.calc(mAvRDFT, mOutputBuffer.Elements()->f);
-    // Recover packed Nyquist.
-    mOutputBuffer[mFFTSize / 2].r = mOutputBuffer[0].i;
-    mOutputBuffer[0].i = 0.0f;
+    // In place transform
+    mFn(mTxCtx, mOutputBuffer.Elements()->f, mOutputBuffer.Elements()->f,
+        2 * sizeof(float));
+#ifdef DEBUG
+    mInversePerformed = false;
+#endif
   }
   // Inverse-transform internal data and store the resulting FFTSize()
   // points in aDataOut.
@@ -66,7 +67,6 @@
     GetInverseWithoutScaling(aDataOut);
     AudioBufferInPlaceScale(aDataOut, 1.0f / mFFTSize, mFFTSize);
   }
-
   // Inverse-transform internal frequency data and store the resulting
   // FFTSize() points in |aDataOut|.  If frequency data has not already been
   // scaled, then the output will need scaling by 1/FFTSize().
@@ -75,17 +75,19 @@
       std::fill_n(aDataOut, mFFTSize, 0.0f);
       return;
     };
-
-    // Even though this function doesn't scale, the libav forward transform
-    // gives a value that needs scaling by 2 in order for things to turn out
-    // similar to how we expect from kissfft/openmax.
-    AudioBufferCopyWithScale(mOutputBuffer.Elements()->f, 2.0f, aDataOut,
-                             mFFTSize);
-    aDataOut[1] = 2.0f * mOutputBuffer[mFFTSize / 2].r;  // Packed Nyquist
-    sRDFTFuncs.calc(mAvIRDFT, aDataOut);
+    // When performing an inverse transform, tx overwrites the input. This
+    // asserts that forward / inverse transforms are interleaved to avoid having
+    // to keep the input around.
+    MOZ_ASSERT(!mInversePerformed);
+    mIFn(mITxCtx, aDataOut, mOutputBuffer.Elements()->f, 2 * sizeof(float));
+#ifdef DEBUG
+    mInversePerformed = true;
+#endif
   }
 
   void Multiply(const FFTBlock& aFrame) {
+    MOZ_ASSERT(!mInversePerformed);
+
     uint32_t halfSize = mFFTSize / 2;
     // DFTs are not packed.
     MOZ_ASSERT(mOutputBuffer[0].i == 0);
@@ -127,33 +129,22 @@
 
   uint32_t FFTSize() const { return mFFTSize; }
   float RealData(uint32_t aIndex) const { return mOutputBuffer[aIndex].r; }
-  float& RealData(uint32_t aIndex) { return mOutputBuffer[aIndex].r; }
+  float& RealData(uint32_t aIndex) {
+    MOZ_ASSERT(!mInversePerformed);
+    return mOutputBuffer[aIndex].r;
+  }
   float ImagData(uint32_t aIndex) const { return mOutputBuffer[aIndex].i; }
-  float& ImagData(uint32_t aIndex) { return mOutputBuffer[aIndex].i; }
+  float& ImagData(uint32_t aIndex) {
+    MOZ_ASSERT(!mInversePerformed);
+    return mOutputBuffer[aIndex].i;
+  }
 
   size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const {
     size_t amount = 0;
 
-    auto ComputedSizeOfContextIfSet = [this](void* aContext) -> size_t {
-      if (!aContext) {
-        return 0;
-      }
-      // RDFTContext is only forward declared in public headers, but this is
-      // an estimate based on a value of 231 seen requested from
-      // _aligned_alloc on Win64.  Don't use malloc_usable_size() because the
-      // context pointer is not necessarily from malloc.
-      size_t amount = 232;
-      // Add size of allocations performed in ff_fft_init().
-      // The maximum FFT size used is 32768 = 2^15 and so revtab32 is not
-      // allocated.
-      MOZ_ASSERT(mFFTSize <= 32768);
-      amount += mFFTSize * (sizeof(uint16_t) + 2 * sizeof(float));
+    amount += aMallocSizeOf(mTxCtx);
+    amount += aMallocSizeOf(mITxCtx);
 
-      return amount;
-    };
-
-    amount += ComputedSizeOfContextIfSet(mAvRDFT);
-    amount += ComputedSizeOfContextIfSet(mAvIRDFT);
     amount += mOutputBuffer.ShallowSizeOfExcludingThis(aMallocSizeOf);
     return amount;
   }
@@ -162,50 +153,55 @@
     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
   }
 
- private:
   FFTBlock(const FFTBlock& other) = delete;
   void operator=(const FFTBlock& other) = delete;
 
+ private:
   bool EnsureFFT() {
-    if (!mAvRDFT) {
-      if (!sRDFTFuncs.init) {
-        return false;
-      }
-
-      mAvRDFT = sRDFTFuncs.init(FloorLog2(mFFTSize), DFT_R2C);
+    if (!mTxCtx) {
+      float scale = 1.0f;
+      DebugOnly<int> rv =
+          sFFTFuncs.init(&mTxCtx, &mFn, AV_TX_FLOAT_RDFT, 0 /* forward */,
+                         AssertedCast<int>(mFFTSize), &scale, 0);
+      MOZ_ASSERT(!rv, "av_tx_init: invalid parameters (forward)");
     }
     return true;
   }
-
   bool EnsureIFFT() {
-    if (!mAvIRDFT) {
-      if (!sRDFTFuncs.init) {
-        return false;
-      }
-
-      mAvIRDFT = sRDFTFuncs.init(FloorLog2(mFFTSize), IDFT_C2R);
+    if (!mITxCtx) {
+      float scale = 0.5f;
+      DebugOnly<int> rv =
+          sFFTFuncs.init(&mITxCtx, &mIFn, AV_TX_FLOAT_RDFT, 1 /* inverse */,
+                         AssertedCast<int>(mFFTSize), &scale, 0);
+      MOZ_ASSERT(!rv, "av_tx_init: invalid parameters (inverse)");
     }
     return true;
   }
-
   void Clear() {
-    if (mAvRDFT) {
-      sRDFTFuncs.end(mAvRDFT);
-      mAvRDFT = nullptr;
+    if (mTxCtx) {
+      sFFTFuncs.uninit(&mTxCtx);
+      mFn = nullptr;
     }
-    if (mAvIRDFT) {
-      sRDFTFuncs.end(mAvIRDFT);
-      mAvIRDFT = nullptr;
+    if (mITxCtx) {
+      sFFTFuncs.uninit(&mITxCtx);
+      mIFn = nullptr;
     }
   }
   void AddConstantGroupDelay(double sampleFrameDelay);
   void InterpolateFrequencyComponents(const FFTBlock& block0,
                                       const FFTBlock& block1, double interp);
-  static FFmpegRDFTFuncs sRDFTFuncs;
-  RDFTContext* mAvRDFT;
-  RDFTContext* mAvIRDFT;
+  static FFmpegFFTFuncs sFFTFuncs;
+  // Context and function pointer for forward transform
+  AVTXContext* mTxCtx{};
+  av_tx_fn mFn{};
+  // Context and function pointer for inverse transform
+  AVTXContext* mITxCtx{};
+  av_tx_fn mIFn{};
   AlignedTArray<ComplexU> mOutputBuffer;
   uint32_t mFFTSize{};
+#ifdef DEBUG
+  bool mInversePerformed = false;
+#endif
 };
 
 }  // namespace mozilla