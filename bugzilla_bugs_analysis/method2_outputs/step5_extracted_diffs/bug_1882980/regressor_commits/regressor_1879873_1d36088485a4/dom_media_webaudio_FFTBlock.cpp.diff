# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webaudio/FFTBlock.cpp
# Commit: 1d36088485a4
# Full Hash: 1d36088485a4ad3034d6a58df21430c3d3b54cc3
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-27 04:32:10
# Regressor Bug: 1879873
# File Overlap Count: 1
# Description:
#   Bug 1879873 - Scale the inverse FFT result using tx instead of pre- or post-processing the data. r=karlt
#   
#   This skips a copy at the expense of having to do a `const_cast`.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202434
# ==============================================================================

diff -r 13edc1b203a7 -r 1d36088485a4 dom/media/webaudio/FFTBlock.cpp
--- a/dom/media/webaudio/FFTBlock.cpp	Mon Feb 26 16:07:09 2024 +0000
+++ b/dom/media/webaudio/FFTBlock.cpp	Mon Feb 26 16:07:09 2024 +0000
@@ -50,17 +50,15 @@
 FFTBlock* FFTBlock::CreateInterpolatedBlock(const FFTBlock& block0,
                                             const FFTBlock& block1,
                                             double interp) {
-  FFTBlock* newBlock = new FFTBlock(block0.FFTSize());
+  uint32_t fftSize = block0.FFTSize();
+  FFTBlock* newBlock = new FFTBlock(fftSize, 1.0f / AssertedCast<float>(fftSize));
 
   newBlock->InterpolateFrequencyComponents(block0, block1, interp);
 
   // In the time-domain, the 2nd half of the response must be zero, to avoid
   // circular convolution aliasing...
-  int fftSize = newBlock->FFTSize();
   AlignedTArray<float> buffer(fftSize);
-  newBlock->GetInverseWithoutScaling(buffer.Elements());
-  AudioBufferInPlaceScale(buffer.Elements(),
-                          1.0f / AssertedCast<float>(fftSize), fftSize / 2);
+  newBlock->GetInverse(buffer.Elements());
   PodZero(buffer.Elements() + fftSize / 2, fftSize / 2);
 
   // Put back into frequency domain.