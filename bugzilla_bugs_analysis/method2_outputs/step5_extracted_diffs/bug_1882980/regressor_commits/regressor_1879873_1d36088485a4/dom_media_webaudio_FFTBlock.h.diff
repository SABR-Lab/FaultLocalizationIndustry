# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webaudio/FFTBlock.h
# Commit: 1d36088485a4
# Full Hash: 1d36088485a4ad3034d6a58df21430c3d3b54cc3
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-02-27 04:32:10
# Regressor Bug: 1879873
# File Overlap Count: 1
# Description:
#   Bug 1879873 - Scale the inverse FFT result using tx instead of pre- or post-processing the data. r=karlt
#   
#   This skips a copy at the expense of having to do a `const_cast`.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202434
# ==============================================================================

diff -r 13edc1b203a7 -r 1d36088485a4 dom/media/webaudio/FFTBlock.h
--- a/dom/media/webaudio/FFTBlock.h	Mon Feb 26 16:07:09 2024 +0000
+++ b/dom/media/webaudio/FFTBlock.h	Mon Feb 26 16:07:09 2024 +0000
@@ -32,7 +32,8 @@
       FFVPXRuntimeLinker::GetFFTFuncs(&sFFTFuncs);
     }
   }
-  explicit FFTBlock(uint32_t aFFTSize) {
+  explicit FFTBlock(uint32_t aFFTSize, float aInverseScaling = 1.0f)
+      : mInverseScaling(aInverseScaling) {
     MOZ_COUNT_CTOR(FFTBlock);
     SetFFTSize(aFFTSize);
   }
@@ -53,24 +54,16 @@
       return;
     }
 
-    PodCopy(mOutputBuffer.Elements()->f, aData, mFFTSize);
-    // In place transform
-    mFn(mTxCtx, mOutputBuffer.Elements()->f, mOutputBuffer.Elements()->f,
+    mFn(mTxCtx, mOutputBuffer.Elements()->f, const_cast<float*>(aData),
         2 * sizeof(float));
 #ifdef DEBUG
     mInversePerformed = false;
 #endif
   }
-  // Inverse-transform internal data and store the resulting FFTSize()
-  // points in aDataOut.
-  void GetInverse(float* aDataOut) {
-    GetInverseWithoutScaling(aDataOut);
-    AudioBufferInPlaceScale(aDataOut, 1.0f / mFFTSize, mFFTSize);
-  }
   // Inverse-transform internal frequency data and store the resulting
   // FFTSize() points in |aDataOut|.  If frequency data has not already been
   // scaled, then the output will need scaling by 1/FFTSize().
-  void GetInverseWithoutScaling(float* aDataOut) {
+  void GetInverse(float* aDataOut) {
     if (!EnsureIFFT()) {
       std::fill_n(aDataOut, mFFTSize, 0.0f);
       return;
@@ -109,8 +102,8 @@
     MOZ_ASSERT(dataSize <= FFTSize());
     AlignedTArray<float> paddedData;
     paddedData.SetLength(FFTSize());
-    AudioBufferCopyWithScale(aData, 1.0f / FFTSize(), paddedData.Elements(),
-                             dataSize);
+    AudioBufferCopyWithScale(aData, 1.0f / AssertedCast<float>(FFTSize()),
+                             paddedData.Elements(), dataSize);
     PodZero(paddedData.Elements() + dataSize, mFFTSize - dataSize);
     PerformFFT(paddedData.Elements());
   }
@@ -128,12 +121,18 @@
   double ExtractAverageGroupDelay();
 
   uint32_t FFTSize() const { return mFFTSize; }
-  float RealData(uint32_t aIndex) const { return mOutputBuffer[aIndex].r; }
+  float RealData(uint32_t aIndex) const {
+    MOZ_ASSERT(!mInversePerformed);
+    return mOutputBuffer[aIndex].r;
+  }
   float& RealData(uint32_t aIndex) {
     MOZ_ASSERT(!mInversePerformed);
     return mOutputBuffer[aIndex].r;
   }
-  float ImagData(uint32_t aIndex) const { return mOutputBuffer[aIndex].i; }
+  float ImagData(uint32_t aIndex) const {
+    MOZ_ASSERT(!mInversePerformed);
+    return mOutputBuffer[aIndex].i;
+  }
   float& ImagData(uint32_t aIndex) {
     MOZ_ASSERT(!mInversePerformed);
     return mOutputBuffer[aIndex].i;
@@ -159,6 +158,7 @@
  private:
   bool EnsureFFT() {
     if (!mTxCtx) {
+      // Forward transform is always unscaled for our purpose.
       float scale = 1.0f;
       DebugOnly<int> rv =
           sFFTFuncs.init(&mTxCtx, &mFn, AV_TX_FLOAT_RDFT, 0 /* forward */,
@@ -169,10 +169,9 @@
   }
   bool EnsureIFFT() {
     if (!mITxCtx) {
-      float scale = 0.5f;
       DebugOnly<int> rv =
           sFFTFuncs.init(&mITxCtx, &mIFn, AV_TX_FLOAT_RDFT, 1 /* inverse */,
-                         AssertedCast<int>(mFFTSize), &scale, 0);
+                         AssertedCast<int>(mFFTSize), &mInverseScaling, 0);
       MOZ_ASSERT(!rv, "av_tx_init: invalid parameters (inverse)");
     }
     return true;
@@ -199,6 +198,9 @@
   av_tx_fn mIFn{};
   AlignedTArray<ComplexU> mOutputBuffer;
   uint32_t mFFTSize{};
+  // A scaling that is performed when doing an inverse transform. The forward
+  // transform is always unscaled.
+  float mInverseScaling;
 #ifdef DEBUG
   bool mInversePerformed = false;
 #endif