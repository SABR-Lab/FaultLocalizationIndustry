# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/TouchManager.cpp
# Commit: 0c3a2df68be4
# Full Hash: 0c3a2df68be4e59a46e89640b95e3f8ba7082a60
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2024-03-12 09:25:52
# Regressor Bug: 1695574
# File Overlap Count: 1
# Description:
#   Bug 1695574 - Make `PresShell::EventHandler::HandleEventUsingCoordinates` keep handling touch events after preceding pointer event target is removed r=smaug,edgar,dom-core
#   
#   As far as investigating the behavior of the other browsers, touch events are
#   dispatched the same target as the preceding `pointerdown` even after the target
#   is removed from the DOM tree.  However, the following pointer events are
# ==============================================================================

diff -r bdee0bed3f5c -r 0c3a2df68be4 layout/base/TouchManager.cpp
--- a/layout/base/TouchManager.cpp	Tue Mar 12 00:54:41 2024 +0000
+++ b/layout/base/TouchManager.cpp	Tue Mar 12 01:03:44 2024 +0000
@@ -174,7 +174,7 @@
   }
 
   nsIFrame* frame = nullptr;
-  for (int32_t i = aEvent->mTouches.Length(); i;) {
+  for (uint32_t i = aEvent->mTouches.Length(); i;) {
     --i;
     dom::Touch* touch = aEvent->mTouches[i];
     if (TouchManager::HasCapturedTouch(touch->Identifier())) {
@@ -182,9 +182,35 @@
     }
 
     MOZ_ASSERT(touch->mOriginalTarget);
-    nsCOMPtr<nsIContent> targetContent = do_QueryInterface(touch->GetTarget());
-    nsIFrame* targetFrame =
-        targetContent ? targetContent->GetPrimaryFrame() : nullptr;
+    nsIContent* const targetContent =
+        nsIContent::FromEventTargetOrNull(touch->GetTarget());
+    if (MOZ_UNLIKELY(!targetContent)) {
+      touch->mIsTouchEventSuppressed = true;
+      continue;
+    }
+
+    // Even if the target content is not connected, we should dispatch the touch
+    // start event except when the target content is owned by different
+    // document.
+    if (MOZ_UNLIKELY(!targetContent->IsInComposedDoc())) {
+      if (anyTarget && anyTarget->OwnerDoc() != targetContent->OwnerDoc()) {
+        touch->mIsTouchEventSuppressed = true;
+        continue;
+      }
+      if (!anyTarget) {
+        anyTarget = targetContent;
+      }
+      touch->SetTouchTarget(targetContent->GetAsElementOrParentElement());
+      if (PresShell* const presShell =
+              targetContent->OwnerDoc()->GetPresShell()) {
+        if (nsIFrame* rootFrame = presShell->GetRootFrame()) {
+          frame = rootFrame;
+        }
+      }
+      continue;
+    }
+
+    nsIFrame* targetFrame = targetContent->GetPrimaryFrame();
     if (targetFrame && !anyTarget) {
       anyTarget = targetContent;
     } else {
@@ -208,10 +234,12 @@
         touch->mIsTouchEventSuppressed = true;
       } else {
         targetFrame = newTargetFrame;
-        targetFrame->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
-        touch->SetTouchTarget(targetContent
-                                  ? targetContent->GetAsElementOrParentElement()
-                                  : nullptr);
+        nsCOMPtr<nsIContent> newTargetContent;
+        targetFrame->GetContentForEvent(aEvent,
+                                        getter_AddRefs(newTargetContent));
+        touch->SetTouchTarget(
+            newTargetContent ? newTargetContent->GetAsElementOrParentElement()
+                             : nullptr);
       }
     }
     if (targetFrame) {