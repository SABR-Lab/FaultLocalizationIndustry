# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/painting/nsDisplayList.cpp
# Commit: b32811ea1c61
# Full Hash: b32811ea1c61e1891454d826f7ba003416c9eb57
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-03-11 21:13:39
# Regressor Bug: 1860328
# File Overlap Count: 2
# Description:
#   Bug 1860328 - Fix a crash which a caret frame misses a MarkNeedsDisplayItemRebuild() call r=emilio
#   
#   Generally, we mark a caret frame for display first, and then
#   nsCaret tracks this frame in nsCaret::SchedulePaint to call
#   MarkNeedsDisplayItemRebuild() accordingly. However, it's possible
# ==============================================================================

diff -r caab023e5d2d -r b32811ea1c61 layout/painting/nsDisplayList.cpp
--- a/layout/painting/nsDisplayList.cpp	Mon Mar 11 13:41:27 2024 +0000
+++ b/layout/painting/nsDisplayList.cpp	Mon Mar 11 13:41:28 2024 +0000
@@ -1124,6 +1124,14 @@
   // instead.
   if (state->mCaretFrame) {
     MOZ_ASSERT(state->mCaretFrame->PresShell() == state->mPresShell);
+    // Generally, nsCaret sets the last caret frame in
+    // nsCaret::SchedulePaint to call MarkNeedsDisplayItemRebuild()
+    // on the frame accordingly, so we shouldn't need do to this manually.
+    // However, it's possible for nsCaret::SchedulePaint fails to find
+    // the caret frame (i.e, selection changes), we end up not calling
+    // MarkNeedsDisplayItemRebuild() on this frame. This is not good,
+    // so we are manually setting the last caret frame here.
+    caret->SetLastCaretFrame(state->mCaretFrame);
     MarkFrameForDisplay(state->mCaretFrame, aReferenceFrame);
   }
 }
