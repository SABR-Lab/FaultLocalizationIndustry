# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCaret.cpp
# Commit: d3946837037d
# Full Hash: d3946837037d31a7b6f83b1977e57c4ea384c904
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-03-19 09:35:23
# Regressor Bug: 1860328
# File Overlap Count: 2
# Description:
#   Bug 1860328 - Track nsCaret position at the DOM level. r=sefeng,masayuki
#   
#   This should avoid a bunch of paint invalidation issues with our caret
#   code (and seems simpler anyways).
#   
# ==============================================================================

diff -r d5855a08e601 -r d3946837037d layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp	Mon Mar 18 09:12:57 2024 +0000
+++ b/layout/base/nsCaret.cpp	Mon Mar 18 09:12:57 2024 +0000
@@ -50,16 +50,7 @@
 // like an insignificant dot
 static const int32_t kMinBidiIndicatorPixels = 2;
 
-nsCaret::nsCaret()
-    : mOverrideOffset(0),
-      mBlinkCount(-1),
-      mBlinkRate(0),
-      mHideCount(0),
-      mIsBlinkOn(false),
-      mVisible(false),
-      mReadOnly(false),
-      mShowDuringSelection(false),
-      mIgnoreUserModify(true) {}
+nsCaret::nsCaret() = default;
 
 nsCaret::~nsCaret() { StopBlinking(); }
 
@@ -82,6 +73,7 @@
 
   selection->AddSelectionListener(this);
   mDomSelectionWeak = selection;
+  UpdateCaretPositionFromSelectionIfNeeded();
 
   return NS_OK;
 }
@@ -137,8 +129,7 @@
   }
   mDomSelectionWeak = nullptr;
   mPresShell = nullptr;
-
-  mOverrideContent = nullptr;
+  mCaretPosition = {};
 }
 
 NS_IMPL_ISUPPORTS(nsCaret, nsISelectionListener)
@@ -148,15 +139,31 @@
 void nsCaret::SetSelection(Selection* aDOMSel) {
   MOZ_ASSERT(aDOMSel);
   mDomSelectionWeak = aDOMSel;
+  UpdateCaretPositionFromSelectionIfNeeded();
   ResetBlinking();
-  SchedulePaint(aDOMSel);
+  SchedulePaint();
+}
+
+void nsCaret::SetVisible(bool aVisible) {
+  mVisible = aVisible;
+  mIgnoreUserModify = aVisible;
+  ResetBlinking();
+  SchedulePaint();
 }
 
-void nsCaret::SetVisible(bool inMakeVisible) {
-  mVisible = inMakeVisible;
-  mIgnoreUserModify = mVisible;
-  ResetBlinking();
-  SchedulePaint();
+bool nsCaret::IsVisible() {
+  if (!mVisible || mHideCount) {
+    return false;
+  }
+
+  if (!mShowDuringSelection) {
+    Selection* selection = GetSelection();
+    if (!selection || !selection->IsCollapsed()) {
+      return false;
+    }
+  }
+
+  return !IsMenuPopupHidingCaret();
 }
 
 void nsCaret::AddForceHide() {
@@ -176,8 +183,8 @@
   SchedulePaint();
 }
 
-void nsCaret::SetCaretReadOnly(bool inMakeReadonly) {
-  mReadOnly = inMakeReadonly;
+void nsCaret::SetCaretReadOnly(bool aReadOnly) {
+  mReadOnly = aReadOnly;
   ResetBlinking();
   SchedulePaint();
 }
@@ -333,61 +340,48 @@
   return rect;
 }
 
-nsIFrame* nsCaret::GetFrameAndOffset(const Selection* aSelection,
-                                     nsINode* aOverrideNode,
-                                     int32_t aOverrideOffset,
-                                     int32_t* aFrameOffset,
-                                     nsIFrame** aUnadjustedFrame) {
-  if (aUnadjustedFrame) {
-    *aUnadjustedFrame = nullptr;
+auto nsCaret::CaretPositionFor(const Selection* aSelection) -> CaretPosition {
+  if (!aSelection) {
+    return {};
+  }
+  const nsFrameSelection* frameSelection = aSelection->GetFrameSelection();
+  if (!frameSelection) {
+    return {};
   }
-
-  nsINode* focusNode;
-  int32_t focusOffset;
+  nsINode* node = aSelection->GetFocusNode();
+  if (!node) {
+    return {};
+  }
+  return {
+      node,
+      int32_t(aSelection->FocusOffset()),
+      frameSelection->GetHint(),
+      frameSelection->GetCaretBidiLevel(),
+  };
+}
 
-  if (aOverrideNode) {
-    focusNode = aOverrideNode;
-    focusOffset = aOverrideOffset;
-  } else if (aSelection) {
-    focusNode = aSelection->GetFocusNode();
-    focusOffset = aSelection->FocusOffset();
-  } else {
-    return nullptr;
-  }
+CaretFrameData nsCaret::GetFrameAndOffset(const CaretPosition& aPosition) {
+  nsINode* focusNode = aPosition.mContent;
+  int32_t focusOffset = aPosition.mOffset;
 
-  if (!focusNode || !focusNode->IsContent() || !aSelection) {
-    return nullptr;
+  if (!focusNode || !focusNode->IsContent()) {
+    return {};
   }
 
   nsIContent* contentNode = focusNode->AsContent();
-  nsFrameSelection* frameSelection = aSelection->GetFrameSelection();
-  BidiEmbeddingLevel bidiLevel = frameSelection->GetCaretBidiLevel();
-  const CaretFrameData result =
-      SelectionMovementUtils::GetCaretFrameForNodeOffset(
-          frameSelection, contentNode, focusOffset, frameSelection->GetHint(),
-          bidiLevel, ForceEditableRegion::No);
-  // FIXME: It's odd to update nsFrameSelection within this method which is
-  // named as a getter.
-  if (result.mFrame) {
-    frameSelection->SetHint(result.mHint);
-  }
-  if (aUnadjustedFrame) {
-    *aUnadjustedFrame = result.mUnadjustedFrame;
-  }
-  if (aFrameOffset) {
-    *aFrameOffset = result.mOffsetInFrameContent;
-  }
-  return result.mFrame;
+  return SelectionMovementUtils::GetCaretFrameForNodeOffset(
+      nullptr, contentNode, focusOffset, aPosition.mHint, aPosition.mBidiLevel,
+      ForceEditableRegion::No);
 }
 
 /* static */
 nsIFrame* nsCaret::GetGeometry(const Selection* aSelection, nsRect* aRect) {
-  int32_t frameOffset;
-  nsIFrame* frame = GetFrameAndOffset(aSelection, nullptr, 0, &frameOffset);
-  if (frame) {
-    *aRect = GetGeometryForFrame(frame, frameOffset, nullptr);
+  auto data = GetFrameAndOffset(CaretPositionFor(aSelection));
+  if (data.mFrame) {
+    *aRect =
+        GetGeometryForFrame(data.mFrame, data.mOffsetInFrameContent, nullptr);
   }
-  return frame;
+  return data.mFrame;
 }
 
 [[nodiscard]] static nsIFrame* GetContainingBlockIfNeeded(nsIFrame* aFrame) {
@@ -397,31 +391,15 @@
   return aFrame->GetContainingBlock();
 }
 
-void nsCaret::SchedulePaint(Selection* aSelection) {
-  if (mLastCaretFrame) {
-    mLastCaretFrame->MarkNeedsDisplayItemRebuild();
-  }
-
-  Selection* selection;
-  if (aSelection) {
-    selection = aSelection;
-  } else {
-    selection = GetSelection();
-  }
-
-  int32_t frameOffset;
-  nsIFrame* frame = GetFrameAndOffset(selection, mOverrideContent,
-                                      mOverrideOffset, &frameOffset);
-  if (!frame) {
-    mLastCaretFrame = nullptr;
+void nsCaret::SchedulePaint() {
+  auto data = GetFrameAndOffset(mCaretPosition);
+  if (!data.mFrame) {
     return;
   }
-
+  nsIFrame* frame = data.mFrame;
   if (nsIFrame* cb = GetContainingBlockIfNeeded(frame)) {
     frame = cb;
   }
-
-  mLastCaretFrame = frame;
   frame->SchedulePaint();
 }
 
@@ -430,12 +408,32 @@
   SchedulePaint();
 }
 
+void nsCaret::UpdateCaretPositionFromSelectionIfNeeded() {
+  if (mFixedCaretPosition) {
+    return;
+  }
+  CaretPosition newPos = CaretPositionFor(GetSelection());
+  if (newPos == mCaretPosition) {
+    return;
+  }
+  // First SchedulePaint call invalidates the old position. Second one the new
+  // one.
+  SchedulePaint();
+  mCaretPosition = newPos;
+  SchedulePaint();
+}
+
 void nsCaret::SetCaretPosition(nsINode* aNode, int32_t aOffset) {
-  mOverrideContent = aNode;
-  mOverrideOffset = aOffset;
-
+  // Schedule a paint with the old position to invalidate.
+  mFixedCaretPosition = !!aNode;
+  if (mFixedCaretPosition) {
+    SchedulePaint();
+    mCaretPosition = {aNode, aOffset};
+    SchedulePaint();
+  } else {
+    UpdateCaretPositionFromSelectionIfNeeded();
+  }
   ResetBlinking();
-  SchedulePaint();
 }
 
 void nsCaret::CheckSelectionLanguageChange() {
@@ -484,16 +482,15 @@
   // taken into account when computing the caret position below.
   CheckSelectionLanguageChange();
 
-  int32_t frameOffset;
-  nsIFrame* unadjustedFrame = nullptr;
-  nsIFrame* frame =
-      GetFrameAndOffset(GetSelection(), mOverrideContent, mOverrideOffset,
-                        &frameOffset, &unadjustedFrame);
-  MOZ_ASSERT(!!frame == !!unadjustedFrame);
-  if (!frame) {
+  auto data = GetFrameAndOffset(mCaretPosition);
+  MOZ_ASSERT(!!data.mFrame == !!data.mUnadjustedFrame);
+  if (!data.mFrame) {
     return nullptr;
   }
 
+  nsIFrame* frame = data.mFrame;
+  nsIFrame* unadjustedFrame = data.mUnadjustedFrame;
+  int32_t frameOffset(data.mOffsetInFrameContent);
   // Now we have a frame, check whether it's appropriate to show the caret here.
   // Note we need to check the unadjusted frame, otherwise consider the
   // following case:
@@ -561,29 +558,28 @@
 NS_IMETHODIMP
 nsCaret::NotifySelectionChanged(Document*, Selection* aDomSel, int16_t aReason,
                                 int32_t aAmount) {
-  if (mLastCaretFrame) {
-    mLastCaretFrame->MarkNeedsDisplayItemRebuild();
-  }
   // Note that aDomSel, per the comment below may not be the same as our
   // selection, but that's OK since if that is the case, it wouldn't have
   // mattered what IsVisible() returns here, so we just opt for checking
   // the selection later down below.
-  if ((aReason & nsISelectionListener::MOUSEUP_REASON) ||
-      !IsVisible(aDomSel))  // this wont do
+  if ((aReason & nsISelectionListener::MOUSEUP_REASON) || !IsVisible()) {
+    // this wont do
     return NS_OK;
+  }
 
   // The same caret is shared amongst the document and any text widgets it
   // may contain. This means that the caret could get notifications from
   // multiple selections.
   //
   // If this notification is for a selection that is not the one the
-  // the caret is currently interested in (mDomSelectionWeak), then there
-  // is nothing to do!
-
-  if (mDomSelectionWeak != aDomSel) return NS_OK;
+  // the caret is currently interested in (mDomSelectionWeak), or the caret
+  // position is fixed, then there is nothing to do!
+  if (mFixedCaretPosition || mDomSelectionWeak != aDomSel) {
+    return NS_OK;
+  }
 
   ResetBlinking();
-  SchedulePaint(aDomSel);
+  UpdateCaretPositionFromSelectionIfNeeded();
 
   return NS_OK;
 }
@@ -656,28 +652,27 @@
   return total;
 }
 
+// FIXME(emilio): this code is broken in tons of ways: Doesn't account for
+// shadow dom, doesn't work in child processes... Do we need this at all?
 bool nsCaret::IsMenuPopupHidingCaret() {
   // Check if there are open popups.
   nsXULPopupManager* popMgr = nsXULPopupManager::GetInstance();
   nsTArray<nsIFrame*> popups;
   popMgr->GetVisiblePopups(popups);
-
-  if (popups.Length() == 0)
+  if (popups.IsEmpty()) {
     return false;  // No popups, so caret can't be hidden by them.
+  }
 
-  // Get the selection focus content, that's where the caret would
-  // go if it was drawn.
-  if (!mDomSelectionWeak) {
+  nsCOMPtr<nsIContent> caretContent =
+      nsIContent::FromNodeOrNull(mCaretPosition.mContent);
+  if (!caretContent) {
     return true;  // No selection/caret to draw.
   }
-  nsCOMPtr<nsIContent> caretContent =
-      nsIContent::FromNodeOrNull(mDomSelectionWeak->GetFocusNode());
-  if (!caretContent) return true;  // No selection/caret to draw.
 
   // If there's a menu popup open before the popup with
   // the caret, don't show the caret.
   for (uint32_t i = 0; i < popups.Length(); i++) {
-    nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame*>(popups[i]);
+    auto* popupFrame = static_cast<nsMenuPopupFrame*>(popups[i]);
     nsIContent* popupContent = popupFrame->GetContent();
 
     if (caretContent->IsInclusiveDescendantOf(popupContent)) {