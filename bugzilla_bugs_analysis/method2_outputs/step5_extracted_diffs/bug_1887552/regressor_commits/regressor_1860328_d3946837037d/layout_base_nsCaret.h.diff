# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCaret.h
# Commit: d3946837037d
# Full Hash: d3946837037d31a7b6f83b1977e57c4ea384c904
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-03-19 09:35:23
# Regressor Bug: 1860328
# File Overlap Count: 2
# Description:
#   Bug 1860328 - Track nsCaret position at the DOM level. r=sefeng,masayuki
#   
#   This should avoid a bunch of paint invalidation issues with our caret
#   code (and seems simpler anyways).
#   
# ==============================================================================

diff -r d5855a08e601 -r d3946837037d layout/base/nsCaret.h
--- a/layout/base/nsCaret.h	Mon Mar 18 09:12:57 2024 +0000
+++ b/layout/base/nsCaret.h	Mon Mar 18 09:12:57 2024 +0000
@@ -10,7 +10,7 @@
 #define nsCaret_h__
 
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/dom/Selection.h"
+#include "mozilla/SelectionMovementUtils.h"
 #include "nsCoord.h"
 #include "nsIFrame.h"
 #include "nsISelectionListener.h"
@@ -47,10 +47,10 @@
 
   using CaretAssociationHint = mozilla::CaretAssociationHint;
 
-  nsresult Init(mozilla::PresShell* aPresShell);
+  nsresult Init(mozilla::PresShell*);
   void Terminate();
 
-  void SetSelection(mozilla::dom::Selection* aDOMSel);
+  void SetSelection(mozilla::dom::Selection*);
   mozilla::dom::Selection* GetSelection();
 
   /**
@@ -65,7 +65,7 @@
   /** SetVisible will set the visibility of the caret
    *  @param inMakeVisible true to show the caret, false to hide it
    */
-  void SetVisible(bool intMakeVisible);
+  void SetVisible(bool aVisible);
   /** IsVisible will get the visibility of the caret.
    *  This returns false if the caret is hidden because it was set
    *  to not be visible, or because the selection is not collapsed, or
@@ -73,29 +73,8 @@
    *  It does not take account of blinking or the caret being hidden
    *  because we're in non-editable/disabled content.
    */
-  bool IsVisible(mozilla::dom::Selection* aSelection = nullptr) {
-    if (!mVisible || mHideCount) {
-      return false;
-    }
+  bool IsVisible();
 
-    if (!mShowDuringSelection) {
-      mozilla::dom::Selection* selection;
-      if (aSelection) {
-        selection = aSelection;
-      } else {
-        selection = GetSelection();
-      }
-      if (!selection || !selection->IsCollapsed()) {
-        return false;
-      }
-    }
-
-    if (IsMenuPopupHidingCaret()) {
-      return false;
-    }
-
-    return true;
-  }
   /**
    * AddForceHide() increases mHideCount and hide the caret even if
    * SetVisible(true) has been or will be called.  This is useful when the
@@ -115,7 +94,7 @@
    *  @param inMakeReadonly true to show the caret in a 'read only' state,
    *         false to show the caret in normal, editing state
    */
-  void SetCaretReadOnly(bool inMakeReadonly);
+  void SetCaretReadOnly(bool aReadOnly);
   /**
    * @param aVisibility true if the caret should be visible even when the
    * selection is not collapsed.
@@ -133,7 +112,7 @@
    * Schedule a repaint for the frame where the caret would appear.
    * Does not check visibility etc.
    */
-  void SchedulePaint(mozilla::dom::Selection* aSelection = nullptr);
+  void SchedulePaint();
 
   /**
    * Returns a frame to paint in, and the bounds of the painted caret
@@ -166,6 +145,22 @@
   // nsISelectionListener interface
   NS_DECL_NSISELECTIONLISTENER
 
+  /** The current caret position. */
+  struct CaretPosition {
+    nsCOMPtr<nsINode> mContent;
+    int32_t mOffset = 0;
+    CaretAssociationHint mHint{0};
+    mozilla::intl::BidiEmbeddingLevel mBidiLevel;
+
+    bool operator==(const CaretPosition& aOther) const {
+      return mContent == aOther.mContent && mOffset == aOther.mOffset &&
+             mHint == aOther.mHint && mBidiLevel == aOther.mBidiLevel;
+    }
+    explicit operator bool() const { return !!mContent; }
+  };
+
+  static CaretPosition CaretPositionFor(const mozilla::dom::Selection*);
+
   /**
    * Gets the position and size of the caret that would be drawn for
    * the focus node/offset of aSelection (assuming it would be drawn,
@@ -182,18 +177,9 @@
   static nsRect GetGeometryForFrame(nsIFrame* aFrame, int32_t aFrameOffset,
                                     nscoord* aBidiIndicatorSize);
 
-  // Get the frame and frame offset based on the focus node and focus offset
-  // of aSelection. If aOverrideNode and aOverride are provided, use them
-  // instead.
-  // @param aFrameOffset return the frame offset if non-null.
-  // @param aUnadjustedFrame return the original frame that the selection is
-  // targeting, without any adjustment for painting.
-  // @return the frame of the focus node.
-  static nsIFrame* GetFrameAndOffset(const mozilla::dom::Selection* aSelection,
-                                     nsINode* aOverrideNode,
-                                     int32_t aOverrideOffset,
-                                     int32_t* aFrameOffset,
-                                     nsIFrame** aUnadjustedFrame = nullptr);
+  // Get the frame and frame offset based on aPosition.
+  static mozilla::CaretFrameData GetFrameAndOffset(
+      const CaretPosition& aPosition);
 
   size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const;
 
@@ -224,67 +210,64 @@
   // 3. The caret selection is empty.
   bool IsMenuPopupHidingCaret();
 
+  // If we're tracking the selection, this updates the caret position and
+  // invalidates paint as needed.
+  void UpdateCaretPositionFromSelectionIfNeeded();
+
   nsWeakPtr mPresShell;
   mozilla::WeakPtr<mozilla::dom::Selection> mDomSelectionWeak;
 
   nsCOMPtr<nsITimer> mBlinkTimer;
 
-  /**
-   * The content to draw the caret at. If null, we use mDomSelectionWeak's
-   * focus node instead.
-   */
-  nsCOMPtr<nsINode> mOverrideContent;
-  /**
-   * The character offset to draw the caret at.
-   * Ignored if mOverrideContent is null.
-   */
-  int32_t mOverrideOffset;
+  CaretPosition mCaretPosition;
+
   /**
    * mBlinkCount is used to control the number of times to blink the caret
    * before stopping the blink. This is reset each time we reset the
    * blinking.
    */
-  int32_t mBlinkCount;
+  int32_t mBlinkCount = -1;
   /**
    * mBlinkRate is the rate of the caret blinking the last time we read it.
    * It is used as a way to optimize whether we need to reset the blinking
    * timer. 0 or a negative value means no blinking.
    */
-  int32_t mBlinkRate;
+  int32_t mBlinkRate = 0;
   /**
    * mHideCount is not 0, it means that somebody doesn't want the caret
    * to be visible.  See AddForceHide() and RemoveForceHide().
    */
-  uint32_t mHideCount;
+  uint32_t mHideCount = 0;
 
   /**
    * mIsBlinkOn is true when we're in a blink cycle where the caret is on.
    */
-  bool mIsBlinkOn;
+  bool mIsBlinkOn = false;
   /**
    * mIsVisible is true when SetVisible was last called with 'true'.
    */
-  bool mVisible;
+  bool mVisible = false;
   /**
    * mReadOnly is true when the caret is set to "read only" mode (i.e.,
    * it doesn't blink).
    */
-  bool mReadOnly;
+  bool mReadOnly = false;
   /**
    * mShowDuringSelection is true when the caret should be shown even when
    * the selection is not collapsed.
    */
-  bool mShowDuringSelection;
+  bool mShowDuringSelection = false;
   /**
    * mIgnoreUserModify is true when the caret should be shown even when
    * it's in non-user-modifiable content.
    */
-  bool mIgnoreUserModify;
+  bool mIgnoreUserModify = true;
 
   /**
-   * mLastCaretFrame is the last caret frame that was scheduled to paint.
+   * If the caret position is fixed, it's been overridden externally and it
+   * will not track the selection.
    */
-  WeakFrame mLastCaretFrame;
+  bool mFixedCaretPosition = false;
 };
 
 #endif  // nsCaret_h__