# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DirectionalityUtils.cpp
# Commit: 14ed8bcf372c
# Full Hash: 14ed8bcf372c696393c3083d29d78959aa0cb5a3
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-01-16 05:03:21
# Regressor Bug: 1856156
# File Overlap Count: 1
# Description:
#   Bug 1856156 - Recompute auto directionality on input type changes. r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D198588
# ==============================================================================

diff -r d84b730f202a -r 14ed8bcf372c dom/base/DirectionalityUtils.cpp
--- a/dom/base/DirectionalityUtils.cpp	Mon Jan 15 19:30:40 2024 +0000
+++ b/dom/base/DirectionalityUtils.cpp	Mon Jan 15 19:35:43 2024 +0000
@@ -231,7 +231,7 @@
 using mozilla::dom::ShadowRoot;
 
 static nsIContent* GetParentOrHostOrSlot(
-    nsIContent* aContent, bool* aCrossedShadowBoundary = nullptr) {
+    const nsIContent* aContent, bool* aCrossedShadowBoundary = nullptr) {
   if (HTMLSlotElement* slot = aContent->GetAssignedSlot()) {
     if (aCrossedShadowBoundary) {
       *aCrossedShadowBoundary = true;
@@ -244,7 +244,7 @@
     return parent;
   }
 
-  ShadowRoot* sr = ShadowRoot::FromNode(aContent);
+  const ShadowRoot* sr = ShadowRoot::FromNode(aContent);
   if (sr) {
     if (aCrossedShadowBoundary) {
       *aCrossedShadowBoundary = true;
@@ -675,6 +675,24 @@
   }
 };
 
+Directionality GetParentDirectionality(const Element* aElement) {
+  if (nsIContent* parent = GetParentOrHostOrSlot(aElement)) {
+    if (ShadowRoot* shadow = ShadowRoot::FromNode(parent)) {
+      parent = shadow->GetHost();
+    }
+    if (parent && parent->IsElement()) {
+      // If the node doesn't have an explicit dir attribute with a valid value,
+      // the directionality is the same as the parent element (but don't
+      // propagate the parent directionality if it isn't set yet).
+      Directionality parentDir = parent->AsElement()->GetDirectionality();
+      if (parentDir != eDir_NotSet) {
+        return parentDir;
+      }
+    }
+  }
+  return eDir_LTR;
+}
+
 Directionality RecomputeDirectionality(Element* aElement, bool aNotify) {
   MOZ_ASSERT(!aElement->HasDirAuto(),
              "RecomputeDirectionality called with dir=auto");
@@ -683,8 +701,6 @@
     return aElement->GetDirectionality();
   }
 
-  Directionality dir = eDir_LTR;
-
   // https://html.spec.whatwg.org/multipage/dom.html#the-directionality:
   //
   // If the element is an input element whose type attribute is in the
@@ -694,27 +710,12 @@
   //     The directionality of the element is 'ltr'.
   if (auto* input = HTMLInputElement::FromNode(*aElement)) {
     if (input->ControlType() == FormControlType::InputTel) {
-      aElement->SetDirectionality(dir, aNotify);
-      return dir;
+      aElement->SetDirectionality(eDir_LTR, aNotify);
+      return eDir_LTR;
     }
   }
 
-  if (nsIContent* parent = GetParentOrHostOrSlot(aElement)) {
-    if (ShadowRoot* shadow = ShadowRoot::FromNode(parent)) {
-      parent = shadow->GetHost();
-    }
-
-    if (parent && parent->IsElement()) {
-      // If the node doesn't have an explicit dir attribute with a valid value,
-      // the directionality is the same as the parent element (but don't
-      // propagate the parent directionality if it isn't set yet).
-      Directionality parentDir = parent->AsElement()->GetDirectionality();
-      if (parentDir != eDir_NotSet) {
-        dir = parentDir;
-      }
-    }
-  }
-
+  const Directionality dir = GetParentDirectionality(aElement);
   aElement->SetDirectionality(dir, aNotify);
   return dir;
 }