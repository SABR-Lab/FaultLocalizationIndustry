# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: toolkit/components/antitracking/URLQueryStringStripper.cpp
# Commit: c2ca2f596c09
# Full Hash: c2ca2f596c0922e7fd34494dc6ed8dd68d46b122
# Author: abhishekmadan30 <148475204+abhishekmadan30@users.noreply.github.com>
# Date: 2024-03-26 04:11:24
# Regressor Bug: 1877419
# File Overlap Count: 1
# Description:
#   Bug 1877419 - Part 1: Added nested stripping of urls to copy without site tracking. r=pbz,necko-reviewers
#   
#   Depends on D204914
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202943
# ==============================================================================

diff -r 45931e6db21e -r c2ca2f596c09 toolkit/components/antitracking/URLQueryStringStripper.cpp
--- a/toolkit/components/antitracking/URLQueryStringStripper.cpp	Mon Mar 25 18:30:38 2024 +0000
+++ b/toolkit/components/antitracking/URLQueryStringStripper.cpp	Mon Mar 25 18:30:38 2024 +0000
@@ -17,6 +17,7 @@
 #include "nsIURIMutator.h"
 #include "nsUnicharUtils.h"
 #include "nsURLHelper.h"
+#include "nsNetUtil.h"
 #include "mozilla/dom/StripOnShareRuleBinding.h"
 
 namespace {
@@ -84,64 +85,16 @@
   NS_ENSURE_ARG_POINTER(strippedURI);
   int aStripCount = 0;
 
-  nsAutoCString query;
-  nsresult rv = aURI->GetQuery(query);
-  NS_ENSURE_SUCCESS(rv, rv);
-  // We don't need to do anything if there is no query string.
-  if (query.IsEmpty()) {
-    Telemetry::Accumulate(Telemetry::STRIP_ON_SHARE_PARAMS_REMOVED, 0);
-    return NS_OK;
-  }
-  nsAutoCString host;
-  rv = aURI->GetHost(host);
+  nsresult rv =
+      StripForCopyOrShareInternal(aURI, strippedURI, aStripCount, false);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  URLParams params;
-
-  URLParams::Parse(query, true, [&](nsString&& name, nsString&& value) {
-    nsAutoString lowerCaseName;
-    ToLowerCase(name, lowerCaseName);
-    // Look through the global rules.
-    dom::StripRule globalRule;
-    bool keyExists = mStripOnShareMap.Get("*"_ns, &globalRule);
-    // There should always be a global rule.
-    MOZ_ASSERT(keyExists);
-    for (const auto& param : globalRule.mQueryParams) {
-      if (param == lowerCaseName) {
-        aStripCount++;
-        return true;
-      }
-    }
-
-    // Check for site specific rules.
-    dom::StripRule siteSpecificRule;
-    keyExists = mStripOnShareMap.Get(host, &siteSpecificRule);
-    if (keyExists) {
-      for (const auto& param : siteSpecificRule.mQueryParams) {
-        if (param == lowerCaseName) {
-          aStripCount++;
-          return true;
-        }
-      }
-    }
-
-    params.Append(name, value);
-    return true;
-  });
-
   Telemetry::Accumulate(Telemetry::STRIP_ON_SHARE_PARAMS_REMOVED, aStripCount);
 
   if (!aStripCount) {
     return NS_OK;
   }
 
-  nsAutoString newQuery;
-  params.Serialize(newQuery, false);
-
-  Unused << NS_MutateURI(aURI)
-                .SetQuery(NS_ConvertUTF16toUTF8(newQuery))
-                .Finalize(strippedURI);
-
   // To calculate difference in length of the URL
   // after stripping occurs for Telemetry
   nsAutoCString specOriginalURI;
@@ -426,4 +379,107 @@
   return NS_OK;
 }
 
+nsresult URLQueryStringStripper::StripForCopyOrShareInternal(
+    nsIURI* aURI, nsIURI** strippedURI, int& aStripCount,
+    bool aStripNestedURIs) {
+  nsAutoCString query;
+  nsresult rv = aURI->GetQuery(query);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // We don't need to do anything if there is no query string.
+  if (query.IsEmpty()) {
+    Telemetry::Accumulate(Telemetry::STRIP_ON_SHARE_PARAMS_REMOVED, 0);
+    return NS_OK;
+  }
+
+  nsAutoCString host;
+  rv = aURI->GetHost(host);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  URLParams params;
+
+  URLParams::Parse(query, false, [&](nsString&& name, nsString&& value) {
+    nsAutoString lowerCaseName;
+    ToLowerCase(name, lowerCaseName);
+
+    // Look through the global rules.
+    dom::StripRule globalRule;
+    bool keyExists = mStripOnShareMap.Get("*"_ns, &globalRule);
+    // There should always be a global rule.
+    MOZ_ASSERT(keyExists);
+
+    // Look through the global rules.
+    for (const auto& param : globalRule.mQueryParams) {
+      if (param == lowerCaseName) {
+        aStripCount++;
+        return true;
+      }
+    }
+
+    // Check for site specific rules.
+    dom::StripRule siteSpecificRule;
+    keyExists = mStripOnShareMap.Get(host, &siteSpecificRule);
+    if (keyExists) {
+      for (const auto& param : siteSpecificRule.mQueryParams) {
+        if (param == lowerCaseName) {
+          aStripCount++;
+          return true;
+        }
+      }
+    }
+
+    // Only if it is top layer of the recursion then it
+    // checks if the value of the query parameter is a valid URI
+    // if not then it gets added back to the query, if it is then
+    // it gets passed back into this method but with the recursive
+    // stripping flag set to true
+    if (!aStripNestedURIs) {
+      nsAutoString decodeValue;
+      URLParams::DecodeString(NS_ConvertUTF16toUTF8(value), decodeValue);
+
+      nsCOMPtr<nsIURI> nestedURI;
+      rv = NS_NewURI(getter_AddRefs(nestedURI), decodeValue);
+
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        if (rv == NS_ERROR_NOT_AVAILABLE) {
+          LOG(("Unable to obtain ioService"));
+          return false;
+        }
+        params.Append(name, value);
+        return true;
+      }
+
+      nsCOMPtr<nsIURI> strippedNestedURI;
+      rv = StripForCopyOrShareInternal(
+          nestedURI, getter_AddRefs(strippedNestedURI), aStripCount, true);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return false;
+      }
+
+      nsAutoCString nestedURIString;
+      rv = strippedNestedURI->GetSpec(nestedURIString);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return false;
+      }
+
+      // Encodes URI
+      nsAutoString encodedURI;
+      URLParams::SerializeString(nestedURIString, encodedURI);
+
+      params.Append(name, encodedURI);
+      return true;
+    }
+
+    params.Append(name, value);
+    return true;
+  });
+
+  nsAutoString newQuery;
+  params.Serialize(newQuery, false);
+
+  return NS_MutateURI(aURI)
+      .SetQuery(NS_ConvertUTF16toUTF8(newQuery))
+      .Finalize(strippedURI);
+}
+
 }  // namespace mozilla