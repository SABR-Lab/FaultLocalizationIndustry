# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/nsICanvasRenderingContextInternal.cpp
# Commit: 40fa8e4b06c8
# Full Hash: 40fa8e4b06c85e9e241da6e56b62a0b2bde7427c
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2024-03-28 17:08:58
# Regressor Bug: 1887729
# File Overlap Count: 2
# Description:
#   Bug 1887729 - Implement context lost/restored support for CanvasRenderingContext2D. r=webidl,gfx-reviewers,smaug,lsalzman
#   
#   Remote canvas can run in the GPU process, and if the GPU process
#   crashes, we need to notify the application using canvas. Historically we
#   just failed, and the application may have been able to continue drawing
# ==============================================================================

diff -r 469884ac63bc -r 40fa8e4b06c8 dom/canvas/nsICanvasRenderingContextInternal.cpp
--- a/dom/canvas/nsICanvasRenderingContextInternal.cpp	Thu Mar 28 01:16:16 2024 +0000
+++ b/dom/canvas/nsICanvasRenderingContextInternal.cpp	Thu Mar 28 01:51:23 2024 +0000
@@ -7,9 +7,12 @@
 
 #include "mozilla/dom/CanvasUtils.h"
 #include "mozilla/dom/Document.h"
+#include "mozilla/dom/Event.h"
 #include "mozilla/dom/WorkerCommon.h"
 #include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/ErrorResult.h"
 #include "mozilla/PresShell.h"
+#include "nsContentUtils.h"
 #include "nsPIDOMWindow.h"
 #include "nsRefreshDriver.h"
 
@@ -116,3 +119,24 @@
   // Last resort, just check the global preference
   return nsContentUtils::ShouldResistFingerprinting("Fallback", aTarget);
 }
+
+bool nsICanvasRenderingContextInternal::DispatchEvent(
+    const nsAString& eventName, mozilla::CanBubble aCanBubble,
+    mozilla::Cancelable aIsCancelable) const {
+  bool useDefaultHandler = true;
+
+  if (mCanvasElement) {
+    nsContentUtils::DispatchTrustedEvent(mCanvasElement->OwnerDoc(),
+                                         mCanvasElement, eventName, aCanBubble,
+                                         aIsCancelable, &useDefaultHandler);
+  } else if (mOffscreenCanvas) {
+    // OffscreenCanvas case
+    auto event = mozilla::MakeRefPtr<mozilla::dom::Event>(mOffscreenCanvas,
+                                                          nullptr, nullptr);
+    event->InitEvent(eventName, aCanBubble, aIsCancelable);
+    event->SetTrusted(true);
+    useDefaultHandler = mOffscreenCanvas->DispatchEvent(
+        *event, mozilla::dom::CallerType::System, mozilla::IgnoreErrors());
+  }
+  return useDefaultHandler;
+}