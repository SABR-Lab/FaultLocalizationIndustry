# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webgpu/ObjectModel.h
# Commit: dd10bf41fcea
# Full Hash: dd10bf41fcea6aa2f40d4528f4a7afc22b1f389e
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2024-04-05 21:43:02
# Regressor Bug: 1881518
# File Overlap Count: 1
# Description:
#   Bug 1881518 - Recycle indices again. r=webgpu-reviewers,bradwerth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202433
# ==============================================================================

diff -r b2cba928a7bb -r dd10bf41fcea dom/webgpu/ObjectModel.h
--- a/dom/webgpu/ObjectModel.h	Fri Apr 05 07:28:07 2024 +0000
+++ b/dom/webgpu/ObjectModel.h	Fri Apr 05 07:42:05 2024 +0000
@@ -26,28 +26,38 @@
   nsIGlobalObject* GetParentObject() const;
 };
 
+/// Most WebGPU DOM objects inherit from this class.
+///
+/// mValid should only be used in the destruction steps in Cleanup() to check
+/// whether they have already run. This is because the destruction steps can be
+/// triggered by either the object's destructor or the cycle collector
+/// attempting to break a cycle. As a result, all methods accessible from JS can
+/// assume that mValid is true.
+///
+/// Similarly, pointers to the device and the IPDL actor (bridge) can be assumed
+/// to be non-null whenever the object is accessible from JS but not during
+/// cleanup as they might have been snatched by cycle collection.
+///
+/// The general pattern is that all objects should implement Cleanup more or
+/// less the same way. Cleanup should be the only function sending the
+/// corresponding Drop message and cleanup should *never* be called by anything
+/// other than the object destructor or the cycle collector.
+///
+/// These rules guarantee that:
+/// - The Drop message is called only once and that no other IPC message
+/// referring
+///   to the same object is send after Drop.
+/// - Any method outside of the destruction sequence can assume the pointers are
+///   non-null. They only have to check that the IPDL actor can send messages
+///   using `WebGPUChild::CanSend()`.
 class ObjectBase : public nsWrapperCache {
  protected:
   virtual ~ObjectBase() = default;
 
-  // False if this object is definitely invalid.
-  //
-  // See WebGPU ยง3.2, "Invalid Internal Objects & Contagious Invalidity".
-  //
-  // There could also be state in the GPU process indicating that our
-  // counterpart object there is invalid; certain GPU process operations will
-  // report an error back to use if we try to use it. But if it's useful to know
-  // whether the object is "definitely invalid", this should suffice.
+  /// False during the destruction sequence of the object.
   bool mValid = true;
 
  public:
-  // Return true if this WebGPU object may be valid.
-  //
-  // This is used by methods that want to know whether somebody other than
-  // `this` is valid. Generally, WebGPU object methods check `this->mValid`
-  // directly.
-  bool IsValid() const { return mValid; }
-
   void GetLabel(nsAString& aValue) const;
   void SetLabel(const nsAString& aLabel);
 