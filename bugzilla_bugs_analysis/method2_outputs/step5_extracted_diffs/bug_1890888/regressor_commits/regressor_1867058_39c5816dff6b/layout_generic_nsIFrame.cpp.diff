# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsIFrame.cpp
# Commit: 39c5816dff6b
# Full Hash: 39c5816dff6b63055f41ca7daa5dcc9805fee475
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-03-23 09:29:17
# Regressor Bug: 1867058
# File Overlap Count: 1
# Description:
#   Bug 1867058 - Part 8: Update Selection to support across shadow dom selection r=smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D195310
# ==============================================================================

diff -r 42e226158dc9 -r 39c5816dff6b layout/generic/nsIFrame.cpp
--- a/layout/generic/nsIFrame.cpp	Fri Mar 22 17:05:50 2024 +0000
+++ b/layout/generic/nsIFrame.cpp	Fri Mar 22 17:05:51 2024 +0000
@@ -8562,6 +8562,12 @@
 bool nsIFrame::IsFrameSelected() const {
   NS_ASSERTION(!GetContent() || GetContent()->IsMaybeSelected(),
                "use the public IsSelected() instead");
+  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+    if (const ShadowRoot* shadowRoot =
+            GetContent()->GetShadowRootForSelection()) {
+      return shadowRoot->IsSelected(0, shadowRoot->GetChildCount());
+    }
+  }
   return GetContent()->IsSelected(0, GetContent()->GetChildCount());
 }
 
@@ -8985,6 +8991,13 @@
 
   if (reachedLimit) {  // no "stop frame" found
     aPos->mResultContent = frame->GetContent();
+    if (ShadowRoot* shadowRoot =
+            aPos->mResultContent->GetShadowRootForSelection()) {
+      // Even if there's no children for this node,
+      // the elements inside the shadow root is still
+      // selectable
+      aPos->mResultContent = shadowRoot;
+    }
     if (aPos->mDirection == eDirPrevious) {
       aPos->mContentOffset = 0;
     } else if (aPos->mResultContent) {
