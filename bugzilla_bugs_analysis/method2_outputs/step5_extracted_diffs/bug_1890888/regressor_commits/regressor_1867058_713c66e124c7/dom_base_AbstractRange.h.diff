# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/AbstractRange.h
# Commit: 713c66e124c7
# Full Hash: 713c66e124c74d0d9c1dda6821bd2984d6cb4040
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-03-26 04:11:24
# Regressor Bug: 1867058
# File Overlap Count: 1
# Description:
#   Bug 1867058 - Part 2: Make both StaticRange and nsRange to have a way to cross the trees r=jjaschke,smaug,dom-core
#   
#   For StaticRange, simply allows node to cross the trees.
#   
#   For nsRange, when nodes are in different trees, in addition
# ==============================================================================

diff -r 0b237fd5577a -r 713c66e124c7 dom/base/AbstractRange.h
--- a/dom/base/AbstractRange.h	Mon Mar 25 13:40:56 2024 +0000
+++ b/dom/base/AbstractRange.h	Mon Mar 25 13:40:56 2024 +0000
@@ -51,13 +51,26 @@
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS(AbstractRange)
 
+  /**
+   * All of the MayCrossShadowBoundary* methods are used to get the boundary
+   * endpoints that cross shadow boundaries. They would return
+   * the same value as the non-MayCrossShadowBoundary* methods if the range
+   * boundaries don't cross shadow boundaries.
+   */
   const RangeBoundary& StartRef() const { return mStart; }
+  const RangeBoundary& MayCrossShadowBoundaryStartRef() const;
+
   const RangeBoundary& EndRef() const { return mEnd; }
+  const RangeBoundary& MayCrossShadowBoundaryEndRef() const;
 
   nsIContent* GetChildAtStartOffset() const {
     return mStart.GetChildAtOffset();
   }
+  nsIContent* GetMayCrossShadowBoundaryChildAtStartOffset() const;
+
   nsIContent* GetChildAtEndOffset() const { return mEnd.GetChildAtOffset(); }
+  nsIContent* GetMayCrossShadowBoundaryChildAtEndOffset() const;
+
   bool IsPositioned() const { return mIsPositioned; }
   /**
    * https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor
@@ -75,7 +88,10 @@
   // `IsPositioned()` directly.
 
   nsINode* GetStartContainer() const { return mStart.Container(); }
+  nsINode* GetMayCrossShadowBoundaryStartContainer() const;
+
   nsINode* GetEndContainer() const { return mEnd.Container(); }
+  nsINode* GetMayCrossShadowBoundaryEndContainer() const;
 
   Document* GetComposedDocOfContainers() const {
     return mStart.Container() ? mStart.Container()->GetComposedDoc() : nullptr;
@@ -86,12 +102,15 @@
     return static_cast<uint32_t>(
         *mStart.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets));
   }
+  uint32_t MayCrossShadowBoundaryStartOffset() const;
 
   // FYI: Returns 0 if it's not positioned.
   uint32_t EndOffset() const {
     return static_cast<uint32_t>(
         *mEnd.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets));
   }
+  uint32_t MayCrossShadowBoundaryEndOffset() const;
+
   bool Collapsed() const {
     return !mIsPositioned || (mStart.Container() == mEnd.Container() &&
                               StartOffset() == EndOffset());