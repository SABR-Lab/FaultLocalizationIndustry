# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerRunnable.cpp
# Commit: 7802e5f1bd13
# Full Hash: 7802e5f1bd1395f19f2d78636787c41f64192bd7
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2024-04-19 15:22:44
# Regressor Bug: 1769913
# File Overlap Count: 3
# Description:
#   Bug 1769913 - P3 Remove WorkerRunnable::mWorkerPrivate. r=dom-worker-reviewers,asuth
#   
#   WorkerRunnable no longer keeps a raw pointer(mWorkerPrivate) for the associated WorkerPrivate in this patch.
#   Removing the WorkerRunnable::mWorkerPrivate needs to fix the following problems.
#   
# ==============================================================================

diff -r ffc69aa8f2c3 -r 7802e5f1bd13 dom/workers/WorkerRunnable.cpp
--- a/dom/workers/WorkerRunnable.cpp	Fri Apr 19 09:41:57 2024 +0000
+++ b/dom/workers/WorkerRunnable.cpp	Fri Apr 19 09:41:58 2024 +0000
@@ -54,15 +54,16 @@
 }  // namespace
 
 #ifdef DEBUG
-WorkerRunnable::WorkerRunnable(WorkerPrivate* aWorkerPrivate, const char* aName)
-    : mWorkerPrivate(aWorkerPrivate),
+WorkerRunnable::WorkerRunnable(const char* aName)
 #  ifdef MOZ_COLLECTING_RUNNABLE_TELEMETRY
-      mName(aName),
+    : mName(aName) {
+  LOG(("WorkerRunnable::WorkerRunnable [%p] (%s)", this, mName));
+}
+#  else
+{
+  LOG(("WorkerRunnable::WorkerRunnable [%p]", this));
+}
 #  endif
-      mCallingCancelWithinRun(false) {
-  LOG(("WorkerRunnable::WorkerRunnable [%p]", this));
-  MOZ_ASSERT(mWorkerPrivate);
-}
 #endif
 
 // static
@@ -80,12 +81,15 @@
   return runnable;
 }
 
-bool WorkerRunnable::Dispatch() {
-  bool ok = PreDispatch(mWorkerPrivate);
+bool WorkerRunnable::Dispatch(WorkerPrivate* aWorkerPrivate) {
+  LOG(("WorkerRunnable::Dispatch [%p] aWorkerPrivate: %p", this,
+       aWorkerPrivate));
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  bool ok = PreDispatch(aWorkerPrivate);
   if (ok) {
-    ok = DispatchInternal();
+    ok = DispatchInternal(aWorkerPrivate);
   }
-  PostDispatch(mWorkerPrivate, ok);
+  PostDispatch(aWorkerPrivate, ok);
   return ok;
 }
 
@@ -119,13 +123,13 @@
   } else
 NS_INTERFACE_MAP_END
 
-WorkerParentThreadRunnable::WorkerParentThreadRunnable(
-    WorkerPrivate* aWorkerPrivate, const char* aName)
-    : WorkerRunnable(aWorkerPrivate, aName) {
+WorkerParentThreadRunnable::WorkerParentThreadRunnable(const char* aName)
+    : WorkerRunnable(aName) {
   LOG(("WorkerParentThreadRunnable::WorkerParentThreadRunnable [%p]", this));
-  MOZ_ASSERT(aWorkerPrivate);
 }
 
+WorkerParentThreadRunnable::~WorkerParentThreadRunnable() = default;
+
 bool WorkerParentThreadRunnable::PreDispatch(WorkerPrivate* aWorkerPrivate) {
 #ifdef DEBUG
   MOZ_ASSERT(aWorkerPrivate);
@@ -134,11 +138,12 @@
   return true;
 }
 
-bool WorkerParentThreadRunnable::DispatchInternal() {
+bool WorkerParentThreadRunnable::DispatchInternal(
+    WorkerPrivate* aWorkerPrivate) {
   LOG(("WorkerParentThreadRunnable::DispatchInternal [%p]", this));
+  mWorkerParentRef = aWorkerPrivate->GetWorkerParentRef();
   RefPtr<WorkerParentThreadRunnable> runnable(this);
-
-  return NS_SUCCEEDED(mWorkerPrivate->DispatchToParent(runnable.forget()));
+  return NS_SUCCEEDED(aWorkerPrivate->DispatchToParent(runnable.forget()));
 }
 
 void WorkerParentThreadRunnable::PostDispatch(WorkerPrivate* aWorkerPrivate,
@@ -157,9 +162,8 @@
                                          WorkerPrivate* aWorkerPrivate,
                                          bool aRunResult) {
   MOZ_ASSERT(aCx);
+#ifdef DEBUG
   MOZ_ASSERT(aWorkerPrivate);
-
-#ifdef DEBUG
   aWorkerPrivate->AssertIsOnParentThread();
 #endif
 }
@@ -167,25 +171,35 @@
 NS_IMETHODIMP
 WorkerParentThreadRunnable::Run() {
   LOG(("WorkerParentThreadRunnable::Run [%p]", this));
+  RefPtr<WorkerPrivate> workerPrivate;
+  MOZ_ASSERT(mWorkerParentRef);
+  workerPrivate = mWorkerParentRef->Private();
+  if (!workerPrivate) {
+    NS_WARNING("Worker has already shut down!!!");
+    return NS_OK;
+  }
 #ifdef DEBUG
-  mWorkerPrivate->AssertIsOnParentThread();
+  workerPrivate->AssertIsOnParentThread();
 #endif
 
-  bool result = PreRun(mWorkerPrivate);
+  WorkerPrivate* parent = workerPrivate->GetParent();
+  bool isOnMainThread = !parent;
+  bool result = PreRun(workerPrivate);
   MOZ_ASSERT(result);
 
+  LOG(("WorkerParentThreadRunnable::Run [%p] WorkerPrivate: %p, parent: %p",
+       this, workerPrivate.get(), parent));
+
   // Track down the appropriate global, if any, to use for the AutoEntryScript.
   nsCOMPtr<nsIGlobalObject> globalObject;
-  bool isMainThread = !mWorkerPrivate->GetParent();
-  MOZ_ASSERT(isMainThread == NS_IsMainThread());
-  RefPtr<WorkerPrivate> kungFuDeathGrip;
-  kungFuDeathGrip = mWorkerPrivate;
-  if (isMainThread) {
-    globalObject = nsGlobalWindowInner::Cast(mWorkerPrivate->GetWindow());
+  if (isOnMainThread) {
+    MOZ_ASSERT(isOnMainThread == NS_IsMainThread());
+    globalObject = nsGlobalWindowInner::Cast(workerPrivate->GetWindow());
   } else {
-    globalObject = mWorkerPrivate->GetParent()->GlobalScope();
+    MOZ_ASSERT(parent == GetCurrentThreadWorkerPrivate());
+    globalObject = parent->GlobalScope();
+    MOZ_DIAGNOSTIC_ASSERT(globalObject);
   }
-
   // We might run script as part of WorkerRun, so we need an AutoEntryScript.
   // This is part of the HTML spec for workers at:
   // http://www.whatwg.org/specs/web-apps/current-work/#run-a-worker
@@ -197,7 +211,7 @@
   AutoJSAPI* jsapi;
 
   if (globalObject) {
-    aes.emplace(globalObject, "Worker parent thread runnable", isMainThread);
+    aes.emplace(globalObject, "Worker parent thread runnable", isOnMainThread);
     jsapi = aes.ptr();
     cx = aes->cx();
   } else {
@@ -208,7 +222,7 @@
   }
 
   // Note that we can't assert anything about
-  // mWorkerPrivate->ParentEventTargetRef()->GetWrapper()
+  // workerPrivate->ParentEventTargetRef()->GetWrapper()
   // existing, since it may in fact have been GCed (and we may be one of the
   // runnables cleaning up the worker as a result).
 
@@ -218,17 +232,18 @@
   // definitely have a globalObject.  If it _is_ the main thread, globalObject
   // can be null for workers started from JSMs or other non-window contexts,
   // sadly.
-  MOZ_ASSERT_IF(!isMainThread,
-                mWorkerPrivate->IsDedicatedWorker() && globalObject);
+  MOZ_ASSERT_IF(!isOnMainThread,
+                workerPrivate->IsDedicatedWorker() && globalObject);
 
   // If we're on the parent thread we might be in a null realm in the
   // situation described above when globalObject is null.  Make sure to enter
   // the realm of the worker's reflector if there is one.  There might
   // not be one if we're just starting to compile the script for this worker.
   Maybe<JSAutoRealm> ar;
-  if (mWorkerPrivate->IsDedicatedWorker() &&
-      mWorkerPrivate->ParentEventTargetRef()->GetWrapper()) {
-    JSObject* wrapper = mWorkerPrivate->ParentEventTargetRef()->GetWrapper();
+  if (workerPrivate->IsDedicatedWorker() &&
+      workerPrivate->ParentEventTargetRef() &&
+      workerPrivate->ParentEventTargetRef()->GetWrapper()) {
+    JSObject* wrapper = workerPrivate->ParentEventTargetRef()->GetWrapper();
 
     // If we're on the parent thread and have a reflector and a globalObject,
     // then the realms of cx, globalObject, and the worker's reflector
@@ -252,12 +267,9 @@
   }
 
   MOZ_ASSERT(!jsapi->HasException());
-  result = WorkerRun(cx, mWorkerPrivate);
+  result = WorkerRun(cx, workerPrivate);
   jsapi->ReportException();
 
-  // We can't even assert that this didn't create our global, since in the case
-  // of CompileScriptRunnable it _does_.
-
   // It would be nice to avoid passing a JSContext to PostRun, but in the case
   // of ScriptExecutorRunnable we need to know the current compartment on the
   // JSContext (the one we set up based on the global returned from PreRun) so
@@ -276,57 +288,42 @@
   // this point; in the one case in which we could do that
   // (CompileScriptRunnable) it actually doesn't matter which compartment we're
   // in for PostRun.
-  PostRun(cx, mWorkerPrivate, result);
+  PostRun(cx, workerPrivate, result);
   MOZ_ASSERT(!jsapi->HasException());
 
   return result ? NS_OK : NS_ERROR_FAILURE;
 }
 
 nsresult WorkerParentThreadRunnable::Cancel() {
-  LOG(("WorkerThreadRunnable::Cancel [%p]", this));
+  LOG(("WorkerParentThreadRunnable::Cancel [%p]", this));
   return NS_OK;
 }
 
-#ifdef DEBUG
-WorkerParentControlRunnable::WorkerParentControlRunnable(
-    WorkerPrivate* aWorkerPrivate, const char* aName)
-    : WorkerParentThreadRunnable(aWorkerPrivate, aName) {
-  MOZ_ASSERT(aWorkerPrivate);
-}
-#endif
+WorkerParentControlRunnable::WorkerParentControlRunnable(const char* aName)
+    : WorkerParentThreadRunnable(aName) {}
+
+WorkerParentControlRunnable::~WorkerParentControlRunnable() = default;
 
 nsresult WorkerParentControlRunnable::Cancel() {
   LOG(("WorkerParentControlRunnable::Cancel [%p]", this));
   if (NS_FAILED(Run())) {
     NS_WARNING("WorkerParentControlRunnable::Run() failed.");
   }
-
   return NS_OK;
 }
 
-bool WorkerParentDebuggeeRunnable::PreDispatch(WorkerPrivate* aWorkerPrivate) {
-  RefPtr<StrongWorkerRef> strongRef = StrongWorkerRef::Create(
-      aWorkerPrivate, "WorkerDebuggeeRunnable::mSender");
-  if (!strongRef) {
-    return false;
-  }
-  mSender = new ThreadSafeWorkerRef(strongRef);
-
-  return WorkerParentThreadRunnable::PreDispatch(aWorkerPrivate);
+WorkerThreadRunnable::WorkerThreadRunnable(const char* aName)
+    : WorkerRunnable(aName), mCallingCancelWithinRun(false) {
+  LOG(("WorkerThreadRunnable::WorkerThreadRunnable [%p]", this));
 }
 
-WorkerThreadRunnable::WorkerThreadRunnable(WorkerPrivate* aWorkerPrivate,
-                                           const char* aName)
-    : WorkerRunnable(aWorkerPrivate, aName) {
-  LOG(("WorkerThreadRunnable::WorkerThreadRunnable [%p]", this));
-  MOZ_ASSERT(aWorkerPrivate);
-}
-
-nsIGlobalObject* WorkerThreadRunnable::DefaultGlobalObject() const {
+nsIGlobalObject* WorkerThreadRunnable::DefaultGlobalObject(
+    WorkerPrivate* aWorkerPrivate) const {
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   if (IsDebuggerRunnable()) {
-    return mWorkerPrivate->DebuggerGlobalScope();
+    return aWorkerPrivate->DebuggerGlobalScope();
   }
-  return mWorkerPrivate->GlobalScope();
+  return aWorkerPrivate->GlobalScope();
 }
 
 bool WorkerThreadRunnable::PreDispatch(WorkerPrivate* aWorkerPrivate) {
@@ -337,11 +334,10 @@
   return true;
 }
 
-bool WorkerThreadRunnable::DispatchInternal() {
+bool WorkerThreadRunnable::DispatchInternal(WorkerPrivate* aWorkerPrivate) {
   LOG(("WorkerThreadRunnable::DispatchInternal [%p]", this));
   RefPtr<WorkerThreadRunnable> runnable(this);
-
-  return NS_SUCCEEDED(mWorkerPrivate->Dispatch(runnable.forget()));
+  return NS_SUCCEEDED(aWorkerPrivate->Dispatch(runnable.forget()));
 }
 
 void WorkerThreadRunnable::PostDispatch(WorkerPrivate* aWorkerPrivate,
@@ -370,38 +366,40 @@
 NS_IMETHODIMP
 WorkerThreadRunnable::Run() {
   LOG(("WorkerThreadRunnable::Run [%p]", this));
+  MOZ_ASSERT(GetCurrentThreadWorkerPrivate());
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
 #ifdef DEBUG
-  mWorkerPrivate->AssertIsOnWorkerThread();
+  workerPrivate->AssertIsOnWorkerThread();
 #endif
 
   if (!mCallingCancelWithinRun &&
-      mWorkerPrivate->CancelBeforeWorkerScopeConstructed()) {
+      workerPrivate->CancelBeforeWorkerScopeConstructed()) {
     mCallingCancelWithinRun = true;
     Cancel();
     mCallingCancelWithinRun = false;
     return NS_OK;
   }
 
-  bool result = PreRun(mWorkerPrivate);
+  bool result = PreRun(workerPrivate);
   if (!result) {
-    mWorkerPrivate->AssertIsOnWorkerThread();
-    MOZ_ASSERT(!JS_IsExceptionPending(mWorkerPrivate->GetJSContext()));
+    workerPrivate->AssertIsOnWorkerThread();
+    MOZ_ASSERT(!JS_IsExceptionPending(workerPrivate->GetJSContext()));
     // We can't enter a useful realm on the JSContext here; just pass it
     // in as-is.
-    PostRun(mWorkerPrivate->GetJSContext(), mWorkerPrivate, false);
+    PostRun(workerPrivate->GetJSContext(), workerPrivate, false);
     return NS_ERROR_FAILURE;
   }
 
   // Track down the appropriate global, if any, to use for the AutoEntryScript.
   nsCOMPtr<nsIGlobalObject> globalObject =
-      mWorkerPrivate->GetCurrentEventLoopGlobal();
-  RefPtr<WorkerPrivate> kungFuDeathGrip;
+      workerPrivate->GetCurrentEventLoopGlobal();
   if (!globalObject) {
-    globalObject = DefaultGlobalObject();
+    globalObject = DefaultGlobalObject(workerPrivate);
     // Our worker thread may not be in a good state here if there is no
     // JSContext avaliable.  The way this manifests itself is that
     // globalObject ends up null (though it's not clear to me how we can be
-    // running runnables at all when DefaultGlobalObject() is returning
+    // running runnables at all when default globalObject(DebuggerGlobalScope
+    // for debugger runnable, and GlobalScope for normal runnables) is returning
     // false!) and then when we try to init the AutoJSAPI either
     // CycleCollectedJSContext::Get() returns null or it has a null JSContext.
     // In any case, we used to have a check for
@@ -433,13 +431,8 @@
     cx = jsapi->cx();
   }
 
-  // Note that we can't assert anything about
-  // mWorkerPrivate->ParentEventTargetRef()->GetWrapper()
-  // existing, since it may in fact have been GCed (and we may be one of the
-  // runnables cleaning up the worker as a result).
-
   MOZ_ASSERT(!jsapi->HasException());
-  result = WorkerRun(cx, mWorkerPrivate);
+  result = WorkerRun(cx, workerPrivate);
   jsapi->ReportException();
 
   // We can't even assert that this didn't create our global, since in the case
@@ -463,7 +456,7 @@
   // this point; in the one case in which we could do that
   // (CompileScriptRunnable) it actually doesn't matter which compartment we're
   // in for PostRun.
-  PostRun(cx, mWorkerPrivate, result);
+  PostRun(cx, workerPrivate, result);
   MOZ_ASSERT(!jsapi->HasException());
 
   return result ? NS_OK : NS_ERROR_FAILURE;
@@ -477,57 +470,40 @@
 void WorkerDebuggerRunnable::PostDispatch(WorkerPrivate* aWorkerPrivate,
                                           bool aDispatchResult) {}
 
-WorkerSyncRunnable::WorkerSyncRunnable(WorkerPrivate* aWorkerPrivate,
-                                       nsIEventTarget* aSyncLoopTarget,
+WorkerSyncRunnable::WorkerSyncRunnable(nsIEventTarget* aSyncLoopTarget,
                                        const char* aName)
-    : WorkerThreadRunnable(aWorkerPrivate, aName),
-      mSyncLoopTarget(aSyncLoopTarget) {
-#ifdef DEBUG
-  if (mSyncLoopTarget) {
-    mWorkerPrivate->AssertValidSyncLoop(mSyncLoopTarget);
-  }
-#endif
-}
+    : WorkerThreadRunnable(aName), mSyncLoopTarget(aSyncLoopTarget) {}
 
 WorkerSyncRunnable::WorkerSyncRunnable(
-    WorkerPrivate* aWorkerPrivate, nsCOMPtr<nsIEventTarget>&& aSyncLoopTarget,
-    const char* aName)
-    : WorkerThreadRunnable(aWorkerPrivate, aName),
-      mSyncLoopTarget(std::move(aSyncLoopTarget)) {
-#ifdef DEBUG
-  if (mSyncLoopTarget) {
-    mWorkerPrivate->AssertValidSyncLoop(mSyncLoopTarget);
-  }
-#endif
-}
+    nsCOMPtr<nsIEventTarget>&& aSyncLoopTarget, const char* aName)
+    : WorkerThreadRunnable(aName),
+      mSyncLoopTarget(std::move(aSyncLoopTarget)) {}
 
 WorkerSyncRunnable::~WorkerSyncRunnable() = default;
 
-bool WorkerSyncRunnable::DispatchInternal() {
+bool WorkerSyncRunnable::DispatchInternal(WorkerPrivate* aWorkerPrivate) {
   if (mSyncLoopTarget) {
+#ifdef DEBUG
+    aWorkerPrivate->AssertValidSyncLoop(mSyncLoopTarget);
+#endif
     RefPtr<WorkerSyncRunnable> runnable(this);
     return NS_SUCCEEDED(
         mSyncLoopTarget->Dispatch(runnable.forget(), NS_DISPATCH_NORMAL));
   }
 
-  return WorkerThreadRunnable::DispatchInternal();
+  return WorkerThreadRunnable::DispatchInternal(aWorkerPrivate);
 }
 
 void MainThreadWorkerSyncRunnable::PostDispatch(WorkerPrivate* aWorkerPrivate,
                                                 bool aDispatchResult) {}
 
 MainThreadStopSyncLoopRunnable::MainThreadStopSyncLoopRunnable(
-    WorkerPrivate* aWorkerPrivate, nsCOMPtr<nsIEventTarget>&& aSyncLoopTarget,
-    nsresult aResult)
-    : WorkerSyncRunnable(aWorkerPrivate, std::move(aSyncLoopTarget)),
-      mResult(aResult) {
+    nsCOMPtr<nsIEventTarget>&& aSyncLoopTarget, nsresult aResult)
+    : WorkerSyncRunnable(std::move(aSyncLoopTarget)), mResult(aResult) {
   LOG(("MainThreadStopSyncLoopRunnable::MainThreadStopSyncLoopRunnable [%p]",
        this));
 
   AssertIsOnMainThread();
-#ifdef DEBUG
-  mWorkerPrivate->AssertValidSyncLoop(mSyncLoopTarget);
-#endif
 }
 
 nsresult MainThreadStopSyncLoopRunnable::Cancel() {
@@ -550,9 +526,12 @@
   return true;
 }
 
-bool MainThreadStopSyncLoopRunnable::DispatchInternal() {
+bool MainThreadStopSyncLoopRunnable::DispatchInternal(
+    WorkerPrivate* aWorkerPrivate) {
   MOZ_ASSERT(mSyncLoopTarget);
-
+#ifdef DEBUG
+  aWorkerPrivate->AssertValidSyncLoop(mSyncLoopTarget);
+#endif
   RefPtr<MainThreadStopSyncLoopRunnable> runnable(this);
   return NS_SUCCEEDED(
       mSyncLoopTarget->Dispatch(runnable.forget(), NS_DISPATCH_NORMAL));
@@ -561,13 +540,8 @@
 void MainThreadStopSyncLoopRunnable::PostDispatch(WorkerPrivate* aWorkerPrivate,
                                                   bool aDispatchResult) {}
 
-#ifdef DEBUG
-WorkerControlRunnable::WorkerControlRunnable(WorkerPrivate* aWorkerPrivate,
-                                             const char* aName)
-    : WorkerThreadRunnable(aWorkerPrivate, aName) {
-  MOZ_ASSERT(aWorkerPrivate);
-}
-#endif
+WorkerControlRunnable::WorkerControlRunnable(const char* aName)
+    : WorkerThreadRunnable(aName) {}
 
 nsresult WorkerControlRunnable::Cancel() {
   LOG(("WorkerControlRunnable::Cancel [%p]", this));
@@ -635,11 +609,10 @@
   bool runResult = MainThreadRun();
 
   RefPtr<MainThreadStopSyncLoopRunnable> response =
-      new MainThreadStopSyncLoopRunnable(mWorkerPrivate,
-                                         std::move(mSyncLoopTarget),
+      new MainThreadStopSyncLoopRunnable(std::move(mSyncLoopTarget),
                                          runResult ? NS_OK : NS_ERROR_FAILURE);
 
-  MOZ_ALWAYS_TRUE(response->Dispatch());
+  MOZ_ALWAYS_TRUE(response->Dispatch(mWorkerPrivate));
 
   return NS_OK;
 }
@@ -698,15 +671,15 @@
     RefPtr<WorkerProxyToMainThreadRunnable> mRunnable;
 
    public:
-    ReleaseRunnable(WorkerPrivate* aWorkerPrivate,
-                    WorkerProxyToMainThreadRunnable* aRunnable)
-        : MainThreadWorkerControlRunnable(aWorkerPrivate),
+    explicit ReleaseRunnable(WorkerProxyToMainThreadRunnable* aRunnable)
+        : MainThreadWorkerControlRunnable("ReleaseRunnable"),
           mRunnable(aRunnable) {
       MOZ_ASSERT(aRunnable);
     }
 
     virtual nsresult Cancel() override {
-      Unused << WorkerRun(nullptr, mWorkerPrivate);
+      MOZ_ASSERT(GetCurrentThreadWorkerPrivate());
+      Unused << WorkerRun(nullptr, GetCurrentThreadWorkerPrivate());
       return NS_OK;
     }
 
@@ -730,9 +703,8 @@
     ~ReleaseRunnable() = default;
   };
 
-  RefPtr<WorkerControlRunnable> runnable =
-      new ReleaseRunnable(mWorkerRef->Private(), this);
-  Unused << NS_WARN_IF(!runnable->Dispatch());
+  RefPtr<WorkerControlRunnable> runnable = new ReleaseRunnable(this);
+  Unused << NS_WARN_IF(!runnable->Dispatch(mWorkerRef->Private()));
 }
 
 void WorkerProxyToMainThreadRunnable::ReleaseWorker() { mWorkerRef = nullptr; }