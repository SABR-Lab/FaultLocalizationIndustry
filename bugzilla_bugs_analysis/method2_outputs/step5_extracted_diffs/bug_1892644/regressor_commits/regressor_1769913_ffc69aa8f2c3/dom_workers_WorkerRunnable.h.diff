# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerRunnable.h
# Commit: ffc69aa8f2c3
# Full Hash: ffc69aa8f2c3bcdc3cc4f2516a618c0430e67ddf
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2024-04-19 15:22:44
# Regressor Bug: 1769913
# File Overlap Count: 3
# Description:
#   Bug 1769913 - P2 WorkerParentThreadRunnable for the runnables dispatched to worker's parent thread. r=dom-worker-reviewers,asuth
#   
#   In this patch, WorkerParentThreadRunnable is extracted from WorkerThreadRunnable for runnable on the parent thread.
#   
#   WorkerParentControlRunnable and WorkerParentDebuggeeRunnable are also created for control runnable and debuggee runnable on the parent thread.
# ==============================================================================

diff -r 379cd5044768 -r ffc69aa8f2c3 dom/workers/WorkerRunnable.h
--- a/dom/workers/WorkerRunnable.h	Fri Apr 19 09:41:57 2024 +0000
+++ b/dom/workers/WorkerRunnable.h	Fri Apr 19 09:41:57 2024 +0000
@@ -39,19 +39,9 @@
                        public nsINamed
 #endif
 {
- public:
-  enum Target {
-    // Target the main thread for top-level workers, otherwise target the
-    // WorkerThread of the worker's parent.
-    ParentThread,
-
-    // Target the thread where the worker event loop runs.
-    WorkerThread,
-  };
-
  protected:
-  // See above.
-  Target mTarget;
+  // The WorkerPrivate that this runnable is associated with.
+  WorkerPrivate* mWorkerPrivate;
 
 #ifdef MOZ_COLLECTING_RUNNABLE_TELEMETRY
   const char* mName = nullptr;
@@ -72,7 +62,7 @@
 
   // The return value is true if and only if both PreDispatch and
   // DispatchInternal return true.
-  virtual bool Dispatch() = 0;
+  virtual bool Dispatch();
 
   // True if this runnable is handled by running JavaScript in some global that
   // could possibly be a debuggee, and thus needs to be deferred when the target
@@ -85,11 +75,27 @@
   // support debugging the debugger server at the moment.
   virtual bool IsDebuggeeRunnable() const { return false; }
 
+  // True if this runnable needs to be dispatched to
+  // WorkerPrivate::mControlEventTareget.
+  virtual bool IsControlRunnable() const { return false; }
+
+  // True if this runnable should be dispatched to the debugger queue,
+  // and false otherwise.
+  virtual bool IsDebuggerRunnable() const { return false; }
+
   static WorkerRunnable* FromRunnable(nsIRunnable* aRunnable);
 
  protected:
-  WorkerRunnable(const char* aName = "WorkerRunnable",
-                 Target aTarget = WorkerThread);
+  WorkerRunnable(WorkerPrivate* aWorkerPrivate,
+                 const char* aName = "WorkerRunnable")
+#ifdef DEBUG
+      ;
+#else
+      : mWorkerPrivate(aWorkerPrivate),
+        mName(aName),
+        mCallingCancelWithinRun(false) {
+  }
+#endif
 
   // This class is reference counted.
   virtual ~WorkerRunnable() = default;
@@ -97,42 +103,15 @@
   // Calling Run() directly is not supported. Just call Dispatch() and
   // WorkerRun() will be called on the correct thread automatically.
   NS_DECL_NSIRUNNABLE
-};
 
-class WorkerThreadRunnable : public WorkerRunnable {
- protected:
-  // The WorkerPrivate that this runnable is associated with.
-  WorkerPrivate* mWorkerPrivate;
-
- public:
-  virtual nsresult Cancel() override;
-
-  // The return value is true if and only if both PreDispatch and
-  // DispatchInternal return true.
-  bool Dispatch() override;
-
- protected:
-  explicit WorkerThreadRunnable(WorkerPrivate* aWorkerPrivate,
-                                const char* aName = "WorkerThreadRunnable",
-                                Target aTarget = WorkerRunnable::WorkerThread);
-
-  // This class is reference counted.
-  virtual ~WorkerThreadRunnable() = default;
-
-  // Returns true if this runnable should be dispatched to the debugger queue,
-  // and false otherwise.
-  virtual bool IsDebuggerRunnable() const;
-
-  nsIGlobalObject* DefaultGlobalObject() const;
+  // By default asserts that Dispatch() is being called on the right thread
+  virtual bool PreDispatch(WorkerPrivate* aWorkerPrivate) = 0;
 
   // By default asserts that Dispatch() is being called on the right thread
-  // (ParentThread if |mTarget| is WorkerThread).
-  virtual bool PreDispatch(WorkerPrivate* aWorkerPrivate);
+  virtual void PostDispatch(WorkerPrivate* aWorkerPrivate,
+                            bool aDispatchResult) = 0;
 
-  // By default asserts that Dispatch() is being called on the right thread
-  // (ParentThread if |mTarget| is WorkerThread).
-  virtual void PostDispatch(WorkerPrivate* aWorkerPrivate,
-                            bool aDispatchResult);
+  virtual bool DispatchInternal() = 0;
 
   // May be implemented by subclasses if desired if they need to do some sort of
   // setup before we try to set up our JSContext and compartment for real.
@@ -141,17 +120,19 @@
   //
   // If false is returned, WorkerRun will not be called at all.  PostRun will
   // still be called, with false passed for aRunResult.
-  virtual bool PreRun(WorkerPrivate* aWorkerPrivate);
+  virtual bool PreRun(WorkerPrivate* aWorkerPrivate) = 0;
 
   // Must be implemented by subclasses. Called on the target thread.  The return
   // value will be passed to PostRun().  The JSContext passed in here comes from
-  // an AutoJSAPI (or AutoEntryScript) that we set up on the stack.  If
-  // mTarget is ParentThread, it is in the compartment of
+  // an AutoJSAPI (or AutoEntryScript) that we set up on the stack.
+  //
+  // If the runnable is for parent thread, aCx is in the compartment of
   // mWorkerPrivate's reflector (i.e. the worker object in the parent thread),
   // unless that reflector is null, in which case it's in the compartment of the
   // parent global (which is the compartment reflector would have been in), or
-  // in the null compartment if there is no parent global.  For other mTarget
-  // values, we're running on the worker thread and aCx is in whatever
+  // in the null compartment if there is no parent global.
+  //
+  // For runnables on the worker thread, aCx is in whatever
   // compartment GetCurrentWorkerThreadJSContext() was in when
   // nsIRunnable::Run() got called.  This is actually important for cases when a
   // runnable spins a syncloop and wants everything that happens during the
@@ -174,9 +155,125 @@
   // exception on the JSContext and must not run script, because the incoming
   // JSContext may be in the null compartment.
   virtual void PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
-                       bool aRunResult);
+                       bool aRunResult) = 0;
+};
+
+class WorkerParentThreadRunnable : public WorkerRunnable {
+ public:
+  NS_INLINE_DECL_REFCOUNTING_INHERITED(WorkerParentThreadRunnable,
+                                       WorkerRunnable)
+
+  virtual nsresult Cancel() override;
+
+ protected:
+  explicit WorkerParentThreadRunnable(
+      WorkerPrivate* aWorkerPrivate,
+      const char* aName = "WorkerParentThreadRunnable");
+
+  // This class is reference counted.
+  virtual ~WorkerParentThreadRunnable() = default;
+
+  virtual bool PreDispatch(WorkerPrivate* aWorkerPrivate) override;
+
+  virtual void PostDispatch(WorkerPrivate* aWorkerPrivate,
+                            bool aDispatchResult) override;
+
+  virtual bool PreRun(WorkerPrivate* aWorkerPrivate) override;
+
+  virtual bool WorkerRun(JSContext* aCx,
+                         WorkerPrivate* aWorkerPrivate) override = 0;
+
+  virtual void PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
+                       bool aRunResult) override;
+
+  virtual bool DispatchInternal() override;
+
+  // Calling Run() directly is not supported. Just call Dispatch() and
+  // WorkerRun() will be called on the correct thread automatically.
+  NS_DECL_NSIRUNNABLE
+};
+
+class WorkerParentControlRunnable : public WorkerParentThreadRunnable {
+  friend class WorkerPrivate;
+
+ protected:
+  explicit WorkerParentControlRunnable(
+      WorkerPrivate* aWorkerPrivate,
+      const char* aName = "WorkerParentControlRunnable")
+#ifdef DEBUG
+      ;
+#else
+      : WorkerParentThreadRunnable(aWorkerPrivate, aName) {
+  }
+#endif
+
+  virtual ~WorkerParentControlRunnable() = default;
+
+  nsresult Cancel() override;
+
+ public:
+  NS_INLINE_DECL_REFCOUNTING_INHERITED(WorkerParentControlRunnable,
+                                       WorkerParentThreadRunnable)
 
-  virtual bool DispatchInternal();
+ private:
+  bool IsControlRunnable() const override { return true; }
+
+  // Should only be called by WorkerPrivate::DoRunLoop.
+  using WorkerParentThreadRunnable::Cancel;
+};
+
+class WorkerParentDebuggeeRunnable : public WorkerParentThreadRunnable {
+ protected:
+  explicit WorkerParentDebuggeeRunnable(
+      WorkerPrivate* aWorkerPrivate,
+      const char* aName = "WorkerParentDebuggeeRunnable")
+      : WorkerParentThreadRunnable(aWorkerPrivate, aName) {}
+
+  bool PreDispatch(WorkerPrivate* aWorkerPrivate) override;
+
+ private:
+  // This override is deliberately private: it doesn't make sense to call it if
+  // we know statically that we are a WorkerDebuggeeRunnable.
+  bool IsDebuggeeRunnable() const override { return true; }
+
+  // Runnables sent upwards, to the content window or parent worker, must keep
+  // their sender alive until they are delivered: they check back with the
+  // sender in case it has been terminated after having dispatched the runnable
+  // (in which case it should not be acted upon); and runnables sent to content
+  // wait until delivery to determine the target window, since
+  // WorkerPrivate::GetWindow may only be used on the main thread.
+  RefPtr<ThreadSafeWorkerRef> mSender;
+};
+
+class WorkerThreadRunnable : public WorkerRunnable {
+ public:
+  NS_INLINE_DECL_REFCOUNTING_INHERITED(WorkerThreadRunnable, WorkerRunnable)
+
+  virtual nsresult Cancel() override;
+
+ protected:
+  explicit WorkerThreadRunnable(WorkerPrivate* aWorkerPrivate,
+                                const char* aName = "WorkerThreadRunnable");
+
+  // This class is reference counted.
+  virtual ~WorkerThreadRunnable() = default;
+
+  nsIGlobalObject* DefaultGlobalObject() const;
+
+  virtual bool PreDispatch(WorkerPrivate* aWorkerPrivate) override;
+
+  virtual void PostDispatch(WorkerPrivate* aWorkerPrivate,
+                            bool aDispatchResult) override;
+
+  virtual bool PreRun(WorkerPrivate* aWorkerPrivate) override;
+
+  virtual bool WorkerRun(JSContext* aCx,
+                         WorkerPrivate* aWorkerPrivate) override = 0;
+
+  virtual void PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
+                       bool aRunResult) override;
+
+  virtual bool DispatchInternal() override;
 
   // Calling Run() directly is not supported. Just call Dispatch() and
   // WorkerRun() will be called on the correct thread automatically.
@@ -188,8 +285,7 @@
  protected:
   explicit WorkerDebuggerRunnable(WorkerPrivate* aWorkerPrivate,
                                   const char* aName = "WorkerDebuggerRunnable")
-      : WorkerThreadRunnable(aWorkerPrivate, aName,
-                             WorkerRunnable::WorkerThread) {}
+      : WorkerThreadRunnable(aWorkerPrivate, aName) {}
 
   virtual ~WorkerDebuggerRunnable() = default;
 
@@ -268,12 +364,11 @@
 
  protected:
   explicit WorkerControlRunnable(WorkerPrivate* aWorkerPrivate,
-                                 const char* aName = "WorkerControlRunnable",
-                                 Target aTarget = WorkerRunnable::WorkerThread)
+                                 const char* aName = "WorkerControlRunnable")
 #ifdef DEBUG
       ;
 #else
-      : WorkerThreadRunnable(aWorkerPrivate, aName, aTarget) {
+      : WorkerThreadRunnable(aWorkerPrivate, aName) {
   }
 #endif
 
@@ -286,7 +381,7 @@
                                        WorkerThreadRunnable)
 
  private:
-  virtual bool DispatchInternal() override;
+  bool IsControlRunnable() const override { return true; }
 
   // Should only be called by WorkerPrivate::DoRunLoop.
   using WorkerThreadRunnable::Cancel;
@@ -299,8 +394,7 @@
   explicit MainThreadWorkerRunnable(
       WorkerPrivate* aWorkerPrivate,
       const char* aName = "MainThreadWorkerRunnable")
-      : WorkerThreadRunnable(aWorkerPrivate, aName,
-                             WorkerRunnable::WorkerThread) {
+      : WorkerThreadRunnable(aWorkerPrivate, aName) {
     AssertIsOnMainThread();
   }
 
@@ -324,8 +418,7 @@
   explicit MainThreadWorkerControlRunnable(
       WorkerPrivate* aWorkerPrivate,
       const char* aName = "MainThreadWorkerControlRunnable")
-      : WorkerControlRunnable(aWorkerPrivate, aName,
-                              WorkerRunnable::WorkerThread) {}
+      : WorkerControlRunnable(aWorkerPrivate, aName) {}
 
   virtual ~MainThreadWorkerControlRunnable() = default;
 
@@ -350,8 +443,7 @@
   explicit WorkerSameThreadRunnable(
       WorkerPrivate* aWorkerPrivate,
       const char* aName = "WorkerSameThreadRunnable")
-      : WorkerThreadRunnable(aWorkerPrivate, aName,
-                             WorkerRunnable::WorkerThread) {}
+      : WorkerThreadRunnable(aWorkerPrivate, aName) {}
 
   virtual ~WorkerSameThreadRunnable() = default;
 
@@ -486,28 +578,13 @@
 class WorkerDebuggeeRunnable : public WorkerThreadRunnable {
  protected:
   explicit WorkerDebuggeeRunnable(WorkerPrivate* aWorkerPrivate,
-                                  const char* aName = "WorkerDebuggeeRunnable",
-                                  Target aTarget = WorkerRunnable::ParentThread)
-      : WorkerThreadRunnable(aWorkerPrivate, aName, aTarget) {}
-
-  bool PreDispatch(WorkerPrivate* aWorkerPrivate) override;
+                                  const char* aName = "WorkerDebuggeeRunnable")
+      : WorkerThreadRunnable(aWorkerPrivate, aName) {}
 
  private:
   // This override is deliberately private: it doesn't make sense to call it if
   // we know statically that we are a WorkerDebuggeeRunnable.
   bool IsDebuggeeRunnable() const override { return true; }
-
-  // Runnables sent upwards, to the content window or parent worker, must keep
-  // their sender alive until they are delivered: they check back with the
-  // sender in case it has been terminated after having dispatched the runnable
-  // (in which case it should not be acted upon); and runnables sent to content
-  // wait until delivery to determine the target window, since
-  // WorkerPrivate::GetWindow may only be used on the main thread.
-  //
-  // Runnables sent downwards, from content to a worker or from a worker to a
-  // child, keep the sender alive because they are WorkerThread
-  // runnables, and so leave this null.
-  RefPtr<ThreadSafeWorkerRef> mSender;
 };
 
 }  // namespace dom