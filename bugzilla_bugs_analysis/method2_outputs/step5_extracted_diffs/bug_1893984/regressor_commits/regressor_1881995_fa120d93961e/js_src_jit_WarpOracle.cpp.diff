# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit/WarpOracle.cpp
# Commit: fa120d93961e
# Full Hash: fa120d93961efddd63d50135f03c55e75dac875a
# Author: Doug Thayer <dothayer@mozilla.com>
# Date: 2024-04-26 04:18:06
# Regressor Bug: 1881995
# File Overlap Count: 1
# Description:
#   Bug 1881995 - Implement ForwardedAtoms and create them during atomization r=iain,sfink
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D202690
# ==============================================================================

diff -r f24ffc487097 -r fa120d93961e js/src/jit/WarpOracle.cpp
--- a/js/src/jit/WarpOracle.cpp	Thu Apr 25 21:30:10 2024 +0300
+++ b/js/src/jit/WarpOracle.cpp	Thu Apr 25 18:29:15 2024 +0000
@@ -510,6 +510,11 @@
         break;
       }
 
+      case JSOp::String:
+        if (!loc.atomizeString(cx_, script_)) {
+          return abort(AbortReason::Alloc);
+        }
+        break;
       case JSOp::GetName:
       case JSOp::GetGName:
       case JSOp::GetProp:
@@ -613,7 +618,6 @@
       case JSOp::Int32:
       case JSOp::Double:
       case JSOp::BigInt:
-      case JSOp::String:
       case JSOp::Symbol:
       case JSOp::Pop:
       case JSOp::PopN:
@@ -1209,6 +1213,10 @@
   // If the stub data contains weak pointers then trigger a read barrier. This
   // is necessary as these will now be strong references in the snapshot.
   //
+  // If the stub data contains strings then atomize them. This ensures we don't
+  // try to access potentially unstable characters from a background thread and
+  // also facilitates certain optimizations.
+  //
   // Also asserts non-object fields don't contain nursery pointers.
 
   uint32_t field = 0;
@@ -1270,11 +1278,17 @@
         break;
       }
       case StubField::Type::String: {
-#ifdef DEBUG
-        JSString* str =
-            stubInfo->getStubField<StubField::Type::String>(stub, offset);
+        uintptr_t oldWord = stubInfo->getStubRawWord(stub, offset);
+        JSString* str = reinterpret_cast<JSString*>(oldWord);
         MOZ_ASSERT(!IsInsideNursery(str));
-#endif
+        JSAtom* atom = AtomizeString(cx_, str);
+        if (!atom) {
+          return false;
+        }
+        if (atom != str) {
+          uintptr_t newWord = reinterpret_cast<uintptr_t>(atom);
+          stubInfo->replaceStubRawWord(stubDataCopy, offset, oldWord, newWord);
+        }
         break;
       }
       case StubField::Type::Id: {
@@ -1287,10 +1301,19 @@
         break;
       }
       case StubField::Type::Value: {
-#ifdef DEBUG
-        Value v = stubInfo->getStubField<StubField::Type::Value>(stub, offset);
+        Value v =
+            stubInfo->getStubField<StubField::Type::Value>(stub, offset).get();
         MOZ_ASSERT_IF(v.isGCThing(), !IsInsideNursery(v.toGCThing()));
-#endif
+        if (v.isString()) {
+          Value newVal;
+          JSAtom* atom = AtomizeString(cx_, v.toString());
+          if (!atom) {
+            return false;
+          }
+          newVal.setString(atom);
+          stubInfo->replaceStubRawValueBits(stubDataCopy, offset, v.asRawBits(),
+                                            newVal.asRawBits());
+        }
         break;
       }
       case StubField::Type::AllocSite: {