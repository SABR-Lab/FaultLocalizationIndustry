# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/ipc/CanvasShutdownManager.cpp
# Commit: 1c98db62bb1a
# Full Hash: 1c98db62bb1a20d26f812d28d86672158450e71c
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2024-03-28 21:36:34
# Regressor Bug: 1887729
# File Overlap Count: 2
# Description:
#   Bug 1887729 - Implement context lost/restored support for CanvasRenderingContext2D. r=webidl,gfx-reviewers,smaug,lsalzman
#   
#   Remote canvas can run in the GPU process, and if the GPU process
#   crashes, we need to notify the application using canvas. Historically we
#   just failed, and the application may have been able to continue drawing
# ==============================================================================

diff -r 315bfe14fe3f -r 1c98db62bb1a gfx/ipc/CanvasShutdownManager.cpp
--- a/gfx/ipc/CanvasShutdownManager.cpp	Thu Mar 28 14:21:58 2024 +0000
+++ b/gfx/ipc/CanvasShutdownManager.cpp	Thu Mar 28 14:50:20 2024 +0000
@@ -9,12 +9,16 @@
 #include "mozilla/dom/CanvasRenderingContext2D.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerRef.h"
+#include "mozilla/dom/WorkerRunnable.h"
 #include "mozilla/gfx/CanvasManagerChild.h"
 
 using namespace mozilla::dom;
 
 namespace mozilla::gfx {
 
+StaticMutex CanvasShutdownManager::sManagersMutex;
+std::set<CanvasShutdownManager*> CanvasShutdownManager::sManagers;
+
 // The owning thread will tell us to close when it is shutdown, either via
 // CanvasShutdownManager::Shutdown for the main thread, or via a shutdown
 // callback from ThreadSafeWorkerRef for worker threads.
@@ -42,6 +46,11 @@
     return;
   }
 
+  {
+    StaticMutexAutoLock lock(sManagersMutex);
+    sManagers.erase(manager);
+  }
+
   sLocalManager.set(nullptr);
   manager->Destroy();
   delete manager;
@@ -77,6 +86,9 @@
 
     CanvasShutdownManager* manager = new CanvasShutdownManager(workerRef);
     sLocalManager.set(manager);
+
+    StaticMutexAutoLock lock(sManagersMutex);
+    sManagers.insert(manager);
     return manager;
   }
 
@@ -88,6 +100,9 @@
 
     CanvasShutdownManager* manager = new CanvasShutdownManager();
     sLocalManager.set(manager);
+
+    StaticMutexAutoLock lock(sManagersMutex);
+    sManagers.insert(manager);
     return manager;
   }
 
@@ -105,4 +120,60 @@
   mActiveCanvas.erase(aCanvas);
 }
 
+void CanvasShutdownManager::OnRemoteCanvasLost() {
+  // Note that the canvas cannot do anything that mutates our state. It will
+  // dispatch for anything that risks re-entrancy.
+  for (const auto& canvas : mActiveCanvas) {
+    canvas->OnRemoteCanvasLost();
+  }
+}
+
+void CanvasShutdownManager::OnRemoteCanvasRestored() {
+  // Note that the canvas cannot do anything that mutates our state. It will
+  // dispatch for anything that risks re-entrancy.
+  for (const auto& canvas : mActiveCanvas) {
+    canvas->OnRemoteCanvasRestored();
+  }
+}
+
+/* static */ void CanvasShutdownManager::MaybeRestoreRemoteCanvas() {
+  // Calling Get will recreate the CanvasManagerChild, which in turn will
+  // cause us to call OnRemoteCanvasRestore upon success.
+  if (CanvasShutdownManager* manager = MaybeGet()) {
+    if (!manager->mActiveCanvas.empty()) {
+      CanvasManagerChild::Get();
+    }
+  }
+}
+
+/* static */ void CanvasShutdownManager::OnCompositorManagerRestored() {
+  MOZ_ASSERT(NS_IsMainThread());
+
+  class RestoreRunnable final : public WorkerRunnable {
+   public:
+    explicit RestoreRunnable(WorkerPrivate* aWorkerPrivate)
+        : WorkerRunnable(aWorkerPrivate,
+                         "CanvasShutdownManager::RestoreRunnable") {}
+
+    bool WorkerRun(JSContext*, WorkerPrivate*) override {
+      MaybeRestoreRemoteCanvas();
+      return true;
+    }
+  };
+
+  // We can restore the main thread canvases immediately.
+  MaybeRestoreRemoteCanvas();
+
+  // And dispatch to restore any DOM worker canvases. This is safe because we
+  // remove the manager from sManagers before clearing mWorkerRef during DOM
+  // worker shutdown.
+  StaticMutexAutoLock lock(sManagersMutex);
+  for (const auto& manager : sManagers) {
+    if (manager->mWorkerRef) {
+      auto task = MakeRefPtr<RestoreRunnable>(manager->mWorkerRef->Private());
+      task->Dispatch();
+    }
+  }
+}
+
 }  // namespace mozilla::gfx