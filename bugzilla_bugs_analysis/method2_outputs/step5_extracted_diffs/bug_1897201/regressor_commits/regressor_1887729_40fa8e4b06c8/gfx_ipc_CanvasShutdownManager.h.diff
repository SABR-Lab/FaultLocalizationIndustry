# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/ipc/CanvasShutdownManager.h
# Commit: 40fa8e4b06c8
# Full Hash: 40fa8e4b06c85e9e241da6e56b62a0b2bde7427c
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2024-03-28 17:08:58
# Regressor Bug: 1887729
# File Overlap Count: 2
# Description:
#   Bug 1887729 - Implement context lost/restored support for CanvasRenderingContext2D. r=webidl,gfx-reviewers,smaug,lsalzman
#   
#   Remote canvas can run in the GPU process, and if the GPU process
#   crashes, we need to notify the application using canvas. Historically we
#   just failed, and the application may have been able to continue drawing
# ==============================================================================

diff -r 469884ac63bc -r 40fa8e4b06c8 gfx/ipc/CanvasShutdownManager.h
--- a/gfx/ipc/CanvasShutdownManager.h	Thu Mar 28 01:16:16 2024 +0000
+++ b/gfx/ipc/CanvasShutdownManager.h	Thu Mar 28 01:51:23 2024 +0000
@@ -7,6 +7,7 @@
 #define _include_gfx_ipc_CanvasShutdownManager_h__
 
 #include "mozilla/RefPtr.h"
+#include "mozilla/StaticMutex.h"
 #include "mozilla/ThreadLocal.h"
 #include <set>
 
@@ -29,15 +30,25 @@
   void AddShutdownObserver(dom::CanvasRenderingContext2D* aCanvas);
   void RemoveShutdownObserver(dom::CanvasRenderingContext2D* aCanvas);
 
+  static void OnCompositorManagerRestored();
+
+  void OnRemoteCanvasLost();
+  void OnRemoteCanvasRestored();
+
  private:
   explicit CanvasShutdownManager(dom::StrongWorkerRef* aWorkerRef);
   CanvasShutdownManager();
   ~CanvasShutdownManager();
   void Destroy();
 
+  static void MaybeRestoreRemoteCanvas();
+
   RefPtr<dom::ThreadSafeWorkerRef> mWorkerRef;
   std::set<dom::CanvasRenderingContext2D*> mActiveCanvas;
   static MOZ_THREAD_LOCAL(CanvasShutdownManager*) sLocalManager;
+
+  static StaticMutex sManagersMutex;
+  static std::set<CanvasShutdownManager*> sManagers;
 };
 
 }  // namespace gfx