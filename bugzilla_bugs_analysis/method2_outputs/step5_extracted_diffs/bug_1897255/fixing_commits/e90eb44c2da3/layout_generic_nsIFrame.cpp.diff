# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsIFrame.cpp
# Commit: e90eb44c2da3
# Full Hash: e90eb44c2da3303c038c67b7ad28b1498cd5a98c
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2024-07-19 16:21:39
# Description:
#   Bug 1897255 - Make `nsIFrame::PeekOffsetForLine` won't cross editing host boundary unless the callers allows that r=emilio
#   
#   The problems in the testcase are, `nsIFrame::PeekOffsetForLine` returns a frame
#   for any content node outside the editing host and `nsIFrame::GetLastLeaf`
#   returns a native anonymous subtree node if the frame is for the native
# ==============================================================================

diff -r bd02e7030721 -r e90eb44c2da3 layout/generic/nsIFrame.cpp
--- a/layout/generic/nsIFrame.cpp	Fri Jul 19 07:46:19 2024 +0000
+++ b/layout/generic/nsIFrame.cpp	Fri Jul 19 08:13:10 2024 +0000
@@ -8669,42 +8669,64 @@
                                          // "this" frame then we go to next line
   nsIFrame* nearStoppingFrame = nullptr;  // if we are backing up from edge,
                                           // stop here
-  nsIFrame* firstFrame;
-  nsIFrame* lastFrame;
   bool isBeforeFirstFrame, isAfterLastFrame;
   bool found = false;
 
+  const bool forceInEditableRegion =
+      aPos->mOptions.contains(PeekOffsetOption::ForceEditableRegion);
   while (!found) {
-    if (aPos->mDirection == eDirPrevious)
+    if (aPos->mDirection == eDirPrevious) {
       searchingLine--;
-    else
+    } else {
       searchingLine++;
+    }
     if ((aPos->mDirection == eDirPrevious && searchingLine < 0) ||
         (aPos->mDirection == eDirNext && searchingLine >= countLines)) {
       // we need to jump to new block frame.
       return NS_ERROR_FAILURE;
     }
-    auto line = it->GetLine(searchingLine).unwrap();
-    if (!line.mNumFramesOnLine) {
-      continue;
-    }
-    lastFrame = firstFrame = line.mFirstFrameOnLine;
-    for (int32_t lineFrameCount = line.mNumFramesOnLine; lineFrameCount > 1;
-         lineFrameCount--) {
-      lastFrame = lastFrame->GetNextSibling();
+    {
+      auto line = it->GetLine(searchingLine).unwrap();
+      if (!line.mNumFramesOnLine) {
+        continue;
+      }
+      nsIFrame* firstFrame = nullptr;
+      nsIFrame* lastFrame = nullptr;
+      nsIFrame* frame = line.mFirstFrameOnLine;
+      int32_t i = line.mNumFramesOnLine;
+      do {
+        // If the caller wants a frame for a inclusive ancestor of the ancestor
+        // limiter, ignore frames for outside the limiter.
+        if (aPos->FrameContentIsInAncestorLimiter(frame)) {
+          if (!firstFrame) {
+            firstFrame = frame;
+          }
+          lastFrame = frame;
+        }
+        if (i == 1) {
+          break;
+        }
+        frame = frame->GetNextSibling();
+        if (!frame) {
+          NS_ERROR("GetLine promised more frames than could be found");
+          return NS_ERROR_FAILURE;
+        }
+      } while (--i);
       if (!lastFrame) {
-        NS_ERROR("GetLine promised more frames than could be found");
+        // If we're looking for an editable content frame, but all frames in the
+        // line are not in the specified editing host, return error because we
+        // must reach the editing host boundary.
         return NS_ERROR_FAILURE;
       }
-    }
-    nsIFrame::GetLastLeaf(&lastFrame);
-
-    if (aPos->mDirection == eDirNext) {
-      nearStoppingFrame = firstFrame;
-      farStoppingFrame = lastFrame;
-    } else {
-      nearStoppingFrame = lastFrame;
-      farStoppingFrame = firstFrame;
+      nsIFrame::GetLastLeaf(&lastFrame);
+
+      if (aPos->mDirection == eDirNext) {
+        nearStoppingFrame = firstFrame;
+        farStoppingFrame = lastFrame;
+      } else {
+        nearStoppingFrame = lastFrame;
+        farStoppingFrame = firstFrame;
+      }
     }
     nsPoint offset;
     nsView* view;  // used for call of get offset from view
@@ -8712,6 +8734,10 @@
     nsPoint newDesiredPos =
         aPos->mDesiredCaretPos -
         offset;  // get desired position into blockframe coords
+    // TODO: nsILineIterator::FindFrameAt should take optional editing host
+    // parameter and if it's set, it should return the nearest editable frame
+    // for the editing host when the frame at the desired position is not
+    // editable.
     nsresult rv = it->FindFrameAt(searchingLine, newDesiredPos, &resultFrame,
                                   &isBeforeFirstFrame, &isAfterLastFrame);
     if (NS_FAILED(rv)) {
@@ -8719,6 +8745,11 @@
     }
 
     if (resultFrame) {
+      // If ancestor limiter is specified and we reached outside content of it,
+      // return error because we reached its element boundary.
+      if (!aPos->FrameContentIsInAncestorLimiter(resultFrame)) {
+        return NS_ERROR_FAILURE;
+      }
       // check to see if this is ANOTHER blockframe inside the other one if so
       // then call into its lines
       if (resultFrame->CanProvideLineIterator()) {
@@ -8735,16 +8766,21 @@
           false   // aSkipPopupChecks
       );
 
-      auto FoundValidFrame = [aPos](const nsIFrame::ContentOffsets& aOffsets,
-                                    const nsIFrame* aFrame) {
+      auto FoundValidFrame = [forceInEditableRegion, aPos](
+                                 const nsIFrame::ContentOffsets& aOffsets,
+                                 const nsIFrame* aFrame) {
         if (!aOffsets.content) {
           return false;
         }
         if (!aFrame->IsSelectable(nullptr)) {
           return false;
         }
-        if (aPos->mOptions.contains(PeekOffsetOption::ForceEditableRegion) &&
-            !aOffsets.content->IsEditable()) {
+        if (aPos->mAncestorLimiter &&
+            !aOffsets.content->IsInclusiveDescendantOf(
+                aPos->mAncestorLimiter)) {
+          return false;
+        }
+        if (forceInEditableRegion && !aOffsets.content->IsEditable()) {
           return false;
         }
         return true;
@@ -8829,13 +8865,17 @@
           break;
         }
         if (aPos->mDirection == eDirPrevious &&
-            (resultFrame == nearStoppingFrame))
+            resultFrame == nearStoppingFrame) {
           break;
-        if (aPos->mDirection == eDirNext && (resultFrame == farStoppingFrame))
+        }
+        if (aPos->mDirection == eDirNext && resultFrame == farStoppingFrame) {
           break;
+        }
         // previous didnt work now we try "next"
         nsIFrame* tempFrame = frameIterator->Traverse(/* aForward = */ true);
-        if (!tempFrame) break;
+        if (!tempFrame) {
+          break;
+        }
         resultFrame = tempFrame;
       }
       aPos->mResultFrame = resultFrame;
@@ -8846,8 +8886,9 @@
       aPos->mAttach = aPos->mDirection == eDirNext
                           ? CaretAssociationHint::Before
                           : CaretAssociationHint::After;
-      if (aPos->mDirection == eDirPrevious)
+      if (aPos->mDirection == eDirPrevious) {
         aPos->mStartOffset = -1;  // start from end
+      }
       return aBlockFrame->PeekOffset(aPos);
     }
   }
@@ -9210,12 +9251,18 @@
 }
 
 static nsIFrame* GetFirstSelectableDescendantWithLineIterator(
-    nsIFrame* aParentFrame, bool aForceEditableRegion) {
-  auto FoundValidFrame = [aForceEditableRegion](const nsIFrame* aFrame) {
+    const PeekOffsetStruct& aPeekOffsetStruct, nsIFrame* aParentFrame) {
+  const bool forceEditableRegion = aPeekOffsetStruct.mOptions.contains(
+      PeekOffsetOption::ForceEditableRegion);
+  auto FoundValidFrame = [aPeekOffsetStruct,
+                          forceEditableRegion](const nsIFrame* aFrame) {
     if (!aFrame->IsSelectable(nullptr)) {
       return false;
     }
-    if (aForceEditableRegion && !aFrame->GetContent()->IsEditable()) {
+    if (!aPeekOffsetStruct.FrameContentIsInAncestorLimiter(aFrame)) {
+      return false;
+    }
+    if (forceEditableRegion && !aFrame->ContentIsEditable()) {
       return false;
     }
     return true;
@@ -9229,7 +9276,7 @@
       return child;
     }
     if (nsIFrame* nested = GetFirstSelectableDescendantWithLineIterator(
-            child, aForceEditableRegion)) {
+            aPeekOffsetStruct, child)) {
       return nested;
     }
   }
@@ -9249,6 +9296,9 @@
     if (!newBlock) {
       return NS_ERROR_FAILURE;
     }
+    // FYI: If the editing host is an inline element, the block frame content
+    // may be either not editable or editable but belonging to different editing
+    // host.
     blockFrame = newBlock;
     nsILineIterator* iter = blockFrame->GetLineIterator();
     int32_t thisLine = iter->FindLineContaining(lineFrame);
@@ -9302,8 +9352,7 @@
 
       if (shouldDrillIntoChildren) {
         nsIFrame* child = GetFirstSelectableDescendantWithLineIterator(
-            aPos->mResultFrame,
-            aPos->mOptions.contains(PeekOffsetOption::ForceEditableRegion));
+            *aPos, aPos->mResultFrame);
         if (child) {
           aPos->mResultFrame = child;
         }
@@ -10705,7 +10754,10 @@
 }
 
 void nsIFrame::GetLastLeaf(nsIFrame** aFrame) {
-  if (!aFrame || !*aFrame) {
+  if (!aFrame || !*aFrame ||
+      // Don't enter into native anoymous subtree from the root like <input> or
+      // <textarea>.
+      (*aFrame)->ContentIsRootOfNativeAnonymousSubtree()) {
     return;
   }
   for (nsIFrame* maybeLastLeaf = (*aFrame)->PrincipalChildList().LastChild();
@@ -10713,10 +10765,9 @@
     nsIFrame* lastChildNotInSubTree = nullptr;
     for (nsIFrame* child = maybeLastLeaf; child;
          child = child->GetPrevSibling()) {
-      nsIContent* content = child->GetContent();
       // ignore anonymous elements, e.g. mozTableAdd* mozTableRemove*
       // see bug 278197 comment #12 #13 for details
-      if (content && !content->IsRootOfNativeAnonymousSubtree()) {
+      if (!child->ContentIsRootOfNativeAnonymousSubtree()) {
         lastChildNotInSubTree = child;
         break;
       }