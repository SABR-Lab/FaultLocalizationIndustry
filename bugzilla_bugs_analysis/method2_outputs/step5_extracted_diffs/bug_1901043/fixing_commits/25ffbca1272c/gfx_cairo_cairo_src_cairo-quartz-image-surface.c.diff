# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-quartz-image-surface.c
# Commit: 25ffbca1272c
# Full Hash: 25ffbca1272cb30429764878ac1e77a5f3d45ef6
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-06-20 21:38:27
# Description:
#   Bug 1901043 - Revert to the pre-1.18.0 version of _cairo_surface_to_cgimage() and cairo_quartz_image_surface code. r=gfx-reviewers,lsalzman
#   
#   This eliminates the new _cairo_quartz_surface_snapshot, and the CGContextRef-based
#   version of cairo_quartz_image_surface,  which seems to be the potentially-problematic
#   codepath.
# ==============================================================================

diff -r 031c8a5d110b -r 25ffbca1272c gfx/cairo/cairo/src/cairo-quartz-image-surface.c
--- a/gfx/cairo/cairo/src/cairo-quartz-image-surface.c	Thu Jun 20 10:41:02 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-quartz-image-surface.c	Thu Jun 20 10:41:14 2024 +0000
@@ -49,14 +49,11 @@
 #define SURFACE_ERROR_INVALID_SIZE (_cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_INVALID_SIZE)))
 #define SURFACE_ERROR_INVALID_FORMAT (_cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_INVALID_FORMAT)))
 
-/**
- * CAIRO_HAS_QUARTZ_IMAGE_SURFACE:
- *
- * Defined if the Quartz image surface backend is available.
- * This macro can be used to conditionally compile backend-specific code.
- *
- * Since: 1.10
- **/
+static void
+DataProviderReleaseCallback (void *image_info, const void *data, size_t size)
+{
+    free (image_info);
+}
 
 static cairo_surface_t *
 _cairo_quartz_image_surface_create_similar (void *asurface,
@@ -90,9 +87,8 @@
 {
     cairo_quartz_image_surface_t *surface = (cairo_quartz_image_surface_t *) asurface;
 
-    CGContextRelease (surface->cgContext);
-    if (surface->imageSurface)
-	cairo_surface_destroy ( (cairo_surface_t*) surface->imageSurface);
+    CGImageRelease (surface->image);
+    cairo_surface_destroy ( (cairo_surface_t*) surface->imageSurface);
     return CAIRO_STATUS_SUCCESS;
 }
 
@@ -138,6 +134,47 @@
     return TRUE;
 }
 
+/* we assume some drawing happened to the image buffer; make sure it's
+ * represented in the CGImage on flush()
+ */
+
+static cairo_status_t
+_cairo_quartz_image_surface_flush (void *asurface,
+				   unsigned flags)
+{
+    cairo_quartz_image_surface_t *surface = (cairo_quartz_image_surface_t *) asurface;
+    CGImageRef oldImage = surface->image;
+    CGImageRef newImage = NULL;
+    void *image_data;
+    const unsigned int size = surface->imageSurface->height * surface->imageSurface->stride;
+    if (flags)
+	return CAIRO_STATUS_SUCCESS;
+
+    /* XXX only flush if the image has been modified. */
+
+    image_data = _cairo_malloc_ab ( surface->imageSurface->height,
+				    surface->imageSurface->stride);
+    if (unlikely (!image_data))
+	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    memcpy (image_data, surface->imageSurface->data,
+	    surface->imageSurface->height * surface->imageSurface->stride);
+    newImage = CairoQuartzCreateCGImage (surface->imageSurface->format,
+					 surface->imageSurface->width,
+					 surface->imageSurface->height,
+					 surface->imageSurface->stride,
+					 image_data,
+					 TRUE,
+					 NULL,
+					 DataProviderReleaseCallback,
+					 image_data);
+
+    surface->image = newImage;
+    CGImageRelease (oldImage);
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
 static cairo_int_status_t
 _cairo_quartz_image_surface_paint (void			*abstract_surface,
 				   cairo_operator_t		 op,
@@ -238,7 +275,7 @@
     _cairo_quartz_image_surface_get_extents,
     NULL, /* get_font_options */
 
-    NULL, /*surface_flush */
+    _cairo_quartz_image_surface_flush,
     NULL, /* mark_dirty_rectangle */
 
     _cairo_quartz_image_surface_paint,
@@ -253,9 +290,12 @@
  * cairo_quartz_image_surface_create:
  * @image_surface: a cairo image surface to wrap with a quartz image surface
  *
- * Creates a Quartz surface backed by a CGBitmapContext that references the
+ * Creates a Quartz surface backed by a CGImageRef that references the
  * given image surface. The resulting surface can be rendered quickly
- * when used as a source when rendering to a #cairo_quartz_surface.
+ * when used as a source when rendering to a #cairo_quartz_surface.  If
+ * the data in the image surface is ever updated, cairo_surface_flush()
+ * must be called on the #cairo_quartz_image_surface to ensure that the
+ * CGImageRef refers to the updated data.
  *
  * Return value: the newly created surface.
  *
@@ -265,11 +305,13 @@
 cairo_quartz_image_surface_create (cairo_surface_t *surface)
 {
     cairo_quartz_image_surface_t *qisurf;
+
+    CGImageRef image;
+
     cairo_image_surface_t *image_surface;
     int width, height, stride;
     cairo_format_t format;
-    CGBitmapInfo bitinfo = kCGBitmapByteOrder32Host;
-    CGColorSpaceRef colorspace;
+    void *image_data;
 
     if (surface->status)
 	return surface;
@@ -296,98 +338,58 @@
     if (qisurf == NULL)
 	return SURFACE_ERROR_NO_MEMORY;
 
+    memset (qisurf, 0, sizeof(cairo_quartz_image_surface_t));
+
+    image_data = _cairo_malloc_ab (height, stride);
+    if (unlikely (!image_data)) {
+	free(qisurf);
+	return SURFACE_ERROR_NO_MEMORY;
+    }
+
+    memcpy (image_data, image_surface->data, height * stride);
+    image = CairoQuartzCreateCGImage (format,
+				      width, height,
+				      stride,
+				      image_data,
+				      TRUE,
+				      NULL,
+				      DataProviderReleaseCallback,
+				      image_data);
+
+    if (!image) {
+	free (qisurf);
+	return SURFACE_ERROR_NO_MEMORY;
+    }
+
     _cairo_surface_init (&qisurf->base,
 			 &cairo_quartz_image_surface_backend,
 			 NULL, /* device */
 			 _cairo_content_from_format (format),
 			 FALSE); /* is_vector */
 
-    if (_cairo_surface_is_quartz (surface) || _cairo_surface_is_quartz_image (surface)) {
-	CGContextRef context = cairo_quartz_surface_get_cg_context(surface);
-	colorspace = _cairo_quartz_create_color_space (context);
-    }
-    else {
-#if CAIRO_HAS_QUARTZ_APPLICATION_SERVICES /* available on macOS but not iOS */
-	colorspace = CGDisplayCopyColorSpace (CGMainDisplayID ());
-#else
-	colorspace = CGColorSpaceCreateDeviceRGB ();
-#endif
-    }
-
-    bitinfo |= format == CAIRO_FORMAT_ARGB32 ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;
-
     qisurf->width = width;
     qisurf->height = height;
 
-    qisurf->cgContext = CGBitmapContextCreate (image_surface->data, width, height, 8, image_surface->stride,
-					       colorspace, bitinfo);
+    qisurf->image = image;
     qisurf->imageSurface = (cairo_image_surface_t*) cairo_surface_reference(surface);
 
-    CGColorSpaceRelease (colorspace);
     return &qisurf->base;
 }
 
 
-/**
- * cairo_quartz_image_surface_get_image:
- * @surface: a #cairo_surface_t
- *
- * Returns a #cairo_surface_t image surface that refers to the same bits
- * as the image of the quartz surface.
- *
- * Return value: a #cairo_surface_t (owned by the quartz #cairo_surface_t),
- * or %NULL if the quartz surface is not an image surface.
- *
- * Since: 1.6
- **/
 cairo_surface_t *
-cairo_quartz_image_surface_get_image (cairo_surface_t *surface)
+cairo_quartz_image_surface_get_image (cairo_surface_t *asurface)
 {
-    cairo_quartz_image_surface_t *qsurface = (cairo_quartz_image_surface_t*) surface;
+    cairo_quartz_image_surface_t *surface = (cairo_quartz_image_surface_t*) asurface;
 
     /* Throw an error for a non-quartz surface */
-    if (! _cairo_surface_is_quartz (surface)) {
+    if (! _cairo_surface_is_quartz (asurface)) {
         return SURFACE_ERROR_TYPE_MISMATCH;
     }
 
-    return (cairo_surface_t*) qsurface->imageSurface;
+    return (cairo_surface_t*) surface->imageSurface;
 }
 
-/*
- * _cairo_quartz_image_surface_get_cg_context:
- * @surface: the Cairo Quartz surface
- *
- * Returns the CGContextRef that the given Quartz surface is backed
- * by.
- *
- * A call to cairo_surface_flush() is required before using the
- * CGContextRef to ensure that all pending drawing operations are
- * finished and to restore any temporary modification cairo has made
- * to its state. A call to cairo_surface_mark_dirty() is required
- * after the state or the content of the CGContextRef has been
- * modified.
- *
- * Return value: the CGContextRef for the given surface.
- *
- **/
-CGContextRef
-_cairo_quartz_image_surface_get_cg_context (cairo_surface_t *surface)
-{
-    if (surface && _cairo_surface_is_quartz_image (surface)) {
-	cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t *) surface;
-	return quartz->cgContext;
-    } else
-	return NULL;
-}
-
-/*
- * _cairo_surface_is_quartz_image:
- * @surface: a #cairo_surface_t
- *
- * Checks if a surface is a #cairo_quartz_surface_t
- *
- * Return value: True if the surface is an quartz surface
- **/
 cairo_bool_t
 _cairo_surface_is_quartz_image (const cairo_surface_t *surface) {
     return surface->backend == &cairo_quartz_image_surface_backend;