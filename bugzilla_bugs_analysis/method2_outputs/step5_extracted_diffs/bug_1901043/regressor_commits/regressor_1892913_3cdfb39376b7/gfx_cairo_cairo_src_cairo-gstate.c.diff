# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-gstate.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-gstate.c
--- a/gfx/cairo/cairo/src/cairo-gstate.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-gstate.c	Mon May 06 19:25:12 2024 +0000
@@ -193,6 +193,7 @@
 _cairo_gstate_fini (cairo_gstate_t *gstate)
 {
     _cairo_stroke_style_fini (&gstate->stroke_style);
+    _cairo_font_options_fini (&gstate->font_options);
 
     cairo_font_face_destroy (gstate->font_face);
     gstate->font_face = NULL;
@@ -470,7 +471,10 @@
 cairo_status_t
 _cairo_gstate_set_line_width (cairo_gstate_t *gstate, double width)
 {
-    gstate->stroke_style.line_width = width;
+    if (gstate->stroke_style.is_hairline)
+	gstate->stroke_style.pre_hairline_line_width = width;
+	else
+	gstate->stroke_style.line_width = width;
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -482,6 +486,29 @@
 }
 
 cairo_status_t
+_cairo_gstate_set_hairline (cairo_gstate_t *gstate, cairo_bool_t set_hairline)
+{
+    if (gstate->stroke_style.is_hairline != set_hairline) {
+        gstate->stroke_style.is_hairline = set_hairline;
+
+        if (set_hairline) {
+            gstate->stroke_style.pre_hairline_line_width = gstate->stroke_style.line_width;
+            gstate->stroke_style.line_width = 0.0;
+        } else {
+            gstate->stroke_style.line_width = gstate->stroke_style.pre_hairline_line_width;
+        }
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+cairo_bool_t
+_cairo_gstate_get_hairline (cairo_gstate_t *gstate)
+{
+    return gstate->stroke_style.is_hairline;
+}
+
+cairo_status_t
 _cairo_gstate_set_line_cap (cairo_gstate_t *gstate, cairo_line_cap_t line_cap)
 {
     gstate->stroke_style.line_cap = line_cap;
@@ -937,9 +964,22 @@
 					const cairo_pattern_t *original,
 					const cairo_matrix_t  *ctm_inverse)
 {
+    /*
+     * What calculations below do can be described in pseudo-code (so using nonexistent fields) as (using column vectors):
+     * pattern->matrix = surface->device_transform *
+     * 			 pattern->matrix *
+     * 			 ctm_inverse *
+     * 			 gstate->target->device_transform_inverse
+     *
+     * The inverse of which is:
+     * pattern->matrix_inverse = gstate->target->device_transform *
+     * 				 ctm *
+     * 				 pattern->matrix_inverse *
+     * 				 surface->device_transform_inverse
+     */
+
     _cairo_gstate_copy_pattern (pattern, original);
 
-    /* apply device_transform first so that it is transformed by ctm_inverse */
     if (original->type == CAIRO_PATTERN_TYPE_SURFACE) {
 	cairo_surface_pattern_t *surface_pattern;
 	cairo_surface_t *surface;
@@ -1106,7 +1146,7 @@
     }
     _cairo_gstate_copy_transformed_mask (gstate, &mask_pattern.base, mask);
 
-    if (source->type == CAIRO_PATTERN_TYPE_SOLID &&
+    if (source->type == CAIRO_PATTERN_TYPE_SOLID && !source->is_foreground_marker &&
 	mask_pattern.base.type == CAIRO_PATTERN_TYPE_SOLID &&
 	_cairo_operator_bounded_by_source (op))
     {
@@ -1159,7 +1199,7 @@
     if (gstate->op == CAIRO_OPERATOR_DEST)
 	return CAIRO_STATUS_SUCCESS;
 
-    if (gstate->stroke_style.line_width <= 0.0)
+    if (gstate->stroke_style.line_width <= 0.0 && !gstate->stroke_style.is_hairline)
 	return CAIRO_STATUS_SUCCESS;
 
     if (_cairo_clip_is_all_clipped (gstate->clip))
@@ -1709,11 +1749,12 @@
 _cairo_gstate_set_font_options (cairo_gstate_t             *gstate,
 				const cairo_font_options_t *options)
 {
-    if (memcmp (options, &gstate->font_options, sizeof (cairo_font_options_t)) == 0)
+    if (_cairo_font_options_compare (options, &gstate->font_options))
 	return;
 
     _cairo_gstate_unset_scaled_font (gstate);
 
+    _cairo_font_options_fini (&gstate->font_options);
     _cairo_font_options_init_copy (&gstate->font_options, options);
 }
 
@@ -1721,7 +1762,8 @@
 _cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
 				cairo_font_options_t *options)
 {
-    *options = gstate->font_options;
+    _cairo_font_options_fini (options);
+    _cairo_font_options_init_copy (options, &gstate->font_options);
 }
 
 cairo_status_t
@@ -1878,6 +1920,8 @@
 					    &font_ctm,
 					    &options);
 
+    _cairo_font_options_fini (&options);
+
     status = cairo_scaled_font_status (scaled_font);
     if (unlikely (status))
 	return status;