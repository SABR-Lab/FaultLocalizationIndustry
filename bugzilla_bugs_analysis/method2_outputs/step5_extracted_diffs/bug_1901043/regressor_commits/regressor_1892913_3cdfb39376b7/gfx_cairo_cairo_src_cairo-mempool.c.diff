# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-mempool.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-mempool.c
--- a/gfx/cairo/cairo/src/cairo-mempool.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-mempool.c	Mon May 06 19:25:12 2024 +0000
@@ -78,14 +78,14 @@
     struct _cairo_memblock *block;
 
     if (clear)
-	clear_bits (pool, start, start + (1 << bits));
+	clear_bits (pool, start, start + (((size_t) 1) << bits));
 
     block = pool->blocks + start;
     block->bits = bits;
 
     cairo_list_add (&block->link, &pool->free[bits]);
 
-    pool->free_bytes += 1 << (bits + pool->min_bits);
+    pool->free_bytes += ((size_t) 1) << (bits + pool->min_bits);
     if (bits > pool->max_free_bits)
 	pool->max_free_bits = bits;
 }
@@ -157,10 +157,10 @@
 {
     struct _cairo_memblock *block;
 
-    if (offset + (1 << bits) >= pool->num_blocks)
+    if (offset + (((size_t) 1) << bits) >= pool->num_blocks)
 	return NULL; /* invalid */
 
-    if (BITTEST (pool, offset + (1 << bits) - 1))
+    if (BITTEST (pool, offset + (((size_t) 1) << bits) - 1))
 	return NULL; /* buddy is allocated */
 
     block = pool->blocks + offset;
@@ -180,7 +180,7 @@
 
     while (bits < max_bits - 1) {
 	/* while you can, merge two blocks and get a legal block size */
-	size_t buddy_offset = block_offset ^ (1 << bits);
+	size_t buddy_offset = block_offset ^ (((size_t) 1) << bits);
 
 	block = get_buddy (pool, buddy_offset, bits);
 	if (block == NULL)
@@ -216,7 +216,7 @@
 				       &pool->free[bits],
 				       link)
 	{
-	    size_t buddy_offset = (block - pool->blocks) ^ (1 << bits);
+	    size_t buddy_offset = (block - pool->blocks) ^ (((size_t) 1) << bits);
 
 	    buddy = get_buddy (pool, buddy_offset, bits);
 	    if (buddy == NULL)
@@ -268,13 +268,13 @@
 
     /* Mark end of allocated area */
     offset = block - pool->blocks;
-    past = offset + (1 << bits);
+    past = offset + (((size_t) 1) << bits);
     BITSET (pool, past - 1);
     block->bits = bits;
 
     /* If we used a larger free block than we needed, free the rest */
-    pool->free_bytes -= 1 << (b + pool->min_bits);
-    free_blocks (pool, past, offset + (1 << b), 0);
+    pool->free_bytes -= ((size_t) 1) << (b + pool->min_bits);
+    free_blocks (pool, past, offset + (((size_t) 1) << b), 0);
 
     return pool->base + ((block - pool->blocks) << pool->min_bits);
 }
@@ -284,19 +284,19 @@
 		      void *base, size_t bytes,
 		      int min_bits, int num_sizes)
 {
-    unsigned long tmp;
+    uintptr_t tmp;
     int num_blocks;
     int i;
 
     /* Align the start to an integral chunk */
-    tmp = ((unsigned long) base) & ((1 << min_bits) - 1);
+    tmp = ((uintptr_t) base) & ((((size_t) 1) << min_bits) - 1);
     if (tmp) {
-	tmp = (1 << min_bits) - tmp;
+	tmp = (((size_t) 1) << min_bits) - tmp;
 	base = (char *)base + tmp;
 	bytes -= tmp;
     }
 
-    assert ((((unsigned long) base) & ((1 << min_bits) - 1)) == 0);
+    assert ((((uintptr_t) base) & ((((size_t) 1) << min_bits) - 1)) == 0);
     assert (num_sizes < ARRAY_LENGTH (pool->free));
 
     pool->base = base;
@@ -337,7 +337,7 @@
     size_t size;
     int bits;
 
-    size = 1 << pool->min_bits;
+    size = ((size_t) 1) << pool->min_bits;
     for (bits = 0; size < bytes; bits++)
 	size <<= 1;
     if (bits >= pool->num_sizes)
@@ -355,8 +355,8 @@
     block_offset = ((char *)storage - pool->base) >> pool->min_bits;
     block = pool->blocks + block_offset;
 
-    BITCLEAR (pool, block_offset + ((1 << block->bits) - 1));
-    pool->free_bytes += 1 << (block->bits + pool->min_bits);
+    BITCLEAR (pool, block_offset + ((((size_t) 1) << block->bits) - 1));
+    pool->free_bytes += ((size_t) 1) << (block->bits + pool->min_bits);
 
     merge_buddies (pool, block, pool->num_sizes);
 }