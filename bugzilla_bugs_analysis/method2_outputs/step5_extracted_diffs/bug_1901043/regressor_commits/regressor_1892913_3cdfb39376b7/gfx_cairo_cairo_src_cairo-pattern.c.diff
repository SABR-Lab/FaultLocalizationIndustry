# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-pattern.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-pattern.c
--- a/gfx/cairo/cairo/src/cairo-pattern.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-pattern.c	Mon May 06 19:25:12 2024 +0000
@@ -63,6 +63,14 @@
  * functions.
  **/
 
+/**
+ * CAIRO_HAS_MIME_SURFACE:
+ *
+ * Unused symbol, always defined.
+ *
+ * Since: 1.12
+ **/
+
 static freed_pool_t freed_pattern_pool[5];
 
 static const cairo_solid_pattern_t _cairo_pattern_nil = {
@@ -76,6 +84,8 @@
       CAIRO_FILTER_DEFAULT,		/* filter */
       CAIRO_EXTEND_GRADIENT_DEFAULT,	/* extend */
       FALSE,				/* has component alpha */
+      FALSE,				/* is_foreground_marker */
+      CAIRO_DITHER_DEFAULT,		/* dither */
       { 1., 0., 0., 1., 0., 0., },	/* matrix */
       1.0                               /* opacity */
     }
@@ -92,6 +102,8 @@
       CAIRO_FILTER_DEFAULT,		/* filter */
       CAIRO_EXTEND_GRADIENT_DEFAULT,	/* extend */
       FALSE,				/* has component alpha */
+      FALSE,				/* is_foreground_marker */
+      CAIRO_DITHER_DEFAULT,		/* dither */
       { 1., 0., 0., 1., 0., 0., },	/* matrix */
       1.0                               /* opacity */
     }
@@ -108,6 +120,8 @@
       CAIRO_FILTER_NEAREST,		/* filter */
       CAIRO_EXTEND_REPEAT,		/* extend */
       FALSE,				/* has component alpha */
+      FALSE,				/* is_foreground_marker */
+      CAIRO_DITHER_DEFAULT,		/* dither */
       { 1., 0., 0., 1., 0., 0., },	/* matrix */
       1.0                               /* opacity */
     },
@@ -125,6 +139,8 @@
       CAIRO_FILTER_NEAREST,		/* filter */
       CAIRO_EXTEND_REPEAT,		/* extend */
       FALSE,				/* has component alpha */
+      FALSE,				/* is_foreground_marker */
+      CAIRO_DITHER_DEFAULT,		/* dither */
       { 1., 0., 0., 1., 0., 0., },	/* matrix */
       1.0                               /* opacity */
     },
@@ -142,6 +158,8 @@
       CAIRO_FILTER_NEAREST,		/* filter */
       CAIRO_EXTEND_REPEAT,		/* extend */
       FALSE,				/* has component alpha */
+      FALSE,				/* is_foreground_marker */
+      CAIRO_DITHER_DEFAULT,		/* dither */
       { 1., 0., 0., 1., 0., 0., },	/* matrix */
       1.0                               /* opacity */
     },
@@ -233,6 +251,9 @@
     pattern->opacity   = 1.0;
 
     pattern->has_component_alpha = FALSE;
+    pattern->is_foreground_marker = FALSE;
+
+    pattern->dither    = CAIRO_DITHER_DEFAULT;
 
     cairo_matrix_init_identity (&pattern->matrix);
 
@@ -555,6 +576,7 @@
     _cairo_pattern_init (&pattern->base, CAIRO_PATTERN_TYPE_SURFACE);
 
     pattern->surface = cairo_surface_reference (surface);
+    pattern->region_array_id = 0;
 }
 
 static void
@@ -618,6 +640,14 @@
 }
 
 cairo_pattern_t *
+_cairo_pattern_create_foreground_marker (void)
+{
+    cairo_pattern_t *pattern = _cairo_pattern_create_solid (CAIRO_COLOR_BLACK);
+    pattern->is_foreground_marker = TRUE;
+    return pattern;
+}
+
+cairo_pattern_t *
 _cairo_pattern_create_in_error (cairo_status_t status)
 {
     cairo_pattern_t *pattern;
@@ -661,7 +691,6 @@
 {
     return cairo_pattern_create_rgba (red, green, blue, 1.0);
 }
-slim_hidden_def (cairo_pattern_create_rgb);
 
 /**
  * cairo_pattern_create_rgba:
@@ -675,6 +704,8 @@
  * 1.  If the values passed in are outside that range, they will be
  * clamped.
  *
+ * The color is specified in the same way as in cairo_set_source_rgb().
+ *
  * Return value: the newly created #cairo_pattern_t if successful, or
  * an error pattern in case of no memory.  The caller owns the
  * returned object and should call cairo_pattern_destroy() when
@@ -703,7 +734,6 @@
 
     return _cairo_pattern_create_solid (&color);
 }
-slim_hidden_def (cairo_pattern_create_rgba);
 
 /**
  * cairo_pattern_create_for_surface:
@@ -752,7 +782,6 @@
 
     return &pattern->base;
 }
-slim_hidden_def (cairo_pattern_create_for_surface);
 
 /**
  * cairo_pattern_create_linear:
@@ -1067,7 +1096,6 @@
 
     return pattern;
 }
-slim_hidden_def (cairo_pattern_reference);
 
 /**
  * cairo_pattern_get_type:
@@ -1138,7 +1166,6 @@
     else
 	free (pattern);
 }
-slim_hidden_def (cairo_pattern_destroy);
 
 /**
  * cairo_pattern_get_reference_count:
@@ -1273,7 +1300,6 @@
 	mesh->has_color[i] = FALSE;
 }
 
-
 static void
 _calc_control_point (cairo_mesh_patch_t *patch, int control_point)
 {
@@ -1478,7 +1504,6 @@
 	mesh->current_patch->points[i][j].y = y3;
     }
 }
-slim_hidden_def (cairo_mesh_pattern_curve_to);
 
 /**
  * cairo_mesh_pattern_line_to:
@@ -1549,7 +1574,6 @@
 				 (last_point.y + 2 * y) * (1. / 3),
 				 x, y);
 }
-slim_hidden_def (cairo_mesh_pattern_line_to);
 
 /**
  * cairo_mesh_pattern_move_to:
@@ -1599,7 +1623,6 @@
     mesh->current_patch->points[0][0].x = x;
     mesh->current_patch->points[0][0].y = y;
 }
-slim_hidden_def (cairo_mesh_pattern_move_to);
 
 /**
  * cairo_mesh_pattern_set_control_point:
@@ -1818,7 +1841,6 @@
 
     _cairo_mesh_pattern_set_corner_color (mesh, corner_num, red, green, blue, alpha);
 }
-slim_hidden_def (cairo_mesh_pattern_set_corner_color_rgba);
 
 static void
 _cairo_pattern_add_color_stop (cairo_gradient_pattern_t	*pattern,
@@ -1962,7 +1984,6 @@
     _cairo_pattern_add_color_stop ((cairo_gradient_pattern_t *) pattern,
 				   offset, red, green, blue, alpha);
 }
-slim_hidden_def (cairo_pattern_add_color_stop_rgba);
 
 /**
  * cairo_pattern_set_matrix:
@@ -2019,7 +2040,6 @@
     if (unlikely (status))
 	status = _cairo_pattern_set_error (pattern, status);
 }
-slim_hidden_def (cairo_pattern_set_matrix);
 
 /**
  * cairo_pattern_get_matrix:
@@ -2086,6 +2106,45 @@
 }
 
 /**
+ * cairo_pattern_get_dither:
+ * @pattern: a #cairo_pattern_t
+ *
+ * Gets the current dithering mode, as set by
+ * cairo_pattern_set_dither().
+ *
+ * Return value: the current dithering mode.
+ *
+ * Since: 1.18
+ **/
+cairo_dither_t
+cairo_pattern_get_dither (cairo_pattern_t *pattern)
+{
+    return pattern->dither;
+}
+
+/**
+ * cairo_pattern_set_dither:
+ * @pattern: a #cairo_pattern_t
+ * @dither: a #cairo_dither_t describing the new dithering mode
+ *
+ * Set the dithering mode of the rasterizer used for drawing shapes.
+ * This value is a hint, and a particular backend may or may not support
+ * a particular value.  At the current time, only pixman is supported.
+ *
+ * Since: 1.18
+ **/
+void
+cairo_pattern_set_dither (cairo_pattern_t *pattern, cairo_dither_t dither)
+{
+    if (pattern->status)
+        return;
+
+    pattern->dither = dither;
+    _cairo_pattern_notify_observers (pattern, CAIRO_PATTERN_NOTIFY_DITHER);
+
+}
+
+/**
  * cairo_pattern_set_extend:
  * @pattern: a #cairo_pattern_t
  * @extend: a #cairo_extend_t describing how the area outside of the
@@ -2127,7 +2186,6 @@
 {
     return pattern->extend;
 }
-slim_hidden_def (cairo_pattern_get_extend);
 
 void
 _cairo_pattern_pretransform (cairo_pattern_t	*pattern,
@@ -2691,7 +2749,6 @@
 #undef lerp
 }
 
-
 /**
  * _cairo_gradient_pattern_fit_to_range:
  *
@@ -3416,9 +3473,10 @@
 /**
  * _cairo_pattern_analyze_filter:
  * @pattern: surface pattern
- * Returns: the optimized #cairo_filter_t to use with @pattern.
  *
  * Possibly optimize the filter to a simpler value depending on transformation
+ *
+ * Returns: the optimized #cairo_filter_t to use with @pattern.
  **/
 cairo_filter_t
 _cairo_pattern_analyze_filter (const cairo_pattern_t *pattern)
@@ -3863,8 +3921,8 @@
     return CAIRO_STATUS_SUCCESS;
 }
 
-static unsigned long
-_cairo_solid_pattern_hash (unsigned long hash,
+static uintptr_t
+_cairo_solid_pattern_hash (uintptr_t hash,
 			   const cairo_solid_pattern_t *solid)
 {
     hash = _cairo_hash_bytes (hash, &solid->color, sizeof (solid->color));
@@ -3872,8 +3930,8 @@
     return hash;
 }
 
-static unsigned long
-_cairo_gradient_color_stops_hash (unsigned long hash,
+static uintptr_t
+_cairo_gradient_color_stops_hash (uintptr_t hash,
 				  const cairo_gradient_pattern_t *gradient)
 {
     unsigned int n;
@@ -3894,8 +3952,8 @@
     return hash;
 }
 
-unsigned long
-_cairo_linear_pattern_hash (unsigned long hash,
+uintptr_t
+_cairo_linear_pattern_hash (uintptr_t hash,
 			    const cairo_linear_pattern_t *linear)
 {
     hash = _cairo_hash_bytes (hash, &linear->pd1, sizeof (linear->pd1));
@@ -3904,8 +3962,8 @@
     return _cairo_gradient_color_stops_hash (hash, &linear->base);
 }
 
-unsigned long
-_cairo_radial_pattern_hash (unsigned long hash,
+uintptr_t
+_cairo_radial_pattern_hash (uintptr_t hash,
 			    const cairo_radial_pattern_t *radial)
 {
     hash = _cairo_hash_bytes (hash, &radial->cd1.center, sizeof (radial->cd1.center));
@@ -3916,8 +3974,8 @@
     return _cairo_gradient_color_stops_hash (hash, &radial->base);
 }
 
-static unsigned long
-_cairo_mesh_pattern_hash (unsigned long hash, const cairo_mesh_pattern_t *mesh)
+static uintptr_t
+_cairo_mesh_pattern_hash (uintptr_t hash, const cairo_mesh_pattern_t *mesh)
 {
     const cairo_mesh_patch_t *patch = _cairo_array_index_const (&mesh->patches, 0);
     unsigned int i, n = _cairo_array_num_elements (&mesh->patches);
@@ -3928,8 +3986,8 @@
     return hash;
 }
 
-static unsigned long
-_cairo_surface_pattern_hash (unsigned long hash,
+static uintptr_t
+_cairo_surface_pattern_hash (uintptr_t hash,
 			     const cairo_surface_pattern_t *surface)
 {
     hash ^= surface->surface->unique_id;
@@ -3937,8 +3995,8 @@
     return hash;
 }
 
-static unsigned long
-_cairo_raster_source_pattern_hash (unsigned long hash,
+static uintptr_t
+_cairo_raster_source_pattern_hash (uintptr_t hash,
 				   const cairo_raster_source_pattern_t *raster)
 {
     hash ^= (uintptr_t)raster->user_data;
@@ -3946,10 +4004,10 @@
     return hash;
 }
 
-unsigned long
+uintptr_t
 _cairo_pattern_hash (const cairo_pattern_t *pattern)
 {
-    unsigned long hash = _CAIRO_HASH_INIT_VALUE;
+    uintptr_t hash = _CAIRO_HASH_INIT_VALUE;
 
     if (pattern->status)
 	return 0;
@@ -4154,6 +4212,8 @@
  *
  * Gets the solid color for a solid color pattern.
  *
+ * Note that the color and alpha values are not premultiplied.
+ *
  * Return value: %CAIRO_STATUS_SUCCESS, or
  * %CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a solid
  * color pattern.
@@ -4236,6 +4296,8 @@
  * where n is the number returned
  * by cairo_pattern_get_color_stop_count().
  *
+ * Note that the color and alpha values are not premultiplied.
+ *
  * Return value: %CAIRO_STATUS_SUCCESS, or %CAIRO_STATUS_INVALID_INDEX
  * if @index is not valid for the given pattern.  If the pattern is
  * not a gradient pattern, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH is
@@ -4434,7 +4496,6 @@
 
     return CAIRO_STATUS_SUCCESS;
 }
-slim_hidden_def (cairo_mesh_pattern_get_patch_count);
 
 /**
  * cairo_mesh_pattern_get_path:
@@ -4522,7 +4583,6 @@
 
     return path;
 }
-slim_hidden_def (cairo_mesh_pattern_get_path);
 
 /**
  * cairo_mesh_pattern_get_corner_color_rgba:
@@ -4543,6 +4603,8 @@
  * Valid values for @corner_num are from 0 to 3 and identify the
  * corners as explained in cairo_pattern_create_mesh().
  *
+ * Note that the color and alpha values are not premultiplied.
+ *
  * Return value: %CAIRO_STATUS_SUCCESS, or %CAIRO_STATUS_INVALID_INDEX
  * if @patch_num or @corner_num is not valid for @pattern. If
  * @pattern is not a mesh pattern, %CAIRO_STATUS_PATTERN_TYPE_MISMATCH
@@ -4590,7 +4652,6 @@
 
     return CAIRO_STATUS_SUCCESS;
 }
-slim_hidden_def (cairo_mesh_pattern_get_corner_color_rgba);
 
 /**
  * cairo_mesh_pattern_get_control_point:
@@ -4655,7 +4716,6 @@
 
     return CAIRO_STATUS_SUCCESS;
 }
-slim_hidden_def (cairo_mesh_pattern_get_control_point);
 
 void
 _cairo_pattern_reset_static_data (void)