# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-ps-surface.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-ps-surface.c
--- a/gfx/cairo/cairo/src/cairo-ps-surface.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-ps-surface.c	Mon May 06 19:25:12 2024 +0000
@@ -66,18 +66,19 @@
 #include "cairo-composite-rectangles-private.h"
 #include "cairo-default-context-private.h"
 #include "cairo-error-private.h"
+#include "cairo-image-info-private.h"
 #include "cairo-image-surface-inline.h"
 #include "cairo-list-inline.h"
-#include "cairo-scaled-font-subsets-private.h"
+#include "cairo-output-stream-private.h"
 #include "cairo-paginated-private.h"
+#include "cairo-recording-surface-inline.h"
 #include "cairo-recording-surface-private.h"
+#include "cairo-scaled-font-subsets-private.h"
 #include "cairo-surface-clipper-private.h"
 #include "cairo-surface-snapshot-inline.h"
 #include "cairo-surface-subsurface-private.h"
-#include "cairo-output-stream-private.h"
+#include "cairo-tag-attributes-private.h"
 #include "cairo-type3-glyph-surface-private.h"
-#include "cairo-image-info-private.h"
-#include "cairo-tag-attributes-private.h"
 
 #include <stdio.h>
 #include <ctype.h>
@@ -102,7 +103,11 @@
 #endif
 
 #ifndef HAVE_CTIME_R
-#define ctime_r(T, BUF) ctime (T)
+static char *ctime_r(const time_t *timep, char *buf)
+{
+    (void)buf;
+    return ctime(timep);
+}
 #endif
 
 /**
@@ -114,9 +119,8 @@
  * The PostScript surface is used to render cairo graphics to Adobe
  * PostScript files and is a multi-page vector surface backend.
  *
- * The following mime types are supported: %CAIRO_MIME_TYPE_JPEG,
- * %CAIRO_MIME_TYPE_UNIQUE_ID,
- * %CAIRO_MIME_TYPE_CCITT_FAX, %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS,
+ * The following mime types are supported on source patterns:
+ * %CAIRO_MIME_TYPE_JPEG, %CAIRO_MIME_TYPE_UNIQUE_ID,
  * %CAIRO_MIME_TYPE_CCITT_FAX, %CAIRO_MIME_TYPE_CCITT_FAX_PARAMS,
  * %CAIRO_MIME_TYPE_EPS, %CAIRO_MIME_TYPE_EPS_PARAMS.
  *
@@ -144,7 +148,7 @@
  * ury]" that specifies the bounding box (in PS coordinates) of the
  * EPS graphics. The parameters are: lower left x, lower left y, upper
  * right x, upper right y. Normally the bbox data is identical to the
- * %%%BoundingBox data in the EPS file.
+ * \%\%\%BoundingBox data in the EPS file.
  *
  **/
 
@@ -172,6 +176,7 @@
 typedef struct  {
     /* input params */
     cairo_surface_t *src_surface;
+    unsigned int regions_id;
     cairo_operator_t op;
     const cairo_rectangle_int_t *src_surface_extents;
     cairo_bool_t src_surface_bounded;
@@ -213,8 +218,11 @@
 static const char *_cairo_ps_supported_mime_types[] =
 {
     CAIRO_MIME_TYPE_JPEG,
+    CAIRO_MIME_TYPE_UNIQUE_ID,
     CAIRO_MIME_TYPE_CCITT_FAX,
     CAIRO_MIME_TYPE_CCITT_FAX_PARAMS,
+    CAIRO_MIME_TYPE_EPS,
+    CAIRO_MIME_TYPE_EPS_PARAMS,
     NULL
 };
 
@@ -282,6 +290,8 @@
 
     _cairo_hash_table_remove (patterns, &surface_entry->base);
     free (surface_entry->unique_id);
+    if (_cairo_surface_is_recording (surface_entry->src_surface) && surface_entry->regions_id != 0)
+	_cairo_recording_surface_region_array_remove (surface_entry->src_surface, surface_entry->regions_id);
     cairo_surface_destroy (surface_entry->src_surface);
     free (surface_entry);
 }
@@ -312,17 +322,21 @@
 
     _cairo_output_stream_printf (surface->final_stream,
 				 "%%!PS-Adobe-3.0%s\n"
-				 "%%%%Creator: cairo %s (https://cairographics.org)\n"
-				 "%%%%CreationDate: %s"
-				 "%%%%Pages: %d\n",
+				 "%%%%Creator: cairo %s (https://cairographics.org)\n",
 				 eps_header,
-				 cairo_version_string (),
-				 ctime_r (&now, ctime_buf),
-				 surface->num_pages);
+				 cairo_version_string ());
+
+    if (!getenv ("CAIRO_DEBUG_PS_NO_DATE")) {
+	_cairo_output_stream_printf (surface->final_stream,
+				     "%%%%CreationDate: %s",
+				     ctime_r (&now, ctime_buf));
+    }
 
     _cairo_output_stream_printf (surface->final_stream,
+				 "%%%%Pages: %d\n"
 				 "%%%%DocumentData: Clean7Bit\n"
 				 "%%%%LanguageLevel: %d\n",
+				 surface->num_pages,
 				 level);
 
     if (!cairo_list_is_empty (&surface->document_media)) {
@@ -497,17 +511,6 @@
 
     _cairo_output_stream_printf (surface->final_stream,
 				 "%%%%EndProlog\n");
-
-    num_comments = _cairo_array_num_elements (&surface->dsc_setup_comments);
-    if (num_comments) {
-	comments = _cairo_array_index (&surface->dsc_setup_comments, 0);
-	for (i = 0; i < num_comments; i++) {
-	    _cairo_output_stream_printf (surface->final_stream,
-					 "%s\n", comments[i]);
-	    free (comments[i]);
-	    comments[i] = NULL;
-	}
-    }
 }
 
 static cairo_status_t
@@ -737,34 +740,6 @@
     return _cairo_output_stream_get_status (stream);
 }
 
-static cairo_int_status_t
-_cairo_ps_surface_analyze_user_font_subset (cairo_scaled_font_subset_t *font_subset,
-					    void		       *closure)
-{
-    cairo_ps_surface_t *surface = closure;
-    cairo_status_t status = CAIRO_STATUS_SUCCESS;
-    unsigned int i;
-    cairo_surface_t *type3_surface;
-
-    type3_surface = _cairo_type3_glyph_surface_create (font_subset->scaled_font,
-						       NULL,
-						       _cairo_ps_emit_imagemask,
-						       surface->font_subsets,
-						       TRUE);
-
-    for (i = 0; i < font_subset->num_glyphs; i++) {
-	status = _cairo_type3_glyph_surface_analyze_glyph (type3_surface,
-							   font_subset->glyphs[i]);
-	if (unlikely (status))
-	    break;
-
-    }
-    cairo_surface_finish (type3_surface);
-    cairo_surface_destroy (type3_surface);
-
-    return status;
-}
-
 static cairo_status_t
 _cairo_ps_surface_emit_type3_font_subset (cairo_ps_surface_t		*surface,
 					  cairo_scaled_font_subset_t	*font_subset)
@@ -931,30 +906,17 @@
 				 "%% _cairo_ps_surface_emit_font_subsets\n");
 #endif
 
-    status = _cairo_scaled_font_subsets_foreach_user (surface->font_subsets,
-						      _cairo_ps_surface_analyze_user_font_subset,
-						      surface);
-    if (unlikely (status))
-	return status;
-
     status = _cairo_scaled_font_subsets_foreach_unscaled (surface->font_subsets,
                                                           _cairo_ps_surface_emit_unscaled_font_subset,
                                                           surface);
     if (unlikely (status))
 	return status;
 
-    status = _cairo_scaled_font_subsets_foreach_scaled (surface->font_subsets,
-                                                        _cairo_ps_surface_emit_scaled_font_subset,
-                                                        surface);
-    if (unlikely (status))
-	return status;
-
-    return _cairo_scaled_font_subsets_foreach_user (surface->font_subsets,
-						    _cairo_ps_surface_emit_scaled_font_subset,
-						    surface);
+    return _cairo_scaled_font_subsets_foreach_scaled (surface->font_subsets,
+						      _cairo_ps_surface_emit_scaled_font_subset,
+						      surface);
 }
 
-
 static cairo_int_status_t
 _cairo_ps_surface_emit_forms (cairo_ps_surface_t *surface)
 {
@@ -1583,7 +1545,7 @@
  * beyond these two conditions, this function will not enforce
  * conformance of the comment with any particular specification.
  *
- * The comment string should not have a trailing newline.
+ * The comment string must not contain any newline characters.
  *
  * The DSC specifies different sections in which particular comments
  * can appear. This function provides for comments to be emitted
@@ -1764,6 +1726,17 @@
     _cairo_output_stream_printf (surface->final_stream,
 				 "%%%%BeginSetup\n");
 
+    num_comments = _cairo_array_num_elements (&surface->dsc_setup_comments);
+    if (num_comments) {
+	comments = _cairo_array_index (&surface->dsc_setup_comments, 0);
+	for (i = 0; i < num_comments; i++) {
+	    _cairo_output_stream_printf (surface->final_stream,
+					 "%s\n", comments[i]);
+	    free (comments[i]);
+	    comments[i] = NULL;
+	}
+    }
+
     status = _cairo_ps_surface_emit_font_subsets (surface);
     if (unlikely (status))
 	goto CLEANUP;
@@ -2481,6 +2454,7 @@
     unsigned char *data_compressed;
     unsigned long data_compressed_size;
     cairo_status_t status, status2;
+    cairo_status_t this_cannot_be_handled;
 
     if (use_strings)
 	string_array_stream = _base85_strings_stream_create (surface->stream);
@@ -2498,6 +2472,7 @@
 	return _cairo_output_stream_destroy (base85_stream);
     }
 
+    status = 0;
     switch (compress) {
 	case CAIRO_PS_COMPRESS_NONE:
 	    _cairo_output_stream_write (base85_stream, data, length);
@@ -2509,8 +2484,8 @@
 	    data_compressed_size = length;
 	    data_compressed = _cairo_lzw_compress ((unsigned char*)data, &data_compressed_size);
 	    if (unlikely (data_compressed == NULL)) {
-		status = _cairo_output_stream_destroy (string_array_stream);
-		status = _cairo_output_stream_destroy (base85_stream);
+		this_cannot_be_handled = _cairo_output_stream_destroy (string_array_stream);
+		this_cannot_be_handled = _cairo_output_stream_destroy (base85_stream);
 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	    }
 	    _cairo_output_stream_write (base85_stream, data_compressed, data_compressed_size);
@@ -2525,9 +2500,9 @@
 	    _cairo_output_stream_write (deflate_stream, data, length);
 	    status = _cairo_output_stream_destroy (deflate_stream);
 	    if (unlikely (status)) {
-		status2 = _cairo_output_stream_destroy (string_array_stream);
-		status2 = _cairo_output_stream_destroy (base85_stream);
-		return _cairo_output_stream_destroy (deflate_stream);
+		this_cannot_be_handled = _cairo_output_stream_destroy (string_array_stream);
+		this_cannot_be_handled = _cairo_output_stream_destroy (base85_stream);
+		return status;
 	    }
 	    break;
     }
@@ -2603,7 +2578,6 @@
 	surf = _cairo_image_surface_create_with_content (image->base.content,
 							 image->width,
 							 image->height);
-	image = (cairo_image_surface_t *) surf;
 	if (surf->status) {
 	    status = surf->status;
 	    goto bail0;
@@ -2614,6 +2588,7 @@
 				       CAIRO_OPERATOR_SOURCE, &pattern.base,
 				       NULL);
         _cairo_pattern_fini (&pattern.base);
+	image = (cairo_image_surface_t *) surf;
         if (unlikely (status))
             goto bail0;
     }
@@ -3085,9 +3060,10 @@
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     /* ensure params_string is null terminated */
-    ccitt_params_string = malloc (ccitt_params_data_len + 1);
-    memcpy (ccitt_params_string, ccitt_params_data, ccitt_params_data_len);
-    ccitt_params_string[ccitt_params_data_len] = 0;
+    ccitt_params_string = _cairo_strndup ((const char *)ccitt_params_data, ccitt_params_data_len);
+    if (unlikely (ccitt_params_string == NULL))
+	return _cairo_surface_set_error (&surface->base, CAIRO_STATUS_NO_MEMORY);
+
     status = _cairo_tag_parse_ccitt_params (ccitt_params_string, &ccitt_params);
     if (unlikely(status))
 	return status;
@@ -3270,9 +3246,10 @@
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     /* ensure params_string is null terminated */
-    params_string = malloc (eps_params_string_len + 1);
-    memcpy (params_string, eps_params_string, eps_params_string_len);
-    params_string[eps_params_string_len] = 0;
+    params_string = _cairo_strndup ((const char *)eps_params_string, eps_params_string_len);
+    if (unlikely (params_string == NULL))
+	return _cairo_surface_set_error (&surface->base, CAIRO_STATUS_NO_MEMORY);
+
     status = _cairo_tag_parse_eps_params (params_string, &eps_params);
     if (unlikely(status))
 	return status;
@@ -3317,7 +3294,11 @@
 				 eps_width,
 				 eps_height);
 
+    _cairo_output_stream_printf (surface->stream,
+				 "%%%%BeginDocument: Document%d\n",
+				 params->src_surface->unique_id);
     _cairo_output_stream_write (surface->stream, eps_data, eps_data_len);
+    _cairo_output_stream_printf (surface->stream, "%%%%EndDocument");
     _cairo_output_stream_printf (surface->stream, "\ncairo_eps_end\n");
 
     return CAIRO_STATUS_SUCCESS;
@@ -3326,6 +3307,7 @@
 static cairo_status_t
 _cairo_ps_surface_emit_recording_surface (cairo_ps_surface_t          *surface,
 					  cairo_surface_t             *recording_surface,
+					  unsigned int                 regions_id,
 					  const cairo_rectangle_int_t *recording_extents,
 					  cairo_bool_t                 subsurface)
 {
@@ -3396,6 +3378,7 @@
     }
 
     status = _cairo_recording_surface_replay_region (recording_surface,
+						     regions_id,
 						     subsurface ? recording_extents : NULL,
 						     &surface->base,
 						     CAIRO_RECORDING_REGION_NATIVE);
@@ -3548,6 +3531,9 @@
     source_entry->unique_id = unique_id;
     source_entry->id = surface->num_forms++;
     source_entry->src_surface = cairo_surface_reference (params->src_surface);
+    source_entry->regions_id = params->regions_id;
+    if (_cairo_surface_is_recording (source_entry->src_surface) && source_entry->regions_id != 0)
+	_cairo_recording_surface_region_array_reference (source_entry->src_surface, source_entry->regions_id);
     source_entry->src_surface_extents = *params->src_surface_extents;
     source_entry->src_surface_bounded = params->src_surface_bounded;
     source_entry->required_extents = *params->src_op_extents;
@@ -3680,11 +3666,13 @@
 	    cairo_surface_subsurface_t *sub = (cairo_surface_subsurface_t *) params->src_surface;
 	    status = _cairo_ps_surface_emit_recording_surface (surface,
 							       sub->target,
+							       params->regions_id,
 							       &sub->extents,
 							       TRUE);
 	} else {
 	    status = _cairo_ps_surface_emit_recording_surface (surface,
 							       params->src_surface,
+							       params->regions_id,
 							       params->src_op_extents,
 							       FALSE);
 	}
@@ -3703,11 +3691,11 @@
 
 	status = _cairo_memory_stream_destroy (surface->stream, &data, &length);
 	free (data);
+	surface->stream = old_stream;
 	if (unlikely (status))
 	    return status;
 
 	params->approx_size = length;
-	surface->stream = old_stream;
 	_cairo_pdf_operators_set_stream (&surface->pdf_operators,
 					 surface->stream);
     }
@@ -3727,6 +3715,7 @@
     cairo_output_stream_t *old_stream;
 
     params.src_surface = form->src_surface;
+    params.regions_id = form->regions_id;
     params.op = CAIRO_OPERATOR_OVER;
     params.src_surface_extents = &form->src_surface_extents;
     params.src_surface_bounded = form->src_surface_bounded;
@@ -3868,11 +3857,17 @@
     cairo_path_fixed_t path;
     cairo_emit_surface_params_t params;
     cairo_image_surface_t *image = NULL;
+    unsigned int region_id = 0;
 
     status = _cairo_pdf_operators_flush (&surface->pdf_operators);
     if (unlikely (status))
 	return status;
 
+    if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
+	cairo_surface_pattern_t *surface_pattern = (cairo_surface_pattern_t *) pattern;
+	region_id = surface_pattern->region_array_id;
+    }
+
     status = _cairo_ps_surface_acquire_source_surface_from_pattern (surface,
 								    pattern,
 								    extents,
@@ -3958,6 +3953,7 @@
     cairo_matrix_translate (&ps_p2d, x_offset, y_offset);
 
     params.src_surface = image ? &image->base : source_surface;
+    params.regions_id = image ? 0 : region_id;
     params.op = op;
     params.src_surface_extents = &src_surface_extents;
     params.src_surface_bounded = src_surface_bounded;
@@ -4012,12 +4008,18 @@
     cairo_rectangle_int_t src_op_extents;
     cairo_emit_surface_params_t params;
     cairo_extend_t extend = cairo_pattern_get_extend (pattern);
+    unsigned int region_id = 0;
 
     cairo_p2d = pattern->matrix;
     status = cairo_matrix_invert (&cairo_p2d);
     /* cairo_pattern_set_matrix ensures the matrix is invertible */
     assert (status == CAIRO_STATUS_SUCCESS);
 
+    if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
+	cairo_surface_pattern_t *surface_pattern = (cairo_surface_pattern_t *) pattern;
+	region_id = surface_pattern->region_array_id;
+    }
+
     status = _cairo_ps_surface_acquire_source_surface_from_pattern (surface,
 								    pattern,
 								    extents,
@@ -4111,6 +4113,7 @@
     old_paint_proc = surface->paint_proc;
     surface->paint_proc = TRUE;
     params.src_surface = image ? &image->base : source_surface;
+    params.regions_id = image ? 0 : region_id;
     params.op = op;
     params.src_surface_extents = &pattern_extents;
     params.src_surface_bounded = bounded;
@@ -4405,7 +4408,7 @@
 	/* no need for stitched function */
 	_cairo_ps_surface_emit_linear_colorgradient (surface, &stops[0], &stops[1]);
     } else {
-	/* multiple stops: stitch. XXX possible optimization: regulary spaced
+	/* multiple stops: stitch. XXX possible optimization: regularly spaced
 	 * stops do not require stitching. XXX */
 	_cairo_ps_surface_emit_stitched_colorgradient (surface, n_stops, stops);
     }