# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-quartz-font.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-quartz-font.c
--- a/gfx/cairo/cairo/src/cairo-quartz-font.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-quartz-font.c	Mon May 06 19:25:12 2024 +0000
@@ -44,15 +44,14 @@
 
 #include "cairo-error-private.h"
 
+//#define DEBUG /* Uncomment this to get debug messages on the console. */
 /**
  * SECTION:cairo-quartz-fonts
  * @Title: Quartz (CGFont) Fonts
- * @Short_Description: Font support via CGFont on OS X
+ * @Short_Description: Font support via Core Text on Apple operating systems.
  * @See_Also: #cairo_font_face_t
  *
- * The Quartz font backend is primarily used to render text on Apple
- * MacOS X systems.  The CGFont API is used for the internal
- * implementation of the font backend methods.
+ * Provide support for font faces via Core Text.
  **/
 
 /**
@@ -64,120 +63,36 @@
  * Since: 1.6
  **/
 
-static CFDataRef (*CGFontCopyTableForTagPtr) (CGFontRef font, uint32_t tag) = NULL;
-
-/* CreateWithFontName exists in 10.5, but not in 10.4; CreateWithName isn't public in 10.4 */
-static CGFontRef (*CGFontCreateWithFontNamePtr) (CFStringRef) = NULL;
-static CGFontRef (*CGFontCreateWithNamePtr) (const char *) = NULL;
-
-/* These aren't public before 10.5, and some have different names in 10.4 */
-static int (*CGFontGetUnitsPerEmPtr) (CGFontRef) = NULL;
-static bool (*CGFontGetGlyphAdvancesPtr) (CGFontRef, const CGGlyph[], size_t, int[]) = NULL;
-static bool (*CGFontGetGlyphBBoxesPtr) (CGFontRef, const CGGlyph[], size_t, CGRect[]) = NULL;
-static CGRect (*CGFontGetFontBBoxPtr) (CGFontRef) = NULL;
-
-/* Not public, but present */
-static void (*CGFontGetGlyphsForUnicharsPtr) (CGFontRef, const UniChar[], const CGGlyph[], size_t) = NULL;
-static void (*CGContextSetAllowsFontSmoothingPtr) (CGContextRef, bool) = NULL;
+/* These are private functions */
 static bool (*CGContextGetAllowsFontSmoothingPtr) (CGContextRef) = NULL;
-
-/* Not public in the least bit */
-static CGPathRef (*CGFontGetGlyphPathPtr) (CGFontRef fontRef, CGAffineTransform *textTransform, int unknown, CGGlyph glyph) = NULL;
-
-/* CTFontCreateWithGraphicsFont is not available until 10.5 */
-typedef const struct __CTFontDescriptor *CTFontDescriptorRef;
-static CTFontRef (*CTFontCreateWithGraphicsFontPtr) (CGFontRef, CGFloat, const CGAffineTransform*, CTFontDescriptorRef) = NULL;
-static CGPathRef (*CTFontCreatePathForGlyphPtr) (CTFontRef, CGGlyph, CGAffineTransform *) = NULL;
-static double (*CTFontGetAdvancesForGlyphsPtr) (CTFontRef, CTFontOrientation, const CGGlyph*, CGSize *, CFIndex) = NULL;
-static CGRect (*CTFontGetBoundingRectsForGlyphsPtr) (CTFontRef, CTFontOrientation, const CGGlyph*, CGRect *, CFIndex) = NULL;
-
-/* CGFontGetHMetrics isn't public, but the other functions are public/present in 10.5 */
-typedef struct {
-    int ascent;
-    int descent;
-    int leading;
-} quartz_CGFontMetrics;
-static quartz_CGFontMetrics* (*CGFontGetHMetricsPtr) (CGFontRef fontRef) = NULL;
-static int (*CGFontGetAscentPtr) (CGFontRef fontRef) = NULL;
-static int (*CGFontGetDescentPtr) (CGFontRef fontRef) = NULL;
-static int (*CGFontGetLeadingPtr) (CGFontRef fontRef) = NULL;
-
-#ifdef CAIRO_HAS_QUARTZ_ATSUFONTID
-/* Not public anymore in 64-bits nor in 10.7 */
-static ATSFontRef (*FMGetATSFontRefFromFontPtr) (ATSUFontID iFont) = NULL;
-#endif /* CAIRO_HAS_QUARTZ_ATSUFONTID */
+static ATSFontRef (*FMGetATSFontRefFromFontPtr) (FMFont iFont) = NULL;
 
 static cairo_bool_t _cairo_quartz_font_symbol_lookup_done = FALSE;
-static cairo_bool_t _cairo_quartz_font_symbols_present = FALSE;
+/* Cairo's transformations assume a unit-scaled font. */
+static const CGFloat font_scale = 1.0;
 
 /* Defined in 10.11 */
 #define CGGLYPH_MAX ((CGGlyph) 0xFFFE) /* kCGFontIndexMax */
 #define CGGLYPH_INVALID ((CGGlyph) 0xFFFF) /* kCGFontIndexInvalid */
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1080
+#define FONT_ORIENTATION_HORIZONTAL kCTFontHorizontalOrientation
+#define FONT_COLOR_GLYPHS kCTFontTraitColorGlyphs
+#else
+#define FONT_ORIENTATION_HORIZONTAL kCTFontOrientationHorizontal
+#define FONT_COLOR_GLYPHS kCTFontColorGlyphsTrait
+#endif
+
 static void
 quartz_font_ensure_symbols(void)
 {
     if (_cairo_quartz_font_symbol_lookup_done)
 	return;
 
-    CGFontCopyTableForTagPtr = dlsym(RTLD_DEFAULT, "CGFontCopyTableForTag");
-
-    /* Look for the 10.5 versions first */
-    CGFontGetGlyphBBoxesPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphBBoxes");
-    if (!CGFontGetGlyphBBoxesPtr)
-	CGFontGetGlyphBBoxesPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphBoundingBoxes");
-
-    CGFontGetGlyphsForUnicharsPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphsForUnichars");
-    if (!CGFontGetGlyphsForUnicharsPtr)
-	CGFontGetGlyphsForUnicharsPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphsForUnicodes");
-
-    CGFontGetFontBBoxPtr = dlsym(RTLD_DEFAULT, "CGFontGetFontBBox");
-
-    /* We just need one of these two */
-    CGFontCreateWithFontNamePtr = dlsym(RTLD_DEFAULT, "CGFontCreateWithFontName");
-    CGFontCreateWithNamePtr = dlsym(RTLD_DEFAULT, "CGFontCreateWithName");
-
-    /* These have the same name in 10.4 and 10.5 */
-    CGFontGetUnitsPerEmPtr = dlsym(RTLD_DEFAULT, "CGFontGetUnitsPerEm");
-    CGFontGetGlyphAdvancesPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphAdvances");
+    CGContextGetAllowsFontSmoothingPtr =
+	dlsym (RTLD_DEFAULT, "CGContextGetAllowsFontSmoothing");
 
-    /*
-     * Some Tiger systems have a partial version of CoreText, which
-     * has incompatible signatures: CTFontCreateWithGraphicsFont
-     * accepts a double for the size argument even on i386 and all
-     * functions omit the CTFontOrientation arguments. Since the 10.4
-     * CoreText library does not provide the CTFontCreatePathForGlyph
-     * symbol, use it to determine whether to use CoreText at all.
-     */
-    CTFontCreatePathForGlyphPtr = dlsym(RTLD_DEFAULT, "CTFontCreatePathForGlyph");
-    if (CTFontCreatePathForGlyphPtr) {
-	CTFontCreateWithGraphicsFontPtr = dlsym(RTLD_DEFAULT, "CTFontCreateWithGraphicsFont");
-	CTFontGetAdvancesForGlyphsPtr = dlsym(RTLD_DEFAULT, "CTFontGetAdvancesForGlyphs");
-	CTFontGetBoundingRectsForGlyphsPtr = dlsym(RTLD_DEFAULT, "CTFontGetBoundingRectsForGlyphs");
-    } else {
-	CGFontGetGlyphPathPtr = dlsym(RTLD_DEFAULT, "CGFontGetGlyphPath");
-    }
-
-    CGFontGetHMetricsPtr = dlsym(RTLD_DEFAULT, "CGFontGetHMetrics");
-    CGFontGetAscentPtr = dlsym(RTLD_DEFAULT, "CGFontGetAscent");
-    CGFontGetDescentPtr = dlsym(RTLD_DEFAULT, "CGFontGetDescent");
-    CGFontGetLeadingPtr = dlsym(RTLD_DEFAULT, "CGFontGetLeading");
-
-    CGContextGetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, "CGContextGetAllowsFontSmoothing");
-    CGContextSetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, "CGContextSetAllowsFontSmoothing");
-
-#ifdef CAIRO_HAS_QUARTZ_ATSUFONTID
     FMGetATSFontRefFromFontPtr = dlsym(RTLD_DEFAULT, "FMGetATSFontRefFromFont");
-#endif /* CAIRO_HAS_QUARTZ_ATSUFONTID */
-
-    if ((CGFontCreateWithFontNamePtr || CGFontCreateWithNamePtr) &&
-	CGFontGetGlyphBBoxesPtr &&
-	CGFontGetGlyphsForUnicharsPtr &&
-	CGFontGetUnitsPerEmPtr &&
-	CGFontGetGlyphAdvancesPtr &&
-	((CTFontCreateWithGraphicsFontPtr && CTFontCreatePathForGlyphPtr) || CGFontGetGlyphPathPtr) &&
-	(CGFontGetHMetricsPtr || (CGFontGetAscentPtr && CGFontGetDescentPtr && CGFontGetLeadingPtr)))
-	_cairo_quartz_font_symbols_present = TRUE;
 
     _cairo_quartz_font_symbol_lookup_done = TRUE;
 }
@@ -187,13 +102,13 @@
 
 struct _cairo_quartz_scaled_font {
     cairo_scaled_font_t base;
+    CTFontRef ctFont;
 };
 
 struct _cairo_quartz_font_face {
     cairo_font_face_t base;
 
     CGFontRef cgFont;
-    CTFontRef ctFont;
 };
 
 /*
@@ -206,14 +121,10 @@
 {
     const char *family;
     char *full_name;
-    CFStringRef cgFontName = NULL;
+    CFStringRef FontName = NULL;
     CGFontRef cgFont = NULL;
     int loop;
 
-    quartz_font_ensure_symbols();
-    if (! _cairo_quartz_font_symbols_present)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-
     family = toy_face->family;
     full_name = _cairo_malloc (strlen (family) + 64); // give us a bit of room to tack on Bold, Oblique, etc.
     /* handle CSS-ish faces */
@@ -240,23 +151,19 @@
 
 	if (loop < 3 && (loop & 1) == 0) {
 	    if (toy_face->weight == CAIRO_FONT_WEIGHT_BOLD)
-		strcat (full_name, " Bold");
+		strcat (full_name, "-Bold");
 	}
 
 	if (loop < 3 && (loop & 2) == 0) {
 	    if (toy_face->slant == CAIRO_FONT_SLANT_ITALIC)
-		strcat (full_name, " Italic");
+		strcat (full_name, "-Italic");
 	    else if (toy_face->slant == CAIRO_FONT_SLANT_OBLIQUE)
-		strcat (full_name, " Oblique");
+		strcat (full_name, "-Oblique");
 	}
 
-	if (CGFontCreateWithFontNamePtr) {
-	    cgFontName = CFStringCreateWithCString (NULL, full_name, kCFStringEncodingASCII);
-	    cgFont = CGFontCreateWithFontNamePtr (cgFontName);
-	    CFRelease (cgFontName);
-	} else {
-	    cgFont = CGFontCreateWithNamePtr (full_name);
-	}
+	FontName = CFStringCreateWithCString (NULL, full_name, kCFStringEncodingASCII);
+	cgFont = CGFontCreateWithFontName (FontName);
+	CFRelease (FontName);
 
 	if (cgFont)
 	    break;
@@ -268,7 +175,7 @@
     }
 
     *font_face = cairo_quartz_font_face_create_for_cgfont (cgFont);
-    CGFontRelease (cgFont);
+    CFRelease (cgFont);
 
     return CAIRO_STATUS_SUCCESS;
 }
@@ -278,15 +185,57 @@
 {
     cairo_quartz_font_face_t *font_face = (cairo_quartz_font_face_t*) abstract_face;
 
-    if (font_face->ctFont)
-	CFRelease (font_face->ctFont);
-
     CGFontRelease (font_face->cgFont);
     return TRUE;
 }
 
 static const cairo_scaled_font_backend_t _cairo_quartz_scaled_font_backend;
 
+#ifdef DEBUG
+static void
+_cairo_quartz_debug_font_characteristics (cairo_quartz_scaled_font_t *font)
+{
+    CGRect ct_bbox = CTFontGetBoundingBox (font->ctFont);
+    CGFloat ct_ascent = CTFontGetAscent (font->ctFont);
+    CGFloat ct_descent = CTFontGetDescent (font->ctFont);
+    CGFloat ct_leading = CTFontGetLeading (font->ctFont);
+    CGFloat ct_capheight = CTFontGetCapHeight (font->ctFont);
+    CGFloat ct_xheight = CTFontGetXHeight (font->ctFont);
+    char chars[] = "ymMW";
+    CGGlyph glyphs[4];
+    UniChar *utf16 = NULL;
+    CGSize ct_advances[4];
+    CGRect ct_gbbox[4], ct_gobox[4], ct_rbbox, ct_robox;
+    double ct_radvance;
+    int converted;
+    cairo_status_t rv;
+
+    rv = _cairo_utf8_to_utf16 (chars, 4, &utf16, &converted);
+    if (rv) return;
+    CTFontGetGlyphsForCharacters (font->ctFont, utf16, glyphs, 4);
+    free (utf16);
+    ct_rbbox = CTFontGetBoundingRectsForGlyphs (font->ctFont, FONT_ORIENTATION_HORIZONTAL, glyphs, ct_gbbox, 4);
+    ct_robox = CTFontGetOpticalBoundsForGlyphs (font->ctFont, glyphs, ct_gobox, 4, 0);
+    ct_radvance = CTFontGetAdvancesForGlyphs (font->ctFont, FONT_ORIENTATION_HORIZONTAL, glyphs, ct_advances, 4);
+
+    fprintf (stderr, "\nCTFont Bounding Box: %f %f %f %f\nAscent %f Descent %f Leading %f Cap Height %f X-Height %f\n",
+	     ct_bbox.origin.x, ct_bbox.origin.y, ct_bbox.size.width, ct_bbox.size.height, ct_ascent, ct_descent,
+	     ct_leading, ct_capheight, ct_xheight);
+    fprintf (stderr, "CTFont string\n\t bounding box %f %f %f %f advance %f\n\toptical box %f %f %f %f\n\n",
+	     ct_rbbox.origin.x, ct_rbbox.origin.y, ct_rbbox.size.width, ct_rbbox.size.height, ct_radvance,
+	     ct_robox.origin.x, ct_robox.origin.y, ct_robox.size.width, ct_robox.size.height);
+    for (int i = 0; i < 4; ++i)
+    {
+	fprintf (stderr, "Character %c\n", chars[i]);
+	fprintf (stderr, "\tbox %f %f %f %f\n\toptical %f %f %f %f advance %f %f\n",
+		 ct_gbbox[i].origin.x, ct_gbbox[i].origin.y, ct_gbbox[i].size.width, ct_gbbox[i].size.height,
+		 ct_advances[i].width, ct_advances[i].height,
+		 ct_gobox[i].origin.x, ct_gobox[i].origin.y, ct_gobox[i].size.width, ct_gobox[i].size.height);
+    }
+    fprintf (stderr, "\n");
+}
+#endif
+
 static cairo_status_t
 _cairo_quartz_font_face_scaled_font_create (void *abstract_face,
 					    const cairo_matrix_t *font_matrix,
@@ -298,13 +247,9 @@
     cairo_quartz_scaled_font_t *font = NULL;
     cairo_status_t status;
     cairo_font_extents_t fs_metrics;
-    double ems;
+    CTFontRef ctFont;
     CGRect bbox;
 
-    quartz_font_ensure_symbols();
-    if (!_cairo_quartz_font_symbols_present)
-	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-
     font = _cairo_malloc (sizeof(cairo_quartz_scaled_font_t));
     if (font == NULL)
 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
@@ -317,48 +262,29 @@
     if (status)
 	goto FINISH;
 
-    ems = CGFontGetUnitsPerEmPtr (font_face->cgFont);
-
+    ctFont = CTFontCreateWithGraphicsFont (font_face->cgFont, font_scale, NULL, NULL);
     /* initialize metrics */
-    if (CGFontGetFontBBoxPtr && CGFontGetAscentPtr) {
-	fs_metrics.ascent = (CGFontGetAscentPtr (font_face->cgFont) / ems);
-	fs_metrics.descent = - (CGFontGetDescentPtr (font_face->cgFont) / ems);
-	fs_metrics.height = fs_metrics.ascent + fs_metrics.descent +
-	    (CGFontGetLeadingPtr (font_face->cgFont) / ems);
-
-	bbox = CGFontGetFontBBoxPtr (font_face->cgFont);
-	fs_metrics.max_x_advance = CGRectGetMaxX(bbox) / ems;
-	fs_metrics.max_y_advance = 0.0;
-    } else {
-	CGGlyph wGlyph;
-	UniChar u;
-
-	quartz_CGFontMetrics *m;
-	m = CGFontGetHMetricsPtr (font_face->cgFont);
+    fs_metrics.ascent = CTFontGetAscent (ctFont);
+    fs_metrics.descent = CTFontGetDescent (ctFont);
+    fs_metrics.height = fs_metrics.ascent + fs_metrics.descent +
+	CTFontGetLeading (ctFont);
 
-	/* On OX 10.4, GetHMetricsPtr sometimes returns NULL for unknown reasons */
-	if (!m) {
-	    status = _cairo_error(CAIRO_STATUS_NULL_POINTER);
-	    goto FINISH;
-	}
-
-	fs_metrics.ascent = (m->ascent / ems);
-	fs_metrics.descent = - (m->descent / ems);
-	fs_metrics.height = fs_metrics.ascent + fs_metrics.descent + (m->leading / ems);
+    bbox = CTFontGetBoundingBox (ctFont);
+    fs_metrics.max_x_advance = CGRectGetMaxX(bbox);
+    fs_metrics.max_y_advance = 0.0;
+    font->ctFont = CFRetain (ctFont);
+    status = _cairo_scaled_font_set_metrics (&font->base, &fs_metrics);
+#ifdef DEBUG
+    {
+	CFStringRef fontFullName = CTFontCopyFullName (ctFont);
+	const char* font_full_name = CFStringGetCStringPtr(fontFullName, kCFStringEncodingUTF8);
 
-	/* We kind of have to guess here; W's big, right? */
-	u = (UniChar) 'W';
-	CGFontGetGlyphsForUnicharsPtr (font_face->cgFont, &u, &wGlyph, 1);
-	if (wGlyph && CGFontGetGlyphBBoxesPtr (font_face->cgFont, &wGlyph, 1, &bbox)) {
-	    fs_metrics.max_x_advance = CGRectGetMaxX(bbox) / ems;
-	    fs_metrics.max_y_advance = 0.0;
-	} else {
-	    fs_metrics.max_x_advance = 0.0;
-	    fs_metrics.max_y_advance = 0.0;
-	}
+	fprintf (stderr, "Create scaled font %s with scale %f ascent %f, descent %f, height %f, x-advance %f\n",
+		 font_full_name, fs_metrics.ascent, fs_metrics.descent, fs_metrics.height,
+		 fs_metrics.max_x_advance);
+	_cairo_quartz_debug_font_characteristics (font);
     }
-
-    status = _cairo_scaled_font_set_metrics (&font->base, &fs_metrics);
+#endif
 
 FINISH:
     if (status != CAIRO_STATUS_SUCCESS) {
@@ -377,6 +303,23 @@
     _cairo_quartz_font_face_scaled_font_create
 };
 
+static inline cairo_quartz_font_face_t*
+_cairo_quartz_font_face_create ()
+{
+    cairo_quartz_font_face_t *font_face =
+	_cairo_malloc (sizeof (cairo_quartz_font_face_t));
+
+    if (!font_face) {
+	cairo_status_t ignore_status;
+	ignore_status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	return (cairo_quartz_font_face_t *)&_cairo_font_face_nil;
+    }
+
+    _cairo_font_face_init (&font_face->base, &_cairo_quartz_font_face_backend);
+
+    return font_face;
+}
+
 /**
  * cairo_quartz_font_face_create_for_cgfont:
  * @font: a #CGFontRef obtained through a method external to cairo.
@@ -393,26 +336,13 @@
 cairo_font_face_t *
 cairo_quartz_font_face_create_for_cgfont (CGFontRef font)
 {
-    cairo_quartz_font_face_t *font_face;
-
-    quartz_font_ensure_symbols();
+    cairo_quartz_font_face_t* font_face = _cairo_quartz_font_face_create ();
 
-    font_face = _cairo_malloc (sizeof (cairo_quartz_font_face_t));
-    if (!font_face) {
-	cairo_status_t ignore_status;
-	ignore_status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	return (cairo_font_face_t *)&_cairo_font_face_nil;
-    }
+    if (cairo_font_face_status (&font_face->base))
+	return &font_face->base;
 
     font_face->cgFont = CGFontRetain (font);
 
-    if (CTFontCreateWithGraphicsFontPtr)
-	font_face->ctFont = CTFontCreateWithGraphicsFontPtr (font, 1.0, NULL, NULL);
-    else
-	font_face->ctFont = NULL;
-
-    _cairo_font_face_init (&font_face->base, &_cairo_quartz_font_face_backend);
-
     return &font_face->base;
 }
 
@@ -432,6 +362,8 @@
 static void
 _cairo_quartz_scaled_font_fini(void *abstract_font)
 {
+    cairo_quartz_scaled_font_t* font = (cairo_quartz_scaled_font_t*)abstract_font;
+    CFRelease (font->ctFont);
 }
 
 static inline CGGlyph
@@ -446,67 +378,30 @@
 {
     cairo_int_status_t status = CAIRO_STATUS_SUCCESS;
 
-    cairo_quartz_font_face_t *font_face = _cairo_quartz_scaled_to_face(font);
     cairo_text_extents_t extents = {0, 0, 0, 0, 0, 0};
     CGGlyph glyph = _cairo_quartz_scaled_glyph_index (scaled_glyph);
-    int advance;
+    CGSize advance;
     CGRect bbox;
     double xmin, ymin, xmax, ymax;
 
     if (unlikely (glyph == CGGLYPH_INVALID))
 	goto FAIL;
 
-    if (font_face->ctFont) {
-	CGSize advanceSize;
-	CTFontGetBoundingRectsForGlyphsPtr (font_face->ctFont,
-					    kCTFontOrientationDefault,
-					    &glyph, &bbox, 1);
-
-	CTFontGetAdvancesForGlyphsPtr (font_face->ctFont,
-				       kCTFontOrientationDefault,
-				       &glyph, &advanceSize, 1);
-
-	extents.x_advance = advanceSize.width;
-	extents.y_advance = advanceSize.height;
-    } else if (CGFontGetGlyphAdvancesPtr (font_face->cgFont, &glyph, 1, &advance) &&
-	       CGFontGetGlyphBBoxesPtr (font_face->cgFont, &glyph, 1, &bbox)) {
-	double emscale = CGFontGetUnitsPerEmPtr (font_face->cgFont);
-
-	/* broken fonts like Al Bayan return incorrect bounds for some null
-	 * characters,see https://bugzilla.mozilla.org/show_bug.cgi?id=534260 */
-	if (unlikely (bbox.origin.x == -32767 &&
-		      bbox.origin.y == -32767 &&
-		      bbox.size.width == 65534 &&
-		      bbox.size.height == 65534)) {
-	    bbox.origin.x = bbox.origin.y = 0;
-	    bbox.size.width = bbox.size.height = 0;
-	}
+    CTFontGetAdvancesForGlyphs (font->ctFont, FONT_ORIENTATION_HORIZONTAL, &glyph, &advance, 1);
+    CTFontGetBoundingRectsForGlyphs (font->ctFont, FONT_ORIENTATION_HORIZONTAL, &glyph, &bbox, 1);
+    /* broken fonts like Al Bayan return incorrect bounds for some null characters,
+       see https://bugzilla.mozilla.org/show_bug.cgi?id=534260 */
+    if (unlikely (bbox.origin.x == -32767 &&
+                  bbox.origin.y == -32767 &&
+                  bbox.size.width == 65534 &&
+                  bbox.size.height == 65534)) {
+        bbox.origin.x = bbox.origin.y = 0;
+        bbox.size.width = bbox.size.height = 0;
+    }
 
-	bbox = CGRectMake (bbox.origin.x / emscale,
-			   bbox.origin.y / emscale,
-			   bbox.size.width / emscale,
-			   bbox.size.height / emscale);
-
-	extents.x_advance = advance / emscale;
-	extents.y_advance = 0.0;
-    } else {
-	goto FAIL;
-    };
-
-    /* Should we want to always integer-align glyph extents, we can do so in this way */
-#if 0
-    {
-	CGAffineTransform textMatrix;
-	textMatrix = CGAffineTransformMake (font->base.scale.xx,
-					    -font->base.scale.yx,
-					    -font->base.scale.xy,
-					    font->base.scale.yy,
-					    0.0f, 0.0f);
-
-	bbox = CGRectApplyAffineTransform (bbox, textMatrix);
-	bbox = CGRectIntegral (bbox);
-	bbox = CGRectApplyAffineTransform (bbox, CGAffineTransformInvert (textMatrix));
-    }
+#ifdef DEBUG
+    fprintf (stderr, "[0x%04x] bbox: x %f y %f width %f height %f\n", glyph,
+	     bbox.origin.x, bbox.origin.y, bbox.size.width, bbox.size.height);
 #endif
 
     xmin = CGRectGetMinX(bbox);
@@ -518,10 +413,17 @@
     extents.y_bearing = - ymax;
     extents.width = xmax - xmin;
     extents.height = ymax - ymin;
+/* At the necessary 1.0pt ctFont size some glyphs get a reduced
+ * advance that causes overlaps when scaled up. We can avoid that by
+ * using the width instead if it's wider. Since cairo doesn't support
+ * vertical font layout we don't do the same for y_advance.
+ */
+    extents.x_advance = MAX(extents.width, advance.width);
+    extents.y_advance = advance.height;
 
-#if 0
-    fprintf (stderr, "[0x%04x] extents: bearings: %f %f dim: %f %f adv: %f\n\n", glyph,
-	     extents.x_bearing, extents.y_bearing, extents.width, extents.height, extents.x_advance);
+#ifdef DEBUG
+    fprintf (stderr, "[0x%04x] extents: bearings: %f %f dim: %f %f adv: %f %f\n\n", glyph,
+	     extents.x_bearing, extents.y_bearing, extents.width, extents.height, extents.x_advance, extents.y_advance);
 #endif
 
   FAIL:
@@ -577,7 +479,7 @@
 						 _cairo_fixed_from_double(el->points[1].y),
 						 _cairo_fixed_from_double(el->points[2].x),
 						 _cairo_fixed_from_double(el->points[2].y));
-	    assert(!status);	    
+	    assert(!status);
 	    break;
 	case kCGPathElementCloseSubpath:
 	    status = _cairo_path_fixed_close_path (path);
@@ -590,7 +492,6 @@
 _cairo_quartz_init_glyph_path (cairo_quartz_scaled_font_t *font,
 			       cairo_scaled_glyph_t *scaled_glyph)
 {
-    cairo_quartz_font_face_t *font_face = _cairo_quartz_scaled_to_face(font);
     CGGlyph glyph = _cairo_quartz_scaled_glyph_index (scaled_glyph);
     CGAffineTransform textMatrix;
     CGPathRef glyphPath;
@@ -608,11 +509,7 @@
 					-font->base.scale.yy,
 					0, 0);
 
-    if (font_face->ctFont) {
-	glyphPath = CTFontCreatePathForGlyphPtr (font_face->ctFont, glyph, &textMatrix);
-    } else {
-	glyphPath = CGFontGetGlyphPathPtr (font_face->cgFont, &textMatrix, 0, glyph);
-    }
+    glyphPath = CTFontCreatePathForGlyph (font->ctFont, glyph, &textMatrix);
 
     if (!glyphPath)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
@@ -632,30 +529,42 @@
     return CAIRO_STATUS_SUCCESS;
 }
 
+static cairo_bool_t
+_cairo_quartz_font_has_color_glyphs (void *abstract_font)
+{
+    cairo_quartz_scaled_font_t *face = (cairo_quartz_scaled_font_t*)abstract_font;
+    CTFontSymbolicTraits traits = CTFontGetSymbolicTraits (face->ctFont);
+    return traits & FONT_COLOR_GLYPHS;
+}
+
 static cairo_int_status_t
 _cairo_quartz_init_glyph_surface (cairo_quartz_scaled_font_t *font,
-				  cairo_scaled_glyph_t *scaled_glyph)
+				  cairo_scaled_glyph_t *scaled_glyph,
+				  cairo_scaled_glyph_info_t info,
+				 const cairo_color_t *fg_color)
 {
     cairo_int_status_t status = CAIRO_STATUS_SUCCESS;
-
-    cairo_quartz_font_face_t *font_face = _cairo_quartz_scaled_to_face(font);
-
     cairo_image_surface_t *surface = NULL;
 
     CGGlyph glyph = _cairo_quartz_scaled_glyph_index (scaled_glyph);
-
-    int advance;
-    CGRect bbox;
+    cairo_text_extents_t metrics = scaled_glyph->fs_metrics;
+    CGRect bbox = CGRectMake (metrics.x_bearing, -(metrics.y_bearing + metrics.height),
+			      metrics.width, metrics.height);
     double width, height;
-    double emscale = CGFontGetUnitsPerEmPtr (font_face->cgFont);
 
-    CGContextRef cgContext = NULL;
     CGAffineTransform textMatrix;
     CGRect glyphRect, glyphRectInt;
     CGPoint glyphOrigin;
+    cairo_bool_t is_color = info & CAIRO_SCALED_GLYPH_INFO_COLOR_SURFACE;
+    cairo_format_t format =  is_color ? CAIRO_FORMAT_ARGB32 : CAIRO_FORMAT_A8;
 
-    //fprintf (stderr, "scaled_glyph: %p surface: %p\n", scaled_glyph, scaled_glyph->surface);
-
+#ifdef DEBUG
+    fprintf (stderr, "[0x%04x] bearing: %f %f width %f height %f advances %f %f\n",
+	     glyph, metrics.x_bearing, metrics.y_bearing, metrics.width, metrics.height,
+	     metrics.x_advance, metrics.y_advance);
+    fprintf (stderr, "[0x%04x] bounds: origin %f %f, size %f %f\n", glyph, bbox.origin.x,
+	     bbox.origin.y, bbox.size.width, bbox.size.height);
+#endif
     /* Create blank 2x2 image if we don't have this character.
      * Maybe we should draw a better missing-glyph slug or something,
      * but this is ok for now.
@@ -672,31 +581,33 @@
 	return CAIRO_STATUS_SUCCESS;
     }
 
-    if (!CGFontGetGlyphAdvancesPtr (font_face->cgFont, &glyph, 1, &advance) ||
-	!CGFontGetGlyphBBoxesPtr (font_face->cgFont, &glyph, 1, &bbox))
-    {
+/* Note: Certain opentype color fonts have the ability to provide a
+ * mixture of color and not-color glyphs. The Core Text API doesn't
+ * expose a way to query individual glyphs and at the level that that
+ * API is written it's not supposed to matter. The following code will
+ * cheerfully render any glyph requested onto the image surface. If
+ * the font is capable of color and
+ * COLOR_SCALED_GLYPH_INFO_COLOR_SURFACE is set then you get back a
+ * CAIRO_FORMAT_ARGB32 surface. If a foreground color is provided then
+ * the glyph will be drawn in that color, otherwise it will be black.
+ */
+    if (unlikely (is_color && ! _cairo_quartz_font_has_color_glyphs (font)))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
-    }
 
     /* scale(1,-1) * font->base.scale * scale(1,-1) */
     textMatrix = CGAffineTransformMake (font->base.scale.xx,
 					-font->base.scale.yx,
 					-font->base.scale.xy,
 					font->base.scale.yy,
-					0, -0);
-    glyphRect = CGRectMake (bbox.origin.x / emscale,
-			    bbox.origin.y / emscale,
-			    bbox.size.width / emscale,
-			    bbox.size.height / emscale);
-
-    glyphRect = CGRectApplyAffineTransform (glyphRect, textMatrix);
+					0, 0);
+    glyphRect = CGRectApplyAffineTransform (bbox, textMatrix);
 
     /* Round the rectangle outwards, so that we don't have to deal
      * with non-integer-pixel origins or dimensions.
      */
     glyphRectInt = CGRectIntegral (glyphRect);
 
-#if 0
+#ifdef DEBUG
     fprintf (stderr, "glyphRect[o]: %f %f %f %f\n",
 	     glyphRect.origin.x, glyphRect.origin.y, glyphRect.size.width, glyphRect.size.height);
     fprintf (stderr, "glyphRectInt: %f %f %f %f\n",
@@ -705,70 +616,50 @@
 
     glyphOrigin = glyphRectInt.origin;
 
-    //textMatrix = CGAffineTransformConcat (textMatrix, CGAffineTransformInvert (ctm));
-
     width = glyphRectInt.size.width;
     height = glyphRectInt.size.height;
 
-    //fprintf (stderr, "glyphRect[n]: %f %f %f %f\n", glyphRect.origin.x, glyphRect.origin.y, glyphRect.size.width, glyphRect.size.height);
-
-    surface = (cairo_image_surface_t*) cairo_image_surface_create (CAIRO_FORMAT_A8, width, height);
+    surface = (cairo_image_surface_t*) cairo_image_surface_create (format, width, height);
     if (surface->base.status)
 	return surface->base.status;
 
     if (surface->width != 0 && surface->height != 0) {
-	cgContext = CGBitmapContextCreate (surface->data,
-					   surface->width,
-					   surface->height,
-					   8,
-					   surface->stride,
-					   NULL,
-					   kCGImageAlphaOnly);
+	CGColorSpaceRef colorspace = is_color ? CGColorSpaceCreateDeviceRGB () : NULL;
+	CGBitmapInfo bitinfo = is_color ? kCGBitmapByteOrder32Host | kCGImageAlphaPremultipliedFirst : kCGImageAlphaOnly;
+
+	CGContextRef cgContext = CGBitmapContextCreate (surface->data,
+							surface->width,
+							surface->height,
+							8,
+							surface->stride,
+							colorspace,
+							bitinfo);
 
 	if (cgContext == NULL) {
 	    cairo_surface_destroy (&surface->base);
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 	}
 
-	CGContextSetFont (cgContext, font_face->cgFont);
-	CGContextSetFontSize (cgContext, 1.0);
-	CGContextSetTextMatrix (cgContext, textMatrix);
-
-	switch (font->base.options.antialias) {
-	case CAIRO_ANTIALIAS_SUBPIXEL:
-	case CAIRO_ANTIALIAS_BEST:
-	    CGContextSetShouldAntialias (cgContext, TRUE);
-	    CGContextSetShouldSmoothFonts (cgContext, TRUE);
-	    if (CGContextSetAllowsFontSmoothingPtr &&
-		!CGContextGetAllowsFontSmoothingPtr (cgContext))
-		CGContextSetAllowsFontSmoothingPtr (cgContext, TRUE);
-	    break;
-	case CAIRO_ANTIALIAS_NONE:
-	    CGContextSetShouldAntialias (cgContext, FALSE);
-	    break;
-	case CAIRO_ANTIALIAS_GRAY:
-	case CAIRO_ANTIALIAS_GOOD:
-	case CAIRO_ANTIALIAS_FAST:
-	    CGContextSetShouldAntialias (cgContext, TRUE);
-	    CGContextSetShouldSmoothFonts (cgContext, FALSE);
-	    break;
-	case CAIRO_ANTIALIAS_DEFAULT:
-	default:
-	    /* Don't do anything */
-	    break;
-	}
-
+	if (fg_color)
+	    CGContextSetRGBFillColor (cgContext, fg_color->red, fg_color->green, fg_color->blue, fg_color->alpha);
+	_cairo_quartz_set_antialiasing (cgContext, font->base.options.antialias);
 	CGContextSetAlpha (cgContext, 1.0);
-	CGContextShowGlyphsAtPoint (cgContext, - glyphOrigin.x, - glyphOrigin.y, &glyph, 1);
-
+	CGContextTranslateCTM (cgContext, -glyphOrigin.x, -glyphOrigin.y);
+	CGContextConcatCTM (cgContext, textMatrix);
+	CTFontDrawGlyphs (font->ctFont, &glyph, &CGPointZero, 1, cgContext);
 	CGContextRelease (cgContext);
+	CGColorSpaceRelease (colorspace);
     }
 
     cairo_surface_set_device_offset (&surface->base,
 				     - glyphOrigin.x,
 				     height + glyphOrigin.y);
+    cairo_surface_mark_dirty (&surface->base);
 
-    _cairo_scaled_glyph_set_surface (scaled_glyph, &font->base, surface);
+    if (is_color)
+	_cairo_scaled_glyph_set_color_surface (scaled_glyph, &font->base, surface, fg_color);
+    else
+	_cairo_scaled_glyph_set_surface (scaled_glyph, &font->base, surface);
 
     return status;
 }
@@ -776,7 +667,8 @@
 static cairo_int_status_t
 _cairo_quartz_scaled_glyph_init (void *abstract_font,
 				 cairo_scaled_glyph_t *scaled_glyph,
-				 cairo_scaled_glyph_info_t info)
+				 cairo_scaled_glyph_info_t info,
+				 const cairo_color_t *foreground_color)
 {
     cairo_quartz_scaled_font_t *font = (cairo_quartz_scaled_font_t *) abstract_font;
     cairo_int_status_t status = CAIRO_STATUS_SUCCESS;
@@ -787,8 +679,10 @@
     if (!status && (info & CAIRO_SCALED_GLYPH_INFO_PATH))
 	status = _cairo_quartz_init_glyph_path (font, scaled_glyph);
 
-    if (!status && (info & CAIRO_SCALED_GLYPH_INFO_SURFACE))
-	status = _cairo_quartz_init_glyph_surface (font, scaled_glyph);
+    if (!status && (info & (CAIRO_SCALED_GLYPH_INFO_SURFACE |
+			    CAIRO_SCALED_GLYPH_INFO_COLOR_SURFACE )))
+	status = _cairo_quartz_init_glyph_surface (font, scaled_glyph,
+						   info, foreground_color);
 
     return status;
 }
@@ -798,13 +692,11 @@
 			     uint32_t ucs4)
 {
     cairo_quartz_scaled_font_t *font = (cairo_quartz_scaled_font_t*) abstract_font;
-    cairo_quartz_font_face_t *ffont = _cairo_quartz_scaled_to_face(font);
     CGGlyph glyph[2];
     UniChar utf16[2];
 
     int len = _cairo_ucs4_to_utf16 (ucs4, utf16);
-    CGFontGetGlyphsForUnicharsPtr (ffont->cgFont, utf16, glyph, len);
-
+    CTFontGetGlyphsForCharacters (font->ctFont, utf16, glyph, len);
     return glyph[0];
 }
 
@@ -815,11 +707,8 @@
 				   unsigned char    *buffer,
 				   unsigned long    *length)
 {
-    cairo_quartz_font_face_t *font_face = _cairo_quartz_scaled_to_face (abstract_font);
-    CFDataRef data = NULL;
-
-    if (likely (CGFontCopyTableForTagPtr))
-	data = CGFontCopyTableForTagPtr (font_face->cgFont, tag);
+    cairo_quartz_scaled_font_t *font = (cairo_quartz_scaled_font_t*) abstract_font;
+    CFDataRef data = CTFontCopyTable (font->ctFont, tag, kCTFontTableOptionNoOptions);
 
     if (!data)
         return CAIRO_INT_STATUS_UNSUPPORTED;
@@ -848,9 +737,12 @@
     NULL, /* text_to_glyphs */
     _cairo_quartz_ucs4_to_index,
     _cairo_quartz_load_truetype_table,
-    NULL, /* map_glyphs_to_unicode */
+    NULL, /*index_to_ucs4*/
+    NULL, /* is_synthetic */
+    NULL, /* index_to_glyph_name */
+    NULL, /* load_type1_data */
+    _cairo_quartz_font_has_color_glyphs
 };
-
 /*
  * private methods that the quartz surface uses
  */
@@ -864,17 +756,45 @@
 }
 
 CTFontRef
-_cairo_quartz_scaled_font_get_ct_font_ref (cairo_scaled_font_t *abstract_font)
+_cairo_quartz_scaled_font_get_ct_font (cairo_scaled_font_t *abstract_font)
 {
-    cairo_quartz_font_face_t *ffont = _cairo_quartz_scaled_to_face(abstract_font);
+    cairo_quartz_scaled_font_t *font = (cairo_quartz_scaled_font_t*) abstract_font;
 
-    return ffont->ctFont;
+    return font->ctFont;
 }
 
+ void
+ _cairo_quartz_set_antialiasing (CGContextRef cgContext, cairo_antialias_t antialias)
+{
+	switch (antialias) {
+	case CAIRO_ANTIALIAS_SUBPIXEL:
+	case CAIRO_ANTIALIAS_BEST:
+	    CGContextSetShouldAntialias (cgContext, TRUE);
+	    CGContextSetShouldSmoothFonts (cgContext, TRUE);
+	    quartz_font_ensure_symbols ();
+	    if (CGContextGetAllowsFontSmoothingPtr &&
+		!CGContextGetAllowsFontSmoothingPtr (cgContext))
+		CGContextSetAllowsFontSmoothing (cgContext, TRUE);
+	    break;
+	case CAIRO_ANTIALIAS_NONE:
+	    CGContextSetShouldAntialias (cgContext, FALSE);
+	    break;
+	case CAIRO_ANTIALIAS_GRAY:
+	case CAIRO_ANTIALIAS_GOOD:
+	case CAIRO_ANTIALIAS_FAST:
+	    CGContextSetShouldAntialias (cgContext, TRUE);
+	    CGContextSetShouldSmoothFonts (cgContext, FALSE);
+	    break;
+	case CAIRO_ANTIALIAS_DEFAULT:
+	default:
+	    /* Don't do anything */
+	    break;
+	}
+
+}
 /*
  * compat with old ATSUI backend
  */
-#ifdef CAIRO_HAS_QUARTZ_ATSUFONTID
 
 /**
  * cairo_quartz_font_face_create_for_atsu_font_id:
@@ -918,5 +838,3 @@
 {
     return cairo_quartz_font_face_create_for_atsu_font_id (font_id);
 }
-
-#endif /* CAIRO_HAS_QUARTZ_ATSUFONTID */