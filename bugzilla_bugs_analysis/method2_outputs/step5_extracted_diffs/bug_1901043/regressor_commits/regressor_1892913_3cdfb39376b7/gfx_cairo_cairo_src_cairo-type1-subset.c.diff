# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-type1-subset.c
# Commit: 3cdfb39376b7
# Full Hash: 3cdfb39376b736597fe658a322389117686b7e82
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 3
# Description:
#   Bug 1892913 - patch 1 - Update cairo source to 1.18.0 r=gfx-reviewers,lsalzman
#   
#   Wholesale replacement of files in gfx/cairo/cairo with contents of the 1.18.0 release tarball,
#   omitting subdirectories that are not part of the core library build.
#   
# ==============================================================================

diff -r 9daa351f875b -r 3cdfb39376b7 gfx/cairo/cairo/src/cairo-type1-subset.c
--- a/gfx/cairo/cairo/src/cairo-type1-subset.c	Mon May 06 19:22:35 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-type1-subset.c	Mon May 06 19:25:12 2024 +0000
@@ -70,7 +70,7 @@
     struct {
 	unsigned int font_id;
 	char *base_font;
-	unsigned int num_glyphs;
+	unsigned int num_glyphs; /* Num /CharStrings in font */
 	double x_min, y_min, x_max, y_max;
 	double ascent, descent;
 	double units_per_em;
@@ -81,6 +81,9 @@
 	unsigned long  trailer_size;
     } base;
 
+    /* Num glyphs in subset. May be greater than
+     * scaled_font_subset->num_glyphs due to glyphs required by the
+     * SEAC operator. */
     int num_glyphs;
 
     /* The glyphs and glyph_names arrays are indexed by the order of
@@ -89,12 +92,12 @@
      * function is used to map the glyph index to the glyph order in
      * the Charstrings. */
 
-    glyph_data_t *glyphs;
-    char **glyph_names;
     cairo_array_t glyphs_array;
+    glyph_data_t *glyphs; /* pointer to first element of above array */
     cairo_array_t glyph_names_array;
+    char **glyph_names; /* pointer to first element of above array */
 
-    int num_subrs;
+    int num_subrs; /* Num /Subrs routines in the font */
     cairo_bool_t subset_subrs;
     struct {
 	const char *subr_string;
@@ -102,12 +105,17 @@
 	const char *np;
 	int np_length;
 	cairo_bool_t used;
-    } *subrs;
+    } *subrs; /* array with num_subrs elements */
+
+    /* Maps scaled_font_subset index to glyphs_array.
+     * Array size = scaled_font_subset->num_glyphs. */
+    int *scaled_subset_index_to_glyphs;
 
-    /* Indexed by subset_index this maps to the glyph order in the
-     * glyph_names and glyphs arrays. Has font->num_golyphs
-     * elements. */
-    int *subset_index_to_glyphs;
+    /* Keeps track of the glyphs that will be emitted in the subset.
+     * Allocated size = base.num_glyphs. Number of entries = num_glyphs.
+     * Array values are glyph_array indexes.
+     */
+    int *type1_subset_index_to_glyphs;
 
     cairo_output_stream_t *output;
     cairo_array_t contents;
@@ -159,7 +167,12 @@
 
     _cairo_array_init (&font->glyphs_array, sizeof (glyph_data_t));
     _cairo_array_init (&font->glyph_names_array, sizeof (char *));
-    font->subset_index_to_glyphs = NULL;
+    font->scaled_subset_index_to_glyphs = calloc (scaled_font_subset->num_glyphs, sizeof font->scaled_subset_index_to_glyphs[0]);
+    if (unlikely (font->scaled_subset_index_to_glyphs == NULL))
+        return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+
+    font->type1_subset_index_to_glyphs = NULL;
     font->base.num_glyphs = 0;
     font->num_subrs = 0;
     font->subset_subrs = TRUE;
@@ -180,7 +193,7 @@
 	return;
 
     font->glyphs[glyph].subset_index = font->num_glyphs;
-    font->subset_index_to_glyphs[font->num_glyphs] = glyph;
+    font->type1_subset_index_to_glyphs[font->num_glyphs] = glyph;
     font->num_glyphs++;
 }
 
@@ -391,7 +404,7 @@
     if (yy == 0.0)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
-    /* Freetype uses 1/yy to get units per EM */
+    /* FreeType uses 1/yy to get units per EM */
     font->base.units_per_em = 1.0/yy;
 
     /* If the FontMatrix is not a uniform scale the metrics we extract
@@ -470,6 +483,7 @@
 {
     const char *start, *end, *segment_end;
     unsigned int i;
+    int glyph;
 
     /* FIXME:
      * This function assumes that /FontName always appears
@@ -550,13 +564,12 @@
 	    }
 	}
     } else {
-	for (i = 0; i < font->base.num_glyphs; i++) {
-	    if (font->glyphs[i].subset_index <= 0)
-		continue;
+	for (i = 1; i < font->scaled_font_subset->num_glyphs; i++) {
+	    glyph = font->scaled_subset_index_to_glyphs[i];
 	    _cairo_output_stream_printf (font->output,
 					 "dup %d /%s put\n",
-					 font->glyphs[i].subset_index,
-					 font->glyph_names[i]);
+					 i,
+					 font->glyph_names[glyph]);
 	}
     }
     _cairo_output_stream_printf (font->output, "readonly def");
@@ -630,7 +643,7 @@
     unsigned char *in, *end;
     char *out;
     int c, p;
-    int i;
+    unsigned int i;
 
     in = (unsigned char *) font->eexec_segment;
     end = (unsigned char *) in + font->eexec_segment_size;
@@ -1072,6 +1085,9 @@
 
 	/* Skip binary data and | or NP token. */
 	p = skip_token (subr_string + subr_length, cleartext_end);
+        if (p == NULL)
+            return CAIRO_INT_STATUS_UNSUPPORTED;
+
 	while (p < cleartext_end && _cairo_isspace(*p))
 	    p++;
 
@@ -1235,6 +1251,9 @@
 
 	/* Skip binary data and |- or ND token. */
 	p = skip_token (charstring + charstring_length, dict_end);
+        if (p == NULL)
+            return CAIRO_INT_STATUS_UNSUPPORTED;
+
 	while (p < dict_end && _cairo_isspace(*p))
 	    p++;
 
@@ -1391,8 +1410,8 @@
     font->glyphs = _cairo_array_index (&font->glyphs_array, 0);
     font->glyph_names = _cairo_array_index (&font->glyph_names_array, 0);
     font->base.num_glyphs = _cairo_array_num_elements (&font->glyphs_array);
-    font->subset_index_to_glyphs = calloc (font->base.num_glyphs, sizeof font->subset_index_to_glyphs[0]);
-    if (unlikely (font->subset_index_to_glyphs == NULL))
+    font->type1_subset_index_to_glyphs = calloc (font->base.num_glyphs, sizeof font->type1_subset_index_to_glyphs[0]);
+    if (unlikely (font->type1_subset_index_to_glyphs == NULL))
         return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 
     backend = font->scaled_font_subset->scaled_font->backend;
@@ -1414,6 +1433,7 @@
 	    return status;
 
 	cairo_type1_font_subset_use_glyph (font, index);
+	font->scaled_subset_index_to_glyphs[i] = index;
     }
 
     /* Go through the charstring of each glyph in use, get the glyph
@@ -1421,7 +1441,7 @@
      * seac operator (which may cause font->num_glyphs to increase
      * while this loop is executing). Also subset the Subrs. */
     for (j = 0; j < font->num_glyphs; j++) {
-	glyph = font->subset_index_to_glyphs[j];
+	glyph = font->type1_subset_index_to_glyphs[j];
 	font->build_stack.sp = 0;
 	font->ps_stack.sp = 0;
 	status = cairo_type1_font_subset_parse_charstring (font,
@@ -1711,7 +1731,9 @@
 
     free (font->base.base_font);
 
-    free (font->subset_index_to_glyphs);
+    free (font->scaled_subset_index_to_glyphs);
+
+    free (font->type1_subset_index_to_glyphs);
 
     free (font->cleartext);
 
@@ -1730,6 +1752,7 @@
     unsigned long length;
     unsigned int i;
     char buf[30];
+    int glyph;
 
     /* We need to use a fallback font if this font differs from the type1 outlines. */
     if (scaled_font_subset->scaled_font->backend->is_synthetic) {
@@ -1759,14 +1782,13 @@
     if (unlikely (type1_subset->base_font == NULL))
 	goto fail1;
 
-    type1_subset->widths = calloc (sizeof (double), font.num_glyphs);
+    type1_subset->widths = calloc (sizeof (double), scaled_font_subset->num_glyphs);
     if (unlikely (type1_subset->widths == NULL))
 	goto fail2;
-    for (i = 0; i < font.base.num_glyphs; i++) {
-	if (font.glyphs[i].subset_index < 0)
-	    continue;
-	type1_subset->widths[font.glyphs[i].subset_index] =
-	    font.glyphs[i].width;
+
+    for (i = 0; i < font.scaled_font_subset->num_glyphs; i++) {
+	glyph = font.scaled_subset_index_to_glyphs[i];
+	type1_subset->widths[i] = font.glyphs[glyph].width;
     }
 
     type1_subset->x_min = font.base.x_min;