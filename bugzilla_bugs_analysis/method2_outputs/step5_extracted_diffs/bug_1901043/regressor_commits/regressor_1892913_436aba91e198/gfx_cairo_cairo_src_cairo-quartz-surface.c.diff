# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/cairo/cairo/src/cairo-quartz-surface.c
# Commit: 436aba91e198
# Full Hash: 436aba91e19876143883c9c92e2668192b8b195f
# Author: Jonathan Kew <jkew@mozilla.com>
# Date: 2024-05-07 09:13:07
# Regressor Bug: 1892913
# File Overlap Count: 1
# Description:
#   Bug 1892913 - patch 19 - Don't prematurely clear cairo_quartz_image_surface_t's imageSurface field, it still needs to hold a reference to the wrapped image surface. r=gfx-reviewers,lsalzman
#   
#   Without this, we end up leaking the DataSourceSurfaceRawData that backs the
#   quartz image surface created during surface-pattern rendering, because the
#   imageSurface pointer holds a strong reference and then gets cleared without
# ==============================================================================

diff -r 61ef06598b0c -r 436aba91e198 gfx/cairo/cairo/src/cairo-quartz-surface.c
--- a/gfx/cairo/cairo/src/cairo-quartz-surface.c	Mon May 06 19:25:20 2024 +0000
+++ b/gfx/cairo/cairo/src/cairo-quartz-surface.c	Mon May 06 19:25:21 2024 +0000
@@ -759,7 +759,12 @@
 
     if (acquired) {
 	_cairo_surface_release_source_image (source, image_surface->imageSurface, image_extra);
-	image_surface->imageSurface = NULL;
+	/* If source itself is an image surface, _cairo_surface_release_source_image
+	   does not release it, and image_surface->imageSurface still owns a reference
+	   to it. So we don't clear that field here; _cairo_quartz_image_surface_finish
+	   will take care of it. */
+	if (source->type != CAIRO_SURFACE_TYPE_IMAGE)
+	    image_surface->imageSurface = NULL;
     }
     cairo_surface_destroy (&image_surface->base);
 
