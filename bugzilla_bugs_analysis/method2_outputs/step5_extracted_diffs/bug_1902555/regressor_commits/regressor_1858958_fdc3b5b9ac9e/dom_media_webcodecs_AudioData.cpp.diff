# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webcodecs/AudioData.cpp
# Commit: fdc3b5b9ac9e
# Full Hash: fdc3b5b9ac9ebda5bef18b062b12c5a777c472d7
# Author: Paul Adenot <paul@paul.cx>
# Date: 2024-03-07 09:55:57
# Regressor Bug: 1858958
# File Overlap Count: 1
# Description:
#   Bug 1858958 - AudioData: copyTo. r=chunmin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D190947
# ==============================================================================

diff -r 0f91085165dd -r fdc3b5b9ac9e dom/media/webcodecs/AudioData.cpp
--- a/dom/media/webcodecs/AudioData.cpp	Wed Mar 06 14:00:13 2024 +0000
+++ b/dom/media/webcodecs/AudioData.cpp	Wed Mar 06 14:00:14 2024 +0000
@@ -277,6 +277,205 @@
   AssertIsOnOwningThread();
   return mTimestamp;
 }
+
+struct CopyToSpec {
+  CopyToSpec(uint32_t aFrameCount, uint32_t aFrameOffset, uint32_t mPlaneIndex,
+             AudioSampleFormat aFormat)
+      : mFrameCount(aFrameCount),
+        mFrameOffset(aFrameOffset),
+        mPlaneIndex(mPlaneIndex),
+        mFormat(aFormat) {}
+
+  const uint32_t mFrameCount;
+  const uint32_t mFrameOffset;
+  const uint32_t mPlaneIndex;
+  const AudioSampleFormat mFormat;
+};
+
+bool IsInterleaved(const AudioSampleFormat& aFormat) {
+  switch (aFormat) {
+    case AudioSampleFormat::U8:
+    case AudioSampleFormat::S16:
+    case AudioSampleFormat::S32:
+    case AudioSampleFormat::F32:
+      return true;
+    case AudioSampleFormat::U8_planar:
+    case AudioSampleFormat::S16_planar:
+    case AudioSampleFormat::S32_planar:
+    case AudioSampleFormat::F32_planar:
+      return false;
+  };
+  MOZ_ASSERT_UNREACHABLE("Invalid enum value");
+  return false;
+}
+
+size_t AudioData::ComputeCopyElementCount(
+    const AudioDataCopyToOptions& aOptions, ErrorResult& aRv) {
+  // https://w3c.github.io/webcodecs/#compute-copy-element-count
+  // 1, 2
+  auto destFormat = mAudioSampleFormat;
+  if (aOptions.mFormat.WasPassed()) {
+    destFormat = OptionalToMaybe(aOptions.mFormat);
+  }
+  // 3, 4
+  MOZ_ASSERT(destFormat.isSome());
+  if (IsInterleaved(destFormat.value())) {
+    if (aOptions.mPlaneIndex > 0) {
+      auto msg = "Interleaved format, but plane index > 0"_ns;
+      LOGD("%s", msg.get());
+      aRv.ThrowRangeError(msg);
+      return 0;
+    }
+  } else {
+    if (aOptions.mPlaneIndex >= mNumberOfChannels) {
+      auto msg = nsPrintfCString(
+          "Plane index %" PRIu32
+          " greater or equal than the number of channels %" PRIu32,
+          aOptions.mPlaneIndex, mNumberOfChannels);
+      LOGD("%s", msg.get());
+      aRv.ThrowRangeError(msg);
+      return 0;
+    }
+  }
+  // 5 -- conversion between all formats supported
+  // 6 -- all planes have the same number of frames, always
+  uint64_t frameCount = mNumberOfFrames;
+  // 7
+  if (aOptions.mFrameOffset >= frameCount) {
+    auto msg = nsPrintfCString("Frame offset of %" PRIu32
+                               " greater or equal than frame count %" PRIu64,
+                               aOptions.mFrameOffset, frameCount);
+    LOGD("%s", msg.get());
+    aRv.ThrowRangeError(msg);
+    return 0;
+  }
+  // 8, 9
+  uint64_t copyFrameCount = frameCount - aOptions.mFrameOffset;
+  if (aOptions.mFrameCount.WasPassed()) {
+    if (aOptions.mFrameCount.Value() > copyFrameCount) {
+      auto msg = nsPrintfCString(
+          "Passed copy frame count of %" PRIu32
+          " greater than available source frames for copy of %" PRIu64,
+          aOptions.mFrameCount.Value(), copyFrameCount);
+      LOGD("%s", msg.get());
+      aRv.ThrowRangeError(msg);
+      return 0;
+    }
+    copyFrameCount = aOptions.mFrameCount.Value();
+  }
+  // 10, 11
+  uint64_t elementCount = copyFrameCount;
+  if (IsInterleaved(destFormat.value())) {
+    elementCount *= mNumberOfChannels;
+  }
+  return elementCount;
+}
+
+// https://w3c.github.io/webcodecs/#dom-audiodata-allocationsize
+// This method returns an int, that can be zero in case of success or error.
+// Caller should check aRv to determine success or error.
+uint32_t AudioData::AllocationSize(const AudioDataCopyToOptions& aOptions,
+                                   ErrorResult& aRv) {
+  AssertIsOnOwningThread();
+  if (!mResource) {
+    auto msg = "allocationSize called on detached AudioData"_ns;
+    LOGD("%s", msg.get());
+    aRv.ThrowInvalidStateError(msg);
+    return 0;
+  }
+  size_t copyElementCount = ComputeCopyElementCount(aOptions, aRv);
+  if (aRv.Failed()) {
+    LOGD("AudioData::AllocationSize failure");
+    // ComputeCopyElementCount has set the exception type.
+    return 0;
+  }
+  Maybe<mozilla::dom::AudioSampleFormat> destFormat = mAudioSampleFormat;
+  if (aOptions.mFormat.WasPassed()) {
+    destFormat = OptionalToMaybe(aOptions.mFormat);
+  }
+  if (destFormat.isNothing()) {
+    auto msg = "AudioData has an unknown format"_ns;
+    LOGD("%s", msg.get());
+    // See https://github.com/w3c/webcodecs/issues/727 -- it isn't clear yet
+    // what to do here
+    aRv.ThrowRangeError(msg);
+    return 0;
+  }
+  CheckedInt<size_t> bytesPerSample = BytesPerSamples(destFormat.ref());
+
+  auto res = bytesPerSample * copyElementCount;
+  if (res.isValid()) {
+    return res.value();
+  }
+  aRv.ThrowRangeError("Allocation size too large");
+  return 0;
+}
+
+template <typename S, typename D>
+void CopySamples(Span<S> aSource, Span<D> aDest, uint32_t aSourceChannelCount,
+                 const AudioSampleFormat aSourceFormat,
+                 const CopyToSpec& aCopyToSpec) {
+  if (IsInterleaved(aSourceFormat) && IsInterleaved(aCopyToSpec.mFormat)) {
+    MOZ_ASSERT(aCopyToSpec.mPlaneIndex == 0);
+    MOZ_ASSERT(aDest.Length() >= aCopyToSpec.mFrameCount);
+    MOZ_ASSERT(aSource.Length() - aCopyToSpec.mFrameOffset >=
+               aCopyToSpec.mFrameCount);
+    // This turns into a regular memcpy if the types are in fact equal
+    ConvertAudioSamples(aSource.data() + aCopyToSpec.mFrameOffset, aDest.data(),
+                        aCopyToSpec.mFrameCount * aSourceChannelCount);
+    return;
+  }
+  if (IsInterleaved(aSourceFormat) && !IsInterleaved(aCopyToSpec.mFormat)) {
+    DebugOnly<size_t> sourceFrameCount = aSource.Length() / aSourceChannelCount;
+    MOZ_ASSERT(aDest.Length() >= aCopyToSpec.mFrameCount);
+    MOZ_ASSERT(aSource.Length() - aCopyToSpec.mFrameOffset >=
+               aCopyToSpec.mFrameCount);
+    // Interleaved to planar -- only copy samples of the correct channel to the
+    // destination
+    size_t readIndex = aCopyToSpec.mFrameOffset * aSourceChannelCount +
+                       aCopyToSpec.mPlaneIndex;
+    for (size_t i = 0; i < aCopyToSpec.mFrameCount; i++) {
+      aDest[i] = ConvertAudioSample<D>(aSource[readIndex]);
+      readIndex += aSourceChannelCount;
+    }
+    return;
+  }
+
+  if (!IsInterleaved(aSourceFormat) && IsInterleaved(aCopyToSpec.mFormat)) {
+    // Planar to interleaved -- copy of all channels of the source into the
+    // destination buffer.
+    MOZ_ASSERT(aCopyToSpec.mPlaneIndex == 0);
+    MOZ_ASSERT(aDest.Length() >= aCopyToSpec.mFrameCount * aSourceChannelCount);
+    MOZ_ASSERT(aSource.Length() -
+                   aCopyToSpec.mFrameOffset * aSourceChannelCount >=
+               aCopyToSpec.mFrameCount * aSourceChannelCount);
+    size_t writeIndex = 0;
+    // Scan the source linearly and put each sample at the right position in the
+    // destination interleaved buffer.
+    size_t readIndex = 0;
+    for (size_t channel = 0; channel < aSourceChannelCount; channel++) {
+      writeIndex = channel;
+      for (size_t i = 0; i < aCopyToSpec.mFrameCount; i++) {
+        aDest[writeIndex] = ConvertAudioSample<D>(aSource[readIndex]);
+        readIndex++;
+        writeIndex += aSourceChannelCount;
+      }
+    }
+    return;
+  }
+  if (!IsInterleaved(aSourceFormat) && !IsInterleaved(aCopyToSpec.mFormat)) {
+    // Planar to Planar / convert + copy from the right index in the source.
+    size_t offset =
+        aCopyToSpec.mPlaneIndex * aSource.Length() / aSourceChannelCount;
+    MOZ_ASSERT(aDest.Length() >= aSource.Length() / aSourceChannelCount -
+                                     aCopyToSpec.mFrameOffset);
+    for (uint32_t i = 0; i < aCopyToSpec.mFrameCount; i++) {
+      aDest[i] =
+          ConvertAudioSample<D>(aSource[offset + aCopyToSpec.mFrameOffset + i]);
+    }
+  }
+}
+
 nsCString AudioData::ToString() const {
   if (!mResource) {
     return nsCString("AudioData[detached]");
@@ -288,12 +487,120 @@
                          mSampleRate, mNumberOfFrames, mNumberOfChannels);
 }
 
+nsCString CopyToToString(size_t aDestBufSize,
+                         const AudioDataCopyToOptions& aOptions) {
+  return nsPrintfCString(
+      "AudioDataCopyToOptions[data: %zu bytes %s frame count:%" PRIu32
+      " frame offset: %" PRIu32 "  plane: %" PRIu32 "]",
+      aDestBufSize,
+      aOptions.mFormat.WasPassed() ? FormatToString(aOptions.mFormat.Value())
+                                   : "null",
+      aOptions.mFrameCount.WasPassed() ? aOptions.mFrameCount.Value() : 0,
+      aOptions.mFrameOffset, aOptions.mPlaneIndex);
+}
+
+using DataSpanType =
+    Variant<Span<uint8_t>, Span<int16_t>, Span<int32_t>, Span<float>>;
+
+DataSpanType GetDataSpan(Span<uint8_t> aSpan, const AudioSampleFormat aFormat) {
+  const size_t Length = aSpan.Length() / BytesPerSamples(aFormat);
+  // TODO: Check size so Span can be reasonably constructed?
+  switch (aFormat) {
+    case AudioSampleFormat::U8:
+    case AudioSampleFormat::U8_planar:
+      return AsVariant(aSpan);
+    case AudioSampleFormat::S16:
+    case AudioSampleFormat::S16_planar:
+      return AsVariant(Span(reinterpret_cast<int16_t*>(aSpan.data()), Length));
+    case AudioSampleFormat::S32:
+    case AudioSampleFormat::S32_planar:
+      return AsVariant(Span(reinterpret_cast<int32_t*>(aSpan.data()), Length));
+    case AudioSampleFormat::F32:
+    case AudioSampleFormat::F32_planar:
+      return AsVariant(Span(reinterpret_cast<float*>(aSpan.data()), Length));
+  }
+  MOZ_ASSERT_UNREACHABLE("Invalid enum value");
+  return AsVariant(aSpan);
+}
+
+void CopySamples(DataSpanType& aSource, DataSpanType& aDest,
+                 uint32_t aSourceChannelCount,
+                 const AudioSampleFormat aSourceFormat,
+                 const CopyToSpec& aCopyToSpec) {
+  aSource.match([&](auto& src) {
+    aDest.match([&](auto& dst) {
+      CopySamples(src, dst, aSourceChannelCount, aSourceFormat, aCopyToSpec);
+    });
+  });
+}
+
+void DoCopy(Span<uint8_t> aSource, Span<uint8_t> aDest,
+            const uint32_t aSourceChannelCount,
+            const AudioSampleFormat aSourceFormat,
+            const CopyToSpec& aCopyToSpec) {
+  DataSpanType source = GetDataSpan(aSource, aSourceFormat);
+  DataSpanType dest = GetDataSpan(aDest, aCopyToSpec.mFormat);
+  CopySamples(source, dest, aSourceChannelCount, aSourceFormat, aCopyToSpec);
+}
+
 // https://w3c.github.io/webcodecs/#dom-audiodata-copyto
 void AudioData::CopyTo(
     const MaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer& aDestination,
     const AudioDataCopyToOptions& aOptions, ErrorResult& aRv) {
   AssertIsOnOwningThread();
 
+  size_t destLength = ProcessTypedArraysFixed(
+      aDestination, [&](const Span<uint8_t>& aData) -> size_t {
+        return aData.LengthBytes();
+      });
+
+  LOGD("AudioData::CopyTo %s -> %s", ToString().get(),
+       CopyToToString(destLength, aOptions).get());
+
+  if (!mResource) {
+    auto msg = "copyTo called on closed AudioData"_ns;
+    LOGD("%s", msg.get());
+    aRv.ThrowInvalidStateError(msg);
+    return;
+  }
+
+  uint64_t copyElementCount = ComputeCopyElementCount(aOptions, aRv);
+  if (aRv.Failed()) {
+    LOGD("AudioData::CopyTo failed in ComputeCopyElementCount");
+    return;
+  }
+  auto destFormat = mAudioSampleFormat;
+  if (aOptions.mFormat.WasPassed()) {
+    destFormat = OptionalToMaybe(aOptions.mFormat);
+  }
+
+  uint32_t bytesPerSample = BytesPerSamples(destFormat.value());
+  CheckedInt<uint32_t> copyLength = bytesPerSample;
+  copyLength *= copyElementCount;
+  if (copyLength.value() > destLength) {
+    auto msg = nsPrintfCString(
+        "destination buffer of length %zu too small for copying %" PRIu64
+        "  elements",
+        destLength, bytesPerSample * copyElementCount);
+    LOGD("%s", msg.get());
+    aRv.ThrowRangeError(msg);
+    return;
+  }
+
+  uint32_t framesToCopy = mNumberOfFrames - aOptions.mFrameOffset;
+  if (aOptions.mFrameCount.WasPassed()) {
+    framesToCopy = aOptions.mFrameCount.Value();
+  }
+
+  CopyToSpec copyToSpec(framesToCopy, aOptions.mFrameOffset,
+                        aOptions.mPlaneIndex, destFormat.value());
+
+  // Now a couple layers of macros to type the pointers and perform the actual
+  // copy.
+  ProcessTypedArraysFixed(aDestination, [&](const Span<uint8_t>& aData) {
+    DoCopy(mResource->Data(), aData, mNumberOfChannels,
+           mAudioSampleFormat.value(), copyToSpec);
+  });
 }
 
 // https://w3c.github.io/webcodecs/#dom-audiodata-clone
