# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/cubeb-coreaudio/src/backend/tests/aggregate_device.rs
# Commit: ad954710c53f
# Full Hash: ad954710c53fa84879169b4f3d7994bb5f2ab714
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2024-06-03 16:07:28
# Regressor Bug: 1890186
# File Overlap Count: 5
# Description:
#   Bug 1890186: Update cubeb-coreaudio-rs to 1796ace5bd. r=cubeb-reviewers,padenot
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D212311
# ==============================================================================

diff -r 8952a815f4b4 -r ad954710c53f third_party/rust/cubeb-coreaudio/src/backend/tests/aggregate_device.rs
--- a/third_party/rust/cubeb-coreaudio/src/backend/tests/aggregate_device.rs	Mon Jun 03 13:31:38 2024 +0300
+++ b/third_party/rust/cubeb-coreaudio/src/backend/tests/aggregate_device.rs	Mon Jun 03 10:03:39 2024 +0000
@@ -1,8 +1,11 @@
+extern crate itertools;
+
 use super::utils::{
     test_get_all_devices, test_get_all_onwed_devices, test_get_default_device,
     test_get_drift_compensations, test_get_master_device, DeviceFilter, Scope,
 };
 use super::*;
+use std::collections::HashSet;
 use std::iter::zip;
 use std::panic;
 
@@ -46,25 +49,73 @@
 
 // AggregateDevice::get_sub_devices
 // ------------------------------------
-// You can check this by creating an aggregate device in `Audio MIDI Setup`
-// application and print out the sub devices of them!
 #[test]
+#[ignore]
 fn test_aggregate_get_sub_devices() {
-    let devices = test_get_all_devices(DeviceFilter::ExcludeCubebAggregateAndVPIO);
-    for device in devices {
-        // `AggregateDevice::get_sub_devices(device)` will return a single-element vector
-        // containing `device` itself if it's not an aggregate device. This test assumes devices
-        // is not an empty aggregate device (Test will panic when calling get_sub_devices with
-        // an empty aggregate device).
-        println!(
-            "get_sub_devices({}={})",
-            device,
-            run_serially_forward_panics(|| get_device_uid(device))
+    fn diff(lhs: Vec<u32>, rhs: Vec<u32>) -> Vec<u32> {
+        let left: HashSet<u32> = lhs.into_iter().collect();
+        let right: HashSet<u32> = rhs.into_iter().collect();
+        left.symmetric_difference(&right)
+            .map(|&i| i.clone())
+            .collect()
+    }
+
+    // Run in a large block so other test cases cannot add or remove devices while this runs.
+    let input_device = test_get_default_device(Scope::Input);
+    let output_device = test_get_default_device(Scope::Output);
+    if input_device.is_none() || output_device.is_none() || input_device == output_device {
+        println!("No input and output device to create an aggregate device.");
+        return;
+    }
+    let devices_base = test_get_all_devices(DeviceFilter::ExcludeVPIO);
+    run_serially_forward_panics(|| {
+        assert!(
+            devices_base
+                .clone()
+                .into_iter()
+                .map(AggregateDevice::get_sub_devices)
+                .any(|r| r.is_err()),
+            "There should be some device that is not an aggregate."
+        )
+    });
+
+    {
+        // Test get_sub_devices on an empty aggregate device.
+        let plugin_id = AggregateDevice::get_system_plugin_id().unwrap();
+        let aggr = run_serially_forward_panics(|| AggregateDevice::create_blank_device(plugin_id))
+            .unwrap();
+        let new = diff(
+            devices_base.clone(),
+            test_get_all_devices(DeviceFilter::ExcludeVPIO),
         );
-        let sub_devices =
-            run_serially_forward_panics(|| AggregateDevice::get_sub_devices(device).unwrap());
-        // TODO: If the device is a blank aggregate device, then the assertion fails!
-        assert!(!sub_devices.is_empty());
+        assert_eq!(new.len(), 1);
+        let new_subs = run_serially_forward_panics(|| AggregateDevice::get_sub_devices(new[0]));
+        assert!(new_subs.is_ok());
+        assert_eq!(new_subs.unwrap().len(), 0);
+        assert!(
+            run_serially_forward_panics(|| AggregateDevice::destroy_device(plugin_id, aggr))
+                .is_ok()
+        );
+    }
+
+    {
+        // Test get_sub_devices on an aggregate device with two sub devices.
+        let aggr = run_serially_forward_panics(|| {
+            let input_device = input_device.unwrap();
+            let output_device = output_device.unwrap();
+
+            AggregateDevice::new(input_device, output_device)
+        })
+        .unwrap();
+        let new = diff(
+            devices_base.clone(),
+            test_get_all_devices(DeviceFilter::ExcludeVPIO),
+        );
+        assert_eq!(new.len(), 1);
+        let new_subs = run_serially_forward_panics(|| AggregateDevice::get_sub_devices(new[0]));
+        assert!(new_subs.is_ok());
+        assert_eq!(new_subs.unwrap().len(), 2);
+        run_serially_forward_panics(|| drop(aggr));
     }
 }
 
@@ -72,8 +123,7 @@
 #[should_panic]
 fn test_aggregate_get_sub_devices_for_a_unknown_device() {
     run_serially_forward_panics(|| {
-        let devices = AggregateDevice::get_sub_devices(kAudioObjectUnknown).unwrap();
-        assert!(devices.is_empty());
+        AggregateDevice::get_sub_devices(kAudioObjectUnknown);
     });
 }
 
@@ -135,15 +185,11 @@
 // AggregateDevice::get_sub_devices
 // ------------------------------------
 #[test]
-#[should_panic]
 fn test_aggregate_get_sub_devices_for_blank_aggregate_devices() {
     run_serially_forward_panics(|| {
         // TODO: Test this when there is no available devices.
         let plugin = AggregateDevice::get_system_plugin_id().unwrap();
         let device = AggregateDevice::create_blank_device_sync(plugin).unwrap();
-        // There is no sub device in a blank aggregate device!
-        // AggregateDevice::get_sub_devices guarantees returning a non-empty devices vector, so
-        // the following call will panic!
         let sub_devices = AggregateDevice::get_sub_devices(device).unwrap();
         assert!(sub_devices.is_empty());
         assert!(AggregateDevice::destroy_device(plugin, device).is_ok());
@@ -173,11 +219,11 @@
     ))
     .is_ok());
 
-    let sub_devices = run_serially(|| AggregateDevice::get_sub_devices(device)).unwrap();
+    let sub_devices = run_serially(|| AggregateDevice::get_sub_devices_or_self(device)).unwrap();
     let input_sub_devices =
-        run_serially(|| AggregateDevice::get_sub_devices(input_device)).unwrap();
+        run_serially(|| AggregateDevice::get_sub_devices_or_self(input_device)).unwrap();
     let output_sub_devices =
-        run_serially(|| AggregateDevice::get_sub_devices(output_device)).unwrap();
+        run_serially(|| AggregateDevice::get_sub_devices_or_self(output_device)).unwrap();
 
     // TODO: There may be overlapping devices between input_sub_devices and output_sub_devices,
     //       but now AggregateDevice::set_sub_devices will add them directly.
@@ -280,7 +326,7 @@
     assert!(run_serially(|| AggregateDevice::set_master_device(device, output_device)).is_ok());
 
     let output_sub_devices =
-        run_serially(|| AggregateDevice::get_sub_devices(output_device)).unwrap();
+        run_serially(|| AggregateDevice::get_sub_devices_or_self(output_device)).unwrap();
     let first_output_sub_device_uid = run_serially(|| get_device_uid(output_sub_devices[0]));
 
     // Check that the first sub device of the output device is set as master device.
@@ -391,10 +437,12 @@
     // The master device is by default the first sub device in the list.
     // This happens to be the first sub device of the input device, see implementation of
     // AggregateDevice::set_sub_devices.
-    let first_input_sub_device_uid =
-        run_serially(|| get_device_uid(AggregateDevice::get_sub_devices(input_device).unwrap()[0]));
-    let first_sub_device_uid =
-        run_serially(|| get_device_uid(AggregateDevice::get_sub_devices(device).unwrap()[0]));
+    let first_input_sub_device_uid = run_serially(|| {
+        get_device_uid(AggregateDevice::get_sub_devices_or_self(input_device).unwrap()[0])
+    });
+    let first_sub_device_uid = run_serially(|| {
+        get_device_uid(AggregateDevice::get_sub_devices_or_self(device).unwrap()[0])
+    });
     assert_eq!(first_input_sub_device_uid, first_sub_device_uid);
     let master_device_uid = run_serially(|| test_get_master_device(device));
     assert_eq!(first_sub_device_uid, master_device_uid);
@@ -422,7 +470,7 @@
         let plugin = AggregateDevice::get_system_plugin_id().unwrap();
         let device = AggregateDevice::create_blank_device_sync(plugin).unwrap();
 
-        let sub_devices = AggregateDevice::get_sub_devices(device).unwrap();
+        let sub_devices = AggregateDevice::get_sub_devices_or_self(device).unwrap();
         assert!(sub_devices.is_empty());
         let onwed_devices = test_get_all_onwed_devices(device);
         assert!(onwed_devices.is_empty());
@@ -475,7 +523,7 @@
         let aggr = AggregateDevice::new(input_device, output_device).unwrap();
 
         // Check main device
-        let output_sub_devices = AggregateDevice::get_sub_devices(output_device).unwrap();
+        let output_sub_devices = AggregateDevice::get_sub_devices_or_self(output_device).unwrap();
         let first_output_sub_device_uid = get_device_uid(output_sub_devices[0]);
         let master_device_uid = test_get_master_device(aggr.get_device_id());
         assert_eq!(first_output_sub_device_uid, master_device_uid);