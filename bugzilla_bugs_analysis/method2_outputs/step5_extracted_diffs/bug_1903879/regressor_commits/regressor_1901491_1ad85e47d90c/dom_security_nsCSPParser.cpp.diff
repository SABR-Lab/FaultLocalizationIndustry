# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/security/nsCSPParser.cpp
# Commit: 1ad85e47d90c
# Full Hash: 1ad85e47d90cd081bf4e8e4f5c674d8e8b22c501
# Author: Mirko Brodesser <mbrodesser@igalia.com>
# Date: 2024-06-20 16:10:57
# Regressor Bug: 1901491
# File Overlap Count: 1
# Description:
#   Bug 1901491: part 3) Implement `ShouldTrustedTypePolicyCreationBeBlockedByCSP` for Windows (not Workers) including reporting exceptions, excluding reporting violations. r=tschuster,webidl,saschanaz
#   
#   Parsing the trusted-types directive's values is not added to
#   `nsCSPParser::sourceList` because the latter supports keywords not
#   supported by the trusted-types directive. E.g. 'report-sample'.
# ==============================================================================

diff -r 8c535232b6c1 -r 1ad85e47d90c dom/security/nsCSPParser.cpp
--- a/dom/security/nsCSPParser.cpp	Thu Jun 20 07:57:31 2024 +0000
+++ b/dom/security/nsCSPParser.cpp	Thu Jun 20 07:57:31 2024 +0000
@@ -689,6 +689,13 @@
   return nullptr;
 }
 
+void nsCSPParser::logWarningForIgnoringNoneKeywordToConsole() {
+  AutoTArray<nsString, 1> params;
+  params.AppendElement(CSP_EnumToUTF16Keyword(CSP_NONE));
+  logWarningErrorToConsole(nsIScriptError::warningFlag, "ignoringUnknownOption",
+                           params);
+}
+
 // source-list = *WSP [ source-expression *( 1*WSP source-expression ) *WSP ]
 //               / *WSP "'none'" *WSP
 void nsCSPParser::sourceList(nsTArray<nsCSPBaseSrc*>& outSrcs) {
@@ -729,10 +736,7 @@
     }
     // Otherwise, we ignore 'none' and report a warning
     else {
-      AutoTArray<nsString, 1> params;
-      params.AppendElement(CSP_EnumToUTF16Keyword(CSP_NONE));
-      logWarningErrorToConsole(nsIScriptError::warningFlag,
-                               "ignoringUnknownOption", params);
+      logWarningForIgnoringNoneKeywordToConsole();
     }
   }
 }
@@ -865,16 +869,7 @@
   mPolicy->addDirective(aDir);
 }
 
-static constexpr auto kTrustedTypesKeywordAllowDuplicates =
-    u"'allow-duplicates'"_ns;
-static constexpr auto kTrustedTypesKeywordNone = u"'none'"_ns;
-
-static bool IsValidTrustedTypesKeyword(const nsAString& aToken) {
-  // tt-keyword = "'allow-duplicates'" / "'none'"
-  return aToken.Equals(kTrustedTypesKeywordAllowDuplicates) ||
-         aToken.Equals(kTrustedTypesKeywordNone);
-}
-
+// https://w3c.github.io/trusted-types/dist/spec/#trusted-types-csp-directive
 static bool IsValidTrustedTypesWildcard(const nsAString& aToken) {
   // tt-wildcard = "*"
   return aToken.Length() == 1 && aToken.First() == WILDCARD;
@@ -889,6 +884,7 @@
          aChar == PERCENT_SIGN;
 }
 
+// https://w3c.github.io/trusted-types/dist/spec/#trusted-types-csp-directive
 static bool IsValidTrustedTypesPolicyName(const nsAString& aToken) {
   // tt-policy-name = 1*( ALPHA / DIGIT / "-" / "#" / "=" / "_" / "/" / "@" /
   // "." / "%")
@@ -906,19 +902,13 @@
   return true;
 }
 
-// https://w3c.github.io/trusted-types/dist/spec/#trusted-types-csp-directive
-static bool IsValidTrustedTypesExpression(const nsAString& aToken) {
-  // tt-expression = tt-policy-name  / tt-keyword / tt-wildcard
-  return IsValidTrustedTypesPolicyName(aToken) ||
-         IsValidTrustedTypesKeyword(aToken) ||
-         IsValidTrustedTypesWildcard(aToken);
-}
-
 void nsCSPParser::handleTrustedTypesDirective(nsCSPDirective* aDir) {
   CSPPARSERLOG(("nsCSPParser::handleTrustedTypesDirective"));
 
   nsTArray<nsCSPBaseSrc*> trustedTypesExpressions;
 
+  bool containsKeywordNone = false;
+
   // "srcs" start and index 1. Here they should represent the tt-expressions
   // (https://w3c.github.io/trusted-types/dist/spec/#trusted-types-csp-directive).
   for (uint32_t i = 1; i < mCurDir.Length(); ++i) {
@@ -927,7 +917,19 @@
     CSPPARSERLOG(("nsCSPParser::handleTrustedTypesDirective, mCurToken: %s",
                   NS_ConvertUTF16toUTF8(mCurToken).get()));
 
-    if (!IsValidTrustedTypesExpression(mCurToken)) {
+    // tt-expression = tt-policy-name  / tt-keyword / tt-wildcard
+    if (IsValidTrustedTypesPolicyName(mCurToken)) {
+      trustedTypesExpressions.AppendElement(
+          new nsCSPTrustedTypesDirectivePolicyName(mCurToken));
+    } else if (CSP_IsKeyword(mCurToken, CSP_NONE)) {
+      containsKeywordNone = true;
+    } else if (CSP_IsKeyword(mCurToken, CSP_ALLOW_DUPLICATES)) {
+      trustedTypesExpressions.AppendElement(
+          new nsCSPKeywordSrc(CSP_ALLOW_DUPLICATES));
+    } else if (IsValidTrustedTypesWildcard(mCurToken)) {
+      trustedTypesExpressions.AppendElement(
+          new nsCSPTrustedTypesDirectivePolicyName(mCurToken));
+    } else {
       AutoTArray<nsString, 1> token = {mCurToken};
       logWarningErrorToConsole(nsIScriptError::errorFlag,
                                "invalidTrustedTypesExpression", token);
@@ -938,15 +940,16 @@
 
       return;
     }
-
-    trustedTypesExpressions.AppendElement(
-        new nsCSPTrustedTypesDirectivePolicyName(mCurToken));
   }
 
   if (trustedTypesExpressions.IsEmpty()) {
     // No tt-expression is equivalent to 'none', see
     // <https://w3c.github.io/trusted-types/dist/spec/#trusted-types-csp-directive>.
     trustedTypesExpressions.AppendElement(new nsCSPKeywordSrc(CSP_NONE));
+  } else if (containsKeywordNone) {
+    // See step 2.4's note at
+    // <https://w3c.github.io/trusted-types/dist/spec/#should-block-create-policy>.
+    logWarningForIgnoringNoneKeywordToConsole();
   }
 
   aDir->addSrcs(trustedTypesExpressions);