# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: 87bc2a8a380e
# Full Hash: 87bc2a8a380ef88aafeec7e012a0c71238f35d95
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2024-06-25 09:36:02
# Regressor Bug: 1894231
# File Overlap Count: 1
# Description:
#   Bug 1894231 - P2 Remove CheckedUnsafePtr<WorkerPrivate> in AutoSyncLoopHolder and AutoPushEventLoopGlobal. r=dom-worker-reviewers,smaug
#   
#   Remove CheckedUnsafePtr<WorkerPrivate> in AutoSyncLoopHolder with a StrongWorkerRef.
#   There is no shutdown callback for AutoSyncLoopHolder::mWorkerRef since Worker's shutdown should be blocked until the created syncLoop is destroyed. Stopping the created syncLoop in the WorkerRef shutdown callback will cause memory leaking which resource releasing should be done during the execution of the syncLoop.
#   
# ==============================================================================

diff -r ab29ecd0d051 -r 87bc2a8a380e dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Mon Jun 24 22:20:50 2024 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Mon Jun 24 22:20:51 2024 +0000
@@ -6373,21 +6373,94 @@
 }
 
 WorkerPrivate::AutoPushEventLoopGlobal::AutoPushEventLoopGlobal(
-    WorkerPrivate* aWorkerPrivate, JSContext* aCx)
-    : mWorkerPrivate(aWorkerPrivate) {
-  auto data = mWorkerPrivate->mWorkerThreadAccessible.Access();
+    WorkerPrivate* aWorkerPrivate, JSContext* aCx) {
+  auto data = aWorkerPrivate->mWorkerThreadAccessible.Access();
   mOldEventLoopGlobal = std::move(data->mCurrentEventLoopGlobal);
   if (JSObject* global = JS::CurrentGlobalOrNull(aCx)) {
     data->mCurrentEventLoopGlobal = xpc::NativeGlobal(global);
   }
+#ifdef DEBUG
+  mNewEventLoopGlobal = data->mCurrentEventLoopGlobal;
+#endif
 }
 
 WorkerPrivate::AutoPushEventLoopGlobal::~AutoPushEventLoopGlobal() {
-  auto data = mWorkerPrivate->mWorkerThreadAccessible.Access();
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+  // We are popping out the event loop global, WorkerPrivate is supposed to be
+  // alive and in a valid status(Running or Canceling)
+  MOZ_ASSERT(workerPrivate);
+  auto data = workerPrivate->mWorkerThreadAccessible.Access();
+#ifdef DEBUG
+  // Saved event loop global should be matched.
+  MOZ_ASSERT(data->mCurrentEventLoopGlobal == mNewEventLoopGlobal);
+  mNewEventLoopGlobal = nullptr;
+#endif
   data->mCurrentEventLoopGlobal = std::move(mOldEventLoopGlobal);
 }
 
 // -----------------------------------------------------------------------------
+// AutoSyncLoopHolder
+
+AutoSyncLoopHolder::AutoSyncLoopHolder(WorkerPrivate* aWorkerPrivate,
+                                       WorkerStatus aFailStatus,
+                                       const char* const aName)
+    : mTarget(aWorkerPrivate->CreateNewSyncLoop(aFailStatus)),
+      mIndex(aWorkerPrivate->mSyncLoopStack.Length() - 1) {
+  aWorkerPrivate->AssertIsOnWorkerThread();
+  LOGV(
+      ("AutoSyncLoopHolder::AutoSyncLoopHolder [%p] creator: %s", this, aName));
+  if (aFailStatus < Canceling) {
+    mWorkerRef = StrongWorkerRef::Create(aWorkerPrivate, aName, [aName]() {
+      // Do nothing with the shutdown callback here since we need to wait for
+      // the underlying SyncLoop to complete by itself.
+      LOGV(
+          ("AutoSyncLoopHolder::AutoSyncLoopHolder Worker starts to shutdown "
+           "with a AutoSyncLoopHolder(%s).",
+           aName));
+    });
+  } else {
+    LOGV(
+        ("AutoSyncLoopHolder::AutoSyncLoopHolder [%p] Create "
+         "AutoSyncLoopHolder(%s) while Worker is shutting down",
+         this, aName));
+    mWorkerRef = StrongWorkerRef::CreateForcibly(aWorkerPrivate, aName);
+  }
+  // mWorkerRef can be nullptr here.
+}
+
+AutoSyncLoopHolder::~AutoSyncLoopHolder() {
+  if (mWorkerRef && mTarget) {
+    mWorkerRef->Private()->AssertIsOnWorkerThread();
+    mWorkerRef->Private()->StopSyncLoop(mTarget, NS_ERROR_FAILURE);
+    mWorkerRef->Private()->DestroySyncLoop(mIndex);
+  }
+}
+
+nsresult AutoSyncLoopHolder::Run() {
+  if (mWorkerRef) {
+    WorkerPrivate* workerPrivate = mWorkerRef->Private();
+    MOZ_ASSERT(workerPrivate);
+
+    workerPrivate->AssertIsOnWorkerThread();
+
+    nsresult rv = workerPrivate->RunCurrentSyncLoop();
+
+    // The sync loop is done, sync loop has already destroyed in the end of
+    // WorkerPrivate::RunCurrentSyncLoop(). So, release mWorkerRef here to
+    // avoid destroying sync loop again in the ~AutoSyncLoopHolder();
+    mWorkerRef = nullptr;
+
+    return rv;
+  }
+  return NS_OK;
+}
+
+nsISerialEventTarget* AutoSyncLoopHolder::GetSerialEventTarget() const {
+  // This can be null if CreateNewSyncLoop() fails.
+  return mTarget;
+}
+
+// -----------------------------------------------------------------------------
 // WorkerParentRef
 WorkerParentRef::WorkerParentRef(RefPtr<WorkerPrivate>& aWorkerPrivate)
     : mWorkerPrivate(aWorkerPrivate) {