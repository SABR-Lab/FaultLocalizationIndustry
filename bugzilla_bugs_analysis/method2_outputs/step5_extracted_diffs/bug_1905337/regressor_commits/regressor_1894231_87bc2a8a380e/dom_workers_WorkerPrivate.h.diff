# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.h
# Commit: 87bc2a8a380e
# Full Hash: 87bc2a8a380ef88aafeec7e012a0c71238f35d95
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2024-06-25 09:36:02
# Regressor Bug: 1894231
# File Overlap Count: 1
# Description:
#   Bug 1894231 - P2 Remove CheckedUnsafePtr<WorkerPrivate> in AutoSyncLoopHolder and AutoPushEventLoopGlobal. r=dom-worker-reviewers,smaug
#   
#   Remove CheckedUnsafePtr<WorkerPrivate> in AutoSyncLoopHolder with a StrongWorkerRef.
#   There is no shutdown callback for AutoSyncLoopHolder::mWorkerRef since Worker's shutdown should be blocked until the created syncLoop is destroyed. Stopping the created syncLoop in the WorkerRef shutdown callback will cause memory leaking which resource releasing should be done during the execution of the syncLoop.
#   
# ==============================================================================

diff -r ab29ecd0d051 -r 87bc2a8a380e dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h	Mon Jun 24 22:20:50 2024 +0000
+++ b/dom/workers/WorkerPrivate.h	Mon Jun 24 22:20:51 2024 +0000
@@ -77,6 +77,7 @@
 class MessagePort;
 class UniqueMessagePortId;
 class PerformanceStorage;
+class StrongWorkerRef;
 class TimeoutHandler;
 class WorkerControlRunnable;
 class WorkerCSPEventListener;
@@ -1556,10 +1557,13 @@
     ~AutoPushEventLoopGlobal();
 
    private:
-    // We cannot make this CheckedUnsafePtr<WorkerPrivate> as this would violate
-    // our static assert
-    MOZ_NON_OWNING_REF WorkerPrivate* mWorkerPrivate;
     nsCOMPtr<nsIGlobalObject> mOldEventLoopGlobal;
+
+#ifdef DEBUG
+    // This is used to checking if we are on the right stack while push the
+    // mOldEventLoopGlobal back.
+    nsCOMPtr<nsIGlobalObject> mNewEventLoopGlobal;
+#endif
   };
   friend class AutoPushEventLoopGlobal;
 
@@ -1661,41 +1665,21 @@
 };
 
 class AutoSyncLoopHolder {
-  CheckedUnsafePtr<WorkerPrivate> mWorkerPrivate;
+  RefPtr<StrongWorkerRef> mWorkerRef;
   nsCOMPtr<nsISerialEventTarget> mTarget;
   uint32_t mIndex;
 
  public:
   // See CreateNewSyncLoop() for more information about the correct value to use
   // for aFailStatus.
-  AutoSyncLoopHolder(WorkerPrivate* aWorkerPrivate, WorkerStatus aFailStatus)
-      : mWorkerPrivate(aWorkerPrivate),
-        mTarget(aWorkerPrivate->CreateNewSyncLoop(aFailStatus)),
-        mIndex(aWorkerPrivate->mSyncLoopStack.Length() - 1) {
-    aWorkerPrivate->AssertIsOnWorkerThread();
-  }
+  AutoSyncLoopHolder(WorkerPrivate* aWorkerPrivate, WorkerStatus aFailStatus,
+                     const char* const aName = "AutoSyncLoopHolder");
 
-  ~AutoSyncLoopHolder() {
-    if (mWorkerPrivate && mTarget) {
-      mWorkerPrivate->AssertIsOnWorkerThread();
-      mWorkerPrivate->StopSyncLoop(mTarget, NS_ERROR_FAILURE);
-      mWorkerPrivate->DestroySyncLoop(mIndex);
-    }
-  }
+  ~AutoSyncLoopHolder();
 
-  nsresult Run() {
-    CheckedUnsafePtr<WorkerPrivate> workerPrivate = mWorkerPrivate;
-    mWorkerPrivate = nullptr;
-
-    workerPrivate->AssertIsOnWorkerThread();
+  nsresult Run();
 
-    return workerPrivate->RunCurrentSyncLoop();
-  }
-
-  nsISerialEventTarget* GetSerialEventTarget() const {
-    // This can be null if CreateNewSyncLoop() fails.
-    return mTarget;
-  }
+  nsISerialEventTarget* GetSerialEventTarget() const;
 };
 
 /**
