# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: b7d4fb0fcc54
# Full Hash: b7d4fb0fcc54c929650660f1c61b63bb4694766f
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2024-06-25 09:36:02
# Regressor Bug: 1894231
# File Overlap Count: 1
# Description:
#   Bug 1894231 - P11 Remove WorkerThreadRunnable::mWorkerPrivateForPreStartCleaning. r=dom-worker-reviewers,asuth
#   
#   This patch introduces a boolean WorkerThreadRunnable::mCleanPreStartDispatching to indicate if the WorkerThreadRunnable needs to skip its execution in its Run() because of WorkerPrivate::RunLoopNeverRan().
#   
#   If any WorkerPrivate initialization fails in [[ https://searchfox.org/mozilla-central/rev/a26e972e97fbec860400d80df625193f4c88d64e/dom/workers/RuntimeService.cpp#2090-2120 | WorkerThreadPrimaryRunnable::Run() ]], corresponding WorkerJSContext might not be created or created then destroyed before entering [[ https://searchfox.org/mozilla-central/rev/a26e972e97fbec860400d80df625193f4c88d64e/dom/workers/RuntimeService.cpp#2085 | WorkerPrivate::RunLoopNeverRan() ]]. This invalidates the WorkerJSContext, and GetCurrentThreadWorkerPrivate() will not work correctly. In this case, any WorkerThreadRunnable should not run in this invalid environment, so we can just skip the execution by returning NS_OK in its Run().
# ==============================================================================

diff -r bb302697f033 -r b7d4fb0fcc54 dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Mon Jun 24 22:20:54 2024 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Mon Jun 24 22:20:54 2024 +0000
@@ -1624,7 +1624,6 @@
            this, runnable.get()));
       RefPtr<WorkerThreadRunnable> workerThreadRunnable =
           static_cast<WorkerThreadRunnable*>(runnable.get());
-      workerThreadRunnable->mWorkerPrivateForPreStartCleaning = this;
       mPreStartRunnables.AppendElement(workerThreadRunnable);
       return NS_OK;
     }
@@ -3216,12 +3215,14 @@
   RefPtr<WorkerThread> thread;
   {
     MutexAutoLock lock(mMutex);
-    // WorkerPrivate::DoRunLoop() is never called, so CompileScriptRunnable
-    // should not execute yet. However, the Worker is going to "Dead", flip the
-    // mCancelBeforeWorkerScopeConstructed to true for the dispatched runnables
-    // to indicate runnables there is no valid WorkerGlobalScope for executing.
-    MOZ_ASSERT(!data->mCancelBeforeWorkerScopeConstructed);
-    data->mCancelBeforeWorkerScopeConstructed.Flip();
+
+    if (!mPreStartRunnables.IsEmpty()) {
+      for (const RefPtr<WorkerThreadRunnable>& runnable : mPreStartRunnables) {
+        runnable->mCleanPreStartDispatching = true;
+      }
+      mPreStartRunnables.Clear();
+    }
+
     // Switch State to Dead
     mStatus = Dead;
     thread = mThread;
@@ -3279,6 +3280,10 @@
 
     MOZ_ASSERT(mStatus == Pending);
     mStatus = Running;
+
+    // Now, start to run the event loop, mPreStartRunnables can be cleared,
+    // since when get here, Worker initialization has done successfully.
+    mPreStartRunnables.Clear();
   }
 
   // Now that we've done that, we can go ahead and set up our AutoJSAPI.  We
@@ -4192,7 +4197,7 @@
 }
 
 void WorkerPrivate::ClearPreStartRunnables() {
-  nsTArray<RefPtr<WorkerRunnable>> prestart;
+  nsTArray<RefPtr<WorkerThreadRunnable>> prestart;
   {
     MutexAutoLock lock(mMutex);
     mPreStartRunnables.SwapElements(prestart);
@@ -5858,7 +5863,8 @@
       MOZ_ALWAYS_SUCCEEDS(mThread->DispatchAnyThread(
           WorkerThreadFriendKey{}, mPreStartRunnables[index].forget()));
     }
-    mPreStartRunnables.Clear();
+    // Don't clear mPreStartRunnables here, it will be cleared in the beginning
+    // of WorkerPrivate::DoRunLoop() or when in WorkerPrivate::RunLoopNeverRan()
   }
 }
 