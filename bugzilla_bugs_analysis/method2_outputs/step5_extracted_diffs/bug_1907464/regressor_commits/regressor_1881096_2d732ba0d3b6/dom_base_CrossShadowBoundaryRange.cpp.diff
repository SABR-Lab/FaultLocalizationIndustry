# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/CrossShadowBoundaryRange.cpp
# Commit: 2d732ba0d3b6
# Full Hash: 2d732ba0d3b6f7ec0be35261ebffb8331fe2cb23
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-06-21 04:13:05
# Regressor Bug: 1881096
# File Overlap Count: 2
# Description:
#   Bug 1881096 - Invalidate the boundary offset when a child of container is being removed for CrossShadowBoundaryRange r=emilio,jjaschke,dom-core
#   
#   This is added to support the use case of nsPrintJob where new
#   ranges were created and elements within these ranges are removed.
#   
# ==============================================================================

diff -r ae87b6009cbc -r 2d732ba0d3b6 dom/base/CrossShadowBoundaryRange.cpp
--- a/dom/base/CrossShadowBoundaryRange.cpp	Thu Jun 20 20:15:15 2024 +0000
+++ b/dom/base/CrossShadowBoundaryRange.cpp	Thu Jun 20 20:15:50 2024 +0000
@@ -147,13 +147,16 @@
 
   RefPtr<CrossShadowBoundaryRange> kungFuDeathGrip(this);
 
-  if (mStart.Container() == aChild || mEnd.Container() == aChild) {
+  const nsINode* startContainer = mStart.Container();
+  const nsINode* endContainer = mEnd.Container();
+
+  if (startContainer == aChild || endContainer == aChild) {
     mOwner->ResetCrossShadowBoundaryRange();
     return;
   }
 
   if (const auto* shadowRoot = aChild->GetShadowRoot()) {
-    if (mStart.Container() == shadowRoot || mEnd.Container() == shadowRoot) {
+    if (startContainer == shadowRoot || endContainer == shadowRoot) {
       mOwner->ResetCrossShadowBoundaryRange();
       return;
     }
@@ -164,5 +167,35 @@
     mOwner->ResetCrossShadowBoundaryRange();
     return;
   }
+
+  nsINode* container = aChild->GetParentNode();
+
+  auto MaybeCreateNewBoundary =
+      [container, aChild, aPreviousSibling](
+          const nsINode* aContainer,
+          const RangeBoundary& aBoundary) -> Maybe<RawRangeBoundary> {
+    if (container == aContainer) {
+      // We're only interested if our boundary reference was removed, otherwise
+      // we can just invalidate the offset.
+      if (aChild == aBoundary.Ref()) {
+        return Some<RawRangeBoundary>({container, aPreviousSibling});
+      }
+      RawRangeBoundary newBoundary;
+      newBoundary.CopyFrom(aBoundary, RangeBoundaryIsMutationObserved::Yes);
+      newBoundary.InvalidateOffset();
+      return Some(newBoundary);
+    }
+    return Nothing();
+  };
+
+  const Maybe<RawRangeBoundary> newStartBoundary =
+      MaybeCreateNewBoundary(startContainer, mStart);
+  const Maybe<RawRangeBoundary> newEndBoundary =
+      MaybeCreateNewBoundary(endContainer, mEnd);
+
+  if (newStartBoundary || newEndBoundary) {
+    SetStartAndEnd(newStartBoundary ? newStartBoundary.ref() : mStart.AsRaw(),
+                   newEndBoundary ? newEndBoundary.ref() : mEnd.AsRaw());
+  }
 }
 }  // namespace mozilla::dom