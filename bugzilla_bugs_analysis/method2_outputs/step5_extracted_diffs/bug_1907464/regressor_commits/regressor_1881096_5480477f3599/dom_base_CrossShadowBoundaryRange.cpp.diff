# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/CrossShadowBoundaryRange.cpp
# Commit: 5480477f3599
# Full Hash: 5480477f35993b93846c693c8e388f727ea18dc4
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-06-21 04:13:05
# Regressor Bug: 1881096
# File Overlap Count: 2
# Description:
#   Bug 1881096 - Add basic support of character removal to CrossShadowBoundaryRange r=emilio,jjaschke,dom-core
#   
#   Because nsPrintJob would remove characters from the selected boundary
#   nodes, the offsets of the boundaries needs to be updated if this
#   happens.
# ==============================================================================

diff -r 2d732ba0d3b6 -r 5480477f3599 dom/base/CrossShadowBoundaryRange.cpp
--- a/dom/base/CrossShadowBoundaryRange.cpp	Thu Jun 20 20:15:50 2024 +0000
+++ b/dom/base/CrossShadowBoundaryRange.cpp	Thu Jun 20 20:15:51 2024 +0000
@@ -198,4 +198,49 @@
                    newEndBoundary ? newEndBoundary.ref() : mEnd.AsRaw());
   }
 }
+
+// For now CrossShadowBoundaryRange::CharacterDataChanged is only meant
+// to handle the character removal initiated by nsRange::CutContents.
+void CrossShadowBoundaryRange::CharacterDataChanged(
+    nsIContent* aContent, const CharacterDataChangeInfo& aInfo) {
+  // When aInfo.mDetails is present, it means the character data was
+  // changed due to splitText() or normalize(), which shouldn't be the
+  // case for nsRange::CutContents, so we return early.
+  if (aInfo.mDetails) {
+    return;
+  }
+  MOZ_ASSERT(aContent);
+  MOZ_ASSERT(mIsPositioned);
+
+  auto MaybeCreateNewBoundary =
+      [aContent,
+       &aInfo](const RangeBoundary& aBoundary) -> Maybe<RawRangeBoundary> {
+    // If the changed node contains our start boundary and the change starts
+    // before the boundary we'll need to adjust the offset.
+    if (aContent == aBoundary.Container() &&
+        // aInfo.mChangeStart is the offset where the change starts, if it's
+        // smaller than the offset of aBoundary, it means the characters
+        // before the selected content is changed (i.e, removed), so the
+        // offset of aBoundary needs to be adjusted.
+        aInfo.mChangeStart <
+            *aBoundary.Offset(
+                RangeBoundary::OffsetFilter::kValidOrInvalidOffsets)) {
+      RawRangeBoundary newStart =
+          nsRange::ComputeNewBoundaryWhenBoundaryInsideChangedText(
+              aInfo, aBoundary.AsRaw());
+      return Some(newStart);
+    }
+    return Nothing();
+  };
+
+  const Maybe<RawRangeBoundary> newStartBoundary =
+      MaybeCreateNewBoundary(mStart);
+  const Maybe<RawRangeBoundary> newEndBoundary = MaybeCreateNewBoundary(mEnd);
+
+  if (newStartBoundary || newEndBoundary) {
+    DoSetRange(newStartBoundary ? newStartBoundary.ref() : mStart.AsRaw(),
+               newEndBoundary ? newEndBoundary.ref() : mEnd.AsRaw(), nullptr,
+               mOwner);
+  }
+}
 }  // namespace mozilla::dom