# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsRange.cpp
# Commit: 5480477f3599
# Full Hash: 5480477f35993b93846c693c8e388f727ea18dc4
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2024-06-21 04:13:05
# Regressor Bug: 1881096
# File Overlap Count: 2
# Description:
#   Bug 1881096 - Add basic support of character removal to CrossShadowBoundaryRange r=emilio,jjaschke,dom-core
#   
#   Because nsPrintJob would remove characters from the selected boundary
#   nodes, the offsets of the boundaries needs to be updated if this
#   happens.
# ==============================================================================

diff -r 2d732ba0d3b6 -r 5480477f3599 dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp	Thu Jun 20 20:15:50 2024 +0000
+++ b/dom/base/nsRange.cpp	Thu Jun 20 20:15:51 2024 +0000
@@ -511,22 +511,8 @@
             ->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
       }
     } else {
-      // If boundary is inside changed text, position it before change
-      // else adjust start offset for the change in length.
-      CheckedUint32 newStartOffset{0};
-      if (*mStart.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets) <=
-          aInfo.mChangeEnd) {
-        newStartOffset = aInfo.mChangeStart;
-      } else {
-        newStartOffset =
-            *mStart.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets);
-        newStartOffset -= aInfo.LengthOfRemovedText();
-        newStartOffset += aInfo.mReplaceLength;
-      }
-
-      // newStartOffset.isValid() isn't checked explicitly here, because
-      // newStartOffset.value() contains an assertion.
-      newStart = {mStart.Container(), newStartOffset.value()};
+      newStart = ComputeNewBoundaryWhenBoundaryInsideChangedText(
+          aInfo, mStart.AsRaw());
     }
   }
 
@@ -567,20 +553,8 @@
             ->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
       }
     } else {
-      CheckedUint32 newEndOffset{0};
-      if (*mEnd.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets) <=
-          aInfo.mChangeEnd) {
-        newEndOffset = aInfo.mChangeStart;
-      } else {
-        newEndOffset =
-            *mEnd.Offset(RangeBoundary::OffsetFilter::kValidOrInvalidOffsets);
-        newEndOffset -= aInfo.LengthOfRemovedText();
-        newEndOffset += aInfo.mReplaceLength;
-      }
-
-      // newEndOffset.isValid() isn't checked explicitly here, because
-      // newEndOffset.value() contains an assertion.
-      newEnd = {mEnd.Container(), newEndOffset.value()};
+      newEnd =
+          ComputeNewBoundaryWhenBoundaryInsideChangedText(aInfo, mEnd.AsRaw());
     }
   }
 
@@ -3549,3 +3523,27 @@
 
   mCrossShadowBoundaryRange->SetStartAndEnd(aStartBoundary, aEndBoundary);
 }
+
+RawRangeBoundary nsRange::ComputeNewBoundaryWhenBoundaryInsideChangedText(
+    const CharacterDataChangeInfo& aInfo, const RawRangeBoundary& aBoundary) {
+  MOZ_ASSERT(aInfo.mChangeStart <
+             *aBoundary.Offset(
+                 RawRangeBoundary::OffsetFilter::kValidOrInvalidOffsets));
+  // If boundary is inside changed text, position it before change
+  // else adjust start offset for the change in length.
+  CheckedUint32 newOffset{0};
+  if (*aBoundary.Offset(
+          RawRangeBoundary::OffsetFilter::kValidOrInvalidOffsets) <=
+      aInfo.mChangeEnd) {
+    newOffset = aInfo.mChangeStart;
+  } else {
+    newOffset = *aBoundary.Offset(
+        RawRangeBoundary::OffsetFilter::kValidOrInvalidOffsets);
+    newOffset -= aInfo.LengthOfRemovedText();
+    newOffset += aInfo.mReplaceLength;
+  }
+
+  // newOffset.isValid() isn't checked explicitly here, because
+  // newOffset.value() contains an assertion.
+  return {aBoundary.Container(), newOffset.value()};
+}