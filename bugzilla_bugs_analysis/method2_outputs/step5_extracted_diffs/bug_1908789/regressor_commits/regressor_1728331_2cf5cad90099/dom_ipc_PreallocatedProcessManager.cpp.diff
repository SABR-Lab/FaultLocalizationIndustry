# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/PreallocatedProcessManager.cpp
# Commit: 2cf5cad90099
# Full Hash: 2cf5cad900992236d596bfb329099742ff15f689
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2024-06-20 04:08:16
# Regressor Bug: 1728331
# File Overlap Count: 1
# Description:
#   Bug 1728331 - Part 4: Make ContentParent KeepAlives explicit with RAII references, r=smaug,dom-worker-reviewers,asuth
#   
#   This is a fairly significant patch, however it would be difficult to break it
#   down into smaller patches:
#   
# ==============================================================================

diff -r d920c2d72d00 -r 2cf5cad90099 dom/ipc/PreallocatedProcessManager.cpp
--- a/dom/ipc/PreallocatedProcessManager.cpp	Wed Jun 19 20:14:49 2024 +0000
+++ b/dom/ipc/PreallocatedProcessManager.cpp	Wed Jun 19 20:14:50 2024 +0000
@@ -41,7 +41,7 @@
   // See comments on PreallocatedProcessManager for these methods.
   void AddBlocker(ContentParent* aParent);
   void RemoveBlocker(ContentParent* aParent);
-  already_AddRefed<ContentParent> Take(const nsACString& aRemoteType);
+  UniqueContentParentKeepAlive Take(const nsACString& aRemoteType);
   void Erase(ContentParent* aParent);
 
  private:
@@ -77,7 +77,7 @@
 
   bool mEnabled;
   uint32_t mNumberPreallocs;
-  AutoTArray<RefPtr<ContentParent>, 3> mPreallocatedProcesses;
+  AutoTArray<UniqueContentParentKeepAlive, 3> mPreallocatedProcesses;
   // Even if we have multiple PreallocatedProcessManagerImpls, we'll have
   // one blocker counter
   static uint32_t sNumBlockers;
@@ -192,14 +192,14 @@
   }
 }
 
-already_AddRefed<ContentParent> PreallocatedProcessManagerImpl::Take(
+UniqueContentParentKeepAlive PreallocatedProcessManagerImpl::Take(
     const nsACString& aRemoteType) {
   if (!IsEnabled()) {
     return nullptr;
   }
-  RefPtr<ContentParent> process;
+  UniqueContentParentKeepAlive process;
   if (!IsEmpty()) {
-    process = mPreallocatedProcesses.ElementAt(0);
+    process = std::move(mPreallocatedProcesses.ElementAt(0));
     mPreallocatedProcesses.RemoveElementAt(0);
 
     // Don't set the priority to FOREGROUND here, since it may not have
@@ -207,7 +207,7 @@
 
     // We took a preallocated process. Let's try to start up a new one
     // soon.
-    ContentParent* last = mPreallocatedProcesses.SafeLastElement(nullptr);
+    ContentParent* last = mPreallocatedProcesses.SafeLastElement(nullptr).get();
     // There could be a launching process that isn't the last, but that's
     // ok (and unlikely)
     if (!last || !last->IsLaunching()) {
@@ -219,11 +219,11 @@
              (unsigned long)mPreallocatedProcesses.Length()));
   }
   if (process && !process->IsLaunching()) {
-    ProcessPriorityManager::SetProcessPriority(process,
+    ProcessPriorityManager::SetProcessPriority(process.get(),
                                                PROCESS_PRIORITY_FOREGROUND);
   }  // else this will get set by the caller when they call InitInternal()
 
-  return process.forget();
+  return process;
 }
 
 void PreallocatedProcessManagerImpl::Erase(ContentParent* aParent) {
@@ -315,19 +315,14 @@
     return;
   }
 
-  RefPtr<ContentParent> process = ContentParent::MakePreallocProcess();
-  mPreallocatedProcesses.AppendElement(process);
-  MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
-          ("Preallocated = %lu of %d processes",
-           (unsigned long)mPreallocatedProcesses.Length(), mNumberPreallocs));
-
-  RefPtr<PreallocatedProcessManagerImpl> self(this);
-  process->LaunchSubprocessAsync(PROCESS_PRIORITY_PREALLOC)
+  UniqueContentParentKeepAlive process = ContentParent::MakePreallocProcess();
+  process->WaitForLaunchAsync(PROCESS_PRIORITY_PREALLOC)
       ->Then(
           GetCurrentSerialEventTarget(), __func__,
-          [self, this, process](const RefPtr<ContentParent>&) {
+          [self = RefPtr{this},
+           process = RefPtr{process.get()}](UniqueContentParentKeepAlive) {
             if (process->IsDead()) {
-              Erase(process);
+              self->Erase(process);
               // Process died in startup (before we could add it).  If it
               // dies after this, MarkAsDead() will Erase() this entry.
               // Shouldn't be in the sBrowserContentParents, so we don't need
@@ -335,24 +330,22 @@
               // preallocation here, to avoid possible looping if something is
               // causing them to consistently fail; if everything is ok on the
               // next allocation request we'll kick off creation.
-            } else {
+            } else if (self->CanAllocate()) {
               // Continue prestarting processes if needed
-              if (CanAllocate()) {
-                if (mPreallocatedProcesses.Length() < mNumberPreallocs) {
-                  AllocateOnIdle();
-                }
-              } else if (!IsEnabled()) {
-                // if this has a remote type set, it's been allocated for use
-                // already
-                if (process->mRemoteType == PREALLOC_REMOTE_TYPE) {
-                  // This will Erase() it
-                  process->ShutDownProcess(
-                      ContentParent::SEND_SHUTDOWN_MESSAGE);
-                }
+              if (self->mPreallocatedProcesses.Length() <
+                  self->mNumberPreallocs) {
+                self->AllocateOnIdle();
               }
             }
           },
-          [self, this, process]() { Erase(process); });
+          [self = RefPtr{this}, process = RefPtr{process.get()}]() {
+            self->Erase(process);
+          });
+
+  mPreallocatedProcesses.AppendElement(std::move(process));
+  MOZ_LOG(ContentParent::GetLog(), LogLevel::Debug,
+          ("Preallocated = %lu of %d processes",
+           (unsigned long)mPreallocatedProcesses.Length(), mNumberPreallocs));
 }
 
 void PreallocatedProcessManagerImpl::Disable() {
@@ -365,12 +358,9 @@
 }
 
 void PreallocatedProcessManagerImpl::CloseProcesses() {
-  while (!IsEmpty()) {
-    RefPtr<ContentParent> process(mPreallocatedProcesses.ElementAt(0));
-    mPreallocatedProcesses.RemoveElementAt(0);
-    process->ShutDownProcess(ContentParent::SEND_SHUTDOWN_MESSAGE);
-    // drop ref and let it free
-  }
+  // Drop our KeepAlives on these processes. This will automatically lead to the
+  // processes being shut down when no keepalives are left.
+  mPreallocatedProcesses.Clear();
 }
 
 inline PreallocatedProcessManagerImpl*
@@ -414,7 +404,7 @@
 }
 
 /* static */
-already_AddRefed<ContentParent> PreallocatedProcessManager::Take(
+UniqueContentParentKeepAlive PreallocatedProcessManager::Take(
     const nsACString& aRemoteType) {
   if (auto impl = GetPPMImpl()) {
     return impl->Take(aRemoteType);