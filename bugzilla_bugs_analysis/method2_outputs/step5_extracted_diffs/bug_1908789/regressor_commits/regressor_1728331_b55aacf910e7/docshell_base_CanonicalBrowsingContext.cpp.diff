# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: docshell/base/CanonicalBrowsingContext.cpp
# Commit: b55aacf910e7
# Full Hash: b55aacf910e704508a5820c09b25411142ccf7cb
# Author: Nika Layzell <nika@thelayzells.com>
# Date: 2024-06-25 09:36:02
# Regressor Bug: 1728331
# File Overlap Count: 1
# Description:
#   Bug 1728331 - Part 4: Make ContentParent KeepAlives explicit with RAII references, r=smaug,dom-worker-reviewers,asuth
#   
#   This is a fairly significant patch, however it would be difficult to break it
#   down into smaller patches:
#   
# ==============================================================================

diff -r 3dd07ed49638 -r b55aacf910e7 docshell/base/CanonicalBrowsingContext.cpp
--- a/docshell/base/CanonicalBrowsingContext.cpp	Mon Jun 24 23:19:28 2024 +0000
+++ b/docshell/base/CanonicalBrowsingContext.cpp	Mon Jun 24 23:19:28 2024 +0000
@@ -1738,10 +1738,10 @@
     return;
   }
 
-  if (mContentParent) {
+  if (mContentParentKeepAlive) {
     // If our new content process is still unloading from a previous process
     // switch, wait for that unload to complete before continuing.
-    auto found = mTarget->FindUnloadingHost(mContentParent->ChildID());
+    auto found = mTarget->FindUnloadingHost(mContentParentKeepAlive->ChildID());
     if (found != mTarget->mUnloadingHosts.end()) {
       found->mCallbacks.AppendElement(
           [self = RefPtr{this}]() { self->ProcessReady(); });
@@ -1791,7 +1791,8 @@
                         "non-remote iframes");
 
   // Abort if our ContentParent died while process switching.
-  if (mContentParent && NS_WARN_IF(mContentParent->IsShuttingDown())) {
+  if (mContentParentKeepAlive &&
+      NS_WARN_IF(mContentParentKeepAlive->IsShuttingDown())) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1842,14 +1843,14 @@
   // Some frontend code checks the value of the `remote` attribute on the
   // browser to determine if it is remote, so update the value.
   browserElement->SetAttr(kNameSpaceID_None, nsGkAtoms::remote,
-                          mContentParent ? u"true"_ns : u"false"_ns,
+                          mContentParentKeepAlive ? u"true"_ns : u"false"_ns,
                           /* notify */ true);
 
   // The process has been created, hand off to nsFrameLoaderOwner to finish
   // the process switch.
   ErrorResult error;
-  frameLoaderOwner->ChangeRemotenessToProcess(mContentParent, mOptions,
-                                              mSpecificGroup, error);
+  frameLoaderOwner->ChangeRemotenessToProcess(mContentParentKeepAlive.get(),
+                                              mOptions, mSpecificGroup, error);
   if (error.Failed()) {
     return error.StealNSResult();
   }
@@ -1865,7 +1866,7 @@
   RefPtr<nsFrameLoader> frameLoader = frameLoaderOwner->GetFrameLoader();
   RefPtr<BrowserParent> newBrowser = frameLoader->GetBrowserParent();
   if (!newBrowser) {
-    if (mContentParent) {
+    if (mContentParentKeepAlive) {
       // Failed to create the BrowserParent somehow! Abort the process switch
       // attempt.
       return NS_ERROR_UNEXPECTED;
@@ -1904,7 +1905,7 @@
     return NS_ERROR_FAILURE;
   }
 
-  if (NS_WARN_IF(!mContentParent)) {
+  if (NS_WARN_IF(!mContentParentKeepAlive)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1920,8 +1921,8 @@
 
   // If we're creating a new remote browser, and the host process is already
   // dead, abort the process switch.
-  if (mContentParent != embedderBrowser->Manager() &&
-      NS_WARN_IF(mContentParent->IsShuttingDown())) {
+  if (mContentParentKeepAlive != embedderBrowser->Manager() &&
+      NS_WARN_IF(mContentParentKeepAlive->IsShuttingDown())) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1947,11 +1948,11 @@
   }
 
   // Update which process is considered the current owner
-  target->SetOwnerProcessId(mContentParent->ChildID());
+  target->SetOwnerProcessId(mContentParentKeepAlive->ChildID());
 
   // If we're switching from remote to local, we don't need to create a
   // BrowserBridge, and can instead perform the switch directly.
-  if (mContentParent == embedderBrowser->Manager()) {
+  if (mContentParentKeepAlive == embedderBrowser->Manager()) {
     MOZ_DIAGNOSTIC_ASSERT(
         mPendingSwitchId,
         "We always have a PendingSwitchId, except for print-preview loads, "
@@ -1987,8 +1988,9 @@
   // Create and initialize our new BrowserBridgeParent.
   TabId tabId(nsContentUtils::GenerateTabId());
   RefPtr<BrowserBridgeParent> bridge = new BrowserBridgeParent();
-  nsresult rv = bridge->InitWithProcess(embedderBrowser, mContentParent,
-                                        windowInit, chromeFlags, tabId);
+  nsresult rv =
+      bridge->InitWithProcess(embedderBrowser, mContentParentKeepAlive.get(),
+                              windowInit, chromeFlags, tabId);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     // If we've already destroyed our previous document, make a best-effort
     // attempt to recover from this failure and show the crashed tab UI. We only
@@ -2053,11 +2055,8 @@
   }
 
   // When this PendingRemotenessChange was created, it was given a
-  // `mContentParent`.
-  if (mContentParent) {
-    mContentParent->RemoveKeepAlive();
-    mContentParent = nullptr;
-  }
+  // `mContentParentKeepAlive`.
+  mContentParentKeepAlive = nullptr;
 
   // If we were given a specific group, stop keeping that group alive manually.
   if (mSpecificGroup) {
@@ -2078,8 +2077,9 @@
       mOptions(aOptions) {}
 
 CanonicalBrowsingContext::PendingRemotenessChange::~PendingRemotenessChange() {
-  MOZ_ASSERT(!mPromise && !mTarget && !mContentParent && !mSpecificGroup,
-             "should've already been Cancel() or Complete()-ed");
+  MOZ_ASSERT(
+      !mPromise && !mTarget && !mContentParentKeepAlive && !mSpecificGroup,
+      "should've already been Cancel() or Complete()-ed");
 }
 
 BrowserParent* CanonicalBrowsingContext::GetBrowserParent() const {
@@ -2226,8 +2226,8 @@
 
     // Switching to local, so we don't need to create a new process, and will
     // instead use our embedder process.
-    change->mContentParent = embedderBrowser->Manager();
-    change->mContentParent->AddKeepAlive();
+    change->mContentParentKeepAlive =
+        embedderBrowser->Manager()->AddKeepAlive(BrowserId());
     change->ProcessLaunched();
     return promise.forget();
   }
@@ -2245,8 +2245,8 @@
   if (existingProcess && !existingProcess->IsShuttingDown() &&
       aOptions.mReplaceBrowsingContext &&
       aOptions.mRemoteType == existingProcess->GetRemoteType()) {
-    change->mContentParent = existingProcess;
-    change->mContentParent->AddKeepAlive();
+    change->mContentParentKeepAlive =
+        existingProcess->AddKeepAlive(BrowserId());
     change->ProcessLaunched();
     return promise.forget();
   }
@@ -2265,25 +2265,28 @@
   bool preferUsed =
       StaticPrefs::browser_tabs_remote_subframesPreferUsed() && !IsTop();
 
-  change->mContentParent = ContentParent::GetNewOrUsedLaunchingBrowserProcess(
-      /* aRemoteType = */ aOptions.mRemoteType,
-      /* aGroup = */ finalGroup,
-      /* aPriority = */ hal::PROCESS_PRIORITY_FOREGROUND,
-      /* aPreferUsed = */ preferUsed);
-  if (!change->mContentParent) {
+  change->mContentParentKeepAlive =
+      ContentParent::GetNewOrUsedLaunchingBrowserProcess(
+          /* aRemoteType = */ aOptions.mRemoteType,
+          /* aGroup = */ finalGroup,
+          /* aPriority = */ hal::PROCESS_PRIORITY_FOREGROUND,
+          /* aPreferUsed = */ preferUsed,
+          /* aBrowserId */ BrowserId());
+  if (!change->mContentParentKeepAlive) {
     change->Cancel(NS_ERROR_FAILURE);
     return promise.forget();
   }
 
-  // Add a KeepAlive used by this ContentParent, which will be cleared when
-  // the change is complete. This should prevent the process dying before
-  // we're ready to use it.
-  change->mContentParent->AddKeepAlive();
-  if (change->mContentParent->IsLaunching()) {
-    change->mContentParent->WaitForLaunchAsync()->Then(
-        GetMainThreadSerialEventTarget(), __func__,
-        [change](ContentParent*) { change->ProcessLaunched(); },
-        [change]() { change->Cancel(NS_ERROR_FAILURE); });
+  if (change->mContentParentKeepAlive->IsLaunching()) {
+    change->mContentParentKeepAlive
+        ->WaitForLaunchAsync(/* aPriority */ hal::PROCESS_PRIORITY_FOREGROUND,
+                             /* aBrowserId */ BrowserId())
+        ->Then(
+            GetMainThreadSerialEventTarget(), __func__,
+            [change](UniqueContentParentKeepAlive) {
+              change->ProcessLaunched();
+            },
+            [change]() { change->Cancel(NS_ERROR_FAILURE); });
   } else {
     change->ProcessLaunched();
   }