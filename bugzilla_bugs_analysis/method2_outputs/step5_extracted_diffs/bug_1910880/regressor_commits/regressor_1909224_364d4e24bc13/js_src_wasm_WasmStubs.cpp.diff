# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmStubs.cpp
# Commit: 364d4e24bc13
# Full Hash: 364d4e24bc13eafbb893adf6381a6cbb862d405f
# Author: Jan de Mooij <jdemooij@mozilla.com>
# Date: 2024-07-29 20:43:57
# Regressor Bug: 1909224
# File Overlap Count: 2
# Description:
#   Bug 1909224 part 3 - Remove checks for FailInstanceReg on JIT => Wasm call path. r=rhunt
#   
#   Because we now unwind JS JIT frames after unwinding Wasm frames, we no longer
#   return to the JIT => Wasm entry code from the exception handler.
#   
# ==============================================================================

diff -r 6eb32b942a04 -r 364d4e24bc13 js/src/wasm/WasmStubs.cpp
--- a/js/src/wasm/WasmStubs.cpp	Mon Jul 29 13:14:47 2024 +0000
+++ b/js/src/wasm/WasmStubs.cpp	Mon Jul 29 13:14:48 2024 +0000
@@ -760,10 +760,10 @@
   CallFuncExport(masm, fe, funcPtr);
   masm.assertStackAlignment(WasmStackAlignment);
 
-  // Set the return value based on whether InstanceReg is the FailInstanceReg
-  // magic value (set by the throw stub).
+  // Set the return value based on whether InstanceReg is the
+  // InterpFailInstanceReg magic value (set by the exception handler).
   Label success, join;
-  masm.branchPtr(Assembler::NotEqual, InstanceReg, Imm32(FailInstanceReg),
+  masm.branchPtr(Assembler::NotEqual, InstanceReg, Imm32(InterpFailInstanceReg),
                  &success);
   masm.move32(Imm32(false), scratch);
   masm.jump(&join);
@@ -1198,13 +1198,6 @@
   CallFuncExport(masm, fe, funcPtr);
   masm.assertStackAlignment(WasmStackAlignment);
 
-  // If InstanceReg is equal to the FailInstanceReg magic value (set by the
-  // throw stub), then report the exception to the JIT caller by jumping into
-  // the exception stub.
-  Label exception;
-  masm.branchPtr(Assembler::Equal, InstanceReg, Imm32(FailInstanceReg),
-                 &exception);
-
   // Pop arguments.
   masm.freeStackTo(frameSize - frameSizeExclFP);
 
@@ -1212,6 +1205,7 @@
             fe.funcIndex());
 
   // Store the return value in the JSReturnOperand.
+  Label exception;
   const ValTypeVector& results = funcType.results();
   if (results.length() == 0) {
     GenPrintf(DebugChannel::Function, masm, "void");
@@ -1278,7 +1272,8 @@
   MOZ_ASSERT(masm.framePushed() == 0);
 
   // Generate an OOL call to the C++ conversion path.
-  if (funcType.args().length()) {
+  bool hasFallThroughForException = false;
+  if (oolCall.used()) {
     masm.bind(&oolCall);
     masm.setFramePushed(frameSize);
 
@@ -1323,13 +1318,16 @@
     // No widening is required, as the return value is used as a bool.
     masm.branchTest32(Assembler::NonZero, ReturnReg, ReturnReg,
                       &rejoinBeforeCall);
+    hasFallThroughForException = true;
   }
 
   // Prepare to throw: reload InstanceReg from the frame.
   masm.bind(&exception);
   masm.setFramePushed(frameSize);
-  masm.freeStackTo(frameSize);
-  GenerateJitEntryThrow(masm, frameSize);
+  if (exception.used() || hasFallThroughForException) {
+    masm.freeStackTo(frameSize);
+    GenerateJitEntryThrow(masm, frameSize);
+  }
 
   return FinishOffsets(masm, offsets);
 }
@@ -1507,9 +1505,6 @@
   masm.freeStackTo(fakeFramePushed);
   masm.assertStackAlignment(WasmStackAlignment);
 
-  masm.branchPtr(Assembler::Equal, InstanceReg, Imm32(wasm::FailInstanceReg),
-                 masm.exceptionLabel());
-
   // Store the return value in the appropriate place.
   GenPrintf(DebugChannel::Function, masm, "wasm-function[%d]; returns ",
             fe.funcIndex());
