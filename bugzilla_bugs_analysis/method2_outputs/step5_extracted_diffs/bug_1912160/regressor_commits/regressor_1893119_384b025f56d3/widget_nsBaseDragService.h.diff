# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/nsBaseDragService.h
# Commit: 384b025f56d3
# Full Hash: 384b025f56d3f87e045ecede6b1a16b71c0b5d4f
# Author: David P <daparks@mozilla.com>
# Date: 2024-07-04 16:09:52
# Regressor Bug: 1893119
# File Overlap Count: 1
# Description:
#   Bug 1893119: Part 21 - Separate nsIDragService and nsIDragSession implementations r=gstoll,geckoview-reviewers,rkraesig,win-reviewers,m_kato
#   
#   Split the class inheritance trees for nsIDragService and nsIDragSession.
#   Remember that, before the start of this patch series, the inheritance
#   diagram was:
# ==============================================================================

diff -r beeda5ef3712 -r 384b025f56d3 widget/nsBaseDragService.h
--- a/widget/nsBaseDragService.h	Thu Jul 04 07:48:11 2024 +0000
+++ b/widget/nsBaseDragService.h	Thu Jul 04 07:48:11 2024 +0000
@@ -56,6 +56,7 @@
  */
 class nsBaseDragSession : public nsIDragSession {
  public:
+  NS_DECL_ISUPPORTS
   NS_DECL_NSIDRAGSESSION
 
   int32_t TakeChildProcessDragAction();
@@ -68,9 +69,106 @@
     mEndDragPoint = aEndDragPoint;
   }
 
+  uint16_t GetInputSource() { return mInputSource; }
+
+  // The nsIDragService uses this to create nsIDragSessions when dragging
+  // from a child process.
+  MOZ_CAN_RUN_SCRIPT nsresult InitWithRemoteImage(
+      nsIWidget* aWidget, nsINode* aDOMNode, nsIPrincipal* aPrincipal,
+      nsIContentSecurityPolicy* aCsp, nsICookieJarSettings* aCookieJarSettings,
+      nsIArray* aTransferableArray, uint32_t aActionType,
+      mozilla::dom::RemoteDragStartData* aDragStartData,
+      mozilla::dom::DragEvent* aDragEvent,
+      mozilla::dom::DataTransfer* aDataTransfer, bool aIsSynthesizedForTests);
+
+  // The nsIDragService uses this to create nsIDragSessions for dragging
+  // a selected region from a Gecko window.
+  MOZ_CAN_RUN_SCRIPT nsresult InitWithSelection(
+      nsIWidget* aWidget, mozilla::dom::Selection* aSelection,
+      nsIPrincipal* aPrincipal, nsIContentSecurityPolicy* aCsp,
+      nsICookieJarSettings* aCookieJarSettings, nsIArray* aTransferableArray,
+      uint32_t aActionType, mozilla::dom::DragEvent* aDragEvent,
+      mozilla::dom::DataTransfer* aDataTransfer, bool aIsSynthesizedForTests);
+
+  // The nsIDragService uses this to create nsIDragSessions when dragging
+  // from anywhere else.
+  MOZ_CAN_RUN_SCRIPT nsresult InitWithImage(
+      nsIWidget* aWidget, nsINode* aDOMNode, nsIPrincipal* aPrincipal,
+      nsIContentSecurityPolicy* aCsp, nsICookieJarSettings* aCookieJarSettings,
+      nsIArray* aTransferableArray, uint32_t aActionType, nsINode* aImage,
+      int32_t aImageX, int32_t aImageY, mozilla::dom::DragEvent* aDragEvent,
+      mozilla::dom::DataTransfer* aDataTransfer, bool aIsSynthesizedForTests);
+
  protected:
   nsBaseDragSession();
-  ~nsBaseDragSession();
+  virtual ~nsBaseDragSession();
+
+  /**
+   * Starts a modal drag session with an array of transaferables.
+   *
+   * @param  aPrincipal - the triggering principal of the drag, or null if
+   *                      it's from browser chrome or OS
+   * @param  aCsp - The csp of the triggering Document
+   * @param  aTransferables - an array of transferables to be dragged
+   * @param  aActionType - specified which of copy/move/link are allowed
+   * @param  aContentPolicyType - the contentPolicyType that will be
+   *           passed to the loadInfo when creating a new channel
+   *           (defaults to TYPE_OTHER)
+   */
+  MOZ_CAN_RUN_SCRIPT virtual nsresult InvokeDragSession(
+      nsIWidget* aWidget, nsINode* aDOMNode, nsIPrincipal* aPrincipal,
+      nsIContentSecurityPolicy* aCsp, nsICookieJarSettings* aCookieJarSettings,
+      nsIArray* aTransferableArray, uint32_t aActionType,
+      nsContentPolicyType aContentPolicyType = nsIContentPolicy::TYPE_OTHER);
+
+  /**
+   * Called to create a drag session with a Gecko source.  Like all drag
+   * sessions, the resulting session needs to be eventually ended with a call
+   * to nsIDragSession::EndDragSession.
+   */
+  MOZ_CAN_RUN_SCRIPT virtual nsresult InvokeDragSessionImpl(
+      nsIWidget* aWidget, nsIArray* aTransferableArray,
+      const mozilla::Maybe<mozilla::CSSIntRegion>& aRegion,
+      uint32_t aActionType) = 0;
+
+  /**
+   * Draw the drag image, if any, to a surface and return it. The drag image
+   * is constructed from mImage if specified, or aDOMNode if mImage is null.
+   *
+   * aRegion may be used to draw only a subset of the element. This region
+   * should be supplied using x and y coordinates measured in css pixels
+   * that are relative to the upper-left corner of the window.
+   *
+   * aScreenPosition should be the screen coordinates of the mouse click
+   * for the drag. These are in CSS pixels.
+   *
+   * On return, aScreenDragRect will contain the screen coordinates of the
+   * area being dragged. This is used by the platform-specific part of the
+   * drag service to determine the drag feedback. This rect will be in the
+   * device pixels of the presContext.
+   *
+   * If there is no drag image, the returned surface will be null, but
+   * aScreenDragRect will still be set to the drag area.
+   *
+   * aPresContext will be set to the nsPresContext used determined from
+   * whichever of mImage or aDOMNode is used.
+   */
+  nsresult DrawDrag(nsINode* aDOMNode,
+                    const mozilla::Maybe<mozilla::CSSIntRegion>& aRegion,
+                    mozilla::CSSIntPoint aScreenPosition,
+                    mozilla::LayoutDeviceIntRect* aScreenDragRect,
+                    RefPtr<mozilla::gfx::SourceSurface>* aSurface,
+                    nsPresContext** aPresContext);
+
+  /**
+   * Draw a drag image for an image node specified by aImageLoader or aCanvas.
+   * This is called by DrawDrag.
+   */
+  nsresult DrawDragForImage(nsPresContext* aPresContext,
+                            nsIImageLoadingContent* aImageLoader,
+                            mozilla::dom::HTMLCanvasElement* aCanvas,
+                            mozilla::LayoutDeviceIntRect* aScreenDragRect,
+                            RefPtr<mozilla::gfx::SourceSurface>* aSurface);
 
   MOZ_CAN_RUN_SCRIPT virtual nsresult EndDragSessionImpl(
       bool aDoneDrag, uint32_t aKeyModifiers);
@@ -133,6 +231,10 @@
   // The position relative to the top level widget where the drag ended.
   mozilla::LayoutDeviceIntPoint mEndDragPoint;
 
+  // the contentpolicy type passed to the channel when initiating the drag
+  // session
+  nsContentPolicyType mContentPolicyType = nsIContentPolicy::TYPE_OTHER;
+
   uint32_t mDragAction = nsIDragService::DRAGDROP_ACTION_NONE;
   uint32_t mDragActionFromChildProcess =
       nsIDragService::DRAGDROP_ACTION_UNINITIALIZED;
@@ -145,7 +247,8 @@
   // The input source of the drag event. Possible values are from MouseEvent.
   uint16_t mInputSource = mozilla::dom::MouseEvent_Binding::MOZ_SOURCE_MOUSE;
 
-  bool mDoingDrag = false;
+  // false after EndDragSession has run
+  bool mDoingDrag = true;
 
   bool mCanDrop = false;
   bool mOnlyChromeDrop = false;
@@ -166,14 +269,9 @@
 
 /**
  * Platform-agnostic base for nsIDragService.
- * NB: This class temporarily subclasses nsBaseDragSession while we move
- * methods from it to nsBaseDragSession.  The inheritance relationship
- * will be severed by the end of this patch series.
  */
-class nsBaseDragService : public nsIDragService, public nsBaseDragSession {
+class nsBaseDragService : public nsIDragService {
  public:
-  typedef mozilla::gfx::SourceSurface SourceSurface;
-
   nsBaseDragService();
 
   // nsISupports
@@ -181,8 +279,6 @@
 
   NS_DECL_NSIDRAGSERVICE
 
-  uint16_t GetInputSource() { return mInputSource; }
-
   using nsIDragService::GetCurrentSession;
 
   uint32_t GetSuppressLevel() { return mSuppressLevel; };
@@ -191,89 +287,34 @@
     return std::move(mBrowsers);
   }
 
+  void ClearCurrentParentDragSession() {
+    mCurrentParentDragSession = nullptr;
+  }
+
+  static nsIWidget* GetWidgetFromWidgetProvider(nsISupports* aWidgetProvider);
+
  protected:
   virtual ~nsBaseDragService();
 
-  /**
-   * Starts a modal drag session with an array of transaferables.
-   *
-   * @param  aPrincipal - the triggering principal of the drag, or null if
-   *                      it's from browser chrome or OS
-   * @param aCsp - The csp of the triggering Document
-   * @param  aTransferables - an array of transferables to be dragged
-   * @param  aActionType - specified which of copy/move/link are allowed
-   * @param  aContentPolicyType - the contentPolicyType that will be
-   *           passed to the loadInfo when creating a new channel
-   *           (defaults to TYPE_OTHER)
-   */
-  MOZ_CAN_RUN_SCRIPT virtual nsresult InvokeDragSession(
-      nsIWidget* aWidget, nsINode* aDOMNode, nsIPrincipal* aPrincipal,
-      nsIContentSecurityPolicy* aCsp, nsICookieJarSettings* aCookieJarSettings,
-      nsIArray* aTransferableArray, uint32_t aActionType,
-      nsContentPolicyType aContentPolicyType = nsIContentPolicy::TYPE_OTHER);
-
-   /**
-   * Called from nsBaseDragService to initiate a platform drag from a source
-   * in this process.  This is expected to ensure that StartDragSession() and
-   * EndDragSession() get called if the platform drag is successfully invoked.
-   */
-  MOZ_CAN_RUN_SCRIPT virtual nsresult InvokeDragSessionImpl(
-      nsIWidget* aWidget, nsIArray* aTransferableArray,
-      const mozilla::Maybe<mozilla::CSSIntRegion>& aRegion,
-      uint32_t aActionType) = 0;
+  virtual already_AddRefed<nsIDragSession> CreateDragSession() = 0;
 
-  /**
-   * Draw the drag image, if any, to a surface and return it. The drag image
-   * is constructed from mImage if specified, or aDOMNode if mImage is null.
-   *
-   * aRegion may be used to draw only a subset of the element. This region
-   * should be supplied using x and y coordinates measured in css pixels
-   * that are relative to the upper-left corner of the window.
-   *
-   * aScreenPosition should be the screen coordinates of the mouse click
-   * for the drag. These are in CSS pixels.
-   *
-   * On return, aScreenDragRect will contain the screen coordinates of the
-   * area being dragged. This is used by the platform-specific part of the
-   * drag service to determine the drag feedback. This rect will be in the
-   * device pixels of the presContext.
-   *
-   * If there is no drag image, the returned surface will be null, but
-   * aScreenDragRect will still be set to the drag area.
-   *
-   * aPresContext will be set to the nsPresContext used determined from
-   * whichever of mImage or aDOMNode is used.
-   */
-  nsresult DrawDrag(nsINode* aDOMNode,
-                    const mozilla::Maybe<mozilla::CSSIntRegion>& aRegion,
-                    mozilla::CSSIntPoint aScreenPosition,
-                    mozilla::LayoutDeviceIntRect* aScreenDragRect,
-                    RefPtr<SourceSurface>* aSurface,
-                    nsPresContext** aPresContext);
-
-  /**
-   * Draw a drag image for an image node specified by aImageLoader or aCanvas.
-   * This is called by DrawDrag.
-   */
-  nsresult DrawDragForImage(nsPresContext* aPresContext,
-                            nsIImageLoadingContent* aImageLoader,
-                            mozilla::dom::HTMLCanvasElement* aCanvas,
-                            mozilla::LayoutDeviceIntRect* aScreenDragRect,
-                            RefPtr<SourceSurface>* aSurface);
-
-  virtual bool IsMockService() { return false; }
-
-  // the contentpolicy type passed to the channel when initiating the drag
-  // session
-  nsContentPolicyType mContentPolicyType;
-
-  uint32_t mSuppressLevel;
+  // The drag session representing the user's current actions, if any.
+  // This value is only valid in the parent process.  For child
+  // process drag sessions, see BrowserChild and PuppetWidget.
+  RefPtr<nsIDragSession> mCurrentParentDragSession;
 
   // Sub-region for tree-selections.
   mozilla::Maybe<mozilla::CSSIntRegion> mRegion;
 
   RefPtr<mozilla::test::MockDragServiceController> mMockController;
 
+  // Weak references to PBrowsers that are currently engaged in drags.
+  // Once an nsIDragSession is created for the remote drag, these browsers
+  // will be moved to that object.
+  nsTArray<nsWeakPtr> mBrowsers;
+
+  uint32_t mSuppressLevel = 0;
+
   // If this is set, mSessionIsSynthesizedForTests should not become true.
   // This hack is used to bypass the "old" drag-drop test behavior.
   // See nsIDragService.idl for details.