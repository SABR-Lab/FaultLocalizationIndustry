# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/nsDragServiceProxy.cpp
# Commit: 384b025f56d3
# Full Hash: 384b025f56d3f87e045ecede6b1a16b71c0b5d4f
# Author: David P <daparks@mozilla.com>
# Date: 2024-07-04 16:09:52
# Regressor Bug: 1893119
# File Overlap Count: 1
# Description:
#   Bug 1893119: Part 21 - Separate nsIDragService and nsIDragSession implementations r=gstoll,geckoview-reviewers,rkraesig,win-reviewers,m_kato
#   
#   Split the class inheritance trees for nsIDragService and nsIDragSession.
#   Remember that, before the start of this patch series, the inheritance
#   diagram was:
# ==============================================================================

diff -r beeda5ef3712 -r 384b025f56d3 widget/nsDragServiceProxy.cpp
--- a/widget/nsDragServiceProxy.cpp	Thu Jul 04 07:48:11 2024 +0000
+++ b/widget/nsDragServiceProxy.cpp	Thu Jul 04 07:48:11 2024 +0000
@@ -24,11 +24,36 @@
 using mozilla::gfx::SurfaceFormat;
 using mozilla::ipc::Shmem;
 
-nsDragServiceProxy::nsDragServiceProxy() = default;
-
 nsDragServiceProxy::~nsDragServiceProxy() = default;
 
-nsresult nsDragServiceProxy::InvokeDragSessionImpl(
+nsDragSessionProxy::~nsDragSessionProxy() = default;
+
+already_AddRefed<nsIDragSession> nsDragServiceProxy::CreateDragSession() {
+  RefPtr<nsIDragSession> session = new nsDragSessionProxy();
+  return session.forget();
+}
+
+nsresult nsDragSessionProxy::InvokeDragSession(
+    nsIWidget* aWidget, nsINode* aDOMNode, nsIPrincipal* aPrincipal,
+    nsIContentSecurityPolicy* aCsp, nsICookieJarSettings* aCookieJarSettings,
+    nsIArray* aTransferableArray, uint32_t aActionType,
+    nsContentPolicyType aContentPolicyType) {
+  BrowserChild* sourceBrowser = aWidget->GetOwningBrowserChild();
+  NS_ENSURE_TRUE(sourceBrowser, NS_ERROR_INVALID_ARG);
+  [[maybe_unused]] RefPtr<nsIDragSession> sourceSession =
+      sourceBrowser->GetDragSession();
+  MOZ_ASSERT(!sourceSession);
+  nsresult rv = nsBaseDragSession::InvokeDragSession(aWidget, aDOMNode,
+      aPrincipal, aCsp, aCookieJarSettings, aTransferableArray, aActionType,
+      aContentPolicyType);
+  if (NS_SUCCEEDED(rv)) {
+    MOZ_ALWAYS_SUCCEEDS(sourceBrowser->GetWeakReference(getter_AddRefs(mSourceBrowser)));
+    sourceBrowser->SetDragSession(this);
+  }
+  return rv;
+}
+
+nsresult nsDragSessionProxy::InvokeDragSessionImpl(
     nsIWidget* aWidget, nsIArray* aArrayTransferables,
     const Maybe<CSSIntRegion>& aRegion, uint32_t aActionType) {
   NS_ENSURE_STATE(mSourceDocument->GetDocShell());
@@ -81,7 +106,6 @@
             std::move(transferables), aActionType, std::move(surfaceData),
             stride, dataSurface->GetFormat(), dragRect, principal, csp, csArgs,
             mSourceWindowContext, mSourceTopWindowContext);
-        StartDragSession(aWidget);
         return NS_OK;
       }
     }
@@ -91,6 +115,88 @@
       std::move(transferables), aActionType, Nothing(), 0,
       static_cast<SurfaceFormat>(0), dragRect, principal, csp, csArgs,
       mSourceWindowContext, mSourceTopWindowContext);
-  StartDragSession(aWidget);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDragServiceProxy::StartDragSession(nsISupports* aWidgetProvider) {
+  nsIWidget* widget = GetWidgetFromWidgetProvider(aWidgetProvider);
+  NS_ENSURE_TRUE(widget, NS_ERROR_INVALID_ARG);
+  BrowserChild* targetBrowser = widget->GetOwningBrowserChild();
+  NS_ENSURE_TRUE(targetBrowser, NS_ERROR_INVALID_ARG);
+  RefPtr<nsIDragSession> session = targetBrowser->GetDragSession();
+  if (session) {
+    // session already exists on the browser
+    return NS_OK;
+  }
+
+  session = CreateDragSession();
+  MOZ_ASSERT(session);
+  static_cast<nsDragSessionProxy*>(session.get())->SetDragTarget(targetBrowser);
+  targetBrowser->SetDragSession(session);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDragServiceProxy::GetCurrentSession(nsISupports* aWidgetProvider,
+                                      nsIDragSession** aSession) {
+  if (!aSession) {
+    return NS_ERROR_INVALID_ARG;
+  }
+  *aSession = nullptr;
+
+  nsIWidget* widget = GetWidgetFromWidgetProvider(aWidgetProvider);
+  NS_ENSURE_TRUE(widget, NS_ERROR_INVALID_ARG);
+  BrowserChild* browser = widget->GetOwningBrowserChild();
+  NS_ENSURE_TRUE(browser, NS_ERROR_INVALID_ARG);
+  RefPtr<nsIDragSession> session = browser->GetDragSession();
+
+  if (!mSuppressLevel && session) {
+    session.forget(aSession);
+  }
+
   return NS_OK;
 }
+
+void nsDragSessionProxy::SetDragTarget(BrowserChild* aTarget) {
+  if (!aTarget) {
+    if (mTargetBrowser) {
+      nsCOMPtr<BrowserChild> targetBC = do_QueryReferent(mTargetBrowser);
+      MOZ_ASSERT(targetBC);
+      if (targetBC) {
+        targetBC->SetDragSession(nullptr);
+      }
+      mTargetBrowser = nullptr;
+    }
+    return;
+  }
+  [[maybe_unused]] RefPtr<nsIDragSession> session =
+      aTarget->GetDragSession();
+  MOZ_ASSERT(!session);
+  MOZ_ALWAYS_SUCCEEDS(aTarget->GetWeakReference(getter_AddRefs(mTargetBrowser)));
+}
+
+nsresult nsDragSessionProxy::EndDragSessionImpl(bool aDoneDrag,
+                                                uint32_t aKeyModifiers) {
+  if (mSourceBrowser) {
+    nsCOMPtr<BrowserChild> sourceBC = do_QueryReferent(mSourceBrowser);
+    MOZ_ASSERT(sourceBC);
+    [[maybe_unused]] RefPtr<nsIDragSession> session =
+        sourceBC->GetDragSession();
+    MOZ_ASSERT(session == this);
+    sourceBC->SetDragSession(nullptr);
+    mSourceBrowser = nullptr;
+  }
+
+  if (mTargetBrowser) {
+    nsCOMPtr<BrowserChild> targetBC = do_QueryReferent(mTargetBrowser);
+    MOZ_ASSERT(targetBC);
+    [[maybe_unused]] RefPtr<nsIDragSession> session =
+        targetBC->GetDragSession();
+    MOZ_ASSERT(session == this);
+    targetBC->SetDragSession(nullptr);
+    mTargetBrowser = nullptr;
+  }
+
+  return nsBaseDragSession::EndDragSessionImpl(aDoneDrag, aKeyModifiers);
+}