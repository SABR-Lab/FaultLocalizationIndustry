# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/MockDragServiceController.cpp
# Commit: beeda5ef3712
# Full Hash: beeda5ef3712b73a19c7a4ce08a52ab4dd08b802
# Author: David P <daparks@mozilla.com>
# Date: 2024-07-04 16:09:52
# Regressor Bug: 1893119
# File Overlap Count: 1
# Description:
#   Bug 1893119: Part 20 - Move EndDragSession from nsIDragService to nsIDragSession r=gstoll,rkraesig,win-reviewers,geckoview-reviewers,m_kato
#   
#   This is a straightforward move.  It does take the liberty of breaking out an
#   EndDragSessionImpl method, which will be needed later.
#   
# ==============================================================================

diff -r 6c3ffc8c534c -r beeda5ef3712 widget/MockDragServiceController.cpp
--- a/widget/MockDragServiceController.cpp	Thu Jul 04 07:48:10 2024 +0000
+++ b/widget/MockDragServiceController.cpp	Thu Jul 04 07:48:11 2024 +0000
@@ -31,14 +31,31 @@
 
     // mDragAction is not yet handled properly in the MockDragService.
     // This should be updated with each drag event.  Instead, we always MOVE.
+    //
+    // We still need to end the drag session on the source widget.
+    // In normal (non-mock) Gecko operation, this happens regardless
+    // of whether the drop/cancel happened over one of our widgets.
+    // For instance, Windows does this in StartInvokingDragSession, after
+    // DoDragDrop returns, gtk does this on eDragTaskSourceEnd and cocoa
+    // does this in -[NSDraggingSource draggingSession: endedAt: operation:].
+    //
+    // Here, we know the source and target are Gecko windows (the test
+    // framework does not support dragging to/from other apps).  We could
+    // end the source drag session on drop and cancel, but sometimes we
+    // will want a dragleave to end the session (representing a drag cancel
+    // from Gecko) and other we times don't (like when dragging from one Gecko
+    // widget to another).  Therefore, we instead rely on the test to tell
+    // us when to end the source session by calling
+    // MockDragServiceController::EndSourceDragSession().
+    // Note that, like in non-mocked DND, we do this regardless of whether
+    // the source and target were the same widget -- in that case,
+    // EndDragSession is just called twice.
     mDragAction = DRAGDROP_ACTION_MOVE;
     StartDragSession(aWidget);
     return NS_OK;
   }
 
   bool IsMockService() override { return true; }
-
-  uint32_t mLastModifierKeyState = 0;
 };
 
 static void SetDragEndPointFromScreenPoint(
@@ -133,7 +150,6 @@
       LayoutDeviceIntPoint(aScreenX, aScreenY) - clientPosInScreenCoords;
 
   RefPtr<MockDragService> ds = mDragService;
-  ds->mLastModifierKeyState = aKeyModifiers;
 
   if (aEventType == EventType::eDragEnter) {
     // We expect StartDragSession to return an "error" when a drag session
@@ -166,7 +182,8 @@
       rv = currentDragSession->GetSourceNode(getter_AddRefs(sourceNode));
       NS_ENSURE_SUCCESS(rv, rv);
       if (!sourceNode) {
-        rv = ds->EndDragSession(false /* doneDrag */, aKeyModifiers);
+        rv = currentDragSession->EndDragSession(false /* doneDrag */,
+                                                aKeyModifiers);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     } break;
@@ -184,7 +201,8 @@
       widget->DispatchInputEvent(widgetEvent.get());
       SetDragEndPointFromScreenPoint(currentDragSession, presCxt,
                                      LayoutDeviceIntPoint(aScreenX, aScreenY));
-      rv = ds->EndDragSession(true /* doneDrag */, aKeyModifiers);
+      rv = currentDragSession->EndDragSession(true /* doneDrag */,
+                                              aKeyModifiers);
       NS_ENSURE_SUCCESS(rv, rv);
     } break;
     default:
@@ -197,8 +215,10 @@
 NS_IMETHODIMP
 MockDragServiceController::CancelDrag(uint32_t aKeyModifiers = 0) {
   RefPtr<MockDragService> ds = mDragService;
-  ds->mLastModifierKeyState = aKeyModifiers;
-  return ds->EndDragSession(false /* doneDrag */, aKeyModifiers);
+  nsCOMPtr<nsIDragSession> currentDragSession;
+  ds->GetCurrentSession(nullptr, getter_AddRefs(currentDragSession));
+  MOZ_ASSERT(currentDragSession);
+  return currentDragSession->EndDragSession(false /* doneDrag */,
+                                            aKeyModifiers);
 }
-
 }  // namespace mozilla::test