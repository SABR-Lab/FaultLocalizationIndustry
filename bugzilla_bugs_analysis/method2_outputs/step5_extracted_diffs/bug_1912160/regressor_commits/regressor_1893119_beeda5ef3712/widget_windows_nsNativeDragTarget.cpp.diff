# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/nsNativeDragTarget.cpp
# Commit: beeda5ef3712
# Full Hash: beeda5ef3712b73a19c7a4ce08a52ab4dd08b802
# Author: David P <daparks@mozilla.com>
# Date: 2024-07-04 16:09:52
# Regressor Bug: 1893119
# File Overlap Count: 1
# Description:
#   Bug 1893119: Part 20 - Move EndDragSession from nsIDragService to nsIDragSession r=gstoll,rkraesig,win-reviewers,geckoview-reviewers,m_kato
#   
#   This is a straightforward move.  It does take the liberty of breaking out an
#   EndDragSessionImpl method, which will be needed later.
#   
# ==============================================================================

diff -r 6c3ffc8c534c -r beeda5ef3712 widget/windows/nsNativeDragTarget.cpp
--- a/widget/windows/nsNativeDragTarget.cpp	Thu Jul 04 07:48:10 2024 +0000
+++ b/widget/windows/nsNativeDragTarget.cpp	Thu Jul 04 07:48:11 2024 +0000
@@ -355,8 +355,8 @@
       // we're done with it for now (until the user drags back into
       // mozilla).
       ModifierKeyState modifierKeyState;
-      nsCOMPtr<nsIDragService> dragService = mDragService;
-      dragService->EndDragSession(false, modifierKeyState.GetModifiers());
+      currentDragSession->EndDragSession(false,
+                                         modifierKeyState.GetModifiers());
     }
   }
 
@@ -378,8 +378,11 @@
     }
     if (mDragService) {
       ModifierKeyState modifierKeyState;
-      nsCOMPtr<nsIDragService> dragService = mDragService;
-      dragService->EndDragSession(false, modifierKeyState.GetModifiers());
+      RefPtr<nsIDragSession> session =
+          mDragService->GetCurrentSession(mWidget);
+      if (session) {
+        session->EndDragSession(false, modifierKeyState.GetModifiers());
+      }
     }
     this->Release();  // matching the AddRef in DragEnter
     mTookOwnRef = false;
@@ -413,7 +416,6 @@
   // NOTE: ProcessDrag spins the event loop which may destroy arbitrary objects.
   // We use strong refs to prevent it from destroying these:
   RefPtr<nsNativeDragTarget> kungFuDeathGrip = this;
-  nsCOMPtr<nsIDragService> serv = mDragService;
 
   // Now process the native drag state and then dispatch the event
   ProcessDrag(eDrop, grfKeyState, aPT, pdwEffect);
@@ -440,7 +442,7 @@
   cpos.y = GET_Y_LPARAM(pos);
   currentDragSession->SetDragEndPoint(cpos.x, cpos.y);
   ModifierKeyState modifierKeyState;
-  serv->EndDragSession(true, modifierKeyState.GetModifiers());
+  currentDragSession->EndDragSession(true, modifierKeyState.GetModifiers());
 
   // release the ref that was taken in DragEnter
   NS_ASSERTION(mTookOwnRef, "want to release own ref, but not taken!");
