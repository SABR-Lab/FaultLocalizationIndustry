# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender_api/src/tile_pool.rs
# Commit: acfdc7e00afa
# Full Hash: acfdc7e00afa2dbb7bc3062043fb358c5e2350e4
# Author: Nicolas Silva <nsilva@mozilla.com>
# Date: 2024-08-30 22:22:38
# Description:
#   Bug 1912366 - Don't panic when allocating large blob tiles. r=gfx-reviewers,jnicol
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D220523
# ==============================================================================

diff -r 67a77d66d0e8 -r acfdc7e00afa gfx/wr/webrender_api/src/tile_pool.rs
--- a/gfx/wr/webrender_api/src/tile_pool.rs	Fri Aug 30 12:12:54 2024 +0000
+++ b/gfx/wr/webrender_api/src/tile_pool.rs	Fri Aug 30 12:39:24 2024 +0000
@@ -41,9 +41,22 @@
     /// The returned buffer is zero-inizitalized.
     /// The length of the returned buffer is equal to the requested size,
     /// however the buffer may be allocated with a larger capacity to
-    /// confirm to the pool's corresponding bucket tile size.
+    /// conform to the pool's corresponding bucket tile size.
     pub fn get_buffer(&mut self, requested_size: usize) -> MutableTileBuffer {
-        assert!(requested_size <= self.largest_size_class);
+        if requested_size > self.largest_size_class {
+            // If the requested size is larger than the largest size class,
+            // simply return a MutableBuffer that isn't tracked/recycled by
+            // the pool.
+            // In Firefox this should only happen in pathological cases
+            // where the blob visible area ends up so large that the tile
+            // size is increased to avoid producing too many tiles.
+            // See wr_resource_updates_add_blob_image.
+            let mut buf = vec![0; requested_size];
+            return MutableTileBuffer {
+                ptr: buf.as_mut_ptr(),
+                strong_ref: Arc::new(buf),
+            };
+        }
 
         let (bucket_idx, cap) = self.bucket_and_size(requested_size);
         let bucket = &mut self.buckets[bucket_idx];
