# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/OpaqueResponseUtils.h
# Commit: 680c502179c6
# Full Hash: 680c502179c6a98e8e6960fbab016d3aea44ff4c
# Author: Andreas Farre <farre@mozilla.com>
# Date: 2023-05-10 21:37:01
# Regressor Bug: 1823877
# File Overlap Count: 1
# Description:
#   Bug 1823877 - Part 1: Filter opaque results from fetch() in the parent for ORB. r=sefeng,smaug,necko-reviewers,edenchuang,valentin
#   
#   We make sure to not send any data to the content process in case of
#   fetching an opaque resource. This is way to remain more web
#   compatible, but is also in conflict with the ORB specification.
# ==============================================================================

diff -r 8295c1c7bfa0 -r 680c502179c6 netwerk/protocol/http/OpaqueResponseUtils.h
--- a/netwerk/protocol/http/OpaqueResponseUtils.h	Wed May 10 14:27:47 2023 +0000
+++ b/netwerk/protocol/http/OpaqueResponseUtils.h	Wed May 10 14:35:52 2023 +0000
@@ -24,7 +24,6 @@
 #include "nsTArray.h"
 
 class nsIContentSniffer;
-static mozilla::LazyLogModule gORBLog("ORB");
 
 namespace mozilla::dom {
 class JSValidatorParent;
@@ -47,6 +46,8 @@
   BLOCKED_SHOULD_SNIFF
 };
 
+enum class OpaqueResponse { Block, Allow, SniffCompressed, Sniff };
+
 OpaqueResponseBlockedReason GetOpaqueResponseBlockedReason(
     const nsACString& aContentType, uint16_t aStatus, bool aNoSniff);
 
@@ -60,6 +61,24 @@
 
 bool IsFirstPartialResponse(nsHttpResponseHead& aResponseHead);
 
+LogModule* GetORBLog();
+
+// Helper class to filter data for opaque responses destined for `Window.fetch`.
+// See https://fetch.spec.whatwg.org/#concept-filtered-response-opaque.
+class OpaqueResponseFilter final : public nsIStreamListener {
+ public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIREQUESTOBSERVER
+  NS_DECL_NSISTREAMLISTENER;
+
+  explicit OpaqueResponseFilter(nsIStreamListener* aNext);
+
+ private:
+  virtual ~OpaqueResponseFilter() = default;
+
+  nsCOMPtr<nsIStreamListener> mNext;
+};
+
 class OpaqueResponseBlocker final : public nsIStreamListener {
   enum class State { Sniffing, Allowed, Blocked };
 
@@ -74,9 +93,13 @@
   bool IsSniffing() const;
   void AllowResponse();
   void BlockResponse(HttpBaseChannel* aChannel, nsresult aStatus);
+  void FilterResponse();
 
   nsresult EnsureOpaqueResponseIsAllowedAfterSniff(nsIRequest* aRequest);
 
+  OpaqueResponse EnsureOpaqueResponseIsAllowedAfterJavaScriptValidation(
+      HttpBaseChannel* aChannel, bool aAllow);
+
   // The four possible results for validation. `JavaScript` and `JSON` are
   // self-explanatory. `JavaScript` is the only successful result, in the sense
   // that it will allow the opaque response, whereas `JSON` will block. `Other`
@@ -100,6 +123,7 @@
 
   const nsCString mContentType;
   const bool mNoSniff;
+  bool mShouldFilter = false;
 
   State mState = State::Sniffing;
   nsresult mStatus = NS_OK;