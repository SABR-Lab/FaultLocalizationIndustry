# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/nsWaylandDisplay.cpp
# Commit: 6770fb6b8d92
# Full Hash: 6770fb6b8d9217b7d75ed7169cb1389c868498ed
# Author: Martin Stransky <stransky@redhat.com>
# Date: 2024-09-06 21:37:32
# Regressor Bug: 1915596
# File Overlap Count: 2
# Description:
#   Bug 1915596 [Wayland] Get touchpad hold event directly from Wayland display r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D220551
# ==============================================================================

diff -r 791b8e439bbd -r 6770fb6b8d92 widget/gtk/nsWaylandDisplay.cpp
--- a/widget/gtk/nsWaylandDisplay.cpp	Fri Sep 06 08:37:00 2024 +0000
+++ b/widget/gtk/nsWaylandDisplay.cpp	Fri Sep 06 09:16:28 2024 +0000
@@ -19,6 +19,7 @@
 #include "mozilla/Sprintf.h"
 #include "WidgetUtilsGtk.h"
 #include "nsGtkKeyUtils.h"
+#include "nsWindow.h"
 
 namespace mozilla::widget {
 
@@ -57,6 +58,198 @@
 
 void nsWaylandDisplay::SetShm(wl_shm* aShm) { mShm = aShm; }
 
+struct PointerState {
+  wl_surface* surface;
+
+  nsWindow* GetWindow() {
+    GdkWindow* window =
+        static_cast<GdkWindow*>(wl_surface_get_user_data(surface));
+    return window ? static_cast<nsWindow*>(
+                        g_object_get_data(G_OBJECT(window), "nsWindow"))
+                  : nullptr;
+  }
+} sPointerState;
+
+static void gesture_hold_begin(void* data,
+                               struct zwp_pointer_gesture_hold_v1* hold,
+                               uint32_t serial, uint32_t time,
+                               struct wl_surface* surface, uint32_t fingers) {
+  RefPtr<nsWindow> window = sPointerState.GetWindow();
+  if (!window) {
+    return;
+  }
+  window->OnTouchpadHoldEvent(GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, time, fingers);
+}
+
+static void gesture_hold_end(void* data,
+                             struct zwp_pointer_gesture_hold_v1* hold,
+                             uint32_t serial, uint32_t time,
+                             int32_t cancelled) {
+  RefPtr<nsWindow> window = sPointerState.GetWindow();
+  if (!window) {
+    return;
+  }
+  window->OnTouchpadHoldEvent(cancelled ? GDK_TOUCHPAD_GESTURE_PHASE_CANCEL
+                                        : GDK_TOUCHPAD_GESTURE_PHASE_END,
+                              time, 0);
+}
+
+static const struct zwp_pointer_gesture_hold_v1_listener gesture_hold_listener =
+    {gesture_hold_begin, gesture_hold_end};
+
+static void pointer_handle_enter(void* data, struct wl_pointer* pointer,
+                                 uint32_t serial, struct wl_surface* surface,
+                                 wl_fixed_t sx, wl_fixed_t sy) {
+  sPointerState.surface = surface;
+}
+
+static void pointer_handle_leave(void* data, struct wl_pointer* pointer,
+                                 uint32_t serial, struct wl_surface* surface) {
+  sPointerState.surface = nullptr;
+}
+
+static void pointer_handle_motion(void* data, struct wl_pointer* pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy) {
+}
+
+static void pointer_handle_button(void* data, struct wl_pointer* pointer,
+                                  uint32_t serial, uint32_t time,
+                                  uint32_t button, uint32_t state) {}
+
+static void pointer_handle_axis(void* data, struct wl_pointer* pointer,
+                                uint32_t time, uint32_t axis,
+                                wl_fixed_t value) {}
+
+static void pointer_handle_frame(void* data, struct wl_pointer* pointer) {}
+
+static void pointer_handle_axis_source(
+    void* data, struct wl_pointer* pointer,
+    /*enum wl_pointer_axis_source */ uint32_t source) {}
+
+static void pointer_handle_axis_stop(void* data, struct wl_pointer* pointer,
+                                     uint32_t time, uint32_t axis) {}
+
+static void pointer_handle_axis_discrete(void* data, struct wl_pointer* pointer,
+                                         uint32_t axis, int32_t value) {}
+
+static void pointer_handle_axis_value120(void* data, struct wl_pointer* pointer,
+                                         uint32_t axis, int32_t value) {}
+
+static const struct moz_wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,         pointer_handle_leave,
+    pointer_handle_motion,        pointer_handle_button,
+    pointer_handle_axis,          pointer_handle_frame,
+    pointer_handle_axis_source,   pointer_handle_axis_stop,
+    pointer_handle_axis_discrete, pointer_handle_axis_value120,
+};
+
+void nsWaylandDisplay::SetPointer(wl_pointer* aPointer) {
+  if (!mPointerGestures) {
+    return;
+  }
+  MOZ_DIAGNOSTIC_ASSERT(!mPointer);
+  mPointer = aPointer;
+  wl_pointer_add_listener(mPointer,
+                          (const wl_pointer_listener*)&pointer_listener, this);
+
+  mPointerGestureHold =
+      zwp_pointer_gestures_v1_get_hold_gesture(mPointerGestures, mPointer);
+  zwp_pointer_gesture_hold_v1_set_user_data(mPointerGestureHold, this);
+  zwp_pointer_gesture_hold_v1_add_listener(mPointerGestureHold,
+                                           &gesture_hold_listener, this);
+}
+
+void nsWaylandDisplay::RemovePointer() {
+  wl_pointer_release(mPointer);
+  mPointer = nullptr;
+}
+
+static void seat_handle_capabilities(void* data, struct wl_seat* seat,
+                                     unsigned int caps) {
+  auto* display = static_cast<nsWaylandDisplay*>(data);
+  if (!display) {
+    return;
+  }
+
+  if ((caps & WL_SEAT_CAPABILITY_POINTER) && !display->GetPointer()) {
+    display->SetPointer(wl_seat_get_pointer(seat));
+  } else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && display->GetPointer()) {
+    display->RemovePointer();
+  }
+
+  wl_keyboard* keyboard = display->GetKeyboard();
+  if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !keyboard) {
+    display->SetKeyboard(wl_seat_get_keyboard(seat));
+  } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && keyboard) {
+    display->ClearKeyboard();
+  }
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+};
+
+void nsWaylandDisplay::SetSeat(wl_seat* aSeat, int aSeatId) {
+  mSeat = aSeat;
+  mSeatId = aSeatId;
+  wl_seat_add_listener(aSeat, &seat_listener, this);
+}
+
+void nsWaylandDisplay::RemoveSeat(int aSeatId) {
+  if (mSeatId == aSeatId) {
+    mSeat = nullptr;
+    mSeatId = -1;
+  }
+}
+
+/* This keymap routine is derived from weston-2.0.0/clients/simple-im.c
+ */
+static void keyboard_handle_keymap(void* data, struct wl_keyboard* wl_keyboard,
+                                   uint32_t format, int fd, uint32_t size) {
+  KeymapWrapper::HandleKeymap(format, fd, size);
+}
+
+static void keyboard_handle_enter(void* data, struct wl_keyboard* keyboard,
+                                  uint32_t serial, struct wl_surface* surface,
+                                  struct wl_array* keys) {
+  KeymapWrapper::SetFocusIn(surface, serial);
+}
+
+static void keyboard_handle_leave(void* data, struct wl_keyboard* keyboard,
+                                  uint32_t serial, struct wl_surface* surface) {
+  KeymapWrapper::SetFocusOut(surface);
+}
+
+static void keyboard_handle_key(void* data, struct wl_keyboard* keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state) {}
+static void keyboard_handle_modifiers(void* data, struct wl_keyboard* keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched,
+                                      uint32_t mods_locked, uint32_t group) {}
+static void keyboard_handle_repeat_info(void* data,
+                                        struct wl_keyboard* keyboard,
+                                        int32_t rate, int32_t delay) {}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,    keyboard_handle_enter,
+    keyboard_handle_leave,     keyboard_handle_key,
+    keyboard_handle_modifiers, keyboard_handle_repeat_info};
+
+void nsWaylandDisplay::SetKeyboard(wl_keyboard* aKeyboard) {
+  MOZ_ASSERT(aKeyboard);
+  MOZ_DIAGNOSTIC_ASSERT(!mKeyboard);
+  mKeyboard = aKeyboard;
+  wl_keyboard_add_listener(mKeyboard, &keyboard_listener, nullptr);
+}
+
+void nsWaylandDisplay::ClearKeyboard() {
+  if (mKeyboard) {
+    wl_keyboard_destroy(mKeyboard);
+    mKeyboard = nullptr;
+  }
+}
+
 void nsWaylandDisplay::SetCompositor(wl_compositor* aCompositor) {
   mCompositor = aCompositor;
 }
@@ -84,6 +277,11 @@
   mPointerConstraints = aPointerConstraints;
 }
 
+void nsWaylandDisplay::SetPointerGestures(
+    zwp_pointer_gestures_v1* aPointerGestures) {
+  mPointerGestures = aPointerGestures;
+}
+
 void nsWaylandDisplay::SetDmabuf(zwp_linux_dmabuf_v1* aDmabuf) {
   mDmabuf = aDmabuf;
 }
@@ -124,7 +322,8 @@
         registry, id, &zwp_pointer_constraints_v1_interface, 1);
     display->SetPointerConstraints(pointer_constraints);
   } else if (iface.EqualsLiteral("wl_compositor")) {
-    // Requested wl_compositor version 4 as we need wl_surface_damage_buffer().
+    // Requested wl_compositor version 4 as we need
+    // wl_surface_damage_buffer().
     auto* compositor = WaylandRegistryBind<wl_compositor>(
         registry, id, &wl_compositor_interface, 4);
     display->SetCompositor(compositor);
@@ -152,7 +351,7 @@
   } else if (iface.EqualsLiteral("wl_seat")) {
     auto* seat =
         WaylandRegistryBind<wl_seat>(registry, id, &wl_seat_interface, 1);
-    KeymapWrapper::SetSeat(seat, id);
+    display->SetSeat(seat, id);
   } else if (iface.EqualsLiteral("wp_fractional_scale_manager_v1")) {
     auto* manager = WaylandRegistryBind<wp_fractional_scale_manager_v1>(
         registry, id, &wp_fractional_scale_manager_v1_interface, 1);
@@ -160,12 +359,21 @@
   } else if (iface.EqualsLiteral("gtk_primary_selection_device_manager") ||
              iface.EqualsLiteral("zwp_primary_selection_device_manager_v1")) {
     display->EnablePrimarySelection();
+  } else if (iface.EqualsLiteral("zwp_pointer_gestures_v1")) {
+    // HOLD is introduced in version 3
+    auto* gestures = WaylandRegistryBind<zwp_pointer_gestures_v1>(
+        registry, id, &zwp_pointer_gestures_v1_interface, 3);
+    display->SetPointerGestures(gestures);
   }
 }
 
 static void global_registry_remover(void* data, wl_registry* registry,
                                     uint32_t id) {
-  KeymapWrapper::ClearSeat(id);
+  auto* display = static_cast<nsWaylandDisplay*>(data);
+  if (!display) {
+    return;
+  }
+  display->RemoveSeat(id);
 }
 
 static const struct wl_registry_listener registry_listener = {