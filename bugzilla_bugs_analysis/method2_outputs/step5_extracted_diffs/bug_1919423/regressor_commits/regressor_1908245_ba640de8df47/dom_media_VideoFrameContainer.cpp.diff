# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/VideoFrameContainer.cpp
# Commit: ba640de8df47
# Full Hash: ba640de8df47d54906c708eb78f2d000d6f6d7f6
# Author: Andrew Osmond <aosmond@mozilla.com>
# Date: 2024-09-13 21:45:07
# Regressor Bug: 1908245
# File Overlap Count: 1
# Description:
#   Bug 1908245 - Add support for missing requestVideoFrameCallback parameters. r=media-playback-reviewers,webidl,padenot,saschanaz
#   
#   This patch adds support for exposing the capture time, receive time,
#   processing duration and RTP timestamp parameters on the callback for
#   rVFC for WebRTC related elements.
# ==============================================================================

diff -r 2f4f9cce6f7d -r ba640de8df47 dom/media/VideoFrameContainer.cpp
--- a/dom/media/VideoFrameContainer.cpp	Fri Sep 13 18:15:18 2024 +0000
+++ b/dom/media/VideoFrameContainer.cpp	Fri Sep 13 18:19:57 2024 +0000
@@ -95,17 +95,18 @@
 }
 #endif
 
-void VideoFrameContainer::SetCurrentFrame(const gfx::IntSize& aIntrinsicSize,
-                                          Image* aImage,
-                                          const TimeStamp& aTargetTime) {
+void VideoFrameContainer::SetCurrentFrame(
+    const gfx::IntSize& aIntrinsicSize, Image* aImage,
+    const TimeStamp& aTargetTime, const media::TimeUnit& aProcessingDuration,
+    const media::TimeUnit& aMediaTime) {
 #ifdef MOZ_WIDGET_ANDROID
   NotifySetCurrent(aImage);
 #endif
   if (aImage) {
     MutexAutoLock lock(mMutex);
     AutoTArray<ImageContainer::NonOwningImage, 1> imageList;
-    imageList.AppendElement(
-        ImageContainer::NonOwningImage(aImage, aTargetTime, ++mFrameID));
+    imageList.AppendElement(ImageContainer::NonOwningImage(
+        aImage, aTargetTime, ++mFrameID, 0, aProcessingDuration, aMediaTime));
     SetCurrentFramesLocked(aIntrinsicSize, imageList);
   } else {
     ClearCurrentFrame(aIntrinsicSize);
@@ -203,16 +204,18 @@
 
   if (!kungFuDeathGrip.IsEmpty()) {
     AutoTArray<ImageContainer::NonOwningImage, 1> currentFrame;
-    ImageContainer::OwningImage& img = kungFuDeathGrip[0];
+    const ImageContainer::OwningImage* img = &kungFuDeathGrip[0];
     // Find the current image in case there are several.
     for (const auto& image : kungFuDeathGrip) {
       if (image.mTimeStamp > aNow) {
         break;
       }
-      img = image;
+      img = &image;
     }
     currentFrame.AppendElement(ImageContainer::NonOwningImage(
-        img.mImage, img.mTimeStamp, img.mFrameID, img.mProducerID));
+        img->mImage, img->mTimeStamp, img->mFrameID, img->mProducerID,
+        img->mProcessingDuration, img->mMediaTime, img->mWebrtcCaptureTime,
+        img->mWebrtcReceiveTime, img->mRtpTimestamp));
     mImageContainer->SetCurrentImages(currentFrame);
   }
 }