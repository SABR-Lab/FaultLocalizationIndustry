# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/CookieCommons.cpp
# Commit: 0868fb4018a7
# Full Hash: 0868fb4018a7ae2002b8f2fcfd88643c2e060f07
# Author: Andrea Marchesini <amarchesini@mozilla.com>
# Date: 2024-09-11 09:21:34
# Regressor Bug: 1475599
# File Overlap Count: 1
# Description:
#   Bug 1475599 - part 2 - CookieStore API - IPDL, r=edgul,webidl,smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D215145
# ==============================================================================

diff -r 9c8b6e35bf3f -r 0868fb4018a7 netwerk/cookie/CookieCommons.cpp
--- a/netwerk/cookie/CookieCommons.cpp	Tue Sep 10 16:31:38 2024 +0000
+++ b/netwerk/cookie/CookieCommons.cpp	Tue Sep 10 16:31:38 2024 +0000
@@ -16,6 +16,8 @@
 #include "mozilla/dom/CanonicalBrowsingContext.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/WindowGlobalParent.h"
+#include "mozilla/dom/WorkerCommon.h"
+#include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/net/CookieJarSettings.h"
 #include "mozilla/Unused.h"
 #include "mozIThirdPartyUtil.h"
@@ -23,10 +25,12 @@
 #include "nsICookiePermission.h"
 #include "nsICookieService.h"
 #include "nsIEffectiveTLDService.h"
+#include "nsIGlobalObject.h"
 #include "nsIHttpChannel.h"
 #include "nsIRedirectHistoryEntry.h"
 #include "nsIWebProgressListener.h"
 #include "nsNetUtil.h"
+#include "nsSandboxFlags.h"
 #include "nsScriptSecurityManager.h"
 #include "ThirdPartyUtil.h"
 
@@ -47,31 +51,35 @@
 
 // static
 bool CookieCommons::PathMatches(Cookie* aCookie, const nsACString& aPath) {
-  const nsCString& cookiePath(aCookie->Path());
+  return PathMatches(aCookie->Path(), aPath);
+}
 
+// static
+bool CookieCommons::PathMatches(const nsACString& aCookiePath,
+                                const nsACString& aPath) {
   // if our cookie path is empty we can't really perform our prefix check, and
   // also we can't check the last character of the cookie path, so we would
   // never return a successful match.
-  if (cookiePath.IsEmpty()) {
+  if (aCookiePath.IsEmpty()) {
     return false;
   }
 
   // if the cookie path and the request path are identical, they match.
-  if (cookiePath.Equals(aPath)) {
+  if (aCookiePath.Equals(aPath)) {
     return true;
   }
 
   // if the cookie path is a prefix of the request path, and the last character
   // of the cookie path is %x2F ("/"), they match.
-  bool isPrefix = StringBeginsWith(aPath, cookiePath);
-  if (isPrefix && cookiePath.Last() == '/') {
+  bool isPrefix = StringBeginsWith(aPath, aCookiePath);
+  if (isPrefix && aCookiePath.Last() == '/') {
     return true;
   }
 
   // if the cookie path is a prefix of the request path, and the first character
   // of the request path that is not included in the cookie path is a %x2F ("/")
   // character, they match.
-  uint32_t cookiePathLen = cookiePath.Length();
+  uint32_t cookiePathLen = aCookiePath.Length();
   return isPrefix && aPath[cookiePathLen] == '/';
 }
 
@@ -827,6 +835,138 @@
 }
 
 // static
+CookieCommons::SecurityChecksResult
+CookieCommons::CheckGlobalAndRetrieveCookiePrincipals(
+    Document* aDocument, nsIPrincipal** aCookiePrincipal,
+    nsIPrincipal** aCookiePartitionedPrincipal) {
+  MOZ_ASSERT(aCookiePrincipal);
+
+  nsCOMPtr<nsIPrincipal> cookiePrincipal;
+  nsCOMPtr<nsIPrincipal> cookiePartitionedPrincipal;
+
+  if (!NS_IsMainThread()) {
+    MOZ_ASSERT(!aDocument);
+
+    dom::WorkerPrivate* workerPrivate = dom::GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+
+    StorageAccess storageAccess = workerPrivate->StorageAccess();
+    if (storageAccess == StorageAccess::eDeny) {
+      return SecurityChecksResult::eDoNotContinue;
+    }
+
+    cookiePrincipal = workerPrivate->GetPrincipal();
+    if (NS_WARN_IF(!cookiePrincipal) || cookiePrincipal->GetIsNullPrincipal()) {
+      return SecurityChecksResult::eSecurityError;
+    }
+
+    // CHIPS - If CHIPS is enabled the partitioned cookie jar is always
+    // available (and therefore the partitioned principal), the unpartitioned
+    // cookie jar is only available in first-party or third-party with
+    // storageAccess contexts. In both cases, the Worker will have storage
+    // access.
+    bool isCHIPS = StaticPrefs::network_cookie_CHIPS_enabled() &&
+                   workerPrivate->CookieJarSettings()->GetPartitionForeign();
+    bool workerHasStorageAccess =
+        workerPrivate->StorageAccess() == StorageAccess::eAllow;
+
+    if (isCHIPS && workerHasStorageAccess) {
+      // Assert that the cookie principal is unpartitioned.
+      MOZ_ASSERT(
+          cookiePrincipal->OriginAttributesRef().mPartitionKey.IsEmpty());
+      // Only retrieve the partitioned originAttributes if the partitionKey is
+      // set. The partitionKey could be empty for partitionKey in partitioned
+      // originAttributes if the aWorker is for privilege context, such as the
+      // extension's background page.
+      nsCOMPtr<nsIPrincipal> partitionedPrincipal =
+          workerPrivate->GetPartitionedPrincipal();
+      if (partitionedPrincipal && !partitionedPrincipal->OriginAttributesRef()
+                                       .mPartitionKey.IsEmpty()) {
+        cookiePartitionedPrincipal = partitionedPrincipal;
+      }
+    }
+  } else {
+    if (!aDocument) {
+      return SecurityChecksResult::eDoNotContinue;
+    }
+
+    cookiePrincipal = aDocument->EffectiveCookiePrincipal();
+    if (NS_WARN_IF(!cookiePrincipal) || cookiePrincipal->GetIsNullPrincipal()) {
+      return SecurityChecksResult::eSecurityError;
+    }
+
+    if (aDocument->CookieAccessDisabled()) {
+      return SecurityChecksResult::eDoNotContinue;
+    }
+
+    // If the document's sandboxed origin flag is set, then reading cookies
+    // is prohibited.
+    if (aDocument->GetSandboxFlags() & SANDBOXED_ORIGIN) {
+      return SecurityChecksResult::eSecurityError;
+    }
+
+    // GTests do not create an inner window and because of these a few security
+    // checks will block this method.
+    if (!StaticPrefs::dom_cookie_testing_enabled()) {
+      StorageAccess storageAccess = CookieAllowedForDocument(aDocument);
+      if (storageAccess == StorageAccess::eDeny) {
+        return SecurityChecksResult::eDoNotContinue;
+      }
+
+      if (ShouldPartitionStorage(storageAccess) &&
+          !StoragePartitioningEnabled(storageAccess,
+                                      aDocument->CookieJarSettings())) {
+        return SecurityChecksResult::eDoNotContinue;
+      }
+
+      // If the document is a cookie-averse Document... return the empty string.
+      if (aDocument->IsCookieAverse()) {
+        return SecurityChecksResult::eDoNotContinue;
+      }
+    }
+
+    // CHIPS - If CHIPS is enabled the partitioned cookie jar is always
+    // available (and therefore the partitioned principal), the unpartitioned
+    // cookie jar is only available in first-party or third-party with
+    // storageAccess contexts. In both cases, the aDocument will have storage
+    // access.
+    bool isCHIPS = StaticPrefs::network_cookie_CHIPS_enabled() &&
+                   aDocument->CookieJarSettings()->GetPartitionForeign();
+    bool documentHasStorageAccess = false;
+    nsresult rv = aDocument->HasStorageAccessSync(documentHasStorageAccess);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SecurityChecksResult::eDoNotContinue;
+    }
+
+    if (isCHIPS && documentHasStorageAccess) {
+      // Assert that the cookie principal is unpartitioned.
+      MOZ_ASSERT(
+          cookiePrincipal->OriginAttributesRef().mPartitionKey.IsEmpty());
+      // Only append the partitioned originAttributes if the partitionKey is
+      // set. The partitionKey could be empty for partitionKey in partitioned
+      // originAttributes if the aDocument is for privilege context, such as the
+      // extension's background page.
+      if (!aDocument->PartitionedPrincipal()
+               ->OriginAttributesRef()
+               .mPartitionKey.IsEmpty()) {
+        cookiePartitionedPrincipal = aDocument->PartitionedPrincipal();
+      }
+    }
+  }
+
+  if (!IsSchemeSupported(cookiePrincipal)) {
+    return SecurityChecksResult::eDoNotContinue;
+  }
+
+  cookiePrincipal.forget(aCookiePrincipal);
+
+  if (aCookiePartitionedPrincipal) {
+    cookiePartitionedPrincipal.forget(aCookiePartitionedPrincipal);
+  }
+
+  return SecurityChecksResult::eContinue;
+}
+// static
 void CookieCommons::GetServerDateHeader(nsIChannel* aChannel,
                                         nsACString& aServerDateHeader) {
   if (!aChannel) {