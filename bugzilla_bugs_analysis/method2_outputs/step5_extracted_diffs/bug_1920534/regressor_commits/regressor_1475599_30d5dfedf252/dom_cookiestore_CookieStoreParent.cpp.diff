# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/cookiestore/CookieStoreParent.cpp
# Commit: 30d5dfedf252
# Full Hash: 30d5dfedf252f4f10a0d8948e86f4e57f1c4ccf9
# Author: Andrea Marchesini <amarchesini@mozilla.com>
# Date: 2024-09-11 09:21:34
# Regressor Bug: 1475599
# File Overlap Count: 1
# Description:
#   Bug 1475599 - part 8 - CookieStore API - e10s support, r=smaug,cookie-reviewers,timhuang
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D217574
# ==============================================================================

diff -r fc3b4c5ee4b2 -r 30d5dfedf252 dom/cookiestore/CookieStoreParent.cpp
--- a/dom/cookiestore/CookieStoreParent.cpp	Tue Sep 10 16:31:40 2024 +0000
+++ b/dom/cookiestore/CookieStoreParent.cpp	Tue Sep 10 16:31:41 2024 +0000
@@ -5,23 +5,116 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "CookieStoreParent.h"
+#include "CookieStoreNotificationWatcher.h"
+
 #include "mozilla/Maybe.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/net/CookieCommons.h"
 #include "mozilla/Unused.h"
 #include "nsICookieManager.h"
+#include "nsProxyRelease.h"
 
 using namespace mozilla::ipc;
 
 namespace mozilla::dom {
 
-namespace {
+CookieStoreParent::CookieStoreParent() { AssertIsOnBackgroundThread(); }
+
+CookieStoreParent::~CookieStoreParent() {
+  AssertIsOnBackgroundThread();
+  CookieStoreNotificationWatcher::ReleaseOnMainThread(
+      mNotificationWatcherOnMainThread.forget());
+}
+
+mozilla::ipc::IPCResult CookieStoreParent::RecvGetRequest(
+    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
+    const bool& aMatchName, const nsString& aName, const nsCString& aPath,
+    const bool& aOnlyFirstMatch, GetRequestResolver&& aResolver) {
+  AssertIsOnBackgroundThread();
+
+  InvokeAsync(GetMainThreadSerialEventTarget(), __func__,
+              [self = RefPtr(this), aDomain, aOriginAttributes, aMatchName,
+               aName, aPath, aOnlyFirstMatch]() {
+                CopyableTArray<CookieData> results;
+                self->GetRequestOnMainThread(aDomain, aOriginAttributes,
+                                             aMatchName, aName, aPath,
+                                             aOnlyFirstMatch, results);
+                return GetRequestPromise::CreateAndResolve(std::move(results),
+                                                           __func__);
+              })
+      ->Then(GetCurrentSerialEventTarget(), __func__,
+             [aResolver = std::move(aResolver)](
+                 const GetRequestPromise::ResolveOrRejectValue& aResult) {
+               MOZ_ASSERT(aResult.IsResolve());
+               aResolver(aResult.ResolveValue());
+             });
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult CookieStoreParent::RecvSetRequest(
+    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
+    const nsString& aName, const nsString& aValue, const bool& aSession,
+    const int64_t& aExpires, const nsString& aPath, const int32_t& aSameSite,
+    const bool& aPartitioned, const nsID& aOperationID,
+    SetRequestResolver&& aResolver) {
+  AssertIsOnBackgroundThread();
 
-void GetRequestHelper(const nsAString& aDomain,
-                      const OriginAttributes& aOriginAttributes,
-                      bool aMatchName, const nsAString& aName,
-                      const nsACString& aPath, bool aOnlyFirstMatch,
-                      nsTArray<CookieData>& aResults) {
+  InvokeAsync(
+      GetMainThreadSerialEventTarget(), __func__,
+      [self = RefPtr(this), aDomain, aOriginAttributes, aName, aValue, aSession,
+       aExpires, aPath, aSameSite, aPartitioned, aOperationID]() {
+        bool waitForNotification = self->SetRequestOnMainThread(
+            aDomain, aOriginAttributes, aName, aValue, aSession, aExpires,
+            aPath, aSameSite, aPartitioned, aOperationID);
+        return SetDeleteRequestPromise::CreateAndResolve(waitForNotification,
+                                                         __func__);
+      })
+      ->Then(GetCurrentSerialEventTarget(), __func__,
+             [aResolver = std::move(aResolver)](
+                 const SetDeleteRequestPromise::ResolveOrRejectValue& aResult) {
+               MOZ_ASSERT(aResult.IsResolve());
+               aResolver(aResult.ResolveValue());
+             });
+
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult CookieStoreParent::RecvDeleteRequest(
+    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
+    const nsString& aName, const nsString& aPath, const bool& aPartitioned,
+    const nsID& aOperationID, DeleteRequestResolver&& aResolver) {
+  AssertIsOnBackgroundThread();
+
+  InvokeAsync(GetMainThreadSerialEventTarget(), __func__,
+              [self = RefPtr(this), aDomain, aOriginAttributes, aName, aPath,
+               aPartitioned, aOperationID]() {
+                bool waitForNotification = self->DeleteRequestOnMainThread(
+                    aDomain, aOriginAttributes, aName, aPath, aPartitioned,
+                    aOperationID);
+                return SetDeleteRequestPromise::CreateAndResolve(
+                    waitForNotification, __func__);
+              })
+      ->Then(GetCurrentSerialEventTarget(), __func__,
+             [aResolver = std::move(aResolver)](
+                 const SetDeleteRequestPromise::ResolveOrRejectValue& aResult) {
+               MOZ_ASSERT(aResult.IsResolve());
+               aResolver(aResult.ResolveValue());
+             });
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult CookieStoreParent::RecvClose() {
+  AssertIsOnBackgroundThread();
+
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void CookieStoreParent::GetRequestOnMainThread(
+    const nsAString& aDomain, const OriginAttributes& aOriginAttributes,
+    bool aMatchName, const nsAString& aName, const nsACString& aPath,
+    bool aOnlyFirstMatch, nsTArray<CookieData>& aResults) {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsICookieManager> service =
@@ -90,19 +183,30 @@
   aResults.SwapElements(list);
 }
 
-void SetRequestHelper(const nsAString& aDomain,
-                      const OriginAttributes& aOriginAttributes,
-                      const nsAString& aName, const nsAString& aValue,
-                      bool aSession, int64_t aExpires, const nsAString& aPath,
-                      int32_t aSameSite, bool aPartitioned) {
+bool CookieStoreParent::SetRequestOnMainThread(
+    const nsAString& aDomain, const OriginAttributes& aOriginAttributes,
+    const nsAString& aName, const nsAString& aValue, bool aSession,
+    int64_t aExpires, const nsAString& aPath, int32_t aSameSite,
+    bool aPartitioned, const nsID& aOperationID) {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsICookieManager> service =
       do_GetService(NS_COOKIEMANAGER_CONTRACTID);
   if (!service) {
-    return;
+    return false;
   }
 
+  bool notified = false;
+  auto notificationCb = [&]() { notified = true; };
+
+  CookieStoreNotificationWatcher* notificationWatcher =
+      GetOrCreateNotificationWatcherOnMainThread(aOriginAttributes);
+  if (!notificationWatcher) {
+    return false;
+  }
+
+  notificationWatcher->CallbackWhenNotified(aOperationID, notificationCb);
+
   OriginAttributes attrs(aOriginAttributes);
   nsresult rv = service->AddNative(
       NS_ConvertUTF16toUTF8(aDomain), NS_ConvertUTF16toUTF8(aPath),
@@ -110,22 +214,26 @@
       true,   //  secure
       false,  // mHttpOnly,
       aSession, aSession ? PR_Now() : aExpires, &attrs, aSameSite,
-      nsICookie::SCHEME_HTTPS, aPartitioned, nullptr);
+      nsICookie::SCHEME_HTTPS, aPartitioned, &aOperationID);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
+    return false;
   }
+
+  notificationWatcher->ForgetOperationID(aOperationID);
+
+  return notified;
 }
 
-void DeleteRequestHelper(const nsAString& aDomain,
-                         const OriginAttributes& aOriginAttributes,
-                         const nsAString& aName, const nsAString& aPath,
-                         bool aPartitioned) {
+bool CookieStoreParent::DeleteRequestOnMainThread(
+    const nsAString& aDomain, const OriginAttributes& aOriginAttributes,
+    const nsAString& aName, const nsAString& aPath, bool aPartitioned,
+    const nsID& aOperationID) {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsICookieManager> service =
       do_GetService(NS_COOKIEMANAGER_CONTRACTID);
   if (!service) {
-    return;
+    return false;
   }
 
   NS_ConvertUTF16toUTF8 domainUtf8(aDomain);
@@ -134,7 +242,7 @@
   nsTArray<RefPtr<nsICookie>> results;
   nsresult rv = service->GetCookiesFromHostNative(domainUtf8, &attrs, results);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
+    return false;
   }
 
   NS_ConvertUTF16toUTF8 matchName(aName);
@@ -146,7 +254,7 @@
     nsAutoCString name;
     rv = cookie->GetName(name);
     if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
+      return false;
     }
 
     if (!matchName.Equals(name)) {
@@ -156,7 +264,7 @@
     nsAutoCString path;
     rv = cookie->GetPath(path);
     if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
+      return false;
     }
 
     if (!matchPath.IsEmpty() && !matchPath.Equals(path)) {
@@ -166,97 +274,47 @@
     bool isPartitioned = false;
     rv = cookie->GetIsPartitioned(&isPartitioned);
     if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
+      return false;
     }
 
     if (isPartitioned != aPartitioned) continue;
 
-    rv = service->RemoveNative(domainUtf8, matchName, path, &attrs, nullptr);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
+    bool notified = false;
+    auto notificationCb = [&]() { notified = true; };
+
+    CookieStoreNotificationWatcher* notificationWatcher =
+        GetOrCreateNotificationWatcherOnMainThread(aOriginAttributes);
+    if (!notificationWatcher) {
+      return false;
     }
-  }
-}
 
-}  // namespace
-
-CookieStoreParent::CookieStoreParent() { AssertIsOnBackgroundThread(); }
-
-CookieStoreParent::~CookieStoreParent() { AssertIsOnBackgroundThread(); }
+    notificationWatcher->CallbackWhenNotified(aOperationID, notificationCb);
 
-mozilla::ipc::IPCResult CookieStoreParent::RecvGetRequest(
-    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
-    const bool& aMatchName, const nsString& aName, const nsCString& aPath,
-    const bool& aOnlyFirstMatch, GetRequestResolver&& aResolver) {
-  InvokeAsync(GetMainThreadSerialEventTarget(), __func__,
-              [aDomain, aOriginAttributes, aMatchName, aName, aPath,
-               aOnlyFirstMatch]() {
-                CopyableTArray<CookieData> results;
-                GetRequestHelper(aDomain, aOriginAttributes, aMatchName, aName,
-                                 aPath, aOnlyFirstMatch, results);
-                return GetRequestPromise::CreateAndResolve(std::move(results),
-                                                           __func__);
-              })
-      ->Then(GetCurrentSerialEventTarget(), __func__,
-             [aResolver = std::move(aResolver)](
-                 const GetRequestPromise::ResolveOrRejectValue& aResult) {
-               MOZ_ASSERT(aResult.IsResolve());
-               aResolver(aResult.ResolveValue());
-             });
+    rv = service->RemoveNative(domainUtf8, matchName, path, &attrs,
+                               &aOperationID);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return false;
+    }
 
-  return IPC_OK();
+    notificationWatcher->ForgetOperationID(aOperationID);
+
+    return notified;
+  }
+
+  return false;
 }
 
-mozilla::ipc::IPCResult CookieStoreParent::RecvSetRequest(
-    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
-    const nsString& aName, const nsString& aValue, const bool& aSession,
-    const int64_t& aExpires, const nsString& aPath, const int32_t& aSameSite,
-    const bool& aPartitioned, SetRequestResolver&& aResolver) {
-  InvokeAsync(
-      GetMainThreadSerialEventTarget(), __func__,
-      [aDomain, aOriginAttributes, aName, aValue, aSession, aExpires, aPath,
-       aSameSite, aPartitioned]() {
-        SetRequestHelper(aDomain, aOriginAttributes, aName, aValue, aSession,
-                         aExpires, aPath, aSameSite, aPartitioned);
-        return SetDeleteRequestPromise::CreateAndResolve(true, __func__);
-      })
-      ->Then(GetCurrentSerialEventTarget(), __func__,
-             [aResolver = std::move(aResolver)](
-                 const SetDeleteRequestPromise::ResolveOrRejectValue& aResult) {
-               MOZ_ASSERT(aResult.IsResolve());
-               aResolver(aResult.ResolveValue());
-             });
-
-  return IPC_OK();
-}
+CookieStoreNotificationWatcher*
+CookieStoreParent::GetOrCreateNotificationWatcherOnMainThread(
+    const OriginAttributes& aOriginAttributes) {
+  MOZ_ASSERT(NS_IsMainThread());
 
-mozilla::ipc::IPCResult CookieStoreParent::RecvDeleteRequest(
-    const nsString& aDomain, const OriginAttributes& aOriginAttributes,
-    const nsString& aName, const nsString& aPath, const bool& aPartitioned,
-    DeleteRequestResolver&& aResolver) {
-  AssertIsOnBackgroundThread();
+  if (!mNotificationWatcherOnMainThread) {
+    mNotificationWatcherOnMainThread = CookieStoreNotificationWatcher::Create(
+        aOriginAttributes.IsPrivateBrowsing());
+  }
 
-  InvokeAsync(GetMainThreadSerialEventTarget(), __func__,
-              [aDomain, aOriginAttributes, aName, aPath, aPartitioned]() {
-                DeleteRequestHelper(aDomain, aOriginAttributes, aName, aPath,
-                                    aPartitioned);
-                return SetDeleteRequestPromise::CreateAndResolve(true,
-                                                                 __func__);
-              })
-      ->Then(GetCurrentSerialEventTarget(), __func__,
-             [aResolver = std::move(aResolver)](
-                 const SetDeleteRequestPromise::ResolveOrRejectValue& aResult) {
-               MOZ_ASSERT(aResult.IsResolve());
-               aResolver(aResult.ResolveValue());
-             });
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult CookieStoreParent::RecvClose() {
-  AssertIsOnBackgroundThread();
-
-  Unused << Send__delete__(this);
-  return IPC_OK();
+  return mNotificationWatcherOnMainThread;
 }
 
 }  // namespace mozilla::dom