# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/cookiestore/CookieStore.cpp
# Commit: 7e736b5732c1
# Full Hash: 7e736b5732c17f105f4692be0794568e23f88532
# Author: Andrea Marchesini <amarchesini@mozilla.com>
# Date: 2024-09-12 09:23:07
# Regressor Bug: 1475599
# File Overlap Count: 1
# Description:
#   Bug 1475599 - part 10 - CookieStore API - CHIP implementation shared between Document and CookieStore, r=cookie-reviewers,valentin
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D220288
# ==============================================================================

diff -r 8620daea37ad -r 7e736b5732c1 dom/cookiestore/CookieStore.cpp
--- a/dom/cookiestore/CookieStore.cpp	Wed Sep 11 16:26:57 2024 +0000
+++ b/dom/cookiestore/CookieStore.cpp	Wed Sep 11 16:26:58 2024 +0000
@@ -22,6 +22,7 @@
 #include "nsIPrincipal.h"
 #include "nsReadableUtils.h"
 #include "nsSandboxFlags.h"
+#include "ThirdPartyUtil.h"
 
 using namespace mozilla::net;
 
@@ -193,6 +194,46 @@
       [promise = RefPtr(aPromise)] { promise->MaybeResolveWithUndefined(); }));
 }
 
+bool GetContextAttributes(CookieStore* aCookieStore, bool* aThirdPartyContext,
+                          bool* aPartitionForeign, bool* aUsingStorageAccess,
+                          Promise* aPromise) {
+  MOZ_ASSERT(aCookieStore);
+  MOZ_ASSERT(aThirdPartyContext);
+  MOZ_ASSERT(aPartitionForeign);
+  MOZ_ASSERT(aUsingStorageAccess);
+  MOZ_ASSERT(aPromise);
+
+  if (NS_IsMainThread()) {
+    nsCOMPtr<nsPIDOMWindowInner> window = aCookieStore->GetOwnerWindow();
+    MOZ_ASSERT(window);
+
+    ThirdPartyUtil* thirdPartyUtil = ThirdPartyUtil::GetInstance();
+    if (thirdPartyUtil) {
+      Unused << thirdPartyUtil->IsThirdPartyWindow(window->GetOuterWindow(),
+                                                   nullptr, aThirdPartyContext);
+    }
+
+    nsCOMPtr<Document> document = window->GetExtantDoc();
+    if (NS_WARN_IF(!document)) {
+      aPromise->MaybeReject(NS_ERROR_DOM_SECURITY_ERR);
+      return false;
+    }
+
+    *aPartitionForeign = document->CookieJarSettings()->GetPartitionForeign();
+    *aUsingStorageAccess = document->UsingStorageAccess();
+    return true;
+  }
+
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+  MOZ_ASSERT(workerPrivate);
+
+  *aThirdPartyContext = workerPrivate->IsThirdPartyContext();
+  *aPartitionForeign =
+      workerPrivate->CookieJarSettings()->GetPartitionForeign();
+  *aUsingStorageAccess = workerPrivate->UsingStorageAccess();
+  return true;
+}
+
 }  // namespace
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(CookieStore)
@@ -324,6 +365,15 @@
           return;
         }
 
+        bool thirdPartyContext = true;
+        bool partitionForeign = true;
+        bool usingStorageAccess = false;
+
+        if (!GetContextAttributes(self, &thirdPartyContext, &partitionForeign,
+                                  &usingStorageAccess, promise)) {
+          return;
+        }
+
         if (!self->MaybeCreateActor()) {
           promise->MaybeRejectWithNotAllowedError("Permission denied");
           return;
@@ -348,8 +398,9 @@
             self->mActor->SendSetRequest(
                 aOptions.mDomain.IsEmpty() ? nsString(baseDomain)
                                            : nsString(aOptions.mDomain),
-                cookiePrincipal->OriginAttributesRef(),
-                nsString(aOptions.mName), nsString(aOptions.mValue),
+                cookiePrincipal->OriginAttributesRef(), thirdPartyContext,
+                partitionForeign, usingStorageAccess, nsString(aOptions.mName),
+                nsString(aOptions.mValue),
                 // If expires is not set, it's a session cookie.
                 aOptions.mExpires.IsNull(),
                 aOptions.mExpires.IsNull()
@@ -437,6 +488,15 @@
           return;
         }
 
+        bool thirdPartyContext = true;
+        bool partitionForeign = true;
+        bool usingStorageAccess = false;
+
+        if (!GetContextAttributes(self, &thirdPartyContext, &partitionForeign,
+                                  &usingStorageAccess, promise)) {
+          return;
+        }
+
         if (!self->MaybeCreateActor()) {
           promise->MaybeRejectWithNotAllowedError("Permission denied");
           return;
@@ -461,9 +521,9 @@
             self->mActor->SendDeleteRequest(
                 aOptions.mDomain.IsEmpty() ? nsString(baseDomain)
                                            : nsString(aOptions.mDomain),
-                cookiePrincipal->OriginAttributesRef(),
-                nsString(aOptions.mName), path, aOptions.mPartitioned,
-                operationID);
+                cookiePrincipal->OriginAttributesRef(), thirdPartyContext,
+                partitionForeign, usingStorageAccess, nsString(aOptions.mName),
+                path, aOptions.mPartitioned, operationID);
         if (NS_WARN_IF(!ipcPromise)) {
           promise->MaybeResolveWithUndefined();
           return;
@@ -528,8 +588,10 @@
   }
 
   nsCOMPtr<nsIPrincipal> cookiePrincipal;
+  nsCOMPtr<nsIPrincipal> partitionedCookiePrincipal;
   switch (CookieCommons::CheckGlobalAndRetrieveCookiePrincipals(
-      MaybeGetDocument(), getter_AddRefs(cookiePrincipal), nullptr)) {
+      MaybeGetDocument(), getter_AddRefs(cookiePrincipal),
+      getter_AddRefs(partitionedCookiePrincipal))) {
     case CookieCommons::SecurityChecksResult::eSandboxedError:
       [[fallthrough]];
 
@@ -549,7 +611,9 @@
   NS_DispatchToCurrentThread(NS_NewRunnableFunction(
       __func__,
       [self = RefPtr(this), promise = RefPtr(promise), aOptions,
-       cookiePrincipal = RefPtr(cookiePrincipal.get()), aOnlyTheFirstMatch]() {
+       cookiePrincipal = RefPtr(cookiePrincipal.get()),
+       partitionedCookiePrincipal = RefPtr(partitionedCookiePrincipal.get()),
+       aOnlyTheFirstMatch]() {
         nsAutoString name;
         if (aOptions.mName.WasPassed()) {
           name = aOptions.mName.Value();
@@ -628,6 +692,15 @@
           }
         }
 
+        bool thirdPartyContext = true;
+        bool partitionForeign = true;
+        bool usingStorageAccess = false;
+
+        if (!GetContextAttributes(self, &thirdPartyContext, &partitionForeign,
+                                  &usingStorageAccess, promise)) {
+          return;
+        }
+
         if (!self->MaybeCreateActor()) {
           promise->MaybeRejectWithNotAllowedError("Permission denied");
           return;
@@ -641,11 +714,15 @@
         }
 
         RefPtr<CookieStoreChild::GetRequestPromise> ipcPromise =
-            self->mActor->SendGetRequest(NS_ConvertUTF8toUTF16(baseDomain),
-                                         cookiePrincipal->OriginAttributesRef(),
-                                         aOptions.mName.WasPassed(),
-                                         nsString(name), path,
-                                         aOnlyTheFirstMatch);
+            self->mActor->SendGetRequest(
+                NS_ConvertUTF8toUTF16(baseDomain),
+                cookiePrincipal->OriginAttributesRef(),
+                partitionedCookiePrincipal
+                    ? Some(partitionedCookiePrincipal->OriginAttributesRef())
+                    : Nothing(),
+                thirdPartyContext, partitionForeign, usingStorageAccess,
+                aOptions.mName.WasPassed(), nsString(name), path,
+                aOnlyTheFirstMatch);
         if (NS_WARN_IF(!ipcPromise)) {
           promise->MaybeResolveWithUndefined();
           return;