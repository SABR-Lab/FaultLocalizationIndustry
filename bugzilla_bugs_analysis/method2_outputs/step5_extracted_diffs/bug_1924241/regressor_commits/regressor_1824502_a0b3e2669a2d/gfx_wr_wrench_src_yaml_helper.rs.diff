# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/wrench/src/yaml_helper.rs
# Commit: a0b3e2669a2d
# Full Hash: a0b3e2669a2dc49c467521cb9b7966ca05e3dbc3
# Author: Ashley Hale <ahale@mozilla.com>
# Date: 2024-05-08 09:49:23
# Regressor Bug: 1824502
# File Overlap Count: 1
# Description:
#   Bug 1824502 - Implement native SVG filter rendering in WebRender r=gw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D209646
# ==============================================================================

diff -r d1df40ba7c88 -r a0b3e2669a2d gfx/wr/wrench/src/yaml_helper.rs
--- a/gfx/wr/wrench/src/yaml_helper.rs	Wed May 08 01:43:25 2024 +0000
+++ b/gfx/wr/wrench/src/yaml_helper.rs	Wed May 08 04:38:26 2024 +0000
@@ -9,6 +9,7 @@
 use webrender::api::*;
 use webrender::api::units::*;
 use yaml_rust::{Yaml, YamlLoader};
+use log::Level;
 
 pub trait YamlHelper {
     fn as_f32(&self) -> Option<f32>;
@@ -33,6 +34,7 @@
     fn as_transform_style(&self) -> Option<TransformStyle>;
     fn as_raster_space(&self) -> Option<RasterSpace>;
     fn as_clip_mode(&self) -> Option<ClipMode>;
+    fn as_graph_picture_reference(&self) -> Option<FilterOpGraphPictureReference>;
     fn as_mix_blend_mode(&self) -> Option<MixBlendMode>;
     fn as_filter_op(&self) -> Option<FilterOp>;
     fn as_vec_filter_op(&self) -> Option<Vec<FilterOp>>;
@@ -537,7 +539,335 @@
         self.as_str().and_then(StringEnum::from_str)
     }
 
+    fn as_graph_picture_reference(&self) -> Option<FilterOpGraphPictureReference> {
+        match self.as_i64() {
+            Some(n) => Some(FilterOpGraphPictureReference{
+                buffer_id: FilterOpGraphPictureBufferId::BufferId(n as i16),
+            }),
+            None => None,
+        }
+    }
+
     fn as_filter_op(&self) -> Option<FilterOp> {
+        if let Some(filter_op) = self["svgfe"].as_str() {
+            let subregion = self["subregion"].as_rect().unwrap_or(
+                LayoutRect::new(
+                    LayoutPoint::new(0.0, 0.0),
+                    LayoutPoint::new(1024.0, 1024.0),
+                ));
+
+            let node = FilterOpGraphNode {
+                linear: self["linear"].as_bool().unwrap_or(true),
+                subregion,
+                input: self["in"].as_graph_picture_reference().unwrap_or(
+                    FilterOpGraphPictureReference{
+                        buffer_id: FilterOpGraphPictureBufferId::None,
+                    }),
+                input2: self["in2"].as_graph_picture_reference().unwrap_or(
+                    FilterOpGraphPictureReference{
+                        buffer_id: FilterOpGraphPictureBufferId::None,
+                    }),
+            };
+            let debug_print_input = |input: FilterOpGraphPictureReference| -> String {
+                match input.buffer_id {
+                    FilterOpGraphPictureBufferId::BufferId(id) => format!("BufferId{}", id),
+                    FilterOpGraphPictureBufferId::None => "None".into(),
+                }
+            };
+            log!(Level::Debug, "svgfe parsed: {} linear: {} in: {} in2: {} subregion: [{}, {}, {}, {}]",
+                filter_op, node.linear,
+                debug_print_input(node.input), debug_print_input(node.input2),
+                node.subregion.min.x, node.subregion.min.y, node.subregion.max.x, node.subregion.max.y,
+            );
+            return match filter_op {
+                "identity" => Some(FilterOp::SVGFEIdentity{node}),
+                "opacity" => {
+                    let value = self["value"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEOpacity{node, valuebinding: value.into(), value})
+                },
+                "toalpha" => Some(FilterOp::SVGFEToAlpha{node}),
+                "blendcolor" => Some(FilterOp::SVGFEBlendColor{node}),
+                "blendcolorburn" => Some(FilterOp::SVGFEBlendColorBurn{node}),
+                "blendcolordodge" => Some(FilterOp::SVGFEBlendColorDodge{node}),
+                "blenddarken" => Some(FilterOp::SVGFEBlendDarken{node}),
+                "blenddifference" => Some(FilterOp::SVGFEBlendDifference{node}),
+                "blendexclusion" => Some(FilterOp::SVGFEBlendExclusion{node}),
+                "blendhardlight" => Some(FilterOp::SVGFEBlendHardLight{node}),
+                "blendhue" => Some(FilterOp::SVGFEBlendHue{node}),
+                "blendlighten" => Some(FilterOp::SVGFEBlendLighten{node}),
+                "blendluminosity" => Some(FilterOp::SVGFEBlendLuminosity{node}),
+                "blendmultiply" => Some(FilterOp::SVGFEBlendMultiply{node}),
+                "blendnormal" => Some(FilterOp::SVGFEBlendNormal{node}),
+                "blendoverlay" => Some(FilterOp::SVGFEBlendOverlay{node}),
+                "blendsaturation" => Some(FilterOp::SVGFEBlendSaturation{node}),
+                "blendscreen" => Some(FilterOp::SVGFEBlendScreen{node}),
+                "blendsoftlight" => Some(FilterOp::SVGFEBlendSoftLight{node}),
+                "colormatrix" => {
+                    let m: Vec<f32> = self["matrix"].as_vec_f32().unwrap();
+                    let mut matrix: [f32; 20] = [0.0; 20];
+                    matrix.clone_from_slice(&m);
+                    Some(FilterOp::SVGFEColorMatrix{node, values: matrix})
+                }
+                "componenttransfer" => Some(FilterOp::SVGFEComponentTransfer{node}),
+                "compositearithmetic" => {
+                    let k: Vec<f32> = self["k"].as_vec_f32().unwrap();
+                    Some(FilterOp::SVGFECompositeArithmetic{
+                        node,
+                        k1: k[0],
+                        k2: k[1],
+                        k3: k[2],
+                        k4: k[3],
+                    })
+                }
+                "compositeatop" => Some(FilterOp::SVGFECompositeATop{node}),
+                "compositein" => Some(FilterOp::SVGFECompositeIn{node}),
+                "compositelighter" => Some(FilterOp::SVGFECompositeLighter{node}),
+                "compositeout" => Some(FilterOp::SVGFECompositeOut{node}),
+                "compositeover" => Some(FilterOp::SVGFECompositeOver{node}),
+                "compositexor" => Some(FilterOp::SVGFECompositeXOR{node}),
+                "convolvematrixedgemodeduplicate" => {
+                    let order_x = self["order_x"].as_i64().unwrap() as i32;
+                    let order_y = self["order_y"].as_i64().unwrap() as i32;
+                    let m: Vec<f32> = self["kernel"].as_vec_f32().unwrap();
+                    let mut kernel: [f32; 25] = [0.0; 25];
+                    kernel.clone_from_slice(&m);
+                    let divisor = self["divisor"].as_f32().unwrap();
+                    let bias = self["bias"].as_f32().unwrap();
+                    let target_x = self["target_x"].as_i64().unwrap() as i32;
+                    let target_y = self["target_y"].as_i64().unwrap() as i32;
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let preserve_alpha = match self["preserve_alpha"].as_bool() {
+                        Some(true) => 1,
+                        Some(false) => 0,
+                        _ => 1,
+                    };
+                    Some(FilterOp::SVGFEConvolveMatrixEdgeModeDuplicate{
+                         node, order_x, order_y, kernel, divisor, bias,
+                         target_x, target_y, kernel_unit_length_x,
+                         kernel_unit_length_y, preserve_alpha})
+                },
+                "convolvematrixedgemodenone" => {
+                    let order_x = self["order_x"].as_i64().unwrap() as i32;
+                    let order_y = self["order_y"].as_i64().unwrap() as i32;
+                    let m: Vec<f32> = self["kernel"].as_vec_f32().unwrap();
+                    let mut kernel: [f32; 25] = [0.0; 25];
+                    kernel.clone_from_slice(&m);
+                    let divisor = self["divisor"].as_f32().unwrap();
+                    let bias = self["bias"].as_f32().unwrap();
+                    let target_x = self["target_x"].as_i64().unwrap() as i32;
+                    let target_y = self["target_y"].as_i64().unwrap() as i32;
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let preserve_alpha = match self["preserve_alpha"].as_bool() {
+                        Some(true) => 1,
+                        Some(false) => 0,
+                        _ => 1,
+                    };
+                    Some(FilterOp::SVGFEConvolveMatrixEdgeModeNone{
+                         node, order_x, order_y, kernel, divisor, bias,
+                         target_x, target_y, kernel_unit_length_x,
+                         kernel_unit_length_y, preserve_alpha})
+                },
+                "convolvematrixedgemodewrap" => {
+                    let order_x = self["order_x"].as_i64().unwrap() as i32;
+                    let order_y = self["order_y"].as_i64().unwrap() as i32;
+                    let m: Vec<f32> = self["kernel"].as_vec_f32().unwrap();
+                    let mut kernel: [f32; 25] = [0.0; 25];
+                    kernel.clone_from_slice(&m);
+                    let divisor = self["divisor"].as_f32().unwrap();
+                    let bias = self["bias"].as_f32().unwrap();
+                    let target_x = self["target_x"].as_i64().unwrap() as i32;
+                    let target_y = self["target_y"].as_i64().unwrap() as i32;
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let preserve_alpha = match self["preserve_alpha"].as_bool() {
+                        Some(true) => 1,
+                        Some(false) => 0,
+                        _ => 1,
+                    };
+                    Some(FilterOp::SVGFEConvolveMatrixEdgeModeWrap{
+                         node, order_x, order_y, kernel, divisor, bias,
+                         target_x, target_y, kernel_unit_length_x,
+                         kernel_unit_length_y, preserve_alpha})
+                },
+                "diffuselightingdistant" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let diffuse_constant = self["diffuse_constant"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let azimuth = self["azimuth"].as_f32().unwrap();
+                    let elevation = self["elevation"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEDiffuseLightingDistant{
+                         node, surface_scale, diffuse_constant,
+                         kernel_unit_length_x, kernel_unit_length_y,
+                         azimuth, elevation})
+                },
+                "diffuselightingpoint" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let diffuse_constant = self["diffuse_constant"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let x = self["x"].as_f32().unwrap();
+                    let y = self["y"].as_f32().unwrap();
+                    let z = self["z"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEDiffuseLightingPoint{
+                         node, surface_scale, diffuse_constant,
+                         kernel_unit_length_x, kernel_unit_length_y, x, y, z})
+                },
+                "diffuselightingspot" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let diffuse_constant = self["diffuse_constant"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let x = self["x"].as_f32().unwrap();
+                    let y = self["y"].as_f32().unwrap();
+                    let z = self["z"].as_f32().unwrap();
+                    let points_at_x = self["points_at_x"].as_f32().unwrap();
+                    let points_at_y = self["points_at_y"].as_f32().unwrap();
+                    let points_at_z = self["points_at_z"].as_f32().unwrap();
+                    let cone_exponent = self["cone_exponent"].as_f32().unwrap();
+                    let limiting_cone_angle = self["limiting_cone_angle"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEDiffuseLightingSpot{
+                         node, surface_scale, diffuse_constant,
+                         kernel_unit_length_x, kernel_unit_length_y, x, y, z,
+                         points_at_x, points_at_y, points_at_z, cone_exponent,
+                         limiting_cone_angle})
+                },
+                "displacementmap" => {
+                    let scale = self["scale"].as_f32().unwrap();
+                    let x_channel_selector = self["x_channel_selector"].as_i64().unwrap() as u32;
+                    let y_channel_selector = self["y_channel_selector"].as_i64().unwrap() as u32;
+                    Some(FilterOp::SVGFEDisplacementMap{node, scale, x_channel_selector, y_channel_selector})
+                },
+                "dropshadow" => {
+                    let color = self["color"].as_colorf().unwrap();
+                    let dx = self["dx"].as_f32().unwrap();
+                    let dy = self["dy"].as_f32().unwrap();
+                    let std_deviation_x = self["std_deviation_x"].as_f32().unwrap();
+                    let std_deviation_y = self["std_deviation_y"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEDropShadow{node, color, dx, dy, std_deviation_x, std_deviation_y})
+                },
+                "flood" => Some(FilterOp::SVGFEFlood{node, color: self["color"].as_colorf().unwrap()}),
+                "gaussianblur" => {
+                    let std_deviation_x = self["std_deviation_x"].as_f32().unwrap();
+                    let std_deviation_y = self["std_deviation_y"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEGaussianBlur{node, std_deviation_x, std_deviation_y})
+                },
+                "image" => {
+                    let sampling_filter = match self["sampling_filter"].as_str() {
+                        Some("GOOD") => 0,
+                        Some("LINEAR") => 1,
+                        Some("POINT") => 2,
+                        _ => 0,
+                    };
+                    let m: Vec<f32> = self["matrix"].as_vec_f32().unwrap();
+                    let mut matrix: [f32; 6] = [0.0; 6];
+                    matrix.clone_from_slice(&m);
+                    Some(FilterOp::SVGFEImage{node, sampling_filter, matrix})
+                },
+                "morphologydilate" => {
+                    let radius_x = self["radius_x"].as_f32().unwrap();
+                    let radius_y = self["radius_y"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEMorphologyDilate{node, radius_x, radius_y})
+                },
+                "morphologyerode" => {
+                    let radius_x = self["radius_x"].as_f32().unwrap();
+                    let radius_y = self["radius_y"].as_f32().unwrap();
+                    Some(FilterOp::SVGFEMorphologyErode{node, radius_x, radius_y})
+                },
+                "offset" => {
+                    let offset = self["offset"].as_vec_f32().unwrap();
+                    Some(FilterOp::SVGFEOffset{node, offset_x: offset[0], offset_y: offset[1]})
+                },
+                "SourceAlpha" => Some(FilterOp::SVGFESourceAlpha{node}),
+                "SourceGraphic" => Some(FilterOp::SVGFESourceGraphic{node}),
+                "sourcealpha" => Some(FilterOp::SVGFESourceAlpha{node}),
+                "sourcegraphic" => Some(FilterOp::SVGFESourceGraphic{node}),
+                "specularlightingdistant" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let specular_constant = self["specular_constant"].as_f32().unwrap();
+                    let specular_exponent = self["specular_exponent"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let azimuth = self["azimuth"].as_f32().unwrap();
+                    let elevation = self["elevation"].as_f32().unwrap();
+                    Some(FilterOp::SVGFESpecularLightingDistant{
+                        node, surface_scale, specular_constant,
+                         specular_exponent, kernel_unit_length_x,
+                         kernel_unit_length_y, azimuth, elevation})
+                },
+                "specularlightingpoint" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let specular_constant = self["specular_constant"].as_f32().unwrap();
+                    let specular_exponent = self["specular_exponent"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let x = self["x"].as_f32().unwrap();
+                    let y = self["y"].as_f32().unwrap();
+                    let z = self["z"].as_f32().unwrap();
+                    Some(FilterOp::SVGFESpecularLightingPoint{
+                         node, surface_scale, specular_constant,
+                         specular_exponent, kernel_unit_length_x,
+                         kernel_unit_length_y, x, y, z})
+                },
+                "specularlightingspot" => {
+                    let surface_scale = self["surface_scale"].as_f32().unwrap();
+                    let specular_constant = self["specular_constant"].as_f32().unwrap();
+                    let specular_exponent = self["specular_exponent"].as_f32().unwrap();
+                    let kernel_unit_length_x = self["kernel_unit_length_x"].as_f32().unwrap();
+                    let kernel_unit_length_y = self["kernel_unit_length_y"].as_f32().unwrap();
+                    let x = self["x"].as_f32().unwrap();
+                    let y = self["y"].as_f32().unwrap();
+                    let z = self["z"].as_f32().unwrap();
+                    let points_at_x = self["points_at_x"].as_f32().unwrap();
+                    let points_at_y = self["points_at_y"].as_f32().unwrap();
+                    let points_at_z = self["points_at_z"].as_f32().unwrap();
+                    let cone_exponent = self["cone_exponent"].as_f32().unwrap();
+                    let limiting_cone_angle = self["limiting_cone_angle"].as_f32().unwrap();
+                    Some(FilterOp::SVGFESpecularLightingSpot{
+                         node, surface_scale, specular_constant,
+                         specular_exponent, kernel_unit_length_x,
+                         kernel_unit_length_y, x, y, z, points_at_x,
+                         points_at_y, points_at_z, limiting_cone_angle,
+                         cone_exponent})
+                },
+                "tile" => Some(FilterOp::SVGFETile{node}),
+                "turbulencewithfractalnoisewithnostitching" => {
+                    let base_frequency_x = self["base_frequency_x"].as_f32().unwrap();
+                    let base_frequency_y = self["base_frequency_y"].as_f32().unwrap();
+                    let num_octaves = self["num_octaves"].as_i64().unwrap() as u32;
+                    let seed = self["seed"].as_i64().unwrap() as u32;
+                    Some(FilterOp::SVGFETurbulenceWithFractalNoiseWithNoStitching{
+                        node, base_frequency_x, base_frequency_y, num_octaves, seed})
+                },
+                "turbulencewithfractalnoisewithstitching" => {
+                    let base_frequency_x = self["base_frequency_x"].as_f32().unwrap();
+                    let base_frequency_y = self["base_frequency_y"].as_f32().unwrap();
+                    let num_octaves = self["num_octaves"].as_i64().unwrap() as u32;
+                    let seed = self["seed"].as_i64().unwrap() as u32;
+                    Some(FilterOp::SVGFETurbulenceWithFractalNoiseWithStitching{
+                        node, base_frequency_x, base_frequency_y, num_octaves, seed})
+                },
+                "turbulencewithturbulencenoisewithnostitching" => {
+                    let base_frequency_x = self["base_frequency_x"].as_f32().unwrap();
+                    let base_frequency_y = self["base_frequency_y"].as_f32().unwrap();
+                    let num_octaves = self["num_octaves"].as_i64().unwrap() as u32;
+                    let seed = self["seed"].as_i64().unwrap() as u32;
+                    Some(FilterOp::SVGFETurbulenceWithTurbulenceNoiseWithNoStitching{
+                        node, base_frequency_x, base_frequency_y, num_octaves, seed})
+                },
+                "turbulencewithturbulencenoisewithstitching" => {
+                    let base_frequency_x = self["base_frequency_x"].as_f32().unwrap();
+                    let base_frequency_y = self["base_frequency_y"].as_f32().unwrap();
+                    let num_octaves = self["num_octaves"].as_i64().unwrap() as u32;
+                    let seed = self["seed"].as_i64().unwrap() as u32;
+                    Some(FilterOp::SVGFETurbulenceWithTurbulenceNoiseWithStitching{
+                        node, base_frequency_x, base_frequency_y, num_octaves, seed})
+                },
+                _ => None,
+            }
+        }
         if let Some(s) = self.as_str() {
             match parse_function(s) {
                 ("identity", _, _) => {
