# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/wr/webrender/src/scene_building.rs
# Commit: beec388d4b0e
# Full Hash: beec388d4b0e6a50ac243ed86c0e3f1f48cbe744
# Author: Ashley Hale <ahale@mozilla.com>
# Date: 2024-06-25 09:36:02
# Regressor Bug: 1896503
# File Overlap Count: 1
# Description:
#   Bug 1896503 - Implement FilterInstance code to send SVG filter graph to WebRender r=mstange,gw
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D174208
# ==============================================================================

diff -r 2147e0051e23 -r beec388d4b0e gfx/wr/webrender/src/scene_building.rs
--- a/gfx/wr/webrender/src/scene_building.rs	Mon Jun 24 23:40:38 2024 +0000
+++ b/gfx/wr/webrender/src/scene_building.rs	Mon Jun 24 23:45:05 2024 +0000
@@ -3795,6 +3795,9 @@
         // For each filter, create a new image with that composite mode.
         let mut current_filter_data_index = 0;
         // Check if the filter chain is actually an SVGFE filter graph DAG
+        //
+        // TODO: We technically could translate all CSS filters to SVGFE here if
+        // we want to reduce redundant code.
         if let Some(Filter::SVGGraphNode(..)) = filter_ops.first() {
             // The interesting parts of the handling of SVG filters are:
             // * scene_building.rs : wrap_prim_with_filters (you are here)
@@ -3808,9 +3811,6 @@
             // Easily tunable for debugging proper handling of inflated rects,
             // this should normally be 1
             const SVGFE_INFLATE: i16 = 1;
-            // Easily tunable for debugging proper handling of inflated rects,
-            // this should normally be 0
-            const SVGFE_INFLATE_OUTPUT: i16 = 0;
 
             // Validate inputs to all filters.
             //
@@ -3846,14 +3846,14 @@
             let mut filters: Vec<(FilterGraphNode, FilterGraphOp)> = Vec::new();
             filters.reserve(BUFFER_LIMIT);
             for (original_id, parsefilter) in filter_ops.iter().enumerate() {
-                match parsefilter {
+                if filters.len() >= BUFFER_LIMIT {
+                    // If the DAG is too large to process, the spec requires
+                    // that we drop all filters and display source image as-is.
+                    return source;
+                }
+
+                let newfilter = match parsefilter {
                     Filter::SVGGraphNode(parsenode, op) => {
-                        if filters.len() >= BUFFER_LIMIT {
-                            // If the DAG is too large we drop it entirely, the spec
-                            // allows this.
-                            return source;
-                        }
-
                         // We need to offset the subregion by the stacking context
                         // offset or we'd be in the wrong coordinate system, prims
                         // are already offset by this same amount.
@@ -3923,7 +3923,7 @@
                             FilterGraphOp::SVGFETurbulenceWithTurbulenceNoiseWithNoStitching{..} |
                             FilterGraphOp::SVGFETurbulenceWithTurbulenceNoiseWithStitching{..} => {
                                 assert!(remapped_inputs.len() == 0);
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             }
                             FilterGraphOp::SVGFEColorMatrix{..} |
                             FilterGraphOp::SVGFEIdentity |
@@ -3932,7 +3932,7 @@
                             FilterGraphOp::SVGFEToAlpha => {
                                 assert!(remapped_inputs.len() == 1);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             }
                             FilterGraphOp::SVGFEComponentTransfer => {
                                 assert!(remapped_inputs.len() == 1);
@@ -3977,7 +3977,7 @@
                                     .intern(&filter_data_key, || ());
 
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), FilterGraphOp::SVGFEComponentTransferInterned{handle, creates_pixels}));
+                                (newnode.clone(), FilterGraphOp::SVGFEComponentTransferInterned{handle, creates_pixels})
                             }
                             FilterGraphOp::SVGFEComponentTransferInterned{..} => unreachable!(),
                             FilterGraphOp::SVGFETile => {
@@ -3988,7 +3988,7 @@
                                 remapped_inputs[0].target_padding =
                                     LayoutRect::max_rect();
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             }
                             FilterGraphOp::SVGFEConvolveMatrixEdgeModeDuplicate{kernel_unit_length_x, kernel_unit_length_y, ..} |
                             FilterGraphOp::SVGFEConvolveMatrixEdgeModeNone{kernel_unit_length_x, kernel_unit_length_y, ..} |
@@ -4010,7 +4010,7 @@
                                     remapped_inputs[0].target_padding
                                     .inflate(padding.width, padding.height);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             },
                             FilterGraphOp::SVGFEDiffuseLightingDistant{kernel_unit_length_x, kernel_unit_length_y, ..} |
                             FilterGraphOp::SVGFEDiffuseLightingPoint{kernel_unit_length_x, kernel_unit_length_y, ..} |
@@ -4035,7 +4035,7 @@
                                     remapped_inputs[0].target_padding
                                     .inflate(padding.width, padding.height);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             },
                             FilterGraphOp::SVGFEDisplacementMap { scale, .. } => {
                                 assert!(remapped_inputs.len() == 2);
@@ -4060,7 +4060,7 @@
                                     remapped_inputs[1].target_padding
                                     .inflate(padding.width, padding.height);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             },
                             FilterGraphOp::SVGFEDropShadow{ dx, dy, std_deviation_x, std_deviation_y, .. } => {
                                 assert!(remapped_inputs.len() == 1);
@@ -4090,7 +4090,7 @@
                                             )
                                     );
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             },
                             FilterGraphOp::SVGFEGaussianBlur{std_deviation_x, std_deviation_y} => {
                                 assert!(remapped_inputs.len() == 1);
@@ -4107,7 +4107,7 @@
                                     remapped_inputs[0].target_padding
                                     .inflate(padding.width, padding.height);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode.clone(), op.clone())
                             }
                             FilterGraphOp::SVGFEBlendColor |
                             FilterGraphOp::SVGFEBlendColorBurn |
@@ -4134,62 +4134,59 @@
                             FilterGraphOp::SVGFECompositeXOR => {
                                 assert!(remapped_inputs.len() == 2);
                                 newnode.inputs = remapped_inputs;
-                                filters.push((newnode.clone(), op.clone()));
+                                (newnode, op.clone())
                             }
                         }
-
-                        // Set the reference remapping for the last (or only) node
-                        // that we just pushed
-                        let id = (filters.len() - 1) as i16;
-                        if let Some(pic) = reference_for_buffer_id.get_mut(original_id as usize) {
-                            *pic = FilterGraphPictureReference {
-                                buffer_id: FilterOpGraphPictureBufferId::BufferId(id),
-                                subregion: newnode.subregion,
-                                offset: LayoutVector2D::zero(),
-                                inflate: newnode.inflate,
-                                source_padding: LayoutRect::zero(),
-                                target_padding: LayoutRect::zero(),
-                            };
-                        }
+                    }
+                    Filter::Opacity(valuebinding, value) => {
+                        // Opacity filter is sometimes appended by
+                        // wr_dp_push_stacking_context before we get here,
+                        // convert to SVGFEOpacity in the graph.  Note that
+                        // linear is set to false because it has no meaning for
+                        // opacity (which scales all of the RGBA uniformly).
+                        let pic = reference_for_buffer_id[original_id as usize - 1];
+                        (
+                            FilterGraphNode {
+                                kept_by_optimizer: false,
+                                linear: false,
+                                inflate: SVGFE_INFLATE,
+                                inputs: [pic].to_vec(),
+                                subregion: pic.subregion,
+                            },
+                            FilterGraphOp::SVGFEOpacity{
+                                valuebinding: *valuebinding,
+                                value: *value,
+                            },
+                        )
                     }
                     _ => {
-                        panic!("wrap_prim_with_filters: Mixed SVG and CSS filters?")
+                        log!(Level::Warn, "wrap_prim_with_filters: unexpected filter after SVG filters filter[{:?}]={:?}", original_id, parsefilter);
+                        // If we can't figure out how to process the graph, spec
+                        // requires that we drop all filters and display source
+                        // image as-is.
+                        return source;
                     }
-                }
+                };
+                let id = filters.len();
+                filters.push(newfilter);
+
+                // Set the reference remapping for the last (or only) node
+                // that we just pushed
+                reference_for_buffer_id[original_id] = FilterGraphPictureReference {
+                    buffer_id: FilterOpGraphPictureBufferId::BufferId(id as i16),
+                    subregion: filters[id].0.subregion,
+                    offset: LayoutVector2D::zero(),
+                    inflate: filters[id].0.inflate,
+                    source_padding: LayoutRect::zero(),
+                    target_padding: LayoutRect::zero(),
+                };
             }
 
-            // Push a special output node at the end, this will correctly handle
-            // the final subregion, which may not have the same bounds as the
-            // surface it is being blitted into, so it needs to properly handle
-            // the cropping and UvRectKind, it also has no inflate.
             if filters.len() >= BUFFER_LIMIT {
-                // If the DAG is too large we drop it entirely
+                // If the DAG is too large to process, the spec requires
+                // that we drop all filters and display source image as-is.
                 return source;
             }
-            let mut outputnode = FilterGraphNode {
-                kept_by_optimizer: true,
-                linear: false,
-                inflate: SVGFE_INFLATE_OUTPUT,
-                inputs: Vec::new(),
-                subregion: LayoutRect::max_rect(),
-            };
-            outputnode.inputs.push(reference_for_buffer_id[filter_ops.len() - 1]);
-            filters.push((
-                outputnode,
-                FilterGraphOp::SVGFEIdentity,
-            ));
-
-            // We want to optimize the filter DAG and then wrap it in a single
-            // picture, we will use a custom RenderTask method to process the
-            // DAG later, there's not really an easy way to keep it as a series
-            // of pictures like CSS filters use.
-            //
-            // The main optimization we can do here is looking for feOffset
-            // filters we can merge away - because all of the node inputs
-            // support offset capability implicitly.  We can also remove no-op
-            // filters (identity) if Gecko produced any.
-            //
-            // TODO: optimize the graph here
 
             // Mark used graph nodes, starting at the last graph node, since
             // this is a DAG in sorted order we can just iterate backwards and
@@ -4223,8 +4220,8 @@
                 }
             }
 
-            // Validate the DAG nature of the graph again - if we find anything
-            // wrong here it means the above code is bugged.
+            // Validate the DAG nature of the graph - if we find anything wrong
+            // here it means the above code is bugged.
             let mut invalid_dag = false;
             for (id, (node, _op)) in filters.iter().enumerate() {
                 for input in &node.inputs {