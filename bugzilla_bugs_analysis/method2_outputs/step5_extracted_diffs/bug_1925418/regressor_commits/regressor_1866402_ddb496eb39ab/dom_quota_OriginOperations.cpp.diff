# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/OriginOperations.cpp
# Commit: ddb496eb39ab
# Full Hash: ddb496eb39ab8e4a48b7e6924a3a908f30620864
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2024-10-09 21:46:09
# Regressor Bug: 1866402
# File Overlap Count: 1
# Description:
#   Bug 1866402 - Add a dedicated method for resetting storages of a specific client; r=dom-storage-reviewers,jari
#   
#   Client storages can be currently reset by using the optional argument of
#   nsIQuotaManagerService::ResetStoragesForPrincipal. However, supporting
#   resetting storages for both a principal and a client is not ideal for several
# ==============================================================================

diff -r 67a39d84be12 -r ddb496eb39ab dom/quota/OriginOperations.cpp
--- a/dom/quota/OriginOperations.cpp	Wed Oct 09 11:59:34 2024 +0000
+++ b/dom/quota/OriginOperations.cpp	Wed Oct 09 11:59:34 2024 +0000
@@ -717,6 +717,33 @@
   void CloseDirectory() override;
 };
 
+class ShutdownClientOp final : public ResolvableNormalOriginOp<bool> {
+  const PrincipalInfo mPrincipalInfo;
+  PrincipalMetadata mPrincipalMetadata;
+  RefPtr<UniversalDirectoryLock> mDirectoryLock;
+  const PersistenceScope mPersistenceScope;
+  const Client::Type mClientType;
+
+ public:
+  ShutdownClientOp(MovingNotNull<RefPtr<QuotaManager>> aQuotaManager,
+                   mozilla::Maybe<PersistenceType> aPersistenceType,
+                   const PrincipalInfo& aPrincipalInfo,
+                   const Client::Type aClientType);
+
+ private:
+  ~ShutdownClientOp() = default;
+
+  nsresult DoInit(QuotaManager& aQuotaManager) override;
+
+  RefPtr<BoolPromise> OpenDirectory() override;
+
+  nsresult DoDirectoryWork(QuotaManager& aQuotaManager) override;
+
+  bool GetResolveValue() override;
+
+  void CloseDirectory() override;
+};
+
 class PersistRequestBase : public OpenStorageDirectoryHelper<QuotaRequestBase> {
   const PrincipalInfo mPrincipalInfo;
 
@@ -967,6 +994,14 @@
       std::move(aQuotaManager), aPersistenceType, aPrincipalInfo, aClientType);
 }
 
+RefPtr<ResolvableNormalOriginOp<bool>> CreateShutdownClientOp(
+    MovingNotNull<RefPtr<QuotaManager>> aQuotaManager,
+    Maybe<PersistenceType> aPersistenceType,
+    const PrincipalInfo& aPrincipalInfo, Client::Type aClientType) {
+  return MakeRefPtr<ShutdownClientOp>(
+      std::move(aQuotaManager), aPersistenceType, aPrincipalInfo, aClientType);
+}
+
 RefPtr<QuotaRequestBase> CreatePersistedOp(
     MovingNotNull<RefPtr<QuotaManager>> aQuotaManager,
     const RequestParams& aParams) {
@@ -2696,6 +2731,66 @@
   DropDirectoryLockIfNotDropped(mDirectoryLock);
 }
 
+ShutdownClientOp::ShutdownClientOp(
+    MovingNotNull<RefPtr<QuotaManager>> aQuotaManager,
+    mozilla::Maybe<PersistenceType> aPersistenceType,
+    const PrincipalInfo& aPrincipalInfo, Client::Type aClientType)
+    : ResolvableNormalOriginOp(std::move(aQuotaManager),
+                               "dom::quota::ShutdownClientOp"),
+      mPrincipalInfo(aPrincipalInfo),
+      mPersistenceScope(aPersistenceType ? PersistenceScope::CreateFromValue(
+                                               *aPersistenceType)
+                                         : PersistenceScope::CreateFromNull()),
+      mClientType(aClientType) {
+  AssertIsOnOwningThread();
+}
+
+nsresult ShutdownClientOp::DoInit(QuotaManager& aQuotaManager) {
+  AssertIsOnOwningThread();
+
+  QM_TRY_UNWRAP(
+      mPrincipalMetadata,
+      aQuotaManager.GetInfoFromValidatedPrincipalInfo(mPrincipalInfo));
+
+  mPrincipalMetadata.AssertInvariants();
+
+  return NS_OK;
+}
+
+RefPtr<BoolPromise> ShutdownClientOp::OpenDirectory() {
+  AssertIsOnOwningThread();
+
+  mDirectoryLock = mQuotaManager->CreateDirectoryLockInternal(
+      mPersistenceScope, OriginScope::FromOrigin(mPrincipalMetadata.mOrigin),
+      Nullable(mClientType), /* aExclusive */ true);
+
+  return mDirectoryLock->Acquire();
+}
+
+nsresult ShutdownClientOp::DoDirectoryWork(QuotaManager& aQuotaManager) {
+  AssertIsOnIOThread();
+
+  AUTO_PROFILER_LABEL("ShutdownClientOp::DoDirectoryWork", OTHER);
+
+  // All the work is handled by NormalOriginOperationBase parent class. In
+  // this particular case, we just needed to acquire an exclusive directory
+  // lock and that's it.
+
+  return NS_OK;
+}
+
+bool ShutdownClientOp::GetResolveValue() {
+  AssertIsOnOwningThread();
+
+  return true;
+}
+
+void ShutdownClientOp::CloseDirectory() {
+  AssertIsOnOwningThread();
+
+  DropDirectoryLockIfNotDropped(mDirectoryLock);
+}
+
 PersistRequestBase::PersistRequestBase(
     MovingNotNull<RefPtr<QuotaManager>> aQuotaManager,
     const PrincipalInfo& aPrincipalInfo)