# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/jit-test/tests/cacheir/date-basic.js
# Commit: 12d75626c542
# Full Hash: 12d75626c542273a7821537deb1a9fa7e3863aa1
# Author: Andr√© Bargull <andre.bargull@gmail.com>
# Date: 2024-10-17 20:50:15
# Regressor Bug: 1925195
# File Overlap Count: 1
# Description:
#   Bug 1925195 - Part 3: Inline Date.prototype.get{FullYear,Month,Date,Day}. r=jandem
#   
#   These functions return the cached local date-time values, so we just need
#   the `DateFillLocalTimeSlots` CacheIR op from part 2, followed by reading the
#   corresponding slot.
# ==============================================================================

diff -r 64ed1e7ffcbc -r 12d75626c542 js/src/jit-test/tests/cacheir/date-basic.js
--- a/js/src/jit-test/tests/cacheir/date-basic.js	Thu Oct 17 12:37:01 2024 +0000
+++ b/js/src/jit-test/tests/cacheir/date-basic.js	Thu Oct 17 12:37:01 2024 +0000
@@ -14,3 +14,100 @@
   }
 }
 testDateGetTime();
+
+var dateValues = [
+  // Start of the epoch and start of the year date.
+  [1970, 1-1, 1, 4],
+
+  // End of year date.
+  [2023, 12-1, 31, 0],
+
+  // Date near maximum allowed time value (275760 September, 13).
+  [275760, 9-1, 13 - 1, 5],
+
+  // Date near minimum allowed time value (-271821 April, 20).
+  [-271821, 4-1, 20 + 1, 3],
+
+  // Invalid Date.
+  [NaN, NaN, NaN, NaN],
+];
+
+function testDateGetFullYear() {
+  for (var i = 0; i < 250; ++i) {
+    var [year, month, date] = dateValues[i % dateValues.length];
+
+    // Create a new Date object with an uninitialized local time cache.
+    var d = new Date(year, month, date);
+
+    // First call to getFullYear initializes the cache.
+    assertEq(d.getFullYear(), year);
+
+    // Second call to getFullYear uses the cached value.
+    assertEq(d.getFullYear(), year);
+  }
+}
+testDateGetFullYear();
+
+function testDateGetMonth() {
+  for (var i = 0; i < 250; ++i) {
+    var [year, month, date] = dateValues[i % dateValues.length];
+
+    // Create a new Date object with an uninitialized local time cache.
+    var d = new Date(year, month, date);
+
+    // First call to getMonth initializes the cache.
+    assertEq(d.getMonth(), month);
+
+    // Second call to getMonth uses the cached value.
+    assertEq(d.getMonth(), month);
+  }
+}
+testDateGetMonth();
+
+function testDateGetDate() {
+  for (var i = 0; i < 250; ++i) {
+    var [year, month, date] = dateValues[i % dateValues.length];
+
+    // Create a new Date object with an uninitialized local time cache.
+    var d = new Date(year, month, date);
+
+    // First call to getDate initializes the cache.
+    assertEq(d.getDate(), date);
+
+    // Second call to getDate uses the cached value.
+    assertEq(d.getDate(), date);
+  }
+}
+testDateGetDate();
+
+function testDateGetDay() {
+  for (var i = 0; i < 250; ++i) {
+    var [year, month, date, day] = dateValues[i % dateValues.length];
+
+    // Create a new Date object with an uninitialized local time cache.
+    var d = new Date(year, month, date);
+
+    // First call to getDay initializes the cache.
+    assertEq(d.getDay(), day);
+
+    // Second call to getDay uses the cached value.
+    assertEq(d.getDay(), day);
+  }
+}
+testDateGetDay();
+
+function testDateGetFullYearMonthDateDay() {
+  for (var i = 0; i < 250; ++i) {
+    var [year, month, date, day] = dateValues[i % dateValues.length];
+
+    // Create a new Date object with an uninitialized local time cache.
+    var d = new Date(year, month, date);
+
+    // Test calling different methods, too.
+    assertEq(d.getFullYear(), year);
+    assertEq(d.getMonth(), month);
+    assertEq(d.getDate(), date);
+    assertEq(d.getDay(), day);
+  }
+}
+testDateGetFullYearMonthDateDay();