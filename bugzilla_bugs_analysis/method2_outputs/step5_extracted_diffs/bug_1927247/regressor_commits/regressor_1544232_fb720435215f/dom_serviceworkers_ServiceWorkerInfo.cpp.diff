# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerInfo.cpp
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp	Thu Oct 24 03:02:42 2024 +0000
@@ -6,11 +6,13 @@
 
 #include "ServiceWorkerInfo.h"
 
+#include "ServiceWorkerManager.h"
 #include "ServiceWorkerUtils.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerScriptCache.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientState.h"
+#include "mozilla/dom/Promise.h"
 #include "mozilla/dom/RemoteWorkerTypes.h"
 #include "mozilla/dom/WorkerPrivate.h"
 
@@ -71,6 +73,14 @@
 }
 
 NS_IMETHODIMP
+ServiceWorkerInfo::GetLaunchCount(uint32_t* aLaunchCount) {
+  MOZ_ASSERT(aLaunchCount);
+  MOZ_ASSERT(NS_IsMainThread());
+  *aLaunchCount = mServiceWorkerPrivate->GetLaunchCount();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 ServiceWorkerInfo::GetState(uint16_t* aState) {
   MOZ_ASSERT(aState);
   MOZ_ASSERT(NS_IsMainThread());
@@ -125,6 +135,20 @@
 }
 
 NS_IMETHODIMP
+ServiceWorkerInfo::GetLifetimeDeadline(double* aLifetimeDeadline) {
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(aLifetimeDeadline);
+  TimeStamp deadline = mServiceWorkerPrivate->GetLifetimeDeadline();
+  if (deadline.IsNull()) {
+    *aLifetimeDeadline = 0;
+    return NS_OK;
+  }
+  *aLifetimeDeadline =
+      (deadline - TimeStamp::ProcessCreation()).ToMilliseconds();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 ServiceWorkerInfo::GetNavigationFaultCount(uint32_t* aNavigationFaultCount) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aNavigationFaultCount);
@@ -159,6 +183,24 @@
   return mServiceWorkerPrivate->DetachDebugger();
 }
 
+NS_IMETHODIMP
+ServiceWorkerInfo::TerminateWorker(JSContext* aCx,
+                                   mozilla::dom::Promise** aPromise) {
+  nsIGlobalObject* global = xpc::CurrentNativeGlobal(aCx);
+  if (NS_WARN_IF(!global)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  ErrorResult rv;
+  RefPtr<Promise> outer = Promise::Create(global, rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    return rv.StealNSResult();
+  }
+
+  mServiceWorkerPrivate->TerminateWorker(Some(outer));
+  return NS_OK;
+}
+
 void ServiceWorkerInfo::UpdateState(ServiceWorkerState aState) {
   MOZ_ASSERT(NS_IsMainThread());
 #ifdef DEBUG
@@ -241,7 +283,37 @@
 
 void ServiceWorkerInfo::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                     const PostMessageSource& aSource) {
-  mServiceWorkerPrivate->SendMessageEvent(std::move(aData), aSource);
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (NS_WARN_IF(!swm)) {
+    return;
+  }
+
+  ServiceWorkerLifetimeExtension lifetime =
+      ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
+
+  switch (aSource.type()) {
+    case PostMessageSource::TClientInfoAndState:
+      lifetime = swm->DetermineLifetimeForClient(
+          ClientInfo(aSource.get_ClientInfoAndState().info()));
+      break;
+    case PostMessageSource::TIPCServiceWorkerDescriptor:
+      lifetime = swm->DetermineLifetimeForServiceWorker(
+          ServiceWorkerDescriptor(aSource.get_IPCServiceWorkerDescriptor()));
+      break;
+    default:
+      MOZ_ASSERT_UNREACHABLE("Unexpected source type");
+      return;
+  }
+
+  mServiceWorkerPrivate->SendMessageEvent(std::move(aData), lifetime, aSource);
+}
+
+Maybe<ClientInfo> ServiceWorkerInfo::GetClientInfo() {
+  return mServiceWorkerPrivate->GetClientInfo();
+}
+
+TimeStamp ServiceWorkerInfo::LifetimeDeadline() {
+  return mServiceWorkerPrivate->GetLifetimeDeadline();
 }
 
 void ServiceWorkerInfo::UpdateInstalledTime() {