# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerManager.cpp
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp	Thu Oct 24 03:02:42 2024 +0000
@@ -872,9 +872,11 @@
   RefPtr<ServiceWorkerResolveWindowPromiseOnRegisterCallback> cb =
       new ServiceWorkerResolveWindowPromiseOnRegisterCallback();
 
+  auto lifetime = DetermineLifetimeForClient(aClientInfo);
+
   RefPtr<ServiceWorkerRegisterJob> job = new ServiceWorkerRegisterJob(
       principal, aScopeURL, aScriptURL,
-      static_cast<ServiceWorkerUpdateViaCache>(aUpdateViaCache));
+      static_cast<ServiceWorkerUpdateViaCache>(aUpdateViaCache), lifetime);
 
   job->AppendResultCallback(cb);
   queue->ScheduleJob(job);
@@ -1282,6 +1284,63 @@
   return registration->GetActive();
 }
 
+ServiceWorkerInfo* ServiceWorkerManager::GetServiceWorkerByClientInfo(
+    const ClientInfo& aClientInfo) const {
+  MOZ_ASSERT(NS_IsMainThread());
+
+  auto principalOrErr = aClientInfo.GetPrincipal();
+  if (NS_WARN_IF(principalOrErr.isErr())) {
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
+  nsAutoCString scopeKey;
+  nsresult rv = PrincipalToScopeKey(principal, scopeKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  RegistrationDataPerPrincipal* data;
+  if (!mRegistrationInfos.Get(scopeKey, &data)) {
+    return nullptr;
+  }
+
+  // If the ClientInfo has CSP data populated, we need to normalize that off, so
+  // make a copy and only propagate the non-CSP fields.
+  ClientInfo normalized = ClientInfo(
+      aClientInfo.Id(), aClientInfo.AgentClusterId(), aClientInfo.Type(),
+      aClientInfo.PrincipalInfo(), aClientInfo.CreationTime(),
+      aClientInfo.URL(), aClientInfo.FrameType());
+
+  for (const auto& registration : data->mInfos.Values()) {
+    ServiceWorkerInfo* info = registration->GetByClientInfo(normalized);
+    if (info) {
+      return info;
+    }
+  }
+
+  return nullptr;
+}
+
+ServiceWorkerInfo* ServiceWorkerManager::GetServiceWorkerByDescriptor(
+    const ServiceWorkerDescriptor& aServiceWorker) const {
+  auto principalOrErr = aServiceWorker.GetPrincipal();
+  if (NS_WARN_IF(principalOrErr.isErr())) {
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = principalOrErr.unwrap();
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+      GetRegistration(principal, aServiceWorker.Scope());
+  if (NS_WARN_IF(!registration)) {
+    return nullptr;
+  }
+
+  return registration->GetByDescriptor(aServiceWorker);
+}
+
 namespace {
 
 class UnregisterJobCallback final : public ServiceWorkerJob::Callback {
@@ -1380,11 +1439,20 @@
     return;
   }
 
+  // We only care about the active worker becoming idle because it means we
+  // can now promote a waiting worker to active.
   if (reg->GetActive() != aWorker) {
     return;
   }
 
-  reg->TryToActivateAsync();
+  // The active worker becoming idle is not a reason to extend a waiting SW's
+  // lifetime (or spawn it) on its own because that potentially enables
+  // unlimited lifetime extension.  `TryToActivate` will handle upgrading the
+  // lifetime extension to a full extension if the registration is controlling
+  // pages (and skipWaiting was used).  It's fine for the ServiceWorker to
+  // receive its activation message prior to its next functional event.
+  reg->TryToActivateAsync(
+      ServiceWorkerLifetimeExtension(NoLifetimeExtension{}));
 }
 
 already_AddRefed<ServiceWorkerJobQueue>
@@ -1919,11 +1987,12 @@
     return;
   }
 
-  // We use to aggressively terminate the worker at this point, but it
+  // We used to aggressively terminate the worker at this point, but it
   // caused problems.  There are more uses for a service worker than actively
   // controlled documents.  We need to let the worker naturally terminate
-  // in case its handling push events, message events, etc.
-  aRegistration->TryToActivateAsync();
+  // in case it's handling push events, message events, etc.
+  aRegistration->TryToActivateAsync(
+      ServiceWorkerLifetimeExtension(NoLifetimeExtension{}));
 }
 
 NS_IMETHODIMP
@@ -2218,6 +2287,43 @@
   }
 }
 
+ServiceWorkerLifetimeExtension ServiceWorkerManager::DetermineLifetimeForClient(
+    const ClientInfo& aClientInfo) {
+  // For everything but ServiceWorkers this should extend the ServiceWorker's
+  // lifetime.
+  if (aClientInfo.Type() == ClientType::Serviceworker) {
+    // But for the ServiceWorker we need to find out the originating
+    // ServiceWorker's lifetime and use that.
+    ServiceWorkerInfo* source = GetServiceWorkerByClientInfo(aClientInfo);
+    if (source) {
+      return ServiceWorkerLifetimeExtension(PropagatedLifetimeExtension{
+          .mDeadline = source->LifetimeDeadline(),
+      });
+    }
+
+    // If we can't find the ServiceWorker, then it's gone and we shouldn't
+    // extend the lifetime.
+    return ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
+  }
+
+  return ServiceWorkerLifetimeExtension(FullLifetimeExtension{});
+}
+
+ServiceWorkerLifetimeExtension
+ServiceWorkerManager::DetermineLifetimeForServiceWorker(
+    const ServiceWorkerDescriptor& aServiceWorker) {
+  ServiceWorkerInfo* source = GetServiceWorkerByDescriptor(aServiceWorker);
+  if (source) {
+    return ServiceWorkerLifetimeExtension(PropagatedLifetimeExtension{
+        .mDeadline = source->LifetimeDeadline(),
+    });
+  }
+
+  // If we can't find the ServiceWorker, then it's gone and we shouldn't
+  // extend the lifetime.
+  return ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
+}
+
 bool ServiceWorkerManager::IsAvailable(nsIPrincipal* aPrincipal, nsIURI* aURI,
                                        nsIChannel* aChannel) {
   MOZ_ASSERT(aPrincipal);
@@ -2469,9 +2575,19 @@
   // See: https://github.com/slightlyoff/ServiceWorker/issues/759
   RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey, aScope);
 
+  // Soft updates always correspond to functional events.  Functional events
+  // are always events that should result in a fresh, full lifetime extension.
+  //
+  // The set of known events at this time is documented at
+  // https://w3c.github.io/ServiceWorker/#execution-context-events at this time.
+  //
+  // Note that Lifecycle events (install, activate) are explicitly not
+  // functional events.
+  auto lifetime = ServiceWorkerLifetimeExtension(FullLifetimeExtension{});
+
   RefPtr<ServiceWorkerUpdateJob> job = new ServiceWorkerUpdateJob(
       principal, registration->Scope(), newest->ScriptSpec(),
-      registration->GetUpdateViaCache());
+      registration->GetUpdateViaCache(), lifetime);
 
   if (aCallback) {
     RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
@@ -2520,12 +2636,14 @@
 
   RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey, aScope);
 
+  auto lifetime = DetermineLifetimeForClient(aClientInfo);
+
   // "Let job be the result of running Create Job with update, registration’s
   // scope url, newestWorker’s script url, promise, and the context object’s
   // relevant settings object."
   RefPtr<ServiceWorkerUpdateJob> job = new ServiceWorkerUpdateJob(
       aPrincipal, registration->Scope(), std::move(aNewestWorkerScriptUrl),
-      registration->GetUpdateViaCache());
+      registration->GetUpdateViaCache(), lifetime);
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);