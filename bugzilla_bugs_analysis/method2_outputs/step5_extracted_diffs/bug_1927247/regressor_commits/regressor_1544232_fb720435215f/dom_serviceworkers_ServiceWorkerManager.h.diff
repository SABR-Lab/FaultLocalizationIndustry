# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerManager.h
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerManager.h	Thu Oct 24 03:02:42 2024 +0000
@@ -19,6 +19,7 @@
 #include "mozilla/UniquePtr.h"
 #include "mozilla/dom/ClientHandle.h"
 #include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/ServiceWorkerLifetimeExtension.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationInfo.h"
 #include "mozilla/dom/ServiceWorkerUtils.h"
@@ -101,6 +102,7 @@
                                    public nsIObserver {
   friend class GetRegistrationsRunnable;
   friend class GetRegistrationRunnable;
+  friend class ServiceWorkerInfo;
   friend class ServiceWorkerJob;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerShutdownBlocker;
@@ -113,6 +115,18 @@
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIOBSERVER
 
+  // Determine the correct lifetime extension to use for a given client.  This
+  // will work for ServiceWorker clients, but ideally you should have a
+  // ServiceWorkerDescriptor in that case.
+  ServiceWorkerLifetimeExtension DetermineLifetimeForClient(
+      const ClientInfo& aClientInfo);
+
+  // Determine the correct lifetime extension to use for a given client.  This
+  // will work for ServiceWorker clients, but ideally you should have a
+  // ServiceWorkerDescriptor in that case.
+  ServiceWorkerLifetimeExtension DetermineLifetimeForServiceWorker(
+      const ServiceWorkerDescriptor& aServiceWorker);
+
   // Return true if the given principal and URI matches a registered service
   // worker which handles fetch event.
   // If there is a matched service worker but doesn't handle fetch events, this
@@ -316,22 +330,43 @@
   ServiceWorkerInfo* GetActiveWorkerInfoForScope(
       const OriginAttributes& aOriginAttributes, const nsACString& aScope);
 
+  // Given the ClientInfo for a ServiceWorker global, return the corresponding
+  // ServiceWorkerInfo, nullptr otherwise.  Do not use this for clients for
+  // globals that are not ServiceWorkers (and ideally you should be using
+  // GetServiceWorkerByDescriptor instead).
+  ServiceWorkerInfo* GetServiceWorkerByClientInfo(
+      const ClientInfo& aClientInfo) const;
+
+  // Given the ServiceWorkerDescriptor for a ServiceWorker, return the
+  // corresponding nullptr otherwise.
+  ServiceWorkerInfo* GetServiceWorkerByDescriptor(
+      const ServiceWorkerDescriptor& aServiceWorker) const;
+
   void StopControllingRegistration(
       ServiceWorkerRegistrationInfo* aRegistration);
 
+  // Find the ServiceWorkerRegistration whose scope best matches the URL of the
+  // given window or worker client (for the origin of the client based on its
+  // principal).  This cannot be used with ServiceWorker ClientInfos.
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(const ClientInfo& aClientInfo) const;
 
+  // Find the ServiceWorkerRegistration whose scope best matches the provided
+  // URL (for the origin of the given principal).
+  //
+  // Note that `GetRegistration` should be used in cases where you already have
+  // an exact scope.
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal,
                                    nsIURI* aURI) const;
 
+  // Find the ServiceWorkerRegistration whose scope best matches the provided
+  // URL for the origin encoded as a scope key that has been obtained from
+  // PrincipToScopeKey.
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(const nsACString& aScopeKey,
                                    nsIURI* aURI) const;
 
-  // This method generates a key using isInElementBrowser from the principal. We
-  // don't use the origin because it can change during the loading.
   static nsresult PrincipalToScopeKey(nsIPrincipal* aPrincipal,
                                       nsACString& aKey);
 