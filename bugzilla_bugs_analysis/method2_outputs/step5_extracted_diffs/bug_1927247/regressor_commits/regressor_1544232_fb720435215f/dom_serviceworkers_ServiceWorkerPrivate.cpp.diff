# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerPrivate.cpp
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/ServiceWorkerPrivate.cpp
--- a/dom/serviceworkers/ServiceWorkerPrivate.cpp	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerPrivate.cpp	Thu Oct 24 03:02:42 2024 +0000
@@ -32,6 +32,7 @@
 #include "mozilla/Telemetry.h"
 #include "mozilla/Unused.h"
 #include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/FetchEventOpChild.h"
 #include "mozilla/dom/InternalHeaders.h"
@@ -41,6 +42,7 @@
 #include "mozilla/dom/RemoteWorkerControllerChild.h"
 #include "mozilla/dom/RemoteWorkerManager.h"  // RemoteWorkerManager::GetRemoteType
 #include "mozilla/dom/ServiceWorkerBinding.h"
+#include "mozilla/dom/ServiceWorkerLifetimeExtension.h"
 #include "mozilla/extensions/WebExtensionPolicy.h"  // WebExtensionPolicy
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/IPCStreamUtils.h"
@@ -463,7 +465,12 @@
  * ServiceWorkerPrivate
  */
 ServiceWorkerPrivate::ServiceWorkerPrivate(ServiceWorkerInfo* aInfo)
-    : mInfo(aInfo), mDebuggerCount(0), mTokenCount(0) {
+    : mInfo(aInfo),
+      mPendingSpawnLifetime(
+          ServiceWorkerLifetimeExtension(NoLifetimeExtension{})),
+      mDebuggerCount(0),
+      mTokenCount(0),
+      mLaunchCount(0) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aInfo);
   MOZ_ASSERT(!mControllerChild);
@@ -687,6 +694,19 @@
   bool isThirdPartyContextToTopWindow =
       !principal->OriginAttributesRef().mPartitionKey.IsEmpty();
 
+  mClientInfo = ClientManager::CreateInfo(
+      ClientType::Serviceworker,
+      // The partitioned principal for ServiceWorkers is currently always
+      // partitioned and so we only use it when in a third party context.
+      isThirdPartyContextToTopWindow ? partitionedPrincipal : principal);
+  if (NS_WARN_IF(!mClientInfo.isSome())) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  mClientInfo->SetAgentClusterId(regInfo->AgentClusterId());
+  mClientInfo->SetURL(mInfo->ScriptSpec());
+  mClientInfo->SetFrameType(FrameType::None);
+
   mRemoteWorkerData = RemoteWorkerData(
       NS_ConvertUTF8toUTF16(mInfo->ScriptSpec()), baseScriptURL, baseScriptURL,
       WorkerOptions(),
@@ -699,7 +719,7 @@
 
       cjsData, domain,
       /* isSecureContext */ true,
-      /* clientInfo*/ Nothing(),
+      /* clientInfo*/ Some(mClientInfo.ref().ToIPC()),
 
       // The RemoteWorkerData CTOR doesn't allow to set the referrerInfo via
       // already_AddRefed<>. Let's set it to null.
@@ -721,6 +741,7 @@
 }
 
 nsresult ServiceWorkerPrivate::CheckScriptEvaluation(
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension,
     RefPtr<LifeCycleEventCallback> aCallback) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aCallback);
@@ -731,7 +752,7 @@
    * We need to capture the actor associated with the current Service Worker so
    * we can terminate it if script evaluation failed.
    */
-  nsresult rv = SpawnWorkerIfNeeded();
+  nsresult rv = SpawnWorkerIfNeeded(aLifetimeExtension);
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aCallback->SetResult(false);
@@ -745,7 +766,7 @@
   RefPtr<RAIIActorPtrHolder> holder = mControllerChild;
 
   return ExecServiceWorkerOp(
-      ServiceWorkerCheckScriptEvaluationOpArgs(),
+      ServiceWorkerCheckScriptEvaluationOpArgs(), aLifetimeExtension,
       [self = std::move(self), holder = std::move(holder),
        callback = aCallback](ServiceWorkerOpResult&& aResult) mutable {
         if (aResult.type() == ServiceWorkerOpResult::
@@ -816,7 +837,9 @@
 }
 
 nsresult ServiceWorkerPrivate::SendMessageEvent(
-    RefPtr<ServiceWorkerCloneData>&& aData, const PostMessageSource& aSource) {
+    RefPtr<ServiceWorkerCloneData>&& aData,
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension,
+    const PostMessageSource& aSource) {
   AssertIsOnMainThread();
   MOZ_ASSERT(aData);
 
@@ -837,18 +860,21 @@
   scopeExit.release();
 
   return ExecServiceWorkerOp(
-      std::move(args), [](ServiceWorkerOpResult&& aResult) {
+      std::move(args), aLifetimeExtension, [](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
       });
 }
 
 nsresult ServiceWorkerPrivate::SendLifeCycleEvent(
-    const nsAString& aEventType, RefPtr<LifeCycleEventCallback> aCallback) {
+    const nsAString& aEventType,
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension,
+    const RefPtr<LifeCycleEventCallback>& aCallback) {
   AssertIsOnMainThread();
   MOZ_ASSERT(aCallback);
 
   return ExecServiceWorkerOp(
       ServiceWorkerLifeCycleEventOpArgs(nsString(aEventType)),
+      aLifetimeExtension,
       [callback = aCallback](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
 
@@ -895,11 +921,10 @@
 nsresult ServiceWorkerPrivate::SendPushEventInternal(
     RefPtr<ServiceWorkerRegistrationInfo>&& aRegistration,
     ServiceWorkerPushEventOpArgs&& aArgs) {
-  AssertIsOnMainThread();
   MOZ_ASSERT(aRegistration);
 
   return ExecServiceWorkerOp(
-      std::move(aArgs),
+      std::move(aArgs), ServiceWorkerLifetimeExtension(FullLifetimeExtension{}),
       [registration = aRegistration](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
 
@@ -915,6 +940,7 @@
 
   return ExecServiceWorkerOp(
       ServiceWorkerPushSubscriptionChangeEventOpArgs(),
+      ServiceWorkerLifetimeExtension(FullLifetimeExtension{}),
       [](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
       });
@@ -950,7 +976,8 @@
   args.disableOpenClickDelay() = gDOMDisableOpenClickDelay;
 
   return ExecServiceWorkerOp(
-      std::move(args), [](ServiceWorkerOpResult&& aResult) {
+      std::move(args), ServiceWorkerLifetimeExtension(FullLifetimeExtension{}),
+      [](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
       });
 }
@@ -1070,7 +1097,8 @@
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  MOZ_TRY(SpawnWorkerIfNeeded());
+  MOZ_TRY(SpawnWorkerIfNeeded(
+      ServiceWorkerLifetimeExtension(FullLifetimeExtension{})));
   MOZ_TRY(MaybeStoreStreamForBackgroundThread(
       aChannel, aArgs.common().internalRequest()));
 
@@ -1108,7 +1136,7 @@
       MakeRefPtr<PromiseExtensionWorkerHasListener::Private>(__func__);
 
   nsresult rv = ExecServiceWorkerOp(
-      std::move(args),
+      std::move(args), ServiceWorkerLifetimeExtension(FullLifetimeExtension{}),
       [promise](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(
             aResult.type() ==
@@ -1126,11 +1154,17 @@
   return outPromise;
 }
 
-nsresult ServiceWorkerPrivate::SpawnWorkerIfNeeded() {
+nsresult ServiceWorkerPrivate::SpawnWorkerIfNeeded(
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension) {
   AssertIsOnMainThread();
 
+  // We don't need to spawn if we already have a spawned, non-terminated worker.
   if (mControllerChild) {
-    RenewKeepAliveToken();
+    // We only need to renew the keepalive token if we actually want to extend
+    // the worker's lifetime; we don't for termination requests.
+    if (aLifetimeExtension.LifetimeExtendsIntoTheFuture()) {
+      RenewKeepAliveToken(aLifetimeExtension);
+    }
     return NS_OK;
   }
 
@@ -1138,6 +1172,11 @@
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  // Don't spawn the ServiceWorker if we don't want to extend its life.
+  if (NS_WARN_IF(!aLifetimeExtension.LifetimeExtendsIntoTheFuture())) {
+    return NS_ERROR_DOM_TIMEOUT_ERR;
+  }
+
   mServiceWorkerLaunchTimeStart = TimeStamp::Now();
 
   PBackgroundChild* bgChild = BackgroundChild::GetForCurrentThread();
@@ -1174,6 +1213,8 @@
 
   RefreshRemoteWorkerData(regInfo);
 
+  mLaunchCount++;
+
   RefPtr<RemoteWorkerControllerChild> controllerChild =
       new RemoteWorkerControllerChild(this);
 
@@ -1182,6 +1223,8 @@
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  mPendingSpawnLifetime = aLifetimeExtension;
+
   mControllerChild = new RAIIActorPtrHolder(controllerChild.forget());
 
   // Update Running count here because we may Terminate before we get
@@ -1192,11 +1235,31 @@
   return NS_OK;
 }
 
-void ServiceWorkerPrivate::TerminateWorker() {
+void ServiceWorkerPrivate::TerminateWorker(
+    Maybe<RefPtr<Promise>> aMaybePromise) {
   MOZ_ASSERT(NS_IsMainThread());
   mIdleWorkerTimer->Cancel();
+  mIdleDeadline = TimeStamp();
+  // We call the shutdown method prior to dropping mIdleKeepAliveToken in order
+  // to ensure that the passed-in promise tracks the shutdown of the current
+  // worker.
+  //
+  // More detail: Dropping the token can cause re-entrance to this method via
+  // ReleaseToken if it is not already the method calling.  Shutdown() is
+  // idempotent except for the promise we pass in; it will only be chained to
+  // track the actual termination if mControllerChild is not null.  On the
+  // second call when mControllerChild is null, it will resolved immediately
+  // with undefined.  The call from ReleaseToken does not pass a Promise and
+  // does not care, so it goes second.
+  //
+  // We of course could hold onto the underlying shutdown promise until it
+  // resolves so that new calls could chain, but because it's conceptually
+  // possible to have multiple spawns and shutdowns in flight and our promise
+  // argument is really only for testing / devtools where we only expect a
+  // single actively involved party at a time, this way works sufficiently.
+  Shutdown(std::move(aMaybePromise));
+  // As per the above, this may potentially
   mIdleKeepAliveToken = nullptr;
-  Shutdown();
 }
 
 void ServiceWorkerPrivate::NoteDeadServiceWorkerInfo() {
@@ -1215,6 +1278,10 @@
 
   nsresult rv = ExecServiceWorkerOp(
       ServiceWorkerUpdateStateOpArgs(aState),
+      // Lifecycle events potentially update the lifetime for ServiceWorkers
+      // controlling a page, but there's no need to update the lifetime to tell
+      // a SW that its state has changed.
+      ServiceWorkerLifetimeExtension(NoLifetimeExtension{}),
       [](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
       });
@@ -1249,7 +1316,8 @@
   // and cancel the idle timeout. The idle timeout should not be reset until
   // the last debugger detached from the worker.
   if (!mDebuggerCount) {
-    nsresult rv = SpawnWorkerIfNeeded();
+    nsresult rv = SpawnWorkerIfNeeded(
+        ServiceWorkerLifetimeExtension(FullLifetimeExtension{}));
     NS_ENSURE_SUCCESS(rv, rv);
 
     /**
@@ -1265,7 +1333,8 @@
      * due to the idle KeepAliveToken being created asynchronously). So, just
      * renew the KeepAliveToken right now.
      */
-    RenewKeepAliveToken();
+    RenewKeepAliveToken(
+        ServiceWorkerLifetimeExtension(FullLifetimeExtension{}));
     mIdleWorkerTimer->Cancel();
   }
 
@@ -1287,7 +1356,7 @@
   // timeout, or terminate the worker if there are no more active tokens.
   if (!mDebuggerCount) {
     if (mTokenCount) {
-      ResetIdleTimeout();
+      ResetIdleTimeout(ServiceWorkerLifetimeExtension(FullLifetimeExtension{}));
     } else {
       TerminateWorker();
     }
@@ -1357,6 +1426,8 @@
 
   // Release ServiceWorkerPrivate's token, since the grace period has ended.
   mIdleKeepAliveToken = nullptr;
+  // Null out our deadline as well.
+  mIdleDeadline = TimeStamp();
 
   if (mControllerChild) {
     // If we still have a living worker at this point it means that either there
@@ -1387,7 +1458,8 @@
   TerminateWorker();
 }
 
-void ServiceWorkerPrivate::RenewKeepAliveToken() {
+void ServiceWorkerPrivate::RenewKeepAliveToken(
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension) {
   // We should have an active worker if we're renewing the keep alive token.
   MOZ_ASSERT(mControllerChild);
 
@@ -1395,7 +1467,7 @@
   // timeout was canceled when the first debugger attached to the worker. It
   // should not be reset until the last debugger detaches from the worker.
   if (!mDebuggerCount) {
-    ResetIdleTimeout();
+    ResetIdleTimeout(aLifetimeExtension);
   }
 
   if (!mIdleKeepAliveToken) {
@@ -1403,12 +1475,55 @@
   }
 }
 
-void ServiceWorkerPrivate::ResetIdleTimeout() {
-  uint32_t timeout = Preferences::GetInt("dom.serviceWorkers.idle_timeout");
+void ServiceWorkerPrivate::ResetIdleTimeout(
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension) {
+  TimeStamp now = TimeStamp::NowLoRes();
+  TimeStamp existing = mIdleDeadline;
+  // Normalize the extension, returning a Null TimeStamp if the lifetime
+  // extension does not actually extend our lifetime.
+  TimeStamp normalizedExtension = aLifetimeExtension.match(
+      // No extension means no extension!
+      [](const NoLifetimeExtension& nle) { return TimeStamp(); },
+      [&existing, &now](const PropagatedLifetimeExtension& ple) {
+        // Ignore null deadlines or deadlines that are in the past.
+        if (ple.mDeadline.IsNull() || ple.mDeadline < now) {
+          return TimeStamp();
+        }
+        // Use this new deadline if our existing deadline is null or the
+        // received deadline is after our current deadline.
+        if (existing.IsNull() || ple.mDeadline > existing) {
+          return ple.mDeadline;
+        }
+        // (This means our existing deadline extends further into the future so
+        // we don't want to change our deadline.)
+        return TimeStamp();
+      },
+      [&now](const FullLifetimeExtension& fle) {
+        return now + TimeDuration::FromMilliseconds(Preferences::GetInt(
+                         "dom.serviceWorkers.idle_timeout"));
+      });
+
+  if (normalizedExtension.IsNull()) {
+    // Convert the unlikely situation where we are trying to reset the timeout
+    // without extension and where we have no existing timeout into a 0 timeout.
+    // This is important because we don't want to let the ServiceWorker live
+    // forever!
+    MOZ_ASSERT(!existing.IsNull());
+    if (NS_WARN_IF(existing.IsNull())) {
+      normalizedExtension = now;
+    } else {
+      // Return without altering the deadline or churning the timer.
+      return;
+    }
+  }
+
+  mIdleDeadline = normalizedExtension;
+
   nsCOMPtr<nsITimerCallback> cb = new ServiceWorkerPrivateTimerCallback(
       this, &ServiceWorkerPrivate::NoteIdleWorkerCallback);
-  DebugOnly<nsresult> rv =
-      mIdleWorkerTimer->InitWithCallback(cb, timeout, nsITimer::TYPE_ONE_SHOT);
+  // We don't need high resolution but TimeDuration provides better type safety.
+  DebugOnly<nsresult> rv = mIdleWorkerTimer->InitHighResolutionWithCallback(
+      cb, mIdleDeadline - now, nsITimer::TYPE_ONE_SHOT);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
@@ -1486,7 +1601,13 @@
   RefPtr<GenericPromise::Private> promise =
       new GenericPromise::Private(__func__);
 
-  regInfo->TryToActivateAsync([promise] { promise->Resolve(true, __func__); });
+  // The ServiceWorker calling skipWaiting on itself is not a basis for lifetime
+  // extension on its own.  `TryToActivate` will upgrade the lifetime to a full
+  // extension iff there are any controlled pages.
+  auto lifetime = ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
+
+  regInfo->TryToActivateAsync(lifetime,
+                              [promise] { promise->Resolve(true, __func__); });
 
   return promise;
 }
@@ -1527,6 +1648,7 @@
                                    mServiceWorkerLaunchTimeStart);
   }
 
+  mPendingSpawnLifetime = ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
   Shutdown();
 }
 
@@ -1534,7 +1656,15 @@
   AssertIsOnMainThread();
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mInfo);
-  MOZ_ASSERT(mControllerChild);
+
+  // It's possible for a request to terminate the worker to happen while the
+  // worker is starting up, in which case we do not want to renew the keepalive
+  // timer and we probably don't want to update the telemetry below either.
+  if (NS_WARN_IF(!mControllerChild)) {
+    mPendingSpawnLifetime =
+        ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
+    return;
+  }
 
   if (mRemoteWorkerData.remoteType().Find(SERVICEWORKER_REMOTE_TYPE) !=
       kNotFound) {
@@ -1546,7 +1676,8 @@
                                    mServiceWorkerLaunchTimeStart);
   }
 
-  RenewKeepAliveToken();
+  RenewKeepAliveToken(mPendingSpawnLifetime);
+  mPendingSpawnLifetime = ServiceWorkerLifetimeExtension(NoLifetimeExtension{});
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   nsCOMPtr<nsIPrincipal> principal = mInfo->Principal();
@@ -1662,7 +1793,7 @@
   return FetchService::NetworkErrorResponse(NS_ERROR_UNEXPECTED);
 }
 
-void ServiceWorkerPrivate::Shutdown() {
+void ServiceWorkerPrivate::Shutdown(Maybe<RefPtr<Promise>>&& aMaybePromise) {
   AssertIsOnMainThread();
 
   if (mControllerChild) {
@@ -1677,6 +1808,18 @@
     RefPtr<GenericNonExclusivePromise> promise =
         ShutdownInternal(shutdownStateId);
     swm->BlockShutdownOn(promise, shutdownStateId);
+    if (aMaybePromise.isSome() && aMaybePromise.ref()) {
+      promise->Then(
+          GetCurrentSerialEventTarget(), __func__,
+          [listener = aMaybePromise.ref()] {
+            listener->MaybeResolveWithUndefined();
+          },
+          [listener = aMaybePromise.ref()] {
+            listener->MaybeResolveWithUndefined();
+          });
+    }
+  } else if (aMaybePromise.isSome() && aMaybePromise.ref()) {
+    aMaybePromise.ref()->MaybeResolveWithUndefined();
   }
 
   MOZ_ASSERT(!mControllerChild);
@@ -1703,6 +1846,11 @@
 
   Unused << ExecServiceWorkerOp(
       ServiceWorkerTerminateWorkerOpArgs(aShutdownStateId),
+      // It doesn't make sense to extend the lifetime in this case.  This will
+      // also ensure that we don't try and spawn the ServiceWorker, but as our
+      // assert at the top of this method makes clear, we don't expect to be in
+      // that situation.
+      ServiceWorkerLifetimeExtension(NoLifetimeExtension{}),
       [promise](ServiceWorkerOpResult&& aResult) {
         MOZ_ASSERT(aResult.type() == ServiceWorkerOpResult::Tnsresult);
         promise->Resolve(true, __func__);
@@ -1723,6 +1871,7 @@
 
 nsresult ServiceWorkerPrivate::ExecServiceWorkerOp(
     ServiceWorkerOpArgs&& aArgs,
+    const ServiceWorkerLifetimeExtension& aLifetimeExtension,
     std::function<void(ServiceWorkerOpResult&&)>&& aSuccessCallback,
     std::function<void()>&& aFailureCallback) {
   AssertIsOnMainThread();
@@ -1733,7 +1882,7 @@
       "actors!");
   MOZ_ASSERT(aSuccessCallback);
 
-  nsresult rv = SpawnWorkerIfNeeded();
+  nsresult rv = SpawnWorkerIfNeeded(aLifetimeExtension);
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aFailureCallback();