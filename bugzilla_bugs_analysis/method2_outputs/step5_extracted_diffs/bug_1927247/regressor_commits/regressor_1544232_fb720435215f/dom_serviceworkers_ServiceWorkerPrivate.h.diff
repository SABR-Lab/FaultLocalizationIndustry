# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerPrivate.h
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/ServiceWorkerPrivate.h
--- a/dom/serviceworkers/ServiceWorkerPrivate.h	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerPrivate.h	Thu Oct 24 03:02:42 2024 +0000
@@ -11,13 +11,16 @@
 #include <type_traits>
 
 #include "mozilla/Attributes.h"
+#include "mozilla/Maybe.h"
 #include "mozilla/MozPromise.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/dom/FetchService.h"
+#include "mozilla/dom/Promise.h"
 #include "mozilla/dom/RemoteWorkerController.h"
 #include "mozilla/dom/RemoteWorkerTypes.h"
+#include "mozilla/dom/ServiceWorkerLifetimeExtension.h"
 #include "mozilla/dom/ServiceWorkerOpArgs.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
@@ -82,15 +85,23 @@
  public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
-  nsresult SendMessageEvent(RefPtr<ServiceWorkerCloneData>&& aData,
-                            const PostMessageSource& aSource);
+  Maybe<ClientInfo> GetClientInfo() { return mClientInfo; }
+
+  nsresult SendMessageEvent(
+      RefPtr<ServiceWorkerCloneData>&& aData,
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension,
+      const PostMessageSource& aSource);
 
   // This is used to validate the worker script and continue the installation
   // process.
-  nsresult CheckScriptEvaluation(RefPtr<LifeCycleEventCallback> aCallback);
+  nsresult CheckScriptEvaluation(
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension,
+      RefPtr<LifeCycleEventCallback> aCallback);
 
-  nsresult SendLifeCycleEvent(const nsAString& aEventType,
-                              RefPtr<LifeCycleEventCallback> aCallback);
+  nsresult SendLifeCycleEvent(
+      const nsAString& aEventType,
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension,
+      const RefPtr<LifeCycleEventCallback>& aCallback);
 
   nsresult SendPushEvent(const nsAString& aMessageId,
                          const Maybe<nsTArray<uint8_t>>& aData,
@@ -119,7 +130,10 @@
   // Called by ServiceWorkerInfo when [[Clear Registration]] is invoked
   // or whenever the spec mandates that we terminate the worker.
   // This is a no-op if the worker has already been stopped.
-  void TerminateWorker();
+  //
+  // Now takes an optional promise that will be resolved when the worker is
+  // dead, including if the worker was not running at all.
+  void TerminateWorker(Maybe<RefPtr<Promise>> aMaybePromise = Nothing());
 
   void NoteDeadServiceWorkerInfo();
 
@@ -133,6 +147,16 @@
 
   nsresult DetachDebugger();
 
+  // Return the current lifetime deadline for this ServiceWorker; this value may
+  // be null or in the past.
+  //
+  // This value always only reflects the explicit lifetime extensions
+  // resulting from functional events and will never reflect the extra "grace
+  // period".
+  TimeStamp GetLifetimeDeadline() { return mIdleDeadline; }
+
+  uint32_t GetLaunchCount() { return mLaunchCount; }
+
   bool IsIdle() const;
 
   // This promise is used schedule clearing of the owning registrations and its
@@ -169,9 +193,11 @@
 
   void TerminateWorkerCallback(nsITimer* aTimer);
 
-  void RenewKeepAliveToken();
+  void RenewKeepAliveToken(
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension);
 
-  void ResetIdleTimeout();
+  void ResetIdleTimeout(
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension);
 
   void AddToken();
 
@@ -179,7 +205,8 @@
 
   already_AddRefed<KeepAliveToken> CreateEventKeepAliveToken();
 
-  nsresult SpawnWorkerIfNeeded();
+  nsresult SpawnWorkerIfNeeded(
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension);
 
   ~ServiceWorkerPrivate();
 
@@ -224,13 +251,14 @@
       nsCOMPtr<nsIInterceptedChannel>&& aChannel,
       RefPtr<FetchServicePromises>&& aPreloadResponseReadyPromises);
 
-  void Shutdown();
+  void Shutdown(Maybe<RefPtr<Promise>>&& aMaybePromise = Nothing());
 
   RefPtr<GenericNonExclusivePromise> ShutdownInternal(
       uint32_t aShutdownStateId);
 
   nsresult ExecServiceWorkerOp(
       ServiceWorkerOpArgs&& aArgs,
+      const ServiceWorkerLifetimeExtension& aLifetimeExtension,
       std::function<void(ServiceWorkerOpResult&&)>&& aSuccessCallback,
       std::function<void()>&& aFailureCallback = [] {});
 
@@ -335,6 +363,7 @@
   RefPtr<RAIIActorPtrHolder> mControllerChild;
 
   RemoteWorkerData mRemoteWorkerData;
+  Maybe<ClientInfo> mClientInfo;
 
   TimeStamp mServiceWorkerLaunchTimeStart;
 
@@ -357,6 +386,14 @@
 
   nsCOMPtr<nsITimer> mIdleWorkerTimer;
 
+  ServiceWorkerLifetimeExtension mPendingSpawnLifetime;
+
+  // This is the current time in the future that the idle timer is set to expire
+  // for keepalive purposes.  This will not be updated for the
+  // "dom.serviceWorkers.idle_extended_timeout" grace period after the time
+  // first expires.
+  TimeStamp mIdleDeadline;
+
   // We keep a token for |dom.serviceWorkers.idle_timeout| seconds to give the
   // worker a grace period after each event.
   RefPtr<KeepAliveToken> mIdleKeepAliveToken;
@@ -365,6 +402,8 @@
 
   uint64_t mTokenCount;
 
+  uint32_t mLaunchCount;
+
   // Used by the owning `ServiceWorkerRegistrationInfo` when it wants to call
   // `Clear` after being unregistered and isn't controlling any clients but this
   // worker (i.e. the registration's active worker) isn't idle yet. Note that