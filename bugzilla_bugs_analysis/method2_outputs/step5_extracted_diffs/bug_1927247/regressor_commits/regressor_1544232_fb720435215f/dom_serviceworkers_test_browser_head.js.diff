# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/test/browser_head.js
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/test/browser_head.js
--- a/dom/serviceworkers/test/browser_head.js	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/test/browser_head.js	Thu Oct 24 03:02:42 2024 +0000
@@ -115,11 +115,14 @@
 
 /**
  * Install a ServiceWorker according to the provided descriptor by opening a
- * fresh tab that will be closed when we are done.  Returns the
- * `nsIServiceWorkerRegistrationInfo` corresponding to the registration.
+ * fresh tab that waits for the installed worker to be active and then closes
+ * the tab.  Returns the`nsIServiceWorkerRegistrationInfo` corresponding to the
+ * registration.
  *
  * The descriptor may have the following properties:
- * - scope: Optional.
+ * - scope: Optional.  This is usually a relative path for tests and because
+ *   there are (security) checks if the scope is more generic than the page
+ *   URL, you almost never would want to specify an absolute scope here.
  * - script: The script, which usually just wants to be a relative path.
  * - origin: Requred, the origin (which should not include a trailing slash).
  */
@@ -152,6 +155,79 @@
   return swm_lookup_reg(swDesc);
 }
 
+async function createMessagingHelperTab(origin, channelName) {
+  const pageUrlStr = `${origin}/${DIR_PATH}/empty_with_utils.html`;
+
+  let tab = await BrowserTestUtils.openNewForegroundTab(gBrowser, pageUrlStr);
+
+  // For hygiene reasons we make sure the helper establishes its message channel
+  // in a task distinct from any of the tasks that will initiate events.
+  await SpecialPowers.spawn(tab.linkedBrowser, [channelName], channelName => {
+    content.wrappedJSObject.setupMessagingChannel(channelName);
+  });
+
+  return {
+    async postMessageScopeAndWaitFor(scope, messageToSend, messageToWaitFor) {
+      info(
+        `Sending message to SW scope ${scope} via helper page: ${messageToSend}`
+      );
+      info(`Waiting for message via helper page: ${messageToWaitFor}`);
+      await SpecialPowers.spawn(
+        tab.linkedBrowser,
+        [channelName, scope, messageToSend, messageToWaitFor],
+        async (channelName, scope, messageToSend, messageToWaitFor) => {
+          await content.wrappedJSObject.postMessageScopeAndWaitFor(
+            channelName,
+            scope,
+            messageToSend,
+            messageToWaitFor
+          );
+        }
+      );
+      ok(true, "Expected message received");
+    },
+
+    async broadcastAndWaitFor(messageToBroadcast, messageToWaitFor) {
+      info(`Sending messageToBroadcast via helper page: ${messageToBroadcast}`);
+      info(`Waiting for message via helper page: ${messageToWaitFor}`);
+      await SpecialPowers.spawn(
+        tab.linkedBrowser,
+        [channelName, messageToBroadcast, messageToWaitFor],
+        async (channelName, messageToBroadcast, messageToWaitFor) => {
+          await content.wrappedJSObject.broadcastAndWaitFor(
+            channelName,
+            messageToBroadcast,
+            messageToWaitFor
+          );
+        }
+      );
+      ok(true, "Expected message received");
+    },
+
+    async updateScopeAndWaitFor(scope, messageToWaitFor) {
+      info(`Updating scope ${scope} via helper page`);
+      info(`Waiting for message via helper page: ${messageToWaitFor}`);
+      await SpecialPowers.spawn(
+        tab.linkedBrowser,
+        [channelName, scope, messageToWaitFor],
+        async (channelName, scope, messageToWaitFor) => {
+          await content.wrappedJSObject.updateScopeAndWaitFor(
+            channelName,
+            scope,
+            messageToWaitFor
+          );
+        }
+      );
+      ok(true, "Expected message received");
+    },
+
+    async closeHelperTab() {
+      await BrowserTestUtils.removeTab(tab);
+      tab = null;
+    },
+  };
+}
+
 /**
  * Consume storage in the given origin by storing randomly generated Blobs into
  * Cache API storage and IndexedDB storage.  We use both APIs in order to