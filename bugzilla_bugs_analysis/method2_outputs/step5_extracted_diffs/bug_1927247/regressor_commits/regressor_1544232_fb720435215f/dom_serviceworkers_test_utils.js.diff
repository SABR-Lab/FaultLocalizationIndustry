# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/test/utils.js
# Commit: fb720435215f
# Full Hash: fb720435215fa5be3b2bd2101f3a54382954b70c
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1544232
# File Overlap Count: 4
# Description:
#   Bug 1544232 - Limit lifetime extension of SWs by SWs to the sender's lifetime. r=edenchuang
#   
#   This patch introduces an explicit concept of lifetimes with mechanisms
#   in place so that actions taken by Clients (windows or non-ServiceWorker
#   orkers) will extend the lifetime of a ServiceWorker, but a ServiceWorker
# ==============================================================================

diff -r 25452f6623a0 -r fb720435215f dom/serviceworkers/test/utils.js
--- a/dom/serviceworkers/test/utils.js	Thu Oct 24 03:02:41 2024 +0000
+++ b/dom/serviceworkers/test/utils.js	Thu Oct 24 03:02:42 2024 +0000
@@ -134,3 +134,94 @@
     };
   });
 }
+
+const messagingChannels = {};
+
+// This method should ideally be called during a setup phase of the test to make
+// sure our BroadcastChannel is fully connected before anything that could cause
+// something to send a message to the channel can happen.  Because IPC ordering
+// is more predictable these days (single channel per process pair), this is
+// primarily an issue of:
+// - Helping you not have to worry about there being a race here at all.
+// - Potentially be able to refactor this to run on the WPT infrastructure in
+//   the future which likely cannot provide the same ordering guarantees.
+function setupMessagingChannel(name) {
+  if (messagingChannels[name]) {
+    return;
+  }
+
+  messagingChannels[name] = new BroadcastChannel(name);
+}
+
+function waitForBroadcastMessage(channelName, messageToWaitFor) {
+  if (!messagingChannels[channelName]) {
+    throw new Error(`You forgot to call setupMessagingChannel(${channelName})`);
+  }
+  return new Promise((resolve, reject) => {
+    const channel = messagingChannels[channelName];
+    const listener = evt => {
+      // Add `--setpref="devtools.console.stdout.content=true"` to your mach
+      // invocation to get this to stdout for extra debugging.
+      console.log("Helper seeing message", evt.data, "on channel", channelName);
+      if (evt.data === messageToWaitFor) {
+        resolve();
+        channel.removeEventListener("message", listener);
+      } else if (evt.data?.error) {
+        // Anything reporting an error means we should fail fast.
+        reject(evt.data);
+        channel.removeEventListener("message", listener);
+      }
+    };
+    channel.addEventListener("message", listener);
+  });
+}
+
+async function postMessageScopeAndWaitFor(
+  channelName,
+  scope,
+  messageToSend,
+  messageToWaitFor
+) {
+  // This will throw for us if the channel does not exist.
+  const waitPromise = waitForBroadcastMessage(channelName, messageToWaitFor);
+  const channel = messagingChannels[channelName];
+
+  const reg = await navigator.serviceWorker.getRegistration(scope);
+  if (!reg) {
+    throw new Error(`Unable to find registration for scope: ${scope}`);
+  }
+  if (!reg.active) {
+    throw new Error(`There is no active SW on the reg for scope: ${scope}`);
+  }
+  reg.active.postMessage(messageToSend);
+
+  await waitPromise;
+}
+
+async function broadcastAndWaitFor(
+  channelName,
+  messageToBroadcast,
+  messageToWaitFor
+) {
+  // This will throw for us if the channel does not exist.
+  const waitPromise = waitForBroadcastMessage(channelName, messageToWaitFor);
+  const channel = messagingChannels[channelName];
+
+  channel.postMessage(messageToBroadcast);
+
+  await waitPromise;
+}
+
+async function updateScopeAndWaitFor(channelName, scope, messageToWaitFor) {
+  // This will throw for us if the channel does not exist.
+  const waitPromise = waitForBroadcastMessage(channelName, messageToWaitFor);
+  const channel = messagingChannels[channelName];
+
+  const reg = await navigator.serviceWorker.getRegistration(scope);
+  if (!reg) {
+    throw new Error(`Unable to find registration for scope: ${scope}`);
+  }
+  reg.update();
+
+  await waitPromise;
+}