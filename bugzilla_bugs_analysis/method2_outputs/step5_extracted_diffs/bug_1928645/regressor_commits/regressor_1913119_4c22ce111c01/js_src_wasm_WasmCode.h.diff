# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmCode.h
# Commit: 4c22ce111c01
# Full Hash: 4c22ce111c012805515250b63074235b5578caa6
# Author: Ryan Hunt <rhunt@eqrion.net>
# Date: 2024-10-31 04:51:12
# Regressor Bug: 1913119
# File Overlap Count: 1
# Description:
#   Bug 1913119 - wasm: Re-use pool mechanism for lazy stubs and simplify logic. r=jseward
#   
#   Lazy func export stubs used some of the mechanism for allocating from a pool
#   of code segments, but not all. This caused some code duplication and layering
#   issues.
# ==============================================================================

diff -r 7593ec9fa478 -r 4c22ce111c01 js/src/wasm/WasmCode.h
--- a/js/src/wasm/WasmCode.h	Wed Oct 30 21:54:24 2024 +0000
+++ b/js/src/wasm/WasmCode.h	Wed Oct 30 21:54:24 2024 +0000
@@ -221,31 +221,75 @@
                                              const LinkData& linkData,
                                              bool allowLastDitchGC = true);
 
-  // Allocate code space at a hardware page granularity, taking space from
-  // `code->lazyFuncSegments`, and copy/link code from `masm` into it.  If an
-  // existing segment can satisy the allocation, space is reserved there, and
-  // that segment is returned; else a new segment is created for the
-  // allocation, is added to `code->lazyFuncSegments`, and returned.
+  // Claims space for `codeLength` from an existing code segment in a pool, or
+  // else creates a new code segment and adds it to the pool.
+  //
+  // Returns the code segment along with details of the allocation. The caller
+  // must copy, link, and make the code executable.
+  //
+  // There are two important ranges created, an 'allocation' range and a 'code
+  // range'.
+  // 
+  // The allocation range is a superset of the code range. The allocation start
+  // offset will be aligned to `AllocationAlignment` which is either the system
+  // page size or just executable code alignment.
+  //
+  // The code range will be within the allocation range and may have some
+  // padding inserted before the start of the allocation. The code start offset
+  // will always be aligned to the executable code alignment.
+  //
+  // Random padding is added before the code range when we are aligning to the
+  // system page size, the start addressess of all the code memories will not
+  // conflict in associative icaches.
+  //
+  // Here's a picture that illustrates the resulting structure of allocations:
+  //
+  // This is an example for a machine with a 4KB page size, for a codeLength
+  // which requires more than one page but less than two, in a segment where
+  // the first page is already allocated.
   //
-  // The location/length of the final code is returned in
-  // `*codeStart`/`*codeLength`.  Note that placement is somewhat randomised
-  // inside the page, so `*codeStart` will not be page-aligned.  Also, the
-  // metadata associated with the code block will have to be offset by the
-  // value returned in `*metadataBias`.
-  static RefPtr<CodeSegment> createFromMasmWithBumpAlloc(
-      jit::MacroAssembler& masm, const LinkData& linkData, const Code* code,
-      bool allowLastDitchGC, uint8_t** codeStartOut, uint32_t* codeLengthOut,
-      uint32_t* metadataBiasOut);
+  // Note: if !JitOptions.writeProtectCode, then allocationStart and
+  //   allocationLength will be a multiple of jit::CodeAlignment, not the
+  //   system page size.
+  //
+  // segment->base() (aligned at 4K = hardware page size)
+  // :
+  // :                      +4k                     +8k                    +12k
+  // :                       :                       :                       :
+  // +-----------------------+          +---------------------------------+   :
+  // |        IN USE         |          |   CODE              CODE        |   :
+  // +-----------------------+----------+---------------------------------+---+
+  // .                       :          :                                 :
+  // :                       :          :     allocationLength            :
+  // :                       :<------------------------------------------>:
+  // .                       :          :                                 :
+  // :                       :  padding :           codeLength            :
+  // :<--------------------->:<-------->:<------------------------------->:
+  // :                       :          :
+  // :                       :          :
+  // :<-------------------------------->:
+  //                         :          :
+  //                         :          codeStart
+  //                         :
+  //                         allocationStart
+  static RefPtr<CodeSegment> claimSpaceFromPool(
+      uint32_t codeLength,
+      Vector<RefPtr<CodeSegment>, 0, SystemAllocPolicy>* segmentPool,
+      bool allowLastDitchGC, uint8_t** allocationStartOut,
+      uint8_t** codeStartOut, uint32_t* allocationLengthOut);
 
-  // For this CodeSegment, perform linking on the area
-  // [codeStart, +codeLength), then make all pages that intersect
-  // [pageStart, +codeLength+(codeStart-pageStart)) executable.  See ASCII
-  // art at CodeSegment::createFromMasmWithBumpAlloc (implementation) for the
-  // meaning of pageStart/codeStart/codeLength.
+  // For this CodeSegment, link the code given at `codeStart` and make the
+  // range of `[allocationStart, allocationLength)` executable.
   bool linkAndMakeExecutableSubRange(
       jit::AutoMarkJitCodeWritableForThread& writable, const LinkData& linkData,
-      const Code* maybeCode, uint8_t* pageStart, uint8_t* codeStart,
-      uint32_t codeLength);
+      const Code* maybeCode, uint8_t* allocationStart, uint8_t* codeStart,
+      uint32_t allocationLength);
+  // Same as above, but only does the minimum necessary linking using a given
+  // masm.
+  bool linkAndMakeExecutableSubRange(
+      jit::AutoMarkJitCodeWritableForThread& writable,
+      jit::MacroAssembler& masm, uint8_t* allocationStart, uint8_t* codeStart,
+      uint32_t allocationLength);
 
   // For this CodeSegment, perform linking on the entire code area, then make
   // it executable.
@@ -897,26 +941,6 @@
     HashMap<const char*, uint32_t, mozilla::CStringHasher, SystemAllocPolicy>;
 
 class Code : public ShareableBase<Code> {
-  // A primitive PRNG, as used in early C library implementations.
-  // See https://en.wikipedia.org/wiki/
-  //             Linear_congruential_generator#Parameters_in_common_use.
-  // It is used for randomising code layout so as to avoid icache misses, not
-  // for any security-related reason, which is why we don't care about its
-  // quality too much.  It also gives us repeatability when debugging or
-  // profiling.
-  class SimplePRNG {
-    uint32_t state_;
-
-   public:
-    SimplePRNG() : state_(999) {}
-    // Returns an 11-bit pseudo-random number.
-    uint32_t get11RandomBits() {
-      state_ = state_ * 1103515245 + 12345;
-      // Both the high and low order bits are reputed to be not very random.
-      // Throw them away.
-      return (state_ >> 4) & 0x7FF;
-    }
-  };
   struct ProtectedData {
     // A vector of all of the code blocks owned by this code. Each code block
     // is immutable once added to the vector, but this vector may grow.
@@ -933,9 +957,6 @@
 
     // A vector of code segments that we can lazily allocate functions into
     SharedCodeSegmentVector lazyFuncSegments;
-
-    // For randomizing code layout.
-    SimplePRNG simplePRNG;
   };
   using ReadGuard = RWExclusiveData<ProtectedData>::ReadGuard;
   using WriteGuard = RWExclusiveData<ProtectedData>::WriteGuard;
@@ -950,10 +971,8 @@
   // Thread-safe mutable map from code pointer to code block that contains it.
   mutable ThreadSafeCodeBlockMap blockMap_;
 
-  // These have the same lifetime end as Code itself -- they can be dropped
-  // when Code itself is dropped.  FIXME: should these be MutableCodeXX?
-  //
-  // This must always be non-null.
+  // Metadata for this module that is needed for the lifetime of Code. This is
+  // always non-null.
   SharedCodeMetadata codeMeta_;
   // This is null for a wasm module, non-null for asm.js
   SharedCodeMetadataForAsmJS codeMetaForAsmJS_;
@@ -1054,7 +1073,10 @@
                                             const FuncExport** funcExport,
                                             void** interpEntry) const;
 
-  const RWExclusiveData<ProtectedData>& data() const { return data_; }
+  SharedCodeSegment createFuncCodeSegmentFromPool(
+      jit::MacroAssembler& masm, const LinkData& linkData,
+      bool allowLastDitchGC, uint8_t** codeStartOut,
+      uint32_t* codeLengthOut) const;
 
   bool requestTierUp(uint32_t funcIndex) const;
 
@@ -1219,16 +1241,6 @@
 
 void PatchDebugSymbolicAccesses(uint8_t* codeBase, jit::MacroAssembler& masm);
 
-// Allocate executable memory from the pool in `lazySegments`, or if none of
-// those have space, create a new Segment, add it to the vector, and allocate
-// from that.  `*roundedUpAllocationSize` returns the actual allocation size;
-// it is guaranteed to be a multiple of the machine's page size.
-SharedCodeSegment AllocateCodePagesFrom(SharedCodeSegmentVector& lazySegments,
-                                        uint32_t bytesNeeded,
-                                        bool allowLastDitchGC,
-                                        size_t* offsetInSegment,
-                                        size_t* roundedUpAllocationSize);
-
 }  // namespace wasm
 }  // namespace js
 