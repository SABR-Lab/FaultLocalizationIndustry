# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/BlockReflowState.cpp
# Commit: b0b878dae244
# Full Hash: b0b878dae244416c3b4799f43ee2f5176f3d3fc8
# Author: fantasai <fantasai.cvs@inkedblade.net>
# Date: 2024-02-28 04:30:28
# Regressor Bug: 1765615
# File Overlap Count: 1
# Description:
#   Bug 1684236 - Implement 'align-content' on block containers. r=layout-reviewers,jfkthame
#   
#   This is Fantasai's original patch, massively simplified:
#   
#    * We now can switch whether we're a BFC dynamically (bug 1765615), which
# ==============================================================================

diff -r 6b8582441a76 -r b0b878dae244 layout/generic/BlockReflowState.cpp
--- a/layout/generic/BlockReflowState.cpp	Tue Feb 27 11:35:54 2024 -0500
+++ b/layout/generic/BlockReflowState.cpp	Tue Feb 27 16:32:02 2024 +0000
@@ -47,7 +47,8 @@
       mMinLineHeight(aReflowInput.GetLineHeight()),
       mLineNumber(0),
       mTrailingClearFromPIF(StyleClear::None),
-      mConsumedBSize(aConsumedBSize) {
+      mConsumedBSize(aConsumedBSize),
+      mAlignContentShift(mBlock->GetAlignContentShift()) {
   NS_ASSERTION(mConsumedBSize != NS_UNCONSTRAINEDSIZE,
                "The consumed block-size should be constrained!");
 
@@ -87,8 +88,8 @@
   // the "overflow" property. When we don't have a specified style block-size,
   // then we may end up limiting our block-size if the available block-size is
   // constrained (this situation occurs when we are paginated).
-  if (const nscoord availableBSize = aReflowInput.AvailableBSize();
-      availableBSize != NS_UNCONSTRAINEDSIZE) {
+  const nscoord availableBSize = aReflowInput.AvailableBSize();
+  if (availableBSize != NS_UNCONSTRAINEDSIZE) {
     // We are in a paginated situation. The block-end edge of the available
     // space to reflow the children is within our block-end border and padding.
     // If we're cloning our border and padding, and we're going to request
@@ -112,10 +113,34 @@
   mContentArea.IStart(wm) = mBorderPadding.IStart(wm);
   mBCoord = mContentArea.BStart(wm) = mBorderPadding.BStart(wm);
 
+  // Account for existing cached shift, we'll re-position in AlignContent() if
+  // needed.
+  if (mAlignContentShift) {
+    mBCoord += mAlignContentShift;
+    mContentArea.BStart(wm) += mAlignContentShift;
+
+    if (availableBSize != NS_UNCONSTRAINEDSIZE) {
+      mContentArea.BSize(wm) += mAlignContentShift;
+    }
+  }
+
   mPrevChild = nullptr;
   mCurrentLine = aFrame->LinesEnd();
 }
 
+void BlockReflowState::UndoAlignContentShift() {
+  if (!mAlignContentShift) {
+    return;
+  }
+
+  mBCoord -= mAlignContentShift;
+  mContentArea.BStart(mReflowInput.GetWritingMode()) -= mAlignContentShift;
+
+  if (mReflowInput.AvailableBSize() != NS_UNCONSTRAINEDSIZE) {
+    mContentArea.BSize(mReflowInput.GetWritingMode()) -= mAlignContentShift;
+  }
+}
+
 void BlockReflowState::ComputeFloatAvoidingOffsets(
     nsIFrame* aFloatAvoidingBlock, const LogicalRect& aFloatAvailableSpace,
     nscoord& aIStartResult, nscoord& aIEndResult) const {