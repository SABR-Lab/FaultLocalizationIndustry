# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/PresShell.cpp
# Commit: b2727a598452
# Full Hash: b2727a598452fb942e0611df5f931d4df0efaceb
# Author: Frédéric Wang <fwang@igalia.com>
# Date: 2024-01-18 04:47:51
# Regressor Bug: 1765615
# File Overlap Count: 1
# Description:
#   Bug 1765615 - Handle most changes to CSS `contain` and `content-visibility` without needing to reconstruct frames. r=layout-reviewers,emilio
#   
#   Right now, we reconstruct frames in response to a change in the CSS
#   `contain` property or `content-visibility`. This patch tries to optimize
#   this a bit:
# ==============================================================================

diff -r 5608664350d8 -r b2727a598452 layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp	Wed Jan 17 07:22:29 2024 +0000
+++ b/layout/base/PresShell.cpp	Wed Jan 17 08:22:48 2024 +0000
@@ -2192,8 +2192,6 @@
       mPendingScrollAnchorAdjustment.Remove(scrollableFrame);
       mPendingScrollResnap.Remove(scrollableFrame);
     }
-
-    mContentVisibilityAutoFrames.Remove(aFrame);
   }
 }
 
@@ -11996,15 +11994,12 @@
     return;
   }
 
-  bool isRelevantContentChanged = false;
   for (nsIFrame* frame : mContentVisibilityAutoFrames) {
-    isRelevantContentChanged |=
-        frame->UpdateIsRelevantContent(mContentVisibilityRelevancyToUpdate);
-  }
-  if (isRelevantContentChanged) {
-    if (nsPresContext* presContext = GetPresContext()) {
-      presContext->UpdateHiddenByContentVisibilityForAnimations();
-    }
+    frame->UpdateIsRelevantContent(mContentVisibilityRelevancyToUpdate);
+  }
+
+  if (nsPresContext* presContext = GetPresContext()) {
+    presContext->UpdateHiddenByContentVisibilityForAnimationsIfNeeded();
   }
 
   mContentVisibilityRelevancyToUpdate.clear();
@@ -12038,7 +12033,6 @@
   auto input = DOMIntersectionObserver::ComputeInput(
       *mDocument, /* aRoot = */ nullptr, &rootMargin);
 
-  bool isRelevantContentChanged = false;
   for (nsIFrame* frame : mContentVisibilityAutoFrames) {
     auto* element = frame->GetContent()->AsElement();
     result.mAnyScrollIntoViewFlag |=
@@ -12059,8 +12053,7 @@
             .Intersects();
     element->SetVisibleForContentVisibility(intersects);
     if (oldVisibility.isNothing() || *oldVisibility != intersects) {
-      isRelevantContentChanged |=
-          frame->UpdateIsRelevantContent(ContentRelevancyReason::Visible);
+      frame->UpdateIsRelevantContent(ContentRelevancyReason::Visible);
     }
 
     // 14.2.3.3
@@ -12068,10 +12061,8 @@
       result.mHadInitialDetermination = true;
     }
   }
-  if (isRelevantContentChanged) {
-    if (nsPresContext* presContext = GetPresContext()) {
-      presContext->UpdateHiddenByContentVisibilityForAnimations();
-    }
+  if (nsPresContext* presContext = GetPresContext()) {
+    presContext->UpdateHiddenByContentVisibilityForAnimationsIfNeeded();
   }
 
   return result;