# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsIFrame.cpp
# Commit: b2727a598452
# Full Hash: b2727a598452fb942e0611df5f931d4df0efaceb
# Author: Frédéric Wang <fwang@igalia.com>
# Date: 2024-01-18 04:47:51
# Regressor Bug: 1765615
# File Overlap Count: 1
# Description:
#   Bug 1765615 - Handle most changes to CSS `contain` and `content-visibility` without needing to reconstruct frames. r=layout-reviewers,emilio
#   
#   Right now, we reconstruct frames in response to a change in the CSS
#   `contain` property or `content-visibility`. This patch tries to optimize
#   this a bit:
# ==============================================================================

diff -r 5608664350d8 -r b2727a598452 layout/generic/nsIFrame.cpp
--- a/layout/generic/nsIFrame.cpp	Wed Jan 17 07:22:29 2024 +0000
+++ b/layout/generic/nsIFrame.cpp	Wed Jan 17 08:22:48 2024 +0000
@@ -753,24 +753,34 @@
 
 void nsIFrame::InitPrimaryFrame() {
   MOZ_ASSERT(IsPrimaryFrame());
+  HandlePrimaryFrameStyleChange(nullptr);
+}
+
+void nsIFrame::HandlePrimaryFrameStyleChange(ComputedStyle* aOldStyle) {
   const nsStyleDisplay* disp = StyleDisplay();
-
-  if (disp->mContainerType != StyleContainerType::Normal) {
-    PresContext()->RegisterContainerQueryFrame(this);
-  }
-
-  if (StyleDisplay()->ContentVisibility(*this) ==
-      StyleContentVisibility::Auto) {
-    PresShell()->RegisterContentVisibilityAutoFrame(this);
-  } else if (auto* element = Element::FromNodeOrNull(GetContent())) {
-    element->ClearContentRelevancy();
-  }
-
-  // TODO(mrobinson): Once bug 1765615 is fixed, this should be called on
-  // layout changes. In addition, when `content-visibility: auto` is implemented
-  // this should also be called when scrolling or focus causes content to be
-  // skipped or unskipped.
-  UpdateAnimationVisibility();
+  const nsStyleDisplay* oldDisp =
+      aOldStyle ? aOldStyle->StyleDisplay() : nullptr;
+  if (!oldDisp || oldDisp->mContainerType != disp->mContainerType) {
+    auto* pc = PresContext();
+    if (disp->mContainerType != StyleContainerType::Normal) {
+      pc->RegisterContainerQueryFrame(this);
+    } else {
+      pc->UnregisterContainerQueryFrame(this);
+    }
+  }
+
+  const auto cv = disp->ContentVisibility(*this);
+  if (!oldDisp || oldDisp->ContentVisibility(*this) != cv) {
+    if (cv == StyleContentVisibility::Auto) {
+      PresShell()->RegisterContentVisibilityAutoFrame(this);
+    } else {
+      if (auto* element = Element::FromNodeOrNull(GetContent())) {
+        element->ClearContentRelevancy();
+      }
+      PresShell()->UnregisterContentVisibilityAutoFrame(this);
+    }
+    PresContext()->SetNeedsToUpdateHiddenByContentVisibilityForAnimations();
+  }
 
   HandleLastRememberedSize();
 }
@@ -796,19 +806,21 @@
     }
   }
 
-  if (disp->mContainerType != StyleContainerType::Normal) {
-    PresContext()->UnregisterContainerQueryFrame(this);
-  }
-
-  nsPresContext* presContext = PresContext();
-  mozilla::PresShell* presShell = presContext->GetPresShell();
   if (HasAnyStateBits(NS_FRAME_OUT_OF_FLOW)) {
     if (nsPlaceholderFrame* placeholder = GetPlaceholderFrame()) {
       placeholder->SetOutOfFlowFrame(nullptr);
     }
   }
 
+  nsPresContext* pc = PresContext();
+  mozilla::PresShell* ps = pc->GetPresShell();
   if (IsPrimaryFrame()) {
+    if (disp->mContainerType != StyleContainerType::Normal) {
+      pc->UnregisterContainerQueryFrame(this);
+    }
+    if (disp->ContentVisibility(*this) == StyleContentVisibility::Auto) {
+      ps->UnregisterContentVisibilityAutoFrame(this);
+    }
     // This needs to happen before we clear our Properties() table.
     ActiveLayerTracker::TransferActivityToContent(this, mContent);
   }
@@ -826,7 +838,7 @@
     // If no new frame for this element is created by the end of the
     // restyling process, stop animations and transitions for this frame
     RestyleManager::AnimationsWithDestroyedFrame* adf =
-        presContext->RestyleManager()->GetAnimationsWithDestroyedFrame();
+        pc->RestyleManager()->GetAnimationsWithDestroyedFrame();
     // AnimationsWithDestroyedFrame only lives during the restyling process.
     if (adf) {
       adf->Put(mContent, mComputedStyle);
@@ -841,12 +853,12 @@
   DisableVisibilityTracking();
 
   // Ensure that we're not in the approximately visible list anymore.
-  PresContext()->GetPresShell()->RemoveFrameFromApproximatelyVisibleList(this);
-
-  presShell->NotifyDestroyingFrame(this);
+  ps->RemoveFrameFromApproximatelyVisibleList(this);
+
+  ps->NotifyDestroyingFrame(this);
 
   if (HasAnyStateBits(NS_FRAME_EXTERNAL_REFERENCE)) {
-    presShell->ClearFrameRefs(this);
+    ps->ClearFrameRefs(this);
   }
 
   nsView* view = GetView();
@@ -884,7 +896,7 @@
 
 #ifdef DEBUG
   {
-    nsIFrame* rootFrame = presShell->GetRootFrame();
+    nsIFrame* rootFrame = ps->GetRootFrame();
     MOZ_ASSERT(rootFrame);
     if (this != rootFrame) {
       auto* builder = nsLayoutUtils::GetRetainedDisplayListBuilder(rootFrame);
@@ -904,7 +916,7 @@
 
   // Now that we're totally cleaned out, we need to add ourselves to
   // the presshell's recycler.
-  presShell->FreeFrame(id, this);
+  ps->FreeFrame(id, this);
 }
 
 std::pair<int32_t, int32_t> nsIFrame::GetOffsets() const {
@@ -1375,7 +1387,8 @@
   }
 
   if (IsPrimaryFrame()) {
-    HandleLastRememberedSize();
+    MOZ_ASSERT(aOldComputedStyle);
+    HandlePrimaryFrameStyleChange(aOldComputedStyle);
   }
 
   RemoveStateBits(NS_FRAME_SIMPLE_EVENT_REGIONS | NS_FRAME_SIMPLE_DISPLAYLIST);
@@ -7107,6 +7120,7 @@
   }
 
   HandleLastRememberedSize();
+  PresContext()->SetNeedsToUpdateHiddenByContentVisibilityForAnimations();
   PresShell()->FrameNeedsReflow(
       this, IntrinsicDirty::FrameAncestorsAndDescendants, NS_FRAME_IS_DIRTY);
   InvalidateFrame();
@@ -11445,29 +11459,6 @@
   }
 }
 
-void nsIFrame::UpdateAnimationVisibility() {
-  auto* animationCollection = AnimationCollection<CSSAnimation>::Get(this);
-  auto* transitionCollection = AnimationCollection<CSSTransition>::Get(this);
-
-  if ((!animationCollection || animationCollection->mAnimations.IsEmpty()) &&
-      (!transitionCollection || transitionCollection->mAnimations.IsEmpty())) {
-    return;
-  }
-
-  bool hidden = IsHiddenByContentVisibilityOnAnyAncestor();
-  if (animationCollection) {
-    for (auto& animation : animationCollection->mAnimations) {
-      animation->SetHiddenByContentVisibility(hidden);
-    }
-  }
-
-  if (transitionCollection) {
-    for (auto& transition : transitionCollection->mAnimations) {
-      transition->SetHiddenByContentVisibility(hidden);
-    }
-  }
-}
-
 nsIFrame::PhysicalAxes nsIFrame::ShouldApplyOverflowClipping(
     const nsStyleDisplay* aDisp) const {
   MOZ_ASSERT(aDisp == StyleDisplay(), "Wrong display struct");