# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/style/nsStyleStruct.cpp
# Commit: b2727a598452
# Full Hash: b2727a598452fb942e0611df5f931d4df0efaceb
# Author: Frédéric Wang <fwang@igalia.com>
# Date: 2024-01-18 04:47:51
# Regressor Bug: 1765615
# File Overlap Count: 1
# Description:
#   Bug 1765615 - Handle most changes to CSS `contain` and `content-visibility` without needing to reconstruct frames. r=layout-reviewers,emilio
#   
#   Right now, we reconstruct frames in response to a change in the CSS
#   `contain` property or `content-visibility`. This patch tries to optimize
#   this a bit:
# ==============================================================================

diff -r 5608664350d8 -r b2727a598452 layout/style/nsStyleStruct.cpp
--- a/layout/style/nsStyleStruct.cpp	Wed Jan 17 07:22:29 2024 +0000
+++ b/layout/style/nsStyleStruct.cpp	Wed Jan 17 08:22:48 2024 +0000
@@ -2248,24 +2248,12 @@
 
 nsChangeHint nsStyleDisplay::CalcDifference(
     const nsStyleDisplay& aNewData, const ComputedStyle& aOldStyle) const {
-  if (mDisplay != aNewData.mDisplay || mContain != aNewData.mContain ||
+  if (mDisplay != aNewData.mDisplay ||
       (mFloat == StyleFloat::None) != (aNewData.mFloat == StyleFloat::None) ||
       mTopLayer != aNewData.mTopLayer || mResize != aNewData.mResize) {
     return nsChangeHint_ReconstructFrame;
   }
 
-  // `content-visibility` can impact whether or not this frame has containment,
-  // so we reconstruct the frame like we do above.
-  // TODO: We should avoid reconstruction here, per bug 1765615.
-  if (mContentVisibility != aNewData.mContentVisibility) {
-    return nsChangeHint_ReconstructFrame;
-  }
-
-  // Same issue as above for now.
-  if (mContainerType != aNewData.mContainerType) {
-    return nsChangeHint_ReconstructFrame;
-  }
-
   auto oldAppearance = EffectiveAppearance();
   auto newAppearance = aNewData.EffectiveAppearance();
   if (oldAppearance != newAppearance) {
@@ -2279,6 +2267,21 @@
   }
 
   auto hint = nsChangeHint(0);
+  const auto containmentDiff =
+      mEffectiveContainment ^ aNewData.mEffectiveContainment;
+  if (containmentDiff) {
+    if (containmentDiff & StyleContain::STYLE) {
+      // Style containment affects counters so we need to re-frame.
+      return nsChangeHint_ReconstructFrame;
+    }
+    if (containmentDiff & (StyleContain::PAINT | StyleContain::LAYOUT)) {
+      // Paint and layout containment boxes are absolutely/fixed positioning
+      // containers and establishes an independent formatting context.
+      hint |= nsChangeHint_UpdateContainingBlock | nsChangeHint_UpdateBFC;
+    }
+    // The other container types only need a reflow.
+    hint |= nsChangeHint_AllReflowHints | nsChangeHint_RepaintFrame;
+  }
   if (mPosition != aNewData.mPosition) {
     if (IsAbsolutelyPositionedStyle() ||
         aNewData.IsAbsolutelyPositionedStyle()) {
@@ -2511,8 +2514,13 @@
   // TODO(emilio): Figure out change hints for container-name, maybe it needs to
   // be handled by the style system as a special-case (since it changes
   // container-query selection on descendants).
+  // container-type / contain / content-visibility are handled by the
+  // mEffectiveContainment check.
   if (!hint && (mWillChange != aNewData.mWillChange ||
                 mOverflowAnchor != aNewData.mOverflowAnchor ||
+                mContentVisibility != aNewData.mContentVisibility ||
+                mContainerType != aNewData.mContainerType ||
+                mContain != aNewData.mContain ||
                 mContainerName != aNewData.mContainerName)) {
     hint |= nsChangeHint_NeutralChange;
   }