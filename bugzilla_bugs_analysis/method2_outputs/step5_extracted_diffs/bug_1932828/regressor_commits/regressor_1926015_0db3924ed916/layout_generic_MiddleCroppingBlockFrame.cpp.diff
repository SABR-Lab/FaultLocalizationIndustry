# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/MiddleCroppingBlockFrame.cpp
# Commit: 0db3924ed916
# Full Hash: 0db3924ed9160b5d0ae0693c24082a11c43d49c2
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-11-22 09:28:00
# Regressor Bug: 1926015
# File Overlap Count: 1
# Description:
#   Bug 1926015 - Percentage-basis aware intrinsic cache. r=TYLin,dholbert
#   
#   This avoids returning wrong intrinsic values with different calls into
#   intrinsic size computation, which is wrong by definition.
#   
# ==============================================================================

diff -r 8a1a1450e750 -r 0db3924ed916 layout/generic/MiddleCroppingBlockFrame.cpp
--- a/layout/generic/MiddleCroppingBlockFrame.cpp	Thu Nov 21 19:17:26 2024 +0000
+++ b/layout/generic/MiddleCroppingBlockFrame.cpp	Thu Nov 21 19:55:31 2024 +0000
@@ -58,26 +58,28 @@
 
 nscoord MiddleCroppingBlockFrame::IntrinsicISize(
     const IntrinsicSizeInput& aInput, IntrinsicISizeType aType) {
-  nsAutoString prevValue;
-  bool restoreOldValue = false;
-
-  // Make sure we measure with the uncropped value.
-  if (mCropped && mCachedPrefISize == NS_INTRINSIC_ISIZE_UNKNOWN) {
-    mTextNode->GetNodeValue(prevValue);
-    restoreOldValue = true;
-    UpdateDisplayedValueToUncroppedValue(false);
+  auto* first = FirstContinuation();
+  if (this != first) {
+    return first->IntrinsicISize(aInput, aType);
   }
-
-  // Our min inline size is the same as our pref inline size, so we always
-  // delegate to nsBlockFrame's pref inline size.
-  nscoord result =
-      nsBlockFrame::IntrinsicISize(aInput, IntrinsicISizeType::PrefISize);
-
-  if (restoreOldValue) {
-    UpdateDisplayedValue(prevValue, /* aIsCropped = */ true, false);
-  }
-
-  return result;
+  return mCachedIntrinsics.GetOrSet(*this, aType, aInput, [&] {
+    nsAutoString prevValue;
+    bool restoreOldValue = false;
+    if (mCropped) {
+      // Make sure we measure with the uncropped value, if we're currently
+      // cropped.
+      mTextNode->GetNodeValue(prevValue);
+      UpdateDisplayedValueToUncroppedValue(false);
+      restoreOldValue = true;
+    }
+    // Our min inline size is the same as our pref inline size, so we always
+    // delegate to nsBlockFrame's pref inline size.
+    const nscoord result = nsBlockFrame::PrefISize(aInput);
+    if (restoreOldValue) {
+      UpdateDisplayedValue(prevValue, /* aIsCropped = */ true, false);
+    }
+    return result;
+  });
 }
 
 bool MiddleCroppingBlockFrame::CropTextToWidth(gfxContext& aRenderingContext,
@@ -177,8 +179,9 @@
         aStatus.Reset();
         MarkSubtreeDirty();
         AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
-        mCachedMinISize = NS_INTRINSIC_ISIZE_UNKNOWN;
-        mCachedPrefISize = NS_INTRINSIC_ISIZE_UNKNOWN;
+        // FIXME(emilio): Why do we need to clear cached intrinsics, if they are
+        // always based off our uncropped value?
+        mCachedIntrinsics.Clear();
         cropped = true;
         continue;
       }