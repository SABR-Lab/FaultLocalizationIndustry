# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/RestyleManager.cpp
# Commit: 3d4472548fb9
# Full Hash: 3d4472548fb9d48cce00f59066690611ee20ffcb
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-11-26 09:36:10
# Regressor Bug: 1931301
# File Overlap Count: 1
# Description:
#   Bug 1931301 - Notify of removals on a stable state, not mid-remove. r=smaug,masayuki,dshin
#   
#   This simplifies some observers, and makes others a bit more subtle, but I think
#   over-all it is an improvement.
#   
# ==============================================================================

diff -r 20a0394d798f -r 3d4472548fb9 layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp	Mon Nov 25 17:56:21 2024 +0000
+++ b/layout/base/RestyleManager.cpp	Mon Nov 25 17:58:40 2024 +0000
@@ -431,8 +431,7 @@
   }
 }
 
-void RestyleManager::ContentRemoved(nsIContent* aOldChild,
-                                    nsIContent* aFollowingSibling) {
+void RestyleManager::ContentWillBeRemoved(nsIContent* aOldChild) {
   auto* container = aOldChild->GetParentNode();
   MOZ_ASSERT(container);
 
@@ -452,15 +451,14 @@
   // transitions code, which manage anon content manually.
   // See similar code in ContentAppended.
   if (MOZ_UNLIKELY(aOldChild->IsRootOfNativeAnonymousSubtree())) {
-    MOZ_ASSERT(!aFollowingSibling, "NAC doesn't have siblings");
+    MOZ_ASSERT(!aOldChild->GetNextSibling(), "NAC doesn't have siblings");
     MOZ_ASSERT(aOldChild->GetProperty(nsGkAtoms::restylableAnonymousNode),
                "anonymous nodes should not be in child lists (bug 439258)");
     return;
   }
 
   if (aOldChild->IsElement()) {
-    StyleSet()->MaybeInvalidateForElementRemove(*aOldChild->AsElement(),
-                                                aFollowingSibling);
+    StyleSet()->MaybeInvalidateForElementRemove(*aOldChild->AsElement());
   }
 
   const auto selectorFlags =
@@ -482,7 +480,7 @@
       // so be conservative and assume :-moz-only-whitespace (i.e., make
       // IsSignificantChild less likely to be true, and thus make us more
       // likely to restyle).
-      if (nsStyleUtil::IsSignificantChild(child, false)) {
+      if (child != aOldChild && nsStyleUtil::IsSignificantChild(child, false)) {
         isEmpty = false;
         break;
       }
@@ -514,24 +512,26 @@
   if (selectorFlags & NodeSelectorFlags::HasSlowSelectorLaterSiblings) {
     // Restyle all later siblings.
     if (selectorFlags & NodeSelectorFlags::HasSlowSelectorNthAll) {
-      Element* nextSibling =
-          aFollowingSibling ? aFollowingSibling->IsElement()
-                                  ? aFollowingSibling->AsElement()
-                                  : aFollowingSibling->GetNextElementSibling()
-                            : nullptr;
+      Element* nextSibling = aOldChild->GetNextElementSibling();
       StyleSet()->MaybeInvalidateRelativeSelectorForNthDependencyFromSibling(
           nextSibling, /* aForceRestyleSiblings = */ true);
     } else {
-      RestyleSiblingsStartingWith(aFollowingSibling);
+      RestyleSiblingsStartingWith(aOldChild->GetNextSibling());
     }
   }
 
   if (selectorFlags & NodeSelectorFlags::HasEdgeChildSelector) {
+    const nsIContent* nextSibling = aOldChild->GetNextSibling();
     // restyle the now-first element child if it was after aOldChild
     bool reachedFollowingSibling = false;
     for (nsIContent* content = container->GetFirstChild(); content;
          content = content->GetNextSibling()) {
-      if (content == aFollowingSibling) {
+      if (content == aOldChild) {
+        // aOldChild is getting removed, so we don't want to account for it for
+        // the purposes of computing whether we're now the first / last child.
+        continue;
+      }
+      if (content == nextSibling) {
         reachedFollowingSibling = true;
         // do NOT continue here; we might want to restyle this node
       }
@@ -547,9 +547,13 @@
       }
     }
     // restyle the now-last element child if it was before aOldChild
-    reachedFollowingSibling = (aFollowingSibling == nullptr);
+    reachedFollowingSibling = !nextSibling;
     for (nsIContent* content = container->GetLastChild(); content;
          content = content->GetPreviousSibling()) {
+      if (content == aOldChild) {
+        // See above.
+        continue;
+      }
       if (content->IsElement()) {
         if (reachedFollowingSibling) {
           auto* element = content->AsElement();
@@ -560,7 +564,7 @@
         }
         break;
       }
-      if (content == aFollowingSibling) {
+      if (content == nextSibling) {
         reachedFollowingSibling = true;
       }
     }