# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/base/nsCSSFrameConstructor.cpp
# Commit: 3d4472548fb9
# Full Hash: 3d4472548fb9d48cce00f59066690611ee20ffcb
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-11-26 09:36:10
# Regressor Bug: 1931301
# File Overlap Count: 1
# Description:
#   Bug 1931301 - Notify of removals on a stable state, not mid-remove. r=smaug,masayuki,dshin
#   
#   This simplifies some observers, and makes others a bit more subtle, but I think
#   over-all it is an improvement.
#   
# ==============================================================================

diff -r 20a0394d798f -r 3d4472548fb9 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Mon Nov 25 17:56:21 2024 +0000
+++ b/layout/base/nsCSSFrameConstructor.cpp	Mon Nov 25 17:58:40 2024 +0000
@@ -1421,7 +1421,8 @@
       mCurrentDepth(0),
       mQuotesDirty(false),
       mCountersDirty(false),
-      mAlwaysCreateFramesForIgnorableWhitespace(false) {
+      mAlwaysCreateFramesForIgnorableWhitespace(false),
+      mReframingForViewportStyles(false) {
 #ifdef DEBUG
   static bool gFirstTime = true;
   if (gFirstTime) {
@@ -5346,7 +5347,7 @@
  * create a frame adjacent to a line boundary in the frame tree, and that
  * line boundary is induced by a content node adjacent to the frame's
  * content node in the content tree. The latter condition is necessary so
- * that ContentAppended/ContentInserted/ContentRemoved can easily find any
+ * that ContentAppended/ContentInserted/ContentWillBeRemoved can easily find any
  * text nodes that were suppressed here.
  */
 bool nsCSSFrameConstructor::AtLineBoundary(FCItemIterator& aIter) {
@@ -7299,13 +7300,13 @@
   return true;
 }
 
-bool nsCSSFrameConstructor::ContentRemoved(nsIContent* aChild,
-                                           nsIContent* aOldNextSibling,
-                                           RemoveFlags aFlags) {
+bool nsCSSFrameConstructor::ContentWillBeRemoved(nsIContent* aChild,
+                                                 RemoveFlags aFlags) {
   MOZ_ASSERT(aChild);
-  MOZ_ASSERT(!aChild->IsRootOfNativeAnonymousSubtree() || !aOldNextSibling,
-             "Anonymous roots don't have siblings");
-  AUTO_PROFILER_LABEL_HOT("nsCSSFrameConstructor::ContentRemoved",
+  MOZ_ASSERT(
+      !aChild->IsRootOfNativeAnonymousSubtree() || !aChild->GetNextSibling(),
+      "Anonymous roots don't have siblings");
+  AUTO_PROFILER_LABEL_HOT("nsCSSFrameConstructor::ContentWillBeRemoved",
                           LAYOUT_FrameConstruction);
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   nsPresContext* presContext = mPresShell->GetPresContext();
@@ -7318,8 +7319,9 @@
   // <body> child of the root element.  So we can only be removing the stored
   // override element if the thing being removed is either the override element
   // itself or the root element (which can be a parent of the override element).
-  if (aChild == presContext->GetViewportScrollStylesOverrideElement() ||
-      (aChild->IsElement() && !aChild->GetParent())) {
+  if ((aChild == presContext->GetViewportScrollStylesOverrideElement() ||
+       aChild->IsRootElement()) &&
+      !mReframingForViewportStyles) {
     // We might be removing the element that we propagated viewport scrollbar
     // styles from.  Recompute those. (This clause covers two of the three
     // possible scrollbar-propagation sources: the <body> [as aChild or a
@@ -7329,8 +7331,10 @@
     // part of the fullscreen cleanup code called by Element::UnbindFromTree.
     // We don't handle the fullscreen case here, because it doesn't change the
     // scrollbar styles override element stored on the prescontext.)
+    const Element* removingElement =
+        aFlags == REMOVE_CONTENT ? aChild->AsElement() : nullptr;
     Element* newOverrideElement =
-        presContext->UpdateViewportScrollStylesOverride();
+        presContext->UpdateViewportScrollStylesOverride(removingElement);
 
     // If aChild is the root, then we don't need to do any reframing of
     // newOverrideElement, because we're about to tear down the whole frame tree
@@ -7338,17 +7342,22 @@
     // reframing the <body> can trigger a reframe of the <html> and then reenter
     // here.
     //
-    // But if aChild is not the root, and if newOverrideElement is not
-    // the root and isn't aChild (which it could be if all we're doing
-    // here is reframing the current override element), it needs
-    // reframing.  In particular, it used to have a scrollframe
-    // (because its overflow was not "visible"), but now it will
-    // propagate its overflow to the viewport, so it should not need a
-    // scrollframe anymore.
+    // But if aChild is not the root, and if newOverrideElement is not the root
+    // and isn't aChild (which it could be if all we're doing here is reframing
+    // the current override element), it needs reframing.  In particular, it
+    // used to have a scrollframe (because its overflow was not "visible"), but
+    // now it will propagate its overflow to the viewport, so it should not need
+    // a scrollframe anymore.
+    //
+    // Make sure to not reenter here in that case, as we don't want to
+    // incorrectly pick aChild again as our viewport scroll style element (if
+    // it's getting removed from the DOM).
     if (aChild->GetParent() && newOverrideElement &&
         newOverrideElement->GetParent() && newOverrideElement != aChild) {
       LAYOUT_PHASE_TEMP_EXIT();
+      mReframingForViewportStyles = true;
       RecreateFramesForContent(newOverrideElement, InsertionKind::Async);
+      mReframingForViewportStyles = false;
       LAYOUT_PHASE_TEMP_REENTER();
     }
   }
@@ -7356,9 +7365,8 @@
 #ifdef DEBUG
   if (gNoisyContentUpdates) {
     printf(
-        "nsCSSFrameConstructor::ContentRemoved container=%p child=%p "
-        "old-next-sibling=%p\n",
-        aChild->GetParent(), aChild, aOldNextSibling);
+        "nsCSSFrameConstructor::ContentWillBeRemoved container=%p child=%p\n",
+        aChild->GetParent(), aChild);
     if (gReallyNoisyContentUpdates) {
       aChild->GetParent()->List(stdout, 0);
     }
@@ -7417,13 +7425,13 @@
 
   if (!childFrame && CouldHaveBeenDisplayContents(aChild)) {
     // NOTE(emilio): We may iterate through ::before and ::after here and they
-    // may be gone after the respective ContentRemoved call. Right now
+    // may be gone after the respective ContentWillBeRemoved call. Right now
     // StyleChildrenIterator handles that properly, so it's not an issue.
     StyleChildrenIterator iter(aChild);
     for (nsIContent* c = iter.GetNextChild(); c; c = iter.GetNextChild()) {
       if (c->GetPrimaryFrame() || CouldHaveBeenDisplayContents(c)) {
         LAYOUT_PHASE_TEMP_EXIT();
-        bool didReconstruct = ContentRemoved(c, nullptr, aFlags);
+        bool didReconstruct = ContentWillBeRemoved(c, aFlags);
         LAYOUT_PHASE_TEMP_REENTER();
         if (didReconstruct) {
           return true;
@@ -7498,7 +7506,7 @@
       // Trap out to special routine that handles adjusting a blocks
       // frame tree when first-letter style is present.
 #ifdef NOISY_FIRST_LETTER
-      printf("ContentRemoved: containingBlock=");
+      printf("ContentWillBeRemoved: containingBlock=");
       containingBlock->ListTag(stdout);
       printf(" parentFrame=");
       parentFrame->ListTag(stdout);
@@ -7533,7 +7541,7 @@
 
 #ifdef DEBUG
     if (gReallyNoisyContentUpdates) {
-      printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
+      printf("nsCSSFrameConstructor::ContentWillBeRemoved: childFrame=");
       childFrame->ListTag(stdout);
       putchar('\n');
       parentFrame->List(stdout);
@@ -7579,7 +7587,7 @@
     // If we're just reconstructing frames for the element, then the
     // following ContentInserted notification on the element will
     // take care of fixing up any adjacent text nodes.
-    if (aOldNextSibling && aFlags == REMOVE_CONTENT) {
+    if (aFlags == REMOVE_CONTENT) {
       MOZ_ASSERT(aChild->GetParentNode(),
                  "How did we have a sibling without a parent?");
       // Adjacent whitespace-only text nodes might have been suppressed if
@@ -7592,7 +7600,7 @@
       // and hence it's adjacent to a block end.
       // If aOldNextSibling is null, then the text node before the node being
       // removed is the last node, and we don't need to worry about it.
-      nsIContent* prevSibling = aOldNextSibling->GetPreviousSibling();
+      nsIContent* prevSibling = aChild->GetPreviousSibling();
       if (prevSibling && prevSibling->GetPreviousSibling()) {
         LAYOUT_PHASE_TEMP_EXIT();
         ReframeTextIfNeeded(prevSibling);
@@ -7600,17 +7608,19 @@
       }
       // Reframe any text node just after the node being removed, if there is
       // one, and if it's not the last child or the first child.
-      if (aOldNextSibling->GetNextSibling() &&
-          aOldNextSibling->GetPreviousSibling()) {
+      nsIContent* nextSibling = aChild->GetNextSibling();
+      if (nextSibling && prevSibling && nextSibling->GetNextSibling()) {
         LAYOUT_PHASE_TEMP_EXIT();
-        ReframeTextIfNeeded(aOldNextSibling);
+        ReframeTextIfNeeded(nextSibling);
         LAYOUT_PHASE_TEMP_REENTER();
       }
     }
 
 #ifdef DEBUG
     if (gReallyNoisyContentUpdates && parentFrame) {
-      printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
+      printf(
+          "nsCSSFrameConstructor::ContentWillBeRemoved: resulting frame "
+          "model:\n");
       parentFrame->List(stdout);
     }
 #endif
@@ -7631,8 +7641,8 @@
   MOZ_ASSERT(aPresShell->GetRootFrame(), "What happened here?");
   MOZ_ASSERT(aPresShell->GetPresContext(), "Say what?");
 
-  //  Note that both in ContentRemoved and ContentInserted the content node
-  //  will still have the right parent pointer, so looking at that is ok.
+  //  Note that both in ContentWillBeRemoved and ContentInserted the content
+  //  node will still have the right parent pointer, so looking at that is ok.
 
   nsIContent* parent = aNode->GetParent();
   if (parent) {
@@ -8473,13 +8483,8 @@
   }
 
   MOZ_ASSERT(aContent->GetParentNode());
-
-  // Remove the frames associated with the content object.
-  nsIContent* nextSibling = aContent->IsRootOfNativeAnonymousSubtree()
-                                ? nullptr
-                                : aContent->GetNextSibling();
-  bool didReconstruct =
-      ContentRemoved(aContent, nextSibling, REMOVE_FOR_RECONSTRUCTION);
+  const bool didReconstruct =
+      ContentWillBeRemoved(aContent, REMOVE_FOR_RECONSTRUCTION);
 
   if (!didReconstruct) {
     if (aInsertionKind == InsertionKind::Async && aContent->IsElement()) {
@@ -8494,8 +8499,8 @@
                                          nsChangeHint_ReconstructFrame);
     } else {
       // Now, recreate the frames associated with this content object. If
-      // ContentRemoved triggered reconstruction, then we don't need to do this
-      // because the frames will already have been built.
+      // ContentWillBeRemoved triggered reconstruction, then we don't need to do
+      // this because the frames will already have been built.
       ContentRangeInserted(aContent, aContent->GetNextSibling(),
                            aInsertionKind);
     }
@@ -8504,12 +8509,7 @@
 
 bool nsCSSFrameConstructor::DestroyFramesFor(nsIContent* aContent) {
   MOZ_ASSERT(aContent && aContent->GetParentNode());
-
-  nsIContent* nextSibling = aContent->IsRootOfNativeAnonymousSubtree()
-                                ? nullptr
-                                : aContent->GetNextSibling();
-
-  return ContentRemoved(aContent, nextSibling, REMOVE_FOR_RECONSTRUCTION);
+  return ContentWillBeRemoved(aContent, REMOVE_FOR_RECONSTRUCTION);
 }
 
 //////////////////////////////////////////////////////////////////////