# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: servo/components/style/invalidation/element/relative_selector.rs
# Commit: 3d4472548fb9
# Full Hash: 3d4472548fb9d48cce00f59066690611ee20ffcb
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2024-11-26 09:36:10
# Regressor Bug: 1931301
# File Overlap Count: 1
# Description:
#   Bug 1931301 - Notify of removals on a stable state, not mid-remove. r=smaug,masayuki,dshin
#   
#   This simplifies some observers, and makes others a bit more subtle, but I think
#   over-all it is an improvement.
#   
# ==============================================================================

diff -r 20a0394d798f -r 3d4472548fb9 servo/components/style/invalidation/element/relative_selector.rs
--- a/servo/components/style/invalidation/element/relative_selector.rs	Mon Nov 25 17:56:21 2024 +0000
+++ b/servo/components/style/invalidation/element/relative_selector.rs	Mon Nov 25 17:58:40 2024 +0000
@@ -26,11 +26,11 @@
 use dom::ElementState;
 use fxhash::FxHashMap;
 use selectors::matching::{
-    matches_compound_selector_from, matches_selector, CompoundSelectorMatchingResult,
-    ElementSelectorFlags, IncludeStartingStyle, MatchingContext, MatchingForInvalidation,
-    MatchingMode, NeedsSelectorFlags, QuirksMode, SelectorCaches, VisitedHandlingMode,
+    matches_selector, ElementSelectorFlags, IncludeStartingStyle, MatchingContext,
+    MatchingForInvalidation, MatchingMode, NeedsSelectorFlags, QuirksMode, SelectorCaches,
+    VisitedHandlingMode,
 };
-use selectors::parser::{Combinator, SelectorKey};
+use selectors::parser::SelectorKey;
 use selectors::OpaqueElement;
 use smallvec::SmallVec;
 use std::ops::DerefMut;
@@ -205,51 +205,10 @@
             );
             (combinator.unwrap(), o)
         };
-        if combinator.is_sibling() {
-            if prev_offset >= dependency.selector.len() - 1 {
-                // Hit the relative combinator - we don't have enough information to
-                // see if there's going to be a downstream match.
-                return false;
-            }
-            if matches!(self.operation, DomMutationOperation::Remove) {
-                // This is sad :( The sibling relation of a removed element is lost, and we don't
-                // propagate sibling traversal map to selector matching context, so we need to do
-                // manual matching here. TODO(dshin): Worth changing selector matching for this?
-
-                // Try matching this compound, then...
-                // Note: We'll not hit the leftmost sequence (Since we would have returned early
-                // if we'd hit the relative selector anchor).
-                if matches!(
-                    matches_compound_selector_from(
-                        &dependency.selector,
-                        dependency.selector.len() - prev_offset + 1,
-                        &mut matching_context,
-                        &element
-                    ),
-                    CompoundSelectorMatchingResult::NotMatched
-                ) {
-                    return true;
-                }
-
-                // ... Match the rest of the selector, manually traversing.
-                let mut prev_sibling = self.sibling_traversal_map.prev_sibling_for(&element);
-                while let Some(sib) = prev_sibling {
-                    if matches_selector(
-                        &dependency.selector,
-                        prev_offset,
-                        None,
-                        &sib,
-                        &mut matching_context,
-                    ) {
-                        return false;
-                    }
-                    if matches!(combinator, Combinator::NextSibling) {
-                        break;
-                    }
-                    prev_sibling = self.sibling_traversal_map.prev_sibling_for(&sib);
-                }
-                return true;
-            }
+        if combinator.is_sibling() && prev_offset >= dependency.selector.len() - 1 {
+            // Hit the relative combinator - we don't have enough information to
+            // see if there's going to be a downstream match.
+            return false;
         }
         !matches_selector(
             &dependency.selector,