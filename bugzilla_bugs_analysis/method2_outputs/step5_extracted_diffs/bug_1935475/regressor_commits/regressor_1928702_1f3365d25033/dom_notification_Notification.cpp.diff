# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/notification/Notification.cpp
# Commit: 1f3365d25033
# Full Hash: 1f3365d25033f9dbc52b13e8fc4c64f3cdd35946
# Author: Kagami Sascha Rosylight <saschanaz@outlook.com>
# Date: 2024-11-12 09:32:50
# Regressor Bug: 1928702
# File Overlap Count: 1
# Description:
#   Bug 1928702 - Part 2: Create PNotification via PBackground r=asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D227687
# ==============================================================================

diff -r cc25e5c94813 -r 1f3365d25033 dom/notification/Notification.cpp
--- a/dom/notification/Notification.cpp	Mon Nov 11 20:34:11 2024 +0000
+++ b/dom/notification/Notification.cpp	Mon Nov 11 20:34:11 2024 +0000
@@ -30,6 +30,9 @@
 #include "mozilla/dom/WorkerRunnable.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/dom/quota/ResultExtensions.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/BackgroundUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
 #include "Navigator.h"
 #include "NotificationUtils.h"
 #include "nsComponentManagerUtils.h"
@@ -2237,6 +2240,52 @@
   return notification.forget();
 }
 
+bool Notification::CreateActor(Promise* aPromise) {
+  mozilla::ipc::PBackgroundChild* backgroundActor =
+      mozilla::ipc::BackgroundChild::GetOrCreateForCurrentThread();
+  IPCNotificationOptions options(mTitle, mDir, mLang, mBody, mTag, mIconUrl,
+                                 mRequireInteraction, mSilent, mVibrate,
+                                 mDataAsBase64, mBehavior);
+
+  // Note: We are not using the typical PBackground managed actor here as we
+  // want the actor to be in the main thread of the main process. Instead we
+  // pass the endpoint to PBackground, it dispatches a runnable to the main
+  // thread, and the endpoint is bound there.
+
+  mozilla::ipc::Endpoint<notification::PNotificationParent> parentEndpoint;
+  mozilla::ipc::Endpoint<notification::PNotificationChild> childEndpoint;
+  notification::PNotification::CreateEndpoints(&parentEndpoint, &childEndpoint);
+
+  mActor = new notification::NotificationChild();
+  if (!childEndpoint.Bind(mActor)) {
+    return false;
+  }
+
+  nsIPrincipal* principal;
+  nsIPrincipal* effectiveStoragePrincipal;
+  bool isSecureContext;
+
+  // TODO: Should get nsIGlobalObject methods for each method
+  if (WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate()) {
+    principal = workerPrivate->GetPrincipal();
+    effectiveStoragePrincipal = workerPrivate->GetEffectiveStoragePrincipal();
+    isSecureContext = workerPrivate->IsSecureContext();
+  } else {
+    nsGlobalWindowInner* win = GetOwnerWindow();
+    NS_ENSURE_TRUE(win, false);
+    principal = win->GetPrincipal();
+    effectiveStoragePrincipal = win->GetEffectiveStoragePrincipal();
+    isSecureContext = win->IsSecureContext();
+  }
+
+  (void)backgroundActor->SendCreateNotificationParent(
+      std::move(parentEndpoint), WrapNotNull(principal),
+      WrapNotNull(effectiveStoragePrincipal), isSecureContext, mID, mScope,
+      options);
+
+  return true;
+}
+
 /* static */
 nsresult Notification::RemovePermission(nsIPrincipal* aPrincipal) {
   MOZ_ASSERT(XRE_IsParentProcess());