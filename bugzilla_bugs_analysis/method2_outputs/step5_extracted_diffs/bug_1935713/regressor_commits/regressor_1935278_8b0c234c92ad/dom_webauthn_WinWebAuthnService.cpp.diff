# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webauthn/WinWebAuthnService.cpp
# Commit: 8b0c234c92ad
# Full Hash: 8b0c234c92ad8db923d5150aba9e7385e8f5c33c
# Author: John Schanck <jschanck@mozilla.com>
# Date: 2024-12-05 09:58:04
# Regressor Bug: 1935278
# File Overlap Count: 1
# Description:
#   Bug 1935278 - support for the WebAuthn PRF extension on Windows. r=keeler
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D230316
# ==============================================================================

diff -r de1a42417976 -r 8b0c234c92ad dom/webauthn/WinWebAuthnService.cpp
--- a/dom/webauthn/WinWebAuthnService.cpp	Wed Dec 04 23:59:18 2024 +0000
+++ b/dom/webauthn/WinWebAuthnService.cpp	Wed Dec 04 23:59:19 2024 +0000
@@ -308,6 +308,9 @@
         // AttestationConveyance
         DWORD winAttestation = WEBAUTHN_ATTESTATION_CONVEYANCE_PREFERENCE_ANY;
 
+        // Prf
+        BOOL winEnablePrf = FALSE;
+
         nsString rpName;
         Unused << aArgs->GetRpName(rpName);
         rpInfo.pwszName = rpName.get();
@@ -430,6 +433,12 @@
           winAttestation = WEBAUTHN_ATTESTATION_CONVEYANCE_PREFERENCE_ANY;
         }
 
+        bool requestedPrf;
+        Unused << aArgs->GetPrf(&requestedPrf);
+        if (requestedPrf) {
+          winEnablePrf = TRUE;
+        }
+
         bool requestedCredProps;
         Unused << aArgs->GetCredProps(&requestedCredProps);
 
@@ -442,7 +451,7 @@
         // Extensions that might require an entry: hmac-secret, minPinLength.
         WEBAUTHN_EXTENSION rgExtension[2] = {};
         DWORD cExtensions = 0;
-        if (requestedHmacCreateSecret) {
+        if (requestedPrf || requestedHmacCreateSecret) {
           HmacCreateSecret = TRUE;
           rgExtension[cExtensions].pwszExtensionIdentifier =
               WEBAUTHN_EXTENSIONS_IDENTIFIER_HMAC_SECRET;
@@ -540,7 +549,7 @@
             WEBAUTHN_LARGE_BLOB_SUPPORT_NONE,
             winPreferResidentKey,  // PreferResidentKey
             FALSE,                 // BrowserInPrivateMode
-            FALSE,                 // EnablePrf
+            winEnablePrf,          // EnablePrf
             NULL,                  // LinkedDevice
             0,                     // size of JsonExt
             NULL,                  // JsonExt
@@ -723,6 +732,89 @@
           winUserVerificationReq = WEBAUTHN_USER_VERIFICATION_REQUIREMENT_ANY;
         }
 
+        // PRF inputs
+        WEBAUTHN_HMAC_SECRET_SALT_VALUES* pPrfInputs = nullptr;
+        WEBAUTHN_HMAC_SECRET_SALT_VALUES prfInputs = {0};
+        WEBAUTHN_HMAC_SECRET_SALT globalHmacSalt = {0};
+        nsTArray<uint8_t> prfEvalFirst;
+        nsTArray<uint8_t> prfEvalSecond;
+        nsTArray<nsTArray<uint8_t>> prfEvalByCredIds;
+        nsTArray<nsTArray<uint8_t>> prfEvalByCredFirsts;
+        nsTArray<bool> prfEvalByCredSecondMaybes;
+        nsTArray<nsTArray<uint8_t>> prfEvalByCredSeconds;
+        nsTArray<WEBAUTHN_HMAC_SECRET_SALT> hmacSecretSalts;
+        nsTArray<WEBAUTHN_CRED_WITH_HMAC_SECRET_SALT>
+            credWithHmacSecretSaltList;
+
+        bool requestedPrf;
+        Unused << aArgs->GetPrf(&requestedPrf);
+        if (requestedPrf) {
+          rv = aArgs->GetPrfEvalFirst(prfEvalFirst);
+          if (rv == NS_OK) {
+            globalHmacSalt.cbFirst = prfEvalFirst.Length();
+            globalHmacSalt.pbFirst = prfEvalFirst.Elements();
+            prfInputs.pGlobalHmacSalt = &globalHmacSalt;
+          }
+          rv = aArgs->GetPrfEvalSecond(prfEvalSecond);
+          if (rv == NS_OK) {
+            globalHmacSalt.cbSecond = prfEvalSecond.Length();
+            globalHmacSalt.pbSecond = prfEvalSecond.Elements();
+          }
+          if (NS_OK ==
+                  aArgs->GetPrfEvalByCredentialCredentialId(prfEvalByCredIds) &&
+              NS_OK ==
+                  aArgs->GetPrfEvalByCredentialEvalFirst(prfEvalByCredFirsts) &&
+              NS_OK == aArgs->GetPrfEvalByCredentialEvalSecondMaybe(
+                           prfEvalByCredSecondMaybes) &&
+              NS_OK == aArgs->GetPrfEvalByCredentialEvalSecond(
+                           prfEvalByCredSeconds) &&
+              prfEvalByCredIds.Length() == prfEvalByCredFirsts.Length() &&
+              prfEvalByCredIds.Length() == prfEvalByCredSecondMaybes.Length() &&
+              prfEvalByCredIds.Length() == prfEvalByCredSeconds.Length()) {
+            for (size_t i = 0; i < prfEvalByCredIds.Length(); i++) {
+              WEBAUTHN_HMAC_SECRET_SALT salt = {0};
+              salt.cbFirst = prfEvalByCredFirsts[i].Length();
+              salt.pbFirst = prfEvalByCredFirsts[i].Elements();
+              if (prfEvalByCredSecondMaybes[i]) {
+                salt.cbSecond = prfEvalByCredSeconds[i].Length();
+                salt.pbSecond = prfEvalByCredSeconds[i].Elements();
+              }
+              hmacSecretSalts.AppendElement(salt);
+            }
+            // The credWithHmacSecretSaltList array will contain raw pointers to
+            // elements of the hmacSecretSalts array, so we must not cause
+            // any re-allocations of hmacSecretSalts from this point.
+            for (size_t i = 0; i < prfEvalByCredIds.Length(); i++) {
+              WEBAUTHN_CRED_WITH_HMAC_SECRET_SALT value = {0};
+              value.cbCredID = prfEvalByCredIds[i].Length();
+              value.pbCredID = prfEvalByCredIds[i].Elements();
+              value.pHmacSecretSalt = &hmacSecretSalts[i];
+              credWithHmacSecretSaltList.AppendElement(value);
+            }
+            prfInputs.cCredWithHmacSecretSaltList =
+                credWithHmacSecretSaltList.Length();
+            prfInputs.pCredWithHmacSecretSaltList =
+                credWithHmacSecretSaltList.Elements();
+          }
+
+          pPrfInputs = &prfInputs;
+        }
+
+        // https://w3c.github.io/webauthn/#prf-extension
+        // "The hmac-secret extension provides two PRFs per credential: one
+        // which is used for requests where user verification is performed and
+        // another for all other requests. This extension [PRF] only exposes a
+        // single PRF per credential and, when implementing on top of
+        // hmac-secret, that PRF MUST be the one used for when user verification
+        // is performed. This overrides the UserVerificationRequirement if
+        // neccessary."
+        if (pPrfInputs &&
+            winUserVerificationReq ==
+                WEBAUTHN_USER_VERIFICATION_REQUIREMENT_DISCOURAGED) {
+          winUserVerificationReq =
+              WEBAUTHN_USER_VERIFICATION_REQUIREMENT_PREFERRED;
+        }
+
         // allow Credentials
         nsTArray<nsTArray<uint8_t>> allowList;
         nsTArray<uint8_t> allowListTransports;
@@ -801,14 +893,14 @@
                 &aCancellationId,  // CancellationId
                 pAllowCredentialList,
                 WEBAUTHN_CRED_LARGE_BLOB_OPERATION_NONE,
-                0,      // Size of CredLargeBlob
-                NULL,   // CredLargeBlob
-                NULL,   // HmacSecretSaltValues
-                FALSE,  // BrowserInPrivateMode
-                NULL,   // LinkedDevice
-                FALSE,  // AutoFill
-                0,      // Size of JsonExt
-                NULL,   // JsonExt
+                0,           // Size of CredLargeBlob
+                NULL,        // CredLargeBlob
+                pPrfInputs,  // HmacSecretSaltValues
+                FALSE,       // BrowserInPrivateMode
+                NULL,        // LinkedDevice
+                FALSE,       // AutoFill
+                0,           // Size of JsonExt
+                NULL,        // JsonExt
             };
 
         PWEBAUTHN_ASSERTION pWebAuthNAssertion = nullptr;
