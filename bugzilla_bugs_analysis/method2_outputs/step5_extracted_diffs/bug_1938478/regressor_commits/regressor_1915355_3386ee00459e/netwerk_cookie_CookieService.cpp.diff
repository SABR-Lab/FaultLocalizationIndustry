# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/CookieService.cpp
# Commit: 3386ee00459e
# Full Hash: 3386ee00459e09b085cec20f4c46064d75acb285
# Author: Tim Huang <tihuang@mozilla.com>
# Date: 2025-01-09 04:16:57
# Regressor Bug: 1915355
# File Overlap Count: 1
# Description:
#   Bug 1915355 - Part 7: Improve the performance of ThirdPartyCookieBlockingExceptions. r=valentin
#   
#   Apparently, suspending the channel before setting cookie headers will
#   impact performance. To improve the performance, this patch stops
#   suspending the channel while we checking the third-party cookie blocking
# ==============================================================================

diff -r 98848e63dfbf -r 3386ee00459e netwerk/cookie/CookieService.cpp
--- a/netwerk/cookie/CookieService.cpp	Wed Jan 08 19:26:00 2025 +0000
+++ b/netwerk/cookie/CookieService.cpp	Wed Jan 08 19:26:00 2025 +0000
@@ -261,6 +261,9 @@
   os->AddObserver(this, "profile-do-change", true);
   os->AddObserver(this, "last-pb-context-exited", true);
 
+  // Initialize the 3PCB exception service.
+  mThirdPartyCookieBlockingExceptions.Initialize();
+
   RunOnShutdown([self = RefPtr{this}] {
     self->mThirdPartyCookieBlockingExceptions.Shutdown();
   });
@@ -1744,12 +1747,15 @@
   nsCOMPtr<nsILoadInfo> loadInfo = aChannel->LoadInfo();
   RefPtr<CookieService> csSingleton = CookieService::GetSingleton();
 
-  // If the channel is a top-level loading, we start initiating the exception
-  // list service.
+  // Bail out if the channel is a top-level loading. The exception is only
+  // applicable to third-party loading.
   if (loadInfo->GetExternalContentPolicyType() ==
       ExtContentPolicy::TYPE_DOCUMENT) {
-    Unused
-        << csSingleton->mThirdPartyCookieBlockingExceptions.EnsureInitialized();
+    return;
+  }
+
+  // Bail out earlier if the 3PCB exception service is not initialized.
+  if (!csSingleton->mThirdPartyCookieBlockingExceptions.IsInitialized()) {
     return;
   }
 
@@ -1759,29 +1765,11 @@
     return;
   }
 
-  // Suspend the channel here. We will resume it after we check the exception
-  // list.
-  aChannel->Suspend();
+  bool isInExceptionList =
+      csSingleton->mThirdPartyCookieBlockingExceptions.CheckExceptionForChannel(
+          aChannel);
 
-  // It would be better to do this check with other checks that also suspend
-  // the channel, such as the URLClassifier.
-  csSingleton->mThirdPartyCookieBlockingExceptions.EnsureInitialized()->Then(
-      GetMainThreadSerialEventTarget(), __func__,
-      [channel = nsCOMPtr{aChannel}, csSingleton, loadInfo](
-          const GenericNonExclusivePromise::ResolveOrRejectValue& aValue) {
-        // We check the 3PCB exception list here. We will check both the
-        // wildcard exception and the specific exception. If any of them is in
-        // the exception list, we will set the channel's isOn3PCBExceptionList
-        // to true.
-        bool isInExceptionList =
-            csSingleton->mThirdPartyCookieBlockingExceptions
-                .CheckExceptionForChannel(channel);
-
-        Unused << loadInfo->SetIsOn3PCBExceptionList(isInExceptionList);
-
-        channel->Resume();
-        return NS_OK;
-      });
+  Unused << loadInfo->SetIsOn3PCBExceptionList(isInExceptionList);
 }
 
 NS_IMETHODIMP