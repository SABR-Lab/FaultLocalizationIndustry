# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/CookieService.cpp
# Commit: 913a7902cea4
# Full Hash: 913a7902cea491a530c9f6d6a72cc95d76a3e2a0
# Author: Tim Huang <tihuang@mozilla.com>
# Date: 2025-01-10 21:44:02
# Regressor Bug: 1915355
# File Overlap Count: 1
# Description:
#   Bug 1915355 - Part 7: Improve the performance of ThirdPartyCookieBlockingExceptions. r=valentin
#   
#   Apparently, suspending the channel before setting cookie headers will
#   impact performance. To improve the performance, this patch stops
#   suspending the channel while we checking the third-party cookie blocking
# ==============================================================================

diff -r 01daaabadcd7 -r 913a7902cea4 netwerk/cookie/CookieService.cpp
--- a/netwerk/cookie/CookieService.cpp	Fri Jan 10 08:24:30 2025 +0000
+++ b/netwerk/cookie/CookieService.cpp	Fri Jan 10 08:24:30 2025 +0000
@@ -260,10 +260,7 @@
   os->AddObserver(this, "profile-before-change", true);
   os->AddObserver(this, "profile-do-change", true);
   os->AddObserver(this, "last-pb-context-exited", true);
-
-  RunOnShutdown([self = RefPtr{this}] {
-    self->mThirdPartyCookieBlockingExceptions.Shutdown();
-  });
+  os->AddObserver(this, "browser-delayed-startup-finished", true);
 
   return NS_OK;
 }
@@ -331,6 +328,12 @@
     // ready for us if and when we switch back to it.
     InitCookieStorages();
 
+  } else if (!strcmp(aTopic, "browser-delayed-startup-finished")) {
+    mThirdPartyCookieBlockingExceptions.Initialize();
+
+    RunOnShutdown([self = RefPtr{this}] {
+      self->mThirdPartyCookieBlockingExceptions.Shutdown();
+    });
   } else if (!strcmp(aTopic, "last-pb-context-exited")) {
     // Flush all the cookies stored by private browsing contexts
     OriginAttributesPattern pattern;
@@ -1744,12 +1747,15 @@
   nsCOMPtr<nsILoadInfo> loadInfo = aChannel->LoadInfo();
   RefPtr<CookieService> csSingleton = CookieService::GetSingleton();
 
-  // If the channel is a top-level loading, we start initiating the exception
-  // list service.
+  // Bail out if the channel is a top-level loading. The exception is only
+  // applicable to third-party loading.
   if (loadInfo->GetExternalContentPolicyType() ==
       ExtContentPolicy::TYPE_DOCUMENT) {
-    Unused
-        << csSingleton->mThirdPartyCookieBlockingExceptions.EnsureInitialized();
+    return;
+  }
+
+  // Bail out earlier if the 3PCB exception service is not initialized.
+  if (!csSingleton->mThirdPartyCookieBlockingExceptions.IsInitialized()) {
     return;
   }
 
@@ -1759,29 +1765,11 @@
     return;
   }
 
-  // Suspend the channel here. We will resume it after we check the exception
-  // list.
-  aChannel->Suspend();
+  bool isInExceptionList =
+      csSingleton->mThirdPartyCookieBlockingExceptions.CheckExceptionForChannel(
+          aChannel);
 
-  // It would be better to do this check with other checks that also suspend
-  // the channel, such as the URLClassifier.
-  csSingleton->mThirdPartyCookieBlockingExceptions.EnsureInitialized()->Then(
-      GetMainThreadSerialEventTarget(), __func__,
-      [channel = nsCOMPtr{aChannel}, csSingleton, loadInfo](
-          const GenericNonExclusivePromise::ResolveOrRejectValue& aValue) {
-        // We check the 3PCB exception list here. We will check both the
-        // wildcard exception and the specific exception. If any of them is in
-        // the exception list, we will set the channel's isOn3PCBExceptionList
-        // to true.
-        bool isInExceptionList =
-            csSingleton->mThirdPartyCookieBlockingExceptions
-                .CheckExceptionForChannel(channel);
-
-        Unused << loadInfo->SetIsOn3PCBExceptionList(isInExceptionList);
-
-        channel->Resume();
-        return NS_OK;
-      });
+  Unused << loadInfo->SetIsOn3PCBExceptionList(isInExceptionList);
 }
 
 NS_IMETHODIMP