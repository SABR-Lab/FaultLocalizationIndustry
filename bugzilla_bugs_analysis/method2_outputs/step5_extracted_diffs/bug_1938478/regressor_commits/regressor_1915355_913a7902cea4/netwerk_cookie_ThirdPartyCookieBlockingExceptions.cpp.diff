# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/cookie/ThirdPartyCookieBlockingExceptions.cpp
# Commit: 913a7902cea4
# Full Hash: 913a7902cea491a530c9f6d6a72cc95d76a3e2a0
# Author: Tim Huang <tihuang@mozilla.com>
# Date: 2025-01-10 21:44:02
# Regressor Bug: 1915355
# File Overlap Count: 1
# Description:
#   Bug 1915355 - Part 7: Improve the performance of ThirdPartyCookieBlockingExceptions. r=valentin
#   
#   Apparently, suspending the channel before setting cookie headers will
#   impact performance. To improve the performance, this patch stops
#   suspending the channel while we checking the third-party cookie blocking
# ==============================================================================

diff -r 01daaabadcd7 -r 913a7902cea4 netwerk/cookie/ThirdPartyCookieBlockingExceptions.cpp
--- a/netwerk/cookie/ThirdPartyCookieBlockingExceptions.cpp	Fri Jan 10 08:24:30 2025 +0000
+++ b/netwerk/cookie/ThirdPartyCookieBlockingExceptions.cpp	Fri Jan 10 08:24:30 2025 +0000
@@ -10,50 +10,51 @@
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Promise-inl.h"
 #include "mozilla/dom/WindowGlobalParent.h"
+#include "mozilla/ErrorNames.h"
+#include "mozilla/Logging.h"
 
 #include "nsIChannel.h"
 
 namespace mozilla {
 namespace net {
 
-RefPtr<GenericNonExclusivePromise>
-ThirdPartyCookieBlockingExceptions::EnsureInitialized() {
-  if (mInitPromise) {
-    return mInitPromise;
+LazyLogModule g3PCBExceptionLog("3pcbexception");
+
+void ThirdPartyCookieBlockingExceptions::Initialize() {
+  if (mIsInitialized) {
+    return;
   }
 
   // Get the remote third-party cookie blocking exception list service instance.
   nsresult rv;
   m3PCBExceptionService = do_GetService(
       NS_NSITHIRDPARTYCOOKIEBLOCKINGEXCEPTIONLISTSERVICE_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv,
-                    GenericNonExclusivePromise::CreateAndReject(rv, __func__));
+  NS_ENSURE_SUCCESS_VOID(rv);
 
   RefPtr<mozilla::dom::Promise> initPromise;
   rv = m3PCBExceptionService->Init(getter_AddRefs(initPromise));
-  NS_ENSURE_SUCCESS(rv,
-                    GenericNonExclusivePromise::CreateAndReject(rv, __func__));
+  NS_ENSURE_SUCCESS_VOID(rv);
 
   // Bail out earlier if we don't have a init promise.
   if (!initPromise) {
-    return GenericNonExclusivePromise::CreateAndReject(rv, __func__);
+    MOZ_LOG(g3PCBExceptionLog, LogLevel::Error,
+            ("Failed to initialize 3PCB exception service: no init promise"));
+    return;
   }
 
-  mInitPromise = new GenericNonExclusivePromise::Private(__func__);
-
   initPromise->AddCallbacksWithCycleCollectedArgs(
       [&self = *this](JSContext*, JS::Handle<JS::Value>,
-                      mozilla::ErrorResult&) {
-        self.mInitPromise->Resolve(true, __func__);
-      },
-      [&self = *this](JSContext*, JS::Handle<JS::Value>,
-                      mozilla::ErrorResult& error) {
+                      mozilla::ErrorResult&) { self.mIsInitialized = true; },
+      [](JSContext*, JS::Handle<JS::Value>, mozilla::ErrorResult& error) {
         nsresult rv = error.StealNSResult();
-        self.mInitPromise->Reject(rv, __func__);
-        return;
+
+        nsAutoCString name;
+        GetErrorName(rv, name);
+
+        MOZ_LOG(
+            g3PCBExceptionLog, LogLevel::Error,
+            ("Failed to initialize 3PCB exception service: %s", name.get()));
       });
-
-  return mInitPromise;
 }
 
 void ThirdPartyCookieBlockingExceptions::Shutdown() {
@@ -62,11 +63,7 @@
     m3PCBExceptionService = nullptr;
   }
 
-  // Reject the init promise during the shutdown.
-  if (mInitPromise) {
-    mInitPromise->Reject(NS_ERROR_ABORT, __func__);
-    mInitPromise = nullptr;
-  }
+  mIsInitialized = false;
 }
 
 void ThirdPartyCookieBlockingExceptions::Insert(const nsACString& aException) {
@@ -99,6 +96,10 @@
   NS_ENSURE_TRUE(aFirstPartyURI, false);
   NS_ENSURE_TRUE(aThirdPartyURI, false);
 
+  if (!mIsInitialized) {
+    return false;
+  }
+
   RefPtr<nsEffectiveTLDService> eTLDService =
       nsEffectiveTLDService::GetInstance();
   NS_ENSURE_TRUE(eTLDService, false);
@@ -125,6 +126,10 @@
   MOZ_ASSERT(XRE_IsParentProcess());
   NS_ENSURE_TRUE(aChannel, false);
 
+  if (!mIsInitialized) {
+    return false;
+  }
+
   RefPtr<nsEffectiveTLDService> eTLDService =
       nsEffectiveTLDService::GetInstance();
   NS_ENSURE_TRUE(eTLDService, false);