# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerContainer.cpp
# Commit: 244df402d6eb
# Full Hash: 244df402d6ebc15d6845c4144245511021408835
# Author: Andrew Sutherland <asutherland@asutherland.org>
# Date: 2024-10-24 09:44:34
# Regressor Bug: 1131324
# File Overlap Count: 1
# Description:
#   Bug 1131324 - Expose ServiceWorkerContainer on WorkerNavigator. r=dom-worker-reviewers,webidl,smaug
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D213725
# ==============================================================================

diff -r 57f70ba5f27e -r 244df402d6eb dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp	Thu Oct 24 03:02:39 2024 +0000
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp	Thu Oct 24 03:02:40 2024 +0000
@@ -6,10 +6,8 @@
 
 #include "ServiceWorkerContainer.h"
 
-#include "nsContentPolicyUtils.h"
 #include "nsContentSecurityManager.h"
 #include "nsContentUtils.h"
-#include "mozilla/dom/Document.h"
 #include "nsIServiceWorkerManager.h"
 #include "nsIScriptError.h"
 #include "nsThreadUtils.h"
@@ -20,7 +18,7 @@
 #include "nsCycleCollectionParticipant.h"
 #include "nsGlobalWindowInner.h"
 #include "nsServiceManagerUtils.h"
-#include "mozilla/LoadInfo.h"
+#include "mozilla/BasePrincipal.h"
 #include "mozilla/SchedulerGroup.h"
 #include "mozilla/StaticPrefs_extensions.h"
 #include "mozilla/StaticPrefs_privacy.h"
@@ -167,36 +165,6 @@
   return ServiceWorkerContainer_Binding::Wrap(aCx, this, aGivenProto);
 }
 
-namespace {
-
-already_AddRefed<nsIURI> GetBaseURIFromGlobal(nsIGlobalObject* aGlobal,
-                                              ErrorResult& aRv) {
-  // It would be nice not to require a window here, but right
-  // now we don't have a great way to get the base URL just
-  // from the nsIGlobalObject.
-  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
-  if (!window) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  Document* doc = window->GetExtantDoc();
-  if (!doc) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  nsCOMPtr<nsIURI> baseURI = doc->GetDocBaseURI();
-  if (!baseURI) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  return baseURI.forget();
-}
-
-}  // anonymous namespace
-
 already_AddRefed<Promise> ServiceWorkerContainer::Register(
     const nsAString& aScriptURL, const RegistrationOptions& aOptions,
     const CallerType aCallerType, ErrorResult& aRv) {
@@ -217,8 +185,9 @@
     return nullptr;
   }
 
-  nsCOMPtr<nsIURI> baseURI = GetBaseURIFromGlobal(global, aRv);
-  if (aRv.Failed()) {
+  nsCOMPtr<nsIURI> baseURI = global->GetBaseURI();
+  if (!baseURI) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
@@ -288,48 +257,11 @@
   scopeURI = std::move(cloneWithoutRef);
 
   ServiceWorkerScopeAndScriptAreValid(clientInfo.ref(), scopeURI, scriptURI,
-                                      aRv);
+                                      aRv, global);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(global);
-  if (!window) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  Document* doc = window->GetExtantDoc();
-  if (!doc) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  // The next section of code executes an NS_CheckContentLoadPolicy()
-  // check.  This is necessary to enforce the CSP of the calling client.
-  // Currently this requires an Document.  Once bug 965637 lands we
-  // should try to move this into ServiceWorkerScopeAndScriptAreValid()
-  // using the ClientInfo instead of doing a window-specific check here.
-  // See bug 1455077 for further investigation.
-  nsCOMPtr<nsILoadInfo> secCheckLoadInfo = new mozilla::net::LoadInfo(
-      doc->NodePrincipal(),  // loading principal
-      doc->NodePrincipal(),  // triggering principal
-      doc,                   // loading node
-      nsILoadInfo::SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK,
-      nsIContentPolicy::TYPE_INTERNAL_SERVICE_WORKER);
-
-  // Check content policy.
-  int16_t decision = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentLoadPolicy(scriptURI, secCheckLoadInfo, &decision);
-  if (NS_FAILED(rv)) {
-    aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
-    return nullptr;
-  }
-  if (NS_WARN_IF(decision != nsIContentPolicy::ACCEPT)) {
-    aRv.Throw(NS_ERROR_CONTENT_BLOCKED);
-    return nullptr;
-  }
-
   // Get the string representation for both the script and scope since
   // we sanitized them above.
   nsCString cleanedScopeURL;
@@ -347,16 +279,21 @@
   // Verify that the global is valid and has permission to store
   // data.  We perform this late so that we can report the final
   // scope URL in any error message.
-  Unused << GetGlobalIfValid(aRv, [&](Document* aDoc) {
+  Unused << GetGlobalIfValid(aRv, [&](nsIGlobalObject* aGlobal) {
     AutoTArray<nsString, 1> param;
     CopyUTF8toUTF16(cleanedScopeURL, *param.AppendElement());
-    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
-                                    "Service Workers"_ns, aDoc,
-                                    nsContentUtils::eDOM_PROPERTIES,
-                                    "ServiceWorkerRegisterStorageError", param);
+    aGlobal->ReportToConsole(nsIScriptError::errorFlag, "Service Workers"_ns,
+                             nsContentUtils::eDOM_PROPERTIES,
+                             "ServiceWorkerRegisterStorageError"_ns, param);
   });
 
-  window->NoteCalledRegisterForServiceWorkerScope(cleanedScopeURL);
+  // TODO: For bug 1836707 we will move this tracking to ServiceWorkerManager
+  // where it can establish the mapping between the job and our client info,
+  // which will also work on workers.  For now we leave this notification for
+  // Windows only.
+  if (auto* window = global->GetAsInnerWindow()) {
+    window->NoteCalledRegisterForServiceWorkerScope(cleanedScopeURL);
+  }
 
   RefPtr<Promise> outer =
       Promise::Create(global, aRv, Promise::ePropagateUserInteraction);
@@ -419,11 +356,10 @@
 
 already_AddRefed<Promise> ServiceWorkerContainer::GetRegistrations(
     ErrorResult& aRv) {
-  nsIGlobalObject* global = GetGlobalIfValid(aRv, [](Document* aDoc) {
-    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
-                                    "Service Workers"_ns, aDoc,
-                                    nsContentUtils::eDOM_PROPERTIES,
-                                    "ServiceWorkerGetRegistrationStorageError");
+  nsIGlobalObject* global = GetGlobalIfValid(aRv, [](nsIGlobalObject* aGlobal) {
+    aGlobal->ReportToConsole(nsIScriptError::errorFlag, "Service Workers"_ns,
+                             nsContentUtils::eDOM_PROPERTIES,
+                             "ServiceWorkerGetRegistrationStorageError"_ns);
   });
   if (aRv.Failed()) {
     return nullptr;
@@ -505,11 +441,10 @@
 
 already_AddRefed<Promise> ServiceWorkerContainer::GetRegistration(
     const nsAString& aURL, ErrorResult& aRv) {
-  nsIGlobalObject* global = GetGlobalIfValid(aRv, [](Document* aDoc) {
-    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
-                                    "Service Workers"_ns, aDoc,
-                                    nsContentUtils::eDOM_PROPERTIES,
-                                    "ServiceWorkerGetRegistrationStorageError");
+  nsIGlobalObject* global = GetGlobalIfValid(aRv, [](nsIGlobalObject* aGlobal) {
+    aGlobal->ReportToConsole(nsIScriptError::errorFlag, "Service Workers"_ns,
+                             nsContentUtils::eDOM_PROPERTIES,
+                             "ServiceWorkerGetRegistrationStorageError"_ns);
   });
   if (aRv.Failed()) {
     return nullptr;
@@ -521,8 +456,8 @@
     return nullptr;
   }
 
-  nsCOMPtr<nsIURI> baseURI = GetBaseURIFromGlobal(global, aRv);
-  if (aRv.Failed()) {
+  nsCOMPtr<nsIURI> baseURI = global->GetBaseURI();
+  if (!baseURI) {
     return nullptr;
   }
 
@@ -706,46 +641,42 @@
 
 nsIGlobalObject* ServiceWorkerContainer::GetGlobalIfValid(
     ErrorResult& aRv,
-    const std::function<void(Document*)>&& aStorageFailureCB) const {
-  // For now we require a window since ServiceWorkerContainer is
-  // not exposed on worker globals yet.  The main thing we need
-  // to fix here to support that is the storage access check via
-  // the nsIGlobalObject.
-  nsGlobalWindowInner* window = GetOwnerWindow();
-  if (NS_WARN_IF(!window)) {
+    const std::function<void(nsIGlobalObject*)>&& aStorageFailureCB) const {
+  nsIGlobalObject* global = GetOwnerGlobal();
+  if (NS_WARN_IF(!global)) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  nsCOMPtr<Document> doc = window->GetExtantDoc();
-  if (NS_WARN_IF(!doc)) {
+  if (NS_FAILED(CheckCurrentGlobalCorrectness())) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
   // Don't allow a service worker to access service worker registrations
-  // from a window with storage disabled.  If these windows can access
+  // from a global with storage disabled.  If these globals can access
   // the registration it increases the chance they can bypass the storage
   // block via postMessage(), etc.
-  auto storageAllowed = StorageAllowedForWindow(window);
+  auto storageAllowed = global->GetStorageAccess();
   if (NS_WARN_IF(storageAllowed != StorageAccess::eAllow &&
                  (!StaticPrefs::privacy_partition_serviceWorkers() ||
-                  !StoragePartitioningEnabled(storageAllowed,
-                                              doc->CookieJarSettings())))) {
+                  !StoragePartitioningEnabled(
+                      storageAllowed, global->GetCookieJarSettings())))) {
     if (aStorageFailureCB) {
-      aStorageFailureCB(doc);
+      aStorageFailureCB(global);
     }
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return nullptr;
   }
 
-  // Don't allow service workers when the document is chrome.
-  if (NS_WARN_IF(doc->NodePrincipal()->IsSystemPrincipal())) {
+  // Don't allow service workers for system principals.
+  nsIPrincipal* principal = global->PrincipalOrNull();
+  if (NS_WARN_IF(!principal || principal->IsSystemPrincipal())) {
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return nullptr;
   }
 
-  return window->AsGlobal();
+  return global;
 }
 
 void ServiceWorkerContainer::EnqueueReceivedMessageDispatch(
@@ -770,7 +701,10 @@
 }
 
 void ServiceWorkerContainer::DispatchMessage(RefPtr<ReceivedMessage> aMessage) {
-  MOZ_ASSERT(NS_IsMainThread());
+  nsresult rv = CheckCurrentGlobalCorrectness();
+  if (NS_FAILED(rv)) {
+    return;
+  }
 
   // When dispatching a message, either DOMContentLoaded has already
   // been fired, or someone called startMessages() or set onmessage.