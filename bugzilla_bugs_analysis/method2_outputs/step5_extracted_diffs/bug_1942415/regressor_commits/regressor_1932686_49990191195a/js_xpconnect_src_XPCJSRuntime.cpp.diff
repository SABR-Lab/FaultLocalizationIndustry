# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/src/XPCJSRuntime.cpp
# Commit: 49990191195a
# Full Hash: 49990191195a650baeb77150e18916b4a998c49c
# Author: Denis Palmeiro <dpalmeiro@mozilla.com>
# Date: 2025-01-15 21:57:20
# Regressor Bug: 1932686
# File Overlap Count: 1
# Description:
#   Bug 1932686: Migrate boolean legacy GC metrics to glean using a labled_counter type.  r=jonco
#   
#   Depends on D231644
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231645
# ==============================================================================

diff -r ba8bd50a3a28 -r 49990191195a js/xpconnect/src/XPCJSRuntime.cpp
--- a/js/xpconnect/src/XPCJSRuntime.cpp	Wed Jan 15 15:30:15 2025 +0000
+++ b/js/xpconnect/src/XPCJSRuntime.cpp	Wed Jan 15 15:30:16 2025 +0000
@@ -2733,6 +2733,72 @@
       glean::javascript_gc::parallel_mark_interruptions.AccumulateSingleSample(
           sample);
       break;
+    case JSMetric::GC_IS_COMPARTMENTAL:
+      if (sample) {
+        glean::javascript_gc::is_zone_gc
+            .EnumGet(glean::javascript_gc::IsZoneGcLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::is_zone_gc
+            .EnumGet(glean::javascript_gc::IsZoneGcLabel::eFalse)
+            .Add(1);
+      }
+      break;
+    case JSMetric::GC_BUDGET_WAS_INCREASED:
+      if (sample) {
+        glean::javascript_gc::budget_was_increased
+            .EnumGet(glean::javascript_gc::BudgetWasIncreasedLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::budget_was_increased
+            .EnumGet(glean::javascript_gc::BudgetWasIncreasedLabel::eFalse)
+            .Add(1);
+      }
+      break;
+    case JSMetric::GC_SLICE_WAS_LONG:
+      if (sample) {
+        glean::javascript_gc::slice_was_long
+            .EnumGet(glean::javascript_gc::SliceWasLongLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::slice_was_long
+            .EnumGet(glean::javascript_gc::SliceWasLongLabel::eFalse)
+            .Add(1);
+      }
+      break;
+    case JSMetric::GC_RESET:
+      if (sample) {
+        glean::javascript_gc::reset
+            .EnumGet(glean::javascript_gc::ResetLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::reset
+            .EnumGet(glean::javascript_gc::ResetLabel::eFalse)
+            .Add(1);
+      }
+      break;
+    case JSMetric::GC_NON_INCREMENTAL:
+      if (sample) {
+        glean::javascript_gc::non_incremental
+            .EnumGet(glean::javascript_gc::NonIncrementalLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::non_incremental
+            .EnumGet(glean::javascript_gc::NonIncrementalLabel::eFalse)
+            .Add(1);
+      }
+      break;
+    case JSMetric::GC_PARALLEL_MARK:
+      if (sample) {
+        glean::javascript_gc::parallel_mark_used
+            .EnumGet(glean::javascript_gc::ParallelMarkUsedLabel::eTrue)
+            .Add(1);
+      } else {
+        glean::javascript_gc::parallel_mark_used
+            .EnumGet(glean::javascript_gc::ParallelMarkUsedLabel::eFalse)
+            .Add(1);
+      }
+      break;
 
     default:
       // The rest aren't relayed to Glean.
