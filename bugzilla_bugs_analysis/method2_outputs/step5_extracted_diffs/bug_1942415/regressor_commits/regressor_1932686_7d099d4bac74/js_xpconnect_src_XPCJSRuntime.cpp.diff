# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/xpconnect/src/XPCJSRuntime.cpp
# Commit: 7d099d4bac74
# Full Hash: 7d099d4bac7446d5bd798f813a2e78b1aefb1816
# Author: Denis Palmeiro <dpalmeiro@mozilla.com>
# Date: 2025-01-15 21:57:20
# Regressor Bug: 1932686
# File Overlap Count: 4
# Description:
#   Bug 1932686: Migrate enumeration legacy GC metrics to glean using a labeled counter. r=jonco,chutten
#   
#   Depends on D231645
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231646
# ==============================================================================

diff -r 49990191195a -r 7d099d4bac74 js/xpconnect/src/XPCJSRuntime.cpp
--- a/js/xpconnect/src/XPCJSRuntime.cpp	Wed Jan 15 15:30:16 2025 +0000
+++ b/js/xpconnect/src/XPCJSRuntime.cpp	Wed Jan 15 15:30:16 2025 +0000
@@ -2799,6 +2799,84 @@
             .Add(1);
       }
       break;
+    case JSMetric::GC_REASON_2: {
+      // Assert that every reason has an associated glean label.
+      static_assert(static_cast<uint8_t>(JS::GCReason::LAST_FIREFOX_REASON) ==
+                        static_cast<uint8_t>(
+                            glean::javascript_gc::ReasonLabel::e__Other__),
+                    "GC reason enum and glean::javascript_gc::reason labels do "
+                    "not match.");
+      MOZ_ASSERT(static_cast<JS::GCReason>(sample) <=
+                     JS::GCReason::LAST_FIREFOX_REASON,
+                 "Invalid GC Reason.");
+
+      nsAutoCString reason(
+          JS::ExplainGCReason(static_cast<JS::GCReason>(sample)));
+      glean::javascript_gc::reason.Get(reason).Add(1);
+    } break;
+    case JSMetric::GC_GLEAN_SLOW_PHASE: {
+      MOZ_ASSERT(sample < static_cast<uint32_t>(
+                              glean::javascript_gc::SlowPhaseLabel::e__Other__),
+                 "Phase does not exist in the slow_phase labels list.");
+      nsAutoCString phase(JS::GetGCPhaseName(sample));
+      glean::javascript_gc::slow_phase.Get(phase).Add(1);
+    } break;
+    case JSMetric::GC_GLEAN_SLOW_TASK: {
+      MOZ_ASSERT(sample < static_cast<uint32_t>(
+                              glean::javascript_gc::SlowTaskLabel::e__Other__),
+                 "Phase does not exist in the slow_task labels list.");
+      nsAutoCString phase(JS::GetGCPhaseName(sample));
+      glean::javascript_gc::slow_task.Get(phase).Add(1);
+    } break;
+    case JSMetric::GC_RESET_REASON: {
+      MOZ_ASSERT(
+          sample < static_cast<uint32_t>(
+                       glean::javascript_gc::ResetReasonLabel::e__Other__),
+          "Reason does not exist in the reset_reason labels list.");
+      nsAutoCString reason(JS::ExplainGCAbortReason(sample));
+      glean::javascript_gc::reset_reason.Get(reason).Add(1);
+    } break;
+    case JSMetric::GC_NON_INCREMENTAL_REASON: {
+      MOZ_ASSERT(
+          sample <
+              static_cast<uint32_t>(
+                  glean::javascript_gc::NonIncrementalReasonLabel::e__Other__),
+          "Reason does not exist in the non_incremental_reason labels list.");
+      nsAutoCString reason(JS::ExplainGCAbortReason(sample));
+      glean::javascript_gc::non_incremental_reason.Get(reason).Add(1);
+    } break;
+    case JSMetric::GC_MINOR_REASON: {
+      // Assert that every reason has an associated glean label.
+      static_assert(
+          static_cast<uint8_t>(JS::GCReason::LAST_FIREFOX_REASON) ==
+              static_cast<uint8_t>(
+                  glean::javascript_gc::MinorReasonLabel::e__Other__),
+          "GC reason enum and glean::javascript_gc::reason labels do not "
+          "match.");
+      MOZ_ASSERT(static_cast<JS::GCReason>(sample) <=
+                     JS::GCReason::LAST_FIREFOX_REASON,
+                 "Invalid GC Reason.");
+
+      nsAutoCString reason(
+          JS::ExplainGCReason(static_cast<JS::GCReason>(sample)));
+      glean::javascript_gc::minor_reason.Get(reason).Add(1);
+    } break;
+    case JSMetric::GC_MINOR_REASON_LONG: {
+      // Assert that every reason has an associated glean label.
+      static_assert(
+          static_cast<uint8_t>(JS::GCReason::LAST_FIREFOX_REASON) ==
+              static_cast<uint8_t>(
+                  glean::javascript_gc::MinorReasonLongLabel::e__Other__),
+          "GC reason enum and glean::javascript_gc::reason labels do not "
+          "match.");
+      MOZ_ASSERT(static_cast<JS::GCReason>(sample) <=
+                     JS::GCReason::LAST_FIREFOX_REASON,
+                 "Invalid GC Reason.");
+
+      nsAutoCString reason(
+          JS::ExplainGCReason(static_cast<JS::GCReason>(sample)));
+      glean::javascript_gc::minor_reason_long.Get(reason).Add(1);
+    } break;
 
     default:
       // The rest aren't relayed to Glean.
