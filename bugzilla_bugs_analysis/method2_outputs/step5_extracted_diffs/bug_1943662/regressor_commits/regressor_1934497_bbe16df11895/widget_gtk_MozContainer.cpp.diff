# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/MozContainer.cpp
# Commit: bbe16df11895
# Full Hash: bbe16df11895cded54872efe6ef6d880eefeb9f3
# Author: stransky <stransky@redhat.com>
# Date: 2024-12-10 16:36:00
# Regressor Bug: 1934497
# File Overlap Count: 2
# Description:
#   Bug 1934497 [Wayland] Move wl_surface management from MozContainerWayland to WaylandSurface and reference it from MozContainerWayland r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D230850
# ==============================================================================

diff -r d6e7e274dda3 -r bbe16df11895 widget/gtk/MozContainer.cpp
--- a/widget/gtk/MozContainer.cpp	Tue Dec 10 07:12:51 2024 +0000
+++ b/widget/gtk/MozContainer.cpp	Tue Dec 10 07:12:52 2024 +0000
@@ -34,6 +34,7 @@
                                         GtkAllocation* allocation);
 static void moz_container_realize(GtkWidget* widget);
 static void moz_container_unrealize(GtkWidget* widget);
+static void moz_container_destroy(GtkWidget* widget);
 
 /* public methods */
 
@@ -62,26 +63,19 @@
   return moz_container_type;
 }
 
-GtkWidget* moz_container_new(void) {
+GtkWidget* moz_container_new(void* aWindow, RefPtr<WaylandSurface> aSurface) {
   MozContainer* container;
-
   container =
       static_cast<MozContainer*>(g_object_new(MOZ_CONTAINER_TYPE, nullptr));
-
+#ifdef MOZ_WAYLAND
+  if (aSurface) {
+    container->wl = new MozContainerWayland(aSurface);
+    MOZ_WL_CONTAINER(container)->mSurface->SetLoggingWidget(aWindow);
+  }
+#endif
   return GTK_WIDGET(container);
 }
 
-static void moz_container_destroy(GtkWidget* widget) {
-  auto* container = MOZ_CONTAINER(widget);
-  if (container->destroyed) {
-    return;  // The destroy signal may run multiple times.
-  }
-  LOGCONTAINER(("moz_container_destroy() [%p]\n",
-                (void*)moz_container_get_nsWindow(MOZ_CONTAINER(widget))));
-  container->destroyed = TRUE;
-  container->data.~Data();
-}
-
 void moz_container_class_init(MozContainerClass* klass) {
   /*GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
     GtkObjectClass *object_class = GTK_OBJECT_CLASS (klass); */
@@ -107,12 +101,29 @@
 }
 
 void moz_container_init(MozContainer* container) {
+  LOGCONTAINER(("%s", __FUNCTION__));
   container->destroyed = FALSE;
-  new (&container->data) MozContainer::Data();
+#ifdef MOZ_WAYLAND
+  container->wl = nullptr;
+#endif
   gtk_widget_set_can_focus(GTK_WIDGET(container), TRUE);
   gtk_widget_set_redraw_on_allocate(GTK_WIDGET(container), FALSE);
-  LOGCONTAINER(("%s [%p]\n", __FUNCTION__,
-                (void*)moz_container_get_nsWindow(container)));
+}
+
+static void moz_container_destroy(GtkWidget* widget) {
+  auto* container = MOZ_CONTAINER(widget);
+  if (container->destroyed) {
+    return;  // The destroy signal may run multiple times.
+  }
+  LOGCONTAINER(("moz_container_destroy() [%p]\n",
+                (void*)moz_container_get_nsWindow(MOZ_CONTAINER(widget))));
+  container->destroyed = TRUE;
+#ifdef MOZ_WAYLAND
+  if (container->wl) {
+    delete container->wl;
+    container->wl = nullptr;
+  }
+#endif
 }
 
 void moz_container_map(GtkWidget* widget) {
@@ -229,5 +240,3 @@
   gpointer user_data = g_object_get_data(G_OBJECT(container), "nsWindow");
   return static_cast<nsWindow*>(user_data);
 }
-
-#undef LOGCONTAINER