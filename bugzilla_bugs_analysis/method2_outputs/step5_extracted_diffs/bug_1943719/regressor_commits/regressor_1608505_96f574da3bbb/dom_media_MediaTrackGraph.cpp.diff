# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/MediaTrackGraph.cpp
# Commit: 96f574da3bbb
# Full Hash: 96f574da3bbbaa7c7d5f5000f1f99fd3efb11967
# Author: Paul Adenot <paul@paul.cx>
# Date: 2020-01-24 03:50:24
# Regressor Bug: 1608505
# File Overlap Count: 1
# Description:
#   Bug 1608505 - Cap the audio output channel count to something the device can handle. r=achronop
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D60549
# ==============================================================================

diff -r 9fb3bfa5ea09 -r 96f574da3bbb dom/media/MediaTrackGraph.cpp
--- a/dom/media/MediaTrackGraph.cpp	Thu Jan 23 15:51:22 2020 +0000
+++ b/dom/media/MediaTrackGraph.cpp	Thu Jan 23 15:18:43 2020 +0000
@@ -880,6 +880,11 @@
   }
 }
 
+void MediaTrackGraphImpl::SetMaxOutputChannelCount(uint32_t aMaxChannelCount) {
+  MOZ_ASSERT(OnGraphThread());
+  mMaxOutputChannelCount = aMaxChannelCount;
+}
+
 void MediaTrackGraphImpl::DeviceChanged() {
   // This is safe to be called from any thread: this message comes from an
   // underlying platform API, and we don't have much guarantees. If it is not
@@ -917,6 +922,33 @@
   MOZ_ASSERT(NS_IsMainThread());
   mAudioOutputLatency = 0.0;
 
+  // Dispatch to the bg thread to do the (potentially expensive) query of the
+  // maximum channel count, and then dispatch back to the main thread, then to
+  // the graph, with the new info.
+  NS_DispatchBackgroundTask(NS_NewRunnableFunction(
+      "MaxChannelCountUpdateOnBgThread", [self{std::move(this)}]() {
+        uint32_t maxChannelCount = CubebUtils::MaxNumberOfChannels();
+        self->Dispatch(NS_NewRunnableFunction(
+            "MaxChannelCountUpdateToMainThread",
+            [self{self}, maxChannelCount]() {
+              class MessageToGraph : public ControlMessage {
+               public:
+                explicit MessageToGraph(MediaTrackGraph* aGraph,
+                                        uint32_t aMaxChannelCount)
+                    : ControlMessage(nullptr),
+                      mGraphImpl(static_cast<MediaTrackGraphImpl*>(aGraph)),
+                      mMaxChannelCount(aMaxChannelCount) {}
+                void Run() override {
+                  mGraphImpl->SetMaxOutputChannelCount(mMaxChannelCount);
+                }
+                MediaTrackGraphImpl* mGraphImpl;
+                uint32_t mMaxChannelCount;
+              };
+              self->AppendMessage(
+                  MakeUnique<MessageToGraph>(self, maxChannelCount));
+            }));
+      }));
+
   AppendMessage(MakeUnique<Message>(this));
 }
 
@@ -2933,7 +2965,8 @@
 #endif
       ,
       mMainThreadGraphTime(0, "MediaTrackGraphImpl::mMainThreadGraphTime"),
-      mAudioOutputLatency(0.0) {
+      mAudioOutputLatency(0.0),
+      mMaxOutputChannelCount(std::min(8u, CubebUtils::MaxNumberOfChannels())) {
   if (aRunTypeRequested == SINGLE_THREAD && !mGraphRunner) {
     // Failed to create thread.  Jump to the last phase of the lifecycle.
     mLifecycleState = LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION;
@@ -3546,7 +3579,8 @@
 uint32_t MediaTrackGraphImpl::AudioOutputChannelCount() const {
   MOZ_ASSERT(OnGraphThread());
   // The audio output channel count for a graph is the maximum of the output
-  // channel count of all the tracks that are in mAudioOutputs.
+  // channel count of all the tracks that are in mAudioOutputs, or the max audio
+  // output channel count the machine can do, whichever is smaller.
   uint32_t channelCount = 0;
   for (auto& tkv : mAudioOutputs) {
     MediaTrack* t = tkv.mTrack;
@@ -3560,6 +3594,7 @@
           std::max<uint32_t>(channelCount, segment->MaxChannelCount());
     }
   }
+  channelCount = std::min(channelCount, mMaxOutputChannelCount);
   if (channelCount) {
     return channelCount;
   } else {