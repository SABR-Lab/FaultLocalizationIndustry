# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandBuffer.cpp
# Commit: 2606acece21a
# Full Hash: 2606acece21a9b38428387d6d19d9c15e9619375
# Author: stransky <stransky@redhat.com>
# Date: 2025-01-24 21:02:20
# Regressor Bug: 1942232
# File Overlap Count: 1
# Description:
#   Bug 1942232 [Wayland] Make WaylandBuffer release more robust r=emilio
#   
#   Split WaylandBuffer attached state to two components:
#     - Attached to WaylandSurface is tracked by mAttachedToSurface direct reference to WaylandSurface.
#     - Attached to Wayland compositor (i.e. used by GPU) is tracked mIsAttachedToCompositor boolean flag.
# ==============================================================================

diff -r 3c7074274bf7 -r 2606acece21a widget/gtk/WaylandBuffer.cpp
--- a/widget/gtk/WaylandBuffer.cpp	Fri Jan 24 11:53:47 2025 +0000
+++ b/widget/gtk/WaylandBuffer.cpp	Fri Jan 24 12:11:20 2025 +0000
@@ -89,23 +89,39 @@
 
 WaylandBuffer::WaylandBuffer(const LayoutDeviceIntSize& aSize) : mSize(aSize) {}
 
-wl_buffer* WaylandBuffer::BorrowBuffer(RefPtr<WaylandSurface> aWaylandSurface) {
-  MOZ_RELEASE_ASSERT(!mSurface, "We're already attached!");
+bool WaylandBuffer::IsAttachedToSurface(WaylandSurface* aWaylandSurface) {
+  MutexAutoLock lock(mMutex);
+  return mAttachedToSurface == aWaylandSurface;
+}
+
+wl_buffer* WaylandBuffer::BorrowBuffer(WaylandSurfaceLock& aSurfaceLock) {
+  MutexAutoLock lock(mMutex);
+
+  LOGWAYLAND(
+      "WaylandBuffer::BorrowBuffer() [%p] WaylandSurface [%p] wl_buffer [%p]",
+      (void*)this,
+      mAttachedToSurface ? mAttachedToSurface->GetLoggingWidget() : nullptr,
+      mWLBuffer);
+
+  MOZ_RELEASE_ASSERT(!mAttachedToSurface, "We're already attached!");
+  MOZ_DIAGNOSTIC_ASSERT(!mBufferDeleteSyncCallback, "We're already deleted!?");
 
   if (CreateWlBuffer()) {
-    mSurface = std::move(aWaylandSurface);
+    mAttachedToSurface = aSurfaceLock.GetWaylandSurface();
   }
 
   LOGWAYLAND(
       "WaylandBuffer::BorrowBuffer() [%p] WaylandSurface [%p] wl_buffer [%p]",
-      (void*)this, mSurface ? mSurface->GetLoggingWidget() : nullptr,
+      (void*)this,
+      mAttachedToSurface ? mAttachedToSurface->GetLoggingWidget() : nullptr,
       mWLBuffer);
 
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete(), "We're already deleted!");
   return mWLBuffer;
 }
 
 void WaylandBuffer::DeleteWlBuffer() {
+  mMutex.AssertCurrentThreadOwns();
+
   if (!mWLBuffer) {
     return;
   }
@@ -114,34 +130,70 @@
   MozClearPointer(mWLBuffer, wl_buffer_destroy);
 }
 
+void WaylandBuffer::BufferDeletedCallbackHandler() {
+  RefPtr<WaylandSurface> surface;
+
+  // Don't take mBufferReleaseMutex and mSurface locks together,
+  // may lead to deadlock.
+  {
+    MutexAutoLock lock(mMutex);
+
+    // BufferDeletedCallbackHandler() should be caled by Wayland compostor
+    // on main thread only.
+    AssertIsOnMainThread();
+
+    LOGWAYLAND(
+        "WaylandBuffer::BufferDeletedCallbackHandler() [%p] WaylandSurface "
+        "[%p]",
+        (void*)this,
+        mAttachedToSurface ? mAttachedToSurface->GetLoggingWidget() : nullptr);
+
+    MOZ_DIAGNOSTIC_ASSERT(mBufferDeleteSyncCallback);
+    MOZ_DIAGNOSTIC_ASSERT(mAttachedToSurface);
+    mBufferDeleteSyncCallback = nullptr;
+
+    // Clear surface reference so WaylandBuffer is marked as not attached now.
+    surface = std::move(mAttachedToSurface);
+  }
+
+  // Notify WaylandSurface we're detached by Wayland compositor
+  // so it can clear reference to us.
+  WaylandSurfaceLock surfaceLock(surface);
+  surface->UntrackWaylandBufferLocked(surfaceLock, this);
+}
+
 static void BufferDeleteSyncFinished(void* aData, struct wl_callback* callback,
                                      uint32_t time) {
   LOGWAYLAND("BufferDeleteSyncFinished() [%p]", aData);
   RefPtr buffer = already_AddRefed(static_cast<WaylandBuffer*>(aData));
   // wl_buffer should be already deleted on our side.
-  buffer->BufferDetachedCallbackHandler(nullptr, /* aWlBufferDeleted */ true);
+  buffer->BufferDeletedCallbackHandler();
 }
 
 static const struct wl_callback_listener sBufferDeleteSyncListener = {
     .done = BufferDeleteSyncFinished,
 };
 
-void WaylandBuffer::ReturnBuffer(RefPtr<WaylandSurface> aWaylandSurface) {
+void WaylandBuffer::ReturnBuffer(WaylandSurfaceLock& aSurfaceLock) {
+  MutexAutoLock lock(mMutex);
+
   LOGWAYLAND("WaylandBuffer::ReturnBuffer() [%p] WaylandSurface [%p]",
-             (void*)this, mSurface.get());
+             (void*)this, mAttachedToSurface.get());
 
-  MutexAutoLock lock(mBufferReleaseMutex);
-  MOZ_RELEASE_ASSERT(aWaylandSurface == mSurface || !mSurface);
-
-  if (mBufferDeleteSyncCallback) {
-    MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
-    return;
-  }
+  MOZ_RELEASE_ASSERT(aSurfaceLock.GetWaylandSurface() == mAttachedToSurface ||
+                     !mAttachedToSurface);
+  MOZ_DIAGNOSTIC_ASSERT(!mBufferDeleteSyncCallback,
+                        "Buffer is already returned?");
+  MOZ_DIAGNOSTIC_ASSERT(mWLBuffer);
 
   DeleteWlBuffer();
 
-  // We're already detached from WaylandSurface
-  if (!mSurface) {
+  if (!mIsAttachedToCompositor) {
+    // We don't need to run synced delete - wl_buffer it already detached
+    // from compositor so we can't get any wl_buffer_release event
+    // and we're free to release this.
+    RefPtr surface = std::move(mAttachedToSurface);
+    surface->UntrackWaylandBufferLocked(aSurfaceLock, this);
     return;
   }
 
@@ -163,60 +215,25 @@
                            &sBufferDeleteSyncListener, this);
 }
 
-void WaylandBuffer::BufferDetachedCallbackHandler(wl_buffer* aBuffer,
-                                                  bool aWlBufferDeleted) {
-  LOGWAYLAND(
-      "WaylandBuffer::BufferDetachedCallbackHandler() [%p] WaylandSurface [%p] "
-      "aBuffer [%p] aWlBufferDeleted %d GetWlBuffer() [%p]",
-      (void*)this, mSurface ? mSurface->GetLoggingWidget() : nullptr, aBuffer,
-      aWlBufferDeleted, GetWlBuffer());
+void WaylandBuffer::BufferDetachedCallbackHandler(wl_buffer* aBuffer) {
+  MutexAutoLock lock(mMutex);
+
+  LOGWAYLAND("WaylandBuffer::BufferDetachedCallbackHandler() [%p] aBuffer [%p]",
+             (void*)this, aBuffer);
+
+  MOZ_DIAGNOSTIC_ASSERT(aBuffer == mWLBuffer, "Different buffer released?");
 
   // BufferDetachedCallbackHandler() should be caled by Wayland compostor
   // on main thread only.
   AssertIsOnMainThread();
-
-  // aWlBufferDeleted means wl_buffer should be nullptr
-  MOZ_DIAGNOSTIC_ASSERT(!aBuffer == aWlBufferDeleted);
-
-  RefPtr<WaylandSurface> surface;
-
-  // Don't take mBufferReleaseMutex and mSurface locks together,
-  // may lead to deadlock.
-  {
-    MutexAutoLock lock(mBufferReleaseMutex);
-
-    // We should release correct buffer.
-    // If GetWlBuffer() is nullptr (deleted) we should have valid delete
-    // callback.
-    MOZ_DIAGNOSTIC_ASSERT(aBuffer == GetWlBuffer() ||
-                          (!GetWlBuffer() && mBufferDeleteSyncCallback));
-
-    if (aWlBufferDeleted) {
-      MOZ_DIAGNOSTIC_ASSERT(mBufferDeleteSyncCallback);
-      mBufferDeleteSyncCallback = nullptr;
-    }
-
-    // We might be unreffed by previous BufferDetachedCallbackHandler() callback
-    // as it's called for both wl_buffer delete and wl_buffer detach events.
-    if (!mSurface) {
-      return;
-    }
-
-    // Clear surface reference so WaylandBuffer is marked as not attached now.
-    surface = std::move(mSurface);
-  }
-
-  // Notify WaylandSurface we're detached by Wayland compositor
-  // so it can clear reference to us.
-  WaylandSurfaceLock surfaceLock(surface);
-  surface->DetachedByWaylandCompositorLocked(surfaceLock, this);
+  mIsAttachedToCompositor = false;
 }
 
 static void BufferDetachedCallbackHandler(void* aData, wl_buffer* aBuffer) {
   LOGWAYLAND("BufferDetachedCallbackHandler() [%p] received wl_buffer [%p]",
              aData, aBuffer);
   RefPtr<WaylandBuffer> buffer = static_cast<WaylandBuffer*>(aData);
-  buffer->BufferDetachedCallbackHandler(aBuffer, /* aWlBufferDeleted */ false);
+  buffer->BufferDetachedCallbackHandler(aBuffer);
 }
 
 static const struct wl_buffer_listener sBufferDetachListener = {
@@ -245,6 +262,8 @@
 }
 
 bool WaylandBufferSHM::CreateWlBuffer() {
+  mMutex.AssertCurrentThreadOwns();
+
   if (mWLBuffer) {
     return true;
   }
@@ -273,12 +292,9 @@
 
 WaylandBufferSHM::~WaylandBufferSHM() {
   LOGWAYLAND("WaylandBufferSHM::~WaylandBufferSHM() [%p]\n", (void*)this);
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete());
-  MOZ_DIAGNOSTIC_ASSERT(!IsAttached());
-  if (!IsAttached()) {
-    DeleteWlBuffer();
-  }
-  MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
+  MOZ_RELEASE_ASSERT(!mBufferDeleteSyncCallback);
+  MOZ_RELEASE_ASSERT(!IsAttached());
+  MOZ_DIAGNOSTIC_ASSERT(!mWLBuffer);
 }
 
 already_AddRefed<gfx::DrawTarget> WaylandBufferSHM::Lock() {
@@ -358,8 +374,9 @@
 }
 
 bool WaylandBufferDMABUF::CreateWlBuffer() {
+  mMutex.AssertCurrentThreadOwns();
+
   MOZ_DIAGNOSTIC_ASSERT(mDMABufSurface);
-
   if (mWLBuffer) {
     return true;
   }
@@ -389,12 +406,9 @@
 WaylandBufferDMABUF::~WaylandBufferDMABUF() {
   LOGWAYLAND("WaylandBufferDMABUF::~WaylandBufferDMABUF [%p] UID %d\n",
              (void*)this, mDMABufSurface ? mDMABufSurface->GetUID() : -1);
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete());
-  MOZ_DIAGNOSTIC_ASSERT(!IsAttached());
-  if (!IsAttached()) {
-    DeleteWlBuffer();
-  }
-  MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
+  MOZ_RELEASE_ASSERT(!mBufferDeleteSyncCallback);
+  MOZ_RELEASE_ASSERT(!IsAttached());
+  MOZ_DIAGNOSTIC_ASSERT(!mWLBuffer);
 }
 
 }  // namespace mozilla::widget