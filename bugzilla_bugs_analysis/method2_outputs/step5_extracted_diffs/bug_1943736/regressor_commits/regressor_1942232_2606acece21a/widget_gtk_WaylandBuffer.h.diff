# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandBuffer.h
# Commit: 2606acece21a
# Full Hash: 2606acece21a9b38428387d6d19d9c15e9619375
# Author: stransky <stransky@redhat.com>
# Date: 2025-01-24 21:02:20
# Regressor Bug: 1942232
# File Overlap Count: 1
# Description:
#   Bug 1942232 [Wayland] Make WaylandBuffer release more robust r=emilio
#   
#   Split WaylandBuffer attached state to two components:
#     - Attached to WaylandSurface is tracked by mAttachedToSurface direct reference to WaylandSurface.
#     - Attached to Wayland compositor (i.e. used by GPU) is tracked mIsAttachedToCompositor boolean flag.
# ==============================================================================

diff -r 3c7074274bf7 -r 2606acece21a widget/gtk/WaylandBuffer.h
--- a/widget/gtk/WaylandBuffer.h	Fri Jan 24 11:53:47 2025 +0000
+++ b/widget/gtk/WaylandBuffer.h	Fri Jan 24 12:11:20 2025 +0000
@@ -52,31 +52,29 @@
   virtual void DestroyGLResources() {};
   virtual gfx::SurfaceFormat GetSurfaceFormat() = 0;
 
-  LayoutDeviceIntSize GetSize() { return mSize; };
-  bool IsMatchingSize(const LayoutDeviceIntSize& aSize) {
+  LayoutDeviceIntSize GetSize() const { return mSize; };
+  bool IsMatchingSize(const LayoutDeviceIntSize& aSize) const {
     return aSize == mSize;
   }
 
-  bool IsAttached() { return !!mSurface; }
+  bool IsAttached() { return mIsAttachedToCompositor; }
+
+  bool IsAttachedToSurface(WaylandSurface* aWaylandSurface);
 
   // Lend wl_buffer to WaylandSurface to attach.
-  // We store reference to WaylandSurface unless we don't have
-  // wl_buffer available.
-  //
-  // At also marks buffer as attached.
-  wl_buffer* BorrowBuffer(RefPtr<WaylandSurface> aWaylandSurface);
+  wl_buffer* BorrowBuffer(WaylandSurfaceLock& aSurfaceLock);
 
-  // Return lended buffer, called by aWaylandSurface.
-  void ReturnBuffer(RefPtr<WaylandSurface> aWaylandSurface);
+  // Return lended buffer, called by WaylandSurface when it's unmapped or
+  // a different buffer is attached.
+  void ReturnBuffer(WaylandSurfaceLock& aSurfaceLock);
 
-  // Called by Wayland compostor when buffer is released/deleted by
+  // Called by Wayland compostor when buffer is detached by
+  // Wayland compostor (free to reuse).
+  void BufferDetachedCallbackHandler(wl_buffer* aBuffer);
+
+  // Called by Wayland compostor when buffer is deleted by
   // Wayland compostor.
-  //
-  // There are two cases how buffer can be detached:
-  // 1) detach call from Wayland compostor, wl_buffer may be kept around.
-  // 2) detach from WaylandSurface - internal wl_buffer is deleted,
-  //    for instance on Unmap when wl_surface becomes invisible.
-  void BufferDetachedCallbackHandler(wl_buffer* aBuffer, bool aWlBufferDeleted);
+  void BufferDeletedCallbackHandler();
 
  protected:
   explicit WaylandBuffer(const LayoutDeviceIntSize& aSize);
@@ -89,25 +87,29 @@
   // memory, doesn't affect actual buffer content but only connection
   // to Wayland compositor.
   void DeleteWlBuffer();
-  wl_buffer* GetWlBuffer() { return mWLBuffer; }
-  bool HasWlBuffer() { return !!mWLBuffer; }
-
-  bool IsWaitingToBufferDelete() const { return !!mBufferDeleteSyncCallback; }
 
   // We need to protect buffer release sequence as it can happen
   // from Main thread (Wayland compositor) and Rendering thread.
-  mozilla::Mutex mBufferReleaseMutex{"WaylandBufferRelease"};
+  mozilla::Mutex mMutex{"WaylandBuffer"};
 
   // wl_buffer delete is not atomic, we need to wait until it's finished.
-  wl_callback* mBufferDeleteSyncCallback = nullptr;
+  wl_callback* mBufferDeleteSyncCallback MOZ_GUARDED_BY(mMutex) = nullptr;
 
   // wl_buffer is a wayland object that encapsulates the shared/dmabuf memory
   // and passes it to wayland compositor by wl_surface object.
-  wl_buffer* mWLBuffer = nullptr;
+  wl_buffer* mWLBuffer MOZ_GUARDED_BY(mMutex) = nullptr;
+
+  // Wayland buffer is tied to WaylandSurface.
+  // We keep reference to WaylandSurface until WaylandSurface returns the
+  // buffer.
+  RefPtr<WaylandSurface> mAttachedToSurface MOZ_GUARDED_BY(mMutex);
 
   LayoutDeviceIntSize mSize;
-  // WaylandSurface where we're attached to.
-  RefPtr<WaylandSurface> mSurface;
+
+  // Indicates that wl_buffer is actively used by Wayland compositor.
+  // We can't delete such wl_buffer.
+  mozilla::Atomic<bool, mozilla::Relaxed> mIsAttachedToCompositor{false};
+
   static gfx::SurfaceFormat sFormat;
 };
 
@@ -125,8 +127,8 @@
   }
 
   void Clear();
-  size_t GetBufferAge() { return mBufferAge; };
-  RefPtr<WaylandShmPool> GetShmPool() { return mShmPool; }
+  size_t GetBufferAge() const { return mBufferAge; };
+  RefPtr<WaylandShmPool> GetShmPool() const { return mShmPool; }
 
   void IncrementBufferAge() { mBufferAge++; };
   void ResetBufferAge() { mBufferAge = 0; };
