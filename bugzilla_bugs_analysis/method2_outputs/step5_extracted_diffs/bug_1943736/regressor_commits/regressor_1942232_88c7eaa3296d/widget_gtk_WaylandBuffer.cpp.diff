# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandBuffer.cpp
# Commit: 88c7eaa3296d
# Full Hash: 88c7eaa3296d009a32b65fe732678c6b55f4c01d
# Author: stransky <stransky@redhat.com>
# Date: 2025-02-05 16:56:59
# Regressor Bug: 1942232
# File Overlap Count: 1
# Description:
#   Bug 1942232 [Wayland] Detach and Release WaylandBuffer through WaylandSurface only r=emilio
#   
#   WaylandBuffer detach/release can happen on various thread and races with WaylandSurface access to WaylandBuffer.
#   To ensure WaylandSurface/WaylandBuffer consistent state, manage WaylandBuffer via. WaylandSurface only.
#   Register all async callbacks to WaylandSurface and use WaylandSurfaceLock to access WaylandBuffer.
# ==============================================================================

diff -r bd5cfbdb02b0 -r 88c7eaa3296d widget/gtk/WaylandBuffer.cpp
--- a/widget/gtk/WaylandBuffer.cpp	Wed Feb 05 11:41:26 2025 +0000
+++ b/widget/gtk/WaylandBuffer.cpp	Wed Feb 05 11:41:26 2025 +0000
@@ -89,19 +89,33 @@
 
 WaylandBuffer::WaylandBuffer(const LayoutDeviceIntSize& aSize) : mSize(aSize) {}
 
-wl_buffer* WaylandBuffer::BorrowBuffer(RefPtr<WaylandSurface> aWaylandSurface) {
-  MOZ_RELEASE_ASSERT(!mSurface, "We're already attached!");
+bool WaylandBuffer::IsAttachedToSurface(WaylandSurface* aWaylandSurface) {
+  return mAttachedToSurface == aWaylandSurface;
+}
 
-  if (CreateWlBuffer()) {
-    mSurface = std::move(aWaylandSurface);
+wl_buffer* WaylandBuffer::BorrowBuffer(WaylandSurfaceLock& aSurfaceLock) {
+  LOGWAYLAND(
+      "WaylandBuffer::BorrowBuffer() [%p] WaylandSurface [%p] wl_buffer [%p]",
+      (void*)this,
+      mAttachedToSurface ? mAttachedToSurface->GetLoggingWidget() : nullptr,
+      mWLBuffer);
+
+  MOZ_RELEASE_ASSERT(!mAttachedToSurface && !mIsAttachedToCompositor,
+                     "We're already attached!");
+  MOZ_DIAGNOSTIC_ASSERT(!mBufferDeleteSyncCallback, "We're already deleted!?");
+
+  if (!CreateWlBuffer()) {
+    return nullptr;
   }
 
+  mAttachedToSurface = aSurfaceLock.GetWaylandSurface();
+
   LOGWAYLAND(
       "WaylandBuffer::BorrowBuffer() [%p] WaylandSurface [%p] wl_buffer [%p]",
-      (void*)this, mSurface ? mSurface->GetLoggingWidget() : nullptr,
+      (void*)this,
+      mAttachedToSurface ? mAttachedToSurface->GetLoggingWidget() : nullptr,
       mWLBuffer);
 
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete(), "We're already deleted!");
   return mWLBuffer;
 }
 
@@ -114,36 +128,67 @@
   MozClearPointer(mWLBuffer, wl_buffer_destroy);
 }
 
+void WaylandBuffer::ReturnBufferDetached(WaylandSurfaceLock& aSurfaceLock) {
+  LOGWAYLAND("WaylandBuffer::ReturnBufferDetached() [%p] WaylandSurface [%p]",
+             (void*)this, mAttachedToSurface.get());
+  MOZ_DIAGNOSTIC_ASSERT(aSurfaceLock.GetWaylandSurface() == mAttachedToSurface);
+  DeleteWlBuffer();
+  mIsAttachedToCompositor = false;
+  mAttachedToSurface = nullptr;
+}
+
+struct SurfaceAndBuffer {
+  SurfaceAndBuffer(WaylandSurface* aSurface, WaylandBuffer* aBuffer)
+      : mSurface(aSurface), mBuffer(aBuffer) {};
+
+  RefPtr<WaylandSurface> mSurface;
+  RefPtr<WaylandBuffer> mBuffer;
+};
+
 static void BufferDeleteSyncFinished(void* aData, struct wl_callback* callback,
                                      uint32_t time) {
-  LOGWAYLAND("BufferDeleteSyncFinished() [%p]", aData);
-  RefPtr buffer = already_AddRefed(static_cast<WaylandBuffer*>(aData));
-  // wl_buffer should be already deleted on our side.
-  buffer->BufferDetachedCallbackHandler(nullptr, /* aWlBufferDeleted */ true);
+  UniquePtr<SurfaceAndBuffer> ref(static_cast<SurfaceAndBuffer*>(aData));
+  LOGWAYLAND(
+      "BufferDeleteSyncFinished() WaylandSurface [%p] WaylandBuffer [%p]",
+      ref->mSurface.get(), ref->mBuffer.get());
+
+  ref->mBuffer->ClearSyncHandler();
+  ref->mSurface->BufferFreeCallbackHandler(ref->mBuffer,
+                                           /* wl_buffer */ nullptr);
 }
 
 static const struct wl_callback_listener sBufferDeleteSyncListener = {
     .done = BufferDeleteSyncFinished,
 };
 
-void WaylandBuffer::ReturnBuffer(RefPtr<WaylandSurface> aWaylandSurface) {
-  LOGWAYLAND("WaylandBuffer::ReturnBuffer() [%p] WaylandSurface [%p]",
-             (void*)this, mSurface.get());
+void WaylandBuffer::ClearSyncHandler() {
+  AssertIsOnMainThread();
+  MOZ_DIAGNOSTIC_ASSERT(!mWLBuffer);
+  mBufferDeleteSyncCallback = nullptr;
+}
+
+void WaylandBuffer::ReturnBufferAttached(WaylandSurfaceLock& aSurfaceLock) {
+  LOGWAYLAND("WaylandBuffer::ReturnBufferAttached() [%p] WaylandSurface [%p]",
+             (void*)this, mAttachedToSurface.get());
 
-  MutexAutoLock lock(mBufferReleaseMutex);
-  MOZ_RELEASE_ASSERT(aWaylandSurface == mSurface || !mSurface);
+  MOZ_DIAGNOSTIC_ASSERT(aSurfaceLock.GetWaylandSurface() == mAttachedToSurface);
+  MOZ_DIAGNOSTIC_ASSERT(mIsAttachedToCompositor,
+                        "WaylandBuffer is not attached to compostor!");
 
+  // It's possible that ReturnBufferAttached() is called twice for the same
+  // WaylandBuffer, may happens if WaylandSurface is
+  // unmapped -> mapped -> unmapped quickly so the mBufferDeleteSyncCallback
+  // from the first unmap is not finished yet.
   if (mBufferDeleteSyncCallback) {
-    MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
+    MOZ_DIAGNOSTIC_ASSERT(!mWLBuffer, "We should not have wl_buffer!");
     return;
   }
 
-  DeleteWlBuffer();
+  MOZ_DIAGNOSTIC_ASSERT(mWLBuffer, "Missing wl_buffer!");
 
-  // We're already detached from WaylandSurface
-  if (!mSurface) {
-    return;
-  }
+  // Delete wl_buffer now and use wl_display_sync() to make sure
+  // it's really deleted.
+  DeleteWlBuffer();
 
   // There are various Wayland queues processed for every thread.
   // It's possible that wl_buffer release event is pending in any
@@ -156,72 +201,12 @@
   // wl_buffer operation pending so we can safely release WaylandSurface
   // and WaylandBuffer objects.
   mBufferDeleteSyncCallback = wl_display_sync(WaylandDisplayGetWLDisplay());
-  // Addref this to keep it live until sync,
-  // we're unref it at sBufferDeleteSyncListener
-  AddRef();
   wl_callback_add_listener(mBufferDeleteSyncCallback,
-                           &sBufferDeleteSyncListener, this);
+                           &sBufferDeleteSyncListener,
+                           new SurfaceAndBuffer(mAttachedToSurface, this));
+  return;
 }
 
-void WaylandBuffer::BufferDetachedCallbackHandler(wl_buffer* aBuffer,
-                                                  bool aWlBufferDeleted) {
-  LOGWAYLAND(
-      "WaylandBuffer::BufferDetachedCallbackHandler() [%p] WaylandSurface [%p] "
-      "aBuffer [%p] aWlBufferDeleted %d GetWlBuffer() [%p]",
-      (void*)this, mSurface ? mSurface->GetLoggingWidget() : nullptr, aBuffer,
-      aWlBufferDeleted, GetWlBuffer());
-
-  // BufferDetachedCallbackHandler() should be caled by Wayland compostor
-  // on main thread only.
-  AssertIsOnMainThread();
-
-  // aWlBufferDeleted means wl_buffer should be nullptr
-  MOZ_DIAGNOSTIC_ASSERT(!aBuffer == aWlBufferDeleted);
-
-  RefPtr<WaylandSurface> surface;
-
-  // Don't take mBufferReleaseMutex and mSurface locks together,
-  // may lead to deadlock.
-  {
-    MutexAutoLock lock(mBufferReleaseMutex);
-
-    // We should release correct buffer.
-    // If GetWlBuffer() is nullptr (deleted) we should have valid delete
-    // callback.
-    MOZ_DIAGNOSTIC_ASSERT(aBuffer == GetWlBuffer() ||
-                          (!GetWlBuffer() && mBufferDeleteSyncCallback));
-
-    if (aWlBufferDeleted) {
-      MOZ_DIAGNOSTIC_ASSERT(mBufferDeleteSyncCallback);
-      mBufferDeleteSyncCallback = nullptr;
-    }
-
-    // We might be unreffed by previous BufferDetachedCallbackHandler() callback
-    // as it's called for both wl_buffer delete and wl_buffer detach events.
-    if (!mSurface) {
-      return;
-    }
-
-    // Clear surface reference so WaylandBuffer is marked as not attached now.
-    surface = std::move(mSurface);
-  }
-
-  // Notify WaylandSurface we're detached by Wayland compositor
-  // so it can clear reference to us.
-  WaylandSurfaceLock surfaceLock(surface);
-  surface->DetachedByWaylandCompositorLocked(surfaceLock, this);
-}
-
-static void BufferDetachedCallbackHandler(void* aData, wl_buffer* aBuffer) {
-  LOGWAYLAND("BufferDetachedCallbackHandler() [%p] received wl_buffer [%p]",
-             aData, aBuffer);
-  RefPtr<WaylandBuffer> buffer = static_cast<WaylandBuffer*>(aData);
-  buffer->BufferDetachedCallbackHandler(aBuffer, /* aWlBufferDeleted */ false);
-}
-
-static const struct wl_buffer_listener sBufferDetachListener = {
-    BufferDetachedCallbackHandler};
-
 /* static */
 RefPtr<WaylandBufferSHM> WaylandBufferSHM::Create(
     const LayoutDeviceIntSize& aSize) {
@@ -249,21 +234,10 @@
     return true;
   }
   LOGWAYLAND("WaylandBufferSHM::CreateWlBuffer() [%p]", (void*)this);
-
   mWLBuffer = wl_shm_pool_create_buffer(mShmPool->GetShmPool(), 0, mSize.width,
                                         mSize.height, mSize.width * BUFFER_BPP,
                                         WL_SHM_FORMAT_ARGB8888);
-  if (!mWLBuffer) {
-    LOGWAYLAND("  failed to create wl_buffer");
-    return false;
-  }
-
-  if (wl_buffer_add_listener(mWLBuffer, &sBufferDetachListener, this) < 0) {
-    LOGWAYLAND("  failed to attach listener");
-    return false;
-  }
-
-  return true;
+  return !!mWLBuffer;
 }
 
 WaylandBufferSHM::WaylandBufferSHM(const LayoutDeviceIntSize& aSize)
@@ -273,12 +247,10 @@
 
 WaylandBufferSHM::~WaylandBufferSHM() {
   LOGWAYLAND("WaylandBufferSHM::~WaylandBufferSHM() [%p]\n", (void*)this);
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete());
-  MOZ_DIAGNOSTIC_ASSERT(!IsAttached());
-  if (!IsAttached()) {
-    DeleteWlBuffer();
-  }
-  MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
+  MOZ_RELEASE_ASSERT(!mBufferDeleteSyncCallback);
+  MOZ_RELEASE_ASSERT(!IsAttached());
+  // We can delete wl_buffer as it not attached.
+  DeleteWlBuffer();
 }
 
 already_AddRefed<gfx::DrawTarget> WaylandBufferSHM::Lock() {
@@ -359,26 +331,15 @@
 
 bool WaylandBufferDMABUF::CreateWlBuffer() {
   MOZ_DIAGNOSTIC_ASSERT(mDMABufSurface);
-
   if (mWLBuffer) {
-    return true;
+    return mWLBuffer;
   }
 
   LOGWAYLAND("WaylandBufferDMABUF::CreateWlBuffer() [%p] UID %d", (void*)this,
              mDMABufSurface->GetUID());
 
   mWLBuffer = mDMABufSurface->CreateWlBuffer();
-  if (!mWLBuffer) {
-    LOGWAYLAND("  failed to create wl_buffer");
-    return false;
-  }
-
-  if (wl_buffer_add_listener(mWLBuffer, &sBufferDetachListener, this) < 0) {
-    LOGWAYLAND("  failed to attach listener!");
-    return false;
-  }
-
-  return true;
+  return !!mWLBuffer;
 }
 
 WaylandBufferDMABUF::WaylandBufferDMABUF(const LayoutDeviceIntSize& aSize)
@@ -389,12 +350,10 @@
 WaylandBufferDMABUF::~WaylandBufferDMABUF() {
   LOGWAYLAND("WaylandBufferDMABUF::~WaylandBufferDMABUF [%p] UID %d\n",
              (void*)this, mDMABufSurface ? mDMABufSurface->GetUID() : -1);
-  MOZ_DIAGNOSTIC_ASSERT(!IsWaitingToBufferDelete());
-  MOZ_DIAGNOSTIC_ASSERT(!IsAttached());
-  if (!IsAttached()) {
-    DeleteWlBuffer();
-  }
-  MOZ_DIAGNOSTIC_ASSERT(!HasWlBuffer());
+  MOZ_RELEASE_ASSERT(!mBufferDeleteSyncCallback);
+  MOZ_RELEASE_ASSERT(!IsAttached());
+  // We can delete wl_buffer as it not attached.
+  DeleteWlBuffer();
 }
 
 }  // namespace mozilla::widget