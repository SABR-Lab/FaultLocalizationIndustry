# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandSurface.h
# Commit: 88c7eaa3296d
# Full Hash: 88c7eaa3296d009a32b65fe732678c6b55f4c01d
# Author: stransky <stransky@redhat.com>
# Date: 2025-02-05 16:56:59
# Regressor Bug: 1942232
# File Overlap Count: 1
# Description:
#   Bug 1942232 [Wayland] Detach and Release WaylandBuffer through WaylandSurface only r=emilio
#   
#   WaylandBuffer detach/release can happen on various thread and races with WaylandSurface access to WaylandBuffer.
#   To ensure WaylandSurface/WaylandBuffer consistent state, manage WaylandBuffer via. WaylandSurface only.
#   Register all async callbacks to WaylandSurface and use WaylandSurfaceLock to access WaylandBuffer.
# ==============================================================================

diff -r bd5cfbdb02b0 -r 88c7eaa3296d widget/gtk/WaylandSurface.h
--- a/widget/gtk/WaylandSurface.h	Wed Feb 05 11:41:26 2025 +0000
+++ b/widget/gtk/WaylandSurface.h	Wed Feb 05 11:41:26 2025 +0000
@@ -90,9 +90,7 @@
 
   bool IsOpaqueSurfaceHandlerSet() const { return mIsOpaqueSurfaceHandlerSet; }
 
-  bool HasBufferAttachedLocked(const WaylandSurfaceLock& aProofOfLock) const {
-    return mBufferAttached;
-  }
+  bool HasBufferAttached() const { return mBufferAttached; }
 
   // Mapped as direct surface of MozContainer
   bool MapLocked(const WaylandSurfaceLock& aProofOfLock,
@@ -103,7 +101,7 @@
                  WaylandSurfaceLock* aParentWaylandSurfaceLock,
                  gfx::IntPoint aSubsurfacePosition);
   // Unmap surface which hides it
-  void UnmapLocked(const WaylandSurfaceLock& aProofOfLock);
+  void UnmapLocked(WaylandSurfaceLock& aSurfaceLock);
 
   // Clean up Gdk resources, on main thread only
   void GdkCleanUpLocked(const WaylandSurfaceLock& aProofOfLock);
@@ -127,18 +125,22 @@
 
   // Attach WaylandBuffer which shows WaylandBuffer content
   // on screen.
-  bool AttachLocked(const WaylandSurfaceLock& aProofOfLock,
+  bool AttachLocked(WaylandSurfaceLock& aSurfaceLock,
                     RefPtr<WaylandBuffer> aWaylandBuffer);
 
-  // Notify WaylandSurface that WaylandBuffer was released by Wayland
-  // compositor.
-  void DetachedByWaylandCompositorLocked(const WaylandSurfaceLock& aProofOfLock,
-                                         RefPtr<WaylandBuffer> aWaylandBuffer);
-
   // If there's any WaylandBuffer recently attached, detach it.
   // It makes the WaylandSurface invisible and it doesn't have any
   // content.
-  void RemoveAttachedBufferLocked(const WaylandSurfaceLock& aProofOfLock);
+  void RemoveAttachedBufferLocked(WaylandSurfaceLock& aProofOfLock);
+
+  // Called from Wayland compostor async handler when wl_buffer is
+  // detached or deleted.
+  // For deleted wl_buffer call we use WaylandBuffer as an argument
+  // as wl_buffer is already deleted.
+  // For detach event we pass wl_buffer as it's provided by Wayland compositor
+  // directly.
+  void BufferFreeCallbackHandler(WaylandBuffer* aWaylandBuffer,
+                                 wl_buffer* aWlBuffer);
 
   // CommitLocked() is needed to call after some of *Locked() method
   // to submit the action to Wayland compositor by wl_surface_commit().
@@ -285,9 +287,10 @@
   void Commit(WaylandSurfaceLock* aProofOfLock, bool aForceCommit,
               bool aForceDisplayFlush);
 
-  bool UntrackWaylandBufferLocked(const WaylandSurfaceLock& aProofOfLock,
-                                  WaylandBuffer* aWaylandBuffer, bool aRemove);
-  void ReleaseAllWaylandBuffersLocked(const WaylandSurfaceLock& aProofOfLock);
+  // Force release/detele all buffers. Some of them may be attached to
+  // compostor and may get wl_buffer::release callback so we need to sync
+  // delete with wayland compostor.
+  void ReleaseAllWaylandBuffersLocked(WaylandSurfaceLock& aSurfaceLock);
 
   void RequestFrameCallbackLocked(const WaylandSurfaceLock& aProofOfLock,
                                   bool aRequestEmulated);
@@ -299,6 +302,11 @@
 
   void ClearScaleLocked(const WaylandSurfaceLock& aProofOfLock);
 
+  ssize_t FindBufferLocked(const WaylandSurfaceLock& aProofOfLock,
+                           wl_buffer* aWlBuffer);
+  ssize_t FindBufferLocked(const WaylandSurfaceLock& aProofOfLock,
+                           WaylandBuffer* aWaylandBuffer);
+
   // Weak ref to owning widget (nsWindow or NativeLayerWayland),
   // used for diagnostics/logging only.
   void* mLoggingWidget = nullptr;
@@ -343,7 +351,8 @@
   wl_subsurface* mSubsurface = nullptr;
   gfx::IntPoint mSubsurfacePosition{-1, -1};
 
-  // Wayland buffers attached to this surface AND held by Wayland compositor.
+  // Wayland buffers recently attached to this surface or held by
+  // Wayland compositor.
   // There may be more than one buffer attached, for instance if
   // previous buffer is hold by compositor. We need to keep
   // there buffers live until compositor notify us that we
@@ -354,7 +363,7 @@
   // to it and expect to get frame callbacks from Wayland compositor.
   // We set it at AttachLocked() or when we get first frame callback
   // (when EGL is used).
-  bool mBufferAttached = false;
+  mozilla::Atomic<bool, mozilla::Relaxed> mBufferAttached{false};
 
   // It's kind of special case here where mSurface equal to mParentSurface
   // so we directly paint to parent surface without subsurface.
