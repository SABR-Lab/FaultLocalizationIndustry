# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/WaylandSurface.cpp
# Commit: f5e50c8e4669
# Full Hash: f5e50c8e46694a3300cef68d6d86932f012c1e93
# Author: stransky <stransky@redhat.com>
# Date: 2025-02-04 21:40:27
# Regressor Bug: 1942232
# File Overlap Count: 1
# Description:
#   Bug 1942232 [Wayland] Detach and Release WaylandBuffer through WaylandSurface only r=emilio
#   
#   WaylandBuffer detach/release can happen on various thread and races with WaylandSurface access to WaylandBuffer.
#   To ensure WaylandSurface/WaylandBuffer consistent state, manage WaylandBuffer via. WaylandSurface only.
#   Register all async callbacks to WaylandSurface and use WaylandSurfaceLock to access WaylandBuffer.
# ==============================================================================

diff -r bd7854684a11 -r f5e50c8e4669 widget/gtk/WaylandSurface.cpp
--- a/widget/gtk/WaylandSurface.cpp	Tue Feb 04 09:47:16 2025 +0000
+++ b/widget/gtk/WaylandSurface.cpp	Tue Feb 04 09:55:39 2025 +0000
@@ -13,6 +13,7 @@
 #include <dlfcn.h>
 #include <fcntl.h>
 #include "ScreenHelperGTK.h"
+#include "DMABufFormats.h"
 
 #undef LOG
 #ifdef MOZ_LOGGING
@@ -90,7 +91,7 @@
   MOZ_RELEASE_ASSERT(!mIsMapped, "We can't release mapped WaylandSurface!");
   MOZ_RELEASE_ASSERT(!mSurfaceLock, "We can't release locked WaylandSurface!");
   MOZ_RELEASE_ASSERT(mAttachedBuffers.Length() == 0,
-                     "We can't release surface with buffer attached!");
+                     "We can't release surface with buffers tracked!");
   MOZ_RELEASE_ASSERT(!mEmulatedFrameCallbackTimerID,
                      "We can't release WaylandSurface with active timer");
   MOZ_RELEASE_ASSERT(!mIsPendingGdkCleanup,
@@ -343,7 +344,6 @@
   }
 
   // Emulate callbacks for empty wl_surfaces only
-  // TODO: Emulate for surfaces with removed buffer? (layers?)
   if (aRequestEmulated && !mBufferAttached && !mEmulatedFrameCallbackTimerID) {
     LOGVERBOSE(
         "WaylandSurface::RequestFrameCallbackLocked() emulated, schedule "
@@ -588,7 +588,7 @@
   }
 }
 
-void WaylandSurface::UnmapLocked(const WaylandSurfaceLock& aProofOfLock) {
+void WaylandSurface::UnmapLocked(WaylandSurfaceLock& aSurfaceLock) {
   if (!mIsMapped) {
     return;
   }
@@ -605,9 +605,9 @@
     mSurface = nullptr;
   }
 
-  ClearReadyToDrawCallbacksLocked(aProofOfLock);
-  ClearFrameCallbackLocked(aProofOfLock);
-  ClearScaleLocked(aProofOfLock);
+  ClearReadyToDrawCallbacksLocked(aSurfaceLock);
+  ClearFrameCallbackLocked(aSurfaceLock);
+  ClearScaleLocked(aSurfaceLock);
 
   MozClearPointer(mViewport, wp_viewport_destroy);
   mViewportDestinationSize = gfx::IntSize(-1, -1);
@@ -625,15 +625,15 @@
     MozClearPointer(mSurface, wl_surface_destroy);
   }
 
-  // Remove references to WaylandBuffers attached to mSurface,
-  // we don't want to get any buffer release callback when we're unmapped.
-  ReleaseAllWaylandBuffersLocked(aProofOfLock);
-
   mIsReadyToDraw = false;
   mBufferAttached = false;
 
   mUnmapCallback = nullptr;
   mGdkCommitCallback = nullptr;
+
+  // Remove references to WaylandBuffers attached to mSurface,
+  // we don't want to get any buffer release callback when we're unmapped.
+  ReleaseAllWaylandBuffersLocked(aSurfaceLock);
 }
 
 void WaylandSurface::Commit(WaylandSurfaceLock* aProofOfLock, bool aForceCommit,
@@ -1075,101 +1075,140 @@
   mSurfaceNeedsCommit = true;
 }
 
-bool WaylandSurface::UntrackWaylandBufferLocked(
-    const WaylandSurfaceLock& aProofOfLock, WaylandBuffer* aWaylandBuffer,
-    bool aRemove) {
-  for (size_t i = 0; i < mAttachedBuffers.Length(); i++) {
-    if (mAttachedBuffers[i] == aWaylandBuffer) {
-      if (aRemove) {
-        mAttachedBuffers.RemoveElementAt(i);
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
 void WaylandSurface::ReleaseAllWaylandBuffersLocked(
-    const WaylandSurfaceLock& aProofOfLock) {
+    WaylandSurfaceLock& aSurfaceLock) {
   LOGWAYLAND("WaylandSurface::ReleaseAllWaylandBuffersLocked(), buffers num %d",
              (int)mAttachedBuffers.Length());
+  MOZ_DIAGNOSTIC_ASSERT(!mIsMapped);
   for (auto& buffer : mAttachedBuffers) {
-    buffer->ReturnBuffer(this);
+    buffer->ReturnBufferAttached(aSurfaceLock);
   }
 }
 
-bool WaylandSurface::AttachLocked(const WaylandSurfaceLock& aProofOfLock,
+ssize_t WaylandSurface::FindBufferLocked(const WaylandSurfaceLock& aProofOfLock,
+                                         wl_buffer* aWlBuffer) {
+  for (size_t i = 0; i < mAttachedBuffers.Length(); i++) {
+    if (mAttachedBuffers[i]->Matches(aWlBuffer)) {
+      return i;
+    }
+  }
+  return -1;
+}
+
+ssize_t WaylandSurface::FindBufferLocked(const WaylandSurfaceLock& aProofOfLock,
+                                         WaylandBuffer* aWaylandBuffer) {
+  for (size_t i = 0; i < mAttachedBuffers.Length(); i++) {
+    if (mAttachedBuffers[i] == aWaylandBuffer) {
+      return i;
+    }
+  }
+  return -1;
+}
+
+// BufferFreeCallbackHandler is called when WaylandBuffer is detached by
+// compositor or we delete it explicitly. The two events can happen in any
+// order.
+void WaylandSurface::BufferFreeCallbackHandler(WaylandBuffer* aWaylandBuffer,
+                                               wl_buffer* aWlBuffer) {
+  LOGWAYLAND(
+      "WaylandSurface::BufferFreeCallbackHandler() WaylandBuffer [%p] "
+      "wl_buffer [%p]",
+      aWaylandBuffer, aWlBuffer);
+  WaylandSurfaceLock lock(this);
+
+  // BufferFreeCallbackHandler() should be caled by Wayland compostor
+  // on main thread only.
+  AssertIsOnMainThread();
+
+  auto bufferIndex = aWaylandBuffer ? FindBufferLocked(lock, aWaylandBuffer)
+                                    : FindBufferLocked(lock, aWlBuffer);
+  // It's possible that buffer was already freed by previous detach call
+  // and we're on synced delete now. In such case just quit.
+  // Reversed order (delete, detach) is not possible - we can't get detach
+  // for deleted buffers.
+  if (bufferIndex < 0) {
+    MOZ_DIAGNOSTIC_ASSERT(
+        aWaylandBuffer && !aWlBuffer,
+        "Wayland compositor detach call after wl_buffer delete?");
+    return;
+  }
+
+  mAttachedBuffers[bufferIndex]->ReturnBufferDetached(lock);
+  mAttachedBuffers.RemoveElementAt(bufferIndex);
+}
+
+static void BufferDetachedCallbackHandler(void* aData, wl_buffer* aBuffer) {
+  LOGS("BufferDetachedCallbackHandler() [%p] received wl_buffer [%p]", aData,
+       aBuffer);
+  RefPtr surface = static_cast<WaylandSurface*>(aData);
+  surface->BufferFreeCallbackHandler(/* WaylandBuffer */ nullptr, aBuffer);
+}
+
+static const struct wl_buffer_listener sBufferDetachListener = {
+    BufferDetachedCallbackHandler};
+
+bool WaylandSurface::AttachLocked(WaylandSurfaceLock& aSurfaceLock,
                                   RefPtr<WaylandBuffer> aWaylandBuffer) {
-  MOZ_DIAGNOSTIC_ASSERT(&aProofOfLock == mSurfaceLock);
+  MOZ_DIAGNOSTIC_ASSERT(&aSurfaceLock == mSurfaceLock);
   MOZ_DIAGNOSTIC_ASSERT(mSurface);
 
-  wl_buffer* buffer = aWaylandBuffer->BorrowBuffer(this);
+  auto scale = GetScaleSafe();
+  LayoutDeviceIntSize bufferSize = aWaylandBuffer->GetSize();
+  // TODO: rounding?
+  SetSizeLocked(aSurfaceLock, gfx::IntSize(bufferSize.width, bufferSize.height),
+                gfx::IntSize((int)round(bufferSize.width / scale),
+                             (int)round(bufferSize.height / scale)));
+
+  LOGWAYLAND(
+      "WaylandSurface::AttachLocked() WaylandBuffer [%p] size [%d x %d] "
+      "fractional scale %f",
+      aWaylandBuffer.get(), bufferSize.width, bufferSize.height, scale);
+
+  wl_buffer* buffer = aWaylandBuffer->BorrowBuffer(aSurfaceLock);
   if (!buffer) {
     LOGWAYLAND("WaylandSurface::AttachLocked() failed, BorrowBuffer() failed");
     return false;
   }
 
-  auto scale = GetScaleSafe();
-  LayoutDeviceIntSize bufferSize = aWaylandBuffer->GetSize();
-  // TODO: rounding?
-  SetSizeLocked(aProofOfLock, gfx::IntSize(bufferSize.width, bufferSize.height),
-                gfx::IntSize((int)round(bufferSize.width / scale),
-                             (int)round(bufferSize.height / scale)));
-  LOGWAYLAND(
-      "WaylandSurface::AttachLocked() WaylandBuffer [%p] size [%d x %d] "
-      "fractional scale %f",
-      aWaylandBuffer.get(), bufferSize.width, bufferSize.height, scale);
+  // We don't take reference to this. Some compositors doesn't send
+  // buffer release callback and we may leak WaylandSurface then.
+  // Rather we destroy wl_buffer at end which makes sure no release callback
+  // comes after WaylandSurface release.
+  if (wl_buffer_add_listener(buffer, &sBufferDetachListener, this) < 0) {
+    LOGWAYLAND(
+        "WaylandSurface::AttachLocked() failed to attach buffer listener");
+    aWaylandBuffer->ReturnBufferDetached(aSurfaceLock);
+    return false;
+  }
 
-  // Take reference to buffer until it's released by compositor
-  MOZ_DIAGNOSTIC_ASSERT(!UntrackWaylandBufferLocked(
-                            aProofOfLock, aWaylandBuffer, /* aRemove */ false),
-                        "Wayland buffer is already attached?");
-  mAttachedBuffers.AppendElement(std::move(aWaylandBuffer));
+  if (!mAttachedBuffers.Contains(aWaylandBuffer)) {
+    mAttachedBuffers.AppendElement(aWaylandBuffer);
+  }
+
   if (mCommitToParentSurface) {
     wl_surface_set_buffer_scale(mSurface, 1);
   }
   wl_surface_attach(mSurface, buffer, 0, 0);
+  aWaylandBuffer->SetAttachedLocked(aSurfaceLock);
   mBufferAttached = true;
   mSurfaceNeedsCommit = true;
   return true;
 }
 
 void WaylandSurface::RemoveAttachedBufferLocked(
-    const WaylandSurfaceLock& aProofOfLock) {
-  MOZ_DIAGNOSTIC_ASSERT(&aProofOfLock == mSurfaceLock);
+    WaylandSurfaceLock& aSurfaceLock) {
+  MOZ_DIAGNOSTIC_ASSERT(&aSurfaceLock == mSurfaceLock);
   MOZ_DIAGNOSTIC_ASSERT(mSurface);
 
   LOGWAYLAND("WaylandSurface::RemoveAttachedBufferLocked()");
 
   // Set our size according to attached buffer
-  SetSizeLocked(aProofOfLock, gfx::IntSize(0, 0), gfx::IntSize(0, 0));
+  SetSizeLocked(aSurfaceLock, gfx::IntSize(0, 0), gfx::IntSize(0, 0));
   wl_surface_attach(mSurface, nullptr, 0, 0);
   mSurfaceNeedsCommit = true;
   mBufferAttached = false;
 }
 
-void WaylandSurface::DetachedByWaylandCompositorLocked(
-    const WaylandSurfaceLock& aProofOfLock,
-    RefPtr<WaylandBuffer> aWaylandBuffer) {
-  // We should be called from Wayland compostor on Main thread only.
-  AssertIsOnMainThread();
-
-  LOGWAYLAND(
-      "WaylandSurface::DetachedByWaylandCompositorLocked() WaylandBuffer [%p]",
-      aWaylandBuffer.get());
-  MOZ_DIAGNOSTIC_ASSERT(&aProofOfLock == mSurfaceLock);
-
-  // Remove WaylandBuffer from our internal list so it can be released.
-  if (!UntrackWaylandBufferLocked(aProofOfLock, aWaylandBuffer,
-                                  /* aRemove */ true)) {
-    MOZ_DIAGNOSTIC_CRASH("Wayland buffer is not attached?");
-  }
-
-  // We don't clear mBufferAttached here. WaylandBuffer may be still used by
-  // Wayland compositor until wl_surface is deleted or a new wl_buffer is
-  // attached or wl_buffer is eplicitly removed by RemoveAttachedBufferLocked().
-}
-
 // Place this WaylandSurface above aLowerSurface
 void WaylandSurface::PlaceAboveLocked(const WaylandSurfaceLock& aProofOfLock,
                                       WaylandSurfaceLock& aLowerSurfaceLock) {