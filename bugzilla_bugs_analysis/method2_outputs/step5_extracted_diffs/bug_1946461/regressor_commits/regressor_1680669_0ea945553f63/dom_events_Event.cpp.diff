# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/Event.cpp
# Commit: 0ea945553f63
# Full Hash: 0ea945553f63659b99fd37265c5e7a764f70504d
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2024-12-03 16:21:08
# Regressor Bug: 1680669
# File Overlap Count: 1
# Description:
#   Bug 1680669 - part 6: Make methods of `MouseEvent` and static methods of `Event` aware of fractional coordinates r=smaug,emilio,webdriver-reviewers
#   
#   `screenX`, `screenY`, `clientX`, `clientY`, `x`, `y`, `offsetX` and `offsetY`
#   are now `double`.  This patch makes the event classes aware of DOM events.
#   
# ==============================================================================

diff -r 98d5a05c6c6e -r 0ea945553f63 dom/events/Event.cpp
--- a/dom/events/Event.cpp	Tue Dec 03 07:10:01 2024 +0000
+++ b/dom/events/Event.cpp	Tue Dec 03 07:10:05 2024 +0000
@@ -4,6 +4,8 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "Event.h"
+
 #include "AccessCheck.h"
 #include "base/basictypes.h"
 #include "ipc/IPCMessageUtils.h"
@@ -27,7 +29,6 @@
 #include "mozilla/ViewportUtils.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/DocumentInlines.h"
-#include "mozilla/dom/Event.h"
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/ScrollContainerFrame.h"
@@ -582,9 +583,9 @@
 WidgetEvent* Event::WidgetEventPtr() { return mEvent; }
 
 // static
-Maybe<CSSIntPoint> Event::GetScreenCoords(nsPresContext* aPresContext,
-                                          WidgetEvent* aEvent,
-                                          LayoutDeviceIntPoint aPoint) {
+Maybe<CSSDoublePoint> Event::GetScreenCoords(
+    nsPresContext* aPresContext, WidgetEvent* aEvent,
+    const LayoutDeviceDoublePoint& aWidgetRelativePoint) {
   if (PointerLockManager::IsLocked()) {
     return Some(EventStateManager::sLastScreenPoint);
   }
@@ -593,11 +594,11 @@
     return Nothing();
   }
 
-  // Doing a straight conversion from LayoutDeviceIntPoint to CSSIntPoint
+  // Doing a straight conversion from LayoutDeviceDoublePoint to CSSDoublePoint
   // seem incorrect, but it is needed to maintain legacy functionality.
-  WidgetGUIEvent* guiEvent = aEvent->AsGUIEvent();
-  if (!aPresContext || !(guiEvent && guiEvent->mWidget)) {
-    return Some(CSSIntPoint(aPoint.x, aPoint.y));
+  const WidgetGUIEvent* guiEvent = aEvent->AsGUIEvent();
+  if (MOZ_UNLIKELY(!aPresContext) || !(guiEvent && guiEvent->mWidget)) {
+    return Some(CSSDoublePoint(aWidgetRelativePoint.x, aWidgetRelativePoint.y));
   }
 
   // (Potentially) transform the point from the coordinate space of an
@@ -605,113 +606,126 @@
   // window. The transform can only be applied to a point whose components
   // are floating-point values, so convert the integer point first, then
   // transform, and then round the result back to an integer point.
-  LayoutDevicePoint floatPoint(aPoint);
-  LayoutDevicePoint topLevelPoint =
+  const LayoutDeviceIntPoint topLevelPoint = LayoutDeviceIntPoint::Round(
       guiEvent->mWidget->WidgetToTopLevelWidgetTransform().TransformPoint(
-          floatPoint);
-  LayoutDeviceIntPoint rounded = RoundedToInt(topLevelPoint);
-
-  nsPoint pt = LayoutDevicePixel::ToAppUnits(
-      rounded, aPresContext->DeviceContext()->AppUnitsPerDevPixel());
-
-  pt += LayoutDevicePixel::ToAppUnits(
-      guiEvent->mWidget->TopLevelWidgetToScreenOffset(),
-      aPresContext->DeviceContext()->AppUnitsPerDevPixel());
-
-  return Some(CSSPixel::FromAppUnitsRounded(pt));
+          aWidgetRelativePoint));
+  const CSSPoint pt = CSSPixel::FromAppUnits(
+      LayoutDevicePixel::ToAppUnits(
+          topLevelPoint, aPresContext->DeviceContext()->AppUnitsPerDevPixel()) +
+      LayoutDevicePixel::ToAppUnits(
+          guiEvent->mWidget->TopLevelWidgetToScreenOffset(),
+          aPresContext->DeviceContext()->AppUnitsPerDevPixel()));
+  return Some(CSSDoublePoint(pt.x, pt.y));
 }
 
 // static
-CSSIntPoint Event::GetPageCoords(nsPresContext* aPresContext,
-                                 WidgetEvent* aEvent,
-                                 LayoutDeviceIntPoint aPoint,
-                                 CSSIntPoint aDefaultPoint) {
-  CSSIntPoint pagePoint =
-      Event::GetClientCoords(aPresContext, aEvent, aPoint, aDefaultPoint);
+CSSDoublePoint Event::GetPageCoords(
+    nsPresContext* aPresContext, WidgetEvent* aEvent,
+    const LayoutDeviceDoublePoint& aWidgetRelativePoint,
+    const CSSDoublePoint& aDefaultClientPoint) {
+  const CSSDoublePoint clientCoords = Event::GetClientCoords(
+      aPresContext, aEvent, aWidgetRelativePoint, aDefaultClientPoint);
 
   // If there is some scrolling, add scroll info to client point.
-  if (aPresContext && aPresContext->GetPresShell()) {
-    PresShell* presShell = aPresContext->PresShell();
-    if (ScrollContainerFrame* sf = presShell->GetRootScrollContainerFrame()) {
-      pagePoint += CSSIntPoint::FromAppUnitsRounded(sf->GetScrollPosition());
+  const CSSPoint scrollPoint = CSSPixel::FromAppUnits([&]() {
+    if (aPresContext && aPresContext->GetPresShell()) {
+      if (const ScrollContainerFrame* const sf =
+              aPresContext->PresShell()->GetRootScrollContainerFrame()) {
+        return sf->GetScrollPosition();
+      }
     }
-  }
-
-  return pagePoint;
+    return nsPoint{};
+  }());
+  return clientCoords + CSSDoublePoint(scrollPoint.x, scrollPoint.y);
 }
 
 // static
-CSSIntPoint Event::GetClientCoords(nsPresContext* aPresContext,
-                                   WidgetEvent* aEvent,
-                                   LayoutDeviceIntPoint aPoint,
-                                   CSSIntPoint aDefaultPoint) {
+CSSDoublePoint Event::GetClientCoords(
+    nsPresContext* aPresContext, WidgetEvent* aEvent,
+    const LayoutDeviceDoublePoint& aWidgetRelativePoint,
+    const CSSDoublePoint& aDefaultClientPoint) {
   if (PointerLockManager::IsLocked()) {
     return EventStateManager::sLastClientPoint;
   }
 
-  if (!aPresContext || !aEvent || !aEvent->DOMEventSupportsCoords() ||
-      !aEvent->AsGUIEvent()->mWidget) {
-    return aDefaultPoint;
+  if (MOZ_UNLIKELY(!aPresContext) || MOZ_UNLIKELY(!aEvent) ||
+      !aEvent->DOMEventSupportsCoords() ||
+      MOZ_UNLIKELY(!aEvent->AsGUIEvent()->mWidget)) {
+    return aDefaultClientPoint;
   }
 
-  PresShell* presShell = aPresContext->GetPresShell();
-  if (!presShell) {
-    return CSSIntPoint(0, 0);
+  const PresShell* const presShell = aPresContext->GetPresShell();
+  if (MOZ_UNLIKELY(!presShell)) {
+    return CSSDoublePoint(0, 0);
   }
-  nsIFrame* rootFrame = presShell->GetRootFrame();
-  if (!rootFrame) {
-    return CSSIntPoint(0, 0);
+  // XXX Why don't we flush pending notifications before computing the offset
+  // from the root frame?
+  const nsIFrame* const rootFrame = presShell->GetRootFrame();
+  if (MOZ_UNLIKELY(!rootFrame)) {
+    return CSSDoublePoint(0, 0);
   }
-  nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(
-      aEvent, aPoint, RelativeTo{rootFrame});
-
-  return CSSIntPoint::FromAppUnitsRounded(pt);
+  const CSSPoint pt =
+      CSSPixel::FromAppUnits(nsLayoutUtils::GetEventCoordinatesRelativeTo(
+          aEvent, LayoutDeviceIntPoint::Round(aWidgetRelativePoint),
+          RelativeTo{rootFrame}));
+  return CSSDoublePoint(pt.x, pt.y);
 }
 
 // static
-CSSIntPoint Event::GetOffsetCoords(nsPresContext* aPresContext,
-                                   WidgetEvent* aEvent,
-                                   LayoutDeviceIntPoint aPoint,
-                                   CSSIntPoint aDefaultPoint) {
-  if (!aEvent->mTarget) {
-    return GetPageCoords(aPresContext, aEvent, aPoint, aDefaultPoint);
-  }
-  nsCOMPtr<nsIContent> content = nsIContent::FromEventTarget(aEvent->mTarget);
-  if (!content || !aPresContext) {
-    return CSSIntPoint();
+nsIFrame* Event::GetPrimaryFrameOfEventTarget(const nsPresContext& aPresContext,
+                                              const WidgetEvent& aEvent) {
+  const nsCOMPtr<nsIContent> content =
+      nsIContent::FromEventTargetOrNull(aEvent.mTarget);
+  if (!content) {
+    return nullptr;
   }
-  RefPtr<PresShell> presShell = aPresContext->GetPresShell();
-  if (!presShell) {
-    return CSSIntPoint();
+  // XXX Even after the event target content is moved to different document, we
+  // may get its primary frame.  In this case, should we return nullptr here?
+  nsIFrame* const frame = content->GetPrimaryFrame(FlushType::Layout);
+  if (MOZ_UNLIKELY(!frame)) {
+    return nullptr;
   }
-  presShell->FlushPendingNotifications(FlushType::Layout);
-  nsIFrame* frame = content->GetPrimaryFrame();
-  if (!frame) {
-    return CSSIntPoint();
-  }
-  // For compat, see https://github.com/w3c/csswg-drafts/issues/1508. In SVG we
-  // just return the coordinates of the outer SVG box. This is all kinda
+  // For compat, see https://github.com/w3c/csswg-drafts/issues/1508. In SVG
+  // we just return the coordinates of the outer SVG box. This is all kinda
   // unfortunate.
   if (frame->HasAnyStateBits(NS_FRAME_SVG_LAYOUT) &&
       StaticPrefs::dom_events_offset_in_svg_relative_to_svg_root()) {
-    frame = SVGUtils::GetOuterSVGFrame(frame);
-    if (!frame) {
-      return CSSIntPoint();
-    }
+    return SVGUtils::GetOuterSVGFrame(frame);
   }
-  nsIFrame* rootFrame = presShell->GetRootFrame();
-  if (!rootFrame) {
-    return CSSIntPoint();
+  return frame;
+}
+
+// static
+CSSDoublePoint Event::GetOffsetCoords(
+    nsPresContext* aPresContext, WidgetEvent* aEvent,
+    const LayoutDeviceDoublePoint& aWidgetRelativePoint,
+    const CSSDoublePoint& aDefaultClientPoint) {
+  if (!aEvent->mTarget) {
+    return GetPageCoords(aPresContext, aEvent, aWidgetRelativePoint,
+                         aDefaultClientPoint);
+  }
+  if (!nsIContent::FromEventTarget(aEvent->mTarget) || !aPresContext) {
+    return CSSDoublePoint();
   }
-  CSSIntPoint clientCoords =
-      GetClientCoords(aPresContext, aEvent, aPoint, aDefaultPoint);
-  nsPoint pt = CSSPixel::ToAppUnits(clientCoords);
-  if (nsLayoutUtils::TransformPoint(RelativeTo{rootFrame}, RelativeTo{frame},
-                                    pt) == nsLayoutUtils::TRANSFORM_SUCCEEDED) {
-    pt -= frame->GetPaddingRectRelativeToSelf().TopLeft();
-    return CSSPixel::FromAppUnitsRounded(pt);
+  const nsIFrame* const frame =
+      GetPrimaryFrameOfEventTarget(*aPresContext, *aEvent);
+  if (MOZ_UNLIKELY(!frame)) {
+    return CSSDoublePoint();
   }
-  return CSSIntPoint();
+  MOZ_ASSERT(aPresContext->PresShell()->GetRootFrame());
+  const CSSDoublePoint clientCoords = GetClientCoords(
+      aPresContext, aEvent, aWidgetRelativePoint, aDefaultClientPoint);
+  nsPoint ptInAppUnits = CSSPixel::ToAppUnits(CSSPoint(
+      static_cast<float>(clientCoords.x), static_cast<float>(clientCoords.y)));
+  if (nsLayoutUtils::TransformPoint(
+          RelativeTo{aPresContext->PresShell()->GetRootFrame()},
+          RelativeTo{frame},
+          ptInAppUnits) != nsLayoutUtils::TRANSFORM_SUCCEEDED) {
+    return CSSDoublePoint();
+  }
+  ptInAppUnits -= frame->GetPaddingRectRelativeToSelf().TopLeft();
+  const CSSPoint pt = CSSPixel::FromAppUnits(ptInAppUnits);
+  return CSSDoublePoint(pt.x, pt.y);
 }
 
 // To be called ONLY by Event::GetType (which has the additional