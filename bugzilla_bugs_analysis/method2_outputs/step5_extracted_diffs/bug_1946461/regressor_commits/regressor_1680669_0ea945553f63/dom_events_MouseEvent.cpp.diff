# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/MouseEvent.cpp
# Commit: 0ea945553f63
# Full Hash: 0ea945553f63659b99fd37265c5e7a764f70504d
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2024-12-03 16:21:08
# Regressor Bug: 1680669
# File Overlap Count: 1
# Description:
#   Bug 1680669 - part 6: Make methods of `MouseEvent` and static methods of `Event` aware of fractional coordinates r=smaug,emilio,webdriver-reviewers
#   
#   `screenX`, `screenY`, `clientX`, `clientY`, `x`, `y`, `offsetX` and `offsetY`
#   are now `double`.  This patch makes the event classes aware of DOM events.
#   
# ==============================================================================

diff -r 98d5a05c6c6e -r 0ea945553f63 dom/events/MouseEvent.cpp
--- a/dom/events/MouseEvent.cpp	Tue Dec 03 07:10:01 2024 +0000
+++ b/dom/events/MouseEvent.cpp	Tue Dec 03 07:10:05 2024 +0000
@@ -7,10 +7,15 @@
 #include "MouseEvent.h"
 
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/EventForwards.h"
 #include "mozilla/MouseEvents.h"
+#include "mozilla/PresShell.h"
+#include "mozilla/StaticPrefs_dom.h"
+#include "mozilla/ViewportUtils.h"
 #include "nsContentUtils.h"
-#include "nsIContent.h"
+#include "nsIFrame.h"
 #include "nsIScreenManager.h"
+#include "nsLayoutUtils.h"
 
 namespace mozilla::dom {
 
@@ -30,19 +35,23 @@
   // It's not that important, though, since a scroll event is not a real
   // DOM event.
 
-  WidgetMouseEvent* mouseEvent = mEvent->AsMouseEvent();
+  WidgetMouseEventBase* const mouseEventBase = mEvent->AsMouseEventBase();
+  MOZ_ASSERT(mouseEventBase);
   if (aEvent) {
     mEventIsInternal = false;
   } else {
     mEventIsInternal = true;
     mEvent->mRefPoint = LayoutDeviceIntPoint(0, 0);
-    mouseEvent->mInputSource = MouseEvent_Binding::MOZ_SOURCE_UNKNOWN;
+    mouseEventBase->mInputSource = MouseEvent_Binding::MOZ_SOURCE_UNKNOWN;
   }
 
-  if (mouseEvent) {
+  mUseFractionalCoords = mouseEventBase->DOMEventShouldUseFractionalCoords();
+  mWidgetRelativePoint = mEvent->mRefPoint;
+
+  if (const WidgetMouseEvent* mouseEvent = mouseEventBase->AsMouseEvent()) {
     MOZ_ASSERT(mouseEvent->mReason != WidgetMouseEvent::eSynthesized,
                "Don't dispatch DOM events from synthesized mouse events");
-    mDetail = mouseEvent->mClickCount;
+    mDetail = static_cast<int32_t>(mouseEvent->mClickCount);
   }
 }
 
@@ -68,15 +77,29 @@
       mouseEventBase->mButton = aButton;
       mouseEventBase->InitBasicModifiers(aCtrlKey, aAltKey, aShiftKey,
                                          aMetaKey);
-      mDefaultClientPoint.x = static_cast<int32_t>(aClientX);
-      mDefaultClientPoint.y = static_cast<int32_t>(aClientY);
-      mouseEventBase->mRefPoint.x = static_cast<int32_t>(aScreenX);
-      mouseEventBase->mRefPoint.y = static_cast<int32_t>(aScreenY);
+      mDefaultClientPoint = CSSDoublePoint(aClientX, aClientY);
+      mWidgetRelativePoint = LayoutDeviceDoublePoint(aScreenX, aScreenY);
+      mouseEventBase->mRefPoint =
+          LayoutDeviceIntPoint::Floor(mWidgetRelativePoint);
 
       WidgetMouseEvent* mouseEvent = mEvent->AsMouseEvent();
       if (mouseEvent) {
         mouseEvent->mClickCount = aDetail;
       }
+
+      mUseFractionalCoords =
+          mouseEventBase->DOMEventShouldUseFractionalCoords();
+      if (!mUseFractionalCoords) {
+        // If we should not use fractional coordinates for this event, we need
+        // to drop the fractional part as defined for the backward compatibility
+        // when we treated the input values are integer coordinates.  These
+        // values will be exposed as screenX, screenY, clientX and clientY as-is
+        // too.  That matches with the Pointer Events spec definitions too.
+        // https://w3c.github.io/pointerevents/#event-coordinates
+        mDefaultClientPoint = CSSIntPoint::Floor(mDefaultClientPoint);
+        mWidgetRelativePoint =
+            LayoutDeviceIntPoint::Floor(mWidgetRelativePoint);
+      }
       break;
     }
     default:
@@ -160,12 +183,35 @@
 }
 
 void MouseEvent::DuplicatePrivateData() {
-  mDefaultClientPoint = Event::GetClientCoords(
-      mPresContext, mEvent, mEvent->mRefPoint, mDefaultClientPoint);
-  mMovementPoint = GetMovementPoint();
-  mPagePoint = Event::GetPageCoords(mPresContext, mEvent, mEvent->mRefPoint,
-                                    mDefaultClientPoint);
+  // If this is a event not created from WidgetMouseEventBase or its subclasses
+  // (i.e., created by JS), mDefaultClientPoint and mMovementPoint are
+  // initialized as expected values.  Therefore, we don't need to recompute it.
+  if (!mEventIsInternal) {
+    mDefaultClientPoint = ClientPoint();
+    mMovementPoint = GetMovementPoint();
+  }
+  // However, mPagePoint needs to include the scroll position.  Therefore, we
+  // need to compute here.
+  mPagePoint = PagePoint();
+
+  // mEvent->mRefPoint is computed by UIEvent::DuplicatePrivateData() with
+  // the device pixel scale, but if we need to store fractional values to
+  // mWidgetRelativePoint, we need to do same thing by ourselves.
+  Maybe<const CSSDoublePoint> maybeScreenPoint;
+  if (mUseFractionalCoords) {
+    maybeScreenPoint.emplace(ScreenPoint(CallerType::System));
+  }
   UIEvent::DuplicatePrivateData();
+  if (maybeScreenPoint.isSome()) {
+    CSSToLayoutDeviceScale scale = mPresContext
+                                       ? mPresContext->CSSToDevPixelScale()
+                                       : CSSToLayoutDeviceScale(1);
+    mWidgetRelativePoint = maybeScreenPoint.ref() * scale;
+  } else {
+    // As mentioned above, mEvent->mRefPoint is already computed by UIEvent, so,
+    // do not need to compute the scale.
+    mWidgetRelativePoint = mEvent->mRefPoint;
+  }
 }
 
 void MouseEvent::PreventClickEvent() {
@@ -228,32 +274,42 @@
   return EnsureWebAccessibleRelatedTarget(relatedTarget);
 }
 
-CSSIntPoint MouseEvent::ScreenPoint(CallerType aCallerType) const {
+CSSDoublePoint MouseEvent::ScreenPoint(CallerType aCallerType) const {
   if (mEvent->mFlags.mIsPositionless) {
     return {};
   }
 
+  // If this is a trusted event, mWidgetRelativeOffset is a copy of
+  // mEvent->mRefPoint, so, the values are integer.
+  // If this is an untrusted event, mWidgetRelativeOffset should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mWidgetRelativePoint ==
+                    LayoutDeviceIntPoint::Floor(mWidgetRelativePoint));
   if (nsContentUtils::ShouldResistFingerprinting(
           aCallerType, GetParentObject(), RFPTarget::MouseEventScreenPoint)) {
-    // Sanitize to something sort of like client cooords, but not quite
+    // Sanitize to something sort of like client coords, but not quite
     // (defaulting to (0,0) instead of our pre-specified client coords).
-    return Event::GetClientCoords(mPresContext, mEvent, mEvent->mRefPoint,
-                                  CSSIntPoint(0, 0));
+    const CSSDoublePoint clientPoint = Event::GetClientCoords(
+        mPresContext, mEvent, mWidgetRelativePoint, CSSDoublePoint{0, 0});
+    return mUseFractionalCoords ? clientPoint : RoundedToInt(clientPoint);
   }
 
-  return Event::GetScreenCoords(mPresContext, mEvent, mEvent->mRefPoint)
-      .extract();
+  const CSSDoublePoint screenPoint =
+      Event::GetScreenCoords(mPresContext, mEvent, mWidgetRelativePoint)
+          .extract();
+  return mUseFractionalCoords ? screenPoint : RoundedToInt(screenPoint);
 }
 
 LayoutDeviceIntPoint MouseEvent::ScreenPointLayoutDevicePix() const {
-  const CSSIntPoint point = ScreenPoint(CallerType::System);
+  const CSSDoublePoint point = ScreenPoint(CallerType::System);
   auto scale = mPresContext ? mPresContext->CSSToDevPixelScale()
                             : CSSToLayoutDeviceScale();
   return LayoutDeviceIntPoint::Round(point * scale);
 }
 
 DesktopIntPoint MouseEvent::ScreenPointDesktopPix() const {
-  const CSSIntPoint point = ScreenPoint(CallerType::System);
+  const CSSDoublePoint point = ScreenPoint(CallerType::System);
   auto scale =
       mPresContext
           ? mPresContext->CSSToDevPixelScale() /
@@ -272,35 +328,82 @@
       DesktopIntRect(ScreenPointDesktopPix(), DesktopIntSize(1, 1)));
 }
 
-CSSIntPoint MouseEvent::PagePoint() const {
+CSSDoublePoint MouseEvent::PagePoint() const {
   if (mEvent->mFlags.mIsPositionless) {
     return {};
   }
 
   if (mPrivateDataDuplicated) {
+    // mPagePoint should be floored when it started to cache the values after
+    // the propagation.
+    MOZ_ASSERT_IF(!mUseFractionalCoords,
+                  mPagePoint == CSSIntPoint::Floor(mPagePoint));
     return mPagePoint;
   }
 
-  return Event::GetPageCoords(mPresContext, mEvent, mEvent->mRefPoint,
-                              mDefaultClientPoint);
+  // If this is a trusted event, mWidgetRelativeOffset is a copy of
+  // mEvent->mRefPoint, so, the values are integer.
+  // If this is an untrusted event, mWidgetRelativeOffset should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mWidgetRelativePoint ==
+                    LayoutDeviceIntPoint::Floor(mWidgetRelativePoint));
+  // If this is a trusted event, mDefaultClientPoint should be floored when
+  // it started to cache the values after the propagation.
+  // If this is an untrusted event, mDefaultClientPoint should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mDefaultClientPoint == CSSIntPoint::Floor(mDefaultClientPoint));
+  const CSSDoublePoint pagePoint = Event::GetPageCoords(
+      mPresContext, mEvent, mWidgetRelativePoint, mDefaultClientPoint);
+  return mUseFractionalCoords ? pagePoint : RoundedToInt(pagePoint);
 }
 
-CSSIntPoint MouseEvent::ClientPoint() const {
+CSSDoublePoint MouseEvent::ClientPoint() const {
   if (mEvent->mFlags.mIsPositionless) {
     return {};
   }
 
-  return Event::GetClientCoords(mPresContext, mEvent, mEvent->mRefPoint,
-                                mDefaultClientPoint);
+  // If this is a trusted event, mWidgetRelativeOffset is a copy of
+  // mEvent->mRefPoint, so, the values are integer.
+  // If this is an untrusted event, mWidgetRelativeOffset should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mWidgetRelativePoint ==
+                    LayoutDeviceIntPoint::Floor(mWidgetRelativePoint));
+  // If this is a trusted event, mDefaultClientPoint should be floored when
+  // it started to cache the values after the propagation.
+  // If this is an untrusted event, mDefaultClientPoint should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mDefaultClientPoint == CSSIntPoint::Floor(mDefaultClientPoint));
+  const CSSDoublePoint clientPoint = Event::GetClientCoords(
+      mPresContext, mEvent, mWidgetRelativePoint, mDefaultClientPoint);
+  return mUseFractionalCoords ? clientPoint : RoundedToInt(clientPoint);
 }
 
-CSSIntPoint MouseEvent::OffsetPoint() const {
+CSSDoublePoint MouseEvent::OffsetPoint() const {
   if (mEvent->mFlags.mIsPositionless) {
     return {};
   }
 
-  return Event::GetOffsetCoords(mPresContext, mEvent, mEvent->mRefPoint,
-                                mDefaultClientPoint);
+  // If this is a trusted event, mWidgetRelativeOffset is a copy of
+  // mEvent->mRefPoint, so, the values are integer.
+  // If this is an untrusted event, mWidgetRelativeOffset should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mWidgetRelativePoint ==
+                    LayoutDeviceIntPoint::Floor(mWidgetRelativePoint));
+  // If this is a trusted event, mDefaultClientPoint should be floored when
+  // it started to cache the values after the propagation.
+  // If this is an untrusted event, mDefaultClientPoint should be floored when
+  // it's initialized.
+  MOZ_ASSERT_IF(!mUseFractionalCoords,
+                mDefaultClientPoint == CSSIntPoint::Floor(mDefaultClientPoint));
+  RefPtr<nsPresContext> presContext(mPresContext);
+  const CSSDoublePoint offsetPoint = Event::GetOffsetCoords(
+      presContext, mEvent, mWidgetRelativePoint, mDefaultClientPoint);
+  return mUseFractionalCoords ? offsetPoint : RoundedToInt(offsetPoint);
 }
 
 nsIntPoint MouseEvent::GetMovementPoint() const {