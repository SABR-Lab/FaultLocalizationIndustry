# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/jsapi/WebrtcGlobalInformation.cpp
# Commit: 3cbde68f2f7d
# Full Hash: 3cbde68f2f7d3d6482696d160db00b62fa6a5b30
# Author: Byron Campen [:bwc] <docfaraday@gmail.com>
# Date: 2022-12-22 21:34:53
# Regressor Bug: 1800136
# File Overlap Count: 1
# Description:
#   Bug 1800136: Fix gap between PC.close() and the storage of its final stats in PeerConnectionCtx. r=ng
#   
#   Ensures that:
#   1) We never have stats report in a still-registered PC _and_ the stats for
#      closed PCs.
# ==============================================================================

diff -r fef019ffca5f -r 3cbde68f2f7d dom/media/webrtc/jsapi/WebrtcGlobalInformation.cpp
--- a/dom/media/webrtc/jsapi/WebrtcGlobalInformation.cpp	Thu Dec 22 15:29:02 2022 +0000
+++ b/dom/media/webrtc/jsapi/WebrtcGlobalInformation.cpp	Thu Dec 22 15:29:02 2022 +0000
@@ -84,26 +84,45 @@
   return nullptr;
 }
 
+static nsTArray<dom::RTCStatsReportInternal>& GetWebrtcGlobalStatsStash() {
+  static StaticAutoPtr<nsTArray<dom::RTCStatsReportInternal>> sStash;
+  if (!sStash) {
+    sStash = new nsTArray<dom::RTCStatsReportInternal>();
+    ClearOnShutdown(&sStash);
+  }
+  return *sStash;
+}
+
 static RefPtr<PWebrtcGlobalParent::GetStatsPromise>
 GetStatsPromiseForThisProcess(const nsAString& aPcIdFilter) {
   nsTArray<RefPtr<dom::RTCStatsReportPromise>> promises;
 
+  std::set<nsString> pcids;
   if (auto ctx = GetPeerConnectionCtx()) {
-    // Grab stats for non-closed PCs
+    // Grab stats for PCs that still exist
     ctx->ForEachPeerConnection([&](PeerConnectionImpl* aPc) {
       if (!aPcIdFilter.IsEmpty() &&
           !aPcIdFilter.EqualsASCII(aPc->GetIdAsAscii().c_str())) {
         return;
       }
-      if (aPc->IsClosed()) {
-        return;
+      if (!aPc->IsClosed() || !aPc->LongTermStatsIsDisabled()) {
+        nsString id;
+        aPc->GetId(id);
+        pcids.insert(id);
+        promises.AppendElement(aPc->GetStats(nullptr, true));
       }
-      promises.AppendElement(aPc->GetStats(nullptr, true));
     });
 
-    // Grab stats for closed PCs
-    for (const auto& report : ctx->mStatsForClosedPeerConnections) {
-      if (aPcIdFilter.IsEmpty() || aPcIdFilter == report.mPcid) {
+    // Grab previously stashed stats, if they aren't dupes, and ensure they
+    // are marked closed. (In a content process, this should already have
+    // happened, but in the parent process, the stash will contain the last
+    // observed stats from the content processes. From the perspective of the
+    // parent process, these are assumed closed unless we see new stats from the
+    // content process that say otherwise.)
+    for (auto& report : GetWebrtcGlobalStatsStash()) {
+      report.mClosed = true;
+      if ((aPcIdFilter.IsEmpty() || aPcIdFilter == report.mPcid) &&
+          !pcids.count(report.mPcid)) {
         promises.AppendElement(dom::RTCStatsReportPromise::CreateAndResolve(
             MakeUnique<dom::RTCStatsReportInternal>(report), __func__));
       }
@@ -129,15 +148,6 @@
              std::move(UnwrapUniquePtrs));
 }
 
-static nsTArray<dom::RTCStatsReportInternal>& GetWebrtcGlobalStatsStash() {
-  static StaticAutoPtr<nsTArray<dom::RTCStatsReportInternal>> sStash;
-  if (!sStash) {
-    sStash = new nsTArray<dom::RTCStatsReportInternal>();
-    ClearOnShutdown(&sStash);
-  }
-  return *sStash;
-}
-
 static std::map<int32_t, dom::Sequence<nsString>>& GetWebrtcGlobalLogStash() {
   static StaticAutoPtr<std::map<int32_t, dom::Sequence<nsString>>> sStash;
   if (!sStash) {
@@ -147,10 +157,10 @@
   return *sStash;
 }
 
-static void ClearClosedStats() {
+static void ClearLongTermStats() {
   GetWebrtcGlobalStatsStash().Clear();
   if (auto ctx = GetPeerConnectionCtx()) {
-    ctx->mStatsForClosedPeerConnections.Clear();
+    ctx->ClearClosedStats();
   }
 }
 
@@ -170,7 +180,7 @@
   }
 
   // Flush the history for the chrome process
-  ClearClosedStats();
+  ClearLongTermStats();
 }
 
 void WebrtcGlobalInformation::GetAllStats(
@@ -211,60 +221,31 @@
         WebrtcGlobalStatisticsReport flattened;
         MOZ_RELEASE_ASSERT(aResult.IsResolve(),
                            "AllSettled should never reject!");
-        for (auto& contentProcessResult : aResult.ResolveValue()) {
+        // Flatten stats from content processes and parent process.
+        // The stats from the parent process (which will come last) might
+        // contain some stale content-process stats, so skip those.
+        for (auto& processResult : aResult.ResolveValue()) {
           // TODO: Report rejection on individual content processes someday?
-          if (contentProcessResult.IsResolve()) {
-            for (auto& pcStats : contentProcessResult.ResolveValue()) {
-              pcids.insert(pcStats.mPcid);
-              if (!flattened.mReports.AppendElement(std::move(pcStats),
-                                                    fallible)) {
-                mozalloc_handle_oom(0);
+          if (processResult.IsResolve()) {
+            for (auto& pcStats : processResult.ResolveValue()) {
+              if (!pcids.count(pcStats.mPcid)) {
+                pcids.insert(pcStats.mPcid);
+                if (!flattened.mReports.AppendElement(std::move(pcStats),
+                                                      fallible)) {
+                  mozalloc_handle_oom(0);
+                }
               }
             }
           }
         }
 
         if (filter.IsEmpty()) {
-          // Unfiltered is pretty simple; add stuff from stash that is
-          // missing, then stomp the stash with the new reports.
-          for (auto& pcStats : GetWebrtcGlobalStatsStash()) {
-            if (!pcids.count(pcStats.mPcid)) {
-              // Stats from a closed PC or stopped content process.
-              // Content process may have gone away before we got to update
-              // this.
-              pcStats.mClosed = true;
-              if (!flattened.mReports.AppendElement(std::move(pcStats),
-                                                    fallible)) {
-                mozalloc_handle_oom(0);
-              }
-            }
-          }
+          // Unfiltered is simple; the flattened result becomes the new stash.
           GetWebrtcGlobalStatsStash() = flattened.mReports;
-        } else {
-          // Filtered is slightly more complex
-          if (flattened.mReports.IsEmpty()) {
-            // Find entry from stash and add it to report
-            for (auto& pcStats : GetWebrtcGlobalStatsStash()) {
-              if (pcStats.mPcid == filter) {
-                pcStats.mClosed = true;
-                if (!flattened.mReports.AppendElement(std::move(pcStats),
-                                                      fallible)) {
-                  mozalloc_handle_oom(0);
-                }
-              }
-            }
-          } else {
-            // Find entries in stash, remove them, and then add new entries
-            for (size_t i = 0; i < GetWebrtcGlobalStatsStash().Length();) {
-              auto& pcStats = GetWebrtcGlobalStatsStash()[i];
-              if (pcStats.mPcid == filter) {
-                GetWebrtcGlobalStatsStash().RemoveElementAt(i);
-              } else {
-                ++i;
-              }
-            }
-            GetWebrtcGlobalStatsStash().AppendElements(flattened.mReports);
-          }
+        } else if (!flattened.mReports.IsEmpty()) {
+          // Update our stash with the single result.
+          MOZ_ASSERT(flattened.mReports.Length() == 1);
+          StashStats(flattened.mReports[0]);
         }
 
         IgnoredErrorResult rv;
@@ -495,6 +476,23 @@
   aDir = NS_ConvertASCIItoUTF16(sAecDebugLogDir.valueOr(""_ns));
 }
 
+/*static*/
+void WebrtcGlobalInformation::StashStats(
+    const dom::RTCStatsReportInternal& aReport) {
+  // Remove previous report, if present
+  // TODO: Make this a map instead of an array?
+  for (size_t i = 0; i < GetWebrtcGlobalStatsStash().Length();) {
+    auto& pcStats = GetWebrtcGlobalStatsStash()[i];
+    if (pcStats.mPcid == aReport.mPcid) {
+      GetWebrtcGlobalStatsStash().RemoveElementAt(i);
+      break;
+    }
+    ++i;
+  }
+
+  GetWebrtcGlobalStatsStash().AppendElement(aReport);
+}
+
 WebrtcGlobalParent* WebrtcGlobalParent::Alloc() {
   return WebrtcContentParents::Alloc();
 }
@@ -543,7 +541,7 @@
     return IPC_OK();
   }
 
-  ClearClosedStats();
+  ClearLongTermStats();
   return IPC_OK();
 }
 
@@ -618,51 +616,4 @@
   MOZ_COUNT_DTOR(WebrtcGlobalChild);
 }
 
-static void StoreLongTermICEStatisticsImpl_m(RTCStatsReportInternal* report) {
-  using namespace Telemetry;
-
-  report->mClosed = true;
-
-  for (const auto& inboundRtpStats : report->mInboundRtpStreamStats) {
-    bool isVideo = (inboundRtpStats.mId.Value().Find(u"video") != -1);
-    if (!isVideo) {
-      continue;
-    }
-    if (inboundRtpStats.mDiscardedPackets.WasPassed() &&
-        report->mCallDurationMs.WasPassed()) {
-      double mins = report->mCallDurationMs.Value() / (1000 * 60);
-      if (mins > 0) {
-        Accumulate(
-            WEBRTC_VIDEO_DECODER_DISCARDED_PACKETS_PER_CALL_PPM,
-            uint32_t(double(inboundRtpStats.mDiscardedPackets.Value()) / mins));
-      }
-    }
-  }
-
-  // Finally, store the stats
-
-  if (auto ctx = GetPeerConnectionCtx()) {
-    if (!ctx->mStatsForClosedPeerConnections.AppendElement(*report, fallible)) {
-      mozalloc_handle_oom(0);
-    }
-  }
-}
-
-void WebrtcGlobalInformation::StoreLongTermICEStatistics(
-    PeerConnectionImpl& aPc) {
-  if (aPc.IceConnectionState() == RTCIceConnectionState::New) {
-    // ICE has not started; we won't have any remote candidates, so recording
-    // statistics on gathered candidates is pointless.
-    return;
-  }
-
-  aPc.GetStats(nullptr, true)
-      ->Then(
-          GetMainThreadSerialEventTarget(), __func__,
-          [=](UniquePtr<dom::RTCStatsReportInternal>&& aReport) {
-            StoreLongTermICEStatisticsImpl_m(aReport.get());
-          },
-          [=](nsresult aError) {});
-}
-
 }  // namespace mozilla::dom