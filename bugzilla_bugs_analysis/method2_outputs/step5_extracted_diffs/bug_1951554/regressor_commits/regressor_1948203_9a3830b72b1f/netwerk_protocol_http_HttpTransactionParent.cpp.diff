# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/protocol/http/HttpTransactionParent.cpp
# Commit: 9a3830b72b1f
# Full Hash: 9a3830b72b1f2a9640a7ff945b91d17d67828bcd
# Author: Kershaw Chang <kershaw@mozilla.com>
# Date: 2025-02-24 17:07:55
# Regressor Bug: 1948203
# File Overlap Count: 5
# Description:
#   Bug 1948203 - Skip alt-svc validation if we already connected to the server, r=necko-reviewers,jesup
#   
#   This patch optimizes how Firefox handles speculative connections for alt-svc headers. When a server sends an alt-svc header, Firefox normally creates a speculative connection to validate it. With this patch, if the connectionâ€™s hash key matches the one generated from the alt-svc header, the validation step is skipped since an equivalent connection is already in place, avoiding unnecessary work.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D238218
# ==============================================================================

diff -r d5962b430cd3 -r 9a3830b72b1f netwerk/protocol/http/HttpTransactionParent.cpp
--- a/netwerk/protocol/http/HttpTransactionParent.cpp	Mon Feb 24 09:01:12 2025 +0000
+++ b/netwerk/protocol/http/HttpTransactionParent.cpp	Mon Feb 24 09:20:35 2025 +0000
@@ -414,22 +414,26 @@
     const bool& aDataToChildProcess, const bool& aRestarted,
     const uint32_t& aHTTPSSVCReceivedStage, const bool& aSupportsHttp3,
     const nsIRequest::TRRMode& aMode, const TRRSkippedReason& aTrrSkipReason,
-    const uint32_t& aCaps, const TimeStamp& aOnStartRequestStartTime) {
+    const uint32_t& aCaps, const TimeStamp& aOnStartRequestStartTime,
+    const HttpConnectionInfoCloneArgs& aArgs) {
+  RefPtr<nsHttpConnectionInfo> cinfo =
+      nsHttpConnectionInfo::DeserializeHttpConnectionInfoCloneArgs(aArgs);
   mEventQ->RunOrEnqueue(new NeckoTargetChannelFunctionEvent(
-      this, [self = UnsafePtr<HttpTransactionParent>(this), aStatus,
-             aResponseHead = std::move(aResponseHead),
-             securityInfo = nsCOMPtr{aSecurityInfo}, aProxyConnectFailed,
-             aTimings, aProxyConnectResponseCode,
-             aDataForSniffer = CopyableTArray{std::move(aDataForSniffer)},
-             aAltSvcUsed, aDataToChildProcess, aRestarted,
-             aHTTPSSVCReceivedStage, aSupportsHttp3, aMode, aTrrSkipReason,
-             aCaps, aOnStartRequestStartTime]() mutable {
+      this,
+      [self = UnsafePtr<HttpTransactionParent>(this), aStatus,
+       aResponseHead = std::move(aResponseHead),
+       securityInfo = nsCOMPtr{aSecurityInfo}, aProxyConnectFailed, aTimings,
+       aProxyConnectResponseCode,
+       aDataForSniffer = CopyableTArray{std::move(aDataForSniffer)},
+       aAltSvcUsed, aDataToChildProcess, aRestarted, aHTTPSSVCReceivedStage,
+       aSupportsHttp3, aMode, aTrrSkipReason, aCaps, aOnStartRequestStartTime,
+       cinfo{std::move(cinfo)}]() mutable {
         self->DoOnStartRequest(
             aStatus, std::move(aResponseHead), securityInfo,
             aProxyConnectFailed, aTimings, aProxyConnectResponseCode,
             std::move(aDataForSniffer), aAltSvcUsed, aDataToChildProcess,
             aRestarted, aHTTPSSVCReceivedStage, aSupportsHttp3, aMode,
-            aTrrSkipReason, aCaps, aOnStartRequestStartTime);
+            aTrrSkipReason, aCaps, aOnStartRequestStartTime, cinfo);
       }));
   return IPC_OK();
 }
@@ -461,7 +465,8 @@
     const bool& aDataToChildProcess, const bool& aRestarted,
     const uint32_t& aHTTPSSVCReceivedStage, const bool& aSupportsHttp3,
     const nsIRequest::TRRMode& aMode, const TRRSkippedReason& aSkipReason,
-    const uint32_t& aCaps, const TimeStamp& aOnStartRequestStartTime) {
+    const uint32_t& aCaps, const TimeStamp& aOnStartRequestStartTime,
+    nsHttpConnectionInfo* aConnInfo) {
   LOG(("HttpTransactionParent::DoOnStartRequest [this=%p aStatus=%" PRIx32
        "]\n",
        this, static_cast<uint32_t>(aStatus)));
@@ -481,6 +486,7 @@
   mCaps = aCaps;
   mSecurityInfo = aSecurityInfo;
   mOnStartRequestStartTime = aOnStartRequestStartTime;
+  mConnInfo = aConnInfo;
 
   if (aResponseHead.isSome()) {
     mResponseHead =
@@ -606,7 +612,6 @@
     const Maybe<nsHttpHeaderArray>& aResponseTrailers,
     Maybe<TransactionObserverResult>&& aTransactionObserverResult,
     const TimeStamp& aLastActiveTabOptHit,
-    const HttpConnectionInfoCloneArgs& aArgs,
     const TimeStamp& aOnStopRequestStartTime) {
   LOG(("HttpTransactionParent::RecvOnStopRequest [this=%p status=%" PRIx32
        "]\n",
@@ -617,16 +622,15 @@
   if (mCanceled) {
     return IPC_OK();
   }
-  RefPtr<nsHttpConnectionInfo> cinfo =
-      nsHttpConnectionInfo::DeserializeHttpConnectionInfoCloneArgs(aArgs);
+
   mEventQ->RunOrEnqueue(new NeckoTargetChannelFunctionEvent(
       this, [self = UnsafePtr<HttpTransactionParent>(this), aStatus,
              aResponseIsComplete, aTransferSize, aTimings, aResponseTrailers,
              aTransactionObserverResult{std::move(aTransactionObserverResult)},
-             cinfo{std::move(cinfo)}, aOnStopRequestStartTime]() mutable {
+             aOnStopRequestStartTime]() mutable {
         self->DoOnStopRequest(aStatus, aResponseIsComplete, aTransferSize,
                               aTimings, aResponseTrailers,
-                              std::move(aTransactionObserverResult), cinfo,
+                              std::move(aTransactionObserverResult),
                               aOnStopRequestStartTime);
       }));
   return IPC_OK();
@@ -637,7 +641,7 @@
     const int64_t& aTransferSize, const TimingStructArgs& aTimings,
     const Maybe<nsHttpHeaderArray>& aResponseTrailers,
     Maybe<TransactionObserverResult>&& aTransactionObserverResult,
-    nsHttpConnectionInfo* aConnInfo, const TimeStamp& aOnStopRequestStartTime) {
+    const TimeStamp& aOnStopRequestStartTime) {
   LOG(("HttpTransactionParent::DoOnStopRequest [this=%p]\n", this));
   if (mCanceled) {
     return;
@@ -658,7 +662,7 @@
   if (aResponseTrailers.isSome()) {
     mResponseTrailers = MakeUnique<nsHttpHeaderArray>(aResponseTrailers.ref());
   }
-  mConnInfo = aConnInfo;
+
   if (aTransactionObserverResult.isSome()) {
     TransactionObserverFunc obs = nullptr;
     std::swap(obs, mTransactionObserver);