# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/wasm/WasmInstance.cpp
# Commit: 1a3bc285395f
# Full Hash: 1a3bc285395ffcc5d9281dd45d4f6c2bb918bf43
# Author: Julien Pages <jpages@mozilla.com>
# Date: 2025-03-04 04:58:00
# Regressor Bug: 1861078
# File Overlap Count: 1
# Description:
#   Bug 1861078 - wasm: make metadata offsets relative to CodeBlock->codeBase. r=rhunt
#   
#   Metadata used offsets to the beginning of code segment. Change that to use
#   offsets relative to the beginning of CodeBlock. This allows us to avoid offseting
#   metadata later on and prepare the work for simplification of stackmaps.
# ==============================================================================

diff -r 66d70b730ea6 -r 1a3bc285395f js/src/wasm/WasmInstance.cpp
--- a/js/src/wasm/WasmInstance.cpp	Mon Mar 03 16:15:17 2025 +0000
+++ b/js/src/wasm/WasmInstance.cpp	Mon Mar 03 16:37:47 2025 +0000
@@ -329,8 +329,7 @@
   }
 
   // The import may already have become optimized.
-  void* jitExitCode =
-      code().sharedStubs().segment->base() + fi.jitExitCodeOffset();
+  void* jitExitCode = code().sharedStubs().base() + fi.jitExitCodeOffset();
   if (import.code == jitExitCode) {
     return true;
   }
@@ -2311,9 +2310,9 @@
 
   // Initialize the request-tier-up stub pointer, if relevant
   if (code().mode() == CompileMode::LazyTiering) {
-    setRequestTierUpStub(code().sharedStubs().segment->base() +
+    setRequestTierUpStub(code().sharedStubs().base() +
                          code().requestTierUpStubOffset());
-    setUpdateCallRefMetricsStub(code().sharedStubs().segment->base() +
+    setUpdateCallRefMetricsStub(code().sharedStubs().base() +
                                 code().updateCallRefMetricsStubOffset());
   } else {
     setRequestTierUpStub(nullptr);
@@ -2439,14 +2438,12 @@
       } else {
         import.instance = this;
         import.realm = fun->realm();
-        import.code =
-            code().sharedStubs().segment->base() + fi.interpExitCodeOffset();
+        import.code = code().sharedStubs().base() + fi.interpExitCodeOffset();
       }
     } else {
       import.instance = this;
       import.realm = f->nonCCWRealm();
-      import.code =
-          code().sharedStubs().segment->base() + fi.interpExitCodeOffset();
+      import.code = code().sharedStubs().base() + fi.interpExitCodeOffset();
     }
   }
 
@@ -3619,7 +3616,7 @@
   Instance* instance = const_cast<Instance*>(this);
   const SuperTypeVector* superTypeVector = funcTypeDef.superTypeVector();
   void* uncheckedCallEntry =
-      codeBlock.segment->base() + codeRange.funcUncheckedCallEntry();
+      codeBlock.base() + codeRange.funcUncheckedCallEntry();
 
   if (isAsmJS()) {
     // asm.js needs to act like a normal JS function which means having the
@@ -4025,12 +4022,11 @@
   const CodeBlock& codeBlock = code().funcCodeBlock(funcIndex);
   const FuncExport& funcExport = codeBlock.lookupFuncExport(funcIndex);
   const CodeRange& range = codeBlock.codeRange(funcExport);
-  const CodeSegment& segment = *codeBlock.segment;
-
-  MOZ_ASSERT(range.begin() < segment.lengthBytes());
-  MOZ_ASSERT(range.end() < segment.lengthBytes());
-
-  uint8_t* functionCode = segment.base() + range.begin();
+
+  MOZ_ASSERT(range.begin() < codeBlock.length());
+  MOZ_ASSERT(range.end() < codeBlock.length());
+
+  uint8_t* functionCode = codeBlock.base() + range.begin();
   jit::Disassemble(functionCode, range.end() - range.begin(), printString);
 }
 