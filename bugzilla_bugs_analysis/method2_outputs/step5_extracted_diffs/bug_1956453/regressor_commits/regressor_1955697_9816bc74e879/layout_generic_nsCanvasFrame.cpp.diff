# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsCanvasFrame.cpp
# Commit: 9816bc74e879
# Full Hash: 9816bc74e879c673ec4541463562d846aadc562a
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2025-03-25 04:32:21
# Regressor Bug: 1955697
# File Overlap Count: 1
# Description:
#   Bug 1955697 - Clean-up a little bit nsCanvasFrame::BuildDisplayList. r=mstange
#   
#   No behavior change.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D242623
# ==============================================================================

diff -r 17f4343ae8f0 -r 9816bc74e879 layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp	Mon Mar 24 18:53:47 2025 +0000
+++ b/layout/generic/nsCanvasFrame.cpp	Mon Mar 24 18:54:34 2025 +0000
@@ -414,6 +414,9 @@
 
 void nsCanvasFrame::BuildDisplayList(nsDisplayListBuilder* aBuilder,
                                      const nsDisplayListSet& aLists) {
+  MOZ_ASSERT(IsVisibleForPainting(),
+             "::-moz-{scrolled-,}canvas doesn't inherit from anything that can "
+             "be invisible, and we don't specify visibility in UA sheets");
   if (GetPrevInFlow()) {
     DisplayOverflowContainers(aBuilder, aLists);
   }
@@ -425,174 +428,164 @@
   // We don't have any border or outline, and our background draws over
   // the overflow area, so just add nsDisplayCanvasBackground instead of
   // calling DisplayBorderBackgroundOutline.
-  if (IsVisibleForPainting()) {
-    ComputedStyle* bg = nullptr;
-    nsIFrame* dependentFrame = nullptr;
-    bool isThemed = IsThemed();
-    if (!isThemed) {
-      dependentFrame = nsCSSRendering::FindBackgroundFrame(this);
-      if (dependentFrame) {
-        bg = dependentFrame->Style();
-        if (dependentFrame == this) {
-          dependentFrame = nullptr;
+  ComputedStyle* bg = nullptr;
+  nsIFrame* dependentFrame = nullptr;
+  bool isThemed = IsThemed();
+  if (!isThemed) {
+    dependentFrame = nsCSSRendering::FindBackgroundFrame(this);
+    if (dependentFrame) {
+      bg = dependentFrame->Style();
+      if (dependentFrame == this) {
+        dependentFrame = nullptr;
+      }
+    }
+  }
+
+  if (isThemed) {
+    aLists.BorderBackground()->AppendNewToTop<nsDisplayCanvasThemedBackground>(
+        aBuilder, this);
+    return;
+  }
+
+  if (!bg) {
+    return;
+  }
+
+  const ActiveScrolledRoot* asr = aBuilder->CurrentActiveScrolledRoot();
+
+  bool needBlendContainer = false;
+  nsDisplayListBuilder::AutoContainerASRTracker contASRTracker(aBuilder);
+
+  const bool suppressBackgroundImage = [&] {
+    // Handle print settings.
+    if (!ComputeShouldPaintBackground().mImage) {
+      return true;
+    }
+    // In high-contrast-mode, we suppress background-image on the canvas frame
+    // (even when backplating), because users expect site backgrounds to
+    // conform to their HCM background color when a solid color is rendered,
+    // and some websites use solid-color images instead of an overwritable
+    // background color.
+    if (PresContext()->ForcingColors() &&
+        StaticPrefs::
+            browser_display_suppress_canvas_background_image_on_forced_colors()) {
+      return true;
+    }
+    return false;
+  }();
+
+  nsDisplayList layerItems(aBuilder);
+
+  // Create separate items for each background layer.
+  const nsStyleImageLayers& layers = bg->StyleBackground()->mImage;
+  NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT(i, layers) {
+    if (layers.mLayers[i].mImage.IsNone() || suppressBackgroundImage) {
+      continue;
+    }
+    if (layers.mLayers[i].mBlendMode != StyleBlend::Normal) {
+      needBlendContainer = true;
+    }
+
+    nsRect bgRect = GetRectRelativeToSelf() + aBuilder->ToReferenceFrame(this);
+
+    const ActiveScrolledRoot* thisItemASR = asr;
+    nsDisplayList thisItemList(aBuilder);
+    nsDisplayBackgroundImage::InitData bgData =
+        nsDisplayBackgroundImage::GetInitData(aBuilder, this, i, bgRect, bg);
+
+    if (bgData.shouldFixToViewport) {
+      auto* displayData = aBuilder->GetCurrentFixedBackgroundDisplayData();
+      nsDisplayListBuilder::AutoBuildingDisplayList buildingDisplayList(
+          aBuilder, this, aBuilder->GetVisibleRect(), aBuilder->GetDirtyRect());
+
+      DisplayListClipState::AutoSaveRestore clipState(aBuilder);
+      nsDisplayListBuilder::AutoCurrentActiveScrolledRootSetter asrSetter(
+          aBuilder);
+      if (displayData) {
+        const nsPoint offset = GetOffsetTo(PresShell()->GetRootFrame());
+        aBuilder->SetVisibleRect(displayData->mVisibleRect + offset);
+        aBuilder->SetDirtyRect(displayData->mDirtyRect + offset);
+
+        clipState.SetClipChainForContainingBlockDescendants(
+            displayData->mContainingBlockClipChain);
+        asrSetter.SetCurrentActiveScrolledRoot(
+            displayData->mContainingBlockActiveScrolledRoot);
+        asrSetter.SetCurrentScrollParentId(displayData->mScrollParentId);
+        thisItemASR = displayData->mContainingBlockActiveScrolledRoot;
+      }
+      nsDisplayCanvasBackgroundImage* bgItem = nullptr;
+      {
+        DisplayListClipState::AutoSaveRestore bgImageClip(aBuilder);
+        bgImageClip.Clear();
+        bgItem = MakeDisplayItemWithIndex<nsDisplayCanvasBackgroundImage>(
+            aBuilder, this, /* aIndex = */ i, bgData);
+        if (bgItem) {
+          bgItem->SetDependentFrame(aBuilder, dependentFrame);
         }
       }
+      if (bgItem) {
+        thisItemList.AppendToTop(
+            nsDisplayFixedPosition::CreateForFixedBackground(
+                aBuilder, this, nullptr, bgItem, i, asr));
+      }
+
+    } else {
+      nsDisplayCanvasBackgroundImage* bgItem =
+          MakeDisplayItemWithIndex<nsDisplayCanvasBackgroundImage>(
+              aBuilder, this, /* aIndex = */ i, bgData);
+      if (bgItem) {
+        bgItem->SetDependentFrame(aBuilder, dependentFrame);
+        thisItemList.AppendToTop(bgItem);
+      }
     }
 
-    if (isThemed) {
-      aLists.BorderBackground()
-          ->AppendNewToTop<nsDisplayCanvasThemedBackground>(aBuilder, this);
-      return;
-    }
-
-    if (!bg) {
-      return;
+    if (layers.mLayers[i].mBlendMode != StyleBlend::Normal) {
+      DisplayListClipState::AutoSaveRestore blendClip(aBuilder);
+      thisItemList.AppendNewToTopWithIndex<nsDisplayBlendMode>(
+          aBuilder, this, i + 1, &thisItemList, layers.mLayers[i].mBlendMode,
+          thisItemASR, true);
     }
-
-    const ActiveScrolledRoot* asr = aBuilder->CurrentActiveScrolledRoot();
-
-    bool needBlendContainer = false;
-    nsDisplayListBuilder::AutoContainerASRTracker contASRTracker(aBuilder);
-
-    const bool suppressBackgroundImage = [&] {
-      // Handle print settings.
-      if (!ComputeShouldPaintBackground().mImage) {
-        return true;
-      }
-      // In high-contrast-mode, we suppress background-image on the canvas frame
-      // (even when backplating), because users expect site backgrounds to
-      // conform to their HCM background color when a solid color is rendered,
-      // and some websites use solid-color images instead of an overwritable
-      // background color.
-      if (PresContext()->ForcingColors() &&
-          StaticPrefs::
-              browser_display_suppress_canvas_background_image_on_forced_colors()) {
-        return true;
-      }
-      return false;
-    }();
+    layerItems.AppendToTop(&thisItemList);
+  }
 
-    nsDisplayList layerItems(aBuilder);
-
-    // Create separate items for each background layer.
-    const nsStyleImageLayers& layers = bg->StyleBackground()->mImage;
-    NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT(i, layers) {
-      if (layers.mLayers[i].mImage.IsNone() || suppressBackgroundImage) {
-        continue;
-      }
-      if (layers.mLayers[i].mBlendMode != StyleBlend::Normal) {
-        needBlendContainer = true;
-      }
-
-      nsRect bgRect =
-          GetRectRelativeToSelf() + aBuilder->ToReferenceFrame(this);
+  bool hasFixedBottomLayer =
+      layers.mImageCount > 0 &&
+      layers.mLayers[0].mAttachment == StyleImageLayerAttachment::Fixed;
 
-      const ActiveScrolledRoot* thisItemASR = asr;
-      nsDisplayList thisItemList(aBuilder);
-      nsDisplayBackgroundImage::InitData bgData =
-          nsDisplayBackgroundImage::GetInitData(aBuilder, this, i, bgRect, bg);
-
-      if (bgData.shouldFixToViewport) {
-        auto* displayData = aBuilder->GetCurrentFixedBackgroundDisplayData();
-        nsDisplayListBuilder::AutoBuildingDisplayList buildingDisplayList(
-            aBuilder, this, aBuilder->GetVisibleRect(),
-            aBuilder->GetDirtyRect());
-
-        DisplayListClipState::AutoSaveRestore clipState(aBuilder);
-        nsDisplayListBuilder::AutoCurrentActiveScrolledRootSetter asrSetter(
-            aBuilder);
-        if (displayData) {
-          const nsPoint offset = GetOffsetTo(PresShell()->GetRootFrame());
-          aBuilder->SetVisibleRect(displayData->mVisibleRect + offset);
-          aBuilder->SetDirtyRect(displayData->mDirtyRect + offset);
+  nsDisplayList list(aBuilder);
 
-          clipState.SetClipChainForContainingBlockDescendants(
-              displayData->mContainingBlockClipChain);
-          asrSetter.SetCurrentActiveScrolledRoot(
-              displayData->mContainingBlockActiveScrolledRoot);
-          asrSetter.SetCurrentScrollParentId(displayData->mScrollParentId);
-          thisItemASR = displayData->mContainingBlockActiveScrolledRoot;
-        }
-        nsDisplayCanvasBackgroundImage* bgItem = nullptr;
-        {
-          DisplayListClipState::AutoSaveRestore bgImageClip(aBuilder);
-          bgImageClip.Clear();
-          bgItem = MakeDisplayItemWithIndex<nsDisplayCanvasBackgroundImage>(
-              aBuilder, this, /* aIndex = */ i, bgData);
-          if (bgItem) {
-            bgItem->SetDependentFrame(aBuilder, dependentFrame);
-          }
-        }
-        if (bgItem) {
-          thisItemList.AppendToTop(
-              nsDisplayFixedPosition::CreateForFixedBackground(
-                  aBuilder, this, nullptr, bgItem, i, asr));
-        }
-
-      } else {
-        nsDisplayCanvasBackgroundImage* bgItem =
-            MakeDisplayItemWithIndex<nsDisplayCanvasBackgroundImage>(
-                aBuilder, this, /* aIndex = */ i, bgData);
-        if (bgItem) {
-          bgItem->SetDependentFrame(aBuilder, dependentFrame);
-          thisItemList.AppendToTop(bgItem);
-        }
-      }
+  if (!hasFixedBottomLayer || needBlendContainer) {
+    // Put a scrolled background color item in place, at the bottom of the
+    // list. The color of this item will be filled in during
+    // PresShell::AddCanvasBackgroundColorItem.
+    // Do not add this item if there's a fixed background image at the bottom
+    // (unless we have to, for correct blending); with a fixed background,
+    // it's better to allow the fixed background image to combine itself with
+    // a non-scrolled background color directly underneath, rather than
+    // interleaving the two with a scrolled background color.
+    // PresShell::AddCanvasBackgroundColorItem makes sure there always is a
+    // non-scrolled background color item at the bottom.
+    list.AppendNewToTop<nsDisplayCanvasBackgroundColor>(aBuilder, this);
+  }
 
-      if (layers.mLayers[i].mBlendMode != StyleBlend::Normal) {
-        DisplayListClipState::AutoSaveRestore blendClip(aBuilder);
-        thisItemList.AppendNewToTopWithIndex<nsDisplayBlendMode>(
-            aBuilder, this, i + 1, &thisItemList, layers.mLayers[i].mBlendMode,
-            thisItemASR, true);
-      }
-      layerItems.AppendToTop(&thisItemList);
-    }
-
-    bool hasFixedBottomLayer =
-        layers.mImageCount > 0 &&
-        layers.mLayers[0].mAttachment == StyleImageLayerAttachment::Fixed;
-
-    nsDisplayList list(aBuilder);
+  list.AppendToTop(&layerItems);
 
-    if (!hasFixedBottomLayer || needBlendContainer) {
-      // Put a scrolled background color item in place, at the bottom of the
-      // list. The color of this item will be filled in during
-      // PresShell::AddCanvasBackgroundColorItem.
-      // Do not add this item if there's a fixed background image at the bottom
-      // (unless we have to, for correct blending); with a fixed background,
-      // it's better to allow the fixed background image to combine itself with
-      // a non-scrolled background color directly underneath, rather than
-      // interleaving the two with a scrolled background color.
-      // PresShell::AddCanvasBackgroundColorItem makes sure there always is a
-      // non-scrolled background color item at the bottom.
-      list.AppendNewToTop<nsDisplayCanvasBackgroundColor>(aBuilder, this);
-    }
-
-    list.AppendToTop(&layerItems);
-
-    if (needBlendContainer) {
-      const ActiveScrolledRoot* containerASR = contASRTracker.GetContainerASR();
-      DisplayListClipState::AutoSaveRestore blendContainerClip(aBuilder);
-      list.AppendToTop(nsDisplayBlendContainer::CreateForBackgroundBlendMode(
-          aBuilder, this, nullptr, &list, containerASR));
-    }
-    aLists.BorderBackground()->AppendToTop(&list);
+  if (needBlendContainer) {
+    const ActiveScrolledRoot* containerASR = contASRTracker.GetContainerASR();
+    DisplayListClipState::AutoSaveRestore blendContainerClip(aBuilder);
+    list.AppendToTop(nsDisplayBlendContainer::CreateForBackgroundBlendMode(
+        aBuilder, this, nullptr, &list, containerASR));
   }
+  aLists.BorderBackground()->AppendToTop(&list);
 
   for (nsIFrame* kid : PrincipalChildList()) {
     // Put our child into its own pseudo-stack.
     BuildDisplayListForChild(aBuilder, kid, aLists);
   }
 
-  if (!mDoPaintFocus) {
-    return;
+  if (mDoPaintFocus) {
+    aLists.Outlines()->AppendNewToTop<nsDisplayCanvasFocus>(aBuilder, this);
   }
-  // Only paint the focus if we're visible
-  if (!StyleVisibility()->IsVisible()) {
-    return;
-  }
-
-  aLists.Outlines()->AppendNewToTop<nsDisplayCanvasFocus>(aBuilder, this);
 }
 
 void nsCanvasFrame::PaintFocus(DrawTarget* aDrawTarget, nsPoint aPt) {
