# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: layout/generic/nsCanvasFrame.cpp
# Commit: bf3033ae1fe7
# Full Hash: bf3033ae1fe73d4384d9f3957f3efbfe4d36223a
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2025-03-25 21:02:33
# Regressor Bug: 1955697
# File Overlap Count: 3
# Description:
#   Bug 1955697 - Remove nsDisplayCanvasBackgroundColor. r=mstange
#   
#   We no longer need it, as now it behaves just like a solid color.
#   
#   This causes an expectation change in an internal windowUtils.elementFromPoint
# ==============================================================================

diff -r 01cecf5bf7e5 -r bf3033ae1fe7 layout/generic/nsCanvasFrame.cpp
--- a/layout/generic/nsCanvasFrame.cpp	Tue Mar 25 08:09:57 2025 +0000
+++ b/layout/generic/nsCanvasFrame.cpp	Tue Mar 25 08:09:58 2025 +0000
@@ -287,54 +287,6 @@
 
 Element* nsCanvasFrame::GetDefaultTooltip() { return mTooltipContent; }
 
-nsDisplayCanvasBackgroundColor::nsDisplayCanvasBackgroundColor(
-    nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
-    : nsDisplaySolidColorBase(
-          aBuilder, aFrame,
-          aFrame->PresShell()->GetCSSSpecifiedCanvasBackground(
-              aFrame->GetParent()->IsPageContentFrame())) {}
-
-void nsDisplayCanvasBackgroundColor::Paint(nsDisplayListBuilder* aBuilder,
-                                           gfxContext* aCtx) {
-  if (!NS_GET_A(mColor)) {
-    return;
-  }
-  auto* frame = static_cast<nsCanvasFrame*>(mFrame);
-  nsPoint offset = ToReferenceFrame();
-  nsRect bgClipRect = frame->CanvasArea() + offset;
-  DrawTarget* drawTarget = aCtx->GetDrawTarget();
-  int32_t appUnitsPerDevPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
-  Rect devPxRect =
-      NSRectToSnappedRect(bgClipRect, appUnitsPerDevPixel, *drawTarget);
-  drawTarget->FillRect(devPxRect, ColorPattern(ToDeviceColor(mColor)));
-}
-
-bool nsDisplayCanvasBackgroundColor::CreateWebRenderCommands(
-    mozilla::wr::DisplayListBuilder& aBuilder,
-    mozilla::wr::IpcResourceUpdateQueue& aResources,
-    const StackingContextHelper& aSc, RenderRootStateManager* aManager,
-    nsDisplayListBuilder* aDisplayListBuilder) {
-  if (!NS_GET_A(mColor)) {
-    return true;
-  }
-  auto* frame = static_cast<nsCanvasFrame*>(mFrame);
-  nsPoint offset = ToReferenceFrame();
-  nsRect bgClipRect = frame->CanvasArea() + offset;
-  int32_t appUnitsPerDevPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
-  auto rect = LayoutDeviceRect::FromAppUnits(bgClipRect, appUnitsPerDevPixel);
-  wr::LayoutRect r = wr::ToLayoutRect(rect);
-  aBuilder.PushRect(r, r, !BackfaceIsHidden(), false, false,
-                    wr::ToColorF(ToDeviceColor(mColor)));
-  return true;
-}
-
-void nsDisplayCanvasBackgroundColor::WriteDebugInfo(
-    std::stringstream& aStream) {
-  aStream << " (rgba " << (int)NS_GET_R(mColor) << "," << (int)NS_GET_G(mColor)
-          << "," << (int)NS_GET_B(mColor) << "," << (int)NS_GET_A(mColor)
-          << ")";
-}
-
 void nsDisplayCanvasBackgroundImage::Paint(nsDisplayListBuilder* aBuilder,
                                            gfxContext* aCtx) {
   auto* frame = static_cast<nsCanvasFrame*>(mFrame);
@@ -553,11 +505,18 @@
     }
     layerItems.AppendToTop(&thisItemList);
   }
-
   nsDisplayList list(aBuilder);
 
   // Put a scrolled background color item in place, at the bottom of the list.
-  list.AppendNewToTop<nsDisplayCanvasBackgroundColor>(aBuilder, this);
+  const bool isPage = GetParent()->IsPageContentFrame();
+  const nscolor bgColor =
+      PresShell()->GetCSSSpecifiedCanvasBackground(isPage);
+  if (NS_GET_A(bgColor)) {
+    list.AppendNewToTop<nsDisplaySolidColor>(
+        aBuilder, this,
+        CanvasArea() + aBuilder->GetCurrentFrameOffsetToReferenceFrame(),
+        bgColor);
+  }
 
   list.AppendToTop(&layerItems);
 