# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webscheduling/WebTaskScheduler.h
# Commit: 134228f242de
# Full Hash: 134228f242dee041e94824d207c4f0e68b48c83c
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-04-01 09:40:15
# Regressor Bug: 1920115
# File Overlap Count: 2
# Description:
#   Bug 1920115 - Allow high priority tasks to run before timers r=smaug
#   
#   In Gecko, unlike other runnables where the TaskController
#   picks one each at a time, the TimeoutManager allows multiple
#   timers to run sequentially without allowing other runnables
# ==============================================================================

diff -r 41d90165c19a -r 134228f242de dom/webscheduling/WebTaskScheduler.h
--- a/dom/webscheduling/WebTaskScheduler.h	Mon Mar 31 19:49:03 2025 +0000
+++ b/dom/webscheduling/WebTaskScheduler.h	Mon Mar 31 19:49:03 2025 +0000
@@ -21,6 +21,12 @@
 #include "mozilla/dom/WebTaskSchedulingBinding.h"
 
 namespace mozilla::dom {
+
+// Keep tracks of the number of same-event-loop-high-priority-queues
+// (User_blocking or User_visible) that have at least one task scheduled.
+MOZ_CONSTINIT extern uint32_t
+    gNumNormalOrHighPriorityQueuesHaveTaskScheduledMainThread;
+
 // https://wicg.github.io/scheduling-apis/#scheduling-state
 class WebTaskSchedulingState {
  public:
@@ -104,6 +110,16 @@
     }
   }
 
+  TaskPriority Priority() const {
+    return mKey.match(
+        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
+          return static_cast<TaskPriority>(aStaticKey);
+        },
+        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
+          return aDynamicKey->Priority();
+        });
+  }
+
   static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
 
   static PLDHashNumber HashKey(KeyTypePointer aKey) {
@@ -121,16 +137,6 @@
   const WebTaskQueueTypeKey& GetTypeKey() const { return mKey; }
 
  private:
-  TaskPriority Priority() const {
-    return mKey.match(
-        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
-          return static_cast<TaskPriority>(aStaticKey);
-        },
-        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
-          return aDynamicKey->Priority();
-        });
-  }
-
   WebTaskQueueTypeKey mKey;
   const bool mIsContinuation;
 };
@@ -160,8 +166,17 @@
 
   void ClearWebTaskScheduler() { mScheduler = nullptr; }
 
+  const WebTaskQueueHashKey& TaskQueueHashKey() const {
+    return mWebTaskQueueHashKey;
+  }
+
+  TaskPriority Priority() const { return mWebTaskQueueHashKey.Priority(); }
+
  private:
-  void SetHasScheduled(bool aHasScheduled) { mHasScheduled = aHasScheduled; }
+  void SetHasScheduled() {
+    MOZ_ASSERT(!mHasScheduled);
+    mHasScheduled = true;
+  }
 
   uint32_t mEnqueueOrder;
 
@@ -188,18 +203,13 @@
  public:
   static constexpr int EffectivePriorityCount = 6;
 
-  explicit WebTaskQueue(WebTaskScheduler* aScheduler) {
+  explicit WebTaskQueue(WebTaskScheduler* aScheduler) : mScheduler(aScheduler) {
     MOZ_ASSERT(aScheduler);
   }
 
   WebTaskQueue(WebTaskQueue&& aWebTaskQueue) = default;
 
-  ~WebTaskQueue() {
-    for (const auto& task : mTasks) {
-      task->ClearWebTaskScheduler();
-    }
-    mTasks.clear();
-  }
+  ~WebTaskQueue();
 
   TaskPriority Priority() const { return mPriority; }
   void SetPriority(TaskPriority aNewPriority) { mPriority = aNewPriority; }
@@ -238,6 +248,10 @@
  private:
   TaskPriority mPriority = TaskPriority::User_visible;
   LinkedList<RefPtr<WebTask>> mTasks;
+
+  // WebTaskScheduler owns WebTaskQueue as a hashtable value, so using a raw
+  // pointer points to WebTaskScheduler is ok.
+  WebTaskScheduler* mScheduler;
 };
 
 class WebTaskSchedulerMainThread;
@@ -281,7 +295,9 @@
     MOZ_ASSERT(result);
   }
 
-  void RemoveEntryFromTaskQueueMapIfNeeded(const WebTaskQueueHashKey&);
+  void NotifyTaskWillBeRunOrAborted(const WebTask* aWebTask);
+  virtual void IncreaseNumNormalOrHighPriorityQueuesHaveTaskScheduled() = 0;
+  virtual void DecreaseNumNormalOrHighPriorityQueuesHaveTaskScheduled() = 0;
 
  protected:
   virtual ~WebTaskScheduler() = default;
@@ -299,7 +315,7 @@
       const Maybe<SchedulerPostTaskCallback&>& aCallback,
       WebTaskSchedulingState* aSchedulingState, Promise* aPromise);
 
-  bool QueueTask(WebTask* aTask, EventQueuePriority aPriority);
+  bool DispatchTask(WebTask* aTask, EventQueuePriority aPriority);
 
   SelectedTaskQueueData SelectTaskQueue(
       const Optional<OwningNonNull<AbortSignal>>& aSignal,
@@ -309,7 +325,8 @@
                                             EventQueuePriority aPriority) = 0;
   virtual bool DispatchEventLoopRunnable(EventQueuePriority aPriority) = 0;
 
-  EventQueuePriority GetEventQueuePriority(const TaskPriority& aPriority) const;
+  EventQueuePriority GetEventQueuePriority(const TaskPriority& aPriority,
+                                           bool aIsContinuation) const;
 
   nsTHashMap<WebTaskQueueHashKey, WebTaskQueue>& GetWebTaskQueues() {
     return mWebTaskQueues;
@@ -330,7 +347,7 @@
   MOZ_CAN_RUN_SCRIPT bool Call(const char* /* unused */) override {
     if (mScheduler && mWebTask) {
       MOZ_ASSERT(!mWebTask->HasScheduled());
-      if (!mScheduler->QueueTask(mWebTask, mPriority)) {
+      if (!mScheduler->DispatchTask(mWebTask, mPriority)) {
         return false;
       }
     }