# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webscheduling/WebTaskScheduler.h
# Commit: 4739af17e757
# Full Hash: 4739af17e757724c0833a8564579833249389566
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-02-27 21:52:52
# Regressor Bug: 1920115
# File Overlap Count: 2
# Description:
#   Bug 1920115 - Allow high priority tasks to run before timers r=smaug
#   
#   In Gecko, unlike other runnables where the TaskController
#   picks one each at a time, the TimeoutManager allows multiple
#   timers to run sequentially without allowing other runnables
# ==============================================================================

diff -r 0773f669c498 -r 4739af17e757 dom/webscheduling/WebTaskScheduler.h
--- a/dom/webscheduling/WebTaskScheduler.h	Thu Feb 27 16:17:36 2025 +0000
+++ b/dom/webscheduling/WebTaskScheduler.h	Thu Feb 27 16:17:36 2025 +0000
@@ -21,6 +21,12 @@
 #include "mozilla/dom/WebTaskSchedulingBinding.h"
 
 namespace mozilla::dom {
+
+// Keep tracks of the number of same-event-loop-high-priority-queues
+// (User_blocking or User_visible) that have at least one task scheduled.
+MOZ_CONSTINIT extern uint32_t
+    gNumNormalOrHighPriorityQueuesHaveTaskScheduledMainThread;
+
 // https://wicg.github.io/scheduling-apis/#scheduling-state
 class WebTaskSchedulingState {
  public:
@@ -103,6 +109,16 @@
     }
   }
 
+  TaskPriority Priority() const {
+    return mKey.match(
+        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
+          return static_cast<TaskPriority>(aStaticKey);
+        },
+        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
+          return aDynamicKey->Priority();
+        });
+  }
+
   static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
 
   static PLDHashNumber HashKey(KeyTypePointer aKey) {
@@ -120,16 +136,6 @@
   const WebTaskQueueTypeKey& GetTypeKey() const { return mKey; }
 
  private:
-  TaskPriority Priority() const {
-    return mKey.match(
-        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
-          return static_cast<TaskPriority>(aStaticKey);
-        },
-        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
-          return aDynamicKey->Priority();
-        });
-  }
-
   WebTaskQueueTypeKey mKey;
   const bool mIsContinuation;
 };
@@ -159,8 +165,17 @@
 
   void ClearWebTaskScheduler() { mScheduler = nullptr; }
 
+  const WebTaskQueueHashKey& TaskQueueHashKey() const {
+    return mWebTaskQueueHashKey;
+  }
+
+  TaskPriority Priority() const { return mWebTaskQueueHashKey.Priority(); }
+
  private:
-  void SetHasScheduled(bool aHasScheduled) { mHasScheduled = aHasScheduled; }
+  void SetHasScheduled() {
+    MOZ_ASSERT(!mHasScheduled);
+    mHasScheduled = true;
+  }
 
   uint32_t mEnqueueOrder;
 
@@ -193,12 +208,7 @@
 
   WebTaskQueue(WebTaskQueue&& aWebTaskQueue) = default;
 
-  ~WebTaskQueue() {
-    for (const auto& task : mTasks) {
-      task->ClearWebTaskScheduler();
-    }
-    mTasks.clear();
-  }
+  ~WebTaskQueue();
 
   TaskPriority Priority() const { return mPriority; }
   void SetPriority(TaskPriority aNewPriority) { mPriority = aNewPriority; }
@@ -284,7 +294,9 @@
     MOZ_ASSERT(result);
   }
 
-  void RemoveEntryFromTaskQueueMapIfNeeded(const WebTaskQueueHashKey&);
+  void NotifyTaskWillBeRunOrAborted(const WebTask* aWebTask);
+  virtual void IncreaseNumNormalOrHighPriorityQueuesHaveTaskScheduled() = 0;
+  virtual void DecreaseNumNormalOrHighPriorityQueuesHaveTaskScheduled() = 0;
 
  protected:
   virtual ~WebTaskScheduler() = default;
@@ -302,7 +314,7 @@
       const Maybe<SchedulerPostTaskCallback&>& aCallback,
       WebTaskSchedulingState* aSchedulingState, Promise* aPromise);
 
-  bool QueueTask(WebTask* aTask, EventQueuePriority aPriority);
+  bool DispatchTask(WebTask* aTask, EventQueuePriority aPriority);
 
   SelectedTaskQueueData SelectTaskQueue(
       const Optional<OwningNonNull<AbortSignal>>& aSignal,
@@ -312,7 +324,8 @@
                                             EventQueuePriority aPriority) = 0;
   virtual bool DispatchEventLoopRunnable(EventQueuePriority aPriority) = 0;
 
-  EventQueuePriority GetEventQueuePriority(const TaskPriority& aPriority) const;
+  EventQueuePriority GetEventQueuePriority(const TaskPriority& aPriority,
+                                           bool aIsContinuation) const;
 
   nsTHashMap<WebTaskQueueHashKey, WebTaskQueue>& GetWebTaskQueues() {
     return mWebTaskQueues;
@@ -333,7 +346,7 @@
   MOZ_CAN_RUN_SCRIPT bool Call(const char* /* unused */) override {
     if (mScheduler && mWebTask) {
       MOZ_ASSERT(!mWebTask->HasScheduled());
-      if (!mScheduler->QueueTask(mWebTask, mPriority)) {
+      if (!mScheduler->DispatchTask(mWebTask, mPriority)) {
         return false;
       }
     }