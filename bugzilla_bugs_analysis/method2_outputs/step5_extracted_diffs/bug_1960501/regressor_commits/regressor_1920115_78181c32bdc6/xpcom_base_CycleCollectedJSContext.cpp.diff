# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/base/CycleCollectedJSContext.cpp
# Commit: 78181c32bdc6
# Full Hash: 78181c32bdc6b1d66eac04f3ce11a2902f477823
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-02-27 21:52:52
# Regressor Bug: 1920115
# File Overlap Count: 2
# Description:
#   Bug 1920115 - Add the setup for WebTaskSchedulingState r=jjaschke,dom-core,arai
#   
#   Spec: https://wicg.github.io/scheduling-apis/#scheduling-state
#   
#   This patch add the setup for WebTaskSchedulingState so that it
# ==============================================================================

diff -r 912cf1adac80 -r 78181c32bdc6 xpcom/base/CycleCollectedJSContext.cpp
--- a/xpcom/base/CycleCollectedJSContext.cpp	Thu Feb 27 16:17:34 2025 +0000
+++ b/xpcom/base/CycleCollectedJSContext.cpp	Thu Feb 27 16:17:35 2025 +0000
@@ -35,6 +35,7 @@
 #include "mozilla/dom/RootedDictionary.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/UserActivation.h"
+#include "mozilla/dom/WebTaskScheduler.h"
 #include "nsContentUtils.h"
 #include "nsCycleCollectionNoteRootCallback.h"
 #include "nsCycleCollectionParticipant.h"
@@ -176,9 +177,11 @@
   PromiseJobRunnable(JS::HandleObject aPromise, JS::HandleObject aCallback,
                      JS::HandleObject aCallbackGlobal,
                      JS::HandleObject aAllocationSite,
-                     nsIGlobalObject* aIncumbentGlobal)
+                     nsIGlobalObject* aIncumbentGlobal,
+                     WebTaskSchedulingState* aSchedulingState)
       : mCallback(new PromiseJobCallback(aCallback, aCallbackGlobal,
                                          aAllocationSite, aIncumbentGlobal)),
+        mSchedulingState(aSchedulingState),
         mPropagateUserInputEventHandling(false) {
     MOZ_ASSERT(js::IsFunctionObject(aCallback));
 
@@ -197,10 +200,11 @@
   MOZ_CAN_RUN_SCRIPT
   virtual void Run(AutoSlowOperation& aAso) override {
     JSObject* callback = mCallback->CallbackPreserveColor();
-    nsIGlobalObject* global = callback ? xpc::NativeGlobal(callback) : nullptr;
+    nsCOMPtr<nsIGlobalObject> global =
+        callback ? xpc::NativeGlobal(callback) : nullptr;
     if (global && !global->IsDying()) {
       // Propagate the user input event handling bit if needed.
-      nsCOMPtr<nsPIDOMWindowInner> win = do_QueryInterface(global);
+      nsPIDOMWindowInner* win = global->GetAsInnerWindow();
       RefPtr<Document> doc;
       if (win) {
         doc = win->GetExtantDoc();
@@ -208,7 +212,17 @@
       AutoHandlingUserInputStatePusher userInpStatePusher(
           mPropagateUserInputEventHandling);
 
+      // https://wicg.github.io/scheduling-apis/#sec-patches-html-hostcalljobcallback
+      // 2. Set event loop’s current scheduling state to
+      // callback.[[HostDefined]].[[SchedulingState]].
+      global->SetWebTaskSchedulingState(mSchedulingState);
+
       mCallback->Call("promise callback");
+
+      // (The step after step 7): Set event loop’s current scheduling state to
+      // null
+      global->SetWebTaskSchedulingState(nullptr);
+
       aAso.CheckForInterrupt();
     }
     // Now that mCallback is no longer needed, clear any pointers it contains to
@@ -227,15 +241,24 @@
 
  private:
   const RefPtr<PromiseJobCallback> mCallback;
+  const RefPtr<WebTaskSchedulingState> mSchedulingState;
   bool mPropagateUserInputEventHandling;
 };
 
-// Finalizer for instances of FinalizeHostDefinedData.
-//
-// HostDefinedData only contains incumbent global, no need to
-// clean that up.
-// TODO(sefeng): Bug 1929356 will add [[SchedulingState]] to HostDefinedData.
-void FinalizeHostDefinedData(JS::GCContext* gcx, JSObject* objSelf) {}
+enum { INCUMBENT_SETTING_SLOT, SCHEDULING_STATE_SLOT, HOSTDEFINED_DATA_SLOTS };
+
+// Finalizer for instances of HostDefinedData.
+void FinalizeHostDefinedData(JS::GCContext* gcx, JSObject* objSelf) {
+  JS::Value slotEvent = JS::GetReservedSlot(objSelf, SCHEDULING_STATE_SLOT);
+  if (slotEvent.isUndefined()) {
+    return;
+  }
+
+  WebTaskSchedulingState* schedulingState =
+      static_cast<WebTaskSchedulingState*>(slotEvent.toPrivate());
+  JS_SetReservedSlot(objSelf, SCHEDULING_STATE_SLOT, JS::UndefinedValue());
+  schedulingState->Release();
+}
 
 static const JSClassOps sHostDefinedData = {
     nullptr /* addProperty */, nullptr /* delProperty */,
@@ -244,13 +267,11 @@
     FinalizeHostDefinedData /* finalize */
 };
 
-enum { INCUMBENT_SETTING_SLOT, HOSTDEFINED_DATA_SLOTS };
-
 // Implements `HostDefined` in https://html.spec.whatwg.org/#hostmakejobcallback
 static const JSClass sHostDefinedDataClass = {
     "HostDefinedData",
     JSCLASS_HAS_RESERVED_SLOTS(HOSTDEFINED_DATA_SLOTS) |
-        JSCLASS_BACKGROUND_FINALIZE,
+        JSCLASS_FOREGROUND_FINALIZE,
     &sHostDefinedData};
 
 bool CycleCollectedJSContext::getHostDefinedData(
@@ -279,6 +300,14 @@
 
   JS_SetReservedSlot(objResult, INCUMBENT_SETTING_SLOT,
                      JS::ObjectValue(*incumbentGlobal));
+
+  if (mozilla::dom::WebTaskSchedulingState* schedulingState =
+          mozilla::dom::GetWebTaskSchedulingState()) {
+    schedulingState->AddRef();
+    JS_SetReservedSlot(objResult, SCHEDULING_STATE_SLOT,
+                       JS::PrivateValue(schedulingState));
+  }
+
   aData.set(objResult);
 
   return true;
@@ -291,6 +320,7 @@
   MOZ_ASSERT(Get() == this);
 
   nsIGlobalObject* global = nullptr;
+  WebTaskSchedulingState* schedulingState = nullptr;
 
   if (hostDefinedData) {
     MOZ_RELEASE_ASSERT(JS::GetClass(hostDefinedData.get()) ==
@@ -300,11 +330,17 @@
     // hostDefinedData is only created when incumbent global exists.
     MOZ_ASSERT(incumbentGlobal.isObject());
     global = xpc::NativeGlobal(&incumbentGlobal.toObject());
+
+    JS::Value state =
+        JS::GetReservedSlot(hostDefinedData.get(), SCHEDULING_STATE_SLOT);
+    if (!state.isUndefined()) {
+      schedulingState = static_cast<WebTaskSchedulingState*>(state.toPrivate());
+    }
   }
 
   JS::RootedObject jobGlobal(aCx, JS::CurrentGlobalOrNull(aCx));
   RefPtr<PromiseJobRunnable> runnable = new PromiseJobRunnable(
-      aPromise, aJob, jobGlobal, aAllocationSite, global);
+      aPromise, aJob, jobGlobal, aAllocationSite, global, schedulingState);
   DispatchToMicroTask(runnable.forget());
   return true;
 }
