# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/webscheduling/WebTaskScheduler.h
# Commit: be6c223e63f0
# Full Hash: be6c223e63f0a0c8ef2428df42321d59e4c0f7c6
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-02-25 09:30:56
# Regressor Bug: 1920115
# File Overlap Count: 2
# Description:
#   Bug 1920115 - Implement scheduler.yield r=jjaschke,dom-core,webidl,smaug
#   
#   Spec: https://wicg.github.io/scheduling-apis/#dom-scheduler-yield
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D234232
# ==============================================================================

diff -r 121bf804d2a6 -r be6c223e63f0 dom/webscheduling/WebTaskScheduler.h
--- a/dom/webscheduling/WebTaskScheduler.h	Mon Feb 24 19:31:26 2025 +0000
+++ b/dom/webscheduling/WebTaskScheduler.h	Mon Feb 24 19:31:27 2025 +0000
@@ -13,6 +13,7 @@
 #include "nsWrapperCache.h"
 #include "nsClassHashtable.h"
 
+#include "TaskSignal.h"
 #include "mozilla/Variant.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/AbortFollower.h"
@@ -50,7 +51,89 @@
   RefPtr<AbortSignal> mPrioritySource;
 };
 
-class WebTaskQueue;
+class WebTaskQueueHashKey : public PLDHashEntryHdr {
+ public:
+  enum { ALLOW_MEMMOVE = false };
+
+  typedef const WebTaskQueueHashKey& KeyType;
+  typedef const WebTaskQueueHashKey* KeyTypePointer;
+
+  using StaticPriorityTaskQueueKey = uint32_t;
+  using DynamicPriorityTaskQueueKey = RefPtr<TaskSignal>;
+
+  // When WebTaskQueueTypeKey is RefPtr<TaskSignal>, this
+  // class holds a strong reference to a cycle collectable
+  // objects.
+  using WebTaskQueueTypeKey =
+      mozilla::Variant<StaticPriorityTaskQueueKey, DynamicPriorityTaskQueueKey>;
+
+  WebTaskQueueHashKey(StaticPriorityTaskQueueKey aKey, bool aIsContinuation)
+      : mKey(aKey), mIsContinuation(aIsContinuation) {}
+
+  WebTaskQueueHashKey(DynamicPriorityTaskQueueKey aKey, bool aIsContinuation)
+      : mKey(aKey), mIsContinuation(aIsContinuation) {}
+
+  explicit WebTaskQueueHashKey(KeyTypePointer aKey)
+      : mKey(aKey->mKey), mIsContinuation(aKey->mIsContinuation) {}
+
+  explicit WebTaskQueueHashKey(KeyType aKey)
+      : mKey(aKey.mKey), mIsContinuation(aKey.mIsContinuation) {}
+
+  WebTaskQueueHashKey(WebTaskQueueHashKey&& aToMove) = default;
+
+  ~WebTaskQueueHashKey() = default;
+
+  KeyType GetKey() const { return *this; }
+
+  bool KeyEquals(KeyTypePointer aKey) const {
+    return aKey->mKey == mKey && aKey->mIsContinuation == mIsContinuation;
+  }
+
+  // https://wicg.github.io/scheduling-apis/#scheduler-task-queue-effective-priority
+  uint8_t EffectivePriority() const {
+    switch (Priority()) {
+      case TaskPriority::Background:
+        return mIsContinuation ? 1 : 0;
+      case TaskPriority::User_visible:
+        return mIsContinuation ? 3 : 2;
+      case TaskPriority::User_blocking:
+        return mIsContinuation ? 5 : 4;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Unexpected priority");
+    }
+  }
+
+  static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
+
+  static PLDHashNumber HashKey(KeyTypePointer aKey) {
+    const WebTaskQueueTypeKey& key = aKey->mKey;
+    return key.match(
+        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
+          return mozilla::HashGeneric(aStaticKey, aKey->mIsContinuation);
+        },
+        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
+          return mozilla::HashGeneric(aDynamicKey.get(), aKey->mIsContinuation);
+        });
+  }
+
+  WebTaskQueueTypeKey& GetTypeKey() { return mKey; }
+  const WebTaskQueueTypeKey& GetTypeKey() const { return mKey; }
+
+ private:
+  TaskPriority Priority() const {
+    return mKey.match(
+        [&](const StaticPriorityTaskQueueKey& aStaticKey) {
+          return static_cast<TaskPriority>(aStaticKey);
+        },
+        [&](const DynamicPriorityTaskQueueKey& aDynamicKey) {
+          return aDynamicKey->Priority();
+        });
+  }
+
+  WebTaskQueueTypeKey mKey;
+  const bool mIsContinuation;
+};
+
 class WebTask : public LinkedListElement<RefPtr<WebTask>>,
                 public AbortFollower,
                 public SupportsWeakPtr {
@@ -62,13 +145,11 @@
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 
   NS_DECL_CYCLE_COLLECTION_CLASS(WebTask)
-  WebTask(uint32_t aEnqueueOrder, SchedulerPostTaskCallback& aCallback,
-          Promise* aPromise)
-      : mEnqueueOrder(aEnqueueOrder),
-        mCallback(&aCallback),
-        mPromise(aPromise),
-        mHasScheduled(false),
-        mOwnerQueue(nullptr) {}
+  WebTask(uint32_t aEnqueueOrder,
+          const Maybe<SchedulerPostTaskCallback&>& aCallback,
+          WebTaskSchedulingState* aSchedulingState, Promise* aPromise,
+          WebTaskScheduler* aWebTaskScheduler,
+          const WebTaskQueueHashKey& aHashKey);
 
   void RunAbortAlgorithm() override;
 
@@ -76,9 +157,7 @@
 
   uint32_t EnqueueOrder() const { return mEnqueueOrder; }
 
-  void SetWebTaskQueue(WebTaskQueue* aWebTaskQueue) {
-    mOwnerQueue = aWebTaskQueue;
-  }
+  void ClearWebTaskScheduler() { mScheduler = nullptr; }
 
  private:
   void SetHasScheduled(bool aHasScheduled) { mHasScheduled = aHasScheduled; }
@@ -90,30 +169,47 @@
 
   bool mHasScheduled;
 
-  // WebTaskQueue owns WebTask, so it's okay to use a raw pointer
-  WebTaskQueue* mOwnerQueue;
+  RefPtr<WebTaskSchedulingState> mSchedulingState;
+
+  // WebTaskScheduler owns WebTaskQueue, and WebTaskQueue owns WebTask, so it's
+  // okay to use a raw pointer
+  WebTaskScheduler* mScheduler;
+
+  // Depending on whether this task was scheduled with static priority
+  // or dynamic priority, it could hold a reference reference to TaskSignal
+  // (cycle collectable object).
+  WebTaskQueueHashKey mWebTaskQueueHashKey;
 
   ~WebTask() = default;
 };
 
 class WebTaskQueue {
  public:
-  WebTaskQueue(uint32_t aKey, WebTaskScheduler* aScheduler)
-      : mOwnerKey(AsVariant(aKey)), mScheduler(aScheduler) {}
-  WebTaskQueue(TaskSignal* aKey, WebTaskScheduler* aScheduler)
-      : mOwnerKey(AsVariant(aKey)), mScheduler(aScheduler) {}
+  static constexpr int EffectivePriorityCount = 6;
+
+  explicit WebTaskQueue(WebTaskScheduler* aScheduler) : mScheduler(aScheduler) {
+    MOZ_ASSERT(aScheduler);
+  }
+
+  WebTaskQueue(WebTaskQueue&& aWebTaskQueue) = default;
+
+  ~WebTaskQueue() {
+    for (const auto& task : mTasks) {
+      task->ClearWebTaskScheduler();
+    }
+    mTasks.clear();
+  }
 
   TaskPriority Priority() const { return mPriority; }
   void SetPriority(TaskPriority aNewPriority) { mPriority = aNewPriority; }
 
   LinkedList<RefPtr<WebTask>>& Tasks() { return mTasks; }
+  const LinkedList<RefPtr<WebTask>>& Tasks() const { return mTasks; }
 
-  void AddTask(WebTask* aTask) {
-    mTasks.insertBack(aTask);
-    aTask->SetWebTaskQueue(this);
-  }
+  void AddTask(WebTask* aTask) { mTasks.insertBack(aTask); }
 
-  void RemoveEntryFromTaskQueueMapIfNeeded();
+  bool IsEmpty() const { return mTasks.isEmpty(); }
+
   // TODO: To optimize it, we could have the scheduled and unscheduled
   // tasks stored separately.
   WebTask* GetFirstScheduledTask() {
@@ -125,23 +221,23 @@
     return nullptr;
   }
 
-  ~WebTaskQueue() {
-    mOwnerKey = AsVariant(Nothing());
+  bool HasScheduledTasks() const {
+    if (mTasks.isEmpty()) {
+      return false;
+    }
+
     for (const auto& task : mTasks) {
-      task->SetWebTaskQueue(nullptr);
+      if (task->HasScheduled()) {
+        return true;
+      }
     }
-    mTasks.clear();
+    return false;
   }
 
  private:
   TaskPriority mPriority = TaskPriority::User_visible;
   LinkedList<RefPtr<WebTask>> mTasks;
 
-  // When mOwnerKey is TaskSignal*, it means as long as
-  // WebTaskQueue is alive, the corresponding TaskSignal
-  // is alive, so using a raw pointer is ok.
-  Variant<Nothing, uint32_t, TaskSignal*> mOwnerKey;
-
   // WebTaskScheduler owns WebTaskQueue as a hashtable value, so using a raw
   // pointer points to WebTaskScheduler is ok.
   WebTaskScheduler* mScheduler;
@@ -168,19 +264,25 @@
   already_AddRefed<Promise> PostTask(SchedulerPostTaskCallback& aCallback,
                                      const SchedulerPostTaskOptions& aOptions);
 
+  already_AddRefed<Promise> YieldImpl();
+
   nsIGlobalObject* GetParentObject() const { return mParent; }
 
   virtual JSObject* WrapObject(JSContext* cx,
                                JS::Handle<JSObject*> aGivenProto) override;
 
-  WebTask* GetNextTask() const;
+  WebTask* GetNextTask();
 
   virtual void Disconnect();
 
   void RunTaskSignalPriorityChange(TaskSignal* aTaskSignal);
 
-  void DeleteEntryFromStaticQueueMap(uint32_t aKey);
-  void DeleteEntryFromDynamicQueueMap(TaskSignal* aKey);
+  void DeleteEntryFromWebTaskQueueMap(const WebTaskQueueHashKey& aKey) {
+    DebugOnly<bool> result = mWebTaskQueues.Remove(aKey);
+    MOZ_ASSERT(result);
+  }
+
+  void RemoveEntryFromTaskQueueMapIfNeeded(const WebTaskQueueHashKey&);
 
  protected:
   virtual ~WebTaskScheduler() = default;
@@ -189,29 +291,36 @@
   uint32_t mNextEnqueueOrder;
 
  private:
-  already_AddRefed<WebTask> CreateTask(
-      WebTaskQueue& aQueue, const Optional<OwningNonNull<AbortSignal>>& aSignal,
-      SchedulerPostTaskCallback& aCallback, Promise* aPromise);
+  struct SelectedTaskQueueData {
+    WebTaskQueueHashKey mSelectedQueueHashKey;
+    WebTaskQueue& mSelectedTaskQueue;
+  };
 
-  bool QueueTask(WebTask* aTask);
-
-  WebTaskQueue& SelectTaskQueue(
+  already_AddRefed<WebTask> CreateTask(
       const Optional<OwningNonNull<AbortSignal>>& aSignal,
-      const Optional<TaskPriority>& aPriority);
+      const Optional<TaskPriority>& aPriority, const bool aIsContinuation,
+      const Maybe<SchedulerPostTaskCallback&>& aCallback,
+      WebTaskSchedulingState* aSchedulingState, Promise* aPromise);
+
+  bool QueueTask(WebTask* aTask, EventQueuePriority aPriority);
 
-  virtual nsresult SetTimeoutForDelayedTask(WebTask* aTask,
-                                            uint64_t aDelay) = 0;
-  virtual bool DispatchEventLoopRunnable() = 0;
+  SelectedTaskQueueData SelectTaskQueue(
+      const Optional<OwningNonNull<AbortSignal>>& aSignal,
+      const Optional<TaskPriority>& aPriority, const bool aIsContinuation);
 
-  nsClassHashtable<nsUint32HashKey, WebTaskQueue> mStaticPriorityTaskQueues;
-  nsClassHashtable<nsRefPtrHashKey<TaskSignal>, WebTaskQueue>
-      mDynamicPriorityTaskQueues;
+  virtual nsresult SetTimeoutForDelayedTask(WebTask* aTask, uint64_t aDelay,
+                                            EventQueuePriority aPriority) = 0;
+  virtual bool DispatchEventLoopRunnable(EventQueuePriority aPriority) = 0;
+
+  EventQueuePriority GetEventQueuePriority(const TaskPriority& aPriority) const;
+
+  nsTHashMap<WebTaskQueueHashKey, WebTaskQueue> mWebTaskQueues;
 };
 
 class DelayedWebTaskHandler final : public TimeoutHandler {
  public:
   DelayedWebTaskHandler(JSContext* aCx, WebTaskScheduler* aScheduler,
-                        WebTask* aTask)
+                        WebTask* aTask, EventQueuePriority aPriority)
       : TimeoutHandler(aCx), mScheduler(aScheduler), mWebTask(aTask) {}
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
@@ -220,7 +329,7 @@
   MOZ_CAN_RUN_SCRIPT bool Call(const char* /* unused */) override {
     if (mScheduler && mWebTask) {
       MOZ_ASSERT(!mWebTask->HasScheduled());
-      if (!mScheduler->QueueTask(mWebTask)) {
+      if (!mScheduler->QueueTask(mWebTask, mPriority)) {
         return false;
       }
     }
@@ -232,6 +341,7 @@
   WeakPtr<WebTaskScheduler> mScheduler;
   // WebTask gets added to WebTaskQueue, and WebTaskQueue keeps its alive.
   WeakPtr<WebTask> mWebTask;
+  EventQueuePriority mPriority;
 };
 }  // namespace mozilla::dom
 #endif