# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerEventTarget.cpp
# Commit: 01fe98c08d10
# Full Hash: 01fe98c08d102c28e3a61209ea31834eff83202a
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-03-25 21:02:33
# Regressor Bug: 1899503
# File Overlap Count: 4
# Description:
#   Bug 1899503 - P3 PRemoteWorkerDebugger binding implementation. r=asuth
#   
#   This patch implements the PRemoteWorkerDebugger binding.
#   
#   We are trying to keep the same logic debugger registration/unregistration to minimize the difference between the local debugger(the debugger on the content process main thread)
# ==============================================================================

diff -r 9bd2a82481f4 -r 01fe98c08d10 dom/workers/WorkerEventTarget.cpp
--- a/dom/workers/WorkerEventTarget.cpp	Tue Mar 25 09:13:20 2025 +0000
+++ b/dom/workers/WorkerEventTarget.cpp	Tue Mar 25 09:13:20 2025 +0000
@@ -84,6 +84,48 @@
 #endif
 };
 
+class WrappedDebuggerRunnable final : public WorkerDebuggerRunnable {
+  nsCOMPtr<nsIRunnable> mInner;
+
+  ~WrappedDebuggerRunnable() = default;
+
+ public:
+  WrappedDebuggerRunnable(WorkerPrivate* aWorkerPrivate,
+                          nsCOMPtr<nsIRunnable>&& aInner)
+      : WorkerDebuggerRunnable("WrappedDebuggerRunnable"),
+        mInner(std::move(aInner)) {}
+
+  virtual bool PreDispatch(WorkerPrivate* aWorkerPrivate) override {
+    // Silence bad assertions, this can be dispatched from any thread.
+    return true;
+  }
+
+  virtual void PostDispatch(WorkerPrivate* aWorkerPrivate,
+                            bool aDispatchResult) override {
+    // Silence bad assertions, this can be dispatched from any thread.
+  }
+
+  bool WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override {
+    mInner->Run();
+    return true;
+  }
+
+#ifdef MOZ_COLLECTING_RUNNABLE_TELEMETRY
+  NS_IMETHOD GetName(nsACString& aName) override {
+    aName.AssignLiteral("WrappedDebuggerRunnable(");
+    if (nsCOMPtr<nsINamed> named = do_QueryInterface(mInner)) {
+      nsAutoCString containedName;
+      named->GetName(containedName);
+      aName.Append(containedName);
+    } else {
+      aName.AppendLiteral("?");
+    }
+    aName.AppendLiteral(")");
+    return NS_OK;
+  }
+#endif
+};
+
 }  // anonymous namespace
 
 NS_IMPL_ISUPPORTS(WorkerEventTarget, nsIEventTarget, nsISerialEventTarget)
@@ -127,6 +169,23 @@
     return NS_ERROR_FAILURE;
   }
 
+  if (mBehavior == Behavior::DebuggerOnly) {
+    RefPtr<WorkerDebuggerRunnable> r =
+        new WrappedDebuggerRunnable(mWorkerPrivate, std::move(runnable));
+    LOGV(
+        ("WorkerEventTarget::Dispatch [%p] Wrapped runnable as debugger "
+         "runnable(%p)",
+         this, r.get()));
+    if (!r->Dispatch(mWorkerPrivate)) {
+      LOGV(
+          ("WorkerEventTarget::Dispatch [%p] Dispatch as debugger runnable(%p) "
+           "fail",
+           this, r.get()));
+      return NS_ERROR_FAILURE;
+    }
+    return NS_OK;
+  }
+
   if (mBehavior == Behavior::Hybrid) {
     LOGV(("WorkerEventTarget::Dispatch [%p] Dispatch as normal runnable(%p)",
           this, runnable.get()));