# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/remoteworkers/RemoteWorkerService.cpp
# Commit: 01fe98c08d10
# Full Hash: 01fe98c08d102c28e3a61209ea31834eff83202a
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-03-25 21:02:33
# Regressor Bug: 1899503
# File Overlap Count: 4
# Description:
#   Bug 1899503 - P3 PRemoteWorkerDebugger binding implementation. r=asuth
#   
#   This patch implements the PRemoteWorkerDebugger binding.
#   
#   We are trying to keep the same logic debugger registration/unregistration to minimize the difference between the local debugger(the debugger on the content process main thread)
# ==============================================================================

diff -r 9bd2a82481f4 -r 01fe98c08d10 dom/workers/remoteworkers/RemoteWorkerService.cpp
--- a/dom/workers/remoteworkers/RemoteWorkerService.cpp	Tue Mar 25 09:13:20 2025 +0000
+++ b/dom/workers/remoteworkers/RemoteWorkerService.cpp	Tue Mar 25 09:13:20 2025 +0000
@@ -190,12 +190,26 @@
   StaticMutexAutoLock lock(sRemoteWorkerServiceMutex);
   MOZ_ASSERT(sRemoteWorkerService);
   MOZ_ASSERT(sRemoteWorkerService->mThread);
+
+  // If we are on WorkerLauncher thread, direcly call
+  // RemoteWorkerDebuggerManager::SendRegister.
   if (sRemoteWorkerService->mThread->IsOnCurrentThread()) {
-    MOZ_ASSERT(sRemoteWorkerService->mDebuggerManagerActor);
-    Unused << sRemoteWorkerService->mDebuggerManagerActor->SendRegister(
+    MOZ_ASSERT(sRemoteWorkerService->mDebuggerManagerChild);
+    Unused << sRemoteWorkerService->mDebuggerManagerChild->SendRegister(
         std::move(aDebuggerInfo), std::move(aDebuggerParentEp));
     return;
   }
+
+  // For top-level workers in parent process, directly call RecvRegister().
+  if (XRE_IsParentProcess() && NS_IsMainThread()) {
+    MOZ_ASSERT(sRemoteWorkerService->mDebuggerManagerParent);
+    Unused << sRemoteWorkerService->mDebuggerManagerParent->RecvRegister(
+        std::move(aDebuggerInfo), std::move(aDebuggerParentEp));
+    return;
+  }
+
+  // We are on other thread in the case of this is a Child worker. Dispatch this
+  // method to WorkerLauncher thread.
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
       "RemoteWorkerService::RegisterRemoteDebugger",
       [debuggerInfo = std::move(aDebuggerInfo),
@@ -263,9 +277,9 @@
        debuggerChildEp = std::move(aDebuggerChildEp)]() mutable {
         self->InitializeOnTargetThread(std::move(endpoint));
 
-        self->mDebuggerManagerActor =
+        self->mDebuggerManagerChild =
             MakeRefPtr<RemoteWorkerDebuggerManagerChild>();
-        debuggerChildEp.Bind(self->mDebuggerManagerActor);
+        debuggerChildEp.Bind(self->mDebuggerManagerChild);
       });
 
   rv = mThread->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
@@ -353,9 +367,9 @@
   NS_ENSURE_TRUE(parentActor, NS_ERROR_FAILURE);
 
   Endpoint<PRemoteWorkerDebuggerManagerChild> debuggerChildEp;
-  RefPtr<RemoteWorkerDebuggerManagerParent> debuggerParentActor =
+  mDebuggerManagerParent =
       RemoteWorkerDebuggerManagerParent::CreateForProcess(&debuggerChildEp);
-  NS_ENSURE_TRUE(debuggerParentActor, NS_ERROR_FAILURE);
+  NS_ENSURE_TRUE(mDebuggerManagerParent, NS_ERROR_FAILURE);
 
   return InitializeOnMainThread(std::move(childEp), std::move(debuggerChildEp));
 }