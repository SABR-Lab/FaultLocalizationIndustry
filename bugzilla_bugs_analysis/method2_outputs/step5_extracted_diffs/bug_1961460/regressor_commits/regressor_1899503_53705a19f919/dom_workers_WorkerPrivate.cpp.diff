# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: 53705a19f919
# Full Hash: 53705a19f919adf1d104910ac49d4f937d8ffbe8
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-04-15 21:21:06
# Regressor Bug: 1899503
# File Overlap Count: 1
# Description:
#   Bug 1899503 - P4 Update SharedWorker windowID for remote worker debugger. r=asuth
#   
#   Depends on D230260
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231778
# ==============================================================================

diff -r f2debe329bca -r 53705a19f919 dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Tue Apr 15 09:47:39 2025 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Tue Apr 15 09:47:39 2025 +0000
@@ -5707,6 +5707,8 @@
 }
 
 void WorkerPrivate::PostMessageToDebugger(const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
+
   mDebugger->PostMessageToDebugger(aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5734,6 +5736,7 @@
 void WorkerPrivate::ReportErrorToDebugger(const nsACString& aFilename,
                                           uint32_t aLineno,
                                           const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
   mDebugger->ReportErrorToDebugger(aFilename, aLineno, aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5749,6 +5752,28 @@
                                     nsAutoString(aMessage)));
 }
 
+void WorkerPrivate::UpdateWindowIDToDebugger(const uint64_t& aWindowID,
+                                             const bool& aIsAdd) {
+  AssertIsOnWorkerThread();
+  // only need to update the remote debugger since local debugger grab the
+  // windowIDs information from RemoteWorkerChild directly.
+
+  RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
+  {
+    MutexAutoLock lock(mMutex);
+    if (!mRemoteDebugger) {
+      return;
+    }
+    remoteDebugger = mRemoteDebugger;
+  }
+  MOZ_ASSERT_DEBUG_OR_FUZZING(remoteDebugger);
+  if (aIsAdd) {
+    Unused << remoteDebugger->SendAddWindowID(aWindowID);
+  } else {
+    Unused << remoteDebugger->SendRemoveWindowID(aWindowID);
+  }
+}
+
 bool WorkerPrivate::NotifyInternal(WorkerStatus aStatus) {
   auto data = mWorkerThreadAccessible.Access();
 