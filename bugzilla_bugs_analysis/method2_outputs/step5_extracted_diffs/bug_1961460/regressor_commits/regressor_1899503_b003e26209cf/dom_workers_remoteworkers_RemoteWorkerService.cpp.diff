# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/remoteworkers/RemoteWorkerService.cpp
# Commit: b003e26209cf
# Full Hash: b003e26209cf8e5dc1ac040f43f9caff01a5c613
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-04-09 04:12:49
# Regressor Bug: 1899503
# File Overlap Count: 2
# Description:
#   Bug 1899503 - P2 PRemoteWorkerDebuggerMangaer binding implementation. r=asuth
#   
#   This patch implements the PRemoteWorkerDebuggerManager binding.
#   
#   PRemoteWorkerDebuggerManager is the IPC that handles the registration/unregistration of remote debuggers.
# ==============================================================================

diff -r 9e22fbf8ab8f -r b003e26209cf dom/workers/remoteworkers/RemoteWorkerService.cpp
--- a/dom/workers/remoteworkers/RemoteWorkerService.cpp	Tue Apr 08 09:43:33 2025 +0000
+++ b/dom/workers/remoteworkers/RemoteWorkerService.cpp	Tue Apr 08 09:43:33 2025 +0000
@@ -7,6 +7,7 @@
 #include "RemoteWorkerService.h"
 
 #include "mozilla/dom/PRemoteWorkerParent.h"
+#include "mozilla/dom/PRemoteWorkerDebuggerParent.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundChild.h"
@@ -21,6 +22,8 @@
 #include "nsThreadUtils.h"
 #include "nsXPCOMPrivate.h"
 #include "RemoteWorkerController.h"
+#include "RemoteWorkerDebuggerManagerChild.h"
+#include "RemoteWorkerDebuggerManagerParent.h"
 #include "RemoteWorkerServiceChild.h"
 #include "RemoteWorkerServiceParent.h"
 
@@ -147,7 +150,9 @@
 
 /* static */
 void RemoteWorkerService::InitializeChild(
-    mozilla::ipc::Endpoint<PRemoteWorkerServiceChild> aEndpoint) {
+    mozilla::ipc::Endpoint<PRemoteWorkerServiceChild> aEndpoint,
+    mozilla::ipc::Endpoint<PRemoteWorkerDebuggerManagerChild>
+        aDebuggerChildEp) {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!XRE_IsParentProcess());
 
@@ -161,7 +166,8 @@
   // We are being told to initialize now that we know what our remote type is.
   // Now is a fine time to call InitializeOnMainThread.
 
-  nsresult rv = service->InitializeOnMainThread(std::move(aEndpoint));
+  nsresult rv = service->InitializeOnMainThread(std::move(aEndpoint),
+                                                std::move(aDebuggerChildEp));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
@@ -178,6 +184,30 @@
 }
 
 /* static */
+void RemoteWorkerService::RegisterRemoteDebugger(
+    RemoteWorkerDebuggerInfo aDebuggerInfo,
+    mozilla::ipc::Endpoint<PRemoteWorkerDebuggerParent> aDebuggerParentEp) {
+  StaticMutexAutoLock lock(sRemoteWorkerServiceMutex);
+  MOZ_ASSERT(sRemoteWorkerService);
+  MOZ_ASSERT(sRemoteWorkerService->mThread);
+  if (sRemoteWorkerService->mThread->IsOnCurrentThread()) {
+    MOZ_ASSERT(sRemoteWorkerService->mDebuggerManagerActor);
+    Unused << sRemoteWorkerService->mDebuggerManagerActor->SendRegister(
+        std::move(aDebuggerInfo), std::move(aDebuggerParentEp));
+    return;
+  }
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
+      "RemoteWorkerService::RegisterRemoteDebugger",
+      [debuggerInfo = std::move(aDebuggerInfo),
+       debuggerParentEp = std::move(aDebuggerParentEp)]() mutable {
+        RemoteWorkerService::RegisterRemoteDebugger(
+            std::move(debuggerInfo), std::move(debuggerParentEp));
+      });
+  Unused << NS_WARN_IF(
+      NS_FAILED(sRemoteWorkerService->mThread->Dispatch(r.forget())));
+}
+
+/* static */
 already_AddRefed<RemoteWorkerServiceKeepAlive>
 RemoteWorkerService::MaybeGetKeepAlive() {
   StaticMutexAutoLock lock(sRemoteWorkerServiceMutex);
@@ -196,7 +226,9 @@
 }
 
 nsresult RemoteWorkerService::InitializeOnMainThread(
-    mozilla::ipc::Endpoint<PRemoteWorkerServiceChild> aEndpoint) {
+    mozilla::ipc::Endpoint<PRemoteWorkerServiceChild> aEndpoint,
+    mozilla::ipc::Endpoint<PRemoteWorkerDebuggerManagerChild>
+        aDebuggerChildEp) {
   // I would like to call this thread "DOM Remote Worker Launcher", but the max
   // length is 16 chars.
   nsresult rv = NS_NewNamedThread("Worker Launcher", getter_AddRefs(mThread));
@@ -226,8 +258,14 @@
 
   RefPtr<RemoteWorkerService> self = this;
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
-      "InitializeThread", [self, endpoint = std::move(aEndpoint)]() mutable {
+      "InitializeThread",
+      [self, endpoint = std::move(aEndpoint),
+       debuggerChildEp = std::move(aDebuggerChildEp)]() mutable {
         self->InitializeOnTargetThread(std::move(endpoint));
+
+        self->mDebuggerManagerActor =
+            MakeRefPtr<RemoteWorkerDebuggerManagerChild>();
+        debuggerChildEp.Bind(self->mDebuggerManagerActor);
       });
 
   rv = mThread->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
@@ -314,7 +352,12 @@
       RemoteWorkerServiceParent::CreateForProcess(nullptr, &childEp);
   NS_ENSURE_TRUE(parentActor, NS_ERROR_FAILURE);
 
-  return InitializeOnMainThread(std::move(childEp));
+  Endpoint<PRemoteWorkerDebuggerManagerChild> debuggerChildEp;
+  RefPtr<RemoteWorkerDebuggerManagerParent> debuggerParentActor =
+      RemoteWorkerDebuggerManagerParent::CreateForProcess(&debuggerChildEp);
+  NS_ENSURE_TRUE(debuggerParentActor, NS_ERROR_FAILURE);
+
+  return InitializeOnMainThread(std::move(childEp), std::move(debuggerChildEp));
 }
 
 void RemoteWorkerService::BeginShutdown() {