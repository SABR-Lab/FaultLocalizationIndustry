# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: d40050ad198b
# Full Hash: d40050ad198b651e81efebf8d9fd7cf7bced8395
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-04-09 04:12:49
# Regressor Bug: 1899503
# File Overlap Count: 1
# Description:
#   Bug 1899503 - P4 Update SharedWorker windowID for remote worker debugger. r=asuth
#   
#   Depends on D230260
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231778
# ==============================================================================

diff -r 1e774bd7f365 -r d40050ad198b dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Tue Apr 08 09:43:33 2025 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Tue Apr 08 09:43:33 2025 +0000
@@ -5706,6 +5706,8 @@
 }
 
 void WorkerPrivate::PostMessageToDebugger(const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
+
   mDebugger->PostMessageToDebugger(aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5733,6 +5735,7 @@
 void WorkerPrivate::ReportErrorToDebugger(const nsACString& aFilename,
                                           uint32_t aLineno,
                                           const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
   mDebugger->ReportErrorToDebugger(aFilename, aLineno, aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5748,6 +5751,28 @@
                                     nsAutoString(aMessage)));
 }
 
+void WorkerPrivate::UpdateWindowIDToDebugger(const uint64_t& aWindowID,
+                                             const bool& aIsAdd) {
+  AssertIsOnWorkerThread();
+  // only need to update the remote debugger since local debugger grab the
+  // windowIDs information from RemoteWorkerChild directly.
+
+  RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
+  {
+    MutexAutoLock lock(mMutex);
+    if (!mRemoteDebugger) {
+      return;
+    }
+    remoteDebugger = mRemoteDebugger;
+  }
+  MOZ_ASSERT_DEBUG_OR_FUZZING(remoteDebugger);
+  if (aIsAdd) {
+    Unused << remoteDebugger->SendAddWindowID(aWindowID);
+  } else {
+    Unused << remoteDebugger->SendRemoveWindowID(aWindowID);
+  }
+}
+
 bool WorkerPrivate::NotifyInternal(WorkerStatus aStatus) {
   auto data = mWorkerThreadAccessible.Access();
 