# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/workers/WorkerPrivate.cpp
# Commit: d926f7fefc9d
# Full Hash: d926f7fefc9dc9eab1d2e65a87ab2883c5ef5143
# Author: Eden Chuang <echuang@mozilla.com>
# Date: 2025-03-25 21:02:33
# Regressor Bug: 1899503
# File Overlap Count: 1
# Description:
#   Bug 1899503 - P4 Update SharedWorker windowID for remote worker debugger. r=asuth
#   
#   Depends on D230260
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231778
# ==============================================================================

diff -r 01fe98c08d10 -r d926f7fefc9d dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp	Tue Mar 25 09:13:20 2025 +0000
+++ b/dom/workers/WorkerPrivate.cpp	Tue Mar 25 09:13:21 2025 +0000
@@ -5693,6 +5693,8 @@
 }
 
 void WorkerPrivate::PostMessageToDebugger(const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
+
   mDebugger->PostMessageToDebugger(aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5720,6 +5722,7 @@
 void WorkerPrivate::ReportErrorToDebugger(const nsACString& aFilename,
                                           uint32_t aLineno,
                                           const nsAString& aMessage) {
+  AssertIsOnWorkerThread();
   mDebugger->ReportErrorToDebugger(aFilename, aLineno, aMessage);
   RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
   {
@@ -5735,6 +5738,28 @@
                                     nsAutoString(aMessage)));
 }
 
+void WorkerPrivate::UpdateWindowIDToDebugger(const uint64_t& aWindowID,
+                                             const bool& aIsAdd) {
+  AssertIsOnWorkerThread();
+  // only need to update the remote debugger since local debugger grab the
+  // windowIDs information from RemoteWorkerChild directly.
+
+  RefPtr<RemoteWorkerDebuggerChild> remoteDebugger;
+  {
+    MutexAutoLock lock(mMutex);
+    if (!mRemoteDebugger) {
+      return;
+    }
+    remoteDebugger = mRemoteDebugger;
+  }
+  MOZ_ASSERT_DEBUG_OR_FUZZING(remoteDebugger);
+  if (aIsAdd) {
+    Unused << remoteDebugger->SendAddWindowID(aWindowID);
+  } else {
+    Unused << remoteDebugger->SendRemoveWindowID(aWindowID);
+  }
+}
+
 bool WorkerPrivate::NotifyInternal(WorkerStatus aStatus) {
   auto data = mWorkerThreadAccessible.Access();
 