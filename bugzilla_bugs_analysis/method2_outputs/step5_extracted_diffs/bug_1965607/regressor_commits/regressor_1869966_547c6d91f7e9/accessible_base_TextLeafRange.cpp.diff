# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/TextLeafRange.cpp
# Commit: 547c6d91f7e9
# Full Hash: 547c6d91f7e99909a4ec3f96327251641705d217
# Author: James Teh <jteh@mozilla.com>
# Date: 2025-05-07 04:19:47
# Regressor Bug: 1869966
# File Overlap Count: 1
# Description:
#   Bug 1869966 part 3: When calculating a DOM point from a TextLeafPoint for a non-text node, use the child index within the parent, not an offset within the node itself. r=eeejay
#   
#   For text nodes, DOM points use the character offset within the node itself, just like accessibility does.
#   For non-text nodes, DOM points use the child index within the parent to specify the position before or after the node.
#   Previously, TextLeafPoint::ToDOMPoint always used an offset within the node itself.
# ==============================================================================

diff -r 16652a9ee9f7 -r 547c6d91f7e9 accessible/base/TextLeafRange.cpp
--- a/accessible/base/TextLeafRange.cpp	Tue May 06 22:13:58 2025 +0000
+++ b/accessible/base/TextLeafRange.cpp	Tue May 06 22:13:58 2025 +0000
@@ -536,7 +536,7 @@
   return startFrameSel ? &startFrameSel->NormalSelection() : nullptr;
 }
 
-std::pair<nsIContent*, int32_t> TextLeafPoint::ToDOMPoint(
+std::pair<nsIContent*, uint32_t> TextLeafPoint::ToDOMPoint(
     bool aIncludeGenerated) const {
   if (!(*this) || !mAcc->IsLocal()) {
     MOZ_ASSERT_UNREACHABLE("Invalid point");
@@ -573,26 +573,37 @@
     }
   }
 
-  if (!mAcc->IsTextLeaf() && !mAcc->IsHTMLBr() && !mAcc->HasChildren()) {
-    // If this is not a text leaf it can be an empty editable container,
-    // whitespace, or an empty doc. In any case, the offset inside should be 0.
-    MOZ_ASSERT(mOffset == 0);
+  if (mAcc->IsTextLeaf()) {
+    // For text nodes, DOM uses a character offset within the node.
+    return {content, RenderedToContentOffset(mAcc->AsLocal(), mOffset)};
+  }
 
-    if (RefPtr<TextControlElement> textControlElement =
-            TextControlElement::FromNodeOrNull(content)) {
-      // This is an empty input, use the shadow root's element.
-      if (RefPtr<TextEditor> textEditor = textControlElement->GetTextEditor()) {
-        if (textEditor->IsEmpty()) {
-          MOZ_ASSERT(mOffset == 0);
-          return {textEditor->GetRoot(), 0};
-        }
+  if (!mAcc->IsHyperText()) {
+    // For non-text nodes (e.g. images), DOM points use the child index within
+    // the parent.
+    nsIContent* parent = content->GetParent();
+    MOZ_ASSERT(parent);
+    auto childIndex = parent->ComputeIndexOf(content);
+    MOZ_ASSERT(childIndex);
+    return {parent, *childIndex};
+  }
+
+  // This could be an empty editable container, whitespace or an empty doc. In
+  // any case, the offset inside should be 0.
+  MOZ_ASSERT(mOffset == 0);
+
+  if (RefPtr<TextControlElement> textControlElement =
+          TextControlElement::FromNodeOrNull(content)) {
+    // This is an empty input, use the shadow root's element.
+    if (RefPtr<TextEditor> textEditor = textControlElement->GetTextEditor()) {
+      if (textEditor->IsEmpty()) {
+        MOZ_ASSERT(mOffset == 0);
+        return {textEditor->GetRoot(), 0};
       }
     }
-
-    return {content, 0};
   }
 
-  return {content, RenderedToContentOffset(mAcc->AsLocal(), mOffset)};
+  return {content, 0};
 }
 
 static bool IsLineBreakContinuation(nsTextFrame* aContinuation) {