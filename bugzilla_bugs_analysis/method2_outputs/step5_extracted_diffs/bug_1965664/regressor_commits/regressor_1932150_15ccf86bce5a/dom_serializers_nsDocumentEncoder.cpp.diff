# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serializers/nsDocumentEncoder.cpp
# Commit: 15ccf86bce5a
# Full Hash: 15ccf86bce5a786e4cbda785e186a2efd342b293
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 2
# Description:
#   Bug 1932150 - Fix some inconsistency about indicating whether the selection is allowed to cross the shadow boundary r=jjaschke,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D246949
# ==============================================================================

diff -r 40f9fe959b19 -r 15ccf86bce5a dom/serializers/nsDocumentEncoder.cpp
--- a/dom/serializers/nsDocumentEncoder.cpp	Wed May 07 15:04:40 2025 +0000
+++ b/dom/serializers/nsDocumentEncoder.cpp	Wed May 07 15:05:08 2025 +0000
@@ -47,6 +47,7 @@
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/AbstractRange.h"
 #include "mozilla/dom/Text.h"
+#include "mozilla/dom/AbstractRange.h"
 #include "mozilla/Encoding.h"
 #include "mozilla/IntegerRange.h"
 #include "mozilla/Maybe.h"
@@ -245,7 +246,8 @@
   virtual ~nsDocumentEncoder();
 
   void Initialize(bool aClearCachedSerializer = true,
-                  bool aAllowCrossShadowBoundary = false);
+                  AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
+                      AllowRangeCrossShadowBoundary::No);
 
   /**
    * @param aMaxLength As described at
@@ -431,7 +433,7 @@
           mNodeSerializer{aNodeSerializer},
           mRangeContextSerializer{aRangeContextSerializer} {}
 
-    void Initialize(bool aAllowCrossShadowBoundary);
+    void Initialize(AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
 
     /**
      * @param aDepth the distance (number of `GetParent` calls) from aNode to
@@ -498,14 +500,15 @@
     const NodeSerializer& mNodeSerializer;
     RangeContextSerializer& mRangeContextSerializer;
 
-    bool mAllowCrossShadowBoundary = false;
+    AllowRangeCrossShadowBoundary mAllowCrossShadowBoundary =
+        AllowRangeCrossShadowBoundary::No;
   };
 
   RangeSerializer mRangeSerializer;
 };
 
 void nsDocumentEncoder::RangeSerializer::Initialize(
-    bool aAllowCrossShadowBoundary) {
+    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
   mContextInfoDepth = {};
   mStartRootIndex = 0;
   mEndRootIndex = 0;
@@ -548,8 +551,9 @@
 nsDocumentEncoder::nsDocumentEncoder()
     : nsDocumentEncoder(MakeUnique<RangeNodeContext>()) {}
 
-void nsDocumentEncoder::Initialize(bool aClearCachedSerializer,
-                                   bool aAllowCrossShadowBoundary) {
+void nsDocumentEncoder::Initialize(
+    bool aClearCachedSerializer,
+    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
   mFlags = 0;
   mWrapColumn = 72;
   mRangeSerializer.Initialize(aAllowCrossShadowBoundary);
@@ -570,6 +574,13 @@
   return parent->IsHTMLElement(nsGkAtoms::tr);
 }
 
+static AllowRangeCrossShadowBoundary GetAllowRangeCrossShadowBoundary(
+    const uint32_t aFlags) {
+  return (aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary)
+             ? AllowRangeCrossShadowBoundary::Yes
+             : AllowRangeCrossShadowBoundary::No;
+}
+
 nsresult nsDocumentEncoder::SerializeDependingOnScope(uint32_t aMaxLength) {
   nsresult rv = NS_OK;
   if (mEncodingScope.mSelection) {
@@ -608,7 +619,7 @@
     // by the immediate context. This assumes that you can't select cells that
     // are multiple selections from two tables simultaneously.
     node = ShadowDOMSelectionHelpers::GetStartContainer(
-        range, mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
+        range, GetAllowRangeCrossShadowBoundary(mFlags));
     NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     if (node != prevNode) {
       if (prevNode) {
@@ -725,7 +736,7 @@
   if (!aDocument) return NS_ERROR_INVALID_ARG;
 
   Initialize(!mMimeType.Equals(aMimeType),
-             aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
+             GetAllowRangeCrossShadowBoundary(aFlags));
 
   mDocument = aDocument;
 
@@ -959,7 +970,7 @@
   }
 
   ShadowRoot* shadowRoot = ShadowDOMSelectionHelpers::GetShadowRoot(
-      aNode, mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
+      aNode, GetAllowRangeCrossShadowBoundary(mFlags));
 
   if (shadowRoot) {
     MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
@@ -1314,8 +1325,10 @@
 
 nsresult nsDocumentEncoder::RangeSerializer::SerializeRangeToString(
     const nsRange* aRange) {
-  if (!aRange || (aRange->Collapsed() && (!mAllowCrossShadowBoundary ||
-                                          !aRange->MayCrossShadowBoundary()))) {
+  if (!aRange ||
+      (aRange->Collapsed() &&
+       (mAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::No ||
+        !aRange->MayCrossShadowBoundary()))) {
     return NS_OK;
   }
 
@@ -1325,9 +1338,7 @@
   // boundary can return the host element as the container.
   // SerializeRangeContextStart doesn't support this case.
   mClosestCommonInclusiveAncestorOfRange =
-      aRange->GetClosestCommonInclusiveAncestor(
-          mAllowCrossShadowBoundary ? AllowRangeCrossShadowBoundary::Yes
-                                    : AllowRangeCrossShadowBoundary::No);
+      aRange->GetClosestCommonInclusiveAncestor(mAllowCrossShadowBoundary);
 
   if (!mClosestCommonInclusiveAncestorOfRange) {
     return NS_OK;
@@ -1362,7 +1373,7 @@
 
   nsContentUtils::GetInclusiveAncestors(mClosestCommonInclusiveAncestorOfRange,
                                         mCommonInclusiveAncestors);
-  if (mAllowCrossShadowBoundary) {
+  if (mAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
     nsContentUtils::GetShadowIncludingAncestorsAndOffsets(
         startContainer, startOffset, inclusiveAncestorsOfStart,
         inclusiveAncestorsOffsetsOfStart);
@@ -1611,7 +1622,7 @@
   if (!aDocument) return NS_ERROR_INVALID_ARG;
 
   mIsTextWidget = false;
-  Initialize(true, aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
+  Initialize(true, GetAllowRangeCrossShadowBoundary(aFlags));
 
   mIsCopying = true;
   mDocument = aDocument;
@@ -1856,19 +1867,13 @@
 
   // set the range to the new values
   ErrorResult err;
-  const bool allowRangeCrossShadowBoundary =
-      mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary;
   inRange->SetStart(*opStartNode, static_cast<uint32_t>(opStartOffset), err,
-                    allowRangeCrossShadowBoundary
-                        ? AllowRangeCrossShadowBoundary::Yes
-                        : AllowRangeCrossShadowBoundary::No);
+                    GetAllowRangeCrossShadowBoundary(mFlags));
   if (NS_WARN_IF(err.Failed())) {
     return err.StealNSResult();
   }
   inRange->SetEnd(*opEndNode, static_cast<uint32_t>(opEndOffset), err,
-                  allowRangeCrossShadowBoundary
-                      ? AllowRangeCrossShadowBoundary::Yes
-                      : AllowRangeCrossShadowBoundary::No);
+                  GetAllowRangeCrossShadowBoundary(mFlags));
   if (NS_WARN_IF(err.Failed())) {
     return err.StealNSResult();
   }
@@ -2057,8 +2062,7 @@
         const bool isGeneratedContent =
             offset == -1 &&
             ShadowDOMSelectionHelpers::GetShadowRoot(
-                parent,
-                mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary) != node;
+                parent, GetAllowRangeCrossShadowBoundary(mFlags)) != node;
         if (isGeneratedContent)  // we hit generated content; STOP
         {
           // back up a bit
