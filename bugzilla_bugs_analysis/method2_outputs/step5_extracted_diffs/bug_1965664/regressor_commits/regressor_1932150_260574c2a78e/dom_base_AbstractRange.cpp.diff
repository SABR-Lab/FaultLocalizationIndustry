# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/AbstractRange.cpp
# Commit: 260574c2a78e
# Full Hash: 260574c2a78e619e6c9815a797a8df7086004994
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Update ranges to correctly set and update nodes for flattened selection r=jjaschke,smaug,dom-core"
#   
#   This reverts commit 0221ba097eb5884f3efe76c607cb0cc7c9170635.
# ==============================================================================

diff -r d699f1b53a1e -r 260574c2a78e dom/base/AbstractRange.cpp
--- a/dom/base/AbstractRange.cpp	Thu May 08 22:53:05 2025 +0300
+++ b/dom/base/AbstractRange.cpp	Thu May 08 22:53:06 2025 +0300
@@ -13,10 +13,8 @@
 #include "mozilla/RangeUtils.h"
 #include "mozilla/dom/ChildIterator.h"
 #include "mozilla/dom/Document.h"
-#include "mozilla/dom/DocumentInlines.h"
 #include "mozilla/dom/StaticRange.h"
 #include "mozilla/dom/Selection.h"
-#include "mozilla/dom/TreeIterator.h"
 #include "mozilla/dom/CrossShadowBoundaryRange.h"
 #include "nsContentUtils.h"
 #include "nsCycleCollectionParticipant.h"
@@ -29,33 +27,28 @@
 
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, nsRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aEndBoundary, nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aEndBoundary, StaticRange* aRange);
 template bool AbstractRange::MaybeCacheToReuse(nsRange& aInstance);
 template bool AbstractRange::MaybeCacheToReuse(StaticRange& aInstance);
 template bool AbstractRange::MaybeCacheToReuse(
@@ -98,70 +91,32 @@
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRegisteredClosestCommonInclusiveAncestor)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
-static void UpdateDescendantsInSameTree(const nsINode& aNode,
-                                        bool aMarkDesendants) {
-  MOZ_ASSERT(!StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-  // don't set the Descendant bit on |aNode| itself
-  nsINode* node = aNode.GetNextNode(&aNode);
-  while (node) {
+// When aMarkDesendants is true, Set
+// DescendantOfClosestCommonInclusiveAncestorForRangeInSelection flag for the
+// shadow including children of aNode. When aMarkDesendants is false, unset that
+// flag for the shadow including children of aNode.
+void UpdateDescendantsByShadowIncludingOrder(const nsIContent& aNode,
+                                             bool aMarkDesendants) {
+  ShadowIncludingTreeIterator iter(*const_cast<nsIContent*>(&aNode));
+  ++iter;  // We don't want to mark the root node
+
+  while (iter) {
+    nsINode* node = *iter;
     if (aMarkDesendants) {
       node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
     } else {
       node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
     }
 
-    if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
-      node = node->GetNextNode(&aNode);
-    } else {
-      // We found an ancestor of an overlapping range, skip its descendants.
-      node = node->GetNextNonChildNode(&aNode);
+    if (node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+      iter.SkipChildren();
+      continue;
     }
+    ++iter;
   }
 }
 
-void AbstractRange::UpdateDescendantsInFlattenedTree(nsINode& aNode,
-                                                     bool aMarkDescendants) {
-  MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-
-  auto UpdateDescendant = [aMarkDescendants](nsINode* node) {
-    if (aMarkDescendants) {
-      node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
-    } else {
-      node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
-    }
-  };
-
-  nsINode* target = &aNode;
-
-  if (target->IsDocument()) {
-    if (auto* rootElement = aNode.AsDocument()->GetRootElement()) {
-      target = rootElement;
-      UpdateDescendant(target);
-    }
-  }
-
-  if (!target || !target->IsContent()) {
-    return;
-  }
-
-  TreeIterator<FlattenedChildIterator> iter(*target->AsContent());
-  iter.GetNext();  // Skip aNode itself.
-  while (nsIContent* curNode = iter.GetCurrent()) {
-    if (curNode->IsInNativeAnonymousSubtree()) {
-      iter.GetNextSkippingChildren();
-      continue;
-    }
-
-    UpdateDescendant(curNode);
-    if (curNode->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
-      iter.GetNextSkippingChildren();
-    } else {
-      iter.GetNext();
-    }
-  }
-}
-
-void AbstractRange::MarkDescendants(nsINode& aNode) {
+void AbstractRange::MarkDescendants(const nsINode& aNode) {
   // Set NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection on
   // aNode's descendants unless aNode is already marked as a range common
   // ancestor or a descendant of one, in which case all of our descendants have
@@ -169,26 +124,59 @@
   if (!aNode.IsMaybeSelected()) {
     // If aNode has a web-exposed shadow root, use this shadow tree and ignore
     // the children of aNode.
-
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      UpdateDescendantsInFlattenedTree(aNode, true /* aMarkDescendants */);
-    } else {
-      UpdateDescendantsInSameTree(aNode, true /* aMarkDescendants */);
+    if (aNode.GetShadowRootForSelection()) {
+      UpdateDescendantsByShadowIncludingOrder(*aNode.AsContent(), true);
+      return;
+    }
+    // don't set the Descendant bit on |aNode| itself
+    nsINode* node = aNode.GetNextNode(&aNode);
+    while (node) {
+      node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
+      if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+        if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+          UpdateDescendantsByShadowIncludingOrder(*node->AsContent(), true);
+          // sub-tree of node has been marked already
+          node = node->GetNextNonChildNode(&aNode);
+        } else {
+          node = node->GetNextNode(&aNode);
+        }
+      } else {
+        // optimize: skip this sub-tree since it's marked already.
+        node = node->GetNextNonChildNode(&aNode);
+      }
     }
   }
 }
 
-void AbstractRange::UnmarkDescendants(nsINode& aNode) {
+void AbstractRange::UnmarkDescendants(const nsINode& aNode) {
   // Unset NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
   // on aNode's descendants unless aNode is a descendant of another range common
   // ancestor. Also, exclude descendants of range common ancestors (but not the
   // common ancestor itself).
   if (!aNode
            .IsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection()) {
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      UpdateDescendantsInFlattenedTree(aNode, false /* aMarkDescendants */);
-    } else {
-      UpdateDescendantsInSameTree(aNode, false /* aMarkDescendants */);
+    // If aNode has a web-exposed shadow root, use this shadow tree and ignore
+    // the children of aNode.
+    if (aNode.GetShadowRootForSelection()) {
+      UpdateDescendantsByShadowIncludingOrder(*aNode.AsContent(), false);
+      return;
+    }
+    // we know |aNode| doesn't have any bit set
+    nsINode* node = aNode.GetNextNode(&aNode);
+    while (node) {
+      node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
+      if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+        if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+          UpdateDescendantsByShadowIncludingOrder(*node->AsContent(), false);
+          // sub-tree has been marked already
+          node = node->GetNextNonChildNode(&aNode);
+        } else {
+          node = node->GetNextNode(&aNode);
+        }
+      } else {
+        // We found an ancestor of an overlapping range, skip its descendants.
+        node = node->GetNextNonChildNode(&aNode);
+      }
     }
   }
 }
@@ -315,8 +303,7 @@
           typename RangeType>
 nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
-    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
+    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange) {
   if (NS_WARN_IF(!aStartBoundary.IsSet()) ||
       NS_WARN_IF(!aEndBoundary.IsSet())) {
     return NS_ERROR_INVALID_ARG;
@@ -384,11 +371,7 @@
   }
 
   const Maybe<int32_t> pointOrder =
-      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes &&
-              StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()
-          ? nsContentUtils::ComparePoints<TreeKind::Flat>(aStartBoundary,
-                                                          aEndBoundary)
-          : nsContentUtils::ComparePoints(aStartBoundary, aEndBoundary);
+      nsContentUtils::ComparePoints(aStartBoundary, aEndBoundary);
   if (!pointOrder) {
     // Safely return a value but also detected this in debug builds.
     MOZ_ASSERT_UNREACHABLE();