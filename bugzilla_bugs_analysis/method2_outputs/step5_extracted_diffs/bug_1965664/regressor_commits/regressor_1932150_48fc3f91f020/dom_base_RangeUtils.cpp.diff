# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/RangeUtils.cpp
# Commit: 48fc3f91f020
# Full Hash: 48fc3f91f0207ca38b1b6ab88f33c7c7c999d152
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core"
#   
#   This reverts commit 8d55fdef16bcd3e93e2aab7e4aead025c2d07ae4.
# ==============================================================================

diff -r 260574c2a78e -r 48fc3f91f020 dom/base/RangeUtils.cpp
--- a/dom/base/RangeUtils.cpp	Thu May 08 22:53:06 2025 +0300
+++ b/dom/base/RangeUtils.cpp	Thu May 08 22:53:07 2025 +0300
@@ -26,59 +26,26 @@
 template bool RangeUtils::IsValidPoints(const RawRangeBoundary& aStartBoundary,
                                         const RawRangeBoundary& aEndBoundary);
 
-template nsresult
-RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
-    nsINode* aNode, const RangeBoundary& aStartBoundary,
-    const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
+template nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RangeBoundary& aStartBoundary,
     const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult
-RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
-    nsINode* aNode, const RangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
+template nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RangeBoundary& aStartBoundary,
     const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult
-RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
-    nsINode* aNode, const RawRangeBoundary& aStartBoundary,
-    const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
+template nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RawRangeBoundary& aStartBoundary,
     const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult
-RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
-    nsINode* aNode, const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
+template nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RawRangeBoundary& aStartBoundary,
     const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult RangeUtils::CompareNodeToRange<TreeKind::ShadowIncludingDOM>(
-    nsINode* aNode, AbstractRange* aAbstractRange, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-template nsresult RangeUtils::CompareNodeToRange<TreeKind::Flat>(
-    nsINode* aNode, AbstractRange* aAbstractRange, bool* aNodeIsBeforeRange,
-    bool* aNodeIsAfterRange);
-
-template Maybe<bool>
-RangeUtils::IsNodeContainedInRange<TreeKind::ShadowIncludingDOM>(
-    nsINode& aNode, AbstractRange* aAbstractRange);
-template Maybe<bool> RangeUtils::IsNodeContainedInRange<TreeKind::Flat>(
-    nsINode& aNode, AbstractRange* aAbstractRange);
-
 [[nodiscard]] static inline bool ParentNodeIsInSameSelection(
     const nsINode& aNode) {
   // Currently, independent selection root is always the anonymous <div> in a
@@ -101,6 +68,17 @@
 }
 
 // static
+nsINode* RangeUtils::GetParentNodeInSameSelection(const nsINode* aNode) {
+  if (MOZ_UNLIKELY(!aNode)) {
+    return nullptr;
+  }
+  if (!ParentNodeIsInSameSelection(*aNode)) {
+    return nullptr;
+  }
+  return aNode->GetParentNode();
+}
+
+// static
 nsINode* RangeUtils::ComputeRootNode(nsINode* aNode) {
   if (!aNode) {
     return nullptr;
@@ -172,14 +150,13 @@
 }
 
 // static
-template <TreeKind aKind, typename Dummy>
 Maybe<bool> RangeUtils::IsNodeContainedInRange(nsINode& aNode,
                                                AbstractRange* aAbstractRange) {
   bool nodeIsBeforeRange{false};
   bool nodeIsAfterRange{false};
 
-  const nsresult rv = CompareNodeToRange<aKind>(
-      &aNode, aAbstractRange, &nodeIsBeforeRange, &nodeIsAfterRange);
+  const nsresult rv = CompareNodeToRange(&aNode, aAbstractRange,
+                                         &nodeIsBeforeRange, &nodeIsAfterRange);
   if (NS_FAILED(rv)) {
     return Nothing();
   }
@@ -195,7 +172,6 @@
 // XXX - callers responsibility to ensure node in same doc as range!
 
 // static
-template <TreeKind aKind, typename Dummy>
 nsresult RangeUtils::CompareNodeToRange(nsINode* aNode,
                                         AbstractRange* aAbstractRange,
                                         bool* aNodeIsBeforeRange,
@@ -204,13 +180,12 @@
       NS_WARN_IF(!aAbstractRange->IsPositioned())) {
     return NS_ERROR_INVALID_ARG;
   }
-  return CompareNodeToRangeBoundaries<aKind>(
+  return CompareNodeToRangeBoundaries(
       aNode, aAbstractRange->MayCrossShadowBoundaryStartRef(),
       aAbstractRange->MayCrossShadowBoundaryEndRef(), aNodeIsBeforeRange,
       aNodeIsAfterRange);
 }
-template <TreeKind aKind, typename SPT, typename SRT, typename EPT,
-          typename ERT, typename Dummy>
+template <typename SPT, typename SRT, typename EPT, typename ERT>
 nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
     const RangeBoundaryBase<EPT, ERT>& aEndBoundary, bool* aNodeIsBeforeRange,
@@ -233,17 +208,7 @@
   // gather up the dom point info
   int32_t nodeStart;
   uint32_t nodeEnd;
-  const nsINode* parent = nullptr;
-
-  MOZ_ASSERT_IF(aKind == TreeKind::Flat,
-                StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-  // ShadowRoot has no parent, nor can be represented by parent/offset pair.
-  if (!aNode->IsShadowRoot()) {
-    parent = ShadowDOMSelectionHelpers::GetParentNodeInSameSelection(
-        *aNode, aKind == TreeKind::Flat ? AllowRangeCrossShadowBoundary::Yes
-                                        : AllowRangeCrossShadowBoundary::No);
-  }
-
+  const nsINode* parent = GetParentNodeInSameSelection(aNode);
   if (!parent) {
     // can't make a parent/offset pair to represent start or
     // end of the root node, because it has no parent.
@@ -251,14 +216,6 @@
     parent = aNode;
     nodeStart = 0;
     nodeEnd = aNode->GetChildCount();
-  } else if (const HTMLSlotElement* slotAsParent =
-                 HTMLSlotElement::FromNode(parent);
-             slotAsParent && aKind == TreeKind::Flat) {
-    // aNode is a slotted content, use the index in the assigned nodes
-    // to represent this node.
-    auto index = slotAsParent->AssignedNodes().IndexOf(aNode);
-    nodeStart = index;
-    nodeEnd = nodeStart + 1;
   } else {
     nodeStart = parent->ComputeIndexOf_Deprecated(aNode);
     NS_WARNING_ASSERTION(
@@ -283,19 +240,17 @@
   // silence the warning. (Bug 1438996)
 
   // is RANGE(start) <= NODE(start) ?
-  Maybe<int32_t> order =
-      nsContentUtils::ComparePoints_AllowNegativeOffsets<aKind>(
-          aStartBoundary.GetContainer(),
-          *aStartBoundary.Offset(
-              RangeBoundaryBase<SPT,
-                                SRT>::OffsetFilter::kValidOrInvalidOffsets),
-          parent, nodeStart);
+  Maybe<int32_t> order = nsContentUtils::ComparePoints_AllowNegativeOffsets(
+      aStartBoundary.GetContainer(),
+      *aStartBoundary.Offset(
+          RangeBoundaryBase<SPT, SRT>::OffsetFilter::kValidOrInvalidOffsets),
+      parent, nodeStart);
   if (NS_WARN_IF(!order)) {
     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   }
   *aNodeIsBeforeRange = *order > 0;
   // is RANGE(end) >= NODE(end) ?
-  order = nsContentUtils::ComparePointsWithIndices<aKind>(
+  order = nsContentUtils::ComparePointsWithIndices(
       aEndBoundary.GetContainer(),
       *aEndBoundary.Offset(
           RangeBoundaryBase<EPT, ERT>::OffsetFilter::kValidOrInvalidOffsets),
@@ -360,17 +315,10 @@
   if (!ParentNodeIsInSameSelection(aNode)) {
     return nullptr;
   }
-
-  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled() &&
-      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
-    if (aNode.IsContent()) {
-      if (HTMLSlotElement* slot = aNode.AsContent()->GetAssignedSlot()) {
-        return slot;
-      }
-    }
-    return aNode.GetParentOrShadowHostNode();
-  }
-  return aNode.GetParentNode();
+  return (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled() &&
+          aAllowCrossShadowBoundary)
+             ? aNode.GetParentOrShadowHostNode()
+             : aNode.GetParentNode();
 }
 
 // static