# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/Selection.cpp
# Commit: 48fc3f91f020
# Full Hash: 48fc3f91f0207ca38b1b6ab88f33c7c7c999d152
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core"
#   
#   This reverts commit 8d55fdef16bcd3e93e2aab7e4aead025c2d07ae4.
# ==============================================================================

diff -r 260574c2a78e -r 48fc3f91f020 dom/base/Selection.cpp
--- a/dom/base/Selection.cpp	Thu May 08 22:53:06 2025 +0300
+++ b/dom/base/Selection.cpp	Thu May 08 22:53:07 2025 +0300
@@ -928,15 +928,9 @@
     return 1;
   }
 
-  nsINode* start = aRange.GetMayCrossShadowBoundaryStartContainer();
-  uint32_t startOffset = aRange.MayCrossShadowBoundaryStartOffset();
-  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-    return *nsContentUtils::ComparePoints<TreeKind::Flat>(
-        aCompareBoundary, ConstRawRangeBoundary{start, startOffset}, aCache);
-  }
-
-  return *nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-      aCompareBoundary, ConstRawRangeBoundary{start, startOffset}, aCache);
+  // The points are in the same subtree, hence there has to be an order.
+  return *nsContentUtils::ComparePoints(
+      aCompareBoundary, aRange.MayCrossShadowBoundaryStartRef(), aCache);
 }
 
 template <typename PT, typename RT>
@@ -962,14 +956,9 @@
     return 1;
   }
 
-  nsINode* end = aRange.GetMayCrossShadowBoundaryEndContainer();
-  uint32_t endOffset = aRange.MayCrossShadowBoundaryEndOffset();
-  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-    return *nsContentUtils::ComparePoints<TreeKind::Flat>(
-        aCompareBoundary, ConstRawRangeBoundary{end, endOffset});
-  }
-  return *nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-      aCompareBoundary, ConstRawRangeBoundary{end, endOffset});
+  // The points are in the same subtree, hence there has to be an order.
+  return *nsContentUtils::ComparePoints(aCompareBoundary,
+                                        aRange.MayCrossShadowBoundaryEndRef());
 }
 
 // static
@@ -3134,24 +3123,17 @@
   const uint32_t endOffset = range->MayCrossShadowBoundaryEndOffset();
 
   bool shouldClearRange = false;
-
-  auto ComparePoints = [](const nsINode* aNode1, const uint32_t aOffset1,
-                          const nsINode* aNode2, const uint32_t aOffset2) {
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      return nsContentUtils::ComparePointsWithIndices<TreeKind::Flat>(
-          aNode1, aOffset1, aNode2, aOffset2);
-    }
-    return nsContentUtils::ComparePointsWithIndices<
-        TreeKind::ShadowIncludingDOM>(aNode1, aOffset1, aNode2, aOffset2);
-  };
   const Maybe<int32_t> anchorOldFocusOrder =
-      ComparePoints(anchorNode, anchorOffset, focusNode, focusOffset);
+      nsContentUtils::ComparePointsWithIndices(anchorNode, anchorOffset,
+                                               focusNode, focusOffset);
   shouldClearRange |= !anchorOldFocusOrder;
   const Maybe<int32_t> oldFocusNewFocusOrder =
-      ComparePoints(focusNode, focusOffset, &aContainer, aOffset);
+      nsContentUtils::ComparePointsWithIndices(focusNode, focusOffset,
+                                               &aContainer, aOffset);
   shouldClearRange |= !oldFocusNewFocusOrder;
   const Maybe<int32_t> anchorNewFocusOrder =
-      ComparePoints(anchorNode, anchorOffset, &aContainer, aOffset);
+      nsContentUtils::ComparePointsWithIndices(anchorNode, anchorOffset,
+                                               &aContainer, aOffset);
   shouldClearRange |= !anchorNewFocusOrder;
 
   // If the points are disconnected, the range will be collapsed below,
@@ -4249,10 +4231,7 @@
   //     new nsRange instance?
   SelectionBatcher batch(this, __FUNCTION__);
   const Maybe<int32_t> order =
-      StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()
-          ? nsContentUtils::ComparePoints<TreeKind::Flat>(aAnchorRef, aFocusRef)
-          : nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-                aAnchorRef, aFocusRef);
+      nsContentUtils::ComparePoints(aAnchorRef, aFocusRef);
   if (order && (*order <= 0)) {
     SetStartAndEndInternal(aInLimiter, aAnchorRef, aFocusRef, eDirNext, aRv);
     return;