# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsRange.cpp
# Commit: 48fc3f91f020
# Full Hash: 48fc3f91f0207ca38b1b6ab88f33c7c7c999d152
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core"
#   
#   This reverts commit 8d55fdef16bcd3e93e2aab7e4aead025c2d07ae4.
# ==============================================================================

diff -r 260574c2a78e -r 48fc3f91f020 dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp	Thu May 08 22:53:06 2025 +0300
+++ b/dom/base/nsRange.cpp	Thu May 08 22:53:07 2025 +0300
@@ -285,21 +285,12 @@
   const RangeBoundary& otherSideExistingBoundary =
       aIsSetStart ? aRange->EndRef() : aRange->StartRef();
 
-  auto ComparePoints = [aAllowCrossShadowBoundary](
-                           const RawRangeBoundary& aBoundary1,
-                           const RawRangeBoundary& aBoundary2) {
-    if (aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
-      return nsContentUtils::ComparePoints<TreeKind::Flat>(aBoundary1,
-                                                           aBoundary2);
-    }
-    return nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-        aBoundary1, aBoundary2);
-  };
   // Both bondaries are in the same root, now check for their position
   const Maybe<int32_t> order =
-      aIsSetStart
-          ? ComparePoints(aNewBoundary, otherSideExistingBoundary.AsRaw())
-          : ComparePoints(otherSideExistingBoundary.AsRaw(), aNewBoundary);
+      aIsSetStart ? nsContentUtils::ComparePoints(aNewBoundary,
+                                                  otherSideExistingBoundary)
+                  : nsContentUtils::ComparePoints(otherSideExistingBoundary,
+                                                  aNewBoundary);
 
   if (order) {
     if (*order != 1) {
@@ -333,12 +324,11 @@
     // otherSideExistingBoundary. However, it's possible that aNewBoundary
     // is valid with the otherSideExistingCrossShadowBoundaryBoundary.
     const Maybe<int32_t> withCrossShadowBoundaryOrder =
-        aIsSetStart ? ComparePoints(
-                          aNewBoundary,
-                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw())
-                    : ComparePoints(
-                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw(),
-                          aNewBoundary);
+        aIsSetStart
+            ? nsContentUtils::ComparePoints(
+                  aNewBoundary, otherSideExistingCrossShadowBoundaryBoundary)
+            : nsContentUtils::ComparePoints(
+                  otherSideExistingCrossShadowBoundaryBoundary, aNewBoundary);
 
     // Valid to the cross boundary boundary.
     if (withCrossShadowBoundaryOrder && *withCrossShadowBoundaryOrder != 1) {
@@ -3256,7 +3246,8 @@
       nsINode* node = preOrderIter.GetCurrentNode();
       preOrderIter.Next();
       bool selectable = true;
-      nsIContent* content = nsIContent::FromNodeOrNull(node);
+      nsIContent* content =
+          node && node->IsContent() ? node->AsContent() : nullptr;
       if (content) {
         if (firstNonSelectableContent &&
             ExcludeIfNextToNonSelectable(content)) {