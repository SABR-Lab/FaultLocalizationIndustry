# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ContentIterator.h
# Commit: 4d69d8456005
# Full Hash: 4d69d8456005efeb2ad4581ff00120e63c0bbdbc
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 2
# Description:
#   Revert "Bug 1932150 - Fix some inconsistency about indicating whether the selection is allowed to cross the shadow boundary r=jjaschke,dom-core"
#   
#   This reverts commit f0836d70a70a1dbc6d74032586a1d5658243ea97.
# ==============================================================================

diff -r 48fc3f91f020 -r 4d69d8456005 dom/base/ContentIterator.h
--- a/dom/base/ContentIterator.h	Thu May 08 22:53:07 2025 +0300
+++ b/dom/base/ContentIterator.h	Thu May 08 22:53:07 2025 +0300
@@ -87,15 +87,13 @@
   static nsINode* GetDeepFirstChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepFirstChild(
-      nsIContent* aRoot,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepFirstChild(nsIContent* aRoot,
+                                       bool aAllowCrossShadowBoundary);
   static nsINode* GetDeepLastChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepLastChild(
-      nsIContent* aRoot,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepLastChild(nsIContent* aRoot,
+                                      bool aAllowCrossShadowBoundary);
 
   // Get the next/previous sibling of aNode, or its parent's, or grandparent's,
   // etc.  Returns null if aNode and all its ancestors have no next/previous
@@ -103,14 +101,10 @@
   //
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow host
   // when it reaches to a shadow root.
-  static nsIContent* GetNextSibling(
-      nsINode* aNode,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
-          dom::AllowRangeCrossShadowBoundary::No,
-  static nsIContent* GetPrevSibling(
-      nsINode* aNode,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
-          dom::AllowRangeCrossShadowBoundary::No);
+  static nsIContent* GetNextSibling(nsINode* aNode,
+                                    bool aAllowCrossShadowBoundary = false);
+  static nsIContent* GetPrevSibling(nsINode* aNode,
+                                    bool aAllowCrossShadowBoundary = false);
 
   nsINode* NextNode(nsINode* aNode);
   nsINode* PrevNode(nsINode* aNode);