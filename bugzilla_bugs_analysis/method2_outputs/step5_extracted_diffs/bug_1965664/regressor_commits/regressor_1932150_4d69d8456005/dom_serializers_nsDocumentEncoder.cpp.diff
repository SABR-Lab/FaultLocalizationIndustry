# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serializers/nsDocumentEncoder.cpp
# Commit: 4d69d8456005
# Full Hash: 4d69d8456005efeb2ad4581ff00120e63c0bbdbc
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 2
# Description:
#   Revert "Bug 1932150 - Fix some inconsistency about indicating whether the selection is allowed to cross the shadow boundary r=jjaschke,dom-core"
#   
#   This reverts commit f0836d70a70a1dbc6d74032586a1d5658243ea97.
# ==============================================================================

diff -r 48fc3f91f020 -r 4d69d8456005 dom/serializers/nsDocumentEncoder.cpp
--- a/dom/serializers/nsDocumentEncoder.cpp	Thu May 08 22:53:07 2025 +0300
+++ b/dom/serializers/nsDocumentEncoder.cpp	Thu May 08 22:53:07 2025 +0300
@@ -47,7 +47,6 @@
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/AbstractRange.h"
 #include "mozilla/dom/Text.h"
-#include "mozilla/dom/AbstractRange.h"
 #include "mozilla/Encoding.h"
 #include "mozilla/IntegerRange.h"
 #include "mozilla/Maybe.h"
@@ -246,8 +245,7 @@
   virtual ~nsDocumentEncoder();
 
   void Initialize(bool aClearCachedSerializer = true,
-                  AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
-                      AllowRangeCrossShadowBoundary::No);
+                  bool aAllowCrossShadowBoundary = false);
 
   /**
    * @param aMaxLength As described at
@@ -433,7 +431,7 @@
           mNodeSerializer{aNodeSerializer},
           mRangeContextSerializer{aRangeContextSerializer} {}
 
-    void Initialize(AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    void Initialize(bool aAllowCrossShadowBoundary);
 
     /**
      * @param aDepth the distance (number of `GetParent` calls) from aNode to
@@ -500,15 +498,14 @@
     const NodeSerializer& mNodeSerializer;
     RangeContextSerializer& mRangeContextSerializer;
 
-    AllowRangeCrossShadowBoundary mAllowCrossShadowBoundary =
-        AllowRangeCrossShadowBoundary::No;
+    bool mAllowCrossShadowBoundary = false;
   };
 
   RangeSerializer mRangeSerializer;
 };
 
 void nsDocumentEncoder::RangeSerializer::Initialize(
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
+    bool aAllowCrossShadowBoundary) {
   mContextInfoDepth = {};
   mStartRootIndex = 0;
   mEndRootIndex = 0;
@@ -551,9 +548,8 @@
 nsDocumentEncoder::nsDocumentEncoder()
     : nsDocumentEncoder(MakeUnique<RangeNodeContext>()) {}
 
-void nsDocumentEncoder::Initialize(
-    bool aClearCachedSerializer,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
+void nsDocumentEncoder::Initialize(bool aClearCachedSerializer,
+                                   bool aAllowCrossShadowBoundary) {
   mFlags = 0;
   mWrapColumn = 72;
   mRangeSerializer.Initialize(aAllowCrossShadowBoundary);
@@ -574,13 +570,6 @@
   return parent->IsHTMLElement(nsGkAtoms::tr);
 }
 
-static AllowRangeCrossShadowBoundary GetAllowRangeCrossShadowBoundary(
-    const uint32_t aFlags) {
-  return (aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary)
-             ? AllowRangeCrossShadowBoundary::Yes
-             : AllowRangeCrossShadowBoundary::No;
-}
-
 nsresult nsDocumentEncoder::SerializeDependingOnScope(uint32_t aMaxLength) {
   nsresult rv = NS_OK;
   if (mEncodingScope.mSelection) {
@@ -619,7 +608,7 @@
     // by the immediate context. This assumes that you can't select cells that
     // are multiple selections from two tables simultaneously.
     node = ShadowDOMSelectionHelpers::GetStartContainer(
-        range, GetAllowRangeCrossShadowBoundary(mFlags));
+        range, mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
     NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     if (node != prevNode) {
       if (prevNode) {
@@ -736,7 +725,7 @@
   if (!aDocument) return NS_ERROR_INVALID_ARG;
 
   Initialize(!mMimeType.Equals(aMimeType),
-             GetAllowRangeCrossShadowBoundary(aFlags));
+             aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
 
   mDocument = aDocument;
 
@@ -970,7 +959,7 @@
   }
 
   ShadowRoot* shadowRoot = ShadowDOMSelectionHelpers::GetShadowRoot(
-      aNode, GetAllowRangeCrossShadowBoundary(mFlags));
+      aNode, mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
 
   if (shadowRoot) {
     MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
@@ -1325,10 +1314,8 @@
 
 nsresult nsDocumentEncoder::RangeSerializer::SerializeRangeToString(
     const nsRange* aRange) {
-  if (!aRange ||
-      (aRange->Collapsed() &&
-       (mAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::No ||
-        !aRange->MayCrossShadowBoundary()))) {
+  if (!aRange || (aRange->Collapsed() && (!mAllowCrossShadowBoundary ||
+                                          !aRange->MayCrossShadowBoundary()))) {
     return NS_OK;
   }
 
@@ -1338,7 +1325,9 @@
   // boundary can return the host element as the container.
   // SerializeRangeContextStart doesn't support this case.
   mClosestCommonInclusiveAncestorOfRange =
-      aRange->GetClosestCommonInclusiveAncestor(mAllowCrossShadowBoundary);
+      aRange->GetClosestCommonInclusiveAncestor(
+          mAllowCrossShadowBoundary ? AllowRangeCrossShadowBoundary::Yes
+                                    : AllowRangeCrossShadowBoundary::No);
 
   if (!mClosestCommonInclusiveAncestorOfRange) {
     return NS_OK;
@@ -1373,7 +1362,7 @@
 
   nsContentUtils::GetInclusiveAncestors(mClosestCommonInclusiveAncestorOfRange,
                                         mCommonInclusiveAncestors);
-  if (mAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
+  if (mAllowCrossShadowBoundary) {
     nsContentUtils::GetShadowIncludingAncestorsAndOffsets(
         startContainer, startOffset, inclusiveAncestorsOfStart,
         inclusiveAncestorsOffsetsOfStart);
@@ -1622,7 +1611,7 @@
   if (!aDocument) return NS_ERROR_INVALID_ARG;
 
   mIsTextWidget = false;
-  Initialize(true, GetAllowRangeCrossShadowBoundary(aFlags));
+  Initialize(true, aFlags & nsIDocumentEncoder::AllowCrossShadowBoundary);
 
   mIsCopying = true;
   mDocument = aDocument;
@@ -1867,13 +1856,19 @@
 
   // set the range to the new values
   ErrorResult err;
+  const bool allowRangeCrossShadowBoundary =
+      mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary;
   inRange->SetStart(*opStartNode, static_cast<uint32_t>(opStartOffset), err,
-                    GetAllowRangeCrossShadowBoundary(mFlags));
+                    allowRangeCrossShadowBoundary
+                        ? AllowRangeCrossShadowBoundary::Yes
+                        : AllowRangeCrossShadowBoundary::No);
   if (NS_WARN_IF(err.Failed())) {
     return err.StealNSResult();
   }
   inRange->SetEnd(*opEndNode, static_cast<uint32_t>(opEndOffset), err,
-                  GetAllowRangeCrossShadowBoundary(mFlags));
+                  allowRangeCrossShadowBoundary
+                      ? AllowRangeCrossShadowBoundary::Yes
+                      : AllowRangeCrossShadowBoundary::No);
   if (NS_WARN_IF(err.Failed())) {
     return err.StealNSResult();
   }
@@ -2062,7 +2057,8 @@
         const bool isGeneratedContent =
             offset == -1 &&
             ShadowDOMSelectionHelpers::GetShadowRoot(
-                parent, GetAllowRangeCrossShadowBoundary(mFlags)) != node;
+                parent,
+                mFlags & nsIDocumentEncoder::AllowCrossShadowBoundary) != node;
         if (isGeneratedContent)  // we hit generated content; STOP
         {
           // back up a bit
