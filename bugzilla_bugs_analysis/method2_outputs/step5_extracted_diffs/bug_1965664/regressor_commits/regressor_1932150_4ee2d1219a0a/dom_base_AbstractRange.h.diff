# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/AbstractRange.h
# Commit: 4ee2d1219a0a
# Full Hash: 4ee2d1219a0a852d740e43e8421c0cc3e1cd9c4e
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-10 09:29:34
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Update ranges to correctly set and update nodes for flattened selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231589
# ==============================================================================

diff -r 29195ee87cf4 -r 4ee2d1219a0a dom/base/AbstractRange.h
--- a/dom/base/AbstractRange.h	Fri May 09 17:16:36 2025 +0000
+++ b/dom/base/AbstractRange.h	Fri May 09 17:16:37 2025 +0000
@@ -30,6 +30,7 @@
 class Document;
 class Selection;
 class StaticRange;
+class HTMLSlotElement;
 
 enum class AllowRangeCrossShadowBoundary : bool { No, Yes };
 
@@ -193,7 +194,9 @@
             typename RangeType>
   static nsresult SetStartAndEndInternal(
       const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
-      const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange);
+      const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange,
+      AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
+          AllowRangeCrossShadowBoundary::No);
 
   template <class RangeType>
   static bool MaybeCacheToReuse(RangeType& aInstance);
@@ -227,8 +230,15 @@
 
   void UpdateCommonAncestorIfNecessary();
 
-  static void MarkDescendants(const nsINode& aNode);
-  static void UnmarkDescendants(const nsINode& aNode);
+  static void MarkDescendants(nsINode& aNode);
+  static void UnmarkDescendants(nsINode& aNode);
+
+  static void UpdateDescendantsInFlattenedTree(nsINode& aNode,
+                                               bool aMarkDescendants);
+  friend void mozilla::SlotAssignedNodeAdded(dom::HTMLSlotElement* aSlot,
+                                             nsIContent& aAssignedNode);
+  friend void mozilla::SlotAssignedNodeRemoved(dom::HTMLSlotElement* aSlot,
+                                               nsIContent& aUnassignedNode);
 
  private:
   void ClearForReuse();