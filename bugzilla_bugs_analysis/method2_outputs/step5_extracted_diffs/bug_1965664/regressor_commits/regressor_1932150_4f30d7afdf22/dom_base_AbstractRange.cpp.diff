# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/AbstractRange.cpp
# Commit: 4f30d7afdf22
# Full Hash: 4f30d7afdf22c652481513564b60b37053c0948b
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 2
# Description:
#   Revert "Bug 1932150 - Fix build bustage" for causing build bustages.
#   
#   This reverts commit 0681b181d6a8a48ac460a97dacb7fca91f9989c3.
#   
#   Revert "Bug 1932150 - Fix lint failure" for causing Build bustage.
# ==============================================================================

diff -r 1e64a48e3517 -r 4f30d7afdf22 dom/base/AbstractRange.cpp
--- a/dom/base/AbstractRange.cpp	Wed May 07 20:11:46 2025 +0300
+++ b/dom/base/AbstractRange.cpp	Wed May 07 20:37:37 2025 +0300
@@ -13,10 +13,8 @@
 #include "mozilla/RangeUtils.h"
 #include "mozilla/dom/ChildIterator.h"
 #include "mozilla/dom/Document.h"
-#include "mozilla/dom/DocumentInlines.h"
 #include "mozilla/dom/StaticRange.h"
 #include "mozilla/dom/Selection.h"
-#include "mozilla/dom/TreeIterator.h"
 #include "mozilla/dom/CrossShadowBoundaryRange.h"
 #include "nsContentUtils.h"
 #include "nsCycleCollectionParticipant.h"
@@ -29,33 +27,28 @@
 
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    nsRange* aRange, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, nsRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aEndBoundary, nsRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    StaticRange* aRange);
 template nsresult AbstractRange::SetStartAndEndInternal(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, StaticRange* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aEndBoundary, StaticRange* aRange);
 template bool AbstractRange::MaybeCacheToReuse(nsRange& aInstance);
 template bool AbstractRange::MaybeCacheToReuse(StaticRange& aInstance);
 template bool AbstractRange::MaybeCacheToReuse(
@@ -98,70 +91,32 @@
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRegisteredClosestCommonInclusiveAncestor)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
-static void UpdateDescendantsInSameTree(const nsINode& aNode,
-                                        bool aMarkDesendants) {
-  MOZ_ASSERT(!StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-  // don't set the Descendant bit on |aNode| itself
-  nsINode* node = aNode.GetNextNode(&aNode);
-  while (node) {
+// When aMarkDesendants is true, Set
+// DescendantOfClosestCommonInclusiveAncestorForRangeInSelection flag for the
+// shadow including children of aNode. When aMarkDesendants is false, unset that
+// flag for the shadow including children of aNode.
+void UpdateDescendantsByShadowIncludingOrder(const nsIContent& aNode,
+                                             bool aMarkDesendants) {
+  ShadowIncludingTreeIterator iter(*const_cast<nsIContent*>(&aNode));
+  ++iter;  // We don't want to mark the root node
+
+  while (iter) {
+    nsINode* node = *iter;
     if (aMarkDesendants) {
       node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
     } else {
       node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
     }
 
-    if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
-      node = node->GetNextNode(&aNode);
-    } else {
-      // We found an ancestor of an overlapping range, skip its descendants.
-      node = node->GetNextNonChildNode(&aNode);
+    if (node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+      iter.SkipChildren();
+      continue;
     }
+    ++iter;
   }
 }
 
-void AbstractRange::UpdateDescendantsInFlattenedTree(nsINode& aNode,
-                                                     bool aMarkDescendants) {
-  MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-
-  auto UpdateDescendant = [aMarkDescendants](nsINode* node) {
-    if (aMarkDescendants) {
-      node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
-    } else {
-      node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
-    }
-  };
-
-  nsINode* target = &aNode;
-
-  if (target->IsDocument()) {
-    if (auto* rootElement = aNode.AsDocument()->GetRootElement()) {
-      target = rootElement;
-      UpdateDescendant(target);
-    }
-  }
-
-  if (!target || !target->IsContent()) {
-    return;
-  }
-
-  TreeIterator<FlattenedChildIterator> iter(*target->AsContent());
-  iter.GetNext();  // Skip aNode itself.
-  while (nsIContent* curNode = iter.GetCurrent()) {
-    if (curNode->IsInNativeAnonymousSubtree()) {
-      iter.GetNextSkippingChildren();
-      continue;
-    }
-
-    UpdateDescendant(curNode);
-    if (curNode->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
-      iter.GetNextSkippingChildren();
-    } else {
-      iter.GetNext();
-    }
-  }
-}
-
-void AbstractRange::MarkDescendants(nsINode& aNode) {
+void AbstractRange::MarkDescendants(const nsINode& aNode) {
   // Set NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection on
   // aNode's descendants unless aNode is already marked as a range common
   // ancestor or a descendant of one, in which case all of our descendants have
@@ -169,26 +124,59 @@
   if (!aNode.IsMaybeSelected()) {
     // If aNode has a web-exposed shadow root, use this shadow tree and ignore
     // the children of aNode.
-
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      UpdateDescendantsInFlattenedTree(aNode, true /* aMarkDescendants */);
-    } else {
-      UpdateDescendantsInSameTree(aNode, true /* aMarkDescendants */);
+    if (aNode.GetShadowRootForSelection()) {
+      UpdateDescendantsByShadowIncludingOrder(*aNode.AsContent(), true);
+      return;
+    }
+    // don't set the Descendant bit on |aNode| itself
+    nsINode* node = aNode.GetNextNode(&aNode);
+    while (node) {
+      node->SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
+      if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+        if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+          UpdateDescendantsByShadowIncludingOrder(*node->AsContent(), true);
+          // sub-tree of node has been marked already
+          node = node->GetNextNonChildNode(&aNode);
+        } else {
+          node = node->GetNextNode(&aNode);
+        }
+      } else {
+        // optimize: skip this sub-tree since it's marked already.
+        node = node->GetNextNonChildNode(&aNode);
+      }
     }
   }
 }
 
-void AbstractRange::UnmarkDescendants(nsINode& aNode) {
+void AbstractRange::UnmarkDescendants(const nsINode& aNode) {
   // Unset NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
   // on aNode's descendants unless aNode is a descendant of another range common
   // ancestor. Also, exclude descendants of range common ancestors (but not the
   // common ancestor itself).
   if (!aNode
            .IsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection()) {
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      UpdateDescendantsInFlattenedTree(aNode, false /* aMarkDescendants */);
-    } else {
-      UpdateDescendantsInSameTree(aNode, false /* aMarkDescendants */);
+    // If aNode has a web-exposed shadow root, use this shadow tree and ignore
+    // the children of aNode.
+    if (aNode.GetShadowRootForSelection()) {
+      UpdateDescendantsByShadowIncludingOrder(*aNode.AsContent(), false);
+      return;
+    }
+    // we know |aNode| doesn't have any bit set
+    nsINode* node = aNode.GetNextNode(&aNode);
+    while (node) {
+      node->ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection();
+      if (!node->IsClosestCommonInclusiveAncestorForRangeInSelection()) {
+        if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+          UpdateDescendantsByShadowIncludingOrder(*node->AsContent(), false);
+          // sub-tree has been marked already
+          node = node->GetNextNonChildNode(&aNode);
+        } else {
+          node = node->GetNextNode(&aNode);
+        }
+      } else {
+        // We found an ancestor of an overlapping range, skip its descendants.
+        node = node->GetNextNonChildNode(&aNode);
+      }
     }
   }
 }
@@ -261,10 +249,14 @@
   if (!mIsPositioned) {
     return nullptr;
   }
-  nsINode* startContainer = ShadowDOMSelectionHelpers::GetStartContainer(
-      this, aAllowCrossShadowBoundary);
-  nsINode* endContainer = ShadowDOMSelectionHelpers::GetEndContainer(
-      this, aAllowCrossShadowBoundary);
+  nsINode* startContainer =
+      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes
+          ? GetMayCrossShadowBoundaryStartContainer()
+          : GetStartContainer();
+  nsINode* endContainer =
+      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes
+          ? GetMayCrossShadowBoundaryEndContainer()
+          : GetEndContainer();
 
   if (MayCrossShadowBoundary() &&
       aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
@@ -315,8 +307,7 @@
           typename RangeType>
 nsresult AbstractRange::SetStartAndEndInternal(
     const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
-    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
+    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, RangeType* aRange) {
   if (NS_WARN_IF(!aStartBoundary.IsSet()) ||
       NS_WARN_IF(!aEndBoundary.IsSet())) {
     return NS_ERROR_INVALID_ARG;
@@ -384,11 +375,7 @@
   }
 
   const Maybe<int32_t> pointOrder =
-      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes &&
-              StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()
-          ? nsContentUtils::ComparePoints<TreeKind::Flat>(aStartBoundary,
-                                                          aEndBoundary)
-          : nsContentUtils::ComparePoints(aStartBoundary, aEndBoundary);
+      nsContentUtils::ComparePoints(aStartBoundary, aEndBoundary);
   if (!pointOrder) {
     // Safely return a value but also detected this in debug builds.
     MOZ_ASSERT_UNREACHABLE();