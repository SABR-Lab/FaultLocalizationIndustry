# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/RangeUtils.cpp
# Commit: 5661dec1e128
# Full Hash: 5661dec1e128f48fc62be6ebc2774fc247b71fc3
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231588
# ==============================================================================

diff -r 15ccf86bce5a -r 5661dec1e128 dom/base/RangeUtils.cpp
--- a/dom/base/RangeUtils.cpp	Wed May 07 15:05:08 2025 +0000
+++ b/dom/base/RangeUtils.cpp	Wed May 07 15:05:09 2025 +0000
@@ -26,26 +26,59 @@
 template bool RangeUtils::IsValidPoints(const RawRangeBoundary& aStartBoundary,
                                         const RawRangeBoundary& aEndBoundary);
 
-template nsresult RangeUtils::CompareNodeToRangeBoundaries(
+template nsresult
+RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
+    nsINode* aNode, const RangeBoundary& aStartBoundary,
+    const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
     nsINode* aNode, const RangeBoundary& aStartBoundary,
     const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult RangeUtils::CompareNodeToRangeBoundaries(
+template nsresult
+RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
+    nsINode* aNode, const RangeBoundary& aStartBoundary,
+    const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
     nsINode* aNode, const RangeBoundary& aStartBoundary,
     const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult RangeUtils::CompareNodeToRangeBoundaries(
+template nsresult
+RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
+    nsINode* aNode, const RawRangeBoundary& aStartBoundary,
+    const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
     nsINode* aNode, const RawRangeBoundary& aStartBoundary,
     const RangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
-template nsresult RangeUtils::CompareNodeToRangeBoundaries(
+template nsresult
+RangeUtils::CompareNodeToRangeBoundaries<TreeKind::ShadowIncludingDOM>(
+    nsINode* aNode, const RawRangeBoundary& aStartBoundary,
+    const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+template nsresult RangeUtils::CompareNodeToRangeBoundaries<TreeKind::Flat>(
     nsINode* aNode, const RawRangeBoundary& aStartBoundary,
     const RawRangeBoundary& aEndBoundary, bool* aNodeIsBeforeRange,
     bool* aNodeIsAfterRange);
 
+template nsresult RangeUtils::CompareNodeToRange<TreeKind::ShadowIncludingDOM>(
+    nsINode* aNode, AbstractRange* aAbstractRange, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+template nsresult RangeUtils::CompareNodeToRange<TreeKind::Flat>(
+    nsINode* aNode, AbstractRange* aAbstractRange, bool* aNodeIsBeforeRange,
+    bool* aNodeIsAfterRange);
+
+template Maybe<bool>
+RangeUtils::IsNodeContainedInRange<TreeKind::ShadowIncludingDOM>(
+    nsINode& aNode, AbstractRange* aAbstractRange);
+template Maybe<bool> RangeUtils::IsNodeContainedInRange<TreeKind::Flat>(
+    nsINode& aNode, AbstractRange* aAbstractRange);
+
 [[nodiscard]] static inline bool ParentNodeIsInSameSelection(
     const nsINode& aNode) {
   // Currently, independent selection root is always the anonymous <div> in a
@@ -68,17 +101,6 @@
 }
 
 // static
-nsINode* RangeUtils::GetParentNodeInSameSelection(const nsINode* aNode) {
-  if (MOZ_UNLIKELY(!aNode)) {
-    return nullptr;
-  }
-  if (!ParentNodeIsInSameSelection(*aNode)) {
-    return nullptr;
-  }
-  return aNode->GetParentNode();
-}
-
-// static
 nsINode* RangeUtils::ComputeRootNode(nsINode* aNode) {
   if (!aNode) {
     return nullptr;
@@ -150,13 +172,14 @@
 }
 
 // static
+template <TreeKind aKind, typename Dummy>
 Maybe<bool> RangeUtils::IsNodeContainedInRange(nsINode& aNode,
                                                AbstractRange* aAbstractRange) {
   bool nodeIsBeforeRange{false};
   bool nodeIsAfterRange{false};
 
-  const nsresult rv = CompareNodeToRange(&aNode, aAbstractRange,
-                                         &nodeIsBeforeRange, &nodeIsAfterRange);
+  const nsresult rv = CompareNodeToRange<aKind>(
+      &aNode, aAbstractRange, &nodeIsBeforeRange, &nodeIsAfterRange);
   if (NS_FAILED(rv)) {
     return Nothing();
   }
@@ -172,6 +195,7 @@
 // XXX - callers responsibility to ensure node in same doc as range!
 
 // static
+template <TreeKind aKind, typename Dummy>
 nsresult RangeUtils::CompareNodeToRange(nsINode* aNode,
                                         AbstractRange* aAbstractRange,
                                         bool* aNodeIsBeforeRange,
@@ -180,12 +204,13 @@
       NS_WARN_IF(!aAbstractRange->IsPositioned())) {
     return NS_ERROR_INVALID_ARG;
   }
-  return CompareNodeToRangeBoundaries(
+  return CompareNodeToRangeBoundaries<aKind>(
       aNode, aAbstractRange->MayCrossShadowBoundaryStartRef(),
       aAbstractRange->MayCrossShadowBoundaryEndRef(), aNodeIsBeforeRange,
       aNodeIsAfterRange);
 }
-template <typename SPT, typename SRT, typename EPT, typename ERT>
+template <TreeKind aKind, typename SPT, typename SRT, typename EPT,
+          typename ERT, typename Dummy>
 nsresult RangeUtils::CompareNodeToRangeBoundaries(
     nsINode* aNode, const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
     const RangeBoundaryBase<EPT, ERT>& aEndBoundary, bool* aNodeIsBeforeRange,
@@ -208,7 +233,17 @@
   // gather up the dom point info
   int32_t nodeStart;
   uint32_t nodeEnd;
-  const nsINode* parent = GetParentNodeInSameSelection(aNode);
+  const nsINode* parent = nullptr;
+
+  MOZ_ASSERT_IF(aKind == TreeKind::Flat,
+                StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
+  // ShadowRoot has no parent, nor can be represented by parent/offset pair.
+  if (!aNode->IsShadowRoot()) {
+    parent = ShadowDOMSelectionHelpers::GetParentNodeInSameSelection(
+        *aNode, aKind == TreeKind::Flat ? AllowRangeCrossShadowBoundary::Yes
+                                        : AllowRangeCrossShadowBoundary::No);
+  }
+
   if (!parent) {
     // can't make a parent/offset pair to represent start or
     // end of the root node, because it has no parent.
@@ -216,6 +251,14 @@
     parent = aNode;
     nodeStart = 0;
     nodeEnd = aNode->GetChildCount();
+  } else if (const HTMLSlotElement* slotAsParent =
+                 HTMLSlotElement::FromNode(parent);
+             slotAsParent && aKind == TreeKind::Flat) {
+    // aNode is a slotted content, use the index in the assigned nodes
+    // to represent this node.
+    auto index = slotAsParent->AssignedNodes().IndexOf(aNode);
+    nodeStart = index;
+    nodeEnd = nodeStart + 1;
   } else {
     nodeStart = parent->ComputeIndexOf_Deprecated(aNode);
     NS_WARNING_ASSERTION(
@@ -240,17 +283,19 @@
   // silence the warning. (Bug 1438996)
 
   // is RANGE(start) <= NODE(start) ?
-  Maybe<int32_t> order = nsContentUtils::ComparePoints_AllowNegativeOffsets(
-      aStartBoundary.GetContainer(),
-      *aStartBoundary.Offset(
-          RangeBoundaryBase<SPT, SRT>::OffsetFilter::kValidOrInvalidOffsets),
-      parent, nodeStart);
+  Maybe<int32_t> order =
+      nsContentUtils::ComparePoints_AllowNegativeOffsets<aKind>(
+          aStartBoundary.GetContainer(),
+          *aStartBoundary.Offset(
+              RangeBoundaryBase<SPT,
+                                SRT>::OffsetFilter::kValidOrInvalidOffsets),
+          parent, nodeStart);
   if (NS_WARN_IF(!order)) {
     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   }
   *aNodeIsBeforeRange = *order > 0;
   // is RANGE(end) >= NODE(end) ?
-  order = nsContentUtils::ComparePointsWithIndices(
+  order = nsContentUtils::ComparePointsWithIndices<aKind>(
       aEndBoundary.GetContainer(),
       *aEndBoundary.Offset(
           RangeBoundaryBase<EPT, ERT>::OffsetFilter::kValidOrInvalidOffsets),
@@ -315,10 +360,17 @@
   if (!ParentNodeIsInSameSelection(aNode)) {
     return nullptr;
   }
-  return (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled() &&
-          aAllowCrossShadowBoundary)
-             ? aNode.GetParentOrShadowHostNode()
-             : aNode.GetParentNode();
+
+  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled() &&
+      aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
+    if (aNode.IsContent()) {
+      if (HTMLSlotElement* slot = aNode.AsContent()->GetAssignedSlot()) {
+        return slot;
+      }
+    }
+    return aNode.GetParentOrShadowHostNode();
+  }
+  return aNode.GetParentNode();
 }
 
 // static