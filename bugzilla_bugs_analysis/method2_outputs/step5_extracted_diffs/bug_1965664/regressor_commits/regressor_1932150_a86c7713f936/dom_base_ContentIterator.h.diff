# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ContentIterator.h
# Commit: a86c7713f936
# Full Hash: a86c7713f936f7e692d673d596dfcf527faccb6d
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-10 09:29:34
# Regressor Bug: 1932150
# File Overlap Count: 2
# Description:
#   Bug 1932150 - Fix some inconsistency about indicating whether the selection is allowed to cross the shadow boundary r=jjaschke,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D246949
# ==============================================================================

diff -r d0d0f8f22432 -r a86c7713f936 dom/base/ContentIterator.h
--- a/dom/base/ContentIterator.h	Fri May 09 17:09:50 2025 +0000
+++ b/dom/base/ContentIterator.h	Fri May 09 17:16:36 2025 +0000
@@ -87,13 +87,15 @@
   static nsINode* GetDeepFirstChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepFirstChild(nsIContent* aRoot,
-                                       bool aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepFirstChild(
+      nsIContent* aRoot,
+      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
   static nsINode* GetDeepLastChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepLastChild(nsIContent* aRoot,
-                                      bool aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepLastChild(
+      nsIContent* aRoot,
+      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
 
   // Get the next/previous sibling of aNode, or its parent's, or grandparent's,
   // etc.  Returns null if aNode and all its ancestors have no next/previous
@@ -101,10 +103,14 @@
   //
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow host
   // when it reaches to a shadow root.
-  static nsIContent* GetNextSibling(nsINode* aNode,
-                                    bool aAllowCrossShadowBoundary = false);
-  static nsIContent* GetPrevSibling(nsINode* aNode,
-                                    bool aAllowCrossShadowBoundary = false);
+  static nsIContent* GetNextSibling(
+      nsINode* aNode,
+      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
+          dom::AllowRangeCrossShadowBoundary::No,
+  static nsIContent* GetPrevSibling(
+      nsINode* aNode,
+      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
+          dom::AllowRangeCrossShadowBoundary::No);
 
   nsINode* NextNode(nsINode* aNode);
   nsINode* PrevNode(nsINode* aNode);