# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ContentIterator.cpp
# Commit: dda3f21e993c
# Full Hash: dda3f21e993cf435acc92686243d42f1fa6f5e1c
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-10 09:29:34
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - ContentSubtreeIterator #3: Fix a bug in ContentSubtreeIterator where the end container is in the light DOM of a shadow host r=jjaschke
#   
#   When the end container is in light DOM of a shadow host, we stop the
#   iteration after we have finished iterating the shadow root of it.
#   
# ==============================================================================

diff -r 4669801f1342 -r dda3f21e993c dom/base/ContentIterator.cpp
--- a/dom/base/ContentIterator.cpp	Fri May 09 17:16:37 2025 +0000
+++ b/dom/base/ContentIterator.cpp	Fri May 09 17:16:37 2025 +0000
@@ -655,6 +655,7 @@
 template <typename NodeType>
 nsIContent* ContentIteratorBase<NodeType>::GetNextSibling(
     nsINode* aNode, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary,
+    nsTArray<AncestorInfo>* aInclusiveAncestorsOfEndContainer) {
   if (NS_WARN_IF(!aNode)) {
     return nullptr;
   }
@@ -687,19 +688,29 @@
     return nullptr;
   }
 
-  if (aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
-    // This is temporary solution.
-    // For shadow root, instead of getting to the sibling of the parent
-    // directly, we need to get into the light tree of the parent to handle
-    // slotted contents.
-    if (aNode->IsShadowRoot()) {
-      if (nsIContent* child = parent->GetFirstChild()) {
-        return child;
-      }
+  // We now have finished iterating descendants within this shadow root, and
+  // reached to the shadow host.
+  if (aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes &&
+      aInclusiveAncestorsOfEndContainer && parent->GetShadowRoot() == aNode) {
+    const int32_t i = aInclusiveAncestorsOfEndContainer->IndexOf(
+        parent, 0, InclusiveAncestorComparator());
+
+    // If parent is an ancestor of the end container, we return the parent so
+    // that the caller (ContentSubtreeIterator::Next) can stop the iteration.
+    //
+    // This is only a special case for ShadowDOM selection where
+    // the end container is in light DOM and we have to iterate
+    // shadow DOM nodes first. We would have reached to mLast
+    // already if this isn't the case.
+    if (i != -1) {
+      MOZ_ASSERT(!aInclusiveAncestorsOfEndContainer->ElementAt(i)
+                      .mIsDescendantInShadowTree);
+      return parent->AsContent();
     }
   }
 
-  return ContentIteratorBase::GetNextSibling(parent, aAllowCrossShadowBoundary);
+  return ContentIteratorBase::GetNextSibling(parent, aAllowCrossShadowBoundary,
+                                             aInclusiveAncestorsOfEndContainer);
 }
 
 // Get the prev sibling, or parent's prev sibling, or shadow host's prev sibling
@@ -1228,8 +1239,8 @@
     return;
   }
 
-  nsINode* nextNode =
-      ContentIteratorBase::GetNextSibling(mCurNode, mAllowCrossShadowBoundary);
+  nsINode* nextNode = ContentIteratorBase::GetNextSibling(
+      mCurNode, mAllowCrossShadowBoundary, &mInclusiveAncestorsOfEndContainer);
 
   NS_ASSERTION(nextNode, "No next sibling!?! This could mean deadlock!");
 
@@ -1251,8 +1262,13 @@
         nextNode = slot->AssignedNodes()[0];
       }
     } else {
-      MOZ_ASSERT(
-          !mInclusiveAncestorsOfEndContainer[i].mIsDescendantInShadowTree);
+      if (root) {
+        // nextNode is a shadow host but the descendant in the light DOM
+        // of it. There's no need to iterate light DOM elements for a
+        // shadow tree. Stop here.
+        mCurNode = nullptr;
+        return;
+      }
       nextNode = nextNode->GetFirstChild();
     }
     NS_ASSERTION(nextNode, "Iterator error, expected a child node!");