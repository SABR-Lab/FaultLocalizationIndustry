# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ContentIterator.cpp
# Commit: e3d805631a7f
# Full Hash: e3d805631a7fdf571adaa756aae9cd4d5c2331ee
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - ContentSubtreeIterator #1: Make the end container related logic in ContentSubtreeIterator more robust r=jjaschke,smaug,dom-core
#   
#   This is more like a fix to the current logic. The end container could
#   be in a shadow tree of a shadow host, or in the light DOM of a shadow
#   host.
# ==============================================================================

diff -r 8a42114140af -r e3d805631a7f dom/base/ContentIterator.cpp
--- a/dom/base/ContentIterator.cpp	Wed May 07 15:05:09 2025 +0000
+++ b/dom/base/ContentIterator.cpp	Wed May 07 15:05:09 2025 +0000
@@ -952,15 +952,27 @@
       mRange, mAllowCrossShadowBoundary);
   nsIContent* endNode =
       endContainer->IsContent() ? endContainer->AsContent() : nullptr;
-  while (endNode) {
-    mInclusiveAncestorsOfEndContainer.AppendElement(endNode);
+
+  AncestorInfo info{endNode, false};
+  while (info.mAncestor) {
+    const nsINode* child = info.mAncestor;
+    mInclusiveAncestorsOfEndContainer.AppendElement(info);
     // Cross the boundary for contents in shadow tree.
     nsINode* parent = ShadowDOMSelectionHelpers::GetParentNodeInSameSelection(
-        *endNode, IterAllowCrossShadowBoundary());
+        *child, mAllowCrossShadowBoundary);
     if (!parent || !parent->IsContent()) {
       break;
     }
-    endNode = parent->AsContent();
+
+    const bool isDescendantInShadowTree =
+        IterAllowCrossShadowBoundary() && child->IsShadowRoot();
+
+    info.mAncestor = parent->AsContent();
+    // mIsDescendantInShadowTree indicates that whether child is in the
+    // shadow tree of parent or in the regular light DOM tree of parent.
+    // So that later, when info.mAncestor is reached, we can decide whether
+    // we should dive into the shadow tree.
+    info.mIsDescendantInShadowTree = isDescendantInShadowTree;
   }
 }
 
@@ -1164,20 +1176,20 @@
 
   NS_ASSERTION(nextNode, "No next sibling!?! This could mean deadlock!");
 
-  int32_t i = mInclusiveAncestorsOfEndContainer.IndexOf(nextNode);
+  int32_t i = mInclusiveAncestorsOfEndContainer.IndexOf(
+      nextNode, 0, InclusiveAncestorComparator());
+
   while (i != -1) {
     // as long as we are finding ancestors of the endpoint of the range,
     // dive down into their children
     ShadowRoot* root = ShadowDOMSelectionHelpers::GetShadowRoot(
-        nextNode, IterAllowCrossShadowBoundary());
-    if (!root) {
-      nextNode = nextNode->GetFirstChild();
+        nextNode, mAllowCrossShadowBoundary);
+    if (mInclusiveAncestorsOfEndContainer[i].mIsDescendantInShadowTree) {
+      nextNode = root->GetFirstChild();
     } else {
-      // If IterAllowCrossShadowBoundary() returns true, it means we should
-      // use shadow-including order for this iterator, that means the shadow
-      // root should always be iterated.
-      nextNode = IterAllowCrossShadowBoundary() ? root->GetFirstChild()
-                                                : nextNode->GetFirstChild();
+      MOZ_ASSERT(
+          !mInclusiveAncestorsOfEndContainer[i].mIsDescendantInShadowTree);
+      nextNode = nextNode->GetFirstChild();
     }
     NS_ASSERTION(nextNode, "Iterator error, expected a child node!");
 
@@ -1185,7 +1197,8 @@
     // down the child chain to the bottom without finding an interior node,
     // then the previous node should have been the last, which was
     // was tested at top of routine.
-    i = mInclusiveAncestorsOfEndContainer.IndexOf(nextNode);
+    i = mInclusiveAncestorsOfEndContainer.IndexOf(
+        nextNode, 0, InclusiveAncestorComparator());
   }
 
   mCurNode = nextNode;