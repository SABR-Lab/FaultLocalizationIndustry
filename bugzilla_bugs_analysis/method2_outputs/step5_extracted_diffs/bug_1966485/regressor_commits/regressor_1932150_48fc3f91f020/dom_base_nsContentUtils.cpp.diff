# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsContentUtils.cpp
# Commit: 48fc3f91f020
# Full Hash: 48fc3f91f0207ca38b1b6ab88f33c7c7c999d152
# Author: Serban Stanca <sstanca@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core"
#   
#   This reverts commit 8d55fdef16bcd3e93e2aab7e4aead025c2d07ae4.
# ==============================================================================

diff -r 260574c2a78e -r 48fc3f91f020 dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp	Thu May 08 22:53:06 2025 +0300
+++ b/dom/base/nsContentUtils.cpp	Thu May 08 22:53:07 2025 +0300
@@ -487,61 +487,31 @@
 int32_t nsContentUtils::sInnerOrOuterWindowCount = 0;
 uint32_t nsContentUtils::sInnerOrOuterWindowSerialCounter = 0;
 
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const RangeBoundary& aFirstBoundary, const RangeBoundary& aSecondBoundary,
     NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
-    const RangeBoundary& aFirstBoundary, const RangeBoundary& aSecondBoundary,
-    NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const RangeBoundary& aFirstBoundary,
     const RawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
-    const RangeBoundary& aFirstBoundary,
-    const RawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const RawRangeBoundary& aFirstBoundary,
     const RangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
-    const RawRangeBoundary& aFirstBoundary,
-    const RangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const RawRangeBoundary& aFirstBoundary,
     const RawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
-    const RawRangeBoundary& aFirstBoundary,
-    const RawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-    const RangeBoundary& aFirstBoundary,
-    const ConstRawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const RangeBoundary& aFirstBoundary,
     const ConstRawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const ConstRawRangeBoundary& aFirstBoundary,
     const RangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
+    const RawRangeBoundary& aFirstBoundary,
+    const ConstRawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const ConstRawRangeBoundary& aFirstBoundary,
     const RawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-
-template Maybe<int32_t>
-nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-    const ConstRawRangeBoundary& aFirstBoundary,
-    const ConstRawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
-template Maybe<int32_t> nsContentUtils::ComparePoints<TreeKind::Flat>(
+template Maybe<int32_t> nsContentUtils::ComparePoints(
     const ConstRawRangeBoundary& aFirstBoundary,
     const ConstRawRangeBoundary& aSecondBoundary, NodeIndexCache* aIndexCache);
 
@@ -787,10 +757,9 @@
   return aContent->GetFlattenedTreeParent();
 }
 
-static nsIContent* GetFlattenedTreeParentNodeForSelection(
-    const nsIContent* aNode) {
-  nsINode* parent = aNode->GetFlattenedTreeParentNodeForSelection();
-  return parent && parent->IsContent() ? parent->AsContent() : nullptr;
+static auto* GetFlattenedTreeParentNodeForSelection(
+    const nsIContent* aContent) {
+  return aContent->GetFlattenedTreeParentNodeForSelection();
 }
 
 static auto* GetFlattenedTreeParentElementForStyle(const Element* aElement) {
@@ -803,17 +772,6 @@
              : nullptr;
 }
 
-static bool AreNodesInSameSlot(const nsINode* aNode1, const nsINode* aNode2) {
-  if (auto* content1 = nsIContent::FromNodeOrNull(aNode1)) {
-    if (auto* slot = content1->GetAssignedSlot()) {
-      if (auto* content2 = nsIContent::FromNodeOrNull(aNode2)) {
-        return slot == content2->GetAssignedSlot();
-      }
-    }
-  }
-  return false;
-}
-
 template <typename Node1, typename Node2, typename GetParentFunc>
 class MOZ_STACK_CLASS CommonAncestors final {
  public:
@@ -868,12 +826,9 @@
     return GetClosestCommonAncestorChild(mInclusiveAncestors2);
   }
 
-  template <TreeKind aKind>
   void WarnIfClosestCommonAncestorChildrenAreNotInChildList() const {
-    WarnIfClosestCommonAncestorChildIsNotInChildList<aKind>(
-        mInclusiveAncestors1);
-    WarnIfClosestCommonAncestorChildIsNotInChildList<aKind>(
-        mInclusiveAncestors2);
+    WarnIfClosestCommonAncestorChildIsNotInChildList(mInclusiveAncestors1);
+    WarnIfClosestCommonAncestorChildIsNotInChildList(mInclusiveAncestors2);
   }
 
  private:
@@ -915,9 +870,7 @@
     return child;
   }
 
-  template <TreeKind aKind, typename Node,
-            typename = std::enable_if_t<aKind == TreeKind::ShadowIncludingDOM ||
-                                        aKind == TreeKind::Flat>>
+  template <typename Node>
   void WarnIfClosestCommonAncestorChildIsNotInChildList(
       const nsTArray<Node*>& aInclusiveAncestors) const {
 #ifdef DEBUG
@@ -926,24 +879,8 @@
       if (!child) {
         return;
       }
-
-      if (mClosestCommonAncestor->GetShadowRoot() == child) {
-        return;
-      }
-
-      Maybe<uint32_t> childIndex;
-      if constexpr (aKind == TreeKind::Flat) {
-        if (auto* slot = HTMLSlotElement::FromNode(mClosestCommonAncestor)) {
-          auto index = slot->AssignedNodes().IndexOf(child);
-          if (index != nsTArray<RefPtr<nsINode>>::NoIndex) {
-            childIndex = Some(index);
-          }
-        }
-      }
-
-      if (childIndex.isNothing()) {
-        childIndex = mClosestCommonAncestor->ComputeIndexOf(child);
-      }
+      const Maybe<uint32_t> childIndex =
+          mClosestCommonAncestor->ComputeIndexOf(child);
       if (MOZ_LIKELY(childIndex.isSome())) {
         return;
       }
@@ -3227,7 +3164,6 @@
 }
 
 /* static */
-template <TreeKind aKind, typename Dummy>
 Maybe<int32_t> nsContentUtils::CompareChildNodes(
     const nsINode* aChild1, const nsINode* aChild2,
     NodeIndexCache* aIndexCache /* = nullptr */) {
@@ -3250,23 +3186,6 @@
     MOZ_ASSERT(aChild1->GetParentOrShadowHostNode());
     return Some(-1);
   }
-
-  if constexpr (aKind == TreeKind::Flat) {
-    if (AreNodesInSameSlot(aChild1, aChild2)) {
-      // They differ at slot, so use their position in slot
-      const auto* slot = aChild1->AsContent()->GetAssignedSlot();
-      MOZ_ASSERT(slot);
-
-      auto child1Index = slot->AssignedNodes().IndexOf(aChild1);
-      auto child2Index = slot->AssignedNodes().IndexOf(aChild2);
-
-      MOZ_ASSERT(child1Index != nsTArray<RefPtr<nsINode>>::NoIndex);
-      MOZ_ASSERT(child2Index != nsTArray<RefPtr<nsINode>>::NoIndex);
-
-      return Some(child1Index < child2Index ? -1 : 1);
-    }
-  }
-
   MOZ_ASSERT(aChild1->GetParentOrShadowHostNode());
   const nsINode& commonParentNode = *aChild1->GetParentOrShadowHostNode();
   MOZ_ASSERT(aChild2->GetParentOrShadowHostNode() == &commonParentNode);
@@ -3335,10 +3254,9 @@
 }
 
 /* static */
-template <TreeKind aKind, typename Dummy>
 Maybe<int32_t> nsContentUtils::CompareClosestCommonAncestorChildren(
     const nsINode& aParent, const nsINode* aChild1, const nsINode* aChild2,
-    nsContentUtils::NodeIndexCache* aIndexCache) {
+    nsContentUtils::NodeIndexCache* aIndexCache = nullptr) {
   MOZ_ASSERT_IF(aChild1, GetParentOrShadowHostNode(aChild1));
   MOZ_ASSERT_IF(aChild2, GetParentOrShadowHostNode(aChild2));
 
@@ -3363,7 +3281,7 @@
     return Some(1);
   }
   const Maybe<int32_t> comp =
-      nsContentUtils::CompareChildNodes<aKind>(aChild1, aChild2, aIndexCache);
+      nsContentUtils::CompareChildNodes(aChild1, aChild2, aIndexCache);
   if (MOZ_UNLIKELY(comp.isNothing())) {
     NS_ASSERTION(comp.isSome(),
                  "nsContentUtils::CompareChildNodes() must return Some here. "
@@ -3373,16 +3291,14 @@
     return Some(1);
   }
   MOZ_ASSERT_IF(!*comp, aChild1 == aChild2);
-  MOZ_ASSERT_IF(*comp < 0 && !AreNodesInSameSlot(aChild1, aChild2),
-                (aChild1 ? *aChild1->ComputeIndexInParentNode()
-                         : aParent.GetChildCount()) <
-                    (aChild2 ? *aChild2->ComputeIndexInParentNode()
-                             : aParent.GetChildCount()));
-  MOZ_ASSERT_IF(*comp > 0 && !AreNodesInSameSlot(aChild1, aChild2),
-                (aChild2 ? *aChild2->ComputeIndexInParentNode()
-                         : aParent.GetChildCount()) <
-                    (aChild1 ? *aChild1->ComputeIndexInParentNode()
-                             : aParent.GetChildCount()));
+  MOZ_ASSERT_IF(*comp < 0, (aChild1 ? *aChild1->ComputeIndexInParentNode()
+                                    : aParent.GetChildCount()) <
+                               (aChild2 ? *aChild2->ComputeIndexInParentNode()
+                                        : aParent.GetChildCount()));
+  MOZ_ASSERT_IF(*comp > 0, (aChild2 ? *aChild2->ComputeIndexInParentNode()
+                                    : aParent.GetChildCount()) <
+                               (aChild1 ? *aChild1->ComputeIndexInParentNode()
+                                        : aParent.GetChildCount()));
   return comp;
 }
 
@@ -3434,7 +3350,6 @@
 }
 
 /* static */
-template <TreeKind aKind, typename Dummy>
 Maybe<int32_t> nsContentUtils::ComparePointsWithIndices(
     const nsINode* aParent1, uint32_t aOffset1, const nsINode* aParent2,
     uint32_t aOffset2, NodeIndexCache* aIndexCache) {
@@ -3445,17 +3360,8 @@
     return Some(aOffset1 < aOffset2 ? -1 : (aOffset1 > aOffset2 ? 1 : 0));
   }
 
-  auto GetParentFunc = [](const nsINode* aNode) -> nsINode* {
-    MOZ_ASSERT(aNode);
-    if constexpr (aKind == TreeKind::Flat) {
-      if (aNode->IsContent() && aNode->AsContent()->GetAssignedSlot()) {
-        return aNode->GetFlattenedTreeParentNodeForSelection();
-      }
-    }
-    return aNode->GetParentOrShadowHostNode();
-  };
-
-  const CommonAncestors commonAncestors(*aParent1, *aParent2, GetParentFunc);
+  const CommonAncestors commonAncestors(*aParent1, *aParent2,
+                                        GetParentOrShadowHostNode);
 
   if (MOZ_UNLIKELY(!commonAncestors.GetClosestCommonAncestor())) {
     return Nothing();
@@ -3466,22 +3372,16 @@
   const nsINode* closestCommonAncestorChild2 =
       commonAncestors.GetClosestCommonAncestorChild2();
   MOZ_ASSERT(closestCommonAncestorChild1 != closestCommonAncestorChild2);
-  commonAncestors
-      .template WarnIfClosestCommonAncestorChildrenAreNotInChildList<aKind>();
+  commonAncestors.WarnIfClosestCommonAncestorChildrenAreNotInChildList();
   if (closestCommonAncestorChild1 && closestCommonAncestorChild2) {
-    return CompareClosestCommonAncestorChildren<aKind>(
+    return CompareClosestCommonAncestorChildren(
         *commonAncestors.GetClosestCommonAncestor(),
         closestCommonAncestorChild1, closestCommonAncestorChild2, aIndexCache);
   }
 
   if (closestCommonAncestorChild2) {
-    MOZ_ASSERT(GetParentFunc(closestCommonAncestorChild2) == aParent1);
-    if (aParent1->GetShadowRoot() == closestCommonAncestorChild2) {
-      // Comparing a shadow host with its shadow root.
-      // We consider: [host, 0] < anything in shadow root < [host, 1]
-      return aOffset1 > 0 ? Some(-1) : Some(1);
-    }
-
+    MOZ_ASSERT(closestCommonAncestorChild2->GetParentOrShadowHostNode() ==
+               aParent1);
     // FIXME: bug 1946001, bug 1946003 and bug 1946008.
     if (MOZ_UNLIKELY(
             closestCommonAncestorChild2->IsRootOfNativeAnonymousSubtree() ||
@@ -3508,14 +3408,9 @@
     return comp;
   }
 
-  if (aParent2->GetShadowRoot() == closestCommonAncestorChild1) {
-    // Comparing a shadow host with its shadow root.
-    // We consider: [host, 0] < anything in shadow root < [host, 1]
-    return aOffset2 > 0 ? Some(-1) : Some(1);
-  }
-
   MOZ_ASSERT(closestCommonAncestorChild1);
-  MOZ_ASSERT(GetParentFunc(closestCommonAncestorChild1) == aParent2);
+  MOZ_ASSERT(closestCommonAncestorChild1->GetParentOrShadowHostNode() ==
+             aParent2);
   // FIXME: bug 1946001, bug 1946003 and bug 1946008.
   if (MOZ_UNLIKELY(
           closestCommonAncestorChild1->IsRootOfNativeAnonymousSubtree() ||
@@ -3605,8 +3500,7 @@
 }
 
 /* static */
-template <TreeKind aKind, typename PT1, typename RT1, typename PT2,
-          typename RT2, typename Dummy>
+template <typename PT1, typename RT1, typename PT2, typename RT2>
 Maybe<int32_t> nsContentUtils::ComparePoints(
     const RangeBoundaryBase<PT1, RT1>& aBoundary1,
     const RangeBoundaryBase<PT2, RT2>& aBoundary2,
@@ -3623,7 +3517,7 @@
   // offset in the container.  If both instances have computed offset, we can
   // use ComparePointsWithIndices() which works with offsets.
   if (aBoundary1.HasOffset() && aBoundary2.HasOffset()) {
-    return ComparePointsWithIndices<aKind>(
+    return ComparePointsWithIndices(
         aBoundary1.GetContainer(), *aBoundary1.Offset(kValidOrInvalidOffsets1),
         aBoundary2.GetContainer(), *aBoundary2.Offset(kValidOrInvalidOffsets2),
         aIndexCache);
@@ -3641,27 +3535,18 @@
   if (aBoundary1.GetContainer() == aBoundary2.GetContainer()) {
     const nsIContent* const child1 = aBoundary1.GetChildAtOffset();
     const nsIContent* const child2 = aBoundary2.GetChildAtOffset();
-    return CompareClosestCommonAncestorChildren<aKind>(
-        *aBoundary1.GetContainer(), child1, child2, aIndexCache);
-  }
-
-  auto GetParentFunc = [](const nsINode* aNode) -> nsINode* {
-    MOZ_ASSERT(aNode);
-    if constexpr (aKind == TreeKind::Flat) {
-      if (aNode->IsContent() && aNode->AsContent()->GetAssignedSlot()) {
-        return aNode->GetFlattenedTreeParentNodeForSelection();
-      }
-    }
-    return aNode->GetParentOrShadowHostNode();
-  };
+    return CompareClosestCommonAncestorChildren(*aBoundary1.GetContainer(),
+                                                child1, child2, aIndexCache);
+  }
 
   // Otherwise, we need to compare the common ancestor children which is the
   // most distant different inclusive ancestors of the containers.  So, the
   // following implementation is similar to ComparePointsWithIndices(), but we
   // don't have offset, so, we cannot use offset when we compare the boundaries
   // whose one is a descendant of the other.
-  const CommonAncestors commonAncestors(
-      *aBoundary1.GetContainer(), *aBoundary2.GetContainer(), GetParentFunc);
+  const CommonAncestors commonAncestors(*aBoundary1.GetContainer(),
+                                        *aBoundary2.GetContainer(),
+                                        GetParentOrShadowHostNode);
 
   if (MOZ_UNLIKELY(!commonAncestors.GetClosestCommonAncestor())) {
     return Nothing();
@@ -3672,11 +3557,10 @@
       commonAncestors.GetClosestCommonAncestorChild1();
   const nsINode* closestCommonAncestorChild2 =
       commonAncestors.GetClosestCommonAncestorChild2();
-  commonAncestors
-      .template WarnIfClosestCommonAncestorChildrenAreNotInChildList<aKind>();
+  commonAncestors.WarnIfClosestCommonAncestorChildrenAreNotInChildList();
   MOZ_ASSERT(closestCommonAncestorChild1 != closestCommonAncestorChild2);
   if (closestCommonAncestorChild1 && closestCommonAncestorChild2) {
-    return CompareClosestCommonAncestorChildren<aKind>(
+    return CompareClosestCommonAncestorChildren(
         *commonAncestors.GetClosestCommonAncestor(),
         closestCommonAncestorChild1, closestCommonAncestorChild2, aIndexCache);
   }
@@ -3691,7 +3575,7 @@
       // XXX Keep the odd traditional behavior for now.
       return Some(1);
     }
-    const Maybe<int32_t> comp = nsContentUtils::CompareChildNodes<aKind>(
+    const Maybe<int32_t> comp = nsContentUtils::CompareChildNodes(
         aBoundary1.GetChildAtOffset(), closestCommonAncestorChild2,
         aIndexCache);
     if (NS_WARN_IF(comp.isNothing())) {
@@ -3729,7 +3613,7 @@
     // XXX Keep the odd traditional behavior for now.
     return Some(-1);
   }
-  const Maybe<int32_t> comp = nsContentUtils::CompareChildNodes<aKind>(
+  const Maybe<int32_t> comp = nsContentUtils::CompareChildNodes(
       closestCommonAncestorChild1, aBoundary2.GetChildAtOffset(), aIndexCache);
   if (NS_WARN_IF(comp.isNothing())) {
     NS_ASSERTION(comp.isSome(),