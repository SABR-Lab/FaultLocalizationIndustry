# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/ContentIterator.h
# Commit: 4f30d7afdf22
# Full Hash: 4f30d7afdf22c652481513564b60b37053c0948b
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Fix build bustage" for causing build bustages.
#   
#   This reverts commit 0681b181d6a8a48ac460a97dacb7fca91f9989c3.
#   
#   Revert "Bug 1932150 - Fix lint failure" for causing Build bustage.
# ==============================================================================

diff -r 1e64a48e3517 -r 4f30d7afdf22 dom/base/ContentIterator.h
--- a/dom/base/ContentIterator.h	Wed May 07 20:11:46 2025 +0300
+++ b/dom/base/ContentIterator.h	Wed May 07 20:37:37 2025 +0300
@@ -87,45 +87,24 @@
   static nsINode* GetDeepFirstChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepFirstChild(
-      nsIContent* aRoot,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepFirstChild(nsIContent* aRoot,
+                                       bool aAllowCrossShadowBoundary);
   static nsINode* GetDeepLastChild(nsINode* aRoot);
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow tree
   // when it reaches to a shadow host.
-  static nsIContent* GetDeepLastChild(
-      nsIContent* aRoot,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+  static nsIContent* GetDeepLastChild(nsIContent* aRoot,
+                                      bool aAllowCrossShadowBoundary);
 
-  struct AncestorInfo {
-    nsIContent* mAncestor = nullptr;
-    // mIsDescendantInShadowTree is used to determine if we should go
-    // dive into the shadow tree or regular light DOM tree if mAncestor
-    // is a shadow host. It should always be false otherwise.
-    bool mIsDescendantInShadowTree = false;
-  };
-
-  class InclusiveAncestorComparator {
-   public:
-    bool Equals(const AncestorInfo& aA, const nsINode* aB) const {
-      return aA.mAncestor == aB;
-    }
-  };
   // Get the next/previous sibling of aNode, or its parent's, or grandparent's,
   // etc.  Returns null if aNode and all its ancestors have no next/previous
   // sibling.
   //
   // If aAllowCrossShadowBoundary is true, it'll continue with the shadow host
   // when it reaches to a shadow root.
-  static nsIContent* GetNextSibling(
-      nsINode* aNode,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
-          dom::AllowRangeCrossShadowBoundary::No,
-      nsTArray<AncestorInfo>* aInclusiveAncestorsOfEndContainer = nullptr);
-  static nsIContent* GetPrevSibling(
-      nsINode* aNode,
-      dom::AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary =
-          dom::AllowRangeCrossShadowBoundary::No);
+  static nsIContent* GetNextSibling(nsINode* aNode,
+                                    bool aAllowCrossShadowBoundary = false);
+  static nsIContent* GetPrevSibling(nsINode* aNode,
+                                    bool aAllowCrossShadowBoundary = false);
 
   nsINode* NextNode(nsINode* aNode);
   nsINode* PrevNode(nsINode* aNode);
@@ -345,7 +324,7 @@
   RefPtr<dom::AbstractRange> mRange;
 
   // See <https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor>.
-  AutoTArray<AncestorInfo, 8> mInclusiveAncestorsOfEndContainer;
+  AutoTArray<nsIContent*, 8> mInclusiveAncestorsOfEndContainer;
 
   // Whether this iterator allows to iterate nodes across shadow boundary.
   dom::AllowRangeCrossShadowBoundary mAllowCrossShadowBoundary =