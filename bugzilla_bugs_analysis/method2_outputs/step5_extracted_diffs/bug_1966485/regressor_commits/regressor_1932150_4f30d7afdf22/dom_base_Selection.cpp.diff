# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/Selection.cpp
# Commit: 4f30d7afdf22
# Full Hash: 4f30d7afdf22c652481513564b60b37053c0948b
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Fix build bustage" for causing build bustages.
#   
#   This reverts commit 0681b181d6a8a48ac460a97dacb7fca91f9989c3.
#   
#   Revert "Bug 1932150 - Fix lint failure" for causing Build bustage.
# ==============================================================================

diff -r 1e64a48e3517 -r 4f30d7afdf22 dom/base/Selection.cpp
--- a/dom/base/Selection.cpp	Wed May 07 20:11:46 2025 +0300
+++ b/dom/base/Selection.cpp	Wed May 07 20:37:37 2025 +0300
@@ -26,7 +26,7 @@
 #include "mozilla/dom/SelectionBinding.h"
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/StaticRange.h"
-#include "mozilla/dom/TreeIterator.h"
+#include "mozilla/dom/ShadowIncludingTreeIterator.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/HTMLEditor.h"
 #include "mozilla/IntegerRange.h"
@@ -333,7 +333,7 @@
     for (size_t rangeIndex = 0; rangeIndex < sel->RangeCount(); ++rangeIndex) {
       AbstractRange* range = sel->GetAbstractRangeAt(rangeIndex);
       MOZ_ASSERT(range);
-      if (range->AreNormalRangeAndCrossShadowBoundaryRangeCollapsed()) {
+      if (range->Collapsed()) {
         continue;
       }
       if (range->IsStaticRange() && !range->AsStaticRange()->IsValid()) {
@@ -346,44 +346,19 @@
           startRef.IsStartOfContainer() ? nullptr : startRef.GetContainer();
       const nsINode* endContainer =
           endRef.IsEndOfContainer() ? nullptr : endRef.GetContainer();
-
-      auto AddNodeIfFullySelected = [&](const nsINode* aNode) {
-        if (!aNode) {
-          return;
-        }
-        // Only collect start and end container if they are fully
-        // selected (they are null in that case).
-        if (aNode == startContainer || aNode == endContainer) {
-          return;
-        }
-        fullySelectedNodes.Insert(aNode);
-      };
-
-      if (!StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-        UnsafePreContentIterator iter;
-        nsresult rv = iter.Init(range);
-        if (NS_FAILED(rv)) {
-          continue;
-        }
-        for (; !iter.IsDone(); iter.Next()) {
-          AddNodeIfFullySelected(iter.GetCurrentNode());
-        }
-      } else {
-        ContentSubtreeIterator subtreeIter;
-        nsresult rv = subtreeIter.InitWithAllowCrossShadowBoundary(range);
-        if (NS_FAILED(rv)) {
-          continue;
-        }
-
-        for (; !subtreeIter.IsDone(); subtreeIter.Next()) {
-          MOZ_DIAGNOSTIC_ASSERT(subtreeIter.GetCurrentNode());
-          if (subtreeIter.GetCurrentNode()->IsContent()) {
-            TreeIterator<FlattenedChildIterator> iter(
-                *(subtreeIter.GetCurrentNode()->AsContent()));
-            for (; iter.GetCurrent(); iter.GetNext()) {
-              AddNodeIfFullySelected(iter.GetCurrent());
-            }
+      UnsafePreContentIterator iter;
+      nsresult rv = iter.Init(range);
+      if (NS_FAILED(rv)) {
+        continue;
+      }
+      for (; !iter.IsDone(); iter.Next()) {
+        if (const nsINode* node = iter.GetCurrentNode()) {
+          // Only collect start and end container if they are fully
+          // selected (they are null in that case).
+          if (node == startContainer || node == endContainer) {
+            continue;
           }
+          fullySelectedNodes.Insert(node);
         }
       }
     }
@@ -943,8 +918,8 @@
     const AbstractRange& aRange, nsContentUtils::NodeIndexCache* aCache) {
   MOZ_ASSERT(aCompareBoundary.IsSet());
   MOZ_ASSERT(aRange.GetMayCrossShadowBoundaryStartContainer());
-  // If the nodes that we're comparing are not in the same document, assume
-  // that aCompareNode will fall at the end of the ranges.
+  // If the nodes that we're comparing are not in the same document, assume that
+  // aCompareNode will fall at the end of the ranges.
   if (aCompareBoundary.GetComposedDoc() !=
           aRange.MayCrossShadowBoundaryStartRef().GetComposedDoc() ||
       !aRange.MayCrossShadowBoundaryStartRef().IsSetAndInComposedDoc()) {
@@ -953,15 +928,9 @@
     return 1;
   }
 
-  nsINode* start = aRange.GetMayCrossShadowBoundaryStartContainer();
-  uint32_t startOffset = aRange.MayCrossShadowBoundaryStartOffset();
-  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-    return *nsContentUtils::ComparePoints<TreeKind::Flat>(
-        aCompareBoundary, ConstRawRangeBoundary{start, startOffset}, aCache);
-  }
-
-  return *nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-      aCompareBoundary, ConstRawRangeBoundary{start, startOffset}, aCache);
+  // The points are in the same subtree, hence there has to be an order.
+  return *nsContentUtils::ComparePoints(
+      aCompareBoundary, aRange.MayCrossShadowBoundaryStartRef(), aCache);
 }
 
 template <typename PT, typename RT>
@@ -987,14 +956,9 @@
     return 1;
   }
 
-  nsINode* end = aRange.GetMayCrossShadowBoundaryEndContainer();
-  uint32_t endOffset = aRange.MayCrossShadowBoundaryEndOffset();
-  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-    return *nsContentUtils::ComparePoints<TreeKind::Flat>(
-        aCompareBoundary, ConstRawRangeBoundary{end, endOffset});
-  }
-  return *nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-      aCompareBoundary, ConstRawRangeBoundary{end, endOffset});
+  // The points are in the same subtree, hence there has to be an order.
+  return *nsContentUtils::ComparePoints(aCompareBoundary,
+                                        aRange.MayCrossShadowBoundaryEndRef());
 }
 
 // static
@@ -1881,6 +1845,16 @@
   return NS_OK;
 }
 
+void Selection::SelectFramesOfShadowIncludingDescendantsOfContent(
+    nsIContent* aContent, bool aSelected) const {
+  MOZ_ASSERT(aContent);
+  MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
+  for (nsINode* node : ShadowIncludingTreeIterator(*aContent)) {
+    nsIContent* innercontent = node->IsContent() ? node->AsContent() : nullptr;
+    SelectFramesOf(innercontent, aSelected);
+  }
+}
+
 void Selection::SelectFramesInAllRanges(nsPresContext* aPresContext) {
   // this method is currently only called in a user-initiated context.
   // therefore it is safe to assume that we are not in a Highlight selection
@@ -2009,7 +1983,7 @@
     if (nsIContent* const content =
             nsIContent::FromNodeOrNull(subtreeIter.GetCurrentNode())) {
       if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-        SelectFramesOfFlattenedTreeOfContent(content, aSelect);
+        SelectFramesOfShadowIncludingDescendantsOfContent(content, aSelect);
       } else {
         SelectFramesOfInclusiveDescendantsOfContent(postOrderIter, content,
                                                     aSelect);
@@ -2032,16 +2006,6 @@
   return NS_OK;
 }
 
-void Selection::SelectFramesOfFlattenedTreeOfContent(nsIContent* aContent,
-                                                     bool aSelected) const {
-  MOZ_ASSERT(aContent);
-  MOZ_ASSERT(StaticPrefs::dom_shadowdom_selection_across_boundary_enabled());
-  TreeIterator<FlattenedChildIterator> iter(*aContent);
-  for (; iter.GetCurrent(); iter.GetNext()) {
-    SelectFramesOf(iter.GetCurrent(), aSelected);
-  }
-}
-
 // Selection::LookUpSelection
 //
 //    This function is called when a node wants to know where the selection is
@@ -3159,24 +3123,17 @@
   const uint32_t endOffset = range->MayCrossShadowBoundaryEndOffset();
 
   bool shouldClearRange = false;
-
-  auto ComparePoints = [](const nsINode* aNode1, const uint32_t aOffset1,
-                          const nsINode* aNode2, const uint32_t aOffset2) {
-    if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
-      return nsContentUtils::ComparePointsWithIndices<TreeKind::Flat>(
-          aNode1, aOffset1, aNode2, aOffset2);
-    }
-    return nsContentUtils::ComparePointsWithIndices<
-        TreeKind::ShadowIncludingDOM>(aNode1, aOffset1, aNode2, aOffset2);
-  };
   const Maybe<int32_t> anchorOldFocusOrder =
-      ComparePoints(anchorNode, anchorOffset, focusNode, focusOffset);
+      nsContentUtils::ComparePointsWithIndices(anchorNode, anchorOffset,
+                                               focusNode, focusOffset);
   shouldClearRange |= !anchorOldFocusOrder;
   const Maybe<int32_t> oldFocusNewFocusOrder =
-      ComparePoints(focusNode, focusOffset, &aContainer, aOffset);
+      nsContentUtils::ComparePointsWithIndices(focusNode, focusOffset,
+                                               &aContainer, aOffset);
   shouldClearRange |= !oldFocusNewFocusOrder;
   const Maybe<int32_t> anchorNewFocusOrder =
-      ComparePoints(anchorNode, anchorOffset, &aContainer, aOffset);
+      nsContentUtils::ComparePointsWithIndices(anchorNode, anchorOffset,
+                                               &aContainer, aOffset);
   shouldClearRange |= !anchorNewFocusOrder;
 
   // If the points are disconnected, the range will be collapsed below,
@@ -3210,10 +3167,7 @@
       }
       SetDirection(eDirNext);
       res = difRange->SetStartAndEnd(
-          focusNode, focusOffset,
-          range->GetMayCrossShadowBoundaryEndContainer(),
-          range->MayCrossShadowBoundaryEndOffset(),
-          AllowRangeCrossShadowBoundary::Yes);
+          focusNode, focusOffset, range->GetEndContainer(), range->EndOffset());
       if (NS_FAILED(res)) {
         aRv.Throw(res);
         return;
@@ -3242,9 +3196,8 @@
     } else if (*anchorNewFocusOrder <= 0 &&
                *oldFocusNewFocusOrder >= 0) {  // a,2,1 or a2,1 or a,21 or a21
       // deselect from 2 to 1
-      res =
-          difRange->SetStartAndEnd(&aContainer, aOffset, focusNode, focusOffset,
-                                   AllowRangeCrossShadowBoundary::Yes);
+      res = difRange->SetStartAndEnd(&aContainer, aOffset, focusNode,
+                                     focusOffset);
       if (NS_FAILED(res)) {
         aRv.Throw(res);
         return;
@@ -3314,14 +3267,12 @@
     } else if (*oldFocusNewFocusOrder <= 0 &&
                *anchorNewFocusOrder >= 0) {  // 1,2,a or 12,a or 1,2a or 12a
       // deselect from 1 to 2
-      res =
-          difRange->SetStartAndEnd(focusNode, focusOffset, &aContainer, aOffset,
-                                   AllowRangeCrossShadowBoundary::Yes);
+      res = difRange->SetStartAndEnd(focusNode, focusOffset, &aContainer,
+                                     aOffset);
       if (NS_FAILED(res)) {
         aRv.Throw(res);
         return;
       }
-
       SetDirection(eDirPrevious);
       range->SetStart(aContainer, aOffset, aRv,
                       AllowRangeCrossShadowBoundary::Yes);
@@ -3355,8 +3306,7 @@
       if (focusNode != anchorNode ||
           focusOffset != anchorOffset) {  // if collapsed diff dont do anything
         res = difRange->SetStartAndEnd(anchorNode, anchorOffset, focusNode,
-                                       focusOffset,
-                                       AllowRangeCrossShadowBoundary::Yes);
+                                       focusOffset);
         nsresult tmp = SetAnchorFocusToRange(range);
         if (NS_FAILED(tmp)) {
           res = tmp;
@@ -3384,9 +3334,9 @@
         return;
       }
       SetDirection(eDirPrevious);
-      res = difRange->SetStartAndEnd(
-          range->GetStartContainer(), range->StartOffset(), focusNode,
-          focusOffset, AllowRangeCrossShadowBoundary::Yes);
+      res = difRange->SetStartAndEnd(range->GetStartContainer(),
+                                     range->StartOffset(), focusNode,
+                                     focusOffset);
       if (NS_FAILED(res)) {
         aRv.Throw(res);
         return;
@@ -4281,10 +4231,7 @@
   //     new nsRange instance?
   SelectionBatcher batch(this, __FUNCTION__);
   const Maybe<int32_t> order =
-      StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()
-          ? nsContentUtils::ComparePoints<TreeKind::Flat>(aAnchorRef, aFocusRef)
-          : nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-                aAnchorRef, aFocusRef);
+      nsContentUtils::ComparePoints(aAnchorRef, aFocusRef);
   if (order && (*order <= 0)) {
     SetStartAndEndInternal(aInLimiter, aAnchorRef, aFocusRef, eDirNext, aRv);
     return;
@@ -4369,11 +4316,7 @@
     }
   }
 
-  RefPtr<nsRange> newRange = nsRange::Create(
-      aStartRef, aEndRef, aRv,
-      StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()
-          ? AllowRangeCrossShadowBoundary::Yes
-          : AllowRangeCrossShadowBoundary::No);
+  RefPtr<nsRange> newRange = nsRange::Create(aStartRef, aEndRef, aRv);
   if (aRv.Failed()) {
     return;
   }