# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsRange.cpp
# Commit: 4f30d7afdf22
# Full Hash: 4f30d7afdf22c652481513564b60b37053c0948b
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Revert "Bug 1932150 - Fix build bustage" for causing build bustages.
#   
#   This reverts commit 0681b181d6a8a48ac460a97dacb7fca91f9989c3.
#   
#   Revert "Bug 1932150 - Fix lint failure" for causing Build bustage.
# ==============================================================================

diff -r 1e64a48e3517 -r 4f30d7afdf22 dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp	Wed May 07 20:11:46 2025 +0300
+++ b/dom/base/nsRange.cpp	Wed May 07 20:37:37 2025 +0300
@@ -87,31 +87,26 @@
 
 template already_AddRefed<nsRange> nsRange::Create(
     const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    ErrorResult& aRv, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    ErrorResult& aRv);
 template already_AddRefed<nsRange> nsRange::Create(
     const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    ErrorResult& aRv, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    ErrorResult& aRv);
 template already_AddRefed<nsRange> nsRange::Create(
     const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    ErrorResult& aRv, AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    ErrorResult& aRv);
 template already_AddRefed<nsRange> nsRange::Create(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary, ErrorResult& aRv,
-    AllowRangeCrossShadowBoundary aAlloCrossShadowBoundary);
-
+    const RawRangeBoundary& aEndBoundary, ErrorResult& aRv);
+
+template nsresult nsRange::SetStartAndEnd(const RangeBoundary& aStartBoundary,
+                                          const RangeBoundary& aEndBoundary);
+template nsresult nsRange::SetStartAndEnd(const RangeBoundary& aStartBoundary,
+                                          const RawRangeBoundary& aEndBoundary);
 template nsresult nsRange::SetStartAndEnd(
-    const RangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
-template nsresult nsRange::SetStartAndEnd(
-    const RangeBoundary& aStartBoundary, const RawRangeBoundary& aEndBoundary,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
-template nsresult nsRange::SetStartAndEnd(
-    const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aStartBoundary, const RangeBoundary& aEndBoundary);
 template nsresult nsRange::SetStartAndEnd(
     const RawRangeBoundary& aStartBoundary,
-    const RawRangeBoundary& aEndBoundary,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary);
+    const RawRangeBoundary& aEndBoundary);
 
 template void nsRange::DoSetRange(const RangeBoundary& aStartBoundary,
                                   const RangeBoundary& aEndBoundary,
@@ -214,13 +209,11 @@
 template <typename SPT, typename SRT, typename EPT, typename ERT>
 already_AddRefed<nsRange> nsRange::Create(
     const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
-    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, ErrorResult& aRv,
-    AllowRangeCrossShadowBoundary aAllowCrossShadowBoundary) {
+    const RangeBoundaryBase<EPT, ERT>& aEndBoundary, ErrorResult& aRv) {
   // If we fail to initialize the range a lot, nsRange should have a static
   // initializer since the allocation cost is not cheap in hot path.
   RefPtr<nsRange> range = nsRange::Create(aStartBoundary.GetContainer());
-  aRv = range->SetStartAndEnd(aStartBoundary, aEndBoundary,
-                              aAllowCrossShadowBoundary);
+  aRv = range->SetStartAndEnd(aStartBoundary, aEndBoundary);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
@@ -292,21 +285,12 @@
   const RangeBoundary& otherSideExistingBoundary =
       aIsSetStart ? aRange->EndRef() : aRange->StartRef();
 
-  auto ComparePoints = [aAllowCrossShadowBoundary](
-                           const RawRangeBoundary& aBoundary1,
-                           const RawRangeBoundary& aBoundary2) {
-    if (aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
-      return nsContentUtils::ComparePoints<TreeKind::Flat>(aBoundary1,
-                                                           aBoundary2);
-    }
-    return nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
-        aBoundary1, aBoundary2);
-  };
   // Both bondaries are in the same root, now check for their position
   const Maybe<int32_t> order =
-      aIsSetStart
-          ? ComparePoints(aNewBoundary, otherSideExistingBoundary.AsRaw())
-          : ComparePoints(otherSideExistingBoundary.AsRaw(), aNewBoundary);
+      aIsSetStart ? nsContentUtils::ComparePoints(aNewBoundary,
+                                                  otherSideExistingBoundary)
+                  : nsContentUtils::ComparePoints(otherSideExistingBoundary,
+                                                  aNewBoundary);
 
   if (order) {
     if (*order != 1) {
@@ -340,12 +324,11 @@
     // otherSideExistingBoundary. However, it's possible that aNewBoundary
     // is valid with the otherSideExistingCrossShadowBoundaryBoundary.
     const Maybe<int32_t> withCrossShadowBoundaryOrder =
-        aIsSetStart ? ComparePoints(
-                          aNewBoundary,
-                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw())
-                    : ComparePoints(
-                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw(),
-                          aNewBoundary);
+        aIsSetStart
+            ? nsContentUtils::ComparePoints(
+                  aNewBoundary, otherSideExistingCrossShadowBoundaryBoundary)
+            : nsContentUtils::ComparePoints(
+                  otherSideExistingCrossShadowBoundaryBoundary, aNewBoundary);
 
     // Valid to the cross boundary boundary.
     if (withCrossShadowBoundaryOrder && *withCrossShadowBoundaryOrder != 1) {
@@ -3263,7 +3246,8 @@
       nsINode* node = preOrderIter.GetCurrentNode();
       preOrderIter.Next();
       bool selectable = true;
-      nsIContent* content = nsIContent::FromNodeOrNull(node);
+      nsIContent* content =
+          node && node->IsContent() ? node->AsContent() : nullptr;
       if (content) {
         if (firstNonSelectableContent &&
             ExcludeIfNextToNonSelectable(content)) {