# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/RangeUtils.h
# Commit: 5661dec1e128
# Full Hash: 5661dec1e128f48fc62be6ebc2774fc247b71fc3
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231588
# ==============================================================================

diff -r 15ccf86bce5a -r 5661dec1e128 dom/base/RangeUtils.h
--- a/dom/base/RangeUtils.h	Wed May 07 15:05:08 2025 +0000
+++ b/dom/base/RangeUtils.h	Wed May 07 15:05:09 2025 +0000
@@ -11,6 +11,7 @@
 #include "mozilla/RangeBoundary.h"
 #include "nsIContent.h"
 #include "nsINode.h"
+#include "nsContentUtils.h"
 
 namespace mozilla {
 
@@ -55,8 +56,6 @@
   using AbstractRange = dom::AbstractRange;
 
  public:
-  static nsINode* GetParentNodeInSameSelection(const nsINode* aNode);
-
   /**
    * GetRawRangeBoundaryBefore() and GetRawRangeBoundaryAfter() retrieve
    * RawRangeBoundary which points before or after aNode.
@@ -137,6 +136,9 @@
   /**
    * The caller needs to ensure aNode is in the same doc like aAbstractRange.
    */
+  template <TreeKind aKind = TreeKind::ShadowIncludingDOM,
+            typename = std::enable_if_t<aKind == TreeKind::ShadowIncludingDOM ||
+                                        aKind == TreeKind::Flat>>
   static Maybe<bool> IsNodeContainedInRange(nsINode& aNode,
                                             AbstractRange* aAbstractRange);
 
@@ -145,12 +147,18 @@
    * ends after a range.  If neither it is contained inside the range.
    * Note that callers responsibility to ensure node in same doc as range.
    */
+  template <TreeKind aKind = TreeKind::ShadowIncludingDOM,
+            typename = std::enable_if_t<aKind == TreeKind::ShadowIncludingDOM ||
+                                        aKind == TreeKind::Flat>>
   static nsresult CompareNodeToRange(nsINode* aNode,
                                      AbstractRange* aAbstractRange,
                                      bool* aNodeIsBeforeRange,
                                      bool* aNodeIsAfterRange);
 
-  template <typename SPT, typename SRT, typename EPT, typename ERT>
+  template <TreeKind aKind, typename SPT, typename SRT, typename EPT,
+            typename ERT,
+            typename = std::enable_if_t<aKind == TreeKind::ShadowIncludingDOM ||
+                                        aKind == TreeKind::Flat>>
   static nsresult CompareNodeToRangeBoundaries(
       nsINode* aNode, const RangeBoundaryBase<SPT, SRT>& aStartBoundary,
       const RangeBoundaryBase<EPT, ERT>& aEndBoundary, bool* aNodeIsBeforeRange,