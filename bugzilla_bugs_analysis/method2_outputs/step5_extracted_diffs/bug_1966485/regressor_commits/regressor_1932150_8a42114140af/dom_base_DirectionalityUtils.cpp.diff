# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/DirectionalityUtils.cpp
# Commit: 8a42114140af
# Full Hash: 8a42114140af9d0a310c50d8c0fcc0a3e3740352
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-08 04:32:48
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Update ranges to correctly set and update nodes for flattened selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231589
# ==============================================================================

diff -r 5661dec1e128 -r 8a42114140af dom/base/DirectionalityUtils.cpp
--- a/dom/base/DirectionalityUtils.cpp	Wed May 07 15:05:09 2025 +0000
+++ b/dom/base/DirectionalityUtils.cpp	Wed May 07 15:05:09 2025 +0000
@@ -559,6 +559,19 @@
 }
 
 void SlotAssignedNodeAdded(HTMLSlotElement* aSlot, nsIContent& aAssignedNode) {
+  MOZ_ASSERT(aSlot);
+  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+    if (aSlot->IsMaybeSelected()) {
+      // Normally it's nsRange::ContentAppended's responsibility to
+      // mark new descendants, however this doesn't work for slotted
+      // content because nsRange observes the common ancestor of
+      // start/end, whereas slotted element may not have the same
+      // ancestor as them.
+      dom::AbstractRange::UpdateDescendantsInFlattenedTree(
+          aAssignedNode, true /* aMarkDesendants*/);
+    }
+  }
+
   if (aSlot->HasDirAuto()) {
     aAssignedNode.SetAffectsDirAutoSlot();
     DownwardPropagateDirAutoFlags(&aAssignedNode);
@@ -568,6 +581,19 @@
 
 void SlotAssignedNodeRemoved(HTMLSlotElement* aSlot,
                              nsIContent& aUnassignedNode) {
+  if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled() &&
+      aUnassignedNode.IsMaybeSelected()) {
+    // Normally, this shouldn't happen because nsRange::ContentRemoved
+    // should be called for content removal, and then
+    // AbstractRange::UnmarkDescendants will be used to clear the flags.
+    // Though this doesn't work for slotted element because nsRange
+    // observers the common ancestor of start/end, whereas slotted element
+    // may not have the same ancestor as them, so we have to clear
+    // the flags manually here.
+    dom::AbstractRange::UpdateDescendantsInFlattenedTree(
+        aUnassignedNode, false /* aMarkDesendants*/);
+  }
+
   if (aSlot->HasDirAuto()) {
     MaybeClearAffectsDirAutoSlot(&aUnassignedNode);
   }