# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsINode.cpp
# Commit: a4ef62ad447f
# Full Hash: a4ef62ad447f3bdeca250ebc7052854226c8891f
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231588
# ==============================================================================

diff -r fb611166c7ab -r a4ef62ad447f dom/base/nsINode.cpp
--- a/dom/base/nsINode.cpp	Thu May 08 13:37:20 2025 +0000
+++ b/dom/base/nsINode.cpp	Thu May 08 13:37:20 2025 +0000
@@ -343,16 +343,28 @@
   }
 
   int operator()(const AbstractRange* const aRange) const {
-    Maybe<int32_t> cmp = nsContentUtils::ComparePoints(
-        ConstRawRangeBoundary(&mNode, mEndOffset,
-                              RangeBoundaryIsMutationObserved::No),
-        aRange->MayCrossShadowBoundaryStartRef(), mCache);
-    if (cmp.valueOr(1) == 1) {
-      cmp = nsContentUtils::ComparePoints(
-          ConstRawRangeBoundary(&mNode, mStartOffset,
-                                RangeBoundaryIsMutationObserved::No),
-          aRange->MayCrossShadowBoundaryEndRef(), mCache);
-      if (cmp.valueOr(1) == -1) {
+    auto ComparePoints = [](const nsINode* aNode1, const uint32_t aOffset1,
+                            const nsINode* aNode2, const uint32_t aOffset2,
+                            nsContentUtils::NodeIndexCache* aCache) {
+      if (StaticPrefs::dom_shadowdom_selection_across_boundary_enabled()) {
+        return nsContentUtils::ComparePointsWithIndices<TreeKind::Flat>(
+            aNode1, aOffset1, aNode2, aOffset2, aCache);
+      }
+      return nsContentUtils::ComparePointsWithIndices<
+          TreeKind::ShadowIncludingDOM>(aNode1, aOffset1, aNode2, aOffset2,
+                                        aCache);
+    };
+
+    Maybe<int32_t> cmp = ComparePoints(
+        &mNode, mEndOffset, aRange->GetMayCrossShadowBoundaryStartContainer(),
+        aRange->MayCrossShadowBoundaryStartOffset(), mCache);
+    MOZ_ASSERT(cmp.isSome());  // Should always be connected at this point.
+    if (cmp.value() == 1) {
+      cmp = ComparePoints(&mNode, mStartOffset,
+                          aRange->GetMayCrossShadowBoundaryEndContainer(),
+                          aRange->MayCrossShadowBoundaryEndOffset(), mCache);
+      MOZ_ASSERT(cmp.isSome());
+      if (cmp.value() == -1) {
         return 0;
       }
       return 1;