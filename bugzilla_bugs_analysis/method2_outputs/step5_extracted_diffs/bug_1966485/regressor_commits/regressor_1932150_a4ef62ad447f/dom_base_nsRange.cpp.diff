# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/nsRange.cpp
# Commit: a4ef62ad447f
# Full Hash: a4ef62ad447f3bdeca250ebc7052854226c8891f
# Author: Sean Feng <sefeng@mozilla.com>
# Date: 2025-05-09 04:15:00
# Regressor Bug: 1932150
# File Overlap Count: 1
# Description:
#   Bug 1932150 - Allow using flat tree order for point comparing in selection r=jjaschke,smaug,dom-core
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D231588
# ==============================================================================

diff -r fb611166c7ab -r a4ef62ad447f dom/base/nsRange.cpp
--- a/dom/base/nsRange.cpp	Thu May 08 13:37:20 2025 +0000
+++ b/dom/base/nsRange.cpp	Thu May 08 13:37:20 2025 +0000
@@ -285,12 +285,21 @@
   const RangeBoundary& otherSideExistingBoundary =
       aIsSetStart ? aRange->EndRef() : aRange->StartRef();
 
+  auto ComparePoints = [aAllowCrossShadowBoundary](
+                           const RawRangeBoundary& aBoundary1,
+                           const RawRangeBoundary& aBoundary2) {
+    if (aAllowCrossShadowBoundary == AllowRangeCrossShadowBoundary::Yes) {
+      return nsContentUtils::ComparePoints<TreeKind::Flat>(aBoundary1,
+                                                           aBoundary2);
+    }
+    return nsContentUtils::ComparePoints<TreeKind::ShadowIncludingDOM>(
+        aBoundary1, aBoundary2);
+  };
   // Both bondaries are in the same root, now check for their position
   const Maybe<int32_t> order =
-      aIsSetStart ? nsContentUtils::ComparePoints(aNewBoundary,
-                                                  otherSideExistingBoundary)
-                  : nsContentUtils::ComparePoints(otherSideExistingBoundary,
-                                                  aNewBoundary);
+      aIsSetStart
+          ? ComparePoints(aNewBoundary, otherSideExistingBoundary.AsRaw())
+          : ComparePoints(otherSideExistingBoundary.AsRaw(), aNewBoundary);
 
   if (order) {
     if (*order != 1) {
@@ -324,11 +333,12 @@
     // otherSideExistingBoundary. However, it's possible that aNewBoundary
     // is valid with the otherSideExistingCrossShadowBoundaryBoundary.
     const Maybe<int32_t> withCrossShadowBoundaryOrder =
-        aIsSetStart
-            ? nsContentUtils::ComparePoints(
-                  aNewBoundary, otherSideExistingCrossShadowBoundaryBoundary)
-            : nsContentUtils::ComparePoints(
-                  otherSideExistingCrossShadowBoundaryBoundary, aNewBoundary);
+        aIsSetStart ? ComparePoints(
+                          aNewBoundary,
+                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw())
+                    : ComparePoints(
+                          otherSideExistingCrossShadowBoundaryBoundary.AsRaw(),
+                          aNewBoundary);
 
     // Valid to the cross boundary boundary.
     if (withCrossShadowBoundaryOrder && *withCrossShadowBoundaryOrder != 1) {
@@ -3246,8 +3256,7 @@
       nsINode* node = preOrderIter.GetCurrentNode();
       preOrderIter.Next();
       bool selectable = true;
-      nsIContent* content =
-          node && node->IsContent() ? node->AsContent() : nullptr;
+      nsIContent* content = nsIContent::FromNodeOrNull(node);
       if (content) {
         if (firstNonSelectableContent &&
             ExcludeIfNextToNonSelectable(content)) {