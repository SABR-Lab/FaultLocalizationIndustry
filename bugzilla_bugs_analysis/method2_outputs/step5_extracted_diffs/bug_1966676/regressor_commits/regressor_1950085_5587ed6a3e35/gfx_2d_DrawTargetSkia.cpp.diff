# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/2d/DrawTargetSkia.cpp
# Commit: 5587ed6a3e35
# Full Hash: 5587ed6a3e35161635cecd4c6daf3a3ff8a279cb
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2025-03-01 09:17:11
# Regressor Bug: 1950085
# File Overlap Count: 1
# Description:
#   Bug 1950085 - Ensure DrawTargetWebgl::DrawSurface clips drawing to surface bounds. r=aosmond
#   
#   For offset surfaces, the source rect to DrawSurface may not actually be entirely filled by
#   the surface's contents. In this case, we need to clip the source and dest rects to reflect
#   the actual surface content bounds.
# ==============================================================================

diff -r 9e52dcfa8931 -r 5587ed6a3e35 gfx/2d/DrawTargetSkia.cpp
--- a/gfx/2d/DrawTargetSkia.cpp	Fri Feb 28 16:06:03 2025 +0000
+++ b/gfx/2d/DrawTargetSkia.cpp	Fri Feb 28 18:20:19 2025 +0000
@@ -588,15 +588,17 @@
     }
     case PatternType::SURFACE: {
       const SurfacePattern& pat = static_cast<const SurfacePattern&>(aPattern);
+      Matrix offsetMatrix = pat.mMatrix;
+      offsetMatrix.PreTranslate(pat.mSurface->GetRect().TopLeft());
       sk_sp<SkImage> image =
-          GetSkImageForSurface(pat.mSurface, &aLock, aBounds, &pat.mMatrix);
+          GetSkImageForSurface(pat.mSurface, &aLock, aBounds, &offsetMatrix);
       if (!image) {
         aPaint.setColor(SK_ColorTRANSPARENT);
         break;
       }
 
       SkMatrix mat;
-      GfxMatrixToSkiaMatrix(pat.mMatrix, mat);
+      GfxMatrixToSkiaMatrix(offsetMatrix, mat);
       if (aMatrix) {
         mat.postConcat(*aMatrix);
       }
@@ -855,10 +857,12 @@
              kOpaque_SkAlphaType) &&
         !pat.mMatrix.HasNonAxisAlignedTransform()) {
       // Bound the sampling to smaller of the bounds or the sampling rect.
-      IntRect srcRect(IntPoint(0, 0), pat.mSurface->GetSize());
+      IntRect surfaceBounds = pat.mSurface->GetRect();
+      IntRect srcRect(IntPoint(0, 0), surfaceBounds.Size());
       if (!pat.mSamplingRect.IsEmpty()) {
         srcRect = srcRect.Intersect(pat.mSamplingRect);
       }
+      srcRect.MoveBy(surfaceBounds.TopLeft());
       // Transform the destination rectangle by the inverse of the pattern
       // matrix so that it is in pattern space like the source rectangle.
       Rect patRect = aRect - pat.mMatrix.GetTranslation();
@@ -1753,10 +1757,12 @@
   }
 
   // Ensure the source rect intersects the surface bounds.
-  IntRect srcRect = aSourceRect.Intersect(SkIRectToIntRect(srcPixmap.bounds()));
+  IntRect offsetSrcRect = aSourceRect - aSurface->GetRect().TopLeft();
+  IntRect srcRect =
+      offsetSrcRect.Intersect(SkIRectToIntRect(srcPixmap.bounds()));
   // Move the destination offset to match the altered source rect.
   IntPoint dstOffset =
-      aDestination + (srcRect.TopLeft() - aSourceRect.TopLeft());
+      aDestination + (srcRect.TopLeft() - offsetSrcRect.TopLeft());
   // Then ensure the dest rect intersect the canvas bounds.
   IntRect dstRect = IntRect(dstOffset, srcRect.Size()).Intersect(GetRect());
   // Move the source rect to match the altered dest rect.