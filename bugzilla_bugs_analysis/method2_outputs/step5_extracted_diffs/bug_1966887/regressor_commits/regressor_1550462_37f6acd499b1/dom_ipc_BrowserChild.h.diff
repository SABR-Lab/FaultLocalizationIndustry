# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/BrowserChild.h
# Commit: 37f6acd499b1
# Full Hash: 37f6acd499b11386a9c97f5783c89c4908692029
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-16 16:19:07
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make PresShell::HandleEvent dispatch preceding pointerrawupdate event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch ePointerRawUpdate with
#   PresShell::EventHandler::DispatchPrecedingPointerEvent as same as usual
#   pointer events.
# ==============================================================================

diff -r 32ba02fa32ec -r 37f6acd499b1 dom/ipc/BrowserChild.h
--- a/dom/ipc/BrowserChild.h	Fri May 16 09:49:43 2025 +0000
+++ b/dom/ipc/BrowserChild.h	Fri May 16 09:49:44 2025 +0000
@@ -641,14 +641,36 @@
   // may reentry the event loop and access to the same hashtable. It's
   // called when dispatching some mouse events other than mousemove.
   void FlushAllCoalescedMouseData();
+
   void ProcessPendingCoalescedMouseDataAndDispatchEvents();
 
   void ProcessPendingCoalescedTouchData();
 
+  /**
+   * Dispatch an eMouseRawUpdate event for dispatching ePointerRawUpdate event
+   * into the DOM immediately when aPendingEvent will be dispatched later.
+   * This does nothing if there is no window which has at least one
+   * `pointerrawupdate` event listener.
+   */
+  void HandleMouseRawUpdateEvent(const WidgetMouseEvent& aPendingMouseEvent,
+                                 const ScrollableLayerGuid& aGuid,
+                                 const uint64_t& aInputBlockId);
+
   void HandleRealMouseButtonEvent(const WidgetMouseEvent& aEvent,
                                   const ScrollableLayerGuid& aGuid,
                                   const uint64_t& aInputBlockId);
 
+  /**
+   * Dispatch an eTouchRawUpdate event for dispatching ePointerRawUpdate event
+   * into the DOM immediately when aPendingEvent will be dispatched later.
+   * This does nothing if there is no window which has at least one
+   * `pointerrawupdate` event listener.
+   */
+  void HandleTouchRawUpdateEvent(const WidgetTouchEvent& aPendingTouchEvent,
+                                 const ScrollableLayerGuid& aGuid,
+                                 const uint64_t& aInputBlockId,
+                                 const nsEventStatus& aApzResponse);
+
   void SetCancelContentJSEpoch(int32_t aEpoch) {
     mCancelContentJSEpoch = aEpoch;
   }
@@ -716,7 +738,7 @@
   void OnPointerRawUpdateEventListenerAdded(const nsPIDOMWindowInner* aWindow);
   void OnPointerRawUpdateEventListenerRemoved(
       const nsPIDOMWindowInner* aWindow);
-  [[nodiscard]] bool HasWindowHavingPointerRawUpdateEventListeners() const {
+  [[nodiscard]] bool HasPointerRawUpdateEventListeners() const {
     return !!mPointerRawUpdateWindowCount;
   }
 