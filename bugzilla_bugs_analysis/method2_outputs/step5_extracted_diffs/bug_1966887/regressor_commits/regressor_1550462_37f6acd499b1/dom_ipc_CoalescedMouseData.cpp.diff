# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/CoalescedMouseData.cpp
# Commit: 37f6acd499b1
# Full Hash: 37f6acd499b11386a9c97f5783c89c4908692029
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-16 16:19:07
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make PresShell::HandleEvent dispatch preceding pointerrawupdate event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch ePointerRawUpdate with
#   PresShell::EventHandler::DispatchPrecedingPointerEvent as same as usual
#   pointer events.
# ==============================================================================

diff -r 32ba02fa32ec -r 37f6acd499b1 dom/ipc/CoalescedMouseData.cpp
--- a/dom/ipc/CoalescedMouseData.cpp	Fri May 16 09:49:43 2025 +0000
+++ b/dom/ipc/CoalescedMouseData.cpp	Fri May 16 09:49:44 2025 +0000
@@ -58,17 +58,29 @@
 
 bool CoalescedMouseData::CanCoalesce(const WidgetMouseEvent& aEvent,
                                      const ScrollableLayerGuid& aGuid,
-                                     const uint64_t& aInputBlockId) {
+                                     const uint64_t& aInputBlockId,
+                                     const nsRefreshDriver* aRefreshDriver) {
   MOZ_ASSERT(aEvent.mMessage == eMouseMove);
-  return !mCoalescedInputEvent ||
-         (!mCoalescedInputEvent->mFlags.mIsSynthesizedForTests &&
-          !aEvent.mFlags.mIsSynthesizedForTests &&
-          mCoalescedInputEvent->mModifiers == aEvent.mModifiers &&
-          mCoalescedInputEvent->mInputSource == aEvent.mInputSource &&
-          mCoalescedInputEvent->pointerId == aEvent.pointerId &&
-          mCoalescedInputEvent->mButton == aEvent.mButton &&
-          mCoalescedInputEvent->mButtons == aEvent.mButtons && mGuid == aGuid &&
-          mInputBlockId == aInputBlockId);
+  if (!mCoalescedInputEvent) {
+    return true;
+  }
+  if (mCoalescedInputEvent->mFlags.mIsSynthesizedForTests !=
+          aEvent.mFlags.mIsSynthesizedForTests ||
+      mCoalescedInputEvent->mModifiers != aEvent.mModifiers ||
+      mCoalescedInputEvent->mInputSource != aEvent.mInputSource ||
+      mCoalescedInputEvent->pointerId != aEvent.pointerId ||
+      mCoalescedInputEvent->mButton != aEvent.mButton ||
+      mCoalescedInputEvent->mButtons != aEvent.mButtons || mGuid != aGuid ||
+      mInputBlockId != aInputBlockId) {
+    return false;
+  }
+  // Basically, tests do not want to coalesces the consecutive mouse events.
+  // However, if the test calls nsIDOMWindowUtils::AdvanceTimeAndRefresh(0),
+  // they must try to check coalesced mouse move events.
+  if (!aEvent.mFlags.mIsSynthesizedForTests) {
+    return true;
+  }
+  return aRefreshDriver && aRefreshDriver->IsTestControllingRefreshesEnabled();
 }
 
 CoalescedMouseMoveFlusher::CoalescedMouseMoveFlusher(