# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/EventStateManager.cpp
# Commit: 5718f7f3067e
# Full Hash: 5718f7f3067eff42e097a6013acd82fbe6aa299a
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-15 22:58:00
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch `ePointerRawUpdate` with
#   `PresShell::EventHandler::DispatchPrecedingPointerEvent` as same as usual
#   pointer events.
# ==============================================================================

diff -r aae164cff6aa -r 5718f7f3067e dom/events/EventStateManager.cpp
--- a/dom/events/EventStateManager.cpp	Thu May 15 03:20:28 2025 +0000
+++ b/dom/events/EventStateManager.cpp	Thu May 15 03:20:29 2025 +0000
@@ -995,6 +995,7 @@
     if (touchEvent->mMessage == eTouchMove) {
       GenerateDragGesture(aPresContext, touchEvent);
     } else {
+      MOZ_ASSERT(touchEvent->mMessage != eTouchRawUpdate);
       mInTouchDrag = false;
       StopTrackingDragGesture(true);
     }
@@ -1142,7 +1143,8 @@
       }
       [[fallthrough]];
     case eMouseMove:
-    case ePointerMove: {
+    case ePointerMove:
+    case ePointerRawUpdate: {
       if (aEvent->mMessage == ePointerMove) {
         PointerEventHandler::UpdateActivePointerState(mouseEvent,
                                                       aTargetContent);
@@ -4366,20 +4368,22 @@
               // events after they have been processed. When determining if
               // a swipe should occur, we should not prefer the current wheel
               // transaction.
-              nsIFrame* lastScrollFrame = WheelTransaction::GetScrollTargetFrame();
+              nsIFrame* lastScrollFrame =
+                  WheelTransaction::GetScrollTargetFrame();
               bool wheelTransactionHandlesInput = false;
               if (lastScrollFrame) {
-                ScrollContainerFrame* scrollContainerFrame = lastScrollFrame->GetScrollTargetFrame();
+                ScrollContainerFrame* scrollContainerFrame =
+                    lastScrollFrame->GetScrollTargetFrame();
                 if (scrollContainerFrame->IsRootScrollFrameOfDocument()) {
                   // If the current wheel transaction target is the root scroll
                   // frame and is not scrollable on the x-axis, all delta is
                   // overflown and swipe-to-nav may occur.
                   wheelTransactionHandlesInput = true;
-                  allDeltaOverflown = !WheelHandlingUtils::CanScrollOn(scrollContainerFrame,
-                                                                       wheelEvent->mDeltaX, 0.0);
-                } else if(WheelHandlingUtils::CanScrollOn(scrollContainerFrame,
-                                                          wheelEvent->mDeltaX,
-                                                          wheelEvent->mDeltaY)) {
+                  allDeltaOverflown = !WheelHandlingUtils::CanScrollOn(
+                      scrollContainerFrame, wheelEvent->mDeltaX, 0.0);
+                } else if (WheelHandlingUtils::CanScrollOn(
+                               scrollContainerFrame, wheelEvent->mDeltaX,
+                               wheelEvent->mDeltaY)) {
                   // If the current wheel transaction target is not the root
                   // scroll frame, ensure that swipe to nav does not occur if
                   // the scroll frame is scrollable on the x or y axis. If the
@@ -5564,7 +5568,8 @@
 /* static */
 void EventStateManager::UpdateLastRefPointOfMouseEvent(
     WidgetMouseEvent* aMouseEvent) {
-  if (aMouseEvent->mMessage != eMouseMove &&
+  if (aMouseEvent->mMessage != ePointerRawUpdate &&
+      aMouseEvent->mMessage != eMouseMove &&
       aMouseEvent->mMessage != ePointerMove) {
     return;
   }
@@ -5597,7 +5602,8 @@
 void EventStateManager::ResetPointerToWindowCenterWhilePointerLocked(
     WidgetMouseEvent* aMouseEvent) {
   MOZ_ASSERT(PointerLockManager::IsLocked());
-  if ((aMouseEvent->mMessage != eMouseMove &&
+  if ((aMouseEvent->mMessage != ePointerRawUpdate &&
+       aMouseEvent->mMessage != eMouseMove &&
        aMouseEvent->mMessage != ePointerMove) ||
       !aMouseEvent->mWidget) {
     return;
@@ -5658,6 +5664,7 @@
   switch (aMouseEvent->mMessage) {
     case eMouseMove:
     case ePointerMove:
+    case ePointerRawUpdate:
     case ePointerDown:
     case ePointerGotCapture: {
       // Get the target content target (mousemove target == mouseover target)