# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/PointerEventHandler.cpp
# Commit: 5718f7f3067e
# Full Hash: 5718f7f3067eff42e097a6013acd82fbe6aa299a
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-15 22:58:00
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch `ePointerRawUpdate` with
#   `PresShell::EventHandler::DispatchPrecedingPointerEvent` as same as usual
#   pointer events.
# ==============================================================================

diff -r aae164cff6aa -r 5718f7f3067e dom/events/PointerEventHandler.cpp
--- a/dom/events/PointerEventHandler.cpp	Thu May 15 03:20:28 2025 +0000
+++ b/dom/events/PointerEventHandler.cpp	Thu May 15 03:20:29 2025 +0000
@@ -715,7 +715,9 @@
     WidgetPointerEvent& aPointerEvent, const WidgetTouchEvent& aTouchEvent,
     const mozilla::dom::Touch& aTouch) {
   // Use mButton/mButtons only when mButton got a value (from pen input)
-  int16_t button = aTouchEvent.mMessage == eTouchMove ? MouseButton::eNotPressed
+  int16_t button = aTouchEvent.mMessage == eTouchRawUpdate ||
+                           aTouchEvent.mMessage == eTouchMove
+                       ? MouseButton::eNotPressed
                    : aTouchEvent.mButton != MouseButton::eNotPressed
                        ? aTouchEvent.mButton
                        : MouseButton::ePrimary;
@@ -783,6 +785,9 @@
   MOZ_ASSERT(aMouseOrTouchEvent);
 
   switch (aMouseOrTouchEvent->mMessage) {
+    case eMouseRawUpdate:
+    case eTouchRawUpdate:
+      return ePointerRawUpdate;
     case eMouseMove:
       return ePointerMove;
     case eMouseUp:
@@ -810,6 +815,15 @@
 }
 
 /* static */
+bool PointerEventHandler::NeedToDispatchPointerRawUpdate(
+    const Document* aDocument) {
+  const nsPIDOMWindowInner* const innerWindow =
+      aDocument ? aDocument->GetInnerWindow() : nullptr;
+  return innerWindow && innerWindow->HasPointerRawUpdateEventListeners() &&
+         innerWindow->IsSecureContext();
+}
+
+/* static */
 void PointerEventHandler::DispatchPointerFromMouseOrTouch(
     PresShell* aShell, nsIFrame* aEventTargetFrame,
     nsIContent* aEventTargetContent, Element* aPointerCapturingElement,
@@ -838,10 +852,8 @@
     }
 
     // 1. If it is not mouse then it is likely will come as touch event
-    // 2. We don't synthesize pointer events for those events that are not
-    //    dispatched to DOM.
-    if (!mouseEvent->convertToPointer ||
-        !aMouseOrTouchEvent->IsAllowedToDispatchDOMEvent()) {
+    // 2. We don't synthesize pointer events for synthesized mouse move
+    if (!mouseEvent->convertToPointer || mouseEvent->IsSynthesized()) {
       return;
     }
 
@@ -849,6 +861,30 @@
     if (pointerMessage == eVoidEvent) {
       return;
     }
+#ifdef DEBUG
+    if (pointerMessage == ePointerRawUpdate) {
+      const nsIContent* const targetContent =
+          aEventTargetContent ? aEventTargetContent
+                              : aEventTargetFrame->GetContent();
+      NS_ASSERTION(targetContent, "Where do we want to try to dispatch?");
+      if (targetContent) {
+        NS_ASSERTION(
+            targetContent->IsInComposedDoc(),
+            nsPrintfCString("Do we want to dispatch ePointerRawUpdate onto "
+                            "disconnected content? (targetContent=%s)",
+                            ToString(*targetContent).c_str())
+                .get());
+        if (!NeedToDispatchPointerRawUpdate(targetContent->OwnerDoc())) {
+          NS_ASSERTION(
+              false,
+              nsPrintfCString(
+                  "Did we fail to retarget the document? (targetContent=%s)",
+                  ToString(*targetContent).c_str())
+                  .get());
+        }
+      }
+    }
+#endif  // #ifdef DEBUG
     WidgetPointerEvent event(*mouseEvent);
     InitPointerEventFromMouse(&event, mouseEvent, pointerMessage);
     event.convertToPointer = mouseEvent->convertToPointer = false;
@@ -927,7 +963,7 @@
         // all pointer events should be dispatched to the same target as their
         // corresponding touch events. Call PresShell::HandleEvent so that we do
         // hit test for pointer events.
-        // FIXME: If aDontRetargetEvents is true and the event is fired on
+        // FIXME: If aDontRetargetEvents is false and the event is fired on
         // different document, we cannot track the pointer event target when
         // it's removed from the tree.
         PreHandlePointerEventsPreventDefault(&event, aMouseOrTouchEvent);
@@ -992,9 +1028,15 @@
 bool PointerEventHandler::IsDragAndDropEnabled(WidgetMouseEvent& aEvent) {
   // We shouldn't start a drag session if the event is synthesized one because
   // aEvent doesn't have enough information for initializing the ePointerCancel.
-  if (!aEvent.IsReal()) {
+  if (aEvent.IsSynthesized()) {
     return false;
   }
+  // And we should not start with raw update events, which should be used only
+  // for notifying web apps of the pointer state changes ASAP.
+  if (aEvent.mMessage == ePointerRawUpdate) {
+    return false;
+  }
+  MOZ_ASSERT(aEvent.mMessage != eMouseRawUpdate);
 #ifdef XP_WIN
   if (StaticPrefs::dom_w3c_pointer_events_dispatch_by_pointer_messages()) {
     // WM_POINTER does not support drag and drop, see bug 1692277