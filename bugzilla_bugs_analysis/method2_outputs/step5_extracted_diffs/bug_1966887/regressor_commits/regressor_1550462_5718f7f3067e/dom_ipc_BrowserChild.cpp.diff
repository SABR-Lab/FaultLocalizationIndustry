# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/BrowserChild.cpp
# Commit: 5718f7f3067e
# Full Hash: 5718f7f3067eff42e097a6013acd82fbe6aa299a
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-15 22:58:00
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch `ePointerRawUpdate` with
#   `PresShell::EventHandler::DispatchPrecedingPointerEvent` as same as usual
#   pointer events.
# ==============================================================================

diff -r aae164cff6aa -r 5718f7f3067e dom/ipc/BrowserChild.cpp
--- a/dom/ipc/BrowserChild.cpp	Thu May 15 03:20:28 2025 +0000
+++ b/dom/ipc/BrowserChild.cpp	Thu May 15 03:20:29 2025 +0000
@@ -1489,7 +1489,7 @@
   // mToBeDispatchedMouseData while dispatching an event.
 
   // We may have some pending coalesced data while dispatch an event and reentry
-  // the event loop. In that case we don't have chance to consume the remainding
+  // the event loop. In that case we don't have chance to consume the remaining
   // pending data until we get new mouse events. Get some helps from
   // mCoalescedMouseEventFlusher to trigger it.
   mCoalescedMouseEventFlusher->StartObserver();
@@ -1500,6 +1500,13 @@
 
     UniquePtr<WidgetMouseEvent> event = data->TakeCoalescedEvent();
     if (event) {
+      // When the real mouse event receivers put the received event into the
+      // queue, they should dispatch eMouseRawUpdate event immediately (if and
+      // only if it's required).  Therefore, unless the event is the last one
+      // of the queue, the pending events should've been marked as "Do not
+      // convert to "pointerrawupdate".
+      MOZ_ASSERT_IF(mToBeDispatchedMouseData.GetSize() > 0,
+                    !event->convertToPointerRawUpdate);
       // Dispatch the pending events. Using HandleRealMouseButtonEvent
       // to bypass the coalesce handling in RecvRealMouseMoveEvent. Can't use
       // RecvRealMouseButtonEvent because we may also put some mouse events
@@ -1556,14 +1563,20 @@
     CoalescedMouseData* data =
         mCoalescedMouseData.GetOrInsertNew(aEvent.pointerId);
     MOZ_ASSERT(data);
-    if (data->CanCoalesce(aEvent, aGuid, aInputBlockId)) {
-      data->Coalesce(aEvent, aGuid, aInputBlockId);
+    if (data->CanCoalesce(aEvent, aGuid, aInputBlockId,
+                          mCoalescedMouseEventFlusher->GetRefreshDriver())) {
+      // We don't need to dispatch aEvent immediately.  However, we need to
+      // dispatch eMouseRawUpdate immediately if there is a `pointerrawupdate`
+      // event listener.  Therefore, the cloned event in the queue shouldn't
+      // cause eMouseRawUpdate later when it'll be dispatched.
+      WidgetMouseEvent pendingMouseMoveEvent(aEvent);
+      pendingMouseMoveEvent.convertToPointerRawUpdate = false;
+      data->Coalesce(pendingMouseMoveEvent, aGuid, aInputBlockId);
       mCoalescedMouseEventFlusher->StartObserver();
-      if (mPointerRawUpdateWindowCount) {
-        // TODO: Dispatch ePointerRawUpdate here
-      }
+      HandleMouseRawUpdateEvent(pendingMouseMoveEvent, aGuid, aInputBlockId);
       return IPC_OK();
     }
+
     // Can't coalesce current mousemove event. Put the coalesced mousemove data
     // with the same pointer id to mToBeDispatchedMouseData, coalesce the
     // current one, and process all pending data in mToBeDispatchedMouseData.
@@ -1578,17 +1591,50 @@
         mCoalescedMouseData
             .InsertOrUpdate(aEvent.pointerId, MakeUnique<CoalescedMouseData>())
             .get();
-    newData->Coalesce(aEvent, aGuid, aInputBlockId);
-
-    // Dispatch all pending mouse events.
+    // We don't want to dispatch aEvent immediately.  However, we need to
+    // dispatch eMouseRawUpdate immediately if there is a `pointerrawupdate`
+    // event listener.  Therefore, the cloned event in the queue shouldn't
+    // cause eMouseRawUpdate later when it'll be dispatched.
+    WidgetMouseEvent pendingMouseMoveEvent(aEvent);
+    pendingMouseMoveEvent.convertToPointerRawUpdate = false;
+    newData->Coalesce(pendingMouseMoveEvent, aGuid, aInputBlockId);
+
+    // Dispatch all pending mouse events which does NOT include aEvent.
     ProcessPendingCoalescedMouseDataAndDispatchEvents();
+
     mCoalescedMouseEventFlusher->StartObserver();
-  } else if (!RecvRealMouseButtonEvent(aEvent, aGuid, aInputBlockId)) {
+    // Finally, dispatch eMouseRawUpdate for aEvent right now.
+    HandleMouseRawUpdateEvent(pendingMouseMoveEvent, aGuid, aInputBlockId);
+    return IPC_OK();
+  }
+
+  if (!RecvRealMouseButtonEvent(aEvent, aGuid, aInputBlockId)) {
     return IPC_FAIL_NO_REASON(this);
   }
   return IPC_OK();
 }
 
+void BrowserChild::HandleMouseRawUpdateEvent(
+    const WidgetMouseEvent& aPendingMouseEvent,
+    const ScrollableLayerGuid& aGuid, const uint64_t& aInputBlockId) {
+  // If there is no window containing pointerrawupdate event listeners or the
+  // event is a synthesized mousemove, we don't need to dispatch eMouseRawUpdate
+  // event.
+  if (!mPointerRawUpdateWindowCount || aPendingMouseEvent.IsSynthesized()) {
+    return;
+  }
+  WidgetMouseEvent mouseRawUpdateEvent(aPendingMouseEvent);
+  mouseRawUpdateEvent.mMessage = eMouseRawUpdate;
+  mouseRawUpdateEvent.mCoalescedWidgetEvents = nullptr;
+  mouseRawUpdateEvent.convertToPointer = true;
+  // Nobody checks `convertToPointerRawUpdate` of eMouseRawUpdate event.
+  // However, the name indicates that it would cause ePointerRawUpdate.
+  // For avoiding to make the developers who watch the value with the debugger
+  // confused, here sets it to `true`.
+  mouseRawUpdateEvent.convertToPointerRawUpdate = true;
+  HandleRealMouseButtonEvent(mouseRawUpdateEvent, aGuid, aInputBlockId);
+}
+
 mozilla::ipc::IPCResult BrowserChild::RecvRealMouseMoveEventForTests(
     const WidgetMouseEvent& aEvent, const ScrollableLayerGuid& aGuid,
     const uint64_t& aInputBlockId) {
@@ -1640,9 +1686,16 @@
     UniquePtr<CoalescedMouseData> dispatchData =
         MakeUnique<CoalescedMouseData>();
 
+    // We'll dispatch aEvent immediately via
+    // ProcessPendingCoalescedMouseDataAndDispatchEvents().
+    // Therefore, PresShell should convert it to eMouseRawUpdate when it starts
+    // handling aEvent if and only if there is a `pointerrawupdate` event
+    // listener.  Therefore, let's assert the allowing flag to convert it to
+    // eMouseRawUpdate here.
+    MOZ_ASSERT(aEvent.convertToPointerRawUpdate);
     dispatchData->Coalesce(aEvent, aGuid, aInputBlockId);
+
     mToBeDispatchedMouseData.Push(dispatchData.release());
-
     ProcessPendingCoalescedMouseDataAndDispatchEvents();
     return IPC_OK();
   }
@@ -1833,7 +1886,7 @@
       ProcessPendingCoalescedTouchData();
     }
 
-    if (aEvent.mMessage != eTouchMove) {
+    if (aEvent.mMessage != eTouchMove && aEvent.mMessage != eTouchRawUpdate) {
       sConsecutiveTouchMoveCount = 0;
     }
   }
@@ -1896,36 +1949,88 @@
     ++sConsecutiveTouchMoveCount;
     if (mCoalescedTouchMoveEventFlusher) {
       MOZ_ASSERT(aEvent.mMessage == eTouchMove);
+      // NOTE: While dispatching eTouchMove or eTouchRawUpdate,
+      // sConsecutiveTouchMoveCount may be changed by the event loop spun,
+      // e.g., an event listener uses sync XHR or calling window.alert().
+      const auto PostponeDispatchingTouchMove = [&]() {
+        return sConsecutiveTouchMoveCount > 1;
+      };
       if (mCoalescedTouchData.IsEmpty() ||
           mCoalescedTouchData.CanCoalesce(aEvent, aGuid, aInputBlockId,
                                           aApzResponse)) {
+        if (PostponeDispatchingTouchMove()) {
+          WidgetTouchEvent pendingTouchMoveEvent(
+              aEvent, WidgetTouchEvent::CloneTouches::Yes);
+          // We don't dispatch aEvent immediately here.  However, we need to
+          // dispatch eTouchRawUpdate immediately if and only if there is a
+          // `pointerrawupdate` event listener.  Therefore, the cloned event in
+          // the queue and it shouldn't cause eTouchRawUpdate again.
+          pendingTouchMoveEvent.SetConvertToPointerRawUpdate(false);
+          mCoalescedTouchData.Coalesce(pendingTouchMoveEvent, aGuid,
+                                       aInputBlockId, aApzResponse);
+          MOZ_ASSERT(PostponeDispatchingTouchMove());
+          mCoalescedTouchMoveEventFlusher->StartObserver();
+          // Let's notify the web app of `pointerrawupdate` immediately if and
+          // only if they listen to it.
+          HandleTouchRawUpdateEvent(pendingTouchMoveEvent, aGuid, aInputBlockId,
+                                    aApzResponse);
+          return IPC_OK();
+        }
+
+        // We'll dispatch aEvent via ProcessPendingCoalescedTouchData() below.
+        // Therefore, the touches should cause eTouchRawUpdate event.
+        MOZ_ASSERT(aEvent.CanConvertToPointerRawUpdate());
         mCoalescedTouchData.Coalesce(aEvent, aGuid, aInputBlockId,
                                      aApzResponse);
+        MOZ_ASSERT(!PostponeDispatchingTouchMove());
       } else {
         UniquePtr<WidgetTouchEvent> touchMoveEvent =
             mCoalescedTouchData.TakeCoalescedEvent();
-
+        MOZ_ASSERT(touchMoveEvent->mMessage == eTouchMove);
+
+        // Before dispatching touchMoveEvent, we need to put aEvent into the
+        // queue for keeping the event order even if an event listener spins the
+        // event loop and we'll receive another touch event.  So, aEvent may be
+        // dispatched while we're dispatching touchMoveEvent. Therefore, we need
+        // to make it convertible to eTouchRawUpdate.
+        MOZ_ASSERT(aEvent.CanConvertToPointerRawUpdate());
         mCoalescedTouchData.Coalesce(aEvent, aGuid, aInputBlockId,
                                      aApzResponse);
-
+        MOZ_ASSERT(!PostponeDispatchingTouchMove());
+
+        // touchMoveEvent was stored by mCoalescedTouchData before receiving
+        // aEvent.  Therefore, the receiver should've already dispatched
+        // eTouchRawUpdate for dispatching `pointerrawupdate` and let web apps
+        // know the update immediately (with sacrificing the performance).
+        // Therefore, we don't need to dispatch eTouchRawUpdate here before
+        // dispatching the touchMoveEvent.
+        MOZ_ASSERT(!touchMoveEvent->CanConvertToPointerRawUpdate());
+        const uint32_t generation = mCoalescedTouchData.Generation();
         if (!RecvRealTouchEvent(*touchMoveEvent,
                                 mCoalescedTouchData.GetScrollableLayerGuid(),
                                 mCoalescedTouchData.GetInputBlockId(),
                                 mCoalescedTouchData.GetApzResponse())) {
           return IPC_FAIL_NO_REASON(this);
         }
+        // RecvRealTouchEvent() may have caused spinning the event loop and
+        // changed sConsecutiveTouchMoveCount.  So, we need to check it now.
+        if (PostponeDispatchingTouchMove()) {
+          mCoalescedTouchMoveEventFlusher->StartObserver();
+          if (generation == mCoalescedTouchData.Generation()) {
+            // Let's notify the web app of `pointerrawupdate` immediately if and
+            // only if they listen to it.  Additionally, we don't want to notify
+            // eTouchRawUpdate when ProcessPendingCoalescedTouchData() is called
+            // later.
+            mCoalescedTouchData.NotifyTouchRawUpdateOfHandled(aEvent);
+            HandleTouchRawUpdateEvent(aEvent, aGuid, aInputBlockId,
+                                      aApzResponse);
+          }
+          return IPC_OK();
+        }
       }
-
-      if (sConsecutiveTouchMoveCount > 1) {
-        mCoalescedTouchMoveEventFlusher->StartObserver();
-        if (mPointerRawUpdateWindowCount) {
-          // TODO: Dispatch ePointerRawUpdate here
-        }
-      } else {
-        // Flush the pending coalesced touch in order to avoid the first
-        // touchmove be overridden by the second one.
-        ProcessPendingCoalescedTouchData();
-      }
+      // Flush the pending coalesced touch in order to avoid the first
+      // touchmove be overridden by the second one, this contains aEvent.
+      ProcessPendingCoalescedTouchData();
       return IPC_OK();
     }
   }
@@ -1936,6 +2041,30 @@
   return IPC_OK();
 }
 
+void BrowserChild::HandleTouchRawUpdateEvent(
+    const WidgetTouchEvent& aPendingTouchEvent,
+    const ScrollableLayerGuid& aGuid, const uint64_t& aInputBlockId,
+    const nsEventStatus& aApzResponse) {
+  if (!mPointerRawUpdateWindowCount) {
+    return;  // There is no window containing pointerrawupdate event listeners
+  }
+
+  WidgetTouchEvent touchRawUpdateEvent(aPendingTouchEvent,
+                                       WidgetTouchEvent::CloneTouches::Yes);
+  touchRawUpdateEvent.mMessage = eTouchRawUpdate;
+  for (Touch* const touch : touchRawUpdateEvent.mTouches) {
+    touch->mMessage = eTouchRawUpdate;
+    touch->mCoalescedWidgetEvents = nullptr;
+    touch->convertToPointer = true;
+    // Although nobody checks `convertToPointerRawUpdate` of eTouchRawUpdate.
+    // However, the name indicates it would cause ePointerRawUpdate or not, so,
+    // for avoiding to make developers confused when they watch the value with
+    // the debugger, we should set this to `true`.
+    touch->convertToPointerRawUpdate = true;
+  }
+  RecvRealTouchEvent(touchRawUpdateEvent, aGuid, aInputBlockId, aApzResponse);
+}
+
 mozilla::ipc::IPCResult BrowserChild::RecvNormalPriorityRealTouchMoveEvent(
     const WidgetTouchEvent& aEvent, const ScrollableLayerGuid& aGuid,
     const uint64_t& aInputBlockId, const nsEventStatus& aApzResponse) {