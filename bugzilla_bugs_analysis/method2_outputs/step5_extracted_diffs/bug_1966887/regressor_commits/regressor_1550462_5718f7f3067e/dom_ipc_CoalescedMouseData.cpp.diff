# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/ipc/CoalescedMouseData.cpp
# Commit: 5718f7f3067e
# Full Hash: 5718f7f3067eff42e097a6013acd82fbe6aa299a
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-15 22:58:00
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar
#   
#   This patch tries to dispatch `ePointerRawUpdate` with
#   `PresShell::EventHandler::DispatchPrecedingPointerEvent` as same as usual
#   pointer events.
# ==============================================================================

diff -r aae164cff6aa -r 5718f7f3067e dom/ipc/CoalescedMouseData.cpp
--- a/dom/ipc/CoalescedMouseData.cpp	Thu May 15 03:20:28 2025 +0000
+++ b/dom/ipc/CoalescedMouseData.cpp	Thu May 15 03:20:29 2025 +0000
@@ -58,17 +58,29 @@
 
 bool CoalescedMouseData::CanCoalesce(const WidgetMouseEvent& aEvent,
                                      const ScrollableLayerGuid& aGuid,
-                                     const uint64_t& aInputBlockId) {
+                                     const uint64_t& aInputBlockId,
+                                     const nsRefreshDriver* aRefreshDriver) {
   MOZ_ASSERT(aEvent.mMessage == eMouseMove);
-  return !mCoalescedInputEvent ||
-         (!mCoalescedInputEvent->mFlags.mIsSynthesizedForTests &&
-          !aEvent.mFlags.mIsSynthesizedForTests &&
-          mCoalescedInputEvent->mModifiers == aEvent.mModifiers &&
-          mCoalescedInputEvent->mInputSource == aEvent.mInputSource &&
-          mCoalescedInputEvent->pointerId == aEvent.pointerId &&
-          mCoalescedInputEvent->mButton == aEvent.mButton &&
-          mCoalescedInputEvent->mButtons == aEvent.mButtons && mGuid == aGuid &&
-          mInputBlockId == aInputBlockId);
+  if (!mCoalescedInputEvent) {
+    return true;
+  }
+  if (mCoalescedInputEvent->mFlags.mIsSynthesizedForTests !=
+          aEvent.mFlags.mIsSynthesizedForTests ||
+      mCoalescedInputEvent->mModifiers != aEvent.mModifiers ||
+      mCoalescedInputEvent->mInputSource != aEvent.mInputSource ||
+      mCoalescedInputEvent->pointerId != aEvent.pointerId ||
+      mCoalescedInputEvent->mButton != aEvent.mButton ||
+      mCoalescedInputEvent->mButtons != aEvent.mButtons || mGuid != aGuid ||
+      mInputBlockId != aInputBlockId) {
+    return false;
+  }
+  // Basically, tests do not want to coalesces the consecutive mouse events.
+  // However, if the test calls nsIDOMWindowUtils::AdvanceTimeAndRefresh(0),
+  // they must try to check coalesced mouse move events.
+  if (!aEvent.mFlags.mIsSynthesizedForTests) {
+    return true;
+  }
+  return aRefreshDriver && aRefreshDriver->IsTestControllingRefreshesEnabled();
 }
 
 CoalescedMouseMoveFlusher::CoalescedMouseMoveFlusher(