# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/PointerEventHandler.h
# Commit: ddd6c187d02d
# Full Hash: ddd6c187d02d1b2ece70f5c1501f508ad96f7604
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-05-15 22:58:00
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Bug 1960253 - Split the computation of target frame/content of events using coordinates from `EventHandler::HandleEventUsingCoordinates` r=smaug
#   
#   We'll need to compute the target `PresShell` before processing the pending
#   pointer capture to check whether the corresponding window needs
#   `pointerrawupdate` events (bug 1550462).
# ==============================================================================

diff -r cd42b1907239 -r ddd6c187d02d dom/events/PointerEventHandler.h
--- a/dom/events/PointerEventHandler.h	Wed May 14 20:47:11 2025 +0000
+++ b/dom/events/PointerEventHandler.h	Wed May 14 21:19:36 2025 +0000
@@ -143,11 +143,27 @@
    *
    * @return                     Target element for aEvent.
    */
-  static dom::Element* GetPointerCapturingElement(WidgetGUIEvent* aEvent);
+  static dom::Element* GetPointerCapturingElement(const WidgetGUIEvent* aEvent);
 
   static dom::Element* GetPointerCapturingElement(uint32_t aPointerId);
 
   /**
+   * Return pending capture element of for the pointerId (of the event).
+   * - If the element has already overriden the pointer capture and there is no
+   * new pending capture element, the result is what captures the pointer right
+   * now.
+   * - If the element has not overriden the pointer capture, the result will
+   * start capturing the pointer once the pending pointer capture is processed
+   * at dispatching a pointer event later.
+   *
+   * So, in other words, the result is the element which will capture the next
+   * pointer event for the pointerId.
+   */
+  static dom::Element* GetPendingPointerCapturingElement(
+      const WidgetGUIEvent* aEvent);
+  static dom::Element* GetPendingPointerCapturingElement(uint32_t aPointerId);
+
+  /**
    * Return an element which captured the pointer at dispatching the last
    * ePointerUp event caused by eMouseUp except the compatibility mouse events
    * of Touch Events or caused by eTouchEnd whose number of touches is one,
@@ -301,6 +317,10 @@
       bool aIsGotCapture, const WidgetPointerEvent* aPointerEvent,
       dom::Element* aCaptureTarget);
 
+  enum class CapturingState { Pending, Override };
+  static dom::Element* GetPointerCapturingElementInternal(
+      CapturingState aCapturingState, const WidgetGUIEvent* aEvent);
+
   // The cached spoofed pointer ID for fingerprinting resistance. We will use a
   // mouse pointer id for desktop. For mobile, we should use the touch pointer
   // id as the spoofed one, and this work will be addressed in Bug 1492775.