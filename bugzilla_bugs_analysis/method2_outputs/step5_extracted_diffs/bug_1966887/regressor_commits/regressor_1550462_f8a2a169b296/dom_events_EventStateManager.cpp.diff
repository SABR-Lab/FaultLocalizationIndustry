# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/EventStateManager.cpp
# Commit: f8a2a169b296
# Full Hash: f8a2a169b2969d29e04733ae27a56459e5359973
# Author: Alexandru Marc <amarc@mozila.com>
# Date: 2025-05-16 09:19:19
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Revert "Bug 1550462 - part 3: Enable `pointerrawupdate` event r=smaug" for causing mochitest failures @ test_pointerrawupdate_event_count.html
#   
#   This reverts commit eb27445e0352d6b4df540adb40e21f72fc052e80.
#   
#   Revert "Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar"
# ==============================================================================

diff -r 8d25773fc82f -r f8a2a169b296 dom/events/EventStateManager.cpp
--- a/dom/events/EventStateManager.cpp	Fri May 16 06:20:47 2025 +0000
+++ b/dom/events/EventStateManager.cpp	Fri May 16 09:30:09 2025 +0300
@@ -995,7 +995,6 @@
     if (touchEvent->mMessage == eTouchMove) {
       GenerateDragGesture(aPresContext, touchEvent);
     } else {
-      MOZ_ASSERT(touchEvent->mMessage != eTouchRawUpdate);
       mInTouchDrag = false;
       StopTrackingDragGesture(true);
     }
@@ -1143,8 +1142,7 @@
       }
       [[fallthrough]];
     case eMouseMove:
-    case ePointerMove:
-    case ePointerRawUpdate: {
+    case ePointerMove: {
       if (aEvent->mMessage == ePointerMove) {
         PointerEventHandler::UpdateActivePointerState(mouseEvent,
                                                       aTargetContent);
@@ -4368,22 +4366,20 @@
               // events after they have been processed. When determining if
               // a swipe should occur, we should not prefer the current wheel
               // transaction.
-              nsIFrame* lastScrollFrame =
-                  WheelTransaction::GetScrollTargetFrame();
+              nsIFrame* lastScrollFrame = WheelTransaction::GetScrollTargetFrame();
               bool wheelTransactionHandlesInput = false;
               if (lastScrollFrame) {
-                ScrollContainerFrame* scrollContainerFrame =
-                    lastScrollFrame->GetScrollTargetFrame();
+                ScrollContainerFrame* scrollContainerFrame = lastScrollFrame->GetScrollTargetFrame();
                 if (scrollContainerFrame->IsRootScrollFrameOfDocument()) {
                   // If the current wheel transaction target is the root scroll
                   // frame and is not scrollable on the x-axis, all delta is
                   // overflown and swipe-to-nav may occur.
                   wheelTransactionHandlesInput = true;
-                  allDeltaOverflown = !WheelHandlingUtils::CanScrollOn(
-                      scrollContainerFrame, wheelEvent->mDeltaX, 0.0);
-                } else if (WheelHandlingUtils::CanScrollOn(
-                               scrollContainerFrame, wheelEvent->mDeltaX,
-                               wheelEvent->mDeltaY)) {
+                  allDeltaOverflown = !WheelHandlingUtils::CanScrollOn(scrollContainerFrame,
+                                                                       wheelEvent->mDeltaX, 0.0);
+                } else if(WheelHandlingUtils::CanScrollOn(scrollContainerFrame,
+                                                          wheelEvent->mDeltaX,
+                                                          wheelEvent->mDeltaY)) {
                   // If the current wheel transaction target is not the root
                   // scroll frame, ensure that swipe to nav does not occur if
                   // the scroll frame is scrollable on the x or y axis. If the
@@ -5568,8 +5564,7 @@
 /* static */
 void EventStateManager::UpdateLastRefPointOfMouseEvent(
     WidgetMouseEvent* aMouseEvent) {
-  if (aMouseEvent->mMessage != ePointerRawUpdate &&
-      aMouseEvent->mMessage != eMouseMove &&
+  if (aMouseEvent->mMessage != eMouseMove &&
       aMouseEvent->mMessage != ePointerMove) {
     return;
   }
@@ -5602,8 +5597,7 @@
 void EventStateManager::ResetPointerToWindowCenterWhilePointerLocked(
     WidgetMouseEvent* aMouseEvent) {
   MOZ_ASSERT(PointerLockManager::IsLocked());
-  if ((aMouseEvent->mMessage != ePointerRawUpdate &&
-       aMouseEvent->mMessage != eMouseMove &&
+  if ((aMouseEvent->mMessage != eMouseMove &&
        aMouseEvent->mMessage != ePointerMove) ||
       !aMouseEvent->mWidget) {
     return;
@@ -5664,7 +5658,6 @@
   switch (aMouseEvent->mMessage) {
     case eMouseMove:
     case ePointerMove:
-    case ePointerRawUpdate:
     case ePointerDown:
     case ePointerGotCapture: {
       // Get the target content target (mousemove target == mouseover target)