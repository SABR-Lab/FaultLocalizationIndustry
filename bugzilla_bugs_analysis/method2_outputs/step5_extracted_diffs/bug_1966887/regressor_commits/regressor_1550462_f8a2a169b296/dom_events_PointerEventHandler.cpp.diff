# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/events/PointerEventHandler.cpp
# Commit: f8a2a169b296
# Full Hash: f8a2a169b2969d29e04733ae27a56459e5359973
# Author: Alexandru Marc <amarc@mozila.com>
# Date: 2025-05-16 09:19:19
# Regressor Bug: 1550462
# File Overlap Count: 1
# Description:
#   Revert "Bug 1550462 - part 3: Enable `pointerrawupdate` event r=smaug" for causing mochitest failures @ test_pointerrawupdate_event_count.html
#   
#   This reverts commit eb27445e0352d6b4df540adb40e21f72fc052e80.
#   
#   Revert "Bug 1550462 - part 2: Make `PresShell::HandleEvent` dispatch preceding `pointerrawupdate` event r=smaug,dom-core,edgar"
# ==============================================================================

diff -r 8d25773fc82f -r f8a2a169b296 dom/events/PointerEventHandler.cpp
--- a/dom/events/PointerEventHandler.cpp	Fri May 16 06:20:47 2025 +0000
+++ b/dom/events/PointerEventHandler.cpp	Fri May 16 09:30:09 2025 +0300
@@ -715,9 +715,7 @@
     WidgetPointerEvent& aPointerEvent, const WidgetTouchEvent& aTouchEvent,
     const mozilla::dom::Touch& aTouch) {
   // Use mButton/mButtons only when mButton got a value (from pen input)
-  int16_t button = aTouchEvent.mMessage == eTouchRawUpdate ||
-                           aTouchEvent.mMessage == eTouchMove
-                       ? MouseButton::eNotPressed
+  int16_t button = aTouchEvent.mMessage == eTouchMove ? MouseButton::eNotPressed
                    : aTouchEvent.mButton != MouseButton::eNotPressed
                        ? aTouchEvent.mButton
                        : MouseButton::ePrimary;
@@ -785,9 +783,6 @@
   MOZ_ASSERT(aMouseOrTouchEvent);
 
   switch (aMouseOrTouchEvent->mMessage) {
-    case eMouseRawUpdate:
-    case eTouchRawUpdate:
-      return ePointerRawUpdate;
     case eMouseMove:
       return ePointerMove;
     case eMouseUp:
@@ -815,15 +810,6 @@
 }
 
 /* static */
-bool PointerEventHandler::NeedToDispatchPointerRawUpdate(
-    const Document* aDocument) {
-  const nsPIDOMWindowInner* const innerWindow =
-      aDocument ? aDocument->GetInnerWindow() : nullptr;
-  return innerWindow && innerWindow->HasPointerRawUpdateEventListeners() &&
-         innerWindow->IsSecureContext();
-}
-
-/* static */
 void PointerEventHandler::DispatchPointerFromMouseOrTouch(
     PresShell* aShell, nsIFrame* aEventTargetFrame,
     nsIContent* aEventTargetContent, Element* aPointerCapturingElement,
@@ -852,8 +838,10 @@
     }
 
     // 1. If it is not mouse then it is likely will come as touch event
-    // 2. We don't synthesize pointer events for synthesized mouse move
-    if (!mouseEvent->convertToPointer || mouseEvent->IsSynthesized()) {
+    // 2. We don't synthesize pointer events for those events that are not
+    //    dispatched to DOM.
+    if (!mouseEvent->convertToPointer ||
+        !aMouseOrTouchEvent->IsAllowedToDispatchDOMEvent()) {
       return;
     }
 
@@ -861,30 +849,6 @@
     if (pointerMessage == eVoidEvent) {
       return;
     }
-#ifdef DEBUG
-    if (pointerMessage == ePointerRawUpdate) {
-      const nsIContent* const targetContent =
-          aEventTargetContent ? aEventTargetContent
-                              : aEventTargetFrame->GetContent();
-      NS_ASSERTION(targetContent, "Where do we want to try to dispatch?");
-      if (targetContent) {
-        NS_ASSERTION(
-            targetContent->IsInComposedDoc(),
-            nsPrintfCString("Do we want to dispatch ePointerRawUpdate onto "
-                            "disconnected content? (targetContent=%s)",
-                            ToString(*targetContent).c_str())
-                .get());
-        if (!NeedToDispatchPointerRawUpdate(targetContent->OwnerDoc())) {
-          NS_ASSERTION(
-              false,
-              nsPrintfCString(
-                  "Did we fail to retarget the document? (targetContent=%s)",
-                  ToString(*targetContent).c_str())
-                  .get());
-        }
-      }
-    }
-#endif  // #ifdef DEBUG
     WidgetPointerEvent event(*mouseEvent);
     InitPointerEventFromMouse(&event, mouseEvent, pointerMessage);
     event.convertToPointer = mouseEvent->convertToPointer = false;
@@ -963,7 +927,7 @@
         // all pointer events should be dispatched to the same target as their
         // corresponding touch events. Call PresShell::HandleEvent so that we do
         // hit test for pointer events.
-        // FIXME: If aDontRetargetEvents is false and the event is fired on
+        // FIXME: If aDontRetargetEvents is true and the event is fired on
         // different document, we cannot track the pointer event target when
         // it's removed from the tree.
         PreHandlePointerEventsPreventDefault(&event, aMouseOrTouchEvent);
@@ -1028,15 +992,9 @@
 bool PointerEventHandler::IsDragAndDropEnabled(WidgetMouseEvent& aEvent) {
   // We shouldn't start a drag session if the event is synthesized one because
   // aEvent doesn't have enough information for initializing the ePointerCancel.
-  if (aEvent.IsSynthesized()) {
+  if (!aEvent.IsReal()) {
     return false;
   }
-  // And we should not start with raw update events, which should be used only
-  // for notifying web apps of the pointer state changes ASAP.
-  if (aEvent.mMessage == ePointerRawUpdate) {
-    return false;
-  }
-  MOZ_ASSERT(aEvent.mMessage != eMouseRawUpdate);
 #ifdef XP_WIN
   if (StaticPrefs::dom_w3c_pointer_events_dispatch_by_pointer_messages()) {
     // WM_POINTER does not support drag and drop, see bug 1692277