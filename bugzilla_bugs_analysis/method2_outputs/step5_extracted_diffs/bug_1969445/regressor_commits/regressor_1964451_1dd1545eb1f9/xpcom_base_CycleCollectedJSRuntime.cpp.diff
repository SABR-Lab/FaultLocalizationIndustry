# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/base/CycleCollectedJSRuntime.cpp
# Commit: 1dd1545eb1f9
# Full Hash: 1dd1545eb1f90ae9a8845c735ca6f173fafbf5a4
# Author: Matthew Gaudet <mgaudet@mozilla.com>
# Date: 2025-05-27 16:03:10
# Regressor Bug: 1964451
# File Overlap Count: 1
# Description:
#   Bug 1964451 - Add use counters for OOM handling r=sfink,mccr8
#   
#   So the goal here is that we get OOM data where processes survive long enough
#   send telemetry. To get the case where processes -crash- we'll also have to
#   get crash data. See Bug 1964092 for that half.
# ==============================================================================

diff -r 1d7f4558293e -r 1dd1545eb1f9 xpcom/base/CycleCollectedJSRuntime.cpp
--- a/xpcom/base/CycleCollectedJSRuntime.cpp	Mon May 26 17:09:42 2025 +0000
+++ b/xpcom/base/CycleCollectedJSRuntime.cpp	Mon May 26 17:41:56 2025 +0000
@@ -1992,7 +1992,14 @@
 
 void CycleCollectedJSRuntime::AnnotateAndSetOutOfMemory(OOMState* aStatePtr,
                                                         OOMState aNewState) {
+  enum class Size { Large, Small };
+
+  Size size = aStatePtr == &mOutOfMemoryState ? Size::Small : Size::Large;
+  MOZ_ASSERT_IF(size == Size::Large,
+                aStatePtr == &mLargeAllocationFailureState);
+
   *aStatePtr = aNewState;
+
   CrashReporter::Annotation annotation =
       (aStatePtr == &mOutOfMemoryState)
           ? CrashReporter::Annotation::JSOutOfMemory
@@ -2000,6 +2007,35 @@
 
   CrashReporter::RecordAnnotationCString(annotation,
                                          OOMStateToString(aNewState));
+
+  // Attempt to report telemetry; this all needs to be as robust as possible
+  // since objects can be in a variety of states when this happens.
+  //
+  // We may not always collect telemetry, and that's got to be OK :)
+  CycleCollectedJSContext* ccjsContext = GetContext();
+  JSContext* jsContext = ccjsContext ? ccjsContext->Context() : nullptr;
+  JSObject* global = jsContext ? JS::CurrentGlobalOrNull(jsContext) : nullptr;
+  if (global) {
+    if (aNewState == OOMState::Recovered) {
+      switch (size) {
+        case Size::Large:
+          SetUseCounter(global, eUseCounter_custom_JS_large_oom_recovered);
+          break;
+        case Size::Small:
+          SetUseCounter(global, eUseCounter_custom_JS_small_oom_recovered);
+          break;
+      }
+    } else {
+      switch (size) {
+        case Size::Large:
+          SetUseCounter(global, eUseCounter_custom_JS_large_oom_reported);
+          break;
+        case Size::Small:
+          SetUseCounter(global, eUseCounter_custom_JS_small_oom_reported);
+          break;
+      }
+    }
+  }
 }
 
 void CycleCollectedJSRuntime::OnGC(JSContext* aContext, JSGCStatus aStatus,
