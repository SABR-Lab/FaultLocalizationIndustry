# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/TextDirectiveUtil.h
# Commit: 29735d438f26
# Full Hash: 29735d438f2634e2c6c1d8e80857bfb144d36483
# Author: Jan-Niklas Jaeschke <jjaschke@mozilla.com>
# Date: 2025-05-27 03:54:23
# Regressor Bug: 1957557
# File Overlap Count: 1
# Description:
#   Bug 1957557, part 7 - Create Text Fragments: Compute word boundary distances for context terms. r=dom-core,farre
#   
#   The distances are always in search direction:
#   For prefix and end terms, the positions are
#   relative to the end of the term and use the word
# ==============================================================================

diff -r 3c7adffd2377 -r 29735d438f26 dom/base/TextDirectiveUtil.h
--- a/dom/base/TextDirectiveUtil.h	Mon May 26 08:18:28 2025 +0000
+++ b/dom/base/TextDirectiveUtil.h	Mon May 26 08:18:28 2025 +0000
@@ -177,6 +177,23 @@
    */
   template <TextScanDirection direction>
   static RangeBoundary FindWordBoundary(const RangeBoundary& aRangeBoundary);
+
+  /**
+   * @brief Creates a list of all word boundary distances to the base of the
+   *        string (beginning for left-to-right, end for right-to-left).
+   *
+   * Word boundaries are determined by iterating the string and checking for
+   * word boundaries using the `intl::WordBreaker` algorithm.
+   *
+   * If direction is `Left`, word begin positions are used, and the distances
+   * are based off the end of the string. Otherwise, the word end positions are
+   * used, and the distances are based off the begin of the string.
+   * The returned array is always sorted and contains monotonically increasing
+   * values.
+   */
+  template <TextScanDirection direction>
+  static nsTArray<uint32_t> ComputeWordBoundaryDistances(
+      const nsAString& aString);
 };
 
 class TimeoutWatchdog final {
@@ -417,6 +434,37 @@
   return {node, offset};
 }
 
+template <TextScanDirection direction>
+/*static*/ nsTArray<uint32_t> TextDirectiveUtil::ComputeWordBoundaryDistances(
+    const nsAString& aString) {
+  // Limit the amount of words to look out for.
+  // If it's not possible to create a text directive because 32 words in _all_
+  // directions are equal, it's reasonable to say that it's not possible to
+  // create a text directive at all. Without this limit, this algorithm could
+  // blow up for extremely large text nodes, such as opening a text file with
+  // megabytes of text.
+  constexpr uint32_t kMaxWordCount = 32;
+  AutoTArray<uint32_t, kMaxWordCount> wordBoundaryDistances;
+  uint32_t pos = 0;
+  while (pos < aString.Length() &&
+         wordBoundaryDistances.Length() < kMaxWordCount) {
+    auto [wordBegin, wordEnd] = intl::WordBreaker::FindWord(aString, pos);
+    if constexpr (direction == TextScanDirection::Left) {
+      // If direction is right-to-left, the distances are relative to the end of
+      // the string, and the array is reversed. This way the distances are
+      // always monotonically increasing.
+      wordBoundaryDistances.AppendElement(aString.Length() - wordBegin);
+    } else {
+      wordBoundaryDistances.AppendElement(wordEnd);
+    }
+    pos = wordEnd + 1;
+  }
+  if constexpr (direction == TextScanDirection::Left) {
+    // Reverse the positions to align with the direction of the search algorithm
+    wordBoundaryDistances.Reverse();
+  }
+  return wordBoundaryDistances;
+}
 }  // namespace mozilla::dom
 
 #endif
