# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/TextDirectiveUtil.cpp
# Commit: 7fe19df9164a
# Full Hash: 7fe19df9164a567d72715409227852d091c697c0
# Author: Jan-Niklas Jaeschke <jjaschke@mozilla.com>
# Date: 2025-05-27 03:54:23
# Regressor Bug: 1957557
# File Overlap Count: 1
# Description:
#   Bug 1957557, part 2 - Create Text Fragments: Remove old implementation. r=dom-core,farre
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D246189
# ==============================================================================

diff -r a6c3b6c595c8 -r 7fe19df9164a dom/base/TextDirectiveUtil.cpp
--- a/dom/base/TextDirectiveUtil.cpp	Mon May 26 08:18:27 2025 +0000
+++ b/dom/base/TextDirectiveUtil.cpp	Mon May 26 08:18:27 2025 +0000
@@ -60,18 +60,6 @@
   return content;
 }
 
-/* static */ Result<nsString, ErrorResult>
-TextDirectiveUtil::RangeContentAsFoldCase(nsRange* aRange) {
-  Result<nsString, ErrorResult> contentResult = RangeContentAsString(aRange);
-  if (MOZ_UNLIKELY(contentResult.isErr())) {
-    return contentResult.propagateErr();
-  }
-  nsString content = contentResult.unwrap();
-  content.CompressWhitespace();
-  ToFoldedCase(content);
-  return content;
-}
-
 /* static */ bool TextDirectiveUtil::NodeIsVisibleTextNode(
     const nsINode& aNode) {
   const Text* text = Text::FromNode(aNode);
@@ -109,24 +97,6 @@
   return result;
 }
 
-/* static */ RangeBoundary TextDirectiveUtil::MoveRangeBoundaryOneWord(
-    const RangeBoundary& aRangeBoundary, TextScanDirection aDirection) {
-  MOZ_ASSERT(aRangeBoundary.IsSetAndValid());
-  PeekOffsetOptions options = {PeekOffsetOption::JumpLines,
-                               PeekOffsetOption::StopAtScroller,
-                               PeekOffsetOption::IsKeyboardSelect};
-  Result<RangeBoundary, nsresult> newBoundary =
-      SelectionMovementUtils::MoveRangeBoundaryToSomewhere(
-          aRangeBoundary,
-          aDirection == TextScanDirection::Left ? nsDirection::eDirPrevious
-                                                : nsDirection::eDirNext,
-          aDirection == TextScanDirection::Left ? CaretAssociationHint::Before
-                                                : CaretAssociationHint::After,
-          intl::BidiEmbeddingLevel::DefaultLTR(),
-          nsSelectionAmount::eSelectWord, options);
-  return newBoundary.unwrapOr({});
-}
-
 /* static */ bool TextDirectiveUtil::IsWhitespaceAtPosition(const Text* aText,
                                                             uint32_t aPos) {
   if (!aText || aText->Length() == 0 || aPos >= aText->Length()) {
@@ -221,37 +191,6 @@
   return false;
 }
 
-/* static */ bool TextDirectiveUtil::IsAtWordBoundary(const nsAString& aText,
-                                                      uint32_t aPosition) {
-  const intl::WordRange wordRange =
-      intl::WordBreaker::FindWord(aText, aPosition);
-  return wordRange.mBegin == aPosition || wordRange.mEnd == aPosition;
-}
-
-/* static */ RangeBoundary TextDirectiveUtil::GetBoundaryPointAtIndex(
-    uint32_t aIndex, const nsTArray<RefPtr<Text>>& aTextNodeList,
-    IsEndIndex aIsEndIndex) {
-  // 1. Let counted be 0.
-  uint32_t counted = 0;
-  // 2. For each curNode of nodes:
-  for (Text* curNode : aTextNodeList) {
-    // 2.1. Let nodeEnd be counted + curNode’s length.
-    uint32_t nodeEnd = counted + curNode->Length();
-    // 2.2. If isEnd is true, add 1 to nodeEnd.
-    if (aIsEndIndex == IsEndIndex::Yes) {
-      ++nodeEnd;
-    }
-    // 2.3. If nodeEnd is greater than index then:
-    if (nodeEnd > aIndex) {
-      // 2.3.1. Return the boundary point (curNode, index − counted).
-      return RangeBoundary(curNode->AsNode(), aIndex - counted);
-    }
-    // 2.4. Increment counted by curNode’s length.
-    counted += curNode->Length();
-  }
-  return {};
-}
-
 /* static */ void TextDirectiveUtil::AdvanceStartToNextNonWhitespacePosition(
     nsRange& aRange) {
   // 1. While range is not collapsed:
@@ -315,74 +254,6 @@
   return {node, pos};
 }
 
-/* static */ RangeBoundary
-TextDirectiveUtil::MoveBoundaryToNextNonWhitespacePosition(
-    const RangeBoundary& aRangeBoundary) {
-  MOZ_ASSERT(aRangeBoundary.IsSetAndValid());
-  nsINode* node = aRangeBoundary.GetContainer();
-  uint32_t offset =
-      *aRangeBoundary.Offset(RangeBoundary::OffsetFilter::kValidOffsets);
-  while (node) {
-    if (TextDirectiveUtil::NodeIsPartOfNonSearchableSubTree(*node) ||
-        !TextDirectiveUtil::NodeIsVisibleTextNode(*node) ||
-        offset == node->Length()) {
-      nsINode* newNode = node->GetNextNode();
-      if (!newNode) {
-        // jjaschke: I don't see a situation where this could happen. However,
-        // let's return the original range boundary as fallback.
-        return aRangeBoundary;
-      }
-      node = newNode;
-      offset = 0;
-      continue;
-    }
-    const Text* text = Text::FromNode(node);
-    MOZ_ASSERT(text);
-    if (TextDirectiveUtil::IsWhitespaceAtPosition(text, offset)) {
-      ++offset;
-      continue;
-    }
-    return {node, offset};
-  }
-  MOZ_ASSERT_UNREACHABLE("All code paths must return in the loop.");
-  return {};
-}
-
-/* static */ RangeBoundary
-TextDirectiveUtil::MoveBoundaryToPreviousNonWhitespacePosition(
-    const RangeBoundary& aRangeBoundary) {
-  MOZ_ASSERT(aRangeBoundary.IsSetAndValid());
-  nsINode* node = aRangeBoundary.GetContainer();
-  uint32_t offset =
-      *aRangeBoundary.Offset(RangeBoundary::OffsetFilter::kValidOffsets);
-  // Decrement offset by one so that the actual previous character is used. This
-  // means that we need to increment the offset by 1 when we have found the
-  // non-whitespace character.
-  while (node) {
-    if (TextDirectiveUtil::NodeIsPartOfNonSearchableSubTree(*node) ||
-        !TextDirectiveUtil::NodeIsVisibleTextNode(*node) || offset == 0) {
-      nsIContent* newNode = node->GetPrevNode();
-      if (!newNode) {
-        // jjaschke: I don't see a situation where this could happen. However,
-        // let's return the original range boundary as fallback.
-        return aRangeBoundary;
-      }
-      node = newNode;
-      offset = node->Length();
-      continue;
-    }
-    const Text* text = Text::FromNode(node);
-    MOZ_ASSERT(text);
-    if (TextDirectiveUtil::IsWhitespaceAtPosition(text, offset - 1)) {
-      --offset;
-      continue;
-    }
-    return {node, offset};
-  }
-  MOZ_ASSERT_UNREACHABLE("All code paths must return in the loop.");
-  return {};
-}
-
 /* static */ Result<RangeBoundary, ErrorResult>
 TextDirectiveUtil::FindNextBlockBoundary(const RangeBoundary& aRangeBoundary,
                                          TextScanDirection aDirection) {
@@ -420,45 +291,6 @@
   return newBoundary;
 }
 
-/* static */ Result<Maybe<RangeBoundary>, ErrorResult>
-TextDirectiveUtil::FindBlockBoundaryInRange(const nsRange& aRange,
-                                            TextScanDirection aDirection) {
-  if (aRange.Collapsed()) {
-    return Result<Maybe<RangeBoundary>, ErrorResult>(Nothing{});
-  }
-  if (aDirection == TextScanDirection::Right) {
-    Result<RangeBoundary, ErrorResult> maybeBoundary =
-        FindNextBlockBoundary(aRange.StartRef(), TextScanDirection::Right);
-    if (MOZ_UNLIKELY(maybeBoundary.isErr())) {
-      return maybeBoundary.propagateErr();
-    }
-    RangeBoundary boundary = maybeBoundary.unwrap();
-
-    Maybe<int32_t> compare =
-        nsContentUtils::ComparePoints(boundary, aRange.EndRef());
-    if (!compare || *compare != -1) {
-      // *compare == -1 means that the found block boundary is after the range
-      // end, and therefore outside of the range.
-      return Result<Maybe<RangeBoundary>, ErrorResult>(Nothing{});
-    }
-
-    return Some(boundary);
-  }
-  Result<RangeBoundary, ErrorResult> maybeBoundary =
-      FindNextBlockBoundary(aRange.EndRef(), TextScanDirection::Left);
-  if (MOZ_UNLIKELY(maybeBoundary.isErr())) {
-    return maybeBoundary.propagateErr();
-  }
-  RangeBoundary boundary = maybeBoundary.unwrap();
-  auto compare = nsContentUtils::ComparePoints(aRange.StartRef(), boundary);
-  if (!compare || *compare != -1) {
-    // *compare == 1 means that the found block boundary is before the range
-    // start boundary, and therefore outside of the range.
-    return Result<Maybe<RangeBoundary>, ErrorResult>(Nothing{});
-  }
-  return Some(boundary);
-}
-
 /* static */ bool TextDirectiveUtil::NormalizedRangeBoundariesAreEqual(
     const RangeBoundary& aRangeBoundary1, const RangeBoundary& aRangeBoundary2,
     nsContentUtils::NodeIndexCache* aCache /* = nullptr */) {
@@ -563,214 +395,4 @@
   return true;
 }
 
-/* static */ Result<Ok, ErrorResult>
-TextDirectiveUtil::ExtendRangeToWordBoundaries(nsRange& aRange) {
-  MOZ_ASSERT(!aRange.Collapsed());
-  PeekOffsetOptions options = {
-      PeekOffsetOption::JumpLines, PeekOffsetOption::StopAtScroller,
-      PeekOffsetOption::IsKeyboardSelect, PeekOffsetOption::Extend};
-  // To extend a range `inputRange` to its word boundaries, perform these steps:
-  // 1. To extend the start boundary:
-  // 1.1 Let `newStartBoundary` be a range boundary, initially null.
-  // 1.2 Create a new range boundary `rangeStartWordEndBoundary` at the next
-  //    word end boundary at `inputRange`s start point.
-  // 1.3 Then, create a new range boundary `rangeStartWordStartBoundary`
-  //     at the previous word start boundary of `rangeStartWordEndBoundary`
-  // 1.4 If `rangeStartWordStartBoundary` is not at the same (normalized)
-  //     position as `inputRange`s start point, let `newStartBoundary` be
-  //     `rangeStartWordStartBoundary`.
-  Result<Maybe<RangeBoundary>, ErrorResult> newStartBoundary =
-      SelectionMovementUtils::MoveRangeBoundaryToSomewhere(
-          aRange.StartRef(), nsDirection::eDirNext, CaretAssociationHint::After,
-          intl::BidiEmbeddingLevel::DefaultLTR(),
-          nsSelectionAmount::eSelectWord, options)
-          .andThen([&options](const RangeBoundary& rangeStartWordEndBoundary) {
-            return SelectionMovementUtils::MoveRangeBoundaryToSomewhere(
-                rangeStartWordEndBoundary, nsDirection::eDirPrevious,
-                CaretAssociationHint::Before,
-                intl::BidiEmbeddingLevel::DefaultLTR(),
-                nsSelectionAmount::eSelectWord, options);
-          })
-          .map([&rangeStart = aRange.StartRef()](
-                   RangeBoundary&& rangeStartWordStartBoundary) {
-            return NormalizedRangeBoundariesAreEqual(
-                       rangeStartWordStartBoundary, rangeStart)
-                       ? Nothing{}
-                       : Some(std::move(rangeStartWordStartBoundary));
-          })
-          .mapErr([](nsresult rv) { return ErrorResult(rv); });
-  if (MOZ_UNLIKELY(newStartBoundary.isErr())) {
-    return newStartBoundary.propagateErr();
-  }
-
-  // 2. To extend the end boundary:
-  // 2.1 Let `newEndBoundary` be a range boundary, initially null.
-  // 2.2 Create a new range boundary `rangeEndWordStartBoundary` at the previous
-  //     word start boundary at `inputRange`s end point.
-  // 2.3 Then, create a new range boundary `rangeEndWordEndBoundary` at the next
-  //     word end boundary from `rangeEndWordStartBoundary`.
-  // 2.4 If `rangeEndWordEndBoundary` is not at the same (normalized) position
-  //     as  `inputRange`s end point, let `newEndBoundary` be
-  //     `rangEndWordEndBoundary`.
-  Result<Maybe<RangeBoundary>, ErrorResult> newEndBoundary =
-      SelectionMovementUtils::MoveRangeBoundaryToSomewhere(
-          aRange.EndRef(), nsDirection::eDirPrevious,
-          CaretAssociationHint::Before, intl::BidiEmbeddingLevel::DefaultLTR(),
-          nsSelectionAmount::eSelectWord, options)
-          .andThen([&options](const RangeBoundary& rangeEndWordStartBoundary) {
-            return SelectionMovementUtils::MoveRangeBoundaryToSomewhere(
-                rangeEndWordStartBoundary, nsDirection::eDirNext,
-                CaretAssociationHint::After,
-                intl::BidiEmbeddingLevel::DefaultLTR(),
-                nsSelectionAmount::eSelectWord, options);
-          })
-          .map([&rangeEnd =
-                    aRange.EndRef()](RangeBoundary&& rangeEndWordEndBoundary) {
-            return NormalizedRangeBoundariesAreEqual(rangeEndWordEndBoundary,
-                                                     rangeEnd)
-                       ? Nothing{}
-                       : Some(std::move(rangeEndWordEndBoundary));
-          })
-          .mapErr([](auto rv) { return ErrorResult(rv); });
-  if (MOZ_UNLIKELY(newEndBoundary.isErr())) {
-    return newEndBoundary.propagateErr();
-  }
-  // 3. If `newStartBoundary` is not null, set `inputRange`s start point to
-  //    `newStartBoundary`.
-  MOZ_TRY(newStartBoundary.andThen(
-      [&aRange](Maybe<RangeBoundary>&& boundary) -> Result<Ok, ErrorResult> {
-        if (boundary.isNothing() || !boundary->IsSetAndValid()) {
-          return Ok();
-        }
-        ErrorResult rv;
-        aRange.SetStart(boundary->AsRaw(), rv);
-        if (MOZ_UNLIKELY(rv.Failed())) {
-          return Err(std::move(rv));
-        }
-        return Ok();
-      }));
-  // 4. If `newEndBoundary` is not null, set `inputRange`s end point to
-  //    `newEndBoundary`.
-  MOZ_TRY(newEndBoundary.andThen(
-      [&aRange](Maybe<RangeBoundary>&& boundary) -> Result<Ok, ErrorResult> {
-        if (boundary.isNothing() || !boundary->IsSetAndValid()) {
-          return Ok();
-        }
-        ErrorResult rv;
-        aRange.SetEnd(boundary->AsRaw(), rv);
-        if (MOZ_UNLIKELY(rv.Failed())) {
-          return Err(std::move(rv));
-        }
-        return Ok();
-      }));
-
-  return Ok();
-}
-
-/* static */
-Result<TextDirective, ErrorResult>
-TextDirectiveUtil::CreateTextDirectiveFromRanges(nsRange* aPrefix,
-                                                 nsRange* aStart, nsRange* aEnd,
-                                                 nsRange* aSuffix) {
-  MOZ_ASSERT(aStart && !aStart->Collapsed());
-
-  ErrorResult rv;
-  TextDirective textDirective;
-  MOZ_TRY(RangeContentAsString(aStart).andThen(
-      [&textDirective](nsString start) -> Result<Ok, ErrorResult> {
-        textDirective.start = std::move(start);
-        return Ok();
-      }));
-  MOZ_TRY(RangeContentAsString(aPrefix).andThen(
-      [&textDirective](nsString prefix) -> Result<Ok, ErrorResult> {
-        textDirective.prefix = std::move(prefix);
-        return Ok();
-      }));
-  MOZ_TRY(RangeContentAsString(aEnd).andThen(
-      [&textDirective](nsString end) -> Result<Ok, ErrorResult> {
-        textDirective.end = std::move(end);
-        return Ok();
-      }));
-  MOZ_TRY(RangeContentAsString(aSuffix).andThen(
-      [&textDirective](nsString suffix) -> Result<Ok, ErrorResult> {
-        textDirective.suffix = std::move(suffix);
-        return Ok();
-      }));
-  return textDirective;
-}
-
-uint32_t TextDirectiveUtil::FindCommonPrefix(const nsAString& aFoldedStr1,
-                                             const nsAString& aFoldedStr2) {
-  const uint32_t maxCommonLength =
-      std::min(aFoldedStr1.Length(), aFoldedStr2.Length());
-  uint32_t commonLength = 0;
-  const char16_t* iter1 = aFoldedStr1.BeginReading();
-  const char16_t* iter2 = aFoldedStr2.BeginReading();
-
-  while (commonLength < maxCommonLength) {
-    if (*iter1 != *iter2) {
-      break;
-    }
-    ++iter1;
-    ++iter2;
-    ++commonLength;
-  }
-  // this condition ensures that if the high surrogate is removed if the low
-  // surrogate does not match.
-  if (commonLength && NS_IS_HIGH_SURROGATE(*(iter1 - 1))) {
-    --commonLength;
-  }
-  return commonLength;
-}
-
-uint32_t TextDirectiveUtil::FindCommonSuffix(const nsAString& aFoldedStr1,
-                                             const nsAString& aFoldedStr2) {
-  const uint32_t maxCommonLength =
-      std::min(aFoldedStr1.Length(), aFoldedStr2.Length());
-  uint32_t commonLength = 0;
-  const char16_t* iter1 = aFoldedStr1.EndReading();
-  const char16_t* iter2 = aFoldedStr2.EndReading();
-  while (commonLength != maxCommonLength) {
-    if (*(iter1 - 1) != *(iter2 - 1)) {
-      break;
-    }
-    --iter1;
-    --iter2;
-    ++commonLength;
-  }
-  // this condition ensures that a matching low surrogate is removed if the high
-  // surrogate does not match.
-  if (commonLength && NS_IS_LOW_SURROGATE(*iter1)) {
-    --commonLength;
-  }
-  return commonLength;
-}
-
-RangeBoundary
-TextDirectiveUtil::CreateRangeBoundaryByMovingOffsetFromRangeStart(
-    nsRange* aRange, uint32_t aLogicalOffset) {
-  MOZ_ASSERT(!aRange->Collapsed());
-
-  nsINode* node = aRange->GetStartContainer();
-  uint32_t startOffset = aRange->StartOffset();
-
-  uint32_t remaining = startOffset + aLogicalOffset;
-  while (node && remaining) {
-    if (NodeIsPartOfNonSearchableSubTree(*node) ||
-        !NodeIsVisibleTextNode(*node)) {
-      node = node->GetNextNode();
-      continue;
-    }
-    MOZ_ASSERT_IF(node == aRange->GetEndContainer(),
-                  remaining <= node->Length());
-    if (node->Length() <= remaining) {
-      remaining -= node->Length();
-      node = node->GetNextNode();
-      continue;
-    }
-    return {node, remaining};
-  }
-  return {node, remaining};
-}
-
 }  // namespace mozilla::dom