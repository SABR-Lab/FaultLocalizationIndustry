# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/ActorsParent.cpp
# Commit: 27b1f7f62a00
# Full Hash: 27b1f7f62a00d003b61e7d3265ec1c7587f221fa
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2025-06-11 18:38:51
# Regressor Bug: 1962133
# File Overlap Count: 10
# Description:
#   Bug 1962133 - QM: Introduce OriginStateMetadata struct for origin metadata header; r=dom-storage-reviewers,hsingh
#   
#   This patch introduces a new OriginStateMetadata struct to represent origin
#   state separately from the other OriginMetadata fields. This prepares the origin
#   metadata loading and saving code for adding a new field like the accessed flag.
# ==============================================================================

diff -r 2d9e785ad3e5 -r 27b1f7f62a00 dom/quota/ActorsParent.cpp
--- a/dom/quota/ActorsParent.cpp	Wed Jun 11 07:39:03 2025 +0000
+++ b/dom/quota/ActorsParent.cpp	Wed Jun 11 07:47:39 2025 +0000
@@ -3421,8 +3421,8 @@
     // since we lack atomic support for creating the origin directory along
     // with its metadata, we need to add the origin to cached origins right
     // after directory creation.
-    AddTemporaryOrigin(
-        FullOriginMetadata{aOriginMetadata, persisted, timestamp});
+    AddTemporaryOrigin(FullOriginMetadata{
+        aOriginMetadata, OriginStateMetadata{timestamp, persisted}});
 
     QM_TRY(MOZ_TO_RESULT(CreateDirectoryMetadata2(*directory, timestamp,
                                                   persisted, aOriginMetadata)));
@@ -4158,7 +4158,8 @@
     QM_TRY(OkIf(usage.isValid()), NS_ERROR_FAILURE);
 
     InitQuotaForOrigin(
-        FullOriginMetadata{aOriginMetadata, aPersisted, aAccessTime},
+        FullOriginMetadata{aOriginMetadata,
+                           OriginStateMetadata{aAccessTime, aPersisted}},
         clientUsages, usage.value());
   }
 
@@ -6290,10 +6291,12 @@
     if (!aCreateIfNonExistent) {
       const int64_t timestamp = PR_Now();
 
-      InitQuotaForOrigin(FullOriginMetadata{aOriginMetadata,
-                                            /* aPersisted */ false, timestamp},
-                         ClientUsageArray(), /* aUsageBytes */ 0,
-                         /* aDirectoryExists */ false);
+      InitQuotaForOrigin(
+          FullOriginMetadata{
+              aOriginMetadata,
+              OriginStateMetadata{timestamp, /* aPersisted */ false}},
+          ClientUsageArray(), /* aUsageBytes */ 0,
+          /* aDirectoryExists */ false);
 
       return std::pair(std::move(directory), false);
     }
@@ -6303,9 +6306,9 @@
     if (created) {
       const int64_t timestamp = PR_Now();
 
-      FullOriginMetadata fullOriginMetadata =
-          FullOriginMetadata{aOriginMetadata,
-                             /* aPersisted */ false, timestamp};
+      FullOriginMetadata fullOriginMetadata = FullOriginMetadata{
+          aOriginMetadata,
+          OriginStateMetadata{timestamp, /* aPersisted */ false}};
 
       // Usually, infallible operations are placed after fallible ones.
       // However, since we lack atomic support for creating the origin
@@ -7230,6 +7233,23 @@
                             std::max<uint64_t>(x, 10 MB));
 }
 
+Maybe<OriginStateMetadata> QuotaManager::GetOriginStateMetadata(
+    const OriginMetadata& aOriginMetadata) {
+  AssertIsOnIOThread();
+  MOZ_DIAGNOSTIC_ASSERT(mStorageConnection);
+  MOZ_DIAGNOSTIC_ASSERT(mTemporaryStorageInitializedInternal);
+
+  MutexAutoLock lock(mQuotaMutex);
+
+  RefPtr<OriginInfo> originInfo =
+      LockedGetOriginInfo(aOriginMetadata.mPersistenceType, aOriginMetadata);
+  if (originInfo) {
+    return Some(originInfo->LockedFlattenToOriginStateMetadata());
+  }
+
+  return Nothing();
+}
+
 std::pair<uint64_t, uint64_t> QuotaManager::GetUsageAndLimitForEstimate(
     const OriginMetadata& aOriginMetadata) {
   AssertIsOnIOThread();