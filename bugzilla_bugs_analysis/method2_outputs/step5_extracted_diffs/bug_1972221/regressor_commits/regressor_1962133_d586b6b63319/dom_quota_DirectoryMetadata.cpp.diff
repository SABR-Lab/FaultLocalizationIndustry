# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/DirectoryMetadata.cpp
# Commit: d586b6b63319
# Full Hash: d586b6b633191a7c6ff251361b0442d98d06c764
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2025-06-15 09:03:40
# Regressor Bug: 1962133
# File Overlap Count: 14
# Description:
#   Bug 1962133 - QM: Add accessed flag to FullOriginMetadata and persist it in the origin metadata file; r=dom-storage-reviewers,hsingh
#   
#   This patch introduces a new mAccessed field in OriginStateMetadata, which is
#   inherited by FullOriginMetadata. One of the reserved 32-bit fields in the
#   metadata header is now used as a bitfield, with one bit allocated to represent
# ==============================================================================

diff -r ca3bdda9fbfd -r d586b6b63319 dom/quota/DirectoryMetadata.cpp
--- a/dom/quota/DirectoryMetadata.cpp	Sat Jun 14 02:29:19 2025 +0000
+++ b/dom/quota/DirectoryMetadata.cpp	Sat Jun 14 02:46:33 2025 +0000
@@ -7,6 +7,7 @@
 #include "DirectoryMetadata.h"
 
 #include "mozilla/Result.h"
+#include "mozilla/TypedEnumBits.h"
 #include "mozilla/dom/quota/Assertions.h"
 #include "mozilla/dom/quota/CommonMetadata.h"
 #include "mozilla/dom/quota/QuotaCommon.h"
@@ -17,6 +18,18 @@
 
 namespace mozilla::dom::quota {
 
+// clang-format off
+
+enum class DirectoryMetadataFlags : uint32_t {
+  None        = 0,
+  Initialized = 1 << 0,
+  Accessed    = 1 << 1,
+};
+
+// clang-format on
+
+MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(DirectoryMetadataFlags)
+
 Result<OriginStateMetadata, nsresult> ReadDirectoryMetadataHeader(
     nsIBinaryInputStream& aStream) {
   AssertIsOnIOThread();
@@ -29,11 +42,18 @@
   QM_TRY_UNWRAP(originStateMetadata.mPersisted,
                 MOZ_TO_RESULT_INVOKE_MEMBER(aStream, ReadBoolean));
 
-  QM_TRY_INSPECT(const bool& reservedData1,
+  QM_TRY_INSPECT(const uint32_t& rawFlags,
                  MOZ_TO_RESULT_INVOKE_MEMBER(aStream, Read32));
-  if (reservedData1 != 0) {
-    QM_TRY(MOZ_TO_RESULT(false));
-  }
+
+  auto flags = static_cast<DirectoryMetadataFlags>(rawFlags);
+
+  // If DirectoryMetadataFlags::Initialized is not set, the flags field
+  // contains no valid data. Since mAccessed indicates whether a full scan must
+  // be done during initialization, we conservatively set it to true when the
+  // access state is unknown.
+  originStateMetadata.mAccessed =
+      rawFlags == 0 || (flags & DirectoryMetadataFlags::Accessed) !=
+                           DirectoryMetadataFlags::None;
 
   // XXX Use for the persistence type.
   QM_TRY_INSPECT(const bool& reservedData2,
@@ -52,10 +72,19 @@
 
   QM_TRY(MOZ_TO_RESULT(aStream.WriteBoolean(aOriginStateMetadata.mPersisted)));
 
-  // Reserved data 1
-  QM_TRY(MOZ_TO_RESULT(aStream.Write32(0)));
+  // Always set DirectoryMetadataFlags::Initialized when writing new metadata,
+  // to mark the flags field as valid. This distinguishes real flags from older
+  // files where the field was reserved and always written as zero.
+  auto flags =
+      DirectoryMetadataFlags::Initialized |
+      (aOriginStateMetadata.mAccessed ? DirectoryMetadataFlags::Accessed
+                                      : DirectoryMetadataFlags::None);
 
-  // Reserved data 2
+  auto rawFlags = static_cast<uint32_t>(flags);
+
+  QM_TRY(MOZ_TO_RESULT(aStream.Write32(rawFlags)));
+
+  // Reserved data
   QM_TRY(MOZ_TO_RESULT(aStream.Write32(0)));
 
   return NS_OK;