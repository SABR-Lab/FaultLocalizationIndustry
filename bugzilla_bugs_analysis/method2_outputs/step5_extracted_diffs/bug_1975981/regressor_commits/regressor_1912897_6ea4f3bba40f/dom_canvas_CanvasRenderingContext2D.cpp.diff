# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/CanvasRenderingContext2D.cpp
# Commit: 6ea4f3bba40f
# Full Hash: 6ea4f3bba40f2fdf5c4893e0eb76fee7d4e05094
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2025-07-05 09:22:06
# Regressor Bug: 1912897
# File Overlap Count: 1
# Description:
#   Bug 1912897 - Support blurring and shadows for Accelerated Canvas2D. r=aosmond
#   
#   This adds support via FilterNodeWebgl for accelerating specific filters in AC2D.
#   In particular, it adds support for accelerated blurring using a separable blur
#   filter. This is then used to implement the Gaussian Blur filter as well as shadows.
# ==============================================================================

diff -r c6d00b59234d -r 6ea4f3bba40f dom/canvas/CanvasRenderingContext2D.cpp
--- a/dom/canvas/CanvasRenderingContext2D.cpp	Sat Jul 05 00:10:54 2025 +0000
+++ b/dom/canvas/CanvasRenderingContext2D.cpp	Sat Jul 05 04:41:59 2025 +0000
@@ -96,6 +96,7 @@
 #include "mozilla/gfx/Tools.h"
 #include "mozilla/gfx/PathHelpers.h"
 #include "mozilla/gfx/DataSurfaceHelpers.h"
+#include "mozilla/gfx/Filters.h"
 #include "mozilla/gfx/PatternHelpers.h"
 #include "mozilla/gfx/Swizzle.h"
 #include "mozilla/layers/ImageBridgeChild.h"
@@ -354,12 +355,14 @@
                           const gfx::IntPoint& aFilterSpaceToTargetOffset,
                           const gfx::IntRect& aPreFilterBounds,
                           const gfx::IntRect& aPostFilterBounds,
-                          gfx::CompositionOp aCompositionOp)
+                          gfx::CompositionOp aCompositionOp,
+                          bool aAllowOptimization = false)
       : mFinalTarget(aFinalTarget),
         mCtx(aCtx),
         mPostFilterBounds(aPostFilterBounds),
         mOffset(aFilterSpaceToTargetOffset),
-        mCompositionOp(aCompositionOp) {
+        mCompositionOp(aCompositionOp),
+        mAllowOptimization(aAllowOptimization) {
     nsIntRegion sourceGraphicNeededRegion;
     nsIntRegion fillPaintNeededRegion;
     nsIntRegion strokePaintNeededRegion;
@@ -382,6 +385,10 @@
       mSourceGraphicRect.SizeTo(1, 1);
     }
 
+    if (mAllowOptimization) {
+      return;
+    }
+
     if (!mFinalTarget->CanCreateSimilarDrawTarget(mSourceGraphicRect.Size(),
                                                   SurfaceFormat::B8G8R8A8)) {
       mTarget = mFinalTarget;
@@ -411,13 +418,107 @@
         -mSourceGraphicRect.TopLeft() + mOffset));
   }
 
+  void Fill(const Path* aPath, const Pattern& aPattern,
+            const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      mDeferInput = mFinalTarget->DeferFilterInput(
+          aPath, aPattern, mSourceGraphicRect, mOffset, aOptions);
+    } else {
+      mTarget->Fill(aPath, aPattern, aOptions);
+    }
+  }
+
+  void FillRect(const Rect& aRect, const Pattern& aPattern,
+                const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      RefPtr<Path> path = MakePathForRect(*mFinalTarget, aRect);
+      mDeferInput = mFinalTarget->DeferFilterInput(
+          path, aPattern, mSourceGraphicRect, mOffset, aOptions);
+    } else {
+      mTarget->FillRect(aRect, aPattern, aOptions);
+    }
+  }
+
+  void Stroke(const Path* aPath, const Pattern& aPattern,
+              const StrokeOptions& aStrokeOptions,
+              const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      mDeferInput =
+          mFinalTarget->DeferFilterInput(aPath, aPattern, mSourceGraphicRect,
+                                         mOffset, aOptions, &aStrokeOptions);
+    } else {
+      mTarget->Stroke(aPath, aPattern, aStrokeOptions, aOptions);
+    }
+  }
+
+  void StrokeRect(const Rect& aRect, const Pattern& aPattern,
+                  const StrokeOptions& aStrokeOptions,
+                  const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      RefPtr<Path> path = MakePathForRect(*mFinalTarget, aRect);
+      mDeferInput =
+          mFinalTarget->DeferFilterInput(path, aPattern, mSourceGraphicRect,
+                                         mOffset, aOptions, &aStrokeOptions);
+    } else {
+      mTarget->StrokeRect(aRect, aPattern, aStrokeOptions, aOptions);
+    }
+  }
+
+  void StrokeLine(const Point& aStart, const Point& aEnd,
+                  const Pattern& aPattern, const StrokeOptions& aStrokeOptions,
+                  const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      RefPtr<PathBuilder> builder = mFinalTarget->CreatePathBuilder();
+      builder->MoveTo(aStart);
+      builder->LineTo(aEnd);
+      RefPtr<Path> path = builder->Finish();
+      mDeferInput =
+          mFinalTarget->DeferFilterInput(path, aPattern, mSourceGraphicRect,
+                                         mOffset, aOptions, &aStrokeOptions);
+    } else {
+      mTarget->StrokeLine(aStart, aEnd, aPattern, aStrokeOptions, aOptions);
+    }
+  }
+
+  void DrawSurface(SourceSurface* aSurface, const Rect& aDest,
+                   const Rect& aSource, const DrawSurfaceOptions& aSurfOptions,
+                   const DrawOptions& aOptions) {
+    if (mAllowOptimization) {
+      RefPtr<Path> path = MakePathForRect(*mFinalTarget, aSource);
+      SurfacePattern pattern(aSurface, ExtendMode::CLAMP, Matrix(),
+                             aSurfOptions.mSamplingFilter);
+      Matrix matrix = Matrix::Scaling(aDest.width / aSource.width,
+                                      aDest.height / aSource.height);
+      matrix.PreTranslate(-aSource.x, -aSource.y);
+      matrix.PostTranslate(aDest.x, aDest.y);
+      AutoRestoreTransform autoRestoreTransform(mFinalTarget);
+      mFinalTarget->ConcatTransform(matrix);
+      mDeferInput = mFinalTarget->DeferFilterInput(
+          path, pattern, mSourceGraphicRect, mOffset, aOptions);
+    } else {
+      mTarget->DrawSurface(aSurface, aDest, aSource, aSurfOptions, aOptions);
+    }
+  }
+
   // Return a SourceSurface that contains the FillPaint or StrokePaint source.
-  already_AddRefed<SourceSurface> DoSourcePaint(
+  already_AddRefed<FilterNode> DoSourcePaint(
       gfx::IntRect& aRect, CanvasRenderingContext2D::Style aStyle) {
     if (aRect.IsEmpty()) {
       return nullptr;
     }
 
+    if (mAllowOptimization) {
+      Matrix transform = mFinalTarget->GetTransform();
+      RefPtr<Path> path =
+          transform.Invert()
+              ? MakePathForRect(*mFinalTarget, transform.TransformBounds(
+                                                   Rect(aRect - mOffset)))
+              : MakeEmptyPath(*mFinalTarget);
+      return mFinalTarget->DeferFilterInput(
+          path, CanvasGeneralPattern().ForStyle(mCtx, aStyle, mFinalTarget),
+          aRect, mOffset);
+    }
+
     RefPtr<DrawTarget> dt = mFinalTarget->CreateSimilarDrawTarget(
         aRect.Size(), SurfaceFormat::B8G8R8A8);
 
@@ -441,7 +542,13 @@
       gfx::Rect fillRect = transform.TransformBounds(dtBounds);
       dt->FillRect(fillRect, CanvasGeneralPattern().ForStyle(mCtx, aStyle, dt));
     }
-    return dt->Snapshot();
+
+    RefPtr<SourceSurface> snapshot = dt->Snapshot();
+    if (!snapshot) {
+      return nullptr;
+    }
+
+    return FilterWrappers::ForSurface(mFinalTarget, snapshot, aRect.TopLeft());
   }
 
   ~AdjustedTargetForFilter() {
@@ -449,11 +556,16 @@
       return;
     }
 
-    RefPtr<SourceSurface> snapshot = mTarget->Snapshot();
-
-    RefPtr<SourceSurface> fillPaint =
+    RefPtr<FilterNode> sourceGraphic;
+    if (mAllowOptimization) {
+      sourceGraphic = mDeferInput;
+    } else if (RefPtr<SourceSurface> snapshot = mTarget->Snapshot()) {
+      sourceGraphic = FilterWrappers::ForSurface(mFinalTarget, snapshot,
+                                                 mSourceGraphicRect.TopLeft());
+    }
+    RefPtr<FilterNode> fillPaint =
         DoSourcePaint(mFillPaintRect, CanvasRenderingContext2D::Style::FILL);
-    RefPtr<SourceSurface> strokePaint = DoSourcePaint(
+    RefPtr<FilterNode> strokePaint = DoSourcePaint(
         mStrokePaintRect, CanvasRenderingContext2D::Style::STROKE);
 
     AutoRestoreTransform autoRestoreTransform(mFinalTarget);
@@ -462,8 +574,9 @@
     MOZ_RELEASE_ASSERT(!mCtx->CurrentState().filter.mPrimitives.IsEmpty());
     gfx::FilterSupport::RenderFilterDescription(
         mFinalTarget, mCtx->CurrentState().filter, gfx::Rect(mPostFilterBounds),
-        snapshot, mSourceGraphicRect, fillPaint, mFillPaintRect, strokePaint,
-        mStrokePaintRect, mCtx->CurrentState().filterAdditionalImages,
+        std::move(sourceGraphic), mSourceGraphicRect, std::move(fillPaint),
+        mFillPaintRect, std::move(strokePaint), mStrokePaintRect,
+        mCtx->CurrentState().filterAdditionalImages,
         mPostFilterBounds.TopLeft() - mOffset,
         DrawOptions(1.0f, mCompositionOp));
 
@@ -490,6 +603,8 @@
   gfx::IntRect mPostFilterBounds;
   gfx::IntPoint mOffset;
   gfx::CompositionOp mCompositionOp;
+  bool mAllowOptimization;
+  RefPtr<FilterNode> mDeferInput;
 };
 
 /* This is an RAII based class that can be used as a drawtarget for
@@ -589,9 +704,7 @@
   explicit AdjustedTarget(CanvasRenderingContext2D* aCtx,
                           const gfx::Rect* aBounds = nullptr,
                           bool aAllowOptimization = false)
-      : mCtx(aCtx),
-        mOptimizeShadow(false),
-        mUsedOperation(aCtx->CurrentState().op) {
+      : mCtx(aCtx), mUsedOperation(aCtx->CurrentState().op) {
     // All rects in this function are in the device space of ctx->mTarget.
 
     // In order to keep our temporary surfaces as small as possible, we first
@@ -649,6 +762,11 @@
       return;
     }
     if (applyFilter) {
+      // Only allow optimizatoin of filters if no shadow is being drawn.
+      if (aAllowOptimization && !mShadowTarget) {
+        mOptimizeFilter = true;
+      }
+
       bounds.RoundOut();
 
       if (!mTarget) {
@@ -660,7 +778,8 @@
       }
       mFilterTarget = MakeUnique<AdjustedTargetForFilter>(
           aCtx, mTarget, offsetToFinalDT, intBounds,
-          gfx::RoundedToInt(boundsAfterFilter), mUsedOperation);
+          gfx::RoundedToInt(boundsAfterFilter), mUsedOperation,
+          mOptimizeFilter);
       mTarget = mFilterTarget->DT();
       mUsedOperation = CompositionOp::OP_OVER;
     }
@@ -683,6 +802,7 @@
   CompositionOp UsedOperation() const { return mUsedOperation; }
 
   bool UseOptimizeShadow() const { return mOptimizeShadow; }
+  bool UseOptimizeFilter() const { return mOptimizeFilter; }
 
   ShadowOptions ShadowParams() const {
     const ContextState& state = mCtx->CurrentState();
@@ -692,6 +812,10 @@
 
   void Fill(const Path* aPath, const Pattern& aPattern,
             const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->Fill(aPath, aPattern, aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       mTarget->DrawShadow(aPath, aPattern, ShadowParams(), aOptions);
     }
@@ -700,6 +824,10 @@
 
   void FillRect(const Rect& aRect, const Pattern& aPattern,
                 const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->FillRect(aRect, aPattern, aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       RefPtr<Path> path = MakePathForRect(*mTarget, aRect);
       mTarget->DrawShadow(path, aPattern, ShadowParams(), aOptions);
@@ -710,6 +838,10 @@
   void Stroke(const Path* aPath, const Pattern& aPattern,
               const StrokeOptions& aStrokeOptions,
               const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->Stroke(aPath, aPattern, aStrokeOptions, aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       mTarget->DrawShadow(aPath, aPattern, ShadowParams(), aOptions,
                           &aStrokeOptions);
@@ -720,6 +852,10 @@
   void StrokeRect(const Rect& aRect, const Pattern& aPattern,
                   const StrokeOptions& aStrokeOptions,
                   const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->StrokeRect(aRect, aPattern, aStrokeOptions, aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       RefPtr<Path> path = MakePathForRect(*mTarget, aRect);
       mTarget->DrawShadow(path, aPattern, ShadowParams(), aOptions,
@@ -731,6 +867,11 @@
   void StrokeLine(const Point& aStart, const Point& aEnd,
                   const Pattern& aPattern, const StrokeOptions& aStrokeOptions,
                   const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->StrokeLine(aStart, aEnd, aPattern, aStrokeOptions,
+                                aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       RefPtr<PathBuilder> builder = mTarget->CreatePathBuilder();
       builder->MoveTo(aStart);
@@ -745,6 +886,11 @@
   void DrawSurface(SourceSurface* aSurface, const Rect& aDest,
                    const Rect& aSource, const DrawSurfaceOptions& aSurfOptions,
                    const DrawOptions& aOptions) {
+    if (mOptimizeFilter) {
+      mFilterTarget->DrawSurface(aSurface, aDest, aSource, aSurfOptions,
+                                 aOptions);
+      return;
+    }
     if (mOptimizeShadow) {
       RefPtr<Path> path = MakePathForRect(*mTarget, aSource);
       ShadowOptions shadowParams(ShadowParams());
@@ -825,7 +971,8 @@
   }
 
   CanvasRenderingContext2D* mCtx;
-  bool mOptimizeShadow;
+  bool mOptimizeShadow = false;
+  bool mOptimizeFilter = false;
   CompositionOp mUsedOperation;
   RefPtr<DrawTarget> mTarget;
   UniquePtr<AdjustedTargetForShadow> mShadowTarget;