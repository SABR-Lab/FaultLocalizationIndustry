# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebgl.h
# Commit: 6ea4f3bba40f
# Full Hash: 6ea4f3bba40f2fdf5c4893e0eb76fee7d4e05094
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2025-07-05 09:22:06
# Regressor Bug: 1912897
# File Overlap Count: 1
# Description:
#   Bug 1912897 - Support blurring and shadows for Accelerated Canvas2D. r=aosmond
#   
#   This adds support via FilterNodeWebgl for accelerating specific filters in AC2D.
#   In particular, it adds support for accelerated blurring using a separable blur
#   filter. This is then used to implement the Gaussian Blur filter as well as shadows.
# ==============================================================================

diff -r c6d00b59234d -r 6ea4f3bba40f dom/canvas/DrawTargetWebgl.h
--- a/dom/canvas/DrawTargetWebgl.h	Sat Jul 05 00:10:54 2025 +0000
+++ b/dom/canvas/DrawTargetWebgl.h	Sat Jul 05 04:41:59 2025 +0000
@@ -49,6 +49,7 @@
 class DataSourceSurface;
 class DrawTargetSkia;
 class DrawTargetWebgl;
+class FilterNodeWebgl;
 class PathSkia;
 class SourceSurfaceSkia;
 class SourceSurfaceWebgl;
@@ -73,6 +74,7 @@
 class SharedContextWebgl : public mozilla::RefCounted<SharedContextWebgl>,
                            public mozilla::SupportsWeakPtr {
   friend class DrawTargetWebgl;
+  friend class FilterNodeWebgl;
   friend class SourceSurfaceWebgl;
   friend class TextureHandle;
   friend class SharedTextureHandle;
@@ -100,6 +102,7 @@
   SharedContextWebgl();
 
   WeakPtr<DrawTargetWebgl> mCurrentTarget;
+  RefPtr<TextureHandle> mTargetHandle;
   IntSize mViewportSize;
   // The current integer-aligned scissor rect.
   IntRect mClipRect;
@@ -149,6 +152,18 @@
   Maybe<uint32_t> mImageProgramSampler;
   Maybe<uint32_t> mImageProgramClipMask;
   Maybe<uint32_t> mImageProgramClipBounds;
+  RefPtr<WebGLProgram> mBlurProgram;
+  Maybe<uint32_t> mBlurProgramViewport;
+  Maybe<uint32_t> mBlurProgramTransform;
+  Maybe<uint32_t> mBlurProgramTexMatrix;
+  Maybe<uint32_t> mBlurProgramTexBounds;
+  Maybe<uint32_t> mBlurProgramOffsetScale;
+  Maybe<uint32_t> mBlurProgramSigma;
+  Maybe<uint32_t> mBlurProgramColor;
+  Maybe<uint32_t> mBlurProgramSwizzle;
+  Maybe<uint32_t> mBlurProgramSampler;
+  Maybe<uint32_t> mBlurProgramClipMask;
+  Maybe<uint32_t> mBlurProgramClipBounds;
 
   struct SolidProgramUniformState {
     Maybe<Array<float, 2>> mViewport;
@@ -169,8 +184,22 @@
     Maybe<Array<float, 4>> mClipBounds;
   } mImageProgramUniformState;
 
+  struct BlurProgramUniformState {
+    Maybe<Array<float, 2>> mViewport;
+    Maybe<Array<float, 4>> mTransform;
+    Maybe<Array<float, 4>> mTexMatrix;
+    Maybe<Array<float, 4>> mTexBounds;
+    Maybe<Array<float, 2>> mOffsetScale;
+    Maybe<Array<float, 1>> mSigma;
+    Maybe<Array<float, 4>> mColor;
+    Maybe<Array<float, 1>> mSwizzle;
+    Maybe<Array<float, 4>> mClipBounds;
+  } mBlurProgramUniformState;
+
   // Scratch framebuffer used to wrap textures for miscellaneous utility ops.
   RefPtr<WebGLFramebuffer> mScratchFramebuffer;
+  // Scratch framebuffer used to wrap textures for sub-targets.
+  RefPtr<WebGLFramebuffer> mTargetFramebuffer;
   // Buffer filled with zero data for initializing textures.
   RefPtr<WebGLBuffer> mZeroBuffer;
   size_t mZeroSize = 0;
@@ -195,8 +224,6 @@
   size_t mNumTextureHandles = 0;
   // User data key linking a SourceSurface with its TextureHandle.
   UserDataKey mTextureHandleKey = {0};
-  // User data key linking a SourceSurface with its shadow blur TextureHandle.
-  UserDataKey mShadowTextureKey = {0};
   // User data key linking a ScaledFont with its GlyphCache.
   UserDataKey mGlyphCacheKey = {0};
   // List of all GlyphCaches currently allocated to fonts.
@@ -257,7 +284,8 @@
   bool IsCurrentTarget(DrawTargetWebgl* aDT) const {
     return aDT == mCurrentTarget;
   }
-  bool SetTarget(DrawTargetWebgl* aDT);
+  bool SetTarget(DrawTargetWebgl* aDT, const RefPtr<TextureHandle>& aHandle);
+  void RestoreCurrentTarget(const RefPtr<WebGLTexture>& aClipMask = nullptr);
 
   // Reset the current target.
   void ClearTarget() { mCurrentTarget = nullptr; }
@@ -283,16 +311,24 @@
       const IntRect& aRect, TextureHandle* aHandle = nullptr);
 
   already_AddRefed<WebGLTexture> GetCompatibleSnapshot(
-      SourceSurface* aSurface) const;
+      SourceSurface* aSurface, RefPtr<TextureHandle>* aHandle = nullptr) const;
   bool IsCompatibleSurface(SourceSurface* aSurface) const;
 
   bool UploadSurface(DataSourceSurface* aData, SurfaceFormat aFormat,
                      const IntRect& aSrcRect, const IntPoint& aDstOffset,
                      bool aInit, bool aZero = false,
                      const RefPtr<WebGLTexture>& aTex = nullptr);
+  void UploadSurfaceToHandle(const RefPtr<DataSourceSurface>& aData,
+                             const IntPoint& aSrcOffset,
+                             const RefPtr<TextureHandle>& aHandle);
+  void BindAndInitRenderTex(const RefPtr<WebGLTexture>& aTex,
+                            SurfaceFormat aFormat, const IntSize& aSize);
+  void InitRenderTex(BackingTexture* aBacking);
+  void ClearRenderTex(BackingTexture* aBacking);
+  void BindScratchFramebuffer(TextureHandle* aHandle, bool aInit);
   already_AddRefed<TextureHandle> AllocateTextureHandle(
       SurfaceFormat aFormat, const IntSize& aSize, bool aAllowShared = true,
-      bool aRenderable = false);
+      bool aRenderable = false, BackingTexture* aAvoid = nullptr);
   void DrawQuad();
   void DrawTriangles(const PathVertexRange& aRange);
   bool DrawRectAccel(const Rect& aRect, const Pattern& aPattern,
@@ -304,6 +340,23 @@
                      const StrokeOptions* aStrokeOptions = nullptr,
                      const PathVertexRange* aVertexRange = nullptr,
                      const Matrix* aRectXform = nullptr);
+  bool BlurRectPass(const Rect& aDestRect, float aSigma, bool aHorizontal,
+                    const RefPtr<SourceSurface>& aSurface,
+                    const IntRect& aSourceRect,
+                    const DrawOptions& aOptions = DrawOptions(),
+                    Maybe<DeviceColor> aMaskColor = Nothing(),
+                    RefPtr<TextureHandle>* aHandle = nullptr,
+                    RefPtr<TextureHandle>* aTargetHandle = nullptr,
+                    bool aFilter = false);
+  bool BlurRectAccel(const Rect& aDestRect, float aSigma,
+                     const RefPtr<SourceSurface>& aSurface,
+                     const IntRect& aSourceRect,
+                     const DrawOptions& aOptions = DrawOptions(),
+                     Maybe<DeviceColor> aMaskColor = Nothing(),
+                     RefPtr<TextureHandle>* aHandle = nullptr,
+                     RefPtr<TextureHandle>* aTargetHandle = nullptr,
+                     RefPtr<TextureHandle>* aResultHandle = nullptr,
+                     bool aFilter = false);
 
   already_AddRefed<TextureHandle> DrawStrokeMask(
       const PathVertexRange& aVertexRange, const IntSize& aSize);
@@ -324,6 +377,12 @@
                        const StrokeOptions* aStrokeOptions,
                        bool aUseSubpixelAA);
 
+  already_AddRefed<TextureHandle> ResolveFilterInputAccel(
+      DrawTargetWebgl* aDT, const Path* aPath, const Pattern& aPattern,
+      const IntRect& aSourceRect, const Matrix& aDestTransform,
+      const DrawOptions& aOptions = DrawOptions(),
+      const StrokeOptions* aStrokeOptions = nullptr);
+
   void PruneTextureHandle(const RefPtr<TextureHandle>& aHandle);
   bool PruneTextureMemory(size_t aMargin = 0, bool aPruneUnused = true);
 
@@ -364,6 +423,9 @@
 // WebGL context so that data can be more easily interchanged between them and
 // also to enable more reasonable limiting of resource usage.
 class DrawTargetWebgl : public DrawTarget, public SupportsWeakPtr {
+  friend class FilterNodeWebgl;
+  friend class FilterNodeDeferInputWebgl;
+  friend class FilterNodeGaussianBlurWebgl;
   friend class SourceSurfaceWebgl;
   friend class SharedContextWebgl;
 
@@ -592,6 +654,16 @@
       GradientStop* aStops, uint32_t aNumStops,
       ExtendMode aExtendMode = ExtendMode::CLAMP) const override;
   already_AddRefed<FilterNode> CreateFilter(FilterType aType) override;
+  already_AddRefed<FilterNode> DeferFilterInput(
+      const Path* aPath, const Pattern& aPattern, const IntRect& aSourceRect,
+      const IntPoint& aDestOffset, const DrawOptions& aOptions = DrawOptions(),
+      const StrokeOptions* aStrokeOptions = nullptr) override;
+
+  already_AddRefed<SourceSurfaceWebgl> ResolveFilterInputAccel(
+      const Path* aPath, const Pattern& aPattern, const IntRect& aSourceRect,
+      const Matrix& aDestTransform, const DrawOptions& aOptions = DrawOptions(),
+      const StrokeOptions* aStrokeOptions = nullptr);
+
   void SetTransform(const Matrix& aTransform) override;
   void* GetNativeSurface(NativeSurfaceType aType) override;
 
@@ -619,7 +691,8 @@
 
   bool SetSimpleClipRect();
   bool GenerateComplexClipMask();
-  bool PrepareContext(bool aClipped = true);
+  bool PrepareContext(bool aClipped = true,
+                      const RefPtr<TextureHandle>& aHandle = nullptr);
 
   void DrawRectFallback(const Rect& aRect, const Pattern& aPattern,
                         const DrawOptions& aOptions,
@@ -653,6 +726,10 @@
                   const DrawOptions& aOptions,
                   const StrokeOptions* aStrokeOptions = nullptr);
 
+  bool BlurSurface(float aSigma, SourceSurface* aSurface,
+                   const IntRect& aSourceRect, const Point& aDest,
+                   const DrawOptions& aOptions = DrawOptions());
+
   bool MarkChanged();
 
   bool ReadIntoSkia();
@@ -676,6 +753,10 @@
 
   bool CreateFramebuffer();
 
+  void DrawFilterFallback(FilterNode* aNode, const Rect& aSourceRect,
+                          const Point& aDestPoint,
+                          const DrawOptions& aOptions = DrawOptions());
+
   // PrepareContext may sometimes be used recursively. When this occurs, ensure
   // that clip state is restored after the context is used.
   struct AutoRestoreContext {