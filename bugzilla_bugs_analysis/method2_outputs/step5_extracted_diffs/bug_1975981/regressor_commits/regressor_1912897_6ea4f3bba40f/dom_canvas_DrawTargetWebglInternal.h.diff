# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/canvas/DrawTargetWebglInternal.h
# Commit: 6ea4f3bba40f
# Full Hash: 6ea4f3bba40f2fdf5c4893e0eb76fee7d4e05094
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2025-07-05 09:22:06
# Regressor Bug: 1912897
# File Overlap Count: 1
# Description:
#   Bug 1912897 - Support blurring and shadows for Accelerated Canvas2D. r=aosmond
#   
#   This adds support via FilterNodeWebgl for accelerating specific filters in AC2D.
#   In particular, it adds support for accelerated blurring using a separable blur
#   filter. This is then used to implement the Gaussian Blur filter as well as shadows.
# ==============================================================================

diff -r c6d00b59234d -r 6ea4f3bba40f dom/canvas/DrawTargetWebglInternal.h
--- a/dom/canvas/DrawTargetWebglInternal.h	Sat Jul 05 00:10:54 2025 +0000
+++ b/dom/canvas/DrawTargetWebglInternal.h	Sat Jul 05 04:41:59 2025 +0000
@@ -10,6 +10,7 @@
 #include "DrawTargetWebgl.h"
 
 #include "mozilla/HashFunctions.h"
+#include "mozilla/WeakPtr.h"
 #include "mozilla/gfx/Etagere.h"
 #include "mozilla/gfx/PathSkia.h"
 #include "mozilla/gfx/WPFGpuRaster.h"
@@ -141,6 +142,7 @@
 // or standalone texture). It may be further linked to use-specific metadata
 // such as for shadow drawing or for cached entries in the glyph cache.
 class TextureHandle : public RefCounted<TextureHandle>,
+                      public SupportsWeakPtr,
                       public LinkedListElement<RefPtr<TextureHandle>> {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(TextureHandle)
@@ -426,6 +428,13 @@
   const PathVertexRange& GetVertexRange() const { return mVertexRange; }
   void SetVertexRange(const PathVertexRange& aRange) { mVertexRange = aRange; }
 
+  const WeakPtr<TextureHandle>& GetSecondaryHandle() const {
+    return mSecondaryHandle;
+  }
+  void SetSecondaryHandle(WeakPtr<TextureHandle> aHandle) {
+    mSecondaryHandle = std::move(aHandle);
+  }
+
  private:
   // The actual path geometry supplied
   QuantizedPath mPath;
@@ -441,6 +450,8 @@
   float mSigma;
   // If the path has cached geometry in the vertex buffer.
   PathVertexRange mVertexRange;
+  // Secondary texture handle that is not linked and only weakly referenced.
+  WeakPtr<TextureHandle> mSecondaryHandle;
 };
 
 class PathCache : public CacheImpl<PathCacheEntry, true> {
@@ -453,6 +464,12 @@
       const Matrix& aTransform, const IntRect& aBounds, const Point& aOrigin,
       float aSigma = -1.0f);
 
+  already_AddRefed<PathCacheEntry> FindEntry(
+      const QuantizedPath& aPath, const Pattern* aPattern,
+      const StrokeOptions* aStrokeOptions, AAStrokeMode aStrokeMode,
+      const Matrix& aTransform, const IntRect& aBounds, const Point& aOrigin,
+      float aSigma = -1.0f, bool aHasSecondaryHandle = false);
+
   void ClearVertexRanges();
 };
 