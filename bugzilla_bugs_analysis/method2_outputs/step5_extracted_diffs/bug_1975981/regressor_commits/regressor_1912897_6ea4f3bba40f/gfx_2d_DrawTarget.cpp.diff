# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: gfx/2d/DrawTarget.cpp
# Commit: 6ea4f3bba40f
# Full Hash: 6ea4f3bba40f2fdf5c4893e0eb76fee7d4e05094
# Author: Lee Salzman <lsalzman@mozilla.com>
# Date: 2025-07-05 09:22:06
# Regressor Bug: 1912897
# File Overlap Count: 1
# Description:
#   Bug 1912897 - Support blurring and shadows for Accelerated Canvas2D. r=aosmond
#   
#   This adds support via FilterNodeWebgl for accelerating specific filters in AC2D.
#   In particular, it adds support for accelerated blurring using a separable blur
#   filter. This is then used to implement the Gaussian Blur filter as well as shadows.
# ==============================================================================

diff -r c6d00b59234d -r 6ea4f3bba40f gfx/2d/DrawTarget.cpp
--- a/gfx/2d/DrawTarget.cpp	Sat Jul 05 00:10:54 2025 +0000
+++ b/gfx/2d/DrawTarget.cpp	Sat Jul 05 04:41:59 2025 +0000
@@ -14,6 +14,8 @@
 #include "BufferEdgePad.h"
 #include "BufferUnrotate.h"
 
+#include "FilterSupport.h"
+
 #ifdef USE_NEON
 #  include "mozilla/arm.h"
 #  include "LuminanceNEON.h"
@@ -351,5 +353,45 @@
   }
 }
 
+already_AddRefed<SourceSurface> DrawTarget::ResolveFilterInput(
+    const Path* aPath, const Pattern& aPattern, const IntRect& aSourceRect,
+    const Matrix& aDestTransform, const DrawOptions& aOptions,
+    const StrokeOptions* aStrokeOptions) {
+  if (!CanCreateSimilarDrawTarget(aSourceRect.Size(),
+                                  SurfaceFormat::B8G8R8A8)) {
+    return nullptr;
+  }
+  RefPtr<DrawTarget> dt =
+      CreateSimilarDrawTarget(aSourceRect.Size(), SurfaceFormat::B8G8R8A8);
+  if (dt) {
+    // See bug 1524554.
+    dt->ClearRect(Rect());
+  }
+  if (!dt || !dt->IsValid()) {
+    return nullptr;
+  }
+  dt->SetTransform(
+      Matrix(aDestTransform).PostTranslate(-aSourceRect.TopLeft()));
+  if (aStrokeOptions) {
+    dt->Stroke(aPath, aPattern, *aStrokeOptions, aOptions);
+  } else {
+    dt->Fill(aPath, aPattern, aOptions);
+  }
+  return dt->Snapshot();
+}
+
+already_AddRefed<FilterNode> DrawTarget::DeferFilterInput(
+    const Path* aPath, const Pattern& aPattern, const IntRect& aSourceRect,
+    const IntPoint& aDestOffset, const DrawOptions& aOptions,
+    const StrokeOptions* aStrokeOptions) {
+  RefPtr<SourceSurface> surface = ResolveFilterInput(
+      aPath, aPattern, aSourceRect, GetTransform().PostTranslate(aDestOffset),
+      aOptions, aStrokeOptions);
+  if (!surface) {
+    return nullptr;
+  }
+  return FilterWrappers::ForSurface(this, surface, aSourceRect.TopLeft());
+}
+
 }  // namespace gfx
 }  // namespace mozilla