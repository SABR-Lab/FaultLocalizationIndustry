# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/EnvironmentObject.h
# Commit: c42e89b08392
# Full Hash: c42e89b083921095db6967a37ffb1256a8e5598d
# Author: Tooru Fujisawa <arai_a@mac.com>
# Date: 2025-07-02 16:04:25
# Regressor Bug: 1970388
# File Overlap Count: 1
# Description:
#   Bug 1970388 - Part 2: Reflect the enclosing environment to MissingEnvironmentMap. r=bthrall
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D253505
# ==============================================================================

diff -r d4c97004a4a1 -r c42e89b08392 js/src/vm/EnvironmentObject.h
--- a/js/src/vm/EnvironmentObject.h	Wed Jul 02 11:03:28 2025 +0000
+++ b/js/src/vm/EnvironmentObject.h	Wed Jul 02 11:03:28 2025 +0000
@@ -1250,35 +1250,69 @@
   AbstractFramePtr maybeInitialFrame() const { return frame_; }
 };
 
-// The key in MissingEnvironmentMap. For live frames, maps live frames to
-// their synthesized environments. For completely optimized-out environments,
-// maps the Scope to their synthesized environments. The env we synthesize for
-// Scopes are read-only, and we never use their parent links, so they don't
-// need to be distinct.
+// The key in MissingEnvironmentMap.
+//
+//   * For live frames, maps live frames to their synthesized environments.
+//   * For completely optimized-out environments, maps the Scope to their
+//     synthesized environments.
+//
+// The env we synthesize for Scopes are read-only, but the parent links can be
+// used when accessing closed-over bindings held by the enclosing environments.
+// Thus these environments need to be distinct for multiple execution for the
+// same scope.  Otherwise looking up the MissingEnvironmentMap can yield
+// the environment for previous execution, which holds different values in the
+// variables.
 //
-// That is, completely optimized out environments can't be distinguished by
-// frame. Note that even if the frame corresponding to the Scope is live on
-// the stack, it is unsound to synthesize an environment from that live
-// frame. In other words, the provenance of the environment chain is from
-// allocated closures (i.e., allocation sites) and is irrecoverable from
-// simple stack inspection (i.e., call sites).
+// Completely optimized out environments lack the frame, and they can't be
+// distinguished by the frame pointers. Note that even if the frame
+// corresponding to the Scope is live on the stack, it is unsound to synthesize
+// environment from that live frame.
+//
+// If the frame is missing, the nearestEnv_ field is used for distinguishing
+// the missing environments across multiple executions.
+// The nearestEnv_ field holds the environment object that encloses this
+// environment.
+//
+// The goal of distinguishing the environments is to avoid mixing up the
+// variables in these enclosing environments, thus using these environment
+// object pointers should be sufficient.
+// For example, if there's no enclosing local environment which has environment
+// object, nearestEnv_ will point the global environment object, and
+// all executions for the same scope will alias, but there's no need to
+// distinguish between them.
 class MissingEnvironmentKey {
   friend class LiveEnvironmentVal;
 
+  // The corresponding frame for the environment.
+  // This can be null for function etc.
   AbstractFramePtr frame_;
+
+  // The nearest enclosing environment object.
+  // Used only if frame_ is null, to distinguish between multiple
+  // execution on the same scope.
+  WeakHeapPtr<EnvironmentObject*> nearestEnv_;
+
+  // The corresponding scope for the environment.
+  // This is shared betwen all executions.
   Scope* scope_;
 
  public:
-  explicit MissingEnvironmentKey(const EnvironmentIter& ei)
-      : frame_(ei.maybeInitialFrame()), scope_(ei.maybeScope()) {}
+  MissingEnvironmentKey(JSContext* cx, const EnvironmentIter& ei);
 
   MissingEnvironmentKey(AbstractFramePtr frame, Scope* scope)
-      : frame_(frame), scope_(scope) {}
+      : frame_(frame), nearestEnv_(nullptr), scope_(scope) {
+    MOZ_ASSERT(frame);
+  }
 
   AbstractFramePtr frame() const { return frame_; }
+  WeakHeapPtr<EnvironmentObject*>& nearestEnvRaw() { return nearestEnv_; }
+  EnvironmentObject* nearestEnvUnbarriered() const {
+    return nearestEnv_.unbarrieredGet();
+  }
   Scope* scope() const { return scope_; }
 
   void updateScope(Scope* scope) { scope_ = scope; }
+  void updateNearestEnv(EnvironmentObject* env) { nearestEnv_ = env; }
   void updateFrame(AbstractFramePtr frame) { frame_ = frame; }
 
   // For use as hash policy.
@@ -1286,7 +1320,8 @@
   static HashNumber hash(MissingEnvironmentKey sk);
   static bool match(MissingEnvironmentKey sk1, MissingEnvironmentKey sk2);
   bool operator!=(const MissingEnvironmentKey& other) const {
-    return frame_ != other.frame_ || scope_ != other.scope_;
+    return frame_ != other.frame_ || nearestEnv_ != other.nearestEnv_ ||
+           scope_ != other.scope_;
   }
   static void rekey(MissingEnvironmentKey& k,
                     const MissingEnvironmentKey& newKey) {
@@ -1300,13 +1335,17 @@
   friend class MissingEnvironmentKey;
 
   AbstractFramePtr frame_;
+  // See LiveEnvironmentVal::staticAsserts.
+  uintptr_t padding_ = 0;
   HeapPtr<Scope*> scope_;
 
   static void staticAsserts();
 
  public:
   explicit LiveEnvironmentVal(const EnvironmentIter& ei)
-      : frame_(ei.initialFrame()), scope_(ei.maybeScope()) {}
+      : frame_(ei.initialFrame()), scope_(ei.maybeScope()) {
+    (void)padding_;
+  }
 
   AbstractFramePtr frame() const { return frame_; }
 
