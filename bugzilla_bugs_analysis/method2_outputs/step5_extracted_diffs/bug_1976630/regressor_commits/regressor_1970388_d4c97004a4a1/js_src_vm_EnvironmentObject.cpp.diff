# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/src/vm/EnvironmentObject.cpp
# Commit: d4c97004a4a1
# Full Hash: d4c97004a4a1fbfc56a2b3210521c7f5ed90b60a
# Author: Tooru Fujisawa <arai_a@mac.com>
# Date: 2025-07-02 16:04:25
# Regressor Bug: 1970388
# File Overlap Count: 1
# Description:
#   Bug 1970388 - Part 1: Add more info to EnvironmentObject::dump. r=bthrall
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D253504
# ==============================================================================

diff -r 5c48af8415d1 -r d4c97004a4a1 js/src/vm/EnvironmentObject.cpp
--- a/js/src/vm/EnvironmentObject.cpp	Wed Jul 02 13:06:46 2025 +0200
+++ b/js/src/vm/EnvironmentObject.cpp	Wed Jul 02 11:03:28 2025 +0000
@@ -4501,7 +4501,7 @@
       break;
     }
 
-    fprintf(stderr, "%s", env->typeString());
+    fprintf(stderr, "%s (%p)", env->typeString(), env.get());
 
     Rooted<Scope*> scope(cx);
     if (env->is<VarEnvironmentObject>()) {
@@ -4515,20 +4515,118 @@
       scope = &env->as<ScopedLexicalEnvironmentObject>().scope();
     }
 
+    bool hadProp = false;
+
+    // Set of names in the scope.
+    // This is used for filtering out those names from properties bwlow.
+    Rooted<GCHashSet<JSAtom*>> names(cx, GCHashSet<JSAtom*>(cx, 0));
+
     if (scope) {
-      fprintf(stderr, " {\n");
+      if (!hadProp) {
+        fprintf(stderr, " {\n");
+      }
+      hadProp = true;
       for (Rooted<BindingIter> bi(cx, BindingIter(scope)); bi; bi++) {
-        if (bi.location().kind() == BindingLocation::Kind::Environment) {
-          UniqueChars bytes = AtomToPrintableString(cx, bi.name());
-          if (!bytes) {
+        fprintf(stderr, "  ");
+
+        switch (bi.location().kind()) {
+          case BindingLocation::Kind::Global:
+            if (bi.isTopLevelFunction()) {
+              fprintf(stderr, "global function: ");
+            } else {
+              fprintf(stderr, "global: ");
+            }
+            break;
+          case BindingLocation::Kind::Argument:
+            fprintf(stderr, "arg slot %u: ", bi.location().argumentSlot());
+            break;
+          case BindingLocation::Kind::Frame:
+            fprintf(stderr, "frame slot %u: ", bi.location().slot());
+            break;
+          case BindingLocation::Kind::Environment:
+            fprintf(stderr, "env slot %u: %s ", bi.location().slot(),
+                    BindingKindString(bi.kind()));
+            break;
+          case BindingLocation::Kind::NamedLambdaCallee:
+            fprintf(stderr, "named lambda callee: ");
+            break;
+          case BindingLocation::Kind::Import:
+            fprintf(stderr, "import: ");
+            break;
+        }
+
+        JSAtom* name = bi.name();
+        if (!names.put(name)) {
+          fprintf(stderr, "  *** out of memory\n");
+          return;
+        }
+
+        UniqueChars bytes = AtomToPrintableString(cx, name);
+        if (!bytes) {
+          fprintf(stderr, "  *** out of memory\n");
+          return;
+        }
+        fprintf(stderr, "%s\n", bytes.get());
+      }
+    }
+
+    // The environment object can have random properties that can be found in
+    // the name lookup.  Show them as well, excluding the properties which
+    // are already shown above for the scope.
+    if (PropMap* map = env->shape()->propMap()) {
+      Vector<PropMap*, 8, SystemAllocPolicy> maps;
+      while (true) {
+        if (!maps.append(map)) {
+          fprintf(stderr, "  *** out of memory\n");
+          return;
+        }
+        if (!map->hasPrevious()) {
+          break;
+        }
+        map = map->asLinked()->previous();
+      }
+
+      for (size_t i = maps.length(); i > 0; i--) {
+        size_t index = i - 1;
+        PropMap* map = maps[index];
+        uint32_t len = (index == 0) ? env->shape()->asNative().propMapLength()
+                                    : PropMap::Capacity;
+        for (uint32_t j = 0; j < len; j++) {
+          if (!map->hasKey(j)) {
+            MOZ_ASSERT(map->isDictionary());
+            continue;
+          }
+
+          PropertyKey propKey = map->getKey(j);
+          if (propKey.isAtom()) {
+            JSAtom* name = propKey.toAtom();
+            if (names.has(name)) {
+              continue;
+            }
+          }
+
+          JS::UniqueChars propChars = map->getPropertyNameAt(j);
+          if (!propChars) {
             fprintf(stderr, "  *** out of memory\n");
             return;
           }
 
-          fprintf(stderr, "  %u: %s %s\n", bi.location().slot(),
-                  BindingKindString(bi.kind()), bytes.get());
+          if (!hadProp) {
+            fprintf(stderr, " {\n");
+          }
+          hadProp = true;
+
+          PropertyInfo prop = map->getPropertyInfo(j);
+          if (prop.hasSlot()) {
+            fprintf(stderr, "  prop %u: %s\n", prop.slot(), propChars.get());
+          } else {
+            fprintf(stderr, "  prop: %s\n", propChars.get());
+          }
         }
       }
+    }
+
+    if (hadProp) {
       fprintf(stderr, "}");
     }
 
