# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/gtk/ScreenHelperGTK.cpp
# Commit: e977efc8bc30
# Full Hash: e977efc8bc30f781fb9f5e56b4e685e6a86e024d
# Author: stransky <stransky@redhat.com>
# Date: 2025-07-08 16:25:02
# Regressor Bug: 1971161
# File Overlap Count: 1
# Description:
#   Bug 1971161 [Wayland] Get HDR monitor info async r=emilio
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D256432
# ==============================================================================

diff -r 13eb4d64e83f -r e977efc8bc30 widget/gtk/ScreenHelperGTK.cpp
--- a/widget/gtk/ScreenHelperGTK.cpp	Tue Jul 08 11:41:55 2025 +0000
+++ b/widget/gtk/ScreenHelperGTK.cpp	Tue Jul 08 11:41:56 2025 +0000
@@ -52,33 +52,155 @@
   NS_INLINE_DECL_REFCOUNTING(ScreenGetterGtk)
 
   explicit ScreenGetterGtk(int aSerial);
+  void AddScreen(RefPtr<Screen> aScreen);
+  bool AddScreenHDRAsync(unsigned int aMonitor);
 
  protected:
-  ~ScreenGetterGtk();
+  ~ScreenGetterGtk() = default;
+
+ private:
+  AutoTArray<RefPtr<Screen>, 4> mScreenList;
+  int mSerial = 0;
+  unsigned int mMonitorNum = 0;
 };
 
-static GdkMonitor* GdkDisplayGetMonitor(GdkDisplay* aDisplay, int aMonitorNum) {
+static GdkMonitor* GdkDisplayGetMonitor(GdkDisplay* aDisplay,
+                                        unsigned int aMonitor) {
   static auto s_gdk_display_get_monitor = (GdkMonitor * (*)(GdkDisplay*, int))
       dlsym(RTLD_DEFAULT, "gdk_display_get_monitor");
   if (!s_gdk_display_get_monitor) {
     return nullptr;
   }
-  return s_gdk_display_get_monitor(aDisplay, aMonitorNum);
+  return s_gdk_display_get_monitor(aDisplay, aMonitor);
+}
+
+static uint32_t GetGTKPixelDepth() {
+  GdkVisual* visual = gdk_screen_get_system_visual(gdk_screen_get_default());
+  return gdk_visual_get_depth(visual);
+}
+
+static already_AddRefed<Screen> MakeScreenGtk(unsigned int aMonitor,
+                                              bool aIsHDR) {
+  GdkScreen* defaultScreen = gdk_screen_get_default();
+  gint gdkScaleFactor = ScreenHelperGTK::GetGTKMonitorScaleFactor(aMonitor);
+
+  // gdk_screen_get_monitor_geometry / workarea returns application pixels
+  // (desktop pixels), so we need to convert it to device pixels with
+  // gdkScaleFactor.
+  gint geometryScaleFactor = gdkScaleFactor;
+
+  gint refreshRate = [&] {
+    // Since gtk 3.22
+    static auto s_gdk_monitor_get_refresh_rate = (int (*)(GdkMonitor*))dlsym(
+        RTLD_DEFAULT, "gdk_monitor_get_refresh_rate");
+    if (!s_gdk_monitor_get_refresh_rate) {
+      return 0;
+    }
+    GdkMonitor* monitor =
+        GdkDisplayGetMonitor(gdk_display_get_default(), aMonitor);
+    if (!monitor) {
+      return 0;
+    }
+    // Convert to Hz.
+    return NSToIntRound(s_gdk_monitor_get_refresh_rate(monitor) / 1000.0f);
+  }();
+
+  GdkRectangle workarea;
+  gdk_screen_get_monitor_workarea(defaultScreen, aMonitor, &workarea);
+  LayoutDeviceIntRect availRect(workarea.x * geometryScaleFactor,
+                                workarea.y * geometryScaleFactor,
+                                workarea.width * geometryScaleFactor,
+                                workarea.height * geometryScaleFactor);
+  LayoutDeviceIntRect rect;
+  DesktopToLayoutDeviceScale contentsScale(1.0);
+  if (GdkIsX11Display()) {
+    GdkRectangle monitor;
+    gdk_screen_get_monitor_geometry(defaultScreen, aMonitor, &monitor);
+    rect = LayoutDeviceIntRect(monitor.x * geometryScaleFactor,
+                               monitor.y * geometryScaleFactor,
+                               monitor.width * geometryScaleFactor,
+                               monitor.height * geometryScaleFactor);
+  } else {
+    // Don't report screen shift in Wayland, see bug 1795066.
+    availRect.MoveTo(0, 0);
+    // We use Gtk workarea on Wayland as it matches our needs (Bug 1732682).
+    rect = availRect;
+    // Use per-monitor scaling factor in Wayland.
+    contentsScale.scale = gdkScaleFactor;
+  }
+
+  uint32_t pixelDepth = GetGTKPixelDepth();
+  if (pixelDepth == 32) {
+    // If a device uses 32 bits per pixel, it's still only using 8 bits
+    // per color component, which is what our callers want to know.
+    // (Some devices report 32 and some devices report 24.)
+    pixelDepth = 24;
+  }
+
+  CSSToLayoutDeviceScale defaultCssScale(gdkScaleFactor);
+
+  float dpi = 96.0f;
+  gint heightMM = gdk_screen_get_monitor_height_mm(defaultScreen, aMonitor);
+  if (heightMM > 0) {
+    dpi = rect.height / (heightMM / MM_PER_INCH_FLOAT);
+  }
+
+  LOG_SCREEN(
+      "New monitor %d size [%d,%d -> %d x %d] depth %d scale %f CssScale %f  "
+      "DPI %f refresh %d HDR %d]",
+      aMonitor, rect.x, rect.y, rect.width, rect.height, pixelDepth,
+      contentsScale.scale, defaultCssScale.scale, dpi, refreshRate, aIsHDR);
+  return MakeAndAddRef<Screen>(
+      rect, availRect, pixelDepth, pixelDepth, refreshRate, contentsScale,
+      defaultCssScale, dpi, Screen::IsPseudoDisplay::No, Screen::IsHDR(aIsHDR));
 }
 
 #ifdef MOZ_WAYLAND
-struct HDRMonitorInfo {
-  int mMonitorNum = 0;
+class WaylandMonitor {
+ public:
+  WaylandMonitor(ScreenGetterGtk* aScreenGetter, unsigned int aMonitor,
+                 wp_color_management_output_v1* aOutput,
+                 wp_image_description_v1* aDescription)
+      : mScreenGetter(aScreenGetter),
+        mMonitor(aMonitor),
+        mOutput(aOutput),
+        mDescription(aDescription) {
+    LOG_SCREEN("WaylandMonitor()[%p] monitor %d", this, mMonitor);
+  }
+  ~WaylandMonitor() {
+    LOG_SCREEN("~WaylandMonitor()[%p]", this);
+    MozClearPointer(mDescription, wp_image_description_v1_destroy);
+    MozClearPointer(mOutput, wp_color_management_output_v1_destroy);
+    mScreenGetter = nullptr;
+  }
+
+  unsigned int GetMonitor() const { return mMonitor; }
+
+  void SetHDR(bool aIsHDR) {
+    LOG_SCREEN("WaylandMonitor()[%p]: monitor num [%d] HDR %d", this, mMonitor,
+               aIsHDR);
+    mIsHDR = aIsHDR;
+  }
+
+  void Done() {
+    LOG_SCREEN("WaylandMonitor()[%p] Done", this);
+    mScreenGetter->AddScreen(MakeScreenGtk(mMonitor, mIsHDR));
+  }
+
+ private:
+  RefPtr<ScreenGetterGtk> mScreenGetter;
+  unsigned int mMonitor = 0;
+  wp_color_management_output_v1* mOutput = nullptr;
+  wp_image_description_v1* mDescription = nullptr;
   bool mIsHDR = false;
-  bool mIsDone = false;
 };
 
 void image_description_info_done(
     void* data,
     struct wp_image_description_info_v1* wp_image_description_info_v1) {
-  auto* info = static_cast<HDRMonitorInfo*>(data);
-  info->mIsDone = true;
-  LOG_SCREEN("Monitor num [%d] Done", info->mMonitorNum);
+  auto* info = static_cast<WaylandMonitor*>(data);
+  info->Done();
+  delete info;
 }
 
 /**
@@ -180,10 +302,10 @@
     void* data,
     struct wp_image_description_info_v1* wp_image_description_info_v1,
     uint32_t min_lum, uint32_t max_lum, uint32_t reference_lum) {
-  auto* info = static_cast<HDRMonitorInfo*>(data);
+  auto* info = static_cast<WaylandMonitor*>(data);
   LOG_SCREEN("Monitor num [%d] Luminance min %d max %d reference %d",
-             info->mMonitorNum, min_lum, max_lum, reference_lum);
-  info->mIsHDR = max_lum > reference_lum;
+             info->GetMonitor(), min_lum, max_lum, reference_lum);
+  info->SetHDR(max_lum > reference_lum);
 }
 /**
  * target primaries as chromaticity coordinates
@@ -280,44 +402,40 @@
                                     image_description_info_target_max_cll,
                                     image_description_info_target_max_fall};
 
-bool IsMonitorHDR(gint aMonitorNum) {
-  if (!WaylandDisplayGet() || !WaylandDisplayGet()->GetColorManager()) {
+bool ScreenGetterGtk::AddScreenHDRAsync(unsigned int aMonitor) {
+  MOZ_DIAGNOSTIC_ASSERT(WaylandDisplayGet()->GetColorManager());
+  GdkMonitor* monitor =
+      GdkDisplayGetMonitor(gdk_display_get_default(), aMonitor);
+  if (!monitor) {
+    LOG_SCREEN("ScreenGetterGtk::AddScreenHDRAsync() failed to get monitor %d",
+               aMonitor);
     return false;
   }
-  GdkMonitor* monitor =
-      GdkDisplayGetMonitor(gdk_display_get_default(), aMonitorNum);
-  if (!monitor) {
-    return monitor;
-  }
   static auto s_gdk_wayland_monitor_get_wl_output =
       (struct wl_output * (*)(GdkMonitor*))
           dlsym(RTLD_DEFAULT, "gdk_wayland_monitor_get_wl_output");
   if (!s_gdk_wayland_monitor_get_wl_output) {
+    LOG_SCREEN(
+        "ScreenGetterGtk::AddScreenHDRAsync() missing "
+        "gdk_wayland_monitor_get_wl_output");
     return false;
   }
   auto wlOutput = s_gdk_wayland_monitor_get_wl_output(monitor);
   if (!wlOutput) {
+    LOG_SCREEN("ScreenGetterGtk::AddScreenHDRAsync() missing wl_output");
     return false;
   }
-  auto output = wp_color_manager_v1_get_output(
+
+  LOG_SCREEN("ScreenGetterGtk::AddScreenHDR() monitor %d", aMonitor);
+  auto* output = wp_color_manager_v1_get_output(
       WaylandDisplayGet()->GetColorManager(), wlOutput);
-  auto description =
+  auto* description =
       wp_color_management_output_v1_get_image_description(output);
   auto descriptionInfo = wp_image_description_v1_get_information(description);
-
-  HDRMonitorInfo monitorInfo;
-  monitorInfo.mMonitorNum = aMonitorNum;
   wp_image_description_info_v1_add_listener(
-      descriptionInfo, &image_description_info_listener, &monitorInfo);
-
-  WaylandDisplayGet()->RequestAsyncRoundtrip();
-  WaylandDisplayGet()->WaitForAsyncRoundtrips();
-
-  wp_image_description_v1_destroy(description);
-  wp_color_management_output_v1_destroy(output);
-
-  MOZ_DIAGNOSTIC_ASSERT(monitorInfo.mIsDone);
-  return monitorInfo.mIsHDR;
+      descriptionInfo, &image_description_info_listener,
+      new WaylandMonitor(this, aMonitor, output, description));
+  return true;
 }
 #endif
 
@@ -358,107 +476,47 @@
   return nullptr;
 }
 
-ScreenGetterGtk::~ScreenGetterGtk() {}
+void ScreenGetterGtk::AddScreen(RefPtr<Screen> aScreen) {
+  mScreenList.AppendElement(std::move(aScreen));
+  MOZ_DIAGNOSTIC_ASSERT(mScreenList.Length() <= mMonitorNum);
 
-static uint32_t GetGTKPixelDepth() {
-  GdkVisual* visual = gdk_screen_get_system_visual(gdk_screen_get_default());
-  return gdk_visual_get_depth(visual);
+  if (mScreenList.Length() == mMonitorNum) {
+    if (mSerial != ScreenHelperGTK::GetLastSerial()) {
+      MOZ_DIAGNOSTIC_ASSERT(mSerial <= ScreenHelperGTK::GetLastSerial());
+      LOG_SCREEN(
+          "ScreenGetterGtk::AddScreen(): rejected, old wrong serial %d latest "
+          "%d",
+          mSerial, ScreenHelperGTK::GetLastSerial());
+      return;
+    }
+
+    LOG_SCREEN("ScreenGetterGtk::AddScreen(): Set screens, serial %d ",
+               mSerial);
+    ScreenManager::Refresh(std::move(mScreenList));
+  }
 }
 
-static already_AddRefed<Screen> MakeScreenGtk(GdkScreen* aScreen,
-                                              gint aMonitorNum) {
-  gint gdkScaleFactor = ScreenHelperGTK::GetGTKMonitorScaleFactor(aMonitorNum);
-
-  // gdk_screen_get_monitor_geometry / workarea returns application pixels
-  // (desktop pixels), so we need to convert it to device pixels with
-  // gdkScaleFactor.
-  gint geometryScaleFactor = gdkScaleFactor;
-
-  gint refreshRate = [&] {
-    // Since gtk 3.22
-    static auto s_gdk_monitor_get_refresh_rate = (int (*)(GdkMonitor*))dlsym(
-        RTLD_DEFAULT, "gdk_monitor_get_refresh_rate");
-    if (!s_gdk_monitor_get_refresh_rate) {
-      return 0;
-    }
-    GdkMonitor* monitor =
-        GdkDisplayGetMonitor(gdk_display_get_default(), aMonitorNum);
-    if (!monitor) {
-      return 0;
-    }
-    // Convert to Hz.
-    return NSToIntRound(s_gdk_monitor_get_refresh_rate(monitor) / 1000.0f);
-  }();
-
-  GdkRectangle workarea;
-  gdk_screen_get_monitor_workarea(aScreen, aMonitorNum, &workarea);
-  LayoutDeviceIntRect availRect(workarea.x * geometryScaleFactor,
-                                workarea.y * geometryScaleFactor,
-                                workarea.width * geometryScaleFactor,
-                                workarea.height * geometryScaleFactor);
-  LayoutDeviceIntRect rect;
-  DesktopToLayoutDeviceScale contentsScale(1.0);
-  if (GdkIsX11Display()) {
-    GdkRectangle monitor;
-    gdk_screen_get_monitor_geometry(aScreen, aMonitorNum, &monitor);
-    rect = LayoutDeviceIntRect(monitor.x * geometryScaleFactor,
-                               monitor.y * geometryScaleFactor,
-                               monitor.width * geometryScaleFactor,
-                               monitor.height * geometryScaleFactor);
-  } else {
-    // Don't report screen shift in Wayland, see bug 1795066.
-    availRect.MoveTo(0, 0);
-    // We use Gtk workarea on Wayland as it matches our needs (Bug 1732682).
-    rect = availRect;
-    // Use per-monitor scaling factor in Wayland.
-    contentsScale.scale = gdkScaleFactor;
-  }
-
-  uint32_t pixelDepth = GetGTKPixelDepth();
-  if (pixelDepth == 32) {
-    // If a device uses 32 bits per pixel, it's still only using 8 bits
-    // per color component, which is what our callers want to know.
-    // (Some devices report 32 and some devices report 24.)
-    pixelDepth = 24;
-  }
-
-  CSSToLayoutDeviceScale defaultCssScale(gdkScaleFactor);
-
-  float dpi = 96.0f;
-  gint heightMM = gdk_screen_get_monitor_height_mm(aScreen, aMonitorNum);
-  if (heightMM > 0) {
-    dpi = rect.height / (heightMM / MM_PER_INCH_FLOAT);
-  }
-
-  bool isHDR = false;
+ScreenGetterGtk::ScreenGetterGtk(int aSerial)
+    : mSerial(aSerial),
+      mMonitorNum(gdk_screen_get_n_monitors(gdk_screen_get_default())) {
+  LOG_SCREEN("ScreenGetterGtk(): monitor num %d", mMonitorNum);
 #ifdef MOZ_WAYLAND
-  if (GdkIsWaylandDisplay()) {
-    isHDR = WaylandDisplayGet()->IsHDREnabled();
-  }
+  LOG_SCREEN("HDR Protocol %s",
+             GdkIsWaylandDisplay() && WaylandDisplayGet()->IsHDREnabled()
+                 ? "present"
+                 : "missing");
 #endif
 
-  LOG_SCREEN(
-      "New monitor %d size [%d,%d -> %d x %d] depth %d scale %f CssScale %f  "
-      "DPI %f refresh %d HDR %d]",
-      aMonitorNum, rect.x, rect.y, rect.width, rect.height, pixelDepth,
-      contentsScale.scale, defaultCssScale.scale, dpi, refreshRate, isHDR);
-  return MakeAndAddRef<Screen>(
-      rect, availRect, pixelDepth, pixelDepth, refreshRate, contentsScale,
-      defaultCssScale, dpi, Screen::IsPseudoDisplay::No, Screen::IsHDR(isHDR));
-}
-
-ScreenGetterGtk::ScreenGetterGtk(int aSerial) {
-  AutoTArray<RefPtr<Screen>, 4> screenList;
-
-  GdkScreen* defaultScreen = gdk_screen_get_default();
-  gint numScreens = gdk_screen_get_n_monitors(defaultScreen);
-  LOG_SCREEN("GDK reports %d screens", numScreens);
-
-  for (gint i = 0; i < numScreens; i++) {
-    screenList.AppendElement(MakeScreenGtk(defaultScreen, i));
+  for (unsigned int i = 0; i < mMonitorNum; i++) {
+#ifdef MOZ_WAYLAND
+    if (GdkIsWaylandDisplay() && WaylandDisplayGet()->IsHDREnabled()) {
+      if (AddScreenHDRAsync(i)) {
+        continue;
+      }
+    }
+#endif
+    AddScreen(MakeScreenGtk(i, /* aIsHDR */ false));
   }
-
-  ScreenManager::Refresh(std::move(screenList));
 }
 
 void ScreenHelperGTK::RequestRefreshScreens() {
@@ -468,11 +526,11 @@
   gLastScreenGetter = new ScreenGetterGtk(gLastSerial);
 }
 
-gint ScreenHelperGTK::GetGTKMonitorScaleFactor(gint aMonitorNum) {
+gint ScreenHelperGTK::GetGTKMonitorScaleFactor(gint aMonitor) {
   MOZ_ASSERT(NS_IsMainThread());
   GdkScreen* screen = gdk_screen_get_default();
-  return aMonitorNum < gdk_screen_get_n_monitors(screen)
-             ? gdk_screen_get_monitor_scale_factor(screen, aMonitorNum)
+  return aMonitor < gdk_screen_get_n_monitors(screen)
+             ? gdk_screen_get_monitor_scale_factor(screen, aMonitor)
              : 1;
 }
 