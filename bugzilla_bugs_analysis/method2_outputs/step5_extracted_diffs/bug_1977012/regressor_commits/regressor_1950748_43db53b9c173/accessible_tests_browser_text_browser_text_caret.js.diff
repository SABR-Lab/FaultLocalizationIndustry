# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/tests/browser/text/browser_text_caret.js
# Commit: 43db53b9c173
# Full Hash: 43db53b9c173205fcb9c60f16e48e76bd9f134f8
# Author: James Teh <jteh@mozilla.com>
# Date: 2025-07-11 16:36:21
# Regressor Bug: 1950748
# File Overlap Count: 2
# Description:
#   Bug 1950748 part 3: Don't return a caret inside an editor when no editor is focused. r=morgan
#   
#   See the code comments for details.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D256399
# ==============================================================================

diff -r a62a2d25a53f -r 43db53b9c173 accessible/tests/browser/text/browser_text_caret.js
--- a/accessible/tests/browser/text/browser_text_caret.js	Fri Jul 11 06:10:57 2025 +0000
+++ b/accessible/tests/browser/text/browser_text_caret.js	Fri Jul 11 06:10:57 2025 +0000
@@ -605,3 +605,91 @@
     is(evt.caretOffset, 0, "Caret event is for offset 0");
   }
 );
+
+/**
+ * Test the caret when clicking in an empty area of a container immediately
+ * before/after a text input.
+ */
+addAccessibleTask(
+  `
+<div id="inputThenEmpty" style="padding-bottom: 10vh;">
+  <input id="inputBeforeEmpty" value="ab">
+</div>
+<div id="emptyThenInput" style="padding-top: 10vh;">
+  <input id="inputAfterEmpty" value="cd">
+</div>
+  `,
+  async function testEmptyNearInput(browser, docAcc) {
+    info("Focusing inputBeforeEmpty");
+    let input = findAccessibleChildByID(docAcc, "inputBeforeEmpty", [
+      nsIAccessibleText,
+    ]);
+    let moved = waitForEvents([
+      [EVENT_FOCUS, input],
+      [EVENT_TEXT_CARET_MOVED, input],
+    ]);
+    input.takeFocus();
+    await moved;
+    is(input.caretOffset, 0, "caretOffset 0");
+
+    info("Clicking at bottom of inputThenEmpty");
+    // BrowserTestUtils.synthesizeMouseAtPoint takes coordinates relative to the
+    // document.
+    const docX = {};
+    const docY = {};
+    docAcc.getBounds(docX, docY, {}, {});
+    let container = findAccessibleChildByID(docAcc, "inputThenEmpty", [
+      nsIAccessibleText,
+    ]);
+    const containerX = {};
+    const containerY = {};
+    const containerH = {};
+    container.getBounds(containerX, containerY, {}, containerH);
+    moved = waitForEvents([
+      [EVENT_FOCUS, docAcc],
+      [EVENT_TEXT_CARET_MOVED, container],
+    ]);
+    await BrowserTestUtils.synthesizeMouseAtPoint(
+      containerX.value - docX.value,
+      containerY.value + containerH.value - 1 - docY.value,
+      {},
+      docAcc.browsingContext
+    );
+    await moved;
+    docAcc.QueryInterface(nsIAccessibleText);
+    is(input.caretOffset, -1, "No caret in inputBeforeEmpty");
+
+    info("Focusing inputAfterEmpty");
+    input = findAccessibleChildByID(docAcc, "inputAfterEmpty", [
+      nsIAccessibleText,
+    ]);
+    moved = waitForEvents([
+      [EVENT_FOCUS, input],
+      [EVENT_TEXT_CARET_MOVED, input],
+    ]);
+    input.takeFocus();
+    await moved;
+    is(input.caretOffset, 0, "caretOffset 0");
+
+    info("Clicking at top of emptyThenInput");
+    container = findAccessibleChildByID(docAcc, "emptyThenInput", [
+      nsIAccessibleText,
+    ]);
+    container.getBounds(containerX, containerY, {}, {});
+    // The caret event fires in the input instead of the container, but this
+    // isn't really important.
+    moved = waitForEvents([
+      [EVENT_FOCUS, docAcc],
+      [EVENT_TEXT_CARET_MOVED, input],
+    ]);
+    await BrowserTestUtils.synthesizeMouseAtPoint(
+      containerX.value - docX.value,
+      containerY.value - docY.value + 1,
+      {},
+      docAcc.browsingContext
+    );
+    await moved;
+    is(input.caretOffset, -1, "No caret in inputAfterEmpty");
+  },
+  { chrome: true, topLevel: true }
+);
