# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/TextLeafRange.cpp
# Commit: ebee26b8b8ce
# Full Hash: ebee26b8b8ce31cfad7fc9daddb960647d444694
# Author: James Teh <jteh@mozilla.com>
# Date: 2025-07-14 09:19:02
# Regressor Bug: 1950748
# File Overlap Count: 2
# Description:
#   Bug 1950748 part 3: Don't return a caret inside an editor when no editor is focused. r=morgan
#   
#   See the code comments for details.
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D256399
# ==============================================================================

diff -r 16cf34285142 -r ebee26b8b8ce accessible/base/TextLeafRange.cpp
--- a/accessible/base/TextLeafRange.cpp	Mon Jul 14 01:38:43 2025 +0000
+++ b/accessible/base/TextLeafRange.cpp	Mon Jul 14 01:38:43 2025 +0000
@@ -634,6 +634,32 @@
   return AreFramesOnDifferentLines(aContinuation, prev);
 }
 
+static bool IsCaretValid(TextLeafPoint aPoint) {
+  Accessible* acc = aPoint.mAcc;
+  if (!acc->IsHyperText()) {
+    acc = acc->Parent();
+  }
+  if (!(acc->State() & states::EDITABLE)) {
+    return true;
+  }
+  // The caret is within editable content.
+  Accessible* focus = FocusMgr() ? FocusMgr()->FocusedAccessible() : nullptr;
+  if (!focus) {
+    return false;
+  }
+  // If the focus isn't an editor, the caret can't be inside an editor. This
+  // can happen, for example, when a text input is the last element in a
+  // container and a user clicks in the empty area at the end of the container.
+  // In this case, the caret is actually at the end of the container outside the
+  // input. This can also happen if there is an empty area in a container before
+  // an input and a user clicks there. TextLeafPoint can't represent either of
+  // these cases and it's generally not useful. We must not normalize this to
+  // the nearest leaf because this would put the caret inside an editor which
+  // isn't focused. Instead, we pretend there is no caret. See bug 1950748 for
+  // more details.
+  return focus->State() & states::EDITABLE;
+}
+
 /*** TextLeafPoint ***/
 
 TextLeafPoint::TextLeafPoint(Accessible* aAcc, int32_t aOffset) {
@@ -1077,6 +1103,9 @@
           "Got HyperText CaretOffset but ToTextLeafPoint failed");
       return point;
     }
+    if (!IsCaretValid(point)) {
+      return TextLeafPoint();
+    }
     nsIFrame* frame = ht->GetFrame();
     RefPtr<nsFrameSelection> sel = frame ? frame->GetFrameSelection() : nullptr;
     if (sel && sel->GetHint() == CaretAssociationHint::Before) {
@@ -1113,6 +1142,16 @@
     return TextLeafPoint();
   }
   TextLeafPoint point = ht->ToTextLeafPoint(htOffset);
+  if (!point) {
+    // The caret offset should usually be in sync with the tree. However, tree
+    // and selection updates happen using separate IPDL calls, so it's possible
+    // for a client caret query to arrive between them. Thus, we can end up
+    // with an invalid caret here.
+    return point;
+  }
+  if (!IsCaretValid(point)) {
+    return TextLeafPoint();
+  }
   point.mIsEndOfLineInsertionPoint = remoteDoc->IsCaretAtEndOfLine();
   return point;
 }