# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/notification/NotificationUtils.cpp
# Commit: 1c6ace5aa850
# Full Hash: 1c6ace5aa8502311912112a4a8d80739253579a2
# Author: Kagami Sascha Rosylight <saschanaz@outlook.com>
# Date: 2025-07-16 21:45:35
# Regressor Bug: 1972117
# File Overlap Count: 1
# Description:
#   Bug 1972117 - Part 3: Move NotificationsCallback to NotificationUtils r=asuth
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D255860
# ==============================================================================

diff -r 5db864f2389f -r 1c6ace5aa850 dom/notification/NotificationUtils.cpp
--- a/dom/notification/NotificationUtils.cpp	Wed Jul 16 15:33:00 2025 +0000
+++ b/dom/notification/NotificationUtils.cpp	Wed Jul 16 15:33:00 2025 +0000
@@ -168,6 +168,66 @@
                                  : NS_NOTIFICATION_STORAGE_CONTRACTID);
 }
 
+class NotificationsCallback : public nsINotificationStorageCallback {
+ public:
+  NS_DECL_ISUPPORTS
+
+  already_AddRefed<NotificationsPromise> Promise() {
+    return mPromiseHolder.Ensure(__func__);
+  }
+
+  NS_IMETHOD Done(
+      const nsTArray<RefPtr<nsINotificationStorageEntry>>& aEntries) final {
+    AssertIsOnMainThread();
+
+    nsTArray<IPCNotification> notifications(aEntries.Length());
+    for (const auto& entry : aEntries) {
+      auto result = NotificationStorageEntry::ToIPC(*entry);
+      if (result.isErr()) {
+        continue;
+      }
+      MOZ_ASSERT(!result.inspect().id().IsEmpty());
+      notifications.AppendElement(result.unwrap());
+    }
+
+    mPromiseHolder.Resolve(std::move(notifications), __func__);
+    return NS_OK;
+  }
+
+ protected:
+  virtual ~NotificationsCallback() {
+    // We may be shutting down prematurely without getting the result, so make
+    // sure to settle the promise.
+    mPromiseHolder.RejectIfExists(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+  };
+
+  MozPromiseHolder<NotificationsPromise> mPromiseHolder;
+};
+
+NS_IMPL_ISUPPORTS(NotificationsCallback, nsINotificationStorageCallback)
+
+already_AddRefed<NotificationsPromise> GetStoredNotificationsForScope(
+    nsIPrincipal* aPrincipal, const nsACString& aScope, const nsAString& aTag) {
+  nsString origin;
+  nsresult rv = GetOrigin(aPrincipal, origin);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NotificationsPromise::CreateAndReject(rv, __func__).forget();
+  }
+
+  RefPtr<NotificationsCallback> callback = new NotificationsCallback();
+  RefPtr<NotificationsPromise> promise = callback->Promise();
+
+  nsCOMPtr<nsINotificationStorage> notificationStorage =
+      GetNotificationStorage(aPrincipal->GetIsInPrivateBrowsing());
+
+  rv = notificationStorage->Get(origin, NS_ConvertUTF8toUTF16(aScope), aTag,
+                                callback);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NotificationsPromise::CreateAndReject(rv, __func__).forget();
+  }
+  return promise.forget();
+}
+
 nsresult PersistNotification(nsIPrincipal* aPrincipal,
                              const IPCNotification& aNotification,
                              const nsString& aScope) {