# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
# Commit: 2e24d997d5de
# Full Hash: 2e24d997d5de727be8e44b522e57d7ff7db52486
# Author: Sandor Molnar <smolnar@mozilla.com>
# Date: 2025-07-16 21:45:35
# Regressor Bug: 1972117
# File Overlap Count: 1
# Description:
#   Revert "Bug 1972117: apply code formatting via Lando" for causing assertion failures @ MozPromise.h
#   
#   This reverts commit e76333b4d7fb2d323e797f12bde50ccc99a51a85.
#   
#   Revert "Bug 1972117 - Part 4: Clear notifications on service worker unregistration r=asuth"
# ==============================================================================

diff -r c257659aa2b4 -r 2e24d997d5de dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp	Wed Jul 16 19:15:43 2025 +0300
+++ b/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp	Wed Jul 16 19:18:03 2025 +0300
@@ -487,6 +487,45 @@
   return promise;
 }
 
+// TODO(krosylight): Ideally this callback shouldn't be needed, see bug 1950116.
+class NotificationsCallback : public nsINotificationStorageCallback {
+ public:
+  NS_DECL_ISUPPORTS
+
+  already_AddRefed<NotificationsPromise> Promise() {
+    return mPromiseHolder.Ensure(__func__);
+  }
+
+  NS_IMETHOD Done(
+      const nsTArray<RefPtr<nsINotificationStorageEntry>>& aEntries) final {
+    AssertIsOnMainThread();
+
+    nsTArray<IPCNotification> notifications(aEntries.Length());
+    for (const auto& entry : aEntries) {
+      auto result = NotificationStorageEntry::ToIPC(*entry);
+      if (result.isErr()) {
+        continue;
+      }
+      MOZ_ASSERT(!result.inspect().id().IsEmpty());
+      notifications.AppendElement(result.unwrap());
+    }
+
+    mPromiseHolder.Resolve(std::move(notifications), __func__);
+    return NS_OK;
+  }
+
+ protected:
+  virtual ~NotificationsCallback() {
+    // We may be shutting down prematurely without getting the result, so make
+    // sure to settle the promise.
+    mPromiseHolder.RejectIfExists(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+  };
+
+  MozPromiseHolder<NotificationsPromise> mPromiseHolder;
+};
+
+NS_IMPL_ISUPPORTS(NotificationsCallback, nsINotificationStorageCallback)
+
 RefPtr<NotificationsPromise> ServiceWorkerRegistrationProxy::GetNotifications(
     const nsAString& aTag) {
   AssertIsOnBackgroundThread();
@@ -506,8 +545,18 @@
         nsString origin;
         GetOrigin(principal, origin);
 
-        RefPtr<NotificationsPromise> promise = GetStoredNotificationsForScope(
-            principal, self->mDescriptor.Scope(), tag);
+        RefPtr<NotificationsCallback> callback = new NotificationsCallback();
+        RefPtr<NotificationsPromise> promise = callback->Promise();
+
+        nsCOMPtr<nsINotificationStorage> notificationStorage =
+            GetNotificationStorage(
+                self->mListeningClientInfo.IsPrivateBrowsing());
+
+        nsString scope;
+        self->GetScope(scope);
+
+        notificationStorage->Get(origin, scope, tag, callback);
+
         return promise;
       });
 }