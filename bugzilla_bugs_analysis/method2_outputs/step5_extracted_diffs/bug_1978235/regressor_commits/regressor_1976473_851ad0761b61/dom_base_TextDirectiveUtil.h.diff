# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/TextDirectiveUtil.h
# Commit: 851ad0761b61
# Full Hash: 851ad0761b619ebf4b4982a18ab0bb627d7dd240
# Author: Jan-Niklas Jaeschke <jjaschke@mozilla.com>
# Date: 2025-07-19 09:41:31
# Regressor Bug: 1976473
# File Overlap Count: 2
# Description:
#   Bug 1976473 - Text Fragments: Treat punctuation as part of a word when computing word boundary distances. r=dom-core,avandolder,mccr8
#   
#   Finding word boundaries uses `intl::WordBreaker::FindWord()`, which stops at punctuation.
#   As a result, finding word boundary distances for the string "foo bar. baz" would have had found
#   the distances `[3,7,8,12]` when going LTR and `[3,5,8,12]` when going RTL.
# ==============================================================================

diff -r 6a6745867aa0 -r 851ad0761b61 dom/base/TextDirectiveUtil.h
--- a/dom/base/TextDirectiveUtil.h	Fri Jul 18 18:12:34 2025 +0000
+++ b/dom/base/TextDirectiveUtil.h	Fri Jul 18 18:16:32 2025 +0000
@@ -209,6 +209,19 @@
   template <TextScanDirection direction>
   static nsTArray<uint32_t> ComputeWordBoundaryDistances(
       const nsAString& aString);
+
+  /**
+   * @brief Returns true if the word between `aWordBegin` and `aWordEnd` is
+   *        just whitespace or punctuation.
+   * @param aString The string to check. Must not be empty.
+   * @param aWordBegin The start index of the word.
+   * @param aWordEnd The end index of the word.
+   * @return true if the word is just whitespace or punctuation, false
+   * otherwise.
+   */
+  static bool WordIsJustWhitespaceOrPunctuation(const nsAString& aString,
+                                                uint32_t aWordBegin,
+                                                uint32_t aWordEnd);
 };
 
 class TimeoutWatchdog final {
@@ -505,13 +518,19 @@
   // This loop relies on underflowing `pos` when going left as stop condition.
   while (pos < aString.Length()) {
     auto [wordBegin, wordEnd] = intl::WordBreaker::FindWord(aString, pos);
-    if constexpr (direction == TextScanDirection::Left) {
-      wordBoundaryDistances.AppendElement(aString.Length() - wordBegin);
-      pos = wordBegin - 1;
-    } else {
-      wordBoundaryDistances.AppendElement(wordEnd);
-      pos = wordEnd + 1;
+    pos = direction == TextScanDirection::Left ? wordBegin - 1 : wordEnd + 1;
+    if (WordIsJustWhitespaceOrPunctuation(aString, wordBegin, wordEnd)) {
+      // The WordBreaker algorithm breaks at punctuation, so that "foo bar. baz"
+      // would be split into four words: [foo, bar, ., baz].
+      // To avoid this, we skip words which are just whitespace or punctuation
+      // and add the punctuation to the previous word, so that the above example
+      // would yield three words: [foo, bar., baz].
+      continue;
     }
+
+    wordBoundaryDistances.AppendElement(direction == TextScanDirection::Left
+                                            ? aString.Length() - wordBegin
+                                            : wordEnd);
   }
   return std::move(wordBoundaryDistances);
 }