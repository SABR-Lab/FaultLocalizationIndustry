# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditor.cpp
# Commit: 366245552cae
# Full Hash: 366245552cae536ef883be806322395dc47b759d
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-06-17 09:24:05
# Regressor Bug: 1951038
# File Overlap Count: 1
# Description:
#   Bug 1951038 - Get rid of the legacy white-space normalizer of `HTMLEditor` and the pref r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D253589
# ==============================================================================

diff -r b13b0a530402 -r 366245552cae editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp	Tue Jun 17 00:10:27 2025 +0000
+++ b/editor/libeditor/HTMLEditor.cpp	Tue Jun 17 00:37:22 2025 +0000
@@ -2261,21 +2261,19 @@
     NS_WARNING("HTMLEditUtils::GetBetterInsertionPointFor() failed");
     return NS_ERROR_FAILURE;
   }
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    Result<EditorDOMPoint, nsresult> pointToInsertOrError =
-        WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesToSplitAt(
-            *this, pointToInsert,
-            {WhiteSpaceVisibilityKeeper::NormalizeOption::
-                 StopIfFollowingWhiteSpacesStartsWithNBSP});
-    if (MOZ_UNLIKELY(pointToInsertOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesToSplitAt() failed");
-      return pointToInsertOrError.propagateErr();
-    }
-    pointToInsert = pointToInsertOrError.unwrap();
-    if (NS_WARN_IF(!pointToInsert.IsSetAndValidInComposedDoc())) {
-      return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-    }
+  Result<EditorDOMPoint, nsresult> pointToInsertOrError =
+      WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesToSplitAt(
+          *this, pointToInsert,
+          {WhiteSpaceVisibilityKeeper::NormalizeOption::
+               StopIfFollowingWhiteSpacesStartsWithNBSP});
+  if (MOZ_UNLIKELY(pointToInsertOrError.isErr())) {
+    NS_WARNING(
+        "WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesToSplitAt() failed");
+    return pointToInsertOrError.propagateErr();
+  }
+  pointToInsert = pointToInsertOrError.unwrap();
+  if (NS_WARN_IF(!pointToInsert.IsSetAndValidInComposedDoc())) {
+    return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
   }
 
   if (aOptions.contains(InsertElementOption::SplitAncestorInlineElements)) {
@@ -4457,8 +4455,7 @@
             !CanInsertLineBreak(*aPointToInsert.ContainerAs<nsIContent>()))) {
       return Err(NS_ERROR_FAILURE);
     }
-    if (!canNormalizeWhiteSpaces ||
-        !StaticPrefs::editor_white_space_normalization_blink_compatible()) {
+    if (!canNormalizeWhiteSpaces) {
       return aPointToInsert;
     }
     Result<EditorDOMPoint, nsresult> pointToInsertOrError =
@@ -4482,8 +4479,7 @@
   }
 
   Result<EditorDOMPoint, nsresult> pointToInsertOrError =
-      canNormalizeWhiteSpaces &&
-              StaticPrefs::editor_white_space_normalization_blink_compatible()
+      canNormalizeWhiteSpaces
           ? WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesToSplitAt(
                 *this, aPointToInsert,
                 {WhiteSpaceVisibilityKeeper::NormalizeOption::
@@ -5438,16 +5434,10 @@
       continue;
     }
     Result<JoinNodesResult, nsresult> joinNodesResultOrError =
-        StaticPrefs::editor_white_space_normalization_blink_compatible()
-            ? JoinTextNodesWithNormalizeWhiteSpaces(
-                  MOZ_KnownLive(leftTextNode), MOZ_KnownLive(rightTextNode))
-            : JoinNodesWithTransaction(MOZ_KnownLive(leftTextNode),
-                                       MOZ_KnownLive(rightTextNode));
+        JoinTextNodesWithNormalizeWhiteSpaces(MOZ_KnownLive(leftTextNode),
+                                              MOZ_KnownLive(rightTextNode));
     if (MOZ_UNLIKELY(joinNodesResultOrError.isErr())) {
-      NS_WARNING(
-          StaticPrefs::editor_white_space_normalization_blink_compatible()
-              ? "HTMLEditor::JoinTextNodesWithNormalizeWhiteSpaces() failed"
-              : "HTMLEditor::JoinNodesWithTransaction() failed");
+      NS_WARNING("HTMLEditor::JoinTextNodesWithNormalizeWhiteSpaces() failed");
       return joinNodesResultOrError.unwrapErr();
     }
   }
@@ -7913,110 +7903,6 @@
   // could destroy the editor
   nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;
 
-  if (!StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    // Selection changes caused by the hacks below should not be exposed because
-    // they should occur silently from web apps.
-    AutoHideSelectionChanges hideSelectionChangesCausedByTheHacks(
-        SelectionRef());
-    // When this is called, there is no toplevel edit sub-action. Then,
-    // InsertNodeWithTransaction() or ReplaceTextWithTransaction() will set it.
-    // Then, OnEndHandlingTopLevelEditSubActionInternal() will call
-    // WhiteSpaceVisibilityKeeper::NormalizeVisibleWhiteSpacesAt() and may reset
-    // the hack here.  Therefore, we need to make it sure that
-    // OnEndHandlingTopLevelEditSubActionInternal() does nothing later.
-    IgnoredErrorResult error;
-    AutoEditSubActionNotifier topLevelEditSubAction(
-        *this, EditSubAction::eMaintainWhiteSpaceVisibility, eNone, error);
-    NS_WARNING_ASSERTION(!error.Failed(),
-                         "Failed to set the toplevel edit sub-action to "
-                         "maintain white-space visibility, but ignored");
-
-    // If user typed a white-space at end of a text node recently, we should try
-    // to make it keep visible even after mutations caused by the web apps
-    // because only we use U+0020 as trailing visible white-space with <br>.
-    // Therefore, web apps may not take care of the white-space visibility.
-    // FIXME: Once we do this, the transaction should be merged to the last
-    // transaction for making an undoing deletes the inserted text too.
-    if (mLastCollapsibleWhiteSpaceAppendedTextNode &&
-        MOZ_LIKELY(
-            mLastCollapsibleWhiteSpaceAppendedTextNode->IsInComposedDoc() &&
-            mLastCollapsibleWhiteSpaceAppendedTextNode->IsEditable() &&
-            mLastCollapsibleWhiteSpaceAppendedTextNode->TextDataLength())) {
-      const auto atLastChar = EditorRawDOMPointInText::AtEndOf(
-          *mLastCollapsibleWhiteSpaceAppendedTextNode);
-      if (MOZ_LIKELY(atLastChar.IsPreviousCharCollapsibleASCIISpace())) {
-        if (const RefPtr<Element> editingHost = ComputeEditingHostInternal(
-                mLastCollapsibleWhiteSpaceAppendedTextNode,
-                LimitInBodyElement::No)) {
-          Result<CreateLineBreakResult, nsresult> insertPaddingBRResultOrError =
-              InsertPaddingBRElementIfNeeded(atLastChar.To<EditorDOMPoint>(),
-                                             eNoStrip, *editingHost);
-          if (MOZ_UNLIKELY(insertPaddingBRResultOrError.isErr())) {
-            if (insertPaddingBRResultOrError.inspectErr() ==
-                NS_ERROR_EDITOR_DESTROYED) {
-              NS_WARNING(
-                  "HTMLEditor::InsertPaddingBRElementIfNeeded(nsIEditor::"
-                  "eNoStrip) destroyed the editor");
-              return insertPaddingBRResultOrError.unwrapErr();
-            }
-            NS_WARNING(
-                "HTMLEditor::InsertPaddingBRElementIfNeeded(nsIEditor::"
-                "eNoStrip) failed, but ignored");
-          } else {
-            // We should not update selection for the mutation to maintain the
-            // white-space visibility.
-            insertPaddingBRResultOrError.unwrap().IgnoreCaretPointSuggestion();
-          }
-        }
-      }
-    }
-
-    // If padding <br> element which made preceding collapsible ASCII
-    // white-space visible was removed by web app, we need to replace the
-    // white-space with an NBSP to make it keep visible until bug 503838 is
-    // fixed.
-    if (!aRunner.NewInvisibleWhiteSpacesRef().IsEmpty()) {
-      AutoSelectionRestorer restoreSelection(this);
-      bool doRestoreSelection = false;
-      for (const EditorDOMPointInText& atCollapsibleWhiteSpace :
-           aRunner.NewInvisibleWhiteSpacesRef()) {
-        if (!atCollapsibleWhiteSpace.IsInComposedDoc() ||
-            !atCollapsibleWhiteSpace.IsAtLastContent() ||
-            !HTMLEditUtils::IsSimplyEditableNode(
-                *atCollapsibleWhiteSpace.ContainerAs<Text>()) ||
-            !atCollapsibleWhiteSpace.IsCharCollapsibleASCIISpace()) {
-          continue;
-        }
-        const Element* const editingHost =
-            atCollapsibleWhiteSpace.ContainerAs<Text>()->GetEditingHost();
-        if (MOZ_UNLIKELY(!editingHost)) {
-          continue;
-        }
-        const WSScanResult nextThing =
-            WSRunScanner::ScanInclusiveNextVisibleNodeOrBlockBoundary(
-                WSRunScanner::Scan::EditableNodes,
-                atCollapsibleWhiteSpace.AfterContainer<EditorRawDOMPoint>(),
-                BlockInlineCheck::UseComputedDisplayStyle);
-        if (!nextThing.ReachedBlockBoundary()) {
-          continue;
-        }
-        Result<InsertTextResult, nsresult> replaceToNBSPResultOrError =
-            ReplaceTextWithTransaction(
-                MOZ_KnownLive(*atCollapsibleWhiteSpace.ContainerAs<Text>()),
-                atCollapsibleWhiteSpace.Offset(), 1u, u"\xA0"_ns);
-        if (MOZ_UNLIKELY(replaceToNBSPResultOrError.isErr())) {
-          NS_WARNING("HTMLEditor::ReplaceTextWithTransaction() failed");
-          continue;
-        }
-        doRestoreSelection = true;
-        replaceToNBSPResultOrError.unwrap().IgnoreCaretPointSuggestion();
-      }
-      if (!doRestoreSelection) {
-        restoreSelection.Abort();
-      }
-    }
-  }
-
   // Delete our padding <br> element for empty editor, if we have one, since
   // the document might not be empty any more.
   nsresult rv = EnsureNoPaddingBRElementForEmptyEditor();
@@ -8039,49 +7925,4 @@
   return rv;
 }
 
-/*****************************************************************************
- * mozilla::HTMLEditor::DocumentModifiedEvent
- *****************************************************************************/
-
-void HTMLEditor::DocumentModifiedEvent::MaybeAppendNewInvisibleWhiteSpace(
-    const nsIContent* aContentWillBeRemoved) {
-  // If the web app deletes a padding `<br>` which is required for the previous
-  // collapsible white-space, we need to replace the collapsible white-space
-  // with an NBSP until bug 503838 gets fixed.  For here, we should just store
-  // the candidate white-space which becomes invisible.
-  // FIXME: This does not work well if a padding `<br>` is removed with its
-  // parent.
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible() ||
-      !aContentWillBeRemoved || !aContentWillBeRemoved->IsInComposedDoc() ||
-      !HTMLEditUtils::IsSimplyEditableNode(*aContentWillBeRemoved) ||
-      !aContentWillBeRemoved->IsHTMLElement(nsGkAtoms::br)) {
-    return;
-  }
-  const WSScanResult nextThing =
-      WSRunScanner::ScanInclusiveNextVisibleNodeOrBlockBoundary(
-          WSRunScanner::Scan::EditableNodes,
-          EditorRawDOMPoint::After(*aContentWillBeRemoved),
-          BlockInlineCheck::UseComputedDisplayStyle);
-  if (!nextThing.ReachedBlockBoundary()) {
-    return;
-  }
-  const WSScanResult previousThing =
-      WSRunScanner::ScanPreviousVisibleNodeOrBlockBoundary(
-          WSRunScanner::Scan::EditableNodes,
-          EditorRawDOMPoint(aContentWillBeRemoved),
-          BlockInlineCheck::UseComputedDisplayOutsideStyle);
-  if (!previousThing.ContentIsText() || !previousThing.IsContentEditable()) {
-    return;
-  }
-  const auto atCollapsibleWhiteSpace =
-      previousThing.PointAtReachedContent<EditorRawDOMPoint>();
-  MOZ_ASSERT(atCollapsibleWhiteSpace.IsAtLastContent());
-  if (!atCollapsibleWhiteSpace.IsCharCollapsibleASCIISpace()) {
-    return;
-  }
-  mNewInvisibleWhiteSpaces.AppendElement(
-      EditorDOMPointInText(atCollapsibleWhiteSpace.ContainerAs<Text>(),
-                           atCollapsibleWhiteSpace.Offset()));
-}
-
 }  // namespace mozilla