# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: editor/libeditor/HTMLEditorDeleteHandler.cpp
# Commit: 366245552cae
# Full Hash: 366245552cae536ef883be806322395dc47b759d
# Author: Masayuki Nakano <masayuki@d-toybox.com>
# Date: 2025-06-17 09:24:05
# Regressor Bug: 1951038
# File Overlap Count: 1
# Description:
#   Bug 1951038 - Get rid of the legacy white-space normalizer of `HTMLEditor` and the pref r=m_kato
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D253589
# ==============================================================================

diff -r b13b0a530402 -r 366245552cae editor/libeditor/HTMLEditorDeleteHandler.cpp
--- a/editor/libeditor/HTMLEditorDeleteHandler.cpp	Tue Jun 17 00:10:27 2025 +0000
+++ b/editor/libeditor/HTMLEditorDeleteHandler.cpp	Tue Jun 17 00:37:22 2025 +0000
@@ -208,34 +208,6 @@
       AutoClonedSelectionRangeArray& aRangesToDelete) const;
 
   /**
-   * Handles deletion of collapsed selection at white-spaces in a text node.
-   *
-   * @param aDirectionAndAmount Direction of the deletion.
-   * @param aPointToDelete      The point to delete.  I.e., typically, caret
-   *                            position.
-   * @param aEditingHost        The editing host.
-   */
-  [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<CaretPoint, nsresult>
-  HandleDeleteCollapsedSelectionAtWhiteSpaces(
-      HTMLEditor& aHTMLEditor, nsIEditor::EDirection aDirectionAndAmount,
-      const EditorDOMPoint& aPointToDelete, const Element& aEditingHost);
-
-  /**
-   * Handle deletion of collapsed selection in a text node.
-   *
-   * @param aDirectionAndAmount Direction of the deletion.
-   * @param aRangesToDelete     Computed selection ranges to delete.
-   * @param aPointAtDeletingChar   The visible char position which you want to
-   *                               delete.
-   * @param aEditingHost        The editing host.
-   */
-  [[nodiscard]] MOZ_CAN_RUN_SCRIPT Result<CaretPoint, nsresult>
-  HandleDeleteCollapsedSelectionAtVisibleChar(
-      HTMLEditor& aHTMLEditor, nsIEditor::EDirection aDirectionAndAmount,
-      AutoClonedSelectionRangeArray& aRangesToDelete,
-      const EditorDOMPoint& aPointAtDeletingChar, const Element& aEditingHost);
-
-  /**
    * Handle deletion of atomic elements like <br>, <hr>, <img>, <input>, etc and
    * data nodes except text node (e.g., comment node). Note that don't call this
    * directly with `<hr>` element.
@@ -406,46 +378,43 @@
       return mOriginalStripWrappers;
     }();
 
-    if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-      {
-        AutoTrackDOMRange firstRangeTracker(aHTMLEditor.RangeUpdaterRef(),
-                                            &aRangesToDelete.FirstRangeRef());
-        for (OwningNonNull<nsRange>& range :
-             Reversed(aRangesToDelete.Ranges())) {
-          if (MOZ_UNLIKELY(!range->IsPositioned() || range->Collapsed())) {
-            continue;
-          }
-          Maybe<AutoTrackDOMRange> trackRange;
-          if (range != aRangesToDelete.FirstRangeRef()) {
-            trackRange.emplace(aHTMLEditor.RangeUpdaterRef(), &range);
-          }
-          Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
-              WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
-                  aHTMLEditor, EditorDOMRange(range));
-          if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
-            NS_WARNING(
-                "WhiteSpaceVisibilityKeeper::"
-                "NormalizeSurroundingWhiteSpacesToJoin() failed");
-            return rangeToDeleteOrError.propagateErr();
-          }
-          trackRange.reset();
-          EditorDOMRange rangeToDelete = rangeToDeleteOrError.unwrap();
-          if (MOZ_LIKELY(rangeToDelete.IsPositionedAndValidInComposedDoc())) {
-            nsresult rv = range->SetStartAndEnd(
-                rangeToDelete.StartRef().ToRawRangeBoundary(),
-                rangeToDelete.EndRef().ToRawRangeBoundary());
-            if (NS_FAILED(rv)) {
-              NS_WARNING("nsRange::SetStartAndEnd() failed");
-              return Err(rv);
-            }
+    {
+      AutoTrackDOMRange firstRangeTracker(aHTMLEditor.RangeUpdaterRef(),
+                                          &aRangesToDelete.FirstRangeRef());
+      for (OwningNonNull<nsRange>& range : Reversed(aRangesToDelete.Ranges())) {
+        if (MOZ_UNLIKELY(!range->IsPositioned() || range->Collapsed())) {
+          continue;
+        }
+        Maybe<AutoTrackDOMRange> trackRange;
+        if (range != aRangesToDelete.FirstRangeRef()) {
+          trackRange.emplace(aHTMLEditor.RangeUpdaterRef(), &range);
+        }
+        Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
+            WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
+                aHTMLEditor, EditorDOMRange(range));
+        if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
+          NS_WARNING(
+              "WhiteSpaceVisibilityKeeper::"
+              "NormalizeSurroundingWhiteSpacesToJoin() failed");
+          return rangeToDeleteOrError.propagateErr();
+        }
+        trackRange.reset();
+        EditorDOMRange rangeToDelete = rangeToDeleteOrError.unwrap();
+        if (MOZ_LIKELY(rangeToDelete.IsPositionedAndValidInComposedDoc())) {
+          nsresult rv = range->SetStartAndEnd(
+              rangeToDelete.StartRef().ToRawRangeBoundary(),
+              rangeToDelete.EndRef().ToRawRangeBoundary());
+          if (NS_FAILED(rv)) {
+            NS_WARNING("nsRange::SetStartAndEnd() failed");
+            return Err(rv);
           }
         }
       }
-      aRangesToDelete.RemoveCollapsedRanges();
-      if (MOZ_UNLIKELY(aRangesToDelete.IsCollapsed())) {
-        return CaretPoint(
-            EditorDOMPoint(aRangesToDelete.FirstRangeRef()->StartRef()));
-      }
+    }
+    aRangesToDelete.RemoveCollapsedRanges();
+    if (MOZ_UNLIKELY(aRangesToDelete.IsCollapsed())) {
+      return CaretPoint(
+          EditorDOMPoint(aRangesToDelete.FirstRangeRef()->StartRef()));
     }
 
     Result<CaretPoint, nsresult> caretPointOrError =
@@ -2159,93 +2128,37 @@
       *aWSRunScannerAtCaret.ScanStartRef().ContainerAs<nsIContent>(),
       EditorType::HTML));
 
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    if (aScanFromCaretPointResult.InCollapsibleWhiteSpaces() ||
-        aScanFromCaretPointResult.InNonCollapsibleCharacters() ||
-        aScanFromCaretPointResult.ReachedPreformattedLineBreak()) {
-      // This means that if aDirectionAndAmount == nsIEditor::eNext, collapse
-      // selection at the found character.  Otherwise, collapse selection after
-      // the found character.
-      nsresult rv = aRangesToDelete.Collapse(
-          aScanFromCaretPointResult.Point_Deprecated<EditorRawDOMPoint>());
-      if (NS_FAILED(rv)) {
-        NS_WARNING("AutoClonedRangeArray::Collapse() failed");
-        return Err(NS_ERROR_FAILURE);
-      }
-      Result<CaretPoint, nsresult> caretPointOrError =
-          HandleDeleteTextAroundCollapsedRanges(
-              aHTMLEditor, aDirectionAndAmount, aRangesToDelete, aEditingHost);
-      if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-        NS_WARNING(
-            "AutoDeleteRangesHandler::HandleDeleteTextAroundCollapsedRanges() "
-            "failed");
-        return caretPointOrError.propagateErr();
-      }
-      rv = caretPointOrError.unwrap().SuggestCaretPointTo(
-          aHTMLEditor, {SuggestCaret::OnlyIfHasSuggestion,
-                        SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
-                        SuggestCaret::AndIgnoreTrivialError});
-      if (NS_FAILED(rv)) {
-        NS_WARNING("CaretPoint::SuggestCaretPointTo() failed");
-        return Err(rv);
-      }
-      NS_WARNING_ASSERTION(
-          rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-          "CaretPoint::SuggestCaretPoint() failed, but ignored");
-      return EditActionResult::HandledResult();
-    }
-  }
-
   if (aScanFromCaretPointResult.InCollapsibleWhiteSpaces() ||
+      aScanFromCaretPointResult.InNonCollapsibleCharacters() ||
       aScanFromCaretPointResult.ReachedPreformattedLineBreak()) {
+    // This means that if aDirectionAndAmount == nsIEditor::eNext, collapse
+    // selection at the found character.  Otherwise, collapse selection after
+    // the found character.
+    nsresult rv = aRangesToDelete.Collapse(
+        aScanFromCaretPointResult.Point_Deprecated<EditorRawDOMPoint>());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("AutoClonedRangeArray::Collapse() failed");
+      return Err(NS_ERROR_FAILURE);
+    }
     Result<CaretPoint, nsresult> caretPointOrError =
-        HandleDeleteCollapsedSelectionAtWhiteSpaces(
-            aHTMLEditor, aDirectionAndAmount,
-            aWSRunScannerAtCaret.ScanStartRef(), aEditingHost);
+        HandleDeleteTextAroundCollapsedRanges(aHTMLEditor, aDirectionAndAmount,
+                                              aRangesToDelete, aEditingHost);
     if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
       NS_WARNING(
-          "AutoDeleteRangesHandler::"
-          "HandleDeleteCollapsedSelectionAtWhiteSpaces() failed");
+          "AutoDeleteRangesHandler::HandleDeleteTextAroundCollapsedRanges() "
+          "failed");
       return caretPointOrError.propagateErr();
     }
-    nsresult rv = caretPointOrError.unwrap().SuggestCaretPointTo(
-        aHTMLEditor, {SuggestCaret::OnlyIfHasSuggestion});
+    rv = caretPointOrError.unwrap().SuggestCaretPointTo(
+        aHTMLEditor, {SuggestCaret::OnlyIfHasSuggestion,
+                      SuggestCaret::OnlyIfTransactionsAllowedToDoIt,
+                      SuggestCaret::AndIgnoreTrivialError});
     if (NS_FAILED(rv)) {
       NS_WARNING("CaretPoint::SuggestCaretPointTo() failed");
       return Err(rv);
     }
-    NS_WARNING_ASSERTION(
-        rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-        "CaretPoint::SuggestCaretPointTo() failed, but ignored");
-    return EditActionResult::HandledResult();
-  }
-
-  if (aScanFromCaretPointResult.InNonCollapsibleCharacters()) {
-    if (NS_WARN_IF(!aScanFromCaretPointResult.ContentIsText())) {
-      return Err(NS_ERROR_FAILURE);
-    }
-    Result<CaretPoint, nsresult> caretPointOrError =
-        HandleDeleteCollapsedSelectionAtVisibleChar(
-            aHTMLEditor, aDirectionAndAmount, aRangesToDelete,
-            // This means that if aDirectionAndAmount == nsIEditor::eNext,
-            // at the found character.  Otherwise, after the found character.
-            aScanFromCaretPointResult.Point_Deprecated<EditorDOMPoint>(),
-            aEditingHost);
-    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-      NS_WARNING(
-          "AutoDeleteRangesHandler::"
-          "HandleDeleteCollapsedSelectionAtVisibleChar() failed");
-      return caretPointOrError.propagateErr();
-    }
-    nsresult rv = caretPointOrError.unwrap().SuggestCaretPointTo(
-        aHTMLEditor, {SuggestCaret::OnlyIfHasSuggestion});
-    if (NS_FAILED(rv)) {
-      NS_WARNING("CaretPoint::SuggestCaretPointTo() failed");
-      return Err(rv);
-    }
-    NS_WARNING_ASSERTION(
-        rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
-        "CaretPoint::SuggestCaretPointTo() failed, but ignored");
+    NS_WARNING_ASSERTION(rv != NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR,
+                         "CaretPoint::SuggestCaretPoint() failed, but ignored");
     return EditActionResult::HandledResult();
   }
 
@@ -2405,7 +2318,6 @@
     HTMLEditor& aHTMLEditor, nsIEditor::EDirection aDirectionAndAmount,
     AutoClonedSelectionRangeArray& aRangesToDelete,
     const Element& aEditingHost) {
-  MOZ_ASSERT(StaticPrefs::editor_white_space_normalization_blink_compatible());
   MOZ_ASSERT(aHTMLEditor.IsEditActionDataAvailable());
   MOZ_ASSERT(aDirectionAndAmount == nsIEditor::eNext ||
              aDirectionAndAmount == nsIEditor::ePrevious);
@@ -2497,343 +2409,6 @@
   return CaretPoint(lineBreakOrError.unwrap().UnwrapCaretPoint());
 }
 
-Result<CaretPoint, nsresult> HTMLEditor::AutoDeleteRangesHandler::
-    HandleDeleteCollapsedSelectionAtWhiteSpaces(
-        HTMLEditor& aHTMLEditor, nsIEditor::EDirection aDirectionAndAmount,
-        const EditorDOMPoint& aPointToDelete, const Element& aEditingHost) {
-  MOZ_ASSERT(aHTMLEditor.IsEditActionDataAvailable());
-  MOZ_ASSERT(!StaticPrefs::editor_white_space_normalization_blink_compatible());
-
-  EditorDOMPoint pointToPutCaret;
-  if (aDirectionAndAmount == nsIEditor::eNext) {
-    Result<CaretPoint, nsresult> caretPointOrError =
-        WhiteSpaceVisibilityKeeper::DeleteInclusiveNextWhiteSpace(
-            aHTMLEditor, aPointToDelete, aEditingHost);
-    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::DeleteInclusiveNextWhiteSpace() failed");
-      return caretPointOrError;
-    }
-    caretPointOrError.unwrap().MoveCaretPointTo(
-        pointToPutCaret, aHTMLEditor,
-        {SuggestCaret::OnlyIfHasSuggestion,
-         SuggestCaret::OnlyIfTransactionsAllowedToDoIt});
-  } else {
-    Result<CaretPoint, nsresult> caretPointOrError =
-        WhiteSpaceVisibilityKeeper::DeletePreviousWhiteSpace(
-            aHTMLEditor, aPointToDelete, aEditingHost);
-    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::DeletePreviousWhiteSpace() failed");
-      return caretPointOrError;
-    }
-    caretPointOrError.unwrap().MoveCaretPointTo(
-        pointToPutCaret, aHTMLEditor,
-        {SuggestCaret::OnlyIfHasSuggestion,
-         SuggestCaret::OnlyIfTransactionsAllowedToDoIt});
-  }
-
-  if (MOZ_LIKELY(pointToPutCaret.IsInContentNode())) {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    nsresult rv =
-        aHTMLEditor.EnsureNoFollowingUnnecessaryLineBreak(pointToPutCaret);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("HTMLEditor::EnsureNoFollowingUnnecessaryLineBreak() failed");
-      return Err(rv);
-    }
-    trackPointToPutCaret.FlushAndStopTracking();
-    if (NS_WARN_IF(!pointToPutCaret.IsSet())) {
-      return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-    }
-  }
-
-  auto newCaretPosition =
-      aHTMLEditor.GetFirstSelectionStartPoint<EditorDOMPoint>();
-  if (MOZ_UNLIKELY(!newCaretPosition.IsSet())) {
-    NS_WARNING("There was no selection range");
-    return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-  }
-  const bool isDeleteSelection = aHTMLEditor.GetTopLevelEditSubAction() ==
-                                 EditSubAction::eDeleteSelectedContent;
-  AutoTrackDOMPoint trackCaretPoint(aHTMLEditor.RangeUpdaterRef(),
-                                    &pointToPutCaret);
-  if (isDeleteSelection) {
-    // Don't remove empty inline elements in the plaintext-only mode because
-    // nobody can restore the style again.
-    if (MOZ_LIKELY(newCaretPosition.IsInContentNode()) &&
-        !aEditingHost.IsContentEditablePlainTextOnly() &&
-        MOZ_LIKELY(HTMLEditUtils::IsRemovableFromParentNode(
-            *newCaretPosition.ContainerAs<nsIContent>()))) {
-      Result<CaretPoint, nsresult> caretPointOrError =
-          aHTMLEditor.DeleteEmptyInclusiveAncestorInlineElements(
-              MOZ_KnownLive(*newCaretPosition.ContainerAs<nsIContent>()),
-              aEditingHost);
-      if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-        NS_WARNING(
-            "HTMLEditor::DeleteEmptyInclusiveAncestorInlineElements() failed");
-        return caretPointOrError.propagateErr();
-      }
-      caretPointOrError.unwrap().MoveCaretPointTo(
-          newCaretPosition, {SuggestCaret::OnlyIfHasSuggestion});
-      if (NS_WARN_IF(!newCaretPosition.IsSetAndValidInComposedDoc())) {
-        return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-      }
-    }
-  }
-  if ((aHTMLEditor.IsMailEditor() || aHTMLEditor.IsPlaintextMailComposer()) &&
-      MOZ_LIKELY(newCaretPosition.IsInContentNode())) {
-    AutoTrackDOMPoint trackNewCaretPosition(aHTMLEditor.RangeUpdaterRef(),
-                                            &newCaretPosition);
-    nsresult rv = aHTMLEditor.DeleteMostAncestorMailCiteElementIfEmpty(
-        MOZ_KnownLive(*newCaretPosition.ContainerAs<nsIContent>()));
-    if (NS_FAILED(rv)) {
-      NS_WARNING(
-          "HTMLEditor::DeleteMostAncestorMailCiteElementIfEmpty() failed");
-      return Err(rv);
-    }
-    trackNewCaretPosition.FlushAndStopTracking();
-    if (NS_WARN_IF(!newCaretPosition.IsSetAndValidInComposedDoc())) {
-      return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-    }
-  }
-  if (isDeleteSelection) {
-    Result<CreateLineBreakResult, nsresult> insertPaddingBRElementOrError =
-        aHTMLEditor.InsertPaddingBRElementIfNeeded(
-            newCaretPosition,
-            aEditingHost.IsContentEditablePlainTextOnly() ? nsIEditor::eNoStrip
-                                                          : nsIEditor::eStrip,
-            aEditingHost);
-    if (MOZ_UNLIKELY(insertPaddingBRElementOrError.isErr())) {
-      NS_WARNING("HTMLEditor::InsertPaddingBRElementIfNeeded() failed");
-      return insertPaddingBRElementOrError.propagateErr();
-    }
-    trackCaretPoint.FlushAndStopTracking();
-    if (!pointToPutCaret.IsInTextNode()) {
-      insertPaddingBRElementOrError.unwrap().MoveCaretPointTo(
-          pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
-    } else {
-      insertPaddingBRElementOrError.unwrap().IgnoreCaretPointSuggestion();
-    }
-  }
-  trackCaretPoint.FlushAndStopTracking();
-  return CaretPoint(std::move(pointToPutCaret));
-}
-
-Result<CaretPoint, nsresult> HTMLEditor::AutoDeleteRangesHandler::
-    HandleDeleteCollapsedSelectionAtVisibleChar(
-        HTMLEditor& aHTMLEditor, nsIEditor::EDirection aDirectionAndAmount,
-        AutoClonedSelectionRangeArray& aRangesToDelete,
-        const EditorDOMPoint& aPointAtDeletingChar,
-        const Element& aEditingHost) {
-  MOZ_ASSERT(aHTMLEditor.IsTopLevelEditSubActionDataAvailable());
-  MOZ_ASSERT(!StaticPrefs::editor_white_space_normalization_blink_compatible());
-  MOZ_ASSERT(aPointAtDeletingChar.IsSet());
-  MOZ_ASSERT(aPointAtDeletingChar.IsInTextNode());
-
-  OwningNonNull<Text> visibleTextNode =
-      *aPointAtDeletingChar.ContainerAs<Text>();
-  EditorDOMPoint startToDelete, endToDelete;
-  // FIXME: This does not care grapheme cluster of complicate character
-  // sequence like Emoji.
-  // TODO: Investigate what happens if a grapheme cluster which should be
-  // delete once is split to multiple text nodes.
-  // TODO: We should stop using this path, instead, we should extend the range
-  // before calling this method.
-  if (aDirectionAndAmount == nsIEditor::ePrevious) {
-    if (MOZ_UNLIKELY(aPointAtDeletingChar.IsStartOfContainer())) {
-      return Err(NS_ERROR_UNEXPECTED);
-    }
-    startToDelete = aPointAtDeletingChar.PreviousPoint();
-    endToDelete = aPointAtDeletingChar;
-    // Bug 1068979: delete both codepoints if surrogate pair
-    if (!startToDelete.IsStartOfContainer()) {
-      const nsTextFragment* text = &visibleTextNode->TextFragment();
-      if (text->IsLowSurrogateFollowingHighSurrogateAt(
-              startToDelete.Offset())) {
-        startToDelete.RewindOffset();
-      }
-    }
-  } else {
-    if (NS_WARN_IF(aRangesToDelete.Ranges().IsEmpty()) ||
-        NS_WARN_IF(aRangesToDelete.FirstRangeRef()->GetStartContainer() !=
-                   aPointAtDeletingChar.GetContainer()) ||
-        NS_WARN_IF(aRangesToDelete.FirstRangeRef()->GetEndContainer() !=
-                   aPointAtDeletingChar.GetContainer())) {
-      return Err(NS_ERROR_FAILURE);
-    }
-    startToDelete = aRangesToDelete.FirstRangeRef()->StartRef();
-    endToDelete = aRangesToDelete.FirstRangeRef()->EndRef();
-  }
-
-  {
-    Result<CaretPoint, nsresult> caretPointOrError =
-        WhiteSpaceVisibilityKeeper::PrepareToDeleteRangeAndTrackPoints(
-            aHTMLEditor, &startToDelete, &endToDelete, aEditingHost);
-    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::PrepareToDeleteRangeAndTrackPoints() "
-          "failed");
-      return caretPointOrError.propagateErr();
-    }
-    // Ignore caret position because we'll set caret position below
-    caretPointOrError.unwrap().IgnoreCaretPointSuggestion();
-  }
-
-  if (aHTMLEditor.MayHaveMutationEventListeners(
-          NS_EVENT_BITS_MUTATION_NODEREMOVED |
-          NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT |
-          NS_EVENT_BITS_MUTATION_ATTRMODIFIED |
-          NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED) &&
-      (NS_WARN_IF(!startToDelete.IsSetAndValid()) ||
-       NS_WARN_IF(!startToDelete.IsInTextNode()) ||
-       NS_WARN_IF(!endToDelete.IsSetAndValid()) ||
-       NS_WARN_IF(!endToDelete.IsInTextNode()) ||
-       NS_WARN_IF(startToDelete.ContainerAs<Text>() != visibleTextNode) ||
-       NS_WARN_IF(endToDelete.ContainerAs<Text>() != visibleTextNode) ||
-       NS_WARN_IF(startToDelete.Offset() >= endToDelete.Offset()))) {
-    NS_WARNING("Mutation event listener changed the DOM tree");
-    return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-  }
-
-  EditorDOMPoint pointToPutCaret = startToDelete;
-  {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    Result<CaretPoint, nsresult> caretPointOrError =
-        aHTMLEditor.DeleteTextWithTransaction(
-            visibleTextNode, startToDelete.Offset(),
-            endToDelete.Offset() - startToDelete.Offset());
-    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-      NS_WARNING("HTMLEditor::DeleteTextWithTransaction() failed");
-      return caretPointOrError.propagateErr();
-    }
-    trackPointToPutCaret.FlushAndStopTracking();
-    caretPointOrError.unwrap().MoveCaretPointTo(
-        pointToPutCaret, aHTMLEditor, {SuggestCaret::OnlyIfHasSuggestion});
-  }
-
-  // XXX When Backspace key is pressed, Chromium removes following empty
-  //     text nodes when removing the last character of the non-empty text
-  //     node.  However, Edge never removes empty text nodes even if
-  //     selection is in the following empty text node(s).  For now, we
-  //     should keep our traditional behavior same as Edge for backward
-  //     compatibility.
-  // XXX When Delete key is pressed, Edge removes all preceding empty
-  //     text nodes when removing the first character of the non-empty
-  //     text node.  Chromium removes only selected empty text node and
-  //     following empty text nodes and the first character of the
-  //     non-empty text node.  For now, we should keep our traditional
-  //     behavior same as Chromium for backward compatibility.
-  {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    nsresult rv =
-        DeleteNodeIfInvisibleAndEditableTextNode(aHTMLEditor, visibleTextNode);
-    if (NS_WARN_IF(rv == NS_ERROR_EDITOR_DESTROYED)) {
-      return Err(NS_ERROR_EDITOR_DESTROYED);
-    }
-    NS_WARNING_ASSERTION(
-        NS_SUCCEEDED(rv),
-        "AutoDeleteRangesHandler::DeleteNodeIfInvisibleAndEditableTextNode() "
-        "failed, but ignored");
-  }
-
-  if (NS_WARN_IF(!pointToPutCaret.IsSet())) {
-    return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-  }
-
-  if (MOZ_LIKELY(pointToPutCaret.IsInContentNode())) {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    nsresult rv =
-        aHTMLEditor.EnsureNoFollowingUnnecessaryLineBreak(pointToPutCaret);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("HTMLEditor::EnsureNoFollowingUnnecessaryLineBreak() failed");
-      return Err(rv);
-    }
-  }
-  if (NS_WARN_IF(!pointToPutCaret.IsSet())) {
-    return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-  }
-
-  // XXX `Selection` may be modified by mutation event listeners so
-  //     that we should use EditorDOMPoint::AtEndOf(visibleTextNode)
-  //     instead.  (Perhaps, we don't and/or shouldn't need to do this
-  //     if the text node is preformatted.)
-  const bool isDeleteSelection = aHTMLEditor.GetTopLevelEditSubAction() ==
-                                 EditSubAction::eDeleteSelectedContent;
-  if (isDeleteSelection) {
-    // Don't remove empty inline elements in the plaintext-only mode because
-    // nobody can restore the style again.
-    if (MOZ_LIKELY(pointToPutCaret.IsInContentNode()) &&
-        !aEditingHost.IsContentEditablePlainTextOnly() &&
-        MOZ_LIKELY(HTMLEditUtils::IsRemovableFromParentNode(
-            *pointToPutCaret.ContainerAs<nsIContent>()))) {
-      AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                             &pointToPutCaret);
-      Result<CaretPoint, nsresult> caretPointOrError =
-          aHTMLEditor.DeleteEmptyInclusiveAncestorInlineElements(
-              MOZ_KnownLive(*pointToPutCaret.ContainerAs<nsIContent>()),
-              aEditingHost);
-      if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-        NS_WARNING(
-            "HTMLEditor::DeleteEmptyInclusiveAncestorInlineElements() failed");
-        return caretPointOrError;
-      }
-      trackPointToPutCaret.FlushAndStopTracking();
-      caretPointOrError.unwrap().MoveCaretPointTo(
-          pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
-      if (NS_WARN_IF(!pointToPutCaret.IsSetAndValidInComposedDoc())) {
-        return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-      }
-    }
-  }
-
-  if ((aHTMLEditor.IsMailEditor() || aHTMLEditor.IsPlaintextMailComposer()) &&
-      MOZ_LIKELY(pointToPutCaret.IsInContentNode())) {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    nsresult rv = aHTMLEditor.DeleteMostAncestorMailCiteElementIfEmpty(
-        MOZ_KnownLive(*pointToPutCaret.ContainerAs<nsIContent>()));
-    if (NS_FAILED(rv)) {
-      NS_WARNING(
-          "HTMLEditor::DeleteMostAncestorMailCiteElementIfEmpty() failed");
-      return Err(rv);
-    }
-    trackPointToPutCaret.FlushAndStopTracking();
-    if (NS_WARN_IF(!pointToPutCaret.IsSetAndValidInComposedDoc())) {
-      return Err(NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE);
-    }
-  }
-
-  if (isDeleteSelection) {
-    AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
-                                           &pointToPutCaret);
-    Result<CreateLineBreakResult, nsresult> insertPaddingBRElementOrError =
-        aHTMLEditor.InsertPaddingBRElementIfNeeded(
-            pointToPutCaret,
-            aEditingHost.IsContentEditablePlainTextOnly() ? nsIEditor::eNoStrip
-                                                          : nsIEditor::eStrip,
-            aEditingHost);
-    if (MOZ_UNLIKELY(insertPaddingBRElementOrError.isErr())) {
-      NS_WARNING("HTMLEditor::InsertPaddingBRElementIfNeeded() failed");
-      return insertPaddingBRElementOrError.propagateErr();
-    }
-    trackPointToPutCaret.FlushAndStopTracking();
-    if (!pointToPutCaret.IsInTextNode()) {
-      insertPaddingBRElementOrError.unwrap().MoveCaretPointTo(
-          pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
-    } else {
-      insertPaddingBRElementOrError.unwrap().IgnoreCaretPointSuggestion();
-    }
-  }
-  // Remember that we did a ranged delete for the benefit of
-  // AfterEditInner().
-  aHTMLEditor.TopLevelEditSubActionDataRef().mDidDeleteNonCollapsedRange = true;
-  return CaretPoint(std::move(pointToPutCaret));
-}
-
 // static
 nsIContent* HTMLEditor::AutoDeleteRangesHandler::GetAtomicContentToDelete(
     nsIEditor::EDirection aDirectionAndAmount,
@@ -3305,8 +2880,7 @@
     return Err(NS_ERROR_FAILURE);
   }
 
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible() &&
-      (mMode == Mode::DeletePrecedingBRElementOfBlock ||
+  if ((mMode == Mode::DeletePrecedingBRElementOfBlock ||
        mMode == Mode::DeletePrecedingPreformattedLineBreak) &&
       pointToPutCaret.IsSetAndValidInComposedDoc()) {
     // If we're deleting only the preceding lines of a block, we should
@@ -3362,37 +2936,34 @@
     NS_WARNING("HTMLEditUtils::GetGoodCaretPointFor() failed");
     return Err(NS_ERROR_FAILURE);
   }
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    // If we're deleting only a line break and move caret to left block, we
-    // want to normalize the white-spaces at end of the left block for the
-    // compatibility with the other browsers.
-    WSScanResult nextThingOfCaretPoint =
+  // If we're deleting only a line break and move caret to left block, we
+  // want to normalize the white-spaces at end of the left block for the
+  // compatibility with the other browsers.
+  WSScanResult nextThingOfCaretPoint =
+      WSRunScanner::ScanInclusiveNextVisibleNodeOrBlockBoundary(
+          WSRunScanner::Scan::All, newCaretPosition,
+          BlockInlineCheck::UseComputedDisplayOutsideStyle);
+  if (nextThingOfCaretPoint.ReachedBRElement() ||
+      nextThingOfCaretPoint.ReachedPreformattedLineBreak()) {
+    nextThingOfCaretPoint =
         WSRunScanner::ScanInclusiveNextVisibleNodeOrBlockBoundary(
-            WSRunScanner::Scan::All, newCaretPosition,
+            WSRunScanner::Scan::All,
+            nextThingOfCaretPoint.PointAfterReachedContent<EditorRawDOMPoint>(),
             BlockInlineCheck::UseComputedDisplayOutsideStyle);
-    if (nextThingOfCaretPoint.ReachedBRElement() ||
-        nextThingOfCaretPoint.ReachedPreformattedLineBreak()) {
-      nextThingOfCaretPoint =
-          WSRunScanner::ScanInclusiveNextVisibleNodeOrBlockBoundary(
-              WSRunScanner::Scan::All,
-              nextThingOfCaretPoint
-                  .PointAfterReachedContent<EditorRawDOMPoint>(),
-              BlockInlineCheck::UseComputedDisplayOutsideStyle);
-    }
-    if (nextThingOfCaretPoint.ReachedBlockBoundary()) {
-      const EditorDOMPoint atBlockBoundary =
-          nextThingOfCaretPoint.ReachedCurrentBlockBoundary()
-              ? EditorDOMPoint::AtEndOf(*nextThingOfCaretPoint.ElementPtr())
-              : EditorDOMPoint(nextThingOfCaretPoint.ElementPtr());
-      Result<EditorDOMPoint, nsresult> afterLastVisibleThingOrError =
-          WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesBefore(
-              aHTMLEditor, atBlockBoundary, {});
-      if (MOZ_UNLIKELY(afterLastVisibleThingOrError.isErr())) {
-        NS_WARNING(
-            "WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesBefore() "
-            "failed");
-        return afterLastVisibleThingOrError.propagateErr();
-      }
+  }
+  if (nextThingOfCaretPoint.ReachedBlockBoundary()) {
+    const EditorDOMPoint atBlockBoundary =
+        nextThingOfCaretPoint.ReachedCurrentBlockBoundary()
+            ? EditorDOMPoint::AtEndOf(*nextThingOfCaretPoint.ElementPtr())
+            : EditorDOMPoint(nextThingOfCaretPoint.ElementPtr());
+    Result<EditorDOMPoint, nsresult> afterLastVisibleThingOrError =
+        WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesBefore(
+            aHTMLEditor, atBlockBoundary, {});
+    if (MOZ_UNLIKELY(afterLastVisibleThingOrError.isErr())) {
+      NS_WARNING(
+          "WhiteSpaceVisibilityKeeper::NormalizeWhiteSpacesBefore() "
+          "failed");
+      return afterLastVisibleThingOrError.propagateErr();
     }
   }
   rv = aHTMLEditor.CollapseSelectionTo(newCaretPosition);
@@ -4253,61 +3824,42 @@
   // Figure out if the endpoints are in nodes that can be merged.  Adjust
   // surrounding white-space in preparation to delete selection.
   if (!aHTMLEditor.IsPlaintextMailComposer()) {
-    if (!StaticPrefs::editor_white_space_normalization_blink_compatible()) {
+    {
       AutoTrackDOMRange firstRangeTracker(aHTMLEditor.RangeUpdaterRef(),
                                           &aRangesToDelete.FirstRangeRef());
-      Result<CaretPoint, nsresult> caretPointOrError =
-          WhiteSpaceVisibilityKeeper::PrepareToDeleteRange(
-              aHTMLEditor, EditorDOMRange(aRangesToDelete.FirstRangeRef()),
-              aEditingHost);
-      if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-        NS_WARNING("WhiteSpaceVisibilityKeeper::PrepareToDeleteRange() failed");
-        return caretPointOrError.propagateErr();
-      }
-      // Ignore caret point suggestion because there was
-      // AutoTransactionsConserveSelection.
-      caretPointOrError.unwrap().IgnoreCaretPointSuggestion();
-    } else {
-      MOZ_ASSERT(
-          StaticPrefs::editor_white_space_normalization_blink_compatible());
-      {
-        AutoTrackDOMRange firstRangeTracker(aHTMLEditor.RangeUpdaterRef(),
-                                            &aRangesToDelete.FirstRangeRef());
-        for (OwningNonNull<nsRange>& range :
-             Reversed(aRangesToDelete.Ranges())) {
-          if (MOZ_UNLIKELY(!range->IsPositioned() || range->Collapsed())) {
-            continue;
-          }
-          Maybe<AutoTrackDOMRange> trackRange;
-          if (range != aRangesToDelete.FirstRangeRef()) {
-            trackRange.emplace(aHTMLEditor.RangeUpdaterRef(), &range);
-          }
-          Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
-              WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
-                  aHTMLEditor, EditorDOMRange(range));
-          if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
-            NS_WARNING(
-                "WhiteSpaceVisibilityKeeper::"
-                "NormalizeSurroundingWhiteSpacesToJoin() failed");
-            return rangeToDeleteOrError.propagateErr();
-          }
-          trackRange.reset();
-          EditorDOMRange rangeToDelete = rangeToDeleteOrError.unwrap();
-          if (MOZ_LIKELY(rangeToDelete.IsPositionedAndValidInComposedDoc())) {
-            nsresult rv = range->SetStartAndEnd(
-                rangeToDelete.StartRef().ToRawRangeBoundary(),
-                rangeToDelete.EndRef().ToRawRangeBoundary());
-            if (NS_FAILED(rv)) {
-              NS_WARNING("nsRange::SetStartAndEnd() failed");
-              return Err(rv);
-            }
+      for (OwningNonNull<nsRange>& range : Reversed(aRangesToDelete.Ranges())) {
+        if (MOZ_UNLIKELY(!range->IsPositioned() || range->Collapsed())) {
+          continue;
+        }
+        Maybe<AutoTrackDOMRange> trackRange;
+        if (range != aRangesToDelete.FirstRangeRef()) {
+          trackRange.emplace(aHTMLEditor.RangeUpdaterRef(), &range);
+        }
+        Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
+            WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
+                aHTMLEditor, EditorDOMRange(range));
+        if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
+          NS_WARNING(
+              "WhiteSpaceVisibilityKeeper::"
+              "NormalizeSurroundingWhiteSpacesToJoin() failed");
+          return rangeToDeleteOrError.propagateErr();
+        }
+        trackRange.reset();
+        EditorDOMRange rangeToDelete = rangeToDeleteOrError.unwrap();
+        if (MOZ_LIKELY(rangeToDelete.IsPositionedAndValidInComposedDoc())) {
+          nsresult rv = range->SetStartAndEnd(
+              rangeToDelete.StartRef().ToRawRangeBoundary(),
+              rangeToDelete.EndRef().ToRawRangeBoundary());
+          if (NS_FAILED(rv)) {
+            NS_WARNING("nsRange::SetStartAndEnd() failed");
+            return Err(rv);
           }
         }
       }
-      aRangesToDelete.RemoveCollapsedRanges();
-      if (MOZ_UNLIKELY(aRangesToDelete.IsCollapsed())) {
-        return EditActionResult::HandledResult();
-      }
+    }
+    aRangesToDelete.RemoveCollapsedRanges();
+    if (MOZ_UNLIKELY(aRangesToDelete.IsCollapsed())) {
+      return EditActionResult::HandledResult();
     }
     if (NS_WARN_IF(!aRangesToDelete.FirstRangeRef()->IsPositioned()) ||
         (aHTMLEditor.MayHaveMutationEventListeners() &&
@@ -4678,21 +4230,19 @@
           BlockInlineCheck::UseComputedDisplayOutsideStyle));
 
   const OwningNonNull<nsRange> rangeToDelete(aRangeToDelete);
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
-        WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
-            aHTMLEditor, EditorDOMRange(rangeToDelete));
-    if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin() "
-          "failed");
-      return rangeToDeleteOrError.propagateErr();
-    }
-    nsresult rv = rangeToDeleteOrError.unwrap().SetToRange(rangeToDelete);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("EditorDOMRange::SetToRange() failed");
-      return Err(rv);
-    }
+  Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
+      WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
+          aHTMLEditor, EditorDOMRange(rangeToDelete));
+  if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
+    NS_WARNING(
+        "WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin() "
+        "failed");
+    return rangeToDeleteOrError.propagateErr();
+  }
+  nsresult rv = rangeToDeleteOrError.unwrap().SetToRange(rangeToDelete);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("EditorDOMRange::SetToRange() failed");
+    return Err(rv);
   }
   if (!rangeToDelete->Collapsed()) {
     AutoClonedSelectionRangeArray rangesToDelete(*rangeToDelete,
@@ -4729,15 +4279,16 @@
   }
 
   EditorDOMRange rangeToCleanUp(*rangeToDelete);
-  AutoTrackDOMRange trackRangeToCleanUp(aHTMLEditor.RangeUpdaterRef(),
-                                        &rangeToCleanUp);
-  nsresult rv = mDeleteRangesHandler->DeleteUnnecessaryNodes(
-      aHTMLEditor, rangeToCleanUp, aEditingHost);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("AutoDeleteRangesHandler::DeleteUnnecessaryNodes() failed");
-    return Err(rv);
-  }
-  trackRangeToCleanUp.FlushAndStopTracking();
+  {
+    AutoTrackDOMRange trackRangeToCleanUp(aHTMLEditor.RangeUpdaterRef(),
+                                          &rangeToCleanUp);
+    nsresult rv = mDeleteRangesHandler->DeleteUnnecessaryNodes(
+        aHTMLEditor, rangeToCleanUp, aEditingHost);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("AutoDeleteRangesHandler::DeleteUnnecessaryNodes() failed");
+      return Err(rv);
+    }
+  }
   const auto& pointToPutCaret =
       !nsIEditor::DirectionIsBackspace(aDirectionAndAmount) ||
               (aHTMLEditor.TopLevelEditSubActionDataRef()
@@ -4807,21 +4358,19 @@
       nsIEditor::DirectionIsBackspace(aDirectionAndAmount);
 
   const OwningNonNull<nsRange> rangeToDelete(aRangeToDelete);
-  if (StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-    Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
-        WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
-            aHTMLEditor, EditorDOMRange(*rangeToDelete));
-    if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
-      NS_WARNING(
-          "WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin() "
-          "failed");
-      return rangeToDeleteOrError.propagateErr();
-    }
-    nsresult rv = rangeToDeleteOrError.unwrap().SetToRange(rangeToDelete);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("EditorDOMRange::SetToRange() failed");
-      return Err(rv);
-    }
+  Result<EditorDOMRange, nsresult> rangeToDeleteOrError =
+      WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin(
+          aHTMLEditor, EditorDOMRange(*rangeToDelete));
+  if (MOZ_UNLIKELY(rangeToDeleteOrError.isErr())) {
+    NS_WARNING(
+        "WhiteSpaceVisibilityKeeper::NormalizeSurroundingWhiteSpacesToJoin() "
+        "failed");
+    return rangeToDeleteOrError.propagateErr();
+  }
+  nsresult rv = rangeToDeleteOrError.unwrap().SetToRange(rangeToDelete);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("EditorDOMRange::SetToRange() failed");
+    return Err(rv);
   }
   if (!rangeToDelete->Collapsed()) {
     AutoClonedSelectionRangeArray rangesToDelete(rangeToDelete,
@@ -4909,7 +4458,7 @@
   }
 
   // Otherwise, we should put caret at start of the right content.
-  nsresult rv = aHTMLEditor.CollapseSelectionTo(
+  rv = aHTMLEditor.CollapseSelectionTo(
       atFirstChildOfTheLastRightNodeOrError.inspect());
   if (NS_FAILED(rv)) {
     NS_WARNING("EditorBase::CollapseSelectionTo() failed");
@@ -8253,14 +7802,8 @@
       EditorRawDOMPoint startPoint =
           HTMLEditUtils::GetPreviousEditablePoint<EditorRawDOMPoint>(
               *mEmptyInclusiveAncestorBlockElement, &aEditingHost,
-              !StaticPrefs::editor_white_space_normalization_blink_compatible()
-                  // In this case, we don't join block elements so that we won't
-                  // delete invisible trailing whitespaces in the previous
-                  // element.
-                  ? InvisibleWhiteSpaces::Preserve
-                  // With the new normalizer, we'ill delete invisible
-                  // white-spaces.
-                  : InvisibleWhiteSpaces::Ignore,
+              // We'ill delete invisible white-spaces later.
+              InvisibleWhiteSpaces::Ignore,
               // In this case, we won't join table cells so that we should
               // get a range which is in a table cell even if it's in a
               // table.
@@ -8284,13 +7827,8 @@
       EditorRawDOMPoint endPoint =
           HTMLEditUtils::GetNextEditablePoint<EditorRawDOMPoint>(
               *mEmptyInclusiveAncestorBlockElement, &aEditingHost,
-              !StaticPrefs::editor_white_space_normalization_blink_compatible()
-                  // In this case, we don't join block elements so that we won't
-                  // delete invisible trailing whitespaces in the next element.
-                  ? InvisibleWhiteSpaces::Preserve
-                  // With the new normalizer, we'ill delete invisible
-                  // white-spaces.
-                  : InvisibleWhiteSpaces::Ignore,
+              // We'ill delete invisible white-spaces.
+              InvisibleWhiteSpaces::Ignore,
               // In this case, we won't join table cells so that we should
               // get a range which is in a table cell even if it's in a
               // table.
@@ -8516,27 +8054,18 @@
         aHTMLEditor.RangeUpdaterRef(), &atEmptyInclusiveAncestorBlockElement);
     AutoTrackDOMPoint trackPointToPutCaret(aHTMLEditor.RangeUpdaterRef(),
                                            &pointToPutCaret);
-    if (!StaticPrefs::editor_white_space_normalization_blink_compatible()) {
-      nsresult rv = aHTMLEditor.DeleteNodeWithTransaction(
-          MOZ_KnownLive(*mEmptyInclusiveAncestorBlockElement));
-      if (NS_FAILED(rv)) {
-        NS_WARNING("EditorBase::DeleteNodeWithTransaction() failed");
-        return Err(rv);
-      }
-    } else {
-      Result<CaretPoint, nsresult> caretPointOrError =
-          WhiteSpaceVisibilityKeeper::DeleteContentNodeAndJoinTextNodesAroundIt(
-              aHTMLEditor, MOZ_KnownLive(*mEmptyInclusiveAncestorBlockElement),
-              pointToPutCaret, aEditingHost);
-      if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
-        NS_WARNING(
-            "WhiteSpaceVisibilityKeeper::"
-            "DeleteContentNodeAndJoinTextNodesAroundIt() failed");
-        return caretPointOrError.propagateErr();
-      }
-      caretPointOrError.unwrap().MoveCaretPointTo(
-          pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
-    }
+    Result<CaretPoint, nsresult> caretPointOrError =
+        WhiteSpaceVisibilityKeeper::DeleteContentNodeAndJoinTextNodesAroundIt(
+            aHTMLEditor, MOZ_KnownLive(*mEmptyInclusiveAncestorBlockElement),
+            pointToPutCaret, aEditingHost);
+    if (MOZ_UNLIKELY(caretPointOrError.isErr())) {
+      NS_WARNING(
+          "WhiteSpaceVisibilityKeeper::"
+          "DeleteContentNodeAndJoinTextNodesAroundIt() failed");
+      return caretPointOrError.propagateErr();
+    }
+    caretPointOrError.unwrap().MoveCaretPointTo(
+        pointToPutCaret, {SuggestCaret::OnlyIfHasSuggestion});
     trackEmptyBlockPoint.FlushAndStopTracking();
     trackPointToPutCaret.FlushAndStopTracking();
     if (NS_WARN_IF(!atEmptyInclusiveAncestorBlockElement