# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/abort/AbortSignal.cpp
# Commit: c372f67e5966
# Full Hash: c372f67e596622cf168b6b503c52aba714a3f678
# Author: Cosmin Sabou <csabou@mozilla.com>
# Date: 2025-07-25 04:08:49
# Regressor Bug: 1964605
# File Overlap Count: 1
# Description:
#   Revert "Bug 1964605 - Use nsIGlobalObject::GetTimeoutManager for AbortSignal.timeout r=aiunusov" for causing Bug 1978585 and as requested by the dev.
#   
#   This reverts commit 46fcd6d7bf1f5aa53b20a243fd91daeb2ddaa1ff.
# ==============================================================================

diff -r a2e01a45c39f -r c372f67e5966 dom/abort/AbortSignal.cpp
--- a/dom/abort/AbortSignal.cpp	Thu Jul 24 21:00:26 2025 +0000
+++ b/dom/abort/AbortSignal.cpp	Fri Jul 25 00:26:36 2025 +0300
@@ -237,21 +237,33 @@
 
 static void SetTimeoutForGlobal(GlobalObject& aGlobal, TimeoutHandler& aHandler,
                                 int32_t timeout, ErrorResult& aRv) {
-  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
-
-  TimeoutManager* manager = global->GetTimeoutManager();
-  if (!manager) {
-    aRv.ThrowInvalidStateError("The current global does not support timeout");
-    return;
-  }
+  if (NS_IsMainThread()) {
+    nsCOMPtr<nsPIDOMWindowInner> innerWindow =
+        do_QueryInterface(aGlobal.GetAsSupports());
+    if (!innerWindow) {
+      aRv.ThrowInvalidStateError("Could not find window.");
+      return;
+    }
 
-  int32_t handle;
-  nsresult rv =
-      manager->SetTimeout(&aHandler, timeout, /* aIsInterval */ false,
-                          Timeout::Reason::eAbortSignalTimeout, &handle);
-  if (NS_FAILED(rv)) {
-    aRv.Throw(rv);
-    return;
+    int32_t handle;
+    nsresult rv =
+        nsGlobalWindowInner::Cast(innerWindow)
+            ->GetTimeoutManager()
+            ->SetTimeout(&aHandler, timeout, /* aIsInterval */ false,
+                         Timeout::Reason::eAbortSignalTimeout, &handle);
+    if (NS_FAILED(rv)) {
+      aRv.Throw(rv);
+      return;
+    }
+  } else {
+    WorkerPrivate* workerPrivate =
+        GetWorkerPrivateFromContext(aGlobal.Context());
+    workerPrivate->SetTimeout(aGlobal.Context(), &aHandler, timeout,
+                              /* aIsInterval */ false,
+                              Timeout::Reason::eAbortSignalTimeout, aRv);
+    if (aRv.Failed()) {
+      return;
+    }
   }
 }
 
