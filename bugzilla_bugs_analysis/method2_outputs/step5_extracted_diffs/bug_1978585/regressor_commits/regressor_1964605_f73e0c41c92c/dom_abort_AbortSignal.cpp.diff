# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/abort/AbortSignal.cpp
# Commit: f73e0c41c92c
# Full Hash: f73e0c41c92cb46eb4da577572534f43c94774e1
# Author: Kagami Sascha Rosylight <saschanaz@outlook.com>
# Date: 2025-07-16 21:45:35
# Regressor Bug: 1964605
# File Overlap Count: 1
# Description:
#   Bug 1964605 - Use nsIGlobalObject::GetTimeoutManager for AbortSignal.timeout r=aiunusov
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D247895
# ==============================================================================

diff -r a771b9ac457c -r f73e0c41c92c dom/abort/AbortSignal.cpp
--- a/dom/abort/AbortSignal.cpp	Wed Jul 16 14:01:33 2025 +0300
+++ b/dom/abort/AbortSignal.cpp	Wed Jul 16 11:04:43 2025 +0000
@@ -237,33 +237,21 @@
 
 static void SetTimeoutForGlobal(GlobalObject& aGlobal, TimeoutHandler& aHandler,
                                 int32_t timeout, ErrorResult& aRv) {
-  if (NS_IsMainThread()) {
-    nsCOMPtr<nsPIDOMWindowInner> innerWindow =
-        do_QueryInterface(aGlobal.GetAsSupports());
-    if (!innerWindow) {
-      aRv.ThrowInvalidStateError("Could not find window.");
-      return;
-    }
+  nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
+
+  TimeoutManager* manager = global->GetTimeoutManager();
+  if (!manager) {
+    aRv.ThrowInvalidStateError("The current global does not support timeout");
+    return;
+  }
 
-    int32_t handle;
-    nsresult rv =
-        nsGlobalWindowInner::Cast(innerWindow)
-            ->GetTimeoutManager()
-            ->SetTimeout(&aHandler, timeout, /* aIsInterval */ false,
-                         Timeout::Reason::eAbortSignalTimeout, &handle);
-    if (NS_FAILED(rv)) {
-      aRv.Throw(rv);
-      return;
-    }
-  } else {
-    WorkerPrivate* workerPrivate =
-        GetWorkerPrivateFromContext(aGlobal.Context());
-    workerPrivate->SetTimeout(aGlobal.Context(), &aHandler, timeout,
-                              /* aIsInterval */ false,
-                              Timeout::Reason::eAbortSignalTimeout, aRv);
-    if (aRv.Failed()) {
-      return;
-    }
+  int32_t handle;
+  nsresult rv =
+      manager->SetTimeout(&aHandler, timeout, /* aIsInterval */ false,
+                          Timeout::Reason::eAbortSignalTimeout, &handle);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return;
   }
 }
 
