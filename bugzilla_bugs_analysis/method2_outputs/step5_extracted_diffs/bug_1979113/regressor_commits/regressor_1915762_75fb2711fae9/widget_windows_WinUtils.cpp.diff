# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/windows/WinUtils.cpp
# Commit: 75fb2711fae9
# Full Hash: 75fb2711fae94f6198683d3e821b82d0081ff2af
# Author: Daisuke Akatsuka <daisuke@birchill.co.jp>
# Date: 2025-04-23 09:21:27
# Regressor Bug: 1915762
# File Overlap Count: 1
# Description:
#   Bug 1915762: Apply getFaviconForPage() in WinUtils r=win-reviewers,mak,handyman
#   
#   Depends on D240120
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D240566
# ==============================================================================

diff -r 579ec95712da -r 75fb2711fae9 widget/windows/WinUtils.cpp
--- a/widget/windows/WinUtils.cpp	Wed Apr 23 04:40:34 2025 +0000
+++ b/widget/windows/WinUtils.cpp	Wed Apr 23 04:40:34 2025 +0000
@@ -48,7 +48,7 @@
 #include "nsNetCID.h"
 #include "prtime.h"
 #ifdef MOZ_PLACES
-#  include "nsIFaviconService.h"
+#  include "mozilla/places/nsFaviconService.h"
 #endif
 #include "nsIDownloader.h"
 #include "nsIChannel.h"
@@ -74,7 +74,6 @@
 
 #ifdef MOZ_PLACES
 NS_IMPL_ISUPPORTS(myDownloadObserver, nsIDownloadObserver)
-NS_IMPL_ISUPPORTS(AsyncFaviconDataReady, nsIFaviconDataCallback)
 #endif
 NS_IMPL_ISUPPORTS(AsyncEncodeAndWriteIcon, nsIRunnable)
 NS_IMPL_ISUPPORTS(AsyncDeleteAllFaviconsFromDisk, nsIRunnable)
@@ -670,31 +669,6 @@
 }
 
 #ifdef MOZ_PLACES
-/************************************************************************
- * Constructs as AsyncFaviconDataReady Object
- * @param aIOThread : the thread which performs the action
- * @param aURLShortcut : Differentiates between (false)Jumplistcache and
- *                       (true)Shortcutcache
- * @param aRunnable : Executed in the aIOThread when the favicon cache is
- *                    avaiable
- * @param [aPromiseHolder=null]: Optional PromiseHolder that will be forwarded
- *                               to AsyncEncodeAndWriteIcon if getting the
- *                               favicon from the favicon service succeeds. If
- *                               it doesn't succeed, the held MozPromise will
- *                               be rejected.
- ************************************************************************/
-
-AsyncFaviconDataReady::AsyncFaviconDataReady(
-    nsIURI* aNewURI, RefPtr<nsISerialEventTarget> aIOThread,
-    const bool aURLShortcut, already_AddRefed<nsIRunnable> aRunnable,
-    UniquePtr<MozPromiseHolder<ObtainCachedIconFileAsyncPromise>>
-        aPromiseHolder)
-    : mNewURI(aNewURI),
-      mIOThread(aIOThread),
-      mRunnable(aRunnable),
-      mPromiseHolder(std::move(aPromiseHolder)),
-      mURLShortcut(aURLShortcut) {}
-
 NS_IMETHODIMP
 myDownloadObserver::OnDownloadComplete(nsIDownloader* downloader,
                                        nsIRequest* request, nsresult status,
@@ -702,28 +676,25 @@
   return NS_OK;
 }
 
-nsresult AsyncFaviconDataReady::OnFaviconDataNotAvailable(void) {
-  if (!mURLShortcut) {
+static nsresult MaybeDownloadFavicon(nsIURI* aNewURI, const bool aURLShortcut) {
+  if (!aURLShortcut) {
     return NS_OK;
   }
 
   nsCOMPtr<nsIFile> icoFile;
   nsresult rv =
-      FaviconHelper::GetOutputIconPath(mNewURI, icoFile, mURLShortcut);
+      FaviconHelper::GetOutputIconPath(aNewURI, icoFile, aURLShortcut);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> mozIconURI;
   rv = NS_NewURI(getter_AddRefs(mozIconURI), "moz-icon://.html?size=32");
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIChannel> channel;
   rv = NS_NewChannel(getter_AddRefs(channel), mozIconURI,
                      nsContentUtils::GetSystemPrincipal(),
                      nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL,
                      nsIContentPolicy::TYPE_INTERNAL_IMAGE);
-
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDownloadObserver> downloadObserver = new myDownloadObserver;
@@ -734,22 +705,36 @@
   return channel->AsyncOpen(listener);
 }
 
-NS_IMETHODIMP
-AsyncFaviconDataReady::OnComplete(nsIURI* aFaviconURI, uint32_t aDataLen,
-                                  const uint8_t* aData,
-                                  const nsACString& aMimeType,
-                                  uint16_t aWidth) {
-  if (!aDataLen || !aData) {
-    if (mURLShortcut) {
-      OnFaviconDataNotAvailable();
+static nsresult CacheFavicon(
+    const places::FaviconPromise::ResolveOrRejectValue& aPromiseResult,
+    nsIURI* aNewURI, RefPtr<nsISerialEventTarget> aIOThread,
+    const bool aURLShortcut, nsCOMPtr<nsIRunnable> aRunnable,
+    UniquePtr<MozPromiseHolder<ObtainCachedIconFileAsyncPromise>>
+        aPromiseHolder) {
+  nsresult rv = NS_OK;
+  auto guard = MakeScopeExit([&]() {
+    if (NS_FAILED(rv) && aPromiseHolder) {
+      aPromiseHolder->RejectIfExists(rv, __func__);
     }
+  });
 
-    return NS_OK;
+  nsCOMPtr<nsIFavicon> favicon =
+      aPromiseResult.IsResolve() ? aPromiseResult.ResolveValue() : nullptr;
+  if (!favicon) {
+    MaybeDownloadFavicon(std::move(aNewURI), aURLShortcut);
+    return (rv = NS_ERROR_FAILURE);
   }
 
+  // Get favicon content.
+  nsTArray<uint8_t> rawData;
+  rv = favicon->GetRawData(rawData);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsAutoCString mimeType;
+  rv = favicon->GetMimeType(mimeType);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsCOMPtr<nsIFile> icoFile;
-  nsresult rv =
-      FaviconHelper::GetOutputIconPath(mNewURI, icoFile, mURLShortcut);
+  rv = FaviconHelper::GetOutputIconPath(aNewURI, icoFile, aURLShortcut);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString path;
@@ -759,9 +744,9 @@
   // Decode the image from the format it was returned to us in (probably PNG)
   nsCOMPtr<imgIContainer> container;
   nsCOMPtr<imgITools> imgtool = do_CreateInstance("@mozilla.org/image/tools;1");
-  rv = imgtool->DecodeImageFromBuffer(reinterpret_cast<const char*>(aData),
-                                      aDataLen, aMimeType,
-                                      getter_AddRefs(container));
+  rv = imgtool->DecodeImageFromBuffer(
+      reinterpret_cast<const char*>(rawData.Elements()), rawData.Length(),
+      mimeType, getter_AddRefs(container));
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<SourceSurface> surface = container->GetFrame(
@@ -772,7 +757,7 @@
   RefPtr<DataSourceSurface> dataSurface;
   IntSize size;
 
-  if (mURLShortcut &&
+  if (aURLShortcut &&
       (surface->GetSize().width < 48 || surface->GetSize().height < 48)) {
     // Create a 48x48 surface and paint the icon into the central rect.
     size.width = std::max(surface->GetSize().width, 48);
@@ -790,8 +775,7 @@
         BackendType::CAIRO, map.mData, dataSurface->GetSize(), map.mStride,
         dataSurface->GetFormat());
     if (!dt) {
-      gfxWarning() << "AsyncFaviconDataReady::OnComplete failed in "
-                      "CreateDrawTargetForData";
+      gfxWarning() << "CreateDrawTargetForData failed in CacheFavicon";
       return NS_ERROR_OUT_OF_MEMORY;
     }
     dt->FillRect(Rect(0, 0, size.width, size.height),
@@ -828,11 +812,13 @@
   }
   int32_t stride = 4 * size.width;
 
+  guard.release();
+
   // AsyncEncodeAndWriteIcon takes ownership of the heap allocated buffer
   nsCOMPtr<nsIRunnable> event = new AsyncEncodeAndWriteIcon(
       path, std::move(data), stride, size.width, size.height,
-      mRunnable.forget(), std::move(mPromiseHolder));
-  mIOThread->Dispatch(event, NS_DISPATCH_NORMAL);
+      aRunnable.forget(), std::move(aPromiseHolder));
+  aIOThread->Dispatch(event, NS_DISPATCH_NORMAL);
 
   return NS_OK;
 }
@@ -856,6 +842,18 @@
 NS_IMETHODIMP AsyncEncodeAndWriteIcon::Run() {
   MOZ_ASSERT(!NS_IsMainThread(), "Should not be called on the main thread.");
 
+  nsresult rv = NS_OK;
+  auto guard = MakeScopeExit([&]() {
+    if (!mPromiseHolder) {
+      return;
+    }
+    if (NS_SUCCEEDED(rv)) {
+      mPromiseHolder->ResolveIfExists(mIconPath, __func__);
+    } else {
+      mPromiseHolder->RejectIfExists(rv, __func__);
+    }
+  });
+
   // Note that since we're off the main thread we can't use
   // gfxPlatform::GetPlatform()->ScreenReferenceDrawTarget()
   RefPtr<DataSourceSurface> surface = Factory::CreateWrappingDataSourceSurface(
@@ -869,34 +867,27 @@
     MOZ_TRY(NS_NewLocalFile(mIconPath, getter_AddRefs(comFile)));
     nsCOMPtr<nsIFile> dirPath;
     MOZ_TRY(comFile->GetParent(getter_AddRefs(dirPath)));
-    nsresult rv = dirPath->Create(nsIFile::DIRECTORY_TYPE, 0777);
+    rv = dirPath->Create(nsIFile::DIRECTORY_TYPE, 0777);
     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS) {
       return rv;
     }
     file = _wfopen(mIconPath.get(), L"wb");
     if (!file) {
-      return NS_ERROR_FAILURE;
+      return (rv = NS_ERROR_FAILURE);
     }
   }
-  nsresult rv = gfxUtils::EncodeSourceSurface(surface, ImageType::ICO, u""_ns,
-                                              gfxUtils::eBinaryEncode, file);
+  rv = gfxUtils::EncodeSourceSurface(surface, ImageType::ICO, u""_ns,
+                                     gfxUtils::eBinaryEncode, file);
   fclose(file);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (mRunnable) {
     mRunnable->Run();
   }
-  if (mPromiseHolder) {
-    mPromiseHolder->ResolveIfExists(mIconPath, __func__);
-  }
   return rv;
 }
 
-AsyncEncodeAndWriteIcon::~AsyncEncodeAndWriteIcon() {
-  if (mPromiseHolder) {
-    mPromiseHolder->RejectIfExists(NS_ERROR_FAILURE, __func__);
-  }
-}
+AsyncEncodeAndWriteIcon::~AsyncEncodeAndWriteIcon() {}
 
 AsyncDeleteAllFaviconsFromDisk::AsyncDeleteAllFaviconsFromDisk(
     bool aIgnoreRecent)
@@ -1104,7 +1095,6 @@
         // CacheIconFileFromFaviconURIAsync to request the favicon.
         RefPtr<nsISerialEventTarget> currentThread =
             GetCurrentSerialEventTarget();
-
         return InvokeAsync(
             GetMainThreadSerialEventTarget(),
             "ObtainCachedIconFileAsync call to "
@@ -1204,16 +1194,17 @@
   nsCOMPtr<nsIRunnable> runnable = aRunnable;
 #ifdef MOZ_PLACES
   // Obtain the favicon service and get the favicon for the specified page
-  nsCOMPtr<nsIFaviconService> favIconSvc(
-      do_GetService("@mozilla.org/browser/favicon-service;1"));
+  auto* favIconSvc = nsFaviconService::GetFaviconService();
   NS_ENSURE_TRUE(favIconSvc, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsIFaviconDataCallback> callback =
-      new mozilla::widget::AsyncFaviconDataReady(
-          aFaviconPageURI, aIOThread, aURLShortcut, runnable.forget(),
-          std::move(aPromiseHolder));
-
-  favIconSvc->GetFaviconDataForPage(aFaviconPageURI, callback, 0);
+  favIconSvc->AsyncGetFaviconForPage(aFaviconPageURI)
+      ->Then(GetMainThreadSerialEventTarget(), __func__,
+             [aFaviconPageURI, aIOThread, aURLShortcut, runnable,
+              promiseHolder = std::move(aPromiseHolder)](
+                 const places::FaviconPromise::ResolveOrRejectValue&
+                     aResult) mutable {
+               CacheFavicon(aResult, aFaviconPageURI, aIOThread, aURLShortcut,
+                            runnable, std::move(promiseHolder));
+             });
 #endif
   return NS_OK;
 }