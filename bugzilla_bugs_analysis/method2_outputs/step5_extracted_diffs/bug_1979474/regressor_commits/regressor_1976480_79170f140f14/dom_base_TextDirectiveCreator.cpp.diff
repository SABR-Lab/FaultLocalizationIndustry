# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/TextDirectiveCreator.cpp
# Commit: 79170f140f14
# Full Hash: 79170f140f14b8cc4b668e6137a623118ddc49cf
# Author: Jan-Niklas Jaeschke <jjaschke@mozilla.com>
# Date: 2025-07-23 09:41:41
# Regressor Bug: 1976480
# File Overlap Count: 2
# Description:
#   Bug 1976480 - Text Fragments: Don't extend the selection if only punctuation is selected. r=dom-core,avandolder,mccr8
#   
#   This patch adds a new check in the beginning of the algorithm which leaves the
#   input range unchanged if its content is only punctuation characters.
#   This edge case is handled by checking if all characters are punctuation and would return early, hence not going into the algorithm that extends the range to word boundaries
# ==============================================================================

diff -r 7336d25e87e7 -r 79170f140f14 dom/base/TextDirectiveCreator.cpp
--- a/dom/base/TextDirectiveCreator.cpp	Tue Jul 22 17:25:32 2025 +0000
+++ b/dom/base/TextDirectiveCreator.cpp	Tue Jul 22 17:27:30 2025 +0000
@@ -38,20 +38,6 @@
     const TimeoutWatchdog* aWatchdog) {
   MOZ_ASSERT(aInputRange);
   MOZ_ASSERT(!aInputRange->Collapsed());
-  const nsString rangeContent =
-      MOZ_TRY(TextDirectiveUtil::RangeContentAsString(aInputRange));
-  if (rangeContent.IsEmpty()) {
-    TEXT_FRAGMENT_LOG("Input range does not contain text.");
-    return VoidCString();
-  }
-  const bool rangeIsOnlyWhitespace =
-      std::all_of(rangeContent.View().cbegin(), rangeContent.View().cend(),
-                  nsContentUtils::IsHTMLWhitespaceOrNBSP);
-
-  if (rangeIsOnlyWhitespace) {
-    TEXT_FRAGMENT_LOG("Input range contains only whitespace.");
-    return VoidCString();
-  }
 
   const RefPtr<AbstractRange> extendedRange =
       MOZ_TRY(ExtendRangeToWordBoundaries(aInputRange));
@@ -115,12 +101,30 @@
 Result<RefPtr<AbstractRange>, ErrorResult>
 TextDirectiveCreator::ExtendRangeToWordBoundaries(AbstractRange* aRange) {
   MOZ_ASSERT(aRange && !aRange->Collapsed());
-  TEXT_FRAGMENT_LOG(
-      "Input range :\n{}",
-      NS_ConvertUTF16toUTF8(
-          TextDirectiveUtil::RangeContentAsString(aRange).unwrapOr(
-              u"<Could not be converted to string>"_ns)));
   ErrorResult rv;
+  const nsString rangeContent =
+      MOZ_TRY(TextDirectiveUtil::RangeContentAsString(aRange));
+  TEXT_FRAGMENT_LOG("Input range :\n{}", NS_ConvertUTF16toUTF8(rangeContent));
+
+  if (rangeContent.IsEmpty()) {
+    TEXT_FRAGMENT_LOG("Input range does not contain text.");
+    return Result<RefPtr<AbstractRange>, ErrorResult>(nullptr);
+  }
+
+  if (std::all_of(rangeContent.View().cbegin(), rangeContent.View().cend(),
+                  nsContentUtils::IsHTMLWhitespaceOrNBSP)) {
+    TEXT_FRAGMENT_LOG("Input range contains only whitespace.");
+    return Result<RefPtr<AbstractRange>, ErrorResult>(nullptr);
+  }
+  if (std::all_of(rangeContent.View().cbegin(), rangeContent.View().cend(),
+                  IsPunctuationForWordSelect)) {
+    RefPtr range =
+        StaticRange::Create(aRange->StartRef(), aRange->EndRef(), rv);
+    if (MOZ_UNLIKELY(rv.Failed())) {
+      return Err(std::move(rv));
+    }
+    return Result<RefPtr<AbstractRange>, ErrorResult>(range);
+  }
   RangeBoundary startPoint = TextDirectiveUtil::FindNextNonWhitespacePosition<
       TextScanDirection::Right>(aRange->StartRef());
   startPoint =