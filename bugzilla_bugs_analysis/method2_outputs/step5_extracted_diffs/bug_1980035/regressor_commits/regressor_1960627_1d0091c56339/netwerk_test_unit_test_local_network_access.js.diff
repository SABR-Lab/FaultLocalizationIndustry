# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: netwerk/test/unit/test_local_network_access.js
# Commit: 1d0091c56339
# Full Hash: 1d0091c5633982e358737a96ed8af1a2be00bf61
# Author: smayya <smayya@mozilla.com>
# Date: 2025-07-27 09:20:01
# Regressor Bug: 1960627
# File Overlap Count: 1
# Description:
#   Bug 1960627 - add LNAPermissionRequest class for dispatching permission prompt requests. r=necko-reviewers,emz,kershaw
#   
#   LNAPermissionRequest is used for dispatching localhost and local-network permission prompts to the user.
#   Additionally, this patch also implements the transaction retry mechanism based on prompt action by the user.
#   This patch also modifies existing unit tests to validate the transaction retry mechanism.
# ==============================================================================

diff -r 0981f147243d -r 1d0091c56339 netwerk/test/unit/test_local_network_access.js
--- a/netwerk/test/unit/test_local_network_access.js	Sat Jul 26 21:51:08 2025 +0000
+++ b/netwerk/test/unit/test_local_network_access.js	Sat Jul 26 21:51:08 2025 +0000
@@ -58,6 +58,14 @@
 add_setup(async () => {
   Services.prefs.setBoolPref("network.lna.block_trackers", true);
   Services.obs.addObserver(ChannelCreationObserver, "http-on-opening-request");
+  // fail transactions on Local Network Access
+  Services.prefs.setBoolPref("network.lna.blocking", true);
+
+  // enable prompt for prefs testing, with this we can simulate the prompt actions by
+  // network.lna.blocking.prompt.allow = false/true
+  Services.prefs.setBoolPref("network.localhost.prompt.testing", true);
+  Services.prefs.setBoolPref("network.localnetwork.prompt.testing", true);
+
   // H1 Server
   httpServer = new HttpServer();
   httpServer.registerPathHandler("/test_lna", pathHandler);
@@ -74,6 +82,14 @@
     try {
       await server.stop();
       await httpServer.stop();
+      Services.prefs.clearUserPref("network.lna.blocking");
+      Services.prefs.clearUserPref("network.lna.blocking.prompt.testing");
+      Services.prefs.clearUserPref("network.localhost.prompt.testing.allow");
+      Services.prefs.clearUserPref("network.localnetwork.prompt.testing.allow");
+
+      Services.prefs.clearUserPref(
+        "network.lna.address_space.private.override"
+      );
     } catch (e) {
       // Ignore errors during cleanup
       info("Error during cleanup:", e);
@@ -89,45 +105,61 @@
   });
 });
 
-add_task(async function lna_blocking_tests() {
-  // Array of test cases:
-  // [blockingEnabled, ipAddressSpace, urlSuffix, expectedStatus, port]
-  const testCases = [
+// This test simulates the failure of transaction due to local network access
+// (local host) and subsequent retries based on user prompt actions.
+// The user prompt actions are simulated by prefs `network.lna.blocking.prompt.testing.allow`
+add_task(async function lna_blocking_tests_localhost_prompt() {
+  const localHostTestCases = [
+    // [allowAction, parentIpAddressSpace, urlSuffix, expectedStatus]
+    [true, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H1_URL],
+    [true, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H1_URL],
+    [false, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H1_URL],
     [
-      true,
+      false,
       Ci.nsILoadInfo.Public,
       "/test_lna",
       Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
       H1_URL,
     ],
     [
-      true,
+      false,
       Ci.nsILoadInfo.Private,
       "/test_lna",
       Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
       H1_URL,
     ],
-    [true, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H1_URL],
-    [false, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H1_URL],
-    [false, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H1_URL],
-    [false, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H1_URL],
+    [true, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H2_URL],
+    [true, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H2_URL],
+    [true, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H2_URL],
     [
-      true,
+      false,
       Ci.nsILoadInfo.Public,
       "/test_lna",
       Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
       H2_URL,
     ],
     [
-      true,
+      false,
       Ci.nsILoadInfo.Private,
       "/test_lna",
       Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
       H2_URL,
     ],
     [true, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H2_URL],
-    [false, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H2_URL],
-    [false, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H2_URL],
+    [
+      false,
+      Ci.nsILoadInfo.Public,
+      "/test_lna",
+      Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
+      H2_URL,
+    ],
+    [
+      false,
+      Ci.nsILoadInfo.Private,
+      "/test_lna",
+      Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
+      H2_URL,
+    ],
     [false, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H2_URL],
     // Test cases for local network access from trackers
     // NO LNA then request should not be blocked
@@ -155,7 +187,7 @@
       H2_URL,
     ],
     [
-      false,
+      true,
       Ci.nsILoadInfo.Public,
       "/test_lna_content_tracker",
       Cr.NS_OK,
@@ -179,15 +211,15 @@
       false,
       Ci.nsILoadInfo.Private,
       "/test_lna_content_tracker",
-      Cr.NS_OK,
+      Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
       H2_URL,
     ],
   ];
 
-  for (let [blocking, space, suffix, expectedStatus, url] of testCases) {
+  for (let [allow, space, suffix, expectedStatus, url] of localHostTestCases) {
     info(`do_test ${url}${suffix}, ${space} -> ${expectedStatus}`);
 
-    Services.prefs.setBoolPref("network.lna.blocking", blocking);
+    Services.prefs.setBoolPref("network.localhost.prompt.testing.allow", allow);
 
     let chan = makeChannel(url + suffix);
     chan.loadInfo.parentIpAddressSpace = space;
@@ -204,3 +236,74 @@
     }
   }
 });
+
+add_task(async function lna_blocking_tests_local_network() {
+  // add override such that target servers is considered as local network (and not localhost)
+  var override_value =
+    "127.0.0.1" +
+    ":" +
+    httpServer.identity.primaryPort +
+    "," +
+    "127.0.0.1" +
+    ":" +
+    server.port();
+
+  Services.prefs.setCharPref(
+    "network.lna.address_space.private.override",
+    override_value
+  );
+
+  const localNetworkTestCases = [
+    // [allowAction, parentIpAddressSpace, urlSuffix, expectedStatus]
+    [true, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H1_URL],
+    [false, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H1_URL],
+    [false, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H1_URL],
+    [
+      false,
+      Ci.nsILoadInfo.Public,
+      "/test_lna",
+      Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
+      H1_URL,
+    ],
+    [false, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H1_URL],
+    [true, Ci.nsILoadInfo.Public, "/test_lna", Cr.NS_OK, H2_URL],
+    [false, Ci.nsILoadInfo.Private, "/test_lna", Cr.NS_OK, H2_URL],
+    [false, Ci.nsILoadInfo.Local, "/test_lna", Cr.NS_OK, H2_URL],
+    [
+      false,
+      Ci.nsILoadInfo.Public,
+      "/test_lna",
+      Cr.NS_ERROR_LOCAL_NETWORK_ACCESS_DENIED,
+      H2_URL,
+    ],
+  ];
+
+  for (let [
+    allow,
+    space,
+    suffix,
+    expectedStatus,
+    url,
+  ] of localNetworkTestCases) {
+    info(`do_test ${url}, ${space} -> ${expectedStatus}`);
+
+    Services.prefs.setBoolPref(
+      "network.localnetwork.prompt.testing.allow",
+      allow
+    );
+
+    let chan = makeChannel(url + suffix);
+    chan.loadInfo.parentIpAddressSpace = space;
+
+    let expectFailure = expectedStatus !== Cr.NS_OK ? CL_EXPECT_FAILURE : 0;
+
+    await new Promise(resolve => {
+      chan.asyncOpen(new ChannelListener(resolve, null, expectFailure));
+    });
+
+    Assert.equal(chan.status, expectedStatus);
+    if (expectedStatus === Cr.NS_OK) {
+      Assert.equal(chan.protocolVersion, url === H1_URL ? "http/1.1" : "h2");
+    }
+  }
+});
