# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/TaskController.cpp
# Commit: a778efcc8703
# Full Hash: a778efcc87038d5c6280a26a3b165f5cb03a8a3f
# Author: Jens Stutte <jstutte@mozilla.com>
# Date: 2025-08-27 16:31:01
# Description:
#   Bug 1982199 - Improve ScheduleWantsLaterTimer error handling. r=smaug
#   
#   Normally we expect timer creation/initialization to be infallible, but there appear to be rare cases where it fails.
#   It would be good to understand the cause, but first of all we should honor the return value in case of error.
#   Note that allocations during timer init are infallible since bug 1961386, so most likely the cause is not running low on memory.
# ==============================================================================

diff -r af8869569063 -r a778efcc8703 xpcom/threads/TaskController.cpp
--- a/xpcom/threads/TaskController.cpp	Wed Aug 27 06:58:24 2025 +0000
+++ b/xpcom/threads/TaskController.cpp	Wed Aug 27 07:09:31 2025 +0000
@@ -888,6 +888,7 @@
     sIdleMemoryCleanupRunner->Cancel();
     sIdleMemoryCleanupRunner = nullptr;
   }
+  nsresult timerInitOK = NS_OK;
   if (!sIdleMemoryCleanupWantsLater) {
     auto res = NS_NewTimerWithFuncCallback(
         CheckIdleMemoryCleanupNeeded, (void*)"IdleMemoryCleanupWantsLaterCheck",
@@ -895,17 +896,29 @@
         "IdleMemoryCleanupWantsLaterCheck");
     if (res.isOk()) {
       sIdleMemoryCleanupWantsLater = res.unwrap().forget();
+    } else {
+      timerInitOK = res.unwrapErr();
     }
   } else {
     if (sIdleMemoryCleanupWantsLaterScheduled) {
       sIdleMemoryCleanupWantsLater->Cancel();
     }
-    sIdleMemoryCleanupWantsLater->InitWithNamedFuncCallback(
+    timerInitOK = sIdleMemoryCleanupWantsLater->InitWithNamedFuncCallback(
         CheckIdleMemoryCleanupNeeded, (void*)"IdleMemoryCleanupWantsLaterCheck",
         aWantsLaterDelay, nsITimer::TYPE_ONE_SHOT_LOW_PRIORITY,
         "IdleMemoryCleanupWantsLaterCheck");
   }
-  sIdleMemoryCleanupWantsLaterScheduled = true;
+  if (NS_SUCCEEDED(timerInitOK)) {
+    sIdleMemoryCleanupWantsLaterScheduled = true;
+  } else {
+    // Under normal conditions, we would never expect this to fail.
+    MOZ_ASSERT_UNREACHABLE(
+        "ScheduleWantsLaterTimer could not create the timer.");
+    // If we were not able to create/init the timer, we will retry the next
+    // time the main thread is about to fall idle. But if we were to stay
+    // idle, we would never purge without this emergency purge.
+    jemalloc_free_dirty_pages();
+  }
 }
 
 void ScheduleIdleMemoryCleanup(uint32_t aWantsLaterDelay) {
