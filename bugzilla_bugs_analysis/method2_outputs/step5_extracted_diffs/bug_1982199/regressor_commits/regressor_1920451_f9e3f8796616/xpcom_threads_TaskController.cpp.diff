# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: xpcom/threads/TaskController.cpp
# Commit: f9e3f8796616
# Full Hash: f9e3f8796616bf24fd9d1c7260bc126fe531d0e0
# Author: Jens Stutte <jstutte@mozilla.com>
# Date: 2025-02-19 21:53:46
# Regressor Bug: 1920451
# File Overlap Count: 1
# Description:
#   Bug 1920451 - Introduce a concept of last significant re-use to decide when to purge. r=pbone,smaug
#   
#   We want to better predict when it is a good moment to purge. D220616 answered well the question, when to best process a purge when it is needed (that is, during main thread idle time), but that does not necessarily mean it is a good idea for a single arena, to purge in that moment as arenas can be used on other threads intensely while the main thread is idle.
#   
#   If we saw a recent re-use in an arena we can most likely expect to come more of that and wait with purge a little more. So whenever we are able to re-use a dirty page, we assume that this is a sign of a significant re-use that avoided an allocation of new memory.
# ==============================================================================

diff -r 4eeb6f53b113 -r f9e3f8796616 xpcom/threads/TaskController.cpp
--- a/xpcom/threads/TaskController.cpp	Wed Feb 19 07:07:49 2025 +0000
+++ b/xpcom/threads/TaskController.cpp	Wed Feb 19 07:21:15 2025 +0000
@@ -298,11 +298,15 @@
 
 #ifdef MOZ_MEMORY
 static StaticRefPtr<IdleTaskRunner> sIdleMemoryCleanupRunner;
+static StaticRefPtr<nsITimer> sIdleMemoryCleanupWantsLater;
+static bool sIdleMemoryCleanupWantsLaterScheduled = false;
 
 static const char kEnableLazyPurgePref[] = "memory.lazypurge.enable";
 static const char kMaxPurgeDelayPref[] = "memory.lazypurge.maximum_delay";
 static const char kMinPurgeBudgetPref[] =
     "memory.lazypurge.minimum_idle_budget";
+static const char kMinPurgeReuseGracePref[] =
+    "memory.lazypurge.reuse_grace_period";
 #endif
 
 void TaskController::Initialize() {
@@ -381,6 +385,11 @@
     sIdleMemoryCleanupRunner->Cancel();
     sIdleMemoryCleanupRunner = nullptr;
   }
+  if (sIdleMemoryCleanupWantsLater) {
+    sIdleMemoryCleanupWantsLater->Cancel();
+    sIdleMemoryCleanupWantsLater = nullptr;
+    sIdleMemoryCleanupWantsLaterScheduled = false;
+  }
 #endif
 }
 
@@ -843,7 +852,8 @@
 static void PrefChangeCallback(const char* aPrefName, void* aNull) {
   MOZ_ASSERT((0 == strcmp(aPrefName, kEnableLazyPurgePref)) ||
              (0 == strcmp(aPrefName, kMaxPurgeDelayPref)) ||
-             (0 == strcmp(aPrefName, kMinPurgeBudgetPref)));
+             (0 == strcmp(aPrefName, kMinPurgeBudgetPref)) ||
+             (0 == strcmp(aPrefName, kMinPurgeReuseGracePref)));
 
   TaskController::Get()->UpdateIdleMemoryCleanupPrefs();
 }
@@ -853,86 +863,203 @@
   Preferences::RegisterCallback(PrefChangeCallback, kEnableLazyPurgePref);
   Preferences::RegisterCallback(PrefChangeCallback, kMaxPurgeDelayPref);
   Preferences::RegisterCallback(PrefChangeCallback, kMinPurgeBudgetPref);
+  Preferences::RegisterCallback(PrefChangeCallback, kMinPurgeReuseGracePref);
   TaskController::Get()->UpdateIdleMemoryCleanupPrefs();
 }
 
+bool RunIdleMemoryCleanup(TimeStamp aDeadline, uint32_t aWantsLaterDelay);
+
+void CheckIdleMemoryCleanupNeeded(nsITimer* aTimer, void* aClosure);
+
+void CancelIdleMemoryCleanupTimerAndRunner() {
+  if (sIdleMemoryCleanupRunner) {
+    sIdleMemoryCleanupRunner->Cancel();
+    sIdleMemoryCleanupRunner = nullptr;
+  }
+  if (sIdleMemoryCleanupWantsLaterScheduled) {
+    MOZ_ASSERT(sIdleMemoryCleanupWantsLater);
+    sIdleMemoryCleanupWantsLater->Cancel();
+    sIdleMemoryCleanupWantsLaterScheduled = false;
+  }
+}
+
+void ScheduleWantsLaterTimer(uint32_t aWantsLaterDelay) {
+  if (sIdleMemoryCleanupRunner) {
+    sIdleMemoryCleanupRunner->Cancel();
+    sIdleMemoryCleanupRunner = nullptr;
+  }
+  if (!sIdleMemoryCleanupWantsLater) {
+    auto res = NS_NewTimerWithFuncCallback(
+        CheckIdleMemoryCleanupNeeded, (void*)"IdleMemoryCleanupWantsLaterCheck",
+        aWantsLaterDelay, nsITimer::TYPE_ONE_SHOT_LOW_PRIORITY,
+        "IdleMemoryCleanupWantsLaterCheck");
+    if (res.isOk()) {
+      sIdleMemoryCleanupWantsLater = res.unwrap().forget();
+    }
+  } else {
+    if (sIdleMemoryCleanupWantsLaterScheduled) {
+      sIdleMemoryCleanupWantsLater->Cancel();
+    }
+    sIdleMemoryCleanupWantsLater->InitWithNamedFuncCallback(
+        CheckIdleMemoryCleanupNeeded, (void*)"IdleMemoryCleanupWantsLaterCheck",
+        aWantsLaterDelay, nsITimer::TYPE_ONE_SHOT_LOW_PRIORITY,
+        "IdleMemoryCleanupWantsLaterCheck");
+  }
+  sIdleMemoryCleanupWantsLaterScheduled = true;
+}
+
+void ScheduleIdleMemoryCleanup(uint32_t aWantsLaterDelay) {
+  TimeDuration maxPurgeDelay = TimeDuration::FromMilliseconds(
+      StaticPrefs::memory_lazypurge_maximum_delay());
+  TimeDuration minPurgeBudget = TimeDuration::FromMilliseconds(
+      StaticPrefs::memory_lazypurge_minimum_idle_budget());
+
+  CancelIdleMemoryCleanupTimerAndRunner();
+  sIdleMemoryCleanupRunner = IdleTaskRunner::Create(
+      [aWantsLaterDelay](TimeStamp aDeadline) {
+        return RunIdleMemoryCleanup(aDeadline, aWantsLaterDelay);
+      },
+      "TaskController::IdlePurgeRunner", TimeDuration(), maxPurgeDelay,
+      minPurgeBudget, true, nullptr, nullptr);
+}
+
+// Check if a purge needs to be scheduled now or later.
+// Both used as timer callback and directly from MayScheduleIdleMemoryCleanup.
+//
+// We schedule our runner if we are about to go idle and there is a purge
+// due now (NeedsMore). We (re-)schedule instead a low-priority timer if
+// we need to check again for a possible future purge (WantsLater). We use
+// a timer for this instead of the same IdleTaskRunner in order to avoid it
+// to post some runnables to the main thread to find idle time before the
+// (very cheap) check actually runs.
+//
+// aTimer:   Not used
+// aClosure: Supposed to point to a name literal to be used for profile
+//           markers.
+void CheckIdleMemoryCleanupNeeded(nsITimer* aTimer, void* aClosure) {
+  MOZ_ASSERT(aClosure);
+  const char* name = (const char*)aClosure;
+
+  uint32_t reuseGracePeriod =
+      StaticPrefs::memory_lazypurge_reuse_grace_period();
+
+  // The wantsLaterDelay is used as a last resort when the main thread stays
+  // idle but we knew we should come back.
+  // We double the grace time to increase the chance that all arenas' grace
+  // periods expired if we really ever trigger it after going idle and to
+  // reduce the impact of occasionally firing while being busy.
+  uint32_t wantsLaterDelay = reuseGracePeriod * 2;
+
+  MOZ_ASSERT(!sIdleMemoryCleanupRunner ||
+             !sIdleMemoryCleanupWantsLaterScheduled);
+  auto result = moz_may_purge_one_now(/* aPeekOnly */ true, reuseGracePeriod);
+  switch (result) {
+    case purge_result_t::Done:
+      // Currently we unqueue purge requests only:
+      // if we run moz_may_purge_one_now with aPeekOnly==false and that happens
+      // only in the IdleTaskRunner which cancels itself when done
+      // OR
+      // if something else causes a MayPurgeAll (like
+      // jemalloc_free_(excess)_dirty_pages or moz_set_max_dirty_page_modifier)
+      // which can happen anytime.
+      if (sIdleMemoryCleanupRunner || sIdleMemoryCleanupWantsLaterScheduled) {
+        PROFILER_MARKER_TEXT(
+            ProfilerString8View::WrapNullTerminatedString(name), OTHER, {},
+            "Done (Cancel timer or runner)"_ns);
+        CancelIdleMemoryCleanupTimerAndRunner();
+      }
+      break;
+    case purge_result_t::WantsLater:
+      if (!sIdleMemoryCleanupWantsLaterScheduled) {
+        PROFILER_MARKER_TEXT(
+            ProfilerString8View::WrapNullTerminatedString(name), OTHER, {},
+            "WantsLater (First schedule of low priority timer)"_ns);
+      }
+      // We always want to (re-)schedule the timer to prevent it from firing
+      // as much as possible.
+      ScheduleWantsLaterTimer(wantsLaterDelay);
+      break;
+    case purge_result_t::NeedsMore:
+      // We can get here from the main thread going repeatedly idle after we
+      // already scheduled a runner. Just keep it.
+      if (!sIdleMemoryCleanupRunner) {
+        PROFILER_MARKER_TEXT(
+            ProfilerString8View::WrapNullTerminatedString(name), OTHER, {},
+            "NeedsMore (Schedule as-soon-as-idle cleanup)"_ns);
+        ScheduleIdleMemoryCleanup(wantsLaterDelay);
+      } else {
+        MOZ_ASSERT(!sIdleMemoryCleanupWantsLaterScheduled);
+      }
+      break;
+  }
+}
+
+// Do some purging until our idle budget is used.
+//
+// At the time the runner actually runs, the situation might have changed wrt
+// when our runner has been scheduled, such that we might find nothing to do.
+// And if we reached our budget and it still NeedsMore, we just keep the runner
+// alive to get another slice of idle time from the current instance.
+// Otherwise we just (un)schedule accordingly like CheckIdleMemoryCleanupNeeded
+// would do.
+//
+// aDeadline:        Deadline passed by the IdleTaskRunner until which we are
+//                   allowed to consume time.
+// aWantsLaterDelay: (Minimum) delay to be used for the WantsLater timer.
+bool RunIdleMemoryCleanup(TimeStamp aDeadline, uint32_t aWantsLaterDelay) {
+  AUTO_PROFILER_MARKER_TEXT("RunIdleMemoryCleanup", OTHER, {}, ""_ns);
+
+  MOZ_ASSERT(!sIdleMemoryCleanupWantsLaterScheduled);
+
+  uint32_t reuseGracePeriod =
+      StaticPrefs::memory_lazypurge_reuse_grace_period();
+
+  purge_result_t result = purge_result_t::NeedsMore;
+  while (result == purge_result_t::NeedsMore) {
+    result = moz_may_purge_one_now(/* aPeekOnly */ false, reuseGracePeriod);
+    if (!aDeadline.IsNull() && TimeStamp::Now() > aDeadline) {
+      break;
+    }
+  }
+
+  switch (result) {
+    case purge_result_t::Done:
+      PROFILER_MARKER_TEXT("RunIdleMemoryCleanup", OTHER, {},
+                           "Done (Cancel timer and runner)"_ns);
+      CancelIdleMemoryCleanupTimerAndRunner();
+      break;
+    case purge_result_t::WantsLater:
+      PROFILER_MARKER_TEXT(
+          "RunIdleMemoryCleanup", OTHER, {},
+          "WantsLater (First schedule of low priority timer)"_ns);
+      ScheduleWantsLaterTimer(aWantsLaterDelay);
+      break;
+    case purge_result_t::NeedsMore:
+      PROFILER_MARKER_TEXT("RunIdleMemoryCleanup", OTHER, {},
+                           "NeedsMore (wait for next idle slice)."_ns);
+      break;
+  }
+  return true;
+};
+
 void TaskController::MayScheduleIdleMemoryCleanup() {
-  // We want to schedule an idle task only if we:
-  // - know to be about to become idle
-  // - are not shutting down
-  // - have not yet an active IdleTaskRunner
-  // - have something to cleanup
   if (PendingMainthreadTaskCountIncludingSuspended() > 0) {
-    // This is a hot code path for the main thread, so please do not add
-    // logic here or before.
+    // This is a hot code path for the main thread, so please be cautious when
+    // adding more logic here or before.
+    // For example it is counterproductive to try to detect here if the main
+    // thread is busy and cancel the timer in case.
     return;
   }
   if (!mIsLazyPurgeEnabled) {
     return;
   }
+
   if (AppShutdown::IsShutdownImpending()) {
-    if (sIdleMemoryCleanupRunner) {
-      sIdleMemoryCleanupRunner->Cancel();
-      sIdleMemoryCleanupRunner = nullptr;
-    }
-    return;
-  }
-
-  if (!moz_may_purge_one_now(/* aPeekOnly */ true)) {
-    // Currently we unqueue purge requests only if we run moz_may_purge_one_now
-    // with aPeekOnly==false and that happens in the below IdleTaskRunner which
-    // cancels itself when done (and all of this happens on the main thread
-    // without possible races) OR if something else causes a MayPurgeAll (like
-    // jemalloc_free_(excess)_dirty_pages or moz_set_max_dirty_page_modifier)
-    // which can happen anytime (and even from other threads).
-    if (sIdleMemoryCleanupRunner) {
-      sIdleMemoryCleanupRunner->Cancel();
-      sIdleMemoryCleanupRunner = nullptr;
-    }
-    return;
-  }
-  if (sIdleMemoryCleanupRunner) {
+    CancelIdleMemoryCleanupTimerAndRunner();
     return;
   }
 
-  // Only create a marker if we really do something.
-  PROFILER_MARKER_TEXT("MayScheduleIdleMemoryCleanup", OTHER, {},
-                       "Schedule for immediate run."_ns);
-
-  TimeDuration maxPurgeDelay = TimeDuration::FromMilliseconds(
-      StaticPrefs::memory_lazypurge_maximum_delay());
-  TimeDuration minPurgeBudget = TimeDuration::FromMilliseconds(
-      StaticPrefs::memory_lazypurge_minimum_idle_budget());
-
-  sIdleMemoryCleanupRunner = IdleTaskRunner::Create(
-      [](TimeStamp aDeadline) {
-        bool pending = moz_may_purge_one_now(true);
-        if (pending) {
-          AUTO_PROFILER_MARKER_TEXT(
-              "DoIdleMemoryCleanup", OTHER, {},
-              "moz_may_purge_one_now until there is budget."_ns);
-          while (pending) {
-            pending = moz_may_purge_one_now(false);
-            if (!aDeadline.IsNull() && TimeStamp::Now() > aDeadline) {
-              break;
-            }
-          }
-        }
-        if (!pending && sIdleMemoryCleanupRunner) {
-          PROFILER_MARKER_TEXT("DoIdleMemoryCleanup", OTHER, {},
-                               "Finished all cleanup."_ns);
-          sIdleMemoryCleanupRunner->Cancel();
-          sIdleMemoryCleanupRunner = nullptr;
-        }
-
-        // We never get here without attempting at least one purge call.
-        return true;
-      },
-      "TaskController::IdlePurgeRunner", TimeDuration::FromMilliseconds(0),
-      maxPurgeDelay, minPurgeBudget, true, nullptr, nullptr);
-  // We do not pass aMayStopProcessing, which would be the only legitimate
-  // reason to return nullptr (OOM would crash), so no fallback needed.
-  MOZ_ASSERT(sIdleMemoryCleanupRunner);
+  CheckIdleMemoryCleanupNeeded(nullptr, (void*)"MayScheduleIdleMemoryCleanup");
 }
 #endif
 
