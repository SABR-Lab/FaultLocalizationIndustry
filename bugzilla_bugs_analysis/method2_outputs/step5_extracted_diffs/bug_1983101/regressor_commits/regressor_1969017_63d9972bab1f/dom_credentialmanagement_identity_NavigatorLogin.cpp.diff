# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/credentialmanagement/identity/NavigatorLogin.cpp
# Commit: 63d9972bab1f
# Full Hash: 63d9972bab1f267a940ec30c7cea7a4c41e54fa6
# Author: Alexandru Marc <amarc@mozila.com>
# Date: 2025-06-06 08:52:03
# Regressor Bug: 1969017
# File Overlap Count: 2
# Description:
#   Revert "Bug 1969015, 1969017: apply code formatting via Lando" for causing leaks @ mochitest.toml
#   
#   This reverts commit a97cb1d6c08bc38e8644bfc916298b847dbac3a1.
#   
#   Revert "Bug 1969017 - Refactor FedCM to use a managed actor rather than tagging onto WindowGlobalParent - r=anti-tracking-reviewers,emz"
# ==============================================================================

diff -r 801e25cb4bfd -r 63d9972bab1f dom/credentialmanagement/identity/NavigatorLogin.cpp
--- a/dom/credentialmanagement/identity/NavigatorLogin.cpp	Thu Jun 05 18:51:36 2025 +0000
+++ b/dom/credentialmanagement/identity/NavigatorLogin.cpp	Thu Jun 05 21:40:49 2025 +0300
@@ -11,7 +11,7 @@
 #include "mozilla/dom/Promise.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/net/SFVService.h"
-#include "mozilla/dom/WebIdentityHandler.h"
+#include "mozilla/dom/WindowGlobalChild.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsIGlobalObject.h"
 #include "nsIPermissionManager.h"
@@ -57,30 +57,54 @@
   return NavigatorLogin_Binding::Wrap(aCx, this, aGivenProto);
 }
 
-NavigatorLogin::NavigatorLogin(nsPIDOMWindowInner* aGlobal) : mOwner(aGlobal) {
+NavigatorLogin::NavigatorLogin(nsIGlobalObject* aGlobal) : mOwner(aGlobal) {
   MOZ_ASSERT(mOwner);
 };
 
 already_AddRefed<mozilla::dom::Promise> NavigatorLogin::SetStatus(
     LoginStatus aStatus, mozilla::ErrorResult& aRv) {
-  RefPtr<Promise> promise = Promise::Create(mOwner->AsGlobal(), aRv);
+  RefPtr<Promise> promise = Promise::Create(mOwner, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  if (!CredentialsContainer::IsSameOriginWithAncestors(mOwner)) {
+  nsPIDOMWindowInner* window = mOwner->GetAsInnerWindow();
+  if (!window) {
+    promise->MaybeRejectWithUnknownError(
+        "navigator.login.setStatus called on unavailable window"_ns);
+    return promise.forget();
+  }
+
+  if (!CredentialsContainer::IsSameOriginWithAncestors(window)) {
     promise->MaybeRejectWithSecurityError(
         "navigator.login.setStatus must be called in a frame that is same-origin with its ancestors"_ns);
     return promise.forget();
   }
 
-  WebIdentityHandler* identityHandler = mOwner->GetOrCreateWebIdentityHandler();
-  if (!identityHandler) {
-    promise->MaybeRejectWithOperationError("");
+  WindowGlobalChild* wgc = window->GetWindowGlobalChild();
+  if (!wgc) {
+    promise->MaybeRejectWithUnknownError(
+        "navigator.login.setStatus called while window already destroyed"_ns);
     return promise.forget();
   }
 
-  identityHandler->SetLoginStatus(aStatus, promise);
+  wgc->SendSetLoginStatus(aStatus)->Then(
+      GetCurrentSerialEventTarget(), __func__,
+      [promise](
+          const WindowGlobalChild::SetLoginStatusPromise::ResolveValueType&
+              aResult) {
+        if (NS_SUCCEEDED(aResult)) {
+          promise->MaybeResolveWithUndefined();
+        } else {
+          promise->MaybeRejectWithUnknownError(
+              "navigator.login.setStatus had an unexpected internal error");
+        }
+      },
+      [promise](const WindowGlobalChild::SetLoginStatusPromise::RejectValueType&
+                    aResult) {
+        promise->MaybeRejectWithUnknownError(
+            "navigator.login.setStatus had an unexpected internal error");
+      });
   return promise.forget();
 }
 