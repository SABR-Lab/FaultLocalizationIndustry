# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/credentialmanagement/CredentialsContainer.cpp
# Commit: ccd96b99aea2
# Full Hash: ccd96b99aea28e8214e585b864d3fb2245bac142
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-06-07 08:31:23
# Regressor Bug: 1969017
# File Overlap Count: 2
# Description:
#   Revert "Bug 1969015, 1969017: apply code formatting via Lando" for causing failures complaining about fedcm-no-registered-idps.https.html.
#   
#   This reverts commit ba33457e0cbac24a8b7d963c45138c62e92a74ae.
#   
#   Revert "Bug 1969017 - Refactor FedCM to use a managed actor rather than tagging onto WindowGlobalParent - r=anti-tracking-reviewers,emz"
# ==============================================================================

diff -r 4bfadfc33207 -r ccd96b99aea2 dom/credentialmanagement/CredentialsContainer.cpp
--- a/dom/credentialmanagement/CredentialsContainer.cpp	Fri Jun 06 21:07:41 2025 +0300
+++ b/dom/credentialmanagement/CredentialsContainer.cpp	Fri Jun 06 21:35:18 2025 +0300
@@ -4,17 +4,22 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "mozilla/Components.h"
+#include "mozilla/CredentialChosenCallback.h"
 #include "mozilla/dom/Credential.h"
 #include "mozilla/dom/CredentialsContainer.h"
 #include "mozilla/dom/FeaturePolicyUtils.h"
+#include "mozilla/dom/IdentityCredential.h"
 #include "mozilla/dom/Promise.h"
+#include "mozilla/dom/Promise-inl.h"
 #include "mozilla/StaticPrefs_dom.h"
 #include "mozilla/StaticPrefs_security.h"
-#include "mozilla/dom/WebIdentityHandler.h"
 #include "mozilla/dom/WebAuthnHandler.h"
 #include "mozilla/dom/WindowGlobalChild.h"
 #include "mozilla/dom/WindowContext.h"
 #include "nsContentUtils.h"
+#include "nsFocusManager.h"
+#include "nsICredentialChooserService.h"
 #include "nsIDocShell.h"
 
 namespace mozilla::dom {
@@ -125,7 +130,7 @@
 }
 
 CredentialsContainer::CredentialsContainer(nsPIDOMWindowInner* aParent)
-    : mParent(aParent) {
+    : mParent(aParent), mActiveIdentityRequest(false) {
   MOZ_ASSERT(aParent);
 }
 
@@ -208,18 +213,29 @@
       return promise.forget();
     }
 
-    WebIdentityHandler* identityHandler =
-        mParent->GetOrCreateWebIdentityHandler();
-    if (!identityHandler) {
-      promise->MaybeRejectWithOperationError("");
+    if (mActiveIdentityRequest) {
+      promise->MaybeRejectWithInvalidStateError(
+          "Concurrent 'identity' credentials.get requests are not supported."_ns);
       return promise.forget();
     }
-    if (aOptions.mSignal.WasPassed()) {
-      identityHandler->Follow(&aOptions.mSignal.Value());
-    }
-    identityHandler->GetCredential(aOptions, IsSameOriginWithAncestors(mParent),
-                                   promise);
+    mActiveIdentityRequest = true;
+
+    RefPtr<CredentialsContainer> self = this;
 
+    promise->AddCallbacksWithCycleCollectedArgs(
+        [](JSContext* aCx, JS::Handle<JS::Value> aValue, ErrorResult& aRv,
+           const RefPtr<CredentialsContainer>& aContainer) {
+          aContainer->mActiveIdentityRequest = false;
+        },
+        [](JSContext* aCx, JS::Handle<JS::Value> aValue, ErrorResult& aRv,
+           const RefPtr<CredentialsContainer>& aContainer) {
+          aContainer->mActiveIdentityRequest = false;
+        },
+        self);
+
+    IdentityCredentialRequestOptions options(aOptions.mIdentity.Value());
+    IdentityCredential::GetCredential(
+        mParent, aOptions, IsSameOriginWithAncestors(mParent), promise);
     return promise.forget();
   }
 
@@ -258,6 +274,27 @@
                                             aOptions.mSignal, aRv);
   }
 
+  if (aOptions.mIdentity.WasPassed() &&
+      StaticPrefs::dom_security_credentialmanagement_identity_enabled() &&
+      StaticPrefs::
+          dom_security_credentialmanagement_identity_lightweight_enabled()) {
+    MOZ_ASSERT(mParent);
+    RefPtr<Promise> promise = CreatePromise(mParent, aRv);
+    if (!promise) {
+      return nullptr;
+    }
+
+    IdentityCredential::Create(mParent, aOptions,
+                               IsSameOriginWithAncestors(mParent))
+        ->Then(
+            GetCurrentSerialEventTarget(), __func__,
+            [promise](const RefPtr<IdentityCredential>& credential) {
+              promise->MaybeResolve(credential);
+            },
+            [promise](nsresult error) { promise->MaybeReject(error); });
+    return promise.forget();
+  }
+
   return CreateAndRejectWithNotSupported(mParent, aRv);
 }
 
@@ -275,6 +312,25 @@
     return mWebAuthnHandler->Store(aCredential, aRv);
   }
 
+  if (type.EqualsLiteral("identity") &&
+      StaticPrefs::dom_security_credentialmanagement_identity_enabled() &&
+      StaticPrefs::
+          dom_security_credentialmanagement_identity_lightweight_enabled()) {
+    MOZ_ASSERT(mParent);
+    RefPtr<Promise> promise = CreatePromise(mParent, aRv);
+    if (!promise) {
+      return nullptr;
+    }
+
+    IdentityCredential::Store(
+        mParent, static_cast<const IdentityCredential*>(&aCredential),
+        IsSameOriginWithAncestors(mParent))
+        ->Then(
+            GetCurrentSerialEventTarget(), __func__,
+            [promise](bool success) { promise->MaybeResolveWithUndefined(); },
+            [promise](nsresult error) { promise->MaybeReject(error); });
+    return promise.forget();
+  }
   return CreateAndRejectWithNotSupported(mParent, aRv);
 }
 
@@ -291,14 +347,12 @@
     return nullptr;
   }
 
-  WebIdentityHandler* identityHandler =
-      mParent->GetOrCreateWebIdentityHandler();
-  if (!identityHandler) {
-    promise->MaybeRejectWithOperationError("");
-    return promise.forget();
-  }
+  RefPtr<WindowGlobalChild> wgc = mParent->GetWindowGlobalChild();
+  MOZ_ASSERT(wgc);
 
-  identityHandler->PreventSilentAccess(promise);
+  wgc->SendPreventSilentAccess()->Then(
+      GetCurrentSerialEventTarget(), __func__,
+      [promise] { promise->MaybeResolveWithUndefined(); });
   return promise.forget();
 }
 