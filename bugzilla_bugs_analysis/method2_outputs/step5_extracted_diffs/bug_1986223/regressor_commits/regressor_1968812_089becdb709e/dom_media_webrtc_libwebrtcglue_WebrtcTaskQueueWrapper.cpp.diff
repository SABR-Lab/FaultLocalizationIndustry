# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.cpp
# Commit: 089becdb709e
# Full Hash: 089becdb709edf0ee24e60ebfdc4f0be25459eec
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2025-06-19 21:40:31
# Regressor Bug: 1968812
# File Overlap Count: 1
# Description:
#   Bug 1968812 - Don't hold a lock while running tasks in WebrtcTaskQueueWrapper. r=bwc
#   
#   It can cause deadlocks, as observed with TimerThread, which also holds a lock
#   while running tasks. This patch simplifies the Delete function of
#   WebrtcTaskQueueWrapper, which is possible since there is now only a single
# ==============================================================================

diff -r 1c0d9fdb8a06 -r 089becdb709e dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.cpp
--- a/dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.cpp	Thu Jun 19 08:18:29 2025 +0000
+++ b/dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.cpp	Thu Jun 19 08:18:30 2025 +0000
@@ -6,10 +6,7 @@
 #include "WebrtcTaskQueueWrapper.h"
 
 #include "api/task_queue/task_queue_factory.h"
-#include "mozilla/DataMutex.h"
-#include "mozilla/RecursiveMutex.h"
 #include "mozilla/TaskQueue.h"
-#include "mozilla/media/MediaUtils.h"  // For media::Await
 #include "VideoUtils.h"
 
 namespace mozilla {
@@ -65,64 +62,45 @@
 
  public:
   template <typename Target>
-  WebrtcTaskQueueWrapper(Target aTaskQueue, nsCString aName)
-      : mTaskQueue(std::forward<Target>(aTaskQueue)), mName(std::move(aName)) {}
+  WebrtcTaskQueueWrapper(Target aTaskQueue, const nsACString& aName)
+      : mTaskQueue(std::forward<Target>(aTaskQueue)), mName(aName) {}
   ~WebrtcTaskQueueWrapper() = default;
 
   void Delete() override {
-    {
-      // Scope this to make sure it does not race against the promise chain we
-      // set up below.
-      auto hasShutdown = mHasShutdown.Lock();
-      *hasShutdown = true;
-    }
-
-    MOZ_RELEASE_ASSERT(Deletion == DeletionPolicy::NonBlocking ||
-                       !mTaskQueue->IsOnCurrentThread());
-
-    if constexpr (Deletion == DeletionPolicy::NonBlocking) {
-      delete this;
-      return;
-    }
-
-    nsCOMPtr<nsISerialEventTarget> backgroundTaskQueue;
-    NS_CreateBackgroundTaskQueue(__func__, getter_AddRefs(backgroundTaskQueue));
-    if (NS_WARN_IF(!backgroundTaskQueue)) {
-      // Ok... that's pretty broken. Try main instead.
-      MOZ_ASSERT(false);
-      backgroundTaskQueue = GetMainThreadSerialEventTarget();
+    if constexpr (Deletion == DeletionPolicy::Blocking) {
+      MOZ_RELEASE_ASSERT(!mTaskQueue->IsOnCurrentThread());
+      // Don't call into the task queue if non-blocking as it is in the middle
+      // of its dtor. There'd be nothing to wait for anyway.
+      mTaskQueue->BeginShutdown();
+      mTaskQueue->AwaitShutdownAndIdle();
+      mTaskQueue->SetObserver(nullptr);
     }
 
-    RefPtr<GenericPromise> shutdownPromise = mTaskQueue->BeginShutdown()->Then(
-        backgroundTaskQueue, __func__, [this] {
-          // Wait until shutdown is complete, then delete for real. Although we
-          // prevent queued tasks from executing with mHasShutdown, that is a
-          // member variable, which means we still need to ensure that the
-          // queue is done executing tasks before destroying it.
-          mTaskQueue->SetObserver(nullptr);
-          delete this;
-          return GenericPromise::CreateAndResolve(true, __func__);
-        });
-    media::Await(backgroundTaskQueue.forget(), shutdownPromise);
+    delete this;
   }
 
-  already_AddRefed<Runnable> CreateTaskRunner(
+  already_AddRefed<Runnable> WrapInvocable(
       absl::AnyInvocable<void() &&>&& aTask) {
-    return NS_NewRunnableFunction(
-        __func__, [this, task = std::move(aTask)]() mutable {
-          auto hasShutdownGuard = mHasShutdown.ConstLock();
-          if (*hasShutdownGuard) {
-            return;
-          }
-          std::move(task)();
-        });
+    struct InvocableRunnable final : public Runnable {
+      absl::AnyInvocable<void() &&> mTask;
+
+      explicit InvocableRunnable(absl::AnyInvocable<void() &&>&& aTask)
+          : Runnable("WebrtcTaskQueueWrapper::InvocableRunnable"),
+            mTask(std::move(aTask)) {}
+
+      NS_IMETHOD Run() {
+        std::move(mTask)();
+        return NS_OK;
+      }
+    };
+
+    return MakeAndAddRef<InvocableRunnable>(std::move(aTask));
   }
 
   void PostTaskImpl(absl::AnyInvocable<void() &&> aTask,
                     const PostTaskTraits& aTraits,
                     const webrtc::Location& aLocation) override {
-    MOZ_ALWAYS_SUCCEEDS(
-        mTaskQueue->Dispatch(CreateTaskRunner(std::move(aTask))));
+    MOZ_ALWAYS_SUCCEEDS(mTaskQueue->Dispatch(WrapInvocable(std::move(aTask))));
   }
 
   void PostDelayedTaskImpl(absl::AnyInvocable<void() &&> aTask,
@@ -135,7 +113,7 @@
       return;
     }
     MOZ_ALWAYS_SUCCEEDS(mTaskQueue->DelayedDispatch(
-        CreateTaskRunner(std::move(aTask)), aDelay.ms()));
+        WrapInvocable(std::move(aTask)), aDelay.ms()));
   }
 
   // If Blocking, access is through WebrtcTaskQueueWrapper, which has to keep
@@ -144,17 +122,8 @@
   const std::conditional_t<Deletion == DeletionPolicy::Blocking,
                            RefPtr<TaskQueue>, TaskQueue*>
       mTaskQueue;
+  // Storage for mTaskQueue's null-terminated const char* name.
   const nsCString mName;
-
-  // This is a recursive mutex because a TaskRunner holding this mutex while
-  // running its runnable may end up running other - tail dispatched - runnables
-  // too, and they'll again try to grab the mutex.
-  // The mutex must be held while running the runnable since otherwise there'd
-  // be a race between shutting down the underlying task queue and the runnable
-  // dispatching to that task queue (and we assert it succeeds in e.g.,
-  // PostTask()).
-  DataMutexBase<bool, RecursiveMutex> mHasShutdown{
-      false, "WebrtcTaskQueueWrapper::mHasShutdown"};
 };
 
 template <DeletionPolicy Deletion>
@@ -168,11 +137,12 @@
 
 std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>
 CreateWebrtcTaskQueue(already_AddRefed<nsIEventTarget> aTarget,
-                      const nsCString& aName, bool aSupportsTailDispatch) {
+                      const nsACString& aName, bool aSupportsTailDispatch) {
   using Wrapper = WebrtcTaskQueueWrapper<DeletionPolicy::Blocking>;
+  const auto& flat = PromiseFlatCString(aName);
   auto tq =
-      TaskQueue::Create(std::move(aTarget), aName.get(), aSupportsTailDispatch);
-  auto wrapper = MakeUnique<Wrapper>(std::move(tq), aName);
+      TaskQueue::Create(std::move(aTarget), flat.get(), aSupportsTailDispatch);
+  auto wrapper = MakeUnique<Wrapper>(std::move(tq), flat);
   auto observer = MakeRefPtr<Wrapper::TaskQueueObserver>(wrapper.get());
   wrapper->mTaskQueue->SetObserver(observer);
   return std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>(
@@ -180,12 +150,13 @@
 }
 
 RefPtr<TaskQueue> CreateWebrtcTaskQueueWrapper(
-    already_AddRefed<nsIEventTarget> aTarget, const nsCString& aName,
+    already_AddRefed<nsIEventTarget> aTarget, const nsACString& aName,
     bool aSupportsTailDispatch) {
   using Wrapper = WebrtcTaskQueueWrapper<DeletionPolicy::NonBlocking>;
+  const auto& flat = PromiseFlatCString(aName);
   auto tq =
-      TaskQueue::Create(std::move(aTarget), aName.get(), aSupportsTailDispatch);
-  auto wrapper = MakeUnique<Wrapper>(tq.get(), aName);
+      TaskQueue::Create(std::move(aTarget), flat.get(), aSupportsTailDispatch);
+  auto wrapper = MakeUnique<Wrapper>(tq.get(), flat);
   auto observer = MakeRefPtr<Wrapper::TaskQueueObserver>(std::move(wrapper));
   tq->SetObserver(observer);
   return tq;
@@ -202,11 +173,11 @@
       // until they've run, and that doesn't play nice with tail dispatching
       // since there will never be a tail. DeletionPolicy::Blocking because this
       // is for libwebrtc use and that's what they expect.
-      nsCString name(aName.data(), aName.size());
       constexpr bool supportTailDispatch = false;
       // XXX Do something with aPriority
       return CreateWebrtcTaskQueue(
-          GetMediaThreadPool(MediaThreadType::WEBRTC_WORKER), name,
+          GetMediaThreadPool(MediaThreadType::WEBRTC_WORKER),
+          nsDependentCSubstring(aName.data(), aName.size()),
           supportTailDispatch);
     }
   };