# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.h
# Commit: 7a33c8b73972
# Full Hash: 7a33c8b7397200d89a0d3904669777e60550c445
# Author: Andreas Pehrson <apehrson@mozilla.com>
# Date: 2025-06-11 18:38:51
# Regressor Bug: 1968812
# File Overlap Count: 1
# Description:
#   Bug 1968812 - Remove the CallWorker thread and use TaskQueue::Observer instead. r=bwc
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D252686
# ==============================================================================

diff -r a3ad3abc4d02 -r 7a33c8b73972 dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.h
--- a/dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.h	Wed Jun 11 13:37:22 2025 +0000
+++ b/dom/media/webrtc/libwebrtcglue/WebrtcTaskQueueWrapper.h	Wed Jun 11 13:37:23 2025 +0000
@@ -6,179 +6,64 @@
 #ifndef DOM_MEDIA_WEBRTC_LIBWEBRTCGLUE_TASKQUEUEWRAPPER_H_
 #define DOM_MEDIA_WEBRTC_LIBWEBRTCGLUE_TASKQUEUEWRAPPER_H_
 
-#include "api/task_queue/task_queue_factory.h"
-#include "mozilla/DataMutex.h"
-#include "mozilla/RecursiveMutex.h"
-#include "mozilla/TaskQueue.h"
-#include "VideoUtils.h"
-#include "mozilla/media/MediaUtils.h"  // For media::Await
+#include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/UniquePtr.h"
+#include "nsStringFwd.h"
+
+class nsIEventTarget;
+
+namespace webrtc {
+class TaskQueueBase;
+struct TaskQueueDeleter;
+class TaskQueueFactory;
+}  // namespace webrtc
 
 namespace mozilla {
-enum class DeletionPolicy : uint8_t { Blocking, NonBlocking };
+class TaskQueue;
 
 /**
- * A wrapper around Mozilla TaskQueues in the shape of a libwebrtc TaskQueue.
+ * Creates a libwebrtc task queue backed by a mozilla::TaskQueue.
  *
- * Allows libwebrtc to use Mozilla threads where tooling, e.g. profiling, is set
- * up and just works.
+ * While in a task running on the returned task queue, both
+ * webrtc::TaskQueueBase::Current() and mozilla::AbstractThread::GetCurrent()
+ * will work as expected.
  *
- * Mozilla APIs like Runnables, MozPromise, etc. can also be used with the
- * wrapped TaskQueue to run things on the right thread when interacting with
- * libwebrtc.
+ * Releasing the returned task queue will synchronously shut down the underlying
+ * mozilla::TaskQueue. Execution will be blocked until the underlying task queue
+ * has finished running any pending tasks. The returned task queue must not be
+ * released while on itself, or a deadlock will occur.
  */
-template <DeletionPolicy Deletion>
-class WebrtcTaskQueueWrapper : public webrtc::TaskQueueBase {
- private:
-  class TaskQueueObserver final : public TaskQueue::Observer {
-   public:
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(TaskQueueObserver, override);
-
-    explicit TaskQueueObserver(WebrtcTaskQueueWrapper* aOwner)
-        : mOwner(aOwner) {}
-
-    void WillProcessEvent(TaskQueue* aQueue) override {
-      mCurrent.emplace(mOwner);
-    }
-    void DidProcessEvent(TaskQueue* aQueue) override { mCurrent = Nothing(); }
-
-   private:
-    ~TaskQueueObserver() override = default;
-    // mOwner is safe because it is not destroyed until the underlying TaskQueue
-    // has finished shutdown.
-    WebrtcTaskQueueWrapper* const mOwner;
-    Maybe<CurrentTaskQueueSetter> mCurrent;
-  };
-
- public:
-  WebrtcTaskQueueWrapper(already_AddRefed<nsIEventTarget> aTarget,
-                         nsCString aName, bool aSupportsTailDispatch)
-      : mTaskQueue(TaskQueue::Create(std::move(aTarget),
-                                     "WebrtcTaskQueueWrapper::mTaskQueue",
-                                     aSupportsTailDispatch)),
-        mName(std::move(aName)) {
-    auto observer = MakeRefPtr<TaskQueueObserver>(this);
-    mTaskQueue->SetObserver(observer);
-  }
-  ~WebrtcTaskQueueWrapper() = default;
-
-  void Delete() override {
-    {
-      // Scope this to make sure it does not race against the promise chain we
-      // set up below.
-      auto hasShutdown = mHasShutdown.Lock();
-      *hasShutdown = true;
-    }
-
-    MOZ_RELEASE_ASSERT(Deletion == DeletionPolicy::NonBlocking ||
-                       !mTaskQueue->IsOnCurrentThread());
-
-    nsCOMPtr<nsISerialEventTarget> backgroundTaskQueue;
-    NS_CreateBackgroundTaskQueue(__func__, getter_AddRefs(backgroundTaskQueue));
-    if (NS_WARN_IF(!backgroundTaskQueue)) {
-      // Ok... that's pretty broken. Try main instead.
-      MOZ_ASSERT(false);
-      backgroundTaskQueue = GetMainThreadSerialEventTarget();
-    }
-
-    RefPtr<GenericPromise> shutdownPromise = mTaskQueue->BeginShutdown()->Then(
-        backgroundTaskQueue, __func__, [this] {
-          // Wait until shutdown is complete, then delete for real. Although we
-          // prevent queued tasks from executing with mHasShutdown, that is a
-          // member variable, which means we still need to ensure that the
-          // queue is done executing tasks before destroying it.
-          mTaskQueue->SetObserver(nullptr);
-          delete this;
-          return GenericPromise::CreateAndResolve(true, __func__);
-        });
-    if constexpr (Deletion == DeletionPolicy::Blocking) {
-      media::Await(backgroundTaskQueue.forget(), shutdownPromise);
-    } else {
-      Unused << shutdownPromise;
-    }
-  }
+std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>
+CreateWebrtcTaskQueue(already_AddRefed<nsIEventTarget> aTarget,
+                      const nsCString& aName, bool aSupportsTailDispatch);
 
-  already_AddRefed<Runnable> CreateTaskRunner(
-      absl::AnyInvocable<void() &&>&& aTask) {
-    return NS_NewRunnableFunction(
-        __func__, [this, task = std::move(aTask)]() mutable {
-          auto hasShutdownGuard = mHasShutdown.ConstLock();
-          if (*hasShutdownGuard) {
-            return;
-          }
-          std::move(task)();
-        });
-  }
-
-  void PostTaskImpl(absl::AnyInvocable<void() &&> aTask,
-                    const PostTaskTraits& aTraits,
-                    const webrtc::Location& aLocation) override {
-    MOZ_ALWAYS_SUCCEEDS(
-        mTaskQueue->Dispatch(CreateTaskRunner(std::move(aTask))));
-  }
-
-  void PostDelayedTaskImpl(absl::AnyInvocable<void() &&> aTask,
-                           webrtc::TimeDelta aDelay,
-                           const PostDelayedTaskTraits& aTraits,
-                           const webrtc::Location& aLocation) override {
-    if (aDelay.ms() == 0) {
-      // AbstractThread::DelayedDispatch doesn't support delay 0
-      PostTaskImpl(std::move(aTask), PostTaskTraits{}, aLocation);
-      return;
-    }
-    MOZ_ALWAYS_SUCCEEDS(mTaskQueue->DelayedDispatch(
-        CreateTaskRunner(std::move(aTask)), aDelay.ms()));
-  }
-
-  const RefPtr<TaskQueue> mTaskQueue;
-  const nsCString mName;
+/**
+ * Creates a mozilla task queue that also exposes a webrtc::TaskQueueBase.
+ *
+ * While in a task running on the returned task queue, both
+ * webrtc::TaskQueueBase::Current() and mozilla::AbstractThread::GetCurrent()
+ * will work as expected.
+ *
+ * webrtc::TaskQueueBase is not refcounted and the representation here is only
+ * accessible through webrtc::TaskQueueBase::Current(). The returned task queue
+ * controls the lifetime of the webrtc::TaskQueueBase instance, which will be
+ * destroyed as the returned task queue finishes shutdown. The thread on which
+ * it is destroyed is not guaranteed.
+ *
+ * Shutdown of the returned task queue is asynchronous, either through
+ * BeginShutdown(), or through releasing all references to it. See
+ * mozilla::TaskQueue.
+ */
+RefPtr<TaskQueue> CreateWebrtcTaskQueueWrapper(
+    already_AddRefed<nsIEventTarget> aTarget, const nsCString& aName,
+    bool aSupportsTailDispatch);
 
-  // This is a recursive mutex because a TaskRunner holding this mutex while
-  // running its runnable may end up running other - tail dispatched - runnables
-  // too, and they'll again try to grab the mutex.
-  // The mutex must be held while running the runnable since otherwise there'd
-  // be a race between shutting down the underlying task queue and the runnable
-  // dispatching to that task queue (and we assert it succeeds in e.g.,
-  // PostTask()).
-  DataMutexBase<bool, RecursiveMutex> mHasShutdown{
-      false, "WebrtcTaskQueueWrapper::mHasShutdown"};
-};
-
-template <DeletionPolicy Deletion>
-class DefaultDelete<WebrtcTaskQueueWrapper<Deletion>>
-    : public webrtc::TaskQueueDeleter {
- public:
-  void operator()(WebrtcTaskQueueWrapper<Deletion>* aPtr) const {
-    webrtc::TaskQueueDeleter::operator()(aPtr);
-  }
-};
-
-class SharedThreadPoolWebRtcTaskQueueFactory : public webrtc::TaskQueueFactory {
- public:
-  template <DeletionPolicy Deletion>
-  UniquePtr<WebrtcTaskQueueWrapper<Deletion>> CreateWebrtcTaskQueueWrapper(
-      absl::string_view aName, bool aSupportTailDispatch, Priority aPriority,
-      MediaThreadType aThreadType = MediaThreadType::WEBRTC_WORKER) const {
-    // XXX Do something with aPriority
-    nsCString name(aName.data(), aName.size());
-    return MakeUnique<WebrtcTaskQueueWrapper<Deletion>>(
-        GetMediaThreadPool(aThreadType), std::move(name), aSupportTailDispatch);
-  }
-
-  std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>
-  CreateTaskQueue(absl::string_view aName, Priority aPriority) const override {
-    // libwebrtc will dispatch some tasks sync, i.e., block the origin thread
-    // until they've run, and that doesn't play nice with tail dispatching since
-    // there will never be a tail.
-    // DeletionPolicy::Blocking because this is for libwebrtc use and that's
-    // what they expect.
-    constexpr bool supportTailDispatch = false;
-    return std::unique_ptr<webrtc::TaskQueueBase, webrtc::TaskQueueDeleter>(
-        CreateWebrtcTaskQueueWrapper<DeletionPolicy::Blocking>(
-            std::move(aName), supportTailDispatch, aPriority)
-            .release(),
-        webrtc::TaskQueueDeleter());
-  }
-};
+/**
+ * Creates a libwebrtc task queue factory that returns webrtc::TaskQueueBase
+ * instances backed by mozilla::TaskQueues. See CreateWebrtcTaskQueue above.
+ */
+UniquePtr<webrtc::TaskQueueFactory> CreateWebrtcTaskQueueFactory();
 
 }  // namespace mozilla
 