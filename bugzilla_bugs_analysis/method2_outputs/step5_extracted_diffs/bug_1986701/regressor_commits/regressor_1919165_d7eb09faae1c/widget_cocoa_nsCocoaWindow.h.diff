# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/cocoa/nsCocoaWindow.h
# Commit: d7eb09faae1c
# Full Hash: d7eb09faae1c39fe5ba7039c0c14b9ee13fe6f48
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2025-04-29 20:49:47
# Regressor Bug: 1919165
# File Overlap Count: 1
# Description:
#   Bug 1919165 - Get rid of nsChildView. r=mac-reviewers,mstange
#   
#   In a follow-up I want to merge nsChildView.mm into nsCocoaWindow.mm, but
#   I thought I'd send this for feedback.
#   
# ==============================================================================

diff -r 1eeb386120ff -r d7eb09faae1c widget/cocoa/nsCocoaWindow.h
--- a/widget/cocoa/nsCocoaWindow.h	Tue Apr 29 13:50:20 2025 +0000
+++ b/widget/cocoa/nsCocoaWindow.h	Tue Apr 29 13:51:02 2025 +0000
@@ -14,6 +14,8 @@
 #include "nsBaseWidget.h"
 #include "nsCocoaUtils.h"
 #include "nsTouchBar.h"
+#include "ViewRegion.h"
+#include "mozView.h"
 #include <dlfcn.h>
 #include <queue>
 
@@ -24,6 +26,10 @@
 
 namespace mozilla {
 enum class NativeKeyBindingsType : uint8_t;
+class VibrancyManager;
+namespace widget {
+class TextInputHandler;
+}
 }  // namespace mozilla
 
 // NSWindow subclass that is the base class for all of our own window classes.
@@ -57,6 +63,7 @@
 - (NSMutableDictionary*)exportState;
 - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState;
 - (BOOL)drawsContentsIntoWindowFrame;
+- (NSRect)childViewFrameRectForCurrentBounds;
 
 // These two methods are like contentRectForFrameRect and
 // frameRectForContentRect, but they deal with the rect of the window's "main
@@ -213,6 +220,9 @@
   LayoutDeviceIntPoint WidgetToScreenOffset() override;
   LayoutDeviceIntPoint GetClientOffset() override;
   LayoutDeviceIntMargin NormalSizeModeClientToWindowMargin() override;
+  bool ShowsResizeIndicator(LayoutDeviceIntRect* aResizerRect) override {
+    return false;
+  }
 
   void* GetNativeData(uint32_t aDataType) override;
 
@@ -225,6 +235,104 @@
   void MoveToWorkspace(const nsAString& workspaceID) override;
   void SuppressAnimation(bool aSuppress) override;
   void HideWindowChrome(bool aShouldHide) override;
+  NSView<mozView>* GetEditorView();
+
+  nsresult SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
+                                    int32_t aNativeKeyCode,
+                                    uint32_t aModifierFlags,
+                                    const nsAString& aCharacters,
+                                    const nsAString& aUnmodifiedCharacters,
+                                    nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                      NativeMouseMessage aNativeMessage,
+                                      mozilla::MouseButton aButton,
+                                      nsIWidget::Modifiers aModifierFlags,
+                                      nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeMouseMove(LayoutDeviceIntPoint aPoint,
+                                     nsIObserver* aObserver) override {
+    return SynthesizeNativeMouseEvent(
+        aPoint, NativeMouseMessage::Move, mozilla::MouseButton::eNotPressed,
+        nsIWidget::Modifiers::NO_MODIFIERS, aObserver);
+  }
+  nsresult SynthesizeNativeMouseScrollEvent(
+      LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage, double aDeltaX,
+      double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
+      uint32_t aAdditionalFlags, nsIObserver* aObserver) override;
+  nsresult SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                      TouchPointerState aPointerState,
+                                      LayoutDeviceIntPoint aPoint,
+                                      double aPointerPressure,
+                                      uint32_t aPointerOrientation,
+                                      nsIObserver* aObserver) override;
+
+  nsresult SynthesizeNativeTouchpadDoubleTap(LayoutDeviceIntPoint aPoint,
+                                             uint32_t aModifierFlags) override;
+
+  static bool DoHasPendingInputEvent();
+  static uint32_t GetCurrentInputEventCount();
+  static void UpdateCurrentInputEventCount();
+
+  // unit conversion convenience functions
+  int32_t CocoaPointsToDevPixels(CGFloat aPts) const {
+    return nsCocoaUtils::CocoaPointsToDevPixels(aPts, BackingScaleFactor());
+  }
+  LayoutDeviceIntPoint CocoaPointsToDevPixels(const NSPoint& aPt) const {
+    return nsCocoaUtils::CocoaPointsToDevPixels(aPt, BackingScaleFactor());
+  }
+  LayoutDeviceIntPoint CocoaPointsToDevPixelsRoundDown(
+      const NSPoint& aPt) const {
+    return nsCocoaUtils::CocoaPointsToDevPixelsRoundDown(aPt,
+                                                         BackingScaleFactor());
+  }
+  LayoutDeviceIntRect CocoaPointsToDevPixels(const NSRect& aRect) const {
+    return nsCocoaUtils::CocoaPointsToDevPixels(aRect, BackingScaleFactor());
+  }
+  CGFloat DevPixelsToCocoaPoints(int32_t aPixels) const {
+    return nsCocoaUtils::DevPixelsToCocoaPoints(aPixels, BackingScaleFactor());
+  }
+  NSRect DevPixelsToCocoaPoints(const LayoutDeviceIntRect& aRect) const {
+    return nsCocoaUtils::DevPixelsToCocoaPoints(aRect, BackingScaleFactor());
+  }
+
+  // Called by nsCocoaWindow when the window's fullscreen state changes.
+  void UpdateFullscreen(bool aFullscreen);
+
+  void DispatchAPZWheelInputEvent(mozilla::InputData& aEvent);
+  nsEventStatus DispatchAPZInputEvent(mozilla::InputData& aEvent);
+
+  void DispatchDoubleTapGesture(mozilla::TimeStamp aEventTimeStamp,
+                                LayoutDeviceIntPoint aScreenPosition,
+                                mozilla::Modifiers aModifiers);
+
+  // Called when the main thread enters a phase during which visual changes
+  // are imminent and any layer updates on the compositor thread would interfere
+  // with visual atomicity.
+  // "Async" CATransactions are CATransactions which happen on a thread that's
+  // not the main thread.
+  void SuspendAsyncCATransactions();
+
+  // Called when we know that the current main thread paint will be completed
+  // once the main thread goes back to the event loop.
+  void MaybeScheduleUnsuspendAsyncCATransactions();
+
+  // Called from the runnable dispatched by
+  // MaybeScheduleUnsuspendAsyncCATransactions(). At this point we know that the
+  // main thread is done handling the visual change (such as a window resize)
+  // and we can start modifying CALayers from the compositor thread again.
+  void UnsuspendAsyncCATransactions();
+
+#ifdef DEBUG
+  // test only.
+  nsresult SetHiDPIMode(bool aHiDPI) override;
+  nsresult RestoreHiDPIMode() override;
+#endif
+
+  void UpdateVibrancy(const nsTArray<ThemeGeometry>& aThemeGeometries);
+  mozilla::VibrancyManager& EnsureVibrancyManager();
+
+  void TearDownView();
 
   bool PrepareForFullscreenTransition(nsISupports** aData) override;
   void PerformFullscreenTransition(FullscreenTransitionStage aStage,
@@ -251,13 +359,49 @@
   LayoutDeviceIntRect GetScreenBounds() override;
   void ReportMoveEvent();
   void ReportSizeEvent();
+  bool WidgetTypeSupportsAcceleration() override { return true; }
+  bool ShouldUseOffMainThreadCompositing() override;
   void SetCursor(const Cursor&) override;
 
-  CGFloat BackingScaleFactor();
+  void UpdateBoundsFromView();
+  void EnsureContentLayerForMainThreadPainting();
+
+  CGFloat BackingScaleFactor() const;
   void BackingScaleFactorChanged();
   double GetDefaultScaleInternal() override;
   int32_t RoundsWidgetCoordinatesTo() override;
 
+  // Mac specific methods
+  void WillPaintWindow();
+  bool PaintWindow(LayoutDeviceIntRegion aRegion);
+  bool PaintWindowInDrawTarget(mozilla::gfx::DrawTarget* aDT,
+                               const LayoutDeviceIntRegion& aRegion,
+                               const mozilla::gfx::IntSize& aSurfaceSize);
+
+  void PaintWindowInContentLayer();
+  void HandleMainThreadCATransaction();
+
+#ifdef ACCESSIBILITY
+  already_AddRefed<mozilla::a11y::LocalAccessible> GetDocumentAccessible();
+#endif
+
+  bool WidgetPaintsBackground() override { return true; }
+
+  bool PreRender(mozilla::widget::WidgetRenderingContext* aContext) override;
+  void PostRender(mozilla::widget::WidgetRenderingContext* aContext) override;
+  RefPtr<mozilla::layers::NativeLayerRoot> GetNativeLayerRoot() override;
+
+  void UpdateWindowDraggingRegion(
+      const LayoutDeviceIntRegion& aRegion) override;
+  LayoutDeviceIntRegion GetNonDraggableRegion() {
+    return mNonDraggableRegion.Region();
+  }
+
+  void LookUpDictionary(const nsAString& aText,
+                        const nsTArray<mozilla::FontRange>& aFontRangeArray,
+                        const bool aIsVertical,
+                        const LayoutDeviceIntPoint& aPoint) override;
+
   mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScale() final {
     return mozilla::DesktopToLayoutDeviceScale(BackingScaleFactor());
   }
@@ -265,12 +409,20 @@
   nsresult SetTitle(const nsAString& aTitle) override;
 
   void Invalidate(const LayoutDeviceIntRect& aRect) override;
-  WindowRenderer* GetWindowRenderer() override;
   nsresult DispatchEvent(mozilla::WidgetGUIEvent* aEvent,
                          nsEventStatus& aStatus) override;
   void CaptureRollupEvents(bool aDoCapture) override;
   [[nodiscard]] nsresult GetAttention(int32_t aCycleCount) override;
   bool HasPendingInputEvent() override;
+  bool SendEventToNativeMenuSystem(NSEvent* aEvent);
+  void PostHandleKeyEvent(mozilla::WidgetKeyboardEvent* aEvent) override;
+  nsresult ActivateNativeMenuItemAt(const nsAString& indexString) override;
+  nsresult ForceUpdateNativeMenuAt(const nsAString& indexString) override;
+  [[nodiscard]] nsresult GetSelectionAsPlaintext(nsAString& aResult) override;
+  TextEventDispatcherListener* GetNativeTextEventDispatcherListener() override;
+  [[nodiscard]] nsresult AttachNativeKeyEvent(
+      mozilla::WidgetKeyboardEvent& aEvent) override;
+
   TransparencyMode GetTransparencyMode() override;
   void SetTransparencyMode(TransparencyMode aMode) override;
   void SetWindowShadowStyle(mozilla::WindowShadow aStyle) override;
@@ -286,15 +438,6 @@
   void SetCustomTitlebar(bool) override;
   void UpdateThemeGeometries(
       const nsTArray<ThemeGeometry>& aThemeGeometries) override;
-  nsresult SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
-                                      NativeMouseMessage aNativeMessage,
-                                      mozilla::MouseButton aButton,
-                                      nsIWidget::Modifiers aModifierFlags,
-                                      nsIObserver* aObserver) override;
-  nsresult SynthesizeNativeMouseScrollEvent(
-      LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage, double aDeltaX,
-      double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
-      uint32_t aAdditionalFlags, nsIObserver* aObserver) override;
   void LockAspectRatio(bool aShouldLock) override;
 
   void DispatchSizeModeEvent();
@@ -314,7 +457,7 @@
 
   void SetInputContext(const InputContext& aContext,
                        const InputContextAction& aAction) override;
-  InputContext GetInputContext() override { return mInputContext; }
+  InputContext GetInputContext() override;
   MOZ_CAN_RUN_SCRIPT bool GetEditCommands(
       mozilla::NativeKeyBindingsType aType,
       const mozilla::WidgetKeyboardEvent& aEvent,
@@ -324,14 +467,6 @@
 
   bool InFullScreenMode() const { return mInFullScreenMode; }
 
-  void PauseOrResumeCompositor(bool aPause) override;
-
-  bool AsyncPanZoomEnabled() const override;
-
-  bool StartAsyncAutoscroll(const ScreenPoint& aAnchorLocation,
-                            const ScrollableLayerGuid& aGuid) override;
-  void StopAsyncAutoscroll(const ScrollableLayerGuid& aGuid) override;
-
   // Class method versions of NSWindow/Delegate callbacks which need to
   // access object state.
   void CocoaWindowWillEnterFullscreen(bool aFullscreen);
@@ -362,7 +497,6 @@
 
   nsresult CreateNativeWindow(const NSRect& aRect, BorderStyle aBorderStyle,
                               bool aRectIsFrameRect, bool aIsPrivateBrowsing);
-  nsresult CreatePopupContentView(const LayoutDeviceIntRect& aRect, InitData*);
   void DestroyNativeWindow();
   void UpdateBounds();
   int32_t GetWorkspaceID();
@@ -384,17 +518,48 @@
   // to ensure that macOS run loops which reference the window will still
   // have something to point to even if they don't use proper retain and
   // release patterns.
-  WindowDelegate*
-      mDelegate;  // our delegate for processing window msgs [STRONG]
+  WindowDelegate* mDelegate =
+      nullptr;  // our delegate for processing window msgs [STRONG]
   RefPtr<nsMenuBarX> mMenuBar;
-  nsChildView*
-      mPopupContentView;  // if this is a popup, this is its content widget
+  ChildView* mChildView = nullptr;  // Cocoa content view, [STRONG]
+#ifdef ACCESSIBILITY
+  // weak ref to this childview's associated mozAccessible for speed reasons
+  // (we get queried for it *a lot* but don't want to own it)
+  nsWeakPtr mAccessible;
+#endif
+  // Held while the compositor (or WR renderer) thread is compositing.
+  // Protects from tearing down the view during compositing and from presenting
+  // half-composited layers to the screen.
+  mozilla::Mutex mCompositingLock MOZ_UNANNOTATED{"ChildViewCompositing"};
+
+  mozilla::ViewRegion mNonDraggableRegion;
+
+  // Cached value of [mChildView backingScaleFactor], to avoid sending two obj-c
+  // messages (respondsToSelector, backingScaleFactor) every time we need to
+  // use it.
+  // ** We'll need to reinitialize this if the backing resolution changes. **
+  mutable CGFloat mBackingScaleFactor;
+
+  RefPtr<mozilla::layers::NativeLayerRootCA> mNativeLayerRoot;
+
+  // In BasicLayers mode, this is the CoreAnimation layer that contains the
+  // rendering from Gecko. It is a sublayer of mNativeLayerRoot's underlying
+  // wrapper layer.
+  // Lazily created by EnsureContentLayerForMainThreadPainting().
+  RefPtr<mozilla::layers::NativeLayerCA> mContentLayer;
+  RefPtr<mozilla::layers::SurfacePoolHandle> mPoolHandle;
+
+  // In BasicLayers mode, this is the invalid region of mContentLayer.
+  LayoutDeviceIntRegion mContentLayerInvalidRegion;
+
+  mozilla::UniquePtr<mozilla::VibrancyManager> mVibrancyManager;
+
+  RefPtr<mozilla::CancelableRunnable> mUnsuspendAsyncCATransactionsRunnable;
+
   // if this is a toplevel window, and there is any ongoing fullscreen
   // transition, it is the animation object.
   NSAnimation* mFullscreenTransitionAnimation;
   mozilla::WindowShadow mShadowStyle;
-
-  CGFloat mBackingScaleFactor;
   CGFloat mAspectRatio;
 
   WindowAnimationType mAnimationType;
@@ -410,6 +575,12 @@
   mozilla::Maybe<TransitionType> mTransitionCurrent;
   std::queue<TransitionType> mTransitionsPending;
 
+  static uint32_t sLastInputEventCount;
+
+  // This is used by SynthesizeNativeTouchPoint to maintain state between
+  // multiple synthesized points
+  mozilla::UniquePtr<mozilla::MultiTouchInput> mSynthesizedTouchInput;
+
   // A runnable we might assign to run ProcessTransitions at a later event loop.
   // Cancelable so we can cancel it in CancelAllTransitions(), if needed.
   RefPtr<mozilla::CancelableRunnable> mProcessTransitionsPending;
@@ -469,6 +640,7 @@
   // is a no-op.
   int32_t mDeferredWorkspaceID = 0;
 
+  RefPtr<mozilla::widget::TextInputHandler> mTextInputHandler;
   InputContext mInputContext;
   NSWindowAnimationBehavior mWindowAnimationBehavior;
 