# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: widget/cocoa/nsCocoaWindow.mm
# Commit: d7eb09faae1c
# Full Hash: d7eb09faae1c39fe5ba7039c0c14b9ee13fe6f48
# Author: Emilio Cobos √Ålvarez <emilio@crisal.io>
# Date: 2025-04-29 20:49:47
# Regressor Bug: 1919165
# File Overlap Count: 1
# Description:
#   Bug 1919165 - Get rid of nsChildView. r=mac-reviewers,mstange
#   
#   In a follow-up I want to merge nsChildView.mm into nsCocoaWindow.mm, but
#   I thought I'd send this for feedback.
#   
# ==============================================================================

diff -r 1eeb386120ff -r d7eb09faae1c widget/cocoa/nsCocoaWindow.mm
--- a/widget/cocoa/nsCocoaWindow.mm	Tue Apr 29 13:50:20 2025 +0000
+++ b/widget/cocoa/nsCocoaWindow.mm	Tue Apr 29 13:51:02 2025 +0000
@@ -6,6 +6,10 @@
 
 #include "nsCocoaWindow.h"
 
+#include "mozilla/layers/NativeLayerCA.h"
+#include "mozilla/TextEventDispatcher.h"
+#include "mozilla/layers/SurfacePool.h"
+#include "mozilla/layers/IAPZCTreeManager.h"
 #include "NativeKeyBindings.h"
 #include "ScreenHelperCocoa.h"
 #include "TextInputHandler.h"
@@ -20,6 +24,7 @@
 #include "nsIAppShellService.h"
 #include "nsIBaseWindow.h"
 #include "nsIInterfaceRequestorUtils.h"
+#include "mozilla/layers/IAPZCTreeManager.h"
 #include "nsIAppWindow.h"
 #include "nsToolkit.h"
 #include "nsPIDOMWindow.h"
@@ -119,14 +124,17 @@
   rollupListener->Rollup(options);
 }
 
+// TODO: Actually move the file contents or something.
+#include "nsChildView.mm"
+
 nsCocoaWindow::nsCocoaWindow()
     : mWindow(nil),
       mClosedRetainedWindow(nil),
       mDelegate(nil),
-      mPopupContentView(nil),
+      mChildView(nil),
+      mBackingScaleFactor(0.0),
       mFullscreenTransitionAnimation(nil),
       mShadowStyle(WindowShadow::None),
-      mBackingScaleFactor(0.0),
       mAnimationType(nsIWidget::eGenericWindowAnimation),
       mWindowMadeHere(false),
       mSizeMode(nsSizeMode_Normal),
@@ -196,7 +204,22 @@
 
   [mClosedRetainedWindow release];
 
-  NS_IF_RELEASE(mPopupContentView);
+  if (mContentLayer) {
+    mNativeLayerRoot->RemoveLayer(mContentLayer);  // safe if already removed
+  }
+
+  DestroyCompositor();
+
+  // An nsCocoaWindow object that was in use can be destroyed without Destroy()
+  // ever being called on it.  So we also need to do a quick, safe cleanup
+  // here (it's too late to just call Destroy(), which can cause crashes).
+  // It's particularly important to make sure widgetDestroyed is called on our
+  // mView -- this method NULLs mView's mGeckoChild, and NULL checks on
+  // mGeckoChild are used throughout the ChildView class to tell if it's safe
+  // to use a ChildView object.
+  [mChildView widgetDestroyed];  // Safe if mView is nil.
+  ClearParent();
+  TearDownView();  // Safe if called twice.
   NS_OBJC_END_TRY_IGNORE_BLOCK;
 }
 
@@ -280,16 +303,28 @@
                          mBorderStyle, false, aInitData->mIsPrivate);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (mWindowType == WindowType::Popup) {
-    // now we can convert widgetRect to device pixels for the window we created,
-    // as the child view expects a rect expressed in the dev pix of its parent
-    LayoutDeviceIntRect devRect =
-        RoundedToInt(aRect * GetDesktopToDeviceScale());
-    return CreatePopupContentView(devRect, aInitData);
-  }
-
   mIsAnimationSuppressed = aInitData->mIsAnimationSuppressed;
 
+  // create our content NSView and hook it up to our parent. Recall that
+  // NS_NATIVE_WIDGET is the NSView.
+  NSView* contentView = mWindow.contentView;
+  mChildView = [[ChildView alloc]
+      initWithFrame:mWindow.childViewFrameRectForCurrentBounds
+         geckoChild:this];
+  mChildView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
+  [contentView addSubview:mChildView];
+
+  mNativeLayerRoot =
+      NativeLayerRootCA::CreateForCALayer(mChildView.rootCALayer);
+  mNativeLayerRoot->SetBackingScale(BackingScaleFactor());
+
+  [WindowDataMap.sharedWindowDataMap ensureDataForWindow:mWindow];
+
+  NS_ASSERTION(!mTextInputHandler, "mTextInputHandler has already existed");
+  mTextInputHandler = new TextInputHandler(this, mChildView);
+
+  [mWindow makeFirstResponder:mChildView];
+
   return NS_OK;
 
   NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
@@ -503,40 +538,14 @@
   NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
 }
 
-nsresult nsCocoaWindow::CreatePopupContentView(const LayoutDeviceIntRect& aRect,
-                                               widget::InitData* aInitData) {
-  NS_OBJC_BEGIN_TRY_BLOCK_RETURN;
-
-  // We need to make our content view a ChildView.
-  mPopupContentView = new nsChildView();
-  if (!mPopupContentView) return NS_ERROR_FAILURE;
-
-  NS_ADDREF(mPopupContentView);
-
-  nsIWidget* thisAsWidget = static_cast<nsIWidget*>(this);
-  nsresult rv = mPopupContentView->Create(thisAsWidget, aRect, aInitData);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  NSView* contentView = mWindow.contentView;
-  auto* childView = static_cast<ChildView*>(
-      mPopupContentView->GetNativeData(NS_NATIVE_WIDGET));
-  childView.frame = contentView.bounds;
-  childView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
-  [contentView addSubview:childView];
-
-  return NS_OK;
-
-  NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
-}
-
 void nsCocoaWindow::Destroy() {
   if (mOnDestroyCalled) {
     return;
   }
   mOnDestroyCalled = true;
 
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+
   // Deal with the possiblity that we're being destroyed while running modal.
   if (mModal) {
     SetModal(false);
@@ -546,10 +555,14 @@
   // (Bug 891424)
   Show(false);
 
-  if (mPopupContentView) {
-    mPopupContentView->Destroy();
+  {
+    // Make sure that no composition is in progress while disconnecting
+    // ourselves from the view.
+    MutexAutoLock lock(mCompositingLock);
+    [mChildView widgetDestroyed];
   }
 
+  TearDownView();  // Safe if called twice.
   if (mFullscreenTransitionAnimation) {
     [mFullscreenTransitionAnimation stopAnimation];
     ReleaseFullscreenTransitionAnimation();
@@ -569,8 +582,6 @@
     DestroyNativeWindow();
   }
 
-  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
-
   nsBaseWidget::OnDestroy();
   nsBaseWidget::Destroy();
 }
@@ -584,7 +595,7 @@
     // to emulate how windows works, we always have to return a NSView
     // for NS_NATIVE_WIDGET
     case NS_NATIVE_WIDGET:
-      retVal = mWindow.contentView;
+      retVal = mChildView;
       break;
 
     case NS_NATIVE_WINDOW:
@@ -596,23 +607,23 @@
       // and it doesn't matter so just return nullptr.
       NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a top-level window!");
       break;
-    case NS_RAW_NATIVE_IME_CONTEXT: {
+    case NS_RAW_NATIVE_IME_CONTEXT:
       retVal = GetPseudoIMEContext();
       if (retVal) {
         break;
       }
-      NSView* view = mWindow ? mWindow.contentView : nil;
-      if (view) {
-        retVal = view.inputContext;
-      }
-      // If inputContext isn't available on this window, return this window's
-      // pointer instead of nullptr since if this returns nullptr,
-      // IMEStateManager cannot manage composition with TextComposition
-      // instance.  Although, this case shouldn't occur.
+      retVal = [mChildView inputContext];
+      // If input context isn't available on this widget, we should set |this|
+      // instead of nullptr since if this returns nullptr, IMEStateManager
+      // cannot manage composition with TextComposition instance.  Although,
+      // this case shouldn't occur.
       if (NS_WARN_IF(!retVal)) {
         retVal = this;
       }
       break;
+    case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID: {
+      retVal = (void*)mWindow.windowNumber;
+      break;
     }
   }
 
@@ -737,11 +748,6 @@
       }
     }
 
-    if (mPopupContentView) {
-      // Ensure our content view is visible. We never need to hide it.
-      mPopupContentView->Show(true);
-    }
-
     // We're about to show a window. If we are opening the new window while the
     // user is in a fullscreen space, for example because the new window is
     // opened from an existing fullscreen window, then macOS will open the new
@@ -871,11 +877,25 @@
          NSScreen.screens.count > 1;
 }
 
-WindowRenderer* nsCocoaWindow::GetWindowRenderer() {
-  if (mPopupContentView) {
-    return mPopupContentView->GetWindowRenderer();
+bool nsCocoaWindow::ShouldUseOffMainThreadCompositing() {
+  // We need to enable OMTC in popups which contain remote layer
+  // trees, since the remote content won't be rendered at all otherwise.
+  if (HasRemoteContent()) {
+    return true;
   }
-  return nullptr;
+
+  // Don't use OMTC for popup windows, because we do not want context menus to
+  // pay the overhead of starting up a compositor. With the OpenGL compositor,
+  // new windows are expensive because of shader re-compilation, and with
+  // WebRender, new windows are expensive because they create their own threads
+  // and texture caches.
+  // Using OMTC with BasicCompositor for context menus would probably be fine
+  // but isn't a well-tested configuration.
+  if (mWindowType == WindowType::Popup) {
+    // Use main-thread BasicLayerManager for drawing menus.
+    return false;
+  }
+  return nsBaseWidget::ShouldUseOffMainThreadCompositing();
 }
 
 TransparencyMode nsCocoaWindow::GetTransparencyMode() {
@@ -1471,11 +1491,8 @@
 
   DispatchSizeModeEvent();
 
-  // Notify the mainChildView with our new fullscreen state.
-  nsChildView* mainChildView =
-      static_cast<nsChildView*>([[mWindow mainChildView] widget]);
-  if (mainChildView) {
-    mainChildView->UpdateFullscreen(aFullScreen);
+  if (mNativeLayerRoot) {
+    mNativeLayerRoot->SetWindowIsFullscreen(aFullScreen);
   }
 }
 
@@ -1852,7 +1869,6 @@
   if (!mWindow) {
     return NSZeroRect;
   }
-
   return [mWindow childViewRectForFrameRect:mWindow.frame];
 }
 
@@ -1867,16 +1883,9 @@
 }
 
 void nsCocoaWindow::UpdateBounds() {
-  NSRect frame = NSZeroRect;
-  if (mWindow) {
-    frame = mWindow.frame;
-  }
+  NSRect frame = mWindow ? mWindow.frame : NSZeroRect;
   mBounds =
       nsCocoaUtils::CocoaRectToGeckoRectDevPix(frame, BackingScaleFactor());
-
-  if (mPopupContentView) {
-    mPopupContentView->UpdateBoundsFromView();
-  }
 }
 
 LayoutDeviceIntRect nsCocoaWindow::GetScreenBounds() {
@@ -1938,7 +1947,7 @@
   return nsCocoaUtils::GetBackingScaleFactor(screen);
 }
 
-CGFloat nsCocoaWindow::BackingScaleFactor() {
+CGFloat nsCocoaWindow::BackingScaleFactor() const {
   if (mBackingScaleFactor > 0.0) {
     return mBackingScaleFactor;
   }
@@ -1957,7 +1966,11 @@
     return;
   }
 
+  SuspendAsyncCATransactions();
   mBackingScaleFactor = newScale;
+  if (mNativeLayerRoot) {
+    mNativeLayerRoot->SetBackingScale(newScale);
+  }
   NotifyAPZOfDPIChange();
 
   if (!mWidgetListener || mWidgetListener->GetAppWindow()) {
@@ -1976,12 +1989,6 @@
   return 1;
 }
 
-void nsCocoaWindow::SetCursor(const Cursor& aCursor) {
-  if (mPopupContentView) {
-    mPopupContentView->SetCursor(aCursor);
-  }
-}
-
 nsresult nsCocoaWindow::SetTitle(const nsAString& aTitle) {
   NS_OBJC_BEGIN_TRY_BLOCK_RETURN;
 
@@ -2007,12 +2014,6 @@
   NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
 }
 
-void nsCocoaWindow::Invalidate(const LayoutDeviceIntRect& aRect) {
-  if (mPopupContentView) {
-    mPopupContentView->Invalidate(aRect);
-  }
-}
-
 // Pass notification of some drag event to Gecko
 //
 // The drag manager has let us know that something related to a drag has
@@ -2029,12 +2030,23 @@
 // Invokes callback and ProcessEvent methods on Event Listener object
 nsresult nsCocoaWindow::DispatchEvent(WidgetGUIEvent* event,
                                       nsEventStatus& aStatus) {
+  RefPtr kungFuDeathGrip{this};
   aStatus = nsEventStatus_eIgnore;
 
-  nsCOMPtr<nsIWidget> kungFuDeathGrip(event->mWidget);
-  mozilla::Unused << kungFuDeathGrip;  // Not used within this function
-
-  if (mWidgetListener) {
+  if (event->mFlags.mIsSynthesizedForTests) {
+    if (WidgetKeyboardEvent* keyEvent = event->AsKeyboardEvent()) {
+      nsresult rv = mTextInputHandler->AttachNativeKeyEvent(*keyEvent);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  // Top level windows can have a view attached which requires events be sent
+  // to the underlying base window and the view. Added when we combined the
+  // base chrome window with the main content child for custom titlebar
+  // rendering.
+  if (mAttachedWidgetListener) {
+    aStatus = mAttachedWidgetListener->HandleEvent(event, mUseAttachedEvents);
+  } else if (mWidgetListener) {
     aStatus = mWidgetListener->HandleEvent(event, mUseAttachedEvents);
   }
 
@@ -2138,11 +2150,14 @@
   NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
 
   UpdateBounds();
+  LayoutDeviceIntRect innerBounds = GetClientBounds();
   if (mWidgetListener) {
-    LayoutDeviceIntRect innerBounds = GetClientBounds();
     mWidgetListener->WindowResized(this, innerBounds.width, innerBounds.height);
   }
-
+  if (mAttachedWidgetListener) {
+    mAttachedWidgetListener->WindowResized(this, innerBounds.width,
+                                           innerBounds.height);
+  }
   NS_OBJC_END_TRY_IGNORE_BLOCK;
 }
 
@@ -2169,10 +2184,6 @@
                              mozilla::dom::CallerType aCallerType) {
   if (!mWindow) return;
 
-  if (mPopupContentView) {
-    return mPopupContentView->SetFocus(aRaise, aCallerType);
-  }
-
   if (aRaise == Raise::Yes && (mWindow.isVisible || mWindow.isMiniaturized)) {
     if (mWindow.isMiniaturized) {
       [mWindow deminiaturize:nil];
@@ -2274,9 +2285,7 @@
   NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
 }
 
-bool nsCocoaWindow::HasPendingInputEvent() {
-  return nsChildView::DoHasPendingInputEvent();
-}
+bool nsCocoaWindow::HasPendingInputEvent() { return DoHasPendingInputEvent(); }
 
 void nsCocoaWindow::SetWindowShadowStyle(WindowShadow aStyle) {
   NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
@@ -2476,43 +2485,6 @@
   NS_OBJC_END_TRY_IGNORE_BLOCK;
 }
 
-NS_IMETHODIMP nsCocoaWindow::SynthesizeNativeMouseEvent(
-    LayoutDeviceIntPoint aPoint, NativeMouseMessage aNativeMessage,
-    MouseButton aButton, nsIWidget::Modifiers aModifierFlags,
-    nsIObserver* aObserver) {
-  NS_OBJC_BEGIN_TRY_BLOCK_RETURN;
-
-  AutoObserverNotifier notifier(aObserver, "mouseevent");
-  if (mPopupContentView) {
-    return mPopupContentView->SynthesizeNativeMouseEvent(
-        aPoint, aNativeMessage, aButton, aModifierFlags, nullptr);
-  }
-
-  return NS_OK;
-
-  NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
-}
-
-NS_IMETHODIMP nsCocoaWindow::SynthesizeNativeMouseScrollEvent(
-    LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage, double aDeltaX,
-    double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
-    uint32_t aAdditionalFlags, nsIObserver* aObserver) {
-  NS_OBJC_BEGIN_TRY_BLOCK_RETURN;
-
-  AutoObserverNotifier notifier(aObserver, "mousescrollevent");
-  if (mPopupContentView) {
-    // Pass nullptr as the observer so that the AutoObserverNotification in
-    // nsChildView::SynthesizeNativeMouseScrollEvent will be ignored.
-    return mPopupContentView->SynthesizeNativeMouseScrollEvent(
-        aPoint, aNativeMessage, aDeltaX, aDeltaY, aDeltaZ, aModifierFlags,
-        aAdditionalFlags, nullptr);
-  }
-
-  return NS_OK;
-
-  NS_OBJC_END_TRY_BLOCK_RETURN(NS_ERROR_FAILURE);
-}
-
 void nsCocoaWindow::LockAspectRatio(bool aShouldLock) {
   NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
 
@@ -2532,17 +2504,6 @@
   NS_OBJC_END_TRY_IGNORE_BLOCK;
 }
 
-void nsCocoaWindow::UpdateThemeGeometries(
-    const nsTArray<ThemeGeometry>& aThemeGeometries) {
-  NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
-
-  if (mPopupContentView) {
-    return mPopupContentView->UpdateThemeGeometries(aThemeGeometries);
-  }
-
-  NS_OBJC_END_TRY_IGNORE_BLOCK;
-}
-
 void nsCocoaWindow::SetPopupWindowLevel() {
   if (!mWindow) {
     return;
@@ -2553,15 +2514,6 @@
   mWindow.hidesOnDeactivate = NO;
 }
 
-void nsCocoaWindow::SetInputContext(const InputContext& aContext,
-                                    const InputContextAction& aAction) {
-  NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
-
-  mInputContext = aContext;
-
-  NS_OBJC_END_TRY_IGNORE_BLOCK;
-}
-
 bool nsCocoaWindow::GetEditCommands(NativeKeyBindingsType aType,
                                     const WidgetKeyboardEvent& aEvent,
                                     nsTArray<CommandInt>& aCommands) {
@@ -2570,44 +2522,16 @@
     return false;
   }
 
-  NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
-  // When the keyboard event is fired from this widget, it must mean that no web
-  // content has focus because any web contents should be on `nsChildView`.  And
-  // in any locales, the system UI is always horizontal layout.  So, let's pass
-  // `Nothing()` for the writing mode here, it won't be treated as in a vertical
-  // content.
-  keyBindings->GetEditCommands(aEvent, Nothing(), aCommands);
-  return true;
-}
-
-void nsCocoaWindow::PauseOrResumeCompositor(bool aPause) {
-  if (auto* mainChildView =
-          static_cast<nsIWidget*>(mWindow.mainChildView.widget)) {
-    mainChildView->PauseOrResumeCompositor(aPause);
+  Maybe<WritingMode> writingMode;
+  if (aEvent.NeedsToRemapNavigationKey()) {
+    if (RefPtr<TextEventDispatcher> dispatcher = GetTextEventDispatcher()) {
+      writingMode = dispatcher->MaybeQueryWritingModeAtSelection();
+    }
   }
-}
-
-bool nsCocoaWindow::AsyncPanZoomEnabled() const {
-  if (mPopupContentView) {
-    return mPopupContentView->AsyncPanZoomEnabled();
-  }
-  return nsBaseWidget::AsyncPanZoomEnabled();
-}
-
-bool nsCocoaWindow::StartAsyncAutoscroll(const ScreenPoint& aAnchorLocation,
-                                         const ScrollableLayerGuid& aGuid) {
-  if (mPopupContentView) {
-    return mPopupContentView->StartAsyncAutoscroll(aAnchorLocation, aGuid);
-  }
-  return nsBaseWidget::StartAsyncAutoscroll(aAnchorLocation, aGuid);
-}
-
-void nsCocoaWindow::StopAsyncAutoscroll(const ScrollableLayerGuid& aGuid) {
-  if (mPopupContentView) {
-    mPopupContentView->StopAsyncAutoscroll(aGuid);
-    return;
-  }
-  nsBaseWidget::StopAsyncAutoscroll(aGuid);
+
+  NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+  keyBindings->GetEditCommands(aEvent, writingMode, aCommands);
+  return true;
 }
 
 already_AddRefed<nsIWidget> nsIWidget::CreateTopLevelWindow() {
@@ -2616,7 +2540,7 @@
 }
 
 already_AddRefed<nsIWidget> nsIWidget::CreateChildWindow() {
-  nsCOMPtr<nsIWidget> window = new nsChildView();
+  nsCOMPtr<nsIWidget> window = new nsCocoaWindow();
   return window.forget();
 }
 
@@ -2905,15 +2829,13 @@
   RollUpPopups();
   ChildViewMouseTracker::ReEvaluateMouseEnterState();
 
-  NSWindow* window = [aNotification object];
-  auto* mainChildView =
-      static_cast<nsChildView*>([[(BaseWindow*)window mainChildView] widget]);
-  if (mainChildView) {
-    if (mainChildView->GetInputContext().IsPasswordEditor()) {
-      TextInputHandler::EnableSecureEventInput();
-    } else {
-      TextInputHandler::EnsureSecureEventInputDisabled();
-    }
+  if (!mGeckoWindow) {
+    return;
+  }
+  if (mGeckoWindow->GetInputContext().IsPasswordEditor()) {
+    TextInputHandler::EnableSecureEventInput();
+  } else {
+    TextInputHandler::EnsureSecureEventInputDisabled();
   }
 
   NS_OBJC_END_TRY_IGNORE_BLOCK;
@@ -3316,6 +3238,15 @@
   return [NSWindow contentRectForFrameRect:aFrameRect styleMask:styleMask];
 }
 
+// relative to the window frame rect, with the origin in the bottom left.
+- (NSRect)childViewFrameRectForCurrentBounds {
+  auto frame = self.frame;
+  NSRect r = [self childViewRectForFrameRect:frame];
+  r.origin.x -= frame.origin.x;
+  r.origin.y -= frame.origin.y;
+  return r;
+}
+
 - (NSRect)frameRectForChildViewRect:(NSRect)aChildViewRect {
   if (mDrawsIntoWindowFrame) {
     return aChildViewRect;
@@ -3733,10 +3664,9 @@
     // Hide the titlebar if we are drawing into it
     self.titlebarAppearsTransparent = self.drawsContentsIntoWindowFrame;
 
-    // Here we extend / shrink our mainChildView. We do that by firing a resize
-    // event which will cause the ChildView to be resized to the rect returned
-    // by nsCocoaWindow::GetClientBounds. GetClientBounds bases its return
-    // value on what we return from drawsContentsIntoWindowFrame.
+    // Here we extend / shrink our mainChildView.
+    self.mainChildView.frame = self.childViewFrameRectForCurrentBounds;
+
     auto* windowDelegate = static_cast<WindowDelegate*>(self.delegate);
     if (nsCocoaWindow* geckoWindow = windowDelegate.geckoWidget) {
       // Re-layout our contents.
