{
  "bug_id": "1988694",
  "status": "matched",
  "stack_source": "step2_socorro",
  "bugzilla_url": "https://bugzilla.mozilla.org/show_bug.cgi?id=1988694",
  "summary": "Crash in [@ mozilla::Maybe<T>::operator-> | js::ArrayBufferObject::maxByteLengthGetterImpl]",
  "regressor_info": [
    {
      "filepath": "js/src/jit-test/lib/wasm.js",
      "filename": "wasm.js",
      "commit_hash": "75d829afb4b0",
      "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "canRunHugeMemoryTests",
          "type": "function",
          "start_line": 6,
          "end_line": 28,
          "line_count": 23,
          "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
        },
        {
          "name": "wasmEvalBinary",
          "type": "function",
          "start_line": 45,
          "end_line": 60,
          "line_count": 16,
          "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
        },
        {
          "name": "wasmEvalText",
          "type": "function",
          "start_line": 62,
          "end_line": 64,
          "line_count": 3,
          "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
        },
        {
          "name": "wasmValidateBinary",
          "type": "function",
          "start_line": 66,
          "end_line": 73,
          "line_count": 8,
          "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
        },
        {
          "name": "wasmFailValidateBinary",
          "type": "function",
          "start_line": 75,
          "end_line": 78,
          "line_count": 4,
          "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
        },
        {
          "name": "wasmValidateText",
          "type": "function",
          "start_line": 80,
          "end_line": 82,
          "line_count": 3,
          "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
        },
        {
          "name": "wasmFailValidateText",
          "type": "function",
          "start_line": 84,
          "end_line": 86,
          "line_count": 3,
          "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
        },
        {
          "name": "wasmCompilationShouldFail",
          "type": "function",
          "start_line": 98,
          "end_line": 110,
          "line_count": 13,
          "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
        },
        {
          "name": "mismatchError",
          "type": "function",
          "start_line": 112,
          "end_line": 116,
          "line_count": 5,
          "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
        },
        {
          "name": "jsify",
          "type": "function",
          "start_line": 121,
          "end_line": 131,
          "line_count": 11,
          "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
        },
        {
          "name": "_augmentSrc",
          "type": "function",
          "start_line": 133,
          "end_line": 198,
          "line_count": 66,
          "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
        },
        {
          "name": "wasmAssert",
          "type": "function",
          "start_line": 200,
          "end_line": 210,
          "line_count": 11,
          "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
        },
        {
          "name": "wasmFullPass",
          "type": "function",
          "start_line": 218,
          "end_line": 226,
          "line_count": 9,
          "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmFullPassI64",
          "type": "function",
          "start_line": 229,
          "end_line": 239,
          "line_count": 11,
          "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmRunWithDebugger",
          "type": "function",
          "start_line": 241,
          "end_line": 260,
          "line_count": 20,
          "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
        },
        {
          "name": "fuzzingSafe",
          "type": "function",
          "start_line": 427,
          "end_line": 429,
          "line_count": 3,
          "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
        },
        {
          "name": "iota",
          "type": "function",
          "start_line": 531,
          "end_line": 536,
          "line_count": 6,
          "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
        },
        {
          "name": "cross",
          "type": "function",
          "start_line": 540,
          "end_line": 546,
          "line_count": 7,
          "signature": "function cross(xs) { let results = []; for ( let x of xs )"
        },
        {
          "name": "remove",
          "type": "function",
          "start_line": 549,
          "end_line": 557,
          "line_count": 9,
          "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
        },
        {
          "name": "permute",
          "type": "function",
          "start_line": 562,
          "end_line": 570,
          "line_count": 9,
          "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
        },
        {
          "name": "interleave",
          "type": "function",
          "start_line": 573,
          "end_line": 581,
          "line_count": 9,
          "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
        },
        {
          "name": "assertSame",
          "type": "function",
          "start_line": 586,
          "end_line": 599,
          "line_count": 14,
          "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
        },
        {
          "name": "assertEqResults",
          "type": "function",
          "start_line": 606,
          "end_line": 614,
          "line_count": 9,
          "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
        }
      ],
      "method_names": [
        "canRunHugeMemoryTests",
        "wasmEvalBinary",
        "wasmEvalText",
        "wasmValidateBinary",
        "wasmFailValidateBinary",
        "wasmValidateText",
        "wasmFailValidateText",
        "wasmCompilationShouldFail",
        "mismatchError",
        "jsify",
        "_augmentSrc",
        "wasmAssert",
        "wasmFullPass",
        "wasmFullPassI64",
        "wasmRunWithDebugger",
        "fuzzingSafe",
        "iota",
        "cross",
        "remove",
        "permute",
        "interleave",
        "assertSame",
        "assertEqResults"
      ],
      "method_count": 23
    },
    {
      "filepath": "js/src/jit-test/lib/wasm.js",
      "filename": "wasm.js",
      "commit_hash": "13b7086f65cb",
      "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "canRunHugeMemoryTests",
          "type": "function",
          "start_line": 6,
          "end_line": 28,
          "line_count": 23,
          "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
        },
        {
          "name": "wasmEvalBinary",
          "type": "function",
          "start_line": 45,
          "end_line": 60,
          "line_count": 16,
          "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
        },
        {
          "name": "wasmEvalText",
          "type": "function",
          "start_line": 62,
          "end_line": 64,
          "line_count": 3,
          "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
        },
        {
          "name": "wasmValidateBinary",
          "type": "function",
          "start_line": 66,
          "end_line": 73,
          "line_count": 8,
          "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
        },
        {
          "name": "wasmFailValidateBinary",
          "type": "function",
          "start_line": 75,
          "end_line": 78,
          "line_count": 4,
          "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
        },
        {
          "name": "wasmValidateText",
          "type": "function",
          "start_line": 80,
          "end_line": 82,
          "line_count": 3,
          "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
        },
        {
          "name": "wasmFailValidateText",
          "type": "function",
          "start_line": 84,
          "end_line": 86,
          "line_count": 3,
          "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
        },
        {
          "name": "wasmCompilationShouldFail",
          "type": "function",
          "start_line": 98,
          "end_line": 110,
          "line_count": 13,
          "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
        },
        {
          "name": "mismatchError",
          "type": "function",
          "start_line": 112,
          "end_line": 116,
          "line_count": 5,
          "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
        },
        {
          "name": "jsify",
          "type": "function",
          "start_line": 121,
          "end_line": 131,
          "line_count": 11,
          "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
        },
        {
          "name": "_augmentSrc",
          "type": "function",
          "start_line": 133,
          "end_line": 198,
          "line_count": 66,
          "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
        },
        {
          "name": "wasmAssert",
          "type": "function",
          "start_line": 200,
          "end_line": 210,
          "line_count": 11,
          "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
        },
        {
          "name": "wasmFullPass",
          "type": "function",
          "start_line": 218,
          "end_line": 226,
          "line_count": 9,
          "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmFullPassI64",
          "type": "function",
          "start_line": 229,
          "end_line": 239,
          "line_count": 11,
          "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmRunWithDebugger",
          "type": "function",
          "start_line": 241,
          "end_line": 260,
          "line_count": 20,
          "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
        },
        {
          "name": "fuzzingSafe",
          "type": "function",
          "start_line": 427,
          "end_line": 429,
          "line_count": 3,
          "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
        },
        {
          "name": "iota",
          "type": "function",
          "start_line": 525,
          "end_line": 530,
          "line_count": 6,
          "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
        },
        {
          "name": "cross",
          "type": "function",
          "start_line": 534,
          "end_line": 540,
          "line_count": 7,
          "signature": "function cross(xs) { let results = []; for ( let x of xs )"
        },
        {
          "name": "remove",
          "type": "function",
          "start_line": 543,
          "end_line": 551,
          "line_count": 9,
          "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
        },
        {
          "name": "permute",
          "type": "function",
          "start_line": 556,
          "end_line": 564,
          "line_count": 9,
          "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
        },
        {
          "name": "interleave",
          "type": "function",
          "start_line": 567,
          "end_line": 575,
          "line_count": 9,
          "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
        },
        {
          "name": "assertSame",
          "type": "function",
          "start_line": 580,
          "end_line": 593,
          "line_count": 14,
          "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
        },
        {
          "name": "assertEqResults",
          "type": "function",
          "start_line": 600,
          "end_line": 608,
          "line_count": 9,
          "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
        }
      ],
      "method_names": [
        "canRunHugeMemoryTests",
        "wasmEvalBinary",
        "wasmEvalText",
        "wasmValidateBinary",
        "wasmFailValidateBinary",
        "wasmValidateText",
        "wasmFailValidateText",
        "wasmCompilationShouldFail",
        "mismatchError",
        "jsify",
        "_augmentSrc",
        "wasmAssert",
        "wasmFullPass",
        "wasmFullPassI64",
        "wasmRunWithDebugger",
        "fuzzingSafe",
        "iota",
        "cross",
        "remove",
        "permute",
        "interleave",
        "assertSame",
        "assertEqResults"
      ],
      "method_count": 23
    },
    {
      "filepath": "js/src/jit-test/lib/wasm.js",
      "filename": "wasm.js",
      "commit_hash": "85d47a33200c",
      "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "canRunHugeMemoryTests",
          "type": "function",
          "start_line": 6,
          "end_line": 28,
          "line_count": 23,
          "signature": "function canRunHugeMemoryTests() { // We're aiming for 64-bit desktop builds with no interesting analysis // running that might inflate memory consumption unreasonably.  It's OK if"
        },
        {
          "name": "wasmEvalBinary",
          "type": "function",
          "start_line": 45,
          "end_line": 60,
          "line_count": 16,
          "signature": "function wasmEvalBinary(binary, imports, compileOptions) { let valid = WebAssembly.validate(binary, compileOptions); "
        },
        {
          "name": "wasmEvalText",
          "type": "function",
          "start_line": 62,
          "end_line": 64,
          "line_count": 3,
          "signature": "function wasmEvalText(str, imports, compileOptions) { return wasmEvalBinary(wasmTextToBinary(str), imports, compileOptions); }"
        },
        {
          "name": "wasmValidateBinary",
          "type": "function",
          "start_line": 66,
          "end_line": 73,
          "line_count": 8,
          "signature": "function wasmValidateBinary(binary) { let valid = WebAssembly.validate(binary); if (!valid) {"
        },
        {
          "name": "wasmFailValidateBinary",
          "type": "function",
          "start_line": 75,
          "end_line": 78,
          "line_count": 4,
          "signature": "function wasmFailValidateBinary(binary, pattern) { assertEq(WebAssembly.validate(binary), false, \"module passed WebAssembly.validate when it should not have\"); assertErrorMessage(() => new WebAssembly"
        },
        {
          "name": "wasmValidateText",
          "type": "function",
          "start_line": 80,
          "end_line": 82,
          "line_count": 3,
          "signature": "function wasmValidateText(str) { return wasmValidateBinary(wasmTextToBinary(str)); }"
        },
        {
          "name": "wasmFailValidateText",
          "type": "function",
          "start_line": 84,
          "end_line": 86,
          "line_count": 3,
          "signature": "function wasmFailValidateText(str, pattern) { return wasmFailValidateBinary(wasmTextToBinary(str), pattern); }"
        },
        {
          "name": "wasmCompilationShouldFail",
          "type": "function",
          "start_line": 98,
          "end_line": 110,
          "line_count": 13,
          "signature": "function wasmCompilationShouldFail(bin, compile_error_regex) { try { new WebAssembly.Module(bin);"
        },
        {
          "name": "mismatchError",
          "type": "function",
          "start_line": 112,
          "end_line": 116,
          "line_count": 5,
          "signature": "function mismatchError(actual, expect) { var str = `(type mismatch: expression has type ${actual} but expected ${expect})|` + `(type mismatch: expected ${expect}, found ${actual}\\)`;"
        },
        {
          "name": "jsify",
          "type": "function",
          "start_line": 121,
          "end_line": 131,
          "line_count": 11,
          "signature": "function jsify(wasmVal) { if (wasmVal === 'nan') return NaN;"
        },
        {
          "name": "_augmentSrc",
          "type": "function",
          "start_line": 133,
          "end_line": 198,
          "line_count": 66,
          "signature": "function _augmentSrc(src, assertions) { let i = 0; let newSrc = src.substr(0, src.lastIndexOf(')'));"
        },
        {
          "name": "wasmAssert",
          "type": "function",
          "start_line": 200,
          "end_line": 210,
          "line_count": 11,
          "signature": "function wasmAssert(src, assertions, maybeImports = {}, exportBox = null) { let { exports } = wasmEvalText(_augmentSrc(src, assertions), maybeImports); if (exportBox !== null)"
        },
        {
          "name": "wasmFullPass",
          "type": "function",
          "start_line": 218,
          "end_line": 226,
          "line_count": 9,
          "signature": "function wasmFullPass(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmFullPassI64",
          "type": "function",
          "start_line": 229,
          "end_line": 239,
          "line_count": 11,
          "signature": "function wasmFullPassI64(text, expected, maybeImports, ...args) { let binary = wasmTextToBinary(text); assertEq(WebAssembly.validate(binary), true, \"Must validate.\");"
        },
        {
          "name": "wasmRunWithDebugger",
          "type": "function",
          "start_line": 241,
          "end_line": 260,
          "line_count": 20,
          "signature": "function wasmRunWithDebugger(wast, lib, init, done) { let g = newGlobal({newCompartment: true}); let dbg = new Debugger(g);"
        },
        {
          "name": "fuzzingSafe",
          "type": "function",
          "start_line": 427,
          "end_line": 429,
          "line_count": 3,
          "signature": "function fuzzingSafe() { return typeof getErrorNotes == 'undefined'; }"
        },
        {
          "name": "iota",
          "type": "function",
          "start_line": 525,
          "end_line": 530,
          "line_count": 6,
          "signature": "function iota(len, k=0) { let xs = []; for ( let i=0 ; i < len ; i++ )"
        },
        {
          "name": "cross",
          "type": "function",
          "start_line": 534,
          "end_line": 540,
          "line_count": 7,
          "signature": "function cross(xs) { let results = []; for ( let x of xs )"
        },
        {
          "name": "remove",
          "type": "function",
          "start_line": 543,
          "end_line": 551,
          "line_count": 9,
          "signature": "function remove(v, xs) { let result = []; for ( let w of xs ) {"
        },
        {
          "name": "permute",
          "type": "function",
          "start_line": 556,
          "end_line": 564,
          "line_count": 9,
          "signature": "function permute(xs) { if (xs.length == 1) return [xs];"
        },
        {
          "name": "interleave",
          "type": "function",
          "start_line": 567,
          "end_line": 575,
          "line_count": 9,
          "signature": "function interleave(xs, ys) { assertEq(xs.length, ys.length); let res = [];"
        },
        {
          "name": "assertSame",
          "type": "function",
          "start_line": 580,
          "end_line": 593,
          "line_count": 14,
          "signature": "function assertSame(got, expected) { assertEq(got.length, expected.length); for ( let i=0; i < got.length; i++ ) {"
        },
        {
          "name": "assertEqResults",
          "type": "function",
          "start_line": 600,
          "end_line": 608,
          "line_count": 9,
          "signature": "function assertEqResults(got, expected) { if (!Array.isArray(got)) { got = [got];"
        }
      ],
      "method_names": [
        "canRunHugeMemoryTests",
        "wasmEvalBinary",
        "wasmEvalText",
        "wasmValidateBinary",
        "wasmFailValidateBinary",
        "wasmValidateText",
        "wasmFailValidateText",
        "wasmCompilationShouldFail",
        "mismatchError",
        "jsify",
        "_augmentSrc",
        "wasmAssert",
        "wasmFullPass",
        "wasmFullPassI64",
        "wasmRunWithDebugger",
        "fuzzingSafe",
        "iota",
        "cross",
        "remove",
        "permute",
        "interleave",
        "assertSame",
        "assertEqResults"
      ],
      "method_count": 23
    },
    {
      "filepath": "js/src/vm/ArrayBufferObject.cpp",
      "filename": "ArrayBufferObject.cpp",
      "commit_hash": "75d829afb4b0",
      "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmReservedBytes",
          "type": "method",
          "start_line": 160,
          "end_line": 160,
          "line_count": 1,
          "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
        },
        {
          "name": "CheckArrayBufferTooLarge",
          "type": "function",
          "start_line": 162,
          "end_line": 172,
          "line_count": 11,
          "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
        },
        {
          "name": "CommitBufferMemory",
          "type": "method",
          "start_line": 244,
          "end_line": 269,
          "line_count": 26,
          "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
        },
        {
          "name": "UnmapBufferMemory",
          "type": "method",
          "start_line": 271,
          "end_line": 296,
          "line_count": 26,
          "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
        },
        {
          "name": "IsArrayBuffer",
          "type": "function",
          "start_line": 431,
          "end_line": 433,
          "line_count": 3,
          "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
        },
        {
          "name": "IsResizableArrayBuffer",
          "type": "function",
          "start_line": 435,
          "end_line": 437,
          "line_count": 3,
          "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 439,
          "end_line": 445,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 447,
          "end_line": 451,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 543,
          "end_line": 569,
          "line_count": 27,
          "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 576,
          "end_line": 581,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "resizableGetterImpl",
          "type": "method",
          "start_line": 588,
          "end_line": 596,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "resizableGetter",
          "type": "method",
          "start_line": 603,
          "end_line": 608,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "detachedGetterImpl",
          "type": "method",
          "start_line": 615,
          "end_line": 623,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "detachedGetter",
          "type": "method",
          "start_line": 630,
          "end_line": 635,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "immutableGetterImpl",
          "type": "method",
          "start_line": 643,
          "end_line": 651,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "immutableGetter",
          "type": "method",
          "start_line": 658,
          "end_line": 663,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "transferImpl",
          "type": "method",
          "start_line": 671,
          "end_line": 685,
          "line_count": 15,
          "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "transfer",
          "type": "method",
          "start_line": 692,
          "end_line": 695,
          "line_count": 4,
          "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
        },
        {
          "name": "transferToFixedLengthImpl",
          "type": "method",
          "start_line": 702,
          "end_line": 717,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToFixedLength",
          "type": "method",
          "start_line": 724,
          "end_line": 729,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "transferToImmutableImpl",
          "type": "method",
          "start_line": 737,
          "end_line": 752,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToImmutable",
          "type": "method",
          "start_line": 759,
          "end_line": 763,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "resizeImpl",
          "type": "method",
          "start_line": 771,
          "end_line": 833,
          "line_count": 63,
          "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 840,
          "end_line": 844,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsArrayBufferSpecies",
          "type": "function",
          "start_line": 846,
          "end_line": 849,
          "line_count": 4,
          "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinArrayBufferSpecies",
          "type": "function",
          "start_line": 851,
          "end_line": 871,
          "line_count": 21,
          "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 878,
          "end_line": 1024,
          "line_count": 147,
          "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 1031,
          "end_line": 1035,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "sliceToImmutableImpl",
          "type": "method",
          "start_line": 1043,
          "end_line": 1108,
          "line_count": 66,
          "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "sliceToImmutable",
          "type": "method",
          "start_line": 1115,
          "end_line": 1120,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "fun_isView",
          "type": "method",
          "start_line": 1126,
          "end_line": 1131,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 1135,
          "end_line": 1212,
          "line_count": 78,
          "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "AllocateUninitializedArrayBufferContents",
          "type": "function",
          "start_line": 1216,
          "end_line": 1234,
          "line_count": 19,
          "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "AllocateArrayBufferContents",
          "type": "function",
          "start_line": 1236,
          "end_line": 1252,
          "line_count": 17,
          "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "ReallocateArrayBufferContents",
          "type": "function",
          "start_line": 1254,
          "end_line": 1273,
          "line_count": 20,
          "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
        },
        {
          "name": "NewCopiedBufferContents",
          "type": "function",
          "start_line": 1275,
          "end_line": 1285,
          "line_count": 11,
          "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
        },
        {
          "name": "detach",
          "type": "method",
          "start_line": 1288,
          "end_line": 1323,
          "line_count": 36,
          "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 1325,
          "end_line": 1360,
          "line_count": 36,
          "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
        },
        {
          "name": " true;\n}\n\nvoid Was",
          "type": "method",
          "start_line": 1533,
          "end_line": 1554,
          "line_count": 22,
          "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
        },
        {
          "name": " void* ",
          "type": "method",
          "start_line": 1556,
          "end_line": 1599,
          "line_count": 44,
          "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
        },
        {
          "name": "sePoint",
          "type": "method",
          "start_line": 1644,
          "end_line": 1657,
          "line_count": 14,
          "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
        },
        {
          "name": " MALLOCED_UNKNO",
          "type": "method",
          "start_line": 1788,
          "end_line": 1834,
          "line_count": 47,
          "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
        },
        {
          "name": "ect::inlineDataPoint",
          "type": "method",
          "start_line": 1836,
          "end_line": 1841,
          "line_count": 6,
          "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
        },
        {
          "name": "asing.\n      brea",
          "type": "method",
          "start_line": 1859,
          "end_line": 1861,
          "line_count": 3,
          "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
        },
        {
          "name": "ed by, well",
          "type": "method",
          "start_line": 1871,
          "end_line": 1909,
          "line_count": 39,
          "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
        },
        {
          "name": "  if (isMapped",
          "type": "method",
          "start_line": 1911,
          "end_line": 1920,
          "line_count": 10,
          "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
        },
        {
          "name": "MappedSize",
          "type": "method",
          "start_line": 1922,
          "end_line": 1924,
          "line_count": 3,
          "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
        },
        {
          "name": "\nAddressType Ar",
          "type": "method",
          "start_line": 1926,
          "end_line": 1934,
          "line_count": 9,
          "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
        },
        {
          "name": "smPages() con",
          "type": "method",
          "start_line": 1936,
          "end_line": 1939,
          "line_count": 4,
          "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
        },
        {
          "name": "ages ArrayBuff",
          "type": "method",
          "start_line": 1941,
          "end_line": 1946,
          "line_count": 6,
          "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
        },
        {
          "name": "ForAsmJS());\n  ",
          "type": "method",
          "start_line": 1948,
          "end_line": 1954,
          "line_count": 7,
          "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
        },
        {
          "name": "();\n  }\n ",
          "type": "method",
          "start_line": 1956,
          "end_line": 1962,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
        },
        {
          "name": "is<ArrayBufferObjec",
          "type": "method",
          "start_line": 1964,
          "end_line": 1970,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
        },
        {
          "name": "eShared* buf) {\n  ",
          "type": "method",
          "start_line": 1972,
          "end_line": 1978,
          "line_count": 7,
          "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
        },
        {
          "name": "ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1980,
          "end_line": 1985,
          "line_count": 6,
          "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
        },
        {
          "name": " ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1987,
          "end_line": 1993,
          "line_count": 7,
          "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "axPages(\n    const A",
          "type": "method",
          "start_line": 1994,
          "end_line": 1999,
          "line_count": 6,
          "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
        },
        {
          "name": "tatic void CheckStealPrecondit",
          "type": "method",
          "start_line": 2000,
          "end_line": 2006,
          "line_count": 7,
          "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "from an immutable buffer\");\n ",
          "type": "method",
          "start_line": 2007,
          "end_line": 2013,
          "line_count": 7,
          "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "\nArrayBufferObject* Arr",
          "type": "function",
          "start_line": 2015,
          "end_line": 2025,
          "line_count": 11,
          "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
        },
        {
          "name": "turn js::gc",
          "type": "method",
          "start_line": 2161,
          "end_line": 2165,
          "line_count": 5,
          "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
        },
        {
          "name": "lass ",
          "type": "method",
          "start_line": 2167,
          "end_line": 2169,
          "line_count": 3,
          "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
        },
        {
          "name": "to_,\n   ",
          "type": "method",
          "start_line": 2171,
          "end_line": 2173,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
        },
        {
          "name": "Kind::ARRAYBUFFER4 ||\n    ",
          "type": "function",
          "start_line": 2175,
          "end_line": 2186,
          "line_count": 12,
          "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
        },
        {
          "name": "h the object by repurposing fixe",
          "type": "method",
          "start_line": 2371,
          "end_line": 2429,
          "line_count": 59,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
        },
        {
          "name": " metadata, proto);\n",
          "type": "method",
          "start_line": 2432,
          "end_line": 2458,
          "line_count": 27,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
        },
        {
          "name": "e allocating the ma",
          "type": "method",
          "start_line": 2461,
          "end_line": 2493,
          "line_count": 33,
          "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
        },
        {
          "name": "Contents contents = buffer->co",
          "type": "method",
          "start_line": 3026,
          "end_line": 3087,
          "line_count": 62,
          "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
        },
        {
          "name": " != INLINE_DATA",
          "type": "method",
          "start_line": 3090,
          "end_line": 3135,
          "line_count": 46,
          "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
        },
        {
          "name": "mallocSizeOf(buffer.da",
          "type": "method",
          "start_line": 3138,
          "end_line": 3182,
          "line_count": 45,
          "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": ">byteLen",
          "type": "method",
          "start_line": 3185,
          "end_line": 3187,
          "line_count": 3,
          "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
        },
        {
          "name": "        ",
          "type": "method",
          "start_line": 3190,
          "end_line": 3202,
          "line_count": 13,
          "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
        },
        {
          "name": "!nursery.is",
          "type": "method",
          "start_line": 3206,
          "end_line": 3226,
          "line_count": 21,
          "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
        },
        {
          "name": "own) {\n  swi",
          "type": "method",
          "start_line": 3234,
          "end_line": 3236,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
        },
        {
          "name": "rrayBuf",
          "type": "method",
          "start_line": 3238,
          "end_line": 3245,
          "line_count": 8,
          "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
        },
        {
          "name": "\");\n      break;\n ",
          "type": "function",
          "start_line": 3250,
          "end_line": 3281,
          "line_count": 32,
          "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
        },
        {
          "name": " break;\n    }\n  }\n}\n\nv",
          "type": "function",
          "start_line": 3284,
          "end_line": 3302,
          "line_count": 19,
          "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
        },
        {
          "name": "_t value) { j",
          "type": "method",
          "start_line": 3304,
          "end_line": 3327,
          "line_count": 24,
          "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "first = false;\n     ",
          "type": "method",
          "start_line": 3329,
          "end_line": 3364,
          "line_count": 36,
          "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "urseryV",
          "type": "method",
          "start_line": 3443,
          "end_line": 3480,
          "line_count": 38,
          "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
        },
        {
          "name": "ject* buffe",
          "type": "method",
          "start_line": 3491,
          "end_line": 3496,
          "line_count": 6,
          "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
        },
        {
          "name": "fterMinor",
          "type": "method",
          "start_line": 3498,
          "end_line": 3502,
          "line_count": 5,
          "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
        },
        {
          "name": "at every map entr",
          "type": "method",
          "start_line": 3504,
          "end_line": 3531,
          "line_count": 28,
          "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
        },
        {
          "name": "    vectorSize += r.fr",
          "type": "method",
          "start_line": 3533,
          "end_line": 3545,
          "line_count": 13,
          "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
        },
        {
          "name": "ferByteLength(JSObj",
          "type": "method",
          "start_line": 3547,
          "end_line": 3555,
          "line_count": 9,
          "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
        },
        {
          "name": "tatic ArrayBufferObject*",
          "type": "method",
          "start_line": 3562,
          "end_line": 3565,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "ge, nullptr,\n    ",
          "type": "method",
          "start_line": 3595,
          "end_line": 3625,
          "line_count": 31,
          "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
        },
        {
          "name": "fferObject>();\n  if (!aobj) {\n",
          "type": "method",
          "start_line": 3627,
          "end_line": 3638,
          "line_count": 12,
          "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
        },
        {
          "name": "rayBufferWithContents(\n    ",
          "type": "method",
          "start_line": 3640,
          "end_line": 3647,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "                   ",
          "type": "method",
          "start_line": 3747,
          "end_line": 3749,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
        },
        {
          "name": "(obj);\n\n  Rooted<A",
          "type": "method",
          "start_line": 3751,
          "end_line": 3753,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
        },
        {
          "name": "                                ",
          "type": "method",
          "start_line": 3820,
          "end_line": 3823,
          "line_count": 4,
          "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
        },
        {
          "name": "ta = aobj->dataPointer();",
          "type": "method",
          "start_line": 3825,
          "end_line": 3832,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "ffer::ResizableUnsharedClas",
          "type": "method",
          "start_line": 3848,
          "end_line": 3856,
          "line_count": 9,
          "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": ");\n  if (!unwrapped",
          "type": "method",
          "start_line": 3899,
          "end_line": 3949,
          "line_count": 51,
          "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
        }
      ],
      "method_names": [
        "WasmReservedBytes",
        "CheckArrayBufferTooLarge",
        "CommitBufferMemory",
        "UnmapBufferMemory",
        "IsArrayBuffer",
        "IsResizableArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "resizableGetterImpl",
        "resizableGetter",
        "detachedGetterImpl",
        "detachedGetter",
        "immutableGetterImpl",
        "immutableGetter",
        "transferImpl",
        "transfer",
        "transferToFixedLengthImpl",
        "transferToFixedLength",
        "transferToImmutableImpl",
        "transferToImmutable",
        "resizeImpl",
        "resize",
        "IsArrayBufferSpecies",
        "HasBuiltinArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "sliceToImmutableImpl",
        "sliceToImmutable",
        "fun_isView",
        "class_constructor",
        "AllocateUninitializedArrayBufferContents",
        "AllocateArrayBufferContents",
        "ReallocateArrayBufferContents",
        "NewCopiedBufferContents",
        "detach",
        "resize",
        " true;\n}\n\nvoid Was",
        " void* ",
        "sePoint",
        " MALLOCED_UNKNO",
        "ect::inlineDataPoint",
        "asing.\n      brea",
        "ed by, well",
        "  if (isMapped",
        "MappedSize",
        "\nAddressType Ar",
        "smPages() con",
        "ages ArrayBuff",
        "ForAsmJS());\n  ",
        "();\n  }\n ",
        "is<ArrayBufferObjec",
        "eShared* buf) {\n  ",
        "ArrayBufferObjectMaybeSha",
        " ArrayBufferObjectMaybeSha",
        "axPages(\n    const A",
        "tatic void CheckStealPrecondit",
        "from an immutable buffer\");\n ",
        "\nArrayBufferObject* Arr",
        "turn js::gc",
        "lass ",
        "to_,\n   ",
        "Kind::ARRAYBUFFER4 ||\n    ",
        "h the object by repurposing fixe",
        " metadata, proto);\n",
        "e allocating the ma",
        "Contents contents = buffer->co",
        " != INLINE_DATA",
        "mallocSizeOf(buffer.da",
        ">byteLen",
        "        ",
        "!nursery.is",
        "own) {\n  swi",
        "rrayBuf",
        "\");\n      break;\n ",
        " break;\n    }\n  }\n}\n\nv",
        "_t value) { j",
        "first = false;\n     ",
        "urseryV",
        "ject* buffe",
        "fterMinor",
        "at every map entr",
        "    vectorSize += r.fr",
        "ferByteLength(JSObj",
        "tatic ArrayBufferObject*",
        "ge, nullptr,\n    ",
        "fferObject>();\n  if (!aobj) {\n",
        "rayBufferWithContents(\n    ",
        "                   ",
        "(obj);\n\n  Rooted<A",
        "                                ",
        "ta = aobj->dataPointer();",
        "ffer::ResizableUnsharedClas",
        ");\n  if (!unwrapped"
      ],
      "method_count": 95
    },
    {
      "filepath": "js/src/vm/ArrayBufferObject.cpp",
      "filename": "ArrayBufferObject.cpp",
      "commit_hash": "13b7086f65cb",
      "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmReservedBytes",
          "type": "method",
          "start_line": 160,
          "end_line": 160,
          "line_count": 1,
          "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
        },
        {
          "name": "CheckArrayBufferTooLarge",
          "type": "function",
          "start_line": 162,
          "end_line": 172,
          "line_count": 11,
          "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
        },
        {
          "name": "CommitBufferMemory",
          "type": "method",
          "start_line": 244,
          "end_line": 269,
          "line_count": 26,
          "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
        },
        {
          "name": "UnmapBufferMemory",
          "type": "method",
          "start_line": 271,
          "end_line": 296,
          "line_count": 26,
          "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
        },
        {
          "name": "IsArrayBuffer",
          "type": "function",
          "start_line": 431,
          "end_line": 433,
          "line_count": 3,
          "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
        },
        {
          "name": "IsResizableArrayBuffer",
          "type": "function",
          "start_line": 435,
          "end_line": 437,
          "line_count": 3,
          "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 439,
          "end_line": 445,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 447,
          "end_line": 451,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 543,
          "end_line": 556,
          "line_count": 14,
          "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 563,
          "end_line": 568,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "resizableGetterImpl",
          "type": "method",
          "start_line": 575,
          "end_line": 583,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "resizableGetter",
          "type": "method",
          "start_line": 590,
          "end_line": 595,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "detachedGetterImpl",
          "type": "method",
          "start_line": 602,
          "end_line": 610,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "detachedGetter",
          "type": "method",
          "start_line": 617,
          "end_line": 622,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "immutableGetterImpl",
          "type": "method",
          "start_line": 630,
          "end_line": 638,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "immutableGetter",
          "type": "method",
          "start_line": 645,
          "end_line": 650,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "transferImpl",
          "type": "method",
          "start_line": 658,
          "end_line": 672,
          "line_count": 15,
          "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "transfer",
          "type": "method",
          "start_line": 679,
          "end_line": 682,
          "line_count": 4,
          "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
        },
        {
          "name": "transferToFixedLengthImpl",
          "type": "method",
          "start_line": 689,
          "end_line": 704,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToFixedLength",
          "type": "method",
          "start_line": 711,
          "end_line": 716,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "transferToImmutableImpl",
          "type": "method",
          "start_line": 724,
          "end_line": 739,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToImmutable",
          "type": "method",
          "start_line": 746,
          "end_line": 750,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "resizeImpl",
          "type": "method",
          "start_line": 758,
          "end_line": 820,
          "line_count": 63,
          "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 827,
          "end_line": 831,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsArrayBufferSpecies",
          "type": "function",
          "start_line": 833,
          "end_line": 836,
          "line_count": 4,
          "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinArrayBufferSpecies",
          "type": "function",
          "start_line": 838,
          "end_line": 858,
          "line_count": 21,
          "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 865,
          "end_line": 1011,
          "line_count": 147,
          "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 1018,
          "end_line": 1022,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "sliceToImmutableImpl",
          "type": "method",
          "start_line": 1030,
          "end_line": 1095,
          "line_count": 66,
          "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "sliceToImmutable",
          "type": "method",
          "start_line": 1102,
          "end_line": 1107,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "fun_isView",
          "type": "method",
          "start_line": 1113,
          "end_line": 1118,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 1122,
          "end_line": 1199,
          "line_count": 78,
          "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "AllocateUninitializedArrayBufferContents",
          "type": "function",
          "start_line": 1203,
          "end_line": 1221,
          "line_count": 19,
          "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "AllocateArrayBufferContents",
          "type": "function",
          "start_line": 1223,
          "end_line": 1239,
          "line_count": 17,
          "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "ReallocateArrayBufferContents",
          "type": "function",
          "start_line": 1241,
          "end_line": 1260,
          "line_count": 20,
          "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
        },
        {
          "name": "NewCopiedBufferContents",
          "type": "function",
          "start_line": 1262,
          "end_line": 1272,
          "line_count": 11,
          "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
        },
        {
          "name": "detach",
          "type": "method",
          "start_line": 1275,
          "end_line": 1310,
          "line_count": 36,
          "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 1312,
          "end_line": 1347,
          "line_count": 36,
          "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
        },
        {
          "name": " true;\n}\n\nvoid Was",
          "type": "method",
          "start_line": 1520,
          "end_line": 1541,
          "line_count": 22,
          "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
        },
        {
          "name": " void* ",
          "type": "method",
          "start_line": 1543,
          "end_line": 1586,
          "line_count": 44,
          "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
        },
        {
          "name": "sePoint",
          "type": "method",
          "start_line": 1631,
          "end_line": 1644,
          "line_count": 14,
          "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
        },
        {
          "name": " MALLOCED_UNKNO",
          "type": "method",
          "start_line": 1775,
          "end_line": 1821,
          "line_count": 47,
          "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
        },
        {
          "name": "ect::inlineDataPoint",
          "type": "method",
          "start_line": 1823,
          "end_line": 1828,
          "line_count": 6,
          "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
        },
        {
          "name": "asing.\n      brea",
          "type": "method",
          "start_line": 1846,
          "end_line": 1848,
          "line_count": 3,
          "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
        },
        {
          "name": "ed by, well",
          "type": "method",
          "start_line": 1858,
          "end_line": 1896,
          "line_count": 39,
          "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
        },
        {
          "name": "  if (isMapped",
          "type": "method",
          "start_line": 1898,
          "end_line": 1907,
          "line_count": 10,
          "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
        },
        {
          "name": "MappedSize",
          "type": "method",
          "start_line": 1909,
          "end_line": 1911,
          "line_count": 3,
          "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
        },
        {
          "name": "\nAddressType Ar",
          "type": "method",
          "start_line": 1913,
          "end_line": 1921,
          "line_count": 9,
          "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
        },
        {
          "name": "smPages() con",
          "type": "method",
          "start_line": 1923,
          "end_line": 1926,
          "line_count": 4,
          "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
        },
        {
          "name": "ages ArrayBuff",
          "type": "method",
          "start_line": 1928,
          "end_line": 1933,
          "line_count": 6,
          "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
        },
        {
          "name": "ForAsmJS());\n  ",
          "type": "method",
          "start_line": 1935,
          "end_line": 1941,
          "line_count": 7,
          "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
        },
        {
          "name": "();\n  }\n ",
          "type": "method",
          "start_line": 1943,
          "end_line": 1949,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
        },
        {
          "name": "is<ArrayBufferObjec",
          "type": "method",
          "start_line": 1951,
          "end_line": 1957,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
        },
        {
          "name": "eShared* buf) {\n  ",
          "type": "method",
          "start_line": 1959,
          "end_line": 1965,
          "line_count": 7,
          "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
        },
        {
          "name": "ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1967,
          "end_line": 1972,
          "line_count": 6,
          "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
        },
        {
          "name": " ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1974,
          "end_line": 1980,
          "line_count": 7,
          "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "axPages(\n    const A",
          "type": "method",
          "start_line": 1981,
          "end_line": 1986,
          "line_count": 6,
          "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
        },
        {
          "name": "tatic void CheckStealPrecondit",
          "type": "method",
          "start_line": 1987,
          "end_line": 1993,
          "line_count": 7,
          "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "from an immutable buffer\");\n ",
          "type": "method",
          "start_line": 1994,
          "end_line": 2000,
          "line_count": 7,
          "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "\nArrayBufferObject* Arr",
          "type": "function",
          "start_line": 2002,
          "end_line": 2012,
          "line_count": 11,
          "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
        },
        {
          "name": "turn js::gc",
          "type": "method",
          "start_line": 2148,
          "end_line": 2152,
          "line_count": 5,
          "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
        },
        {
          "name": "lass ",
          "type": "method",
          "start_line": 2154,
          "end_line": 2156,
          "line_count": 3,
          "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
        },
        {
          "name": "to_,\n   ",
          "type": "method",
          "start_line": 2158,
          "end_line": 2160,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
        },
        {
          "name": "Kind::ARRAYBUFFER4 ||\n    ",
          "type": "function",
          "start_line": 2162,
          "end_line": 2173,
          "line_count": 12,
          "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
        },
        {
          "name": "h the object by repurposing fixe",
          "type": "method",
          "start_line": 2358,
          "end_line": 2416,
          "line_count": 59,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
        },
        {
          "name": " metadata, proto);\n",
          "type": "method",
          "start_line": 2419,
          "end_line": 2445,
          "line_count": 27,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
        },
        {
          "name": "e allocating the ma",
          "type": "method",
          "start_line": 2448,
          "end_line": 2480,
          "line_count": 33,
          "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
        },
        {
          "name": "Contents contents = buffer->co",
          "type": "method",
          "start_line": 3013,
          "end_line": 3074,
          "line_count": 62,
          "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
        },
        {
          "name": " != INLINE_DATA",
          "type": "method",
          "start_line": 3077,
          "end_line": 3122,
          "line_count": 46,
          "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
        },
        {
          "name": "mallocSizeOf(buffer.da",
          "type": "method",
          "start_line": 3125,
          "end_line": 3169,
          "line_count": 45,
          "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": ">byteLen",
          "type": "method",
          "start_line": 3172,
          "end_line": 3174,
          "line_count": 3,
          "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
        },
        {
          "name": "        ",
          "type": "method",
          "start_line": 3177,
          "end_line": 3189,
          "line_count": 13,
          "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
        },
        {
          "name": "!nursery.is",
          "type": "method",
          "start_line": 3193,
          "end_line": 3213,
          "line_count": 21,
          "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
        },
        {
          "name": "own) {\n  swi",
          "type": "method",
          "start_line": 3221,
          "end_line": 3223,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
        },
        {
          "name": "rrayBuf",
          "type": "method",
          "start_line": 3225,
          "end_line": 3232,
          "line_count": 8,
          "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
        },
        {
          "name": "\");\n      break;\n ",
          "type": "function",
          "start_line": 3237,
          "end_line": 3268,
          "line_count": 32,
          "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
        },
        {
          "name": " break;\n    }\n  }\n}\n\nv",
          "type": "function",
          "start_line": 3271,
          "end_line": 3289,
          "line_count": 19,
          "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
        },
        {
          "name": "_t value) { j",
          "type": "method",
          "start_line": 3291,
          "end_line": 3314,
          "line_count": 24,
          "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "first = false;\n     ",
          "type": "method",
          "start_line": 3316,
          "end_line": 3351,
          "line_count": 36,
          "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "urseryV",
          "type": "method",
          "start_line": 3430,
          "end_line": 3467,
          "line_count": 38,
          "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
        },
        {
          "name": "ject* buffe",
          "type": "method",
          "start_line": 3478,
          "end_line": 3483,
          "line_count": 6,
          "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
        },
        {
          "name": "fterMinor",
          "type": "method",
          "start_line": 3485,
          "end_line": 3489,
          "line_count": 5,
          "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
        },
        {
          "name": "at every map entr",
          "type": "method",
          "start_line": 3491,
          "end_line": 3518,
          "line_count": 28,
          "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
        },
        {
          "name": "    vectorSize += r.fr",
          "type": "method",
          "start_line": 3520,
          "end_line": 3532,
          "line_count": 13,
          "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
        },
        {
          "name": "ferByteLength(JSObj",
          "type": "method",
          "start_line": 3534,
          "end_line": 3542,
          "line_count": 9,
          "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
        },
        {
          "name": "tatic ArrayBufferObject*",
          "type": "method",
          "start_line": 3549,
          "end_line": 3552,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "ge, nullptr,\n    ",
          "type": "method",
          "start_line": 3582,
          "end_line": 3612,
          "line_count": 31,
          "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
        },
        {
          "name": "fferObject>();\n  if (!aobj) {\n",
          "type": "method",
          "start_line": 3614,
          "end_line": 3625,
          "line_count": 12,
          "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
        },
        {
          "name": "rayBufferWithContents(\n    ",
          "type": "method",
          "start_line": 3627,
          "end_line": 3634,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "                   ",
          "type": "method",
          "start_line": 3734,
          "end_line": 3736,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
        },
        {
          "name": "(obj);\n\n  Rooted<A",
          "type": "method",
          "start_line": 3738,
          "end_line": 3740,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
        },
        {
          "name": "                                ",
          "type": "method",
          "start_line": 3807,
          "end_line": 3810,
          "line_count": 4,
          "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
        },
        {
          "name": "ta = aobj->dataPointer();",
          "type": "method",
          "start_line": 3812,
          "end_line": 3819,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "ffer::ResizableUnsharedClas",
          "type": "method",
          "start_line": 3835,
          "end_line": 3843,
          "line_count": 9,
          "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": ");\n  if (!unwrapped",
          "type": "method",
          "start_line": 3886,
          "end_line": 3936,
          "line_count": 51,
          "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
        }
      ],
      "method_names": [
        "WasmReservedBytes",
        "CheckArrayBufferTooLarge",
        "CommitBufferMemory",
        "UnmapBufferMemory",
        "IsArrayBuffer",
        "IsResizableArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "resizableGetterImpl",
        "resizableGetter",
        "detachedGetterImpl",
        "detachedGetter",
        "immutableGetterImpl",
        "immutableGetter",
        "transferImpl",
        "transfer",
        "transferToFixedLengthImpl",
        "transferToFixedLength",
        "transferToImmutableImpl",
        "transferToImmutable",
        "resizeImpl",
        "resize",
        "IsArrayBufferSpecies",
        "HasBuiltinArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "sliceToImmutableImpl",
        "sliceToImmutable",
        "fun_isView",
        "class_constructor",
        "AllocateUninitializedArrayBufferContents",
        "AllocateArrayBufferContents",
        "ReallocateArrayBufferContents",
        "NewCopiedBufferContents",
        "detach",
        "resize",
        " true;\n}\n\nvoid Was",
        " void* ",
        "sePoint",
        " MALLOCED_UNKNO",
        "ect::inlineDataPoint",
        "asing.\n      brea",
        "ed by, well",
        "  if (isMapped",
        "MappedSize",
        "\nAddressType Ar",
        "smPages() con",
        "ages ArrayBuff",
        "ForAsmJS());\n  ",
        "();\n  }\n ",
        "is<ArrayBufferObjec",
        "eShared* buf) {\n  ",
        "ArrayBufferObjectMaybeSha",
        " ArrayBufferObjectMaybeSha",
        "axPages(\n    const A",
        "tatic void CheckStealPrecondit",
        "from an immutable buffer\");\n ",
        "\nArrayBufferObject* Arr",
        "turn js::gc",
        "lass ",
        "to_,\n   ",
        "Kind::ARRAYBUFFER4 ||\n    ",
        "h the object by repurposing fixe",
        " metadata, proto);\n",
        "e allocating the ma",
        "Contents contents = buffer->co",
        " != INLINE_DATA",
        "mallocSizeOf(buffer.da",
        ">byteLen",
        "        ",
        "!nursery.is",
        "own) {\n  swi",
        "rrayBuf",
        "\");\n      break;\n ",
        " break;\n    }\n  }\n}\n\nv",
        "_t value) { j",
        "first = false;\n     ",
        "urseryV",
        "ject* buffe",
        "fterMinor",
        "at every map entr",
        "    vectorSize += r.fr",
        "ferByteLength(JSObj",
        "tatic ArrayBufferObject*",
        "ge, nullptr,\n    ",
        "fferObject>();\n  if (!aobj) {\n",
        "rayBufferWithContents(\n    ",
        "                   ",
        "(obj);\n\n  Rooted<A",
        "                                ",
        "ta = aobj->dataPointer();",
        "ffer::ResizableUnsharedClas",
        ");\n  if (!unwrapped"
      ],
      "method_count": 95
    },
    {
      "filepath": "js/src/vm/ArrayBufferObject.cpp",
      "filename": "ArrayBufferObject.cpp",
      "commit_hash": "85d47a33200c",
      "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmReservedBytes",
          "type": "method",
          "start_line": 160,
          "end_line": 160,
          "line_count": 1,
          "signature": "uint64_t js::WasmReservedBytes() { return wasmReservedBytes; }  [[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx,"
        },
        {
          "name": "CheckArrayBufferTooLarge",
          "type": "function",
          "start_line": 162,
          "end_line": 172,
          "line_count": 11,
          "signature": "[[nodiscard]] static bool CheckArrayBufferTooLarge(JSContext* cx, uint64_t nbytes) { // Refuse to allocate too large buffers."
        },
        {
          "name": "CommitBufferMemory",
          "type": "method",
          "start_line": 244,
          "end_line": 269,
          "line_count": 26,
          "signature": "bool js::CommitBufferMemory(void* dataEnd, size_t delta) { MOZ_ASSERT(delta); MOZ_ASSERT(delta % gc::SystemPageSize() == 0);"
        },
        {
          "name": "UnmapBufferMemory",
          "type": "method",
          "start_line": 271,
          "end_line": 296,
          "line_count": 26,
          "signature": "void js::UnmapBufferMemory(wasm::AddressType t, void* base, size_t mappedSize, size_t committedSize) { MOZ_ASSERT(mappedSize % gc::SystemPageSize() == 0);"
        },
        {
          "name": "IsArrayBuffer",
          "type": "function",
          "start_line": 431,
          "end_line": 433,
          "line_count": 3,
          "signature": "static bool IsArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ArrayBufferObject>(); }"
        },
        {
          "name": "IsResizableArrayBuffer",
          "type": "function",
          "start_line": 435,
          "end_line": 437,
          "line_count": 3,
          "signature": "static bool IsResizableArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<ResizableArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 439,
          "end_line": 445,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool ArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 447,
          "end_line": 451,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 543,
          "end_line": 556,
          "line_count": 14,
          "signature": "bool ArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 563,
          "end_line": 568,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "resizableGetterImpl",
          "type": "method",
          "start_line": 575,
          "end_line": 583,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::resizableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "resizableGetter",
          "type": "method",
          "start_line": 590,
          "end_line": 595,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::resizableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "detachedGetterImpl",
          "type": "method",
          "start_line": 602,
          "end_line": 610,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::detachedGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "detachedGetter",
          "type": "method",
          "start_line": 617,
          "end_line": 622,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::detachedGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "immutableGetterImpl",
          "type": "method",
          "start_line": 630,
          "end_line": 638,
          "line_count": 9,
          "signature": "bool ArrayBufferObject::immutableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "immutableGetter",
          "type": "method",
          "start_line": 645,
          "end_line": 650,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::immutableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "transferImpl",
          "type": "method",
          "start_line": 658,
          "end_line": 672,
          "line_count": 15,
          "signature": "bool ArrayBufferObject::transferImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "transfer",
          "type": "method",
          "start_line": 679,
          "end_line": 682,
          "line_count": 4,
          "signature": "bool ArrayBufferObject::transfer(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); return CallNonGenericMethod<IsArrayBuffer, transferImpl>(cx, args);"
        },
        {
          "name": "transferToFixedLengthImpl",
          "type": "method",
          "start_line": 689,
          "end_line": 704,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToFixedLengthImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToFixedLength",
          "type": "method",
          "start_line": 711,
          "end_line": 716,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::transferToFixedLength(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "transferToImmutableImpl",
          "type": "method",
          "start_line": 724,
          "end_line": 739,
          "line_count": 16,
          "signature": "bool ArrayBufferObject::transferToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "transferToImmutable",
          "type": "method",
          "start_line": 746,
          "end_line": 750,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::transferToImmutable(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "resizeImpl",
          "type": "method",
          "start_line": 758,
          "end_line": 820,
          "line_count": 63,
          "signature": "bool ArrayBufferObject::resizeImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsResizableArrayBuffer(args.thisv())); "
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 827,
          "end_line": 831,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::resize(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsArrayBufferSpecies",
          "type": "function",
          "start_line": 833,
          "end_line": 836,
          "line_count": 4,
          "signature": "static bool IsArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName(species, cx->names().dollar_ArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinArrayBufferSpecies",
          "type": "function",
          "start_line": 838,
          "end_line": 858,
          "line_count": 21,
          "signature": "static bool HasBuiltinArrayBufferSpecies(ArrayBufferObject* obj, JSContext* cx) { // Ensure `ArrayBuffer.prototype.constructor` and `ArrayBuffer[@@species]`"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 865,
          "end_line": 1011,
          "line_count": 147,
          "signature": "bool ArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 1018,
          "end_line": 1022,
          "line_count": 5,
          "signature": "bool ArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "sliceToImmutableImpl",
          "type": "method",
          "start_line": 1030,
          "end_line": 1095,
          "line_count": 66,
          "signature": "bool ArrayBufferObject::sliceToImmutableImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsArrayBuffer(args.thisv()));"
        },
        {
          "name": "sliceToImmutable",
          "type": "method",
          "start_line": 1102,
          "end_line": 1107,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::sliceToImmutable(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "fun_isView",
          "type": "method",
          "start_line": 1113,
          "end_line": 1118,
          "line_count": 6,
          "signature": "bool ArrayBufferObject::fun_isView(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp); args.rval().setBoolean(args.get(0).isObject() &&"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 1122,
          "end_line": 1199,
          "line_count": 78,
          "signature": "bool ArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "AllocateUninitializedArrayBufferContents",
          "type": "function",
          "start_line": 1203,
          "end_line": 1221,
          "line_count": 19,
          "signature": "static ArrayBufferContents AllocateUninitializedArrayBufferContents( JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "AllocateArrayBufferContents",
          "type": "function",
          "start_line": 1223,
          "end_line": 1239,
          "line_count": 17,
          "signature": "static ArrayBufferContents AllocateArrayBufferContents(JSContext* cx, size_t nbytes) { // First attempt a normal allocation."
        },
        {
          "name": "ReallocateArrayBufferContents",
          "type": "function",
          "start_line": 1241,
          "end_line": 1260,
          "line_count": 20,
          "signature": "static ArrayBufferContents ReallocateArrayBufferContents(JSContext* cx, uint8_t* old, size_t oldSize,"
        },
        {
          "name": "NewCopiedBufferContents",
          "type": "function",
          "start_line": 1262,
          "end_line": 1272,
          "line_count": 11,
          "signature": "static ArrayBufferContents NewCopiedBufferContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) { ArrayBufferContents dataCopy ="
        },
        {
          "name": "detach",
          "type": "method",
          "start_line": 1275,
          "end_line": 1310,
          "line_count": 36,
          "signature": "void ArrayBufferObject::detach(JSContext* cx, Handle<ArrayBufferObject*> buffer) { cx->check(buffer);"
        },
        {
          "name": "resize",
          "type": "method",
          "start_line": 1312,
          "end_line": 1347,
          "line_count": 36,
          "signature": "void ResizableArrayBufferObject::resize(size_t newByteLength) { MOZ_ASSERT(!isPreparedForAsmJS()); MOZ_ASSERT(!isWasm());"
        },
        {
          "name": " true;\n}\n\nvoid Was",
          "type": "method",
          "start_line": 1520,
          "end_line": 1541,
          "line_count": 22,
          "signature": "[[nodiscard]] bool WasmArrayRawBuffer::growToPagesInPlace(Pages newPages) { size_t newSize = newPages.byteLength(); size_t oldSize = byteLength();"
        },
        {
          "name": " void* ",
          "type": "method",
          "start_line": 1543,
          "end_line": 1586,
          "line_count": 44,
          "signature": "void WasmArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { uint8_t* memBase = dataPointer(); "
        },
        {
          "name": "sePoint",
          "type": "method",
          "start_line": 1631,
          "end_line": 1644,
          "line_count": 14,
          "signature": "void WasmArrayRawBuffer::Release(void* mem) { WasmArrayRawBuffer* header = (WasmArrayRawBuffer*)((uint8_t*)mem - sizeof(WasmArrayRawBuffer));"
        },
        {
          "name": " MALLOCED_UNKNO",
          "type": "method",
          "start_line": 1775,
          "end_line": 1821,
          "line_count": 47,
          "signature": "bool ArrayBufferObject::prepareForAsmJS() { MOZ_ASSERT(byteLength() % wasm::PageSize == 0, \"prior size checking should have guaranteed page-size multiple\");"
        },
        {
          "name": "ect::inlineDataPoint",
          "type": "method",
          "start_line": 1823,
          "end_line": 1828,
          "line_count": 6,
          "signature": "ArrayBufferObject::BufferContents ArrayBufferObject::createMappedContents( int fd, size_t offset, size_t length) { void* data ="
        },
        {
          "name": "asing.\n      brea",
          "type": "method",
          "start_line": 1846,
          "end_line": 1848,
          "line_count": 3,
          "signature": "SharedMem<uint8_t*> ArrayBufferObject::dataPointerShared() const { return SharedMem<uint8_t*>::unshared(getFixedSlot(DATA_SLOT).toPrivate()); }"
        },
        {
          "name": "ed by, well",
          "type": "method",
          "start_line": 1858,
          "end_line": 1896,
          "line_count": 39,
          "signature": "void ArrayBufferObject::releaseData(JS::GCContext* gcx) { switch (bufferKind()) { case INLINE_DATA:"
        },
        {
          "name": "  if (isMapped",
          "type": "method",
          "start_line": 1898,
          "end_line": 1907,
          "line_count": 10,
          "signature": "void ArrayBufferObject::setDataPointer(BufferContents contents) { setFixedSlot(DATA_SLOT, PrivateValue(contents.data())); setFlags((flags() & ~KIND_MASK) | contents.kind());"
        },
        {
          "name": "MappedSize",
          "type": "method",
          "start_line": 1909,
          "end_line": 1911,
          "line_count": 3,
          "signature": "size_t ArrayBufferObject::byteLength() const { return size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()); }"
        },
        {
          "name": "\nAddressType Ar",
          "type": "method",
          "start_line": 1913,
          "end_line": 1921,
          "line_count": 9,
          "signature": "inline size_t ArrayBufferObject::associatedBytes() const { if (isMalloced()) { return maxByteLength();"
        },
        {
          "name": "smPages() con",
          "type": "method",
          "start_line": 1923,
          "end_line": 1926,
          "line_count": 4,
          "signature": "void ArrayBufferObject::setByteLength(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); setFixedSlot(BYTE_LENGTH_SLOT, PrivateValue(length));"
        },
        {
          "name": "ages ArrayBuff",
          "type": "method",
          "start_line": 1928,
          "end_line": 1933,
          "line_count": 6,
          "signature": "size_t ArrayBufferObject::wasmMappedSize() const { if (isWasm()) { return contents().wasmBuffer()->mappedSize();"
        },
        {
          "name": "ForAsmJS());\n  ",
          "type": "method",
          "start_line": 1935,
          "end_line": 1941,
          "line_count": 7,
          "signature": "AddressType ArrayBufferObject::wasmAddressType() const { if (isWasm()) { return contents().wasmBuffer()->addressType();"
        },
        {
          "name": "();\n  }\n ",
          "type": "method",
          "start_line": 1943,
          "end_line": 1949,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmPages() const { if (isWasm()) { return contents().wasmBuffer()->pages();"
        },
        {
          "name": "is<ArrayBufferObjec",
          "type": "method",
          "start_line": 1951,
          "end_line": 1957,
          "line_count": 7,
          "signature": "Pages ArrayBufferObject::wasmClampedMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->clampedMaxPages();"
        },
        {
          "name": "eShared* buf) {\n  ",
          "type": "method",
          "start_line": 1959,
          "end_line": 1965,
          "line_count": 7,
          "signature": "Maybe<Pages> ArrayBufferObject::wasmSourceMaxPages() const { if (isWasm()) { return contents().wasmBuffer()->sourceMaxPages();"
        },
        {
          "name": "ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1967,
          "end_line": 1972,
          "line_count": 6,
          "signature": "size_t js::WasmArrayBufferMappedSize(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmMappedSize();"
        },
        {
          "name": " ArrayBufferObjectMaybeSha",
          "type": "method",
          "start_line": 1974,
          "end_line": 1980,
          "line_count": 7,
          "signature": "AddressType js::WasmArrayBufferAddressType( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "axPages(\n    const A",
          "type": "method",
          "start_line": 1981,
          "end_line": 1986,
          "line_count": 6,
          "signature": "Pages js::WasmArrayBufferPages(const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) { return buf->as<ArrayBufferObject>().wasmPages();"
        },
        {
          "name": "tatic void CheckStealPrecondit",
          "type": "method",
          "start_line": 1987,
          "end_line": 1993,
          "line_count": 7,
          "signature": "Pages js::WasmArrayBufferClampedMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "from an immutable buffer\");\n ",
          "type": "method",
          "start_line": 1994,
          "end_line": 2000,
          "line_count": 7,
          "signature": "Maybe<Pages> js::WasmArrayBufferSourceMaxPages( const ArrayBufferObjectMaybeShared* buf) { if (buf->is<ArrayBufferObject>()) {"
        },
        {
          "name": "\nArrayBufferObject* Arr",
          "type": "function",
          "start_line": 2002,
          "end_line": 2012,
          "line_count": 11,
          "signature": "static void CheckStealPreconditions(Handle<ArrayBufferObject*> buffer, JSContext* cx) { cx->check(buffer);"
        },
        {
          "name": "turn js::gc",
          "type": "method",
          "start_line": 2148,
          "end_line": 2152,
          "line_count": 5,
          "signature": "void ArrayBufferObject::wasmDiscard(Handle<ArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) { MOZ_ASSERT(buf->isWasm());"
        },
        {
          "name": "lass ",
          "type": "method",
          "start_line": 2154,
          "end_line": 2156,
          "line_count": 3,
          "signature": "uint32_t ArrayBufferObject::flags() const { return uint32_t(getFixedSlot(FLAGS_SLOT).toInt32()); }"
        },
        {
          "name": "to_,\n   ",
          "type": "method",
          "start_line": 2158,
          "end_line": 2160,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFlags(uint32_t flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags)); }"
        },
        {
          "name": "Kind::ARRAYBUFFER4 ||\n    ",
          "type": "function",
          "start_line": 2162,
          "end_line": 2173,
          "line_count": 12,
          "signature": "static constexpr js::gc::AllocKind GetArrayBufferGCObjectKind(size_t numSlots) { if (numSlots <= 4) { return js::gc::AllocKind::ARRAYBUFFER4;"
        },
        {
          "name": "h the object by repurposing fixe",
          "type": "method",
          "start_line": 2358,
          "end_line": 2416,
          "line_count": 59,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createUninitializedBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata&,"
        },
        {
          "name": " metadata, proto);\n",
          "type": "method",
          "start_line": 2419,
          "end_line": 2445,
          "line_count": 27,
          "signature": "/* static */ std::tuple<ArrayBufferType*, uint8_t*> ArrayBufferObject::createBufferAndData( JSContext* cx, size_t nbytes, AutoSetNewObjectMetadata& metadata,"
        },
        {
          "name": "e allocating the ma",
          "type": "method",
          "start_line": 2448,
          "end_line": 2480,
          "line_count": 33,
          "signature": "/* static */ std::tuple<ResizableArrayBufferObject*, uint8_t*> ResizableArrayBufferObject::createBufferAndData( JSContext* cx, size_t byteLength, size_t maxByteLength,"
        },
        {
          "name": "Contents contents = buffer->co",
          "type": "method",
          "start_line": 3013,
          "end_line": 3074,
          "line_count": 62,
          "signature": "/* static */ ArrayBufferObject::BufferContents ArrayBufferObject::extractStructuredCloneContents( JSContext* cx, Handle<ArrayBufferObject*> buffer) {"
        },
        {
          "name": " != INLINE_DATA",
          "type": "method",
          "start_line": 3077,
          "end_line": 3122,
          "line_count": 46,
          "signature": "bool ArrayBufferObject::ensureNonInline(JSContext* cx, Handle<ArrayBufferObject*> buffer) { if (buffer->isDetached() || buffer->isPreparedForAsmJS()) {"
        },
        {
          "name": "mallocSizeOf(buffer.da",
          "type": "method",
          "start_line": 3125,
          "end_line": 3169,
          "line_count": 45,
          "signature": "void ArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": ">byteLen",
          "type": "method",
          "start_line": 3172,
          "end_line": 3174,
          "line_count": 3,
          "signature": "void ArrayBufferObject::finalize(JS::GCContext* gcx, JSObject* obj) { obj->as<ArrayBufferObject>().releaseData(gcx); }"
        },
        {
          "name": "        ",
          "type": "method",
          "start_line": 3177,
          "end_line": 3189,
          "line_count": 13,
          "signature": "void ArrayBufferObject::copyData(ArrayBufferObject* toBuffer, size_t toIndex, ArrayBufferObject* fromBuffer, size_t fromIndex, size_t count) {"
        },
        {
          "name": "!nursery.is",
          "type": "method",
          "start_line": 3193,
          "end_line": 3213,
          "line_count": 21,
          "signature": "size_t ArrayBufferObject::objectMoved(JSObject* obj, JSObject* old) { auto& dst = obj->as<ArrayBufferType>(); const auto& src = old->as<ArrayBufferType>();"
        },
        {
          "name": "own) {\n  swi",
          "type": "method",
          "start_line": 3221,
          "end_line": 3223,
          "line_count": 3,
          "signature": "void ArrayBufferObject::setFirstView(ArrayBufferViewObject* view) { setFixedSlot(FIRST_VIEW_SLOT, ObjectOrNullValue(view)); }"
        },
        {
          "name": "rrayBuf",
          "type": "method",
          "start_line": 3225,
          "end_line": 3232,
          "line_count": 8,
          "signature": "bool ArrayBufferObject::addView(JSContext* cx, ArrayBufferViewObject* view) { if (!firstView()) { setFirstView(view);"
        },
        {
          "name": "\");\n      break;\n ",
          "type": "function",
          "start_line": 3237,
          "end_line": 3268,
          "line_count": 32,
          "signature": "void BufferKindToString(ArrayBufferObject::BufferKind kind, KnownF known, UnknownF unknown) { switch (kind) {"
        },
        {
          "name": " break;\n    }\n  }\n}\n\nv",
          "type": "function",
          "start_line": 3271,
          "end_line": 3289,
          "line_count": 19,
          "signature": "void ForEachArrayBufferFlag(uint32_t flags, KnownF known, UnknownF unknown) { for (uint32_t i = ArrayBufferObject::ArrayBufferFlags::BUFFER_KIND_MASK + 1; i; i = i << 1) {"
        },
        {
          "name": "_t value) { j",
          "type": "method",
          "start_line": 3291,
          "end_line": 3314,
          "line_count": 24,
          "signature": "void ArrayBufferObject::dumpOwnFields(js::JSONPrinter& json) const { json.formatProperty(\"byteLength\", \"%zu\", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "first = false;\n     ",
          "type": "method",
          "start_line": 3316,
          "end_line": 3351,
          "line_count": 36,
          "signature": "void ArrayBufferObject::dumpOwnStringContent(js::GenericPrinter& out) const { out.printf(\"byteLength=%zu, \", size_t(getFixedSlot(BYTE_LENGTH_SLOT).toPrivate()));"
        },
        {
          "name": "urseryV",
          "type": "method",
          "start_line": 3430,
          "end_line": 3467,
          "line_count": 38,
          "signature": "bool InnerViewTable::addView(JSContext* cx, ArrayBufferObject* buffer, ArrayBufferViewObject* view) { // ArrayBufferObject entries are only added when there are multiple views."
        },
        {
          "name": "ject* buffe",
          "type": "method",
          "start_line": 3478,
          "end_line": 3483,
          "line_count": 6,
          "signature": "void InnerViewTable::removeViews(ArrayBufferObject* buffer) { auto ptr = map.lookup(buffer); MOZ_ASSERT(ptr);"
        },
        {
          "name": "fterMinor",
          "type": "method",
          "start_line": 3485,
          "end_line": 3489,
          "line_count": 5,
          "signature": "bool InnerViewTable::traceWeak(JSTracer* trc) { nurseryKeys.traceWeak(trc); map.traceWeak(trc);"
        },
        {
          "name": "at every map entr",
          "type": "method",
          "start_line": 3491,
          "end_line": 3518,
          "line_count": 28,
          "signature": "void InnerViewTable::sweepAfterMinorGC(JSTracer* trc) { MOZ_ASSERT(needsSweepAfterMinorGC()); "
        },
        {
          "name": "    vectorSize += r.fr",
          "type": "method",
          "start_line": 3520,
          "end_line": 3532,
          "line_count": 13,
          "signature": "bool InnerViewTable::sweepViewsAfterMinorGC(JSTracer* trc, ArrayBufferObject* buffer, Views& views) {"
        },
        {
          "name": "ferByteLength(JSObj",
          "type": "method",
          "start_line": 3534,
          "end_line": 3542,
          "line_count": 9,
          "signature": "size_t InnerViewTable::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) { size_t vectorSize = 0; for (auto r = map.all(); !r.empty(); r.popFront()) {"
        },
        {
          "name": "tatic ArrayBufferObject*",
          "type": "method",
          "start_line": 3549,
          "end_line": 3552,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetArrayBufferByteLength(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapAs<ArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "ge, nullptr,\n    ",
          "type": "method",
          "start_line": 3582,
          "end_line": 3612,
          "line_count": 31,
          "signature": "JS_PUBLIC_API bool JS::DetachArrayBuffer(JSContext* cx, HandleObject obj) { AssertHeapIsIdle(); CHECK_THREAD(cx);"
        },
        {
          "name": "fferObject>();\n  if (!aobj) {\n",
          "type": "method",
          "start_line": 3614,
          "end_line": 3625,
          "line_count": 12,
          "signature": "JS_PUBLIC_API bool JS::HasDefinedArrayBufferDetachKey(JSContext* cx, HandleObject obj, bool* isDefined) {"
        },
        {
          "name": "rayBufferWithContents(\n    ",
          "type": "method",
          "start_line": 3627,
          "end_line": 3634,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsDetachedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "                   ",
          "type": "method",
          "start_line": 3734,
          "end_line": 3736,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<ArrayBufferObject>(); }"
        },
        {
          "name": "(obj);\n\n  Rooted<A",
          "type": "method",
          "start_line": 3738,
          "end_line": 3740,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ArrayBufferHasData(JSObject* obj) { return !obj->unwrapAs<ArrayBufferObject>().isDetached(); }"
        },
        {
          "name": "                                ",
          "type": "method",
          "start_line": 3807,
          "end_line": 3810,
          "line_count": 4,
          "signature": "JS_PUBLIC_API void JS::ReleaseMappedArrayBufferContents(void* contents, size_t length) { gc::DeallocateMappedContent(contents, length);"
        },
        {
          "name": "ta = aobj->dataPointer();",
          "type": "method",
          "start_line": 3812,
          "end_line": 3819,
          "line_count": 8,
          "signature": "JS_PUBLIC_API bool JS::IsMappedArrayBufferObject(JSObject* obj) { ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>(); if (!aobj) {"
        },
        {
          "name": "ffer::ResizableUnsharedClas",
          "type": "method",
          "start_line": 3835,
          "end_line": 3843,
          "line_count": 9,
          "signature": "JS_PUBLIC_API void JS::GetArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": ");\n  if (!unwrapped",
          "type": "method",
          "start_line": 3886,
          "end_line": 3936,
          "line_count": 51,
          "signature": "bool JS::ArrayBufferCopyData(JSContext* cx, Handle<JSObject*> toBlock, size_t toIndex, Handle<JSObject*> fromBlock, size_t fromIndex, size_t count) {"
        }
      ],
      "method_names": [
        "WasmReservedBytes",
        "CheckArrayBufferTooLarge",
        "CommitBufferMemory",
        "UnmapBufferMemory",
        "IsArrayBuffer",
        "IsResizableArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "resizableGetterImpl",
        "resizableGetter",
        "detachedGetterImpl",
        "detachedGetter",
        "immutableGetterImpl",
        "immutableGetter",
        "transferImpl",
        "transfer",
        "transferToFixedLengthImpl",
        "transferToFixedLength",
        "transferToImmutableImpl",
        "transferToImmutable",
        "resizeImpl",
        "resize",
        "IsArrayBufferSpecies",
        "HasBuiltinArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "sliceToImmutableImpl",
        "sliceToImmutable",
        "fun_isView",
        "class_constructor",
        "AllocateUninitializedArrayBufferContents",
        "AllocateArrayBufferContents",
        "ReallocateArrayBufferContents",
        "NewCopiedBufferContents",
        "detach",
        "resize",
        " true;\n}\n\nvoid Was",
        " void* ",
        "sePoint",
        " MALLOCED_UNKNO",
        "ect::inlineDataPoint",
        "asing.\n      brea",
        "ed by, well",
        "  if (isMapped",
        "MappedSize",
        "\nAddressType Ar",
        "smPages() con",
        "ages ArrayBuff",
        "ForAsmJS());\n  ",
        "();\n  }\n ",
        "is<ArrayBufferObjec",
        "eShared* buf) {\n  ",
        "ArrayBufferObjectMaybeSha",
        " ArrayBufferObjectMaybeSha",
        "axPages(\n    const A",
        "tatic void CheckStealPrecondit",
        "from an immutable buffer\");\n ",
        "\nArrayBufferObject* Arr",
        "turn js::gc",
        "lass ",
        "to_,\n   ",
        "Kind::ARRAYBUFFER4 ||\n    ",
        "h the object by repurposing fixe",
        " metadata, proto);\n",
        "e allocating the ma",
        "Contents contents = buffer->co",
        " != INLINE_DATA",
        "mallocSizeOf(buffer.da",
        ">byteLen",
        "        ",
        "!nursery.is",
        "own) {\n  swi",
        "rrayBuf",
        "\");\n      break;\n ",
        " break;\n    }\n  }\n}\n\nv",
        "_t value) { j",
        "first = false;\n     ",
        "urseryV",
        "ject* buffe",
        "fterMinor",
        "at every map entr",
        "    vectorSize += r.fr",
        "ferByteLength(JSObj",
        "tatic ArrayBufferObject*",
        "ge, nullptr,\n    ",
        "fferObject>();\n  if (!aobj) {\n",
        "rayBufferWithContents(\n    ",
        "                   ",
        "(obj);\n\n  Rooted<A",
        "                                ",
        "ta = aobj->dataPointer();",
        "ffer::ResizableUnsharedClas",
        ");\n  if (!unwrapped"
      ],
      "method_count": 95
    },
    {
      "filepath": "js/src/vm/SharedArrayObject.cpp",
      "filename": "SharedArrayObject.cpp",
      "commit_hash": "75d829afb4b0",
      "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmSharedArrayAccessibleSize",
          "type": "function",
          "start_line": 40,
          "end_line": 42,
          "line_count": 3,
          "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
        },
        {
          "name": "NonWasmSharedArrayAllocSize",
          "type": "function",
          "start_line": 44,
          "end_line": 47,
          "line_count": 4,
          "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
        },
        {
          "name": "SharedArrayMappedSize",
          "type": "function",
          "start_line": 53,
          "end_line": 60,
          "line_count": 8,
          "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
        },
        {
          "name": "wasmGrowToPagesInPlace",
          "type": "method",
          "start_line": 135,
          "end_line": 173,
          "line_count": 39,
          "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
        },
        {
          "name": "discard",
          "type": "method",
          "start_line": 175,
          "end_line": 234,
          "line_count": 60,
          "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
        },
        {
          "name": "addReference",
          "type": "method",
          "start_line": 236,
          "end_line": 250,
          "line_count": 15,
          "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
        },
        {
          "name": "dropReference",
          "type": "method",
          "start_line": 252,
          "end_line": 278,
          "line_count": 27,
          "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
        },
        {
          "name": "growJS",
          "type": "method",
          "start_line": 280,
          "end_line": 301,
          "line_count": 22,
          "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
        },
        {
          "name": "IsSharedArrayBuffer",
          "type": "function",
          "start_line": 303,
          "end_line": 305,
          "line_count": 3,
          "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
        },
        {
          "name": "IsGrowableSharedArrayBuffer",
          "type": "function",
          "start_line": 307,
          "end_line": 309,
          "line_count": 3,
          "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 311,
          "end_line": 317,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 319,
          "end_line": 324,
          "line_count": 6,
          "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 329,
          "end_line": 359,
          "line_count": 31,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 364,
          "end_line": 370,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growableGetterImpl",
          "type": "method",
          "start_line": 375,
          "end_line": 383,
          "line_count": 9,
          "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "growableGetter",
          "type": "method",
          "start_line": 388,
          "end_line": 394,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growImpl",
          "type": "method",
          "start_line": 399,
          "end_line": 448,
          "line_count": 50,
          "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
        },
        {
          "name": "grow",
          "type": "method",
          "start_line": 453,
          "end_line": 457,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 459,
          "end_line": 462,
          "line_count": 4,
          "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 464,
          "end_line": 484,
          "line_count": 21,
          "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 491,
          "end_line": 596,
          "line_count": 106,
          "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 603,
          "end_line": 607,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 611,
          "end_line": 688,
          "line_count": 78,
          "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "acceptRawBuffer",
          "type": "method",
          "start_line": 777,
          "end_line": 790,
          "line_count": 14,
          "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
        },
        {
          "name": "dropRawBuffer",
          "type": "method",
          "start_line": 792,
          "end_line": 800,
          "line_count": 9,
          "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
        },
        {
          "name": "Finalize",
          "type": "method",
          "start_line": 808,
          "end_line": 821,
          "line_count": 14,
          "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
        },
        {
          "name": "addSizeOfExcludingThis",
          "type": "method",
          "start_line": 824,
          "end_line": 851,
          "line_count": 28,
          "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": "copyData",
          "type": "method",
          "start_line": 854,
          "end_line": 868,
          "line_count": 15,
          "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
        },
        {
          "name": "wasmDiscard",
          "type": "method",
          "start_line": 933,
          "end_line": 938,
          "line_count": 6,
          "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
        },
        {
          "name": "GetSharedArrayBufferByteLength",
          "type": "method",
          "start_line": 1022,
          "end_line": 1025,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "GetSharedArrayBufferLengthAndData",
          "type": "method",
          "start_line": 1027,
          "end_line": 1036,
          "line_count": 10,
          "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": "IsSharedArrayBufferObject",
          "type": "method",
          "start_line": 1051,
          "end_line": 1053,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
        },
        {
          "name": "ContainsSharedArrayBuffer",
          "type": "method",
          "start_line": 1065,
          "end_line": 1067,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
        }
      ],
      "method_names": [
        "WasmSharedArrayAccessibleSize",
        "NonWasmSharedArrayAllocSize",
        "SharedArrayMappedSize",
        "wasmGrowToPagesInPlace",
        "discard",
        "addReference",
        "dropReference",
        "growJS",
        "IsSharedArrayBuffer",
        "IsGrowableSharedArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "growableGetterImpl",
        "growableGetter",
        "growImpl",
        "grow",
        "IsSharedArrayBufferSpecies",
        "HasBuiltinSharedArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "class_constructor",
        "acceptRawBuffer",
        "dropRawBuffer",
        "Finalize",
        "addSizeOfExcludingThis",
        "copyData",
        "wasmDiscard",
        "GetSharedArrayBufferByteLength",
        "GetSharedArrayBufferLengthAndData",
        "IsSharedArrayBufferObject",
        "ContainsSharedArrayBuffer"
      ],
      "method_count": 33
    },
    {
      "filepath": "js/src/vm/SharedArrayObject.cpp",
      "filename": "SharedArrayObject.cpp",
      "commit_hash": "13b7086f65cb",
      "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmSharedArrayAccessibleSize",
          "type": "function",
          "start_line": 40,
          "end_line": 42,
          "line_count": 3,
          "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
        },
        {
          "name": "NonWasmSharedArrayAllocSize",
          "type": "function",
          "start_line": 44,
          "end_line": 47,
          "line_count": 4,
          "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
        },
        {
          "name": "SharedArrayMappedSize",
          "type": "function",
          "start_line": 53,
          "end_line": 60,
          "line_count": 8,
          "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
        },
        {
          "name": "wasmGrowToPagesInPlace",
          "type": "method",
          "start_line": 135,
          "end_line": 173,
          "line_count": 39,
          "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
        },
        {
          "name": "discard",
          "type": "method",
          "start_line": 175,
          "end_line": 234,
          "line_count": 60,
          "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
        },
        {
          "name": "addReference",
          "type": "method",
          "start_line": 236,
          "end_line": 250,
          "line_count": 15,
          "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
        },
        {
          "name": "dropReference",
          "type": "method",
          "start_line": 252,
          "end_line": 278,
          "line_count": 27,
          "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
        },
        {
          "name": "growJS",
          "type": "method",
          "start_line": 280,
          "end_line": 301,
          "line_count": 22,
          "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
        },
        {
          "name": "IsSharedArrayBuffer",
          "type": "function",
          "start_line": 303,
          "end_line": 305,
          "line_count": 3,
          "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
        },
        {
          "name": "IsGrowableSharedArrayBuffer",
          "type": "function",
          "start_line": 307,
          "end_line": 309,
          "line_count": 3,
          "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 311,
          "end_line": 317,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 319,
          "end_line": 324,
          "line_count": 6,
          "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 329,
          "end_line": 337,
          "line_count": 9,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 342,
          "end_line": 348,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growableGetterImpl",
          "type": "method",
          "start_line": 353,
          "end_line": 361,
          "line_count": 9,
          "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "growableGetter",
          "type": "method",
          "start_line": 366,
          "end_line": 372,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growImpl",
          "type": "method",
          "start_line": 377,
          "end_line": 426,
          "line_count": 50,
          "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
        },
        {
          "name": "grow",
          "type": "method",
          "start_line": 431,
          "end_line": 435,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 437,
          "end_line": 440,
          "line_count": 4,
          "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 442,
          "end_line": 462,
          "line_count": 21,
          "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 469,
          "end_line": 574,
          "line_count": 106,
          "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 581,
          "end_line": 585,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 589,
          "end_line": 666,
          "line_count": 78,
          "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "acceptRawBuffer",
          "type": "method",
          "start_line": 755,
          "end_line": 768,
          "line_count": 14,
          "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
        },
        {
          "name": "dropRawBuffer",
          "type": "method",
          "start_line": 770,
          "end_line": 778,
          "line_count": 9,
          "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
        },
        {
          "name": "Finalize",
          "type": "method",
          "start_line": 786,
          "end_line": 799,
          "line_count": 14,
          "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
        },
        {
          "name": "addSizeOfExcludingThis",
          "type": "method",
          "start_line": 802,
          "end_line": 829,
          "line_count": 28,
          "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": "copyData",
          "type": "method",
          "start_line": 832,
          "end_line": 846,
          "line_count": 15,
          "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
        },
        {
          "name": "wasmDiscard",
          "type": "method",
          "start_line": 911,
          "end_line": 916,
          "line_count": 6,
          "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
        },
        {
          "name": "GetSharedArrayBufferByteLength",
          "type": "method",
          "start_line": 1000,
          "end_line": 1003,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "GetSharedArrayBufferLengthAndData",
          "type": "method",
          "start_line": 1005,
          "end_line": 1014,
          "line_count": 10,
          "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": "IsSharedArrayBufferObject",
          "type": "method",
          "start_line": 1029,
          "end_line": 1031,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
        },
        {
          "name": "ContainsSharedArrayBuffer",
          "type": "method",
          "start_line": 1043,
          "end_line": 1045,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
        }
      ],
      "method_names": [
        "WasmSharedArrayAccessibleSize",
        "NonWasmSharedArrayAllocSize",
        "SharedArrayMappedSize",
        "wasmGrowToPagesInPlace",
        "discard",
        "addReference",
        "dropReference",
        "growJS",
        "IsSharedArrayBuffer",
        "IsGrowableSharedArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "growableGetterImpl",
        "growableGetter",
        "growImpl",
        "grow",
        "IsSharedArrayBufferSpecies",
        "HasBuiltinSharedArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "class_constructor",
        "acceptRawBuffer",
        "dropRawBuffer",
        "Finalize",
        "addSizeOfExcludingThis",
        "copyData",
        "wasmDiscard",
        "GetSharedArrayBufferByteLength",
        "GetSharedArrayBufferLengthAndData",
        "IsSharedArrayBufferObject",
        "ContainsSharedArrayBuffer"
      ],
      "method_count": 33
    },
    {
      "filepath": "js/src/vm/SharedArrayObject.cpp",
      "filename": "SharedArrayObject.cpp",
      "commit_hash": "85d47a33200c",
      "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "WasmSharedArrayAccessibleSize",
          "type": "function",
          "start_line": 40,
          "end_line": 42,
          "line_count": 3,
          "signature": "static size_t WasmSharedArrayAccessibleSize(size_t length) { return AlignBytes(length, gc::SystemPageSize()); }"
        },
        {
          "name": "NonWasmSharedArrayAllocSize",
          "type": "function",
          "start_line": 44,
          "end_line": 47,
          "line_count": 4,
          "signature": "static size_t NonWasmSharedArrayAllocSize(size_t length) { MOZ_ASSERT(length <= ArrayBufferObject::ByteLengthLimit); return sizeof(SharedArrayRawBuffer) + length;"
        },
        {
          "name": "SharedArrayMappedSize",
          "type": "function",
          "start_line": 53,
          "end_line": 60,
          "line_count": 8,
          "signature": "static size_t SharedArrayMappedSize(bool isWasm, size_t length) { // Wasm buffers use MapBufferMemory and allocate a full page for the header. // Non-Wasm buffers use malloc."
        },
        {
          "name": "wasmGrowToPagesInPlace",
          "type": "method",
          "start_line": 135,
          "end_line": 173,
          "line_count": 39,
          "signature": "bool WasmSharedArrayRawBuffer::wasmGrowToPagesInPlace(const Lock&, wasm::AddressType t, wasm::Pages newPages) {"
        },
        {
          "name": "discard",
          "type": "method",
          "start_line": 175,
          "end_line": 234,
          "line_count": 60,
          "signature": "void WasmSharedArrayRawBuffer::discard(size_t byteOffset, size_t byteLen) { SharedMem<uint8_t*> memBase = dataPointerShared(); "
        },
        {
          "name": "addReference",
          "type": "method",
          "start_line": 236,
          "end_line": 250,
          "line_count": 15,
          "signature": "bool SharedArrayRawBuffer::addReference() { MOZ_RELEASE_ASSERT(refcount_ > 0); "
        },
        {
          "name": "dropReference",
          "type": "method",
          "start_line": 252,
          "end_line": 278,
          "line_count": 27,
          "signature": "void SharedArrayRawBuffer::dropReference() { // Normally if the refcount is zero then the memory will have been unmapped // and this test may just crash, but if the memory has been retained for any"
        },
        {
          "name": "growJS",
          "type": "method",
          "start_line": 280,
          "end_line": 301,
          "line_count": 22,
          "signature": "bool SharedArrayRawBuffer::growJS(size_t newByteLength) { MOZ_ASSERT(!isWasm()); MOZ_RELEASE_ASSERT(isGrowableJS());"
        },
        {
          "name": "IsSharedArrayBuffer",
          "type": "function",
          "start_line": 303,
          "end_line": 305,
          "line_count": 3,
          "signature": "static bool IsSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<SharedArrayBufferObject>(); }"
        },
        {
          "name": "IsGrowableSharedArrayBuffer",
          "type": "function",
          "start_line": 307,
          "end_line": 309,
          "line_count": 3,
          "signature": "static bool IsGrowableSharedArrayBuffer(HandleValue v) { return v.isObject() && v.toObject().is<GrowableSharedArrayBufferObject>(); }"
        },
        {
          "name": "byteLengthGetterImpl",
          "type": "method",
          "start_line": 311,
          "end_line": 317,
          "line_count": 7,
          "signature": "MOZ_ALWAYS_INLINE bool SharedArrayBufferObject::byteLengthGetterImpl( JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "byteLengthGetter",
          "type": "method",
          "start_line": 319,
          "end_line": 324,
          "line_count": 6,
          "signature": "bool SharedArrayBufferObject::byteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "maxByteLengthGetterImpl",
          "type": "method",
          "start_line": 329,
          "end_line": 337,
          "line_count": 9,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "maxByteLengthGetter",
          "type": "method",
          "start_line": 342,
          "end_line": 348,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::maxByteLengthGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growableGetterImpl",
          "type": "method",
          "start_line": 353,
          "end_line": 361,
          "line_count": 9,
          "signature": "bool SharedArrayBufferObject::growableGetterImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv()));"
        },
        {
          "name": "growableGetter",
          "type": "method",
          "start_line": 366,
          "end_line": 372,
          "line_count": 7,
          "signature": "bool SharedArrayBufferObject::growableGetter(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3."
        },
        {
          "name": "growImpl",
          "type": "method",
          "start_line": 377,
          "end_line": 426,
          "line_count": 50,
          "signature": "bool SharedArrayBufferObject::growImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsGrowableSharedArrayBuffer(args.thisv())); Rooted<GrowableSharedArrayBufferObject*> buffer("
        },
        {
          "name": "grow",
          "type": "method",
          "start_line": 431,
          "end_line": 435,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::grow(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "IsSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 437,
          "end_line": 440,
          "line_count": 4,
          "signature": "static bool IsSharedArrayBufferSpecies(JSContext* cx, JSFunction* species) { return IsSelfHostedFunctionWithName( species, cx->names().dollar_SharedArrayBufferSpecies_);"
        },
        {
          "name": "HasBuiltinSharedArrayBufferSpecies",
          "type": "function",
          "start_line": 442,
          "end_line": 462,
          "line_count": 21,
          "signature": "static bool HasBuiltinSharedArrayBufferSpecies(SharedArrayBufferObject* obj, JSContext* cx) { // Ensure `SharedArrayBuffer.prototype.constructor` and"
        },
        {
          "name": "sliceImpl",
          "type": "method",
          "start_line": 469,
          "end_line": 574,
          "line_count": 106,
          "signature": "bool SharedArrayBufferObject::sliceImpl(JSContext* cx, const CallArgs& args) { MOZ_ASSERT(IsSharedArrayBuffer(args.thisv())); "
        },
        {
          "name": "slice",
          "type": "method",
          "start_line": 581,
          "end_line": 585,
          "line_count": 5,
          "signature": "bool SharedArrayBufferObject::slice(JSContext* cx, unsigned argc, Value* vp) { // Steps 1-3. CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "class_constructor",
          "type": "method",
          "start_line": 589,
          "end_line": 666,
          "line_count": 78,
          "signature": "bool SharedArrayBufferObject::class_constructor(JSContext* cx, unsigned argc, Value* vp) { CallArgs args = CallArgsFromVp(argc, vp);"
        },
        {
          "name": "acceptRawBuffer",
          "type": "method",
          "start_line": 755,
          "end_line": 768,
          "line_count": 14,
          "signature": "bool SharedArrayBufferObject::acceptRawBuffer(SharedArrayRawBuffer* buffer, size_t length) { MOZ_ASSERT(!isInitialized());"
        },
        {
          "name": "dropRawBuffer",
          "type": "method",
          "start_line": 770,
          "end_line": 778,
          "line_count": 9,
          "signature": "void SharedArrayBufferObject::dropRawBuffer() { size_t length = byteLengthOrMaxByteLength(); size_t size = SharedArrayMappedSize(isWasm(), length);"
        },
        {
          "name": "Finalize",
          "type": "method",
          "start_line": 786,
          "end_line": 799,
          "line_count": 14,
          "signature": "void SharedArrayBufferObject::Finalize(JS::GCContext* gcx, JSObject* obj) { // Must be foreground finalizable so that we can account for the object. MOZ_ASSERT(gcx->onMainThread());"
        },
        {
          "name": "addSizeOfExcludingThis",
          "type": "method",
          "start_line": 802,
          "end_line": 829,
          "line_count": 28,
          "signature": "void SharedArrayBufferObject::addSizeOfExcludingThis( JSObject* obj, mozilla::MallocSizeOf mallocSizeOf, JS::ClassInfo* info, JS::RuntimeSizes* runtimeSizes) {"
        },
        {
          "name": "copyData",
          "type": "method",
          "start_line": 832,
          "end_line": 846,
          "line_count": 15,
          "signature": "void SharedArrayBufferObject::copyData(ArrayBufferObjectMaybeShared* toBuffer, size_t toIndex, ArrayBufferObjectMaybeShared* fromBuffer,"
        },
        {
          "name": "wasmDiscard",
          "type": "method",
          "start_line": 911,
          "end_line": 916,
          "line_count": 6,
          "signature": "void SharedArrayBufferObject::wasmDiscard(Handle<SharedArrayBufferObject*> buf, uint64_t byteOffset, uint64_t byteLen) {"
        },
        {
          "name": "GetSharedArrayBufferByteLength",
          "type": "method",
          "start_line": 1000,
          "end_line": 1003,
          "line_count": 4,
          "signature": "JS_PUBLIC_API size_t JS::GetSharedArrayBufferByteLength(JSObject* obj) { auto* aobj = obj->maybeUnwrapAs<SharedArrayBufferObject>(); return aobj ? aobj->byteLength() : 0;"
        },
        {
          "name": "GetSharedArrayBufferLengthAndData",
          "type": "method",
          "start_line": 1005,
          "end_line": 1014,
          "line_count": 10,
          "signature": "JS_PUBLIC_API void JS::GetSharedArrayBufferLengthAndData(JSObject* obj, size_t* length, bool* isSharedMemory,"
        },
        {
          "name": "IsSharedArrayBufferObject",
          "type": "method",
          "start_line": 1029,
          "end_line": 1031,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::IsSharedArrayBufferObject(JSObject* obj) { return obj->canUnwrapAs<SharedArrayBufferObject>(); }"
        },
        {
          "name": "ContainsSharedArrayBuffer",
          "type": "method",
          "start_line": 1043,
          "end_line": 1045,
          "line_count": 3,
          "signature": "JS_PUBLIC_API bool JS::ContainsSharedArrayBuffer(JSContext* cx) { return cx->runtime()->hasLiveSABs(); }"
        }
      ],
      "method_names": [
        "WasmSharedArrayAccessibleSize",
        "NonWasmSharedArrayAllocSize",
        "SharedArrayMappedSize",
        "wasmGrowToPagesInPlace",
        "discard",
        "addReference",
        "dropReference",
        "growJS",
        "IsSharedArrayBuffer",
        "IsGrowableSharedArrayBuffer",
        "byteLengthGetterImpl",
        "byteLengthGetter",
        "maxByteLengthGetterImpl",
        "maxByteLengthGetter",
        "growableGetterImpl",
        "growableGetter",
        "growImpl",
        "grow",
        "IsSharedArrayBufferSpecies",
        "HasBuiltinSharedArrayBufferSpecies",
        "sliceImpl",
        "slice",
        "class_constructor",
        "acceptRawBuffer",
        "dropRawBuffer",
        "Finalize",
        "addSizeOfExcludingThis",
        "copyData",
        "wasmDiscard",
        "GetSharedArrayBufferByteLength",
        "GetSharedArrayBufferLengthAndData",
        "IsSharedArrayBufferObject",
        "ContainsSharedArrayBuffer"
      ],
      "method_count": 33
    },
    {
      "filepath": "js/src/wasm/WasmMemory.h",
      "filename": "WasmMemory.h",
      "commit_hash": "75d829afb4b0",
      "full_hash": "75d829afb4b06a3a8b7e91ea15c8a0cf34665fb7",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "ToValType",
          "type": "function",
          "start_line": 41,
          "end_line": 43,
          "line_count": 3,
          "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
        },
        {
          "name": "MinAddressType",
          "type": "function",
          "start_line": 45,
          "end_line": 48,
          "line_count": 4,
          "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
        },
        {
          "name": "fromByteLengthExact",
          "type": "function",
          "start_line": 68,
          "end_line": 87,
          "line_count": 20,
          "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
        },
        {
          "name": "checkedIncrement",
          "type": "function",
          "start_line": 115,
          "end_line": 123,
          "line_count": 9,
          "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
        },
        {
          "name": "MaxMemoryBytes",
          "type": "function",
          "start_line": 139,
          "end_line": 141,
          "line_count": 3,
          "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
        },
        {
          "name": "MaxMemoryPagesValidation",
          "type": "function",
          "start_line": 149,
          "end_line": 152,
          "line_count": 4,
          "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
        },
        {
          "name": "MaxTableElemsValidation",
          "type": "function",
          "start_line": 154,
          "end_line": 157,
          "line_count": 4,
          "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 225,
          "end_line": 229,
          "line_count": 5,
          "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 233,
          "end_line": 239,
          "line_count": 7,
          "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
        }
      ],
      "method_names": [
        "ToValType",
        "MinAddressType",
        "fromByteLengthExact",
        "checkedIncrement",
        "MaxMemoryBytes",
        "MaxMemoryPagesValidation",
        "MaxTableElemsValidation",
        "MemoryBoundsCheck",
        "MemoryBoundsCheck"
      ],
      "method_count": 9
    },
    {
      "filepath": "js/src/wasm/WasmMemory.h",
      "filename": "WasmMemory.h",
      "commit_hash": "13b7086f65cb",
      "full_hash": "13b7086f65cbbbf1fed6e0341cfbdfb309fb962c",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "ToValType",
          "type": "function",
          "start_line": 41,
          "end_line": 43,
          "line_count": 3,
          "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
        },
        {
          "name": "MinAddressType",
          "type": "function",
          "start_line": 45,
          "end_line": 48,
          "line_count": 4,
          "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
        },
        {
          "name": "fromByteLengthExact",
          "type": "function",
          "start_line": 68,
          "end_line": 87,
          "line_count": 20,
          "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
        },
        {
          "name": "checkedIncrement",
          "type": "function",
          "start_line": 108,
          "end_line": 116,
          "line_count": 9,
          "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
        },
        {
          "name": "MaxMemoryBytes",
          "type": "function",
          "start_line": 132,
          "end_line": 134,
          "line_count": 3,
          "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
        },
        {
          "name": "MaxMemoryPagesValidation",
          "type": "function",
          "start_line": 142,
          "end_line": 145,
          "line_count": 4,
          "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
        },
        {
          "name": "MaxTableElemsValidation",
          "type": "function",
          "start_line": 147,
          "end_line": 150,
          "line_count": 4,
          "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 218,
          "end_line": 222,
          "line_count": 5,
          "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 226,
          "end_line": 232,
          "line_count": 7,
          "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
        }
      ],
      "method_names": [
        "ToValType",
        "MinAddressType",
        "fromByteLengthExact",
        "checkedIncrement",
        "MaxMemoryBytes",
        "MaxMemoryPagesValidation",
        "MaxTableElemsValidation",
        "MemoryBoundsCheck",
        "MemoryBoundsCheck"
      ],
      "method_count": 9
    },
    {
      "filepath": "js/src/wasm/WasmMemory.h",
      "filename": "WasmMemory.h",
      "commit_hash": "85d47a33200c",
      "full_hash": "85d47a33200c36a5f91f011f5713c34da79329ee",
      "regressor_bug_id": "1969509",
      "methods": [
        {
          "name": "ToValType",
          "type": "function",
          "start_line": 41,
          "end_line": 43,
          "line_count": 3,
          "signature": "inline ValType ToValType(AddressType at) { return at == AddressType::I64 ? ValType::I64 : ValType::I32; }"
        },
        {
          "name": "MinAddressType",
          "type": "function",
          "start_line": 45,
          "end_line": 48,
          "line_count": 4,
          "signature": "inline AddressType MinAddressType(AddressType a, AddressType b) { return (a == AddressType::I32 || b == AddressType::I32) ? AddressType::I32 : AddressType::I64;"
        },
        {
          "name": "fromByteLengthExact",
          "type": "function",
          "start_line": 68,
          "end_line": 87,
          "line_count": 20,
          "signature": "struct Pages { private: // Pages are specified by limit fields, which in general may be up to 2^48,"
        },
        {
          "name": "checkedIncrement",
          "type": "function",
          "start_line": 108,
          "end_line": 116,
          "line_count": 9,
          "signature": "bool checkedIncrement(Pages delta) { mozilla::CheckedInt<uint64_t> newValue = value_; newValue += delta.value_;"
        },
        {
          "name": "MaxMemoryBytes",
          "type": "function",
          "start_line": 132,
          "end_line": 134,
          "line_count": 3,
          "signature": "static inline size_t MaxMemoryBytes(AddressType t) { return MaxMemoryPages(t).byteLength(); }"
        },
        {
          "name": "MaxMemoryPagesValidation",
          "type": "function",
          "start_line": 142,
          "end_line": 145,
          "line_count": 4,
          "signature": "static inline uint64_t MaxMemoryPagesValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxMemory32PagesValidation : MaxMemory64PagesValidation;"
        },
        {
          "name": "MaxTableElemsValidation",
          "type": "function",
          "start_line": 147,
          "end_line": 150,
          "line_count": 4,
          "signature": "static inline uint64_t MaxTableElemsValidation(AddressType addressType) { return addressType == AddressType::I32 ? MaxTable32ElemsValidation : MaxTable64ElemsValidation;"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 218,
          "end_line": 222,
          "line_count": 5,
          "signature": "static inline bool MemoryBoundsCheck(uint32_t offset, uint32_t len, size_t memLen) { uint64_t offsetLimit = uint64_t(offset) + uint64_t(len);"
        },
        {
          "name": "MemoryBoundsCheck",
          "type": "function",
          "start_line": 226,
          "end_line": 232,
          "line_count": 7,
          "signature": "static inline bool MemoryBoundsCheck(uint64_t offset, uint64_t len, size_t memLen) { uint64_t offsetLimit = offset + len;"
        }
      ],
      "method_names": [
        "ToValType",
        "MinAddressType",
        "fromByteLengthExact",
        "checkedIncrement",
        "MaxMemoryBytes",
        "MaxMemoryPagesValidation",
        "MaxTableElemsValidation",
        "MemoryBoundsCheck",
        "MemoryBoundsCheck"
      ],
      "method_count": 9
    }
  ],
  "stack_info": {
    "source": "step2_socorro",
    "frame_count": 85,
    "filenames": [
      "Jit.cpp",
      "FunctionBinding.h",
      "ObjectOperations-inl.h",
      "CallAndConstruct.cpp",
      "nsWindowsWMain.cpp",
      "Variant.h",
      "nsGlobalWindowInner.cpp",
      "CallbackObject.cpp",
      "nsThreadUtils.cpp",
      "nsAppShell.cpp",
      "CallNonGenericMethod.h",
      "Bootstrap.cpp",
      "NativeObject.cpp",
      "CycleCollectedJSContext.cpp",
      "nsBaseAppShell.cpp",
      "WindowBinding.h",
      "CycleCollectedJSContext.h",
      "nsBrowserApp.cpp",
      "TimeoutExecutor.cpp",
      "exe_common.inl",
      "TimeoutManager.cpp",
      "ThrottledEventQueue.cpp",
      "message_loop.cc",
      "nsIGlobalObject.cpp",
      "nsEmbedFunctions.cpp",
      "BaselineIC.cpp",
      "ArrayBufferObject.cpp",
      "TimerThread.cpp",
      "TaskController.cpp",
      "FunctionBinding.cpp",
      "nsTimerImpl.cpp",
      "Interpreter.cpp",
      "nsThreadUtils.h",
      "IdleRequest.cpp",
      "nsThread.cpp",
      "MessagePump.cpp",
      "Maybe.h"
    ],
    "functions": [
      "GetExistingProperty(JSContext*, JS::Handle<JS::Value>, JS::Handle<js::NativeObject*>, JS::Handle<JS::PropertyKey>, js::PropertyInfoBase<unsigned int>, JS::MutableHandle<JS::Value>)",
      "NS_ProcessNextEvent(nsIThread*, bool)",
      "mozilla::dom::IdleRequest::IdleRun(nsPIDOMWindowInner*, double, bool)",
      "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
      "mozilla::BootstrapImpl::XRE_InitChildProcess(int, char**, XREChildData const*)",
      "js::CallFromStack(JSContext*, JS::CallArgs const&, js::CallReason)",
      "mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::match(nsTimerImpl::Fire::<lambda_10>&&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
      "mozilla::Maybe<js::wasm::Pages>::operator->()",
      "js::RunScript(JSContext*, js::RunState&)",
      "js::InternalCallOrConstruct(JSContext*, JS::CallArgs const&, js::MaybeConstruct, js::CallReason)",
      "mozilla::dom::VoidFunction::Call(mozilla::dom::BindingCallContext&, JS::Handle<JS::Value>, mozilla::ErrorResult&)",
      "XRE_InitChildProcess(int, char**, XREChildData const*)",
      "RtlUserThreadStart",
      "CallGetter(JSContext*, JS::Handle<js::NativeObject*>, JS::Handle<JS::Value>, JS::Handle<JS::PropertyKey>, js::PropertyInfoBase<unsigned int>, JS::MutableHandle<JS::Value>)",
      "mozilla::dom::TimeoutExecutor::Notify(nsITimer*)",
      "nsTimerImpl::Fire::<lambda_11>::operator()(nsCOMPtr<nsITimerCallback> const&) const",
      "mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::matchN(mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >&, nsTimerImpl::Fire::<lambda_10>&&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
      "JS::CallNonGenericMethod(JSContext*, JS::CallArgs const&)",
      "mozilla::detail::VariantImplementation<unsigned char, 1, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::matchN(mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
      "mozilla::CycleCollectedJSContext::LeaveMicroTask()",
      "mozilla::TaskController::ProcessPendingMTTask(bool)",
      "js::NativeGetProperty(JSContext*, JS::Handle<js::NativeObject*>, JS::Handle<JS::Value>, JS::Handle<JS::PropertyKey>, JS::MutableHandle<JS::Value>)",
      "js::GetProperty(JSContext*, JS::Handle<JS::Value>, JS::Handle<js::PropertyName*>, JS::MutableHandle<JS::Value>)",
      "nsTimerImpl::Fire(unsigned long long)",
      "QueuedMicrotask::Run(mozilla::AutoSlowOperation&)",
      "mozilla::CycleCollectedJSContext::PerformMicroTaskCheckPoint(bool)",
      "mozilla::dom::TimeoutManager::RunTimeout(mozilla::TimeStamp const&, mozilla::TimeStamp const&, bool)",
      "js::Interpret(JSContext*, js::RunState&)",
      "mozilla::dom::IdleRequestCallback::Call(mozilla::dom::IdleDeadline&, char const*)",
      "mozilla::RunnableTask::Run()",
      "mozilla::TaskController::DoExecuteNextTaskOnlyMainThreadInternal(mozilla::detail::BaseAutoLock<mozilla::Mutex&> const&)",
      "NativeGetPropertyInline(JSContext*, JS::Handle<js::NativeObject*>, JS::Handle<JS::Value>, JS::Handle<JS::PropertyKey>, IsNameLookup, JS::MutableHandle<JS::Value>)",
      "js::jit::MaybeEnterJit(JSContext*, js::RunState&)",
      "MaybeEnterInterpreterTrampoline(JSContext*, js::RunState&)",
      "mozilla::ThrottledEventQueue::Inner::ExecuteRunnable()",
      "mozilla::ipc::MessagePump::Run(base::MessagePump::Delegate*)",
      "mozilla::TaskController::TaskController::<lambda_6>::operator()() const",
      "nsThread::ProcessNextEvent(bool, bool*)",
      "nsAppShell::Run()",
      "BaseThreadInitThunk",
      "mozilla::dom::VoidFunction::Call(mozilla::ErrorResult&, char const*, mozilla::dom::CallbackObjectBase::ExceptionHandling, JS::Realm*)",
      "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
      "MessageLoop::RunHandler()",
      "nsBaseAppShell::Run()",
      "mozilla::detail::RunnableFunction<`lambda at /builds/worker/checkouts/gecko/xpcom/threads/TaskController.cpp:333:7'>::Run()",
      "CallJSNative(JSContext*, bool (*)(JSContext*, unsigned int, JS::Value*), js::CallReason, JS::CallArgs const&)",
      "mozilla::dom::IdleRequestCallback::Call(mozilla::dom::IdleDeadline&, mozilla::ErrorResult&, char const*, mozilla::dom::CallbackObjectBase::ExceptionHandling, JS::Realm*)",
      "js::jit::DoCallFallback(JSContext*, js::jit::BaselineFrame*, js::jit::ICFallbackStub*, unsigned int, JS::Value*, JS::MutableHandle<JS::Value>)",
      "nsTimerEvent::Run()",
      "JS::Call(JSContext*, JS::Handle<JS::Value>, JS::Handle<JS::Value>, JS::HandleValueArray const&, JS::MutableHandle<JS::Value>)"
    ]
  },
  "matching_results": {
    "file_matches": [
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_filename": "wasm.js",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_filename": "wasm.js",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_filename": "wasm.js",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_filename": "ArrayBufferObject.cpp",
        "matched": true,
        "matched_stack_file": "ArrayBufferObject.cpp"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_filename": "ArrayBufferObject.cpp",
        "matched": true,
        "matched_stack_file": "ArrayBufferObject.cpp"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_filename": "ArrayBufferObject.cpp",
        "matched": true,
        "matched_stack_file": "ArrayBufferObject.cpp"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_filename": "SharedArrayObject.cpp",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_filename": "SharedArrayObject.cpp",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_filename": "SharedArrayObject.cpp",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_filename": "WasmMemory.h",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_filename": "WasmMemory.h",
        "matched": false,
        "matched_stack_file": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_filename": "WasmMemory.h",
        "matched": false,
        "matched_stack_file": null
      }
    ],
    "method_matches": [
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "canRunHugeMemoryTests",
        "regressor_method_normalized": "canrunhugememorytests",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalBinary",
        "regressor_method_normalized": "wasmevalbinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalText",
        "regressor_method_normalized": "wasmevaltext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateBinary",
        "regressor_method_normalized": "wasmvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateBinary",
        "regressor_method_normalized": "wasmfailvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateText",
        "regressor_method_normalized": "wasmvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateText",
        "regressor_method_normalized": "wasmfailvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmCompilationShouldFail",
        "regressor_method_normalized": "wasmcompilationshouldfail",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "mismatchError",
        "regressor_method_normalized": "mismatcherror",
        "matched": true,
        "matched_stack_function": "mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::match(nsTimerImpl::Fire::<lambda_10>&&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "jsify",
        "regressor_method_normalized": "jsify",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "_augmentSrc",
        "regressor_method_normalized": "_augmentsrc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmAssert",
        "regressor_method_normalized": "wasmassert",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPass",
        "regressor_method_normalized": "wasmfullpass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPassI64",
        "regressor_method_normalized": "wasmfullpassi64",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmRunWithDebugger",
        "regressor_method_normalized": "wasmrunwithdebugger",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "fuzzingSafe",
        "regressor_method_normalized": "fuzzingsafe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "iota",
        "regressor_method_normalized": "iota",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "cross",
        "regressor_method_normalized": "cross",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "remove",
        "regressor_method_normalized": "remove",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "permute",
        "regressor_method_normalized": "permute",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "interleave",
        "regressor_method_normalized": "interleave",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertSame",
        "regressor_method_normalized": "assertsame",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertEqResults",
        "regressor_method_normalized": "asserteqresults",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "canRunHugeMemoryTests",
        "regressor_method_normalized": "canrunhugememorytests",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalBinary",
        "regressor_method_normalized": "wasmevalbinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalText",
        "regressor_method_normalized": "wasmevaltext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateBinary",
        "regressor_method_normalized": "wasmvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateBinary",
        "regressor_method_normalized": "wasmfailvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateText",
        "regressor_method_normalized": "wasmvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateText",
        "regressor_method_normalized": "wasmfailvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmCompilationShouldFail",
        "regressor_method_normalized": "wasmcompilationshouldfail",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "mismatchError",
        "regressor_method_normalized": "mismatcherror",
        "matched": true,
        "matched_stack_function": "mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::match(nsTimerImpl::Fire::<lambda_10>&&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "jsify",
        "regressor_method_normalized": "jsify",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "_augmentSrc",
        "regressor_method_normalized": "_augmentsrc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmAssert",
        "regressor_method_normalized": "wasmassert",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPass",
        "regressor_method_normalized": "wasmfullpass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPassI64",
        "regressor_method_normalized": "wasmfullpassi64",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmRunWithDebugger",
        "regressor_method_normalized": "wasmrunwithdebugger",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "fuzzingSafe",
        "regressor_method_normalized": "fuzzingsafe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "iota",
        "regressor_method_normalized": "iota",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "cross",
        "regressor_method_normalized": "cross",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "remove",
        "regressor_method_normalized": "remove",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "permute",
        "regressor_method_normalized": "permute",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "interleave",
        "regressor_method_normalized": "interleave",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertSame",
        "regressor_method_normalized": "assertsame",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertEqResults",
        "regressor_method_normalized": "asserteqresults",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "canRunHugeMemoryTests",
        "regressor_method_normalized": "canrunhugememorytests",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalBinary",
        "regressor_method_normalized": "wasmevalbinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmEvalText",
        "regressor_method_normalized": "wasmevaltext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateBinary",
        "regressor_method_normalized": "wasmvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateBinary",
        "regressor_method_normalized": "wasmfailvalidatebinary",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmValidateText",
        "regressor_method_normalized": "wasmvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFailValidateText",
        "regressor_method_normalized": "wasmfailvalidatetext",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmCompilationShouldFail",
        "regressor_method_normalized": "wasmcompilationshouldfail",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "mismatchError",
        "regressor_method_normalized": "mismatcherror",
        "matched": true,
        "matched_stack_function": "mozilla::Variant<nsTimerImpl::UnknownCallback, nsCOMPtr<nsITimerCallback>, nsCOMPtr<nsIObserver>, nsTimerImpl::FuncCallback, std::function<void (nsITimer*)> >::match(nsTimerImpl::Fire::<lambda_10>&&, nsTimerImpl::Fire::<lambda_11>&&, nsTimerImpl::Fire::<lambda_12>&&, nsTimerImpl::Fire::<lambda_13>&&, nsTimerImpl::Fire::<lambda_14>&&)",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "jsify",
        "regressor_method_normalized": "jsify",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "_augmentSrc",
        "regressor_method_normalized": "_augmentsrc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmAssert",
        "regressor_method_normalized": "wasmassert",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPass",
        "regressor_method_normalized": "wasmfullpass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmFullPassI64",
        "regressor_method_normalized": "wasmfullpassi64",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "wasmRunWithDebugger",
        "regressor_method_normalized": "wasmrunwithdebugger",
        "matched": true,
        "matched_stack_function": "mozilla::ThrottledEventQueue::Inner::Executor::Run()",
        "match_type": "partial_reverse"
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "fuzzingSafe",
        "regressor_method_normalized": "fuzzingsafe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "iota",
        "regressor_method_normalized": "iota",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "cross",
        "regressor_method_normalized": "cross",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "remove",
        "regressor_method_normalized": "remove",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "permute",
        "regressor_method_normalized": "permute",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "interleave",
        "regressor_method_normalized": "interleave",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertSame",
        "regressor_method_normalized": "assertsame",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/jit-test/lib/wasm.js",
        "regressor_method": "assertEqResults",
        "regressor_method_normalized": "asserteqresults",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "WasmReservedBytes",
        "regressor_method_normalized": "wasmreservedbytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CheckArrayBufferTooLarge",
        "regressor_method_normalized": "checkarraybuffertoolarge",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CommitBufferMemory",
        "regressor_method_normalized": "commitbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "UnmapBufferMemory",
        "regressor_method_normalized": "unmapbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBuffer",
        "regressor_method_normalized": "isarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsResizableArrayBuffer",
        "regressor_method_normalized": "isresizablearraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetterImpl",
        "regressor_method_normalized": "resizablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetter",
        "regressor_method_normalized": "resizablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetterImpl",
        "regressor_method_normalized": "detachedgetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetter",
        "regressor_method_normalized": "detachedgetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetterImpl",
        "regressor_method_normalized": "immutablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetter",
        "regressor_method_normalized": "immutablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferImpl",
        "regressor_method_normalized": "transferimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transfer",
        "regressor_method_normalized": "transfer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLengthImpl",
        "regressor_method_normalized": "transfertofixedlengthimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLength",
        "regressor_method_normalized": "transfertofixedlength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutableImpl",
        "regressor_method_normalized": "transfertoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutable",
        "regressor_method_normalized": "transfertoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizeImpl",
        "regressor_method_normalized": "resizeimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBufferSpecies",
        "regressor_method_normalized": "isarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "HasBuiltinArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutableImpl",
        "regressor_method_normalized": "slicetoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutable",
        "regressor_method_normalized": "slicetoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fun_isView",
        "regressor_method_normalized": "fun_isview",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateUninitializedArrayBufferContents",
        "regressor_method_normalized": "allocateuninitializedarraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateArrayBufferContents",
        "regressor_method_normalized": "allocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ReallocateArrayBufferContents",
        "regressor_method_normalized": "reallocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "NewCopiedBufferContents",
        "regressor_method_normalized": "newcopiedbuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detach",
        "regressor_method_normalized": "detach",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " true;\n}\n\nvoid Was",
        "regressor_method_normalized": "true;\n}\n\nvoid was",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " void* ",
        "regressor_method_normalized": "void*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sePoint",
        "regressor_method_normalized": "sepoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " MALLOCED_UNKNO",
        "regressor_method_normalized": "malloced_unkno",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ect::inlineDataPoint",
        "regressor_method_normalized": "inlinedatapoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "asing.\n      brea",
        "regressor_method_normalized": "asing.\n      brea",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ed by, well",
        "regressor_method_normalized": "ed by, well",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "  if (isMapped",
        "regressor_method_normalized": "if (ismapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "MappedSize",
        "regressor_method_normalized": "mappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nAddressType Ar",
        "regressor_method_normalized": "addresstype ar",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "smPages() con",
        "regressor_method_normalized": "smpages con",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ages ArrayBuff",
        "regressor_method_normalized": "ages arraybuff",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ForAsmJS());\n  ",
        "regressor_method_normalized": "forasmjs);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "();\n  }\n ",
        "regressor_method_normalized": ";\n  }",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "is<ArrayBufferObjec",
        "regressor_method_normalized": "is<arraybufferobjec",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "eShared* buf) {\n  ",
        "regressor_method_normalized": "eshared* buf) {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "axPages(\n    const A",
        "regressor_method_normalized": "axpages(\n    const a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic void CheckStealPrecondit",
        "regressor_method_normalized": "tatic void checkstealprecondit",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "from an immutable buffer\");\n ",
        "regressor_method_normalized": "from an immutable buffer\");",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nArrayBufferObject* Arr",
        "regressor_method_normalized": "arraybufferobject* arr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "turn js::gc",
        "regressor_method_normalized": "gc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "lass ",
        "regressor_method_normalized": "lass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "to_,\n   ",
        "regressor_method_normalized": "to_,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Kind::ARRAYBUFFER4 ||\n    ",
        "regressor_method_normalized": "arraybuffer4 ||",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "h the object by repurposing fixe",
        "regressor_method_normalized": "h the object by repurposing fixe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " metadata, proto);\n",
        "regressor_method_normalized": "metadata, proto);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "e allocating the ma",
        "regressor_method_normalized": "e allocating the ma",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Contents contents = buffer->co",
        "regressor_method_normalized": "contents contents = buffer->co",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " != INLINE_DATA",
        "regressor_method_normalized": "!= inline_data",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "mallocSizeOf(buffer.da",
        "regressor_method_normalized": "mallocsizeof(buffer.da",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ">byteLen",
        "regressor_method_normalized": ">bytelen",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "        ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "!nursery.is",
        "regressor_method_normalized": "!nursery.is",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "own) {\n  swi",
        "regressor_method_normalized": "own) {\n  swi",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rrayBuf",
        "regressor_method_normalized": "rraybuf",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\");\n      break;\n ",
        "regressor_method_normalized": "\");\n      break;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " break;\n    }\n  }\n}\n\nv",
        "regressor_method_normalized": "break;\n    }\n  }\n}\n\nv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "_t value) { j",
        "regressor_method_normalized": "_t value) { j",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "first = false;\n     ",
        "regressor_method_normalized": "first = false;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "urseryV",
        "regressor_method_normalized": "urseryv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ject* buffe",
        "regressor_method_normalized": "ject* buffe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fterMinor",
        "regressor_method_normalized": "fterminor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "at every map entr",
        "regressor_method_normalized": "at every map entr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "    vectorSize += r.fr",
        "regressor_method_normalized": "vectorsize += r.fr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ferByteLength(JSObj",
        "regressor_method_normalized": "ferbytelength(jsobj",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic ArrayBufferObject*",
        "regressor_method_normalized": "tatic arraybufferobject*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ge, nullptr,\n    ",
        "regressor_method_normalized": "ge, nullptr,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fferObject>();\n  if (!aobj) {\n",
        "regressor_method_normalized": "fferobject>;\n  if  {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rayBufferWithContents(\n    ",
        "regressor_method_normalized": "raybufferwithcontents(",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                   ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "(obj);\n\n  Rooted<A",
        "regressor_method_normalized": ";\n\n  rooted<a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                                ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ta = aobj->dataPointer();",
        "regressor_method_normalized": "ta = aobj->datapointer;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ffer::ResizableUnsharedClas",
        "regressor_method_normalized": "resizableunsharedclas",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ");\n  if (!unwrapped",
        "regressor_method_normalized": ");\n  if (!unwrapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "WasmReservedBytes",
        "regressor_method_normalized": "wasmreservedbytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CheckArrayBufferTooLarge",
        "regressor_method_normalized": "checkarraybuffertoolarge",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CommitBufferMemory",
        "regressor_method_normalized": "commitbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "UnmapBufferMemory",
        "regressor_method_normalized": "unmapbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBuffer",
        "regressor_method_normalized": "isarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsResizableArrayBuffer",
        "regressor_method_normalized": "isresizablearraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetterImpl",
        "regressor_method_normalized": "resizablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetter",
        "regressor_method_normalized": "resizablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetterImpl",
        "regressor_method_normalized": "detachedgetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetter",
        "regressor_method_normalized": "detachedgetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetterImpl",
        "regressor_method_normalized": "immutablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetter",
        "regressor_method_normalized": "immutablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferImpl",
        "regressor_method_normalized": "transferimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transfer",
        "regressor_method_normalized": "transfer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLengthImpl",
        "regressor_method_normalized": "transfertofixedlengthimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLength",
        "regressor_method_normalized": "transfertofixedlength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutableImpl",
        "regressor_method_normalized": "transfertoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutable",
        "regressor_method_normalized": "transfertoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizeImpl",
        "regressor_method_normalized": "resizeimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBufferSpecies",
        "regressor_method_normalized": "isarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "HasBuiltinArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutableImpl",
        "regressor_method_normalized": "slicetoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutable",
        "regressor_method_normalized": "slicetoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fun_isView",
        "regressor_method_normalized": "fun_isview",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateUninitializedArrayBufferContents",
        "regressor_method_normalized": "allocateuninitializedarraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateArrayBufferContents",
        "regressor_method_normalized": "allocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ReallocateArrayBufferContents",
        "regressor_method_normalized": "reallocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "NewCopiedBufferContents",
        "regressor_method_normalized": "newcopiedbuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detach",
        "regressor_method_normalized": "detach",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " true;\n}\n\nvoid Was",
        "regressor_method_normalized": "true;\n}\n\nvoid was",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " void* ",
        "regressor_method_normalized": "void*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sePoint",
        "regressor_method_normalized": "sepoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " MALLOCED_UNKNO",
        "regressor_method_normalized": "malloced_unkno",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ect::inlineDataPoint",
        "regressor_method_normalized": "inlinedatapoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "asing.\n      brea",
        "regressor_method_normalized": "asing.\n      brea",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ed by, well",
        "regressor_method_normalized": "ed by, well",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "  if (isMapped",
        "regressor_method_normalized": "if (ismapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "MappedSize",
        "regressor_method_normalized": "mappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nAddressType Ar",
        "regressor_method_normalized": "addresstype ar",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "smPages() con",
        "regressor_method_normalized": "smpages con",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ages ArrayBuff",
        "regressor_method_normalized": "ages arraybuff",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ForAsmJS());\n  ",
        "regressor_method_normalized": "forasmjs);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "();\n  }\n ",
        "regressor_method_normalized": ";\n  }",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "is<ArrayBufferObjec",
        "regressor_method_normalized": "is<arraybufferobjec",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "eShared* buf) {\n  ",
        "regressor_method_normalized": "eshared* buf) {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "axPages(\n    const A",
        "regressor_method_normalized": "axpages(\n    const a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic void CheckStealPrecondit",
        "regressor_method_normalized": "tatic void checkstealprecondit",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "from an immutable buffer\");\n ",
        "regressor_method_normalized": "from an immutable buffer\");",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nArrayBufferObject* Arr",
        "regressor_method_normalized": "arraybufferobject* arr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "turn js::gc",
        "regressor_method_normalized": "gc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "lass ",
        "regressor_method_normalized": "lass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "to_,\n   ",
        "regressor_method_normalized": "to_,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Kind::ARRAYBUFFER4 ||\n    ",
        "regressor_method_normalized": "arraybuffer4 ||",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "h the object by repurposing fixe",
        "regressor_method_normalized": "h the object by repurposing fixe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " metadata, proto);\n",
        "regressor_method_normalized": "metadata, proto);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "e allocating the ma",
        "regressor_method_normalized": "e allocating the ma",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Contents contents = buffer->co",
        "regressor_method_normalized": "contents contents = buffer->co",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " != INLINE_DATA",
        "regressor_method_normalized": "!= inline_data",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "mallocSizeOf(buffer.da",
        "regressor_method_normalized": "mallocsizeof(buffer.da",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ">byteLen",
        "regressor_method_normalized": ">bytelen",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "        ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "!nursery.is",
        "regressor_method_normalized": "!nursery.is",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "own) {\n  swi",
        "regressor_method_normalized": "own) {\n  swi",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rrayBuf",
        "regressor_method_normalized": "rraybuf",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\");\n      break;\n ",
        "regressor_method_normalized": "\");\n      break;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " break;\n    }\n  }\n}\n\nv",
        "regressor_method_normalized": "break;\n    }\n  }\n}\n\nv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "_t value) { j",
        "regressor_method_normalized": "_t value) { j",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "first = false;\n     ",
        "regressor_method_normalized": "first = false;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "urseryV",
        "regressor_method_normalized": "urseryv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ject* buffe",
        "regressor_method_normalized": "ject* buffe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fterMinor",
        "regressor_method_normalized": "fterminor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "at every map entr",
        "regressor_method_normalized": "at every map entr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "    vectorSize += r.fr",
        "regressor_method_normalized": "vectorsize += r.fr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ferByteLength(JSObj",
        "regressor_method_normalized": "ferbytelength(jsobj",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic ArrayBufferObject*",
        "regressor_method_normalized": "tatic arraybufferobject*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ge, nullptr,\n    ",
        "regressor_method_normalized": "ge, nullptr,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fferObject>();\n  if (!aobj) {\n",
        "regressor_method_normalized": "fferobject>;\n  if  {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rayBufferWithContents(\n    ",
        "regressor_method_normalized": "raybufferwithcontents(",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                   ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "(obj);\n\n  Rooted<A",
        "regressor_method_normalized": ";\n\n  rooted<a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                                ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ta = aobj->dataPointer();",
        "regressor_method_normalized": "ta = aobj->datapointer;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ffer::ResizableUnsharedClas",
        "regressor_method_normalized": "resizableunsharedclas",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ");\n  if (!unwrapped",
        "regressor_method_normalized": ");\n  if (!unwrapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "WasmReservedBytes",
        "regressor_method_normalized": "wasmreservedbytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CheckArrayBufferTooLarge",
        "regressor_method_normalized": "checkarraybuffertoolarge",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "CommitBufferMemory",
        "regressor_method_normalized": "commitbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "UnmapBufferMemory",
        "regressor_method_normalized": "unmapbuffermemory",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBuffer",
        "regressor_method_normalized": "isarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsResizableArrayBuffer",
        "regressor_method_normalized": "isresizablearraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetterImpl",
        "regressor_method_normalized": "resizablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizableGetter",
        "regressor_method_normalized": "resizablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetterImpl",
        "regressor_method_normalized": "detachedgetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detachedGetter",
        "regressor_method_normalized": "detachedgetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetterImpl",
        "regressor_method_normalized": "immutablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "immutableGetter",
        "regressor_method_normalized": "immutablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferImpl",
        "regressor_method_normalized": "transferimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transfer",
        "regressor_method_normalized": "transfer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLengthImpl",
        "regressor_method_normalized": "transfertofixedlengthimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToFixedLength",
        "regressor_method_normalized": "transfertofixedlength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutableImpl",
        "regressor_method_normalized": "transfertoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "transferToImmutable",
        "regressor_method_normalized": "transfertoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resizeImpl",
        "regressor_method_normalized": "resizeimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "IsArrayBufferSpecies",
        "regressor_method_normalized": "isarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "HasBuiltinArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutableImpl",
        "regressor_method_normalized": "slicetoimmutableimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sliceToImmutable",
        "regressor_method_normalized": "slicetoimmutable",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fun_isView",
        "regressor_method_normalized": "fun_isview",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateUninitializedArrayBufferContents",
        "regressor_method_normalized": "allocateuninitializedarraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "AllocateArrayBufferContents",
        "regressor_method_normalized": "allocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ReallocateArrayBufferContents",
        "regressor_method_normalized": "reallocatearraybuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "NewCopiedBufferContents",
        "regressor_method_normalized": "newcopiedbuffercontents",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "detach",
        "regressor_method_normalized": "detach",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "resize",
        "regressor_method_normalized": "resize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " true;\n}\n\nvoid Was",
        "regressor_method_normalized": "true;\n}\n\nvoid was",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " void* ",
        "regressor_method_normalized": "void*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "sePoint",
        "regressor_method_normalized": "sepoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " MALLOCED_UNKNO",
        "regressor_method_normalized": "malloced_unkno",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ect::inlineDataPoint",
        "regressor_method_normalized": "inlinedatapoint",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "asing.\n      brea",
        "regressor_method_normalized": "asing.\n      brea",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ed by, well",
        "regressor_method_normalized": "ed by, well",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "  if (isMapped",
        "regressor_method_normalized": "if (ismapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "MappedSize",
        "regressor_method_normalized": "mappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nAddressType Ar",
        "regressor_method_normalized": "addresstype ar",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "smPages() con",
        "regressor_method_normalized": "smpages con",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ages ArrayBuff",
        "regressor_method_normalized": "ages arraybuff",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ForAsmJS());\n  ",
        "regressor_method_normalized": "forasmjs);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "();\n  }\n ",
        "regressor_method_normalized": ";\n  }",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "is<ArrayBufferObjec",
        "regressor_method_normalized": "is<arraybufferobjec",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "eShared* buf) {\n  ",
        "regressor_method_normalized": "eshared* buf) {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " ArrayBufferObjectMaybeSha",
        "regressor_method_normalized": "arraybufferobjectmaybesha",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "axPages(\n    const A",
        "regressor_method_normalized": "axpages(\n    const a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic void CheckStealPrecondit",
        "regressor_method_normalized": "tatic void checkstealprecondit",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "from an immutable buffer\");\n ",
        "regressor_method_normalized": "from an immutable buffer\");",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\nArrayBufferObject* Arr",
        "regressor_method_normalized": "arraybufferobject* arr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "turn js::gc",
        "regressor_method_normalized": "gc",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "lass ",
        "regressor_method_normalized": "lass",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "to_,\n   ",
        "regressor_method_normalized": "to_,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Kind::ARRAYBUFFER4 ||\n    ",
        "regressor_method_normalized": "arraybuffer4 ||",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "h the object by repurposing fixe",
        "regressor_method_normalized": "h the object by repurposing fixe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " metadata, proto);\n",
        "regressor_method_normalized": "metadata, proto);",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "e allocating the ma",
        "regressor_method_normalized": "e allocating the ma",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "Contents contents = buffer->co",
        "regressor_method_normalized": "contents contents = buffer->co",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " != INLINE_DATA",
        "regressor_method_normalized": "!= inline_data",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "mallocSizeOf(buffer.da",
        "regressor_method_normalized": "mallocsizeof(buffer.da",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ">byteLen",
        "regressor_method_normalized": ">bytelen",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "        ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "!nursery.is",
        "regressor_method_normalized": "!nursery.is",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "own) {\n  swi",
        "regressor_method_normalized": "own) {\n  swi",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rrayBuf",
        "regressor_method_normalized": "rraybuf",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "\");\n      break;\n ",
        "regressor_method_normalized": "\");\n      break;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": " break;\n    }\n  }\n}\n\nv",
        "regressor_method_normalized": "break;\n    }\n  }\n}\n\nv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "_t value) { j",
        "regressor_method_normalized": "_t value) { j",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "first = false;\n     ",
        "regressor_method_normalized": "first = false;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "urseryV",
        "regressor_method_normalized": "urseryv",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ject* buffe",
        "regressor_method_normalized": "ject* buffe",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fterMinor",
        "regressor_method_normalized": "fterminor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "at every map entr",
        "regressor_method_normalized": "at every map entr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "    vectorSize += r.fr",
        "regressor_method_normalized": "vectorsize += r.fr",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ferByteLength(JSObj",
        "regressor_method_normalized": "ferbytelength(jsobj",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "tatic ArrayBufferObject*",
        "regressor_method_normalized": "tatic arraybufferobject*",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ge, nullptr,\n    ",
        "regressor_method_normalized": "ge, nullptr,",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "fferObject>();\n  if (!aobj) {\n",
        "regressor_method_normalized": "fferobject>;\n  if  {",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "rayBufferWithContents(\n    ",
        "regressor_method_normalized": "raybufferwithcontents(",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                   ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "(obj);\n\n  Rooted<A",
        "regressor_method_normalized": ";\n\n  rooted<a",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "                                ",
        "regressor_method_normalized": "",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ta = aobj->dataPointer();",
        "regressor_method_normalized": "ta = aobj->datapointer;",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": "ffer::ResizableUnsharedClas",
        "regressor_method_normalized": "resizableunsharedclas",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/ArrayBufferObject.cpp",
        "regressor_method": ");\n  if (!unwrapped",
        "regressor_method_normalized": ");\n  if (!unwrapped",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "WasmSharedArrayAccessibleSize",
        "regressor_method_normalized": "wasmsharedarrayaccessiblesize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "NonWasmSharedArrayAllocSize",
        "regressor_method_normalized": "nonwasmsharedarrayallocsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "SharedArrayMappedSize",
        "regressor_method_normalized": "sharedarraymappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmGrowToPagesInPlace",
        "regressor_method_normalized": "wasmgrowtopagesinplace",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "discard",
        "regressor_method_normalized": "discard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addReference",
        "regressor_method_normalized": "addreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropReference",
        "regressor_method_normalized": "dropreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growJS",
        "regressor_method_normalized": "growjs",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBuffer",
        "regressor_method_normalized": "issharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsGrowableSharedArrayBuffer",
        "regressor_method_normalized": "isgrowablesharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetterImpl",
        "regressor_method_normalized": "growablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetter",
        "regressor_method_normalized": "growablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growImpl",
        "regressor_method_normalized": "growimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "grow",
        "regressor_method_normalized": "grow",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferSpecies",
        "regressor_method_normalized": "issharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "HasBuiltinSharedArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinsharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "acceptRawBuffer",
        "regressor_method_normalized": "acceptrawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropRawBuffer",
        "regressor_method_normalized": "droprawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "Finalize",
        "regressor_method_normalized": "finalize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addSizeOfExcludingThis",
        "regressor_method_normalized": "addsizeofexcludingthis",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "copyData",
        "regressor_method_normalized": "copydata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmDiscard",
        "regressor_method_normalized": "wasmdiscard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferByteLength",
        "regressor_method_normalized": "getsharedarraybufferbytelength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferLengthAndData",
        "regressor_method_normalized": "getsharedarraybufferlengthanddata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferObject",
        "regressor_method_normalized": "issharedarraybufferobject",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "ContainsSharedArrayBuffer",
        "regressor_method_normalized": "containssharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "WasmSharedArrayAccessibleSize",
        "regressor_method_normalized": "wasmsharedarrayaccessiblesize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "NonWasmSharedArrayAllocSize",
        "regressor_method_normalized": "nonwasmsharedarrayallocsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "SharedArrayMappedSize",
        "regressor_method_normalized": "sharedarraymappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmGrowToPagesInPlace",
        "regressor_method_normalized": "wasmgrowtopagesinplace",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "discard",
        "regressor_method_normalized": "discard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addReference",
        "regressor_method_normalized": "addreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropReference",
        "regressor_method_normalized": "dropreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growJS",
        "regressor_method_normalized": "growjs",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBuffer",
        "regressor_method_normalized": "issharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsGrowableSharedArrayBuffer",
        "regressor_method_normalized": "isgrowablesharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetterImpl",
        "regressor_method_normalized": "growablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetter",
        "regressor_method_normalized": "growablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growImpl",
        "regressor_method_normalized": "growimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "grow",
        "regressor_method_normalized": "grow",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferSpecies",
        "regressor_method_normalized": "issharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "HasBuiltinSharedArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinsharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "acceptRawBuffer",
        "regressor_method_normalized": "acceptrawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropRawBuffer",
        "regressor_method_normalized": "droprawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "Finalize",
        "regressor_method_normalized": "finalize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addSizeOfExcludingThis",
        "regressor_method_normalized": "addsizeofexcludingthis",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "copyData",
        "regressor_method_normalized": "copydata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmDiscard",
        "regressor_method_normalized": "wasmdiscard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferByteLength",
        "regressor_method_normalized": "getsharedarraybufferbytelength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferLengthAndData",
        "regressor_method_normalized": "getsharedarraybufferlengthanddata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferObject",
        "regressor_method_normalized": "issharedarraybufferobject",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "ContainsSharedArrayBuffer",
        "regressor_method_normalized": "containssharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "WasmSharedArrayAccessibleSize",
        "regressor_method_normalized": "wasmsharedarrayaccessiblesize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "NonWasmSharedArrayAllocSize",
        "regressor_method_normalized": "nonwasmsharedarrayallocsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "SharedArrayMappedSize",
        "regressor_method_normalized": "sharedarraymappedsize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmGrowToPagesInPlace",
        "regressor_method_normalized": "wasmgrowtopagesinplace",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "discard",
        "regressor_method_normalized": "discard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addReference",
        "regressor_method_normalized": "addreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropReference",
        "regressor_method_normalized": "dropreference",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growJS",
        "regressor_method_normalized": "growjs",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBuffer",
        "regressor_method_normalized": "issharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsGrowableSharedArrayBuffer",
        "regressor_method_normalized": "isgrowablesharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetterImpl",
        "regressor_method_normalized": "bytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "byteLengthGetter",
        "regressor_method_normalized": "bytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "partial"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetterImpl",
        "regressor_method_normalized": "maxbytelengthgetterimpl",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetterImpl(JSContext*, JS::CallArgs const&)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "maxByteLengthGetter",
        "regressor_method_normalized": "maxbytelengthgetter",
        "matched": true,
        "matched_stack_function": "js::ArrayBufferObject::maxByteLengthGetter(JSContext*, unsigned int, JS::Value*)",
        "match_type": "exact"
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetterImpl",
        "regressor_method_normalized": "growablegetterimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growableGetter",
        "regressor_method_normalized": "growablegetter",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "growImpl",
        "regressor_method_normalized": "growimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "grow",
        "regressor_method_normalized": "grow",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferSpecies",
        "regressor_method_normalized": "issharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "HasBuiltinSharedArrayBufferSpecies",
        "regressor_method_normalized": "hasbuiltinsharedarraybufferspecies",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "sliceImpl",
        "regressor_method_normalized": "sliceimpl",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "slice",
        "regressor_method_normalized": "slice",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "class_constructor",
        "regressor_method_normalized": "class_constructor",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "acceptRawBuffer",
        "regressor_method_normalized": "acceptrawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "dropRawBuffer",
        "regressor_method_normalized": "droprawbuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "Finalize",
        "regressor_method_normalized": "finalize",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "addSizeOfExcludingThis",
        "regressor_method_normalized": "addsizeofexcludingthis",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "copyData",
        "regressor_method_normalized": "copydata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "wasmDiscard",
        "regressor_method_normalized": "wasmdiscard",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferByteLength",
        "regressor_method_normalized": "getsharedarraybufferbytelength",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "GetSharedArrayBufferLengthAndData",
        "regressor_method_normalized": "getsharedarraybufferlengthanddata",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "IsSharedArrayBufferObject",
        "regressor_method_normalized": "issharedarraybufferobject",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/vm/SharedArrayObject.cpp",
        "regressor_method": "ContainsSharedArrayBuffer",
        "regressor_method_normalized": "containssharedarraybuffer",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "ToValType",
        "regressor_method_normalized": "tovaltype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MinAddressType",
        "regressor_method_normalized": "minaddresstype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "fromByteLengthExact",
        "regressor_method_normalized": "frombytelengthexact",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "checkedIncrement",
        "regressor_method_normalized": "checkedincrement",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryBytes",
        "regressor_method_normalized": "maxmemorybytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryPagesValidation",
        "regressor_method_normalized": "maxmemorypagesvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxTableElemsValidation",
        "regressor_method_normalized": "maxtableelemsvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "ToValType",
        "regressor_method_normalized": "tovaltype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MinAddressType",
        "regressor_method_normalized": "minaddresstype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "fromByteLengthExact",
        "regressor_method_normalized": "frombytelengthexact",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "checkedIncrement",
        "regressor_method_normalized": "checkedincrement",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryBytes",
        "regressor_method_normalized": "maxmemorybytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryPagesValidation",
        "regressor_method_normalized": "maxmemorypagesvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxTableElemsValidation",
        "regressor_method_normalized": "maxtableelemsvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "ToValType",
        "regressor_method_normalized": "tovaltype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MinAddressType",
        "regressor_method_normalized": "minaddresstype",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "fromByteLengthExact",
        "regressor_method_normalized": "frombytelengthexact",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "checkedIncrement",
        "regressor_method_normalized": "checkedincrement",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryBytes",
        "regressor_method_normalized": "maxmemorybytes",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxMemoryPagesValidation",
        "regressor_method_normalized": "maxmemorypagesvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MaxTableElemsValidation",
        "regressor_method_normalized": "maxtableelemsvalidation",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      },
      {
        "regressor_file": "js/src/wasm/WasmMemory.h",
        "regressor_method": "MemoryBoundsCheck",
        "regressor_method_normalized": "memoryboundscheck",
        "matched": false,
        "matched_stack_function": null,
        "match_type": null
      }
    ],
    "statistics": {
      "total_regressor_files": 12,
      "matched_files": 3,
      "file_match_rate": 0.25,
      "total_regressor_methods": 480,
      "matched_methods": 33,
      "method_match_rate": 0.06875,
      "stack_has_filenames": true,
      "stack_has_functions": true,
      "stack_filename_count": 37,
      "stack_function_count": 74
    }
  }
}