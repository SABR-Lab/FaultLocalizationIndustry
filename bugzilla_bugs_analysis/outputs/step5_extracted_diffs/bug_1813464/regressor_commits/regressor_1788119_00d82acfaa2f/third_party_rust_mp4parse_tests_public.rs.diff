# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/mp4parse/tests/public.rs
# Commit: 00d82acfaa2f
# Full Hash: 00d82acfaa2f56095e5033a6905427d43b95eccb
# Author: zaggy1024 <Zaggy1024@gmail.com>
# Date: 2023-01-28 21:11:06
# Regressor Bug: 1788119
# File Overlap Count: 1
# Overlapping Files: Cargo.lock
# Description:
#   Bug 1788119 - Part 4 - Update mp4parse-rust for AVIS support. r=kinetik,glandium,supply-chain-reviewers
#   
#   Depends on D156652
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D156653
# ==============================================================================

diff -r 4ba88410cdf6 -r 00d82acfaa2f third_party/rust/mp4parse/tests/public.rs
--- a/third_party/rust/mp4parse/tests/public.rs	Fri Jan 27 18:35:14 2023 +0000
+++ b/third_party/rust/mp4parse/tests/public.rs	Fri Jan 27 18:35:14 2023 +0000
@@ -2,9 +2,9 @@
 // This Source Code Form is subject to the terms of the Mozilla Public
 // License, v. 2.0. If a copy of the MPL was not distributed with this
 // file, You can obtain one at https://mozilla.org/MPL/2.0/.
-extern crate mp4parse as mp4;
+use mp4parse as mp4;
 
-use mp4::{Error, ParseStrictness, Status};
+use crate::mp4::{ParseStrictness, Status};
 use std::convert::TryInto;
 use std::fs::File;
 use std::io::{Cursor, Read, Seek, SeekFrom};
@@ -53,6 +53,9 @@
 static IMAGE_AVIF_NO_PIXI: &str = "tests/corrupt/no-pixi.avif";
 static IMAGE_AVIF_NO_AV1C: &str = "tests/corrupt/no-av1C.avif";
 static IMAGE_AVIF_NO_ISPE: &str = "tests/corrupt/no-ispe.avif";
+static IMAGE_AVIF_NO_ALPHA_ISPE: &str = "tests/corrupt/no-alpha-ispe.avif";
+static IMAGE_AVIF_TRANSFORM_ORDER: &str = "tests/corrupt/invalid-transformation-order.avif";
+static IMAGE_AVIF_TRANSFORM_BEFORE_ISPE: &str = "tests/corrupt/transformation-before-ispe.avif";
 static IMAGE_AVIF_NO_ALPHA_AV1C: &str = "tests/corrupt/no-alpha-av1C.avif";
 static IMAGE_AVIF_NO_ALPHA_PIXI: &str = "tests/corrupt/no-pixi-for-alpha.avif";
 static IMAGE_AVIF_AV1C_MISSING_ESSENTIAL: &str = "tests/av1C-missing-essential.avif";
@@ -92,8 +95,6 @@
     AVIF_GRID,
     AVIF_GRID_A1LX,
     AVIF_LSEL,
-    AVIF_AVIS_MAJOR_NO_PITM,
-    AVIF_AVIS_MAJOR_WITH_PITM_AND_ALPHA,
     "av1-avif/testFiles/Apple/multilayer_examples/animals_00_multilayer_a1lx.avif",
     "av1-avif/testFiles/Apple/multilayer_examples/animals_00_multilayer_a1op.avif",
     "av1-avif/testFiles/Apple/multilayer_examples/animals_00_multilayer_a1op_lsel.avif",
@@ -104,7 +105,6 @@
     "av1-avif/testFiles/Microsoft/Chimera_10bit_cropped_to_1920x1008.avif",
     "av1-avif/testFiles/Microsoft/Chimera_10bit_cropped_to_1920x1008_with_HDR_metadata.avif",
     "av1-avif/testFiles/Microsoft/Chimera_8bit_cropped_480x256.avif",
-    "av1-avif/testFiles/Netflix/avis/alpha_video.avif",
     "av1-avif/testFiles/Xiph/abandoned_filmgrain.avif",
     "av1-avif/testFiles/Xiph/fruits_2layer_thumbsize.avif",
     "av1-avif/testFiles/Xiph/quebec_3layer_op2.avif",
@@ -112,18 +112,27 @@
     "av1-avif/testFiles/Xiph/tiger_3layer_3res.avif",
     "link-u-avif-sample-images/kimono.crop.avif",
     "link-u-avif-sample-images/kimono.mirror-vertical.rotate270.crop.avif",
-    "link-u-avif-sample-images/star-10bpc-with-alpha.avifs",
-    "link-u-avif-sample-images/star-10bpc.avifs",
-    "link-u-avif-sample-images/star-12bpc-with-alpha.avifs",
-    "link-u-avif-sample-images/star-12bpc.avifs",
-    "link-u-avif-sample-images/star-8bpc-with-alpha.avifs",
-    "link-u-avif-sample-images/star-8bpc.avifs",
 ];
 /// See https://github.com/AOMediaCodec/av1-avif/issues/150
 ///     https://github.com/AOMediaCodec/av1-avif/issues/174
-/// and https://github.com/AOMediaCodec/av1-avif/issues/177
+///     https://github.com/AOMediaCodec/av1-avif/issues/177
+/// and https://github.com/AOMediaCodec/av1-avif/issues/178
 // TODO: make this into a map of expected errors?
 static AV1_AVIF_CORRUPT_IMAGES: &[&str] = &[
+    "av1-avif/testFiles/Link-U/kimono.crop.avif",
+    "av1-avif/testFiles/Link-U/kimono.mirror-horizontal.avif",
+    "av1-avif/testFiles/Link-U/kimono.mirror-vertical.avif",
+    "av1-avif/testFiles/Link-U/kimono.mirror-vertical.rotate270.avif",
+    "av1-avif/testFiles/Link-U/kimono.mirror-vertical.rotate270.crop.avif",
+    "av1-avif/testFiles/Link-U/kimono.rotate90.avif",
+    "av1-avif/testFiles/Link-U/kimono.rotate270.avif",
+    "link-u-avif-sample-images/kimono.crop.avif",
+    "link-u-avif-sample-images/kimono.mirror-horizontal.avif",
+    "link-u-avif-sample-images/kimono.mirror-vertical.avif",
+    "link-u-avif-sample-images/kimono.mirror-vertical.rotate270.avif",
+    "link-u-avif-sample-images/kimono.mirror-vertical.rotate270.crop.avif",
+    "link-u-avif-sample-images/kimono.rotate90.avif",
+    "link-u-avif-sample-images/kimono.rotate270.avif",
     "link-u-avif-sample-images/plum-blossom-large.profile0.10bpc.yuv420.alpha-full.avif",
     "link-u-avif-sample-images/plum-blossom-large.profile0.10bpc.yuv420.alpha-full.monochrome.avif",
     "link-u-avif-sample-images/plum-blossom-large.profile0.10bpc.yuv420.alpha-limited.avif",
@@ -328,7 +337,7 @@
                 assert!(a.samplesize > 0);
                 assert!(a.samplerate > 0.0);
             }
-            mp4::TrackType::Metadata | mp4::TrackType::Unknown => {}
+            _ => {}
         }
     }
 }
@@ -849,7 +858,7 @@
 fn public_mp4_ctts_overflow() {
     let input = &mut File::open("tests/clusterfuzz-testcase-minimized-mp4-6093954524250112")
         .expect("Unknown file");
-    assert_invalid_data(mp4::read_mp4(input), "insufficient data in 'ctts' box");
+    assert_eq!(Status::from(mp4::read_mp4(input)), Status::CttsBadSize);
 }
 
 #[test]
@@ -911,22 +920,6 @@
     assert!(mp4::read_avif(input, ParseStrictness::Normal).is_err());
 }
 
-fn assert_invalid_data<T: std::fmt::Debug>(result: mp4::Result<T>, expected_msg: &str) {
-    match result {
-        Err(Error::InvalidData(msg)) if msg == expected_msg => {}
-        Err(Error::InvalidData(msg)) if msg != expected_msg => {
-            panic!(
-                "Error message mismatch\nExpected: {}\nFound:    {}",
-                expected_msg, msg
-            );
-        }
-        r => panic!(
-            "Expected Err(Error::InvalidData({:?}), found {:?}",
-            expected_msg, r
-        ),
-    }
-}
-
 fn for_strictness_result(
     path: &str,
     check: impl Fn(ParseStrictness, mp4::Result<mp4::AvifContext>),
@@ -944,18 +937,7 @@
 }
 
 /// Check that input generates the expected error only in strict parsing mode
-fn assert_avif_should(path: &str, expected_msg: &str) {
-    let input = &mut File::open(path).expect("Unknown file");
-    assert_invalid_data(mp4::read_avif(input, ParseStrictness::Strict), expected_msg);
-    input.seek(SeekFrom::Start(0)).expect("rewind failed");
-    mp4::read_avif(input, ParseStrictness::Normal).expect("ParseStrictness::Normal failed");
-    input.seek(SeekFrom::Start(0)).expect("rewind failed");
-    mp4::read_avif(input, ParseStrictness::Permissive).expect("ParseStrictness::Permissive failed");
-}
-
-/// Check that input generates the expected error only in strict parsing mode
-// TODO: replace assert_avif_should
-fn assert_avif_should2(path: &str, expected: Status) {
+fn assert_avif_should(path: &str, expected: Status) {
     for_strictness_result(path, |strictness, result| {
         if strictness == ParseStrictness::Strict {
             assert_eq!(expected, Status::from(result));
@@ -966,17 +948,7 @@
 }
 
 /// Check that input generates the expected error unless in permissive parsing mode
-fn assert_avif_shall(path: &str, expected_msg: &str) {
-    let input = &mut File::open(path).expect("Unknown file");
-    assert_invalid_data(mp4::read_avif(input, ParseStrictness::Strict), expected_msg);
-    input.seek(SeekFrom::Start(0)).expect("rewind failed");
-    assert_invalid_data(mp4::read_avif(input, ParseStrictness::Normal), expected_msg);
-    input.seek(SeekFrom::Start(0)).expect("rewind failed");
-    mp4::read_avif(input, ParseStrictness::Permissive).expect("ParseStrictness::Permissive failed");
-}
-
-// TODO: replace assert_avif_shall
-fn assert_avif_shall2(path: &str, expected: Status) {
+fn assert_avif_shall(path: &str, expected: Status) {
     for_strictness_result(path, |strictness, result| {
         if strictness == ParseStrictness::Permissive {
             assert!(result.is_ok());
@@ -992,7 +964,7 @@
 
 #[test]
 fn public_avif_av1c_missing_essential() {
-    assert_avif_should2(IMAGE_AVIF_AV1C_MISSING_ESSENTIAL, Status::TxformNoEssential);
+    assert_avif_should(IMAGE_AVIF_AV1C_MISSING_ESSENTIAL, Status::TxformNoEssential);
 }
 
 #[test]
@@ -1008,36 +980,30 @@
 
 #[test]
 fn public_avif_imir_missing_essential() {
-    assert_avif_should2(IMAGE_AVIF_IMIR_MISSING_ESSENTIAL, Status::TxformNoEssential);
+    assert_avif_should(IMAGE_AVIF_IMIR_MISSING_ESSENTIAL, Status::TxformNoEssential);
 }
 
 #[test]
 fn public_avif_irot_missing_essential() {
-    assert_avif_should2(IMAGE_AVIF_IROT_MISSING_ESSENTIAL, Status::TxformNoEssential);
+    assert_avif_should(IMAGE_AVIF_IROT_MISSING_ESSENTIAL, Status::TxformNoEssential);
 }
 
 #[test]
 fn public_avif_ipma_bad_version() {
-    let expected_msg = "The ipma version 0 should be used unless 32-bit \
-                        item_ID values are needed \
-                        per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1";
-    assert_avif_should(IMAGE_AVIF_IPMA_BAD_VERSION, expected_msg);
+    assert_avif_should(IMAGE_AVIF_IPMA_BAD_VERSION, Status::IpmaBadVersion);
 }
 
 #[test]
 fn public_avif_ipma_bad_flags() {
-    let expected_msg = "Unless there are more than 127 properties in the \
-                        ItemPropertyContainerBox, flags should be equal to 0 \
-                        per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1";
-    assert_avif_should(IMAGE_AVIF_IPMA_BAD_FLAGS, expected_msg);
+    assert_avif_should(IMAGE_AVIF_IPMA_BAD_FLAGS, Status::IpmaFlagsNonzero);
 }
 
 #[test]
 fn public_avif_ipma_duplicate_version_and_flags() {
-    let expected_msg = "There shall be at most one ItemPropertyAssociationbox \
-                        with a given pair of values of version and flags \
-                        per ISOBMFF (ISO 14496-12:2020 § 8.11.14.1";
-    assert_avif_shall(IMAGE_AVIF_IPMA_DUPLICATE_VERSION_AND_FLAGS, expected_msg);
+    assert_avif_shall(
+        IMAGE_AVIF_IPMA_DUPLICATE_VERSION_AND_FLAGS,
+        Status::IpmaBadQuantity,
+    );
 }
 
 #[test]
@@ -1046,101 +1012,90 @@
 // which is kind of annoying to make pass the "should" requirements on flags and version
 // as well as the "shall" requirement on duplicate version and flags
 fn public_avif_ipma_duplicate_item_id() {
-    let expected_msg = "There shall be at most one occurrence of a given item_ID, \
-                        in the set of ItemPropertyAssociationBox boxes \
-                        per ISOBMFF (ISO 14496-12:2020) § 8.11.14.1";
     let input = &mut File::open(IMAGE_AVIF_IPMA_DUPLICATE_ITEM_ID).expect("Unknown file");
-    assert_invalid_data(
-        mp4::read_avif(input, ParseStrictness::Permissive),
-        expected_msg,
+    assert_eq!(
+        Status::from(mp4::read_avif(input, ParseStrictness::Permissive)),
+        Status::IpmaDuplicateItemId
     )
 }
 
 #[test]
 fn public_avif_ipma_invalid_property_index() {
-    let expected_msg = "Invalid property index in ipma";
-    assert_avif_shall(IMAGE_AVIF_IPMA_INVALID_PROPERTY_INDEX, expected_msg);
+    assert_avif_shall(IMAGE_AVIF_IPMA_INVALID_PROPERTY_INDEX, Status::IpmaBadIndex);
 }
 
 #[test]
 fn public_avif_hdlr_first_in_meta() {
-    let expected_msg = "The HandlerBox shall be the first contained box within \
-                        the MetaBox \
-                        per MIAF (ISO 23000-22:2019) § 7.2.1.5";
-    assert_avif_shall(IMAGE_AVIF_NO_HDLR, expected_msg);
-    assert_avif_shall(IMAGE_AVIF_HDLR_NOT_FIRST, expected_msg);
+    assert_avif_shall(IMAGE_AVIF_NO_HDLR, Status::HdlrNotFirst);
+    assert_avif_shall(IMAGE_AVIF_HDLR_NOT_FIRST, Status::HdlrNotFirst);
 }
 
 #[test]
 fn public_avif_hdlr_is_pict() {
-    let expected_msg = "The HandlerBox handler_type must be 'pict' \
-                        per MIAF (ISO 23000-22:2019) § 7.2.1.5";
-    assert_avif_shall(IMAGE_AVIF_HDLR_NOT_PICT, expected_msg);
+    assert_avif_shall(IMAGE_AVIF_HDLR_NOT_PICT, Status::HdlrTypeNotPict);
 }
 
 #[test]
 fn public_avif_hdlr_nonzero_reserved() {
-    let expected_msg = "The HandlerBox 'reserved' fields shall be 0 \
-                        per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2";
     // This is a "should" despite the spec indicating a (somewhat ambiguous)
     // requirement that this field is set to zero.
     // See comments in read_hdlr
-    assert_avif_should(IMAGE_AVIF_HDLR_NONZERO_RESERVED, expected_msg);
+    assert_avif_should(
+        IMAGE_AVIF_HDLR_NONZERO_RESERVED,
+        Status::HdlrReservedNonzero,
+    );
 }
 
 #[test]
 fn public_avif_hdlr_multiple_nul() {
-    let expected_msg = "The HandlerBox 'name' field shall have a NUL byte \
-                        only in the final position \
-                        per ISOBMFF (ISO 14496-12:2020) § 8.4.3.2";
-
     // This is a "should" despite the spec indicating a (somewhat ambiguous)
     // requirement about extra data in boxes
     // See comments in read_hdlr
-    assert_avif_should(IMAGE_AVIF_HDLR_MULTIPLE_NUL, expected_msg);
+    assert_avif_should(IMAGE_AVIF_HDLR_MULTIPLE_NUL, Status::HdlrNameMultipleNul);
 }
 
 #[test]
 fn public_avif_no_mif1() {
-    let expected_msg = "The FileTypeBox should contain 'mif1' in the compatible_brands list \
-                        per MIAF (ISO 23000-22:2019) § 7.2.1.2";
-    assert_avif_should(IMAGE_AVIF_NO_MIF1, expected_msg);
+    assert_avif_should(IMAGE_AVIF_NO_MIF1, Status::MissingMif1Brand);
 }
 
 #[test]
 fn public_avif_no_pitm() {
-    assert_avif_shall2(IMAGE_AVIF_NO_PITM, Status::NoPrimaryItem);
+    assert_avif_shall(IMAGE_AVIF_NO_PITM, Status::PitmMissing);
 }
 
 #[test]
 fn public_avif_pixi_present_for_displayable_images() {
-    let expected_msg = "The pixel information property shall be associated with every image \
-                        that is displayable (not hidden) \
-                        per MIAF (ISO/IEC 23000-22:2019) specification § 7.3.6.6";
     let pixi_test = if cfg!(feature = "missing-pixi-permitted") {
         assert_avif_should
     } else {
         assert_avif_shall
     };
 
-    pixi_test(IMAGE_AVIF_NO_PIXI, expected_msg);
-    pixi_test(IMAGE_AVIF_NO_ALPHA_PIXI, expected_msg);
+    pixi_test(IMAGE_AVIF_NO_PIXI, Status::PixiMissing);
+    pixi_test(IMAGE_AVIF_NO_ALPHA_PIXI, Status::PixiMissing);
 }
 
 #[test]
 fn public_avif_av1c_present_for_av01() {
-    let expected_msg = "One AV1 Item Configuration Property (av1C) \
-                        is mandatory for an image item of type 'av01' \
-                        per AVIF specification § 2.2.1";
-    assert_avif_shall(IMAGE_AVIF_NO_AV1C, expected_msg);
-    assert_avif_shall(IMAGE_AVIF_NO_ALPHA_AV1C, expected_msg);
+    assert_avif_shall(IMAGE_AVIF_NO_AV1C, Status::Av1cMissing);
+    assert_avif_shall(IMAGE_AVIF_NO_ALPHA_AV1C, Status::Av1cMissing);
 }
 
 #[test]
 fn public_avif_ispe_present() {
-    let expected_msg = "Missing 'ispe' property for primary item, required \
-                        per HEIF (ISO/IEC 23008-12:2017) § 6.5.3.1";
-    assert_avif_shall(IMAGE_AVIF_NO_ISPE, expected_msg);
+    assert_avif_shall(IMAGE_AVIF_NO_ISPE, Status::IspeMissing);
+    assert_avif_shall(IMAGE_AVIF_NO_ALPHA_ISPE, Status::IspeMissing);
+}
+
+#[test]
+fn public_avif_transform_before_ispe() {
+    assert_avif_shall(IMAGE_AVIF_TRANSFORM_BEFORE_ISPE, Status::TxformBeforeIspe);
+}
+
+#[test]
+fn public_avif_transform_order() {
+    assert_avif_shall(IMAGE_AVIF_TRANSFORM_ORDER, Status::TxformOrder);
 }
 
 fn assert_unsupported_nonfatal(result: &mp4::Result<mp4::AvifContext>, feature: mp4::Feature) {
@@ -1192,7 +1147,7 @@
 
 #[test]
 fn public_avif_a1lx_marked_essential() {
-    assert_avif_shall2(IMAGE_AVIF_A1LX_MARKED_ESSENTIAL, Status::A1lxEssential);
+    assert_avif_shall(IMAGE_AVIF_A1LX_MARKED_ESSENTIAL, Status::A1lxEssential);
 }
 
 #[test]
@@ -1202,7 +1157,7 @@
 
 #[test]
 fn public_avif_a1op_missing_essential() {
-    assert_avif_shall2(IMAGE_AVIF_A1OP_MISSING_ESSENTIAL, Status::A1opNoEssential);
+    assert_avif_shall(IMAGE_AVIF_A1OP_MISSING_ESSENTIAL, Status::A1opNoEssential);
 }
 
 #[test]
@@ -1212,7 +1167,7 @@
 
 #[test]
 fn public_avif_lsel_missing_essential() {
-    assert_avif_shall2(IMAGE_AVIF_LSEL_MISSING_ESSENTIAL, Status::LselNoEssential);
+    assert_avif_shall(IMAGE_AVIF_LSEL_MISSING_ESSENTIAL, Status::LselNoEssential);
 }
 
 #[test]
@@ -1237,8 +1192,8 @@
     match mp4::read_avif(input, ParseStrictness::Normal) {
         Ok(context) => {
             assert_eq!(context.major_brand, mp4::AVIS_BRAND);
-            assert!(context.unsupported_features.contains(mp4::Feature::Avis));
             assert!(context.primary_item_coded_data().is_none());
+            assert!(context.sequence.is_some());
         }
         Err(e) => panic!("Expected Ok(_), found {:?}", e),
     }
@@ -1250,9 +1205,9 @@
     match mp4::read_avif(input, ParseStrictness::Normal) {
         Ok(context) => {
             assert_eq!(context.major_brand, mp4::AVIS_BRAND);
-            assert!(context.unsupported_features.contains(mp4::Feature::Avis));
             assert!(context.primary_item_coded_data().is_some());
             assert!(context.alpha_item_coded_data().is_some());
+            assert!(context.sequence.is_some());
         }
         Err(e) => panic!("Expected Ok(_), found {:?}", e),
     }
@@ -1260,7 +1215,7 @@
 
 #[test]
 fn public_avif_avis_major_no_moov() {
-    assert_avif_shall2(AVIF_AVIS_MAJOR_NO_MOOV, Status::NoMoov);
+    assert_avif_shall(AVIF_AVIS_MAJOR_NO_MOOV, Status::MoovMissing);
 }
 
 #[test]