# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: third_party/rust/sync15/src/client/coll_update.rs
# Commit: 2147c5c81edf
# Full Hash: 2147c5c81edf9cd56c19e7e92dfebfcd77329978
# Author: Ryan VanderMeulen <ryanvm@gmail.com>
# Date: 2023-03-01 17:52 -0500
# Description:
#   Backed out changesets b05343a5b533 and 57b2cda7e0db (bug 1818349) for causing bug 1819723.
# ==============================================================================

diff -r d59b76766f0d -r 2147c5c81edf third_party/rust/sync15/src/client/coll_update.rs
--- a/third_party/rust/sync15/src/client/coll_update.rs	Wed Mar 01 05:53:30 2023 +0000
+++ b/third_party/rust/sync15/src/client/coll_update.rs	Wed Mar 01 17:52:01 2023 -0500
@@ -8,8 +8,9 @@
 };
 use crate::bso::OutgoingEncryptedBso;
 use crate::engine::{CollectionRequest, IncomingChangeset, OutgoingChangeset};
-use crate::error::{self, Error, Result};
-use crate::{CollectionName, KeyBundle, ServerTimestamp};
+use crate::error::{self, Error, ErrorResponse, Result};
+use crate::{KeyBundle, ServerTimestamp};
+use std::borrow::Cow;
 
 pub fn encrypt_outgoing(
     o: OutgoingChangeset,
@@ -23,8 +24,8 @@
 
 pub fn fetch_incoming(
     client: &Sync15StorageClient,
-    state: &CollState,
-    collection_request: CollectionRequest,
+    state: &mut CollState,
+    collection_request: &CollectionRequest,
 ) -> Result<IncomingChangeset> {
     let collection = collection_request.collection.clone();
     let (records, timestamp) = match client.get_encrypted_records(collection_request)? {
@@ -35,6 +36,8 @@
         } => (record, last_modified),
         other => return Err(other.create_storage_error()),
     };
+    // xxx - duplication below of `timestamp` smells wrong
+    state.last_modified = timestamp;
     let mut result = IncomingChangeset::new(collection, timestamp);
     result.changes.reserve(records.len());
     for record in records {
@@ -51,7 +54,7 @@
 pub struct CollectionUpdate<'a> {
     client: &'a Sync15StorageClient,
     state: &'a CollState,
-    collection: CollectionName,
+    collection: Cow<'static, str>,
     xius: ServerTimestamp,
     to_update: Vec<OutgoingEncryptedBso>,
     fully_atomic: bool,
@@ -61,7 +64,7 @@
     pub fn new(
         client: &'a Sync15StorageClient,
         state: &'a CollState,
-        collection: CollectionName,
+        collection: Cow<'static, str>,
         xius: ServerTimestamp,
         records: Vec<OutgoingEncryptedBso>,
         fully_atomic: bool,
@@ -83,12 +86,19 @@
         fully_atomic: bool,
     ) -> Result<CollectionUpdate<'a>> {
         let collection = changeset.collection.clone();
+        let xius = changeset.timestamp;
+        if xius < state.last_modified {
+            // We know we are going to fail the XIUS check...
+            return Err(Error::StorageHttpError(ErrorResponse::PreconditionFailed {
+                route: collection.into_owned(),
+            }));
+        }
         let to_update = encrypt_outgoing(changeset, &state.key)?;
         Ok(CollectionUpdate::new(
             client,
             state,
             collection,
-            state.last_modified,
+            xius,
             to_update,
             fully_atomic,
         ))