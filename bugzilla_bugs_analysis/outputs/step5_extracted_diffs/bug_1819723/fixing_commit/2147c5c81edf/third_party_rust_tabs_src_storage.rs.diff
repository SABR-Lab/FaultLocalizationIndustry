# ==============================================================================
# FIXING COMMIT DIFF
# ==============================================================================
# File: third_party/rust/tabs/src/storage.rs
# Commit: 2147c5c81edf
# Full Hash: 2147c5c81edf9cd56c19e7e92dfebfcd77329978
# Author: Ryan VanderMeulen <ryanvm@gmail.com>
# Date: 2023-03-01 17:52 -0500
# Description:
#   Backed out changesets b05343a5b533 and 57b2cda7e0db (bug 1818349) for causing bug 1819723.
# ==============================================================================

diff -r d59b76766f0d -r 2147c5c81edf third_party/rust/tabs/src/storage.rs
--- a/third_party/rust/tabs/src/storage.rs	Wed Mar 01 05:53:30 2023 +0000
+++ b/third_party/rust/tabs/src/storage.rs	Wed Mar 01 17:52:01 2023 -0500
@@ -27,8 +27,6 @@
 
 pub(crate) const TABS_CLIENT_TTL: u32 = 15_552_000; // 180 days, same as CLIENTS_TTL
 const FAR_FUTURE: i64 = 4_102_405_200_000; // 2100/01/01
-const MAX_PAYLOAD_SIZE: usize = 512 * 1024; // Twice as big as desktop, still smaller than server max (2MB)
-const MAX_TITLE_CHAR_LENGTH: usize = 512; // We put an upper limit on title sizes for tabs to reduce memory
 
 #[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
 pub struct RemoteTab {
@@ -148,44 +146,30 @@
         self.local_tabs.borrow_mut().replace(local_state);
     }
 
-    // We try our best to fit as many tabs in a payload as possible, this includes
-    // limiting the url history entries, title character count and finally drop enough tabs
-    // until we have small enough payload that the server will accept
     pub fn prepare_local_tabs_for_upload(&self) -> Option<Vec<RemoteTab>> {
         if let Some(local_tabs) = self.local_tabs.borrow().as_ref() {
-            let mut sanitized_tabs: Vec<RemoteTab> = local_tabs
-                .iter()
-                .cloned()
-                .filter_map(|mut tab| {
-                    if tab.url_history.is_empty() || !is_url_syncable(&tab.url_history[0]) {
-                        return None;
-                    }
-                    let mut sanitized_history = Vec::with_capacity(TAB_ENTRIES_LIMIT);
-                    for url in tab.url_history {
-                        if sanitized_history.len() == TAB_ENTRIES_LIMIT {
-                            break;
-                        }
-                        if is_url_syncable(&url) {
-                            sanitized_history.push(url);
+            return Some(
+                local_tabs
+                    .iter()
+                    .cloned()
+                    .filter_map(|mut tab| {
+                        if tab.url_history.is_empty() || !is_url_syncable(&tab.url_history[0]) {
+                            return None;
                         }
-                    }
-
-                    tab.url_history = sanitized_history;
-                    // Truncate the title to some limit and append ellipsis
-                    // to incate that we've truncated
-                    if tab.title.len() > MAX_TITLE_CHAR_LENGTH {
-                        tab.title.truncate(MAX_TITLE_CHAR_LENGTH - 3);
-                        // Append ellipsis char for any client displaying the full title
-                        tab.title.push('\u{2026}');
-                    }
-                    Some(tab)
-                })
-                .collect();
-            // Sort the tabs so when we trim tabs it's the oldest tabs
-            sanitized_tabs.sort_by(|a, b| b.last_used.cmp(&a.last_used));
-            // If trimming the tab length failed for some reason, just return the untrimmed tabs
-            trim_tabs_length(&mut sanitized_tabs, MAX_PAYLOAD_SIZE);
-            return Some(sanitized_tabs);
+                        let mut sanitized_history = Vec::with_capacity(TAB_ENTRIES_LIMIT);
+                        for url in tab.url_history {
+                            if sanitized_history.len() == TAB_ENTRIES_LIMIT {
+                                break;
+                            }
+                            if is_url_syncable(&url) {
+                                sanitized_history.push(url);
+                            }
+                        }
+                        tab.url_history = sanitized_history;
+                        Some(tab)
+                    })
+                    .collect(),
+            );
         }
         None
     }
@@ -346,11 +330,12 @@
     }
 
     pub(crate) fn put_meta(&mut self, key: &str, value: &dyn ToSql) -> Result<()> {
-        let db = self.open_or_create()?;
-        db.execute_cached(
-            "REPLACE INTO moz_meta (key, value) VALUES (:key, :value)",
-            &[(":key", &key as &dyn ToSql), (":value", value)],
-        )?;
+        if let Some(db) = self.open_if_exists()? {
+            db.execute_cached(
+                "REPLACE INTO moz_meta (key, value) VALUES (:key, :value)",
+                &[(":key", &key as &dyn ToSql), (":value", value)],
+            )?;
+        }
         Ok(())
     }
 
@@ -377,28 +362,6 @@
     }
 }
 
-// Trim the amount of tabs in a list to fit the specified memory size
-fn trim_tabs_length(tabs: &mut Vec<RemoteTab>, payload_size_max_bytes: usize) {
-    // Ported from https://searchfox.org/mozilla-central/rev/84fb1c4511312a0b9187f647d90059e3a6dd27f8/services/sync/modules/util.sys.mjs#422
-    // See bug 535326 comment 8 for an explanation of the estimation
-    let max_serialized_size = (payload_size_max_bytes / 4) * 3 - 1500;
-    let size = compute_serialized_size(tabs);
-    if size > max_serialized_size {
-        // Estimate a little more than the direct fraction to maximize packing
-        let cutoff = (tabs.len() * max_serialized_size) / size;
-        tabs.truncate(cutoff);
-
-        // Keep dropping off the last entry until the data fits.
-        while compute_serialized_size(tabs) > max_serialized_size {
-            tabs.pop();
-        }
-    }
-}
-
-fn compute_serialized_size(v: &Vec<RemoteTab>) -> usize {
-    serde_json::to_string(v).unwrap_or_default().len()
-}
-
 // Try to keep in sync with https://searchfox.org/mozilla-central/rev/2ad13433da20a0749e1e9a10ec0ab49b987c2c8e/modules/libpref/init/all.js#3927
 fn is_url_syncable(url: &str) -> bool {
     url.len() <= URI_LENGTH_MAX
@@ -442,15 +405,12 @@
 
     #[test]
     fn test_tabs_meta() {
-        let dir = tempfile::tempdir().unwrap();
-        let db_name = dir.path().join("test_tabs_meta.db");
-        let mut db = TabsStorage::new(db_name);
+        let mut db = TabsStorage::new_with_mem_path("test");
         let test_key = "TEST KEY A";
         let test_value = "TEST VALUE A";
         let test_key2 = "TEST KEY B";
         let test_value2 = "TEST VALUE B";
 
-        // should automatically make the DB if one doesn't exist
         db.put_meta(test_key, &test_value).unwrap();
         db.put_meta(test_key2, &test_value2).unwrap();
 
@@ -545,54 +505,6 @@
             ])
         );
     }
-    #[test]
-    fn test_trimming_tab_title() {
-        let mut storage = TabsStorage::new_with_mem_path("test_prepare_local_tabs_for_upload");
-        assert_eq!(storage.prepare_local_tabs_for_upload(), None);
-        storage.update_local_state(vec![RemoteTab {
-            title: "a".repeat(MAX_TITLE_CHAR_LENGTH + 10), // Fill a string more than max
-            url_history: vec!["https://foo.bar".to_owned()],
-            icon: None,
-            last_used: 0,
-        }]);
-        let mut truncated_title = "a".repeat(MAX_TITLE_CHAR_LENGTH - 3);
-        truncated_title.push('\u{2026}');
-        assert_eq!(
-            storage.prepare_local_tabs_for_upload(),
-            Some(vec![
-                // title trimmed to 50 characters
-                RemoteTab {
-                    title: truncated_title, // title was trimmed to only max char length
-                    url_history: vec!["https://foo.bar".to_owned()],
-                    icon: None,
-                    last_used: 0,
-                },
-            ])
-        );
-    }
-    #[test]
-    fn test_trim_tabs_length() {
-        let mut storage = TabsStorage::new_with_mem_path("test_prepare_local_tabs_for_upload");
-        assert_eq!(storage.prepare_local_tabs_for_upload(), None);
-        let mut too_many_tabs: Vec<RemoteTab> = Vec::new();
-        for n in 1..5000 {
-            too_many_tabs.push(RemoteTab {
-                title: "aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa" //50 characters
-                    .to_owned(),
-                url_history: vec![format!("https://foo{}.bar", n)],
-                icon: None,
-                last_used: 0,
-            });
-        }
-        let tabs_mem_size = compute_serialized_size(&too_many_tabs);
-        // ensure we are definitely over the payload limit
-        assert!(tabs_mem_size > MAX_PAYLOAD_SIZE);
-        // Add our over-the-limit tabs to the local state
-        storage.update_local_state(too_many_tabs.clone());
-        // prepare_local_tabs_for_upload did the trimming we needed to get under payload size
-        let tabs_to_upload = &storage.prepare_local_tabs_for_upload().unwrap();
-        assert!(compute_serialized_size(tabs_to_upload) <= MAX_PAYLOAD_SIZE);
-    }
     // Helper struct to model what's stored in the DB
     struct TabsSQLRecord {
         guid: String,