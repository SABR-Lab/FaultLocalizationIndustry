# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/sync15/src/client/coll_state.rs
# Commit: 2147c5c81edf
# Full Hash: 2147c5c81edf9cd56c19e7e92dfebfcd77329978
# Author: Ryan VanderMeulen <ryanvm@gmail.com>
# Date: 2023-03-01 17:52 -0500
# Regressor Bug: 1818349
# File Overlap Count: 24
# Overlapping Files: third_party/rust/sync15/src/client/coll_update.rs, third_party/rust/sync15/src/client/mod.rs, third_party/rust/sync15/.cargo-checksum.json, third_party/rust/sync15/src/client/sync.rs, Cargo.toml
# Description:
#   Backed out changesets b05343a5b533 and 57b2cda7e0db (bug 1818349) for causing bug 1819723.
# ==============================================================================

diff -r d59b76766f0d -r 2147c5c81edf third_party/rust/sync15/src/client/coll_state.rs
--- a/third_party/rust/sync15/src/client/coll_state.rs	Wed Mar 01 05:53:30 2023 +0000
+++ b/third_party/rust/sync15/src/client/coll_state.rs	Wed Mar 01 17:52:01 2023 -0500
@@ -9,18 +9,17 @@
 use crate::KeyBundle;
 use crate::ServerTimestamp;
 
-/// Holds state for a collection necessary to perform a sync of it. Lives for the lifetime
-/// of a single sync.
+/// Holds state for a collection. In general, only the CollState is
+/// needed to sync a collection (but a valid GlobalState is needed to obtain
+/// a CollState)
 #[derive(Debug, Clone)]
 pub struct CollState {
-    // Info about the server configuration/capabilities
     pub config: InfoConfiguration,
-    // from meta/global, used for XIUS when we POST outgoing record based on this state.
+    // initially from meta/global, updated after an xius POST/PUT.
     pub last_modified: ServerTimestamp,
     pub key: KeyBundle,
 }
 
-/// This mini state-machine helps build a CollState
 #[derive(Debug)]
 pub enum LocalCollState {
     /// The state is unknown, with the EngineSyncAssociation the collection
@@ -39,7 +38,7 @@
     SyncIdChanged { ids: CollSyncIds },
 
     /// The collection is ready to sync.
-    Ready { coll_state: CollState },
+    Ready { key: KeyBundle },
 }
 
 pub struct LocalCollStateMachine<'state> {
@@ -72,27 +71,14 @@
                             if ids.global == meta_global.sync_id
                                 && ids.coll == engine_meta.sync_id =>
                         {
-                            // We are done - build the CollState
                             let coll_keys = CollectionKeys::from_encrypted_payload(
                                 self.global_state.keys.clone(),
                                 self.global_state.keys_timestamp,
                                 self.root_key,
                             )?;
-                            let key = coll_keys.key_for_collection(name).clone();
-                            let name = engine.collection_name();
-                            let config = self.global_state.config.clone();
-                            let last_modified = self
-                                .global_state
-                                .collections
-                                .get(name.as_ref())
-                                .cloned()
-                                .unwrap_or_default();
-                            let coll_state = CollState {
-                                config,
-                                last_modified,
-                                key,
-                            };
-                            Ok(LocalCollState::Ready { coll_state })
+                            Ok(LocalCollState::Ready {
+                                key: coll_keys.key_for_collection(name).clone(),
+                            })
                         }
                         _ => Ok(LocalCollState::SyncIdChanged {
                             ids: CollSyncIds {
@@ -134,8 +120,23 @@
         loop {
             log::trace!("LocalCollState in {:?}", s);
             match s {
-                LocalCollState::Ready { coll_state } => return Ok(Some(coll_state)),
+                LocalCollState::Ready { key } => {
+                    let name = engine.collection_name();
+                    let config = self.global_state.config.clone();
+                    let last_modified = self
+                        .global_state
+                        .collections
+                        .get(name.as_ref())
+                        .cloned()
+                        .unwrap_or_default();
+                    return Ok(Some(CollState {
+                        config,
+                        last_modified,
+                        key,
+                    }));
+                }
                 LocalCollState::Declined | LocalCollState::NoSuchCollection => return Ok(None),
+
                 _ => {
                     count += 1;
                     if count > 10 {
@@ -171,7 +172,7 @@
     use crate::engine::CollectionRequest;
     use crate::engine::{IncomingChangeset, OutgoingChangeset};
     use crate::record_types::{MetaGlobalEngine, MetaGlobalRecord};
-    use crate::{telemetry, CollectionName};
+    use crate::telemetry;
     use anyhow::Result;
     use std::cell::{Cell, RefCell};
     use std::collections::HashMap;
@@ -226,7 +227,7 @@
     }
 
     impl SyncEngine for TestSyncEngine {
-        fn collection_name(&self) -> CollectionName {
+        fn collection_name(&self) -> std::borrow::Cow<'static, str> {
             self.collection_name.into()
         }
 