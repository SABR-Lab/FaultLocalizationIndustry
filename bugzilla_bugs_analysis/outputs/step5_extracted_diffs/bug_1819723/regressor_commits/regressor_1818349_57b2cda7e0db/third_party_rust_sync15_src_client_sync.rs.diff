# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/sync15/src/client/sync.rs
# Commit: 57b2cda7e0db
# Full Hash: 57b2cda7e0db8b07fcc1e09113ce26add178c68a
# Author: Sammy Khamis <skhamis@mozilla.com>
# Date: 2023-03-01 03:56:13
# Regressor Bug: 1818349
# File Overlap Count: 23
# Overlapping Files: third_party/rust/sync15/src/client/coll_update.rs, third_party/rust/sync15/src/client/mod.rs, third_party/rust/sync15/.cargo-checksum.json, third_party/rust/sync15/src/client/sync.rs, Cargo.toml
# Description:
#   Bug 1818349 Part 1: Vendor new version of application-services r=markh
#   
#   Differential Revision: https://phabricator.services.mozilla.com/D171181
# ==============================================================================

diff -r eaf9f12a1481 -r 57b2cda7e0db third_party/rust/sync15/src/client/sync.rs
--- a/third_party/rust/sync15/src/client/sync.rs	Tue Feb 28 04:22:35 2023 +0000
+++ b/third_party/rust/sync15/src/client/sync.rs	Tue Feb 28 05:14:29 2023 +0000
@@ -2,10 +2,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-use super::coll_state::LocalCollStateMachine;
-use super::coll_update::CollectionUpdate;
-use super::state::GlobalState;
-use super::storage_client::Sync15StorageClient;
+use super::{CollectionUpdate, GlobalState, LocalCollStateMachine, Sync15StorageClient};
 use crate::clients_engine;
 use crate::engine::{IncomingChangeset, SyncEngine};
 use crate::error::Error;
@@ -28,18 +25,17 @@
     log::info!("Syncing collection {}", collection);
 
     // our global state machine is ready - get the collection machine going.
-    let mut coll_state =
-        match LocalCollStateMachine::get_state(engine, global_state, root_sync_key)? {
-            Some(coll_state) => coll_state,
-            None => {
-                // XXX - this is either "error" or "declined".
-                log::warn!(
-                    "can't setup for the {} collection - hopefully it works later",
-                    collection
-                );
-                return Ok(());
-            }
-        };
+    let coll_state = match LocalCollStateMachine::get_state(engine, global_state, root_sync_key)? {
+        Some(coll_state) => coll_state,
+        None => {
+            // XXX - this is either "error" or "declined".
+            log::warn!(
+                "can't setup for the {} collection - hopefully it works later",
+                collection
+            );
+            return Ok(());
+        }
+    };
 
     if let Some(clients) = clients {
         engine.prepare_for_sync(&|| clients.get_client_data())?;
@@ -59,7 +55,7 @@
             .map(|(idx, collection_request)| {
                 interruptee.err_if_interrupted()?;
                 let incoming_changes =
-                    super::fetch_incoming(client, &mut coll_state, &collection_request)?;
+                    super::fetch_incoming(client, &coll_state, collection_request)?;
 
                 log::info!(
                     "Downloaded {} remote changes (request {} of {})",
@@ -72,25 +68,18 @@
             .collect::<Result<Vec<_>, Error>>()?
     };
 
-    let new_timestamp = incoming.last().expect("must have >= 1").timestamp;
-    let mut outgoing = engine.apply_incoming(incoming, telem_engine)?;
-
+    let outgoing = engine.apply_incoming(incoming, telem_engine)?;
     interruptee.err_if_interrupted()?;
-    // Bump the timestamps now just incase the upload fails.
-    // xxx - duplication below smells wrong
-    outgoing.timestamp = new_timestamp;
-    coll_state.last_modified = new_timestamp;
-
     log::info!("Uploading {} outgoing changes", outgoing.changes.len());
     let upload_info =
         CollectionUpdate::new_from_changeset(client, &coll_state, outgoing, fully_atomic)?
             .upload()?;
-
     log::info!(
         "Upload success ({} records success, {} records failed)",
         upload_info.successful_ids.len(),
         upload_info.failed_ids.len()
     );
+
     // ideally we'd report this per-batch, but for now, let's just report it
     // as a total.
     let mut telem_outgoing = telemetry::EngineOutgoing::new();