# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/OriginOperations.cpp
# Commit: 9987ebf11f14
# Full Hash: 9987ebf11f141d7e31c958972aee01676d717246
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2025-06-16 09:38:11
# Regressor Bug: 1962133
# File Overlap Count: 14
# Overlapping Files: dom/quota/CommonMetadata.h, dom/quota/DirectoryMetadata.h, dom/quota/test/gtest/TestQuotaManager.cpp, dom/quota/OriginInfo.cpp, dom/quota/QuotaManager.h
# Description:
#   Bug 1962133 - QM: Add accessed flag to FullOriginMetadata and persist it in the origin metadata file; r=dom-storage-reviewers,hsingh
#   
#   This patch introduces a new mAccessed field in OriginStateMetadata, which is
#   inherited by FullOriginMetadata. One of the reserved 32-bit fields in the
#   metadata header is now used as a bitfield, with one bit allocated to represent
# ==============================================================================

diff -r d2ec302b7103 -r 9987ebf11f14 dom/quota/OriginOperations.cpp
--- a/dom/quota/OriginOperations.cpp	Sun Jun 15 21:21:24 2025 +0000
+++ b/dom/quota/OriginOperations.cpp	Sun Jun 15 23:24:14 2025 +0000
@@ -1334,6 +1334,7 @@
   auto originStateMetadata = maybeOriginStateMetadata.extract();
 
   originStateMetadata.mLastAccessTime = PR_Now();
+  originStateMetadata.mAccessed = true;
 
   QM_TRY_INSPECT(const auto& file,
                  aQuotaManager.GetOriginDirectory(mOriginMetadata));
@@ -3512,48 +3513,45 @@
   if (created) {
     // A new origin directory has been created.
 
-    // XXX The code below could be converted to a function which returns the
-    //     timestamp.
-    int64_t timestamp;
-
-    // Update OriginInfo too if temporary origin was already initialized.
+    const auto [timestamp, accessed] = [&aQuotaManager, &originMetadata]() {
+      // Update OriginInfo too if temporary origin was already initialized.
+      if (aQuotaManager.IsTemporaryStorageInitializedInternal()) {
+        if (aQuotaManager.IsTemporaryOriginInitializedInternal(
+                originMetadata)) {
+          // We have a temporary origin which has been initialized without
+          // ensuring respective origin directory. So OriginInfo already exists
+          // and it needs to be updated because the origin directory has been
+          // just created.
+
+          return aQuotaManager.WithOriginInfo(
+              originMetadata, [](const auto& originInfo) {
+                const int64_t timestamp = originInfo->LockedAccessTime();
+                const bool accessed = originInfo->LockedAccessed();
+
+                originInfo->LockedDirectoryCreated();
+
+                return std::make_pair(timestamp, accessed);
+              });
+        }
+      }
+
+      return std::make_pair(/* timestamp */ PR_Now(), /* accessed */ false);
+    }();
+
+    FullOriginMetadata fullOriginMetadata = FullOriginMetadata{
+        originMetadata,
+        OriginStateMetadata{timestamp, accessed, /* aPersisted */ true}};
+
     if (aQuotaManager.IsTemporaryStorageInitializedInternal()) {
-      if (aQuotaManager.IsTemporaryOriginInitializedInternal(originMetadata)) {
-        // We have a temporary origin which has been initialized without
-        // ensuring respective origin directory. So OriginInfo already exists
-        // and it needs to be updated because the origin directory has been
-        // just created.
-
-        timestamp = aQuotaManager.WithOriginInfo(
-            originMetadata, [](const auto& originInfo) {
-              const int64_t timestamp = originInfo->LockedAccessTime();
-
-              originInfo->LockedDirectoryCreated();
-
-              return timestamp;
-            });
-      } else {
-        timestamp = PR_Now();
-      }
-
-      FullOriginMetadata fullOriginMetadata = FullOriginMetadata{
-          originMetadata,
-          OriginStateMetadata{timestamp, /* aPersisted */ true}};
-
       // Usually, infallible operations are placed after fallible ones.
       // However, since we lack atomic support for creating the origin
       // directory along with its metadata, we need to add the origin to cached
       // origins right after directory creation.
       aQuotaManager.AddTemporaryOrigin(fullOriginMetadata);
-    } else {
-      timestamp = PR_Now();
     }
 
     QM_TRY(MOZ_TO_RESULT(QuotaManager::CreateDirectoryMetadata2(
-        *directory,
-        FullOriginMetadata{
-            originMetadata,
-            OriginStateMetadata{timestamp, /* aPersisted */ true}})));
+        *directory, fullOriginMetadata)));
 
     // Update or create OriginInfo too if temporary storage was already
     // initialized.
@@ -3570,46 +3568,50 @@
         // initialized yet. So OriginInfo needs to be created because the
         // origin directory has been just created.
 
-        FullOriginMetadata fullOriginMetadata = FullOriginMetadata{
-            originMetadata,
-            OriginStateMetadata{timestamp, /* aPersisted */ true}};
-
         aQuotaManager.InitQuotaForOrigin(fullOriginMetadata, ClientUsageArray(),
                                          /* aUsageBytes */ 0);
       }
     }
   } else {
-    QM_TRY_INSPECT(
-        const bool& persisted,
+    QM_TRY_UNWRAP(
+        OriginStateMetadata originStateMetadata,
         ([&aQuotaManager, &originMetadata,
-          &directory]() -> mozilla::Result<bool, nsresult> {
-          Nullable<bool> persisted =
-              aQuotaManager.OriginPersisted(originMetadata);
-
-          if (!persisted.IsNull()) {
-            return persisted.Value();
+          &directory]() -> mozilla::Result<OriginStateMetadata, nsresult> {
+          Maybe<OriginStateMetadata> maybeOriginStateMetadata =
+              aQuotaManager.IsTemporaryStorageInitializedInternal()
+                  ? aQuotaManager.GetOriginStateMetadata(originMetadata)
+                  : Nothing();
+
+          if (maybeOriginStateMetadata) {
+            return maybeOriginStateMetadata.extract();
           }
 
           // Get the metadata (restore the metadata file if necessary). We only
-          // use the persisted flag.
+          // use the origin state metadata.
           QM_TRY_INSPECT(
               const auto& metadata,
               aQuotaManager.LoadFullOriginMetadataWithRestore(directory));
 
-          return metadata.mPersisted;
+          return metadata;
         }()));
 
-    if (!persisted) {
+    if (!originStateMetadata.mPersisted) {
       // Set the persisted flag to true and also update origin access time
       // while we are here.
-      QM_TRY(MOZ_TO_RESULT(SaveDirectoryMetadataHeader(
-          *directory, OriginStateMetadata{/* aLastAccessTime */ PR_Now(),
-                                          /* aPersisted */ true})));
+
+      originStateMetadata.mLastAccessTime = PR_Now();
+      originStateMetadata.mPersisted = true;
+
+      QM_TRY(MOZ_TO_RESULT(
+          SaveDirectoryMetadataHeader(*directory, originStateMetadata)));
 
       // Directory metadata has been successfully updated.
       // Update OriginInfo too if temporary storage was already initialized.
       if (aQuotaManager.IsTemporaryStorageInitializedInternal()) {
         aQuotaManager.PersistOrigin(originMetadata);
+
+        // XXX The origin access time should be updated too (but not the
+        // accessed flag).
       }
     }
   }