# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/quota/ActorsParent.cpp
# Commit: d586b6b63319
# Full Hash: d586b6b633191a7c6ff251361b0442d98d06c764
# Author: Jan Varga <jvarga@mozilla.com>
# Date: 2025-06-15 09:03:40
# Regressor Bug: 1962133
# File Overlap Count: 14
# Overlapping Files: dom/quota/CommonMetadata.h, dom/quota/DirectoryMetadata.h, dom/quota/test/gtest/TestQuotaManager.cpp, dom/quota/OriginInfo.cpp, dom/quota/QuotaManager.h
# Description:
#   Bug 1962133 - QM: Add accessed flag to FullOriginMetadata and persist it in the origin metadata file; r=dom-storage-reviewers,hsingh
#   
#   This patch introduces a new mAccessed field in OriginStateMetadata, which is
#   inherited by FullOriginMetadata. One of the reserved 32-bit fields in the
#   metadata header is now used as a bitfield, with one bit allocated to represent
# ==============================================================================

diff -r ca3bdda9fbfd -r d586b6b63319 dom/quota/ActorsParent.cpp
--- a/dom/quota/ActorsParent.cpp	Sat Jun 14 02:29:19 2025 +0000
+++ b/dom/quota/ActorsParent.cpp	Sat Jun 14 02:46:33 2025 +0000
@@ -2704,6 +2704,32 @@
   originInfo->LockedUpdateAccessTime(aTimestamp);
 }
 
+void QuotaManager::UpdateOriginAccessed(const OriginMetadata& aOriginMetadata) {
+  AssertIsOnIOThread();
+  MOZ_ASSERT(aOriginMetadata.mPersistenceType != PERSISTENCE_TYPE_PERSISTENT);
+
+  MutexAutoLock lock(mQuotaMutex);
+
+  GroupInfoPair* pair;
+  if (!mGroupInfoPairs.Get(aOriginMetadata.mGroup, &pair)) {
+    return;
+  }
+
+  RefPtr<GroupInfo> groupInfo =
+      pair->LockedGetGroupInfo(aOriginMetadata.mPersistenceType);
+  if (!groupInfo) {
+    return;
+  }
+
+  RefPtr<OriginInfo> originInfo =
+      groupInfo->LockedGetOriginInfo(aOriginMetadata.mOrigin);
+  if (!originInfo) {
+    return;
+  }
+
+  originInfo->LockedUpdateAccessed();
+}
+
 void QuotaManager::RemoveQuota() {
   AssertIsOnIOThread();
 
@@ -2824,8 +2850,8 @@
                          MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt64, 5));
           QM_TRY_UNWRAP(fullOriginMetadata.mLastAccessTime,
                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt64, 6));
-          QM_TRY_INSPECT(const int64_t& accessed,
-                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt32, 7));
+          QM_TRY_UNWRAP(fullOriginMetadata.mAccessed,
+                        MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt32, 7));
           QM_TRY_UNWRAP(fullOriginMetadata.mPersisted,
                         MOZ_TO_RESULT_INVOKE_MEMBER(stmt, GetInt32, 8));
 
@@ -2849,7 +2875,7 @@
           // ensure consistency is in
           // EnsureTemporaryOriginIsInitializedInternal.)
 
-          if (accessed) {
+          if (fullOriginMetadata.mAccessed) {
             QM_TRY_INSPECT(const auto& directory,
                            GetOriginDirectory(fullOriginMetadata));
 
@@ -2877,6 +2903,12 @@
             QM_TRY(OkIf(fullOriginMetadata.mPersisted == metadata.mPersisted),
                    Err(NS_ERROR_FAILURE));
 
+            // There was a previous regression where mLastAccessTime did not
+            // match. To avoid failing on similar non-critical mismatches, we
+            // wrap this check in a warn-only try macro for now.
+            QM_WARNONLY_TRY(
+                OkIf(fullOriginMetadata.mAccessed == metadata.mAccessed));
+
             QM_TRY(OkIf(fullOriginMetadata.mPersistenceType ==
                         metadata.mPersistenceType),
                    Err(NS_ERROR_FAILURE));
@@ -3406,18 +3438,19 @@
     // respective origin directory. So OriginInfo already exists and it needs
     // to be updated because the origin directory has been just created.
 
-    auto [timestamp, persisted] =
+    auto [timestamp, accessed, persisted] =
         WithOriginInfo(aOriginMetadata, [](const auto& originInfo) {
           const int64_t timestamp = originInfo->LockedAccessTime();
+          const bool accessed = originInfo->LockedAccessed();
           const bool persisted = originInfo->LockedPersisted();
 
           originInfo->LockedDirectoryCreated();
 
-          return std::make_pair(timestamp, persisted);
+          return std::make_tuple(timestamp, accessed, persisted);
         });
 
     FullOriginMetadata fullOriginMetadata{
-        aOriginMetadata, OriginStateMetadata{timestamp, persisted}};
+        aOriginMetadata, OriginStateMetadata{timestamp, accessed, persisted}};
 
     // Usually, infallible operations are placed after fallible ones. However,
     // since we lack atomic support for creating the origin directory along
@@ -6095,7 +6128,8 @@
                 *directory,
                 FullOriginMetadata{
                     aOriginMetadata,
-                    OriginStateMetadata{timestamp, /* aPersisted */ true}})));
+                    OriginStateMetadata{timestamp, /* aAccessed */ false,
+                                        /* aPersisted */ true}})));
 
             return timestamp;
           }
@@ -6112,7 +6146,7 @@
     QM_TRY(MOZ_TO_RESULT(InitializeOrigin(
         directory,
         FullOriginMetadata{aOriginMetadata,
-                           OriginStateMetadata{timestamp,
+                           OriginStateMetadata{timestamp, /* aAccessed */ false,
                                                /* aPersisted */ true}})));
 
     mInitializedOriginsInternal.AppendElement(aOriginMetadata.mOrigin);
@@ -6268,7 +6302,8 @@
       InitQuotaForOrigin(
           FullOriginMetadata{
               aOriginMetadata,
-              OriginStateMetadata{timestamp, /* aPersisted */ false}},
+              OriginStateMetadata{timestamp, /* aAccessed */ false,
+                                  /* aPersisted */ false}},
           ClientUsageArray(), /* aUsageBytes */ 0,
           /* aDirectoryExists */ false);
 
@@ -6281,8 +6316,8 @@
       const int64_t timestamp = PR_Now();
 
       FullOriginMetadata fullOriginMetadata = FullOriginMetadata{
-          aOriginMetadata,
-          OriginStateMetadata{timestamp, /* aPersisted */ false}};
+          aOriginMetadata, OriginStateMetadata{timestamp, /* aAccessed */ false,
+                                               /* aPersisted */ false}};
 
       // Usually, infallible operations are placed after fallible ones.
       // However, since we lack atomic support for creating the origin
@@ -6292,10 +6327,10 @@
 
       // Only creating .metadata-v2 to reduce IO.
       QM_TRY(MOZ_TO_RESULT(CreateDirectoryMetadata2(
-          *directory,
-          FullOriginMetadata{
-              aOriginMetadata,
-              OriginStateMetadata{timestamp, /* aPersisted */ false}})));
+          *directory, FullOriginMetadata{
+                          aOriginMetadata,
+                          OriginStateMetadata{timestamp, /* aAccessed */ false,
+                                              /* aPersisted */ false}})));
 
       // Don't need to traverse the directory, since it's empty.
       InitQuotaForOrigin(fullOriginMetadata, ClientUsageArray(),
@@ -9507,6 +9542,7 @@
       *aOriginProps.mDirectory,
       FullOriginMetadata{aOriginProps.mOriginMetadata,
                          OriginStateMetadata{aOriginProps.mTimestamp,
+                                             /* aAccessed */ true,
                                              /* aPersisted */ false}})));
 
   return NS_OK;