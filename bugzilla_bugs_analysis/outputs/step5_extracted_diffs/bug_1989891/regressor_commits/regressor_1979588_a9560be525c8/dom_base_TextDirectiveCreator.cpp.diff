# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: dom/base/TextDirectiveCreator.cpp
# Commit: a9560be525c8
# Full Hash: a9560be525c8880189debb175e8ad3fa9e56ba49
# Author: Jan-Niklas Jaeschke <jjaschke@mozilla.com>
# Date: 2025-09-10 21:28:29
# Regressor Bug: 1979588
# File Overlap Count: 2
# Overlapping Files: dom/base/test/test_text-fragments-create-text-directive.html, dom/base/TextDirectiveCreator.cpp
# Description:
#   Bug 1979588 - Text Fragments: Correctly deal with long words at end of range for range-based matching. r=dom-core,smaug
#   
#   The range-based approach for creating a text directive uses the word breaker algorithm
#   to identify where to split between `start` and `end` term. If the range ends with a word
#   which is over 50% of the length content, the algorithm would return wordEnd=length,
# ==============================================================================

diff -r b6966486a1dd -r a9560be525c8 dom/base/TextDirectiveCreator.cpp
--- a/dom/base/TextDirectiveCreator.cpp	Wed Sep 10 12:06:33 2025 +0000
+++ b/dom/base/TextDirectiveCreator.cpp	Wed Sep 10 12:33:30 2025 +0000
@@ -236,17 +236,26 @@
             dom_text_fragments_create_text_fragment_exact_match_max_length());
     const auto [wordStart, wordEnd] =
         intl::WordBreaker::FindWord(mStartContent, mStartContent.Length() / 2);
+    // This check is fine because the range content strings have compressed
+    // whitespace, therefore first and last character cannot be whitespace.
     if (wordStart == 0 && wordEnd == mStartContent.Length()) {
-      // This check is fine because the range content strings have compressed
-      // whitespace.
       TEXT_FRAGMENT_LOG(
           "Target range only contains one word, which is longer than the "
           "maximum length. Aborting.");
       return false;
     }
 
-    mEndContent = Substring(mStartContent, wordEnd);
-    mStartContent = Substring(mStartContent, 0, wordEnd);
+    // These cases are hit when `mStartContent` contains a very large (>50% of
+    // the total length) word. Then the wordbreaker would return wordEnd=length
+    // if the long word is at the end of the string. In that case, use the
+    // wordStart position to break, so that mEndContent is not empty.
+    if (wordEnd == mStartContent.Length()) {
+      mEndContent = Substring(mStartContent, wordStart);
+      mStartContent = Substring(mStartContent, 0, wordStart);
+    } else {
+      mEndContent = Substring(mStartContent, wordEnd);
+      mStartContent = Substring(mStartContent, 0, wordEnd);
+    }
   }
   if (mStartContent.Length() > kMaxContextTermLength) {
     TEXT_FRAGMENT_LOG(
@@ -255,6 +264,7 @@
         mStartContent.Length(), kMaxContextTermLength);
     mStartContent = Substring(mStartContent, 0, kMaxContextTermLength);
   }
+  mStartContent.CompressWhitespace();
   mStartFoldCaseContent = mStartContent;
   ToFoldedCase(mStartFoldCaseContent);
   TEXT_FRAGMENT_LOG("Maximum possible start term:\n{}",
@@ -267,6 +277,7 @@
     mEndContent =
         Substring(mEndContent, mEndContent.Length() - kMaxContextTermLength);
   }
+  mEndContent.CompressWhitespace();
   mEndFoldCaseContent = mEndContent;
   ToFoldedCase(mEndFoldCaseContent);
   TEXT_FRAGMENT_LOG("Maximum possible end term:\n{}",