# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: js/loader/ModuleLoaderBase.cpp
# Commit: a20ad923b1f8
# Full Hash: a20ad923b1f84a5ba68c69196dfd02d5157915aa
# Author: Yoshi Cheng-Hao Huang <allstars.chh@gmail.com>
# Date: 2025-09-26 06:07 +0000
# Regressor Bug: 1968890
# File Overlap Count: 2
# Overlapping Files: js/loader/ModuleLoadRequest.cpp, js/loader/ModuleLoaderBase.cpp
# Description:
#   Bug 1968890 - Part 3: Call ModuleErrored in OnFetchFailed. r=jonco
# ==============================================================================

diff -r 70130eac1346 -r a20ad923b1f8 js/loader/ModuleLoaderBase.cpp
--- a/js/loader/ModuleLoaderBase.cpp	Fri Sep 26 06:07:43 2025 +0000
+++ b/js/loader/ModuleLoaderBase.cpp	Fri Sep 26 06:07:43 2025 +0000
@@ -281,7 +281,6 @@
         JS_ReportErrorNumberASCII(aCx, js::GetErrorMessage, nullptr,
                                   JSMSG_DYNAMIC_IMPORT_FAILED, url.get());
       } else {
-        request->LoadFailed();
         loader->OnFetchFailed(request);
         return true;
       }
@@ -698,8 +697,6 @@
                                             bool aSuccess) {
   if (aSuccess) {
     aRequest->ModuleLoaded();
-  } else {
-    aRequest->LoadFailed();
   }
 
   if (!aRequest->IsErrored()) {
@@ -823,6 +820,7 @@
       LOG(("ScriptLoadRequest (%p): found parse error", aRequest));
       aRequest->mModuleScript->SetErrorToRethrow(parseError);
     }
+    DispatchModuleErrored(aRequest);
 
     return;
   }
@@ -862,6 +860,7 @@
       FinishLoadingImportedModuleFailed(cx, payload, error);
     }
 
+    aRequest->ModuleErrored();
     aRequest->ClearImport();
     return;
   }
@@ -881,6 +880,7 @@
   // Step 14.5. Perform FinishLoadingImportedModule(referrer, moduleRequest,
   //            payload, completion).
   FinishLoadingImportedModuleFailed(cx, payload, parseError);
+  aRequest->ModuleErrored();
   aRequest->ClearImport();
 }
 
@@ -898,7 +898,13 @@
 };
 
 void ModuleLoaderBase::DispatchModuleErrored(ModuleLoadRequest* aRequest) {
-  if (aRequest->HasScriptLoadContext()) {
+  if (aRequest->HasScriptLoadContext() &&
+      aRequest->GetScriptLoadContext()->mIsInline) {
+    // https://html.spec.whatwg.org/#prepare-the-script-element
+    // Step 32. If el does not have a src content attribute:
+    //   2. "module".3.1
+    //   Queue an element task on the networking task source given el to
+    //   perform the following steps:
     CycleCollectedJSContext* context = CycleCollectedJSContext::Get();
     RefPtr<ModuleErroredRunnable> runnable =
         new ModuleErroredRunnable(aRequest);
@@ -998,7 +1004,6 @@
       }
 
       moduleScript->SetParseError(error);
-      DispatchModuleErrored(aRequest);
       return NS_OK;
     }
 
@@ -1014,7 +1019,6 @@
         aRequest->mModuleScript = nullptr;
         return rv;
       }
-      DispatchModuleErrored(aRequest);
       return NS_OK;
     }
   }
