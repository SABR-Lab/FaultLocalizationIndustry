# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/ipc/RemoteAccessible.cpp
# Commit: 09de143215a1
# Full Hash: 09de143215a13a22dcb2cd53d4ed1dfb60480c82
# Author: Atila Butkovits <abutkovits@mozilla.com>
# Date: 2025-09-30 02:48 +0300
# Regressor Bug: 1987945
# File Overlap Count: 2
# Overlapping Files: accessible/base/nsCoreUtils.cpp, accessible/tests/browser/relations/browser_anchor_positioning.js
# Description:
#   Revert "Bug 1987945: apply code formatting via Lando" for causing bustages at DocAccessible.cpp.
# ==============================================================================

diff -r 826eb4ac00dd -r 09de143215a1 accessible/ipc/RemoteAccessible.cpp
--- a/accessible/ipc/RemoteAccessible.cpp	Tue Sep 30 02:35:22 2025 +0300
+++ b/accessible/ipc/RemoteAccessible.cpp	Tue Sep 30 02:48:50 2025 +0300
@@ -1193,76 +1193,25 @@
     return rel;
   }
 
-  auto GetDirectRelationFromCache =
-      [](const RemoteAccessible* aAcc,
-         RelationType aRelType) -> Maybe<const nsTArray<uint64_t>&> {
-    for (const auto& data : kRelationTypeAtoms) {
-      if (data.mType != aRelType ||
-          (data.mValidTag && aAcc->TagName() != data.mValidTag)) {
-        continue;
-      }
-
-      if (auto maybeIds = aAcc->mCachedFields->GetAttribute<nsTArray<uint64_t>>(
-              data.mAtom)) {
-        if (data.mAtom == nsGkAtoms::target) {
-          if (!maybeIds->IsEmpty() &&
-              !nsAccUtils::IsValidDetailsTargetForAnchor(
-                  aAcc->mDoc->GetAccessible(maybeIds->ElementAt(0)), aAcc)) {
-            continue;
-          }
-        }
-
-        // Relations can have several cached attributes in order of precedence,
-        // if one is found we use it.
-        return maybeIds;
-      }
+  for (const auto& data : kRelationTypeAtoms) {
+    if (data.mType != aType ||
+        (data.mValidTag && TagName() != data.mValidTag)) {
+      continue;
     }
 
-    return Nothing();
-  };
-
-  if (auto maybeIds = GetDirectRelationFromCache(this, aType)) {
-    rel.AppendIter(new RemoteAccIterator(*maybeIds, Document()));
+    if (auto maybeIds =
+            mCachedFields->GetAttribute<nsTArray<uint64_t>>(data.mAtom)) {
+      rel.AppendIter(new RemoteAccIterator(*maybeIds, Document()));
+    }
+    // Each relation type has only one relevant cached attribute,
+    // so break after we've handled the attr for this type,
+    // even if we didn't find any targets.
+    break;
   }
 
   if (auto accRelMapEntry = mDoc->mReverseRelations.Lookup(ID())) {
-    // A list of candidate IDs that might have a relation of type aType
-    // pointing to us. We keep a list so we don't evaluate or add the same
-    // target more than once.
-    nsTArray<uint64_t> relationCandidateIds;
-    for (const auto& data : kRelationTypeAtoms) {
-      if (data.mReverseType != aType) {
-        continue;
-      }
-
-      auto reverseIdsEntry = accRelMapEntry.Data().Lookup(&data);
-      if (!reverseIdsEntry) {
-        continue;
-      }
-
-      for (auto id : *reverseIdsEntry) {
-        if (relationCandidateIds.Contains(id)) {
-          // If multiple attributes point to the same target, only
-          // include it once. Our assumption is that there is a 1:1
-          // relationship between relation and reverse relation *types*.
-          continue;
-        }
-        relationCandidateIds.AppendElement(id);
-
-        RemoteAccessible* relatedAcc = mDoc->GetAccessible(id);
-        if (!relatedAcc) {
-          continue;
-        }
-
-        if (auto maybeIds =
-                GetDirectRelationFromCache(relatedAcc, data.mType)) {
-          if (maybeIds->Contains(ID())) {
-            // The candidate target has the forward relation type pointing
-            // to us, so we can add it as a target.
-            rel.AppendTarget(relatedAcc);
-          }
-        }
-      }
+    if (auto reverseIdsEntry = accRelMapEntry.Data().Lookup(aType)) {
+      rel.AppendIter(new RemoteAccIterator(reverseIdsEntry.Data(), Document()));
     }
   }
 
@@ -1397,7 +1346,7 @@
             // the following assert, we don't have parity on implicit/explicit
             // rels and something is wrong.
             nsTArray<uint64_t>& reverseRelIDs =
-                reverseRels->LookupOrInsert(&data);
+                reverseRels->LookupOrInsert(data.mReverseType);
             //  There might be other reverse relations stored for this acc, so
             //  remove our ID instead of deleting the array entirely.
             DebugOnly<bool> removed = reverseRelIDs.RemoveElement(ID());
@@ -1430,8 +1379,9 @@
       const nsTArray<uint64_t>& newIDs =
           *mCachedFields->GetAttribute<nsTArray<uint64_t>>(data.mAtom);
       for (uint64_t id : newIDs) {
-        auto& relations = Document()->mReverseRelations.LookupOrInsert(id);
-        nsTArray<uint64_t>& ids = relations.LookupOrInsert(&data);
+        nsTHashMap<RelationType, nsTArray<uint64_t>>& relations =
+            Document()->mReverseRelations.LookupOrInsert(id);
+        nsTArray<uint64_t>& ids = relations.LookupOrInsert(data.mReverseType);
         ids.AppendElement(ID());
       }
     }
@@ -1445,7 +1395,7 @@
   }
   for (auto const& data : kRelationTypeAtoms) {
     // Fetch the list of targets for this reverse relation
-    auto reverseTargetList = reverseRels->Lookup(&data);
+    auto reverseTargetList = reverseRels->Lookup(data.mReverseType);
     if (!reverseTargetList) {
       continue;
     }