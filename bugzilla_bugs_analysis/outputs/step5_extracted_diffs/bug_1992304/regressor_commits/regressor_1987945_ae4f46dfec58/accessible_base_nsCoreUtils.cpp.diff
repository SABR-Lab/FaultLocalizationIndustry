# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: accessible/base/nsCoreUtils.cpp
# Commit: ae4f46dfec58
# Full Hash: ae4f46dfec5886a64797be7073f63bda296c3541
# Author: Eitan Isaacson <eitan@monotonous.org>
# Date: 2025-09-29 20:54 +0000
# Regressor Bug: 1987945
# File Overlap Count: 2
# Overlapping Files: accessible/base/nsCoreUtils.cpp, accessible/tests/browser/relations/browser_anchor_positioning.js
# Description:
#   Bug 1987945 - P1: Implement details relationship for CSS anchored local accessibles. r=Jamie,emilio
# ==============================================================================

diff -r 55449173b0e6 -r ae4f46dfec58 accessible/base/nsCoreUtils.cpp
--- a/accessible/base/nsCoreUtils.cpp	Mon Sep 29 20:39:23 2025 +0000
+++ b/accessible/base/nsCoreUtils.cpp	Mon Sep 29 20:54:29 2025 +0000
@@ -674,3 +674,70 @@
       nsIFrame::TrailingWhitespace::Trim);
   return text.mString.IsEmpty();
 }
+
+nsIFrame* nsCoreUtils::GetAnchorForPositionedFrame(
+    const PresShell* aPresShell, const nsIFrame* aPositionedFrame) {
+  if (!aPositionedFrame ||
+      !aPositionedFrame->Style()->HasAnchorPosReference()) {
+    return nullptr;
+  }
+
+  const nsAtom* anchorName = nullptr;
+  AnchorPosReferenceData* referencedAnchors =
+      aPositionedFrame->GetProperty(nsIFrame::AnchorPosReferences());
+
+  if (!referencedAnchors) {
+    return nullptr;
+  }
+
+  for (auto& entry : *referencedAnchors) {
+    if (entry.GetData().isNothing()) {
+      continue;
+    }
+
+    if (anchorName && entry.GetKey() != anchorName) {
+      // Multiple anchors referenced.
+      return nullptr;
+    }
+
+    anchorName = entry.GetKey();
+  }
+
+  return anchorName
+             ? aPresShell->GetAnchorPosAnchor(anchorName, aPositionedFrame)
+             : nullptr;
+}
+
+nsIFrame* nsCoreUtils::GetPositionedFrameForAnchor(
+    const PresShell* aPresShell, const nsIFrame* aAnchorFrame) {
+  if (!aAnchorFrame) {
+    return nullptr;
+  }
+
+  nsIFrame* positionedFrame = nullptr;
+  const auto* styleDisp = aAnchorFrame->StyleDisplay();
+  if (styleDisp->HasAnchorName()) {
+    for (auto& name : styleDisp->mAnchorName.AsSpan()) {
+      for (nsIFrame* frame : aPresShell->GetAnchorPosPositioned()) {
+        // Bug 1990069: We need to iterate over all positioned frames in doc and
+        // check their referenced anchors because we don't store reverse mapping
+        // from anchor to positioned frame.
+        const auto* referencedAnchors =
+            frame->GetProperty(nsIFrame::AnchorPosReferences());
+        const auto* data = referencedAnchors->Lookup(name.AsAtom());
+        if (data && *data && data->ref().mOrigin) {
+          if (aAnchorFrame ==
+              aPresShell->GetAnchorPosAnchor(name.AsAtom(), frame)) {
+            if (positionedFrame) {
+              // Multiple positioned frames reference this anchor.
+              return nullptr;
+            }
+            positionedFrame = frame;
+          }
+        }
+      }
+    }
+  }
+
+  return positionedFrame;
+}