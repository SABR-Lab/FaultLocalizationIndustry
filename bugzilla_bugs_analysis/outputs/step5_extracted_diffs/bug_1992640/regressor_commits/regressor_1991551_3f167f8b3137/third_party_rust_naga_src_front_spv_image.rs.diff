# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/front/spv/image.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/naga/src/front/spv/image.rs
--- a/third_party/rust/naga/src/front/spv/image.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/naga/src/front/spv/image.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -48,6 +48,8 @@
     pub project: bool,
     /// Depth comparison sampling with a reference value.
     pub compare: bool,
+    /// Gather sampling: Operates on four samples of one channel.
+    pub gather: bool,
 }
 
 enum ExtraCoordinate {
@@ -500,10 +502,10 @@
         let result_id = self.next()?;
         let sampled_image_id = self.next()?;
         let coordinate_id = self.next()?;
-        let dref_id = if options.compare {
-            Some(self.next()?)
-        } else {
-            None
+        let (component_id, dref_id) = match (options.gather, options.compare) {
+            (true, false) => (Some(self.next()?), None),
+            (_, true) => (None, Some(self.next()?)),
+            (_, _) => (None, None),
         };
         let span = self.span_from_with_op(start);
 
@@ -629,6 +631,58 @@
             self.get_expr_handle(coordinate_id, coord_lexp, ctx, emitter, block, body_idx);
         let coord_type_handle = self.lookup_type.lookup(coord_lexp.type_id)?.handle;
 
+        let gather = match (options.gather, component_id) {
+            (true, Some(component_id)) => {
+                let component_lexp = self.lookup_expression.lookup(component_id)?;
+
+                let component_value = match ctx.expressions[component_lexp.handle] {
+                    // VUID-StandaloneSpirv-OpImageGather-04664:
+                    // The “Component” operand of OpImageGather, and OpImageSparseGather must be the
+                    // <id> of a constant instruction.
+                    crate::Expression::Constant(const_handle) => {
+                        let constant = &ctx.module.constants[const_handle];
+                        match ctx.module.global_expressions[constant.init] {
+                            // SPIR-V specification: "It must be a 32-bit integer type scalar."
+                            crate::Expression::Literal(crate::Literal::U32(value)) => value,
+                            crate::Expression::Literal(crate::Literal::I32(value)) => value as u32,
+                            _ => {
+                                log::error!(
+                                    "Image gather component constant must be a 32-bit integer literal"
+                                );
+                                return Err(Error::InvalidOperand);
+                            }
+                        }
+                    }
+                    _ => {
+                        log::error!("Image gather component must be a constant");
+                        return Err(Error::InvalidOperand);
+                    }
+                };
+
+                debug_assert_eq!(level, crate::SampleLevel::Auto);
+                level = crate::SampleLevel::Zero;
+
+                // SPIR-V specification: "Behavior is undefined if its value is not 0, 1, 2 or 3."
+                match component_value {
+                    0 => Some(crate::SwizzleComponent::X),
+                    1 => Some(crate::SwizzleComponent::Y),
+                    2 => Some(crate::SwizzleComponent::Z),
+                    3 => Some(crate::SwizzleComponent::W),
+                    other => {
+                        log::error!("Invalid gather component operand: {other}");
+                        return Err(Error::InvalidOperand);
+                    }
+                }
+            }
+            (true, None) => {
+                debug_assert_eq!(level, crate::SampleLevel::Auto);
+                level = crate::SampleLevel::Zero;
+
+                Some(crate::SwizzleComponent::X)
+            }
+            (_, _) => None,
+        };
+
         let sampling_bit = if options.compare {
             SamplingFlags::COMPARISON
         } else {
@@ -745,7 +799,7 @@
         let expr = crate::Expression::ImageSample {
             image: si_lexp.image,
             sampler: si_lexp.sampler,
-            gather: None, //TODO
+            gather,
             coordinate,
             array_index,
             offset,