# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/ron/src/de/mod.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/ron/src/de/mod.rs
--- a/third_party/rust/ron/src/de/mod.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/ron/src/de/mod.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,15 +1,17 @@
 /// Deserialization module.
-use std::{
-    io::{self, Write},
-    str,
+use alloc::{
+    borrow::ToOwned,
+    string::{String, ToString},
+    vec::Vec,
 };
+use core::str;
 
 use serde::{
     de::{self, DeserializeSeed, Deserializer as _, Visitor},
     Deserialize,
 };
 
-pub use crate::error::{Error, Position, SpannedError};
+pub use crate::error::{Error, Position, Span, SpannedError};
 use crate::{
     error::{Result, SpannedResult},
     extensions::Extensions,
@@ -17,15 +19,15 @@
     parse::{NewtypeMode, ParsedByteStr, ParsedStr, Parser, StructType, TupleMode},
 };
 
+#[cfg(feature = "std")]
+use std::io;
+
 mod id;
 mod tag;
 #[cfg(test)]
 mod tests;
 mod value;
 
-const SERDE_CONTENT_CANARY: &str = "serde::__private::de::content::Content";
-const SERDE_TAG_KEY_CANARY: &str = "serde::__private::de::content::TagOrContent";
-
 /// The RON deserializer.
 ///
 /// If you just want to simply deserialize a value,
@@ -78,7 +80,10 @@
 
         Err(SpannedError {
             code: err.into(),
-            position: Position::from_src_end(valid_input),
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position::from_src_end(valid_input),
+            },
         })
     }
 
@@ -100,6 +105,7 @@
 
 /// A convenience function for building a deserializer
 /// and deserializing a value of type `T` from a reader.
+#[cfg(feature = "std")]
 pub fn from_reader<R, T>(rdr: R) -> SpannedResult<T>
 where
     R: io::Read,
@@ -170,8 +176,8 @@
     {
         // HACK: switch to JSON enum semantics for JSON content
         // Robust impl blocked on https://github.com/serde-rs/serde/pull/2420
-        let is_serde_content = std::any::type_name::<V::Value>() == SERDE_CONTENT_CANARY
-            || std::any::type_name::<V::Value>() == SERDE_TAG_KEY_CANARY;
+        let is_serde_content =
+            is_serde_content::<V::Value>() || is_serde_tag_or_content::<V::Value>();
 
         let old_serde_content_newtype = self.serde_content_newtype;
         self.serde_content_newtype = false;
@@ -323,13 +329,13 @@
         } else if self.parser.consume_str("()") {
             return visitor.visit_unit();
         } else if self.parser.consume_ident("inf") || self.parser.consume_ident("inff32") {
-            return visitor.visit_f32(std::f32::INFINITY);
+            return visitor.visit_f32(core::f32::INFINITY);
         } else if self.parser.consume_ident("inff64") {
-            return visitor.visit_f64(std::f64::INFINITY);
+            return visitor.visit_f64(core::f64::INFINITY);
         } else if self.parser.consume_ident("NaN") || self.parser.consume_ident("NaNf32") {
-            return visitor.visit_f32(std::f32::NAN);
+            return visitor.visit_f32(core::f32::NAN);
         } else if self.parser.consume_ident("NaNf64") {
-            return visitor.visit_f64(std::f64::NAN);
+            return visitor.visit_f64(core::f64::NAN);
         }
 
         // `skip_identifier` does not change state if it fails
@@ -670,25 +676,21 @@
     where
         V: Visitor<'de>,
     {
-        // Detect `#[serde(flatten)]` as a struct deserialised as a map
-        const SERDE_FLATTEN_CANARY: &[u8] = b"struct ";
-
         struct VisitorExpecting<V>(V);
-        impl<'de, V: Visitor<'de>> std::fmt::Display for VisitorExpecting<&'_ V> {
-            fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
+        impl<'de, V: Visitor<'de>> core::fmt::Display for VisitorExpecting<&'_ V> {
+            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                 self.0.expecting(fmt)
             }
         }
 
         self.newtype_variant = false;
 
-        let mut canary_buffer = [0u8; SERDE_FLATTEN_CANARY.len()];
-        std::mem::drop(write!(
-            canary_buffer.as_mut(),
-            "{}",
-            VisitorExpecting(&visitor)
-        ));
-        let terminator = if canary_buffer == SERDE_FLATTEN_CANARY {
+        // TODO: Avoid allocating to perform this check.
+        let serde_flatten_canary = VisitorExpecting(&visitor)
+            .to_string()
+            .starts_with("struct ");
+
+        let terminator = if serde_flatten_canary {
             Terminator::MapAsStruct
         } else {
             Terminator::Map
@@ -852,8 +854,7 @@
         K: DeserializeSeed<'de>,
     {
         if self.has_element()? {
-            self.inside_internally_tagged_enum =
-                std::any::type_name::<K::Value>() == SERDE_TAG_KEY_CANARY;
+            self.inside_internally_tagged_enum = is_serde_tag_or_content::<K::Value>();
 
             match self.terminator {
                 Terminator::Struct => guard_recursion! { self.de =>
@@ -878,9 +879,7 @@
         if self.de.parser.consume_char(':') {
             self.de.parser.skip_ws()?;
 
-            let res = if self.inside_internally_tagged_enum
-                && std::any::type_name::<V::Value>() != SERDE_CONTENT_CANARY
-            {
+            let res = if self.inside_internally_tagged_enum && !is_serde_content::<V::Value>() {
                 guard_recursion! { self.de =>
                     seed.deserialize(&mut tag::Deserializer::new(&mut *self.de))?
                 }
@@ -1047,3 +1046,19 @@
         result
     }
 }
+
+// ensure that these are the same as in the 449_tagged_enum test
+fn is_serde_content<T>() -> bool {
+    matches!(
+        core::any::type_name::<T>(),
+        "serde::__private::de::content::Content" | "serde::__private::de::content::Content<'_>"
+    )
+}
+
+fn is_serde_tag_or_content<T>() -> bool {
+    matches!(
+        core::any::type_name::<T>(),
+        "serde::__private::de::content::TagOrContent"
+            | "serde::__private::de::content::TagOrContent<'_>"
+    )
+}