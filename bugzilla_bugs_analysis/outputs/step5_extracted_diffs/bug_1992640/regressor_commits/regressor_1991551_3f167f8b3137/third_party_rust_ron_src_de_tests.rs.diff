# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/ron/src/de/tests.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/ron/src/de/tests.rs
--- a/third_party/rust/ron/src/de/tests.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/ron/src/de/tests.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -1,29 +1,43 @@
+use alloc::{
+    borrow::ToOwned,
+    format,
+    string::{String, ToString},
+    vec,
+    vec::Vec,
+};
+
 use serde_bytes;
 use serde_derive::Deserialize;
 
 use crate::{
-    error::{Error, Position, SpannedError, SpannedResult},
+    error::{Error, Position, Span, SpannedError, SpannedResult},
     parse::Parser,
     value::Number,
 };
 
+#[cfg(feature = "internal-span-substring-test")]
+use crate::util::span_substring::check_error_span_inclusive;
+
+#[cfg(feature = "internal-span-substring-test")]
+use crate::util::span_substring::check_error_span_exclusive;
+
 #[derive(Debug, PartialEq, Deserialize)]
 struct EmptyStruct1;
 
 #[derive(Debug, PartialEq, Deserialize)]
 struct EmptyStruct2 {}
 
-#[derive(Debug, PartialEq, Deserialize)]
+#[derive(Clone, Debug, PartialEq, Deserialize)]
 struct NewType(i32);
 
-#[derive(Debug, PartialEq, Deserialize)]
+#[derive(Clone, Copy, Debug, PartialEq, Deserialize)]
 #[serde(rename = "")]
 struct UnnamedNewType(i32);
 
 #[derive(Debug, PartialEq, Deserialize)]
 struct TupleStruct(f32, f32);
 
-#[derive(Debug, PartialEq, Deserialize)]
+#[derive(Clone, Debug, PartialEq, Deserialize)]
 #[serde(rename = "")]
 struct UnnamedTupleStruct(f32, f32);
 
@@ -64,28 +78,44 @@
     check_from_str_bytes_reader("NewType(42)", Ok(NewType(42)));
     check_from_str_bytes_reader("(33)", Ok(NewType(33)));
 
-    check_from_str_bytes_reader::<NewType>(
-        "NewType",
-        Err(SpannedError {
-            code: Error::ExpectedNamedStructLike("NewType"),
-            position: Position { line: 1, col: 8 },
-        }),
-    );
+    let bogus_struct = "NewType";
+    let expected_err = Err(SpannedError {
+        code: Error::ExpectedNamedStructLike("NewType"),
+        span: Span {
+            start: Position { line: 1, col: 1 },
+            end: Position { line: 1, col: 8 },
+        },
+    });
+    check_from_str_bytes_reader::<NewType>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<NewType>(bogus_struct, expected_err, "NewType");
+
     check_from_str_bytes_reader::<UnnamedNewType>(
         "",
         Err(SpannedError {
             code: Error::ExpectedStructLike,
-            position: Position { line: 1, col: 1 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 1 },
+            },
         }),
     );
     check_from_str_bytes_reader("(33)", Ok(UnnamedNewType(33)));
-    check_from_str_bytes_reader::<UnnamedNewType>(
-        "Newtype",
-        Err(SpannedError {
-            code: Error::ExpectedNamedStructLike(""),
-            position: Position { line: 1, col: 8 },
-        }),
-    );
+
+    let bogus_struct = "NewType";
+    let expected_err = Err(SpannedError {
+        code: Error::ExpectedNamedStructLike(""),
+        span: Span {
+            start: Position { line: 1, col: 1 },
+            end: Position { line: 1, col: 8 },
+        },
+    });
+
+    check_from_str_bytes_reader::<UnnamedNewType>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<UnnamedNewType>(bogus_struct, expected_err, "NewType");
 
     check_from_str_bytes_reader("TupleStruct(2,5,)", Ok(TupleStruct(2.0, 5.0)));
     check_from_str_bytes_reader("(3,4)", Ok(TupleStruct(3.0, 4.0)));
@@ -93,22 +123,35 @@
         "",
         Err(SpannedError {
             code: Error::ExpectedNamedStructLike("TupleStruct"),
-            position: Position { line: 1, col: 1 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 1 },
+            },
         }),
     );
-    check_from_str_bytes_reader::<UnnamedTupleStruct>(
-        "TupleStruct(2,5,)",
-        Err(SpannedError {
-            code: Error::ExpectedNamedStructLike(""),
-            position: Position { line: 1, col: 12 },
-        }),
-    );
+
+    let bogus_struct = "TupleStruct(2,5,)";
+    let expected_err = Err(SpannedError {
+        code: Error::ExpectedNamedStructLike(""),
+        span: Span {
+            start: Position { line: 1, col: 1 },
+            end: Position { line: 1, col: 12 },
+        },
+    });
+    check_from_str_bytes_reader::<UnnamedTupleStruct>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<UnnamedTupleStruct>(bogus_struct, expected_err, "TupleStruct");
+
     check_from_str_bytes_reader("(3,4)", Ok(UnnamedTupleStruct(3.0, 4.0)));
     check_from_str_bytes_reader::<UnnamedTupleStruct>(
         "",
         Err(SpannedError {
             code: Error::ExpectedStructLike,
-            position: Position { line: 1, col: 1 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 1 },
+            },
         }),
     );
 }
@@ -126,7 +169,7 @@
                 type Value = LimitedStruct;
 
                 // GRCOV_EXCL_START
-                fn expecting(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
+                fn expecting(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                     fmt.write_str("struct LimitedStruct")
                 }
                 // GRCOV_EXCL_STOP
@@ -147,7 +190,10 @@
         "(",
         Err(SpannedError {
             code: Error::ExpectedStructLikeEnd,
-            position: Position { line: 1, col: 2 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 2 },
+            },
         }),
     )
 }
@@ -165,7 +211,7 @@
                 type Value = LimitedSeq;
 
                 // GRCOV_EXCL_START
-                fn expecting(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
+                fn expecting(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                     fmt.write_str("an empty sequence")
                 }
                 // GRCOV_EXCL_STOP
@@ -186,7 +232,10 @@
         "[",
         Err(SpannedError {
             code: Error::ExpectedArrayEnd,
-            position: Position { line: 1, col: 2 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 2 },
+            },
         }),
     );
 
@@ -212,7 +261,7 @@
                 type Value = LimitedMap;
 
                 // GRCOV_EXCL_START
-                fn expecting(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
+                fn expecting(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                     fmt.write_str("an empty map")
                 }
                 // GRCOV_EXCL_STOP
@@ -233,7 +282,10 @@
         "{",
         Err(SpannedError {
             code: Error::ExpectedMapEnd,
-            position: Position { line: 1, col: 2 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 2 },
+            },
         }),
     );
 
@@ -260,7 +312,10 @@
         "B",
         Err(SpannedError {
             code: Error::ExpectedStructLike,
-            position: Position { line: 1, col: 2 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 2 },
+            },
         }),
     );
     check_from_str_bytes_reader("C(true,3.5,)", Ok(MyEnum::C(true, 3.5)));
@@ -276,6 +331,7 @@
     check_from_str_bytes_reader("[2,3,4,]", Ok([2, 3, 4i32].to_vec()));
 }
 
+#[cfg(feature = "std")]
 #[test]
 fn test_map() {
     use std::collections::HashMap;
@@ -339,26 +395,44 @@
     );
 }
 
-fn err<T>(kind: Error, line: usize, col: usize) -> SpannedResult<T> {
+fn err<T>(
+    kind: Error,
+    (line_start, col_start): (usize, usize),
+    (line_end, col_end): (usize, usize),
+) -> SpannedResult<T> {
     Err(SpannedError {
         code: kind,
-        position: Position { line, col },
+        span: Span {
+            start: Position {
+                line: line_start,
+                col: col_start,
+            },
+            end: Position {
+                line: line_end,
+                col: col_end,
+            },
+        },
     })
 }
 
 #[test]
 fn test_err_wrong_value() {
+    #[cfg(feature = "std")]
     use std::collections::HashMap;
 
-    check_from_str_bytes_reader::<f32>("'c'", err(Error::ExpectedFloat, 1, 1));
-    check_from_str_bytes_reader::<String>("'c'", err(Error::ExpectedString, 1, 1));
-    check_from_str_bytes_reader::<HashMap<u32, u32>>("'c'", err(Error::ExpectedMap, 1, 1));
-    check_from_str_bytes_reader::<[u8; 5]>("'c'", err(Error::ExpectedStructLike, 1, 1));
-    check_from_str_bytes_reader::<Vec<u32>>("'c'", err(Error::ExpectedArray, 1, 1));
-    check_from_str_bytes_reader::<MyEnum>("'c'", err(Error::ExpectedIdentifier, 1, 1));
+    check_from_str_bytes_reader::<f32>("'c'", err(Error::ExpectedFloat, (1, 1), (1, 1)));
+    check_from_str_bytes_reader::<String>("'c'", err(Error::ExpectedString, (1, 1), (1, 1)));
+    #[cfg(feature = "std")]
+    check_from_str_bytes_reader::<HashMap<u32, u32>>(
+        "'c'",
+        err(Error::ExpectedMap, (1, 1), (1, 1)),
+    );
+    check_from_str_bytes_reader::<[u8; 5]>("'c'", err(Error::ExpectedStructLike, (1, 1), (1, 1)));
+    check_from_str_bytes_reader::<Vec<u32>>("'c'", err(Error::ExpectedArray, (1, 1), (1, 1)));
+    check_from_str_bytes_reader::<MyEnum>("'c'", err(Error::ExpectedIdentifier, (1, 1), (1, 1)));
     check_from_str_bytes_reader::<MyStruct>(
         "'c'",
-        err(Error::ExpectedNamedStructLike("MyStruct"), 1, 1),
+        err(Error::ExpectedNamedStructLike("MyStruct"), (1, 1), (1, 1)),
     );
     check_from_str_bytes_reader::<MyStruct>(
         "NotMyStruct(x: 4, y: 2)",
@@ -367,21 +441,31 @@
                 expected: "MyStruct",
                 found: String::from("NotMyStruct"),
             },
-            1,
-            12,
+            (1, 1),
+            (1, 12),
         ),
     );
-    check_from_str_bytes_reader::<(u8, bool)>("'c'", err(Error::ExpectedStructLike, 1, 1));
-    check_from_str_bytes_reader::<bool>("notabool", err(Error::ExpectedBoolean, 1, 1));
+    check_from_str_bytes_reader::<(u8, bool)>(
+        "'c'",
+        err(Error::ExpectedStructLike, (1, 1), (1, 1)),
+    );
+    check_from_str_bytes_reader::<bool>("notabool", err(Error::ExpectedBoolean, (1, 1), (1, 1)));
+
+    let bogus_struct = "MyStruct(\n    x: true)";
+    let expected_err = err(Error::ExpectedFloat, (2, 7), (2, 8));
+
+    check_from_str_bytes_reader::<MyStruct>(bogus_struct, expected_err.clone());
 
-    check_from_str_bytes_reader::<MyStruct>(
-        "MyStruct(\n    x: true)",
-        err(Error::ExpectedFloat, 2, 8),
-    );
-    check_from_str_bytes_reader::<MyStruct>(
-        "MyStruct(\n    x: 3.5, \n    y:)",
-        err(Error::ExpectedFloat, 3, 7),
-    );
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_inclusive::<MyStruct>(bogus_struct, expected_err, " t");
+
+    let bogus_struct = "MyStruct(\n    x: 3.5, \n    y:)";
+    let expected_err = err(Error::ExpectedFloat, (3, 7), (3, 7));
+
+    check_from_str_bytes_reader::<MyStruct>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_inclusive::<MyStruct>(bogus_struct, expected_err, ")");
 }
 
 #[test]
@@ -394,7 +478,7 @@
 
 #[test]
 fn untagged() {
-    #[derive(Deserialize, Debug, PartialEq)]
+    #[derive(Deserialize, Clone, Debug, PartialEq)]
     #[serde(untagged)]
     enum Untagged {
         U8(u8),
@@ -410,13 +494,19 @@
     // - serde content uses deserialize_any, which retriggers the struct type check
     // - struct type check inside a serde content performs a full newtype check
     // - newtype check fails on the unclosed struct
-    check_from_str_bytes_reader::<Untagged>(
-        "Value(()",
-        Err(crate::error::SpannedError {
-            code: crate::Error::Eof,
-            position: crate::error::Position { line: 1, col: 9 },
-        }),
-    );
+    //
+    let bogus_struct = "Value(()";
+    let expected_err = Err(crate::error::SpannedError {
+        code: crate::Error::Eof,
+        span: Span {
+            start: Position { line: 1, col: 8 },
+            end: crate::error::Position { line: 1, col: 9 },
+        },
+    });
+    check_from_str_bytes_reader::<Untagged>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<Untagged>(bogus_struct, expected_err, ")");
 }
 
 #[test]
@@ -435,34 +525,51 @@
 
 #[test]
 fn forgot_apostrophes() {
-    check_from_str_bytes_reader::<(i32, String)>(
-        "(4, \"Hello)",
-        Err(SpannedError {
-            code: Error::ExpectedStringEnd,
-            position: Position { line: 1, col: 6 },
-        }),
-    );
+    let bogus_struct = "(4, \"Hello)";
+    let expected_err = Err(SpannedError {
+        code: Error::ExpectedStringEnd,
+        span: Span {
+            start: Position { line: 1, col: 5 },
+            end: Position { line: 1, col: 6 },
+        },
+    });
+
+    check_from_str_bytes_reader::<(i32, String)>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<(i32, String)>(bogus_struct, expected_err, "\"");
 }
 
 #[test]
 fn expected_attribute() {
-    check_from_str_bytes_reader::<String>("#\"Hello\"", err(Error::ExpectedAttribute, 1, 2));
+    check_from_str_bytes_reader::<String>(
+        "#\"Hello\"",
+        err(Error::ExpectedAttribute, (1, 2), (1, 2)),
+    );
 }
 
 #[test]
 fn expected_attribute_end() {
-    check_from_str_bytes_reader::<String>(
-        "#![enable(unwrap_newtypes) \"Hello\"",
-        err(Error::ExpectedAttributeEnd, 1, 28),
-    );
+    let bogus_struct = "#![enable(unwrap_newtypes) \"Hello\"";
+    let expected_err = err(Error::ExpectedAttributeEnd, (1, 27), (1, 28));
+    check_from_str_bytes_reader::<String>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_inclusive::<String>(bogus_struct, expected_err, " \"");
 }
 
 #[test]
 fn invalid_attribute() {
-    check_from_str_bytes_reader::<String>(
-        "#![enable(invalid)] \"Hello\"",
-        err(Error::NoSuchExtension("invalid".to_string()), 1, 18),
+    let bogus_struct = "#![enable(invalid)] \"Hello\"";
+    let expected_err = err(
+        Error::NoSuchExtension("invalid".to_string()),
+        (1, 11),
+        (1, 18),
     );
+    check_from_str_bytes_reader::<String>(bogus_struct, expected_err.clone());
+
+    #[cfg(feature = "internal-span-substring-test")]
+    check_error_span_exclusive::<String>(bogus_struct, expected_err, "invalid");
 }
 
 #[test]
@@ -537,7 +644,7 @@
 }
 
 fn check_de_any_number<
-    T: Copy + PartialEq + std::fmt::Debug + Into<Number> + serde::de::DeserializeOwned,
+    T: Copy + PartialEq + core::fmt::Debug + Into<Number> + serde::de::DeserializeOwned,
 >(
     s: &str,
     cmp: T,
@@ -626,7 +733,7 @@
     check_from_str_bytes_reader("  EmptyStruct1", Ok(EmptyStruct1));
 }
 
-fn check_from_str_bytes_reader<T: serde::de::DeserializeOwned + PartialEq + std::fmt::Debug>(
+fn check_from_str_bytes_reader<T: serde::de::DeserializeOwned + PartialEq + core::fmt::Debug>(
     ron: &str,
     check: SpannedResult<T>,
 ) {
@@ -636,8 +743,11 @@
     let res_bytes = super::from_bytes::<T>(ron.as_bytes());
     assert_eq!(res_bytes, check);
 
-    let res_reader = super::from_reader::<&[u8], T>(ron.as_bytes());
-    assert_eq!(res_reader, check);
+    #[cfg(feature = "std")]
+    {
+        let res_reader = super::from_reader::<&[u8], T>(ron.as_bytes());
+        assert_eq!(res_reader, check);
+    }
 }
 
 #[test]
@@ -665,14 +775,20 @@
         "true_",
         Err(SpannedError {
             code: Error::ExpectedBoolean,
-            position: Position { line: 1, col: 1 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 1 },
+            },
         }),
     );
     check_from_str_bytes_reader::<bool>(
         "false_",
         Err(SpannedError {
             code: Error::ExpectedBoolean,
-            position: Position { line: 1, col: 1 },
+            span: Span {
+                start: Position { line: 1, col: 1 },
+                end: Position { line: 1, col: 1 },
+            },
         }),
     );
 }