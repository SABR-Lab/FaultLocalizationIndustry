# ==============================================================================
# REGRESSOR COMMIT DIFF
# ==============================================================================
# File: third_party/rust/naga/src/back/msl/writer.rs
# Commit: 3f167f8b3137
# Full Hash: 3f167f8b313749f50f135e189e5854bef7ac0c73
# Author: Erich Gubler <erichdongubler@gmail.com>
# Date: 2025-10-03 18:08 +0000
# Regressor Bug: 1991551
# File Overlap Count: 23
# Overlapping Files: third_party/rust/wgpu-hal/Cargo.toml, supply-chain/audits.toml, third_party/rust/naga/src/back/spv/writer.rs, third_party/rust/naga/src/back/msl/writer.rs, third_party/rust/wgpu-types/src/lib.rs
# Description:
#   Bug 1991551 - build(webgpu): update WGPU to 8c4aebc0c1b75e3f7412dfc180745a0717fc30ec r=webgpu-reviewers,supply-chain-reviewers,nical
# ==============================================================================

diff -r 823439f307a0 -r 3f167f8b3137 third_party/rust/naga/src/back/msl/writer.rs
--- a/third_party/rust/naga/src/back/msl/writer.rs	Fri Oct 03 18:01:30 2025 +0000
+++ b/third_party/rust/naga/src/back/msl/writer.rs	Fri Oct 03 18:08:29 2025 +0000
@@ -6359,7 +6359,7 @@
         struct VertexBufferMappingResolved<'a> {
             id: u32,
             stride: u32,
-            indexed_by_vertex: bool,
+            step_mode: back::msl::VertexBufferStepMode,
             ty_name: String,
             param_name: String,
             elem_name: String,
@@ -6395,10 +6395,14 @@
                     "Vertex pulling requires a non-zero buffer stride."
                 );
 
-                if vbm.indexed_by_vertex {
-                    needs_vertex_id = true;
-                } else {
-                    needs_instance_id = true;
+                match vbm.step_mode {
+                    back::msl::VertexBufferStepMode::Constant => {}
+                    back::msl::VertexBufferStepMode::ByVertex => {
+                        needs_vertex_id = true;
+                    }
+                    back::msl::VertexBufferStepMode::ByInstance => {
+                        needs_instance_id = true;
+                    }
                 }
 
                 let buffer_ty = self.namer.call(format!("vb_{buffer_id}_type").as_str());
@@ -6408,7 +6412,7 @@
                 vbm_resolved.push(VertexBufferMappingResolved {
                     id: buffer_id,
                     stride: buffer_stride,
-                    indexed_by_vertex: vbm.indexed_by_vertex,
+                    step_mode: vbm.step_mode,
                     ty_name: buffer_ty,
                     param_name: buffer_param,
                     elem_name: buffer_elem,
@@ -7199,8 +7203,6 @@
             }
 
             if do_vertex_pulling {
-                assert!(needs_vertex_id || needs_instance_id);
-
                 let mut separator = if is_first_argument {
                     is_first_argument = false;
                     ' '
@@ -7278,16 +7280,22 @@
 
                     let idx = &vbm.id;
                     let stride = &vbm.stride;
-                    let index_name = if vbm.indexed_by_vertex {
-                        if let Some(ref name) = v_existing_id {
-                            name
-                        } else {
-                            &v_id
+                    let index_name = match vbm.step_mode {
+                        back::msl::VertexBufferStepMode::Constant => "0",
+                        back::msl::VertexBufferStepMode::ByVertex => {
+                            if let Some(ref name) = v_existing_id {
+                                name
+                            } else {
+                                &v_id
+                            }
                         }
-                    } else if let Some(ref name) = i_existing_id {
-                        name
-                    } else {
-                        &i_id
+                        back::msl::VertexBufferStepMode::ByInstance => {
+                            if let Some(ref name) = i_existing_id {
+                                name
+                            } else {
+                                &i_id
+                            }
+                        }
                     };
                     write!(
                         self.out,